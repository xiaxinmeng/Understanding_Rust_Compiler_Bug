{"sha": "cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiNjQ5MWQ3NmM3YWE4MWNkZjVkM2IzYTgxMzg2MTI5YzVlMmZjZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-02T16:38:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-02T16:38:43Z"}, "message": "libgo: Update to weekly.2012-02-14 release.\n\nFrom-SVN: r184798", "tree": {"sha": "efa0c55763b34cbc633bc494c2743d1b5d9aaff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efa0c55763b34cbc633bc494c2743d1b5d9aaff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/comments", "author": null, "committer": null, "parents": [{"sha": "ff2f581b00ac6759f6366c16ef902c935163aa13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2f581b00ac6759f6366c16ef902c935163aa13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2f581b00ac6759f6366c16ef902c935163aa13"}], "stats": {"total": 21572, "additions": 11968, "deletions": 9604}, "files": [{"sha": "bc949c6b56e7d5ddddbf5f12042a7c955bb7bfbb", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -88,60 +88,6 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n   if (add_to_globals)\n     this->add_named_object(no);\n \n-  // Typeof.\n-  Type* empty_interface = Type::make_empty_interface_type(bloc);\n-  Typed_identifier_list* parameters = new Typed_identifier_list;\n-  parameters->push_back(Typed_identifier(\"i\", empty_interface, bloc));\n-  results = new Typed_identifier_list;\n-  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n-  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n-  no = bindings->add_function_declaration(\"Typeof\", package, fntype, bloc);\n-  if (add_to_globals)\n-    this->add_named_object(no);\n-\n-  // Reflect.\n-  parameters = new Typed_identifier_list;\n-  parameters->push_back(Typed_identifier(\"it\", empty_interface, bloc));\n-  results = new Typed_identifier_list;\n-  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n-  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n-  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n-  no = bindings->add_function_declaration(\"Reflect\", package, fntype, bloc);\n-  if (add_to_globals)\n-    this->add_named_object(no);\n-\n-  // Unreflect.\n-  parameters = new Typed_identifier_list;\n-  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n-  parameters->push_back(Typed_identifier(\"addr\", pointer_type, bloc));\n-  results = new Typed_identifier_list;\n-  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n-  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n-  no = bindings->add_function_declaration(\"Unreflect\", package, fntype, bloc);\n-  if (add_to_globals)\n-    this->add_named_object(no);\n-\n-  // New.\n-  parameters = new Typed_identifier_list;\n-  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n-  results = new Typed_identifier_list;\n-  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n-  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n-  no = bindings->add_function_declaration(\"New\", package, fntype, bloc);\n-  if (add_to_globals)\n-    this->add_named_object(no);\n-\n-  // NewArray.\n-  parameters = new Typed_identifier_list;\n-  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n-  parameters->push_back(Typed_identifier(\"n\", int_type, bloc));\n-  results = new Typed_identifier_list;\n-  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n-  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n-  no = bindings->add_function_declaration(\"NewArray\", package, fntype, bloc);\n-  if (add_to_globals)\n-    this->add_named_object(no);\n-\n   if (!this->imported_unsafe_)\n     {\n       go_imported_unsafe();"}, {"sha": "c17fd7ca23a1dbcb5fb4eccbe0118f70b9fc1048", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug388.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug388.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug388.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug388.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,13 +9,13 @@\n package main\n import \"runtime\"\n \n-func foo(runtime.UintType, i int) {  // ERROR \"cannot declare name runtime.UintType|named/anonymous mix\"\n-\tprintln(i, runtime.UintType) \n+func foo(runtime.UintType, i int) {  // ERROR \"cannot declare name runtime.UintType|named/anonymous mix|undefined identifier\"\n+\tprintln(i, runtime.UintType) // GCCGO_ERROR \"undefined identifier\"\n }\n \n func bar(i int) {\n-\truntime.UintType := i       // ERROR \"cannot declare name runtime.UintType|non-name on left side\"\n-\tprintln(runtime.UintType)\t// GCCGO_ERROR \"invalid use of type\"\n+\truntime.UintType := i       // ERROR \"cannot declare name runtime.UintType|non-name on left side|undefined identifier\"\n+\tprintln(runtime.UintType)\t// GCCGO_ERROR \"invalid use of type|undefined identifier\"\n }\n \n func baz() {"}, {"sha": "a760ae9c8de8289262e86aa074fa837a65c896fb", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -1,4 +1,4 @@\n-52ba9506bd99\n+43cf9b39b647\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "1167a3f7ed0414366c61b93f8e257454a3090bef", "filename": "libgo/Makefile.am", "status": "modified", "additions": 31, "deletions": 47, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -225,7 +225,6 @@ toolexeclibgoexp_DATA = \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n-\texp/signal.gox \\\n \texp/terminal.gox \\\n \texp/types.gox \\\n \texp/utf8string.gox\n@@ -325,6 +324,7 @@ toolexeclibgoosdir = $(toolexeclibgodir)/os\n \n toolexeclibgoos_DATA = \\\n \tos/exec.gox \\\n+\tos/signal.gox \\\n \tos/user.gox\n \n toolexeclibgopathdir = $(toolexeclibgodir)/path\n@@ -352,8 +352,7 @@ toolexeclibgotestingdir = $(toolexeclibgodir)/testing\n \n toolexeclibgotesting_DATA = \\\n \ttesting/iotest.gox \\\n-\ttesting/quick.gox \\\n-\ttesting/script.gox\n+\ttesting/quick.gox\n \n toolexeclibgotextdir = $(toolexeclibgodir)/text\n \n@@ -398,6 +397,7 @@ runtime_files = \\\n \truntime/go-byte-array-to-string.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n+\truntime/go-callers.c \\\n \truntime/go-can-convert-interface.c \\\n \truntime/go-cgo.c \\\n \truntime/go-check-interface.c \\\n@@ -428,7 +428,6 @@ runtime_files = \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n \truntime/go-recover.c \\\n-\truntime/go-reflect.c \\\n \truntime/go-reflect-call.c \\\n \truntime/go-reflect-map.c \\\n \truntime/go-rune.c \\\n@@ -450,7 +449,6 @@ runtime_files = \\\n \truntime/go-type-string.c \\\n \truntime/go-typedesc-equal.c \\\n \truntime/go-typestring.c \\\n-\truntime/go-unreflect.c \\\n \truntime/go-unsafe-new.c \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n@@ -468,6 +466,7 @@ runtime_files = \\\n \truntime/msize.c \\\n \truntime/proc.c \\\n \truntime/runtime.c \\\n+\truntime/signal_unix.c \\\n \truntime/thread.c \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n@@ -509,7 +508,7 @@ sema.c: $(srcdir)/runtime/sema.goc goc2c\n \tmv -f $@.tmp $@\n \n sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n-\t./goc2c --gcc --go-prefix libgo_runtime $< > $@.tmp\n+\t./goc2c --gcc --go-prefix libgo_os $< > $@.tmp\n \tmv -f $@.tmp $@\n \n time.c: $(srcdir)/runtime/time.goc goc2c\n@@ -526,7 +525,8 @@ go_bufio_files = \\\n go_bytes_files = \\\n \tgo/bytes/buffer.go \\\n \tgo/bytes/bytes.go \\\n-\tgo/bytes/bytes_decl.go\n+\tgo/bytes/bytes_decl.go \\\n+\tgo/bytes/reader.go\n go_bytes_c_files = \\\n \tgo/bytes/indexbyte.c\n \n@@ -784,9 +784,7 @@ go_os_files = \\\n \t$(go_os_stat_file) \\\n \tgo/os/str.go \\\n \t$(go_os_sys_file) \\\n-\tgo/os/time.go \\\n-\tgo/os/types.go \\\n-\tsignal_unix.go\n+\tgo/os/types.go\n \n go_path_files = \\\n \tgo/path/match.go \\\n@@ -811,7 +809,6 @@ go_runtime_files = \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n-\tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n \tversion.go\n@@ -1103,8 +1100,6 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/per_host.go \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n-go_exp_signal_files = \\\n-\tgo/exp/signal/signal.go\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n@@ -1302,6 +1297,10 @@ go_os_exec_files = \\\n \tgo/os/exec/exec.go \\\n \tgo/os/exec/lp_unix.go\n \n+go_os_signal_files = \\\n+\tgo/os/signal/signal.go \\\n+\tgo/os/signal/signal_unix.go\n+\n go_os_user_files = \\\n \tgo/os/user/user.go \\\n \tgo/os/user/lookup_unix.go\n@@ -1352,8 +1351,6 @@ go_testing_iotest_files = \\\n \tgo/testing/iotest/writer.go\n go_testing_quick_files = \\\n \tgo/testing/quick/quick.go\n-go_testing_script_files = \\\n-\tgo/testing/script/script.go\n \n go_text_scanner_files = \\\n \tgo/text/scanner/scanner.go\n@@ -1529,6 +1526,7 @@ go_syscall_files = \\\n \tsyscall_arch.go\n go_syscall_c_files = \\\n \tgo/syscall/errno.c \\\n+\tgo/syscall/signame.c \\\n \t$(syscall_wait_c_file)\n \n libcalls.go: s-libcalls; @true\n@@ -1667,7 +1665,6 @@ libgo_go_objs = \\\n \texp/html.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n-\texp/signal.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n \texp/utf8string.lo \\\n@@ -1712,6 +1709,7 @@ libgo_go_objs = \\\n \told/regexp.lo \\\n \told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n+\tos/signal.lo \\\n \tos/user.lo \\\n \tpath/filepath.lo \\\n \tregexp/syntax.lo \\\n@@ -1722,6 +1720,7 @@ libgo_go_objs = \\\n \tsync/atomic_c.lo \\\n \tsyscall/syscall.lo \\\n \tsyscall/errno.lo \\\n+\tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n \ttext/scanner.lo \\\n \ttext/tabwriter.lo \\\n@@ -1730,7 +1729,6 @@ libgo_go_objs = \\\n \ttesting/testing.lo \\\n \ttesting/iotest.lo \\\n \ttesting/quick.lo \\\n-\ttesting/script.lo \\\n \tunicode/utf16.lo \\\n \tunicode/utf8.lo\n \n@@ -1986,10 +1984,6 @@ os/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/check\n \n-signal_unix.go: $(srcdir)/go/os/mkunixsignals.sh sysinfo.go\n-\t$(SHELL) $(srcdir)/go/os/mkunixsignals.sh sysinfo.go > $@.tmp\n-\tmv -f $@.tmp $@\n-\n @go_include@ path/path.lo.dep\n path/path.lo.dep: $(go_path_files)\n \t$(BUILDDEPS)\n@@ -2599,16 +2593,6 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n-@go_include@ exp/signal.lo.dep\n-exp/signal.lo.dep: $(go_exp_signal_files)\n-\t$(BUILDDEPS)\n-exp/signal.lo: $(go_exp_signal_files)\n-\t$(BUILDPACKAGE)\n-exp/signal/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/signal\n-\t@$(CHECK)\n-.PHONY: exp/signal/check\n-\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -3060,6 +3044,16 @@ os/exec/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/exec/check\n \n+@go_include@ os/signal.lo.dep\n+os/signal.lo.dep: $(go_os_signal_files)\n+\t$(BUILDDEPS)\n+os/signal.lo: $(go_os_signal_files)\n+\t$(BUILDPACKAGE)\n+os/signal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) os/signal\n+\t@$(CHECK)\n+.PHONY: os/signal/check\n+\n @go_include@ os/user.lo.dep\n os/user.lo.dep: $(go_os_user_files)\n \t$(BUILDDEPS)\n@@ -3171,16 +3165,6 @@ testing/quick/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: testing/quick/check\n \n-@go_include@ testing/script.lo.dep\n-testing/script.lo.dep: $(go_testing_script_files)\n-\t$(BUILDDEPS)\n-testing/script.lo: $(go_testing_script_files)\n-\t$(BUILDPACKAGE)\n-testing/script/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) testing/script\n-\t@$(CHECK)\n-.PHONY: testing/script/check\n-\n @go_include@ unicode/utf16.lo.dep\n unicode/utf16.lo.dep: $(go_unicode_utf16_files)\n \t$(BUILDDEPS)\n@@ -3208,6 +3192,8 @@ syscall/syscall.lo: $(go_syscall_files)\n \t$(BUILDPACKAGE)\n syscall/errno.lo: go/syscall/errno.c\n \t$(LTCOMPILE) -c -o $@ $<\n+syscall/signame.lo: go/syscall/signame.c\n+\t$(LTCOMPILE) -c -o $@ $<\n syscall/wait.lo: go/syscall/wait.c\n \t$(LTCOMPILE) -c -o $@ $<\n \n@@ -3384,8 +3370,6 @@ exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n-exp/signal.gox: exp/signal.lo\n-\t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n@@ -3486,6 +3470,8 @@ old/template.gox: old/template.lo\n \n os/exec.gox: os/exec.lo\n \t$(BUILDGOX)\n+os/signal.gox: os/signal.lo\n+\t$(BUILDGOX)\n os/user.gox: os/user.lo\n \t$(BUILDGOX)\n \n@@ -3516,8 +3502,6 @@ testing/iotest.gox: testing/iotest.lo\n \t$(BUILDGOX)\n testing/quick.gox: testing/quick.lo\n \t$(BUILDGOX)\n-testing/script.gox: testing/script.lo\n-\t$(BUILDGOX)\n \n unicode/utf16.gox: unicode/utf16.lo\n \t$(BUILDGOX)\n@@ -3605,7 +3589,6 @@ TEST_PACKAGES = \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/proxy/check \\\n-\texp/signal/check \\\n \texp/terminal/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n@@ -3635,6 +3618,7 @@ TEST_PACKAGES = \\\n \tnet/http/check \\\n \tnet/http/cgi/check \\\n \tnet/http/fcgi/check \\\n+\tnet/http/httptest/check \\\n \tnet/http/httputil/check \\\n \tnet/mail/check \\\n \tnet/rpc/check \\\n@@ -3646,6 +3630,7 @@ TEST_PACKAGES = \\\n \told/regexp/check \\\n \told/template/check \\\n \tos/exec/check \\\n+\tos/signal/check \\\n \tos/user/check \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n@@ -3655,7 +3640,6 @@ TEST_PACKAGES = \\\n \ttext/template/check \\\n \ttext/template/parse/check \\\n \ttesting/quick/check \\\n-\ttesting/script/check \\\n \tunicode/utf16/check \\\n \tunicode/utf8/check\n "}, {"sha": "b1d1d4c561ee74c6bb598a9d2fa3fa8bd3e5cfff", "filename": "libgo/Makefile.in", "status": "modified", "additions": 98, "deletions": 117, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -154,67 +154,66 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n \tencoding/csv.lo encoding/gob.lo encoding/hex.lo \\\n \tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/html.lo exp/norm.lo exp/proxy.lo exp/signal.lo \\\n-\texp/terminal.lo exp/types.lo exp/utf8string.lo \\\n-\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n-\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n-\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n-\tnet/http/pprof.lo image/color.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n-\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n-\tmath/rand.lo mime/mime.lo mime/multipart.lo net/http.lo \\\n-\tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n+\texp/html.lo exp/norm.lo exp/proxy.lo exp/terminal.lo \\\n+\texp/types.lo exp/utf8string.lo html/template.lo go/ast.lo \\\n+\tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n+\tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n+\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n+\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n+\timage/color.lo image/draw.lo image/gif.lo image/jpeg.lo \\\n+\timage/png.lo index/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n+\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n+\tmime/mime.lo mime/multipart.lo net/http.lo net/mail.lo \\\n+\tnet/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n \told/netchan.lo old/regexp.lo old/template.lo \\\n-\t$(am__DEPENDENCIES_1) os/user.lo path/filepath.lo \\\n+\t$(am__DEPENDENCIES_1) os/signal.lo os/user.lo path/filepath.lo \\\n \tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n \truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n-\tsyscall/syscall.lo syscall/errno.lo syscall/wait.lo \\\n-\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n-\ttext/template/parse.lo testing/testing.lo testing/iotest.lo \\\n-\ttesting/quick.lo testing/script.lo unicode/utf16.lo \\\n+\tsyscall/syscall.lo syscall/errno.lo syscall/signame.lo \\\n+\tsyscall/wait.lo text/scanner.lo text/tabwriter.lo \\\n+\ttext/template.lo text/template/parse.lo testing/testing.lo \\\n+\ttesting/iotest.lo testing/quick.lo unicode/utf16.lo \\\n \tunicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-assert-interface.c \\\n \truntime/go-byte-array-to-string.c runtime/go-breakpoint.c \\\n-\truntime/go-caller.c runtime/go-can-convert-interface.c \\\n-\truntime/go-cgo.c runtime/go-check-interface.c \\\n-\truntime/go-construct-map.c runtime/go-convert-interface.c \\\n-\truntime/go-copy.c runtime/go-defer.c \\\n-\truntime/go-deferred-recover.c runtime/go-eface-compare.c \\\n-\truntime/go-eface-val-compare.c runtime/go-getgoroot.c \\\n-\truntime/go-int-array-to-string.c runtime/go-int-to-string.c \\\n-\truntime/go-interface-compare.c \\\n+\truntime/go-caller.c runtime/go-callers.c \\\n+\truntime/go-can-convert-interface.c runtime/go-cgo.c \\\n+\truntime/go-check-interface.c runtime/go-construct-map.c \\\n+\truntime/go-convert-interface.c runtime/go-copy.c \\\n+\truntime/go-defer.c runtime/go-deferred-recover.c \\\n+\truntime/go-eface-compare.c runtime/go-eface-val-compare.c \\\n+\truntime/go-getgoroot.c runtime/go-int-array-to-string.c \\\n+\truntime/go-int-to-string.c runtime/go-interface-compare.c \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c runtime/go-make-slice.c \\\n \truntime/go-map-delete.c runtime/go-map-index.c \\\n \truntime/go-map-len.c runtime/go-map-range.c \\\n \truntime/go-matherr.c runtime/go-nanotime.c runtime/go-now.c \\\n \truntime/go-new-map.c runtime/go-new.c runtime/go-nosys.c \\\n \truntime/go-panic.c runtime/go-print.c runtime/go-recover.c \\\n-\truntime/go-reflect.c runtime/go-reflect-call.c \\\n-\truntime/go-reflect-map.c runtime/go-rune.c \\\n-\truntime/go-runtime-error.c runtime/go-setenv.c \\\n-\truntime/go-signal.c runtime/go-strcmp.c \\\n+\truntime/go-reflect-call.c runtime/go-reflect-map.c \\\n+\truntime/go-rune.c runtime/go-runtime-error.c \\\n+\truntime/go-setenv.c runtime/go-signal.c runtime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n \truntime/go-string-to-int-array.c runtime/go-strplus.c \\\n \truntime/go-strslice.c runtime/go-trampoline.c \\\n \truntime/go-type-complex.c runtime/go-type-eface.c \\\n \truntime/go-type-error.c runtime/go-type-float.c \\\n \truntime/go-type-identity.c runtime/go-type-interface.c \\\n \truntime/go-type-string.c runtime/go-typedesc-equal.c \\\n-\truntime/go-typestring.c runtime/go-unreflect.c \\\n-\truntime/go-unsafe-new.c runtime/go-unsafe-newarray.c \\\n-\truntime/go-unsafe-pointer.c runtime/go-unwind.c runtime/chan.c \\\n-\truntime/cpuprof.c runtime/lock_sema.c runtime/thread-sema.c \\\n-\truntime/lock_futex.c runtime/thread-linux.c runtime/mcache.c \\\n-\truntime/mcentral.c runtime/mem_posix_memalign.c runtime/mem.c \\\n-\truntime/mfinal.c runtime/mfixalloc.c runtime/mgc0.c \\\n-\truntime/mheap.c runtime/msize.c runtime/proc.c \\\n-\truntime/runtime.c runtime/thread.c runtime/yield.c \\\n+\truntime/go-typestring.c runtime/go-unsafe-new.c \\\n+\truntime/go-unsafe-newarray.c runtime/go-unsafe-pointer.c \\\n+\truntime/go-unwind.c runtime/chan.c runtime/cpuprof.c \\\n+\truntime/lock_sema.c runtime/thread-sema.c runtime/lock_futex.c \\\n+\truntime/thread-linux.c runtime/mcache.c runtime/mcentral.c \\\n+\truntime/mem_posix_memalign.c runtime/mem.c runtime/mfinal.c \\\n+\truntime/mfixalloc.c runtime/mgc0.c runtime/mheap.c \\\n+\truntime/msize.c runtime/proc.c runtime/runtime.c \\\n+\truntime/signal_unix.c runtime/thread.c runtime/yield.c \\\n \truntime/rtems-task-variable-add.c iface.c malloc.c map.c \\\n \tmprof.c reflect.c runtime1.c sema.c sigqueue.c string.c time.c\n @LIBGO_IS_LINUX_FALSE@am__objects_1 = lock_sema.lo thread-sema.lo\n@@ -224,30 +223,30 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n @LIBGO_IS_RTEMS_TRUE@am__objects_3 = rtems-task-variable-add.lo\n am__objects_4 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-byte-array-to-string.lo go-breakpoint.lo go-caller.lo \\\n-\tgo-can-convert-interface.lo go-cgo.lo go-check-interface.lo \\\n-\tgo-construct-map.lo go-convert-interface.lo go-copy.lo \\\n-\tgo-defer.lo go-deferred-recover.lo go-eface-compare.lo \\\n+\tgo-callers.lo go-can-convert-interface.lo go-cgo.lo \\\n+\tgo-check-interface.lo go-construct-map.lo \\\n+\tgo-convert-interface.lo go-copy.lo go-defer.lo \\\n+\tgo-deferred-recover.lo go-eface-compare.lo \\\n \tgo-eface-val-compare.lo go-getgoroot.lo \\\n \tgo-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n \tgo-interface-val-compare.lo go-make-slice.lo go-map-delete.lo \\\n \tgo-map-index.lo go-map-len.lo go-map-range.lo go-matherr.lo \\\n \tgo-nanotime.lo go-now.lo go-new-map.lo go-new.lo go-nosys.lo \\\n-\tgo-panic.lo go-print.lo go-recover.lo go-reflect.lo \\\n-\tgo-reflect-call.lo go-reflect-map.lo go-rune.lo \\\n-\tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n-\tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n-\tgo-strplus.lo go-strslice.lo go-trampoline.lo \\\n-\tgo-type-complex.lo go-type-eface.lo go-type-error.lo \\\n-\tgo-type-float.lo go-type-identity.lo go-type-interface.lo \\\n-\tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n-\tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n+\tgo-panic.lo go-print.lo go-recover.lo go-reflect-call.lo \\\n+\tgo-reflect-map.lo go-rune.lo go-runtime-error.lo go-setenv.lo \\\n+\tgo-signal.lo go-strcmp.lo go-string-to-byte-array.lo \\\n+\tgo-string-to-int-array.lo go-strplus.lo go-strslice.lo \\\n+\tgo-trampoline.lo go-type-complex.lo go-type-eface.lo \\\n+\tgo-type-error.lo go-type-float.lo go-type-identity.lo \\\n+\tgo-type-interface.lo go-type-string.lo go-typedesc-equal.lo \\\n+\tgo-typestring.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n \tgo-unsafe-pointer.lo go-unwind.lo chan.lo cpuprof.lo \\\n \t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n \tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo proc.lo \\\n-\truntime.lo thread.lo yield.lo $(am__objects_3) iface.lo \\\n-\tmalloc.lo map.lo mprof.lo reflect.lo runtime1.lo sema.lo \\\n-\tsigqueue.lo string.lo time.lo\n+\truntime.lo signal_unix.lo thread.lo yield.lo $(am__objects_3) \\\n+\tiface.lo malloc.lo map.lo mprof.lo reflect.lo runtime1.lo \\\n+\tsema.lo sigqueue.lo string.lo time.lo\n am_libgo_la_OBJECTS = $(am__objects_4)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -679,7 +678,6 @@ toolexeclibgoexp_DATA = \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n-\texp/signal.gox \\\n \texp/terminal.gox \\\n \texp/types.gox \\\n \texp/utf8string.gox\n@@ -765,6 +763,7 @@ toolexeclibgoold_DATA = \\\n toolexeclibgoosdir = $(toolexeclibgodir)/os\n toolexeclibgoos_DATA = \\\n \tos/exec.gox \\\n+\tos/signal.gox \\\n \tos/user.gox\n \n toolexeclibgopathdir = $(toolexeclibgodir)/path\n@@ -787,8 +786,7 @@ toolexeclibgosync_DATA = \\\n toolexeclibgotestingdir = $(toolexeclibgodir)/testing\n toolexeclibgotesting_DATA = \\\n \ttesting/iotest.gox \\\n-\ttesting/quick.gox \\\n-\ttesting/script.gox\n+\ttesting/quick.gox\n \n toolexeclibgotextdir = $(toolexeclibgodir)/text\n toolexeclibgotext_DATA = \\\n@@ -818,6 +816,7 @@ runtime_files = \\\n \truntime/go-byte-array-to-string.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n+\truntime/go-callers.c \\\n \truntime/go-can-convert-interface.c \\\n \truntime/go-cgo.c \\\n \truntime/go-check-interface.c \\\n@@ -848,7 +847,6 @@ runtime_files = \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n \truntime/go-recover.c \\\n-\truntime/go-reflect.c \\\n \truntime/go-reflect-call.c \\\n \truntime/go-reflect-map.c \\\n \truntime/go-rune.c \\\n@@ -870,7 +868,6 @@ runtime_files = \\\n \truntime/go-type-string.c \\\n \truntime/go-typedesc-equal.c \\\n \truntime/go-typestring.c \\\n-\truntime/go-unreflect.c \\\n \truntime/go-unsafe-new.c \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n@@ -888,6 +885,7 @@ runtime_files = \\\n \truntime/msize.c \\\n \truntime/proc.c \\\n \truntime/runtime.c \\\n+\truntime/signal_unix.c \\\n \truntime/thread.c \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n@@ -908,7 +906,8 @@ go_bufio_files = \\\n go_bytes_files = \\\n \tgo/bytes/buffer.go \\\n \tgo/bytes/bytes.go \\\n-\tgo/bytes/bytes_decl.go\n+\tgo/bytes/bytes_decl.go \\\n+\tgo/bytes/reader.go\n \n go_bytes_c_files = \\\n \tgo/bytes/indexbyte.c\n@@ -1106,9 +1105,7 @@ go_os_files = \\\n \t$(go_os_stat_file) \\\n \tgo/os/str.go \\\n \t$(go_os_sys_file) \\\n-\tgo/os/time.go \\\n-\tgo/os/types.go \\\n-\tsignal_unix.go\n+\tgo/os/types.go\n \n go_path_files = \\\n \tgo/path/match.go \\\n@@ -1133,7 +1130,6 @@ go_runtime_files = \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n-\tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n \tversion.go\n@@ -1442,9 +1438,6 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n \n-go_exp_signal_files = \\\n-\tgo/exp/signal/signal.go\n-\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n@@ -1664,6 +1657,10 @@ go_os_exec_files = \\\n \tgo/os/exec/exec.go \\\n \tgo/os/exec/lp_unix.go\n \n+go_os_signal_files = \\\n+\tgo/os/signal/signal.go \\\n+\tgo/os/signal/signal_unix.go\n+\n go_os_user_files = \\\n \tgo/os/user/user.go \\\n \tgo/os/user/lookup_unix.go\n@@ -1720,9 +1717,6 @@ go_testing_iotest_files = \\\n go_testing_quick_files = \\\n \tgo/testing/quick/quick.go\n \n-go_testing_script_files = \\\n-\tgo/testing/script/script.go\n-\n go_text_scanner_files = \\\n \tgo/text/scanner/scanner.go\n \n@@ -1833,6 +1827,7 @@ go_syscall_files = \\\n \n go_syscall_c_files = \\\n \tgo/syscall/errno.c \\\n+\tgo/syscall/signame.c \\\n \t$(syscall_wait_c_file)\n \n @LIBGO_IS_LINUX_FALSE@os_lib_inotify_lo = \n@@ -1917,7 +1912,6 @@ libgo_go_objs = \\\n \texp/html.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n-\texp/signal.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n \texp/utf8string.lo \\\n@@ -1962,6 +1956,7 @@ libgo_go_objs = \\\n \told/regexp.lo \\\n \told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n+\tos/signal.lo \\\n \tos/user.lo \\\n \tpath/filepath.lo \\\n \tregexp/syntax.lo \\\n@@ -1972,6 +1967,7 @@ libgo_go_objs = \\\n \tsync/atomic_c.lo \\\n \tsyscall/syscall.lo \\\n \tsyscall/errno.lo \\\n+\tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n \ttext/scanner.lo \\\n \ttext/tabwriter.lo \\\n@@ -1980,7 +1976,6 @@ libgo_go_objs = \\\n \ttesting/testing.lo \\\n \ttesting/iotest.lo \\\n \ttesting/quick.lo \\\n-\ttesting/script.lo \\\n \tunicode/utf16.lo \\\n \tunicode/utf8.lo\n \n@@ -2166,7 +2161,6 @@ TEST_PACKAGES = \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/proxy/check \\\n-\texp/signal/check \\\n \texp/terminal/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n@@ -2196,6 +2190,7 @@ TEST_PACKAGES = \\\n \tnet/http/check \\\n \tnet/http/cgi/check \\\n \tnet/http/fcgi/check \\\n+\tnet/http/httptest/check \\\n \tnet/http/httputil/check \\\n \tnet/mail/check \\\n \tnet/rpc/check \\\n@@ -2207,6 +2202,7 @@ TEST_PACKAGES = \\\n \told/regexp/check \\\n \told/template/check \\\n \tos/exec/check \\\n+\tos/signal/check \\\n \tos/user/check \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n@@ -2216,7 +2212,6 @@ TEST_PACKAGES = \\\n \ttext/template/check \\\n \ttext/template/parse/check \\\n \ttesting/quick/check \\\n-\ttesting/script/check \\\n \tunicode/utf16/check \\\n \tunicode/utf8/check\n \n@@ -2362,6 +2357,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-breakpoint.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-byte-array-to-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-caller.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-callers.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-can-convert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cgo.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-check-interface.Plo@am__quote@\n@@ -2395,7 +2391,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-call.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-map.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rune.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-runtime-error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n@@ -2415,7 +2410,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-typedesc-equal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-typestring.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unreflect.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-newarray.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-pointer.Plo@am__quote@\n@@ -2441,6 +2435,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sema.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/signal_unix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sigqueue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-linux.Plo@am__quote@\n@@ -2526,6 +2521,13 @@ go-caller.lo: runtime/go-caller.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-caller.lo `test -f 'runtime/go-caller.c' || echo '$(srcdir)/'`runtime/go-caller.c\n \n+go-callers.lo: runtime/go-callers.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-callers.lo -MD -MP -MF $(DEPDIR)/go-callers.Tpo -c -o go-callers.lo `test -f 'runtime/go-callers.c' || echo '$(srcdir)/'`runtime/go-callers.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-callers.Tpo $(DEPDIR)/go-callers.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-callers.c' object='go-callers.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-callers.lo `test -f 'runtime/go-callers.c' || echo '$(srcdir)/'`runtime/go-callers.c\n+\n go-can-convert-interface.lo: runtime/go-can-convert-interface.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-can-convert-interface.lo -MD -MP -MF $(DEPDIR)/go-can-convert-interface.Tpo -c -o go-can-convert-interface.lo `test -f 'runtime/go-can-convert-interface.c' || echo '$(srcdir)/'`runtime/go-can-convert-interface.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-can-convert-interface.Tpo $(DEPDIR)/go-can-convert-interface.Plo\n@@ -2736,13 +2738,6 @@ go-recover.lo: runtime/go-recover.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-recover.lo `test -f 'runtime/go-recover.c' || echo '$(srcdir)/'`runtime/go-recover.c\n \n-go-reflect.lo: runtime/go-reflect.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-reflect.lo -MD -MP -MF $(DEPDIR)/go-reflect.Tpo -c -o go-reflect.lo `test -f 'runtime/go-reflect.c' || echo '$(srcdir)/'`runtime/go-reflect.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-reflect.Tpo $(DEPDIR)/go-reflect.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-reflect.c' object='go-reflect.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-reflect.lo `test -f 'runtime/go-reflect.c' || echo '$(srcdir)/'`runtime/go-reflect.c\n-\n go-reflect-call.lo: runtime/go-reflect-call.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-reflect-call.lo -MD -MP -MF $(DEPDIR)/go-reflect-call.Tpo -c -o go-reflect-call.lo `test -f 'runtime/go-reflect-call.c' || echo '$(srcdir)/'`runtime/go-reflect-call.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-reflect-call.Tpo $(DEPDIR)/go-reflect-call.Plo\n@@ -2890,13 +2885,6 @@ go-typestring.lo: runtime/go-typestring.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-typestring.lo `test -f 'runtime/go-typestring.c' || echo '$(srcdir)/'`runtime/go-typestring.c\n \n-go-unreflect.lo: runtime/go-unreflect.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-unreflect.lo -MD -MP -MF $(DEPDIR)/go-unreflect.Tpo -c -o go-unreflect.lo `test -f 'runtime/go-unreflect.c' || echo '$(srcdir)/'`runtime/go-unreflect.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-unreflect.Tpo $(DEPDIR)/go-unreflect.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-unreflect.c' object='go-unreflect.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-unreflect.lo `test -f 'runtime/go-unreflect.c' || echo '$(srcdir)/'`runtime/go-unreflect.c\n-\n go-unsafe-new.lo: runtime/go-unsafe-new.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-unsafe-new.lo -MD -MP -MF $(DEPDIR)/go-unsafe-new.Tpo -c -o go-unsafe-new.lo `test -f 'runtime/go-unsafe-new.c' || echo '$(srcdir)/'`runtime/go-unsafe-new.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-unsafe-new.Tpo $(DEPDIR)/go-unsafe-new.Plo\n@@ -3044,6 +3032,13 @@ runtime.lo: runtime/runtime.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o runtime.lo `test -f 'runtime/runtime.c' || echo '$(srcdir)/'`runtime/runtime.c\n \n+signal_unix.lo: runtime/signal_unix.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT signal_unix.lo -MD -MP -MF $(DEPDIR)/signal_unix.Tpo -c -o signal_unix.lo `test -f 'runtime/signal_unix.c' || echo '$(srcdir)/'`runtime/signal_unix.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/signal_unix.Tpo $(DEPDIR)/signal_unix.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/signal_unix.c' object='signal_unix.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o signal_unix.lo `test -f 'runtime/signal_unix.c' || echo '$(srcdir)/'`runtime/signal_unix.c\n+\n thread.lo: runtime/thread.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT thread.lo -MD -MP -MF $(DEPDIR)/thread.Tpo -c -o thread.lo `test -f 'runtime/thread.c' || echo '$(srcdir)/'`runtime/thread.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/thread.Tpo $(DEPDIR)/thread.Plo\n@@ -4327,7 +4322,7 @@ sema.c: $(srcdir)/runtime/sema.goc goc2c\n \tmv -f $@.tmp $@\n \n sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n-\t./goc2c --gcc --go-prefix libgo_runtime $< > $@.tmp\n+\t./goc2c --gcc --go-prefix libgo_os $< > $@.tmp\n \tmv -f $@.tmp $@\n \n time.c: $(srcdir)/runtime/time.goc goc2c\n@@ -4548,10 +4543,6 @@ os/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/check\n \n-signal_unix.go: $(srcdir)/go/os/mkunixsignals.sh sysinfo.go\n-\t$(SHELL) $(srcdir)/go/os/mkunixsignals.sh sysinfo.go > $@.tmp\n-\tmv -f $@.tmp $@\n-\n @go_include@ path/path.lo.dep\n path/path.lo.dep: $(go_path_files)\n \t$(BUILDDEPS)\n@@ -5161,16 +5152,6 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n-@go_include@ exp/signal.lo.dep\n-exp/signal.lo.dep: $(go_exp_signal_files)\n-\t$(BUILDDEPS)\n-exp/signal.lo: $(go_exp_signal_files)\n-\t$(BUILDPACKAGE)\n-exp/signal/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/signal\n-\t@$(CHECK)\n-.PHONY: exp/signal/check\n-\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -5622,6 +5603,16 @@ os/exec/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/exec/check\n \n+@go_include@ os/signal.lo.dep\n+os/signal.lo.dep: $(go_os_signal_files)\n+\t$(BUILDDEPS)\n+os/signal.lo: $(go_os_signal_files)\n+\t$(BUILDPACKAGE)\n+os/signal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) os/signal\n+\t@$(CHECK)\n+.PHONY: os/signal/check\n+\n @go_include@ os/user.lo.dep\n os/user.lo.dep: $(go_os_user_files)\n \t$(BUILDDEPS)\n@@ -5733,16 +5724,6 @@ testing/quick/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: testing/quick/check\n \n-@go_include@ testing/script.lo.dep\n-testing/script.lo.dep: $(go_testing_script_files)\n-\t$(BUILDDEPS)\n-testing/script.lo: $(go_testing_script_files)\n-\t$(BUILDPACKAGE)\n-testing/script/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) testing/script\n-\t@$(CHECK)\n-.PHONY: testing/script/check\n-\n @go_include@ unicode/utf16.lo.dep\n unicode/utf16.lo.dep: $(go_unicode_utf16_files)\n \t$(BUILDDEPS)\n@@ -5770,6 +5751,8 @@ syscall/syscall.lo: $(go_syscall_files)\n \t$(BUILDPACKAGE)\n syscall/errno.lo: go/syscall/errno.c\n \t$(LTCOMPILE) -c -o $@ $<\n+syscall/signame.lo: go/syscall/signame.c\n+\t$(LTCOMPILE) -c -o $@ $<\n syscall/wait.lo: go/syscall/wait.c\n \t$(LTCOMPILE) -c -o $@ $<\n \n@@ -5941,8 +5924,6 @@ exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n-exp/signal.gox: exp/signal.lo\n-\t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n@@ -6043,6 +6024,8 @@ old/template.gox: old/template.lo\n \n os/exec.gox: os/exec.lo\n \t$(BUILDGOX)\n+os/signal.gox: os/signal.lo\n+\t$(BUILDGOX)\n os/user.gox: os/user.lo\n \t$(BUILDGOX)\n \n@@ -6073,8 +6056,6 @@ testing/iotest.gox: testing/iotest.lo\n \t$(BUILDGOX)\n testing/quick.gox: testing/quick.lo\n \t$(BUILDGOX)\n-testing/script.gox: testing/script.lo\n-\t$(BUILDGOX)\n \n unicode/utf16.gox: unicode/utf16.lo\n \t$(BUILDGOX)"}, {"sha": "ea9e0020db4a6639961bc7a415dc3b2a552c1c2b", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -278,7 +278,7 @@ func TestInvalidFiles(t *testing.T) {\n \tb := make([]byte, size)\n \n \t// zeroes\n-\t_, err := NewReader(sliceReaderAt(b), size)\n+\t_, err := NewReader(bytes.NewReader(b), size)\n \tif err != ErrFormat {\n \t\tt.Errorf(\"zeroes: error=%v, want %v\", err, ErrFormat)\n \t}\n@@ -289,15 +289,8 @@ func TestInvalidFiles(t *testing.T) {\n \tfor i := 0; i < size-4; i += 4 {\n \t\tcopy(b[i:i+4], sig)\n \t}\n-\t_, err = NewReader(sliceReaderAt(b), size)\n+\t_, err = NewReader(bytes.NewReader(b), size)\n \tif err != ErrFormat {\n \t\tt.Errorf(\"sigs: error=%v, want %v\", err, ErrFormat)\n \t}\n }\n-\n-type sliceReaderAt []byte\n-\n-func (r sliceReaderAt) ReadAt(b []byte, off int64) (int, error) {\n-\tcopy(b, r[int(off):int(off)+len(b)])\n-\treturn len(b), nil\n-}"}, {"sha": "c591aed5cedcc8fcef2e4dd08420aee24fac27c2", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -19,7 +19,7 @@ import (\n \n // Writer implements a zip file writer.\n type Writer struct {\n-\tcountWriter\n+\tcw     *countWriter\n \tdir    []*header\n \tlast   *fileWriter\n \tclosed bool\n@@ -32,7 +32,7 @@ type header struct {\n \n // NewWriter returns a new Writer writing a zip file to w.\n func NewWriter(w io.Writer) *Writer {\n-\treturn &Writer{countWriter: countWriter{w: bufio.NewWriter(w)}}\n+\treturn &Writer{cw: &countWriter{w: bufio.NewWriter(w)}}\n }\n \n // Close finishes writing the zip file by writing the central directory.\n@@ -52,42 +52,42 @@ func (w *Writer) Close() (err error) {\n \tdefer recoverError(&err)\n \n \t// write central directory\n-\tstart := w.count\n+\tstart := w.cw.count\n \tfor _, h := range w.dir {\n-\t\twrite(w, uint32(directoryHeaderSignature))\n-\t\twrite(w, h.CreatorVersion)\n-\t\twrite(w, h.ReaderVersion)\n-\t\twrite(w, h.Flags)\n-\t\twrite(w, h.Method)\n-\t\twrite(w, h.ModifiedTime)\n-\t\twrite(w, h.ModifiedDate)\n-\t\twrite(w, h.CRC32)\n-\t\twrite(w, h.CompressedSize)\n-\t\twrite(w, h.UncompressedSize)\n-\t\twrite(w, uint16(len(h.Name)))\n-\t\twrite(w, uint16(len(h.Extra)))\n-\t\twrite(w, uint16(len(h.Comment)))\n-\t\twrite(w, uint16(0)) // disk number start\n-\t\twrite(w, uint16(0)) // internal file attributes\n-\t\twrite(w, h.ExternalAttrs)\n-\t\twrite(w, h.offset)\n-\t\twriteBytes(w, []byte(h.Name))\n-\t\twriteBytes(w, h.Extra)\n-\t\twriteBytes(w, []byte(h.Comment))\n+\t\twrite(w.cw, uint32(directoryHeaderSignature))\n+\t\twrite(w.cw, h.CreatorVersion)\n+\t\twrite(w.cw, h.ReaderVersion)\n+\t\twrite(w.cw, h.Flags)\n+\t\twrite(w.cw, h.Method)\n+\t\twrite(w.cw, h.ModifiedTime)\n+\t\twrite(w.cw, h.ModifiedDate)\n+\t\twrite(w.cw, h.CRC32)\n+\t\twrite(w.cw, h.CompressedSize)\n+\t\twrite(w.cw, h.UncompressedSize)\n+\t\twrite(w.cw, uint16(len(h.Name)))\n+\t\twrite(w.cw, uint16(len(h.Extra)))\n+\t\twrite(w.cw, uint16(len(h.Comment)))\n+\t\twrite(w.cw, uint16(0)) // disk number start\n+\t\twrite(w.cw, uint16(0)) // internal file attributes\n+\t\twrite(w.cw, h.ExternalAttrs)\n+\t\twrite(w.cw, h.offset)\n+\t\twriteBytes(w.cw, []byte(h.Name))\n+\t\twriteBytes(w.cw, h.Extra)\n+\t\twriteBytes(w.cw, []byte(h.Comment))\n \t}\n-\tend := w.count\n+\tend := w.cw.count\n \n \t// write end record\n-\twrite(w, uint32(directoryEndSignature))\n-\twrite(w, uint16(0))          // disk number\n-\twrite(w, uint16(0))          // disk number where directory starts\n-\twrite(w, uint16(len(w.dir))) // number of entries this disk\n-\twrite(w, uint16(len(w.dir))) // number of entries total\n-\twrite(w, uint32(end-start))  // size of directory\n-\twrite(w, uint32(start))      // start of directory\n-\twrite(w, uint16(0))          // size of comment\n+\twrite(w.cw, uint32(directoryEndSignature))\n+\twrite(w.cw, uint16(0))          // disk number\n+\twrite(w.cw, uint16(0))          // disk number where directory starts\n+\twrite(w.cw, uint16(len(w.dir))) // number of entries this disk\n+\twrite(w.cw, uint16(len(w.dir))) // number of entries total\n+\twrite(w.cw, uint32(end-start))  // size of directory\n+\twrite(w.cw, uint32(start))      // start of directory\n+\twrite(w.cw, uint16(0))          // size of comment\n \n-\treturn w.w.(*bufio.Writer).Flush()\n+\treturn w.cw.w.(*bufio.Writer).Flush()\n }\n \n // Create adds a file to the zip file using the provided name.\n@@ -119,28 +119,32 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \tfh.ReaderVersion = 0x14\n \n \tfw := &fileWriter{\n-\t\tzipw:      w,\n-\t\tcompCount: &countWriter{w: w},\n+\t\tzipw:      w.cw,\n+\t\tcompCount: &countWriter{w: w.cw},\n \t\tcrc32:     crc32.NewIEEE(),\n \t}\n \tswitch fh.Method {\n \tcase Store:\n \t\tfw.comp = nopCloser{fw.compCount}\n \tcase Deflate:\n-\t\tfw.comp = flate.NewWriter(fw.compCount, 5)\n+\t\tvar err error\n+\t\tfw.comp, err = flate.NewWriter(fw.compCount, 5)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \tdefault:\n \t\treturn nil, ErrAlgorithm\n \t}\n \tfw.rawCount = &countWriter{w: fw.comp}\n \n \th := &header{\n \t\tFileHeader: fh,\n-\t\toffset:     uint32(w.count),\n+\t\toffset:     uint32(w.cw.count),\n \t}\n \tw.dir = append(w.dir, h)\n \tfw.header = h\n \n-\tif err := writeHeader(w, fh); err != nil {\n+\tif err := writeHeader(w.cw, fh); err != nil {\n \t\treturn nil, err\n \t}\n "}, {"sha": "88e5211ff7be6d04eea79707823cf28b16fc1179", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -77,7 +77,7 @@ func TestWriter(t *testing.T) {\n \t}\n \n \t// read it back\n-\tr, err := NewReader(sliceReaderAt(buf.Bytes()), int64(buf.Len()))\n+\tr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "d6490c4cbbea8c927d9f633c1008ff29f0053304", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,22 +9,12 @@ package zip\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"io\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n \n-type stringReaderAt string\n-\n-func (s stringReaderAt) ReadAt(p []byte, off int64) (n int, err error) {\n-\tif off >= int64(len(s)) {\n-\t\treturn 0, io.EOF\n-\t}\n-\tn = copy(p, s[off:])\n-\treturn\n-}\n-\n func TestOver65kFiles(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Logf(\"slow test; skipping\")\n@@ -42,8 +32,8 @@ func TestOver65kFiles(t *testing.T) {\n \tif err := w.Close(); err != nil {\n \t\tt.Fatalf(\"Writer.Close: %v\", err)\n \t}\n-\trat := stringReaderAt(buf.String())\n-\tzr, err := NewReader(rat, int64(len(rat)))\n+\ts := buf.String()\n+\tzr, err := NewReader(strings.NewReader(s), int64(len(s)))\n \tif err != nil {\n \t\tt.Fatalf(\"NewReader: %v\", err)\n \t}"}, {"sha": "afdf2205598ffd83357c193f29e7fba70b179be1", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -182,14 +182,21 @@ func makeSlice(n int) []byte {\n func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n \tb.lastRead = opInvalid\n \tif b.off < len(b.buf) {\n+\t\tnBytes := b.Len()\n \t\tm, e := w.Write(b.buf[b.off:])\n+\t\tif m > nBytes {\n+\t\t\tpanic(\"bytes.Buffer.WriteTo: invalid Write count\")\n+\t\t}\n \t\tb.off += m\n \t\tn = int64(m)\n \t\tif e != nil {\n \t\t\treturn n, e\n \t\t}\n-\t\t// otherwise all bytes were written, by definition of\n+\t\t// all bytes should have been written, by definition of\n \t\t// Write method in io.Writer\n+\t\tif m != nBytes {\n+\t\t\treturn n, io.ErrShortWrite\n+\t\t}\n \t}\n \t// Buffer is now empty; reset.\n \tb.Truncate(0)"}, {"sha": "a062e54ba4d0808184a6c6e074e09b437c897e9a", "filename": "libgo/go/bytes/reader.go", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bytes\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"unicode/utf8\"\n+)\n+\n+// A Reader implements the io.Reader, io.ReaderAt, io.Seeker,\n+// io.ByteScanner, and io.RuneScanner interfaces by reading from\n+// a byte slice.\n+// Unlike a Buffer, a Reader is read-only and supports seeking.\n+type Reader struct {\n+\ts        []byte\n+\ti        int // current reading index\n+\tprevRune int // index of previous rune; or < 0\n+}\n+\n+// Len returns the number of bytes of the unread portion of the\n+// slice.\n+func (r *Reader) Len() int {\n+\tif r.i >= len(r.s) {\n+\t\treturn 0\n+\t}\n+\treturn len(r.s) - r.i\n+}\n+\n+func (r *Reader) Read(b []byte) (n int, err error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\tif r.i >= len(r.s) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tn = copy(b, r.s[r.i:])\n+\tr.i += n\n+\tr.prevRune = -1\n+\treturn\n+}\n+\n+func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {\n+\tif off < 0 {\n+\t\treturn 0, errors.New(\"bytes: invalid offset\")\n+\t}\n+\tif off >= int64(len(r.s)) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tn = copy(b, r.s[int(off):])\n+\tif n < len(b) {\n+\t\terr = io.EOF\n+\t}\n+\treturn\n+}\n+\n+func (r *Reader) ReadByte() (b byte, err error) {\n+\tif r.i >= len(r.s) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tb = r.s[r.i]\n+\tr.i++\n+\tr.prevRune = -1\n+\treturn\n+}\n+\n+func (r *Reader) UnreadByte() error {\n+\tif r.i <= 0 {\n+\t\treturn errors.New(\"bytes.Reader: at beginning of slice\")\n+\t}\n+\tr.i--\n+\tr.prevRune = -1\n+\treturn nil\n+}\n+\n+func (r *Reader) ReadRune() (ch rune, size int, err error) {\n+\tif r.i >= len(r.s) {\n+\t\treturn 0, 0, io.EOF\n+\t}\n+\tr.prevRune = r.i\n+\tif c := r.s[r.i]; c < utf8.RuneSelf {\n+\t\tr.i++\n+\t\treturn rune(c), 1, nil\n+\t}\n+\tch, size = utf8.DecodeRune(r.s[r.i:])\n+\tr.i += size\n+\treturn\n+}\n+\n+func (r *Reader) UnreadRune() error {\n+\tif r.prevRune < 0 {\n+\t\treturn errors.New(\"bytes.Reader: previous operation was not ReadRune\")\n+\t}\n+\tr.i = r.prevRune\n+\tr.prevRune = -1\n+\treturn nil\n+}\n+\n+// Seek implements the io.Seeker interface.\n+func (r *Reader) Seek(offset int64, whence int) (int64, error) {\n+\tvar abs int64\n+\tswitch whence {\n+\tcase 0:\n+\t\tabs = offset\n+\tcase 1:\n+\t\tabs = int64(r.i) + offset\n+\tcase 2:\n+\t\tabs = int64(len(r.s)) + offset\n+\tdefault:\n+\t\treturn 0, errors.New(\"bytes: invalid whence\")\n+\t}\n+\tif abs < 0 {\n+\t\treturn 0, errors.New(\"bytes: negative position\")\n+\t}\n+\tif abs >= 1<<31 {\n+\t\treturn 0, errors.New(\"bytes: position out of range\")\n+\t}\n+\tr.i = int(abs)\n+\treturn abs, nil\n+}\n+\n+// NewReader returns a new Reader reading from b.\n+func NewReader(b []byte) *Reader { return &Reader{b, 0, -1} }"}, {"sha": "2e4b1f26e81776214c017428044d450fbe3b4df8", "filename": "libgo/go/bytes/reader_test.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bytes_test\n+\n+import (\n+\t. \"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestReader(t *testing.T) {\n+\tr := NewReader([]byte(\"0123456789\"))\n+\ttests := []struct {\n+\t\toff     int64\n+\t\tseek    int\n+\t\tn       int\n+\t\twant    string\n+\t\twantpos int64\n+\t\tseekerr string\n+\t}{\n+\t\t{seek: os.SEEK_SET, off: 0, n: 20, want: \"0123456789\"},\n+\t\t{seek: os.SEEK_SET, off: 1, n: 1, want: \"1\"},\n+\t\t{seek: os.SEEK_CUR, off: 1, wantpos: 3, n: 2, want: \"34\"},\n+\t\t{seek: os.SEEK_SET, off: -1, seekerr: \"bytes: negative position\"},\n+\t\t{seek: os.SEEK_SET, off: 1<<31 - 1},\n+\t\t{seek: os.SEEK_CUR, off: 1, seekerr: \"bytes: position out of range\"},\n+\t\t{seek: os.SEEK_SET, n: 5, want: \"01234\"},\n+\t\t{seek: os.SEEK_CUR, n: 5, want: \"56789\"},\n+\t\t{seek: os.SEEK_END, off: -1, n: 1, wantpos: 9, want: \"9\"},\n+\t}\n+\n+\tfor i, tt := range tests {\n+\t\tpos, err := r.Seek(tt.off, tt.seek)\n+\t\tif err == nil && tt.seekerr != \"\" {\n+\t\t\tt.Errorf(\"%d. want seek error %q\", i, tt.seekerr)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil && err.Error() != tt.seekerr {\n+\t\t\tt.Errorf(\"%d. seek error = %q; want %q\", i, err.Error(), tt.seekerr)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tt.wantpos != 0 && tt.wantpos != pos {\n+\t\t\tt.Errorf(\"%d. pos = %d, want %d\", i, pos, tt.wantpos)\n+\t\t}\n+\t\tbuf := make([]byte, tt.n)\n+\t\tn, err := r.Read(buf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d. read = %v\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tgot := string(buf[:n])\n+\t\tif got != tt.want {\n+\t\t\tt.Errorf(\"%d. got %q; want %q\", i, got, tt.want)\n+\t\t}\n+\t}\n+}\n+\n+func TestReaderAt(t *testing.T) {\n+\tr := NewReader([]byte(\"0123456789\"))\n+\ttests := []struct {\n+\t\toff     int64\n+\t\tn       int\n+\t\twant    string\n+\t\twanterr interface{}\n+\t}{\n+\t\t{0, 10, \"0123456789\", nil},\n+\t\t{1, 10, \"123456789\", io.EOF},\n+\t\t{1, 9, \"123456789\", nil},\n+\t\t{11, 10, \"\", io.EOF},\n+\t\t{0, 0, \"\", nil},\n+\t\t{-1, 0, \"\", \"bytes: invalid offset\"},\n+\t}\n+\tfor i, tt := range tests {\n+\t\tb := make([]byte, tt.n)\n+\t\trn, err := r.ReadAt(b, tt.off)\n+\t\tgot := string(b[:rn])\n+\t\tif got != tt.want {\n+\t\t\tt.Errorf(\"%d. got %q; want %q\", i, got, tt.want)\n+\t\t}\n+\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wanterr) {\n+\t\t\tt.Errorf(\"%d. got error = %v; want %v\", i, err, tt.wanterr)\n+\t\t}\n+\t}\n+}"}, {"sha": "20408409c8ecb4ab4b416c2558b75af6c163d186", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -5,6 +5,7 @@\n package flate\n \n import (\n+\t\"fmt\"\n \t\"io\"\n \t\"math\"\n )\n@@ -390,7 +391,7 @@ func (d *compressor) init(w io.Writer, level int) (err error) {\n \t\td.fill = (*compressor).fillDeflate\n \t\td.step = (*compressor).deflate\n \tdefault:\n-\t\treturn WrongValueError{\"level\", 0, 9, int32(level)}\n+\t\treturn fmt.Errorf(\"flate: invalid compression level %d: want value in range [-1, 9]\", level)\n \t}\n \treturn nil\n }\n@@ -408,17 +409,22 @@ func (d *compressor) close() error {\n \treturn d.w.err\n }\n \n-// NewWriter returns a new Writer compressing\n-// data at the given level.  Following zlib, levels\n-// range from 1 (BestSpeed) to 9 (BestCompression);\n-// higher levels typically run slower but compress more.\n-// Level 0 (NoCompression) does not attempt any\n-// compression; it only adds the necessary DEFLATE framing.\n-func NewWriter(w io.Writer, level int) *Writer {\n+// NewWriter returns a new Writer compressing data at the given level.\n+// Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\n+// higher levels typically run slower but compress more. Level 0\n+// (NoCompression) does not attempt any compression; it only adds the\n+// necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default\n+// compression level.\n+//\n+// If level is in the range [-1, 9] then the error returned will be nil.\n+// Otherwise the error returned will be non-nil.\n+func NewWriter(w io.Writer, level int) (*Writer, error) {\n \tconst logWindowSize = logMaxOffsetSize\n \tvar dw Writer\n-\tdw.d.init(w, level)\n-\treturn &dw\n+\tif err := dw.d.init(w, level); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &dw, nil\n }\n \n // NewWriterDict is like NewWriter but initializes the new\n@@ -427,13 +433,16 @@ func NewWriter(w io.Writer, level int) *Writer {\n // any compressed output.  The compressed data written to w\n // can only be decompressed by a Reader initialized with the\n // same dictionary.\n-func NewWriterDict(w io.Writer, level int, dict []byte) *Writer {\n+func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n \tdw := &dictWriter{w, false}\n-\tzw := NewWriter(dw, level)\n+\tzw, err := NewWriter(dw, level)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tzw.Write(dict)\n \tzw.Flush()\n \tdw.enabled = true\n-\treturn zw\n+\treturn zw, err\n }\n \n type dictWriter struct {"}, {"sha": "a76e2d930f60694adf9dc745f3a34dc3c627d125", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -81,7 +81,11 @@ func largeDataChunk() []byte {\n func TestDeflate(t *testing.T) {\n \tfor _, h := range deflateTests {\n \t\tvar buf bytes.Buffer\n-\t\tw := NewWriter(&buf, h.level)\n+\t\tw, err := NewWriter(&buf, h.level)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"NewWriter: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n \t\tw.Write(h.in)\n \t\tw.Close()\n \t\tif !bytes.Equal(buf.Bytes(), h.out) {\n@@ -151,7 +155,11 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \tbuf := newSyncBuffer()\n \tbuf1 := new(bytes.Buffer)\n \tbuf.WriteMode()\n-\tw := NewWriter(io.MultiWriter(buf, buf1), level)\n+\tw, err := NewWriter(io.MultiWriter(buf, buf1), level)\n+\tif err != nil {\n+\t\tt.Errorf(\"NewWriter: %v\", err)\n+\t\treturn\n+\t}\n \tr := NewReader(buf)\n \n \t// Write half the input and read back.\n@@ -213,7 +221,7 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \n \t// stream should work for ordinary reader too\n \tr = NewReader(buf1)\n-\tout, err := ioutil.ReadAll(r)\n+\tout, err = ioutil.ReadAll(r)\n \tif err != nil {\n \t\tt.Errorf(\"testSync: read: %s\", err)\n \t\treturn\n@@ -224,31 +232,31 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \t}\n }\n \n-func testToFromWithLevel(t *testing.T, level int, input []byte, name string) error {\n-\treturn testToFromWithLevelAndLimit(t, level, input, name, -1)\n-}\n-\n-func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name string, limit int) error {\n+func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name string, limit int) {\n \tvar buffer bytes.Buffer\n-\tw := NewWriter(&buffer, level)\n+\tw, err := NewWriter(&buffer, level)\n+\tif err != nil {\n+\t\tt.Errorf(\"NewWriter: %v\", err)\n+\t\treturn\n+\t}\n \tw.Write(input)\n \tw.Close()\n \tif limit > 0 && buffer.Len() > limit {\n \t\tt.Errorf(\"level: %d, len(compress(data)) = %d > limit = %d\", level, buffer.Len(), limit)\n+\t\treturn\n \t}\n \tr := NewReader(&buffer)\n \tout, err := ioutil.ReadAll(r)\n \tif err != nil {\n \t\tt.Errorf(\"read: %s\", err)\n-\t\treturn err\n+\t\treturn\n \t}\n \tr.Close()\n \tif !bytes.Equal(input, out) {\n \t\tt.Errorf(\"decompress(compress(data)) != data: level=%d input=%s\", level, name)\n+\t\treturn\n \t}\n-\n \ttestSync(t, level, input, name)\n-\treturn nil\n }\n \n func testToFromWithLimit(t *testing.T, input []byte, name string, limit [10]int) {\n@@ -257,13 +265,9 @@ func testToFromWithLimit(t *testing.T, input []byte, name string, limit [10]int)\n \t}\n }\n \n-func testToFrom(t *testing.T, input []byte, name string) {\n-\ttestToFromWithLimit(t, input, name, [10]int{})\n-}\n-\n func TestDeflateInflate(t *testing.T) {\n \tfor i, h := range deflateInflateTests {\n-\t\ttestToFrom(t, h.in, fmt.Sprintf(\"#%d\", i))\n+\t\ttestToFromWithLimit(t, h.in, fmt.Sprintf(\"#%d\", i), [10]int{})\n \t}\n }\n \n@@ -311,7 +315,10 @@ func TestReaderDict(t *testing.T) {\n \t\ttext = \"hello again world\"\n \t)\n \tvar b bytes.Buffer\n-\tw := NewWriter(&b, 5)\n+\tw, err := NewWriter(&b, 5)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t}\n \tw.Write([]byte(dict))\n \tw.Flush()\n \tb.Reset()\n@@ -334,15 +341,18 @@ func TestWriterDict(t *testing.T) {\n \t\ttext = \"hello again world\"\n \t)\n \tvar b bytes.Buffer\n-\tw := NewWriter(&b, 5)\n+\tw, err := NewWriter(&b, 5)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t}\n \tw.Write([]byte(dict))\n \tw.Flush()\n \tb.Reset()\n \tw.Write([]byte(text))\n \tw.Close()\n \n \tvar b1 bytes.Buffer\n-\tw = NewWriterDict(&b1, 5, []byte(dict))\n+\tw, _ = NewWriterDict(&b1, 5, []byte(dict))\n \tw.Write([]byte(text))\n \tw.Close()\n \n@@ -353,7 +363,10 @@ func TestWriterDict(t *testing.T) {\n \n // See http://code.google.com/p/go/issues/detail?id=2508\n func TestRegression2508(t *testing.T) {\n-\tw := NewWriter(ioutil.Discard, 1)\n+\tw, err := NewWriter(ioutil.Discard, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewWriter: %v\", err)\n+\t}\n \tbuf := make([]byte, 1024)\n \tfor i := 0; i < 131072; i++ {\n \t\tif _, err := w.Write(buf); err != nil {"}, {"sha": "25e1da336aa469bc5560e57b5476488f40471021", "filename": "libgo/go/compress/flate/huffman_bit_writer.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_bit_writer.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,7 +7,6 @@ package flate\n import (\n \t\"io\"\n \t\"math\"\n-\t\"strconv\"\n )\n \n const (\n@@ -85,13 +84,6 @@ type huffmanBitWriter struct {\n \terr             error\n }\n \n-type WrongValueError struct {\n-\tname  string\n-\tfrom  int32\n-\tto    int32\n-\tvalue int32\n-}\n-\n func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \treturn &huffmanBitWriter{\n \t\tw:               w,\n@@ -105,11 +97,6 @@ func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter {\n \t}\n }\n \n-func (err WrongValueError) Error() string {\n-\treturn \"huffmanBitWriter: \" + err.name + \" should belong to [\" + strconv.FormatInt(int64(err.from), 10) + \";\" +\n-\t\tstrconv.FormatInt(int64(err.to), 10) + \"] but actual value is \" + strconv.FormatInt(int64(err.value), 10)\n-}\n-\n func (w *huffmanBitWriter) flushBits() {\n \tif w.err != nil {\n \t\tw.nbits = 0"}, {"sha": "33736f635082fd636fb07957803126993d7b88fe", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -16,9 +16,6 @@ import (\n \t\"time\"\n )\n \n-// BUG(nigeltao): Comments and Names don't properly map UTF-8 character codes outside of\n-// the 0x00-0x7f range to ISO 8859-1 (Latin-1).\n-\n const (\n \tgzipID1     = 0x1f\n \tgzipID2     = 0x8b\n@@ -37,11 +34,15 @@ func makeReader(r io.Reader) flate.Reader {\n \treturn bufio.NewReader(r)\n }\n \n-var ErrHeader = errors.New(\"invalid gzip header\")\n-var ErrChecksum = errors.New(\"gzip checksum error\")\n+var (\n+\t// ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n+\tErrChecksum = errors.New(\"gzip: invalid checksum\")\n+\t// ErrHeader is returned when reading GZIP data that has an invalid header.\n+\tErrHeader = errors.New(\"gzip: invalid header\")\n+)\n \n // The gzip file stores a header giving metadata about the compressed file.\n-// That header is exposed as the fields of the Compressor and Decompressor structs.\n+// That header is exposed as the fields of the Writer and Reader structs.\n type Header struct {\n \tComment string    // comment\n \tExtra   []byte    // \"extra data\"\n@@ -50,21 +51,21 @@ type Header struct {\n \tOS      byte      // operating system type\n }\n \n-// An Decompressor is an io.Reader that can be read to retrieve\n+// A Reader is an io.Reader that can be read to retrieve\n // uncompressed data from a gzip-format compressed file.\n //\n // In general, a gzip file can be a concatenation of gzip files,\n-// each with its own header.  Reads from the Decompressor\n+// each with its own header.  Reads from the Reader\n // return the concatenation of the uncompressed data of each.\n-// Only the first header is recorded in the Decompressor fields.\n+// Only the first header is recorded in the Reader fields.\n //\n // Gzip files store a length and checksum of the uncompressed data.\n-// The Decompressor will return a ErrChecksum when Read\n+// The Reader will return a ErrChecksum when Read\n // reaches the end of the uncompressed data if it does not\n // have the expected length or checksum.  Clients should treat data\n-// returned by Read as tentative until they receive the successful\n-// (zero length, nil error) Read marking the end of the data.\n-type Decompressor struct {\n+// returned by Read as tentative until they receive the io.EOF\n+// marking the end of the data.\n+type Reader struct {\n \tHeader\n \tr            flate.Reader\n \tdecompressor io.ReadCloser\n@@ -75,15 +76,14 @@ type Decompressor struct {\n \terr          error\n }\n \n-// NewReader creates a new Decompressor reading the given reader.\n+// NewReader creates a new Reader reading the given reader.\n // The implementation buffers input and may read more data than necessary from r.\n-// It is the caller's responsibility to call Close on the Decompressor when done.\n-func NewReader(r io.Reader) (*Decompressor, error) {\n-\tz := new(Decompressor)\n+// It is the caller's responsibility to call Close on the Reader when done.\n+func NewReader(r io.Reader) (*Reader, error) {\n+\tz := new(Reader)\n \tz.r = makeReader(r)\n \tz.digest = crc32.NewIEEE()\n \tif err := z.readHeader(true); err != nil {\n-\t\tz.err = err\n \t\treturn nil, err\n \t}\n \treturn z, nil\n@@ -94,7 +94,7 @@ func get4(p []byte) uint32 {\n \treturn uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24\n }\n \n-func (z *Decompressor) readString() (string, error) {\n+func (z *Reader) readString() (string, error) {\n \tvar err error\n \tneedconv := false\n \tfor i := 0; ; i++ {\n@@ -123,15 +123,15 @@ func (z *Decompressor) readString() (string, error) {\n \tpanic(\"not reached\")\n }\n \n-func (z *Decompressor) read2() (uint32, error) {\n+func (z *Reader) read2() (uint32, error) {\n \t_, err := io.ReadFull(z.r, z.buf[0:2])\n \tif err != nil {\n \t\treturn 0, err\n \t}\n \treturn uint32(z.buf[0]) | uint32(z.buf[1])<<8, nil\n }\n \n-func (z *Decompressor) readHeader(save bool) error {\n+func (z *Reader) readHeader(save bool) error {\n \t_, err := io.ReadFull(z.r, z.buf[0:10])\n \tif err != nil {\n \t\treturn err\n@@ -197,7 +197,7 @@ func (z *Decompressor) readHeader(save bool) error {\n \treturn nil\n }\n \n-func (z *Decompressor) Read(p []byte) (n int, err error) {\n+func (z *Reader) Read(p []byte) (n int, err error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -237,5 +237,5 @@ func (z *Decompressor) Read(p []byte) (n int, err error) {\n \treturn z.Read(p)\n }\n \n-// Calling Close does not close the wrapped io.Reader originally passed to NewReader.\n-func (z *Decompressor) Close() error { return z.decompressor.Close() }\n+// Close closes the Reader. It does not close the underlying io.Reader.\n+func (z *Reader) Close() error { return z.decompressor.Close() }"}, {"sha": "3035dfffccf31ded5a87c7856b3e7177bb7275c0", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,6 +7,7 @@ package gzip\n import (\n \t\"compress/flate\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n@@ -21,9 +22,9 @@ const (\n \tDefaultCompression = flate.DefaultCompression\n )\n \n-// A Compressor is an io.WriteCloser that satisfies writes by compressing data written\n+// A Writer is an io.WriteCloser that satisfies writes by compressing data written\n // to its wrapped io.Writer.\n-type Compressor struct {\n+type Writer struct {\n \tHeader\n \tw          io.Writer\n \tlevel      int\n@@ -35,25 +36,40 @@ type Compressor struct {\n \terr        error\n }\n \n-// NewWriter calls NewWriterLevel with the default compression level.\n-func NewWriter(w io.Writer) (*Compressor, error) {\n-\treturn NewWriterLevel(w, DefaultCompression)\n+// NewWriter creates a new Writer that satisfies writes by compressing data\n+// written to w.\n+//\n+// It is the caller's responsibility to call Close on the WriteCloser when done.\n+// Writes may be buffered and not flushed until Close.\n+//\n+// Callers that wish to set the fields in Writer.Header must do so before\n+// the first call to Write or Close. The Comment and Name header fields are\n+// UTF-8 strings in Go, but the underlying format requires NUL-terminated ISO\n+// 8859-1 (Latin-1). NUL or non-Latin-1 runes in those strings will lead to an\n+// error on Write.\n+func NewWriter(w io.Writer) *Writer {\n+\tz, _ := NewWriterLevel(w, DefaultCompression)\n+\treturn z\n }\n \n-// NewWriterLevel creates a new Compressor writing to the given writer.\n-// Writes may be buffered and not flushed until Close.\n-// Callers that wish to set the fields in Compressor.Header must\n-// do so before the first call to Write or Close.\n-// It is the caller's responsibility to call Close on the WriteCloser when done.\n-// level is the compression level, which can be DefaultCompression, NoCompression,\n-// or any integer value between BestSpeed and BestCompression (inclusive).\n-func NewWriterLevel(w io.Writer, level int) (*Compressor, error) {\n-\tz := new(Compressor)\n-\tz.OS = 255 // unknown\n-\tz.w = w\n-\tz.level = level\n-\tz.digest = crc32.NewIEEE()\n-\treturn z, nil\n+// NewWriterLevel is like NewWriter but specifies the compression level instead\n+// of assuming DefaultCompression.\n+//\n+// The compression level can be DefaultCompression, NoCompression, or any\n+// integer value between BestSpeed and BestCompression inclusive. The error\n+// returned will be nil if the level is valid.\n+func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n+\tif level < DefaultCompression || level > BestCompression {\n+\t\treturn nil, fmt.Errorf(\"gzip: invalid compression level: %d\", level)\n+\t}\n+\treturn &Writer{\n+\t\tHeader: Header{\n+\t\t\tOS: 255, // unknown\n+\t\t},\n+\t\tw:      w,\n+\t\tlevel:  level,\n+\t\tdigest: crc32.NewIEEE(),\n+\t}, nil\n }\n \n // GZIP (RFC 1952) is little-endian, unlike ZLIB (RFC 1950).\n@@ -70,7 +86,7 @@ func put4(p []byte, v uint32) {\n }\n \n // writeBytes writes a length-prefixed byte slice to z.w.\n-func (z *Compressor) writeBytes(b []byte) error {\n+func (z *Writer) writeBytes(b []byte) error {\n \tif len(b) > 0xffff {\n \t\treturn errors.New(\"gzip.Write: Extra data is too large\")\n \t}\n@@ -83,10 +99,10 @@ func (z *Compressor) writeBytes(b []byte) error {\n \treturn err\n }\n \n-// writeString writes a string (in ISO 8859-1 (Latin-1) format) to z.w.\n-func (z *Compressor) writeString(s string) error {\n-\t// GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1).\n-\tvar err error\n+// writeString writes a UTF-8 string s in GZIP's format to z.w.\n+// GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1).\n+func (z *Writer) writeString(s string) (err error) {\n+\t// GZIP stores Latin-1 strings; error if non-Latin-1; convert if non-ASCII.\n \tneedconv := false\n \tfor _, v := range s {\n \t\tif v == 0 || v > 0xff {\n@@ -114,7 +130,9 @@ func (z *Compressor) writeString(s string) error {\n \treturn err\n }\n \n-func (z *Compressor) Write(p []byte) (int, error) {\n+// Write writes a compressed form of p to the underlying io.Writer. The\n+// compressed bytes are not necessarily flushed until the Writer is closed.\n+func (z *Writer) Write(p []byte) (int, error) {\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -165,16 +183,16 @@ func (z *Compressor) Write(p []byte) (int, error) {\n \t\t\t\treturn n, z.err\n \t\t\t}\n \t\t}\n-\t\tz.compressor = flate.NewWriter(z.w, z.level)\n+\t\tz.compressor, _ = flate.NewWriter(z.w, z.level)\n \t}\n \tz.size += uint32(len(p))\n \tz.digest.Write(p)\n \tn, z.err = z.compressor.Write(p)\n \treturn n, z.err\n }\n \n-// Calling Close does not close the wrapped io.Writer originally passed to NewWriter.\n-func (z *Compressor) Close() error {\n+// Close closes the Writer. It does not close the underlying io.Writer.\n+func (z *Writer) Close() error {\n \tif z.err != nil {\n \t\treturn z.err\n \t}"}, {"sha": "6f7b593644975ae3cc3159c9625c3c61104c2ee8", "filename": "libgo/go/compress/gzip/gzip_test.go", "status": "modified", "additions": 122, "deletions": 77, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,108 +7,153 @@ package gzip\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t\"io\"\n \t\"io/ioutil\"\n \t\"testing\"\n \t\"time\"\n )\n \n-// pipe creates two ends of a pipe that gzip and gunzip, and runs dfunc at the\n-// writer end and cfunc at the reader end.\n-func pipe(t *testing.T, dfunc func(*Compressor), cfunc func(*Decompressor)) {\n-\tpiper, pipew := io.Pipe()\n-\tdefer piper.Close()\n-\tgo func() {\n-\t\tdefer pipew.Close()\n-\t\tcompressor, err := NewWriter(pipew)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"%v\", err)\n-\t\t}\n-\t\tdefer compressor.Close()\n-\t\tdfunc(compressor)\n-\t}()\n-\tdecompressor, err := NewReader(piper)\n+// TestEmpty tests that an empty payload still forms a valid GZIP stream.\n+func TestEmpty(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\n+\tif err := NewWriter(buf).Close(); err != nil {\n+\t\tt.Fatalf(\"Writer.Close: %v\", err)\n+\t}\n+\n+\tr, err := NewReader(buf)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewReader: %v\", err)\n+\t}\n+\tb, err := ioutil.ReadAll(r)\n \tif err != nil {\n-\t\tt.Fatalf(\"%v\", err)\n+\t\tt.Fatalf(\"ReadAll: %v\", err)\n+\t}\n+\tif len(b) != 0 {\n+\t\tt.Fatalf(\"got %d bytes, want 0\", len(b))\n+\t}\n+\tif err := r.Close(); err != nil {\n+\t\tt.Fatalf(\"Reader.Close: %v\", err)\n \t}\n-\tdefer decompressor.Close()\n-\tcfunc(decompressor)\n }\n \n-// Tests that an empty payload still forms a valid GZIP stream.\n-func TestEmpty(t *testing.T) {\n-\tpipe(t,\n-\t\tfunc(compressor *Compressor) {},\n-\t\tfunc(decompressor *Decompressor) {\n-\t\t\tb, err := ioutil.ReadAll(decompressor)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"%v\", err)\n-\t\t\t}\n-\t\t\tif len(b) != 0 {\n-\t\t\t\tt.Fatalf(\"did not read an empty slice\")\n-\t\t\t}\n-\t\t})\n-}\n+// TestRoundTrip tests that gzipping and then gunzipping is the identity\n+// function.\n+func TestRoundTrip(t *testing.T) {\n+\tbuf := new(bytes.Buffer)\n+\n+\tw := NewWriter(buf)\n+\tw.Comment = \"comment\"\n+\tw.Extra = []byte(\"extra\")\n+\tw.ModTime = time.Unix(1e8, 0)\n+\tw.Name = \"name\"\n+\tif _, err := w.Write([]byte(\"payload\")); err != nil {\n+\t\tt.Fatalf(\"Write: %v\", err)\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatalf(\"Writer.Close: %v\", err)\n+\t}\n \n-// Tests that gzipping and then gunzipping is the identity function.\n-func TestWriter(t *testing.T) {\n-\tpipe(t,\n-\t\tfunc(compressor *Compressor) {\n-\t\t\tcompressor.Comment = \"\u00c4u\u00dferung\"\n-\t\t\t//compressor.Comment = \"comment\"\n-\t\t\tcompressor.Extra = []byte(\"extra\")\n-\t\t\tcompressor.ModTime = time.Unix(1e8, 0)\n-\t\t\tcompressor.Name = \"name\"\n-\t\t\t_, err := compressor.Write([]byte(\"payload\"))\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"%v\", err)\n-\t\t\t}\n-\t\t},\n-\t\tfunc(decompressor *Decompressor) {\n-\t\t\tb, err := ioutil.ReadAll(decompressor)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"%v\", err)\n-\t\t\t}\n-\t\t\tif string(b) != \"payload\" {\n-\t\t\t\tt.Fatalf(\"payload is %q, want %q\", string(b), \"payload\")\n-\t\t\t}\n-\t\t\tif decompressor.Comment != \"\u00c4u\u00dferung\" {\n-\t\t\t\tt.Fatalf(\"comment is %q, want %q\", decompressor.Comment, \"\u00c4u\u00dferung\")\n-\t\t\t}\n-\t\t\tif string(decompressor.Extra) != \"extra\" {\n-\t\t\t\tt.Fatalf(\"extra is %q, want %q\", decompressor.Extra, \"extra\")\n-\t\t\t}\n-\t\t\tif decompressor.ModTime.Unix() != 1e8 {\n-\t\t\t\tt.Fatalf(\"mtime is %d, want %d\", decompressor.ModTime.Unix(), uint32(1e8))\n-\t\t\t}\n-\t\t\tif decompressor.Name != \"name\" {\n-\t\t\t\tt.Fatalf(\"name is %q, want %q\", decompressor.Name, \"name\")\n-\t\t\t}\n-\t\t})\n+\tr, err := NewReader(buf)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewReader: %v\", err)\n+\t}\n+\tb, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ReadAll: %v\", err)\n+\t}\n+\tif string(b) != \"payload\" {\n+\t\tt.Fatalf(\"payload is %q, want %q\", string(b), \"payload\")\n+\t}\n+\tif r.Comment != \"comment\" {\n+\t\tt.Fatalf(\"comment is %q, want %q\", r.Comment, \"comment\")\n+\t}\n+\tif string(r.Extra) != \"extra\" {\n+\t\tt.Fatalf(\"extra is %q, want %q\", r.Extra, \"extra\")\n+\t}\n+\tif r.ModTime.Unix() != 1e8 {\n+\t\tt.Fatalf(\"mtime is %d, want %d\", r.ModTime.Unix(), uint32(1e8))\n+\t}\n+\tif r.Name != \"name\" {\n+\t\tt.Fatalf(\"name is %q, want %q\", r.Name, \"name\")\n+\t}\n+\tif err := r.Close(); err != nil {\n+\t\tt.Fatalf(\"Reader.Close: %v\", err)\n+\t}\n }\n \n+// TestLatin1 tests the internal functions for converting to and from Latin-1.\n func TestLatin1(t *testing.T) {\n \tlatin1 := []byte{0xc4, 'u', 0xdf, 'e', 'r', 'u', 'n', 'g', 0}\n \tutf8 := \"\u00c4u\u00dferung\"\n-\tz := Decompressor{r: bufio.NewReader(bytes.NewBuffer(latin1))}\n+\tz := Reader{r: bufio.NewReader(bytes.NewBuffer(latin1))}\n \ts, err := z.readString()\n \tif err != nil {\n-\t\tt.Fatalf(\"%v\", err)\n+\t\tt.Fatalf(\"readString: %v\", err)\n \t}\n \tif s != utf8 {\n-\t\tt.Fatalf(\"string is %q, want %q\", s, utf8)\n+\t\tt.Fatalf(\"read latin-1: got %q, want %q\", s, utf8)\n \t}\n \n \tbuf := bytes.NewBuffer(make([]byte, 0, len(latin1)))\n-\tc := Compressor{w: buf}\n+\tc := Writer{w: buf}\n \tif err = c.writeString(utf8); err != nil {\n-\t\tt.Fatalf(\"%v\", err)\n+\t\tt.Fatalf(\"writeString: %v\", err)\n \t}\n \ts = buf.String()\n \tif s != string(latin1) {\n-\t\tt.Fatalf(\"string is %v, want %v\", s, latin1)\n+\t\tt.Fatalf(\"write utf-8: got %q, want %q\", s, string(latin1))\n+\t}\n+}\n+\n+// TestLatin1RoundTrip tests that metadata that is representable in Latin-1\n+// survives a round trip.\n+func TestLatin1RoundTrip(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname string\n+\t\tok   bool\n+\t}{\n+\t\t{\"\", true},\n+\t\t{\"ASCII is OK\", true},\n+\t\t{\"unless it contains a NUL\\x00\", false},\n+\t\t{\"no matter where \\x00 occurs\", false},\n+\t\t{\"\\x00\\x00\\x00\", false},\n+\t\t{\"L\u00e1tin-1 also passes (U+00E1)\", true},\n+\t\t{\"but L\u0100tin Extended-A (U+0100) does not\", false},\n+\t\t{\"neither does \u65e5\u672c\u8a9e\", false},\n+\t\t{\"invalid UTF-8 also \\xffails\", false},\n+\t\t{\"\\x00 as does L\u00e1tin-1 with NUL\", false},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tbuf := new(bytes.Buffer)\n+\n+\t\tw := NewWriter(buf)\n+\t\tw.Name = tc.name\n+\t\terr := w.Close()\n+\t\tif (err == nil) != tc.ok {\n+\t\t\tt.Errorf(\"Writer.Close: name = %q, err = %v\", tc.name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !tc.ok {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr, err := NewReader(buf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"NewReader: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t_, err = ioutil.ReadAll(r)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"ReadAll: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif r.Name != tc.name {\n+\t\t\tt.Errorf(\"name is %q, want %q\", r.Name, tc.name)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := r.Close(); err != nil {\n+\t\t\tt.Errorf(\"Reader.Close: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n \t}\n-\t//if s, err = buf.ReadString(0); err != nil {\n-\t//t.Fatalf(\"%v\", err)\n-\t//}\n }"}, {"sha": "f38ef5a885e8107569d15d2ef3ab4e693c99d5df", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -34,9 +34,14 @@ import (\n \n const zlibDeflate = 8\n \n-var ErrChecksum = errors.New(\"zlib checksum error\")\n-var ErrHeader = errors.New(\"invalid zlib header\")\n-var ErrDictionary = errors.New(\"invalid zlib dictionary\")\n+var (\n+\t// ErrChecksum is returned when reading ZLIB data that has an invalid checksum.\n+\tErrChecksum = errors.New(\"zlib: invalid checksum\")\n+\t// ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.\n+\tErrDictionary = errors.New(\"zlib: invalid dictionary\")\n+\t// ErrHeader is returned when reading ZLIB data that has an invalid header.\n+\tErrHeader = errors.New(\"zlib: invalid header\")\n+)\n \n type reader struct {\n \tr            flate.Reader"}, {"sha": "cd8dea460a4f868f296366d4160f61399e425692", "filename": "libgo/go/compress/zlib/writer.go", "status": "modified", "additions": 70, "deletions": 33, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,7 +6,7 @@ package zlib\n \n import (\n \t\"compress/flate\"\n-\t\"errors\"\n+\t\"fmt\"\n \t\"hash\"\n \t\"hash/adler32\"\n \t\"io\"\n@@ -24,30 +24,55 @@ const (\n // A Writer takes data written to it and writes the compressed\n // form of that data to an underlying writer (see NewWriter).\n type Writer struct {\n-\tw          io.Writer\n-\tcompressor *flate.Writer\n-\tdigest     hash.Hash32\n-\terr        error\n-\tscratch    [4]byte\n+\tw           io.Writer\n+\tlevel       int\n+\tdict        []byte\n+\tcompressor  *flate.Writer\n+\tdigest      hash.Hash32\n+\terr         error\n+\tscratch     [4]byte\n+\twroteHeader bool\n }\n \n-// NewWriter calls NewWriterLevel with the default compression level.\n-func NewWriter(w io.Writer) (*Writer, error) {\n-\treturn NewWriterLevel(w, DefaultCompression)\n+// NewWriter creates a new Writer that satisfies writes by compressing data\n+// written to w.\n+//\n+// It is the caller's responsibility to call Close on the WriteCloser when done.\n+// Writes may be buffered and not flushed until Close.\n+func NewWriter(w io.Writer) *Writer {\n+\tz, _ := NewWriterLevelDict(w, DefaultCompression, nil)\n+\treturn z\n }\n \n-// NewWriterLevel calls NewWriterDict with no dictionary.\n+// NewWriterLevel is like NewWriter but specifies the compression level instead\n+// of assuming DefaultCompression.\n+//\n+// The compression level can be DefaultCompression, NoCompression, or any\n+// integer value between BestSpeed and BestCompression inclusive. The error\n+// returned will be nil if the level is valid.\n func NewWriterLevel(w io.Writer, level int) (*Writer, error) {\n-\treturn NewWriterDict(w, level, nil)\n+\treturn NewWriterLevelDict(w, level, nil)\n }\n \n-// NewWriterDict creates a new io.WriteCloser that satisfies writes by compressing data written to w.\n-// It is the caller's responsibility to call Close on the WriteCloser when done.\n-// level is the compression level, which can be DefaultCompression, NoCompression,\n-// or any integer value between BestSpeed and BestCompression (inclusive).\n-// dict is the preset dictionary to compress with, or nil to use no dictionary.\n-func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n-\tz := new(Writer)\n+// NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\n+// compress with.\n+//\n+// The dictionary may be nil. If not, its contents should not be modified until\n+// the Writer is closed.\n+func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n+\tif level < DefaultCompression || level > BestCompression {\n+\t\treturn nil, fmt.Errorf(\"zlib: invalid compression level: %d\", level)\n+\t}\n+\treturn &Writer{\n+\t\tw:     w,\n+\t\tlevel: level,\n+\t\tdict:  dict,\n+\t}, nil\n+}\n+\n+// writeHeader writes the ZLIB header.\n+func (z *Writer) writeHeader() (err error) {\n+\tz.wroteHeader = true\n \t// ZLIB has a two-byte header (as documented in RFC 1950).\n \t// The first four bits is the CINFO (compression info), which is 7 for the default deflate window size.\n \t// The next four bits is the CM (compression method), which is 8 for deflate.\n@@ -56,7 +81,7 @@ func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n \t// 0=fastest, 1=fast, 2=default, 3=best.\n \t// The next bit, FDICT, is set if a dictionary is given.\n \t// The final five FCHECK bits form a mod-31 checksum.\n-\tswitch level {\n+\tswitch z.level {\n \tcase 0, 1:\n \t\tz.scratch[1] = 0 << 6\n \tcase 2, 3, 4, 5:\n@@ -66,35 +91,41 @@ func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error) {\n \tcase 7, 8, 9:\n \t\tz.scratch[1] = 3 << 6\n \tdefault:\n-\t\treturn nil, errors.New(\"level out of range\")\n+\t\tpanic(\"unreachable\")\n \t}\n-\tif dict != nil {\n+\tif z.dict != nil {\n \t\tz.scratch[1] |= 1 << 5\n \t}\n \tz.scratch[1] += uint8(31 - (uint16(z.scratch[0])<<8+uint16(z.scratch[1]))%31)\n-\t_, err := w.Write(z.scratch[0:2])\n-\tif err != nil {\n-\t\treturn nil, err\n+\tif _, err = z.w.Write(z.scratch[0:2]); err != nil {\n+\t\treturn err\n \t}\n-\tif dict != nil {\n+\tif z.dict != nil {\n \t\t// The next four bytes are the Adler-32 checksum of the dictionary.\n-\t\tchecksum := adler32.Checksum(dict)\n+\t\tchecksum := adler32.Checksum(z.dict)\n \t\tz.scratch[0] = uint8(checksum >> 24)\n \t\tz.scratch[1] = uint8(checksum >> 16)\n \t\tz.scratch[2] = uint8(checksum >> 8)\n \t\tz.scratch[3] = uint8(checksum >> 0)\n-\t\t_, err = w.Write(z.scratch[0:4])\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tif _, err = z.w.Write(z.scratch[0:4]); err != nil {\n+\t\t\treturn err\n \t\t}\n \t}\n-\tz.w = w\n-\tz.compressor = flate.NewWriterDict(w, level, dict)\n+\tz.compressor, err = flate.NewWriterDict(z.w, z.level, z.dict)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tz.digest = adler32.New()\n-\treturn z, nil\n+\treturn nil\n }\n \n+// Write writes a compressed form of p to the underlying io.Writer. The\n+// compressed bytes are not necessarily flushed until the Writer is closed or\n+// explicitly flushed.\n func (z *Writer) Write(p []byte) (n int, err error) {\n+\tif !z.wroteHeader {\n+\t\tz.err = z.writeHeader()\n+\t}\n \tif z.err != nil {\n \t\treturn 0, z.err\n \t}\n@@ -110,8 +141,11 @@ func (z *Writer) Write(p []byte) (n int, err error) {\n \treturn\n }\n \n-// Flush flushes the underlying compressor.\n+// Flush flushes the Writer to its underlying io.Writer.\n func (z *Writer) Flush() error {\n+\tif !z.wroteHeader {\n+\t\tz.err = z.writeHeader()\n+\t}\n \tif z.err != nil {\n \t\treturn z.err\n \t}\n@@ -121,6 +155,9 @@ func (z *Writer) Flush() error {\n \n // Calling Close does not close the wrapped io.Writer originally passed to NewWriter.\n func (z *Writer) Close() error {\n+\tif !z.wroteHeader {\n+\t\tz.err = z.writeHeader()\n+\t}\n \tif z.err != nil {\n \t\treturn z.err\n \t}"}, {"sha": "aee1a5c2f5426456296b7896de7b155f6445bf7d", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -52,7 +52,7 @@ func testLevelDict(t *testing.T, fn string, b0 []byte, level int, d string) {\n \tdefer piper.Close()\n \tgo func() {\n \t\tdefer pipew.Close()\n-\t\tzlibw, err := NewWriterDict(pipew, level, dict)\n+\t\tzlibw, err := NewWriterLevelDict(pipew, level, dict)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\t\treturn\n@@ -125,9 +125,9 @@ func TestWriterDict(t *testing.T) {\n func TestWriterDictIsUsed(t *testing.T) {\n \tvar input = []byte(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n \tvar buf bytes.Buffer\n-\tcompressor, err := NewWriterDict(&buf, BestCompression, input)\n+\tcompressor, err := NewWriterLevelDict(&buf, BestCompression, input)\n \tif err != nil {\n-\t\tt.Errorf(\"error in NewWriterDict: %s\", err)\n+\t\tt.Errorf(\"error in NewWriterLevelDict: %s\", err)\n \t\treturn\n \t}\n \tcompressor.Write(input)"}, {"sha": "c3b8d94cb2acd304c62b5f76e0b5abf7d0140908", "filename": "libgo/go/container/heap/example_test.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fexample_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This example demonstrates a priority queue built using the heap interface.\n+package heap_test\n+\n+import (\n+\t\"container/heap\"\n+\t\"fmt\"\n+)\n+\n+// An Item is something we manage in a priority queue.\n+type Item struct {\n+\tvalue    string // The value of the item; arbitrary.\n+\tpriority int    // The priority of the item in the queue.\n+\t// The index is needed by changePriority and is maintained by the heap.Interface methods.\n+\tindex int // The index of the item in the heap.\n+}\n+\n+// A PriorityQueue implements heap.Interface and holds Items.\n+type PriorityQueue []*Item\n+\n+func (pq PriorityQueue) Len() int { return len(pq) }\n+\n+func (pq PriorityQueue) Less(i, j int) bool {\n+\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\n+\treturn pq[i].priority > pq[j].priority\n+}\n+\n+func (pq PriorityQueue) Swap(i, j int) {\n+\tpq[i], pq[j] = pq[j], pq[i]\n+\tpq[i].index = i\n+\tpq[j].index = j\n+}\n+\n+func (pq *PriorityQueue) Push(x interface{}) {\n+\t// Push and Pop use pointer receivers because they modify the slice's length,\n+\t// not just its contents.\n+\t// To simplify indexing expressions in these methods, we save a copy of the\n+\t// slice object. We could instead write (*pq)[i].\n+\ta := *pq\n+\tn := len(a)\n+\ta = a[0 : n+1]\n+\titem := x.(*Item)\n+\titem.index = n\n+\ta[n] = item\n+\t*pq = a\n+}\n+\n+func (pq *PriorityQueue) Pop() interface{} {\n+\ta := *pq\n+\tn := len(a)\n+\titem := a[n-1]\n+\titem.index = -1 // for safety\n+\t*pq = a[0 : n-1]\n+\treturn item\n+}\n+\n+// 99:seven 88:five 77:zero 66:nine 55:three 44:two 33:six 22:one 11:four 00:eight\n+func ExampleInterface() {\n+\t// The full code of this example, including the methods that implement\n+\t// heap.Interface, is in the file src/pkg/container/heap/example_test.go.\n+\n+\tconst nItem = 10\n+\t// Random priorities for the items (a permutation of 0..9, times 11)).\n+\tpriorities := [nItem]int{\n+\t\t77, 22, 44, 55, 11, 88, 33, 99, 00, 66,\n+\t}\n+\tvalues := [nItem]string{\n+\t\t\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n+\t}\n+\t// Create a priority queue and put some items in it.\n+\tpq := make(PriorityQueue, 0, nItem)\n+\tfor i := 0; i < cap(pq); i++ {\n+\t\titem := &Item{\n+\t\t\tvalue:    values[i],\n+\t\t\tpriority: priorities[i],\n+\t\t}\n+\t\theap.Push(&pq, item)\n+\t}\n+\t// Take the items out; should arrive in decreasing priority order.\n+\t// For example, the highest priority (99) is the seventh item, so output starts with 99:\"seven\".\n+\tfor i := 0; i < nItem; i++ {\n+\t\titem := heap.Pop(&pq).(*Item)\n+\t\tfmt.Printf(\"%.2d:%s \", item.priority, item.value)\n+\t}\n+}\n+\n+// update is not used by the example but shows how to take the top item from the queue,\n+// update its priority and value, and put it back.\n+func (pq *PriorityQueue) update(value string, priority int) {\n+\titem := heap.Pop(pq).(*Item)\n+\titem.value = value\n+\titem.priority = priority\n+\theap.Push(pq, item)\n+}\n+\n+// changePriority is not used by the example but shows how to change the priority of an arbitrary\n+// item.\n+func (pq *PriorityQueue) changePriority(item *Item, priority int) {\n+\theap.Remove(pq, item.index)\n+\titem.priority = priority\n+\theap.Push(pq, item)\n+}"}, {"sha": "67018e6baea929887e3812109450be96dadb87a1", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,10 +6,11 @@\n // heap.Interface. A heap is a tree with the property that each node is the\n // highest-valued node in its subtree.\n //\n-// A heap is a common way to impement a priority queue. To build a priority\n+// A heap is a common way to implement a priority queue. To build a priority\n // queue, implement the Heap interface with the (negative) priority as the\n // ordering for the Less method, so Push adds items while Pop removes the\n-// highest-priority item from the queue.\n+// highest-priority item from the queue. The Examples include such an\n+// implementation; the file example_test.go has the complete source.\n //\n package heap\n "}, {"sha": "7d307c93a0be1300f31b097ad17f233ac2f5f3d1", "filename": "libgo/go/crypto/aes/cipher.go", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -4,13 +4,16 @@\n \n package aes\n \n-import \"strconv\"\n+import (\n+\t\"crypto/cipher\"\n+\t\"strconv\"\n+)\n \n // The AES block size in bytes.\n const BlockSize = 16\n \n-// A Cipher is an instance of AES encryption using a particular key.\n-type Cipher struct {\n+// A cipher is an instance of AES encryption using a particular key.\n+type aesCipher struct {\n \tenc []uint32\n \tdec []uint32\n }\n@@ -21,11 +24,11 @@ func (k KeySizeError) Error() string {\n \treturn \"crypto/aes: invalid key size \" + strconv.Itoa(int(k))\n }\n \n-// NewCipher creates and returns a new Cipher.\n+// NewCipher creates and returns a new cipher.Block.\n // The key argument should be the AES key,\n // either 16, 24, or 32 bytes to select\n // AES-128, AES-192, or AES-256.\n-func NewCipher(key []byte) (*Cipher, error) {\n+func NewCipher(key []byte) (cipher.Block, error) {\n \tk := len(key)\n \tswitch k {\n \tdefault:\n@@ -35,34 +38,13 @@ func NewCipher(key []byte) (*Cipher, error) {\n \t}\n \n \tn := k + 28\n-\tc := &Cipher{make([]uint32, n), make([]uint32, n)}\n+\tc := &aesCipher{make([]uint32, n), make([]uint32, n)}\n \texpandKey(key, c.enc, c.dec)\n \treturn c, nil\n }\n \n-// BlockSize returns the AES block size, 16 bytes.\n-// It is necessary to satisfy the Block interface in the\n-// package \"crypto/cipher\".\n-func (c *Cipher) BlockSize() int { return BlockSize }\n+func (c *aesCipher) BlockSize() int { return BlockSize }\n \n-// Encrypt encrypts the 16-byte buffer src using the key k\n-// and stores the result in dst.\n-// Note that for amounts of data larger than a block,\n-// it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n-func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c.enc, dst, src) }\n+func (c *aesCipher) Encrypt(dst, src []byte) { encryptBlock(c.enc, dst, src) }\n \n-// Decrypt decrypts the 16-byte buffer src using the key k\n-// and stores the result in dst.\n-func (c *Cipher) Decrypt(dst, src []byte) { decryptBlock(c.dec, dst, src) }\n-\n-// Reset zeros the key data, so that it will no longer\n-// appear in the process's memory.\n-func (c *Cipher) Reset() {\n-\tfor i := 0; i < len(c.enc); i++ {\n-\t\tc.enc[i] = 0\n-\t}\n-\tfor i := 0; i < len(c.dec); i++ {\n-\t\tc.dec[i] = 0\n-\t}\n-}\n+func (c *aesCipher) Decrypt(dst, src []byte) { decryptBlock(c.dec, dst, src) }"}, {"sha": "cee3a784b5074949a3916912d6a9ea4ae9ff393c", "filename": "libgo/go/crypto/cipher/cbc_aes_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc_aes_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,11 +8,12 @@\n // Special Publication 800-38A, ``Recommendation for Block Cipher\n // Modes of Operation,'' 2001 Edition, pp. 24-29.\n \n-package cipher\n+package cipher_test\n \n import (\n \t\"bytes\"\n \t\"crypto/aes\"\n+\t\"crypto/cipher\"\n \t\"testing\"\n )\n \n@@ -72,14 +73,14 @@ func TestCBC_AES(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \n-\t\tencrypter := NewCBCEncrypter(c, tt.iv)\n+\t\tencrypter := cipher.NewCBCEncrypter(c, tt.iv)\n \t\td := make([]byte, len(tt.in))\n \t\tencrypter.CryptBlocks(d, tt.in)\n \t\tif !bytes.Equal(tt.out, d) {\n \t\t\tt.Errorf(\"%s: CBCEncrypter\\nhave %x\\nwant %x\", test, d, tt.out)\n \t\t}\n \n-\t\tdecrypter := NewCBCDecrypter(c, tt.iv)\n+\t\tdecrypter := cipher.NewCBCDecrypter(c, tt.iv)\n \t\tp := make([]byte, len(d))\n \t\tdecrypter.CryptBlocks(p, d)\n \t\tif !bytes.Equal(tt.in, p) {"}, {"sha": "f704b337e4bd006834c6a06f48f1c27b121afc5e", "filename": "libgo/go/crypto/cipher/cfb_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,11 +2,12 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package cipher\n+package cipher_test\n \n import (\n \t\"bytes\"\n \t\"crypto/aes\"\n+\t\"crypto/cipher\"\n \t\"crypto/rand\"\n \t\"testing\"\n )\n@@ -21,11 +22,11 @@ func TestCFB(t *testing.T) {\n \tplaintext := []byte(\"this is the plaintext\")\n \tiv := make([]byte, block.BlockSize())\n \trand.Reader.Read(iv)\n-\tcfb := NewCFBEncrypter(block, iv)\n+\tcfb := cipher.NewCFBEncrypter(block, iv)\n \tciphertext := make([]byte, len(plaintext))\n \tcfb.XORKeyStream(ciphertext, plaintext)\n \n-\tcfbdec := NewCFBDecrypter(block, iv)\n+\tcfbdec := cipher.NewCFBDecrypter(block, iv)\n \tplaintextCopy := make([]byte, len(plaintext))\n \tcfbdec.XORKeyStream(plaintextCopy, ciphertext)\n "}, {"sha": "c75c919d1758078aa280e712b205dd66b40db614", "filename": "libgo/go/crypto/cipher/common_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcommon_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcommon_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcommon_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package cipher\n+package cipher_test\n \n // Common values for tests.\n "}, {"sha": "d019ae0d022eb803e6a00ca74e23bad5b973ea58", "filename": "libgo/go/crypto/cipher/ctr_aes_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr_aes_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,11 +8,12 @@\n // Special Publication 800-38A, ``Recommendation for Block Cipher\n // Modes of Operation,'' 2001 Edition, pp. 55-58.\n \n-package cipher\n+package cipher_test\n \n import (\n \t\"bytes\"\n \t\"crypto/aes\"\n+\t\"crypto/cipher\"\n \t\"testing\"\n )\n \n@@ -76,7 +77,7 @@ func TestCTR_AES(t *testing.T) {\n \n \t\tfor j := 0; j <= 5; j += 5 {\n \t\t\tin := tt.in[0 : len(tt.in)-j]\n-\t\t\tctr := NewCTR(c, tt.iv)\n+\t\t\tctr := cipher.NewCTR(c, tt.iv)\n \t\t\tencrypted := make([]byte, len(in))\n \t\t\tctr.XORKeyStream(encrypted, in)\n \t\t\tif out := tt.out[0:len(in)]; !bytes.Equal(out, encrypted) {\n@@ -86,7 +87,7 @@ func TestCTR_AES(t *testing.T) {\n \n \t\tfor j := 0; j <= 7; j += 7 {\n \t\t\tin := tt.out[0 : len(tt.out)-j]\n-\t\t\tctr := NewCTR(c, tt.iv)\n+\t\t\tctr := cipher.NewCTR(c, tt.iv)\n \t\t\tplain := make([]byte, len(in))\n \t\t\tctr.XORKeyStream(plain, in)\n \t\t\tif out := tt.in[0:len(in)]; !bytes.Equal(out, plain) {"}, {"sha": "8d3c5d3a3899bdb0510deb5147fda2fd2c48c439", "filename": "libgo/go/crypto/cipher/ofb_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fofb_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,11 +8,12 @@\n // Special Publication 800-38A, ``Recommendation for Block Cipher\n // Modes of Operation,'' 2001 Edition, pp. 52-55.\n \n-package cipher\n+package cipher_test\n \n import (\n \t\"bytes\"\n \t\"crypto/aes\"\n+\t\"crypto/cipher\"\n \t\"testing\"\n )\n \n@@ -76,7 +77,7 @@ func TestOFB(t *testing.T) {\n \n \t\tfor j := 0; j <= 5; j += 5 {\n \t\t\tplaintext := tt.in[0 : len(tt.in)-j]\n-\t\t\tofb := NewOFB(c, tt.iv)\n+\t\t\tofb := cipher.NewOFB(c, tt.iv)\n \t\t\tciphertext := make([]byte, len(plaintext))\n \t\t\tofb.XORKeyStream(ciphertext, plaintext)\n \t\t\tif !bytes.Equal(ciphertext, tt.out[:len(plaintext)]) {\n@@ -86,7 +87,7 @@ func TestOFB(t *testing.T) {\n \n \t\tfor j := 0; j <= 5; j += 5 {\n \t\t\tciphertext := tt.out[0 : len(tt.in)-j]\n-\t\t\tofb := NewOFB(c, tt.iv)\n+\t\t\tofb := cipher.NewOFB(c, tt.iv)\n \t\t\tplaintext := make([]byte, len(ciphertext))\n \t\t\tofb.XORKeyStream(plaintext, ciphertext)\n \t\t\tif !bytes.Equal(plaintext, tt.in[:len(ciphertext)]) {"}, {"sha": "c11c62cd7239e30e7139fba3e32eb63fe98d512b", "filename": "libgo/go/crypto/des/block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -79,7 +79,7 @@ func ksRotate(in uint32) (out []uint32) {\n }\n \n // creates 16 56-bit subkeys from the original key\n-func (c *Cipher) generateSubkeys(keyBytes []byte) {\n+func (c *desCipher) generateSubkeys(keyBytes []byte) {\n \t// apply PC1 permutation to key\n \tkey := binary.BigEndian.Uint64(keyBytes)\n \tpermutedKey := permuteBlock(key, permutedChoice1[:])"}, {"sha": "2f929ca7bed0356e337c85699ebb1d153ef6f4d7", "filename": "libgo/go/crypto/des/cipher.go", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -4,7 +4,10 @@\n \n package des\n \n-import \"strconv\"\n+import (\n+\t\"crypto/cipher\"\n+\t\"strconv\"\n+)\n \n // The DES block size in bytes.\n const BlockSize = 8\n@@ -15,86 +18,56 @@ func (k KeySizeError) Error() string {\n \treturn \"crypto/des: invalid key size \" + strconv.Itoa(int(k))\n }\n \n-// Cipher is an instance of DES encryption.\n-type Cipher struct {\n+// desCipher is an instance of DES encryption.\n+type desCipher struct {\n \tsubkeys [16]uint64\n }\n \n-// NewCipher creates and returns a new Cipher.\n-func NewCipher(key []byte) (*Cipher, error) {\n+// NewCipher creates and returns a new cipher.Block.\n+func NewCipher(key []byte) (cipher.Block, error) {\n \tif len(key) != 8 {\n \t\treturn nil, KeySizeError(len(key))\n \t}\n \n-\tc := new(Cipher)\n+\tc := new(desCipher)\n \tc.generateSubkeys(key)\n \treturn c, nil\n }\n \n-// BlockSize returns the DES block size, 8 bytes.\n-func (c *Cipher) BlockSize() int { return BlockSize }\n+func (c *desCipher) BlockSize() int { return BlockSize }\n \n-// Encrypt encrypts the 8-byte buffer src and stores the result in dst.\n-// Note that for amounts of data larger than a block,\n-// it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n-func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c.subkeys[:], dst, src) }\n+func (c *desCipher) Encrypt(dst, src []byte) { encryptBlock(c.subkeys[:], dst, src) }\n \n-// Decrypt decrypts the 8-byte buffer src and stores the result in dst.\n-func (c *Cipher) Decrypt(dst, src []byte) { decryptBlock(c.subkeys[:], dst, src) }\n+func (c *desCipher) Decrypt(dst, src []byte) { decryptBlock(c.subkeys[:], dst, src) }\n \n-// Reset zeros the key data, so that it will no longer\n-// appear in the process's memory.\n-func (c *Cipher) Reset() {\n-\tfor i := 0; i < len(c.subkeys); i++ {\n-\t\tc.subkeys[i] = 0\n-\t}\n-}\n-\n-// A TripleDESCipher is an instance of TripleDES encryption.\n-type TripleDESCipher struct {\n-\tcipher1, cipher2, cipher3 Cipher\n+// A tripleDESCipher is an instance of TripleDES encryption.\n+type tripleDESCipher struct {\n+\tcipher1, cipher2, cipher3 desCipher\n }\n \n-// NewCipher creates and returns a new Cipher.\n-func NewTripleDESCipher(key []byte) (*TripleDESCipher, error) {\n+// NewTripleDESCipher creates and returns a new cipher.Block.\n+func NewTripleDESCipher(key []byte) (cipher.Block, error) {\n \tif len(key) != 24 {\n \t\treturn nil, KeySizeError(len(key))\n \t}\n \n-\tc := new(TripleDESCipher)\n+\tc := new(tripleDESCipher)\n \tc.cipher1.generateSubkeys(key[:8])\n \tc.cipher2.generateSubkeys(key[8:16])\n \tc.cipher3.generateSubkeys(key[16:])\n \treturn c, nil\n }\n \n-// BlockSize returns the TripleDES block size, 8 bytes.\n-// It is necessary to satisfy the Block interface in the\n-// package \"crypto/cipher\".\n-func (c *TripleDESCipher) BlockSize() int { return BlockSize }\n+func (c *tripleDESCipher) BlockSize() int { return BlockSize }\n \n-// Encrypts the 8-byte buffer src and stores the result in dst.\n-// Note that for amounts of data larger than a block,\n-// it is not safe to just call Encrypt on successive blocks;\n-// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n-func (c *TripleDESCipher) Encrypt(dst, src []byte) {\n+func (c *tripleDESCipher) Encrypt(dst, src []byte) {\n \tc.cipher1.Encrypt(dst, src)\n \tc.cipher2.Decrypt(dst, dst)\n \tc.cipher3.Encrypt(dst, dst)\n }\n \n-// Decrypts the 8-byte buffer src and stores the result in dst.\n-func (c *TripleDESCipher) Decrypt(dst, src []byte) {\n+func (c *tripleDESCipher) Decrypt(dst, src []byte) {\n \tc.cipher3.Decrypt(dst, src)\n \tc.cipher2.Encrypt(dst, dst)\n \tc.cipher1.Decrypt(dst, dst)\n }\n-\n-// Reset zeros the key data, so that it will no longer\n-// appear in the process's memory.\n-func (c *TripleDESCipher) Reset() {\n-\tc.cipher1.Reset()\n-\tc.cipher2.Reset()\n-\tc.cipher3.Reset()\n-}"}, {"sha": "e9fc236299ef630d4a3b6ec5607b253e0835aded", "filename": "libgo/go/crypto/des/des_test.go", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -1260,11 +1260,19 @@ var tableA4Tests = []CryptTest{\n \t\t[]byte{0x63, 0xfa, 0xc0, 0xd0, 0x34, 0xd9, 0xf7, 0x93}},\n }\n \n+func newCipher(key []byte) *desCipher {\n+\tc, err := NewCipher(key)\n+\tif err != nil {\n+\t\tpanic(\"NewCipher failed: \" + err.Error())\n+\t}\n+\treturn c.(*desCipher)\n+}\n+\n // Use the known weak keys to test DES implementation\n func TestWeakKeys(t *testing.T) {\n \tfor i, tt := range weakKeyTests {\n \t\tvar encrypt = func(in []byte) (out []byte) {\n-\t\t\tc, _ := NewCipher(tt.key)\n+\t\t\tc := newCipher(tt.key)\n \t\t\tout = make([]byte, len(in))\n \t\t\tencryptBlock(c.subkeys[:], out, in)\n \t\t\treturn\n@@ -1285,7 +1293,7 @@ func TestWeakKeys(t *testing.T) {\n func TestSemiWeakKeyPairs(t *testing.T) {\n \tfor i, tt := range semiWeakKeyTests {\n \t\tvar encrypt = func(key, in []byte) (out []byte) {\n-\t\t\tc, _ := NewCipher(key)\n+\t\t\tc := newCipher(key)\n \t\t\tout = make([]byte, len(in))\n \t\t\tencryptBlock(c.subkeys[:], out, in)\n \t\t\treturn\n@@ -1305,7 +1313,7 @@ func TestSemiWeakKeyPairs(t *testing.T) {\n \n func TestDESEncryptBlock(t *testing.T) {\n \tfor i, tt := range encryptDESTests {\n-\t\tc, _ := NewCipher(tt.key)\n+\t\tc := newCipher(tt.key)\n \t\tout := make([]byte, len(tt.in))\n \t\tencryptBlock(c.subkeys[:], out, tt.in)\n \n@@ -1317,7 +1325,7 @@ func TestDESEncryptBlock(t *testing.T) {\n \n func TestDESDecryptBlock(t *testing.T) {\n \tfor i, tt := range encryptDESTests {\n-\t\tc, _ := NewCipher(tt.key)\n+\t\tc := newCipher(tt.key)\n \t\tplain := make([]byte, len(tt.in))\n \t\tdecryptBlock(c.subkeys[:], plain, tt.out)\n "}, {"sha": "f7c47831790d9d059e53a90ceb89a154b8074117", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -29,17 +29,11 @@ type PrivateKey struct {\n \tX *big.Int\n }\n \n-type invalidPublicKeyError int\n-\n-func (invalidPublicKeyError) Error() string {\n-\treturn \"crypto/dsa: invalid public key\"\n-}\n-\n // ErrInvalidPublicKey results when a public key is not usable by this code.\n // FIPS is quite strict about the format of DSA keys, but other code may be\n // less so. Thus, when using keys which may have been generated by other code,\n // this error must be handled.\n-var ErrInvalidPublicKey error = invalidPublicKeyError(0)\n+var ErrInvalidPublicKey = errors.New(\"crypto/dsa: invalid public key\")\n \n // ParameterSizes is a enumeration of the acceptable bit lengths of the primes\n // in a set of DSA parameters. See FIPS 186-3, section 4.2."}, {"sha": "be3a5a221d7d8e61ed5ca39f754265d79885ad16", "filename": "libgo/go/crypto/rand/rand_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -22,7 +22,7 @@ func TestRead(t *testing.T) {\n \t}\n \n \tvar z bytes.Buffer\n-\tf := flate.NewWriter(&z, 5)\n+\tf, _ := flate.NewWriter(&z, 5)\n \tf.Write(b)\n \tf.Close()\n \tif z.Len() < len(b)*99/100 {"}, {"sha": "5eb4cda2b3a522e31f495553c9719dee3d95228f", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,6 +12,7 @@ package rand\n import (\n \t\"bufio\"\n \t\"crypto/aes\"\n+\t\"crypto/cipher\"\n \t\"io\"\n \t\"os\"\n \t\"sync\"\n@@ -66,7 +67,7 @@ func newReader(entropy io.Reader) io.Reader {\n type reader struct {\n \tmu                   sync.Mutex\n \tbudget               int // number of bytes that can be generated\n-\tcipher               *aes.Cipher\n+\tcipher               cipher.Block\n \tentropy              io.Reader\n \ttime, seed, dst, key [aes.BlockSize]byte\n }"}, {"sha": "254f4a3da04203ff0a7b5a2b6be4ee667f9d1654", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -21,7 +21,7 @@ import (\n func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error) {\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-11 {\n-\t\terr = MessageTooLongError{}\n+\t\terr = ErrMessageTooLong\n \t\treturn\n \t}\n \n@@ -47,7 +47,7 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error) {\n \tvalid, out, err := decryptPKCS1v15(rand, priv, ciphertext)\n \tif err == nil && valid == 0 {\n-\t\terr = DecryptionError{}\n+\t\terr = ErrDecryption\n \t}\n \n \treturn\n@@ -69,7 +69,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out [\n func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k-(len(key)+3+8) < 0 {\n-\t\terr = DecryptionError{}\n+\t\terr = ErrDecryption\n \t\treturn\n \t}\n \n@@ -86,7 +86,7 @@ func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []by\n func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid int, msg []byte, err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k < 11 {\n-\t\terr = DecryptionError{}\n+\t\terr = ErrDecryption\n \t\treturn\n \t}\n \n@@ -170,7 +170,7 @@ func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []b\n \ttLen := len(prefix) + hashLen\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k < tLen+11 {\n-\t\treturn nil, MessageTooLongError{}\n+\t\treturn nil, ErrMessageTooLong\n \t}\n \n \t// EM = 0x00 || 0x01 || PS || 0x00 || T\n@@ -203,7 +203,7 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n \ttLen := len(prefix) + hashLen\n \tk := (pub.N.BitLen() + 7) / 8\n \tif k < tLen+11 {\n-\t\terr = VerificationError{}\n+\t\terr = ErrVerification\n \t\treturn\n \t}\n \n@@ -223,7 +223,7 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n \t}\n \n \tif ok != 1 {\n-\t\treturn VerificationError{}\n+\t\treturn ErrVerification\n \t}\n \n \treturn nil"}, {"sha": "ec77e68696b4b366e59079a57117c9b41160b799", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -206,13 +206,9 @@ func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {\n \t}\n }\n \n-// MessageTooLongError is returned when attempting to encrypt a message which\n-// is too large for the size of the public key.\n-type MessageTooLongError struct{}\n-\n-func (MessageTooLongError) Error() string {\n-\treturn \"message too long for RSA public key size\"\n-}\n+// ErrMessageTooLong is returned when attempting to encrypt a message which is\n+// too large for the size of the public key.\n+var ErrMessageTooLong = errors.New(\"crypto/rsa: message too long for RSA public key size\")\n \n func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {\n \te := big.NewInt(int64(pub.E))\n@@ -227,7 +223,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \thash.Reset()\n \tk := (pub.N.BitLen() + 7) / 8\n \tif len(msg) > k-2*hash.Size()-2 {\n-\t\terr = MessageTooLongError{}\n+\t\terr = ErrMessageTooLong\n \t\treturn\n \t}\n \n@@ -266,17 +262,13 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l\n \treturn\n }\n \n-// A DecryptionError represents a failure to decrypt a message.\n+// ErrDecryption represents a failure to decrypt a message.\n // It is deliberately vague to avoid adaptive attacks.\n-type DecryptionError struct{}\n+var ErrDecryption = errors.New(\"crypto/rsa: decryption error\")\n \n-func (DecryptionError) Error() string { return \"RSA decryption error\" }\n-\n-// A VerificationError represents a failure to verify a signature.\n+// ErrVerification represents a failure to verify a signature.\n // It is deliberately vague to avoid adaptive attacks.\n-type VerificationError struct{}\n-\n-func (VerificationError) Error() string { return \"RSA verification error\" }\n+var ErrVerification = errors.New(\"crypto/rsa: verification error\")\n \n // modInverse returns ia, the inverse of a in the multiplicative group of prime\n // order n. It requires that a be a member of the group (i.e. less than n).\n@@ -338,7 +330,7 @@ func (priv *PrivateKey) Precompute() {\n func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err error) {\n \t// TODO(agl): can we get away with reusing blinds?\n \tif c.Cmp(priv.N) > 0 {\n-\t\terr = DecryptionError{}\n+\t\terr = ErrDecryption\n \t\treturn\n \t}\n \n@@ -417,7 +409,7 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext\n \tk := (priv.N.BitLen() + 7) / 8\n \tif len(ciphertext) > k ||\n \t\tk < hash.Size()*2+2 {\n-\t\terr = DecryptionError{}\n+\t\terr = ErrDecryption\n \t\treturn\n \t}\n \n@@ -473,7 +465,7 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext\n \t}\n \n \tif firstByteIsZero&lHash2Good&^invalid&^lookingForIndex != 1 {\n-\t\terr = DecryptionError{}\n+\t\terr = ErrDecryption\n \t\treturn\n \t}\n "}, {"sha": "2a5115dc6aba08975723379632dd4a9b77180ce5", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -87,9 +87,9 @@ func (c *Conn) RemoteAddr() net.Addr {\n \treturn c.conn.RemoteAddr()\n }\n \n-// SetDeadline sets the read deadline associated with the connection.\n-// There is no write deadline.\n-// A zero value for t means Read will not time out.\n+// SetDeadline sets the read and write deadlines associated with the connection.\n+// A zero value for t means Read and Write will not time out.\n+// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.\n func (c *Conn) SetDeadline(t time.Time) error {\n \treturn c.conn.SetDeadline(t)\n }\n@@ -100,10 +100,11 @@ func (c *Conn) SetReadDeadline(t time.Time) error {\n \treturn c.conn.SetReadDeadline(t)\n }\n \n-// SetWriteDeadline exists to satisfy the net.Conn interface\n-// but is not implemented by TLS.  It always returns an error.\n+// SetWriteDeadline sets the write deadline on the underlying conneciton.\n+// A zero value for t means Write will not time out.\n+// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.\n func (c *Conn) SetWriteDeadline(t time.Time) error {\n-\treturn errors.New(\"TLS does not support SetWriteDeadline\")\n+\treturn c.conn.SetWriteDeadline(t)\n }\n \n // A halfConn represents one direction of the record layer\n@@ -726,9 +727,13 @@ func (c *Conn) readHandshake() (interface{}, error) {\n }\n \n // Write writes data to the connection.\n-func (c *Conn) Write(b []byte) (n int, err error) {\n-\tif err = c.Handshake(); err != nil {\n-\t\treturn\n+func (c *Conn) Write(b []byte) (int, error) {\n+\tif c.err != nil {\n+\t\treturn 0, c.err\n+\t}\n+\n+\tif c.err = c.Handshake(); c.err != nil {\n+\t\treturn 0, c.err\n \t}\n \n \tc.out.Lock()\n@@ -737,10 +742,10 @@ func (c *Conn) Write(b []byte) (n int, err error) {\n \tif !c.handshakeComplete {\n \t\treturn 0, alertInternalError\n \t}\n-\tif c.err != nil {\n-\t\treturn 0, c.err\n-\t}\n-\treturn c.writeRecord(recordTypeApplicationData, b)\n+\n+\tvar n int\n+\tn, c.err = c.writeRecord(recordTypeApplicationData, b)\n+\treturn n, c.err\n }\n \n // Read can be made to time out and return a net.Error with Timeout() == true"}, {"sha": "84be5bfd856c3ea35537a3f80b357086f38b1d27", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Generate a self-signed X.509 certificate for a TLS server. Outputs to\n // 'cert.pem' and 'key.pem' and will overwrite existing files.\n "}, {"sha": "8c56daaf619331381c5cad787790bac0e0e257b7", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -62,7 +62,7 @@ func TestRunClient(t *testing.T) {\n \n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in client mode:\n-//   % gotest -test.run \"TestRunClient\" -connect\n+//   % go test -run \"TestRunClient\" -connect\n // and then:\n //   % gnutls-serv -p 10443 --debug 100 --x509keyfile key.pem --x509certfile cert.pem -a > /tmp/log 2>&1\n //   % python parse-gnutls-cli-debug-log.py < /tmp/log"}, {"sha": "bd31d31ae1adad4021d7b65d9d46b1f87b7ee61f", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -284,7 +284,7 @@ func loadPEMCert(in string) *x509.Certificate {\n \n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in server mode:\n-//   % gotest -test.run \"TestRunServer\" -serve\n+//   % go test -run \"TestRunServer\" -serve\n // and then:\n //   % gnutls-cli --insecure --debug 100 -p 10443 localhost > /tmp/log 2>&1\n //   % python parse-gnutls-cli-debug-log.py < /tmp/log\n@@ -949,7 +949,7 @@ var sslv3ServerScript = [][]byte{\n \n var clientauthTests = []clientauthTest{\n \t// Server doesn't asks for cert\n-\t// gotest -test.run \"TestRunServer\" -serve -clientauth 0\n+\t// go test -run \"TestRunServer\" -serve -clientauth 0\n \t// gnutls-cli --insecure --debug 100 -p 10443 localhost 2>&1 |\n \t//   python parse-gnutls-cli-debug-log.py\n \t{\"NoClientCert\", NoClientCert, nil,\n@@ -1115,7 +1115,7 @@ var clientauthTests = []clientauthTest{\n \t\t\t\t0x03, 0x11, 0x43, 0x3e, 0xee, 0xb7, 0x4d, 0x69,\n \t\t\t}}},\n \t// Server asks for cert with empty CA list, client doesn't give it.\n-\t// gotest -test.run \"TestRunServer\" -serve -clientauth 1\n+\t// go test -run \"TestRunServer\" -serve -clientauth 1\n \t// gnutls-cli --insecure --debug 100 -p 10443 localhost\n \t{\"RequestClientCert, none given\", RequestClientCert, nil,\n \t\t[][]byte{{\n@@ -1282,7 +1282,7 @@ var clientauthTests = []clientauthTest{\n \t\t\t\t0xf4, 0x70, 0xcc, 0xb4, 0xed, 0x07, 0x76, 0x3a,\n \t\t\t}}},\n \t// Server asks for cert with empty CA list, client gives one\n-\t// gotest -test.run \"TestRunServer\" -serve -clientauth 1\n+\t// go test -run \"TestRunServer\" -serve -clientauth 1\n \t// gnutls-cli --insecure --debug 100 -p 10443 localhost\n \t{\"RequestClientCert, client gives it\", RequestClientCert,\n \t\t[]*x509.Certificate{clicert},"}, {"sha": "3116525d33d270bde4c822aa174f663b34362da7", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -327,21 +327,17 @@ type Certificate struct {\n \tPolicyIdentifiers []asn1.ObjectIdentifier\n }\n \n-// UnsupportedAlgorithmError results from attempting to perform an operation\n-// that involves algorithms that are not currently implemented.\n-type UnsupportedAlgorithmError struct{}\n-\n-func (UnsupportedAlgorithmError) Error() string {\n-\treturn \"cannot verify signature: algorithm unimplemented\"\n-}\n+// ErrUnsupportedAlgorithm results from attempting to perform an operation that\n+// involves algorithms that are not currently implemented.\n+var ErrUnsupportedAlgorithm = errors.New(\"crypto/x509: cannot verify signature: algorithm unimplemented\")\n \n // ConstraintViolationError results when a requested usage is not permitted by\n // a certificate. For example: checking a signature when the public key isn't a\n // certificate signing key.\n type ConstraintViolationError struct{}\n \n func (ConstraintViolationError) Error() string {\n-\treturn \"invalid signature: parent certificate cannot sign this kind of certificate\"\n+\treturn \"crypto/x509: invalid signature: parent certificate cannot sign this kind of certificate\"\n }\n \n func (c *Certificate) Equal(other *Certificate) bool {\n@@ -366,7 +362,7 @@ func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error) {\n \t}\n \n \tif parent.PublicKeyAlgorithm == UnknownPublicKeyAlgorithm {\n-\t\treturn UnsupportedAlgorithmError{}\n+\t\treturn ErrUnsupportedAlgorithm\n \t}\n \n \t// TODO(agl): don't ignore the path length constraint.\n@@ -389,12 +385,12 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \tcase SHA512WithRSA:\n \t\thashType = crypto.SHA512\n \tdefault:\n-\t\treturn UnsupportedAlgorithmError{}\n+\t\treturn ErrUnsupportedAlgorithm\n \t}\n \n \th := hashType.New()\n \tif h == nil {\n-\t\treturn UnsupportedAlgorithmError{}\n+\t\treturn ErrUnsupportedAlgorithm\n \t}\n \n \th.Write(signed)\n@@ -416,7 +412,7 @@ func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature\n \t\t}\n \t\treturn\n \t}\n-\treturn UnsupportedAlgorithmError{}\n+\treturn ErrUnsupportedAlgorithm\n }\n \n // CheckCRLSignature checks that the signature in crl is from c.\n@@ -795,7 +791,7 @@ var (\n )\n \n func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n-\tret = make([]pkix.Extension, 7 /* maximum number of elements. */ )\n+\tret = make([]pkix.Extension, 7 /* maximum number of elements. */)\n \tn := 0\n \n \tif template.KeyUsage != 0 {"}, {"sha": "4afa2bef753a217d2edeb9d0fa0ddadc5796befd", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -90,8 +90,8 @@ func convertAssign(dest, src interface{}) error {\n \t\treturn nil\n \t}\n \n-\tif scanner, ok := dest.(ScannerInto); ok {\n-\t\treturn scanner.ScanInto(src)\n+\tif scanner, ok := dest.(Scanner); ok {\n+\t\treturn scanner.Scan(src)\n \t}\n \n \tdpv := reflect.ValueOf(dest)\n@@ -110,6 +110,14 @@ func convertAssign(dest, src interface{}) error {\n \t}\n \n \tswitch dv.Kind() {\n+\tcase reflect.Ptr:\n+\t\tif src == nil {\n+\t\t\tdv.Set(reflect.Zero(dv.Type()))\n+\t\t\treturn nil\n+\t\t} else {\n+\t\t\tdv.Set(reflect.New(dv.Type().Elem()))\n+\t\t\treturn convertAssign(dv.Interface(), src)\n+\t\t}\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\ts := asString(src)\n \t\ti64, err := strconv.ParseInt(s, 10, dv.Type().Bits())"}, {"sha": "9c362d7320a17bf7c3e759abb92bfa0b143c5756", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -13,6 +13,7 @@ import (\n )\n \n var someTime = time.Unix(123, 0)\n+var answer int64 = 42\n \n type conversionTest struct {\n \ts, d interface{} // source and destination\n@@ -27,6 +28,8 @@ type conversionTest struct {\n \twantbool  bool // used if d is of type *bool\n \twanterr   string\n \twantiface interface{}\n+\twantptr   *int64 // if non-nil, *d's pointed value must be equal to *wantptr\n+\twantnil   bool   // if true, *d must be *int64(nil)\n }\n \n // Target variables for scanning into.\n@@ -42,6 +45,7 @@ var (\n \tscanf32    float32\n \tscanf64    float64\n \tscantime   time.Time\n+\tscanptr    *int64\n \tscaniface  interface{}\n )\n \n@@ -98,6 +102,10 @@ var conversionTests = []conversionTest{\n \t{s: \"1.5\", d: &scanf32, wantf32: float32(1.5)},\n \t{s: \"1.5\", d: &scanf64, wantf64: float64(1.5)},\n \n+\t// Pointers\n+\t{s: interface{}(nil), d: &scanptr, wantnil: true},\n+\t{s: int64(42), d: &scanptr, wantptr: &answer},\n+\n \t// To interface{}\n \t{s: float64(1.5), d: &scaniface, wantiface: float64(1.5)},\n \t{s: int64(1), d: &scaniface, wantiface: int64(1)},\n@@ -107,6 +115,10 @@ var conversionTests = []conversionTest{\n \t{s: nil, d: &scaniface},\n }\n \n+func intPtrValue(intptr interface{}) interface{} {\n+\treturn reflect.Indirect(reflect.Indirect(reflect.ValueOf(intptr))).Int()\n+}\n+\n func intValue(intptr interface{}) int64 {\n \treturn reflect.Indirect(reflect.ValueOf(intptr)).Int()\n }\n@@ -162,6 +174,16 @@ func TestConversions(t *testing.T) {\n \t\tif !ct.wanttime.IsZero() && !ct.wanttime.Equal(timeValue(ct.d)) {\n \t\t\terrf(\"want time %v, got %v\", ct.wanttime, timeValue(ct.d))\n \t\t}\n+\t\tif ct.wantnil && *ct.d.(**int64) != nil {\n+\t\t\terrf(\"want nil, got %v\", intPtrValue(ct.d))\n+\t\t}\n+\t\tif ct.wantptr != nil {\n+\t\t\tif *ct.d.(**int64) == nil {\n+\t\t\t\terrf(\"want pointer to %v, got nil\", *ct.wantptr)\n+\t\t\t} else if *ct.wantptr != intPtrValue(ct.d) {\n+\t\t\t\terrf(\"want pointer to %v, got %v\", *ct.wantptr, intPtrValue(ct.d))\n+\t\t\t}\n+\t\t}\n \t\tif ifptr, ok := ct.d.(*interface{}); ok {\n \t\t\tif !reflect.DeepEqual(ct.wantiface, scaniface) {\n \t\t\t\terrf(\"want interface %#v, got %#v\", ct.wantiface, scaniface)"}, {"sha": "ce3c943ead27170b7105f260e97cd0cf407b1647", "filename": "libgo/go/database/sql/driver/types.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -248,6 +248,13 @@ func (defaultConverter) ConvertValue(v interface{}) (interface{}, error) {\n \n \trv := reflect.ValueOf(v)\n \tswitch rv.Kind() {\n+\tcase reflect.Ptr:\n+\t\t// indirect pointers\n+\t\tif rv.IsNil() {\n+\t\t\treturn nil, nil\n+\t\t} else {\n+\t\t\treturn defaultConverter{}.ConvertValue(rv.Elem().Interface())\n+\t\t}\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\treturn rv.Int(), nil\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:"}, {"sha": "ab82bca7166e3ce7b466c317e91c6f015bcf7723", "filename": "libgo/go/database/sql/driver/types_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Ftypes_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -18,6 +18,7 @@ type valueConverterTest struct {\n }\n \n var now = time.Now()\n+var answer int64 = 42\n \n var valueConverterTests = []valueConverterTest{\n \t{Bool, \"true\", true, \"\"},\n@@ -37,6 +38,9 @@ var valueConverterTests = []valueConverterTest{\n \t{c: Bool, in: \"foo\", err: \"sql/driver: couldn't convert \\\"foo\\\" into type bool\"},\n \t{c: Bool, in: 2, err: \"sql/driver: couldn't convert 2 into type bool\"},\n \t{DefaultParameterConverter, now, now, \"\"},\n+\t{DefaultParameterConverter, (*int64)(nil), nil, \"\"},\n+\t{DefaultParameterConverter, &answer, answer, \"\"},\n+\t{DefaultParameterConverter, &now, now, \"\"},\n }\n \n func TestValueConverters(t *testing.T) {"}, {"sha": "f14a98c3cf29eb4a484a50b0094df500f93315fc", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -35,7 +35,7 @@ func Register(name string, driver driver.Driver) {\n type RawBytes []byte\n \n // NullString represents a string that may be null.\n-// NullString implements the ScannerInto interface so\n+// NullString implements the Scanner interface so\n // it can be used as a scan destination:\n //\n //  var s NullString\n@@ -52,8 +52,8 @@ type NullString struct {\n \tValid  bool // Valid is true if String is not NULL\n }\n \n-// ScanInto implements the ScannerInto interface.\n-func (ns *NullString) ScanInto(value interface{}) error {\n+// Scan implements the Scanner interface.\n+func (ns *NullString) Scan(value interface{}) error {\n \tif value == nil {\n \t\tns.String, ns.Valid = \"\", false\n \t\treturn nil\n@@ -71,15 +71,15 @@ func (ns NullString) SubsetValue() (interface{}, error) {\n }\n \n // NullInt64 represents an int64 that may be null.\n-// NullInt64 implements the ScannerInto interface so\n+// NullInt64 implements the Scanner interface so\n // it can be used as a scan destination, similar to NullString.\n type NullInt64 struct {\n \tInt64 int64\n \tValid bool // Valid is true if Int64 is not NULL\n }\n \n-// ScanInto implements the ScannerInto interface.\n-func (n *NullInt64) ScanInto(value interface{}) error {\n+// Scan implements the Scanner interface.\n+func (n *NullInt64) Scan(value interface{}) error {\n \tif value == nil {\n \t\tn.Int64, n.Valid = 0, false\n \t\treturn nil\n@@ -97,15 +97,15 @@ func (n NullInt64) SubsetValue() (interface{}, error) {\n }\n \n // NullFloat64 represents a float64 that may be null.\n-// NullFloat64 implements the ScannerInto interface so\n+// NullFloat64 implements the Scanner interface so\n // it can be used as a scan destination, similar to NullString.\n type NullFloat64 struct {\n \tFloat64 float64\n \tValid   bool // Valid is true if Float64 is not NULL\n }\n \n-// ScanInto implements the ScannerInto interface.\n-func (n *NullFloat64) ScanInto(value interface{}) error {\n+// Scan implements the Scanner interface.\n+func (n *NullFloat64) Scan(value interface{}) error {\n \tif value == nil {\n \t\tn.Float64, n.Valid = 0, false\n \t\treturn nil\n@@ -123,15 +123,15 @@ func (n NullFloat64) SubsetValue() (interface{}, error) {\n }\n \n // NullBool represents a bool that may be null.\n-// NullBool implements the ScannerInto interface so\n+// NullBool implements the Scanner interface so\n // it can be used as a scan destination, similar to NullString.\n type NullBool struct {\n \tBool  bool\n \tValid bool // Valid is true if Bool is not NULL\n }\n \n-// ScanInto implements the ScannerInto interface.\n-func (n *NullBool) ScanInto(value interface{}) error {\n+// Scan implements the Scanner interface.\n+func (n *NullBool) Scan(value interface{}) error {\n \tif value == nil {\n \t\tn.Bool, n.Valid = false, false\n \t\treturn nil\n@@ -148,22 +148,24 @@ func (n NullBool) SubsetValue() (interface{}, error) {\n \treturn n.Bool, nil\n }\n \n-// ScannerInto is an interface used by Scan.\n-type ScannerInto interface {\n-\t// ScanInto assigns a value from a database driver.\n+// Scanner is an interface used by Scan.\n+type Scanner interface {\n+\t// Scan assigns a value from a database driver.\n \t//\n-\t// The value will be of one of the following restricted\n+\t// The src value will be of one of the following restricted\n \t// set of types:\n \t//\n \t//    int64\n \t//    float64\n \t//    bool\n \t//    []byte\n+\t//    string\n+\t//    time.Time\n \t//    nil - for NULL values\n \t//\n \t// An error should be returned if the value can not be stored\n \t// without loss of information.\n-\tScanInto(value interface{}) error\n+\tScan(src interface{}) error\n }\n \n // ErrNoRows is returned by Scan when QueryRow doesn't return a\n@@ -368,7 +370,7 @@ func (db *DB) Begin() (*Tx, error) {\n \t}, nil\n }\n \n-// DriverDatabase returns the database's underlying driver.\n+// Driver returns the database's underlying driver.\n func (db *DB) Driver() driver.Driver {\n \treturn db.driver\n }\n@@ -378,7 +380,7 @@ func (db *DB) Driver() driver.Driver {\n // A transaction must end with a call to Commit or Rollback.\n //\n // After a call to Commit or Rollback, all operations on the\n-// transaction fail with ErrTransactionFinished.\n+// transaction fail with ErrTxDone.\n type Tx struct {\n \tdb *DB\n \n@@ -393,11 +395,11 @@ type Tx struct {\n \n \t// done transitions from false to true exactly once, on Commit\n \t// or Rollback. once done, all operations fail with\n-\t// ErrTransactionFinished.\n+\t// ErrTxDone.\n \tdone bool\n }\n \n-var ErrTransactionFinished = errors.New(\"sql: Transaction has already been committed or rolled back\")\n+var ErrTxDone = errors.New(\"sql: Transaction has already been committed or rolled back\")\n \n func (tx *Tx) close() {\n \tif tx.done {\n@@ -411,7 +413,7 @@ func (tx *Tx) close() {\n \n func (tx *Tx) grabConn() (driver.Conn, error) {\n \tif tx.done {\n-\t\treturn nil, ErrTransactionFinished\n+\t\treturn nil, ErrTxDone\n \t}\n \ttx.cimu.Lock()\n \treturn tx.ci, nil\n@@ -424,7 +426,7 @@ func (tx *Tx) releaseConn() {\n // Commit commits the transaction.\n func (tx *Tx) Commit() error {\n \tif tx.done {\n-\t\treturn ErrTransactionFinished\n+\t\treturn ErrTxDone\n \t}\n \tdefer tx.close()\n \treturn tx.txi.Commit()\n@@ -433,7 +435,7 @@ func (tx *Tx) Commit() error {\n // Rollback aborts the transaction.\n func (tx *Tx) Rollback() error {\n \tif tx.done {\n-\t\treturn ErrTransactionFinished\n+\t\treturn ErrTxDone\n \t}\n \tdefer tx.close()\n \treturn tx.txi.Rollback()\n@@ -523,10 +525,12 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \n \tif execer, ok := ci.(driver.Execer); ok {\n \t\tresi, err := execer.Exec(query, args)\n-\t\tif err != nil {\n+\t\tif err == nil {\n+\t\t\treturn result{resi}, nil\n+\t\t}\n+\t\tif err != driver.ErrSkip {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn result{resi}, nil\n \t}\n \n \tsti, err := ci.Prepare(query)\n@@ -550,7 +554,7 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n // Query executes a query that returns rows, typically a SELECT.\n func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error) {\n \tif tx.done {\n-\t\treturn nil, ErrTransactionFinished\n+\t\treturn nil, ErrTxDone\n \t}\n \tstmt, err := tx.Prepare(query)\n \tif err != nil {\n@@ -767,7 +771,7 @@ func (s *Stmt) Query(args ...interface{}) (*Rows, error) {\n // Example usage:\n //\n //  var name string\n-//  err := nameByUseridStmt.QueryRow(id).Scan(&s)\n+//  err := nameByUseridStmt.QueryRow(id).Scan(&name)\n func (s *Stmt) QueryRow(args ...interface{}) *Row {\n \trows, err := s.Query(args...)\n \tif err != nil {"}, {"sha": "c985a10beee627492803d835e1d74ceb807c49a3", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -386,6 +386,38 @@ func TestNullByteSlice(t *testing.T) {\n \t}\n }\n \n+func TestPointerParamsAndScans(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t|id=int32,name=nullstring\")\n+\n+\tbob := \"bob\"\n+\tvar name *string\n+\n+\tname = &bob\n+\texec(t, db, \"INSERT|t|id=10,name=?\", name)\n+\tname = nil\n+\texec(t, db, \"INSERT|t|id=20,name=?\", name)\n+\n+\terr := db.QueryRow(\"SELECT|t|name|id=?\", 10).Scan(&name)\n+\tif err != nil {\n+\t\tt.Fatalf(\"querying id 10: %v\", err)\n+\t}\n+\tif name == nil {\n+\t\tt.Errorf(\"id 10's name = nil; want bob\")\n+\t} else if *name != \"bob\" {\n+\t\tt.Errorf(\"id 10's name = %q; want bob\", *name)\n+\t}\n+\n+\terr = db.QueryRow(\"SELECT|t|name|id=?\", 20).Scan(&name)\n+\tif err != nil {\n+\t\tt.Fatalf(\"querying id 20: %v\", err)\n+\t}\n+\tif name != nil {\n+\t\tt.Errorf(\"id 20 = %q; want nil\", *name)\n+\t}\n+}\n+\n func TestQueryRowClosingStmt(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)"}, {"sha": "fa73a315c77f19910f338016211ba453949db516", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,8 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package macho implements access to Mach-O object files, as defined by\n-// http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html.\n+// Package macho implements access to Mach-O object files.\n package macho\n \n // High level access to low level data structures."}, {"sha": "b26b1bb2c93c13fa1b6557e17dc14e3398417a89", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -5,6 +5,9 @@\n // Package binary implements translation between\n // unsigned integer values and byte sequences\n // and the reading and writing of fixed-size values.\n+// A fixed-size value is either a fixed-size arithmetic\n+// type (int8, uint8, int16, float32, complex64, ...)\n+// or an array or struct containing only fixed-size values.\n package binary\n \n import (\n@@ -119,9 +122,6 @@ func (bigEndian) GoString() string { return \"binary.BigEndian\" }\n // Read reads structured binary data from r into data.\n // Data must be a pointer to a fixed-size value or a slice\n // of fixed-size values.\n-// A fixed-size value is either a fixed-size arithmetic\n-// type (int8, uint8, int16, float32, complex64, ...)\n-// or an array or struct containing only fixed-size values.\n // Bytes read from r are decoded using the specified byte order\n // and written to successive fields of the data.\n func Read(r io.Reader, order ByteOrder, data interface{}) error {\n@@ -176,11 +176,8 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n }\n \n // Write writes the binary representation of data into w.\n-// Data must be a fixed-size value or a pointer to\n-// a fixed-size value.\n-// A fixed-size value is either a fixed-size arithmetic\n-// type (int8, uint8, int16, float32, complex64, ...)\n-// or an array or struct containing only fixed-size values.\n+// Data must be a fixed-size value or a slice of fixed-size\n+// values, or a pointer to such data.\n // Bytes written to w are encoded using the specified byte order\n // and read from successive fields of the data.\n func Write(w io.Writer, order ByteOrder, data interface{}) error {\n@@ -253,6 +250,12 @@ func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \treturn err\n }\n \n+// Size returns how many bytes Write would generate to encode the value v, which\n+// must be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\n+func Size(v interface{}) int {\n+\treturn dataSize(reflect.Indirect(reflect.ValueOf(v)))\n+}\n+\n // dataSize returns the number of bytes the actual data represented by v occupies in memory.\n // For compound structures, it sums the sizes of the elements. Thus, for instance, for a slice\n // it returns the length of the slice times the element size and does not count the memory\n@@ -373,6 +376,7 @@ func (d *decoder) value(v reflect.Value) {\n \t\tfor i := 0; i < l; i++ {\n \t\t\td.value(v.Index(i))\n \t\t}\n+\n \tcase reflect.Struct:\n \t\tl := v.NumField()\n \t\tfor i := 0; i < l; i++ {\n@@ -428,11 +432,13 @@ func (e *encoder) value(v reflect.Value) {\n \t\tfor i := 0; i < l; i++ {\n \t\t\te.value(v.Index(i))\n \t\t}\n+\n \tcase reflect.Struct:\n \t\tl := v.NumField()\n \t\tfor i := 0; i < l; i++ {\n \t\t\te.value(v.Field(i))\n \t\t}\n+\n \tcase reflect.Slice:\n \t\tl := v.Len()\n \t\tfor i := 0; i < l; i++ {"}, {"sha": "750d623cde20c4ed71094a11cd3a53a7787e4fad", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -456,7 +456,7 @@ func allocate(rtyp reflect.Type, p uintptr, indir int) uintptr {\n \t}\n \tif *(*unsafe.Pointer)(up) == nil {\n \t\t// Allocate object.\n-\t\t*(*unsafe.Pointer)(up) = unsafe.New(rtyp)\n+\t\t*(*unsafe.Pointer)(up) = unsafe.Pointer(reflect.New(rtyp).Pointer())\n \t}\n \treturn *(*uintptr)(up)\n }\n@@ -609,7 +609,7 @@ func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p uintptr,\n \t// Maps cannot be accessed by moving addresses around the way\n \t// that slices etc. can.  We must recover a full reflection value for\n \t// the iteration.\n-\tv := reflect.ValueOf(unsafe.Unreflect(mtyp, unsafe.Pointer(p)))\n+\tv := reflect.NewAt(mtyp, unsafe.Pointer(p)).Elem()\n \tn := int(state.decodeUint())\n \tfor i := 0; i < n; i++ {\n \t\tkey := decodeIntoValue(state, keyOp, keyIndir, allocValue(mtyp.Key()), ovfl)\n@@ -662,7 +662,7 @@ func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintpt\n \t// Always write a header at p.\n \thdrp := (*reflect.SliceHeader)(unsafe.Pointer(p))\n \tif hdrp.Cap < n {\n-\t\thdrp.Data = uintptr(unsafe.NewArray(atyp.Elem(), n))\n+\t\thdrp.Data = reflect.MakeSlice(atyp, n, n).Pointer()\n \t\thdrp.Cap = n\n \t}\n \thdrp.Len = n\n@@ -969,16 +969,16 @@ func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) (*decOp, int) {\n \t\t// Caller has gotten us to within one indirection of our value.\n \t\tif i.indir > 0 {\n \t\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t\t*(*unsafe.Pointer)(p) = unsafe.New(ut.base)\n+\t\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(reflect.New(ut.base).Pointer())\n \t\t\t}\n \t\t}\n \t\t// Now p is a pointer to the base type.  Do we need to climb out to\n \t\t// get to the receiver type?\n \t\tvar v reflect.Value\n \t\tif ut.decIndir == -1 {\n-\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rcvrType, unsafe.Pointer(&p)))\n+\t\t\tv = reflect.NewAt(rcvrType, unsafe.Pointer(&p)).Elem()\n \t\t} else {\n-\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rcvrType, p))\n+\t\t\tv = reflect.NewAt(rcvrType, p).Elem()\n \t\t}\n \t\tstate.dec.decodeGobDecoder(state, v)\n \t}"}, {"sha": "e23a11e48bf712c0f4c51e196d9774f6569f5682", "filename": "libgo/go/encoding/gob/dump.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package main\n \n // Need to compile package gob with debug.go to build this program."}, {"sha": "168e08b137a435dac52186cd37968d7bf90d2197", "filename": "libgo/go/encoding/gob/encode.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -590,7 +590,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t\t// Maps cannot be accessed by moving addresses around the way\n \t\t\t\t// that slices etc. can.  We must recover a full reflection value for\n \t\t\t\t// the iteration.\n-\t\t\t\tv := reflect.ValueOf(unsafe.Unreflect(t, unsafe.Pointer(p)))\n+\t\t\t\tv := reflect.NewAt(t, unsafe.Pointer(p)).Elem()\n \t\t\t\tmv := reflect.Indirect(v)\n \t\t\t\t// We send zero-length (but non-nil) maps because the\n \t\t\t\t// receiver might want to use the map.  (Maps don't use append.)\n@@ -613,7 +613,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\t// Interfaces transmit the name and contents of the concrete\n \t\t\t\t// value they contain.\n-\t\t\t\tv := reflect.ValueOf(unsafe.Unreflect(t, unsafe.Pointer(p)))\n+\t\t\t\tv := reflect.NewAt(t, unsafe.Pointer(p)).Elem()\n \t\t\t\tiv := reflect.Indirect(v)\n \t\t\t\tif !state.sendZero && (!iv.IsValid() || iv.IsNil()) {\n \t\t\t\t\treturn\n@@ -645,9 +645,9 @@ func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n \t\tvar v reflect.Value\n \t\tif ut.encIndir == -1 {\n \t\t\t// Need to climb up one level to turn value into pointer.\n-\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rt, unsafe.Pointer(&p)))\n+\t\t\tv = reflect.NewAt(rt, unsafe.Pointer(&p)).Elem()\n \t\t} else {\n-\t\t\tv = reflect.ValueOf(unsafe.Unreflect(rt, p))\n+\t\t\tv = reflect.NewAt(rt, p).Elem()\n \t\t}\n \t\tif !state.sendZero && isZero(v) {\n \t\t\treturn"}, {"sha": "456f9eac72485ff0ee5eb476d2e061860c6ebf99", "filename": "libgo/go/encoding/hex/hex_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -87,7 +87,7 @@ func TestInvalidErr(t *testing.T) {\n \t\tdst := make([]byte, DecodedLen(len(test.in)))\n \t\t_, err := Decode(dst, []byte(test.in))\n \t\tif err == nil {\n-\t\t\tt.Errorf(\"#%d: expected error; got none\")\n+\t\t\tt.Errorf(\"#%d: expected error; got none\", i)\n \t\t} else if err.Error() != test.err {\n \t\t\tt.Errorf(\"#%d: got: %v want: %v\", i, err, test.err)\n \t\t}\n@@ -98,7 +98,7 @@ func TestInvalidStringErr(t *testing.T) {\n \tfor i, test := range errTests {\n \t\t_, err := DecodeString(test.in)\n \t\tif err == nil {\n-\t\t\tt.Errorf(\"#%d: expected error; got none\")\n+\t\t\tt.Errorf(\"#%d: expected error; got none\", i)\n \t\t} else if err.Error() != test.err {\n \t\t\tt.Errorf(\"#%d: got: %v want: %v\", i, err, test.err)\n \t\t}"}, {"sha": "7d1cc5f119c5d85454123f914996dab59786a546", "filename": "libgo/go/encoding/json/stream.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -19,6 +19,9 @@ type Decoder struct {\n }\n \n // NewDecoder returns a new decoder that reads from r.\n+//\n+// The decoder introduces its own buffering and may\n+// read data from r beyond the JSON values requested.\n func NewDecoder(r io.Reader) *Decoder {\n \treturn &Decoder{r: r}\n }"}, {"sha": "a71284312af732cfaaba3233c889d1311027b483", "filename": "libgo/go/encoding/xml/atom_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fatom_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fatom_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fatom_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -4,6 +4,8 @@\n \n package xml\n \n+import \"time\"\n+\n var atomValue = &Feed{\n \tXMLName: Name{\"http://www.w3.org/2005/Atom\", \"feed\"},\n \tTitle:   \"Example Feed\",\n@@ -24,11 +26,10 @@ var atomValue = &Feed{\n }\n \n var atomXml = `` +\n-\t`<feed xmlns=\"http://www.w3.org/2005/Atom\">` +\n+\t`<feed xmlns=\"http://www.w3.org/2005/Atom\" updated=\"2003-12-13T18:30:02Z\">` +\n \t`<title>Example Feed</title>` +\n \t`<id>urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6</id>` +\n \t`<link href=\"http://example.org/\"></link>` +\n-\t`<updated>2003-12-13T18:30:02Z</updated>` +\n \t`<author><name>John Doe</name><uri></uri><email></email></author>` +\n \t`<entry>` +\n \t`<title>Atom-Powered Robots Run Amok</title>` +\n@@ -40,8 +41,12 @@ var atomXml = `` +\n \t`</entry>` +\n \t`</feed>`\n \n-func ParseTime(str string) Time {\n-\treturn Time(str)\n+func ParseTime(str string) time.Time {\n+\tt, err := time.Parse(time.RFC3339, str)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn t\n }\n \n func NewText(text string) Text {"}, {"sha": "a96c523d55316e2f0530b077f49fb2dfbaf49a69", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"time\"\n )\n \n const (\n@@ -52,6 +53,10 @@ const (\n //     - a field with tag \",comment\" is written as an XML comment, not\n //       subject to the usual marshalling procedure. It must not contain\n //       the \"--\" string within it.\n+//     - a field with a tag including the \"omitempty\" option is omitted\n+//       if the field value is empty. The empty values are false, 0, any\n+//       nil pointer or interface value, and any array, slice, map, or\n+//       string of length zero.\n //\n // If a field uses a tag \"a>b>c\", then the element c will be nested inside\n // parent elements a and b.  Fields that appear next to each other that name\n@@ -63,6 +68,8 @@ const (\n //\t\tFirstName string   `xml:\"person>name>first\"`\n //\t\tLastName  string   `xml:\"person>name>last\"`\n //\t\tAge       int      `xml:\"person>age\"`\n+//\t\tHeight    float    `xml:\"person>height,omitempty\"`\n+//\t\tMarried   bool     `xml:\"person>married\"`\n //\t}\n //\n //\txml.Marshal(&Result{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42})\n@@ -76,6 +83,7 @@ const (\n //\t\t\t\t<last>Doe</last>\n //\t\t\t</name>\n //\t\t\t<age>42</age>\n+//\t\t\t<married>false</married>\n //\t\t</person>\n //\t</result>\n //\n@@ -116,6 +124,9 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \tif !val.IsValid() {\n \t\treturn nil\n \t}\n+\tif finfo != nil && finfo.flags&fOmitEmpty != 0 && isEmptyValue(val) {\n+\t\treturn nil\n+\t}\n \n \tkind := val.Kind()\n \ttyp := val.Type()\n@@ -183,12 +194,8 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \t\t\tcontinue\n \t\t}\n \t\tfv := val.FieldByIndex(finfo.idx)\n-\t\tswitch fv.Kind() {\n-\t\tcase reflect.String, reflect.Array, reflect.Slice:\n-\t\t\t// TODO: Should we really do this once ,omitempty is in?\n-\t\t\tif fv.Len() == 0 {\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tif finfo.flags&fOmitEmpty != 0 && isEmptyValue(fv) {\n+\t\t\tcontinue\n \t\t}\n \t\tp.WriteByte(' ')\n \t\tp.WriteString(finfo.name)\n@@ -217,7 +224,14 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \treturn nil\n }\n \n+var timeType = reflect.TypeOf(time.Time{})\n+\n func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) error {\n+\t// Normally we don't see structs, but this can happen for an attribute.\n+\tif val.Type() == timeType {\n+\t\tp.WriteString(val.Interface().(time.Time).Format(time.RFC3339Nano))\n+\t\treturn nil\n+\t}\n \tswitch val.Kind() {\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\tp.WriteString(strconv.FormatInt(val.Int(), 10))\n@@ -249,6 +263,10 @@ func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) error {\n var ddBytes = []byte(\"--\")\n \n func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n+\tif val.Type() == timeType {\n+\t\tp.WriteString(val.Interface().(time.Time).Format(time.RFC3339Nano))\n+\t\treturn nil\n+\t}\n \ts := parentStack{printer: p}\n \tfor i := range tinfo.fields {\n \t\tfinfo := &tinfo.fields[i]\n@@ -378,3 +396,21 @@ type UnsupportedTypeError struct {\n func (e *UnsupportedTypeError) Error() string {\n \treturn \"xml: unsupported type: \" + e.Type.String()\n }\n+\n+func isEmptyValue(v reflect.Value) bool {\n+\tswitch v.Kind() {\n+\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n+\t\treturn v.Len() == 0\n+\tcase reflect.Bool:\n+\t\treturn !v.Bool()\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn v.Int() == 0\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\treturn v.Uint() == 0\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn v.Float() == 0\n+\tcase reflect.Interface, reflect.Ptr:\n+\t\treturn v.IsNil()\n+\t}\n+\treturn false\n+}"}, {"sha": "9170fccd243282076a9f94265744d2076c516239", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type DriveType int\n@@ -38,14 +39,14 @@ type NamedType string\n \n type Port struct {\n \tXMLName struct{} `xml:\"port\"`\n-\tType    string   `xml:\"type,attr\"`\n+\tType    string   `xml:\"type,attr,omitempty\"`\n \tComment string   `xml:\",comment\"`\n \tNumber  string   `xml:\",chardata\"`\n }\n \n type Domain struct {\n \tXMLName struct{} `xml:\"domain\"`\n-\tCountry string   `xml:\",attr\"`\n+\tCountry string   `xml:\",attr,omitempty\"`\n \tName    []byte   `xml:\",chardata\"`\n \tComment []byte   `xml:\",comment\"`\n }\n@@ -149,11 +150,33 @@ type NameInField struct {\n \n type AttrTest struct {\n \tInt   int     `xml:\",attr\"`\n-\tLower int     `xml:\"int,attr\"`\n+\tNamed int     `xml:\"int,attr\"`\n \tFloat float64 `xml:\",attr\"`\n \tUint8 uint8   `xml:\",attr\"`\n \tBool  bool    `xml:\",attr\"`\n \tStr   string  `xml:\",attr\"`\n+\tBytes []byte  `xml:\",attr\"`\n+}\n+\n+type OmitAttrTest struct {\n+\tInt   int     `xml:\",attr,omitempty\"`\n+\tNamed int     `xml:\"int,attr,omitempty\"`\n+\tFloat float64 `xml:\",attr,omitempty\"`\n+\tUint8 uint8   `xml:\",attr,omitempty\"`\n+\tBool  bool    `xml:\",attr,omitempty\"`\n+\tStr   string  `xml:\",attr,omitempty\"`\n+\tBytes []byte  `xml:\",attr,omitempty\"`\n+}\n+\n+type OmitFieldTest struct {\n+\tInt   int           `xml:\",omitempty\"`\n+\tNamed int           `xml:\"int,omitempty\"`\n+\tFloat float64       `xml:\",omitempty\"`\n+\tUint8 uint8         `xml:\",omitempty\"`\n+\tBool  bool          `xml:\",omitempty\"`\n+\tStr   string        `xml:\",omitempty\"`\n+\tBytes []byte        `xml:\",omitempty\"`\n+\tPtr   *PresenceTest `xml:\",omitempty\"`\n }\n \n type AnyTest struct {\n@@ -234,6 +257,12 @@ var marshalTests = []struct {\n \t{Value: &Plain{[]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n \t{Value: &Plain{[3]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n \n+\t// Test time.\n+\t{\n+\t\tValue:     &Plain{time.Unix(1e9, 123456789).UTC()},\n+\t\tExpectXML: `<Plain><V>2001-09-09T01:46:40.123456789Z</V></Plain>`,\n+\t},\n+\n \t// A pointer to struct{} may be used to test for an element's presence.\n \t{\n \t\tValue:     &PresenceTest{new(struct{})},\n@@ -549,13 +578,65 @@ var marshalTests = []struct {\n \t{\n \t\tValue: &AttrTest{\n \t\t\tInt:   8,\n-\t\t\tLower: 9,\n+\t\t\tNamed: 9,\n+\t\t\tFloat: 23.5,\n+\t\t\tUint8: 255,\n+\t\t\tBool:  true,\n+\t\t\tStr:   \"str\",\n+\t\t\tBytes: []byte(\"byt\"),\n+\t\t},\n+\t\tExpectXML: `<AttrTest Int=\"8\" int=\"9\" Float=\"23.5\" Uint8=\"255\"` +\n+\t\t\t` Bool=\"true\" Str=\"str\" Bytes=\"byt\"></AttrTest>`,\n+\t},\n+\t{\n+\t\tValue: &AttrTest{Bytes: []byte{}},\n+\t\tExpectXML: `<AttrTest Int=\"0\" int=\"0\" Float=\"0\" Uint8=\"0\"` +\n+\t\t\t` Bool=\"false\" Str=\"\" Bytes=\"\"></AttrTest>`,\n+\t},\n+\t{\n+\t\tValue: &OmitAttrTest{\n+\t\t\tInt:   8,\n+\t\t\tNamed: 9,\n+\t\t\tFloat: 23.5,\n+\t\t\tUint8: 255,\n+\t\t\tBool:  true,\n+\t\t\tStr:   \"str\",\n+\t\t\tBytes: []byte(\"byt\"),\n+\t\t},\n+\t\tExpectXML: `<OmitAttrTest Int=\"8\" int=\"9\" Float=\"23.5\" Uint8=\"255\"` +\n+\t\t\t` Bool=\"true\" Str=\"str\" Bytes=\"byt\"></OmitAttrTest>`,\n+\t},\n+\t{\n+\t\tValue:     &OmitAttrTest{},\n+\t\tExpectXML: `<OmitAttrTest></OmitAttrTest>`,\n+\t},\n+\n+\t// omitempty on fields\n+\t{\n+\t\tValue: &OmitFieldTest{\n+\t\t\tInt:   8,\n+\t\t\tNamed: 9,\n \t\t\tFloat: 23.5,\n \t\t\tUint8: 255,\n \t\t\tBool:  true,\n-\t\t\tStr:   \"s\",\n+\t\t\tStr:   \"str\",\n+\t\t\tBytes: []byte(\"byt\"),\n+\t\t\tPtr:   &PresenceTest{},\n \t\t},\n-\t\tExpectXML: `<AttrTest Int=\"8\" int=\"9\" Float=\"23.5\" Uint8=\"255\" Bool=\"true\" Str=\"s\"></AttrTest>`,\n+\t\tExpectXML: `<OmitFieldTest>` +\n+\t\t\t`<Int>8</Int>` +\n+\t\t\t`<int>9</int>` +\n+\t\t\t`<Float>23.5</Float>` +\n+\t\t\t`<Uint8>255</Uint8>` +\n+\t\t\t`<Bool>true</Bool>` +\n+\t\t\t`<Str>str</Str>` +\n+\t\t\t`<Bytes>byt</Bytes>` +\n+\t\t\t`<Ptr></Ptr>` +\n+\t\t\t`</OmitFieldTest>`,\n+\t},\n+\t{\n+\t\tValue:     &OmitFieldTest{},\n+\t\tExpectXML: `<OmitFieldTest></OmitFieldTest>`,\n \t},\n \n \t// Test \",any\""}, {"sha": "b5a3426a328e27fdc4a5dce742017482bcdc05bd", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"time\"\n )\n \n // BUG(rsc): Mapping between XML elements and data structures is inherently flawed:\n@@ -270,6 +271,10 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\t\tv.Set(reflect.ValueOf(start.Name))\n \t\t\tbreak\n \t\t}\n+\t\tif typ == timeType {\n+\t\t\tsaveData = v\n+\t\t\tbreak\n+\t\t}\n \n \t\tsv = v\n \t\ttinfo, err = getTypeInfo(typ)\n@@ -473,6 +478,14 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \t\t\tsrc = []byte{}\n \t\t}\n \t\tt.SetBytes(src)\n+\tcase reflect.Struct:\n+\t\tif t.Type() == timeType {\n+\t\t\ttv, err := time.Parse(time.RFC3339, string(src))\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tt.Set(reflect.ValueOf(tv))\n+\t\t}\n \t}\n \treturn nil\n }"}, {"sha": "8df09b3cceea01a9e7a34452a5ed4328bee4dd47", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,6 +7,7 @@ package xml\n import (\n \t\"reflect\"\n \t\"testing\"\n+\t\"time\"\n )\n \n // Stripped down Atom feed data structures.\n@@ -24,7 +25,7 @@ func TestUnmarshalFeed(t *testing.T) {\n // hget http://codereview.appspot.com/rss/mine/rsc\n const atomFeedString = `\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en-us\"><title>Code Review - My issues</title><link href=\"http://codereview.appspot.com/\" rel=\"alternate\"></link><link href=\"http://codereview.appspot.com/rss/mine/rsc\" rel=\"self\"></link><id>http://codereview.appspot.com/</id><updated>2009-10-04T01:35:58+00:00</updated><author><name>rietveld&lt;&gt;</name></author><entry><title>rietveld: an attempt at pubsubhubbub\n+<feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en-us\" updated=\"2009-10-04T01:35:58+00:00\"><title>Code Review - My issues</title><link href=\"http://codereview.appspot.com/\" rel=\"alternate\"></link><link href=\"http://codereview.appspot.com/rss/mine/rsc\" rel=\"self\"></link><id>http://codereview.appspot.com/</id><author><name>rietveld&lt;&gt;</name></author><entry><title>rietveld: an attempt at pubsubhubbub\n </title><link href=\"http://codereview.appspot.com/126085\" rel=\"alternate\"></link><updated>2009-10-04T01:35:58+00:00</updated><author><name>email-address-removed</name></author><id>urn:md5:134d9179c41f806be79b3a5f7877d19a</id><summary type=\"html\">\n   An attempt at adding pubsubhubbub support to Rietveld.\n http://code.google.com/p/pubsubhubbub\n@@ -78,26 +79,26 @@ not being used from outside intra_region_diff.py.\n </summary></entry></feed> \t   `\n \n type Feed struct {\n-\tXMLName Name    `xml:\"http://www.w3.org/2005/Atom feed\"`\n-\tTitle   string  `xml:\"title\"`\n-\tId      string  `xml:\"id\"`\n-\tLink    []Link  `xml:\"link\"`\n-\tUpdated Time    `xml:\"updated\"`\n-\tAuthor  Person  `xml:\"author\"`\n-\tEntry   []Entry `xml:\"entry\"`\n+\tXMLName Name      `xml:\"http://www.w3.org/2005/Atom feed\"`\n+\tTitle   string    `xml:\"title\"`\n+\tId      string    `xml:\"id\"`\n+\tLink    []Link    `xml:\"link\"`\n+\tUpdated time.Time `xml:\"updated,attr\"`\n+\tAuthor  Person    `xml:\"author\"`\n+\tEntry   []Entry   `xml:\"entry\"`\n }\n \n type Entry struct {\n-\tTitle   string `xml:\"title\"`\n-\tId      string `xml:\"id\"`\n-\tLink    []Link `xml:\"link\"`\n-\tUpdated Time   `xml:\"updated\"`\n-\tAuthor  Person `xml:\"author\"`\n-\tSummary Text   `xml:\"summary\"`\n+\tTitle   string    `xml:\"title\"`\n+\tId      string    `xml:\"id\"`\n+\tLink    []Link    `xml:\"link\"`\n+\tUpdated time.Time `xml:\"updated\"`\n+\tAuthor  Person    `xml:\"author\"`\n+\tSummary Text      `xml:\"summary\"`\n }\n \n type Link struct {\n-\tRel  string `xml:\"rel,attr\"`\n+\tRel  string `xml:\"rel,attr,omitempty\"`\n \tHref string `xml:\"href,attr\"`\n }\n \n@@ -109,12 +110,10 @@ type Person struct {\n }\n \n type Text struct {\n-\tType string `xml:\"type,attr\"`\n+\tType string `xml:\"type,attr,omitempty\"`\n \tBody string `xml:\",chardata\"`\n }\n \n-type Time string\n-\n var atomFeed = Feed{\n \tXMLName: Name{\"http://www.w3.org/2005/Atom\", \"feed\"},\n \tTitle:   \"Code Review - My issues\",\n@@ -123,7 +122,7 @@ var atomFeed = Feed{\n \t\t{Rel: \"self\", Href: \"http://codereview.appspot.com/rss/mine/rsc\"},\n \t},\n \tId:      \"http://codereview.appspot.com/\",\n-\tUpdated: \"2009-10-04T01:35:58+00:00\",\n+\tUpdated: ParseTime(\"2009-10-04T01:35:58+00:00\"),\n \tAuthor: Person{\n \t\tName:     \"rietveld<>\",\n \t\tInnerXML: \"<name>rietveld&lt;&gt;</name>\",\n@@ -134,7 +133,7 @@ var atomFeed = Feed{\n \t\t\tLink: []Link{\n \t\t\t\t{Rel: \"alternate\", Href: \"http://codereview.appspot.com/126085\"},\n \t\t\t},\n-\t\t\tUpdated: \"2009-10-04T01:35:58+00:00\",\n+\t\t\tUpdated: ParseTime(\"2009-10-04T01:35:58+00:00\"),\n \t\t\tAuthor: Person{\n \t\t\t\tName:     \"email-address-removed\",\n \t\t\t\tInnerXML: \"<name>email-address-removed</name>\",\n@@ -181,7 +180,7 @@ the top of feeds.py marked NOTE(rsc).\n \t\t\tLink: []Link{\n \t\t\t\t{Rel: \"alternate\", Href: \"http://codereview.appspot.com/124106\"},\n \t\t\t},\n-\t\t\tUpdated: \"2009-10-03T23:02:17+00:00\",\n+\t\t\tUpdated: ParseTime(\"2009-10-03T23:02:17+00:00\"),\n \t\t\tAuthor: Person{\n \t\t\t\tName:     \"email-address-removed\",\n \t\t\t\tInnerXML: \"<name>email-address-removed</name>\","}, {"sha": "8e2e4508b104880af8cf0ab1215d9947eda8b136", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -36,8 +36,7 @@ const (\n \tfComment\n \tfAny\n \n-\t// TODO:\n-\t//fOmitEmpty\n+\tfOmitEmpty\n \n \tfMode = fElement | fAttr | fCharData | fInnerXml | fComment | fAny\n )\n@@ -133,20 +132,28 @@ func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, erro\n \t\t\t\tfinfo.flags |= fComment\n \t\t\tcase \"any\":\n \t\t\t\tfinfo.flags |= fAny\n+\t\t\tcase \"omitempty\":\n+\t\t\t\tfinfo.flags |= fOmitEmpty\n \t\t\t}\n \t\t}\n \n \t\t// Validate the flags used.\n+\t\tvalid := true\n \t\tswitch mode := finfo.flags & fMode; mode {\n \t\tcase 0:\n \t\t\tfinfo.flags |= fElement\n \t\tcase fAttr, fCharData, fInnerXml, fComment, fAny:\n-\t\t\tif f.Name != \"XMLName\" && (tag == \"\" || mode == fAttr) {\n-\t\t\t\tbreak\n+\t\t\tif f.Name == \"XMLName\" || tag != \"\" && mode != fAttr {\n+\t\t\t\tvalid = false\n \t\t\t}\n-\t\t\tfallthrough\n \t\tdefault:\n \t\t\t// This will also catch multiple modes in a single field.\n+\t\t\tvalid = false\n+\t\t}\n+\t\tif finfo.flags&fOmitEmpty != 0 && finfo.flags&(fElement|fAttr) == 0 {\n+\t\t\tvalid = false\n+\t\t}\n+\t\tif !valid {\n \t\t\treturn nil, fmt.Errorf(\"xml: invalid tag in field %s of type %s: %q\",\n \t\t\t\tf.Name, typ, f.Tag.Get(\"xml\"))\n \t\t}"}, {"sha": "ccff4670602179e9d1ae6bf792234aaf166686f8", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -102,7 +102,7 @@ func (rb *reorderBuffer) insert(src input, i int, info runeInfo) bool {\n \t\t}\n \t}\n \tif info.hasDecomposition() {\n-\t\tdcomp := rb.f.decompose(src, i)\n+\t\tdcomp := info.decomposition()\n \t\trb.tmpBytes = inputBytes(dcomp)\n \t\tfor i := 0; i < len(dcomp); {\n \t\t\tinfo = rb.f.info(&rb.tmpBytes, i)"}, {"sha": "fd7b3956233278e6747219776c8302a02aa206f3", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,25 +6,50 @@ package norm\n \n // This file contains Form-specific logic and wrappers for data in tables.go.\n \n+// Rune info is stored in a separate trie per composing form. A composing form\n+// and its corresponding decomposing form share the same trie.  Each trie maps\n+// a rune to a uint16. The values take two forms.  For v >= 0x8000:\n+//   bits\n+//   0..8:   ccc\n+//   9..12:  qcInfo (see below). isYesD is always true (no decompostion).\n+//   16:     1\n+// For v < 0x8000, the respective rune has a decomposition and v is an index\n+// into a byte array of UTF-8 decomposition sequences and additional info and\n+// has the form:\n+//    <header> <decomp_byte>* [<tccc> [<lccc>]]\n+// The header contains the number of bytes in the decomposition (excluding this\n+// length byte). The two most significant bits of this lenght byte correspond\n+// to bit 2 and 3 of qcIfo (see below).  The byte sequence itself starts at v+1.\n+// The byte sequence is followed by a trailing and leading CCC if the values\n+// for these are not zero.  The value of v determines which ccc are appended\n+// to the sequences.  For v < firstCCC, there are none, for v >= firstCCC,\n+// the seqence is followed by a trailing ccc, and for v >= firstLeadingCC\n+// there is an additional leading ccc.\n+\n+const (\n+\tqcInfoMask      = 0xF  // to clear all but the relevant bits in a qcInfo\n+\theaderLenMask   = 0x3F // extract the lenght value from the header byte\n+\theaderFlagsMask = 0xC0 // extract the qcInfo bits from the header byte\n+)\n+\n+// runeInfo is a representation for the data stored in charinfoTrie.\n type runeInfo struct {\n \tpos   uint8  // start position in reorderBuffer; used in composition.go\n \tsize  uint8  // length of UTF-8 encoding of this rune\n-\tccc   uint8  // canonical combining class\n+\tccc   uint8  // leading canonical combining class (ccc if not decomposition)\n+\ttccc  uint8  // trailing canonical combining class (ccc if not decomposition)\n \tflags qcInfo // quick check flags\n+\tindex uint16\n }\n \n // functions dispatchable per form\n type lookupFunc func(b input, i int) runeInfo\n-type decompFunc func(b input, i int) []byte\n \n // formInfo holds Form-specific functions and tables.\n type formInfo struct {\n-\tform Form\n-\n+\tform                     Form\n \tcomposing, compatibility bool // form type\n-\n-\tdecompose decompFunc\n-\tinfo      lookupFunc\n+\tinfo                     lookupFunc\n }\n \n var formTable []*formInfo\n@@ -38,10 +63,8 @@ func init() {\n \t\tf.form = Form(i)\n \t\tif Form(i) == NFKD || Form(i) == NFKC {\n \t\t\tf.compatibility = true\n-\t\t\tf.decompose = decomposeNFKC\n \t\t\tf.info = lookupInfoNFKC\n \t\t} else {\n-\t\t\tf.decompose = decomposeNFC\n \t\t\tf.info = lookupInfoNFC\n \t\t}\n \t\tif Form(i) == NFC || Form(i) == NFKC {\n@@ -76,8 +99,6 @@ func (i runeInfo) boundaryAfter() bool {\n // \n // When all 4 bits are zero, the character is inert, meaning it is never\n // influenced by normalization.\n-//\n-// We pack the bits for both NFC/D and NFKC/D in one byte.\n type qcInfo uint8\n \n func (i runeInfo) isYesC() bool { return i.flags&0x4 == 0 }\n@@ -91,22 +112,12 @@ func (r runeInfo) isInert() bool {\n \treturn r.flags&0xf == 0 && r.ccc == 0\n }\n \n-// Wrappers for tables.go\n-\n-// The 16-bit value of the decomposition tries is an index into a byte\n-// array of UTF-8 decomposition sequences. The first byte is the number\n-// of bytes in the decomposition (excluding this length byte). The actual\n-// sequence starts at the offset+1.\n-func decomposeNFC(s input, i int) []byte {\n-\tp := s.decomposeNFC(i)\n-\tn := decomps[p]\n-\tp++\n-\treturn decomps[p : p+uint16(n)]\n-}\n-\n-func decomposeNFKC(s input, i int) []byte {\n-\tp := s.decomposeNFKC(i)\n-\tn := decomps[p]\n+func (r runeInfo) decomposition() []byte {\n+\tif r.index == 0 {\n+\t\treturn nil\n+\t}\n+\tp := r.index\n+\tn := decomps[p] & 0x3F\n \tp++\n \treturn decomps[p : p+uint16(n)]\n }\n@@ -124,16 +135,40 @@ func combine(a, b rune) rune {\n \treturn recompMap[key]\n }\n \n-// The 16-bit character info has the following bit layout:\n-//    0..7   CCC value.\n-//    8..11  qcInfo for NFC/NFD\n-//   12..15  qcInfo for NFKC/NFKD\n func lookupInfoNFC(b input, i int) runeInfo {\n-\tv, sz := b.charinfo(i)\n-\treturn runeInfo{size: uint8(sz), ccc: uint8(v), flags: qcInfo(v >> 8)}\n+\tv, sz := b.charinfoNFC(i)\n+\treturn compInfo(v, sz)\n }\n \n func lookupInfoNFKC(b input, i int) runeInfo {\n-\tv, sz := b.charinfo(i)\n-\treturn runeInfo{size: uint8(sz), ccc: uint8(v), flags: qcInfo(v >> 12)}\n+\tv, sz := b.charinfoNFKC(i)\n+\treturn compInfo(v, sz)\n+}\n+\n+// compInfo converts the information contained in v and sz\n+// to a runeInfo.  See the comment at the top of the file\n+// for more information on the format.\n+func compInfo(v uint16, sz int) runeInfo {\n+\tif v == 0 {\n+\t\treturn runeInfo{size: uint8(sz)}\n+\t} else if v >= 0x8000 {\n+\t\treturn runeInfo{\n+\t\t\tsize:  uint8(sz),\n+\t\t\tccc:   uint8(v),\n+\t\t\ttccc:  uint8(v),\n+\t\t\tflags: qcInfo(v>>8) & qcInfoMask,\n+\t\t}\n+\t}\n+\t// has decomposition\n+\th := decomps[v]\n+\tf := (qcInfo(h&headerFlagsMask) >> 4) | 0x1\n+\tri := runeInfo{size: uint8(sz), flags: f, index: v}\n+\tif v >= firstCCC {\n+\t\tv += uint16(h&headerLenMask) + 1\n+\t\tri.tccc = decomps[v]\n+\t\tif v >= firstLeadingCCC {\n+\t\t\tri.ccc = decomps[v+1]\n+\t\t}\n+\t}\n+\treturn ri\n }"}, {"sha": "5c0968ba58cd5d7611fd0fa8a6188d36c41d5c82", "filename": "libgo/go/exp/norm/input.go", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -11,9 +11,8 @@ type input interface {\n \tskipNonStarter(p int) int\n \tappendSlice(buf []byte, s, e int) []byte\n \tcopySlice(buf []byte, s, e int)\n-\tcharinfo(p int) (uint16, int)\n-\tdecomposeNFC(p int) uint16\n-\tdecomposeNFKC(p int) uint16\n+\tcharinfoNFC(p int) (uint16, int)\n+\tcharinfoNFKC(p int) (uint16, int)\n \thangul(p int) rune\n }\n \n@@ -42,16 +41,12 @@ func (s inputString) copySlice(buf []byte, b, e int) {\n \tcopy(buf, s[b:e])\n }\n \n-func (s inputString) charinfo(p int) (uint16, int) {\n-\treturn charInfoTrie.lookupString(string(s[p:]))\n+func (s inputString) charinfoNFC(p int) (uint16, int) {\n+\treturn nfcTrie.lookupString(string(s[p:]))\n }\n \n-func (s inputString) decomposeNFC(p int) uint16 {\n-\treturn nfcDecompTrie.lookupStringUnsafe(string(s[p:]))\n-}\n-\n-func (s inputString) decomposeNFKC(p int) uint16 {\n-\treturn nfkcDecompTrie.lookupStringUnsafe(string(s[p:]))\n+func (s inputString) charinfoNFKC(p int) (uint16, int) {\n+\treturn nfkcTrie.lookupString(string(s[p:]))\n }\n \n func (s inputString) hangul(p int) rune {\n@@ -84,16 +79,12 @@ func (s inputBytes) copySlice(buf []byte, b, e int) {\n \tcopy(buf, s[b:e])\n }\n \n-func (s inputBytes) charinfo(p int) (uint16, int) {\n-\treturn charInfoTrie.lookup(s[p:])\n-}\n-\n-func (s inputBytes) decomposeNFC(p int) uint16 {\n-\treturn nfcDecompTrie.lookupUnsafe(s[p:])\n+func (s inputBytes) charinfoNFC(p int) (uint16, int) {\n+\treturn nfcTrie.lookup(s[p:])\n }\n \n-func (s inputBytes) decomposeNFKC(p int) uint16 {\n-\treturn nfkcDecompTrie.lookupUnsafe(s[p:])\n+func (s inputBytes) charinfoNFKC(p int) (uint16, int) {\n+\treturn nfkcTrie.lookup(s[p:])\n }\n \n func (s inputBytes) hangul(p int) rune {"}, {"sha": "bb21bb5810949d384719d3a3b86815b889308c54", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 108, "deletions": 65, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,8 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Normalization table generator.\n // Data read from the web.\n+// See forminfo.go for a description of the trie values associated with each rune.\n \n package main\n \n@@ -17,6 +20,7 @@ import (\n \t\"net/http\"\n \t\"os\"\n \t\"regexp\"\n+\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n )\n@@ -187,18 +191,14 @@ func (f FormInfo) String() string {\n \tfmt.Fprintf(buf, \"    cmbBackward: %v\\n\", f.combinesBackward)\n \tfmt.Fprintf(buf, \"    isOneWay: %v\\n\", f.isOneWay)\n \tfmt.Fprintf(buf, \"    inDecomp: %v\\n\", f.inDecomp)\n-\tfmt.Fprintf(buf, \"    decomposition: %v\\n\", f.decomp)\n-\tfmt.Fprintf(buf, \"    expandedDecomp: %v\\n\", f.expandedDecomp)\n+\tfmt.Fprintf(buf, \"    decomposition: %X\\n\", f.decomp)\n+\tfmt.Fprintf(buf, \"    expandedDecomp: %X\\n\", f.expandedDecomp)\n \n \treturn buf.String()\n }\n \n type Decomposition []rune\n \n-func (d Decomposition) String() string {\n-\treturn fmt.Sprintf(\"%.4X\", d)\n-}\n-\n func openReader(file string) (input io.ReadCloser) {\n \tif *localFiles {\n \t\tf, err := os.Open(file)\n@@ -571,80 +571,121 @@ func makeEntry(f *FormInfo) uint16 {\n \treturn e\n }\n \n-// Bits\n-// 0..8:   CCC\n-// 9..12:  NF(C|D) qc bits.\n-// 13..16: NFK(C|D) qc bits.\n-func makeCharInfo(c Char) uint16 {\n-\te := makeEntry(&c.forms[FCompatibility])\n-\te = e<<4 | makeEntry(&c.forms[FCanonical])\n-\te = e<<8 | uint16(c.ccc)\n-\treturn e\n+// decompSet keeps track of unique decompositions, grouped by whether\n+// the decomposition is followed by a trailing and/or leading CCC.\n+type decompSet [4]map[string]bool\n+\n+func makeDecompSet() decompSet {\n+\tm := decompSet{}\n+\tfor i, _ := range m {\n+\t\tm[i] = make(map[string]bool)\n+\t}\n+\treturn m\n+}\n+func (m *decompSet) insert(key int, s string) {\n+\tm[key][s] = true\n }\n \n func printCharInfoTables() int {\n-\t// Quick Check + CCC trie.\n-\tt := newNode()\n-\tfor i, char := range chars {\n-\t\tv := makeCharInfo(char)\n-\t\tif v != 0 {\n-\t\t\tt.insert(rune(i), v)\n+\tmkstr := func(r rune, f *FormInfo) (int, string) {\n+\t\td := f.expandedDecomp\n+\t\ts := string([]rune(d))\n+\t\tif max := 1 << 6; len(s) >= max {\n+\t\t\tconst msg = \"%U: too many bytes in decomposition: %d >= %d\"\n+\t\t\tlogger.Fatalf(msg, r, len(s), max)\n+\t\t}\n+\t\thead := uint8(len(s))\n+\t\tif f.quickCheck[MComposed] != QCYes {\n+\t\t\thead |= 0x40\n+\t\t}\n+\t\tif f.combinesForward {\n+\t\t\thead |= 0x80\n+\t\t}\n+\t\ts = string([]byte{head}) + s\n+\n+\t\tlccc := ccc(d[0])\n+\t\ttccc := ccc(d[len(d)-1])\n+\t\tif tccc < lccc && lccc != 0 {\n+\t\t\tconst msg = \"%U: lccc (%d) must be <= tcc (%d)\"\n+\t\t\tlogger.Fatalf(msg, r, lccc, tccc)\n+\t\t}\n+\t\tindex := 0\n+\t\tif tccc > 0 || lccc > 0 {\n+\t\t\ts += string([]byte{tccc})\n+\t\t\tindex = 1\n+\t\t\tif lccc > 0 {\n+\t\t\t\ts += string([]byte{lccc})\n+\t\t\t\tindex |= 2\n+\t\t\t}\n \t\t}\n+\t\treturn index, s\n \t}\n-\treturn t.printTables(\"charInfo\")\n-}\n \n-func printDecompositionTables() int {\n-\tdecompositions := bytes.NewBuffer(make([]byte, 0, 10000))\n-\tsize := 0\n-\n-\t// Map decompositions\n-\tpositionMap := make(map[string]uint16)\n+\tdecompSet := makeDecompSet()\n \n \t// Store the uniqued decompositions in a byte buffer,\n \t// preceded by their byte length.\n \tfor _, c := range chars {\n-\t\tfor f := 0; f < 2; f++ {\n-\t\t\td := c.forms[f].expandedDecomp\n-\t\t\ts := string([]rune(d))\n-\t\t\tif _, ok := positionMap[s]; !ok {\n-\t\t\t\tp := decompositions.Len()\n-\t\t\t\tdecompositions.WriteByte(uint8(len(s)))\n-\t\t\t\tdecompositions.WriteString(s)\n-\t\t\t\tpositionMap[s] = uint16(p)\n+\t\tfor _, f := range c.forms {\n+\t\t\tif len(f.expandedDecomp) == 0 {\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\tif f.combinesBackward {\n+\t\t\t\tlogger.Fatalf(\"%U: combinesBackward and decompose\", c.codePoint)\n+\t\t\t}\n+\t\t\tindex, s := mkstr(c.codePoint, &f)\n+\t\t\tdecompSet.insert(index, s)\n \t\t}\n \t}\n+\n+\tdecompositions := bytes.NewBuffer(make([]byte, 0, 10000))\n+\tsize := 0\n+\tpositionMap := make(map[string]uint16)\n+\tdecompositions.WriteString(\"\\000\")\n+\tcname := []string{\"firstCCC\", \"firstLeadingCCC\", \"\", \"lastDecomp\"}\n+\tfmt.Println(\"const (\")\n+\tfor i, m := range decompSet {\n+\t\tsa := []string{}\n+\t\tfor s, _ := range m {\n+\t\t\tsa = append(sa, s)\n+\t\t}\n+\t\tsort.Strings(sa)\n+\t\tfor _, s := range sa {\n+\t\t\tp := decompositions.Len()\n+\t\t\tdecompositions.WriteString(s)\n+\t\t\tpositionMap[s] = uint16(p)\n+\t\t}\n+\t\tif cname[i] != \"\" {\n+\t\t\tfmt.Printf(\"%s = 0x%X\\n\", cname[i], decompositions.Len())\n+\t\t}\n+\t}\n+\tfmt.Println(\"maxDecomp = 0x8000\")\n+\tfmt.Println(\")\")\n \tb := decompositions.Bytes()\n \tprintBytes(b, \"decomps\")\n \tsize += len(b)\n \n-\tnfcT := newNode()\n-\tnfkcT := newNode()\n-\tfor i, c := range chars {\n-\t\td := c.forms[FCanonical].expandedDecomp\n-\t\tif len(d) != 0 {\n-\t\t\tnfcT.insert(rune(i), positionMap[string([]rune(d))])\n-\t\t\tif ccc(c.codePoint) != ccc(d[0]) {\n-\t\t\t\t// We assume the lead ccc of a decomposition is !=0 in this case.\n-\t\t\t\tif ccc(d[0]) == 0 {\n-\t\t\t\t\tlogger.Fatal(\"Expected differing CCC to be non-zero.\")\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\td = c.forms[FCompatibility].expandedDecomp\n-\t\tif len(d) != 0 {\n-\t\t\tnfkcT.insert(rune(i), positionMap[string([]rune(d))])\n-\t\t\tif ccc(c.codePoint) != ccc(d[0]) {\n-\t\t\t\t// We assume the lead ccc of a decomposition is !=0 in this case.\n-\t\t\t\tif ccc(d[0]) == 0 {\n-\t\t\t\t\tlogger.Fatal(\"Expected differing CCC to be non-zero.\")\n+\tvarnames := []string{\"nfc\", \"nfkc\"}\n+\tfor i := 0; i < FNumberOfFormTypes; i++ {\n+\t\ttrie := newNode()\n+\t\tfor r, c := range chars {\n+\t\t\tf := c.forms[i]\n+\t\t\td := f.expandedDecomp\n+\t\t\tif len(d) != 0 {\n+\t\t\t\t_, key := mkstr(c.codePoint, &f)\n+\t\t\t\ttrie.insert(rune(r), positionMap[key])\n+\t\t\t\tif c.ccc != ccc(d[0]) {\n+\t\t\t\t\t// We assume the lead ccc of a decomposition !=0 in this case.\n+\t\t\t\t\tif ccc(d[0]) == 0 {\n+\t\t\t\t\t\tlogger.Fatalf(\"Expected leading CCC to be non-zero; ccc is %d\", c.ccc)\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t} else if v := makeEntry(&f)<<8 | uint16(c.ccc); v != 0 {\n+\t\t\t\ttrie.insert(c.codePoint, 0x8000|v)\n \t\t\t}\n \t\t}\n+\t\tsize += trie.printTables(varnames[i])\n \t}\n-\tsize += nfcT.printTables(\"nfcDecomp\")\n-\tsize += nfkcT.printTables(\"nfkcDecomp\")\n \treturn size\n }\n \n@@ -687,15 +728,15 @@ func makeTables() {\n \t}\n \tlist := strings.Split(*tablelist, \",\")\n \tif *tablelist == \"all\" {\n-\t\tlist = []string{\"decomp\", \"recomp\", \"info\"}\n+\t\tlist = []string{\"recomp\", \"info\"}\n \t}\n \tfmt.Printf(fileHeader, *tablelist, *url)\n \n \tfmt.Println(\"// Version is the Unicode edition from which the tables are derived.\")\n \tfmt.Printf(\"const Version = %q\\n\\n\", version())\n \n-\tif contains(list, \"decomp\") {\n-\t\tsize += printDecompositionTables()\n+\tif contains(list, \"info\") {\n+\t\tsize += printCharInfoTables()\n \t}\n \n \tif contains(list, \"recomp\") {\n@@ -730,9 +771,6 @@ func makeTables() {\n \t\tfmt.Printf(\"}\\n\\n\")\n \t}\n \n-\tif contains(list, \"info\") {\n-\t\tsize += printCharInfoTables()\n-\t}\n \tfmt.Printf(\"// Total size of tables: %dKB (%d bytes)\\n\", (size+512)/1024, size)\n }\n \n@@ -761,6 +799,11 @@ func verifyComputed() {\n \t\t\t\tlog.Fatalf(\"%U: NF*C must be maybe if combinesBackward\", i)\n \t\t\t}\n \t\t}\n+\t\tnfc := c.forms[FCanonical]\n+\t\tnfkc := c.forms[FCompatibility]\n+\t\tif nfc.combinesBackward != nfkc.combinesBackward {\n+\t\t\tlogger.Fatalf(\"%U: Cannot combine combinesBackward\\n\", c.codePoint)\n+\t\t}\n \t}\n }\n "}, {"sha": "d3112b4041c8ce38fce12e99b7bae9e0596d4c78", "filename": "libgo/go/exp/norm/maketesttables.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Generate test data for trie code.\n \n package main"}, {"sha": "030d900918ed6873d1877c50f55654a5d203788d", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -448,7 +448,7 @@ func decomposeToLastBoundary(rb *reorderBuffer, buf []byte) []byte {\n \t\t}\n \t\t// Check that decomposition doesn't result in overflow.\n \t\tif info.hasDecomposition() {\n-\t\t\tdcomp := rb.f.decompose(inputBytes(buf), p-int(info.size))\n+\t\t\tdcomp := info.decomposition()\n \t\t\tfor i := 0; i < len(dcomp); {\n \t\t\t\tinf := rb.f.info(inputBytes(dcomp), i)\n \t\t\t\ti += int(inf.size)"}, {"sha": "c2ab25bc99dab9a7836b8ea2a040dafc7e637afc", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package main\n \n import ("}, {"sha": "e97b1710722079d3e84eabb94b6f86fc7b12205f", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 6023, "deletions": 6131, "changes": 12154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce"}, {"sha": "2e275a06254f56a142af4aef313b7a9ea368bb51", "filename": "libgo/go/exp/norm/triegen.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n // Trie table generator.\n // Used by make*tables tools to generate a go file with trie data structures\n // for mapping UTF-8 to a 16-bit value. All but the last byte in a UTF-8 byte"}, {"sha": "bce4530e7bc73c2a05fc65f83f9ea4c5ba079551", "filename": "libgo/go/exp/signal/signal.go", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal.go?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin freebsd linux netbsd openbsd\n-\n-// Package signal implements operating system-independent signal handling.\n-package signal\n-\n-import (\n-\t\"os\"\n-\t\"runtime\"\n-)\n-\n-// Incoming is the global signal channel.\n-// All signals received by the program will be delivered to this channel.\n-var Incoming <-chan os.Signal\n-\n-func process(ch chan<- os.Signal) {\n-\tfor {\n-\t\tvar mask uint32 = runtime.Sigrecv()\n-\t\tfor sig := uint(0); sig < 32; sig++ {\n-\t\t\tif mask&(1<<sig) != 0 {\n-\t\t\t\tch <- os.UnixSignal(sig)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func init() {\n-\truntime.Siginit()\n-\tch := make(chan os.Signal) // Done here so Incoming can have type <-chan Signal\n-\tIncoming = ch\n-\tgo process(ch)\n-}\n-\n-// BUG(rsc): This package is unavailable on Plan 9 and Windows."}, {"sha": "a7cecb38256313caf9222e5fff40c5f211c33733", "filename": "libgo/go/exp/signal/signal_test.go", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal_test.go?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin freebsd linux netbsd openbsd\n-\n-package signal\n-\n-import (\n-\t\"os\"\n-\t\"syscall\"\n-\t\"testing\"\n-)\n-\n-const sighup = os.UnixSignal(syscall.SIGHUP)\n-\n-func TestSignal(t *testing.T) {\n-\t// Send this process a SIGHUP.\n-\tsyscall.Syscall(syscall.SYS_KILL, uintptr(syscall.Getpid()), syscall.SIGHUP, 0)\n-\n-\tif sig := (<-Incoming).(os.UnixSignal); sig != sighup {\n-\t\tt.Errorf(\"signal was %v, want %v\", sig, sighup)\n-\t}\n-}"}, {"sha": "ae0beb4e9b0b1d59ed876106a4fa6f5ff9b87c0d", "filename": "libgo/go/exp/types/check.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,14 +17,14 @@ import (\n const debug = false\n \n type checker struct {\n-\tfset *token.FileSet\n-\tscanner.ErrorVector\n-\ttypes map[ast.Expr]Type\n+\tfset   *token.FileSet\n+\terrors scanner.ErrorList\n+\ttypes  map[ast.Expr]Type\n }\n \n func (c *checker) errorf(pos token.Pos, format string, args ...interface{}) string {\n \tmsg := fmt.Sprintf(format, args...)\n-\tc.Error(c.fset.Position(pos), msg)\n+\tc.errors.Add(c.fset.Position(pos), msg)\n \treturn msg\n }\n \n@@ -221,5 +221,6 @@ func Check(fset *token.FileSet, pkg *ast.Package) (types map[ast.Expr]Type, err\n \t\tc.checkObj(obj, false)\n \t}\n \n-\treturn c.types, c.GetError(scanner.NoMultiples)\n+\tc.errors.RemoveMultiples()\n+\treturn c.types, c.errors.Err()\n }"}, {"sha": "8b28aede1ecf1b9ce47d8e336245f714bd355de2", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -11,20 +11,19 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n+\t\"go/build\"\n \t\"go/token\"\n \t\"io\"\n \t\"math/big\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"runtime\"\n \t\"strconv\"\n \t\"text/scanner\"\n )\n \n const trace = false // set to true for debugging\n \n var (\n-\tpkgRoot = filepath.Join(runtime.GOROOT(), \"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH)\n \tpkgExts = [...]string{\".a\", \".5\", \".6\", \".8\"}\n )\n \n@@ -39,8 +38,12 @@ func findPkg(path string) (filename, id string) {\n \tvar noext string\n \tswitch path[0] {\n \tdefault:\n-\t\t// \"x\" -> \"$GOROOT/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n-\t\tnoext = filepath.Join(pkgRoot, path)\n+\t\t// \"x\" -> \"$GOPATH/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n+\t\ttree, pkg, err := build.FindTree(path)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tnoext = filepath.Join(tree.PkgDir(), pkg)\n \n \tcase '.':\n \t\t// \"./x\" -> \"/this/directory/x.ext\", \"/this/directory/x\""}, {"sha": "c229b50113db32b43a9c4914c7c2ba8fae41f7dd", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,7 +6,9 @@ package types\n \n import (\n \t\"go/ast\"\n+\t\"go/build\"\n \t\"io/ioutil\"\n+\t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -31,7 +33,7 @@ func init() {\n \t\tgcPath = gcName\n \t\treturn\n \t}\n-\tgcPath = filepath.Join(runtime.GOROOT(), \"/bin/tool/\", gcName)\n+\tgcPath = filepath.Join(build.ToolDir, gcName)\n }\n \n func compile(t *testing.T, dirname, filename string) {\n@@ -61,7 +63,7 @@ func testPath(t *testing.T, path string) bool {\n const maxTime = 3 * time.Second\n \n func testDir(t *testing.T, dir string, endTime time.Time) (nimports int) {\n-\tdirname := filepath.Join(pkgRoot, dir)\n+\tdirname := filepath.Join(runtime.GOROOT(), \"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH, dir)\n \tlist, err := ioutil.ReadDir(dirname)\n \tif err != nil {\n \t\tt.Errorf(\"testDir(%s): %s\", dirname, err)\n@@ -90,6 +92,13 @@ func testDir(t *testing.T, dir string, endTime time.Time) (nimports int) {\n }\n \n func TestGcImport(t *testing.T) {\n+\t// On cross-compile builds, the path will not exist.\n+\t// Need to use GOHOSTOS, which is not available.\n+\tif _, err := os.Stat(gcPath); err != nil {\n+\t\tt.Logf(\"skipping test: %v\", err)\n+\t\treturn\n+\t}\n+\n \tcompile(t, \"testdata\", \"exports.go\")\n \n \tnimports := 0"}, {"sha": "f34df59422f31d3dbdcdd59cb3803b3f785602b9", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -423,6 +423,7 @@ var fmttests = []struct {\n \t{\"p0=%p\", new(int), \"p0=0xPTR\"},\n \t{\"p1=%s\", &pValue, \"p1=String(p)\"}, // String method...\n \t{\"p2=%p\", &pValue, \"p2=0xPTR\"},     // ... not called with %p\n+\t{\"p3=%p\", (*int)(nil), \"p3=0x0\"},\n \t{\"p4=%#p\", new(int), \"p4=PTR\"},\n \n \t// %p on non-pointers\n@@ -431,6 +432,14 @@ var fmttests = []struct {\n \t{\"%p\", make([]int, 1), \"0xPTR\"},\n \t{\"%p\", 27, \"%!p(int=27)\"}, // not a pointer at all\n \n+\t// %q on pointers\n+\t{\"%q\", (*int)(nil), \"%!q(*int=<nil>)\"},\n+\t{\"%q\", new(int), \"%!q(*int=0xPTR)\"},\n+\n+\t// %v on pointers formats 0 as <nil>\n+\t{\"%v\", (*int)(nil), \"<nil>\"},\n+\t{\"%v\", new(int), \"0xPTR\"},\n+\n \t// %d on Stringer should give integer if possible\n \t{\"%s\", time.Time{}.Month(), \"January\"},\n \t{\"%d\", time.Time{}.Month(), \"1\"},"}, {"sha": "c3ba2f339e511bc3ccedfe68d8eab0f8e721fefc", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -553,6 +553,14 @@ func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, depth int) {\n }\n \n func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n+\tswitch verb {\n+\tcase 'p', 'v', 'b', 'd', 'o', 'x', 'X':\n+\t\t// ok\n+\tdefault:\n+\t\tp.badVerb(verb)\n+\t\treturn\n+\t}\n+\n \tvar u uintptr\n \tswitch value.Kind() {\n \tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n@@ -561,6 +569,7 @@ func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n \t\tp.badVerb(verb)\n \t\treturn\n \t}\n+\n \tif goSyntax {\n \t\tp.add('(')\n \t\tp.buf.WriteString(value.Type().String())\n@@ -572,6 +581,8 @@ func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n \t\t\tp.fmt0x64(uint64(u), true)\n \t\t}\n \t\tp.add(')')\n+\t} else if verb == 'v' && u == 0 {\n+\t\tp.buf.Write(nilAngleBytes)\n \t} else {\n \t\tp.fmt0x64(uint64(u), !p.fmt.sharp)\n \t}\n@@ -929,24 +940,7 @@ BigSwitch:\n \t\t\t\tbreak BigSwitch\n \t\t\t}\n \t\t}\n-\t\tif goSyntax {\n-\t\t\tp.buf.WriteByte('(')\n-\t\t\tp.buf.WriteString(value.Type().String())\n-\t\t\tp.buf.WriteByte(')')\n-\t\t\tp.buf.WriteByte('(')\n-\t\t\tif v == 0 {\n-\t\t\t\tp.buf.Write(nilBytes)\n-\t\t\t} else {\n-\t\t\t\tp.fmt0x64(uint64(v), true)\n-\t\t\t}\n-\t\t\tp.buf.WriteByte(')')\n-\t\t\tbreak\n-\t\t}\n-\t\tif v == 0 {\n-\t\t\tp.buf.Write(nilAngleBytes)\n-\t\t\tbreak\n-\t\t}\n-\t\tp.fmt0x64(uint64(v), true)\n+\t\tfallthrough\n \tcase reflect.Chan, reflect.Func, reflect.UnsafePointer:\n \t\tp.fmtPointer(value, verb, goSyntax)\n \tdefault:"}, {"sha": "fa9a5584a883f68a420be7e6d48f1b724fed66bc", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -512,7 +512,7 @@ func (s *ss) scanBool(verb rune) bool {\n \t\t}\n \t\treturn true\n \tcase 'f', 'F':\n-\t\tif s.accept(\"aL\") && (!s.accept(\"lL\") || !s.accept(\"sS\") || !s.accept(\"eE\")) {\n+\t\tif s.accept(\"aA\") && (!s.accept(\"lL\") || !s.accept(\"sS\") || !s.accept(\"eE\")) {\n \t\t\ts.error(boolError)\n \t\t}\n \t\treturn false"}, {"sha": "61b48f9cc6d3f265173c191ebcab8975f7626a6e", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -317,6 +317,7 @@ var overflowTests = []ScanTest{\n \t{\"(1-1e500i)\", &complex128Val, 0},\n }\n \n+var truth bool\n var i, j, k int\n var f float64\n var s, t string\n@@ -350,6 +351,9 @@ var multiTests = []ScanfMultiTest{\n \n \t// Bad UTF-8: should see every byte.\n \t{\"%c%c%c\", \"\\xc2X\\xc2\", args(&r1, &r2, &r3), args(utf8.RuneError, 'X', utf8.RuneError), \"\"},\n+\n+\t// Fixed bugs\n+\t{\"%v%v\", \"FALSE23\", args(&truth, &i), args(false, 23), \"\"},\n }\n \n func testScan(name string, t *testing.T, scan func(r io.Reader, a ...interface{}) (int, error)) {"}, {"sha": "908e61c5da01d71560449ebb777d5d3bd1405154", "filename": "libgo/go/go/ast/resolve.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -14,12 +14,12 @@ import (\n )\n \n type pkgBuilder struct {\n-\tscanner.ErrorVector\n-\tfset *token.FileSet\n+\tfset   *token.FileSet\n+\terrors scanner.ErrorList\n }\n \n func (p *pkgBuilder) error(pos token.Pos, msg string) {\n-\tp.Error(p.fset.Position(pos), msg)\n+\tp.errors.Add(p.fset.Position(pos), msg)\n }\n \n func (p *pkgBuilder) errorf(pos token.Pos, format string, args ...interface{}) {\n@@ -169,5 +169,6 @@ func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer,\n \t\tpkgScope.Outer = universe // reset universe scope\n \t}\n \n-\treturn &Package{pkgName, pkgScope, imports, files}, p.GetError(scanner.Sorted)\n+\tp.errors.Sort()\n+\treturn &Package{pkgName, pkgScope, imports, files}, p.errors.Err()\n }"}, {"sha": "6b30f76265b2450127261b29e9d5d4275e981ea6", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -25,10 +25,11 @@ import (\n \n // A Context specifies the supporting context for a build.\n type Context struct {\n-\tGOARCH     string   // target architecture\n-\tGOOS       string   // target operating system\n-\tCgoEnabled bool     // whether cgo can be used\n-\tBuildTags  []string // additional tags to recognize in +build lines\n+\tGOARCH      string   // target architecture\n+\tGOOS        string   // target operating system\n+\tCgoEnabled  bool     // whether cgo can be used\n+\tBuildTags   []string // additional tags to recognize in +build lines\n+\tUseAllFiles bool     // use files regardless of +build lines, file names\n \n \t// By default, ScanDir uses the operating system's\n \t// file system calls to read directories and files.\n@@ -225,6 +226,7 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \n \tvar Sfiles []string // files with \".S\" (capital S)\n \tvar di DirInfo\n+\tvar firstFile string\n \timported := make(map[string][]token.Position)\n \ttestImported := make(map[string][]token.Position)\n \tfset := token.NewFileSet()\n@@ -237,7 +239,7 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\tstrings.HasPrefix(name, \".\") {\n \t\t\tcontinue\n \t\t}\n-\t\tif !ctxt.goodOSArchFile(name) {\n+\t\tif !ctxt.UseAllFiles && !ctxt.goodOSArchFile(name) {\n \t\t\tcontinue\n \t\t}\n \n@@ -250,12 +252,13 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\tcontinue\n \t\t}\n \n-\t\t// Look for +build comments to accept or reject the file.\n \t\tfilename, data, err := ctxt.readFile(dir, name)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tif !ctxt.shouldBuild(data) {\n+\n+\t\t// Look for +build comments to accept or reject the file.\n+\t\tif !ctxt.UseAllFiles && !ctxt.shouldBuild(data) {\n \t\t\tcontinue\n \t\t}\n \n@@ -281,9 +284,6 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t}\n \n \t\tpkg := string(pf.Name.Name)\n-\t\tif pkg == \"main\" && di.Package != \"\" && di.Package != \"main\" {\n-\t\t\tcontinue\n-\t\t}\n \t\tif pkg == \"documentation\" {\n \t\t\tcontinue\n \t\t}\n@@ -293,15 +293,11 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\tpkg = pkg[:len(pkg)-len(\"_test\")]\n \t\t}\n \n-\t\tif pkg != di.Package && di.Package == \"main\" {\n-\t\t\t// Found non-main package but was recording\n-\t\t\t// information about package main.  Reset.\n-\t\t\tdi = DirInfo{}\n-\t\t}\n \t\tif di.Package == \"\" {\n \t\t\tdi.Package = pkg\n+\t\t\tfirstFile = name\n \t\t} else if pkg != di.Package {\n-\t\t\treturn nil, fmt.Errorf(\"%s: found packages %s and %s\", dir, pkg, di.Package)\n+\t\t\treturn nil, fmt.Errorf(\"%s: found packages %s (%s) and %s (%s)\", dir, di.Package, firstFile, pkg, name)\n \t\t}\n \t\tif pf.Doc != nil {\n \t\t\tif di.PackageComment != nil {"}, {"sha": "e160ac3b280bb13aad02c8605838542b1dc7c915", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,6 +12,9 @@ import (\n \t\"runtime\"\n )\n \n+// ToolDir is the directory containing build tools.\n+var ToolDir = filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+\n // Path is a validated list of Trees derived from $GOROOT and $GOPATH at init.\n var Path []*Tree\n "}, {"sha": "f957ede4abffc47ffcea0a48e51edb235464ca9f", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -14,12 +14,14 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"regexp\"\n \t\"strings\"\n \t\"testing\"\n \t\"text/template\"\n )\n \n var update = flag.Bool(\"update\", false, \"update golden (.out) files\")\n+var files = flag.String(\"files\", \"\", \"consider only Go test files matching this regular expression\")\n \n const dataDir = \"testdata\"\n \n@@ -66,14 +68,26 @@ type bundle struct {\n }\n \n func test(t *testing.T, mode Mode) {\n-\t// get all packages\n+\t// determine file filter\n+\tfilter := isGoFile\n+\tif *files != \"\" {\n+\t\trx, err := regexp.Compile(*files)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tfilter = func(fi os.FileInfo) bool {\n+\t\t\treturn isGoFile(fi) && rx.MatchString(fi.Name())\n+\t\t}\n+\t}\n+\n+\t// get packages\n \tfset := token.NewFileSet()\n-\tpkgs, err := parser.ParseDir(fset, dataDir, isGoFile, parser.ParseComments)\n+\tpkgs, err := parser.ParseDir(fset, dataDir, filter, parser.ParseComments)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \n-\t// test all packages\n+\t// test packages\n \tfor _, pkg := range pkgs {\n \t\timportpath := dataDir + \"/\" + pkg.Name\n \t\tdoc := New(pkg, importpath, mode)"}, {"sha": "1c23b0d95c3928edc3d7b5ba8de4a911cdf57d13", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,6 +9,7 @@ package doc\n import (\n \t\"go/ast\"\n \t\"go/printer\"\n+\t\"go/token\"\n \t\"strings\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n@@ -21,28 +22,47 @@ type Example struct {\n }\n \n func Examples(pkg *ast.Package) []*Example {\n-\tvar examples []*Example\n-\tfor _, src := range pkg.Files {\n-\t\tfor _, decl := range src.Decls {\n+\tvar list []*Example\n+\tfor _, file := range pkg.Files {\n+\t\thasTests := false // file contains tests or benchmarks\n+\t\tnumDecl := 0      // number of non-import declarations in the file\n+\t\tvar flist []*Example\n+\t\tfor _, decl := range file.Decls {\n+\t\t\tif g, ok := decl.(*ast.GenDecl); ok && g.Tok != token.IMPORT {\n+\t\t\t\tnumDecl++\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tf, ok := decl.(*ast.FuncDecl)\n \t\t\tif !ok {\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tnumDecl++\n \t\t\tname := f.Name.Name\n+\t\t\tif isTest(name, \"Test\") || isTest(name, \"Benchmark\") {\n+\t\t\t\thasTests = true\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tif !isTest(name, \"Example\") {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\texamples = append(examples, &Example{\n+\t\t\tflist = append(flist, &Example{\n \t\t\t\tName: name[len(\"Example\"):],\n \t\t\t\tBody: &printer.CommentedNode{\n \t\t\t\t\tNode:     f.Body,\n-\t\t\t\t\tComments: src.Comments,\n+\t\t\t\t\tComments: file.Comments,\n \t\t\t\t},\n \t\t\t\tOutput: f.Doc.Text(),\n \t\t\t})\n \t\t}\n+\t\tif !hasTests && numDecl > 1 && len(flist) == 1 {\n+\t\t\t// If this file only has one example function, some\n+\t\t\t// other top-level declarations, and no tests or\n+\t\t\t// benchmarks, use the whole file as the example.\n+\t\t\tflist[0].Body.Node = file\n+\t\t}\n+\t\tlist = append(list, flist...)\n \t}\n-\treturn examples\n+\treturn list\n }\n \n // isTest tells whether name looks like a test, example, or benchmark."}, {"sha": "146be5d87070d485b26c3f65e92b99d23e199788", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -22,12 +22,38 @@ func filterIdentList(list []*ast.Ident) []*ast.Ident {\n \treturn list[0:j]\n }\n \n+// removeErrorField removes anonymous fields named \"error\" from an interface.\n+// This is called when \"error\" has been determined to be a local name,\n+// not the predeclared type.\n+//\n+func removeErrorField(ityp *ast.InterfaceType) {\n+\tlist := ityp.Methods.List // we know that ityp.Methods != nil\n+\tj := 0\n+\tfor _, field := range list {\n+\t\tkeepField := true\n+\t\tif n := len(field.Names); n == 0 {\n+\t\t\t// anonymous field\n+\t\t\tif fname, _ := baseTypeName(field.Type); fname == \"error\" {\n+\t\t\t\tkeepField = false\n+\t\t\t}\n+\t\t}\n+\t\tif keepField {\n+\t\t\tlist[j] = field\n+\t\t\tj++\n+\t\t}\n+\t}\n+\tif j < len(list) {\n+\t\tityp.Incomplete = true\n+\t}\n+\tityp.Methods.List = list[0:j]\n+}\n+\n // filterFieldList removes unexported fields (field names) from the field list\n // in place and returns true if fields were removed. Anonymous fields are\n // recorded with the parent type. filterType is called with the types of\n // all remaining fields.\n //\n-func (r *reader) filterFieldList(parent *namedType, fields *ast.FieldList) (removedFields bool) {\n+func (r *reader) filterFieldList(parent *namedType, fields *ast.FieldList, ityp *ast.InterfaceType) (removedFields bool) {\n \tif fields == nil {\n \t\treturn\n \t}\n@@ -37,9 +63,15 @@ func (r *reader) filterFieldList(parent *namedType, fields *ast.FieldList) (remo\n \t\tkeepField := false\n \t\tif n := len(field.Names); n == 0 {\n \t\t\t// anonymous field\n-\t\t\tname := r.recordAnonymousField(parent, field.Type)\n-\t\t\tif ast.IsExported(name) {\n+\t\t\tfname := r.recordAnonymousField(parent, field.Type)\n+\t\t\tif ast.IsExported(fname) {\n+\t\t\t\tkeepField = true\n+\t\t\t} else if ityp != nil && fname == \"error\" {\n+\t\t\t\t// possibly the predeclared error interface; keep\n+\t\t\t\t// it for now but remember this interface so that\n+\t\t\t\t// it can be fixed if error is also defined locally\n \t\t\t\tkeepField = true\n+\t\t\t\tr.remember(ityp)\n \t\t\t}\n \t\t} else {\n \t\t\tfield.Names = filterIdentList(field.Names)\n@@ -86,14 +118,14 @@ func (r *reader) filterType(parent *namedType, typ ast.Expr) {\n \tcase *ast.ArrayType:\n \t\tr.filterType(nil, t.Elt)\n \tcase *ast.StructType:\n-\t\tif r.filterFieldList(parent, t.Fields) {\n+\t\tif r.filterFieldList(parent, t.Fields, nil) {\n \t\t\tt.Incomplete = true\n \t\t}\n \tcase *ast.FuncType:\n \t\tr.filterParamList(t.Params)\n \t\tr.filterParamList(t.Results)\n \tcase *ast.InterfaceType:\n-\t\tif r.filterFieldList(parent, t.Methods) {\n+\t\tif r.filterFieldList(parent, t.Methods, t) {\n \t\t\tt.Incomplete = true\n \t\t}\n \tcase *ast.MapType:\n@@ -116,9 +148,12 @@ func (r *reader) filterSpec(spec ast.Spec) bool {\n \t\t\treturn true\n \t\t}\n \tcase *ast.TypeSpec:\n-\t\tif ast.IsExported(s.Name.Name) {\n+\t\tif name := s.Name.Name; ast.IsExported(name) {\n \t\t\tr.filterType(r.lookupType(s.Name.Name), s.Type)\n \t\t\treturn true\n+\t\t} else if name == \"error\" {\n+\t\t\t// special case: remember that error is declared locally\n+\t\t\tr.errorDecl = true\n \t\t}\n \t}\n \treturn false"}, {"sha": "f5593476382cacfb30a4c9ae6f9e0551c082f72c", "filename": "libgo/go/go/doc/headscan.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n /*\n \tThe headscan command extracts comment headings from package files;\n \tit is used to detect false positives which may require an adjustment"}, {"sha": "bdfb294adb001bc3f3072b96e4b6d8e318c2d07c", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,7 +17,7 @@ import (\n //\n // Internally, we treat functions like methods and collect them in method sets.\n \n-// methodSet describes a set of methods. Entries where Decl == nil are conflict\n+// A methodSet describes a set of methods. Entries where Decl == nil are conflict\n // entries (more then one method with the same name at the same embedding level).\n //\n type methodSet map[string]*Func\n@@ -110,6 +110,9 @@ func baseTypeName(x ast.Expr) (name string, imported bool) {\n \treturn\n }\n \n+// An embeddedSet describes a set of embedded types.\n+type embeddedSet map[*namedType]bool\n+\n // A namedType represents a named unqualified (package local, or possibly\n // predeclared) type. The namedType for a type name is always found via\n // reader.lookupType.\n@@ -119,9 +122,9 @@ type namedType struct {\n \tname string       // type name\n \tdecl *ast.GenDecl // nil if declaration hasn't been seen yet\n \n-\tisEmbedded bool                // true if this type is embedded\n-\tisStruct   bool                // true if this type is a struct\n-\tembedded   map[*namedType]bool // true if the embedded type is a pointer\n+\tisEmbedded bool        // true if this type is embedded\n+\tisStruct   bool        // true if this type is a struct\n+\tembedded   embeddedSet // true if the embedded type is a pointer\n \n \t// associated declarations\n \tvalues  []*Value // consts and vars\n@@ -152,6 +155,10 @@ type reader struct {\n \tvalues  []*Value // consts and vars\n \ttypes   map[string]*namedType\n \tfuncs   methodSet\n+\n+\t// support for package-local error type declarations\n+\terrorDecl bool                 // if set, type \"error\" was declared locally\n+\tfixlist   []*ast.InterfaceType // list of interfaces containing anonymous field \"error\"\n }\n \n func (r *reader) isVisible(name string) bool {\n@@ -173,7 +180,7 @@ func (r *reader) lookupType(name string) *namedType {\n \t// type not found - add one without declaration\n \ttyp := &namedType{\n \t\tname:     name,\n-\t\tembedded: make(map[*namedType]bool),\n+\t\tembedded: make(embeddedSet),\n \t\tfuncs:    make(methodSet),\n \t\tmethods:  make(methodSet),\n \t}\n@@ -210,6 +217,10 @@ func (r *reader) readDoc(comment *ast.CommentGroup) {\n \tr.doc += \"\\n\" + text\n }\n \n+func (r *reader) remember(typ *ast.InterfaceType) {\n+\tr.fixlist = append(r.fixlist, typ)\n+}\n+\n func specNames(specs []ast.Spec) []string {\n \tnames := make([]string, 0, len(specs)) // reasonable estimate\n \tfor _, s := range specs {\n@@ -274,7 +285,7 @@ func (r *reader) readValue(decl *ast.GenDecl) {\n \t// determine values list with which to associate the Value for this decl\n \tvalues := &r.values\n \tconst threshold = 0.75\n-\tif domName != \"\" && domFreq >= int(float64(len(decl.Specs))*threshold) {\n+\tif domName != \"\" && r.isVisible(domName) && domFreq >= int(float64(len(decl.Specs))*threshold) {\n \t\t// typed entries are sufficiently frequent\n \t\tif typ := r.lookupType(domName); typ != nil {\n \t\t\tvalues = &typ.values // associate with that type\n@@ -315,7 +326,7 @@ func (r *reader) readType(decl *ast.GenDecl, spec *ast.TypeSpec) {\n \t\treturn // no name or blank name - ignore the type\n \t}\n \n-\t// A type should be added at most once, so info.decl\n+\t// A type should be added at most once, so typ.decl\n \t// should be nil - if it is not, simply overwrite it.\n \ttyp.decl = decl\n \n@@ -543,7 +554,8 @@ func customizeRecv(f *Func, recvTypeName string, embeddedIsPtr bool, level int)\n \n // collectEmbeddedMethods collects the embedded methods of typ in mset.\n //\n-func (r *reader) collectEmbeddedMethods(mset methodSet, typ *namedType, recvTypeName string, embeddedIsPtr bool, level int) {\n+func (r *reader) collectEmbeddedMethods(mset methodSet, typ *namedType, recvTypeName string, embeddedIsPtr bool, level int, visited embeddedSet) {\n+\tvisited[typ] = true\n \tfor embedded, isPtr := range typ.embedded {\n \t\t// Once an embedded type is embedded as a pointer type\n \t\t// all embedded types in those types are treated like\n@@ -557,8 +569,11 @@ func (r *reader) collectEmbeddedMethods(mset methodSet, typ *namedType, recvType\n \t\t\t\tmset.add(customizeRecv(m, recvTypeName, thisEmbeddedIsPtr, level))\n \t\t\t}\n \t\t}\n-\t\tr.collectEmbeddedMethods(mset, embedded, recvTypeName, thisEmbeddedIsPtr, level+1)\n+\t\tif !visited[embedded] {\n+\t\t\tr.collectEmbeddedMethods(mset, embedded, recvTypeName, thisEmbeddedIsPtr, level+1, visited)\n+\t\t}\n \t}\n+\tdelete(visited, typ)\n }\n \n // computeMethodSets determines the actual method sets for each type encountered.\n@@ -568,12 +583,19 @@ func (r *reader) computeMethodSets() {\n \t\t// collect embedded methods for t\n \t\tif t.isStruct {\n \t\t\t// struct\n-\t\t\tr.collectEmbeddedMethods(t.methods, t, t.name, false, 1)\n+\t\t\tr.collectEmbeddedMethods(t.methods, t, t.name, false, 1, make(embeddedSet))\n \t\t} else {\n \t\t\t// interface\n \t\t\t// TODO(gri) fix this\n \t\t}\n \t}\n+\n+\t// if error was declared locally, don't treat it as exported field anymore\n+\tif r.errorDecl {\n+\t\tfor _, ityp := range r.fixlist {\n+\t\t\tremoveErrorField(ityp)\n+\t\t}\n+\t}\n }\n \n // cleanupTypes removes the association of functions and methods with"}, {"sha": "9d93392eaa59331c2943c8731df1802db6c9cde5", "filename": "libgo/go/go/doc/testdata/b.0.golden", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.0.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -11,19 +11,47 @@ FILENAMES\n \ttestdata/b.go\n \n CONSTANTS\n+\t// \n+\tconst (\n+\t\tC1\tnotExported\t= iota\n+\t\tC2\n+\t\n+\t\tC4\n+\t\tC5\n+\t)\n+\n+\t// \n+\tconst C notExported = 0\n+\n \t// \n \tconst Pi = 3.14\t// Pi\n \n \n VARIABLES\n+\t// \n+\tvar (\n+\t\tU1, U2, U4, U5\tnotExported\n+\t\n+\t\tU7\tnotExported\t= 7\n+\t)\n+\n \t// \n \tvar MaxInt int\t// MaxInt\n \n+\t// \n+\tvar V notExported\n+\n+\t// \n+\tvar V1, V2, V4, V5 notExported\n+\n \n FUNCTIONS\n \t// \n \tfunc F(x int) int\n \n+\t// \n+\tfunc F1() notExported\n+\n \t// Always under the package functions list. \n \tfunc NotAFactory() int\n "}, {"sha": "66c47b5c2a7175d853cd5f9293b3563a9d91eef7", "filename": "libgo/go/go/doc/testdata/b.1.golden", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.1.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -38,8 +38,42 @@ TYPES\n \t// \n \tfunc (x *T) M()\n \n+\t// \n+\ttype notExported int\n+\n+\t// \n+\tconst (\n+\t\tC1\tnotExported\t= iota\n+\t\tC2\n+\t\tc3\n+\t\tC4\n+\t\tC5\n+\t)\n+\n+\t// \n+\tconst C notExported = 0\n+\n+\t// \n+\tvar (\n+\t\tU1, U2, u3, U4, U5\tnotExported\n+\t\tu6\t\t\tnotExported\n+\t\tU7\t\t\tnotExported\t= 7\n+\t)\n+\n+\t// \n+\tvar V notExported\n+\n+\t// \n+\tvar V1, V2, v3, V4, V5 notExported\n+\n+\t// \n+\tfunc F1() notExported\n+\n+\t// \n+\tfunc f2() notExported\n+\n \t// Should only appear if AllDecls is set. \n-\ttype uint struct{}\n+\ttype uint struct{}\t// overrides a predeclared type uint\n \n \t// Associated with uint type if AllDecls is set. \n \tfunc UintFactory() uint"}, {"sha": "9d93392eaa59331c2943c8731df1802db6c9cde5", "filename": "libgo/go/go/doc/testdata/b.2.golden", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -11,19 +11,47 @@ FILENAMES\n \ttestdata/b.go\n \n CONSTANTS\n+\t// \n+\tconst (\n+\t\tC1\tnotExported\t= iota\n+\t\tC2\n+\t\n+\t\tC4\n+\t\tC5\n+\t)\n+\n+\t// \n+\tconst C notExported = 0\n+\n \t// \n \tconst Pi = 3.14\t// Pi\n \n \n VARIABLES\n+\t// \n+\tvar (\n+\t\tU1, U2, U4, U5\tnotExported\n+\t\n+\t\tU7\tnotExported\t= 7\n+\t)\n+\n \t// \n \tvar MaxInt int\t// MaxInt\n \n+\t// \n+\tvar V notExported\n+\n+\t// \n+\tvar V1, V2, V4, V5 notExported\n+\n \n FUNCTIONS\n \t// \n \tfunc F(x int) int\n \n+\t// \n+\tfunc F1() notExported\n+\n \t// Always under the package functions list. \n \tfunc NotAFactory() int\n "}, {"sha": "e50663b3dfaa8747cd13b173fd2baff61705db91", "filename": "libgo/go/go/doc/testdata/b.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,6 +6,7 @@ package b\n \n import \"a\"\n \n+// ----------------------------------------------------------------------------\n // Basic declarations\n \n const Pi = 3.14   // Pi\n@@ -28,3 +29,30 @@ func uintFactory() uint {}\n \n // Should only appear if AllDecls is set.\n type uint struct{} // overrides a predeclared type uint\n+\n+// ----------------------------------------------------------------------------\n+// Exported declarations associated with non-exported types must always be shown.\n+\n+type notExported int\n+\n+const C notExported = 0\n+\n+const (\n+\tC1 notExported = iota\n+\tC2\n+\tc3\n+\tC4\n+\tC5\n+)\n+\n+var V notExported\n+var V1, V2, v3, V4, V5 notExported\n+\n+var (\n+\tU1, U2, u3, U4, U5 notExported\n+\tu6                 notExported\n+\tU7                 notExported = 7\n+)\n+\n+func F1() notExported {}\n+func f2() notExported {}"}, {"sha": "6987e5867cffc7b6eb203bfd5a1ab44fb7e49257", "filename": "libgo/go/go/doc/testdata/e.0.golden", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -40,3 +40,70 @@ TYPES\n \t\tT4\n \t}\n \n+\t// \n+\ttype U1 struct {\n+\t\t*U1\n+\t}\n+\n+\t// U1.M should appear as method of U1. \n+\tfunc (*U1) M()\n+\n+\t// \n+\ttype U2 struct {\n+\t\t*U3\n+\t}\n+\n+\t// U2.M should appear as method of U2 and as method of U3 only if ...\n+\tfunc (*U2) M()\n+\n+\t// \n+\ttype U3 struct {\n+\t\t*U2\n+\t}\n+\n+\t// U3.N should appear as method of U3 and as method of U2 only if ...\n+\tfunc (*U3) N()\n+\n+\t// \n+\ttype U4 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// U4.M should appear as method of U4. \n+\tfunc (*U4) M()\n+\n+\t// \n+\ttype V1 struct {\n+\t\t*V2\n+\t\t*V5\n+\t}\n+\n+\t// \n+\ttype V2 struct {\n+\t\t*V3\n+\t}\n+\n+\t// \n+\ttype V3 struct {\n+\t\t*V4\n+\t}\n+\n+\t// \n+\ttype V4 struct {\n+\t\t*V5\n+\t}\n+\n+\t// V4.M should appear as method of V2 and V3 if AllMethods is set. \n+\tfunc (*V4) M()\n+\n+\t// \n+\ttype V5 struct {\n+\t\t*V6\n+\t}\n+\n+\t// \n+\ttype V6 struct{}\n+\n+\t// V6.M should appear as method of V1 and V5 if AllMethods is set. \n+\tfunc (*V6) M()\n+"}, {"sha": "cbe22e0bf63e763e6589e3cdbb9e1e6b540aca86", "filename": "libgo/go/go/doc/testdata/e.1.golden", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -42,6 +42,73 @@ TYPES\n \t\tT4\n \t}\n \n+\t// \n+\ttype U1 struct {\n+\t\t*U1\n+\t}\n+\n+\t// U1.M should appear as method of U1. \n+\tfunc (*U1) M()\n+\n+\t// \n+\ttype U2 struct {\n+\t\t*U3\n+\t}\n+\n+\t// U2.M should appear as method of U2 and as method of U3 only if ...\n+\tfunc (*U2) M()\n+\n+\t// \n+\ttype U3 struct {\n+\t\t*U2\n+\t}\n+\n+\t// U3.N should appear as method of U3 and as method of U2 only if ...\n+\tfunc (*U3) N()\n+\n+\t// \n+\ttype U4 struct {\n+\t\t*u5\n+\t}\n+\n+\t// U4.M should appear as method of U4. \n+\tfunc (*U4) M()\n+\n+\t// \n+\ttype V1 struct {\n+\t\t*V2\n+\t\t*V5\n+\t}\n+\n+\t// \n+\ttype V2 struct {\n+\t\t*V3\n+\t}\n+\n+\t// \n+\ttype V3 struct {\n+\t\t*V4\n+\t}\n+\n+\t// \n+\ttype V4 struct {\n+\t\t*V5\n+\t}\n+\n+\t// V4.M should appear as method of V2 and V3 if AllMethods is set. \n+\tfunc (*V4) M()\n+\n+\t// \n+\ttype V5 struct {\n+\t\t*V6\n+\t}\n+\n+\t// \n+\ttype V6 struct{}\n+\n+\t// V6.M should appear as method of V1 and V5 if AllMethods is set. \n+\tfunc (*V6) M()\n+\n \t// \n \ttype t1 struct{}\n \n@@ -70,3 +137,8 @@ TYPES\n \t// t2.M should not appear as method in a Tx type. \n \tfunc (t2e) M()\n \n+\t// \n+\ttype u5 struct {\n+\t\t*U4\n+\t}\n+"}, {"sha": "e7b05e80faf203e985f4e7a2239b31984621deed", "filename": "libgo/go/go/doc/testdata/e.2.golden", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.2.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -43,3 +43,88 @@ TYPES\n \t// T4.M should appear as method of T5 only if AllMethods is set. \n \tfunc (*T5) M()\n \n+\t// \n+\ttype U1 struct {\n+\t\t*U1\n+\t}\n+\n+\t// U1.M should appear as method of U1. \n+\tfunc (*U1) M()\n+\n+\t// \n+\ttype U2 struct {\n+\t\t*U3\n+\t}\n+\n+\t// U2.M should appear as method of U2 and as method of U3 only if ...\n+\tfunc (*U2) M()\n+\n+\t// U3.N should appear as method of U3 and as method of U2 only if ...\n+\tfunc (U2) N()\n+\n+\t// \n+\ttype U3 struct {\n+\t\t*U2\n+\t}\n+\n+\t// U2.M should appear as method of U2 and as method of U3 only if ...\n+\tfunc (U3) M()\n+\n+\t// U3.N should appear as method of U3 and as method of U2 only if ...\n+\tfunc (*U3) N()\n+\n+\t// \n+\ttype U4 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// U4.M should appear as method of U4. \n+\tfunc (*U4) M()\n+\n+\t// \n+\ttype V1 struct {\n+\t\t*V2\n+\t\t*V5\n+\t}\n+\n+\t// V6.M should appear as method of V1 and V5 if AllMethods is set. \n+\tfunc (V1) M()\n+\n+\t// \n+\ttype V2 struct {\n+\t\t*V3\n+\t}\n+\n+\t// V4.M should appear as method of V2 and V3 if AllMethods is set. \n+\tfunc (V2) M()\n+\n+\t// \n+\ttype V3 struct {\n+\t\t*V4\n+\t}\n+\n+\t// V4.M should appear as method of V2 and V3 if AllMethods is set. \n+\tfunc (V3) M()\n+\n+\t// \n+\ttype V4 struct {\n+\t\t*V5\n+\t}\n+\n+\t// V4.M should appear as method of V2 and V3 if AllMethods is set. \n+\tfunc (*V4) M()\n+\n+\t// \n+\ttype V5 struct {\n+\t\t*V6\n+\t}\n+\n+\t// V6.M should appear as method of V1 and V5 if AllMethods is set. \n+\tfunc (V5) M()\n+\n+\t// \n+\ttype V6 struct{}\n+\n+\t// V6.M should appear as method of V1 and V5 if AllMethods is set. \n+\tfunc (*V6) M()\n+"}, {"sha": "19dd138cf404ba4a3738140e1a9e3a4a5e6e627a", "filename": "libgo/go/go/doc/testdata/e.go", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -77,3 +77,71 @@ func (*T4) M() {}\n type T5 struct {\n \tT4\n }\n+\n+// ----------------------------------------------------------------------------\n+// Recursive type declarations must not lead to endless recursion.\n+\n+type U1 struct {\n+\t*U1\n+}\n+\n+// U1.M should appear as method of U1.\n+func (*U1) M() {}\n+\n+type U2 struct {\n+\t*U3\n+}\n+\n+// U2.M should appear as method of U2 and as method of U3 only if AllMethods is set.\n+func (*U2) M() {}\n+\n+type U3 struct {\n+\t*U2\n+}\n+\n+// U3.N should appear as method of U3 and as method of U2 only if AllMethods is set.\n+func (*U3) N() {}\n+\n+type U4 struct {\n+\t*u5\n+}\n+\n+// U4.M should appear as method of U4. \n+func (*U4) M() {}\n+\n+type u5 struct {\n+\t*U4\n+}\n+\n+// ----------------------------------------------------------------------------\n+// A higher-level embedded type (and its methods) wins over the same type (and\n+// its methods) embedded at a lower level.\n+\n+type V1 struct {\n+\t*V2\n+\t*V5\n+}\n+\n+type V2 struct {\n+\t*V3\n+}\n+\n+type V3 struct {\n+\t*V4\n+}\n+\n+type V4 struct {\n+\t*V5\n+}\n+\n+type V5 struct {\n+\t*V6\n+}\n+\n+type V6 struct{}\n+\n+// V4.M should appear as method of V2 and V3 if AllMethods is set.\n+func (*V4) M() {}\n+\n+// V6.M should appear as method of V1 and V5 if AllMethods is set.\n+func (*V6) M() {}"}, {"sha": "6c6fe5d49bdf04d6572c104bd8edcd44318545bd", "filename": "libgo/go/go/doc/testdata/error1.0.golden", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.0.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,30 @@\n+// \n+PACKAGE error1\n+\n+IMPORTPATH\n+\ttestdata/error1\n+\n+FILENAMES\n+\ttestdata/error1.go\n+\n+TYPES\n+\t// \n+\ttype I0 interface {\n+\t\t// When embedded, the predeclared error interface\n+\t\t// must remain visible in interface types.\n+\t\terror\n+\t}\n+\n+\t// \n+\ttype S0 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// \n+\ttype T0 struct {\n+\t\tExportedField interface {\n+\t\t\t// error should be visible\n+\t\t\terror\n+\t\t}\n+\t}\n+"}, {"sha": "a8dc2e71dc31f84cc8f04cb2f3f92781d9d49de6", "filename": "libgo/go/go/doc/testdata/error1.1.golden", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.1.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,32 @@\n+// \n+PACKAGE error1\n+\n+IMPORTPATH\n+\ttestdata/error1\n+\n+FILENAMES\n+\ttestdata/error1.go\n+\n+TYPES\n+\t// \n+\ttype I0 interface {\n+\t\t// When embedded, the predeclared error interface\n+\t\t// must remain visible in interface types.\n+\t\terror\n+\t}\n+\n+\t// \n+\ttype S0 struct {\n+\t\t// In struct types, an embedded error must only be visible\n+\t\t// if AllDecls is set.\n+\t\terror\n+\t}\n+\n+\t// \n+\ttype T0 struct {\n+\t\tExportedField interface {\n+\t\t\t// error should be visible\n+\t\t\terror\n+\t\t}\n+\t}\n+"}, {"sha": "6c6fe5d49bdf04d6572c104bd8edcd44318545bd", "filename": "libgo/go/go/doc/testdata/error1.2.golden", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.2.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,30 @@\n+// \n+PACKAGE error1\n+\n+IMPORTPATH\n+\ttestdata/error1\n+\n+FILENAMES\n+\ttestdata/error1.go\n+\n+TYPES\n+\t// \n+\ttype I0 interface {\n+\t\t// When embedded, the predeclared error interface\n+\t\t// must remain visible in interface types.\n+\t\terror\n+\t}\n+\n+\t// \n+\ttype S0 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// \n+\ttype T0 struct {\n+\t\tExportedField interface {\n+\t\t\t// error should be visible\n+\t\t\terror\n+\t\t}\n+\t}\n+"}, {"sha": "3c777a78005a073c984dc2f509d1d99d8129c468", "filename": "libgo/go/go/doc/testdata/error1.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror1.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package error1\n+\n+type I0 interface {\n+\t// When embedded, the predeclared error interface\n+\t// must remain visible in interface types.\n+\terror\n+}\n+\n+type T0 struct {\n+\tExportedField interface {\n+\t\t// error should be visible\n+\t\terror\n+\t}\n+}\n+\n+type S0 struct {\n+\t// In struct types, an embedded error must only be visible\n+\t// if AllDecls is set.\n+\terror\n+}"}, {"sha": "dedfe412a0fcbef55f7838e035533686217bdefc", "filename": "libgo/go/go/doc/testdata/error2.0.golden", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.0.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,27 @@\n+// \n+PACKAGE error2\n+\n+IMPORTPATH\n+\ttestdata/error2\n+\n+FILENAMES\n+\ttestdata/error2.go\n+\n+TYPES\n+\t// \n+\ttype I0 interface {\n+\t\t// contains filtered or unexported methods\n+\t}\n+\n+\t// \n+\ttype S0 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// \n+\ttype T0 struct {\n+\t\tExportedField interface {\n+\t\t\t// contains filtered or unexported methods\n+\t\t}\n+\t}\n+"}, {"sha": "776bd1b3e40bd95566a173bbce07a0ba87f8ad9d", "filename": "libgo/go/go/doc/testdata/error2.1.golden", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.1.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,37 @@\n+// \n+PACKAGE error2\n+\n+IMPORTPATH\n+\ttestdata/error2\n+\n+FILENAMES\n+\ttestdata/error2.go\n+\n+TYPES\n+\t// \n+\ttype I0 interface {\n+\t\t// When embedded, the the locally declared error interface\n+\t\t// is only visible if all declarations are shown.\n+\t\terror\n+\t}\n+\n+\t// \n+\ttype S0 struct {\n+\t\t// In struct types, an embedded error must only be visible\n+\t\t// if AllDecls is set.\n+\t\terror\n+\t}\n+\n+\t// \n+\ttype T0 struct {\n+\t\tExportedField interface {\n+\t\t\t// error should not be visible\n+\t\t\terror\n+\t\t}\n+\t}\n+\n+\t// This error declaration shadows the predeclared error type. \n+\ttype error interface {\n+\t\tError() string\n+\t}\n+"}, {"sha": "dedfe412a0fcbef55f7838e035533686217bdefc", "filename": "libgo/go/go/doc/testdata/error2.2.golden", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.2.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,27 @@\n+// \n+PACKAGE error2\n+\n+IMPORTPATH\n+\ttestdata/error2\n+\n+FILENAMES\n+\ttestdata/error2.go\n+\n+TYPES\n+\t// \n+\ttype I0 interface {\n+\t\t// contains filtered or unexported methods\n+\t}\n+\n+\t// \n+\ttype S0 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// \n+\ttype T0 struct {\n+\t\tExportedField interface {\n+\t\t\t// contains filtered or unexported methods\n+\t\t}\n+\t}\n+"}, {"sha": "6cc36feef3e8c15369550207a221bf9cc84eb6b9", "filename": "libgo/go/go/doc/testdata/error2.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package error2\n+\n+type I0 interface {\n+\t// When embedded, the the locally declared error interface\n+\t// is only visible if all declarations are shown.\n+\terror\n+}\n+\n+type T0 struct {\n+\tExportedField interface {\n+\t\t// error should not be visible\n+\t\terror\n+\t}\n+}\n+\n+type S0 struct {\n+\t// In struct types, an embedded error must only be visible\n+\t// if AllDecls is set.\n+\terror\n+}\n+\n+// This error declaration shadows the predeclared error type.\n+type error interface {\n+\tError() string\n+}"}, {"sha": "7e9add90784ca1268903fa801f6b7c53ed472bbc", "filename": "libgo/go/go/doc/testdata/f.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n+// Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "5c203a7846e22b7b2fe583f15cfea034a05a45c7", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -80,13 +80,25 @@ const (\n // are returned via a scanner.ErrorList which is sorted by file position.\n //\n func ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode) (*ast.File, error) {\n+\t// get source\n \ttext, err := readSource(filename, src)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n+\t// parse source\n \tvar p parser\n \tp.init(fset, filename, text, mode)\n-\treturn p.parseFile(), p.errors()\n+\tf := p.parseFile()\n+\n+\t// sort errors\n+\tif p.mode&SpuriousErrors == 0 {\n+\t\tp.errors.RemoveMultiples()\n+\t} else {\n+\t\tp.errors.Sort()\n+\t}\n+\n+\treturn f, p.errors.Err()\n }\n \n // ParseDir calls ParseFile for the files in the directory specified by path and"}, {"sha": "6a0b61eb48cf3630396888b753d141a75561e4fa", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -18,8 +18,8 @@ import (\n \n // The parser structure holds the parser's internal state.\n type parser struct {\n-\tfile *token.File\n-\tscanner.ErrorVector\n+\tfile    *token.File\n+\terrors  scanner.ErrorList\n \tscanner scanner.Scanner\n \n \t// Tracing/debugging\n@@ -58,7 +58,8 @@ func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mod\n \tif mode&ParseComments != 0 {\n \t\tm = scanner.ScanComments\n \t}\n-\tp.scanner.Init(p.file, src, p, m)\n+\teh := func(pos token.Position, msg string) { p.errors.Add(pos, msg) }\n+\tp.scanner.Init(p.file, src, eh, m)\n \n \tp.mode = mode\n \tp.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)\n@@ -74,14 +75,6 @@ func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mod\n \tp.openLabelScope()\n }\n \n-func (p *parser) errors() error {\n-\tm := scanner.Sorted\n-\tif p.mode&SpuriousErrors == 0 {\n-\t\tm = scanner.NoMultiples\n-\t}\n-\treturn p.GetError(m)\n-}\n-\n // ----------------------------------------------------------------------------\n // Scoping support\n \n@@ -334,15 +327,15 @@ func (p *parser) next() {\n }\n \n func (p *parser) error(pos token.Pos, msg string) {\n-\tp.Error(p.file.Position(pos), msg)\n+\tp.errors.Add(p.file.Position(pos), msg)\n }\n \n func (p *parser) errorExpected(pos token.Pos, msg string) {\n \tmsg = \"expected \" + msg\n \tif pos == p.pos {\n \t\t// the error happened at the current position;\n \t\t// make the error message more specific\n-\t\tif p.tok == token.SEMICOLON && p.lit[0] == '\\n' {\n+\t\tif p.tok == token.SEMICOLON && p.lit == \"\\n\" {\n \t\t\tmsg += \", found newline\"\n \t\t} else {\n \t\t\tmsg += \", found '\" + p.tok.String() + \"'\"\n@@ -363,6 +356,17 @@ func (p *parser) expect(tok token.Token) token.Pos {\n \treturn pos\n }\n \n+// expectClosing is like expect but provides a better error message\n+// for the common case of a missing comma before a newline.\n+//\n+func (p *parser) expectClosing(tok token.Token, construct string) token.Pos {\n+\tif p.tok != tok && p.tok == token.SEMICOLON && p.lit == \"\\n\" {\n+\t\tp.error(p.pos, \"missing ',' before newline in \"+construct)\n+\t\tp.next()\n+\t}\n+\treturn p.expect(tok)\n+}\n+\n func (p *parser) expectSemi() {\n \tif p.tok != token.RPAREN && p.tok != token.RBRACE {\n \t\tp.expect(token.SEMICOLON)\n@@ -1063,7 +1067,7 @@ func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {\n \t\tp.next()\n \t}\n \tp.exprLev--\n-\trparen := p.expect(token.RPAREN)\n+\trparen := p.expectClosing(token.RPAREN, \"argument list\")\n \n \treturn &ast.CallExpr{fun, lparen, list, ellipsis, rparen}\n }\n@@ -1118,7 +1122,7 @@ func (p *parser) parseLiteralValue(typ ast.Expr) ast.Expr {\n \t\telts = p.parseElementList()\n \t}\n \tp.exprLev--\n-\trbrace := p.expect(token.RBRACE)\n+\trbrace := p.expectClosing(token.RBRACE, \"composite literal\")\n \treturn &ast.CompositeLit{typ, lbrace, elts, rbrace}\n }\n \n@@ -2123,7 +2127,7 @@ func (p *parser) parseFile() *ast.File {\n \t// Don't bother parsing the rest if we had errors already.\n \t// Likely not a Go source file at all.\n \n-\tif p.ErrorCount() == 0 && p.mode&PackageClauseOnly == 0 {\n+\tif p.errors.Len() == 0 && p.mode&PackageClauseOnly == 0 {\n \t\t// import decls\n \t\tfor p.tok == token.IMPORT {\n \t\t\tdecls = append(decls, p.parseGenDecl(token.IMPORT, parseImportSpec))"}, {"sha": "0c6a4e71f132af832f6e0f90d431115e55fa66ea", "filename": "libgo/go/go/printer/performance_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fperformance_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // This file implements a simple printer performance benchmark:\n-// gotest -bench=BenchmarkPrint \n+// go test -bench=BenchmarkPrint \n \n package printer\n "}, {"sha": "c9949205e8a141a05ccd3fb87d5f4895842ea0ad", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 152, "deletions": 130, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,7 +6,6 @@\n package printer\n \n import (\n-\t\"bytes\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/token\"\n@@ -51,22 +50,22 @@ type printer struct {\n \tfset *token.FileSet\n \n \t// Current state\n-\toutput      bytes.Buffer // raw printer result\n+\toutput      []byte       // raw printer result\n \tindent      int          // current indentation\n \tmode        pmode        // current printer mode\n \timpliedSemi bool         // if set, a linebreak implies a semicolon\n \tlastTok     token.Token  // the last token printed (token.ILLEGAL if it's whitespace)\n \twsbuf       []whiteSpace // delayed white space\n \n-\t// The (possibly estimated) position in the generated output;\n-\t// in AST space (i.e., pos is set whenever a token position is\n-\t// known accurately, and updated dependending on what has been\n-\t// written).\n-\tpos token.Position\n-\n-\t// The value of pos immediately after the last item has been\n-\t// written using writeItem.\n-\tlast token.Position\n+\t// Positions\n+\t// The out position differs from the pos position when the result\n+\t// formatting differs from the source formatting (in the amount of\n+\t// white space). If there's a difference and SourcePos is set in\n+\t// ConfigMode, //line comments are used in the output to restore\n+\t// original source positions for a reader.\n+\tpos  token.Position // current position in AST (source) space\n+\tout  token.Position // current position in output space\n+\tlast token.Position // value of pos after calling writeString\n \n \t// The list of all source comments, in order of appearance.\n \tcomments        []*ast.CommentGroup // may be nil\n@@ -89,6 +88,8 @@ type printer struct {\n func (p *printer) init(cfg *Config, fset *token.FileSet, nodeSizes map[ast.Node]int) {\n \tp.Config = *cfg\n \tp.fset = fset\n+\tp.pos = token.Position{Line: 1, Column: 1}\n+\tp.out = token.Position{Line: 1, Column: 1}\n \tp.wsbuf = make([]whiteSpace, 0, 16) // whitespace sequences are short\n \tp.nodeSizes = nodeSizes\n \tp.cachedPos = -1\n@@ -151,41 +152,57 @@ func (p *printer) lineFor(pos token.Pos) int {\n \treturn p.cachedLine\n }\n \n-// writeByte writes ch to p.output and updates p.pos.\n-func (p *printer) writeByte(ch byte) {\n-\tp.output.WriteByte(ch)\n-\tp.pos.Offset++\n-\tp.pos.Column++\n-\n-\tif ch == '\\n' || ch == '\\f' {\n-\t\t// write indentation\n-\t\t// use \"hard\" htabs - indentation columns\n-\t\t// must not be discarded by the tabwriter\n-\t\tconst htabs = \"\\t\\t\\t\\t\\t\\t\\t\\t\"\n-\t\tj := p.indent\n-\t\tfor j > len(htabs) {\n-\t\t\tp.output.WriteString(htabs)\n-\t\t\tj -= len(htabs)\n-\t\t}\n-\t\tp.output.WriteString(htabs[0:j])\n+// atLineBegin emits a //line comment if necessary and prints indentation.\n+func (p *printer) atLineBegin(pos token.Position) {\n+\t// write a //line comment if necessary\n+\tif p.Config.Mode&SourcePos != 0 && pos.IsValid() && (p.out.Line != pos.Line || p.out.Filename != pos.Filename) {\n+\t\tp.output = append(p.output, tabwriter.Escape) // protect '\\n' in //line from tabwriter interpretation\n+\t\tp.output = append(p.output, fmt.Sprintf(\"//line %s:%d\\n\", pos.Filename, pos.Line)...)\n+\t\tp.output = append(p.output, tabwriter.Escape)\n+\t\t// p.out must match the //line comment\n+\t\tp.out.Filename = pos.Filename\n+\t\tp.out.Line = pos.Line\n+\t}\n \n-\t\t// update p.pos\n-\t\tp.pos.Line++\n-\t\tp.pos.Offset += p.indent\n-\t\tp.pos.Column = 1 + p.indent\n+\t// write indentation\n+\t// use \"hard\" htabs - indentation columns\n+\t// must not be discarded by the tabwriter\n+\tfor i := 0; i < p.indent; i++ {\n+\t\tp.output = append(p.output, '\\t')\n \t}\n+\n+\t// update positions\n+\ti := p.indent\n+\tp.pos.Offset += i\n+\tp.pos.Column += i\n+\tp.out.Column += i\n }\n \n-// writeByteN writes ch n times to p.output and updates p.pos.\n-func (p *printer) writeByteN(ch byte, n int) {\n-\tfor n > 0 {\n-\t\tp.writeByte(ch)\n-\t\tn--\n+// writeByte writes ch n times to p.output and updates p.pos.\n+func (p *printer) writeByte(ch byte, n int) {\n+\tif p.out.Column == 1 {\n+\t\tp.atLineBegin(p.pos)\n+\t}\n+\n+\tfor i := 0; i < n; i++ {\n+\t\tp.output = append(p.output, ch)\n+\t}\n+\n+\t// update positions\n+\tp.pos.Offset += n\n+\tif ch == '\\n' || ch == '\\f' {\n+\t\tp.pos.Line += n\n+\t\tp.out.Line += n\n+\t\tp.pos.Column = 1\n+\t\tp.out.Column = 1\n+\t\treturn\n \t}\n+\tp.pos.Column += n\n+\tp.out.Column += n\n }\n \n-// writeString writes the string s to p.output and updates p.pos.\n-// If isLit is set, s is escaped w/ tabwriter.Escape characters\n+// writeString writes the string s to p.output and updates p.pos, p.out,\n+// and p.last. If isLit is set, s is escaped w/ tabwriter.Escape characters\n // to protect s from being interpreted by the tabwriter.\n //\n // Note: writeString is only used to write Go tokens, literals, and\n@@ -195,64 +212,69 @@ func (p *printer) writeByteN(ch byte, n int) {\n // avoids processing extra escape characters and reduces run time of the\n // printer benchmark by up to 10%.\n //\n-func (p *printer) writeString(s string, isLit bool) {\n+func (p *printer) writeString(pos token.Position, s string, isLit bool) {\n+\tif p.out.Column == 1 {\n+\t\tp.atLineBegin(pos)\n+\t}\n+\n+\tif pos.IsValid() {\n+\t\t// update p.pos (if pos is invalid, continue with existing p.pos)\n+\t\t// Note: Must do this after handling line beginnings because\n+\t\t// atLineBegin updates p.pos if there's indentation, but p.pos\n+\t\t// is the position of s.\n+\t\tp.pos = pos\n+\t\t// reset state if the file changed\n+\t\t// (used when printing merged ASTs of different files\n+\t\t// e.g., the result of ast.MergePackageFiles)\n+\t\tif p.last.IsValid() && p.last.Filename != pos.Filename {\n+\t\t\tp.indent = 0\n+\t\t\tp.mode = 0\n+\t\t\tp.wsbuf = p.wsbuf[0:0]\n+\t\t}\n+\t}\n+\n \tif isLit {\n \t\t// Protect s such that is passes through the tabwriter\n \t\t// unchanged. Note that valid Go programs cannot contain\n \t\t// tabwriter.Escape bytes since they do not appear in legal\n \t\t// UTF-8 sequences.\n-\t\tp.output.WriteByte(tabwriter.Escape)\n+\t\tp.output = append(p.output, tabwriter.Escape)\n \t}\n \n-\tp.output.WriteString(s)\n+\tif debug {\n+\t\tp.output = append(p.output, fmt.Sprintf(\"/*%s*/\", pos)...) // do not update p.pos!\n+\t}\n+\tp.output = append(p.output, s...)\n \n-\t// update p.pos\n+\t// update positions\n \tnlines := 0\n-\tcolumn := p.pos.Column + len(s)\n+\tvar li int // index of last newline; valid if nlines > 0\n \tfor i := 0; i < len(s); i++ {\n+\t\t// Go tokens cannot contain '\\f' - no need to look for it\n \t\tif s[i] == '\\n' {\n \t\t\tnlines++\n-\t\t\tcolumn = len(s) - i\n+\t\t\tli = i\n \t\t}\n \t}\n \tp.pos.Offset += len(s)\n-\tp.pos.Line += nlines\n-\tp.pos.Column = column\n+\tif nlines > 0 {\n+\t\tp.pos.Line += nlines\n+\t\tp.out.Line += nlines\n+\t\tc := len(s) - li\n+\t\tp.pos.Column = c\n+\t\tp.out.Column = c\n+\t} else {\n+\t\tp.pos.Column += len(s)\n+\t\tp.out.Column += len(s)\n+\t}\n \n \tif isLit {\n-\t\tp.output.WriteByte(tabwriter.Escape)\n+\t\tp.output = append(p.output, tabwriter.Escape)\n \t}\n-}\n \n-// writeItem writes data at position pos. data is the text corresponding to\n-// a single lexical token, but may also be comment text. pos is the actual\n-// (or at least very accurately estimated) position of the data in the original\n-// source text. writeItem updates p.last to the position immediately following\n-// the data.\n-//\n-func (p *printer) writeItem(pos token.Position, data string, isLit bool) {\n-\tif pos.IsValid() {\n-\t\t// continue with previous position if we don't have a valid pos\n-\t\tif p.last.IsValid() && p.last.Filename != pos.Filename {\n-\t\t\t// the file has changed - reset state\n-\t\t\t// (used when printing merged ASTs of different files\n-\t\t\t// e.g., the result of ast.MergePackageFiles)\n-\t\t\tp.indent = 0\n-\t\t\tp.mode = 0\n-\t\t\tp.wsbuf = p.wsbuf[0:0]\n-\t\t}\n-\t\tp.pos = pos\n-\t}\n-\tif debug {\n-\t\t// do not update p.pos - use write0\n-\t\tfmt.Fprintf(&p.output, \"/*%s*/\", pos)\n-\t}\n-\tp.writeString(data, isLit)\n \tp.last = p.pos\n }\n \n-const linePrefix = \"//line \"\n-\n // writeCommentPrefix writes the whitespace before a comment.\n // If there is any pending whitespace, it consumes as much of\n // it as is likely to help position the comment nicely.\n@@ -262,14 +284,14 @@ const linePrefix = \"//line \"\n // next item is a keyword.\n //\n func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *ast.Comment, isKeyword bool) {\n-\tif p.output.Len() == 0 {\n+\tif len(p.output) == 0 {\n \t\t// the comment is the first item to be printed - don't write any whitespace\n \t\treturn\n \t}\n \n \tif pos.IsValid() && pos.Filename != p.last.Filename {\n \t\t// comment in a different file - separate with newlines\n-\t\tp.writeByteN('\\f', maxNewlines)\n+\t\tp.writeByte('\\f', maxNewlines)\n \t\treturn\n \t}\n \n@@ -309,7 +331,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t\t\t\t// with a blank instead of a tab\n \t\t\t\tsep = ' '\n \t\t\t}\n-\t\t\tp.writeByte(sep)\n+\t\t\tp.writeByte(sep, 1)\n \t\t}\n \n \t} else {\n@@ -373,23 +395,17 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t\t}\n \n \t\tif n > 0 {\n-\t\t\t// turn off indent if we're about to print a line directive\n-\t\t\tindent := p.indent\n-\t\t\tif strings.HasPrefix(comment.Text, linePrefix) {\n-\t\t\t\tp.indent = 0\n-\t\t\t}\n \t\t\t// use formfeeds to break columns before a comment;\n \t\t\t// this is analogous to using formfeeds to separate\n \t\t\t// individual lines of /*-style comments\n-\t\t\tp.writeByteN('\\f', nlimit(n))\n-\t\t\tp.indent = indent // restore indent\n+\t\t\tp.writeByte('\\f', nlimit(n))\n \t\t}\n \t}\n }\n \n // Split comment text into lines\n // (using strings.Split(text, \"\\n\") is significantly slower for\n-// this specific purpose, as measured with: gotest -bench=Print)\n+// this specific purpose, as measured with: go test -bench=Print)\n func split(text string) []string {\n \t// count lines (comment text never ends in a newline)\n \tn := 1\n@@ -564,30 +580,33 @@ func stripCommonPrefix(lines []string) {\n \n func (p *printer) writeComment(comment *ast.Comment) {\n \ttext := comment.Text\n+\tpos := p.posFor(comment.Pos())\n \n-\tif strings.HasPrefix(text, linePrefix) {\n-\t\tpos := strings.TrimSpace(text[len(linePrefix):])\n-\t\ti := strings.LastIndex(pos, \":\")\n-\t\tif i >= 0 {\n-\t\t\t// The line directive we are about to print changed\n-\t\t\t// the Filename and Line number used by go/token\n-\t\t\t// as it was reading the input originally.\n-\t\t\t// In order to match the original input, we have to\n-\t\t\t// update our own idea of the file and line number\n-\t\t\t// accordingly, after printing the directive.\n-\t\t\tfile := pos[:i]\n-\t\t\tline, _ := strconv.Atoi(pos[i+1:])\n-\t\t\tdefer func() {\n-\t\t\t\tp.pos.Filename = file\n-\t\t\t\tp.pos.Line = line\n-\t\t\t\tp.pos.Column = 1\n-\t\t\t}()\n+\tconst linePrefix = \"//line \"\n+\tif strings.HasPrefix(text, linePrefix) && (!pos.IsValid() || pos.Column == 1) {\n+\t\t// possibly a line directive\n+\t\tldir := strings.TrimSpace(text[len(linePrefix):])\n+\t\tif i := strings.LastIndex(ldir, \":\"); i >= 0 {\n+\t\t\tif line, err := strconv.Atoi(ldir[i+1:]); err == nil && line > 0 {\n+\t\t\t\t// The line directive we are about to print changed\n+\t\t\t\t// the Filename and Line number used for subsequent\n+\t\t\t\t// tokens. We have to update our AST-space position\n+\t\t\t\t// accordingly and suspend indentation temporarily.\n+\t\t\t\tindent := p.indent\n+\t\t\t\tp.indent = 0\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tp.pos.Filename = ldir[:i]\n+\t\t\t\t\tp.pos.Line = line\n+\t\t\t\t\tp.pos.Column = 1\n+\t\t\t\t\tp.indent = indent\n+\t\t\t\t}()\n+\t\t\t}\n \t\t}\n \t}\n \n \t// shortcut common case of //-style comments\n \tif text[1] == '/' {\n-\t\tp.writeItem(p.posFor(comment.Pos()), text, true)\n+\t\tp.writeString(pos, text, true)\n \t\treturn\n \t}\n \n@@ -598,14 +617,13 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \n \t// write comment lines, separated by formfeed,\n \t// without a line break after the last line\n-\tpos := p.posFor(comment.Pos())\n \tfor i, line := range lines {\n \t\tif i > 0 {\n-\t\t\tp.writeByte('\\f')\n+\t\t\tp.writeByte('\\f', 1)\n \t\t\tpos = p.pos\n \t\t}\n \t\tif len(line) > 0 {\n-\t\t\tp.writeItem(pos, line, true)\n+\t\t\tp.writeString(pos, line, true)\n \t\t}\n \t}\n }\n@@ -643,7 +661,7 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (wroteNewline, dropped\n \n \t// make sure we have a line break\n \tif needsLinebreak {\n-\t\tp.writeByte('\\n')\n+\t\tp.writeByte('\\n', 1)\n \t\twroteNewline = true\n \t}\n \n@@ -671,7 +689,7 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (wro\n \t\tif last.Text[1] == '*' && p.lineFor(last.Pos()) == next.Line {\n \t\t\t// the last comment is a /*-style comment and the next item\n \t\t\t// follows on the same line: separate with an extra blank\n-\t\t\tp.writeByte(' ')\n+\t\t\tp.writeByte(' ', 1)\n \t\t}\n \t\t// ensure that there is a line break after a //-style comment,\n \t\t// before a closing '}' unless explicitly disabled, or at eof\n@@ -722,7 +740,7 @@ func (p *printer) writeWhitespace(n int) {\n \t\t\t}\n \t\t\tfallthrough\n \t\tdefault:\n-\t\t\tp.writeByte(byte(ch))\n+\t\t\tp.writeByte(byte(ch), 1)\n \t\t}\n \t}\n \n@@ -886,12 +904,12 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\tif droppedFF {\n \t\t\t\t\tch = '\\f' // use formfeed since we dropped one before\n \t\t\t\t}\n-\t\t\t\tp.writeByteN(ch, n)\n+\t\t\t\tp.writeByte(ch, n)\n \t\t\t\timpliedSemi = false\n \t\t\t}\n \t\t}\n \n-\t\tp.writeItem(next, data, isLit)\n+\t\tp.writeString(next, data, isLit)\n \t\tp.impliedSemi = impliedSemi\n \t}\n }\n@@ -1027,7 +1045,7 @@ unsupported:\n type trimmer struct {\n \toutput io.Writer\n \tstate  int\n-\tspace  bytes.Buffer\n+\tspace  []byte\n }\n \n // trimmer is implemented as a state machine.\n@@ -1038,6 +1056,11 @@ const (\n \tinText          // inside text\n )\n \n+func (p *trimmer) resetSpace() {\n+\tp.state = inSpace\n+\tp.space = p.space[0:0]\n+}\n+\n // Design note: It is tempting to eliminate extra blanks occurring in\n //              whitespace in this function as it could simplify some\n //              of the blanks logic in the node printing functions.\n@@ -1062,36 +1085,33 @@ func (p *trimmer) Write(data []byte) (n int, err error) {\n \t\tcase inSpace:\n \t\t\tswitch b {\n \t\t\tcase '\\t', ' ':\n-\t\t\t\tp.space.WriteByte(b) // WriteByte returns no errors\n+\t\t\t\tp.space = append(p.space, b)\n \t\t\tcase '\\n', '\\f':\n-\t\t\t\tp.space.Reset() // discard trailing space\n+\t\t\t\tp.resetSpace() // discard trailing space\n \t\t\t\t_, err = p.output.Write(aNewline)\n \t\t\tcase tabwriter.Escape:\n-\t\t\t\t_, err = p.output.Write(p.space.Bytes())\n+\t\t\t\t_, err = p.output.Write(p.space)\n \t\t\t\tp.state = inEscape\n \t\t\t\tm = n + 1 // +1: skip tabwriter.Escape\n \t\t\tdefault:\n-\t\t\t\t_, err = p.output.Write(p.space.Bytes())\n+\t\t\t\t_, err = p.output.Write(p.space)\n \t\t\t\tp.state = inText\n \t\t\t\tm = n\n \t\t\t}\n \t\tcase inEscape:\n \t\t\tif b == tabwriter.Escape {\n \t\t\t\t_, err = p.output.Write(data[m:n])\n-\t\t\t\tp.state = inSpace\n-\t\t\t\tp.space.Reset()\n+\t\t\t\tp.resetSpace()\n \t\t\t}\n \t\tcase inText:\n \t\t\tswitch b {\n \t\t\tcase '\\t', ' ':\n \t\t\t\t_, err = p.output.Write(data[m:n])\n-\t\t\t\tp.state = inSpace\n-\t\t\t\tp.space.Reset()\n-\t\t\t\tp.space.WriteByte(b) // WriteByte returns no errors\n+\t\t\t\tp.resetSpace()\n+\t\t\t\tp.space = append(p.space, b)\n \t\t\tcase '\\n', '\\f':\n \t\t\t\t_, err = p.output.Write(data[m:n])\n-\t\t\t\tp.state = inSpace\n-\t\t\t\tp.space.Reset()\n+\t\t\t\tp.resetSpace()\n \t\t\t\t_, err = p.output.Write(aNewline)\n \t\t\tcase tabwriter.Escape:\n \t\t\t\t_, err = p.output.Write(data[m:n])\n@@ -1110,8 +1130,7 @@ func (p *trimmer) Write(data []byte) (n int, err error) {\n \tswitch p.state {\n \tcase inEscape, inText:\n \t\t_, err = p.output.Write(data[m:n])\n-\t\tp.state = inSpace\n-\t\tp.space.Reset()\n+\t\tp.resetSpace()\n \t}\n \n \treturn\n@@ -1120,16 +1139,19 @@ func (p *trimmer) Write(data []byte) (n int, err error) {\n // ----------------------------------------------------------------------------\n // Public interface\n \n-// General printing is controlled with these Config.Mode flags.\n+// A Mode value is a set of flags (or 0). They coontrol printing. \n+type Mode uint\n+\n const (\n-\tRawFormat uint = 1 << iota // do not use a tabwriter; if set, UseSpaces is ignored\n+\tRawFormat Mode = 1 << iota // do not use a tabwriter; if set, UseSpaces is ignored\n \tTabIndent                  // use tabs for indentation independent of UseSpaces\n \tUseSpaces                  // use spaces instead of tabs for alignment\n+\tSourcePos                  // emit //line comments to preserve original source positions\n )\n \n // A Config node controls the output of Fprint.\n type Config struct {\n-\tMode     uint // default: 0\n+\tMode     Mode // default: 0\n \tTabwidth int  // default: 8\n }\n \n@@ -1170,7 +1192,7 @@ func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{\n \t}\n \n \t// write printer result via tabwriter/trimmer to output\n-\tif _, err = output.Write(p.output.Bytes()); err != nil {\n+\tif _, err = output.Write(p.output); err != nil {\n \t\treturn\n \t}\n "}, {"sha": "fa133cd35f04f4fbcf02ffffa5f22b9ef7a43b07", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 135, "deletions": 2, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -67,6 +67,13 @@ func runcheck(t *testing.T, source, golden string, mode checkMode) {\n \t}\n \tres := buf.Bytes()\n \n+\t// formatted source must be valid\n+\tif _, err := parser.ParseFile(fset, \"\", res, 0); err != nil {\n+\t\tt.Error(err)\n+\t\tt.Logf(\"\\n%s\", res)\n+\t\treturn\n+\t}\n+\n \t// update golden files if necessary\n \tif *update {\n \t\tif err := ioutil.WriteFile(golden, res, 0644); err != nil {\n@@ -133,7 +140,7 @@ type entry struct {\n \tmode           checkMode\n }\n \n-// Use gotest -update to create/update the respective golden files.\n+// Use go test -update to create/update the respective golden files.\n var data = []entry{\n \t{\"empty.input\", \"empty.golden\", 0},\n \t{\"comments.input\", \"comments.golden\", 0},\n@@ -223,7 +230,8 @@ func TestBadNodes(t *testing.T) {\n \t}\n }\n \n-// Print and parse f with \n+// testComment verifies that f can be parsed again after printing it\n+// with its first comment set to comment at any possible source offset.\n func testComment(t *testing.T, f *ast.File, srclen int, comment *ast.Comment) {\n \tf.Comments[0].List[0] = comment\n \tvar buf bytes.Buffer\n@@ -280,3 +288,128 @@ func fibo(n int) {\n \ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style \\n comment */\"})\n \ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style comment \\n\\n\\n */\"})\n }\n+\n+type visitor chan *ast.Ident\n+\n+func (v visitor) Visit(n ast.Node) (w ast.Visitor) {\n+\tif ident, ok := n.(*ast.Ident); ok {\n+\t\tv <- ident\n+\t}\n+\treturn v\n+}\n+\n+// idents is an iterator that returns all idents in f via the result channel.\n+func idents(f *ast.File) <-chan *ast.Ident {\n+\tv := make(visitor)\n+\tgo func() {\n+\t\tast.Walk(v, f)\n+\t\tclose(v)\n+\t}()\n+\treturn v\n+}\n+\n+// identCount returns the number of identifiers found in f.\n+func identCount(f *ast.File) int {\n+\tn := 0\n+\tfor _ = range idents(f) {\n+\t\tn++\n+\t}\n+\treturn n\n+}\n+\n+// Verify that the SourcePos mode emits correct //line comments\n+// by testing that position information for matching identifiers\n+// is maintained.\n+func TestSourcePos(t *testing.T) {\n+\tconst src = `\n+package p\n+import ( \"go/printer\"; \"math\" )\n+const pi = 3.14; var x = 0\n+type t struct{ x, y, z int; u, v, w float32 }\n+func (t *t) foo(a, b, c int) int {\n+\treturn a*t.x + b*t.y +\n+\t\t// two extra lines here\n+\t\t// ...\n+\t\tc*t.z\n+}\n+`\n+\n+\t// parse original\n+\tf1, err := parser.ParseFile(fset, \"src\", src, parser.ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// pretty-print original\n+\tvar buf bytes.Buffer\n+\terr = (&Config{Mode: UseSpaces | SourcePos, Tabwidth: 8}).Fprint(&buf, fset, f1)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// parse pretty printed original\n+\t// (//line comments must be interpreted even w/o parser.ParseComments set)\n+\tf2, err := parser.ParseFile(fset, \"\", buf.Bytes(), 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"%s\\n%s\", err, buf.Bytes())\n+\t}\n+\n+\t// At this point the position information of identifiers in f2 should\n+\t// match the position information of corresponding identifiers in f1.\n+\n+\t// number of identifiers must be > 0 (test should run) and must match\n+\tn1 := identCount(f1)\n+\tn2 := identCount(f2)\n+\tif n1 == 0 {\n+\t\tt.Fatal(\"got no idents\")\n+\t}\n+\tif n2 != n1 {\n+\t\tt.Errorf(\"got %d idents; want %d\", n2, n1)\n+\t}\n+\n+\t// verify that all identifiers have correct line information\n+\ti2range := idents(f2)\n+\tfor i1 := range idents(f1) {\n+\t\ti2 := <-i2range\n+\n+\t\tif i2.Name != i1.Name {\n+\t\t\tt.Errorf(\"got ident %s; want %s\", i2.Name, i1.Name)\n+\t\t}\n+\n+\t\tl1 := fset.Position(i1.Pos()).Line\n+\t\tl2 := fset.Position(i2.Pos()).Line\n+\t\tif l2 != l1 {\n+\t\t\tt.Errorf(\"got line %d; want %d for %s\", l2, l1, i1.Name)\n+\t\t}\n+\t}\n+\n+\tif t.Failed() {\n+\t\tt.Logf(\"\\n%s\", buf.Bytes())\n+\t}\n+}\n+\n+// TextX is a skeleton test that can be filled in for debugging one-off cases.\n+// Do not remove.\n+func TestX(t *testing.T) {\n+\tconst src = `\n+package p\n+func _() {}\n+`\n+\t// parse original\n+\tf, err := parser.ParseFile(fset, \"src\", src, parser.ParseComments)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// pretty-print original\n+\tvar buf bytes.Buffer\n+\tif err = (&Config{Mode: UseSpaces, Tabwidth: 8}).Fprint(&buf, fset, f); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// parse pretty printed original\n+\tif _, err := parser.ParseFile(fset, \"\", buf.Bytes(), 0); err != nil {\n+\t\tt.Fatalf(\"%s\\n%s\", err, buf.Bytes())\n+\t}\n+\n+}"}, {"sha": "e5826eecefeefadab2b0b0da4b2841b72f6559c0", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -404,7 +404,7 @@ func _() {\n \t*/\n }\n \n-// Some interesting interspersed comments\n+// Some interesting interspersed comments.\n func _( /* this */ x /* is */ /* an */ int) {\n }\n \n@@ -428,6 +428,26 @@ func _() {\n \t_ = []int{0, 1 /* don't introduce a newline after this comment - was issue 1365 */ }\n }\n \n+// Test cases from issue 1542:\n+// Comments must not be placed before commas and cause invalid programs.\n+func _() {\n+\tvar a = []int{1, 2\t/*jasldf*/}\n+\t_ = a\n+}\n+\n+func _() {\n+\tvar a = []int{1, 2}/*jasldf\n+\t */\n+\n+\t_ = a\n+}\n+\n+func _() {\n+\tvar a = []int{1, 2}// jasldf \n+\n+\t_ = a\n+}\n+\n // Comments immediately adjacent to punctuation (for which the go/printer\n // may only have estimated position information) must remain after the punctuation.\n func _() {\n@@ -459,6 +479,25 @@ func _() {\n \t}\n }\n \n+// Print line directives correctly.\n+\n+// The following is a legal line directive.\n+//line foo:1\n+func _() {\n+\t_ = 0\n+\t// The following is a legal line directive. It must not be indented:\n+//line foo:2\n+\t_ = 1\n+\n+\t// The following is not a legal line directive (it doesn't start in column 1):\n+\t//line foo:2\n+\t_ = 2\n+\n+\t// The following is not a legal line directive (negative line number):\n+\t//line foo:-3\n+\t_ = 3\n+}\n+\n // Line comments with tabs\n func _() {\n \tvar finput *bufio.Reader\t// input file"}, {"sha": "55f6b61f21f388f2f1c2a54c21c347c9904a3917", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -410,7 +410,7 @@ func _() {\n }\n \n \n-// Some interesting interspersed comments\n+// Some interesting interspersed comments.\n func _(/* this */x/* is *//* an */ int) {\n }\n \n@@ -432,6 +432,26 @@ func _() {\n \t_ = []int{0, 1 /* don't introduce a newline after this comment - was issue 1365 */}\n }\n \n+// Test cases from issue 1542:\n+// Comments must not be placed before commas and cause invalid programs.\n+func _() {\n+\tvar a = []int{1, 2, /*jasldf*/\n+\t}\n+\t_ = a\n+}\n+\n+func _() {\n+\tvar a = []int{1, 2, /*jasldf\n+\t\t\t\t\t\t*/\n+\t}\n+\t_ = a\n+}\n+\n+func _() {\n+\tvar a = []int{1, 2, // jasldf \n+\t}\n+\t_ = a\n+}\n \n // Comments immediately adjacent to punctuation (for which the go/printer\n // may only have estimated position information) must remain after the punctuation.\n@@ -467,6 +487,25 @@ func _() {\n }\n \n \n+// Print line directives correctly.\n+\n+// The following is a legal line directive.\n+//line foo:1\n+func _() {\n+\t_ = 0\n+// The following is a legal line directive. It must not be indented:\n+//line foo:2\n+\t_ = 1\n+\n+// The following is not a legal line directive (it doesn't start in column 1):\n+\t//line foo:2\n+\t_ = 2\n+\n+// The following is not a legal line directive (negative line number):\n+//line foo:-3\n+\t_ = 3\n+}\n+\n // Line comments with tabs\n func _() {\n var\tfinput\t\t*bufio.Reader\t\t\t// input file"}, {"sha": "8a75a96508e86bb224fe5e40fd8ce3a83c50d0eb", "filename": "libgo/go/go/scanner/errors.go", "status": "modified", "additions": 47, "deletions": 88, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -11,44 +11,18 @@ import (\n \t\"sort\"\n )\n \n-// An implementation of an ErrorHandler may be provided to the Scanner.\n-// If a syntax error is encountered and a handler was installed, Error\n-// is called with a position and an error message. The position points\n-// to the beginning of the offending token.\n-//\n-type ErrorHandler interface {\n-\tError(pos token.Position, msg string)\n-}\n-\n-// ErrorVector implements the ErrorHandler interface. It maintains a list\n-// of errors which can be retrieved with GetErrorList and GetError. The\n-// zero value for an ErrorVector is an empty ErrorVector ready to use.\n-//\n-// A common usage pattern is to embed an ErrorVector alongside a\n-// scanner in a data structure that uses the scanner. By passing a\n-// reference to an ErrorVector to the scanner's Init call, default\n-// error handling is obtained.\n-//\n-type ErrorVector struct {\n-\terrors []*Error\n-}\n-\n-// Reset resets an ErrorVector to no errors.\n-func (h *ErrorVector) Reset() { h.errors = h.errors[:0] }\n-\n-// ErrorCount returns the number of errors collected.\n-func (h *ErrorVector) ErrorCount() int { return len(h.errors) }\n-\n-// Within ErrorVector, an error is represented by an Error node. The\n-// position Pos, if valid, points to the beginning of the offending\n-// token, and the error condition is described by Msg.\n+// In an ErrorList, an error is represented by an *Error.\n+// The position Pos, if valid, points to the beginning of\n+// the offending token, and the error condition is described\n+// by Msg.\n //\n type Error struct {\n \tPos token.Position\n \tMsg string\n }\n \n-func (e *Error) Error() string {\n+// Error implements the error interface.\n+func (e Error) Error() string {\n \tif e.Pos.Filename != \"\" || e.Pos.IsValid() {\n \t\t// don't print \"<unknown position>\"\n \t\t// TODO(gri) reconsider the semantics of Position.IsValid\n@@ -57,9 +31,19 @@ func (e *Error) Error() string {\n \treturn e.Msg\n }\n \n-// An ErrorList is a (possibly sorted) list of Errors.\n+// ErrorList is a list of *Errors.\n+// The zero value for an ErrorList is an empty ErrorList ready to use.\n+//\n type ErrorList []*Error\n \n+// Add adds an Error with given position and error message to an ErrorList.\n+func (p *ErrorList) Add(pos token.Position, msg string) {\n+\t*p = append(*p, &Error{pos, msg})\n+}\n+\n+// Reset resets an ErrorList to no errors.\n+func (p *ErrorList) Reset() { *p = (*p)[0:0] }\n+\n // ErrorList implements the sort Interface.\n func (p ErrorList) Len() int      { return len(p) }\n func (p ErrorList) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n@@ -84,72 +68,47 @@ func (p ErrorList) Less(i, j int) bool {\n \treturn false\n }\n \n+// Sort sorts an ErrorList. *Error entries are sorted by position,\n+// other errors are sorted by error message, and before any *Error\n+// entry.\n+//\n+func (p ErrorList) Sort() {\n+\tsort.Sort(p)\n+}\n+\n+// RemoveMultiples sorts an ErrorList and removes all but the first error per line.\n+func (p *ErrorList) RemoveMultiples() {\n+\tsort.Sort(p)\n+\tvar last token.Position // initial last.Line is != any legal error line\n+\ti := 0\n+\tfor _, e := range *p {\n+\t\tif e.Pos.Filename != last.Filename || e.Pos.Line != last.Line {\n+\t\t\tlast = e.Pos\n+\t\t\t(*p)[i] = e\n+\t\t\ti++\n+\t\t}\n+\t}\n+\t(*p) = (*p)[0:i]\n+}\n+\n+// An ErrorList implements the error interface.\n func (p ErrorList) Error() string {\n \tswitch len(p) {\n \tcase 0:\n-\t\treturn \"unspecified error\"\n+\t\treturn \"no errors\"\n \tcase 1:\n \t\treturn p[0].Error()\n \t}\n \treturn fmt.Sprintf(\"%s (and %d more errors)\", p[0], len(p)-1)\n }\n \n-// These constants control the construction of the ErrorList\n-// returned by GetErrors.\n-//\n-const (\n-\tRaw         = iota // leave error list unchanged\n-\tSorted             // sort error list by file, line, and column number\n-\tNoMultiples        // sort error list and leave only the first error per line\n-)\n-\n-// GetErrorList returns the list of errors collected by an ErrorVector.\n-// The construction of the ErrorList returned is controlled by the mode\n-// parameter. If there are no errors, the result is nil.\n-//\n-func (h *ErrorVector) GetErrorList(mode int) ErrorList {\n-\tif len(h.errors) == 0 {\n-\t\treturn nil\n-\t}\n-\n-\tlist := make(ErrorList, len(h.errors))\n-\tcopy(list, h.errors)\n-\n-\tif mode >= Sorted {\n-\t\tsort.Sort(list)\n-\t}\n-\n-\tif mode >= NoMultiples {\n-\t\tvar last token.Position // initial last.Line is != any legal error line\n-\t\ti := 0\n-\t\tfor _, e := range list {\n-\t\t\tif e.Pos.Filename != last.Filename || e.Pos.Line != last.Line {\n-\t\t\t\tlast = e.Pos\n-\t\t\t\tlist[i] = e\n-\t\t\t\ti++\n-\t\t\t}\n-\t\t}\n-\t\tlist = list[0:i]\n-\t}\n-\n-\treturn list\n-}\n-\n-// GetError is like GetErrorList, but it returns an error instead\n-// so that a nil result can be assigned to an error variable and\n-// remains nil.\n-//\n-func (h *ErrorVector) GetError(mode int) error {\n-\tif len(h.errors) == 0 {\n+// Err returns an error equivalent to this error list.\n+// If the list is empty, Err returns nil.\n+func (p ErrorList) Err() error {\n+\tif len(p) == 0 {\n \t\treturn nil\n \t}\n-\n-\treturn h.GetErrorList(mode)\n-}\n-\n-// ErrorVector implements the ErrorHandler interface.\n-func (h *ErrorVector) Error(pos token.Position, msg string) {\n-\th.errors = append(h.errors, &Error{pos, msg})\n+\treturn p\n }\n \n // PrintError is a utility function that prints a list of errors to w,"}, {"sha": "458e1f9f37a8a7b69ba07499922dd79aedb65ae2", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -30,6 +30,13 @@ import (\n \t\"unicode/utf8\"\n )\n \n+// An ErrorHandler may be provided to Scanner.Init. If a syntax error is\n+// encountered and a handler was installed, the handler is called with a\n+// position and an error message. The position points to the beginning of\n+// the offending token.\n+//\n+type ErrorHandler func(pos token.Position, msg string)\n+\n // A Scanner holds the scanner's internal state while processing\n // a given text.  It can be allocated as part of another data\n // structure but must be initialized via Init before use.\n@@ -103,7 +110,7 @@ const (\n // line information which is already present is ignored. Init causes a\n // panic if the file size does not match the src size.\n //\n-// Calls to Scan will use the error handler err if they encounter a\n+// Calls to Scan will invoke the error handler err if they encounter a\n // syntax error and err is not nil. Also, for each error encountered,\n // the Scanner field ErrorCount is incremented by one. The mode parameter\n // determines how comments are handled.\n@@ -134,7 +141,7 @@ func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode\n \n func (s *Scanner) error(offs int, msg string) {\n \tif s.err != nil {\n-\t\ts.err.Error(s.file.Position(s.file.Pos(offs)), msg)\n+\t\ts.err(s.file.Position(s.file.Pos(offs)), msg)\n \t}\n \ts.ErrorCount++\n }"}, {"sha": "06223e23bd8df0e7d4558727009117b85ad17fa8", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -186,14 +186,6 @@ var source = func() []byte {\n \treturn src\n }()\n \n-type testErrorHandler struct {\n-\tt *testing.T\n-}\n-\n-func (h *testErrorHandler) Error(pos token.Position, msg string) {\n-\th.t.Errorf(\"Error() called (msg = %s)\", msg)\n-}\n-\n func newlineCount(s string) int {\n \tn := 0\n \tfor i := 0; i < len(s); i++ {\n@@ -226,9 +218,14 @@ func TestScan(t *testing.T) {\n \tsrc_linecount := newlineCount(string(source))\n \twhitespace_linecount := newlineCount(whitespace)\n \n+\t// error handler\n+\teh := func(_ token.Position, msg string) {\n+\t\tt.Errorf(\"error handler called (msg = %s)\", msg)\n+\t}\n+\n \t// verify scan\n \tvar s Scanner\n-\ts.Init(fset.AddFile(\"\", fset.Base(), len(source)), source, &testErrorHandler{t}, ScanComments|dontInsertSemis)\n+\ts.Init(fset.AddFile(\"\", fset.Base(), len(source)), source, eh, ScanComments|dontInsertSemis)\n \tindex := 0\n \t// epos is the expected position\n \tepos := token.Position{\n@@ -569,36 +566,37 @@ func TestStdErrorHander(t *testing.T) {\n \t\t\"//line File1:1\\n\" +\n \t\t\"@ @ @\" // original file, line 1 again\n \n-\tv := new(ErrorVector)\n+\tvar list ErrorList\n+\teh := func(pos token.Position, msg string) { list.Add(pos, msg) }\n+\n \tvar s Scanner\n-\ts.Init(fset.AddFile(\"File1\", fset.Base(), len(src)), []byte(src), v, dontInsertSemis)\n+\ts.Init(fset.AddFile(\"File1\", fset.Base(), len(src)), []byte(src), eh, dontInsertSemis)\n \tfor {\n \t\tif _, tok, _ := s.Scan(); tok == token.EOF {\n \t\t\tbreak\n \t\t}\n \t}\n \n-\tlist := v.GetErrorList(Raw)\n+\tif len(list) != s.ErrorCount {\n+\t\tt.Errorf(\"found %d errors, expected %d\", len(list), s.ErrorCount)\n+\t}\n+\n \tif len(list) != 9 {\n \t\tt.Errorf(\"found %d raw errors, expected 9\", len(list))\n \t\tPrintError(os.Stderr, list)\n \t}\n \n-\tlist = v.GetErrorList(Sorted)\n+\tlist.Sort()\n \tif len(list) != 9 {\n \t\tt.Errorf(\"found %d sorted errors, expected 9\", len(list))\n \t\tPrintError(os.Stderr, list)\n \t}\n \n-\tlist = v.GetErrorList(NoMultiples)\n+\tlist.RemoveMultiples()\n \tif len(list) != 4 {\n \t\tt.Errorf(\"found %d one-per-line errors, expected 4\", len(list))\n \t\tPrintError(os.Stderr, list)\n \t}\n-\n-\tif v.ErrorCount() != s.ErrorCount {\n-\t\tt.Errorf(\"found %d errors, expected %d\", v.ErrorCount(), s.ErrorCount)\n-\t}\n }\n \n type errorCollector struct {\n@@ -607,16 +605,15 @@ type errorCollector struct {\n \tpos token.Position // last error position encountered\n }\n \n-func (h *errorCollector) Error(pos token.Position, msg string) {\n-\th.cnt++\n-\th.msg = msg\n-\th.pos = pos\n-}\n-\n func checkError(t *testing.T, src string, tok token.Token, pos int, err string) {\n \tvar s Scanner\n \tvar h errorCollector\n-\ts.Init(fset.AddFile(\"\", fset.Base(), len(src)), []byte(src), &h, ScanComments|dontInsertSemis)\n+\teh := func(pos token.Position, msg string) {\n+\t\th.cnt++\n+\t\th.msg = msg\n+\t\th.pos = pos\n+\t}\n+\ts.Init(fset.AddFile(\"\", fset.Base(), len(src)), []byte(src), eh, ScanComments|dontInsertSemis)\n \t_, tok0, _ := s.Scan()\n \t_, tok1, _ := s.Scan()\n \tif tok0 != tok {"}, {"sha": "6fe507abea4c8ddca94ed0d3c59746602b39768e", "filename": "libgo/go/html/template/doc.go", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -3,15 +3,19 @@\n // license that can be found in the LICENSE file.\n \n /*\n-Package template (html/template) is a specialization of package text/template\n-that automates the construction of HTML output that is safe against code\n-injection.\n+Package template (html/template) implements data-driven templates for\n+generating HTML output safe against code injection. It provides the\n+same interface as package text/template and should be used instead of\n+text/template whenever the output is HTML.\n \n+The documentation here focuses on the security features of the package.\n+For information about how to program the templates themselves, see the\n+documentation for text/template.\n \n Introduction\n \n-This package wraps package template so you can use the standard template API\n-to parse and execute templates.\n+This package wraps package text/template so you can share its template API\n+to parse and execute HTML templates safely.\n \n   set, err := new(template.Set).Parse(...)\n   // Error checking elided\n@@ -25,7 +29,8 @@ can be safely embedded in an HTML document. The escaping is contextual, so\n actions can appear within JavaScript, CSS, and URI contexts.\n \n The security model used by this package assumes that template authors are\n-trusted, while Execute's data parameter is not. More details are provided below.\n+trusted, while text/template Execute's data parameter is not. More details are\n+provided below.\n \n Example\n \n@@ -38,7 +43,7 @@ produces\n \n   Hello, <script>alert('you have been pwned')</script>!\n \n-but with contextual autoescaping,\n+but the contextual autoescaping in html/template\n \n   import \"html/template\"\n   ..."}, {"sha": "24c4ea448081d964fa373e5a93cdbf30864f611e", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -246,7 +246,7 @@ var readerErrors = []struct {\n \tfile string\n \terr  string\n }{\n-\t{\"invalid-zlib.png\", \"zlib checksum error\"},\n+\t{\"invalid-zlib.png\", \"zlib: invalid checksum\"},\n \t{\"invalid-crc32.png\", \"invalid checksum\"},\n \t{\"invalid-noend.png\", \"unexpected EOF\"},\n \t{\"invalid-trunc.png\", \"unexpected EOF\"},"}, {"sha": "57c03792b59dc835969f9421d66ff8e3fdc8d107", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -263,10 +263,7 @@ func filter(cr *[nFilter][]byte, pr []byte, bpp int) int {\n }\n \n func writeImage(w io.Writer, m image.Image, cb int) error {\n-\tzw, err := zlib.NewWriter(w)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n+\tzw := zlib.NewWriter(w)\n \tdefer zw.Close()\n \n \tbpp := 0 // Bytes per pixel.\n@@ -391,8 +388,7 @@ func writeImage(w io.Writer, m image.Image, cb int) error {\n \t\tf := filter(&cr, pr, bpp)\n \n \t\t// Write the compressed bytes.\n-\t\t_, err = zw.Write(cr[f])\n-\t\tif err != nil {\n+\t\tif _, err := zw.Write(cr[f]); err != nil {\n \t\t\treturn err\n \t\t}\n "}, {"sha": "3eb5353e9a9b8ae73854d883ac0f73787942267e", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -136,25 +136,33 @@ func (w *Writer) Debug(m string) (err error) {\n }\n \n func (n netConn) writeBytes(p Priority, prefix string, b []byte) (int, error) {\n-\treturn fmt.Fprintf(n.conn, \"<%d>%s: %s\\n\", p, prefix, b)\n+\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s\\n\", p, prefix, b)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn len(b), nil\n }\n \n func (n netConn) writeString(p Priority, prefix string, s string) (int, error) {\n-\treturn fmt.Fprintf(n.conn, \"<%d>%s: %s\\n\", p, prefix, s)\n+\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s\\n\", p, prefix, s)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn len(s), nil\n }\n \n func (n netConn) close() error {\n \treturn n.conn.Close()\n }\n \n-// NewLogger provides an object that implements the full log.Logger interface,\n-// but sends messages to Syslog instead; flag is passed as is to Logger;\n-// priority will be used for all messages sent using this interface.\n-// All messages are logged with priority p.\n-func NewLogger(p Priority, flag int) *log.Logger {\n+// NewLogger creates a log.Logger whose output is written to\n+// the system log service with the specified priority. The logFlag\n+// argument is the flag set passed through to log.New to create\n+// the Logger.\n+func NewLogger(p Priority, logFlag int) (*log.Logger, error) {\n \ts, err := New(p, \"\")\n \tif err != nil {\n-\t\treturn nil\n+\t\treturn nil, err\n \t}\n-\treturn log.New(s, \"\", flag)\n+\treturn log.New(s, \"\", logFlag), nil\n }"}, {"sha": "7f509b3666e81574aea51f5ba70b032e486326c1", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -61,9 +61,9 @@ func TestNewLogger(t *testing.T) {\n \tif skipNetTest(t) {\n \t\treturn\n \t}\n-\tf := NewLogger(LOG_INFO, 0)\n+\tf, err := NewLogger(LOG_INFO, 0)\n \tif f == nil {\n-\t\tt.Error(\"NewLogger() failed\")\n+\t\tt.Error(err)\n \t}\n }\n "}, {"sha": "efe1837bba3613cc911e34f74d5a8983460bcde1", "filename": "libgo/go/math/big/calibrate_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fbig%2Fcalibrate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fbig%2Fcalibrate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fcalibrate_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,7 +8,7 @@\n // results are somewhat fragile; use repeated runs to get\n // a clear picture.\n \n-// Usage: gotest -calibrate\n+// Usage: go test -run=TestCalibrate -calibrate\n \n package big\n "}, {"sha": "da1ac944c5c3d07d5b07135b64085070b7b80bbb", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -897,7 +897,7 @@ func (q nat) convertWords(s []byte, charset string, b Word, ndigits int, bb Word\n }\n \n // Split blocks greater than leafSize Words (or set to 0 to disable recursive conversion)\n-// Benchmark and configure leafSize using: gotest -test.bench=\"Leaf\"\n+// Benchmark and configure leafSize using: go test -bench=\"Leaf\"\n //   8 and 16 effective on 3.0 GHz Xeon \"Clovertown\" CPU (128 byte cache lines)\n //   8 and 16 effective on 2.66 GHz Core 2 Duo \"Penryn\" CPU\n var leafSize int = 8 // number of Word-size binary values treat as a monolithic block"}, {"sha": "edb14f6fa435dd1d31d29b395766d235010ef391", "filename": "libgo/go/math/const.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fconst.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,7 +6,7 @@\n package math\n \n // Mathematical constants.\n-// Reference: http://www.research.att.com/~njas/sequences/Axxxxxx\n+// Reference: http://oeis.org/Axxxxxx\n const (\n \tE   = 2.71828182845904523536028747135266249775724709369995957496696763 // A001113\n \tPi  = 3.14159265358979323846264338327950288419716939937510582097494459 // A000796"}, {"sha": "7c6f421bad1a2a1a6912dbd26552632ddd0ddd9e", "filename": "libgo/go/math/gamma.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmath%2Fgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fgamma.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -116,7 +116,7 @@ func stirling(x float64) float64 {\n //\tGamma(\u00b1Inf) = \u00b1Inf\n //\tGamma(NaN) = NaN\n // Large values overflow to +Inf.\n-// Negative integer values equal \u00b1Inf.\n+// Zero and negative integer arguments return \u00b1Inf.\n func Gamma(x float64) float64 {\n \tconst Euler = 0.57721566490153286060651209008240243104215933593992 // A001620\n \t// special cases"}, {"sha": "83cc411343f2f6a98b41ce7072eee7d225a6f34e", "filename": "libgo/go/mime/grammar.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmime%2Fgrammar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmime%2Fgrammar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fgrammar.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -14,25 +14,25 @@ func isTSpecial(r rune) bool {\n \treturn strings.IndexRune(`()<>@,;:\\\"/[]?=`, r) != -1\n }\n \n-// IsTokenChar returns true if rune is in 'token' as defined by RFC\n+// isTokenChar returns true if rune is in 'token' as defined by RFC\n // 1521 and RFC 2045.\n-func IsTokenChar(r rune) bool {\n+func isTokenChar(r rune) bool {\n \t// token := 1*<any (US-ASCII) CHAR except SPACE, CTLs,\n \t//             or tspecials>\n \treturn r > 0x20 && r < 0x7f && !isTSpecial(r)\n }\n \n-// IsToken returns true if s is a 'token' as as defined by RFC 1521\n+// isToken returns true if s is a 'token' as as defined by RFC 1521\n // and RFC 2045.\n-func IsToken(s string) bool {\n+func isToken(s string) bool {\n \tif s == \"\" {\n \t\treturn false\n \t}\n \treturn strings.IndexFunc(s, isNotTokenChar) < 0\n }\n \n-// IsQText returns true if rune is in 'qtext' as defined by RFC 822.\n-func IsQText(r int) bool {\n+// isQText returns true if rune is in 'qtext' as defined by RFC 822.\n+func isQText(r int) bool {\n \t// CHAR        =  <any ASCII character>        ; (  0-177,  0.-127.)\n \t// qtext       =  <any CHAR excepting <\">,     ; => may be folded\n \t//                \"\\\" & CR, and including"}, {"sha": "9398dece1d9107d3bc69f6688d3c39a2ae55f62f", "filename": "libgo/go/mime/mediatype.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmime%2Fmediatype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmime%2Fmediatype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -23,7 +23,7 @@ func FormatMediaType(t string, param map[string]string) string {\n \t\treturn \"\"\n \t}\n \tmajor, sub := t[:slash], t[slash+1:]\n-\tif !IsToken(major) || !IsToken(sub) {\n+\tif !isToken(major) || !isToken(sub) {\n \t\treturn \"\"\n \t}\n \tvar b bytes.Buffer\n@@ -34,12 +34,12 @@ func FormatMediaType(t string, param map[string]string) string {\n \tfor attribute, value := range param {\n \t\tb.WriteByte(';')\n \t\tb.WriteByte(' ')\n-\t\tif !IsToken(attribute) {\n+\t\tif !isToken(attribute) {\n \t\t\treturn \"\"\n \t\t}\n \t\tb.WriteString(strings.ToLower(attribute))\n \t\tb.WriteByte('=')\n-\t\tif IsToken(value) {\n+\t\tif isToken(value) {\n \t\t\tb.WriteString(value)\n \t\t\tcontinue\n \t\t}\n@@ -205,7 +205,7 @@ func decode2231Enc(v string) string {\n }\n \n func isNotTokenChar(r rune) bool {\n-\treturn !IsTokenChar(r)\n+\treturn !isTokenChar(r)\n }\n \n // consumeToken consumes a token from the beginning of provided"}, {"sha": "eee53fc8dd0574fa376bd38a5c4ecbe7ef76da22", "filename": "libgo/go/mime/multipart/formdata.go", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -130,7 +130,7 @@ type FileHeader struct {\n // Open opens and returns the FileHeader's associated File.\n func (fh *FileHeader) Open() (File, error) {\n \tif b := fh.content; b != nil {\n-\t\tr := io.NewSectionReader(sliceReaderAt(b), 0, int64(len(b)))\n+\t\tr := io.NewSectionReader(bytes.NewReader(b), 0, int64(len(b)))\n \t\treturn sectionReadCloser{r}, nil\n \t}\n \treturn os.Open(fh.tmpfile)\n@@ -155,13 +155,3 @@ type sectionReadCloser struct {\n func (rc sectionReadCloser) Close() error {\n \treturn nil\n }\n-\n-type sliceReaderAt []byte\n-\n-func (r sliceReaderAt) ReadAt(b []byte, off int64) (int, error) {\n-\tif int(off) >= len(r) || off < 0 {\n-\t\treturn 0, io.ErrUnexpectedEOF\n-\t}\n-\tn := copy(b, r[int(off):])\n-\treturn n, nil\n-}"}, {"sha": "61b8911fcf98c474fdbf1fb96058743223a4e7e1", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -185,7 +185,7 @@ func Listen(net, laddr string) (Listener, error) {\n \t\tif a != nil {\n \t\t\tla = a.(*TCPAddr)\n \t\t}\n-\t\treturn ListenTCP(afnet, la)\n+\t\treturn ListenTCP(net, la)\n \tcase \"unix\", \"unixpacket\":\n \t\tvar la *UnixAddr\n \t\tif a != nil {"}, {"sha": "e5a797e13bf6ca0f6e24e64bfe1be3ea0946bcf5", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -27,8 +27,7 @@ func TestDialTimeout(t *testing.T) {\n \n \terrc := make(chan error)\n \n-\tconst SOMAXCONN = 0x80 // copied from syscall, but not always available\n-\tconst numConns = SOMAXCONN + 10\n+\tnumConns := listenerBacklog + 10\n \n \t// TODO(bradfitz): It's hard to test this in a portable\n \t// way. This is unforunate, but works for now.\n@@ -43,7 +42,7 @@ func TestDialTimeout(t *testing.T) {\n \t\t\t\terrc <- err\n \t\t\t}()\n \t\t}\n-\tcase \"darwin\", \"windows\":\n+\tcase \"darwin\":\n \t\t// At least OS X 10.7 seems to accept any number of\n \t\t// connections, ignoring listen's backlog, so resort\n \t\t// to connecting to a hopefully-dead 127/8 address.\n@@ -54,8 +53,10 @@ func TestDialTimeout(t *testing.T) {\n \t\t}()\n \tdefault:\n \t\t// TODO(bradfitz):\n-\t\t// OpenBSD may have a reject route to 10/8.\n-\t\t// FreeBSD likely works, but is untested.\n+\t\t// OpenBSD may have a reject route to 127/8 except 127.0.0.1/32\n+\t\t// by default. FreeBSD likely works, but is untested.\n+\t\t// TODO(rsc):\n+\t\t// The timeout never happens on Windows.  Why?  Issue 3016.\n \t\tt.Logf(\"skipping test on %q; untested.\", runtime.GOOS)\n \t\treturn\n \t}\n@@ -85,3 +86,45 @@ func TestDialTimeout(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestSelfConnect(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// TODO(brainman): do not know why it hangs.\n+\t\tt.Logf(\"skipping known-broken test on windows\")\n+\t\treturn\n+\t}\n+\t// Test that Dial does not honor self-connects.\n+\t// See the comment in DialTCP.\n+\n+\t// Find a port that would be used as a local address.\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc, err := Dial(\"tcp\", l.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\taddr := c.LocalAddr().String()\n+\tc.Close()\n+\tl.Close()\n+\n+\t// Try to connect to that address repeatedly.\n+\tn := 100000\n+\tif testing.Short() {\n+\t\tn = 1000\n+\t}\n+\tswitch runtime.GOOS {\n+\tcase \"darwin\", \"freebsd\", \"openbsd\", \"windows\":\n+\t\t// Non-Linux systems take a long time to figure\n+\t\t// out that there is nothing listening on localhost.\n+\t\tn = 100\n+\t}\n+\tfor i := 0; i < n; i++ {\n+\t\tc, err := Dial(\"tcp\", addr)\n+\t\tif err == nil {\n+\t\t\tc.Close()\n+\t\t\tt.Errorf(\"#%d: Dial %q succeeded\", i, addr)\n+\t\t}\n+\t}\n+}"}, {"sha": "bf0a387775de494f0852f3ba9af2f6c85870101e", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 140, "deletions": 106, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,6 +7,7 @@\n package net\n \n import (\n+\t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"sync\"\n@@ -17,8 +18,11 @@ import (\n // Network file descriptor.\n type netFD struct {\n \t// locking/lifetime of sysfd\n-\tsysmu   sync.Mutex\n-\tsysref  int\n+\tsysmu  sync.Mutex\n+\tsysref int\n+\n+\t// must lock both sysmu and pollserver to write\n+\t// can lock either to read\n \tclosing bool\n \n \t// immutable until Close\n@@ -27,8 +31,8 @@ type netFD struct {\n \tsotype      int\n \tisConnected bool\n \tsysfile     *os.File\n-\tcr          chan bool\n-\tcw          chan bool\n+\tcr          chan error\n+\tcw          chan error\n \tnet         string\n \tladdr       Addr\n \traddr       Addr\n@@ -86,20 +90,15 @@ type pollServer struct {\n \tdeadline   int64 // next deadline (nsec since 1970)\n }\n \n-func (s *pollServer) AddFD(fd *netFD, mode int) {\n+func (s *pollServer) AddFD(fd *netFD, mode int) error {\n+\ts.Lock()\n \tintfd := fd.sysfd\n-\tif intfd < 0 {\n+\tif intfd < 0 || fd.closing {\n \t\t// fd closed underfoot\n-\t\tif mode == 'r' {\n-\t\t\tfd.cr <- true\n-\t\t} else {\n-\t\t\tfd.cw <- true\n-\t\t}\n-\t\treturn\n+\t\ts.Unlock()\n+\t\treturn errClosing\n \t}\n \n-\ts.Lock()\n-\n \tvar t int64\n \tkey := intfd << 1\n \tif mode == 'r' {\n@@ -124,12 +123,28 @@ func (s *pollServer) AddFD(fd *netFD, mode int) {\n \tif wake {\n \t\tdoWakeup = true\n \t}\n-\n \ts.Unlock()\n \n \tif doWakeup {\n \t\ts.Wakeup()\n \t}\n+\treturn nil\n+}\n+\n+// Evict evicts fd from the pending list, unblocking\n+// any I/O running on fd.  The caller must have locked\n+// pollserver.\n+func (s *pollServer) Evict(fd *netFD) {\n+\tif s.pending[fd.sysfd<<1] == fd {\n+\t\ts.WakeFD(fd, 'r', errClosing)\n+\t\ts.poll.DelFD(fd.sysfd, 'r')\n+\t\tdelete(s.pending, fd.sysfd<<1)\n+\t}\n+\tif s.pending[fd.sysfd<<1|1] == fd {\n+\t\ts.WakeFD(fd, 'w', errClosing)\n+\t\ts.poll.DelFD(fd.sysfd, 'w')\n+\t\tdelete(s.pending, fd.sysfd<<1|1)\n+\t}\n }\n \n var wakeupbuf [1]byte\n@@ -149,16 +164,16 @@ func (s *pollServer) LookupFD(fd int, mode int) *netFD {\n \treturn netfd\n }\n \n-func (s *pollServer) WakeFD(fd *netFD, mode int) {\n+func (s *pollServer) WakeFD(fd *netFD, mode int, err error) {\n \tif mode == 'r' {\n \t\tfor fd.ncr > 0 {\n \t\t\tfd.ncr--\n-\t\t\tfd.cr <- true\n+\t\t\tfd.cr <- err\n \t\t}\n \t} else {\n \t\tfor fd.ncw > 0 {\n \t\t\tfd.ncw--\n-\t\t\tfd.cw <- true\n+\t\t\tfd.cw <- err\n \t\t}\n \t}\n }\n@@ -196,7 +211,7 @@ func (s *pollServer) CheckDeadlines() {\n \t\t\t\t\ts.poll.DelFD(fd.sysfd, mode)\n \t\t\t\t\tfd.wdeadline = -1\n \t\t\t\t}\n-\t\t\t\ts.WakeFD(fd, mode)\n+\t\t\t\ts.WakeFD(fd, mode, nil)\n \t\t\t} else if next_deadline == 0 || t < next_deadline {\n \t\t\t\tnext_deadline = t\n \t\t\t}\n@@ -228,7 +243,7 @@ func (s *pollServer) Run() {\n \t\t\ts.CheckDeadlines()\n \t\t\tcontinue\n \t\t}\n-\t\tif fd == s.pr.Fd() {\n+\t\tif fd == int(s.pr.Fd()) {\n \t\t\t// Drain our wakeup pipe (we could loop here,\n \t\t\t// but it's unlikely that there are more than\n \t\t\t// len(scratch) wakeup calls).\n@@ -240,19 +255,25 @@ func (s *pollServer) Run() {\n \t\t\t\tprint(\"pollServer: unexpected wakeup for fd=\", fd, \" mode=\", string(mode), \"\\n\")\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\ts.WakeFD(netfd, mode)\n+\t\t\ts.WakeFD(netfd, mode, nil)\n \t\t}\n \t}\n }\n \n-func (s *pollServer) WaitRead(fd *netFD) {\n-\ts.AddFD(fd, 'r')\n-\t<-fd.cr\n+func (s *pollServer) WaitRead(fd *netFD) error {\n+\terr := s.AddFD(fd, 'r')\n+\tif err == nil {\n+\t\terr = <-fd.cr\n+\t}\n+\treturn err\n }\n \n-func (s *pollServer) WaitWrite(fd *netFD) {\n-\ts.AddFD(fd, 'w')\n-\t<-fd.cw\n+func (s *pollServer) WaitWrite(fd *netFD) error {\n+\terr := s.AddFD(fd, 'w')\n+\tif err == nil {\n+\t\terr = <-fd.cw\n+\t}\n+\treturn err\n }\n \n // Network FD methods.\n@@ -280,8 +301,8 @@ func newFD(fd, family, sotype int, net string) (*netFD, error) {\n \t\tsotype: sotype,\n \t\tnet:    net,\n \t}\n-\tnetfd.cr = make(chan bool, 1)\n-\tnetfd.cw = make(chan bool, 1)\n+\tnetfd.cr = make(chan error, 1)\n+\tnetfd.cw = make(chan error, 1)\n \treturn netfd, nil\n }\n \n@@ -295,13 +316,15 @@ func (fd *netFD) setAddr(laddr, raddr Addr) {\n \tif raddr != nil {\n \t\trs = raddr.String()\n \t}\n-\tfd.sysfile = os.NewFile(fd.sysfd, fd.net+\":\"+ls+\"->\"+rs)\n+\tfd.sysfile = os.NewFile(uintptr(fd.sysfd), fd.net+\":\"+ls+\"->\"+rs)\n }\n \n func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \terr := syscall.Connect(fd.sysfd, ra)\n \tif err == syscall.EINPROGRESS {\n-\t\tpollserver.WaitWrite(fd)\n+\t\tif err = pollserver.WaitWrite(fd); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\tvar e int\n \t\te, err = syscall.GetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)\n \t\tif err != nil {\n@@ -314,24 +337,37 @@ func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \treturn err\n }\n \n+var errClosing = errors.New(\"use of closed network connection\")\n+\n // Add a reference to this fd.\n-func (fd *netFD) incref() {\n+// If closing==true, pollserver must be locked; mark the fd as closing.\n+// Returns an error if the fd cannot be used.\n+func (fd *netFD) incref(closing bool) error {\n+\tif fd == nil {\n+\t\treturn errClosing\n+\t}\n \tfd.sysmu.Lock()\n+\tif fd.closing {\n+\t\tfd.sysmu.Unlock()\n+\t\treturn errClosing\n+\t}\n \tfd.sysref++\n+\tif closing {\n+\t\tfd.closing = true\n+\t}\n \tfd.sysmu.Unlock()\n+\treturn nil\n }\n \n // Remove a reference to this FD and close if we've been asked to do so (and\n // there are no references left.\n func (fd *netFD) decref() {\n+\tif fd == nil {\n+\t\treturn\n+\t}\n \tfd.sysmu.Lock()\n \tfd.sysref--\n-\tif fd.closing && fd.sysref == 0 && fd.sysfd >= 0 {\n-\t\t// In case the user has set linger, switch to blocking mode so\n-\t\t// the close blocks.  As long as this doesn't happen often, we\n-\t\t// can handle the extra OS processes.  Otherwise we'll need to\n-\t\t// use the pollserver for Close too.  Sigh.\n-\t\tsyscall.SetNonblock(fd.sysfd, false)\n+\tif fd.closing && fd.sysref == 0 && fd.sysfile != nil {\n \t\tfd.sysfile.Close()\n \t\tfd.sysfile = nil\n \t\tfd.sysfd = -1\n@@ -340,21 +376,26 @@ func (fd *netFD) decref() {\n }\n \n func (fd *netFD) Close() error {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn os.EINVAL\n-\t}\n-\n-\tfd.incref()\n-\tsyscall.Shutdown(fd.sysfd, syscall.SHUT_RDWR)\n-\tfd.closing = true\n+\tpollserver.Lock() // needed for both fd.incref(true) and pollserver.Evict\n+\tdefer pollserver.Unlock()\n+\tif err := fd.incref(true); err != nil {\n+\t\treturn err\n+\t}\n+\t// Unblock any I/O.  Once it all unblocks and returns,\n+\t// so that it cannot be referring to fd.sysfd anymore,\n+\t// the final decref will close fd.sysfd.  This should happen\n+\t// fairly quickly, since all the I/O is non-blocking, and any\n+\t// attempts to block in the pollserver will return errClosing.\n+\tpollserver.Evict(fd)\n \tfd.decref()\n \treturn nil\n }\n \n func (fd *netFD) shutdown(how int) error {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn os.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n \t}\n+\tdefer fd.decref()\n \terr := syscall.Shutdown(fd.sysfd, how)\n \tif err != nil {\n \t\treturn &OpError{\"shutdown\", fd.net, fd.laddr, err}\n@@ -371,24 +412,21 @@ func (fd *netFD) CloseWrite() error {\n }\n \n func (fd *netFD) Read(p []byte) (n int, err error) {\n-\tif fd == nil {\n-\t\treturn 0, os.EINVAL\n-\t}\n \tfd.rio.Lock()\n \tdefer fd.rio.Unlock()\n-\tfd.incref()\n-\tdefer fd.decref()\n-\tif fd.sysfile == nil {\n-\t\treturn 0, os.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n \t}\n+\tdefer fd.decref()\n \tfor {\n-\t\tn, err = syscall.Read(fd.sysfile.Fd(), p)\n+\t\tn, err = syscall.Read(int(fd.sysfd), p)\n \t\tif err == syscall.EAGAIN {\n+\t\t\terr = errTimeout\n \t\t\tif fd.rdeadline >= 0 {\n-\t\t\t\tpollserver.WaitRead(fd)\n-\t\t\t\tcontinue\n+\t\t\t\tif err = pollserver.WaitRead(fd); err == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = errTimeout\n \t\t}\n \t\tif err != nil {\n \t\t\tn = 0\n@@ -404,49 +442,49 @@ func (fd *netFD) Read(p []byte) (n int, err error) {\n }\n \n func (fd *netFD) ReadFrom(p []byte) (n int, sa syscall.Sockaddr, err error) {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn 0, nil, os.EINVAL\n-\t}\n \tfd.rio.Lock()\n \tdefer fd.rio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, nil, err\n+\t}\n \tdefer fd.decref()\n \tfor {\n \t\tn, sa, err = syscall.Recvfrom(fd.sysfd, p, 0)\n \t\tif err == syscall.EAGAIN {\n+\t\t\terr = errTimeout\n \t\t\tif fd.rdeadline >= 0 {\n-\t\t\t\tpollserver.WaitRead(fd)\n-\t\t\t\tcontinue\n+\t\t\t\tif err = pollserver.WaitRead(fd); err == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = errTimeout\n \t\t}\n \t\tif err != nil {\n \t\t\tn = 0\n \t\t}\n \t\tbreak\n \t}\n-\tif err != nil {\n+\tif err != nil && err != io.EOF {\n \t\terr = &OpError{\"read\", fd.net, fd.laddr, err}\n \t}\n \treturn\n }\n \n func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.Sockaddr, err error) {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn 0, 0, 0, nil, os.EINVAL\n-\t}\n \tfd.rio.Lock()\n \tdefer fd.rio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, 0, 0, nil, err\n+\t}\n \tdefer fd.decref()\n \tfor {\n \t\tn, oobn, flags, sa, err = syscall.Recvmsg(fd.sysfd, p, oob, 0)\n \t\tif err == syscall.EAGAIN {\n+\t\t\terr = errTimeout\n \t\t\tif fd.rdeadline >= 0 {\n-\t\t\t\tpollserver.WaitRead(fd)\n-\t\t\t\tcontinue\n+\t\t\t\tif err = pollserver.WaitRead(fd); err == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = errTimeout\n \t\t}\n \t\tif err == nil && n == 0 {\n \t\t\terr = io.EOF\n@@ -461,12 +499,11 @@ func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.S\n }\n \n func (fd *netFD) Write(p []byte) (int, error) {\n-\tif fd == nil {\n-\t\treturn 0, os.EINVAL\n-\t}\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tif fd.sysfile == nil {\n \t\treturn 0, os.EINVAL\n@@ -476,19 +513,20 @@ func (fd *netFD) Write(p []byte) (int, error) {\n \tnn := 0\n \tfor {\n \t\tvar n int\n-\t\tn, err = syscall.Write(fd.sysfile.Fd(), p[nn:])\n+\t\tn, err = syscall.Write(int(fd.sysfd), p[nn:])\n \t\tif n > 0 {\n \t\t\tnn += n\n \t\t}\n \t\tif nn == len(p) {\n \t\t\tbreak\n \t\t}\n \t\tif err == syscall.EAGAIN {\n+\t\t\terr = errTimeout\n \t\t\tif fd.wdeadline >= 0 {\n-\t\t\t\tpollserver.WaitWrite(fd)\n-\t\t\t\tcontinue\n+\t\t\t\tif err = pollserver.WaitWrite(fd); err == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = errTimeout\n \t\t}\n \t\tif err != nil {\n \t\t\tn = 0\n@@ -506,21 +544,21 @@ func (fd *netFD) Write(p []byte) (int, error) {\n }\n \n func (fd *netFD) WriteTo(p []byte, sa syscall.Sockaddr) (n int, err error) {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn 0, os.EINVAL\n-\t}\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tfor {\n \t\terr = syscall.Sendto(fd.sysfd, p, 0, sa)\n \t\tif err == syscall.EAGAIN {\n+\t\t\terr = errTimeout\n \t\t\tif fd.wdeadline >= 0 {\n-\t\t\t\tpollserver.WaitWrite(fd)\n-\t\t\t\tcontinue\n+\t\t\t\tif err = pollserver.WaitWrite(fd); err == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = errTimeout\n \t\t}\n \t\tbreak\n \t}\n@@ -533,21 +571,21 @@ func (fd *netFD) WriteTo(p []byte, sa syscall.Sockaddr) (n int, err error) {\n }\n \n func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oobn int, err error) {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn 0, 0, os.EINVAL\n-\t}\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, 0, err\n+\t}\n \tdefer fd.decref()\n \tfor {\n \t\terr = syscall.Sendmsg(fd.sysfd, p, oob, sa, 0)\n \t\tif err == syscall.EAGAIN {\n+\t\t\terr = errTimeout\n \t\t\tif fd.wdeadline >= 0 {\n-\t\t\t\tpollserver.WaitWrite(fd)\n-\t\t\t\tcontinue\n+\t\t\t\tif err = pollserver.WaitWrite(fd); err == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = errTimeout\n \t\t}\n \t\tbreak\n \t}\n@@ -561,11 +599,9 @@ func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oob\n }\n \n func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err error) {\n-\tif fd == nil || fd.sysfile == nil {\n-\t\treturn nil, os.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n \t}\n-\n-\tfd.incref()\n \tdefer fd.decref()\n \n \t// See ../syscall/exec.go for description of ForkLock.\n@@ -574,19 +610,17 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err e\n \tvar s int\n \tvar rsa syscall.Sockaddr\n \tfor {\n-\t\tif fd.closing {\n-\t\t\treturn nil, os.EINVAL\n-\t\t}\n \t\tsyscall.ForkLock.RLock()\n \t\ts, rsa, err = syscall.Accept(fd.sysfd)\n \t\tif err != nil {\n \t\t\tsyscall.ForkLock.RUnlock()\n \t\t\tif err == syscall.EAGAIN {\n+\t\t\t\terr = errTimeout\n \t\t\t\tif fd.rdeadline >= 0 {\n-\t\t\t\t\tpollserver.WaitRead(fd)\n-\t\t\t\t\tcontinue\n+\t\t\t\t\tif err = pollserver.WaitRead(fd); err == nil {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\terr = errTimeout\n \t\t\t}\n \t\t\treturn nil, &OpError{\"accept\", fd.net, fd.laddr, err}\n \t\t}\n@@ -615,7 +649,7 @@ func (fd *netFD) dup() (f *os.File, err error) {\n \t\treturn nil, &OpError{\"setnonblock\", fd.net, fd.laddr, err}\n \t}\n \n-\treturn os.NewFile(ns, fd.sysfile.Name()), nil\n+\treturn os.NewFile(uintptr(ns), fd.sysfile.Name()), nil\n }\n \n func closesocket(s int) error {"}, {"sha": "efd846e5d8c8aefb16ab1316ba8df280e7886eb0", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -5,6 +5,7 @@\n package net\n \n import (\n+\t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"runtime\"\n@@ -272,19 +273,45 @@ func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \treturn syscall.Connect(fd.sysfd, ra)\n }\n \n+var errClosing = errors.New(\"use of closed network connection\")\n+\n // Add a reference to this fd.\n-func (fd *netFD) incref() {\n+// If closing==true, mark the fd as closing.\n+// Returns an error if the fd cannot be used.\n+func (fd *netFD) incref(closing bool) error {\n+\tif fd == nil {\n+\t\treturn errClosing\n+\t}\n \tfd.sysmu.Lock()\n+\tif fd.closing {\n+\t\tfd.sysmu.Unlock()\n+\t\treturn errClosing\n+\t}\n \tfd.sysref++\n+\tif closing {\n+\t\tfd.closing = true\n+\t}\n+\tclosing = fd.closing\n \tfd.sysmu.Unlock()\n+\treturn nil\n }\n \n // Remove a reference to this FD and close if we've been asked to do so (and\n // there are no references left.\n func (fd *netFD) decref() {\n \tfd.sysmu.Lock()\n \tfd.sysref--\n-\tif fd.closing && fd.sysref == 0 && fd.sysfd != syscall.InvalidHandle {\n+\t// NOTE(rsc): On Unix we check fd.sysref == 0 here before closing,\n+\t// but on Windows we have no way to wake up the blocked I/O other\n+\t// than closing the socket (or calling Shutdown, which breaks other\n+\t// programs that might have a reference to the socket).  So there is\n+\t// a small race here that we might close fd.sysfd and then some other\n+\t// goroutine might start a read of fd.sysfd (having read it before we\n+\t// write InvalidHandle to it), which might refer to some other file\n+\t// if the specific handle value gets reused.  I think handle values on\n+\t// Windows are not reused as aggressively as file descriptors on Unix,\n+\t// so this might be tolerable.\n+\tif fd.closing && fd.sysfd != syscall.InvalidHandle {\n \t\t// In case the user has set linger, switch to blocking mode so\n \t\t// the close blocks.  As long as this doesn't happen often, we\n \t\t// can handle the extra OS processes.  Otherwise we'll need to\n@@ -299,13 +326,9 @@ func (fd *netFD) decref() {\n }\n \n func (fd *netFD) Close() error {\n-\tif fd == nil || fd.sysfd == syscall.InvalidHandle {\n-\t\treturn os.EINVAL\n+\tif err := fd.incref(true); err != nil {\n+\t\treturn err\n \t}\n-\n-\tfd.incref()\n-\tsyscall.Shutdown(fd.sysfd, syscall.SHUT_RDWR)\n-\tfd.closing = true\n \tfd.decref()\n \treturn nil\n }\n@@ -350,7 +373,9 @@ func (fd *netFD) Read(buf []byte) (int, error) {\n \t}\n \tfd.rio.Lock()\n \tdefer fd.rio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tif fd.sysfd == syscall.InvalidHandle {\n \t\treturn 0, os.EINVAL\n@@ -390,11 +415,10 @@ func (fd *netFD) ReadFrom(buf []byte) (n int, sa syscall.Sockaddr, err error) {\n \t}\n \tfd.rio.Lock()\n \tdefer fd.rio.Unlock()\n-\tfd.incref()\n-\tdefer fd.decref()\n-\tif fd.sysfd == syscall.InvalidHandle {\n-\t\treturn 0, nil, os.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, nil, err\n \t}\n+\tdefer fd.decref()\n \tvar o readFromOp\n \to.Init(fd, buf, 'r')\n \to.rsan = int32(unsafe.Sizeof(o.rsa))\n@@ -427,11 +451,10 @@ func (fd *netFD) Write(buf []byte) (int, error) {\n \t}\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n-\tfd.incref()\n-\tdefer fd.decref()\n-\tif fd.sysfd == syscall.InvalidHandle {\n-\t\treturn 0, os.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n \t}\n+\tdefer fd.decref()\n \tvar o writeOp\n \to.Init(fd, buf, 'w')\n \treturn iosrv.ExecIO(&o, fd.wdeadline)\n@@ -462,7 +485,9 @@ func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n \t}\n \tfd.wio.Lock()\n \tdefer fd.wio.Unlock()\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tif fd.sysfd == syscall.InvalidHandle {\n \t\treturn 0, os.EINVAL\n@@ -493,10 +518,9 @@ func (o *acceptOp) Name() string {\n }\n \n func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n-\tif fd == nil || fd.sysfd == syscall.InvalidHandle {\n-\t\treturn nil, os.EINVAL\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n \t}\n-\tfd.incref()\n \tdefer fd.decref()\n \n \t// Get new socket."}, {"sha": "f9546dc930db4a07fbafb3a238f3632663c497d8", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,7 +12,7 @@ import (\n )\n \n func newFileFD(f *os.File) (*netFD, error) {\n-\tfd, err := syscall.Dup(f.Fd())\n+\tfd, err := syscall.Dup(int(f.Fd()))\n \tif err != nil {\n \t\treturn nil, os.NewSyscallError(\"dup\", err)\n \t}"}, {"sha": "fec35b72f992ff844f85d7aab77f248471724faf", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -19,6 +19,7 @@ import (\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"syscall\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -355,7 +356,7 @@ func TestCopyError(t *testing.T) {\n \t\tif err != nil {\n \t\t\treturn false\n \t\t}\n-\t\treturn p.Signal(os.UnixSignal(0)) == nil\n+\t\treturn p.Signal(syscall.Signal(0)) == nil\n \t}\n \n \tif !childRunning() {"}, {"sha": "b6ae8b87a2f0de952d44198eedc3c4a370c2d040", "filename": "libgo/go/net/http/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fdoc.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,7 +12,7 @@ Get, Head, Post, and PostForm make HTTP requests:\n \tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\n \t...\n \tresp, err := http.PostForm(\"http://example.com/form\",\n- \t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n+\t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n \n The client must close the response body when finished with it:\n \n@@ -60,7 +60,7 @@ Handle and HandleFunc add handlers to DefaultServeMux:\n \thttp.Handle(\"/foo\", fooHandler)\n \n \thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n-\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.RawPath))\n+\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n \t})\n \n \tlog.Fatal(http.ListenAndServe(\":8080\", nil))"}, {"sha": "c8b9a33c87bedbfc2757db6ffc1a1411b38fa976", "filename": "libgo/go/net/http/fcgi/child.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -243,9 +243,9 @@ func (c *child) serveRequest(req *request, body io.ReadCloser) {\n }\n \n // Serve accepts incoming FastCGI connections on the listener l, creating a new\n-// service thread for each. The service threads read requests and then call handler\n+// goroutine for each. The goroutine reads requests and then calls handler\n // to reply to them.\n-// If l is nil, Serve accepts connections on stdin.\n+// If l is nil, Serve accepts connections from os.Stdin.\n // If handler is nil, http.DefaultServeMux is used.\n func Serve(l net.Listener, handler http.Handler) error {\n \tif l == nil {"}, {"sha": "f35dd32c3055426cfed876f8af69ff8ea5454440", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 124, "deletions": 87, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,7 +17,6 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n-\t\"unicode/utf8\"\n )\n \n // A Dir implements http.FileSystem using the native file\n@@ -58,32 +57,6 @@ type File interface {\n \tSeek(offset int64, whence int) (int64, error)\n }\n \n-// Heuristic: b is text if it is valid UTF-8 and doesn't\n-// contain any unprintable ASCII or Unicode characters.\n-func isText(b []byte) bool {\n-\tfor len(b) > 0 && utf8.FullRune(b) {\n-\t\trune, size := utf8.DecodeRune(b)\n-\t\tif size == 1 && rune == utf8.RuneError {\n-\t\t\t// decoding error\n-\t\t\treturn false\n-\t\t}\n-\t\tif 0x7F <= rune && rune <= 0x9F {\n-\t\t\treturn false\n-\t\t}\n-\t\tif rune < ' ' {\n-\t\t\tswitch rune {\n-\t\t\tcase '\\n', '\\r', '\\t':\n-\t\t\t\t// okay\n-\t\t\tdefault:\n-\t\t\t\t// binary garbage\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t\tb = b[size:]\n-\t}\n-\treturn true\n-}\n-\n func dirList(w ResponseWriter, f File) {\n \tw.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n \tfmt.Fprintf(w, \"<pre>\\n\")\n@@ -104,6 +77,126 @@ func dirList(w ResponseWriter, f File) {\n \tfmt.Fprintf(w, \"</pre>\\n\")\n }\n \n+// ServeContent replies to the request using the content in the\n+// provided ReadSeeker.  The main benefit of ServeContent over io.Copy\n+// is that it handles Range requests properly, sets the MIME type, and\n+// handles If-Modified-Since requests.\n+//\n+// If the response's Content-Type header is not set, ServeContent\n+// first tries to deduce the type from name's file extension and,\n+// if that fails, falls back to reading the first block of the content\n+// and passing it to DetectContentType.\n+// The name is otherwise unused; in particular it can be empty and is\n+// never sent in the response.\n+//\n+// If modtime is not the zero time, ServeContent includes it in a\n+// Last-Modified header in the response.  If the request includes an\n+// If-Modified-Since header, ServeContent uses modtime to decide\n+// whether the content needs to be sent at all.\n+//\n+// The content's Seek method must work: ServeContent uses\n+// a seek to the end of the content to determine its size.\n+//\n+// Note that *os.File implements the io.ReadSeeker interface.\n+func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker) {\n+\tsize, err := content.Seek(0, os.SEEK_END)\n+\tif err != nil {\n+\t\tError(w, \"seeker can't seek\", StatusInternalServerError)\n+\t\treturn\n+\t}\n+\t_, err = content.Seek(0, os.SEEK_SET)\n+\tif err != nil {\n+\t\tError(w, \"seeker can't seek\", StatusInternalServerError)\n+\t\treturn\n+\t}\n+\tserveContent(w, req, name, modtime, size, content)\n+}\n+\n+// if name is empty, filename is unknown. (used for mime type, before sniffing)\n+// if modtime.IsZero(), modtime is unknown.\n+// content must be seeked to the beginning of the file.\n+func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time, size int64, content io.ReadSeeker) {\n+\tif checkLastModified(w, r, modtime) {\n+\t\treturn\n+\t}\n+\n+\tcode := StatusOK\n+\n+\t// If Content-Type isn't set, use the file's extension to find it.\n+\tif w.Header().Get(\"Content-Type\") == \"\" {\n+\t\tctype := mime.TypeByExtension(filepath.Ext(name))\n+\t\tif ctype == \"\" {\n+\t\t\t// read a chunk to decide between utf-8 text and binary\n+\t\t\tvar buf [1024]byte\n+\t\t\tn, _ := io.ReadFull(content, buf[:])\n+\t\t\tb := buf[:n]\n+\t\t\tctype = DetectContentType(b)\n+\t\t\t_, err := content.Seek(0, os.SEEK_SET) // rewind to output whole file\n+\t\t\tif err != nil {\n+\t\t\t\tError(w, \"seeker can't seek\", StatusInternalServerError)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", ctype)\n+\t}\n+\n+\t// handle Content-Range header.\n+\t// TODO(adg): handle multiple ranges\n+\tsendSize := size\n+\tif size >= 0 {\n+\t\tranges, err := parseRange(r.Header.Get(\"Range\"), size)\n+\t\tif err == nil && len(ranges) > 1 {\n+\t\t\terr = errors.New(\"multiple ranges not supported\")\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n+\t\t\treturn\n+\t\t}\n+\t\tif len(ranges) == 1 {\n+\t\t\tra := ranges[0]\n+\t\t\tif _, err := content.Seek(ra.start, os.SEEK_SET); err != nil {\n+\t\t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tsendSize = ra.length\n+\t\t\tcode = StatusPartialContent\n+\t\t\tw.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, size))\n+\t\t}\n+\n+\t\tw.Header().Set(\"Accept-Ranges\", \"bytes\")\n+\t\tif w.Header().Get(\"Content-Encoding\") == \"\" {\n+\t\t\tw.Header().Set(\"Content-Length\", strconv.FormatInt(sendSize, 10))\n+\t\t}\n+\t}\n+\n+\tw.WriteHeader(code)\n+\n+\tif r.Method != \"HEAD\" {\n+\t\tif sendSize == -1 {\n+\t\t\tio.Copy(w, content)\n+\t\t} else {\n+\t\t\tio.CopyN(w, content, sendSize)\n+\t\t}\n+\t}\n+}\n+\n+// modtime is the modification time of the resource to be served, or IsZero().\n+// return value is whether this request is now complete.\n+func checkLastModified(w ResponseWriter, r *Request, modtime time.Time) bool {\n+\tif modtime.IsZero() {\n+\t\treturn false\n+\t}\n+\n+\t// The Date-Modified header truncates sub-second precision, so\n+\t// use mtime < t+1s instead of mtime <= t to check for unmodified.\n+\tif t, err := time.Parse(TimeFormat, r.Header.Get(\"If-Modified-Since\")); err == nil && modtime.Before(t.Add(1*time.Second)) {\n+\t\tw.WriteHeader(StatusNotModified)\n+\t\treturn true\n+\t}\n+\tw.Header().Set(\"Last-Modified\", modtime.UTC().Format(TimeFormat))\n+\treturn false\n+}\n+\n // name is '/'-separated, not filepath.Separator.\n func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirect bool) {\n \tconst indexPage = \"/index.html\"\n@@ -148,14 +241,11 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\t}\n \t}\n \n-\tif t, err := time.Parse(TimeFormat, r.Header.Get(\"If-Modified-Since\")); err == nil && !d.ModTime().After(t) {\n-\t\tw.WriteHeader(StatusNotModified)\n-\t\treturn\n-\t}\n-\tw.Header().Set(\"Last-Modified\", d.ModTime().UTC().Format(TimeFormat))\n-\n \t// use contents of index.html for directory, if present\n \tif d.IsDir() {\n+\t\tif checkLastModified(w, r, d.ModTime()) {\n+\t\t\treturn\n+\t\t}\n \t\tindex := name + indexPage\n \t\tff, err := fs.Open(index)\n \t\tif err == nil {\n@@ -174,60 +264,7 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\treturn\n \t}\n \n-\t// serve file\n-\tsize := d.Size()\n-\tcode := StatusOK\n-\n-\t// If Content-Type isn't set, use the file's extension to find it.\n-\tif w.Header().Get(\"Content-Type\") == \"\" {\n-\t\tctype := mime.TypeByExtension(filepath.Ext(name))\n-\t\tif ctype == \"\" {\n-\t\t\t// read a chunk to decide between utf-8 text and binary\n-\t\t\tvar buf [1024]byte\n-\t\t\tn, _ := io.ReadFull(f, buf[:])\n-\t\t\tb := buf[:n]\n-\t\t\tif isText(b) {\n-\t\t\t\tctype = \"text/plain; charset=utf-8\"\n-\t\t\t} else {\n-\t\t\t\t// generic binary\n-\t\t\t\tctype = \"application/octet-stream\"\n-\t\t\t}\n-\t\t\tf.Seek(0, os.SEEK_SET) // rewind to output whole file\n-\t\t}\n-\t\tw.Header().Set(\"Content-Type\", ctype)\n-\t}\n-\n-\t// handle Content-Range header.\n-\t// TODO(adg): handle multiple ranges\n-\tranges, err := parseRange(r.Header.Get(\"Range\"), size)\n-\tif err == nil && len(ranges) > 1 {\n-\t\terr = errors.New(\"multiple ranges not supported\")\n-\t}\n-\tif err != nil {\n-\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n-\t\treturn\n-\t}\n-\tif len(ranges) == 1 {\n-\t\tra := ranges[0]\n-\t\tif _, err := f.Seek(ra.start, os.SEEK_SET); err != nil {\n-\t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n-\t\t\treturn\n-\t\t}\n-\t\tsize = ra.length\n-\t\tcode = StatusPartialContent\n-\t\tw.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, d.Size()))\n-\t}\n-\n-\tw.Header().Set(\"Accept-Ranges\", \"bytes\")\n-\tif w.Header().Get(\"Content-Encoding\") == \"\" {\n-\t\tw.Header().Set(\"Content-Length\", strconv.FormatInt(size, 10))\n-\t}\n-\n-\tw.WriteHeader(code)\n-\n-\tif r.Method != \"HEAD\" {\n-\t\tio.CopyN(w, f, size)\n-\t}\n+\tserveContent(w, r, d.Name(), d.ModTime(), d.Size(), f)\n }\n \n // localRedirect gives a Moved Permanently response."}, {"sha": "143617e95fc62c22a33e5a36b8b2075cc74cd077", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 138, "deletions": 7, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -5,15 +5,22 @@\n package http_test\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n+\t\"io\"\n \t\"io/ioutil\"\n+\t\"net\"\n \t. \"net/http\"\n \t\"net/http/httptest\"\n \t\"net/url\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n const (\n@@ -56,18 +63,18 @@ func TestServeFile(t *testing.T) {\n \treq.Method = \"GET\"\n \n \t// straight GET\n-\t_, body := getBody(t, req)\n+\t_, body := getBody(t, \"straight get\", req)\n \tif !equal(body, file) {\n \t\tt.Fatalf(\"body mismatch: got %q, want %q\", body, file)\n \t}\n \n \t// Range tests\n-\tfor _, rt := range ServeFileRangeTests {\n+\tfor i, rt := range ServeFileRangeTests {\n \t\treq.Header.Set(\"Range\", \"bytes=\"+rt.r)\n \t\tif rt.r == \"\" {\n \t\t\treq.Header[\"Range\"] = nil\n \t\t}\n-\t\tr, body := getBody(t, req)\n+\t\tr, body := getBody(t, fmt.Sprintf(\"test %d\", i), req)\n \t\tif r.StatusCode != rt.code {\n \t\t\tt.Errorf(\"range=%q: StatusCode=%d, want %d\", rt.r, r.StatusCode, rt.code)\n \t\t}\n@@ -298,29 +305,153 @@ func TestServeIndexHtml(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n-\t\tdefer res.Body.Close()\n \t\tb, err := ioutil.ReadAll(res.Body)\n \t\tif err != nil {\n \t\t\tt.Fatal(\"reading Body:\", err)\n \t\t}\n \t\tif s := string(b); s != want {\n \t\t\tt.Errorf(\"for path %q got %q, want %q\", path, s, want)\n \t\t}\n+\t\tres.Body.Close()\n+\t}\n+}\n+\n+func TestServeContent(t *testing.T) {\n+\ttype req struct {\n+\t\tname    string\n+\t\tmodtime time.Time\n+\t\tcontent io.ReadSeeker\n+\t}\n+\tch := make(chan req, 1)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tp := <-ch\n+\t\tServeContent(w, r, p.name, p.modtime, p.content)\n+\t}))\n+\tdefer ts.Close()\n+\n+\tcss, err := os.Open(\"testdata/style.css\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer css.Close()\n+\n+\tch <- req{\"style.css\", time.Time{}, css}\n+\tres, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, e := res.Header.Get(\"Content-Type\"), \"text/css; charset=utf-8\"; g != e {\n+\t\tt.Errorf(\"style.css: content type = %q, want %q\", g, e)\n+\t}\n+\tif g := res.Header.Get(\"Last-Modified\"); g != \"\" {\n+\t\tt.Errorf(\"want empty Last-Modified; got %q\", g)\n+\t}\n+\n+\tfi, err := css.Stat()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tch <- req{\"style.html\", fi.ModTime(), css}\n+\tres, err = Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, e := res.Header.Get(\"Content-Type\"), \"text/html; charset=utf-8\"; g != e {\n+\t\tt.Errorf(\"style.html: content type = %q, want %q\", g, e)\n+\t}\n+\tif g := res.Header.Get(\"Last-Modified\"); g == \"\" {\n+\t\tt.Errorf(\"want non-empty last-modified\")\n \t}\n }\n \n-func getBody(t *testing.T, req Request) (*Response, []byte) {\n+// verifies that sendfile is being used on Linux\n+func TestLinuxSendfile(t *testing.T) {\n+\tif runtime.GOOS != \"linux\" {\n+\t\tt.Logf(\"skipping; linux-only test\")\n+\t\treturn\n+\t}\n+\t_, err := exec.LookPath(\"strace\")\n+\tif err != nil {\n+\t\tt.Logf(\"skipping; strace not found in path\")\n+\t\treturn\n+\t}\n+\n+\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tlnf, err := ln.(*net.TCPListener).File()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer ln.Close()\n+\n+\tvar buf bytes.Buffer\n+\tchild := exec.Command(\"strace\", \"-f\", os.Args[0], \"-test.run=TestLinuxSendfileChild\")\n+\tchild.ExtraFiles = append(child.ExtraFiles, lnf)\n+\tchild.Env = append([]string{\"GO_WANT_HELPER_PROCESS=1\"}, os.Environ()...)\n+\tchild.Stdout = &buf\n+\tchild.Stderr = &buf\n+\terr = child.Start()\n+\tif err != nil {\n+\t\tt.Logf(\"skipping; failed to start straced child: %v\", err)\n+\t\treturn\n+\t}\n+\n+\t_, err = Get(fmt.Sprintf(\"http://%s/\", ln.Addr()))\n+\tif err != nil {\n+\t\tt.Errorf(\"http client error: %v\", err)\n+\t\treturn\n+\t}\n+\n+\t// Force child to exit cleanly.\n+\tGet(fmt.Sprintf(\"http://%s/quit\", ln.Addr()))\n+\tchild.Wait()\n+\n+\trx := regexp.MustCompile(`sendfile(64)?\\(\\d+,\\s*\\d+,\\s*NULL,\\s*\\d+\\)\\s*=\\s*\\d+\\s*\\n`)\n+\trxResume := regexp.MustCompile(`<\\.\\.\\. sendfile(64)? resumed> \\)\\s*=\\s*\\d+\\s*\\n`)\n+\tout := buf.String()\n+\tif !rx.MatchString(out) && !rxResume.MatchString(out) {\n+\t\tt.Errorf(\"no sendfile system call found in:\\n%s\", out)\n+\t}\n+}\n+\n+func getBody(t *testing.T, testName string, req Request) (*Response, []byte) {\n \tr, err := DefaultClient.Do(&req)\n \tif err != nil {\n-\t\tt.Fatal(req.URL.String(), \"send:\", err)\n+\t\tt.Fatalf(\"%s: for URL %q, send error: %v\", testName, req.URL.String(), err)\n \t}\n \tb, err := ioutil.ReadAll(r.Body)\n \tif err != nil {\n-\t\tt.Fatal(\"reading Body:\", err)\n+\t\tt.Fatalf(\"%s: for URL %q, reading body: %v\", testName, req.URL.String(), err)\n \t}\n \treturn r, b\n }\n \n+// TestLinuxSendfileChild isn't a real test. It's used as a helper process\n+// for TestLinuxSendfile.\n+func TestLinuxSendfileChild(*testing.T) {\n+\tif os.Getenv(\"GO_WANT_HELPER_PROCESS\") != \"1\" {\n+\t\treturn\n+\t}\n+\tdefer os.Exit(0)\n+\tfd3 := os.NewFile(3, \"ephemeral-port-listener\")\n+\tln, err := net.FileListener(fd3)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tmux := NewServeMux()\n+\tmux.Handle(\"/\", FileServer(Dir(\"testdata\")))\n+\tmux.HandleFunc(\"/quit\", func(ResponseWriter, *Request) {\n+\t\tos.Exit(0)\n+\t})\n+\ts := &Server{Handler: mux}\n+\terr = s.Serve(ln)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+}\n+\n func equal(a, b []byte) bool {\n \tif len(a) != len(b) {\n \t\treturn false"}, {"sha": "8d911f7575bfbfa0592bb54e9e4e3912b8a43ed7", "filename": "libgo/go/net/http/httptest/server.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -61,7 +61,7 @@ func newLocalListener() net.Listener {\n \n // When debugging a particular http server-based test,\n // this flag lets you run\n-//\tgotest -run=BrokenTest -httptest.serve=127.0.0.1:8000\n+//\tgo test -run=BrokenTest -httptest.serve=127.0.0.1:8000\n // to start the broken server so you can interact with it manually.\n var serve = flag.String(\"httptest.serve\", \"\", \"if non-empty, httptest.NewServer serves on this address and blocks\")\n \n@@ -95,7 +95,7 @@ func (s *Server) Start() {\n \ts.URL = \"http://\" + s.Listener.Addr().String()\n \tgo s.Config.Serve(s.Listener)\n \tif *serve != \"\" {\n-\t\tfmt.Println(os.Stderr, \"httptest: serving on\", s.URL)\n+\t\tfmt.Fprintln(os.Stderr, \"httptest: serving on\", s.URL)\n \t\tselect {}\n \t}\n }"}, {"sha": "500a9f0b80000b93a1c85f9f6fd1689e487c7239", "filename": "libgo/go/net/http/httptest/server_test.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package httptest\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"net/http\"\n+\t\"testing\"\n+)\n+\n+func TestServer(t *testing.T) {\n+\tts := NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Write([]byte(\"hello\"))\n+\t}))\n+\tdefer ts.Close()\n+\tres, err := http.Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tgot, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(got) != \"hello\" {\n+\t\tt.Errorf(\"got %q, want hello\", string(got))\n+\t}\n+}"}, {"sha": "0fe41b7d31b0dbea4ff505daaa6bbddf52f6c352", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,15 +12,23 @@\n // The handled paths all begin with /debug/pprof/.\n //\n // To use pprof, link this package into your program:\n-//\timport _ \"http/pprof\"\n+//\timport _ \"net/http/pprof\"\n //\n // Then use the pprof tool to look at the heap profile:\n //\n-//\tpprof http://localhost:6060/debug/pprof/heap\n+//\tgo tool pprof http://localhost:6060/debug/pprof/heap\n //\n // Or to look at a 30-second CPU profile:\n //\n-//\tpprof http://localhost:6060/debug/pprof/profile\n+//\tgo tool pprof http://localhost:6060/debug/pprof/profile\n+//\n+// Or to look at the thread creation profile:\n+//\n+//\tgo tool pprof http://localhost:6060/debug/pprof/thread\n+//\n+// For a study of the facility in action, visit\n+//\n+//\thttp://blog.golang.org/2011/06/profiling-go-programs.html\n //\n package pprof\n \n@@ -43,6 +51,7 @@ func init() {\n \thttp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(Profile))\n \thttp.Handle(\"/debug/pprof/heap\", http.HandlerFunc(Heap))\n \thttp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(Symbol))\n+\thttp.Handle(\"/debug/pprof/thread\", http.HandlerFunc(Thread))\n }\n \n // Cmdline responds with the running program's\n@@ -60,6 +69,13 @@ func Heap(w http.ResponseWriter, r *http.Request) {\n \tpprof.WriteHeapProfile(w)\n }\n \n+// Thread responds with the pprof-formatted thread creation profile.\n+// The package initialization registers it as /debug/pprof/thread.\n+func Thread(w http.ResponseWriter, r *http.Request) {\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\tpprof.WriteThreadProfile(w)\n+}\n+\n // Profile responds with the pprof-formatted cpu profile.\n // The package initialization registers it as /debug/pprof/profile.\n func Profile(w http.ResponseWriter, r *http.Request) {"}, {"sha": "165ec3624a4585303f97ac6959c4f4f1bca7a934", "filename": "libgo/go/net/http/response_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -321,9 +321,7 @@ func TestReadResponseCloseInMiddle(t *testing.T) {\n \t\t}\n \t\tif test.compressed {\n \t\t\tbuf.WriteString(\"Content-Encoding: gzip\\r\\n\")\n-\t\t\tvar err error\n-\t\t\twr, err = gzip.NewWriter(wr)\n-\t\t\tcheckErr(err, \"gzip.NewWriter\")\n+\t\t\twr = gzip.NewWriter(wr)\n \t\t}\n \t\tbuf.WriteString(\"\\r\\n\")\n \n@@ -337,7 +335,7 @@ func TestReadResponseCloseInMiddle(t *testing.T) {\n \t\t\twr.Write(chunk)\n \t\t}\n \t\tif test.compressed {\n-\t\t\terr := wr.(*gzip.Compressor).Close()\n+\t\t\terr := wr.(*gzip.Writer).Close()\n \t\t\tcheckErr(err, \"compressor close\")\n \t\t}\n \t\tif test.chunked {"}, {"sha": "e715c73cb6e9586d1757f4f84e8f97546185130a", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -59,7 +59,9 @@ type ResponseWriter interface {\n \n \t// Write writes the data to the connection as part of an HTTP reply.\n \t// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\n-\t// before writing the data.\n+\t// before writing the data.  If the Header does not contain a\n+\t// Content-Type line, Write adds a Content-Type set to the result of passing\n+\t// the initial 512 bytes of written data to DetectContentType.\n \tWrite([]byte) (int, error)\n \n \t// WriteHeader sends an HTTP response header with status code.\n@@ -833,11 +835,17 @@ func RedirectHandler(url string, code int) Handler {\n // redirecting any request containing . or .. elements to an\n // equivalent .- and ..-free URL.\n type ServeMux struct {\n-\tm map[string]Handler\n+\tmu sync.RWMutex\n+\tm  map[string]muxEntry\n+}\n+\n+type muxEntry struct {\n+\texplicit bool\n+\th        Handler\n }\n \n // NewServeMux allocates and returns a new ServeMux.\n-func NewServeMux() *ServeMux { return &ServeMux{make(map[string]Handler)} }\n+func NewServeMux() *ServeMux { return &ServeMux{m: make(map[string]muxEntry)} }\n \n // DefaultServeMux is the default ServeMux used by Serve.\n var DefaultServeMux = NewServeMux()\n@@ -883,12 +891,28 @@ func (mux *ServeMux) match(path string) Handler {\n \t\t}\n \t\tif h == nil || len(k) > n {\n \t\t\tn = len(k)\n-\t\t\th = v\n+\t\t\th = v.h\n \t\t}\n \t}\n \treturn h\n }\n \n+// handler returns the handler to use for the request r.\n+func (mux *ServeMux) handler(r *Request) Handler {\n+\tmux.mu.RLock()\n+\tdefer mux.mu.RUnlock()\n+\n+\t// Host-specific pattern takes precedence over generic ones\n+\th := mux.match(r.Host + r.URL.Path)\n+\tif h == nil {\n+\t\th = mux.match(r.URL.Path)\n+\t}\n+\tif h == nil {\n+\t\th = NotFoundHandler()\n+\t}\n+\treturn h\n+}\n+\n // ServeHTTP dispatches the request to the handler whose\n // pattern most closely matches the request URL.\n func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n@@ -898,30 +922,33 @@ func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n \t\tw.WriteHeader(StatusMovedPermanently)\n \t\treturn\n \t}\n-\t// Host-specific pattern takes precedence over generic ones\n-\th := mux.match(r.Host + r.URL.Path)\n-\tif h == nil {\n-\t\th = mux.match(r.URL.Path)\n-\t}\n-\tif h == nil {\n-\t\th = NotFoundHandler()\n-\t}\n-\th.ServeHTTP(w, r)\n+\tmux.handler(r).ServeHTTP(w, r)\n }\n \n // Handle registers the handler for the given pattern.\n+// If a handler already exists for pattern, Handle panics.\n func (mux *ServeMux) Handle(pattern string, handler Handler) {\n+\tmux.mu.Lock()\n+\tdefer mux.mu.Unlock()\n+\n \tif pattern == \"\" {\n \t\tpanic(\"http: invalid pattern \" + pattern)\n \t}\n+\tif handler == nil {\n+\t\tpanic(\"http: nil handler\")\n+\t}\n+\tif mux.m[pattern].explicit {\n+\t\tpanic(\"http: multiple registrations for \" + pattern)\n+\t}\n \n-\tmux.m[pattern] = handler\n+\tmux.m[pattern] = muxEntry{explicit: true, h: handler}\n \n \t// Helpful behavior:\n-\t// If pattern is /tree/, insert permanent redirect for /tree.\n+\t// If pattern is /tree/, insert an implicit permanent redirect for /tree.\n+\t// It can be overridden by an explicit registration.\n \tn := len(pattern)\n-\tif n > 0 && pattern[n-1] == '/' {\n-\t\tmux.m[pattern[0:n-1]] = RedirectHandler(pattern, StatusMovedPermanently)\n+\tif n > 0 && pattern[n-1] == '/' && !mux.m[pattern[0:n-1]].explicit {\n+\t\tmux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(pattern, StatusMovedPermanently)}\n \t}\n }\n \n@@ -980,15 +1007,26 @@ func (srv *Server) ListenAndServe() error {\n // then call srv.Handler to reply to them.\n func (srv *Server) Serve(l net.Listener) error {\n \tdefer l.Close()\n+\tvar tempDelay time.Duration // how long to sleep on accept failure\n \tfor {\n \t\trw, e := l.Accept()\n \t\tif e != nil {\n \t\t\tif ne, ok := e.(net.Error); ok && ne.Temporary() {\n-\t\t\t\tlog.Printf(\"http: Accept error: %v\", e)\n+\t\t\t\tif tempDelay == 0 {\n+\t\t\t\t\ttempDelay = 5 * time.Millisecond\n+\t\t\t\t} else {\n+\t\t\t\t\ttempDelay *= 2\n+\t\t\t\t}\n+\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n+\t\t\t\t\ttempDelay = max\n+\t\t\t\t}\n+\t\t\t\tlog.Printf(\"http: Accept error: %v; retrying in %v\", e, tempDelay)\n+\t\t\t\ttime.Sleep(tempDelay)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\treturn e\n \t\t}\n+\t\ttempDelay = 0\n \t\tif srv.ReadTimeout != 0 {\n \t\t\trw.SetReadDeadline(time.Now().Add(srv.ReadTimeout))\n \t\t}"}, {"sha": "68f519b0542099a1f9dca3994abda70e2b43dee4", "filename": "libgo/go/net/http/sniff.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,15 +9,15 @@ import (\n \t\"encoding/binary\"\n )\n \n-// Content-type sniffing algorithm.\n-// References in this file refer to this draft specification:\n-//   http://mimesniff.spec.whatwg.org/\n-\n-// The algorithm prefers to use sniffLen bytes to make its decision.\n+// The algorithm uses at most sniffLen bytes to make its decision.\n const sniffLen = 512\n \n-// DetectContentType returns the sniffed Content-Type string\n-// for the given data. This function always returns a valid MIME type.\n+// DetectContentType implements the algorithm described\n+// at http://mimesniff.spec.whatwg.org/ to determine the\n+// Content-Type of the given data.  It considers at most the\n+// first 512 bytes of data.  DetectContentType always returns\n+// a valid MIME type: if it cannot determine a more specific one, it\n+// returns \"application/octet-stream\".\n func DetectContentType(data []byte) string {\n \tif len(data) > sniffLen {\n \t\tdata = data[:sniffLen]"}, {"sha": "3e48abafb5e72e9be6cdbb1d5eae6204465a224c", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -85,16 +85,16 @@ func ProxyFromEnvironment(req *Request) (*url.URL, error) {\n \tif !useProxy(canonicalAddr(req.URL)) {\n \t\treturn nil, nil\n \t}\n-\tproxyURL, err := url.ParseRequest(proxy)\n+\tproxyURL, err := url.Parse(proxy)\n \tif err != nil {\n-\t\treturn nil, errors.New(\"invalid proxy address\")\n-\t}\n-\tif proxyURL.Host == \"\" {\n-\t\tproxyURL, err = url.ParseRequest(\"http://\" + proxy)\n-\t\tif err != nil {\n-\t\t\treturn nil, errors.New(\"invalid proxy address\")\n+\t\tif u, err := url.Parse(\"http://\" + proxy); err == nil {\n+\t\t\tproxyURL = u\n+\t\t\terr = nil\n \t\t}\n \t}\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid proxy address %q: %v\", proxy, err)\n+\t}\n \treturn proxyURL, nil\n }\n \n@@ -235,15 +235,19 @@ func (cm *connectMethod) proxyAuth() string {\n \treturn \"\"\n }\n \n-func (t *Transport) putIdleConn(pconn *persistConn) {\n+// putIdleConn adds pconn to the list of idle persistent connections awaiting\n+// a new request.\n+// If pconn is no longer needed or not in a good state, putIdleConn\n+// returns false.\n+func (t *Transport) putIdleConn(pconn *persistConn) bool {\n \tt.lk.Lock()\n \tdefer t.lk.Unlock()\n \tif t.DisableKeepAlives || t.MaxIdleConnsPerHost < 0 {\n \t\tpconn.close()\n-\t\treturn\n+\t\treturn false\n \t}\n \tif pconn.isBroken() {\n-\t\treturn\n+\t\treturn false\n \t}\n \tkey := pconn.cacheKey\n \tmax := t.MaxIdleConnsPerHost\n@@ -252,9 +256,10 @@ func (t *Transport) putIdleConn(pconn *persistConn) {\n \t}\n \tif len(t.idleConn[key]) >= max {\n \t\tpconn.close()\n-\t\treturn\n+\t\treturn false\n \t}\n \tt.idleConn[key] = append(t.idleConn[key], pconn)\n+\treturn true\n }\n \n func (t *Transport) getIdleConn(cm *connectMethod) (pconn *persistConn) {\n@@ -565,7 +570,9 @@ func (pc *persistConn) readLoop() {\n \t\t\t\tlastbody = resp.Body\n \t\t\t\twaitForBodyRead = make(chan bool)\n \t\t\t\tresp.Body.(*bodyEOFSignal).fn = func() {\n-\t\t\t\t\tpc.t.putIdleConn(pc)\n+\t\t\t\t\tif !pc.t.putIdleConn(pc) {\n+\t\t\t\t\t\talive = false\n+\t\t\t\t\t}\n \t\t\t\t\twaitForBodyRead <- true\n \t\t\t\t}\n \t\t\t} else {\n@@ -578,7 +585,9 @@ func (pc *persistConn) readLoop() {\n \t\t\t\t// read it (even though it'll just be 0, EOF).\n \t\t\t\tlastbody = nil\n \n-\t\t\t\tpc.t.putIdleConn(pc)\n+\t\t\t\tif !pc.t.putIdleConn(pc) {\n+\t\t\t\t\talive = false\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n "}, {"sha": "a36571a44468ce7c08ce9d58201e95bc939d6f14", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -16,6 +16,7 @@ import (\n \t. \"net/http\"\n \t\"net/http/httptest\"\n \t\"net/url\"\n+\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -441,11 +442,7 @@ func TestRoundTripGzip(t *testing.T) {\n \t\t}\n \t\tif accept == \"gzip\" {\n \t\t\trw.Header().Set(\"Content-Encoding\", \"gzip\")\n-\t\t\tgz, err := gzip.NewWriter(rw)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"gzip NewWriter: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n+\t\t\tgz := gzip.NewWriter(rw)\n \t\t\tgz.Write([]byte(responseBody))\n \t\t\tgz.Close()\n \t\t} else {\n@@ -512,7 +509,7 @@ func TestTransportGzip(t *testing.T) {\n \t\t\t\trw.Header().Set(\"Content-Length\", strconv.Itoa(buf.Len()))\n \t\t\t}()\n \t\t}\n-\t\tgz, _ := gzip.NewWriter(w)\n+\t\tgz := gzip.NewWriter(w)\n \t\tgz.Write([]byte(testString))\n \t\tif req.FormValue(\"body\") == \"large\" {\n \t\t\tio.CopyN(gz, rand.Reader, nRandBytes)\n@@ -636,6 +633,70 @@ func TestTransportGzipRecursive(t *testing.T) {\n \t}\n }\n \n+// tests that persistent goroutine connections shut down when no longer desired.\n+func TestTransportPersistConnLeak(t *testing.T) {\n+\tgotReqCh := make(chan bool)\n+\tunblockCh := make(chan bool)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tgotReqCh <- true\n+\t\t<-unblockCh\n+\t\tw.Header().Set(\"Content-Length\", \"0\")\n+\t\tw.WriteHeader(204)\n+\t}))\n+\tdefer ts.Close()\n+\n+\ttr := &Transport{}\n+\tc := &Client{Transport: tr}\n+\n+\tn0 := runtime.Goroutines()\n+\n+\tconst numReq = 25\n+\tdidReqCh := make(chan bool)\n+\tfor i := 0; i < numReq; i++ {\n+\t\tgo func() {\n+\t\t\tres, err := c.Get(ts.URL)\n+\t\t\tdidReqCh <- true\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"client fetch error: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tres.Body.Close()\n+\t\t}()\n+\t}\n+\n+\t// Wait for all goroutines to be stuck in the Handler.\n+\tfor i := 0; i < numReq; i++ {\n+\t\t<-gotReqCh\n+\t}\n+\n+\tnhigh := runtime.Goroutines()\n+\n+\t// Tell all handlers to unblock and reply.\n+\tfor i := 0; i < numReq; i++ {\n+\t\tunblockCh <- true\n+\t}\n+\n+\t// Wait for all HTTP clients to be done.\n+\tfor i := 0; i < numReq; i++ {\n+\t\t<-didReqCh\n+\t}\n+\n+\ttr.CloseIdleConnections()\n+\ttime.Sleep(100 * time.Millisecond)\n+\truntime.GC()\n+\truntime.GC() // even more.\n+\tnfinal := runtime.Goroutines()\n+\n+\tgrowth := nfinal - n0\n+\n+\t// We expect 0 or 1 extra goroutine, empirically.  Allow up to 5.\n+\t// Previously we were leaking one per numReq.\n+\tt.Logf(\"goroutine growth: %d -> %d -> %d (delta: %d)\", n0, nhigh, nfinal, growth)\n+\tif int(growth) > 5 {\n+\t\tt.Error(\"too many new goroutines\")\n+\t}\n+}\n+\n type fooProto struct{}\n \n func (fooProto) RoundTrip(req *Request) (*Response, error) {"}, {"sha": "c88a0fbce73cff2d6554a9815535139e378d6371", "filename": "libgo/go/net/http/triv.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build ignore\n+\n package main\n \n import ("}, {"sha": "4da18a5061ac3d3d156bd408a3cfef9fa12fd65a", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -53,13 +53,13 @@ func probeIPv6Stack() (supportsIPv6, supportsIPv4map bool) {\n }\n \n // favoriteAddrFamily returns the appropriate address family to\n-// the given net, raddr, laddr and mode.  At first it figures\n+// the given net, laddr, raddr and mode.  At first it figures\n // address family out from the net.  If mode indicates \"listen\"\n // and laddr.(type).IP is nil, it assumes that the user wants to\n // make a passive connection with wildcard address family, both\n // INET and INET6, and wildcard address.  Otherwise guess: if the\n // addresses are IPv4 then returns INET, or else returns INET6.\n-func favoriteAddrFamily(net string, raddr, laddr sockaddr, mode string) int {\n+func favoriteAddrFamily(net string, laddr, raddr sockaddr, mode string) int {\n \tswitch net[len(net)-1] {\n \tcase '4':\n \t\treturn syscall.AF_INET\n@@ -68,17 +68,20 @@ func favoriteAddrFamily(net string, raddr, laddr sockaddr, mode string) int {\n \t}\n \n \tif mode == \"listen\" {\n+\t\t// Note that OpenBSD allows neither \"net.inet6.ip6.v6only\"\n+\t\t// change nor IPPROTO_IPV6 level IPV6_V6ONLY socket option\n+\t\t// setting.\n \t\tswitch a := laddr.(type) {\n \t\tcase *TCPAddr:\n-\t\t\tif a.IP == nil && supportsIPv6 {\n+\t\t\tif a.IP == nil && supportsIPv6 && supportsIPv4map {\n \t\t\t\treturn syscall.AF_INET6\n \t\t\t}\n \t\tcase *UDPAddr:\n-\t\t\tif a.IP == nil && supportsIPv6 {\n+\t\t\tif a.IP == nil && supportsIPv6 && supportsIPv4map {\n \t\t\t\treturn syscall.AF_INET6\n \t\t\t}\n \t\tcase *IPAddr:\n-\t\t\tif a.IP == nil && supportsIPv6 {\n+\t\t\tif a.IP == nil && supportsIPv6 && supportsIPv4map {\n \t\t\t\treturn syscall.AF_INET6\n \t\t\t}\n \t\t}\n@@ -104,7 +107,7 @@ type sockaddr interface {\n func internetSocket(net string, laddr, raddr sockaddr, sotype, proto int, mode string, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n \tvar oserr error\n \tvar la, ra syscall.Sockaddr\n-\tfamily := favoriteAddrFamily(net, raddr, laddr, mode)\n+\tfamily := favoriteAddrFamily(net, laddr, raddr, mode)\n \tif laddr != nil {\n \t\tif la, oserr = laddr.sockaddr(family); oserr != nil {\n \t\t\tgoto Error"}, {"sha": "69d7ac878808edebaef6d5733f36f4c6966281a6", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"regexp\"\n \t\"runtime\"\n \t\"testing\"\n+\t\"time\"\n )\n \n var runErrorTest = flag.Bool(\"run_error_test\", false, \"let TestDialError check for dns errors\")\n@@ -173,3 +174,58 @@ func TestShutdown(t *testing.T) {\n \t\tt.Errorf(\"read = %q, want \\\"response\\\"\", got)\n \t}\n }\n+\n+func TestTCPListenClose(t *testing.T) {\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t}\n+\n+\tdone := make(chan bool, 1)\n+\tgo func() {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\tl.Close()\n+\t}()\n+\tgo func() {\n+\t\t_, err = l.Accept()\n+\t\tif err == nil {\n+\t\t\tt.Error(\"Accept succeeded\")\n+\t\t} else {\n+\t\t\tt.Logf(\"Accept timeout error: %s (any error is fine)\", err)\n+\t\t}\n+\t\tdone <- true\n+\t}()\n+\tselect {\n+\tcase <-done:\n+\tcase <-time.After(2 * time.Second):\n+\t\tt.Fatal(\"timeout waiting for TCP close\")\n+\t}\n+}\n+\n+func TestUDPListenClose(t *testing.T) {\n+\tl, err := ListenPacket(\"udp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t}\n+\n+\tbuf := make([]byte, 1000)\n+\tdone := make(chan bool, 1)\n+\tgo func() {\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\tl.Close()\n+\t}()\n+\tgo func() {\n+\t\t_, _, err = l.ReadFrom(buf)\n+\t\tif err == nil {\n+\t\t\tt.Error(\"ReadFrom succeeded\")\n+\t\t} else {\n+\t\t\tt.Logf(\"ReadFrom timeout error: %s (any error is fine)\", err)\n+\t\t}\n+\t\tdone <- true\n+\t}()\n+\tselect {\n+\tcase <-done:\n+\tcase <-time.After(2 * time.Second):\n+\t\tt.Fatal(\"timeout waiting for UDP close\")\n+\t}\n+}"}, {"sha": "d34bb511f7fd57afad1776702721c8ee282ce1ae", "filename": "libgo/go/net/newpollserver.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnewpollserver.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -18,16 +18,16 @@ func newPollServer() (s *pollServer, err error) {\n \tif s.pr, s.pw, err = os.Pipe(); err != nil {\n \t\treturn nil, err\n \t}\n-\tif err = syscall.SetNonblock(s.pr.Fd(), true); err != nil {\n+\tif err = syscall.SetNonblock(int(s.pr.Fd()), true); err != nil {\n \t\tgoto Errno\n \t}\n-\tif err = syscall.SetNonblock(s.pw.Fd(), true); err != nil {\n+\tif err = syscall.SetNonblock(int(s.pw.Fd()), true); err != nil {\n \t\tgoto Errno\n \t}\n \tif s.poll, err = newpollster(); err != nil {\n \t\tgoto Error\n \t}\n-\tif _, err = s.poll.AddFD(s.pr.Fd(), 'r', true); err != nil {\n+\tif _, err = s.poll.AddFD(int(s.pr.Fd()), 'r', true); err != nil {\n \t\ts.poll.Close()\n \t\tgoto Error\n \t}"}, {"sha": "a0d53036263e6f1f93e9bc0a92432c2fff3873d4", "filename": "libgo/go/net/sendfile_linux.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_linux.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -38,11 +38,13 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \n \tc.wio.Lock()\n \tdefer c.wio.Unlock()\n-\tc.incref()\n+\tif err := c.incref(false); err != nil {\n+\t\treturn 0, err, true\n+\t}\n \tdefer c.decref()\n \n \tdst := c.sysfd\n-\tsrc := f.Fd()\n+\tsrc := int(f.Fd())\n \tfor remain > 0 {\n \t\tn := maxSendfileSize\n \t\tif int64(n) > remain {\n@@ -57,8 +59,9 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \t\t\tbreak\n \t\t}\n \t\tif err1 == syscall.EAGAIN && c.wdeadline >= 0 {\n-\t\t\tpollserver.WaitWrite(c)\n-\t\t\tcontinue\n+\t\t\tif err1 = pollserver.WaitWrite(c); err1 == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t}\n \t\tif err1 != nil {\n \t\t\t// This includes syscall.ENOSYS (no kernel"}, {"sha": "f5a6d8804da6361f95418be4d7ae2203717ac439", "filename": "libgo/go/net/sendfile_windows.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsendfile_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsendfile_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -50,13 +50,15 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \n \tc.wio.Lock()\n \tdefer c.wio.Unlock()\n-\tc.incref()\n+\tif err := c.incref(false); err != nil {\n+\t\treturn 0, err, true\n+\t}\n \tdefer c.decref()\n \n \tvar o sendfileOp\n \to.Init(c, 'w')\n \to.n = uint32(n)\n-\to.src = f.Fd()\n+\to.src = syscall.Handle(f.Fd())\n \tdone, err := iosrv.ExecIO(&o, 0)\n \tif err != nil {\n \t\treturn 0, err, false"}, {"sha": "55691493aa9dc2596530f088cb7e28503116ec4e", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -83,7 +83,7 @@ func connect(t *testing.T, network, addr string, isEmpty bool) {\n \t}\n \n \t// Send explicit ending for unixpacket.\n-\t// Older Linux kernels do stop reads on close.\n+\t// Older Linux kernels do not stop reads on close.\n \tif network == \"unixpacket\" {\n \t\tfd.Write([]byte(\"END\"))\n \t}\n@@ -115,16 +115,13 @@ func doTest(t *testing.T, network, listenaddr, dialaddr string) {\n }\n \n func TestTCPServer(t *testing.T) {\n-\tif runtime.GOOS != \"openbsd\" {\n-\t\tdoTest(t, \"tcp\", \"\", \"127.0.0.1\")\n-\t}\n+\tdoTest(t, \"tcp\", \"\", \"127.0.0.1\")\n \tdoTest(t, \"tcp\", \"0.0.0.0\", \"127.0.0.1\")\n \tdoTest(t, \"tcp\", \"127.0.0.1\", \"127.0.0.1\")\n \tdoTest(t, \"tcp4\", \"\", \"127.0.0.1\")\n \tdoTest(t, \"tcp4\", \"0.0.0.0\", \"127.0.0.1\")\n \tdoTest(t, \"tcp4\", \"127.0.0.1\", \"127.0.0.1\")\n \tif supportsIPv6 {\n-\t\tdoTest(t, \"tcp\", \"\", \"[::1]\")\n \t\tdoTest(t, \"tcp\", \"[::]\", \"[::1]\")\n \t\tdoTest(t, \"tcp\", \"[::1]\", \"[::1]\")\n \t\tdoTest(t, \"tcp6\", \"\", \"[::1]\")"}, {"sha": "2607b04c7bc777d688b64cf2247c2536cb06549f", "filename": "libgo/go/net/sock_bsd.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_bsd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -38,6 +38,11 @@ func listenerSockaddr(s, f int, la syscall.Sockaddr, toAddr func(syscall.Sockadd\n \t\treturn la, nil\n \t}\n \tswitch v := a.(type) {\n+\tcase *TCPAddr, *UnixAddr:\n+\t\terr := setDefaultListenerSockopts(s)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \tcase *UDPAddr:\n \t\tif v.IP.IsMulticast() {\n \t\t\terr := setDefaultMulticastSockopts(s)"}, {"sha": "e509d93978b1205b30e9a45e83a873fd779deb27", "filename": "libgo/go/net/sock_linux.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsock_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsock_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_linux.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -32,6 +32,11 @@ func listenerSockaddr(s, f int, la syscall.Sockaddr, toAddr func(syscall.Sockadd\n \t\treturn la, nil\n \t}\n \tswitch v := a.(type) {\n+\tcase *TCPAddr, *UnixAddr:\n+\t\terr := setDefaultListenerSockopts(s)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \tcase *UDPAddr:\n \t\tif v.IP.IsMulticast() {\n \t\t\terr := setDefaultMulticastSockopts(s)"}, {"sha": "cce6181c9e52d2570f5cc4ecf4dfb1c4053bd99d", "filename": "libgo/go/net/sock_windows.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -19,6 +19,11 @@ func listenerSockaddr(s syscall.Handle, f int, la syscall.Sockaddr, toAddr func(\n \t\treturn la, nil\n \t}\n \tswitch v := a.(type) {\n+\tcase *TCPAddr, *UnixAddr:\n+\t\terr := setDefaultListenerSockopts(s)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \tcase *UDPAddr:\n \t\tif v.IP.IsMulticast() {\n \t\t\terr := setDefaultMulticastSockopts(s)"}, {"sha": "0a051d7ae3c6ec0ce82497333deb8a91ebeeb13a", "filename": "libgo/go/net/sockopt.go", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -105,13 +105,17 @@ done:\n }\n \n func setReadBuffer(fd *netFD, bytes int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes))\n }\n \n func setWriteBuffer(fd *netFD, bytes int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes))\n }\n@@ -142,25 +146,33 @@ func setDeadline(fd *netFD, t time.Time) error {\n }\n \n func setReuseAddr(fd *netFD, reuse bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse)))\n }\n \n func setDontRoute(fd *netFD, dontroute bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute)))\n }\n \n func setKeepAlive(fd *netFD, keepalive bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive)))\n }\n \n func setNoDelay(fd *netFD, noDelay bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_TCP, syscall.TCP_NODELAY, boolint(noDelay)))\n }\n@@ -174,7 +186,9 @@ func setLinger(fd *netFD, sec int) error {\n \t\tl.Onoff = 0\n \t\tl.Linger = 0\n \t}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptLinger(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_LINGER, &l))\n }"}, {"sha": "79e0e57e21ee49634128484a384f1f2ae9d947f9", "filename": "libgo/go/net/sockopt_bsd.go", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -20,31 +20,20 @@ func setDefaultSockopts(s, f, t int) error {\n \t\t// Note that some operating systems never admit this option.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n-\n-\tif f == syscall.AF_UNIX ||\n-\t\t(f == syscall.AF_INET || f == syscall.AF_INET6) && t == syscall.SOCK_STREAM {\n-\t\t// Allow reuse of recently-used addresses.\n-\t\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n-\t\tif err != nil {\n-\t\t\treturn os.NewSyscallError(\"setsockopt\", err)\n-\t\t}\n-\n-\t\t// Allow reuse of recently-used ports.\n-\t\t// This option is supported only in descendants of 4.4BSD,\n-\t\t// to make an effective multicast application and an application\n-\t\t// that requires quick draw possible.\n-\t\terr = syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n-\t\tif err != nil {\n-\t\t\treturn os.NewSyscallError(\"setsockopt\", err)\n-\t\t}\n-\t}\n-\n \t// Allow broadcast.\n \terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n \tif err != nil {\n \t\treturn os.NewSyscallError(\"setsockopt\", err)\n \t}\n+\treturn nil\n+}\n \n+func setDefaultListenerSockopts(s int) error {\n+\t// Allow reuse of recently-used addresses.\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n \treturn nil\n }\n \n@@ -55,6 +44,10 @@ func setDefaultMulticastSockopts(s int) error {\n \tif err != nil {\n \t\treturn os.NewSyscallError(\"setsockopt\", err)\n \t}\n+\t// Allow reuse of recently-used ports.\n+\t// This option is supported only in descendants of 4.4BSD,\n+\t// to make an effective multicast application that requires\n+\t// quick draw possible.\n \terr = syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n \tif err != nil {\n \t\treturn os.NewSyscallError(\"setsockopt\", err)"}, {"sha": "7509c29eecf231233afd533e55e180bcb7afd5fa", "filename": "libgo/go/net/sockopt_linux.go", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_linux.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -18,23 +18,20 @@ func setDefaultSockopts(s, f, t int) error {\n \t\t// Note that some operating systems never admit this option.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n-\n-\tif f == syscall.AF_UNIX ||\n-\t\t(f == syscall.AF_INET || f == syscall.AF_INET6) && t == syscall.SOCK_STREAM {\n-\t\t// Allow reuse of recently-used addresses.\n-\t\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n-\t\tif err != nil {\n-\t\t\treturn os.NewSyscallError(\"setsockopt\", err)\n-\t\t}\n-\n-\t}\n-\n \t// Allow broadcast.\n \terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n \tif err != nil {\n \t\treturn os.NewSyscallError(\"setsockopt\", err)\n \t}\n+\treturn nil\n+}\n \n+func setDefaultListenerSockopts(s int) error {\n+\t// Allow reuse of recently-used addresses.\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n \treturn nil\n }\n "}, {"sha": "b18af67d754f92f78b8fd6df466baf37f7f5ddef", "filename": "libgo/go/net/sockopt_windows.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -18,16 +18,18 @@ func setDefaultSockopts(s syscall.Handle, f, t int) error {\n \t\t// Note that some operating systems never admit this option.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n+\t// Allow broadcast.\n+\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\treturn nil\n+}\n \n+func setDefaultListenerSockopts(s syscall.Handle) error {\n \t// Windows will reuse recently-used addresses by default.\n \t// SO_REUSEADDR should not be used here, as it allows\n \t// a socket to forcibly bind to a port in use by another socket.\n \t// This could lead to a non-deterministic behavior, where\n \t// connection requests over the port cannot be guaranteed\n \t// to be handled by the correct socket.\n-\n-\t// Allow broadcast.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n \treturn nil\n }\n "}, {"sha": "1fcad4018cc7df378b66886538a895675446f5cb", "filename": "libgo/go/net/sockoptip.go", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -14,17 +14,21 @@ import (\n )\n \n func ipv4TOS(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TOS)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn v, nil\n }\n \n func setIPv4TOS(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TOS, v)\n \tif err != nil {\n@@ -34,17 +38,21 @@ func setIPv4TOS(fd *netFD, v int) error {\n }\n \n func ipv4TTL(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TTL)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn v, nil\n }\n \n func setIPv4TTL(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TTL, v)\n \tif err != nil {\n@@ -58,7 +66,9 @@ func joinIPv4Group(fd *netFD, ifi *Interface, ip IP) error {\n \tif err := setIPv4MreqToInterface(mreq, ifi); err != nil {\n \t\treturn err\n \t}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPMreq(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_ADD_MEMBERSHIP, mreq))\n }\n@@ -68,23 +78,29 @@ func leaveIPv4Group(fd *netFD, ifi *Interface, ip IP) error {\n \tif err := setIPv4MreqToInterface(mreq, ifi); err != nil {\n \t\treturn err\n \t}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPMreq(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_DROP_MEMBERSHIP, mreq))\n }\n \n func ipv6HopLimit(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn v, nil\n }\n \n func setIPv6HopLimit(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS, v)\n \tif err != nil {\n@@ -94,7 +110,9 @@ func setIPv6HopLimit(fd *netFD, v int) error {\n }\n \n func ipv6MulticastInterface(fd *netFD) (*Interface, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_IF)\n \tif err != nil {\n@@ -115,7 +133,9 @@ func setIPv6MulticastInterface(fd *netFD, ifi *Interface) error {\n \tif ifi != nil {\n \t\tv = ifi.Index\n \t}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_IF, v)\n \tif err != nil {\n@@ -125,17 +145,21 @@ func setIPv6MulticastInterface(fd *netFD, ifi *Interface) error {\n }\n \n func ipv6MulticastHopLimit(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_HOPS)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn v, nil\n }\n \n func setIPv6MulticastHopLimit(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_HOPS, v)\n \tif err != nil {\n@@ -145,7 +169,9 @@ func setIPv6MulticastHopLimit(fd *netFD, v int) error {\n }\n \n func ipv6MulticastLoopback(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_LOOP)\n \tif err != nil {\n@@ -155,7 +181,9 @@ func ipv6MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv6MulticastLoopback(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_LOOP, boolint(v))\n \tif err != nil {\n@@ -170,7 +198,9 @@ func joinIPv6Group(fd *netFD, ifi *Interface, ip IP) error {\n \tif ifi != nil {\n \t\tmreq.Interface = uint32(ifi.Index)\n \t}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPv6Mreq(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_JOIN_GROUP, mreq))\n }\n@@ -181,7 +211,9 @@ func leaveIPv6Group(fd *netFD, ifi *Interface, ip IP) error {\n \tif ifi != nil {\n \t\tmreq.Interface = uint32(ifi.Index)\n \t}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPv6Mreq(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_LEAVE_GROUP, mreq))\n }"}, {"sha": "19e2b142e92a5760f97a04fe778aa0a466ece599", "filename": "libgo/go/net/sockoptip_bsd.go", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_bsd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -14,17 +14,21 @@ import (\n )\n \n func ipv4MulticastTTL(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn int(v), nil\n }\n \n func setIPv4MulticastTTL(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL, byte(v))\n \tif err != nil {\n@@ -34,17 +38,21 @@ func setIPv4MulticastTTL(fd *netFD, v int) error {\n }\n \n func ipv6TrafficClass(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn v, nil\n }\n \n func setIPv6TrafficClass(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, v)\n \tif err != nil {"}, {"sha": "52b237c4b8db8ba77984d7fd64c845501bad815e", "filename": "libgo/go/net/sockoptip_darwin.go", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_darwin.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,7 +12,9 @@ import (\n )\n \n func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n+\t}\n \tdefer fd.decref()\n \ta, err := syscall.GetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n \tif err != nil {\n@@ -28,7 +30,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n \t}\n \tvar x [4]byte\n \tcopy(x[:], ip.To4())\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr = syscall.SetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, x)\n \tif err != nil {\n@@ -38,7 +42,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n }\n \n func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n \tif err != nil {\n@@ -48,7 +54,9 @@ func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n \tif err != nil {\n@@ -58,7 +66,9 @@ func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n }\n \n func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF)\n \tif err != nil {\n@@ -68,7 +78,9 @@ func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n }\n \n func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF, boolint(v))\n \tif err != nil {"}, {"sha": "4a3bc2e82c8b200959a408e1aa49e3cf6eea4b7c", "filename": "libgo/go/net/sockoptip_freebsd.go", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_freebsd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,7 +12,9 @@ import (\n )\n \n func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n+\t}\n \tdefer fd.decref()\n \tmreq, err := syscall.GetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n \tif err != nil {\n@@ -30,7 +32,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n \t\tv = int32(ifi.Index)\n \t}\n \tmreq := &syscall.IPMreqn{Ifindex: v}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, mreq)\n \tif err != nil {\n@@ -40,7 +44,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n }\n \n func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n \tif err != nil {\n@@ -50,7 +56,9 @@ func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n \tif err != nil {\n@@ -60,7 +68,9 @@ func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n }\n \n func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF)\n \tif err != nil {\n@@ -70,7 +80,9 @@ func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n }\n \n func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF, boolint(v))\n \tif err != nil {"}, {"sha": "169718f14aa9d0070130899ea02a9ebf0d183903", "filename": "libgo/go/net/sockoptip_linux.go", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_linux.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,7 +12,9 @@ import (\n )\n \n func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n+\t}\n \tdefer fd.decref()\n \tmreq, err := syscall.GetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n \tif err != nil {\n@@ -30,7 +32,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n \t\tv = int32(ifi.Index)\n \t}\n \tmreq := &syscall.IPMreqn{Ifindex: v}\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, mreq)\n \tif err != nil {\n@@ -40,7 +44,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n }\n \n func ipv4MulticastTTL(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL)\n \tif err != nil {\n@@ -50,7 +56,9 @@ func ipv4MulticastTTL(fd *netFD) (int, error) {\n }\n \n func setIPv4MulticastTTL(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL, v)\n \tif err != nil {\n@@ -60,7 +68,9 @@ func setIPv4MulticastTTL(fd *netFD, v int) error {\n }\n \n func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n \tif err != nil {\n@@ -70,7 +80,9 @@ func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n \tif err != nil {\n@@ -80,7 +92,9 @@ func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n }\n \n func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_PKTINFO)\n \tif err != nil {\n@@ -90,7 +104,9 @@ func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n }\n \n func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_PKTINFO, boolint(v))\n \tif err != nil {\n@@ -100,17 +116,21 @@ func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n }\n \n func ipv6TrafficClass(fd *netFD) (int, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn 0, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS)\n \tif err != nil {\n-\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t\treturn 0, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \treturn v, nil\n }\n \n func setIPv6TrafficClass(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, v)\n \tif err != nil {"}, {"sha": "f3e42f1a9bcf3f2913882033e1f7c8aba77ca9ac", "filename": "libgo/go/net/sockoptip_openbsd.go", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_openbsd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,7 +12,9 @@ import (\n )\n \n func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn nil, err\n+\t}\n \tdefer fd.decref()\n \ta, err := syscall.GetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n \tif err != nil {\n@@ -28,7 +30,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n \t}\n \tvar x [4]byte\n \tcopy(x[:], ip.To4())\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr = syscall.SetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, x)\n \tif err != nil {\n@@ -38,7 +42,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n }\n \n func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n \tif err != nil {\n@@ -48,7 +54,9 @@ func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, byte(boolint(v)))\n \tif err != nil {\n@@ -58,7 +66,9 @@ func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n }\n \n func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn false, err\n+\t}\n \tdefer fd.decref()\n \tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF)\n \tif err != nil {\n@@ -68,7 +78,9 @@ func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n }\n \n func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF, boolint(v))\n \tif err != nil {"}, {"sha": "b9db3334d5ff47b059b93a01bcc19e74a9530350", "filename": "libgo/go/net/sockoptip_windows.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -23,7 +23,9 @@ func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n \t}\n \tvar x [4]byte\n \tcopy(x[:], ip.To4())\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr = syscall.SetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, x)\n \tif err != nil {\n@@ -38,7 +40,9 @@ func ipv4MulticastTTL(fd *netFD) (int, error) {\n }\n \n func setIPv4MulticastTTL(fd *netFD, v int) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL, v)\n \tif err != nil {\n@@ -54,7 +58,9 @@ func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n-\tfd.incref()\n+\tif err := fd.incref(false); err != nil {\n+\t\treturn err\n+\t}\n \tdefer fd.decref()\n \terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n \tif err != nil {"}, {"sha": "200ce91566c7b456e780167a89dee583f0c49fdd", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -227,13 +227,43 @@ func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {\n \tif raddr == nil {\n \t\treturn nil, &OpError{\"dial\", net, nil, errMissingAddress}\n \t}\n+\n \tfd, err := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_STREAM, 0, \"dial\", sockaddrToTCP)\n+\n+\t// TCP has a rarely used mechanism called a 'simultaneous connection' in\n+\t// which Dial(\"tcp\", addr1, addr2) run on the machine at addr1 can\n+\t// connect to a simultaneous Dial(\"tcp\", addr2, addr1) run on the machine\n+\t// at addr2, without either machine executing Listen.  If laddr == nil,\n+\t// it means we want the kernel to pick an appropriate originating local\n+\t// address.  Some Linux kernels cycle blindly through a fixed range of\n+\t// local ports, regardless of destination port.  If a kernel happens to\n+\t// pick local port 50001 as the source for a Dial(\"tcp\", \"\", \"localhost:50001\"),\n+\t// then the Dial will succeed, having simultaneously connected to itself.\n+\t// This can only happen when we are letting the kernel pick a port (laddr == nil)\n+\t// and when there is no listener for the destination address.\n+\t// It's hard to argue this is anything other than a kernel bug.  If we\n+\t// see this happen, rather than expose the buggy effect to users, we\n+\t// close the fd and try again.  If it happens twice more, we relent and\n+\t// use the result.  See also:\n+\t//\thttp://golang.org/issue/2690\n+\t//\thttp://stackoverflow.com/questions/4949858/\n+\tfor i := 0; i < 2 && err == nil && laddr == nil && selfConnect(fd); i++ {\n+\t\tfd.Close()\n+\t\tfd, err = internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_STREAM, 0, \"dial\", sockaddrToTCP)\n+\t}\n+\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn newTCPConn(fd), nil\n }\n \n+func selfConnect(fd *netFD) bool {\n+\tl := fd.laddr.(*TCPAddr)\n+\tr := fd.raddr.(*TCPAddr)\n+\treturn l.Port == r.Port && l.IP.Equal(r.IP)\n+}\n+\n // TCPListener is a TCP network listener.\n // Clients should typically use variables of type Listener\n // instead of assuming TCP."}, {"sha": "59350510ccfc1254e4047349cf040b1b42caf8d0", "filename": "libgo/go/os/env.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -29,10 +29,10 @@ func Expand(s string, mapping func(string) string) string {\n \treturn string(buf) + s[i:]\n }\n \n-// ShellExpand replaces ${var} or $var in the string according to the values\n-// of the operating system's environment variables.  References to undefined\n+// ExpandEnv replaces ${var} or $var in the string according to the values\n+// of the current environment variables.  References to undefined\n // variables are replaced by the empty string.\n-func ShellExpand(s string) string {\n+func ExpandEnv(s string) string {\n \treturn Expand(s, Getenv)\n }\n \n@@ -115,7 +115,7 @@ func Clearenv() {\n \tsyscall.Clearenv()\n }\n \n-// Environ returns an array of strings representing the environment,\n+// Environ returns a copy of strings representing the environment,\n // in the form \"key=value\".\n func Environ() []string {\n \treturn syscall.Environ()"}, {"sha": "135cdae1f9b74e506bb39f140ead4eddd43ded85", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,3 +12,21 @@ type PathError struct {\n }\n \n func (e *PathError) Error() string { return e.Op + \" \" + e.Path + \": \" + e.Err.Error() }\n+\n+// SyscallError records an error from a specific system call.\n+type SyscallError struct {\n+\tSyscall string\n+\tErr     error\n+}\n+\n+func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Err.Error() }\n+\n+// NewSyscallError returns, as an error, a new SyscallError\n+// with the given system call name and error details.\n+// As a convenience, if err is nil, NewSyscallError returns nil.\n+func NewSyscallError(syscall string, err error) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\treturn &SyscallError{syscall, err}\n+}"}, {"sha": "cc847e0774324939756425bb5361d2a9529a7114", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,24 +9,6 @@ import (\n \t\"syscall\"\n )\n \n-// SyscallError records an error from a specific system call.\n-type SyscallError struct {\n-\tSyscall string\n-\tErr     string\n-}\n-\n-func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Err }\n-\n-// NewSyscallError returns, as an error, a new SyscallError\n-// with the given system call name and error details.\n-// As a convenience, if err is nil, NewSyscallError returns nil.\n-func NewSyscallError(syscall string, err error) error {\n-\tif err == nil {\n-\t\treturn nil\n-\t}\n-\treturn &SyscallError{syscall, err.Error()}\n-}\n-\n var (\n \tEshortstat = errors.New(\"stat buffer too small\")\n \tEbadstat   = errors.New(\"malformed stat buffer\")"}, {"sha": "57c9b6f27862c374a7fa91ceee3bb5a5aafe8108", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,7 +6,7 @@\n \n package os\n \n-import syscall \"syscall\"\n+import \"syscall\"\n \n // Commonly known Unix errors.\n var (\n@@ -15,7 +15,6 @@ var (\n \tESRCH        error = syscall.ESRCH\n \tEINTR        error = syscall.EINTR\n \tEIO          error = syscall.EIO\n-\tENXIO        error = syscall.ENXIO\n \tE2BIG        error = syscall.E2BIG\n \tENOEXEC      error = syscall.ENOEXEC\n \tEBADF        error = syscall.EBADF\n@@ -50,21 +49,3 @@ var (\n \tETIMEDOUT    error = syscall.ETIMEDOUT\n \tENOTCONN     error = syscall.ENOTCONN\n )\n-\n-// SyscallError records an error from a specific system call.\n-type SyscallError struct {\n-\tSyscall string\n-\tErrno   error\n-}\n-\n-func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Errno.Error() }\n-\n-// NewSyscallError returns, as an error, a new SyscallError\n-// with the given system call name and error details.\n-// As a convenience, if err is nil, NewSyscallError returns nil.\n-func NewSyscallError(syscall string, err error) error {\n-\tif err == nil {\n-\t\treturn nil\n-\t}\n-\treturn &SyscallError{syscall, err}\n-}"}, {"sha": "37a0051c5dca5ae579bd4b5499e1c5bf1c408784", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -46,11 +46,22 @@ type ProcAttr struct {\n \tSys *syscall.SysProcAttr\n }\n \n-// A Signal can represent any operating system signal.\n+// A Signal represents an operating system signal.\n+// The usual underlying implementation is operating system-dependent:\n+// on Unix it is syscall.Signal.\n type Signal interface {\n \tString() string\n+\tSignal() // to distinguish from other Stringers\n }\n \n+// The only signal values guaranteed to be present on all systems\n+// are Interrupt (send the process an interrupt) and\n+// Kill (force the process to exit).\n+var (\n+\tInterrupt Signal = syscall.SIGINT\n+\tKill      Signal = syscall.SIGKILL\n+)\n+\n // Getpid returns the process id of the caller.\n func Getpid() int { return syscall.Getpid() }\n "}, {"sha": "fe254672169c66e890e20979009f11a724733e83", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -68,7 +68,7 @@ type Cmd struct {\n \t// new process. It does not include standard input, standard output, or\n \t// standard error. If non-nil, entry i becomes file descriptor 3+i.\n \t//\n-\t// BUG: on OS X 10.6, child processes may sometimes inherit extra fds.\n+\t// BUG: on OS X 10.6, child processes may sometimes inherit unwanted fds.\n \t// http://golang.org/issue/2603\n \tExtraFiles []*os.File\n \n@@ -79,6 +79,10 @@ type Cmd struct {\n \t// Process is the underlying process, once started.\n \tProcess *os.Process\n \n+\t// Waitmsg contains information about an exited process,\n+\t// available after a call to Wait or Run.\n+\tWaitmsg *os.Waitmsg\n+\n \terr             error // last error (from LookPath, stdin, stdout, stderr)\n \tfinished        bool  // when Wait was called\n \tchildFiles      []*os.File\n@@ -288,6 +292,7 @@ func (c *Cmd) Wait() error {\n \t}\n \tc.finished = true\n \tmsg, err := c.Process.Wait(0)\n+\tc.Waitmsg = msg\n \n \tvar copyError error\n \tfor _ = range c.goroutine {"}, {"sha": "52f4bce3aea3f495e22d38ea997d983187489613", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,7 +17,6 @@ import (\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n-\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -154,7 +153,7 @@ func TestExtraFiles(t *testing.T) {\n \t// Ensure that file descriptors have not already been leaked into\n \t// our environment.\n \tfor fd := os.Stderr.Fd() + 1; fd <= 101; fd++ {\n-\t\terr := syscall.Close(fd)\n+\t\terr := os.NewFile(fd, \"\").Close()\n \t\tif err == nil {\n \t\t\tt.Logf(\"Something already leaked - closed fd %d\", fd)\n \t\t}"}, {"sha": "08f16b86d54e8939a6b6ba2f4d50a0b4d66bb833", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,6 +12,7 @@ import (\n \n // StartProcess starts a new process with the program, arguments and attributes\n // specified by name, argv and attr.\n+// If there is an error, it will be of type *PathError.\n func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n \tsysattr := &syscall.ProcAttr{\n \t\tDir: attr.Dir,\n@@ -71,19 +72,6 @@ func (p *Process) Kill() error {\n \treturn e\n }\n \n-// Exec replaces the current process with an execution of the\n-// named binary, with arguments argv and environment envv.\n-// If successful, Exec never returns.  If it fails, it returns an error.\n-// ForkExec is almost always a better way to execute a program.\n-func Exec(name string, argv []string, envv []string) error {\n-\te := syscall.Exec(name, argv, envv)\n-\tif e != nil {\n-\t\treturn &PathError{\"exec\", name, e}\n-\t}\n-\n-\treturn nil\n-}\n-\n // Waitmsg stores the information about an exited process as reported by Wait.\n type Waitmsg struct {\n \tsyscall.Waitmsg"}, {"sha": "33a689eb045ba8f73b7855a951819bc9b63bc34c", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,25 +7,16 @@\n package os\n \n import (\n-\t\"runtime\"\n \t\"syscall\"\n )\n \n-type UnixSignal int32\n-\n-func (sig UnixSignal) String() string {\n-\ts := runtime.Signame(int32(sig))\n-\tif len(s) > 0 {\n-\t\treturn s\n-\t}\n-\treturn \"UnixSignal\"\n-}\n-\n // StartProcess starts a new process with the program, arguments and attributes\n // specified by name, argv and attr.\n //\n // StartProcess is a low-level interface. The os/exec package provides\n // higher-level interfaces.\n+//\n+// If there is an error, it will be of type *PathError.\n func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n \tsysattr := &syscall.ProcAttr{\n \t\tDir: attr.Dir,\n@@ -48,24 +39,7 @@ func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \n // Kill causes the Process to exit immediately.\n func (p *Process) Kill() error {\n-\treturn p.Signal(UnixSignal(syscall.SIGKILL))\n-}\n-\n-// Exec replaces the current process with an execution of the\n-// named binary, with arguments argv and environment envv.\n-// If successful, Exec never returns.  If it fails, it returns an error.\n-//\n-// To run a child process, see StartProcess (for a low-level interface)\n-// or the os/exec package (for higher-level interfaces).\n-func Exec(name string, argv []string, envv []string) error {\n-\tif envv == nil {\n-\t\tenvv = Environ()\n-\t}\n-\te := syscall.Exec(name, argv, envv)\n-\tif e != nil {\n-\t\treturn &PathError{\"exec\", name, e}\n-\t}\n-\treturn nil\n+\treturn p.Signal(Kill)\n }\n \n // TODO(rsc): Should os implement its own syscall.WaitStatus\n@@ -133,9 +107,9 @@ func (w *Waitmsg) String() string {\n \tcase w.Exited():\n \t\tres = \"exit status \" + itod(w.ExitStatus())\n \tcase w.Signaled():\n-\t\tres = \"signal \" + itod(w.Signal())\n+\t\tres = \"signal \" + itod(int(w.Signal()))\n \tcase w.Stopped():\n-\t\tres = \"stop signal \" + itod(w.StopSignal())\n+\t\tres = \"stop signal \" + itod(int(w.StopSignal()))\n \t\tif w.StopSignal() == syscall.SIGTRAP && w.TrapCause() != 0 {\n \t\t\tres += \" (trap \" + itod(w.TrapCause()) + \")\"\n \t\t}"}, {"sha": "7fe7c2fe8cdeac3d5c5514bb2bdaab2cd6ed83b6", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -57,7 +57,11 @@ func (p *Process) Signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n-\tif e := syscall.Kill(p.Pid, int(sig.(UnixSignal))); e != nil {\n+\ts, ok := sig.(syscall.Signal)\n+\tif !ok {\n+\t\treturn errors.New(\"os: unsupported signal type\")\n+\t}\n+\tif e := syscall.Kill(p.Pid, s); e != nil {\n \t\treturn e\n \t}\n \treturn nil"}, {"sha": "f357a3034b1f335e2b615906a2f7d13bdf9fa686", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -37,10 +37,11 @@ func (p *Process) Signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n-\tif us, ok := sig.(UnixSignal); ok && us == syscall.SIGKILL {\n+\tif sig == Kill {\n \t\te := syscall.TerminateProcess(syscall.Handle(p.handle), 1)\n \t\treturn NewSyscallError(\"TerminateProcess\", e)\n \t}\n+\t// TODO(rsc): Handle Interrupt too?\n \treturn syscall.Errno(syscall.EWINDOWS)\n }\n "}, {"sha": "85f151e2840d8a1567d5ef989730a222458f6ed6", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -3,7 +3,13 @@\n // license that can be found in the LICENSE file.\n \n // Package os provides a platform-independent interface to operating system\n-// functionality.  The design is Unix-like.\n+// functionality. The design is Unix-like, although the error handling is\n+// Go-like; failing calls return values of type error rather than error numbers.\n+// Often, more information is available within the error. For example,\n+// if a call that takes a file name fails, such as Open or Stat, the error\n+// will include failing file name when printed and will be of type *PathError,\n+// which may be unpacked for more information.\n+// \n // The os interface is intended to be uniform across all operating systems.\n // Features not generally available appear in the system-specific package syscall.\n package os\n@@ -19,26 +25,22 @@ func (f *File) Name() string { return f.name }\n // Stdin, Stdout, and Stderr are open Files pointing to the standard input,\n // standard output, and standard error file descriptors.\n var (\n-\tStdin  = NewFile(syscall.Stdin, \"/dev/stdin\")\n-\tStdout = NewFile(syscall.Stdout, \"/dev/stdout\")\n-\tStderr = NewFile(syscall.Stderr, \"/dev/stderr\")\n+\tStdin  = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\")\n+\tStdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\")\n+\tStderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\")\n )\n \n // Flags to Open wrapping those of the underlying system. Not all flags\n // may be implemented on a given system.\n const (\n-\tO_RDONLY   int = syscall.O_RDONLY   // open the file read-only.\n-\tO_WRONLY   int = syscall.O_WRONLY   // open the file write-only.\n-\tO_RDWR     int = syscall.O_RDWR     // open the file read-write.\n-\tO_APPEND   int = syscall.O_APPEND   // append data to the file when writing.\n-\tO_ASYNC    int = syscall.O_ASYNC    // generate a signal when I/O is available.\n-\tO_CREATE   int = syscall.O_CREAT    // create a new file if none exists.\n-\tO_EXCL     int = syscall.O_EXCL     // used with O_CREATE, file must not exist\n-\tO_NOCTTY   int = syscall.O_NOCTTY   // do not make file the controlling tty.\n-\tO_NONBLOCK int = syscall.O_NONBLOCK // open in non-blocking mode.\n-\tO_NDELAY   int = O_NONBLOCK         // synonym for O_NONBLOCK\n-\tO_SYNC     int = syscall.O_SYNC     // open for synchronous I/O.\n-\tO_TRUNC    int = syscall.O_TRUNC    // if possible, truncate file when opened.\n+\tO_RDONLY int = syscall.O_RDONLY // open the file read-only.\n+\tO_WRONLY int = syscall.O_WRONLY // open the file write-only.\n+\tO_RDWR   int = syscall.O_RDWR   // open the file read-write.\n+\tO_APPEND int = syscall.O_APPEND // append data to the file when writing.\n+\tO_CREATE int = syscall.O_CREAT  // create a new file if none exists.\n+\tO_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist\n+\tO_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.\n+\tO_TRUNC  int = syscall.O_TRUNC  // if possible, truncate file when opened.\n )\n \n // Seek whence values.\n@@ -157,7 +159,7 @@ func (f *File) WriteString(s string) (ret int, err error) {\n }\n \n // Mkdir creates a new directory with the specified name and permission bits.\n-// It returns an error, if any.\n+// If there is an error, it will be of type *PathError.\n func Mkdir(name string, perm FileMode) error {\n \te := syscall.Mkdir(name, syscallMode(perm))\n \tif e != nil {\n@@ -167,6 +169,7 @@ func Mkdir(name string, perm FileMode) error {\n }\n \n // Chdir changes the current working directory to the named directory.\n+// If there is an error, it will be of type *PathError.\n func Chdir(dir string) error {\n \tif e := syscall.Chdir(dir); e != nil {\n \t\treturn &PathError{\"chdir\", dir, e}\n@@ -176,6 +179,7 @@ func Chdir(dir string) error {\n \n // Chdir changes the current working directory to the file,\n // which must be a directory.\n+// If there is an error, it will be of type *PathError.\n func (f *File) Chdir() error {\n \tif e := syscall.Fchdir(f.fd); e != nil {\n \t\treturn &PathError{\"chdir\", f.name, e}\n@@ -186,7 +190,7 @@ func (f *File) Chdir() error {\n // Open opens the named file for reading.  If successful, methods on\n // the returned file can be used for reading; the associated file\n // descriptor has mode O_RDONLY.\n-// It returns the File and an error, if any.\n+// If there is an error, it will be of type *PathError.\n func Open(name string) (file *File, err error) {\n \treturn OpenFile(name, O_RDONLY, 0)\n }\n@@ -195,7 +199,7 @@ func Open(name string) (file *File, err error) {\n // it if it already exists.  If successful, methods on the returned\n // File can be used for I/O; the associated file descriptor has mode\n // O_RDWR.\n-// It returns the File and an error, if any.\n+// If there is an error, it will be of type *PathError.\n func Create(name string) (file *File, err error) {\n \treturn OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n }"}, {"sha": "fed2b809175d7a628ba1bf98c8ae7e1768eacf5b", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -76,7 +76,7 @@ func syscallMode(i FileMode) (o uint32) {\n // or Create instead.  It opens the named file with specified flag\n // (O_RDONLY etc.) and perm, (0666 etc.) if applicable.  If successful,\n // methods on the returned File can be used for I/O.\n-// It returns the File and an error, if any.\n+// If there is an error, it will be of type *PathError.\n func OpenFile(name string, flag int, perm FileMode) (file *File, err error) {\n \tvar (\n \t\tfd     int\n@@ -181,6 +181,7 @@ func (f *File) Truncate(size int64) error {\n const chmodMask = uint32(syscall.DMAPPEND | syscall.DMEXCL | syscall.DMTMP | ModePerm)\n \n // Chmod changes the mode of the file to mode.\n+// If there is an error, it will be of type *PathError.\n func (f *File) Chmod(mode FileMode) error {\n \tvar d Dir\n \n@@ -248,6 +249,7 @@ func (f *File) seek(offset int64, whence int) (ret int64, err error) {\n \n // Truncate changes the size of the named file.\n // If the file is a symbolic link, it changes the size of the link's target.\n+// If there is an error, it will be of type *PathError.\n func Truncate(name string, size int64) error {\n \tvar d Dir\n \td.Null()\n@@ -261,6 +263,7 @@ func Truncate(name string, size int64) error {\n }\n \n // Remove removes the named file or directory.\n+// If there is an error, it will be of type *PathError.\n func Remove(name string) error {\n \tif e := syscall.Remove(name); e != nil {\n \t\treturn &PathError{\"remove\", name, e}\n@@ -269,6 +272,7 @@ func Remove(name string) error {\n }\n \n // Rename renames a file.\n+// If there is an error, it will be of type *PathError.\n func Rename(oldname, newname string) error {\n \tvar d Dir\n \td.Null()\n@@ -282,6 +286,7 @@ func Rename(oldname, newname string) error {\n }\n \n // Chmod changes the mode of the named file to mode.\n+// If there is an error, it will be of type *PathError.\n func Chmod(name string, mode FileMode) error {\n \tvar d Dir\n "}, {"sha": "8d3a00b6c5a9c5362dc3c0956aca5a5f338dccc5", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -37,7 +37,7 @@ func (e *LinkError) Error() string {\n \treturn e.Op + \" \" + e.Old + \" \" + e.New + \": \" + e.Err.Error()\n }\n \n-// Link creates a hard link.\n+// Link creates newname as a hard link to the oldname file.\n func Link(oldname, newname string) error {\n \te := syscall.Link(oldname, newname)\n \tif e != nil {\n@@ -46,7 +46,7 @@ func Link(oldname, newname string) error {\n \treturn nil\n }\n \n-// Symlink creates a symbolic link.\n+// Symlink creates newname as a symbolic link to oldname.\n func Symlink(oldname, newname string) error {\n \te := syscall.Symlink(oldname, newname)\n \tif e != nil {\n@@ -55,8 +55,8 @@ func Symlink(oldname, newname string) error {\n \treturn nil\n }\n \n-// Readlink reads the contents of a symbolic link: the destination of\n-// the link.  It returns the contents and an error, if any.\n+// Readlink returns the destination of the named symbolic link.\n+// If there is an error, it will be of type *PathError.\n func Readlink(name string) (string, error) {\n \tfor len := 128; ; len *= 2 {\n \t\tb := make([]byte, len)\n@@ -99,6 +99,7 @@ func syscallMode(i FileMode) (o uint32) {\n \n // Chmod changes the mode of the named file to mode.\n // If the file is a symbolic link, it changes the mode of the link's target.\n+// If there is an error, it will be of type *PathError.\n func Chmod(name string, mode FileMode) error {\n \tif e := syscall.Chmod(name, syscallMode(mode)); e != nil {\n \t\treturn &PathError{\"chmod\", name, e}\n@@ -107,6 +108,7 @@ func Chmod(name string, mode FileMode) error {\n }\n \n // Chmod changes the mode of the file to mode.\n+// If there is an error, it will be of type *PathError.\n func (f *File) Chmod(mode FileMode) error {\n \tif e := syscall.Fchmod(f.fd, syscallMode(mode)); e != nil {\n \t\treturn &PathError{\"chmod\", f.name, e}\n@@ -116,6 +118,7 @@ func (f *File) Chmod(mode FileMode) error {\n \n // Chown changes the numeric uid and gid of the named file.\n // If the file is a symbolic link, it changes the uid and gid of the link's target.\n+// If there is an error, it will be of type *PathError.\n func Chown(name string, uid, gid int) error {\n \tif e := syscall.Chown(name, uid, gid); e != nil {\n \t\treturn &PathError{\"chown\", name, e}\n@@ -125,6 +128,7 @@ func Chown(name string, uid, gid int) error {\n \n // Lchown changes the numeric uid and gid of the named file.\n // If the file is a symbolic link, it changes the uid and gid of the link itself.\n+// If there is an error, it will be of type *PathError.\n func Lchown(name string, uid, gid int) error {\n \tif e := syscall.Lchown(name, uid, gid); e != nil {\n \t\treturn &PathError{\"lchown\", name, e}\n@@ -133,6 +137,7 @@ func Lchown(name string, uid, gid int) error {\n }\n \n // Chown changes the numeric uid and gid of the named file.\n+// If there is an error, it will be of type *PathError.\n func (f *File) Chown(uid, gid int) error {\n \tif e := syscall.Fchown(f.fd, uid, gid); e != nil {\n \t\treturn &PathError{\"chown\", f.name, e}\n@@ -142,6 +147,7 @@ func (f *File) Chown(uid, gid int) error {\n \n // Truncate changes the size of the file.\n // It does not change the I/O offset.\n+// If there is an error, it will be of type *PathError.\n func (f *File) Truncate(size int64) error {\n \tif e := syscall.Ftruncate(f.fd, size); e != nil {\n \t\treturn &PathError{\"truncate\", f.name, e}\n@@ -167,6 +173,7 @@ func (f *File) Sync() (err error) {\n //\n // The underlying filesystem may truncate or round the values to a\n // less precise time unit.\n+// If there is an error, it will be of type *PathError.\n func Chtimes(name string, atime time.Time, mtime time.Time) error {\n \tvar utimes [2]syscall.Timeval\n \tatime_ns := atime.Unix()*1e9 + int64(atime.Nanosecond())"}, {"sha": "3d659efe061a61d9dfa22b0198f54473c71fa5e4", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -28,19 +28,20 @@ type file struct {\n }\n \n // Fd returns the integer Unix file descriptor referencing the open file.\n-func (f *File) Fd() int {\n+func (f *File) Fd() uintptr {\n \tif f == nil {\n-\t\treturn -1\n+\t\treturn ^(uintptr(0))\n \t}\n-\treturn f.fd\n+\treturn uintptr(f.fd)\n }\n \n // NewFile returns a new File with the given file descriptor and name.\n-func NewFile(fd int, name string) *File {\n-\tif fd < 0 {\n+func NewFile(fd uintptr, name string) *File {\n+\tfdi := int(fd)\n+\tif fdi < 0 {\n \t\treturn nil\n \t}\n-\tf := &File{&file{fd: fd, name: name}}\n+\tf := &File{&file{fd: fdi, name: name}}\n \truntime.SetFinalizer(f.file, (*file).close)\n \treturn f\n }\n@@ -59,7 +60,7 @@ const DevNull = \"/dev/null\"\n // or Create instead.  It opens the named file with specified flag\n // (O_RDONLY etc.) and perm, (0666 etc.) if applicable.  If successful,\n // methods on the returned File can be used for I/O.\n-// It returns the File and an error, if any.\n+// If there is an error, it will be of type *PathError.\n func OpenFile(name string, flag int, perm FileMode) (file *File, err error) {\n \tr, e := syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))\n \tif e != nil {\n@@ -77,7 +78,7 @@ func OpenFile(name string, flag int, perm FileMode) (file *File, err error) {\n \t\tsyscall.CloseOnExec(r)\n \t}\n \n-\treturn NewFile(r, name), nil\n+\treturn NewFile(uintptr(r), name), nil\n }\n \n // Close closes the File, rendering it unusable for I/O.\n@@ -109,7 +110,7 @@ func (file *file) close() error {\n }\n \n // Stat returns the FileInfo structure describing file.\n-// It returns the FileInfo and an error, if any.\n+// If there is an error, it will be of type *PathError.\n func (f *File) Stat() (fi FileInfo, err error) {\n \tvar stat syscall.Stat_t\n \terr = syscall.Fstat(f.fd, &stat)\n@@ -119,11 +120,8 @@ func (f *File) Stat() (fi FileInfo, err error) {\n \treturn fileInfoFromStat(&stat, f.name), nil\n }\n \n-// Stat returns a FileInfo describing the named file and an error, if any.\n-// If name names a valid symbolic link, the returned FileInfo describes\n-// the file pointed at by the link and has fi.FollowedSymlink set to true.\n-// If name names an invalid symbolic link, the returned FileInfo describes\n-// the link itself and has fi.FollowedSymlink set to false.\n+// Stat returns a FileInfo describing the named file.\n+// If there is an error, it will be of type *PathError.\n func Stat(name string) (fi FileInfo, err error) {\n \tvar stat syscall.Stat_t\n \terr = syscall.Stat(name, &stat)\n@@ -133,9 +131,10 @@ func Stat(name string) (fi FileInfo, err error) {\n \treturn fileInfoFromStat(&stat, name), nil\n }\n \n-// Lstat returns a FileInfo describing the named file and an\n-// error, if any.  If the file is a symbolic link, the returned FileInfo\n+// Lstat returns a FileInfo describing the named file.\n+// If the file is a symbolic link, the returned FileInfo\n // describes the symbolic link.  Lstat makes no attempt to follow the link.\n+// If there is an error, it will be of type *PathError.\n func Lstat(name string) (fi FileInfo, err error) {\n \tvar stat syscall.Stat_t\n \terr = syscall.Lstat(name, &stat)\n@@ -199,6 +198,7 @@ func (f *File) seek(offset int64, whence int) (ret int64, err error) {\n \n // Truncate changes the size of the named file.\n // If the file is a symbolic link, it changes the size of the link's target.\n+// If there is an error, it will be of type *PathError.\n func Truncate(name string, size int64) error {\n \tif e := syscall.Truncate(name, size); e != nil {\n \t\treturn &PathError{\"truncate\", name, e}\n@@ -207,6 +207,7 @@ func Truncate(name string, size int64) error {\n }\n \n // Remove removes the named file or directory.\n+// If there is an error, it will be of type *PathError.\n func Remove(name string) error {\n \t// System call interface forces us to know\n \t// whether name is a file or directory.\n@@ -270,7 +271,7 @@ func Pipe() (r *File, w *File, err error) {\n \tsyscall.CloseOnExec(p[1])\n \tsyscall.ForkLock.RUnlock()\n \n-\treturn NewFile(p[0], \"|0\"), NewFile(p[1], \"|1\"), nil\n+\treturn NewFile(uintptr(p[0]), \"|0\"), NewFile(uintptr(p[1]), \"|1\"), nil\n }\n \n // TempDir returns the default directory to use for temporary files."}, {"sha": "3487bc3bc3c43c54ac164bdac2649904ddf27385", "filename": "libgo/go/os/mkunixsignals.sh", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fos%2Fmkunixsignals.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fos%2Fmkunixsignals.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fmkunixsignals.sh?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,24 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2010 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-echo '// ./mkunix.sh' \"$1\"\n-echo '// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT'\n-echo\n-\n-cat <<EOH\n-package os\n-\n-import (\n-  \"syscall\"\n-)\n-\n-var _ = syscall.Open  // in case there are zero signals\n-\n-const (\n-EOH\n-\n-sed -n 's/^const[ \t]*\\(SIG[A-Z0-9][A-Z0-9]*\\)[ \t].*/  \\1 = UnixSignal(syscall.\\1)/p' \"$1\"\n-\n-echo \")\""}, {"sha": "27436dadcdaeed5beb1baeb21d280a01f463ab19", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -23,7 +23,6 @@ var dot = []string{\n \t\"error.go\",\n \t\"file.go\",\n \t\"os_test.go\",\n-\t\"time.go\",\n \t\"types.go\",\n }\n \n@@ -742,19 +741,6 @@ func TestChdirAndGetwd(t *testing.T) {\n \tfd.Close()\n }\n \n-func TestTime(t *testing.T) {\n-\t// Just want to check that Time() is getting something.\n-\t// A common failure mode on Darwin is to get 0, 0,\n-\t// because it returns the time in registers instead of\n-\t// filling in the structure passed to the system call.\n-\t// Too bad the compiler doesn't know that\n-\t// 365.24*86400 is an integer.\n-\tsec, nsec, err := Time()\n-\tif sec < (2009-1970)*36524*864 {\n-\t\tt.Errorf(\"Time() = %d, %d, %s; not plausible\", sec, nsec, err)\n-\t}\n-}\n-\n func TestSeek(t *testing.T) {\n \tf := newFile(\"TestSeek\", t)\n \tdefer Remove(f.Name())"}, {"sha": "dfdcf40617391fefbb9f9449f84da648228c796d", "filename": "libgo/go/os/signal/signal.go", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fsignal%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fsignal%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package signal implements access to incoming signals.\n+package signal\n+\n+// BUG(rsc): This package is not yet implemented on Plan 9 and Windows.\n+\n+import (\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+var handlers struct {\n+\tsync.Mutex\n+\tlist []handler\n+}\n+\n+type handler struct {\n+\tc   chan<- os.Signal\n+\tsig os.Signal\n+\tall bool\n+}\n+\n+// Notify causes package signal to relay incoming signals to c.\n+// If no signals are listed, all incoming signals will be relayed to c.\n+// Otherwise, just the listed signals will.\n+//\n+// Package signal will not block sending to c: the caller must ensure\n+// that c has sufficient buffer space to keep up with the expected\n+// signal rate.  For a channel used for notification of just one signal value,\n+// a buffer of size 1 is sufficient.\n+//\n+func Notify(c chan<- os.Signal, sig ...os.Signal) {\n+\tif c == nil {\n+\t\tpanic(\"os/signal: Notify using nil channel\")\n+\t}\n+\n+\thandlers.Lock()\n+\tdefer handlers.Unlock()\n+\tif len(sig) == 0 {\n+\t\tenableSignal(nil)\n+\t\thandlers.list = append(handlers.list, handler{c: c, all: true})\n+\t} else {\n+\t\tfor _, s := range sig {\n+\t\t\t// We use nil as a special wildcard value for enableSignal,\n+\t\t\t// so filter it out of the list of arguments.  This is safe because\n+\t\t\t// we will never get an incoming nil signal, so discarding the\n+\t\t\t// registration cannot affect the observed behavior.\n+\t\t\tif s != nil {\n+\t\t\t\tenableSignal(s)\n+\t\t\t\thandlers.list = append(handlers.list, handler{c: c, sig: s})\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func process(sig os.Signal) {\n+\thandlers.Lock()\n+\tdefer handlers.Unlock()\n+\n+\tfor _, h := range handlers.list {\n+\t\tif h.all || h.sig == sig {\n+\t\t\t// send but do not block for it\n+\t\t\tselect {\n+\t\t\tcase h.c <- sig:\n+\t\t\tdefault:\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "3494f8c34cb5d50c8875f0c6114e19155a784eca", "filename": "libgo/go/os/signal/signal_test.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd\n+\n+package signal\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+const sighup = syscall.SIGHUP\n+\n+func waitSig(t *testing.T, c <-chan os.Signal, sig os.Signal) {\n+\tselect {\n+\tcase s := <-c:\n+\t\tif s != sig {\n+\t\t\tt.Fatalf(\"signal was %v, want %v\", s, sig)\n+\t\t}\n+\tcase <-time.After(1 * time.Second):\n+\t\tt.Fatalf(\"timeout waiting for %v\", sig)\n+\t}\n+}\n+\n+func TestSignal(t *testing.T) {\n+\t// Ask for SIGHUP\n+\tc := make(chan os.Signal, 1)\n+\tNotify(c, sighup)\n+\n+\tt.Logf(\"sighup...\")\n+\t// Send this process a SIGHUP\n+\tsyscall.Kill(syscall.Getpid(), sighup)\n+\twaitSig(t, c, sighup)\n+\n+\t// Ask for everything we can get.\n+\tc1 := make(chan os.Signal, 1)\n+\tNotify(c1)\n+\n+\tt.Logf(\"sigwinch...\")\n+\t// Send this process a SIGWINCH\n+\tsyscall.Kill(syscall.Getpid(), syscall.SIGWINCH)\n+\twaitSig(t, c1, syscall.SIGWINCH)\n+\n+\t// Send two more SIGHUPs, to make sure that\n+\t// they get delivered on c1 and that not reading\n+\t// from c does not block everything.\n+\tt.Logf(\"sigwinch...\")\n+\tsyscall.Kill(syscall.Getpid(), syscall.SIGHUP)\n+\twaitSig(t, c1, syscall.SIGHUP)\n+\tt.Logf(\"sigwinch...\")\n+\tsyscall.Kill(syscall.Getpid(), syscall.SIGHUP)\n+\twaitSig(t, c1, syscall.SIGHUP)\n+\n+\t// The first SIGHUP should be waiting for us on c.\n+\twaitSig(t, c, syscall.SIGHUP)\n+}"}, {"sha": "20ee5f26aaa1f8b773be5f4a681f74436094c232", "filename": "libgo/go/os/signal/signal_unix.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_unix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd windows\n+\n+package signal\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// In assembly.\n+func signal_enable(uint32)\n+func signal_recv() uint32\n+\n+func loop() {\n+\tfor {\n+\t\tprocess(syscall.Signal(signal_recv()))\n+\t}\n+}\n+\n+func init() {\n+\tsignal_enable(0) // first call - initialize\n+\tgo loop()\n+}\n+\n+func enableSignal(sig os.Signal) {\n+\tswitch sig := sig.(type) {\n+\tcase nil:\n+\t\tsignal_enable(^uint32(0))\n+\tcase syscall.Signal:\n+\t\tsignal_enable(uint32(sig))\n+\tdefault:\n+\t\t// Can ignore: this signal (whatever it is) will never come in.\n+\t}\n+}"}, {"sha": "00622581f4f054ea1555b03145defada55af2e9b", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -82,7 +82,8 @@ func dirstat(arg interface{}) (d *Dir, err error) {\n \treturn nil, &PathError{\"stat\", name, Ebadstat}\n }\n \n-// Stat returns a FileInfo structure describing the named file and an error, if any.\n+// Stat returns a FileInfo structure describing the named file.\n+// If there is an error, it will be of type *PathError.\n func Stat(name string) (FileInfo, error) {\n \td, err := dirstat(name)\n \tif err != nil {\n@@ -91,9 +92,10 @@ func Stat(name string) (FileInfo, error) {\n \treturn fileInfoFromStat(d), nil\n }\n \n-// Lstat returns the FileInfo structure describing the named file and an\n-// error, if any.  If the file is a symbolic link (though Plan 9 does not have symbolic links), \n+// Lstat returns the FileInfo structure describing the named file.\n+// If the file is a symbolic link (though Plan 9 does not have symbolic links), \n // the returned FileInfo describes the symbolic link.  Lstat makes no attempt to follow the link.\n+// If there is an error, it will be of type *PathError.\n func Lstat(name string) (FileInfo, error) {\n \treturn Stat(name)\n }"}, {"sha": "eb564e57a6cc05baf2171bb130cd08e931e653f7", "filename": "libgo/go/os/time.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fos%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fos%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftime.go?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package os\n-\n-import \"syscall\"\n-\n-// Time returns the current time, in whole seconds and\n-// fractional nanoseconds, plus an error if any. The current\n-// time is thus 1e9*sec+nsec, in nanoseconds.  The zero of\n-// time is the Unix epoch.\n-func Time() (sec int64, nsec int64, err error) {\n-\tvar tv syscall.Timeval\n-\tif e := syscall.Gettimeofday(&tv); e != nil {\n-\t\treturn 0, 0, NewSyscallError(\"gettimeofday\", e)\n-\t}\n-\treturn int64(tv.Sec), int64(tv.Usec) * 1000, err\n-}"}, {"sha": "36ab422c930b713719d3494170e03f5ede41eff7", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -356,7 +356,7 @@ func TestWalk(t *testing.T) {\n \n \t// Test permission errors.  Only possible if we're not root\n \t// and only on some file systems (AFS, FAT).  To avoid errors during\n-\t// all.bash on those file systems, skip during gotest -short.\n+\t// all.bash on those file systems, skip during go test -short.\n \tif os.Getuid() > 0 && !testing.Short() {\n \t\t// introduce 2 errors: chmod top-level directories to 0\n \t\tos.Chmod(filepath.Join(tree.name, tree.entries[1].name), 0)"}, {"sha": "9568e41136ffdad98672f604d417ea017d9c1d90", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -16,7 +16,6 @@\n package reflect\n \n import (\n-\t\"runtime\"\n \t\"strconv\"\n \t\"sync\"\n \t\"unsafe\"\n@@ -181,7 +180,7 @@ type Type interface {\n \t// It panics if i is not in the range [0, NumOut()).\n \tOut(i int) Type\n \n-\truntimeType() *runtime.Type\n+\truntimeType() *runtimeType\n \tcommon() *commonType\n \tuncommon() *uncommonType\n }\n@@ -221,127 +220,127 @@ const (\n )\n \n /*\n- * Copy of data structures from ../runtime/type.go.\n- * For comments, see the ones in that file.\n- *\n- * These data structures are known to the compiler and the runtime.\n- *\n- * Putting these types in runtime instead of reflect means that\n- * reflect doesn't need to be autolinked into every binary, which\n- * simplifies bootstrapping and package dependencies.\n- * Unfortunately, it also means that reflect needs its own\n- * copy in order to access the private fields.\n+ * These data structures are known to the compiler (../../cmd/gc/reflect.c).\n+ * A few are known to ../runtime/type.go to convey to debuggers.\n  */\n \n+type runtimeType commonType\n+\n // commonType is the common implementation of most values.\n // It is embedded in other, public struct types, but always\n // with a unique tag like `reflect:\"array\"` or `reflect:\"ptr\"`\n // so that code cannot convert from, say, *arrayType to *ptrType.\n-\n type commonType struct {\n-\tkind       uint8\n-\talign      int8\n-\tfieldAlign uint8\n-\tsize       uintptr\n-\thash       uint32\n-\thashfn     func(unsafe.Pointer, uintptr)\n-\tequalfn    func(unsafe.Pointer, unsafe.Pointer, uintptr)\n-\tstring     *string\n-\t*uncommonType\n-\tptrToThis *runtime.Type\n+\tkind       uint8   // enumeration for C\n+\talign      int8    // alignment of variable with this type\n+\tfieldAlign uint8   // alignment of struct field with this type\n+\tsize       uintptr // size in bytes\n+\thash       uint32  // hash of type; avoids computation in hash tables\n+\n+\thashfn  func(unsafe.Pointer, uintptr)                 // hash function\n+\tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) // equality function\n+\n+\tstring        *string      // string form; unnecessary  but undeniably useful\n+\t*uncommonType              // (relatively) uncommon fields\n+\tptrToThis     *runtimeType // pointer to this type, if used in binary or has methods\n }\n \n+// Method on non-interface type\n type method struct {\n-\tname    *string\n-\tpkgPath *string\n-\tmtyp    *runtime.Type\n-\ttyp     *runtime.Type\n-\ttfn     unsafe.Pointer\n+\tname    *string        // name of method\n+\tpkgPath *string        // nil for exported Names; otherwise import path\n+\tmtyp    *runtimeType   // method type (without receiver)\n+\ttyp     *runtimeType   // .(*FuncType) underneath (with receiver)\n+\ttfn     unsafe.Pointer // fn used for normal method call\n }\n \n+// uncommonType is present only for types with names or methods\n+// (if T is a named type, the uncommonTypes for T and *T have methods).\n+// Using a pointer to this struct reduces the overall size required\n+// to describe an unnamed type with no methods.\n type uncommonType struct {\n-\tname    *string\n-\tpkgPath *string\n-\tmethods []method\n+\tname    *string  // name of type\n+\tpkgPath *string  // import path; nil for built-in types like int, string\n+\tmethods []method // methods associated with type\n }\n \n // ChanDir represents a channel type's direction.\n type ChanDir int\n \n const (\n-\tRecvDir ChanDir = 1 << iota\n-\tSendDir\n-\tBothDir = RecvDir | SendDir\n+\tRecvDir ChanDir             = 1 << iota // <-chan\n+\tSendDir                                 // chan<-\n+\tBothDir = RecvDir | SendDir             // chan\n )\n \n // arrayType represents a fixed array type.\n type arrayType struct {\n \tcommonType `reflect:\"array\"`\n-\telem       *runtime.Type\n-\tslice      *runtime.Type\n+\telem       *runtimeType // array element type\n+\tslice      *runtimeType // slice type\n \tlen        uintptr\n }\n \n // chanType represents a channel type.\n type chanType struct {\n \tcommonType `reflect:\"chan\"`\n-\telem       *runtime.Type\n-\tdir        uintptr\n+\telem       *runtimeType // channel element type\n+\tdir        uintptr      // channel direction (ChanDir)\n }\n \n // funcType represents a function type.\n type funcType struct {\n \tcommonType `reflect:\"func\"`\n-\tdotdotdot  bool\n-\tin         []*runtime.Type\n-\tout        []*runtime.Type\n+\tdotdotdot  bool           // last input parameter is ...\n+\tin         []*runtimeType // input parameter types\n+\tout        []*runtimeType // output parameter types\n }\n \n // imethod represents a method on an interface type\n type imethod struct {\n-\tname    *string\n-\tpkgPath *string\n-\ttyp     *runtime.Type\n+\tname    *string      // name of method\n+\tpkgPath *string      // nil for exported Names; otherwise import path\n+\ttyp     *runtimeType // .(*FuncType) underneath\n }\n \n // interfaceType represents an interface type.\n type interfaceType struct {\n \tcommonType `reflect:\"interface\"`\n-\tmethods    []imethod\n+\tmethods    []imethod // sorted by hash\n }\n \n // mapType represents a map type.\n type mapType struct {\n \tcommonType `reflect:\"map\"`\n-\tkey        *runtime.Type\n-\telem       *runtime.Type\n+\tkey        *runtimeType // map key type\n+\telem       *runtimeType // map element (value) type\n }\n \n // ptrType represents a pointer type.\n type ptrType struct {\n \tcommonType `reflect:\"ptr\"`\n-\telem       *runtime.Type\n+\telem       *runtimeType // pointer element (pointed at) type\n }\n \n // sliceType represents a slice type.\n type sliceType struct {\n \tcommonType `reflect:\"slice\"`\n-\telem       *runtime.Type\n+\telem       *runtimeType // slice element type\n }\n \n // Struct field\n type structField struct {\n-\tname    *string\n-\tpkgPath *string\n-\ttyp     *runtime.Type\n-\ttag     *string\n-\toffset  uintptr\n+\tname    *string      // nil for embedded fields\n+\tpkgPath *string      // nil for exported Names; otherwise import path\n+\ttyp     *runtimeType // type of field\n+\ttag     *string      // nil if no tag\n+\toffset  uintptr      // byte offset of field within struct\n }\n \n // structType represents a struct type.\n type structType struct {\n \tcommonType `reflect:\"struct\"`\n-\tfields     []structField\n+\tfields     []structField // sorted by offset\n }\n \n /*\n@@ -559,7 +558,7 @@ func (t *commonType) Elem() Type {\n \t\ttt := (*sliceType)(unsafe.Pointer(t))\n \t\treturn toType(tt.elem)\n \t}\n-\tpanic(\"reflect; Elem of invalid type\")\n+\tpanic(\"reflect: Elem of invalid type\")\n }\n \n func (t *commonType) Field(i int) StructField {\n@@ -628,15 +627,15 @@ func (t *commonType) NumField() int {\n \n func (t *commonType) NumIn() int {\n \tif t.Kind() != Func {\n-\t\tpanic(\"reflect; NumIn of non-func type\")\n+\t\tpanic(\"reflect: NumIn of non-func type\")\n \t}\n \ttt := (*funcType)(unsafe.Pointer(t))\n \treturn len(tt.in)\n }\n \n func (t *commonType) NumOut() int {\n \tif t.Kind() != Func {\n-\t\tpanic(\"reflect; NumOut of non-func type\")\n+\t\tpanic(\"reflect: NumOut of non-func type\")\n \t}\n \ttt := (*funcType)(unsafe.Pointer(t))\n \treturn len(tt.out)\n@@ -909,12 +908,11 @@ func (t *structType) FieldByNameFunc(match func(string) bool) (f StructField, pr\n }\n \n // Convert runtime type to reflect type.\n-func toCommonType(p *runtime.Type) *commonType {\n+func toCommonType(p *runtimeType) *commonType {\n \tif p == nil {\n \t\treturn nil\n \t}\n-\tx := unsafe.Pointer(p)\n-\treturn (*commonType)(x)\n+\treturn (*commonType)(unsafe.Pointer(p))\n }\n \n // Canonicalize a Type.\n@@ -949,11 +947,11 @@ func canonicalize(t Type) Type {\n \treturn t\n }\n \n-func toType(p *runtime.Type) Type {\n+func toType(p *runtimeType) Type {\n \tif p == nil {\n \t\treturn nil\n \t}\n-\treturn toCommonType(p).toType()\n+\treturn (*commonType)(unsafe.Pointer(p))\n }\n \n // TypeOf returns the reflection Type of the value in the interface{}.\n@@ -968,8 +966,8 @@ var ptrMap struct {\n \tm map[*commonType]*ptrType\n }\n \n-func (t *commonType) runtimeType() *runtime.Type {\n-\treturn (*runtime.Type)(unsafe.Pointer(t))\n+func (t *commonType) runtimeType() *runtimeType {\n+\treturn (*runtimeType)(unsafe.Pointer(t))\n }\n \n // PtrTo returns the pointer type with element t.\n@@ -1018,13 +1016,10 @@ func (ct *commonType) ptrTo() *commonType {\n \t\treturn r.(*commonType)\n \t}\n \n-\trp := new(runtime.PtrType)\n-\n \t// initialize p using *byte's ptrType as a prototype.\n-\t// have to do assignment as ptrType, not runtime.PtrType,\n-\t// in order to write to unexported fields.\n-\tp = (*ptrType)(unsafe.Pointer(rp))\n-\tbp := (*ptrType)(unsafe.Pointer(unsafe.Typeof((*byte)(nil)).(*runtime.PtrType)))\n+\tp = new(ptrType)\n+\tvar ibyte interface{} = (*byte)(nil)\n+\tbp := (*ptrType)(unsafe.Pointer(*(**runtimeType)(unsafe.Pointer(&ibyte))))\n \t*p = *bp\n \n \tp.string = &s\n@@ -1040,7 +1035,7 @@ func (ct *commonType) ptrTo() *commonType {\n \n \tp.uncommonType = nil\n \tp.ptrToThis = nil\n-\tp.elem = (*runtime.Type)(unsafe.Pointer(ct))\n+\tp.elem = (*runtimeType)(unsafe.Pointer(ct))\n \n \tp = canonicalize(p).(*ptrType)\n "}, {"sha": "ab56bdf56b68264792bd1060ed4976b734fc605a", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -207,15 +207,15 @@ func storeIword(p unsafe.Pointer, w iword, n uintptr) {\n \n // emptyInterface is the header for an interface{} value.\n type emptyInterface struct {\n-\ttyp  *runtime.Type\n+\ttyp  *runtimeType\n \tword iword\n }\n \n // nonEmptyInterface is the header for a interface value with methods.\n type nonEmptyInterface struct {\n \t// see ../runtime/iface.c:/Itab\n \titab *struct {\n-\t\ttyp *runtime.Type          // dynamic concrete type\n+\t\ttyp *runtimeType           // dynamic concrete type\n \t\tfun [100000]unsafe.Pointer // method table\n \t}\n \tword iword\n@@ -692,7 +692,7 @@ func (v Value) FieldByNameFunc(match func(string) bool) Value {\n \treturn Value{}\n }\n \n-// Float returns v's underlying value, as an float64.\n+// Float returns v's underlying value, as a float64.\n // It panics if v's Kind is not Float32 or Float64\n func (v Value) Float() float64 {\n \tk := v.kind()\n@@ -796,6 +796,8 @@ func (v Value) CanInterface() bool {\n // If v is a method obtained by invoking Value.Method\n // (as opposed to Type.Method), Interface cannot return an\n // interface value, so it panics.\n+// It also panics if the Value was obtained by accessing\n+// unexported struct fields.\n func (v Value) Interface() interface{} {\n \treturn valueInterface(v, true)\n }\n@@ -1244,7 +1246,8 @@ func (v Value) SetInt(x int64) {\n }\n \n // SetLen sets v's length to n.\n-// It panics if v's Kind is not Slice.\n+// It panics if v's Kind is not Slice or if n is negative or\n+// greater than the capacity of the slice.\n func (v Value) SetLen(n int) {\n \tv.mustBeAssignable()\n \tv.mustBe(Slice)\n@@ -1595,6 +1598,10 @@ func Copy(dst, src Value) int {\n  * constructors\n  */\n \n+// implemented in package runtime\n+func unsafe_New(Type) unsafe.Pointer\n+func unsafe_NewArray(Type, int) unsafe.Pointer\n+\n // MakeSlice creates a new zero-initialized slice value\n // for the specified slice type, length, and capacity.\n func MakeSlice(typ Type, len, cap int) Value {\n@@ -1607,7 +1614,7 @@ func MakeSlice(typ Type, len, cap int) Value {\n \n \t// Reinterpret as *SliceHeader to edit.\n \ts := (*SliceHeader)(unsafe.Pointer(&x))\n-\ts.Data = uintptr(unsafe.NewArray(typ.Elem(), cap))\n+\ts.Data = uintptr(unsafe_NewArray(typ.Elem(), cap))\n \ts.Len = len\n \ts.Cap = cap\n \n@@ -1639,7 +1646,7 @@ func MakeMap(typ Type) Value {\n }\n \n // Indirect returns the value that v points to.\n-// If v is a nil pointer, Indirect returns a nil Value.\n+// If v is a nil pointer, Indirect returns a zero Value.\n // If v is not a pointer, Indirect returns v.\n func Indirect(v Value) Value {\n \tif v.Kind() != Ptr {\n@@ -1686,7 +1693,7 @@ func Zero(typ Type) Value {\n \tif t.Kind() == Ptr || t.Kind() == UnsafePointer {\n \t\treturn Value{t, nil, fl}\n \t}\n-\treturn Value{t, unsafe.New(typ), fl | flagIndir}\n+\treturn Value{t, unsafe_New(typ), fl | flagIndir}\n }\n \n // New returns a Value representing a pointer to a new zero value\n@@ -1695,11 +1702,18 @@ func New(typ Type) Value {\n \tif typ == nil {\n \t\tpanic(\"reflect: New(nil)\")\n \t}\n-\tptr := unsafe.New(typ)\n+\tptr := unsafe_New(typ)\n \tfl := flag(Ptr) << flagKindShift\n \treturn Value{typ.common().ptrTo(), ptr, fl}\n }\n \n+// NewAt returns a Value representing a pointer to a value of the\n+// specified type, using p as that pointer.\n+func NewAt(typ Type, p unsafe.Pointer) Value {\n+\tfl := flag(Ptr) << flagKindShift\n+\treturn Value{typ.common().ptrTo(), p, fl}\n+}\n+\n // assignTo returns a value v that can be assigned directly to typ.\n // It panics if v is not assignable to typ.\n // For a conversion to an interface type, target is a suggested scratch space to use.\n@@ -1738,20 +1752,20 @@ func (v Value) assignTo(context string, dst *commonType, target *interface{}) Va\n func chancap(ch iword) int32\n func chanclose(ch iword)\n func chanlen(ch iword) int32\n-func chanrecv(t *runtime.Type, ch iword, nb bool) (val iword, selected, received bool)\n-func chansend(t *runtime.Type, ch iword, val iword, nb bool) bool\n-\n-func makechan(typ *runtime.Type, size uint32) (ch iword)\n-func makemap(t *runtime.Type) (m iword)\n-func mapaccess(t *runtime.Type, m iword, key iword) (val iword, ok bool)\n-func mapassign(t *runtime.Type, m iword, key, val iword, ok bool)\n-func mapiterinit(t *runtime.Type, m iword) *byte\n+func chanrecv(t *runtimeType, ch iword, nb bool) (val iword, selected, received bool)\n+func chansend(t *runtimeType, ch iword, val iword, nb bool) bool\n+\n+func makechan(typ *runtimeType, size uint32) (ch iword)\n+func makemap(t *runtimeType) (m iword)\n+func mapaccess(t *runtimeType, m iword, key iword) (val iword, ok bool)\n+func mapassign(t *runtimeType, m iword, key, val iword, ok bool)\n+func mapiterinit(t *runtimeType, m iword) *byte\n func mapiterkey(it *byte) (key iword, ok bool)\n func mapiternext(it *byte)\n func maplen(m iword) int32\n \n func call(typ *commonType, fnaddr unsafe.Pointer, isInterface bool, isMethod bool, params *unsafe.Pointer, results *unsafe.Pointer)\n-func ifaceE2I(t *runtime.Type, src interface{}, dst unsafe.Pointer)\n+func ifaceE2I(t *runtimeType, src interface{}, dst unsafe.Pointer)\n \n // Dummy annotation marking that the value x escapes,\n // for use in cases where the reflect code is so clever that"}, {"sha": "f7b41a67416badc3b1ce17e5abb1839764f7c3d0", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -176,6 +176,45 @@ var replaceTests = []ReplaceTest{\n \t{\"[a-c]*\", \"x\", \"def\", \"xdxexfx\"},\n \t{\"[a-c]+\", \"x\", \"abcbcdcdedef\", \"xdxdedef\"},\n \t{\"[a-c]*\", \"x\", \"abcbcdcdedef\", \"xdxdxexdxexfx\"},\n+\n+\t// Substitutions\n+\t{\"a+\", \"($0)\", \"banana\", \"b(a)n(a)n(a)\"},\n+\t{\"a+\", \"(${0})\", \"banana\", \"b(a)n(a)n(a)\"},\n+\t{\"a+\", \"(${0})$0\", \"banana\", \"b(a)an(a)an(a)a\"},\n+\t{\"a+\", \"(${0})$0\", \"banana\", \"b(a)an(a)an(a)a\"},\n+\t{\"hello, (.+)\", \"goodbye, ${1}\", \"hello, world\", \"goodbye, world\"},\n+\t{\"hello, (.+)\", \"goodbye, $1x\", \"hello, world\", \"goodbye, \"},\n+\t{\"hello, (.+)\", \"goodbye, ${1}x\", \"hello, world\", \"goodbye, worldx\"},\n+\t{\"hello, (.+)\", \"<$0><$1><$2><$3>\", \"hello, world\", \"<hello, world><world><><>\"},\n+\t{\"hello, (?P<noun>.+)\", \"goodbye, $noun!\", \"hello, world\", \"goodbye, world!\"},\n+\t{\"hello, (?P<noun>.+)\", \"goodbye, ${noun}\", \"hello, world\", \"goodbye, world\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"$x$x$x\", \"hi\", \"hihihi\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"$x$x$x\", \"bye\", \"byebyebye\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"$xyz\", \"hi\", \"\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"${x}yz\", \"hi\", \"hiyz\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"hello $$x\", \"hi\", \"hello $x\"},\n+\t{\"a+\", \"${oops\", \"aaa\", \"${oops\"},\n+\t{\"a+\", \"$$\", \"aaa\", \"$\"},\n+\t{\"a+\", \"$\", \"aaa\", \"$\"},\n+}\n+\n+var replaceLiteralTests = []ReplaceTest{\n+\t// Substitutions\n+\t{\"a+\", \"($0)\", \"banana\", \"b($0)n($0)n($0)\"},\n+\t{\"a+\", \"(${0})\", \"banana\", \"b(${0})n(${0})n(${0})\"},\n+\t{\"a+\", \"(${0})$0\", \"banana\", \"b(${0})$0n(${0})$0n(${0})$0\"},\n+\t{\"a+\", \"(${0})$0\", \"banana\", \"b(${0})$0n(${0})$0n(${0})$0\"},\n+\t{\"hello, (.+)\", \"goodbye, ${1}\", \"hello, world\", \"goodbye, ${1}\"},\n+\t{\"hello, (?P<noun>.+)\", \"goodbye, $noun!\", \"hello, world\", \"goodbye, $noun!\"},\n+\t{\"hello, (?P<noun>.+)\", \"goodbye, ${noun}\", \"hello, world\", \"goodbye, ${noun}\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"$x$x$x\", \"hi\", \"$x$x$x\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"$x$x$x\", \"bye\", \"$x$x$x\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"$xyz\", \"hi\", \"$xyz\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"${x}yz\", \"hi\", \"${x}yz\"},\n+\t{\"(?P<x>hi)|(?P<x>bye)\", \"hello $$x\", \"hi\", \"hello $$x\"},\n+\t{\"a+\", \"${oops\", \"aaa\", \"${oops\"},\n+\t{\"a+\", \"$$\", \"aaa\", \"$$\"},\n+\t{\"a+\", \"$\", \"aaa\", \"$\"},\n }\n \n type ReplaceFuncTest struct {\n@@ -199,13 +238,58 @@ func TestReplaceAll(t *testing.T) {\n \t\t}\n \t\tactual := re.ReplaceAllString(tc.input, tc.replacement)\n \t\tif actual != tc.output {\n-\t\t\tt.Errorf(\"%q.Replace(%q,%q) = %q; want %q\",\n+\t\t\tt.Errorf(\"%q.ReplaceAllString(%q,%q) = %q; want %q\",\n \t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n \t\t}\n \t\t// now try bytes\n \t\tactual = string(re.ReplaceAll([]byte(tc.input), []byte(tc.replacement)))\n \t\tif actual != tc.output {\n-\t\t\tt.Errorf(\"%q.Replace(%q,%q) = %q; want %q\",\n+\t\t\tt.Errorf(\"%q.ReplaceAll(%q,%q) = %q; want %q\",\n+\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n+\t\t}\n+\t}\n+}\n+\n+func TestReplaceAllLiteral(t *testing.T) {\n+\t// Run ReplaceAll tests that do not have $ expansions.\n+\tfor _, tc := range replaceTests {\n+\t\tif strings.Contains(tc.replacement, \"$\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tre, err := Compile(tc.pattern)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Unexpected error compiling %q: %v\", tc.pattern, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tactual := re.ReplaceAllLiteralString(tc.input, tc.replacement)\n+\t\tif actual != tc.output {\n+\t\t\tt.Errorf(\"%q.ReplaceAllLiteralString(%q,%q) = %q; want %q\",\n+\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n+\t\t}\n+\t\t// now try bytes\n+\t\tactual = string(re.ReplaceAllLiteral([]byte(tc.input), []byte(tc.replacement)))\n+\t\tif actual != tc.output {\n+\t\t\tt.Errorf(\"%q.ReplaceAllLiteral(%q,%q) = %q; want %q\",\n+\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n+\t\t}\n+\t}\n+\n+\t// Run literal-specific tests.\n+\tfor _, tc := range replaceLiteralTests {\n+\t\tre, err := Compile(tc.pattern)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Unexpected error compiling %q: %v\", tc.pattern, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tactual := re.ReplaceAllLiteralString(tc.input, tc.replacement)\n+\t\tif actual != tc.output {\n+\t\t\tt.Errorf(\"%q.ReplaceAllLiteralString(%q,%q) = %q; want %q\",\n+\t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n+\t\t}\n+\t\t// now try bytes\n+\t\tactual = string(re.ReplaceAllLiteral([]byte(tc.input), []byte(tc.replacement)))\n+\t\tif actual != tc.output {\n+\t\t\tt.Errorf(\"%q.ReplaceAllLiteral(%q,%q) = %q; want %q\",\n \t\t\t\ttc.pattern, tc.input, tc.replacement, actual, tc.output)\n \t\t}\n \t}"}, {"sha": "54c53776cf7adbb9ab8e97cac2bf35fad55621fb", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 220, "deletions": 64, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -61,6 +61,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n+\t\"unicode\"\n \t\"unicode/utf8\"\n )\n \n@@ -416,41 +417,79 @@ func Match(pattern string, b []byte) (matched bool, error error) {\n \treturn re.Match(b), nil\n }\n \n-// ReplaceAllString returns a copy of src in which all matches for the Regexp\n-// have been replaced by repl.  No support is provided for expressions\n-// (e.g. \\1 or $1) in the replacement string.\n+// ReplaceAllString returns a copy of src, replacing matches of the Regexp\n+// with the replacement string repl.  Inside repl, $ signs are interpreted as\n+// in Expand, so for instance $1 represents the text of the first submatch.\n func (re *Regexp) ReplaceAllString(src, repl string) string {\n-\treturn re.ReplaceAllStringFunc(src, func(string) string { return repl })\n+\tn := 2\n+\tif strings.Index(repl, \"$\") >= 0 {\n+\t\tn = 2 * (re.numSubexp + 1)\n+\t}\n+\tb := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {\n+\t\treturn re.expand(dst, repl, nil, src, match)\n+\t})\n+\treturn string(b)\n }\n \n-// ReplaceAllStringFunc returns a copy of src in which all matches for the\n-// Regexp have been replaced by the return value of of function repl (whose\n-// first argument is the matched string).  No support is provided for\n-// expressions (e.g. \\1 or $1) in the replacement string.\n+// ReplaceAllStringLiteral returns a copy of src, replacing matches of the Regexp\n+// with the replacement string repl.  The replacement repl is substituted directly,\n+// without using Expand.\n+func (re *Regexp) ReplaceAllLiteralString(src, repl string) string {\n+\treturn string(re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {\n+\t\treturn append(dst, repl...)\n+\t}))\n+}\n+\n+// ReplaceAllStringFunc returns a copy of src in which all matches of the\n+// Regexp have been replaced by the return value of of function repl applied\n+// to the matched substring.  The replacement returned by repl is substituted\n+// directly, without using Expand.\n func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string {\n+\tb := re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {\n+\t\treturn append(dst, repl(src[match[0]:match[1]])...)\n+\t})\n+\treturn string(b)\n+}\n+\n+func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte {\n \tlastMatchEnd := 0 // end position of the most recent match\n \tsearchPos := 0    // position where we next look for a match\n-\tbuf := new(bytes.Buffer)\n-\tfor searchPos <= len(src) {\n-\t\ta := re.doExecute(nil, nil, src, searchPos, 2)\n+\tvar buf []byte\n+\tvar endPos int\n+\tif bsrc != nil {\n+\t\tendPos = len(bsrc)\n+\t} else {\n+\t\tendPos = len(src)\n+\t}\n+\tfor searchPos <= endPos {\n+\t\ta := re.doExecute(nil, bsrc, src, searchPos, nmatch)\n \t\tif len(a) == 0 {\n \t\t\tbreak // no more matches\n \t\t}\n \n \t\t// Copy the unmatched characters before this match.\n-\t\tio.WriteString(buf, src[lastMatchEnd:a[0]])\n+\t\tif bsrc != nil {\n+\t\t\tbuf = append(buf, bsrc[lastMatchEnd:a[0]]...)\n+\t\t} else {\n+\t\t\tbuf = append(buf, src[lastMatchEnd:a[0]]...)\n+\t\t}\n \n \t\t// Now insert a copy of the replacement string, but not for a\n \t\t// match of the empty string immediately after another match.\n \t\t// (Otherwise, we get double replacement for patterns that\n \t\t// match both empty and nonempty strings.)\n \t\tif a[1] > lastMatchEnd || a[0] == 0 {\n-\t\t\tio.WriteString(buf, repl(src[a[0]:a[1]]))\n+\t\t\tbuf = repl(buf, a)\n \t\t}\n \t\tlastMatchEnd = a[1]\n \n \t\t// Advance past this match; always advance at least one character.\n-\t\t_, width := utf8.DecodeRuneInString(src[searchPos:])\n+\t\tvar width int\n+\t\tif bsrc != nil {\n+\t\t\t_, width = utf8.DecodeRune(bsrc[searchPos:])\n+\t\t} else {\n+\t\t\t_, width = utf8.DecodeRuneInString(src[searchPos:])\n+\t\t}\n \t\tif searchPos+width > a[1] {\n \t\t\tsearchPos += width\n \t\t} else if searchPos+1 > a[1] {\n@@ -463,61 +502,50 @@ func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) str\n \t}\n \n \t// Copy the unmatched characters after the last match.\n-\tio.WriteString(buf, src[lastMatchEnd:])\n+\tif bsrc != nil {\n+\t\tbuf = append(buf, bsrc[lastMatchEnd:]...)\n+\t} else {\n+\t\tbuf = append(buf, src[lastMatchEnd:]...)\n+\t}\n \n-\treturn buf.String()\n+\treturn buf\n }\n \n-// ReplaceAll returns a copy of src in which all matches for the Regexp\n-// have been replaced by repl.  No support is provided for expressions\n-// (e.g. \\1 or $1) in the replacement text.\n+// ReplaceAll returns a copy of src, replacing matches of the Regexp\n+// with the replacement string repl.  Inside repl, $ signs are interpreted as\n+// in Expand, so for instance $1 represents the text of the first submatch.\n func (re *Regexp) ReplaceAll(src, repl []byte) []byte {\n-\treturn re.ReplaceAllFunc(src, func([]byte) []byte { return repl })\n-}\n-\n-// ReplaceAllFunc returns a copy of src in which all matches for the\n-// Regexp have been replaced by the return value of of function repl (whose\n-// first argument is the matched []byte).  No support is provided for\n-// expressions (e.g. \\1 or $1) in the replacement string.\n-func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {\n-\tlastMatchEnd := 0 // end position of the most recent match\n-\tsearchPos := 0    // position where we next look for a match\n-\tbuf := new(bytes.Buffer)\n-\tfor searchPos <= len(src) {\n-\t\ta := re.doExecute(nil, src, \"\", searchPos, 2)\n-\t\tif len(a) == 0 {\n-\t\t\tbreak // no more matches\n-\t\t}\n-\n-\t\t// Copy the unmatched characters before this match.\n-\t\tbuf.Write(src[lastMatchEnd:a[0]])\n-\n-\t\t// Now insert a copy of the replacement string, but not for a\n-\t\t// match of the empty string immediately after another match.\n-\t\t// (Otherwise, we get double replacement for patterns that\n-\t\t// match both empty and nonempty strings.)\n-\t\tif a[1] > lastMatchEnd || a[0] == 0 {\n-\t\t\tbuf.Write(repl(src[a[0]:a[1]]))\n-\t\t}\n-\t\tlastMatchEnd = a[1]\n-\n-\t\t// Advance past this match; always advance at least one character.\n-\t\t_, width := utf8.DecodeRune(src[searchPos:])\n-\t\tif searchPos+width > a[1] {\n-\t\t\tsearchPos += width\n-\t\t} else if searchPos+1 > a[1] {\n-\t\t\t// This clause is only needed at the end of the input\n-\t\t\t// string.  In that case, DecodeRuneInString returns width=0.\n-\t\t\tsearchPos++\n-\t\t} else {\n-\t\t\tsearchPos = a[1]\n-\t\t}\n+\tn := 2\n+\tif bytes.IndexByte(repl, '$') >= 0 {\n+\t\tn = 2 * (re.numSubexp + 1)\n \t}\n+\tsrepl := \"\"\n+\tb := re.replaceAll(src, \"\", n, func(dst []byte, match []int) []byte {\n+\t\tif len(srepl) != len(repl) {\n+\t\t\tsrepl = string(repl)\n+\t\t}\n+\t\treturn re.expand(dst, srepl, src, \"\", match)\n+\t})\n+\treturn b\n+}\n \n-\t// Copy the unmatched characters after the last match.\n-\tbuf.Write(src[lastMatchEnd:])\n+// ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp\n+// with the replacement bytes repl.  The replacement repl is substituted directly,\n+// without using Expand.\n+func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte {\n+\treturn re.replaceAll(src, \"\", 2, func(dst []byte, match []int) []byte {\n+\t\treturn append(dst, repl...)\n+\t})\n+}\n \n-\treturn buf.Bytes()\n+// ReplaceAllFunc returns a copy of src in which all matches of the\n+// Regexp have been replaced by the return value of of function repl applied\n+// to the matched byte slice.  The replacement returned by repl is substituted\n+// directly, without using Expand.\n+func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {\n+\treturn re.replaceAll(src, \"\", 2, func(dst []byte, match []int) []byte {\n+\t\treturn append(dst, repl(src[match[0]:match[1]])...)\n+\t})\n }\n \n var specialBytes = []byte(`\\.+*?()|[]{}^$`)\n@@ -648,7 +676,7 @@ func (re *Regexp) FindString(s string) string {\n // location of the leftmost match in s of the regular expression.  The match\n // itself is at s[loc[0]:loc[1]].\n // A return value of nil indicates no match.\n-func (re *Regexp) FindStringIndex(s string) []int {\n+func (re *Regexp) FindStringIndex(s string) (loc []int) {\n \ta := re.doExecute(nil, nil, s, 0, 2)\n \tif a == nil {\n \t\treturn nil\n@@ -660,7 +688,7 @@ func (re *Regexp) FindStringIndex(s string) []int {\n // location of the leftmost match of the regular expression in text read from\n // the RuneReader.  The match itself is at s[loc[0]:loc[1]].  A return\n // value of nil indicates no match.\n-func (re *Regexp) FindReaderIndex(r io.RuneReader) []int {\n+func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int) {\n \ta := re.doExecute(r, nil, \"\", 0, 2)\n \tif a == nil {\n \t\treturn nil\n@@ -687,6 +715,134 @@ func (re *Regexp) FindSubmatch(b []byte) [][]byte {\n \treturn ret\n }\n \n+// Expand appends template to dst and returns the result; during the\n+// append, Expand replaces variables in the template with corresponding\n+// matches drawn from src.  The match slice should have been returned by\n+// FindSubmatchIndex.\n+// \n+// In the template, a variable is denoted by a substring of the form\n+// $name or ${name}, where name is a non-empty sequence of letters,\n+// digits, and underscores.  A purely numeric name like $1 refers to\n+// the submatch with the corresponding index; other names refer to\n+// capturing parentheses named with the (?P<name>...) syntax.  A\n+// reference to an out of range or unmatched index or a name that is not\n+// present in the regular expression is replaced with an empty string.\n+// \n+// In the $name form, name is taken to be as long as possible: $1x is\n+// equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.\n+// \n+// To insert a literal $ in the output, use $$ in the template.\n+func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte {\n+\treturn re.expand(dst, string(template), src, \"\", match)\n+}\n+\n+// ExpandString is like Expand but the template and source are strings.\n+// It appends to and returns a byte slice in order to give the calling\n+// code control over allocation.\n+func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte {\n+\treturn re.expand(dst, template, nil, src, match)\n+}\n+\n+func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte {\n+\tfor len(template) > 0 {\n+\t\ti := strings.Index(template, \"$\")\n+\t\tif i < 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tdst = append(dst, template[:i]...)\n+\t\ttemplate = template[i:]\n+\t\tif len(template) > 1 && template[1] == '$' {\n+\t\t\t// Treat $$ as $.\n+\t\t\tdst = append(dst, '$')\n+\t\t\ttemplate = template[2:]\n+\t\t\tcontinue\n+\t\t}\n+\t\tname, num, rest, ok := extract(template)\n+\t\tif !ok {\n+\t\t\t// Malformed; treat $ as raw text.\n+\t\t\tdst = append(dst, '$')\n+\t\t\ttemplate = template[1:]\n+\t\t\tcontinue\n+\t\t}\n+\t\ttemplate = rest\n+\t\tif num >= 0 {\n+\t\t\tif 2*num+1 < len(match) {\n+\t\t\t\tif bsrc != nil {\n+\t\t\t\t\tdst = append(dst, bsrc[match[2*num]:match[2*num+1]]...)\n+\t\t\t\t} else {\n+\t\t\t\t\tdst = append(dst, src[match[2*num]:match[2*num+1]]...)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor i, namei := range re.subexpNames {\n+\t\t\t\tif name == namei && 2*i+1 < len(match) && match[2*i] >= 0 {\n+\t\t\t\t\tif bsrc != nil {\n+\t\t\t\t\t\tdst = append(dst, bsrc[match[2*i]:match[2*i+1]]...)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdst = append(dst, src[match[2*i]:match[2*i+1]]...)\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tdst = append(dst, template...)\n+\treturn dst\n+}\n+\n+// extract returns the name from a leading \"$name\" or \"${name}\" in str.\n+// If it is a number, extract returns num set to that number; otherwise num = -1.\n+func extract(str string) (name string, num int, rest string, ok bool) {\n+\tif len(str) < 2 || str[0] != '$' {\n+\t\treturn\n+\t}\n+\tbrace := false\n+\tif str[1] == '{' {\n+\t\tbrace = true\n+\t\tstr = str[2:]\n+\t} else {\n+\t\tstr = str[1:]\n+\t}\n+\ti := 0\n+\tfor i < len(str) {\n+\t\trune, size := utf8.DecodeRuneInString(str[i:])\n+\t\tif !unicode.IsLetter(rune) && !unicode.IsDigit(rune) && rune != '_' {\n+\t\t\tbreak\n+\t\t}\n+\t\ti += size\n+\t}\n+\tif i == 0 {\n+\t\t// empty name is not okay\n+\t\treturn\n+\t}\n+\tname = str[:i]\n+\tif brace {\n+\t\tif i >= len(str) || str[i] != '}' {\n+\t\t\t// missing closing brace\n+\t\t\treturn\n+\t\t}\n+\t\ti++\n+\t}\n+\n+\t// Parse number.\n+\tnum = 0\n+\tfor i := 0; i < len(name); i++ {\n+\t\tif name[i] < '0' || '9' < name[i] || num >= 1e8 {\n+\t\t\tnum = -1\n+\t\t\tbreak\n+\t\t}\n+\t\tnum = num*10 + int(name[i]) - '0'\n+\t}\n+\t// Disallow leading zeros.\n+\tif name[0] == '0' && len(name) > 1 {\n+\t\tnum = -1\n+\t}\n+\n+\trest = str[i:]\n+\tok = true\n+\treturn\n+}\n+\n // FindSubmatchIndex returns a slice holding the index pairs identifying the\n // leftmost match of the regular expression in b and the matches, if any, of\n // its subexpressions, as defined by the 'Submatch' and 'Index' descriptions"}, {"sha": "71b07b993070aebe96ac3c6baf9b0337219a8e18", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,6 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Package syntax parses regular expressions into parse trees and compiles\n+// parse trees into programs. Most clients of regular expressions will use\n+// the facilities of package regexp (such as Compile and Match) instead of\n+// this package.\n package syntax\n \n import (\n@@ -648,6 +652,9 @@ func literalRegexp(s string, flags Flags) *Regexp {\n \n // Parsing.\n \n+// Parse parses a regular expression string s, controlled by the specified\n+// Flags, and returns a regular expression parse tree. The syntax is\n+// described in the top-level comment for package regexp.\n func Parse(s string, flags Flags) (*Regexp, error) {\n \tif flags&Literal != 0 {\n \t\t// Trivial parser for literal string."}, {"sha": "329a90e01294076d07f12086237d8b8669234fd7", "filename": "libgo/go/regexp/syntax/regexp.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package syntax parses regular expressions into syntax trees.\n-// WORK IN PROGRESS.\n package syntax\n \n // Note to implementers:"}, {"sha": "bd6dcc971a1a4a37f91785599854b23b73ce5477", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -95,11 +95,37 @@ func (r *MemProfileRecord) Stack() []uintptr {\n // where r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\n // These are sites where memory was allocated, but it has all\n // been released back to the runtime.\n+//\n // Most clients should use the runtime/pprof package or\n // the testing package's -test.memprofile flag instead\n // of calling MemProfile directly.\n func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)\n \n+// A ThreadProfileRecord describes the execution stack that\n+// caused a new thread to be created.\n+type ThreadProfileRecord struct {\n+\tStack0 [32]uintptr // stack trace for this record; ends at first 0 entry\n+}\n+\n+// Stack returns the stack trace associated with the record,\n+// a prefix of r.Stack0.\n+func (r *ThreadProfileRecord) Stack() []uintptr {\n+\tfor i, v := range r.Stack0 {\n+\t\tif v == 0 {\n+\t\t\treturn r.Stack0[0:i]\n+\t\t}\n+\t}\n+\treturn r.Stack0[0:]\n+}\n+\n+// ThreadProfile returns n, the number of records in the current thread profile.\n+// If len(p) >= n, ThreadProfile copies the profile into p and returns n, true.\n+// If len(p) < n, ThreadProfile does not change p and returns n, false.\n+//\n+// Most clients should use the runtime/pprof package instead\n+// of calling ThreadProfile directly.\n+func ThreadProfile(p []ThreadProfileRecord) (n int, ok bool)\n+\n // CPUProfile returns the next chunk of binary CPU profiling stack trace data,\n // blocking until data is available.  If profiling is turned off and all the profile\n // data accumulated while it was on has been returned, CPUProfile returns nil."}, {"sha": "d3913ec27b8e9b40d86ec6f2726df836e2ee4f01", "filename": "libgo/go/runtime/error.go", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ferror.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,9 +17,6 @@ type Error interface {\n \n // A TypeAssertionError explains a failed type assertion.\n type TypeAssertionError struct {\n-\tinterfaceType   *Type // interface had this type\n-\tconcreteType    *Type // concrete value had this type\n-\tassertedType    *Type // asserted type\n \tinterfaceString string\n \tconcreteString  string\n \tassertedString  string\n@@ -33,7 +30,7 @@ func (e *TypeAssertionError) Error() string {\n \tif inter == \"\" {\n \t\tinter = \"interface\"\n \t}\n-\tif e.concreteType == nil {\n+\tif e.concreteString == \"\" {\n \t\treturn \"interface conversion: \" + inter + \" is nil, not \" + e.assertedString\n \t}\n \tif e.missingMethod == \"\" {\n@@ -44,40 +41,10 @@ func (e *TypeAssertionError) Error() string {\n \t\t\": missing method \" + e.missingMethod\n }\n \n-// Concrete returns the type of the concrete value in the failed type assertion.\n-// If the interface value was nil, Concrete returns nil.\n-func (e *TypeAssertionError) Concrete() *Type {\n-\treturn e.concreteType\n-}\n-\n-// Asserted returns the type incorrectly asserted by the type assertion.\n-func (e *TypeAssertionError) Asserted() *Type {\n-\treturn e.assertedType\n-}\n-\n-// If the type assertion is to an interface type, MissingMethod returns the\n-// name of a method needed to satisfy that interface type but not implemented\n-// by Concrete.  If there are multiple such methods,\n-// MissingMethod returns one; which one is unspecified.\n-// If the type assertion is not to an interface type, MissingMethod returns an empty string.\n-func (e *TypeAssertionError) MissingMethod() string {\n-\treturn e.missingMethod\n-}\n-\n // For calling from C.\n-func NewTypeAssertionError(pt1, pt2, pt3 *Type, ps1, ps2, ps3 *string, pmeth *string, ret *interface{}) {\n-\tvar t1, t2, t3 *Type\n+func NewTypeAssertionError(ps1, ps2, ps3 *string, pmeth *string, ret *interface{}) {\n \tvar s1, s2, s3, meth string\n \n-\tif pt1 != nil {\n-\t\tt1 = pt1\n-\t}\n-\tif pt2 != nil {\n-\t\tt2 = pt2\n-\t}\n-\tif pt3 != nil {\n-\t\tt3 = pt3\n-\t}\n \tif ps1 != nil {\n \t\ts1 = *ps1\n \t}\n@@ -90,7 +57,7 @@ func NewTypeAssertionError(pt1, pt2, pt3 *Type, ps1, ps2, ps3 *string, pmeth *st\n \tif pmeth != nil {\n \t\tmeth = *pmeth\n \t}\n-\t*ret = &TypeAssertionError{t1, t2, t3, s1, s2, s3, meth}\n+\t*ret = &TypeAssertionError{s1, s2, s3, meth}\n }\n \n // An errorString represents a runtime error described by a single string."}, {"sha": "65894a6fd01531695c2435efe9064b406d64bbbb", "filename": "libgo/go/runtime/gc_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fgc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fgc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fgc_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -15,7 +15,11 @@ func TestGcSys(t *testing.T) {\n \truntime.ReadMemStats(memstats)\n \tsys := memstats.Sys\n \n-\tfor i := 0; i < 1000000; i++ {\n+\titercount := 1000000\n+\tif testing.Short() {\n+\t\titercount = 100000\n+\t}\n+\tfor i := 0; i < itercount; i++ {\n \t\tworkthegc()\n \t}\n "}, {"sha": "42f04f320a703f654258bf26dc77e86632efd292", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -110,6 +110,44 @@ func WriteHeapProfile(w io.Writer) error {\n \treturn b.Flush()\n }\n \n+// WriteThreadProfile writes a pprof-formatted thread creation profile to w.\n+// If a write to w returns an error, WriteThreadProfile returns that error.\n+// Otherwise, WriteThreadProfile returns nil.\n+func WriteThreadProfile(w io.Writer) error {\n+\t// Find out how many records there are (ThreadProfile(nil)),\n+\t// allocate that many records, and get the data.\n+\t// There's a race\u2014more records (threads) might be added between\n+\t// the two calls\u2014so allocate a few extra records for safety\n+\t// and also try again if we're very unlucky.\n+\t// The loop should only execute one iteration in the common case.\n+\tvar p []runtime.ThreadProfileRecord\n+\tn, ok := runtime.ThreadProfile(nil)\n+\tfor {\n+\t\t// Allocate room for a slightly bigger profile,\n+\t\t// in case a few more entries have been added\n+\t\t// since the call to ThreadProfile.\n+\t\tp = make([]runtime.ThreadProfileRecord, n+10)\n+\t\tn, ok = runtime.ThreadProfile(p)\n+\t\tif ok {\n+\t\t\tp = p[0:n]\n+\t\t\tbreak\n+\t\t}\n+\t\t// Profile grew; try again.\n+\t}\n+\n+\tb := bufio.NewWriter(w)\n+\tfmt.Fprintf(b, \"thread creation profile: %d threads\\n\", n)\n+\tfor i := range p {\n+\t\tr := &p[i]\n+\t\tfmt.Fprintf(b, \"@\")\n+\t\tfor _, pc := range r.Stack() {\n+\t\t\tfmt.Fprintf(b, \" %#x\", pc)\n+\t\t}\n+\t\tfmt.Fprintf(b, \"\\n\")\n+\t}\n+\treturn b.Flush()\n+}\n+\n var cpu struct {\n \tsync.Mutex\n \tprofiling bool"}, {"sha": "d68b363e99866fcbe4f29cfb184fc2c70449d769", "filename": "libgo/go/runtime/runtime_test.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fruntime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fruntime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime_test\n+\n+import (\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+var errf error\n+\n+func errfn() error {\n+\treturn errf\n+}\n+\n+func errfn1() error {\n+\treturn io.EOF\n+}\n+\n+func BenchmarkIfaceCmp100(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor j := 0; j < 100; j++ {\n+\t\t\tif errfn() == io.EOF {\n+\t\t\t\tb.Fatal(\"bad comparison\")\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkIfaceCmpNil100(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor j := 0; j < 100; j++ {\n+\t\t\tif errfn1() == nil {\n+\t\t\t\tb.Fatal(\"bad comparison\")\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "6d560b90077de2b5ee61246c699cbbad7d34e75d", "filename": "libgo/go/runtime/sig.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fruntime%2Fsig.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Fruntime%2Fsig.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsig.go?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-// Sigrecv returns a bitmask of signals that have arrived since the last call to Sigrecv.\n-// It blocks until at least one signal arrives.\n-func Sigrecv() uint32\n-\n-// Signame returns a string describing the signal, or \"\" if the signal is unknown.\n-func Signame(sig int32) string\n-\n-// Siginit enables receipt of signals via Sigrecv.  It should typically\n-// be called during initialization.\n-func Siginit()"}, {"sha": "4fcf8f269018e90440157f2f7a1dd72dff00e24d", "filename": "libgo/go/runtime/softfloat64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fsoftfloat64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Fsoftfloat64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsoftfloat64.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -4,7 +4,7 @@\n \n // Software IEEE754 64-bit floating point.\n // Only referred to (and thus linked in) by arm port\n-// and by gotest in this directory.\n+// and by tests in this directory.\n \n package runtime\n "}, {"sha": "c15c1c10c85b3314185146af86c9ff797bfe2513", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 29, "deletions": 182, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -4,205 +4,52 @@\n \n /*\n  * Runtime type representation.\n- *\n- * The following files know the exact layout of these\n- * data structures and must be kept in sync with this file:\n- *\n- *\t../../cmd/gc/reflect.c\n- *\t../../cmd/ld/dwarf.c decodetype_*\n- *\t../reflect/type.go\n- *\ttype.h\n+ * This file exists only to provide types that 6l can turn into\n+ * DWARF information for use by gdb.  Nothing else uses these.\n+ * They should match the same types in ../reflect/type.go.\n+ * For comments see ../reflect/type.go.\n  */\n \n package runtime\n \n import \"unsafe\"\n \n-// All types begin with a few common fields needed for\n-// the interface runtime.\n type commonType struct {\n-\tKind       uint8   // type kind\n-\talign      uint8   // alignment of variable with this type\n-\tfieldAlign uint8   // alignment of struct field with this type\n-\tsize       uintptr // size in bytes\n-\thash       uint32  // hash of type; avoids computation in hash tables\n+\tKind       uint8\n+\talign      uint8\n+\tfieldAlign uint8\n+\tsize       uintptr\n+\thash       uint32\n \n-\thashfn  func(unsafe.Pointer, uintptr) uintptr              // hash function\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool // equality function\n+\thashfn  func(unsafe.Pointer, uintptr) uintptr\n+\tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool\n \n-\tstring        *string // string form; unnecessary  but undeniably useful\n-\t*uncommonType         // (relatively) uncommon fields\n-\tptrToThis     *Type   // pointer to this type, if used in binary or has methods\n+\tstring *string\n+\t*uncommonType\n+\tptrToThis *commonType\n }\n \n-// Values for commonType.kind.\n-const (\n-\tkindBool = 1 + iota\n-\tkindInt\n-\tkindInt8\n-\tkindInt16\n-\tkindInt32\n-\tkindInt64\n-\tkindUint\n-\tkindUint8\n-\tkindUint16\n-\tkindUint32\n-\tkindUint64\n-\tkindUintptr\n-\tkindFloat32\n-\tkindFloat64\n-\tkindComplex64\n-\tkindComplex128\n-\tkindArray\n-\tkindChan\n-\tkindFunc\n-\tkindInterface\n-\tkindMap\n-\tkindPtr\n-\tkindSlice\n-\tkindString\n-\tkindStruct\n-\tkindUnsafePointer\n-\n-\t// Not currently generated by gccgo.\n-\t// kindNoPointers = 1 << 7 // OR'ed into kind\n-)\n-\n-// Externally visible name.\n-type Type commonType\n-\n-// Method on non-interface type\n-type _method struct { // underscore is to avoid collision with C\n-\tname    *string        // name of method\n-\tpkgPath *string        // nil for exported Names; otherwise import path\n-\tmtyp    *Type          // method type (without receiver)\n-\ttyp     *Type          // .(*FuncType) underneath (with receiver)\n-\ttfn     unsafe.Pointer // fn used for normal method call\n+type _method struct {\n+\tname    *string\n+\tpkgPath *string\n+\tmtyp    *commonType\n+\ttyp     *commonType\n+\ttfn     unsafe.Pointer\n }\n \n-// uncommonType is present only for types with names or methods\n-// (if T is a named type, the uncommonTypes for T and *T have methods).\n-// Using a pointer to this struct reduces the overall size required\n-// to describe an unnamed type with no methods.\n type uncommonType struct {\n-\tname    *string   // name of type\n-\tpkgPath *string   // import path; nil for built-in types like int, string\n-\tmethods []_method // methods associated with type\n-}\n-\n-// BoolType represents a boolean type.\n-type BoolType commonType\n-\n-// FloatType represents a float type.\n-type FloatType commonType\n-\n-// ComplexType represents a complex type.\n-type ComplexType commonType\n-\n-// IntType represents an int type.\n-type IntType commonType\n-\n-// UintType represents a uint type.\n-type UintType commonType\n-\n-// StringType represents a string type.\n-type StringType commonType\n-\n-// UintptrType represents a uintptr type.\n-type UintptrType commonType\n-\n-// UnsafePointerType represents an unsafe.Pointer type.\n-type UnsafePointerType commonType\n-\n-// ArrayType represents a fixed array type.\n-type ArrayType struct {\n-\tcommonType\n-\telem  *Type // array element type\n-\tslice *Type // slice type\n-\tlen   uintptr\n-}\n-\n-// SliceType represents a slice type.\n-type SliceType struct {\n-\tcommonType\n-\telem *Type // slice element type\n-}\n-\n-// ChanDir represents a channel type's direction.\n-type ChanDir int\n-\n-const (\n-\tRecvDir ChanDir             = 1 << iota // <-chan\n-\tSendDir                                 // chan<-\n-\tBothDir = RecvDir | SendDir             // chan\n-)\n-\n-// ChanType represents a channel type.\n-type ChanType struct {\n-\tcommonType\n-\telem *Type   // channel element type\n-\tdir  uintptr // channel direction (ChanDir)\n-}\n-\n-// FuncType represents a function type.\n-type FuncType struct {\n-\tcommonType\n-\tdotdotdot bool    // last input parameter is ...\n-\tin        []*Type // input parameter types\n-\tout       []*Type // output parameter types\n-}\n-\n-// Method on interface type\n-type _imethod struct { // underscore is to avoid collision with C\n-\tname    *string // name of method\n-\tpkgPath *string // nil for exported Names; otherwise import path\n-\ttyp     *Type   // .(*FuncType) underneath\n-}\n-\n-// InterfaceType represents an interface type.\n-type InterfaceType struct {\n-\tcommonType\n-\tmethods []_imethod // sorted by hash\n+\tname    *string\n+\tpkgPath *string\n+\tmethods []_method\n }\n \n-// MapType represents a map type.\n-type MapType struct {\n-\tcommonType\n-\tkey  *Type // map key type\n-\telem *Type // map element (value) type\n-}\n-\n-// PtrType represents a pointer type.\n-type PtrType struct {\n-\tcommonType\n-\telem *Type // pointer element (pointed at) type\n-}\n-\n-// Struct field\n-type structField struct {\n-\tname    *string // nil for embedded fields\n-\tpkgPath *string // nil for exported Names; otherwise import path\n-\ttyp     *Type   // type of field\n-\ttag     *string // nil if no tag\n-\toffset  uintptr // byte offset of field within struct\n+type _imethod struct {\n+\tname    *string\n+\tpkgPath *string\n+\ttyp     *commonType\n }\n \n-// StructType represents a struct type.\n-type StructType struct {\n+type interfaceType struct {\n \tcommonType\n-\tfields []structField // sorted by offset\n-}\n-\n-/*\n- * Must match iface.c:/Itab and compilers.\n- * NOTE: this is the version used by the reflection code, there is another\n- * one in iface_defs.go that is closer to the original C version.\n- */\n-type Itable struct {\n-\tItype  *Type // (*tab.inter).(*InterfaceType) is the interface type\n-\tType   *Type\n-\tlink   *Itable\n-\tbad    int32\n-\tunused int32\n-\tFn     [100000]uintptr // bigger than we'll ever see\n+\tmethods []_imethod\n }"}, {"sha": "cd3031b0e61b86d30998389534e3ff82746a2460", "filename": "libgo/go/strconv/atof.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrconv%2Fatof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrconv%2Fatof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -52,10 +52,10 @@ func special(s string) (f float64, ok bool) {\n \treturn\n }\n \n-// TODO(rsc): Better truncation handling.\n func (b *decimal) set(s string) (ok bool) {\n \ti := 0\n \tb.neg = false\n+\tb.trunc = false\n \n \t// optional sign\n \tif i >= len(s) {\n@@ -88,8 +88,12 @@ func (b *decimal) set(s string) (ok bool) {\n \t\t\t\tb.dp--\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tb.d[b.nd] = s[i]\n-\t\t\tb.nd++\n+\t\t\tif b.nd < len(b.d) {\n+\t\t\t\tb.d[b.nd] = s[i]\n+\t\t\t\tb.nd++\n+\t\t\t} else if s[i] != '0' {\n+\t\t\t\tb.trunc = true\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\tbreak"}, {"sha": "59950238230c4e288fa9bf5f82414c1c1d5c48e3", "filename": "libgo/go/strconv/atof_test.go", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"math/rand\"\n \t\"reflect\"\n \t. \"strconv\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -117,6 +118,20 @@ var atoftests = []atofTest{\n \n \t// A very large number (initially wrongly parsed by the fast algorithm).\n \t{\"4.630813248087435e+307\", \"4.630813248087435e+307\", nil},\n+\n+\t// A different kind of very large number.\n+\t{\"22.222222222222222\", \"22.22222222222222\", nil},\n+\t{\"2.\" + strings.Repeat(\"2\", 4000) + \"e+1\", \"22.22222222222222\", nil},\n+\n+\t// Exactly halfway between 1 and math.Nextafter(1, 2).\n+\t// Round to even (down).\n+\t{\"1.00000000000000011102230246251565404236316680908203125\", \"1\", nil},\n+\t// Slightly lower; still round down.\n+\t{\"1.00000000000000011102230246251565404236316680908203124\", \"1\", nil},\n+\t// Slightly higher; round up.\n+\t{\"1.00000000000000011102230246251565404236316680908203126\", \"1.0000000000000002\", nil},\n+\t// Slightly higher, but you have to read all the way to the end.\n+\t{\"1.00000000000000011102230246251565404236316680908203125\" + strings.Repeat(\"0\", 10000) + \"1\", \"1.0000000000000002\", nil},\n }\n \n type atofSimpleTest struct {\n@@ -211,6 +226,44 @@ func TestAtofRandom(t *testing.T) {\n \tt.Logf(\"tested %d random numbers\", len(atofRandomTests))\n }\n \n+var roundTripCases = []struct {\n+\tf float64\n+\ts string\n+}{\n+\t// Issue 2917.\n+\t// This test will break the optimized conversion if the\n+\t// FPU is using 80-bit registers instead of 64-bit registers,\n+\t// usually because the operating system initialized the\n+\t// thread with 80-bit precision and the Go runtime didn't\n+\t// fix the FP control word.\n+\t{8865794286000691 << 39, \"4.87402195346389e+27\"},\n+\t{8865794286000692 << 39, \"4.8740219534638903e+27\"},\n+}\n+\n+func TestRoundTrip(t *testing.T) {\n+\tfor _, tt := range roundTripCases {\n+\t\told := SetOptimize(false)\n+\t\ts := FormatFloat(tt.f, 'g', -1, 64)\n+\t\tif s != tt.s {\n+\t\t\tt.Errorf(\"no-opt FormatFloat(%b) = %s, want %s\", tt.f, s, tt.s)\n+\t\t}\n+\t\tf, err := ParseFloat(tt.s, 64)\n+\t\tif f != tt.f || err != nil {\n+\t\t\tt.Errorf(\"no-opt ParseFloat(%s) = %b, %v want %b, nil\", tt.s, f, err, tt.f)\n+\t\t}\n+\t\tSetOptimize(true)\n+\t\ts = FormatFloat(tt.f, 'g', -1, 64)\n+\t\tif s != tt.s {\n+\t\t\tt.Errorf(\"opt FormatFloat(%b) = %s, want %s\", tt.f, s, tt.s)\n+\t\t}\n+\t\tf, err = ParseFloat(tt.s, 64)\n+\t\tif f != tt.f || err != nil {\n+\t\t\tt.Errorf(\"opt ParseFloat(%s) = %b, %v want %b, nil\", tt.s, f, err, tt.f)\n+\t\t}\n+\t\tSetOptimize(old)\n+\t}\n+}\n+\n func BenchmarkAtof64Decimal(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tParseFloat(\"33909\", 64)"}, {"sha": "a75071dcc46507ff0ef907244c09b53429bc1385", "filename": "libgo/go/strconv/decimal.go", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrconv%2Fdecimal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrconv%2Fdecimal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fdecimal.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,12 +12,11 @@\n package strconv\n \n type decimal struct {\n-\t// TODO(rsc): Can make d[] a bit smaller and add\n-\t// truncated bool;\n-\td   [800]byte // digits\n-\tnd  int       // number of digits used\n-\tdp  int       // decimal point\n-\tneg bool\n+\td     [800]byte // digits\n+\tnd    int       // number of digits used\n+\tdp    int       // decimal point\n+\tneg   bool\n+\ttrunc bool // discarded nonzero digits beyond d[:nd]\n }\n \n func (a *decimal) String() string {\n@@ -145,8 +144,12 @@ func rightShift(a *decimal, k uint) {\n \tfor n > 0 {\n \t\tdig := n >> k\n \t\tn -= dig << k\n-\t\ta.d[w] = byte(dig + '0')\n-\t\tw++\n+\t\tif w < len(a.d) {\n+\t\t\ta.d[w] = byte(dig + '0')\n+\t\t\tw++\n+\t\t} else if dig > 0 {\n+\t\t\ta.trunc = true\n+\t\t}\n \t\tn = n * 10\n \t}\n \n@@ -242,7 +245,11 @@ func leftShift(a *decimal, k uint) {\n \t\tquo := n / 10\n \t\trem := n - 10*quo\n \t\tw--\n-\t\ta.d[w] = byte(rem + '0')\n+\t\tif w < len(a.d) {\n+\t\t\ta.d[w] = byte(rem + '0')\n+\t\t} else if rem != 0 {\n+\t\t\ta.trunc = true\n+\t\t}\n \t\tn = quo\n \t}\n \n@@ -251,11 +258,18 @@ func leftShift(a *decimal, k uint) {\n \t\tquo := n / 10\n \t\trem := n - 10*quo\n \t\tw--\n-\t\ta.d[w] = byte(rem + '0')\n+\t\tif w < len(a.d) {\n+\t\t\ta.d[w] = byte(rem + '0')\n+\t\t} else if rem != 0 {\n+\t\t\ta.trunc = true\n+\t\t}\n \t\tn = quo\n \t}\n \n \ta.nd += delta\n+\tif a.nd >= len(a.d) {\n+\t\ta.nd = len(a.d)\n+\t}\n \ta.dp += delta\n \ttrim(a)\n }\n@@ -286,14 +300,17 @@ func shouldRoundUp(a *decimal, nd int) bool {\n \t\treturn false\n \t}\n \tif a.d[nd] == '5' && nd+1 == a.nd { // exactly halfway - round to even\n+\t\t// if we truncated, a little higher than what's recorded - always round up\n+\t\tif a.trunc {\n+\t\t\treturn true\n+\t\t}\n \t\treturn nd > 0 && (a.d[nd-1]-'0')%2 != 0\n \t}\n \t// not halfway - digit tells all\n \treturn a.d[nd] >= '5'\n }\n \n // Round a to nd digits (or fewer).\n-// Returns receiver for convenience.\n // If nd is zero, it means we're rounding\n // just to the left of the digits, as in\n // 0.09 -> 0.1.\n@@ -309,7 +326,6 @@ func (a *decimal) Round(nd int) {\n }\n \n // Round a down to nd digits (or fewer).\n-// Returns receiver for convenience.\n func (a *decimal) RoundDown(nd int) {\n \tif nd < 0 || nd >= a.nd {\n \t\treturn\n@@ -319,7 +335,6 @@ func (a *decimal) RoundDown(nd int) {\n }\n \n // Round a up to nd digits (or fewer).\n-// Returns receiver for convenience.\n func (a *decimal) RoundUp(nd int) {\n \tif nd < 0 || nd >= a.nd {\n \t\treturn"}, {"sha": "5ef0b93d15e5d6ef9b3fc3c8a8707ac15d95b5d0", "filename": "libgo/go/strings/example_test.go", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -13,3 +13,160 @@ import (\n func ExampleFields() {\n \tfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \"))\n }\n+\n+// true\n+// false\n+// true\n+// true\n+func ExampleContains() {\n+\tfmt.Println(strings.Contains(\"seafood\", \"foo\"))\n+\tfmt.Println(strings.Contains(\"seafood\", \"bar\"))\n+\tfmt.Println(strings.Contains(\"seafood\", \"\"))\n+\tfmt.Println(strings.Contains(\"\", \"\"))\n+}\n+\n+// false\n+// true\n+// false\n+// false\n+func ExampleContainsAny() {\n+\tfmt.Println(strings.ContainsAny(\"team\", \"i\"))\n+\tfmt.Println(strings.ContainsAny(\"failure\", \"u & i\"))\n+\tfmt.Println(strings.ContainsAny(\"foo\", \"\"))\n+\tfmt.Println(strings.ContainsAny(\"\", \"\"))\n+\n+}\n+\n+// 3\n+// 5\n+func ExampleCount() {\n+\tfmt.Println(strings.Count(\"cheese\", \"e\"))\n+\tfmt.Println(strings.Count(\"five\", \"\")) // before & after each rune\n+}\n+\n+// true\n+func ExampleEqualFold() {\n+\tfmt.Println(strings.EqualFold(\"Go\", \"go\"))\n+}\n+\n+// 4\n+// -1\n+func ExampleIndex() {\n+\tfmt.Println(strings.Index(\"chicken\", \"ken\"))\n+\tfmt.Println(strings.Index(\"chicken\", \"dmr\"))\n+}\n+\n+// 4\n+// -1\n+func ExampleRune() {\n+\tfmt.Println(strings.IndexRune(\"chicken\", 'k'))\n+\tfmt.Println(strings.IndexRune(\"chicken\", 'd'))\n+}\n+\n+// 0\n+// 3\n+// -1\n+func ExampleLastIndex() {\n+\tfmt.Println(strings.Index(\"go gopher\", \"go\"))\n+\tfmt.Println(strings.LastIndex(\"go gopher\", \"go\"))\n+\tfmt.Println(strings.LastIndex(\"go gopher\", \"rodent\"))\n+}\n+\n+// foo, bar, baz\n+func ExampleJoin() {\n+\ts := []string{\"foo\", \"bar\", \"baz\"}\n+\tfmt.Println(strings.Join(s, \", \"))\n+}\n+\n+// banana\n+func ExampleRepeat() {\n+\tfmt.Println(\"ba\" + strings.Repeat(\"na\", 2))\n+}\n+\n+// oinky oinky oink\n+// moo moo moo\n+func ExampleReplace() {\n+\tfmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2))\n+\tfmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1))\n+}\n+\n+// [\"a\" \"b\" \"c\"]\n+// [\"\" \"man \" \"plan \" \"canal panama\"]\n+// [\" \" \"x\" \"y\" \"z\" \" \"]\n+// [\"\"]\n+func ExampleSplit() {\n+\tfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))\n+\tfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))\n+\tfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))\n+\tfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))\n+}\n+\n+// [\"a\" \"b,c\"]\n+// [] (nil = true)\n+func ExampleSplitN() {\n+\tfmt.Printf(\"%q\\n\", strings.SplitN(\"a,b,c\", \",\", 2))\n+\tz := strings.SplitN(\"a,b,c\", \",\", 0)\n+\tfmt.Printf(\"%q (nil = %v)\\n\", z, z == nil)\n+}\n+\n+// [\"a,\" \"b,\" \"c\"]\n+func ExampleSplitAfter() {\n+\tfmt.Printf(\"%q\\n\", strings.SplitAfter(\"a,b,c\", \",\"))\n+}\n+\n+// [\"a,\" \"b,c\"]\n+func ExampleSplitAfterN() {\n+\tfmt.Printf(\"%q\\n\", strings.SplitAfterN(\"a,b,c\", \",\", 2))\n+}\n+\n+// Her Royal Highness\n+func ExampleTitle() {\n+\tfmt.Println(strings.Title(\"her royal highness\"))\n+}\n+\n+// LOUD NOISES\n+// \u0425\u041b\u0415\u0411\n+func ExampleToTitle() {\n+\tfmt.Println(strings.ToTitle(\"loud noises\"))\n+\tfmt.Println(strings.ToTitle(\"\u0445\u043b\u0435\u0431\"))\n+}\n+\n+// [Achtung]\n+func ExampleTrim() {\n+\tfmt.Printf(\"[%s]\", strings.Trim(\" !!! Achtung !!! \", \"! \"))\n+}\n+\n+// 'Gjnf oevyyvt naq gur fyvgul tbcure...\n+func ExampleMap() {\n+\trot13 := func(r rune) rune {\n+\t\tswitch {\n+\t\tcase r >= 'A' && r <= 'Z':\n+\t\t\treturn 'A' + (r-'A'+13)%26\n+\t\tcase r >= 'a' && r <= 'z':\n+\t\t\treturn 'a' + (r-'a'+13)%26\n+\t\t}\n+\t\treturn r\n+\t}\n+\tfmt.Println(strings.Map(rot13, \"'Twas brillig and the slithy gopher...\"))\n+}\n+\n+// a lone gopher\n+func ExampleTrimSpace() {\n+\tfmt.Println(strings.TrimSpace(\" \\t\\n a lone gopher \\n\\t\\r\\n\"))\n+}\n+\n+// This is &lt;b&gt;HTML&lt;/b&gt;!\n+func ExampleNewReplacer() {\n+\tr := strings.NewReplacer(\"<\", \"&lt;\", \">\", \"&gt;\")\n+\tfmt.Println(r.Replace(\"This is <b>HTML</b>!\"))\n+}\n+\n+// GOPHER\n+func ExampleToUpper() {\n+\tfmt.Println(strings.ToUpper(\"Gopher\"))\n+}\n+\n+// gopher\n+func ExampleToLower() {\n+\tfmt.Println(strings.ToLower(\"Gopher\"))\n+}"}, {"sha": "8569805552d639febfd129bfe5d62924dc57d66b", "filename": "libgo/go/strings/reader.go", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrings%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrings%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -10,8 +10,9 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// A Reader implements the io.Reader, io.ByteScanner, and\n-// io.RuneScanner interfaces by reading from a string.\n+// A Reader implements the io.Reader, io.ReaderAt, io.Seeker,\n+// io.ByteScanner, and io.RuneScanner interfaces by reading\n+// from a string.\n type Reader struct {\n \ts        string\n \ti        int // current reading index\n@@ -21,10 +22,16 @@ type Reader struct {\n // Len returns the number of bytes of the unread portion of the\n // string.\n func (r *Reader) Len() int {\n+\tif r.i >= len(r.s) {\n+\t\treturn 0\n+\t}\n \treturn len(r.s) - r.i\n }\n \n func (r *Reader) Read(b []byte) (n int, err error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, nil\n+\t}\n \tif r.i >= len(r.s) {\n \t\treturn 0, io.EOF\n \t}\n@@ -34,6 +41,20 @@ func (r *Reader) Read(b []byte) (n int, err error) {\n \treturn\n }\n \n+func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {\n+\tif off < 0 {\n+\t\treturn 0, errors.New(\"strings: invalid offset\")\n+\t}\n+\tif off >= int64(len(r.s)) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tn = copy(b, r.s[int(off):])\n+\tif n < len(b) {\n+\t\terr = io.EOF\n+\t}\n+\treturn\n+}\n+\n func (r *Reader) ReadByte() (b byte, err error) {\n \tif r.i >= len(r.s) {\n \t\treturn 0, io.EOF\n@@ -44,9 +65,6 @@ func (r *Reader) ReadByte() (b byte, err error) {\n \treturn\n }\n \n-// UnreadByte moves the reading position back by one byte.\n-// It is an error to call UnreadByte if nothing has been\n-// read yet.\n func (r *Reader) UnreadByte() error {\n \tif r.i <= 0 {\n \t\treturn errors.New(\"strings.Reader: at beginning of string\")\n@@ -56,11 +74,6 @@ func (r *Reader) UnreadByte() error {\n \treturn nil\n }\n \n-// ReadRune reads and returns the next UTF-8-encoded\n-// Unicode code point from the buffer.\n-// If no bytes are available, the error returned is io.EOF.\n-// If the bytes are an erroneous UTF-8 encoding, it\n-// consumes one byte and returns U+FFFD, 1.\n func (r *Reader) ReadRune() (ch rune, size int, err error) {\n \tif r.i >= len(r.s) {\n \t\treturn 0, 0, io.EOF\n@@ -75,9 +88,6 @@ func (r *Reader) ReadRune() (ch rune, size int, err error) {\n \treturn\n }\n \n-// UnreadRune causes the next call to ReadRune to return the same rune\n-// as the previous call to ReadRune.\n-// The last method called on r must have been ReadRune.\n func (r *Reader) UnreadRune() error {\n \tif r.prevRune < 0 {\n \t\treturn errors.New(\"strings.Reader: previous operation was not ReadRune\")\n@@ -87,6 +97,29 @@ func (r *Reader) UnreadRune() error {\n \treturn nil\n }\n \n+// Seek implements the io.Seeker interface.\n+func (r *Reader) Seek(offset int64, whence int) (int64, error) {\n+\tvar abs int64\n+\tswitch whence {\n+\tcase 0:\n+\t\tabs = offset\n+\tcase 1:\n+\t\tabs = int64(r.i) + offset\n+\tcase 2:\n+\t\tabs = int64(len(r.s)) + offset\n+\tdefault:\n+\t\treturn 0, errors.New(\"strings: invalid whence\")\n+\t}\n+\tif abs < 0 {\n+\t\treturn 0, errors.New(\"strings: negative position\")\n+\t}\n+\tif abs >= 1<<31 {\n+\t\treturn 0, errors.New(\"strings: position out of range\")\n+\t}\n+\tr.i = int(abs)\n+\treturn abs, nil\n+}\n+\n // NewReader returns a new Reader reading from s.\n // It is similar to bytes.NewBufferString but more efficient and read-only.\n func NewReader(s string) *Reader { return &Reader{s, 0, -1} }"}, {"sha": "a99ae2a0ea600fcd0c82c2837c9bccdea15148fb", "filename": "libgo/go/strings/reader_test.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrings%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fstrings%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package strings_test\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestReader(t *testing.T) {\n+\tr := strings.NewReader(\"0123456789\")\n+\ttests := []struct {\n+\t\toff     int64\n+\t\tseek    int\n+\t\tn       int\n+\t\twant    string\n+\t\twantpos int64\n+\t\tseekerr string\n+\t}{\n+\t\t{seek: os.SEEK_SET, off: 0, n: 20, want: \"0123456789\"},\n+\t\t{seek: os.SEEK_SET, off: 1, n: 1, want: \"1\"},\n+\t\t{seek: os.SEEK_CUR, off: 1, wantpos: 3, n: 2, want: \"34\"},\n+\t\t{seek: os.SEEK_SET, off: -1, seekerr: \"strings: negative position\"},\n+\t\t{seek: os.SEEK_SET, off: 1<<31 - 1},\n+\t\t{seek: os.SEEK_CUR, off: 1, seekerr: \"strings: position out of range\"},\n+\t\t{seek: os.SEEK_SET, n: 5, want: \"01234\"},\n+\t\t{seek: os.SEEK_CUR, n: 5, want: \"56789\"},\n+\t\t{seek: os.SEEK_END, off: -1, n: 1, wantpos: 9, want: \"9\"},\n+\t}\n+\n+\tfor i, tt := range tests {\n+\t\tpos, err := r.Seek(tt.off, tt.seek)\n+\t\tif err == nil && tt.seekerr != \"\" {\n+\t\t\tt.Errorf(\"%d. want seek error %q\", i, tt.seekerr)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil && err.Error() != tt.seekerr {\n+\t\t\tt.Errorf(\"%d. seek error = %q; want %q\", i, err.Error(), tt.seekerr)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tt.wantpos != 0 && tt.wantpos != pos {\n+\t\t\tt.Errorf(\"%d. pos = %d, want %d\", i, pos, tt.wantpos)\n+\t\t}\n+\t\tbuf := make([]byte, tt.n)\n+\t\tn, err := r.Read(buf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d. read = %v\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tgot := string(buf[:n])\n+\t\tif got != tt.want {\n+\t\t\tt.Errorf(\"%d. got %q; want %q\", i, got, tt.want)\n+\t\t}\n+\t}\n+}\n+\n+func TestReaderAt(t *testing.T) {\n+\tr := strings.NewReader(\"0123456789\")\n+\ttests := []struct {\n+\t\toff     int64\n+\t\tn       int\n+\t\twant    string\n+\t\twanterr interface{}\n+\t}{\n+\t\t{0, 10, \"0123456789\", nil},\n+\t\t{1, 10, \"123456789\", io.EOF},\n+\t\t{1, 9, \"123456789\", nil},\n+\t\t{11, 10, \"\", io.EOF},\n+\t\t{0, 0, \"\", nil},\n+\t\t{-1, 0, \"\", \"strings: invalid offset\"},\n+\t}\n+\tfor i, tt := range tests {\n+\t\tb := make([]byte, tt.n)\n+\t\trn, err := r.ReadAt(b, tt.off)\n+\t\tgot := string(b[:rn])\n+\t\tif got != tt.want {\n+\t\t\tt.Errorf(\"%d. got %q; want %q\", i, got, tt.want)\n+\t\t}\n+\t\tif fmt.Sprintf(\"%v\", err) != fmt.Sprintf(\"%v\", tt.wanterr) {\n+\t\t\tt.Errorf(\"%d. got error = %v; want %v\", i, err, tt.wanterr)\n+\t\t}\n+\t}\n+}"}, {"sha": "a514b4ad4c02a8086e4bb4a09b40217318eb74bb", "filename": "libgo/go/sync/mutex_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsync%2Fmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsync%2Fmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// GOMAXPROCS=10 gotest\n+// GOMAXPROCS=10 go test\n \n package sync_test\n "}, {"sha": "39d5d6540de7853680e6f813983508436ea1fab6", "filename": "libgo/go/sync/rwmutex_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsync%2Frwmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsync%2Frwmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Frwmutex_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// GOMAXPROCS=10 gotest\n+// GOMAXPROCS=10 go test\n \n package sync_test\n "}, {"sha": "f1f7a188de2183dab44afe27e4f2b417773bb60b", "filename": "libgo/go/syscall/exec_bsd.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -38,8 +38,10 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t\ti      int\n \t)\n \n-\t// guard against side effects of shuffling fds below.\n-\tfd := append([]int(nil), attr.Files...)\n+\tfd := make([]int, len(attr.Files))\n+\tfor i, ufd := range attr.Files {\n+\t\tfd[i] = int(ufd)\n+\t}\n \n \t// About to call fork.\n \t// No more allocation or calls of non-assembly functions."}, {"sha": "a6c4427a59fc97a34b173498d4bf68a931396a10", "filename": "libgo/go/syscall/exec_linux.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_linux.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -21,7 +21,7 @@ type SysProcAttr struct {\n \tSetpgid    bool        // Set process group ID to new pid (SYSV setpgrp)\n \tSetctty    bool        // Set controlling terminal to fd 0\n \tNoctty     bool        // Detach fd 0 from controlling terminal\n-\tPdeathsig  int         // Signal that the process will get when its parent dies (Linux only)\n+\tPdeathsig  Signal      // Signal that the process will get when its parent dies (Linux only)\n }\n \n // Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n@@ -43,7 +43,10 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t)\n \n \t// guard against side effects of shuffling fds below.\n-\tfd := append([]int(nil), attr.Files...)\n+\tfd := make([]int, len(attr.Files))\n+\tfor i, ufd := range attr.Files {\n+\t\tfd[i] = int(ufd)\n+\t}\n \n \t// About to call fork.\n \t// No more allocation or calls of non-assembly functions.\n@@ -61,7 +64,7 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \n \t// Parent death signal\n \tif sys.Pdeathsig != 0 {\n-\t\t_, err1 = raw_prctl(PR_SET_PDEATHSIG, sys.Pdeathsig, 0, 0, 0)\n+\t\t_, err1 = raw_prctl(PR_SET_PDEATHSIG, int(sys.Pdeathsig), 0, 0, 0)\n \t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}"}, {"sha": "664908d1310175373fa629b77665613bd1482474", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -141,9 +141,9 @@ type Credential struct {\n // ProcAttr holds attributes that will be applied to a new process started\n // by StartProcess.\n type ProcAttr struct {\n-\tDir   string   // Current working directory.\n-\tEnv   []string // Environment.\n-\tFiles []int    // File descriptors.\n+\tDir   string    // Current working directory.\n+\tEnv   []string  // Environment.\n+\tFiles []uintptr // File descriptors.\n \tSys   *SysProcAttr\n }\n "}, {"sha": "4dc4d059d7e307bf16e376b5e22651fdeaff9045", "filename": "libgo/go/syscall/exec_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_windows.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -220,7 +220,7 @@ func joinExeDirAndFName(dir, p string) (name string, err error) {\n type ProcAttr struct {\n \tDir   string\n \tEnv   []string\n-\tFiles []Handle\n+\tFiles []uintptr\n \tSys   *SysProcAttr\n }\n "}, {"sha": "bb960731f752435628c4de64d038561007eb7031", "filename": "libgo/go/syscall/libcall_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -335,7 +335,7 @@ func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n i\n //sys\tTee(rfd int, wfd int, len int, flags int) (n int64, err error)\n //tee(rfd int, wfd int, len Size_t, flags uint) Ssize_t\n \n-func Tgkill(tgid, tid, sig int) error {\n+func Tgkill(tgid, tid, sig Signal) error {\n \tr1, _, errno := Syscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))\n \tif r1 < 0 {\n \t\treturn errno"}, {"sha": "92feae0c1021e12f541c4bc8154c8ae0dbd820df", "filename": "libgo/go/syscall/libcall_posix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -128,8 +128,8 @@ func (w WaitStatus) Stopped() bool\n func (w WaitStatus) Continued() bool\n func (w WaitStatus) CoreDump() bool\n func (w WaitStatus) ExitStatus() int\n-func (w WaitStatus) Signal() int\n-func (w WaitStatus) StopSignal() int\n+func (w WaitStatus) Signal() Signal\n+func (w WaitStatus) StopSignal() Signal\n func (w WaitStatus) TrapCause() int\n \n //sys\tMkfifo(path string, mode uint32) (err error)\n@@ -253,7 +253,7 @@ func Gettimeofday(tv *Timeval) (err error) {\n //sysnb Getuid() (uid int)\n //getuid() Uid_t\n \n-//sysnb\tKill(pid int, sig int) (err error)\n+//sysnb\tKill(pid int, sig Signal) (err error)\n //kill(pid Pid_t, sig int) int\n \n //sys\tLchown(path string, uid int, gid int) (err error)"}, {"sha": "f2ff85a9a02ddd4161327c29481c3d3f7d3ad94a", "filename": "libgo/go/syscall/signame.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fsigname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fsigname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsigname.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,40 @@\n+/* signame.c -- get the name of a signal\n+\n+   Copyright 2012 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include <string.h>\n+\n+#include \"config.h\"\n+#include \"runtime.h\"\n+#include \"arch.h\"\n+#include \"malloc.h\"\n+\n+String Signame (int sig) asm (\"libgo_syscall.syscall.Signame\");\n+\n+String\n+Signame (int sig)\n+{\n+  const char* s = NULL;\n+  char buf[100];\n+  size_t len;\n+  unsigned char *data;\n+  String ret;\n+\n+#if defined(HAVE_STRSIGNAL)\n+  s = strsignal (sig);\n+#endif\n+\n+  if (s == NULL)\n+    {\n+      snprintf(buf, sizeof buf, \"signal %d\", sig);\n+      s = buf;\n+    }\n+  len = __builtin_strlen (s);\n+  data = runtime_mallocgc (len, FlagNoPointers, 0, 0);\n+  __builtin_memcpy (data, s, len);\n+  ret.__data = data;\n+  ret.__length = len;\n+  return ret;\n+}"}, {"sha": "85182b764b0c21e22b10f693abad9e1de8bf0cea", "filename": "libgo/go/syscall/syscall_unix.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -163,3 +163,15 @@ func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, e\n func Munmap(b []byte) (err error) {\n \treturn mapper.Munmap(b)\n }\n+\n+// A Signal is a number describing a process signal.\n+// It implements the os.Signal interface.\n+type Signal int\n+\n+func (s Signal) Signal() {}\n+\n+func Signame(s Signal) string\n+\n+func (s Signal) String() string {\n+\treturn Signame(s)\n+}"}, {"sha": "41290594ee27033eadea3fa56749b8589592164d", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -16,7 +16,7 @@ var matchBenchmarks = flag.String(\"test.bench\", \"\", \"regular expression to selec\n var benchTime = flag.Float64(\"test.benchtime\", 1, \"approximate run time for each benchmark, in seconds\")\n \n // An internal type but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of the \"go test\" command.\n type InternalBenchmark struct {\n \tName string\n \tF    func(b *B)\n@@ -213,7 +213,7 @@ func (r BenchmarkResult) String() string {\n }\n \n // An internal function but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of the \"go test\" command.\n func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) {\n \t// If no flag was specified, don't run benchmarks.\n \tif len(*matchBenchmarks) == 0 {\n@@ -281,7 +281,7 @@ func (b *B) trimOutput() {\n }\n \n // Benchmark benchmarks a single function. Useful for creating\n-// custom benchmarks that do not use gotest.\n+// custom benchmarks that do not use the \"go test\" command.\n func Benchmark(f func(b *B)) BenchmarkResult {\n \tb := &B{\n \t\tcommon: common{"}, {"sha": "441b9102d94d7a59623efa72bbf9cebea8af9ec1", "filename": "libgo/go/testing/iotest/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Fiotest%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Fiotest%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fiotest%2Freader.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package iotest implements Readers and Writers useful only for testing.\n+// Package iotest implements Readers and Writers useful mainly for testing.\n package iotest\n \n import ("}, {"sha": "2427098228170cabffb27dcd746a5e8a1d69e4da", "filename": "libgo/go/testing/quick/quick.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Fquick%2Fquick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Fquick%2Fquick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fquick%2Fquick.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -50,7 +50,7 @@ const complexSize = 50\n \n // Value returns an arbitrary value of the given type.\n // If the type implements the Generator interface, that will be used.\n-// Note: in order to create arbitrary values for structs, all the members must be public.\n+// Note: To create arbitrary values for structs, all the fields must be exported.\n func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {\n \tif m, ok := reflect.Zero(t).Interface().(Generator); ok {\n \t\treturn m.Generate(rand, complexSize), true\n@@ -155,9 +155,10 @@ type Config struct {\n \t// If non-nil, rand is a source of random numbers. Otherwise a default\n \t// pseudo-random source will be used.\n \tRand *rand.Rand\n-\t// If non-nil, Values is a function which generates a slice of arbitrary\n-\t// Values that are congruent with the arguments to the function being\n-\t// tested. Otherwise, Values is used to generate the values.\n+\t// If non-nil, the Values function generates a slice of arbitrary\n+\t// reflect.Values that are congruent with the arguments to the function\n+\t// being tested. Otherwise, the top-level Values function is used\n+\t// to generate them.\n \tValues func([]reflect.Value, *rand.Rand)\n }\n "}, {"sha": "d8f8093af9034006c604733e8f274e1e5f26155e", "filename": "libgo/go/testing/script/script.go", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Ftesting%2Fscript%2Fscript.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Ftesting%2Fscript%2Fscript.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fscript%2Fscript.go?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,358 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package script aids in the testing of code that uses channels.\n-package script\n-\n-import (\n-\t\"fmt\"\n-\t\"math/rand\"\n-\t\"reflect\"\n-\t\"strings\"\n-)\n-\n-// An Event is an element in a partially ordered set that either sends a value\n-// to a channel or expects a value from a channel.\n-type Event struct {\n-\tname         string\n-\toccurred     bool\n-\tpredecessors []*Event\n-\taction       action\n-}\n-\n-type action interface {\n-\t// getSend returns nil if the action is not a send action.\n-\tgetSend() sendAction\n-\t// getRecv returns nil if the action is not a receive action.\n-\tgetRecv() recvAction\n-\t// getChannel returns the channel that the action operates on.\n-\tgetChannel() interface{}\n-}\n-\n-type recvAction interface {\n-\trecvMatch(interface{}) bool\n-}\n-\n-type sendAction interface {\n-\tsend()\n-}\n-\n-// isReady returns true if all the predecessors of an Event have occurred.\n-func (e Event) isReady() bool {\n-\tfor _, predecessor := range e.predecessors {\n-\t\tif !predecessor.occurred {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\n-\treturn true\n-}\n-\n-// A Recv action reads a value from a channel and uses reflect.DeepMatch to\n-// compare it with an expected value.\n-type Recv struct {\n-\tChannel  interface{}\n-\tExpected interface{}\n-}\n-\n-func (r Recv) getRecv() recvAction { return r }\n-\n-func (Recv) getSend() sendAction { return nil }\n-\n-func (r Recv) getChannel() interface{} { return r.Channel }\n-\n-func (r Recv) recvMatch(chanEvent interface{}) bool {\n-\tc, ok := chanEvent.(channelRecv)\n-\tif !ok || c.channel != r.Channel {\n-\t\treturn false\n-\t}\n-\n-\treturn reflect.DeepEqual(c.value, r.Expected)\n-}\n-\n-// A RecvMatch action reads a value from a channel and calls a function to\n-// determine if the value matches.\n-type RecvMatch struct {\n-\tChannel interface{}\n-\tMatch   func(interface{}) bool\n-}\n-\n-func (r RecvMatch) getRecv() recvAction { return r }\n-\n-func (RecvMatch) getSend() sendAction { return nil }\n-\n-func (r RecvMatch) getChannel() interface{} { return r.Channel }\n-\n-func (r RecvMatch) recvMatch(chanEvent interface{}) bool {\n-\tc, ok := chanEvent.(channelRecv)\n-\tif !ok || c.channel != r.Channel {\n-\t\treturn false\n-\t}\n-\n-\treturn r.Match(c.value)\n-}\n-\n-// A Closed action matches if the given channel is closed. The closing is\n-// treated as an event, not a state, thus Closed will only match once for a\n-// given channel.\n-type Closed struct {\n-\tChannel interface{}\n-}\n-\n-func (r Closed) getRecv() recvAction { return r }\n-\n-func (Closed) getSend() sendAction { return nil }\n-\n-func (r Closed) getChannel() interface{} { return r.Channel }\n-\n-func (r Closed) recvMatch(chanEvent interface{}) bool {\n-\tc, ok := chanEvent.(channelClosed)\n-\tif !ok || c.channel != r.Channel {\n-\t\treturn false\n-\t}\n-\n-\treturn true\n-}\n-\n-// A Send action sends a value to a channel. The value must match the\n-// type of the channel exactly unless the channel if of type chan interface{}.\n-type Send struct {\n-\tChannel interface{}\n-\tValue   interface{}\n-}\n-\n-func (Send) getRecv() recvAction { return nil }\n-\n-func (s Send) getSend() sendAction { return s }\n-\n-func (s Send) getChannel() interface{} { return s.Channel }\n-\n-type empty struct {\n-\tx interface{}\n-}\n-\n-func newEmptyInterface(e empty) reflect.Value {\n-\treturn reflect.ValueOf(e).Field(0)\n-}\n-\n-func (s Send) send() {\n-\t// With reflect.ChanValue.Send, we must match the types exactly. So, if\n-\t// s.Channel is a chan interface{} we convert s.Value to an interface{}\n-\t// first.\n-\tc := reflect.ValueOf(s.Channel)\n-\tvar v reflect.Value\n-\tif iface := c.Type().Elem(); iface.Kind() == reflect.Interface && iface.NumMethod() == 0 {\n-\t\tv = newEmptyInterface(empty{s.Value})\n-\t} else {\n-\t\tv = reflect.ValueOf(s.Value)\n-\t}\n-\tc.Send(v)\n-}\n-\n-// A Close action closes the given channel.\n-type Close struct {\n-\tChannel interface{}\n-}\n-\n-func (Close) getRecv() recvAction { return nil }\n-\n-func (s Close) getSend() sendAction { return s }\n-\n-func (s Close) getChannel() interface{} { return s.Channel }\n-\n-func (s Close) send() { reflect.ValueOf(s.Channel).Close() }\n-\n-// A ReceivedUnexpected error results if no active Events match a value\n-// received from a channel.\n-type ReceivedUnexpected struct {\n-\tValue interface{}\n-\tready []*Event\n-}\n-\n-func (r ReceivedUnexpected) Error() string {\n-\tnames := make([]string, len(r.ready))\n-\tfor i, v := range r.ready {\n-\t\tnames[i] = v.name\n-\t}\n-\treturn fmt.Sprintf(\"received unexpected value on one of the channels: %#v. Runnable events: %s\", r.Value, strings.Join(names, \", \"))\n-}\n-\n-// A SetupError results if there is a error with the configuration of a set of\n-// Events.\n-type SetupError string\n-\n-func (s SetupError) Error() string { return string(s) }\n-\n-func NewEvent(name string, predecessors []*Event, action action) *Event {\n-\te := &Event{name, false, predecessors, action}\n-\treturn e\n-}\n-\n-// Given a set of Events, Perform repeatedly iterates over the set and finds the\n-// subset of ready Events (that is, all of their predecessors have\n-// occurred). From that subset, it pseudo-randomly selects an Event to perform.\n-// If the Event is a send event, the send occurs and Perform recalculates the ready\n-// set. If the event is a receive event, Perform waits for a value from any of the\n-// channels that are contained in any of the events. That value is then matched\n-// against the ready events. The first event that matches is considered to\n-// have occurred and Perform recalculates the ready set.\n-//\n-// Perform continues this until all Events have occurred.\n-//\n-// Note that uncollected goroutines may still be reading from any of the\n-// channels read from after Perform returns.\n-//\n-// For example, consider the problem of testing a function that reads values on\n-// one channel and echos them to two output channels. To test this we would\n-// create three events: a send event and two receive events. Each of the\n-// receive events must list the send event as a predecessor but there is no\n-// ordering between the receive events.\n-//\n-//  send := NewEvent(\"send\", nil, Send{c, 1})\n-//  recv1 := NewEvent(\"recv 1\", []*Event{send}, Recv{c, 1})\n-//  recv2 := NewEvent(\"recv 2\", []*Event{send}, Recv{c, 1})\n-//  Perform(0, []*Event{send, recv1, recv2})\n-//\n-// At first, only the send event would be in the ready set and thus Perform will\n-// send a value to the input channel. Now the two receive events are ready and\n-// Perform will match each of them against the values read from the output channels.\n-//\n-// It would be invalid to list one of the receive events as a predecessor of\n-// the other. At each receive step, all the receive channels are considered,\n-// thus Perform may see a value from a channel that is not in the current ready\n-// set and fail.\n-func Perform(seed int64, events []*Event) (err error) {\n-\tr := rand.New(rand.NewSource(seed))\n-\n-\tchannels, err := getChannels(events)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tmultiplex := make(chan interface{})\n-\tfor _, channel := range channels {\n-\t\tgo recvValues(multiplex, channel)\n-\t}\n-\n-Outer:\n-\tfor {\n-\t\tready, err := readyEvents(events)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\n-\t\tif len(ready) == 0 {\n-\t\t\t// All events occurred.\n-\t\t\tbreak\n-\t\t}\n-\n-\t\tevent := ready[r.Intn(len(ready))]\n-\t\tif send := event.action.getSend(); send != nil {\n-\t\t\tsend.send()\n-\t\t\tevent.occurred = true\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tv := <-multiplex\n-\t\tfor _, event := range ready {\n-\t\t\tif recv := event.action.getRecv(); recv != nil && recv.recvMatch(v) {\n-\t\t\t\tevent.occurred = true\n-\t\t\t\tcontinue Outer\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn ReceivedUnexpected{v, ready}\n-\t}\n-\n-\treturn nil\n-}\n-\n-// getChannels returns all the channels listed in any receive events.\n-func getChannels(events []*Event) ([]interface{}, error) {\n-\tchannels := make([]interface{}, len(events))\n-\n-\tj := 0\n-\tfor _, event := range events {\n-\t\tif recv := event.action.getRecv(); recv == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tc := event.action.getChannel()\n-\t\tif reflect.ValueOf(c).Kind() != reflect.Chan {\n-\t\t\treturn nil, SetupError(\"one of the channel values is not a channel\")\n-\t\t}\n-\n-\t\tduplicate := false\n-\t\tfor _, other := range channels[0:j] {\n-\t\t\tif c == other {\n-\t\t\t\tduplicate = true\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\n-\t\tif !duplicate {\n-\t\t\tchannels[j] = c\n-\t\t\tj++\n-\t\t}\n-\t}\n-\n-\treturn channels[0:j], nil\n-}\n-\n-// recvValues is a multiplexing helper function. It reads values from the given\n-// channel repeatedly, wrapping them up as either a channelRecv or\n-// channelClosed structure, and forwards them to the multiplex channel.\n-func recvValues(multiplex chan<- interface{}, channel interface{}) {\n-\tc := reflect.ValueOf(channel)\n-\n-\tfor {\n-\t\tv, ok := c.Recv()\n-\t\tif !ok {\n-\t\t\tmultiplex <- channelClosed{channel}\n-\t\t\treturn\n-\t\t}\n-\n-\t\tmultiplex <- channelRecv{channel, v.Interface()}\n-\t}\n-}\n-\n-type channelClosed struct {\n-\tchannel interface{}\n-}\n-\n-type channelRecv struct {\n-\tchannel interface{}\n-\tvalue   interface{}\n-}\n-\n-// readyEvents returns the subset of events that are ready.\n-func readyEvents(events []*Event) ([]*Event, error) {\n-\tready := make([]*Event, len(events))\n-\n-\tj := 0\n-\teventsWaiting := false\n-\tfor _, event := range events {\n-\t\tif event.occurred {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\teventsWaiting = true\n-\t\tif event.isReady() {\n-\t\t\tready[j] = event\n-\t\t\tj++\n-\t\t}\n-\t}\n-\n-\tif j == 0 && eventsWaiting {\n-\t\tnames := make([]string, len(events))\n-\t\tfor _, event := range events {\n-\t\t\tif event.occurred {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tnames[j] = event.name\n-\t\t}\n-\n-\t\treturn nil, SetupError(\"dependency cycle in events. These events are waiting to run but cannot: \" + strings.Join(names, \", \"))\n-\t}\n-\n-\treturn ready[0:j], nil\n-}"}, {"sha": "e9ab142c2b1b5f8237187385d3c16a10b2e8848a", "filename": "libgo/go/testing/script/script_test.go", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Ftesting%2Fscript%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fgo%2Ftesting%2Fscript%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fscript%2Fscript_test.go?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,75 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package script\n-\n-import (\n-\t\"testing\"\n-)\n-\n-func TestNoop(t *testing.T) {\n-\terr := Perform(0, nil)\n-\tif err != nil {\n-\t\tt.Errorf(\"Got error: %s\", err)\n-\t}\n-}\n-\n-func TestSimple(t *testing.T) {\n-\tc := make(chan int)\n-\tdefer close(c)\n-\n-\ta := NewEvent(\"send\", nil, Send{c, 1})\n-\tb := NewEvent(\"recv\", []*Event{a}, Recv{c, 1})\n-\n-\terr := Perform(0, []*Event{a, b})\n-\tif err != nil {\n-\t\tt.Errorf(\"Got error: %s\", err)\n-\t}\n-}\n-\n-func TestFail(t *testing.T) {\n-\tc := make(chan int)\n-\tdefer close(c)\n-\n-\ta := NewEvent(\"send\", nil, Send{c, 2})\n-\tb := NewEvent(\"recv\", []*Event{a}, Recv{c, 1})\n-\n-\terr := Perform(0, []*Event{a, b})\n-\tif err == nil {\n-\t\tt.Errorf(\"Failed to get expected error\")\n-\t} else if _, ok := err.(ReceivedUnexpected); !ok {\n-\t\tt.Errorf(\"Error returned was of the wrong type: %s\", err)\n-\t}\n-}\n-\n-func TestClose(t *testing.T) {\n-\tc := make(chan int)\n-\n-\ta := NewEvent(\"close\", nil, Close{c})\n-\tb := NewEvent(\"closed\", []*Event{a}, Closed{c})\n-\n-\terr := Perform(0, []*Event{a, b})\n-\tif err != nil {\n-\t\tt.Errorf(\"Got error: %s\", err)\n-\t}\n-}\n-\n-func matchOne(v interface{}) bool {\n-\tif i, ok := v.(int); ok && i == 1 {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n-func TestRecvMatch(t *testing.T) {\n-\tc := make(chan int)\n-\n-\ta := NewEvent(\"send\", nil, Send{c, 1})\n-\tb := NewEvent(\"recv\", []*Event{a}, RecvMatch{c, matchOne})\n-\n-\terr := Perform(0, []*Event{a, b})\n-\tif err != nil {\n-\t\tt.Errorf(\"Got error: %s\", err)\n-\t}\n-}"}, {"sha": "d5d60eae4cd20cb72929842cd4c284fccd762a5f", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -12,8 +12,8 @@\n //\n // Functions of the form\n //     func BenchmarkXxx(*testing.B)\n-// are considered benchmarks, and are executed by gotest when the -test.bench\n-// flag is provided.\n+// are considered benchmarks, and are executed by the \"go test\" command when\n+// the -test.bench flag is provided.\n //\n // A sample benchmark function looks like this:\n //     func BenchmarkHello(b *testing.B) {\n@@ -64,6 +64,9 @@\n //     func ExampleT_suffix() { ... }\n //     func ExampleT_M_suffix() { ... }\n //\n+// The entire test file is presented as the example when it contains a single\n+// example function, at least one other function, type, variable, or constant\n+// declaration, and no test or benchmark functions.\n package testing\n \n import (\n@@ -81,7 +84,7 @@ var (\n \t// The short flag requests that tests run more quickly, but its functionality\n \t// is provided by test writers themselves.  The testing package is just its\n \t// home.  The all.bash installation script sets it to make installation more\n-\t// efficient, but by default the flag is off so a plain \"gotest\" will do a\n+\t// efficient, but by default the flag is off so a plain \"go test\" will do a\n \t// full test of the package.\n \tshort = flag.Bool(\"test.short\", false, \"run smaller test suite to save time\")\n \n@@ -162,7 +165,7 @@ func (c *common) Fail() { c.failed = true }\n func (c *common) Failed() bool { return c.failed }\n \n // FailNow marks the function as having failed and stops its execution.\n-// Execution will continue at the next Test.\n+// Execution will continue at the next test or benchmark.\n func (c *common) FailNow() {\n \tc.Fail()\n \n@@ -225,19 +228,6 @@ func (c *common) Fatalf(format string, args ...interface{}) {\n \tc.FailNow()\n }\n \n-// TODO(dsymonds): Consider hooking into runtime\u00b7traceback instead.\n-func (c *common) stack() {\n-\tfor i := 2; ; i++ { // Caller we care about is the user, 2 frames up\n-\t\tpc, file, line, ok := runtime.Caller(i)\n-\t\tf := runtime.FuncForPC(pc)\n-\t\tif !ok || f == nil {\n-\t\t\tbreak\n-\t\t}\n-\t\tc.Logf(\"%s:%d (0x%x)\", file, line, pc)\n-\t\tc.Logf(\"\\t%s\", f.Name())\n-\t}\n-}\n-\n // Parallel signals that this test is to be run in parallel with (and only with) \n // other parallel tests in this CPU group.\n func (t *T) Parallel() {\n@@ -246,7 +236,7 @@ func (t *T) Parallel() {\n }\n \n // An internal type but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of the \"go test\" command.\n type InternalTest struct {\n \tName string\n \tF    func(*T)\n@@ -260,22 +250,20 @@ func tRunner(t *T, test *InternalTest) {\n \t// a call to runtime.Goexit, record the duration and send\n \t// a signal saying that the test is done.\n \tdefer func() {\n-\t\t// Consider any uncaught panic a failure.\n+\t\tt.duration = time.Now().Sub(t.start)\n+\t\t// If the test panicked, print any test output before dying.\n \t\tif err := recover(); err != nil {\n-\t\t\tt.failed = true\n-\t\t\tt.Log(err)\n-\t\t\tt.stack()\n+\t\t\tt.report()\n+\t\t\tpanic(err)\n \t\t}\n-\n-\t\tt.duration = time.Now().Sub(t.start)\n \t\tt.signal <- t\n \t}()\n \n \ttest.F(t)\n }\n \n // An internal function but exported because it is cross-package; part of the implementation\n-// of gotest.\n+// of the \"go test\" command.\n func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) {\n \tflag.Parse()\n \tparseCpuList()"}, {"sha": "565650edf9c05f07f40f0c3ad0b3fbb600744274", "filename": "libgo/go/text/scanner/scanner.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -5,8 +5,7 @@\n // Package scanner provides a scanner and tokenizer for UTF-8-encoded text.\n // It takes an io.Reader providing the source, which then can be tokenized\n // through repeated calls to the Scan function.  For compatibility with\n-// existing tools, the NUL character is not allowed (implementation\n-// restriction).\n+// existing tools, the NUL character is not allowed.\n //\n // By default, a Scanner skips white space and Go comments and recognizes all\n // literals as defined by the Go language specification.  It may be\n@@ -104,7 +103,7 @@ var tokenString = map[rune]string{\n \tComment:   \"Comment\",\n }\n \n-// TokenString returns a (visible) string for a token or Unicode character.\n+// TokenString returns a printable string for a token or Unicode character.\n func TokenString(tok rune) string {\n \tif s, found := tokenString[tok]; found {\n \t\treturn s\n@@ -287,7 +286,7 @@ func (s *Scanner) next() rune {\n \t// special situations\n \tswitch ch {\n \tcase 0:\n-\t\t// implementation restriction for compatibility with other tools\n+\t\t// for compatibility with other tools\n \t\ts.error(\"illegal character NUL\")\n \tcase '\\n':\n \t\ts.line++"}, {"sha": "35c4c6811831a472ced222be42c7081820d23cc4", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -3,8 +3,10 @@\n // license that can be found in the LICENSE file.\n \n /*\n-Package template implements data-driven templates for generating textual output\n-such as HTML.\n+Package template implements data-driven templates for generating textual output.\n+\n+To generate HTML output, see package html/template, which has the same interface\n+as this package but automatically secures HTML output against certain attacks.\n \n Templates are executed by applying them to a data structure. Annotations in the\n template refer to elements of the data structure (typically a field of a struct"}, {"sha": "9bb55e48aac602df616d5d2edd924a8acbeb06b2", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -168,10 +167,12 @@ func (t *T) MAdd(a int, b []int) []int {\n \treturn v\n }\n \n-// EPERM returns a value and an error according to its argument.\n-func (t *T) EPERM(error bool) (bool, error) {\n+var myError = errors.New(\"my error\")\n+\n+// MyError returns a value and an error according to its argument.\n+func (t *T) MyError(error bool) (bool, error) {\n \tif error {\n-\t\treturn true, os.EPERM\n+\t\treturn true, myError\n \t}\n \treturn false, nil\n }\n@@ -417,8 +418,8 @@ var execTests = []execTest{\n \t{\"or as if false\", `{{or .SIEmpty \"slice is empty\"}}`, \"slice is empty\", tVal, true},\n \n \t// Error handling.\n-\t{\"error method, error\", \"{{.EPERM true}}\", \"\", tVal, false},\n-\t{\"error method, no error\", \"{{.EPERM false}}\", \"false\", tVal, true},\n+\t{\"error method, error\", \"{{.MyError true}}\", \"\", tVal, false},\n+\t{\"error method, no error\", \"{{.MyError false}}\", \"false\", tVal, true},\n \n \t// Fixed bugs.\n \t// Must separate dot and receiver; otherwise args are evaluated with dot set to variable.\n@@ -565,18 +566,18 @@ func TestDelims(t *testing.T) {\n func TestExecuteError(t *testing.T) {\n \tb := new(bytes.Buffer)\n \ttmpl := New(\"error\")\n-\t_, err := tmpl.Parse(\"{{.EPERM true}}\")\n+\t_, err := tmpl.Parse(\"{{.MyError true}}\")\n \tif err != nil {\n \t\tt.Fatalf(\"parse error: %s\", err)\n \t}\n \terr = tmpl.Execute(b, tVal)\n \tif err == nil {\n \t\tt.Errorf(\"expected error; got none\")\n-\t} else if !strings.Contains(err.Error(), os.EPERM.Error()) {\n+\t} else if !strings.Contains(err.Error(), myError.Error()) {\n \t\tif *debug {\n \t\t\tfmt.Printf(\"test execute error: %s\\n\", err)\n \t\t}\n-\t\tt.Errorf(\"expected os.EPERM; got %s\", err)\n+\t\tt.Errorf(\"expected myError; got %s\", err)\n \t}\n }\n "}, {"sha": "54e75ee0ca25e19d566c64767ef567fb2a556369", "filename": "libgo/go/text/template/parse/lex.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -187,7 +187,7 @@ func (l *lexer) lineNumber() int {\n }\n \n // error returns an error token and terminates the scan by passing\n-// back a nil pointer that will be the next state, terminating l.run.\n+// back a nil pointer that will be the next state, terminating l.nextItem.\n func (l *lexer) errorf(format string, args ...interface{}) stateFn {\n \tl.items <- item{itemError, fmt.Sprintf(format, args...)}\n \treturn nil"}, {"sha": "db645624c562064725d2189146d941e2adfe9a72", "filename": "libgo/go/text/template/parse/node.go", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fnode.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,6 +17,10 @@ import (\n type Node interface {\n \tType() NodeType\n \tString() string\n+\t// Copy does a deep copy of the Node and all its components.\n+\t// To avoid type assertions, some XxxNodes also have specialized\n+\t// CopyXxx methods that return *XxxNode.\n+\tCopy() Node\n }\n \n // NodeType identifies the type of a parse tree node.\n@@ -73,6 +77,21 @@ func (l *ListNode) String() string {\n \treturn b.String()\n }\n \n+func (l *ListNode) CopyList() *ListNode {\n+\tif l == nil {\n+\t\treturn l\n+\t}\n+\tn := newList()\n+\tfor _, elem := range l.Nodes {\n+\t\tn.append(elem.Copy())\n+\t}\n+\treturn n\n+}\n+\n+func (l *ListNode) Copy() Node {\n+\treturn l.CopyList()\n+}\n+\n // TextNode holds plain text.\n type TextNode struct {\n \tNodeType\n@@ -87,6 +106,10 @@ func (t *TextNode) String() string {\n \treturn fmt.Sprintf(\"%q\", t.Text)\n }\n \n+func (t *TextNode) Copy() Node {\n+\treturn &TextNode{NodeType: NodeText, Text: append([]byte{}, t.Text...)}\n+}\n+\n // PipeNode holds a pipeline with optional declaration\n type PipeNode struct {\n \tNodeType\n@@ -123,6 +146,25 @@ func (p *PipeNode) String() string {\n \treturn s\n }\n \n+func (p *PipeNode) CopyPipe() *PipeNode {\n+\tif p == nil {\n+\t\treturn p\n+\t}\n+\tvar decl []*VariableNode\n+\tfor _, d := range p.Decl {\n+\t\tdecl = append(decl, d.Copy().(*VariableNode))\n+\t}\n+\tn := newPipeline(p.Line, decl)\n+\tfor _, c := range p.Cmds {\n+\t\tn.append(c.Copy().(*CommandNode))\n+\t}\n+\treturn n\n+}\n+\n+func (p *PipeNode) Copy() Node {\n+\treturn p.CopyPipe()\n+}\n+\n // ActionNode holds an action (something bounded by delimiters).\n // Control actions have their own nodes; ActionNode represents simple\n // ones such as field evaluations.\n@@ -141,6 +183,11 @@ func (a *ActionNode) String() string {\n \n }\n \n+func (a *ActionNode) Copy() Node {\n+\treturn newAction(a.Line, a.Pipe.CopyPipe())\n+\n+}\n+\n // CommandNode holds a command (a pipeline inside an evaluating action).\n type CommandNode struct {\n \tNodeType\n@@ -166,6 +213,17 @@ func (c *CommandNode) String() string {\n \treturn s\n }\n \n+func (c *CommandNode) Copy() Node {\n+\tif c == nil {\n+\t\treturn c\n+\t}\n+\tn := newCommand()\n+\tfor _, c := range c.Args {\n+\t\tn.append(c.Copy())\n+\t}\n+\treturn n\n+}\n+\n // IdentifierNode holds an identifier.\n type IdentifierNode struct {\n \tNodeType\n@@ -181,6 +239,10 @@ func (i *IdentifierNode) String() string {\n \treturn i.Ident\n }\n \n+func (i *IdentifierNode) Copy() Node {\n+\treturn NewIdentifier(i.Ident)\n+}\n+\n // VariableNode holds a list of variable names. The dollar sign is\n // part of the name.\n type VariableNode struct {\n@@ -203,6 +265,10 @@ func (v *VariableNode) String() string {\n \treturn s\n }\n \n+func (v *VariableNode) Copy() Node {\n+\treturn &VariableNode{NodeType: NodeVariable, Ident: append([]string{}, v.Ident...)}\n+}\n+\n // DotNode holds the special identifier '.'. It is represented by a nil pointer.\n type DotNode bool\n \n@@ -218,6 +284,10 @@ func (d *DotNode) String() string {\n \treturn \".\"\n }\n \n+func (d *DotNode) Copy() Node {\n+\treturn newDot()\n+}\n+\n // FieldNode holds a field (identifier starting with '.').\n // The names may be chained ('.x.y').\n // The period is dropped from each ident.\n@@ -238,6 +308,10 @@ func (f *FieldNode) String() string {\n \treturn s\n }\n \n+func (f *FieldNode) Copy() Node {\n+\treturn &FieldNode{NodeType: NodeField, Ident: append([]string{}, f.Ident...)}\n+}\n+\n // BoolNode holds a boolean constant.\n type BoolNode struct {\n \tNodeType\n@@ -255,6 +329,10 @@ func (b *BoolNode) String() string {\n \treturn \"false\"\n }\n \n+func (b *BoolNode) Copy() Node {\n+\treturn newBool(b.True)\n+}\n+\n // NumberNode holds a number: signed or unsigned integer, float, or complex.\n // The value is parsed and stored under all the types that can represent the value.\n // This simulates in a small amount of code the behavior of Go's ideal constants.\n@@ -373,6 +451,12 @@ func (n *NumberNode) String() string {\n \treturn n.Text\n }\n \n+func (n *NumberNode) Copy() Node {\n+\tnn := new(NumberNode)\n+\t*nn = *n // Easy, fast, correct.\n+\treturn nn\n+}\n+\n // StringNode holds a string constant. The value has been \"unquoted\".\n type StringNode struct {\n \tNodeType\n@@ -388,6 +472,10 @@ func (s *StringNode) String() string {\n \treturn s.Quoted\n }\n \n+func (s *StringNode) Copy() Node {\n+\treturn newString(s.Quoted, s.Text)\n+}\n+\n // endNode represents an {{end}} action. It is represented by a nil pointer.\n // It does not appear in the final parse tree.\n type endNode bool\n@@ -404,6 +492,10 @@ func (e *endNode) String() string {\n \treturn \"{{end}}\"\n }\n \n+func (e *endNode) Copy() Node {\n+\treturn newEnd()\n+}\n+\n // elseNode represents an {{else}} action. Does not appear in the final tree.\n type elseNode struct {\n \tNodeType\n@@ -422,6 +514,10 @@ func (e *elseNode) String() string {\n \treturn \"{{else}}\"\n }\n \n+func (e *elseNode) Copy() Node {\n+\treturn newElse(e.Line)\n+}\n+\n // BranchNode is the common representation of if, range, and with.\n type BranchNode struct {\n \tNodeType\n@@ -458,6 +554,10 @@ func newIf(line int, pipe *PipeNode, list, elseList *ListNode) *IfNode {\n \treturn &IfNode{BranchNode{NodeType: NodeIf, Line: line, Pipe: pipe, List: list, ElseList: elseList}}\n }\n \n+func (i *IfNode) Copy() Node {\n+\treturn newIf(i.Line, i.Pipe.CopyPipe(), i.List.CopyList(), i.ElseList.CopyList())\n+}\n+\n // RangeNode represents a {{range}} action and its commands.\n type RangeNode struct {\n \tBranchNode\n@@ -467,6 +567,10 @@ func newRange(line int, pipe *PipeNode, list, elseList *ListNode) *RangeNode {\n \treturn &RangeNode{BranchNode{NodeType: NodeRange, Line: line, Pipe: pipe, List: list, ElseList: elseList}}\n }\n \n+func (r *RangeNode) Copy() Node {\n+\treturn newRange(r.Line, r.Pipe.CopyPipe(), r.List.CopyList(), r.ElseList.CopyList())\n+}\n+\n // WithNode represents a {{with}} action and its commands.\n type WithNode struct {\n \tBranchNode\n@@ -476,6 +580,10 @@ func newWith(line int, pipe *PipeNode, list, elseList *ListNode) *WithNode {\n \treturn &WithNode{BranchNode{NodeType: NodeWith, Line: line, Pipe: pipe, List: list, ElseList: elseList}}\n }\n \n+func (w *WithNode) Copy() Node {\n+\treturn newWith(w.Line, w.Pipe.CopyPipe(), w.List.CopyList(), w.ElseList.CopyList())\n+}\n+\n // TemplateNode represents a {{template}} action.\n type TemplateNode struct {\n \tNodeType\n@@ -494,3 +602,7 @@ func (t *TemplateNode) String() string {\n \t}\n \treturn fmt.Sprintf(\"{{template %q %s}}\", t.Name, t.Pipe)\n }\n+\n+func (t *TemplateNode) Copy() Node {\n+\treturn newTemplate(t.Line, t.Name, t.Pipe.CopyPipe())\n+}"}, {"sha": "efa7d8be7424170b11a77ea8997e26f220d38004", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -232,7 +232,7 @@ var builtins = map[string]interface{}{\n \t\"printf\": fmt.Sprintf,\n }\n \n-func TestParse(t *testing.T) {\n+func testParse(doCopy bool, t *testing.T) {\n \tfor _, test := range parseTests {\n \t\ttmpl, err := New(test.name).Parse(test.input, \"\", \"\", make(map[string]*Tree), builtins)\n \t\tswitch {\n@@ -249,13 +249,27 @@ func TestParse(t *testing.T) {\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n-\t\tresult := tmpl.Root.String()\n+\t\tvar result string\n+\t\tif doCopy {\n+\t\t\tresult = tmpl.Root.Copy().String()\n+\t\t} else {\n+\t\t\tresult = tmpl.Root.String()\n+\t\t}\n \t\tif result != test.result {\n \t\t\tt.Errorf(\"%s=(%q): got\\n\\t%v\\nexpected\\n\\t%v\", test.name, test.input, result, test.result)\n \t\t}\n \t}\n }\n \n+func TestParse(t *testing.T) {\n+\ttestParse(false, t)\n+}\n+\n+// Same as TestParse, but we copy the node first\n+func TestParseCopy(t *testing.T) {\n+\ttestParse(true, t)\n+}\n+\n type isEmptyTest struct {\n \tname  string\n \tinput string"}, {"sha": "b25e64cda3e0e1ad999713afd3e30de5a0c88283", "filename": "libgo/go/time/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fexample_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -51,7 +51,7 @@ func ExampleMonth() {\n \t}\n }\n \n-// Go launched at Tue Nov 10 15:00:00 -0800 PST 2009\n+// Go launched at 2009-11-10 15:00:00 -0800 PST\n func ExampleDate() {\n \tt := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n \tfmt.Printf(\"Go launched at %s\\n\", t.Local())"}, {"sha": "ef6f1f335142c3b058713ea3c88c8cc9d508619f", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 77, "deletions": 40, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -16,18 +16,23 @@ const (\n \n // These are predefined layouts for use in Time.Format.\n // The standard time used in the layouts is:\n-//\tMon Jan 2 15:04:05 MST 2006  (MST is GMT-0700)\n-// which is Unix time 1136243045.\n-// (Think of it as 01/02 03:04:05PM '06 -0700.)\n-// To define your own format, write down what the standard\n-// time would look like formatted your way.\n+//\tMon Jan 2 15:04:05 MST 2006\n+// which is Unix time 1136243045. Since MST is GMT-0700,\n+// the standard time can be thought of as\n+//\t01/02 03:04:05PM '06 -0700\n+// To define your own format, write down what the standard time would look\n+// like formatted your way; see the values of constants like ANSIC,\n+// StampMicro or Kitchen for examples.\n //\n // Within the format string, an underscore _ represents a space that may be\n // replaced by a digit if the following number (a day) has two digits; for\n // compatibility with fixed-width Unix time formats.\n //\n // A decimal point followed by one or more zeros represents a fractional\n-// second. When parsing (only), the input may contain a fractional second\n+// second, printed to the given number of decimal places.  A decimal point\n+// followed by one or more nines represents a fractional second, printed to\n+// the given number of decimal places, with trailing zeros removed.\n+// When parsing (only), the input may contain a fractional second\n // field immediately after the seconds field, even if the layout does not\n // signify its presence. In that case a decimal point followed by a maximal\n // series of digits is parsed as a fractional second.\n@@ -41,16 +46,17 @@ const (\n //\tZ0700  Z or \u00b1hhmm\n //\tZ07:00 Z or \u00b1hh:mm\n const (\n-\tANSIC    = \"Mon Jan _2 15:04:05 2006\"\n-\tUnixDate = \"Mon Jan _2 15:04:05 MST 2006\"\n-\tRubyDate = \"Mon Jan 02 15:04:05 -0700 2006\"\n-\tRFC822   = \"02 Jan 06 1504 MST\"\n-\tRFC822Z  = \"02 Jan 06 1504 -0700\" // RFC822 with numeric zone\n-\tRFC850   = \"Monday, 02-Jan-06 15:04:05 MST\"\n-\tRFC1123  = \"Mon, 02 Jan 2006 15:04:05 MST\"\n-\tRFC1123Z = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n-\tRFC3339  = \"2006-01-02T15:04:05Z07:00\"\n-\tKitchen  = \"3:04PM\"\n+\tANSIC       = \"Mon Jan _2 15:04:05 2006\"\n+\tUnixDate    = \"Mon Jan _2 15:04:05 MST 2006\"\n+\tRubyDate    = \"Mon Jan 02 15:04:05 -0700 2006\"\n+\tRFC822      = \"02 Jan 06 1504 MST\"\n+\tRFC822Z     = \"02 Jan 06 1504 -0700\" // RFC822 with numeric zone\n+\tRFC850      = \"Monday, 02-Jan-06 15:04:05 MST\"\n+\tRFC1123     = \"Mon, 02 Jan 2006 15:04:05 MST\"\n+\tRFC1123Z    = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n+\tRFC3339     = \"2006-01-02T15:04:05Z07:00\"\n+\tRFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n+\tKitchen     = \"3:04PM\"\n \t// Handy time stamps.\n \tStamp      = \"Jan _2 15:04:05\"\n \tStampMilli = \"Jan _2 15:04:05.000\"\n@@ -165,15 +171,17 @@ func nextStdChunk(layout string) (prefix, std, suffix string) {\n \t\t\tif len(layout) >= i+6 && layout[i:i+6] == stdISO8601ColonTZ {\n \t\t\t\treturn layout[0:i], layout[i : i+6], layout[i+6:]\n \t\t\t}\n-\t\tcase '.': // .000 - multiple digits of zeros (only) for fractional seconds.\n-\t\t\tnumZeros := 0\n-\t\t\tvar j int\n-\t\t\tfor j = i + 1; j < len(layout) && layout[j] == '0'; j++ {\n-\t\t\t\tnumZeros++\n-\t\t\t}\n-\t\t\t// String of digits must end here - only fractional second is all zeros.\n-\t\t\tif numZeros > 0 && !isDigit(layout, j) {\n-\t\t\t\treturn layout[0:i], layout[i : i+1+numZeros], layout[i+1+numZeros:]\n+\t\tcase '.': // .000 or .999 - repeated digits for fractional seconds.\n+\t\t\tif i+1 < len(layout) && (layout[i+1] == '0' || layout[i+1] == '9') {\n+\t\t\t\tch := layout[i+1]\n+\t\t\t\tj := i + 1\n+\t\t\t\tfor j < len(layout) && layout[j] == ch {\n+\t\t\t\t\tj++\n+\t\t\t\t}\n+\t\t\t\t// String of digits must end here - only fractional second is all digits.\n+\t\t\t\tif !isDigit(layout, j) {\n+\t\t\t\t\treturn layout[0:i], layout[i:j], layout[j:]\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -313,7 +321,7 @@ func pad(i int, padding string) string {\n func zeroPad(i int) string { return pad(i, \"0\") }\n \n // formatNano formats a fractional second, as nanoseconds.\n-func formatNano(nanosec, n int) string {\n+func formatNano(nanosec, n int, trim bool) string {\n \t// User might give us bad data. Make sure it's positive and in range.\n \t// They'll get nonsense output but it will have the right format.\n \ts := itoa(int(uint(nanosec) % 1e9))\n@@ -324,13 +332,21 @@ func formatNano(nanosec, n int) string {\n \tif n > 9 {\n \t\tn = 9\n \t}\n+\tif trim {\n+\t\tfor n > 0 && s[n-1] == '0' {\n+\t\t\tn--\n+\t\t}\n+\t\tif n == 0 {\n+\t\t\treturn \"\"\n+\t\t}\n+\t}\n \treturn \".\" + s[:n]\n }\n \n // String returns the time formatted using the format string\n-//\t\"Mon Jan _2 15:04:05 -0700 MST 2006\"\n+//\t\"2006-01-02 15:04:05.999999999 -0700 MST\"\n func (t Time) String() string {\n-\treturn t.Format(\"Mon Jan _2 15:04:05 -0700 MST 2006\")\n+\treturn t.Format(\"2006-01-02 15:04:05.999999999 -0700 MST\")\n }\n \n type buffer []byte\n@@ -345,10 +361,12 @@ func (b *buffer) String() string {\n \n // Format returns a textual representation of the time value formatted\n // according to layout.  The layout defines the format by showing the\n-// representation of a standard time, which is then used to describe\n-// the time to be formatted.  Predefined layouts ANSIC, UnixDate,\n-// RFC3339 and others describe standard representations. For more\n-// information about the formats, see the documentation for ANSIC.\n+// representation of the standard time,\n+//\tMon Jan 2 15:04:05 -0700 MST 2006\n+// which is then used to describe the time to be formatted. Predefined\n+// layouts ANSIC, UnixDate, RFC3339 and others describe standard\n+// representations. For more information about the formats and the\n+// definition of the standard time, see the documentation for ANSIC.\n func (t Time) Format(layout string) string {\n \tvar (\n \t\tyear  int = -1\n@@ -388,7 +406,24 @@ func (t Time) Format(layout string) string {\n \t\tcase stdYear:\n \t\t\tp = zeroPad(year % 100)\n \t\tcase stdLongYear:\n+\t\t\t// Pad year to at least 4 digits.\n \t\t\tp = itoa(year)\n+\t\t\tswitch {\n+\t\t\tcase year <= -1000:\n+\t\t\t\t// ok\n+\t\t\tcase year <= -100:\n+\t\t\t\tp = p[:1] + \"0\" + p[1:]\n+\t\t\tcase year <= -10:\n+\t\t\t\tp = p[:1] + \"00\" + p[1:]\n+\t\t\tcase year < 0:\n+\t\t\t\tp = p[:1] + \"000\" + p[1:]\n+\t\t\tcase year < 10:\n+\t\t\t\tp = \"000\" + p\n+\t\t\tcase year < 100:\n+\t\t\t\tp = \"00\" + p\n+\t\t\tcase year < 1000:\n+\t\t\t\tp = \"0\" + p\n+\t\t\t}\n \t\tcase stdMonth:\n \t\t\tp = month.String()[:3]\n \t\tcase stdLongMonth:\n@@ -481,8 +516,8 @@ func (t Time) Format(layout string) string {\n \t\t\t\tp += zeroPad(zone % 60)\n \t\t\t}\n \t\tdefault:\n-\t\t\tif len(std) >= 2 && std[0:2] == \".0\" {\n-\t\t\t\tp = formatNano(t.Nanosecond(), len(std)-1)\n+\t\t\tif len(std) >= 2 && (std[0:2] == \".0\" || std[0:2] == \".9\") {\n+\t\t\t\tp = formatNano(t.Nanosecond(), len(std)-1, std[1] == '9')\n \t\t\t}\n \t\t}\n \t\tb.WriteString(p)\n@@ -574,13 +609,15 @@ func skip(value, prefix string) (string, error) {\n }\n \n // Parse parses a formatted string and returns the time value it represents.\n-// The layout defines the format by showing the representation of a standard\n-// time, which is then used to describe the string to be parsed.  Predefined\n-// layouts ANSIC, UnixDate, RFC3339 and others describe standard\n-// representations.For more information about the formats, see the\n-// documentation for ANSIC.\n+// The layout defines the format by showing the representation of the\n+// standard time,\n+//\tMon Jan 2 15:04:05 -0700 MST 2006\n+// which is then used to describe the string to be parsed. Predefined layouts\n+// ANSIC, UnixDate, RFC3339 and others describe standard representations. For\n+// more information about the formats and the definition of the standard\n+// time, see the documentation for ANSIC.\n //\n-// Elements omitted from the value are assumed to be zero, or when\n+// Elements omitted from the value are assumed to be zero or, when\n // zero is impossible, one, so parsing \"3:04pm\" returns the time\n // corresponding to Jan 1, year 0, 15:04:00 UTC.\n // Years must be in the range 0000..9999. The day of the week is checked"}, {"sha": "e572b67841967f45c0807ff22efe87535fd89b17", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -108,10 +108,11 @@ func TestAfter(t *testing.T) {\n }\n \n func TestAfterTick(t *testing.T) {\n-\tconst (\n-\t\tDelta = 100 * Millisecond\n-\t\tCount = 10\n-\t)\n+\tconst Count = 10\n+\tDelta := 100 * Millisecond\n+\tif testing.Short() {\n+\t\tDelta = 10 * Millisecond\n+\t}\n \tt0 := Now()\n \tfor i := 0; i < Count; i++ {\n \t\t<-After(Delta)\n@@ -165,7 +166,7 @@ func TestAfterQueuing(t *testing.T) {\n }\n \n // For gccgo omit 0 for now because it can take too long to start the\n-var slots = []int{5, 3, 6, 6, 6, 1, 1, 2, 7, 9, 4, 8 /*0*/ }\n+var slots = []int{5, 3, 6, 6, 6, 1, 1, 2, 7, 9, 4, 8 /*0*/}\n \n type afterResult struct {\n \tslot int\n@@ -177,9 +178,10 @@ func await(slot int, result chan<- afterResult, ac <-chan Time) {\n }\n \n func testAfterQueuing(t *testing.T) error {\n-\tconst (\n-\t\tDelta = 100 * Millisecond\n-\t)\n+\tDelta := 100 * Millisecond\n+\tif testing.Short() {\n+\t\tDelta = 20 * Millisecond\n+\t}\n \t// make the result channel buffered because we don't want\n \t// to depend on channel queueing semantics that might\n \t// possibly change in the future."}, {"sha": "0c1c4d67ab00500069fef149992c0e3d4adc7c69", "filename": "libgo/go/time/tick_test.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Ftick_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Ftick_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -10,10 +10,11 @@ import (\n )\n \n func TestTicker(t *testing.T) {\n-\tconst (\n-\t\tDelta = 100 * Millisecond\n-\t\tCount = 10\n-\t)\n+\tconst Count = 10\n+\tDelta := 100 * Millisecond\n+\tif testing.Short() {\n+\t\tDelta = 10 * Millisecond\n+\t}\n \tticker := NewTicker(Delta)\n \tt0 := Now()\n \tfor i := 0; i < Count; i++ {\n@@ -39,8 +40,12 @@ func TestTicker(t *testing.T) {\n \n // Test that a bug tearing down a ticker has been fixed.  This routine should not deadlock.\n func TestTeardown(t *testing.T) {\n+\tDelta := 100 * Millisecond\n+\tif testing.Short() {\n+\t\tDelta = 20 * Millisecond\n+\t}\n \tfor i := 0; i < 3; i++ {\n-\t\tticker := NewTicker(1e8)\n+\t\tticker := NewTicker(Delta)\n \t\t<-ticker.C\n \t\tticker.Stop()\n \t}"}, {"sha": "709a42267246fad5fb4216f92ba2856263ea5090", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -841,46 +841,17 @@ func (t *Time) GobDecode(buf []byte) error {\n // MarshalJSON implements the json.Marshaler interface.\n // Time is formatted as RFC3339.\n func (t Time) MarshalJSON() ([]byte, error) {\n-\tyearInt := t.Year()\n-\tif yearInt < 0 || yearInt > 9999 {\n+\tif y := t.Year(); y < 0 || y >= 10000 {\n \t\treturn nil, errors.New(\"Time.MarshalJSON: year outside of range [0,9999]\")\n \t}\n-\n-\t// We need a four-digit year, but Format produces variable-width years.\n-\tyear := itoa(yearInt)\n-\tyear = \"0000\"[:4-len(year)] + year\n-\n-\tvar formattedTime string\n-\tif t.nsec == 0 {\n-\t\t// RFC3339, no fractional second\n-\t\tformattedTime = t.Format(\"-01-02T15:04:05Z07:00\")\n-\t} else {\n-\t\t// RFC3339 with fractional second\n-\t\tformattedTime = t.Format(\"-01-02T15:04:05.000000000Z07:00\")\n-\n-\t\t// Trim trailing zeroes from fractional second.\n-\t\tconst nanoEnd = 24 // Index of last digit of fractional second\n-\t\tvar i int\n-\t\tfor i = nanoEnd; formattedTime[i] == '0'; i-- {\n-\t\t\t// Seek backwards until first significant digit is found.\n-\t\t}\n-\n-\t\tformattedTime = formattedTime[:i+1] + formattedTime[nanoEnd+1:]\n-\t}\n-\n-\tbuf := make([]byte, 0, 1+len(year)+len(formattedTime)+1)\n-\tbuf = append(buf, '\"')\n-\tbuf = append(buf, year...)\n-\tbuf = append(buf, formattedTime...)\n-\tbuf = append(buf, '\"')\n-\treturn buf, nil\n+\treturn []byte(t.Format(`\"` + RFC3339Nano + `\"`)), nil\n }\n \n // UnmarshalJSON implements the json.Unmarshaler interface.\n // Time is expected in RFC3339 format.\n func (t *Time) UnmarshalJSON(data []byte) (err error) {\n-\t*t, err = Parse(\"\\\"\"+RFC3339+\"\\\"\", string(data))\n \t// Fractional seconds are handled implicitly by Parse.\n+\t*t, err = Parse(`\"`+RFC3339+`\"`, string(data))\n \treturn\n }\n "}, {"sha": "3430526b8bff2d6e3b43c3ee424078dee655fd56", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"encoding/gob\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"math/rand\"\n \t\"strconv\"\n \t\"strings\"\n@@ -227,6 +228,7 @@ var formatTests = []FormatTest{\n \t{\"RFC1123\", RFC1123, \"Wed, 04 Feb 2009 21:00:57 PST\"},\n \t{\"RFC1123Z\", RFC1123Z, \"Wed, 04 Feb 2009 21:00:57 -0800\"},\n \t{\"RFC3339\", RFC3339, \"2009-02-04T21:00:57-08:00\"},\n+\t{\"RFC3339Nano\", RFC3339Nano, \"2009-02-04T21:00:57.0123456-08:00\"},\n \t{\"Kitchen\", Kitchen, \"9:00PM\"},\n \t{\"am/pm\", \"3pm\", \"9pm\"},\n \t{\"AM/PM\", \"3PM\", \"9PM\"},\n@@ -235,12 +237,12 @@ var formatTests = []FormatTest{\n \t{\"Stamp\", Stamp, \"Feb  4 21:00:57\"},\n \t{\"StampMilli\", StampMilli, \"Feb  4 21:00:57.012\"},\n \t{\"StampMicro\", StampMicro, \"Feb  4 21:00:57.012345\"},\n-\t{\"StampNano\", StampNano, \"Feb  4 21:00:57.012345678\"},\n+\t{\"StampNano\", StampNano, \"Feb  4 21:00:57.012345600\"},\n }\n \n func TestFormat(t *testing.T) {\n-\t// The numeric time represents Thu Feb  4 21:00:57.012345678 PST 2010\n-\ttime := Unix(0, 1233810057012345678)\n+\t// The numeric time represents Thu Feb  4 21:00:57.012345600 PST 2010\n+\ttime := Unix(0, 1233810057012345600)\n \tfor _, test := range formatTests {\n \t\tresult := time.Format(test.format)\n \t\tif result != test.result {\n@@ -249,6 +251,38 @@ func TestFormat(t *testing.T) {\n \t}\n }\n \n+func TestFormatShortYear(t *testing.T) {\n+\tyears := []int{\n+\t\t-100001, -100000, -99999,\n+\t\t-10001, -10000, -9999,\n+\t\t-1001, -1000, -999,\n+\t\t-101, -100, -99,\n+\t\t-11, -10, -9,\n+\t\t-1, 0, 1,\n+\t\t9, 10, 11,\n+\t\t99, 100, 101,\n+\t\t999, 1000, 1001,\n+\t\t9999, 10000, 10001,\n+\t\t99999, 100000, 100001,\n+\t}\n+\n+\tfor _, y := range years {\n+\t\ttime := Date(y, January, 1, 0, 0, 0, 0, UTC)\n+\t\tresult := time.Format(\"2006.01.02\")\n+\t\tvar want string\n+\t\tif y < 0 {\n+\t\t\t// The 4 in %04d counts the - sign, so print -y instead\n+\t\t\t// and introduce our own - sign.\n+\t\t\twant = fmt.Sprintf(\"-%04d.%02d.%02d\", -y, 1, 1)\n+\t\t} else {\n+\t\t\twant = fmt.Sprintf(\"%04d.%02d.%02d\", y, 1, 1)\n+\t\t}\n+\t\tif result != want {\n+\t\t\tt.Errorf(\"(jan 1 %d).Format(\\\"2006.01.02\\\") = %q, want %q\", y, result, want)\n+\t\t}\n+\t}\n+}\n+\n type ParseTest struct {\n \tname       string\n \tformat     string\n@@ -782,7 +816,7 @@ func TestTimeJSON(t *testing.T) {\n \t\tif jsonBytes, err := json.Marshal(tt.time); err != nil {\n \t\t\tt.Errorf(\"%v json.Marshal error = %v, want nil\", tt.time, err)\n \t\t} else if string(jsonBytes) != tt.json {\n-\t\t\tt.Errorf(\"%v JSON = %q, want %q\", tt.time, string(jsonBytes), tt.json)\n+\t\t\tt.Errorf(\"%v JSON = %#q, want %#q\", tt.time, string(jsonBytes), tt.json)\n \t\t} else if err = json.Unmarshal(jsonBytes, &jsonTime); err != nil {\n \t\t\tt.Errorf(\"%v json.Unmarshal error = %v, want nil\", tt.time, err)\n \t\t} else if !equalTimeAndZone(jsonTime, tt.time) {"}, {"sha": "0de90ebd80cb3f3eda23b576499ae72495bb5aa7", "filename": "libgo/go/unicode/graphic.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Fgraphic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Fgraphic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fgraphic.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -53,7 +53,6 @@ func IsPrint(r rune) bool {\n }\n \n // IsOneOf reports whether the rune is a member of one of the ranges.\n-// The rune is known to be above Latin-1.\n func IsOneOf(set []*RangeTable, r rune) bool {\n \tfor _, inside := range set {\n \t\tif Is(inside, r) {\n@@ -65,7 +64,7 @@ func IsOneOf(set []*RangeTable, r rune) bool {\n \n // IsControl reports whether the rune is a control character.\n // The C (Other) Unicode category includes more code points\n-// such as surrogates; use Is(C, rune) to test for them.\n+// such as surrogates; use Is(C, r) to test for them.\n func IsControl(r rune) bool {\n \tif uint32(r) <= MaxLatin1 {\n \t\treturn properties[uint8(r)]&pC != 0"}, {"sha": "be484553dc49e1307d91f76c4c9e1923e86286fc", "filename": "libgo/go/unicode/letter.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Fletter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Fletter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fletter.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -60,8 +60,8 @@ type CaseRange struct {\n // Methods of SpecialCase customize (by overriding) the standard mappings.\n type SpecialCase []CaseRange\n \n-//BUG(r): Provide a mechanism for full case folding (those that involve\n-// multiple runes in the input or output).\n+// BUG(r): There is no mechanism for full case folding, that is, for\n+// characters that involve multiple runes in the input or output.\n \n // Indices into the Delta arrays inside CaseRanges for case mapping.\n const (\n@@ -288,7 +288,7 @@ type foldPair struct {\n // SimpleFold iterates over Unicode code points equivalent under\n // the Unicode-defined simple case folding.  Among the code points\n // equivalent to rune (including rune itself), SimpleFold returns the\n-// smallest r >= rune if one exists, or else the smallest r >= 0. \n+// smallest rune >= r if one exists, or else the smallest rune >= 0. \n //\n // For example:\n //\tSimpleFold('A') = 'a'"}, {"sha": "5009e6b98c8165f815a1afeb8ea89396dc749adf", "filename": "libgo/go/unicode/tables.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Ftables.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -7,7 +7,7 @@ package unicode\n // Version is the Unicode edition from which the tables are derived.\n const Version = \"6.0.0\"\n \n-// Categories is the set of Unicode data tables.\n+// Categories is the set of Unicode category tables.\n var Categories = map[string]*RangeTable{\n \t\"C\":  C,\n \t\"Cc\": Cc,"}, {"sha": "631533a5a3579c859d9ac9fcc3914d6df881ec3e", "filename": "libgo/go/unicode/utf8/utf8.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // Package utf8 implements functions and constants to support text encoded in\n-// UTF-8. This package calls a Unicode character a rune for brevity.\n+// UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.\n package utf8\n \n import \"unicode\" // only needed for a couple of constants\n@@ -198,19 +198,21 @@ func FullRuneInString(s string) bool {\n }\n \n // DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes.\n+// If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF-8.\n func DecodeRune(p []byte) (r rune, size int) {\n \tr, size, _ = decodeRuneInternal(p)\n \treturn\n }\n \n // DecodeRuneInString is like DecodeRune but its input is a string.\n+// If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF-8.\n func DecodeRuneInString(s string) (r rune, size int) {\n \tr, size, _ = decodeRuneInStringInternal(s)\n \treturn\n }\n \n-// DecodeLastRune unpacks the last UTF-8 encoding in p\n-// and returns the rune and its width in bytes.\n+// DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes.\n+// If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF-8.\n func DecodeLastRune(p []byte) (r rune, size int) {\n \tend := len(p)\n \tif end == 0 {\n@@ -244,6 +246,7 @@ func DecodeLastRune(p []byte) (r rune, size int) {\n }\n \n // DecodeLastRuneInString is like DecodeLastRune but its input is a string.\n+// If the encoding is invalid, it returns (RuneError, 1), an impossible result for correct UTF-8.\n func DecodeLastRuneInString(s string) (r rune, size int) {\n \tend := len(s)\n \tif end == 0 {"}, {"sha": "32652118fe59088e39b386dc56c0275829b97c3f", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -163,7 +163,7 @@ done\n   done\n done\n \n-runtime=\"chan.c cpuprof.c goc2c.c lock_futex.c lock_sema.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c msize.c proc.c runtime.c runtime.h malloc.h malloc.goc mprof.goc runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n+runtime=\"chan.c cpuprof.c goc2c.c lock_futex.c lock_sema.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c msize.c proc.c runtime.c runtime.h signal_unix.c malloc.h malloc.goc mprof.goc runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n for f in $runtime; do\n   merge_c $f $f\n done"}, {"sha": "09d0784f0060faeaa38d0de093e4a7b112db57ab", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -172,7 +172,7 @@ fi\n # The signal numbers.\n grep '^const _SIG[^_]' gen-sysinfo.go | \\\n   grep -v '^const _SIGEV_' | \\\n-  sed -e 's/^\\(const \\)_\\(SIG[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+  sed -e 's/^\\(const \\)_\\(SIG[^= ]*\\)\\(.*\\)$/\\1\\2 = Signal(_\\2)/' >> ${OUT}\n \n # The syscall numbers.  We force the names to upper case.\n grep '^const _SYS_' gen-sysinfo.go | \\"}, {"sha": "db91d2c49eab4182452131a819e1d880ee21a123", "filename": "libgo/runtime/chan.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fchan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fchan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -662,6 +662,10 @@ newselect(int32 size, Select **selp)\n \tif(size > 1)\n \t\tn = size-1;\n \n+\t// allocate all the memory we need in a single allocation\n+\t// start with Select with size cases\n+\t// then lockorder with size entries\n+\t// then pollorder with size entries\n \tsel = runtime_mal(sizeof(*sel) +\n \t\tn*sizeof(sel->scase[0]) +\n \t\tsize*sizeof(sel->lockorder[0]) +"}, {"sha": "94bdaeef42983a8ebbd2b28f0cb23899b92bfc8a", "filename": "libgo/runtime/go-assert-interface.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-assert-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-assert-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-assert-interface.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,6 +8,7 @@\n #include \"go-assert.h\"\n #include \"go-panic.h\"\n #include \"interface.h\"\n+#include \"runtime.h\"\n \n /* This is called by the compiler to implement a type assertion from\n    one interface type to another.  This returns the value that should\n@@ -26,14 +27,8 @@ __go_assert_interface (const struct __go_type_descriptor *lhs_descriptor,\n \n       /* A type assertion is not permitted with a nil interface.  */\n \n-      newTypeAssertionError (NULL,\n-\t\t\t     NULL,\n-\t\t\t     lhs_descriptor,\n-\t\t\t     NULL,\n-\t\t\t     NULL,\n-\t\t\t     lhs_descriptor->__reflection,\n-\t\t\t     NULL,\n-\t\t\t     &panic_arg);\n+      runtime_newTypeAssertionError (NULL, NULL, lhs_descriptor->__reflection,\n+\t\t\t\t     NULL, &panic_arg);\n       __go_panic (panic_arg);\n     }\n "}, {"sha": "65babbe12215360bd6d5488aee740090aaa71e9d", "filename": "libgo/runtime/go-callers.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,57 @@\n+/* go-callers.c -- get callers for Go.\n+\n+   Copyright 2012 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+\n+#include \"runtime.h\"\n+\n+/* Argument passed to backtrace function.  */\n+\n+struct callers_data\n+{\n+  int skip;\n+  uintptr *pcbuf;\n+  int index;\n+  int max;\n+};\n+\n+static _Unwind_Reason_Code\n+backtrace (struct _Unwind_Context *context, void *varg)\n+{\n+  struct callers_data *arg = (struct callers_data *) varg;\n+  uintptr pc;\n+\n+  pc = _Unwind_GetIP (context);\n+\n+  /* FIXME: If PC is in the __morestack routine, we should ignore\n+     it.  */\n+\n+  if (arg->skip > 0)\n+    --arg->skip;\n+  else if (arg->index >= arg->max)\n+    return _URC_END_OF_STACK;\n+  else\n+    {\n+      arg->pcbuf[arg->index] = pc;\n+      ++arg->index;\n+    }\n+  return _URC_NO_REASON;\n+}\n+\n+int32\n+runtime_callers (int32 skip, uintptr *pcbuf, int32 m)\n+{\n+  struct callers_data arg;\n+\n+  arg.skip = skip;\n+  arg.pcbuf = pcbuf;\n+  arg.index = 0;\n+  arg.max = m;\n+  _Unwind_Backtrace (backtrace, &arg);\n+  return arg.index;\n+}"}, {"sha": "963559d8ed0737f28722827fee49dc3840633cc5", "filename": "libgo/runtime/go-check-interface.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-check-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-check-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-check-interface.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -6,6 +6,7 @@\n \n #include \"go-panic.h\"\n #include \"interface.h\"\n+#include \"runtime.h\"\n \n /* Check that an interface type matches for a conversion to a\n    non-interface type.  This panics if the types are bad.  The actual\n@@ -21,8 +22,8 @@ __go_check_interface_type (\n     {\n       struct __go_empty_interface panic_arg;\n \n-      newTypeAssertionError(NULL, NULL, lhs_descriptor, NULL, NULL,\n-\t\t\t    lhs_descriptor->__reflection, NULL, &panic_arg);\n+      runtime_newTypeAssertionError(NULL, NULL, lhs_descriptor->__reflection,\n+\t\t\t\t    NULL, &panic_arg);\n       __go_panic(panic_arg);\n     }\n \n@@ -35,12 +36,10 @@ __go_check_interface_type (\n     {\n       struct __go_empty_interface panic_arg;\n \n-      newTypeAssertionError(rhs_inter_descriptor, rhs_descriptor,\n-\t\t\t    lhs_descriptor,\n-\t\t\t    rhs_inter_descriptor->__reflection,\n-\t\t\t    rhs_descriptor->__reflection,\n-\t\t\t    lhs_descriptor->__reflection,\n-\t\t\t    NULL, &panic_arg);\n+      runtime_newTypeAssertionError(rhs_inter_descriptor->__reflection,\n+\t\t\t\t    rhs_descriptor->__reflection,\n+\t\t\t\t    lhs_descriptor->__reflection,\n+\t\t\t\t    NULL, &panic_arg);\n       __go_panic(panic_arg);\n     }\n }"}, {"sha": "8ce82ea5ed617930e701aaf18ce6148132d6dd75", "filename": "libgo/runtime/go-convert-interface.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-convert-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-convert-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-convert-interface.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -8,6 +8,7 @@\n #include \"go-assert.h\"\n #include \"go-panic.h\"\n #include \"interface.h\"\n+#include \"runtime.h\"\n \n /* This is called when converting one interface type into another\n    interface type.  LHS_DESCRIPTOR is the type descriptor of the\n@@ -55,14 +56,10 @@ __go_convert_interface_2 (const struct __go_type_descriptor *lhs_descriptor,\n       if (may_fail)\n \treturn NULL;\n \n-      newTypeAssertionError (NULL,\n-\t\t\t     rhs_descriptor,\n-\t\t\t     lhs_descriptor,\n-\t\t\t     NULL,\n-\t\t\t     rhs_descriptor->__reflection,\n-\t\t\t     lhs_descriptor->__reflection,\n-\t\t\t     lhs_methods[0].__name,\n-\t\t\t     &panic_arg);\n+      runtime_newTypeAssertionError (NULL, rhs_descriptor->__reflection,\n+\t\t\t\t     lhs_descriptor->__reflection,\n+\t\t\t\t     lhs_methods[0].__name,\n+\t\t\t\t     &panic_arg);\n       __go_panic (panic_arg);\n     }\n \n@@ -100,14 +97,9 @@ __go_convert_interface_2 (const struct __go_type_descriptor *lhs_descriptor,\n \t  if (may_fail)\n \t    return NULL;\n \n-\t  newTypeAssertionError (NULL,\n-\t\t\t\t rhs_descriptor,\n-\t\t\t\t lhs_descriptor,\n-\t\t\t\t NULL,\n-\t\t\t\t rhs_descriptor->__reflection,\n-\t\t\t\t lhs_descriptor->__reflection,\n-\t\t\t\t p_lhs_method->__name,\n-\t\t\t\t &panic_arg);\n+\t  runtime_newTypeAssertionError (NULL, rhs_descriptor->__reflection,\n+\t\t\t\t\t lhs_descriptor->__reflection,\n+\t\t\t\t\t p_lhs_method->__name, &panic_arg);\n \t  __go_panic (panic_arg);\n \t}\n "}, {"sha": "5871981f2b826bc65c0af8d8ed9e6ac47e7a095b", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -40,7 +40,7 @@ static void mainstart (void *);\n int\n main (int argc, char **argv)\n {\n-  runtime_initsig (0);\n+  runtime_initsig ();\n   runtime_args (argc, (byte **) argv);\n   runtime_osinit ();\n   runtime_schedinit ();"}, {"sha": "7ba426f51482a1668b2030077881aed1c83b81af", "filename": "libgo/runtime/go-panic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-panic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-panic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -27,7 +27,7 @@ __printpanics (struct __go_panic_stack *p)\n       fprintf (stderr, \"\\t\");\n     }\n   fprintf (stderr, \"panic: \");\n-  printany (p->__arg);\n+  runtime_printany (p->__arg);\n   if (p->__was_recovered)\n     fprintf (stderr, \" [recovered]\");\n   fputc ('\\n', stderr);"}, {"sha": "76411498759893adb9e6187b651d9de6f922de49", "filename": "libgo/runtime/go-panic.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-panic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-panic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.h?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -40,23 +40,4 @@ extern struct __go_empty_interface __go_recover (void);\n \n extern void __go_unwind_stack (void);\n \n-/* Functions defined in libgo/go/runtime/error.go.  */\n-\n-extern void newTypeAssertionError(const struct __go_type_descriptor *pt1,\n-\t\t\t\t  const struct __go_type_descriptor *pt2,\n-\t\t\t\t  const struct __go_type_descriptor *pt3,\n-\t\t\t\t  const struct __go_string *ps1,\n-\t\t\t\t  const struct __go_string *ps2,\n-\t\t\t\t  const struct __go_string *ps3,\n-\t\t\t\t  const struct __go_string *pmeth,\n-\t\t\t\t  struct __go_empty_interface *ret)\n-  __asm__ (\"libgo_runtime.runtime.NewTypeAssertionError\");\n-\n-extern void runtime_newErrorString(struct __go_string,\n-\t\t\t\t   struct __go_empty_interface *)\n-  __asm__ (\"libgo_runtime.runtime.NewErrorString\");\n-\n-extern void printany(struct __go_empty_interface)\n-  __asm__ (\"libgo_runtime.runtime.Printany\");\n-\n #endif /* !defined(LIBGO_GO_PANIC_H) */"}, {"sha": "d14a580554929e115ad23cf525ac69dd2674e1f5", "filename": "libgo/runtime/go-reflect.c", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fruntime%2Fgo-reflect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fruntime%2Fgo-reflect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect.c?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,192 +0,0 @@\n-/* go-reflect.c -- implement unsafe.Reflect and unsafe.Typeof for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdlib.h>\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"interface.h\"\n-#include \"go-alloc.h\"\n-#include \"go-string.h\"\n-#include \"go-type.h\"\n-\n-/* For field alignment.  */\n-\n-struct field_align\n-{\n-  char c;\n-  struct __go_type_descriptor *p;\n-};\n-\n-/* The type descriptors in the runtime package.  */\n-\n-extern const struct __go_type_descriptor ptr_bool_descriptor\n-  asm (\"__go_td_pN30_libgo_runtime.runtime.BoolType\");\n-extern const struct __go_type_descriptor ptr_float_descriptor\n-  asm (\"__go_td_pN31_libgo_runtime.runtime.FloatType\");\n-extern const struct __go_type_descriptor ptr_complex_descriptor\n-  asm (\"__go_td_pN33_libgo_runtime.runtime.ComplexType\");\n-extern const struct __go_type_descriptor ptr_int_descriptor\n-  asm (\"__go_td_pN29_libgo_runtime.runtime.IntType\");\n-extern const struct __go_type_descriptor ptr_uint_descriptor\n-  asm (\"__go_td_pN30_libgo_runtime.runtime.UintType\");\n-extern const struct __go_type_descriptor ptr_string_descriptor\n-  asm (\"__go_td_pN32_libgo_runtime.runtime.StringType\");\n-extern const struct __go_type_descriptor ptr_unsafe_pointer_decriptor\n-  asm (\"__go_td_pN39_libgo_runtime.runtime.UnsafePointerType\");\n-extern const struct __go_type_descriptor ptr_array_descriptor\n-  asm (\"__go_td_pN31_libgo_runtime.runtime.ArrayType\");\n-extern const struct __go_type_descriptor ptr_slice_descriptor\n-  asm (\"__go_td_pN31_libgo_runtime.runtime.SliceType\");\n-extern const struct __go_type_descriptor ptr_chan_descriptor\n-  asm (\"__go_td_pN30_libgo_runtime.runtime.ChanType\");\n-extern const struct __go_type_descriptor ptr_func_descriptor\n-  asm (\"__go_td_pN30_libgo_runtime.runtime.FuncType\");\n-extern const struct __go_type_descriptor ptr_interface_descriptor\n-  asm (\"__go_td_pN35_libgo_runtime.runtime.InterfaceType\");\n-extern const struct __go_type_descriptor ptr_map_descriptor\n-  asm (\"__go_td_pN29_libgo_runtime.runtime.MapType\");\n-extern const struct __go_type_descriptor ptr_ptr_descriptor\n-  asm (\"__go_td_pN29_libgo_runtime.runtime.PtrType\");\n-extern const struct __go_type_descriptor ptr_struct_descriptor\n-  asm (\"__go_td_pN32_libgo_runtime.runtime.StructType\");\n-\n-const struct __go_type_descriptor *\n-get_descriptor (int code)\n-{\n-  switch (code & GO_CODE_MASK)\n-    {\n-    case GO_BOOL:\n-      return &ptr_bool_descriptor;\n-    case GO_FLOAT32:\n-    case GO_FLOAT64:\n-      return &ptr_float_descriptor;\n-    case GO_COMPLEX64:\n-    case GO_COMPLEX128:\n-      return &ptr_complex_descriptor;\n-    case GO_INT16:\n-    case GO_INT32:\n-    case GO_INT64:\n-    case GO_INT8:\n-    case GO_INT:\n-      return &ptr_int_descriptor;\n-    case GO_UINT16:\n-    case GO_UINT32:\n-    case GO_UINT64:\n-    case GO_UINT8:\n-    case GO_UINTPTR:\n-    case GO_UINT:\n-      return &ptr_uint_descriptor;\n-    case GO_STRING:\n-      return &ptr_string_descriptor;\n-    case GO_UNSAFE_POINTER:\n-      return &ptr_unsafe_pointer_decriptor;\n-    case GO_ARRAY:\n-      return &ptr_array_descriptor;\n-    case GO_SLICE:\n-      return &ptr_slice_descriptor;\n-    case GO_CHAN:\n-      return &ptr_chan_descriptor;\n-    case GO_FUNC:\n-      return &ptr_func_descriptor;\n-    case GO_INTERFACE:\n-      return &ptr_interface_descriptor;\n-    case GO_MAP:\n-      return &ptr_map_descriptor;\n-    case GO_PTR:\n-      return &ptr_ptr_descriptor;\n-    case GO_STRUCT:\n-      return &ptr_struct_descriptor;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-/* Implement unsafe.Reflect.  */\n-\n-struct reflect_ret\n-{\n-  struct __go_empty_interface rettype;\n-  void *addr;\n-};\n-\n-struct reflect_ret Reflect (struct __go_empty_interface)\n-  asm (\"libgo_unsafe.unsafe.Reflect\");\n-\n-struct reflect_ret\n-Reflect (struct __go_empty_interface e)\n-{\n-  struct reflect_ret ret;\n-\n-  if (((uintptr_t) e.__type_descriptor & reflectFlags) != 0)\n-    runtime_panicstring (\"invalid interface value\");\n-\n-  if (e.__type_descriptor == NULL)\n-    {\n-      ret.rettype.__type_descriptor = NULL;\n-      ret.rettype.__object = NULL;\n-      ret.addr = NULL;\n-    }\n-  else\n-    {\n-      size_t size;\n-\n-      ret.rettype.__type_descriptor =\n-\tget_descriptor (e.__type_descriptor->__code);\n-\n-      /* This memcpy is really just an assignment of a const pointer\n-\t to a non-const pointer.  FIXME: We should canonicalize this\n-\t pointer, so that for a given type we always return the same\n-\t pointer.  */\n-      __builtin_memcpy (&ret.rettype.__object, &e.__type_descriptor,\n-\t\t\tsizeof (void *));\n-\n-      /* Make a copy of the value.  */\n-      size = e.__type_descriptor->__size;\n-      if (size <= sizeof (uint64_t))\n-\tret.addr = __go_alloc (sizeof (uint64_t));\n-      else\n-\tret.addr = __go_alloc (size);\n-      if (__go_is_pointer_type (e.__type_descriptor))\n-\t*(void **) ret.addr = e.__object;\n-      else\n-\t__builtin_memcpy (ret.addr, e.__object, size);\n-    }\n-\n-  return ret;\n-}\n-\n-/* Implement unsafe.Typeof.  */\n-\n-struct __go_empty_interface Typeof (struct __go_empty_interface)\n-  asm (\"libgo_unsafe.unsafe.Typeof\");\n-\n-struct __go_empty_interface\n-Typeof (const struct __go_empty_interface e)\n-{\n-  struct __go_empty_interface ret;\n-\n-  if (((uintptr_t) e.__type_descriptor & reflectFlags) != 0)\n-    runtime_panicstring (\"invalid interface value\");\n-\n-  if (e.__type_descriptor == NULL)\n-    {\n-      ret.__type_descriptor = NULL;\n-      ret.__object = NULL;\n-    }\n-  else\n-    {\n-      ret.__type_descriptor = get_descriptor (e.__type_descriptor->__code);\n-\n-      /* This memcpy is really just an assignment of a const pointer\n-\t to a non-const pointer.  FIXME: We should canonicalize this\n-\t pointer, so that for a given type we always return the same\n-\t pointer.  */\n-      __builtin_memcpy (&ret.__object, &e.__type_descriptor, sizeof (void *));\n-    }\n-\n-  return ret;\n-}"}, {"sha": "b698ae2b8975975a4bfe1a48ca8b7ac1dbe59384", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 78, "deletions": 138, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -25,11 +25,11 @@ extern void __splitstack_setcontext(void *context[10]);\n \n #endif\n \n-#define C SigCatch\n-#define I SigIgnore\n-#define R SigRestart\n-#define Q SigQueue\n+#define N SigNotify\n+#define K SigKill\n+#define T SigThrow\n #define P SigPanic\n+#define D SigDefault\n \n /* Signal actions.  This collects the sigtab tables for several\n    different targets from the master library.  SIGKILL, SIGCONT, and\n@@ -38,105 +38,105 @@ extern void __splitstack_setcontext(void *context[10]);\n \n SigTab runtime_sigtab[] = {\n #ifdef SIGHUP\n-  { SIGHUP,\tQ + R },\n+  { SIGHUP,\tN + K },\n #endif\n #ifdef SIGINT\n-  { SIGINT, \tQ + R },\n+  { SIGINT, \tN + K },\n #endif\n #ifdef SIGQUIT\n-  { SIGQUIT, \tC },\n+  { SIGQUIT, \tN + T },\n #endif\n #ifdef SIGILL\n-  { SIGILL, \tC },\n+  { SIGILL, \tT },\n #endif\n #ifdef SIGTRAP\n-  { SIGTRAP, \tC },\n+  { SIGTRAP, \tT },\n #endif\n #ifdef SIGABRT\n-  { SIGABRT, \tC },\n+  { SIGABRT, \tN + T },\n #endif\n #ifdef SIGBUS\n-  { SIGBUS, \tC + P },\n+  { SIGBUS, \tP },\n #endif\n #ifdef SIGFPE\n-  { SIGFPE, \tC + P },\n+  { SIGFPE, \tP },\n #endif\n #ifdef SIGUSR1\n-  { SIGUSR1, \tQ + I + R },\n+  { SIGUSR1, \tN },\n #endif\n #ifdef SIGSEGV\n-  { SIGSEGV, \tC + P },\n+  { SIGSEGV, \tP },\n #endif\n #ifdef SIGUSR2\n-  { SIGUSR2, \tQ + I + R },\n+  { SIGUSR2, \tN },\n #endif\n #ifdef SIGPIPE\n-  { SIGPIPE, \tI },\n+  { SIGPIPE, \tN },\n #endif\n #ifdef SIGALRM\n-  { SIGALRM, \tQ + I + R },\n+  { SIGALRM, \tN },\n #endif\n #ifdef SIGTERM\n-  { SIGTERM, \tQ + R },\n+  { SIGTERM, \tN + K },\n #endif\n #ifdef SIGSTKFLT\n-  { SIGSTKFLT, \tC },\n+  { SIGSTKFLT, \tT },\n #endif\n #ifdef SIGCHLD\n-  { SIGCHLD, \tQ + I + R },\n+  { SIGCHLD, \tN },\n #endif\n #ifdef SIGTSTP\n-  { SIGTSTP, \tQ + I + R },\n+  { SIGTSTP, \tN + D },\n #endif\n #ifdef SIGTTIN\n-  { SIGTTIN, \tQ + I + R },\n+  { SIGTTIN, \tN + D },\n #endif\n #ifdef SIGTTOU\n-  { SIGTTOU, \tQ + I + R },\n+  { SIGTTOU, \tN + D },\n #endif\n #ifdef SIGURG\n-  { SIGURG, \tQ + I + R },\n+  { SIGURG, \tN },\n #endif\n #ifdef SIGXCPU\n-  { SIGXCPU, \tQ + I + R },\n+  { SIGXCPU, \tN },\n #endif\n #ifdef SIGXFSZ\n-  { SIGXFSZ, \tQ + I + R },\n+  { SIGXFSZ, \tN },\n #endif\n #ifdef SIGVTALRM\n-  { SIGVTALRM, \tQ + I + R },\n+  { SIGVTALRM, \tN },\n #endif\n #ifdef SIGPROF\n-  { SIGPROF, \tQ + I + R },\n+  { SIGPROF, \tN },\n #endif\n #ifdef SIGWINCH\n-  { SIGWINCH, \tQ + I + R },\n+  { SIGWINCH, \tN },\n #endif\n #ifdef SIGIO\n-  { SIGIO, \tQ + I + R },\n+  { SIGIO, \tN },\n #endif\n #ifdef SIGPWR\n-  { SIGPWR, \tQ + I + R },\n+  { SIGPWR, \tN },\n #endif\n #ifdef SIGSYS\n-  { SIGSYS, \tC },\n+  { SIGSYS, \tN },\n #endif\n #ifdef SIGEMT\n-  { SIGEMT,\tC },\n+  { SIGEMT,\tT },\n #endif\n #ifdef SIGINFO\n-  { SIGINFO,\tQ + I + R },\n+  { SIGINFO,\tN },\n #endif\n #ifdef SIGTHR\n-  { SIGTHR,\tQ + I + R },\n+  { SIGTHR,\tN },\n #endif\n   { -1,\t\t0 }\n };\n-#undef C\n-#undef I\n-#undef R\n-#undef Q\n+#undef N\n+#undef K\n+#undef T\n #undef P\n+#undef D\n \n /* Handle a signal, for cases where we don't panic.  We can split the\n    stack here.  */\n@@ -158,21 +158,24 @@ sig_handler (int sig)\n   for (i = 0; runtime_sigtab[i].sig != -1; ++i)\n     {\n       struct sigaction sa;\n+      SigTab *t;\n \n-      if (runtime_sigtab[i].sig != sig)\n+      t = &runtime_sigtab[i];\n+\n+      if (t->sig != sig)\n \tcontinue;\n \n-      if ((runtime_sigtab[i].flags & SigQueue) != 0)\n+      if ((t->flags & SigNotify) != 0)\n \t{\n-\t  if (__go_sigsend (sig)\n-\t      || (runtime_sigtab[sig].flags & SigIgnore) != 0)\n+\t  if (__go_sigsend (sig))\n \t    return;\n-\t  runtime_exit (2);\t\t// SIGINT, SIGTERM, etc\n \t}\n-\n-      if (runtime_panicking)\n+      if ((t->flags & SigKill) != 0)\n \truntime_exit (2);\n-      runtime_panicking = 1;\n+      if ((t->flags & SigThrow) == 0)\n+\treturn;\n+\n+      runtime_startpanic ();\n \n       /* We should do a stack backtrace here.  Until we can do that,\n \t we reraise the signal in order to get a slightly better\n@@ -227,7 +230,7 @@ static void\n sig_panic_info_handler (int sig, siginfo_t *info,\n \t\t\tvoid *context __attribute__ ((unused)))\n {\n-  if (runtime_g () == NULL)\n+  if (runtime_g () == NULL || info->si_code == SI_USER)\n     {\n       sig_handler (sig);\n       return;\n@@ -316,16 +319,6 @@ sig_panic_handler (int sig)\n \n #endif /* !defined (SA_SIGINFO) */\n \n-/* Ignore a signal.  This is called on the alternate signal stack so\n-   it may not split the stack.  */\n-\n-static void sig_ignore (int) __attribute__ ((no_split_stack));\n-\n-static void\n-sig_ignore (int sig __attribute__ ((unused)))\n-{\n-}\n-\n /* A signal handler used for signals which are not going to panic.\n    This is called on the alternate signal stack so it may not split\n    the stack.  */\n@@ -376,100 +369,41 @@ sig_tramp (int sig)\n     }\n }\n \n-/* Initialize signal handling for Go.  This is called when the program\n-   starts.  */\n-\n void\n-runtime_initsig (int32 queue)\n+runtime_setsig (int32 i, bool def __attribute__ ((unused)), bool restart)\n {\n   struct sigaction sa;\n-  int i;\n-\n-  siginit ();\n+  int r;\n+  SigTab *t;\n \n   memset (&sa, 0, sizeof sa);\n \n-  i = sigfillset (&sa.sa_mask);\n-  __go_assert (i == 0);\n-\n-  for (i = 0; runtime_sigtab[i].sig != -1; ++i)\n-    {\n-      if (runtime_sigtab[i].flags == 0)\n-\tcontinue;\n-      if ((runtime_sigtab[i].flags & SigQueue) != queue)\n-\tcontinue;\n-\n-      if ((runtime_sigtab[i].flags & (SigCatch | SigQueue)) != 0)\n-\t{\n-\t  if ((runtime_sigtab[i].flags & SigPanic) == 0)\n-\t    {\n-\t      sa.sa_flags = SA_ONSTACK;\n-\t      sa.sa_handler = sig_tramp;\n-\t    }\n-\t  else\n-\t    {\n-#ifdef SA_SIGINFO\n-\t      sa.sa_flags = SA_SIGINFO;\n-\t      sa.sa_sigaction = sig_panic_info_handler;\n-#else\n-\t      sa.sa_flags = 0;\n-\t      sa.sa_handler = sig_panic_handler;\n-#endif\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  sa.sa_flags = SA_ONSTACK;\n-\t  sa.sa_handler = sig_ignore;\n-\t}\n+  r = sigfillset (&sa.sa_mask);\n+  __go_assert (r == 0);\n \n-      if ((runtime_sigtab[i].flags & SigRestart) != 0)\n-\tsa.sa_flags |= SA_RESTART;\n+  t = &runtime_sigtab[i];\n \n-      if (sigaction (runtime_sigtab[i].sig, &sa, NULL) != 0)\n-\t__go_assert (0);\n-    }\n-}\n-\n-void\n-runtime_resetcpuprofiler(int32 hz)\n-{\n-#ifdef SIGPROF\n-  struct itimerval it;\n-  struct sigaction sa;\n-  int i;\n-\n-  memset (&it, 0, sizeof it);\n-\n-  memset (&sa, 0, sizeof sa);\n-  i = sigfillset (&sa.sa_mask);\n-  __go_assert (i == 0);\n-\n-  if (hz == 0)\n+  if ((t->flags & SigPanic) == 0)\n     {\n-      i = setitimer (ITIMER_PROF, &it, NULL);\n-      __go_assert (i == 0);\n-\n-      sa.sa_handler = SIG_IGN;\n-      i = sigaction (SIGPROF, &sa, NULL);\n-      __go_assert (i == 0);\n+      sa.sa_flags = SA_ONSTACK;\n+      sa.sa_handler = sig_tramp;\n     }\n   else\n     {\n-      sa.sa_handler = sig_handler;\n-      sa.sa_flags = SA_RESTART;\n-      i = sigaction (SIGPROF, &sa, NULL);\n-      __go_assert (i == 0);\n-\n-      it.it_interval.tv_sec = 0;\n-      it.it_interval.tv_usec = 1000000 / hz;\n-      it.it_value = it.it_interval;\n-      i = setitimer (ITIMER_PROF, &it, NULL);\n-      __go_assert (i == 0);\n-    }\n+#ifdef SA_SIGINFO\n+      sa.sa_flags = SA_SIGINFO;\n+      sa.sa_sigaction = sig_panic_info_handler;\n+#else\n+      sa.sa_flags = 0;\n+      sa.sa_handler = sig_panic_handler;\n #endif\n+    }\n+\n+  if (restart)\n+    sa.sa_flags |= SA_RESTART;\n \n-  runtime_m()->profilehz = hz;\n+  if (sigaction (t->sig, &sa, NULL) != 0)\n+    __go_assert (0);\n }\n \n /* Used by the os package to raise SIGPIPE.  */\n@@ -494,3 +428,9 @@ os_sigpipe (void)\n \n   raise (SIGPIPE);\n }\n+\n+void\n+runtime_setprof(bool on)\n+{\n+\tUSED(on);\n+}"}, {"sha": "6f1ea732fa3f30d120e013272662794b47bf4266", "filename": "libgo/runtime/go-unreflect.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fruntime%2Fgo-unreflect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2f581b00ac6759f6366c16ef902c935163aa13/libgo%2Fruntime%2Fgo-unreflect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unreflect.c?ref=ff2f581b00ac6759f6366c16ef902c935163aa13", "patch": "@@ -1,34 +0,0 @@\n-/* go-unreflect.c -- implement unsafe.Unreflect for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Implement unsafe.Unreflect.  */\n-\n-struct __go_empty_interface Unreflect (struct __go_empty_interface type,\n-\t\t\t\t       void *object)\n-  asm (\"libgo_unsafe.unsafe.Unreflect\");\n-\n-struct __go_empty_interface\n-Unreflect (struct __go_empty_interface type, void *object)\n-{\n-  struct __go_empty_interface ret;\n-\n-  if (((uintptr_t) type.__type_descriptor & reflectFlags) != 0)\n-    runtime_panicstring (\"invalid interface value\");\n-\n-  /* FIXME: We should check __type_descriptor to verify that this is\n-     really a type descriptor.  */\n-  ret.__type_descriptor = type.__object;\n-  if (__go_is_pointer_type (ret.__type_descriptor))\n-    ret.__object = *(void **) object;\n-  else\n-    ret.__object = object;\n-  return ret;\n-}"}, {"sha": "2b9e044dc33a00590573f8f1214db381313705ef", "filename": "libgo/runtime/go-unsafe-new.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-unsafe-new.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-unsafe-new.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-new.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,15 +9,16 @@\n #include \"go-type.h\"\n #include \"interface.h\"\n \n-/* Implement unsafe.New.  */\n+/* Implement unsafe_New, called from the reflect package.  */\n \n-void *New (struct __go_empty_interface type) asm (\"libgo_unsafe.unsafe.New\");\n+void *unsafe_New (struct __go_empty_interface type)\n+  asm (\"libgo_reflect.reflect.unsafe_New\");\n \n /* The dynamic type of the argument will be a pointer to a type\n    descriptor.  */\n \n void *\n-New (struct __go_empty_interface type)\n+unsafe_New (struct __go_empty_interface type)\n {\n   const struct __go_type_descriptor *descriptor;\n "}, {"sha": "f4c5595d46323277263d8827b1a42b760cae511e", "filename": "libgo/runtime/go-unsafe-newarray.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-unsafe-newarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fgo-unsafe-newarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-newarray.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -9,16 +9,16 @@\n #include \"go-type.h\"\n #include \"interface.h\"\n \n-/* Implement unsafe.NewArray.  */\n+/* Implement unsafe_NewArray, called from the reflect package.  */\n \n-void *NewArray (struct __go_empty_interface type, int n)\n-  asm (\"libgo_unsafe.unsafe.NewArray\");\n+void *unsafe_NewArray (struct __go_empty_interface type, int n)\n+  asm (\"libgo_reflect.reflect.unsafe_NewArray\");\n \n /* The dynamic type of the argument will be a pointer to a type\n    descriptor.  */\n \n void *\n-NewArray (struct __go_empty_interface type, int n)\n+unsafe_NewArray (struct __go_empty_interface type, int n)\n {\n   const struct __go_type_descriptor *descriptor;\n "}, {"sha": "8b48c8663464191967825fd9867d113665b4a718", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -279,6 +279,15 @@ runtime_mallocinit(void)\n \n \truntime_sizeof_C_MStats = sizeof(MStats);\n \n+\tp = nil;\n+\tarena_size = 0;\n+\tbitmap_size = 0;\n+\t\n+\t// for 64-bit build\n+\tUSED(p);\n+\tUSED(arena_size);\n+\tUSED(bitmap_size);\n+\n \truntime_InitSizes();\n \n \t// Set up the allocation arena, a contiguous area of memory where\n@@ -307,12 +316,13 @@ runtime_mallocinit(void)\n \t\t// Actually we reserve 17 GB (because the bitmap ends up being 1 GB)\n \t\t// but it hardly matters: fc is not valid UTF-8 either, and we have to\n \t\t// allocate 15 GB before we get that far.\n+\t\t//\n+\t\t// If this fails we fall back to the 32 bit memory mechanism\n \t\tarena_size = (uintptr)(16LL<<30);\n \t\tbitmap_size = arena_size / (sizeof(void*)*8/4);\n \t\tp = runtime_SysReserve((void*)(0x00f8ULL<<32), bitmap_size + arena_size);\n-\t\tif(p == nil)\n-\t\t\truntime_throw(\"runtime: cannot reserve arena virtual address space\");\n-\t} else {\n+\t}\n+\tif (p == nil) {\n \t\t// On a 32-bit machine, we can't typically get away\n \t\t// with a giant virtual address space reservation.\n \t\t// Instead we map the memory information bitmap\n@@ -379,8 +389,8 @@ runtime_MHeap_SysAlloc(MHeap *h, uintptr n)\n \t\treturn p;\n \t}\n \t\n-\t// On 64-bit, our reservation is all we have.\n-\tif(sizeof(void*) == 8)\n+\t// If using 64-bit, our reservation is all we have.\n+\tif(sizeof(void*) == 8 && (uintptr)h->bitmap >= 0xffffffffU)\n \t\treturn nil;\n \n \t// On 32-bit, once the reservation is gone we can"}, {"sha": "05f071ae06c4a5a7c018aa9dc3973c689cb11d4a", "filename": "libgo/runtime/mem.c", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -39,6 +39,22 @@ addrspace_free(void *v __attribute__ ((unused)), uintptr n __attribute__ ((unuse\n \treturn 1;\n }\n \n+static void *\n+mmap_fixed(byte *v, uintptr n, int32 prot, int32 flags, int32 fd, uint32 offset)\n+{\n+\tvoid *p;\n+\n+\tp = runtime_mmap(v, n, prot, flags, fd, offset);\n+\tif(p != v && addrspace_free(v, n)) {\n+\t\t// On some systems, mmap ignores v without\n+\t\t// MAP_FIXED, so retry if the address space is free.\n+\t\tif(p != MAP_FAILED)\n+\t\t\truntime_munmap(p, n);\n+\t\tp = runtime_mmap(v, n, prot, flags|MAP_FIXED, fd, offset);\n+\t}\n+\treturn p;\n+}\n+\n void*\n runtime_SysAlloc(uintptr n)\n {\n@@ -91,12 +107,6 @@ runtime_SysReserve(void *v, uintptr n)\n \tint fd = -1;\n \tvoid *p;\n \n-\t// On 64-bit, people with ulimit -v set complain if we reserve too\n-\t// much address space.  Instead, assume that the reservation is okay\n-\t// and check the assumption in SysMap.\n-\tif(sizeof(void*) == 8)\n-\t\treturn v;\n-\t\n #ifdef USE_DEV_ZERO\n \tif (dev_zero == -1) {\n \t\tdev_zero = open(\"/dev/zero\", O_RDONLY);\n@@ -108,10 +118,21 @@ runtime_SysReserve(void *v, uintptr n)\n \tfd = dev_zero;\n #endif\n \n+\t// On 64-bit, people with ulimit -v set complain if we reserve too\n+\t// much address space.  Instead, assume that the reservation is okay\n+\t// if we can reserve at least 64K and check the assumption in SysMap.\n+\t// Only user-mode Linux (UML) rejects these requests.\n+\tif(sizeof(void*) == 8 && (uintptr)v >= 0xffffffffU) {\n+\t\tp = mmap_fixed(v, 64<<10, PROT_NONE, MAP_ANON|MAP_PRIVATE, fd, 0);\n+\t\tif (p != v)\n+\t\t\treturn nil;\n+\t\truntime_munmap(p, 64<<10);\n+\t\treturn v;\n+\t}\n+\t\n \tp = runtime_mmap(v, n, PROT_NONE, MAP_ANON|MAP_PRIVATE, fd, 0);\n-\tif((uintptr)p < 4096 || -(uintptr)p < 4096) {\n+\tif(p == MAP_FAILED)\n \t\treturn nil;\n-\t}\n \treturn p;\n }\n \n@@ -135,13 +156,10 @@ runtime_SysMap(void *v, uintptr n)\n #endif\n \n \t// On 64-bit, we don't actually have v reserved, so tread carefully.\n-\tif(sizeof(void*) == 8) {\n-\t\tp = runtime_mmap(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_PRIVATE, fd, 0);\n-\t\tif(p != v && addrspace_free(v, n)) {\n-\t\t\t// On some systems, mmap ignores v without\n-\t\t\t// MAP_FIXED, so retry if the address space is free.\n-\t\t\tp = runtime_mmap(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_FIXED|MAP_PRIVATE, fd, 0);\n-\t\t}\n+\tif(sizeof(void*) == 8 && (uintptr)v >= 0xffffffffU) {\n+\t\tp = mmap_fixed(v, n, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANON|MAP_PRIVATE, fd, 0);\n+\t\tif(p == MAP_FAILED && errno == ENOMEM)\n+\t\t\truntime_throw(\"runtime: out of memory\");\n \t\tif(p != v) {\n \t\t\truntime_printf(\"runtime: address space conflict: map(%p) = %p\\n\", v, p);\n \t\t\truntime_throw(\"runtime: address space conflict\");"}, {"sha": "95e05fabeb3958f2d889defafbd54efdb1ac0f79", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -240,7 +240,7 @@ runtime_MProf_Free(void *p, uintptr size)\n // Go interface to profile data.  (Declared in extern.go)\n // Assumes Go sizeof(int) == sizeof(int32)\n \n-// Must match MemProfileRecord in extern.go.\n+// Must match MemProfileRecord in debug.go.\n typedef struct Record Record;\n struct Record {\n \tint64 alloc_bytes, free_bytes;\n@@ -292,3 +292,28 @@ runtime_MProf_Mark(void (*scan)(byte *, int64))\n \tscan((byte*)&addrhash, sizeof addrhash);\n \tscan((byte*)&addrfree, sizeof addrfree);\n }\n+\n+// Must match ThreadProfileRecord in debug.go.\n+typedef struct TRecord TRecord;\n+struct TRecord {\n+\tuintptr stk[32];\n+};\n+\n+func ThreadProfile(p Slice) (n int32, ok bool) {\n+\tTRecord *r;\n+\tM *first, *m;\n+\t\n+\tfirst = runtime_atomicloadp(&runtime_allm);\n+\tn = 0;\n+\tfor(m=first; m; m=m->alllink)\n+\t\tn++;\n+\tok = false;\n+\tif(n <= p.__count) {\n+\t\tok = true;\n+\t\tr = (TRecord*)p.__values;\n+\t\tfor(m=first; m; m=m->alllink) {\n+\t\t\truntime_memmove(r->stk, m->createstack, sizeof r->stk);\n+\t\t\tr++;\n+\t\t}\n+\t}\n+}"}, {"sha": "a4e4588299e47e631c81a579c0ac1d7383cfc540", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -536,18 +536,20 @@ runtime_idlegoroutine(void)\n static void\n mcommoninit(M *m)\n {\n-\t// Add to runtime_allm so garbage collector doesn't free m\n-\t// when it is just in a register or thread-local storage.\n-\tm->alllink = runtime_allm;\n-\t// runtime_Cgocalls() iterates over allm w/o schedlock,\n-\t// so we need to publish it safely.\n-\truntime_atomicstorep((void**)&runtime_allm, m);\n-\n \tm->id = runtime_sched.mcount++;\n \tm->fastrand = 0x49f6428aUL + m->id + runtime_cputicks();\n \n \tif(m->mcache == nil)\n \t\tm->mcache = runtime_allocmcache();\n+\n+\truntime_callers(1, m->createstack, nelem(m->createstack));\n+\t\n+\t// Add to runtime_allm so garbage collector doesn't free m\n+\t// when it is just in a register or thread-local storage.\n+\tm->alllink = runtime_allm;\n+\t// runtime_Cgocalls() iterates over allm w/o schedlock,\n+\t// so we need to publish it safely.\n+\truntime_atomicstorep(&runtime_allm, m);\n }\n \n // Try to increment mcpu.  Report whether succeeded."}, {"sha": "447b786a8d848436ee5da170676f119d381e7de8", "filename": "libgo/runtime/reflect.goc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Freflect.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Freflect.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Freflect.goc?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -17,10 +17,10 @@ func ifaceE2I(inter *Type, e Eface, ret *Iface) {\n \tt = e.__type_descriptor;\n \tif(t == nil) {\n \t\t// explicit conversions require non-nil interface value.\n-\t\tnewTypeAssertionError(nil, nil, inter,\n+\t\truntime_newTypeAssertionError(\n \t\t\tnil, nil, inter->__reflection,\n \t\t\tnil, &err);\n-\t\t__go_panic(err);\n+\t\truntime_panic(err);\n \t}\n \tret->__object = e.__object;\n \tret->__methods = __go_convert_interface(inter, t);"}, {"sha": "713af1744910bdb287f87fbf36297d708c162c2f", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -174,6 +174,7 @@ struct\tM\n \tMCache\t*mcache;\n \tG*\tlockedg;\n \tG*\tidleg;\n+\tuintptr\tcreatestack[32];\t// Stack that created this thread.\n \tM*\tnextwaitm;\t// next M waiting for lock\n \tuintptr\twaitsema;\t// semaphore for parking on locks\n \tuint32\twaitsemacount;\n@@ -187,13 +188,17 @@ struct\tSigTab\n };\n enum\n {\n-\tSigCatch = 1<<0,\n-\tSigIgnore = 1<<1,\n-\tSigRestart = 1<<2,\n-\tSigQueue = 1<<3,\n-\tSigPanic = 1<<4,\n+\tSigNotify = 1<<0,\t// let signal.Notify have signal, even if from kernel\n+\tSigKill = 1<<1,  // if signal.Notify doesn't take it, exit quietly\n+\tSigThrow = 1<<2,  // if signal.Notify doesn't take it, exit loudly\n+\tSigPanic = 1<<3,  // if the signal is from the kernel, panic\n+\tSigDefault = 1<<4,\t// if the signal isn't explicitly requested, don't monitor it\n };\n \n+#ifndef NSIG\n+#define NSIG 32\n+#endif\n+\n /* Macros.  */\n \n #ifdef GOOS_windows\n@@ -271,7 +276,7 @@ void\truntime_throw(const char*) __attribute__ ((noreturn));\n void\truntime_panicstring(const char*) __attribute__ ((noreturn));\n void*\truntime_mal(uintptr);\n void\truntime_schedinit(void);\n-void\truntime_initsig(int32);\n+void\truntime_initsig(void);\n String\truntime_gostringnocopy(const byte*);\n void*\truntime_mstart(void*);\n G*\truntime_malg(int32, byte**, size_t*);\n@@ -285,6 +290,7 @@ void\truntime_entersyscall(void) __asm__(\"libgo_syscall.syscall.entersyscall\");\n void\truntime_exitsyscall(void) __asm__(\"libgo_syscall.syscall.exitsyscall\");\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n+int32\truntime_callers(int32, uintptr*, int32);\n int64\truntime_nanotime(void);\n int64\truntime_cputicks(void);\n \n@@ -335,10 +341,26 @@ void\truntime_semawakeup(M*);\n void\truntime_futexsleep(uint32*, uint32, int64);\n void\truntime_futexwakeup(uint32*, uint32);\n \n+/*\n+ * low level C-called\n+ */\n+#define runtime_mmap mmap\n+#define runtime_munmap munmap\n+#define runtime_madvise madvise\n+#define runtime_memclr(buf, size) __builtin_memset((buf), 0, (size))\n+\n+#ifdef __rtems__\n+void __wrap_rtems_task_variable_add(void **);\n+#endif\n+\n /*\n  * runtime go-called\n  */\n void\truntime_panic(Eface);\n+struct __go_func_type;\n+void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,\n+\t\t  void **, void **)\n+  asm (\"libgo_reflect.reflect.call\");\n \n /* Functions.  */\n #define runtime_panic __go_panic\n@@ -374,29 +396,40 @@ void\truntime_resetcpuprofiler(int32);\n void\truntime_setcpuprofilerate(void(*)(uintptr*, int32), int32);\n void\truntime_usleep(uint32);\n \n+/*\n+ * runtime c-called (but written in Go)\n+ */\n+void\truntime_newError(String, Eface*);\n+void\truntime_printany(Eface)\n+     __asm__(\"libgo_runtime.runtime.Printany\");\n+void\truntime_newTypeAssertionError(const String*, const String*, const String*, const String*, Eface*)\n+     __asm__(\"libgo_runtime.runtime.NewTypeAssertionError\");\n+void\truntime_newErrorString(String, Eface*)\n+     __asm__(\"libgo_runtime.runtime.NewErrorString\");\n+\n+/*\n+ * wrapped for go users\n+ */\n void\truntime_semacquire(uint32 volatile *);\n void\truntime_semrelease(uint32 volatile *);\n+String\truntime_signame(int32 sig);\n int32\truntime_gomaxprocsfunc(int32 n);\n void\truntime_procyield(uint32);\n void\truntime_osyield(void);\n void\truntime_LockOSThread(void) __asm__(\"libgo_runtime.runtime.LockOSThread\");\n void\truntime_UnlockOSThread(void) __asm__(\"libgo_runtime.runtime.UnlockOSThread\");\n \n-/*\n- * low level C-called\n- */\n-#define runtime_mmap mmap\n-#define runtime_munmap munmap\n-#define runtime_madvise madvise\n-#define runtime_memclr(buf, size) __builtin_memset((buf), 0, (size))\n-\n-struct __go_func_type;\n-void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,\n-\t\t  void **, void **)\n-  asm (\"libgo_reflect.reflect.call\");\n-\n-#ifdef __rtems__\n-void __wrap_rtems_task_variable_add(void **);\n-#endif\n+// If appropriate, ask the operating system to control whether this\n+// thread should receive profiling signals.  This is only necessary on OS X.\n+// An operating system should not deliver a profiling signal to a\n+// thread that is not actually executing (what good is that?), but that's\n+// what OS X prefers to do.  When profiling is turned on, we mask\n+// away the profiling signal when threads go to sleep, so that OS X\n+// is forced to deliver the signal to a thread that's actually running.\n+// This is a no-op on other systems.\n+void\truntime_setprof(bool);\n \n void\truntime_time_scan(void (*)(byte*, int64));\n+\n+void\truntime_setsig(int32, bool, bool);\n+#define runtime_setitimer setitimer"}, {"sha": "3b8f4393708a80be223a78ce88a681f0a37625ea", "filename": "libgo/runtime/signal_unix.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fsignal_unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fsignal_unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsignal_unix.c?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux openbsd netbsd\n+\n+#include <sys/time.h>\n+\n+#include \"runtime.h\"\n+#include \"defs.h\"\n+\n+extern SigTab runtime_sigtab[];\n+\n+void\n+runtime_initsig(void)\n+{\n+\tint32 i;\n+\tSigTab *t;\n+\n+\t// First call: basic setup.\n+\tfor(i = 0; runtime_sigtab[i].sig != -1; i++) {\n+\t\tt = &runtime_sigtab[i];\n+\t\tif((t->flags == 0) || (t->flags & SigDefault))\n+\t\t\tcontinue;\n+\t\truntime_setsig(i, false, true);\n+\t}\n+}\n+\n+void\n+runtime_sigenable(uint32 sig)\n+{\n+\tint32 i;\n+\tSigTab *t;\n+\n+\tfor(i = 0; runtime_sigtab[i].sig != -1; i++) {\n+\t\t// ~0 means all signals.\n+\t\tif(~sig == 0 || runtime_sigtab[i].sig == (int32)sig) {\n+\t\t\tt = &runtime_sigtab[i];\n+\t\t\tif(t->flags & SigDefault) {\n+\t\t\t\truntime_setsig(i, false, true);\n+\t\t\t\tt->flags &= ~SigDefault;  // make this idempotent\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+void\n+runtime_resetcpuprofiler(int32 hz)\n+{\n+\tstruct itimerval it;\n+\n+\truntime_memclr((byte*)&it, sizeof it);\n+\tif(hz == 0) {\n+\t\truntime_setitimer(ITIMER_PROF, &it, nil);\n+\t\truntime_setprof(false);\n+\t} else {\n+\t\tit.it_interval.tv_sec = 0;\n+\t\tit.it_interval.tv_usec = 1000000 / hz;\n+\t\tit.it_value = it.it_interval;\n+\t\truntime_setitimer(ITIMER_PROF, &it, nil);\n+\t\truntime_setprof(true);\n+\t}\n+\truntime_m()->profilehz = hz;\n+}"}, {"sha": "c550a4ebe9b864203c03870155ffd76905916538", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 78, "deletions": 42, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=cbb6491d76c7aa81cdf5d3b3a81386129c5e2fce", "patch": "@@ -11,7 +11,7 @@\n //\n // Ownership for sig.Note passes back and forth between\n // the signal handler and the signal goroutine in rounds.\n-// The initial state is that sig.note is cleared (setup by siginit).\n+// The initial state is that sig.note is cleared (setup by signal_enable).\n // At the beginning of each round, mask == 0.\n // The round goes through three stages:\n //\n@@ -36,7 +36,7 @@\n // ownership by returning from notesleep (caused by the notewakeup)\n // and gives up ownership by clearing mask.\n \n-package runtime\n+package signal\n #include \"config.h\"\n #include \"runtime.h\"\n #include \"arch.h\"\n@@ -45,71 +45,107 @@ package runtime\n \n static struct {\n \tNote;\n-\tuint32 mask;\n+\tuint32 mask[(NSIG+31)/32];\n+\tuint32 wanted[(NSIG+31)/32];\n+\tuint32 kick;\n \tbool inuse;\n } sig;\n \n-void\n-siginit(void)\n-{\n-\truntime_noteclear(&sig);\n-}\n-\n // Called from sighandler to send a signal back out of the signal handling thread.\n bool\n __go_sigsend(int32 s)\n {\n \tuint32 bit, mask;\n \n-\tif(!sig.inuse)\n+\tif(!sig.inuse || s < 0 || (size_t)s >= 32*nelem(sig.wanted) || !(sig.wanted[s/32]&(1U<<(s&31))))\n \t\treturn false;\n-\tbit = 1 << s;\n+\tbit = 1 << (s&31);\n \tfor(;;) {\n-\t\tmask = sig.mask;\n+\t\tmask = sig.mask[s/32];\n \t\tif(mask & bit)\n \t\t\tbreak;\t\t// signal already in queue\n-\t\tif(runtime_cas(&sig.mask, mask, mask|bit)) {\n+\t\tif(runtime_cas(&sig.mask[s/32], mask, mask|bit)) {\n \t\t\t// Added to queue.\n-\t\t\t// Only send a wakeup for the first signal in each round.\n-\t\t\tif(mask == 0)\n+\t\t\t// Only send a wakeup if the receiver needs a kick.\n+\t\t\tif(runtime_cas(&sig.kick, 1, 0))\n \t\t\t\truntime_notewakeup(&sig);\n \t\t\tbreak;\n \t\t}\n \t}\n \treturn true;\n }\n \n-// Called to receive a bitmask of queued signals.\n-func Sigrecv() (m uint32) {\n-\truntime_entersyscall();\n-\truntime_notesleep(&sig);\n-\truntime_exitsyscall();\n-\truntime_noteclear(&sig);\n+// Called to receive the next queued signal.\n+// Must only be called from a single goroutine at a time.\n+func signal_recv() (m uint32) {\n+\tstatic uint32 recv[nelem(sig.mask)];\n+\tint32 i, more;\n+\t\n \tfor(;;) {\n-\t\tm = sig.mask;\n-\t\tif(runtime_cas(&sig.mask, m, 0))\n-\t\t\tbreak;\n+\t\t// Serve from local copy if there are bits left.\n+\t\tfor(i=0; i<NSIG; i++) {\n+\t\t\tif(recv[i/32]&(1U<<(i&31))) {\n+\t\t\t\trecv[i/32] ^= 1U<<(i&31);\n+\t\t\t\tm = i;\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Get a new local copy.\n+\t\t// Ask for a kick if more signals come in\n+\t\t// during or after our check (before the sleep).\n+\t\tif(sig.kick == 0) {\n+\t\t\truntime_noteclear(&sig);\n+\t\t\truntime_cas(&sig.kick, 0, 1);\n+\t\t}\n+\n+\t\tmore = 0;\n+\t\tfor(i=0; (size_t)i<nelem(sig.mask); i++) {\n+\t\t\tfor(;;) {\n+\t\t\t\tm = sig.mask[i];\n+\t\t\t\tif(runtime_cas(&sig.mask[i], m, 0))\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\trecv[i] = m;\n+\t\t\tif(m != 0)\n+\t\t\t\tmore = 1;\n+\t\t}\n+\t\tif(more)\n+\t\t\tcontinue;\n+\n+\t\t// Sleep waiting for more.\n+\t\truntime_entersyscall();\n+\t\truntime_notesleep(&sig);\n+\t\truntime_exitsyscall();\n \t}\n+\n+done:;\n+\t// goc requires that we fall off the end of functions\n+\t// that return values instead of using our own return\n+\t// statements.\n }\n \n-func Signame(sig int32) (name String) {\n-\tconst char* s = NULL;\n-\tchar buf[100];\n-#if defined(HAVE_STRSIGNAL)\n-\ts = strsignal(sig);\n-#endif\n-\tif (s == NULL) {\n-\t\tsnprintf(buf, sizeof buf, \"signal %d\", sig);\n-\t\ts = buf;\n+// Must only be called from a single goroutine at a time.\n+func signal_enable(s uint32) {\n+\tint32 i;\n+\n+\tif(!sig.inuse) {\n+\t\t// The first call to signal_enable is for us\n+\t\t// to use for initialization.  It does not pass\n+\t\t// signal information in m.\n+\t\tsig.inuse = true;\t// enable reception of signals; cannot disable\n+\t\truntime_noteclear(&sig);\n+\t\treturn;\n+\t}\n+\t\n+\tif(~s == 0) {\n+\t\t// Special case: want everything.\n+\t\tfor(i=0; (size_t)i<nelem(sig.wanted); i++)\n+\t\t\tsig.wanted[i] = ~(uint32)0;\n+\t\treturn;\n \t}\n-\tint32 len = __builtin_strlen(s);\n-\tunsigned char *data = runtime_mallocgc(len, FlagNoPointers, 0, 0);\n-\t__builtin_memcpy(data, s, len);\n-\tname.__data = data;\n-\tname.__length = len;\n-}\n \n-func Siginit() {\n-\truntime_initsig(SigQueue);\n-\tsig.inuse = true;\t// enable reception of signals; cannot disable\n+\tif(s >= nelem(sig.wanted)*32)\n+\t\treturn;\n+\tsig.wanted[s/32] |= 1U<<(s&31);\n }"}]}