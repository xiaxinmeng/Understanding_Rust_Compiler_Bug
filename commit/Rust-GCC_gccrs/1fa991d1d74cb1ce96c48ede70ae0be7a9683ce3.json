{"sha": "1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZhOTkxZDFkNzRjYjFjZTk2YzQ4ZWRlNzBhZTBiZTdhOTY4M2NlMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-06-11T10:31:42Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-06-11T10:32:40Z"}, "message": "i386: Try to avoid variable permutation instruction [PR101021]\n\nSome permutations can be implemented without costly PSHUFB instruction, e.g.:\n\n{ 8,9,10,11,12,13,14,15, 0,1,2,3,4,5,6,7 } with PALIGNR,\n\n{ 0,1,2,3, 4,5,6,7, 4,5,6,7, 12,13,14,15 } with PSHUFD,\n\n{ 0,1, 2,3, 2,3, 6,7, 8,9,10,11,12,13,14,15 } with PSHUFLW and\n\n{ 0,1,2,3,4,5,6,7, 8,9, 10,11, 10,11, 14,15 } with PSHUFHW.\n\nAll these instructions have constant shuffle control mask and do not\nneed to load shuffle mask from a memory to a temporary XMM register.\n\n2021-06-11  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/\n\tPR target/101021\n\t* config/i386/i386-expand.c (expand_vec_perm_pshufb): Return\n\tfalse if the permutation can be implemented with constant\n\tpermutation instruction in wider mode.\n\t(canonicalize_vector_int_perm): Move above expand_vec_perm_pshufb.\n\tHandle V8QImode and V4HImode.\n\ngcc/testsuite/\n\n\tPR target/101021\n\t* gcc.target/i386/pr101021-1.c: New test.\n\t* gcc.target/i386/pr101021-2.c: Ditto.", "tree": {"sha": "bc1ea9b598c736fa30bcd1faab10c94018a8ec09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc1ea9b598c736fa30bcd1faab10c94018a8ec09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf728aecc4fea46b4490e950b9ae229f90597b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf728aecc4fea46b4490e950b9ae229f90597b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf728aecc4fea46b4490e950b9ae229f90597b0"}], "stats": {"total": 165, "additions": 114, "deletions": 51}, "files": [{"sha": "2fa3a18dc6af27c1757697c75ee9fac19b493bb7", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 58, "deletions": 51, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "patch": "@@ -17354,6 +17354,59 @@ expand_vec_perm_vpermil (struct expand_vec_perm_d *d)\n   return true;\n }\n \n+/* For V*[QHS]Imode permutations, check if the same permutation\n+   can't be performed in a 2x, 4x or 8x wider inner mode.  */\n+\n+static bool\n+canonicalize_vector_int_perm (const struct expand_vec_perm_d *d,\n+\t\t\t      struct expand_vec_perm_d *nd)\n+{\n+  int i;\n+  machine_mode mode = VOIDmode;\n+\n+  switch (d->vmode)\n+    {\n+    case E_V8QImode: mode = V4HImode; break;\n+    case E_V16QImode: mode = V8HImode; break;\n+    case E_V32QImode: mode = V16HImode; break;\n+    case E_V64QImode: mode = V32HImode; break;\n+    case E_V4HImode: mode = V2SImode; break;\n+    case E_V8HImode: mode = V4SImode; break;\n+    case E_V16HImode: mode = V8SImode; break;\n+    case E_V32HImode: mode = V16SImode; break;\n+    case E_V4SImode: mode = V2DImode; break;\n+    case E_V8SImode: mode = V4DImode; break;\n+    case E_V16SImode: mode = V8DImode; break;\n+    default: return false;\n+    }\n+  for (i = 0; i < d->nelt; i += 2)\n+    if ((d->perm[i] & 1) || d->perm[i + 1] != d->perm[i] + 1)\n+      return false;\n+  nd->vmode = mode;\n+  nd->nelt = d->nelt / 2;\n+  for (i = 0; i < nd->nelt; i++)\n+    nd->perm[i] = d->perm[2 * i] / 2;\n+  if (GET_MODE_INNER (mode) != DImode)\n+    canonicalize_vector_int_perm (nd, nd);\n+  if (nd != d)\n+    {\n+      nd->one_operand_p = d->one_operand_p;\n+      nd->testing_p = d->testing_p;\n+      if (d->op0 == d->op1)\n+\tnd->op0 = nd->op1 = gen_lowpart (nd->vmode, d->op0);\n+      else\n+\t{\n+\t  nd->op0 = gen_lowpart (nd->vmode, d->op0);\n+\t  nd->op1 = gen_lowpart (nd->vmode, d->op1);\n+\t}\n+      if (d->testing_p)\n+\tnd->target = gen_raw_REG (nd->vmode, LAST_VIRTUAL_REGISTER + 1);\n+      else\n+\tnd->target = gen_reg_rtx (nd->vmode);\n+    }\n+  return true;\n+}\n+\n /* Return true if permutation D can be performed as VMODE permutation\n    instead.  */\n \n@@ -17391,6 +17444,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n   unsigned i, nelt, eltsz, mask;\n   unsigned char perm[64];\n   machine_mode vmode = V16QImode;\n+  struct expand_vec_perm_d nd;\n   rtx rperm[64], vperm, target, op0, op1;\n \n   nelt = d->nelt;\n@@ -17539,6 +17593,10 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \treturn false;\n     }\n \n+  /* Try to avoid variable permutation instruction.  */\n+  if (canonicalize_vector_int_perm (d, &nd) && expand_vec_perm_1 (&nd))\n+    return false;\n+\n   if (d->testing_p)\n     return true;\n \n@@ -17617,57 +17675,6 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n   return true;\n }\n \n-/* For V*[QHS]Imode permutations, check if the same permutation\n-   can't be performed in a 2x, 4x or 8x wider inner mode.  */\n-\n-static bool\n-canonicalize_vector_int_perm (const struct expand_vec_perm_d *d,\n-\t\t\t      struct expand_vec_perm_d *nd)\n-{\n-  int i;\n-  machine_mode mode = VOIDmode;\n-\n-  switch (d->vmode)\n-    {\n-    case E_V16QImode: mode = V8HImode; break;\n-    case E_V32QImode: mode = V16HImode; break;\n-    case E_V64QImode: mode = V32HImode; break;\n-    case E_V8HImode: mode = V4SImode; break;\n-    case E_V16HImode: mode = V8SImode; break;\n-    case E_V32HImode: mode = V16SImode; break;\n-    case E_V4SImode: mode = V2DImode; break;\n-    case E_V8SImode: mode = V4DImode; break;\n-    case E_V16SImode: mode = V8DImode; break;\n-    default: return false;\n-    }\n-  for (i = 0; i < d->nelt; i += 2)\n-    if ((d->perm[i] & 1) || d->perm[i + 1] != d->perm[i] + 1)\n-      return false;\n-  nd->vmode = mode;\n-  nd->nelt = d->nelt / 2;\n-  for (i = 0; i < nd->nelt; i++)\n-    nd->perm[i] = d->perm[2 * i] / 2;\n-  if (GET_MODE_INNER (mode) != DImode)\n-    canonicalize_vector_int_perm (nd, nd);\n-  if (nd != d)\n-    {\n-      nd->one_operand_p = d->one_operand_p;\n-      nd->testing_p = d->testing_p;\n-      if (d->op0 == d->op1)\n-\tnd->op0 = nd->op1 = gen_lowpart (nd->vmode, d->op0);\n-      else\n-\t{\n-\t  nd->op0 = gen_lowpart (nd->vmode, d->op0);\n-\t  nd->op1 = gen_lowpart (nd->vmode, d->op1);\n-\t}\n-      if (d->testing_p)\n-\tnd->target = gen_raw_REG (nd->vmode, LAST_VIRTUAL_REGISTER + 1);\n-      else\n-\tnd->target = gen_reg_rtx (nd->vmode);\n-    }\n-  return true;\n-}\n-\n /* Try to expand one-operand permutation with constant mask.  */\n \n static bool"}, {"sha": "f4649c00338904f9db2c8d01c296273e66747d88", "filename": "gcc/testsuite/gcc.target/i386/pr101021-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101021-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101021-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101021-1.c?ref=1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "patch": "@@ -0,0 +1,35 @@\n+/* PR target/101021 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-final { scan-assembler-not \"vpshufb\" } } */\n+\n+typedef char S;\n+typedef S V __attribute__((vector_size(16 * sizeof(S))));\n+\n+V t1 (V x)\n+{\n+  return __builtin_shuffle (x, (V) { 8,9,10,11,12,13,14,15, 0,1,2,3,4,5,6,7 });\n+}\n+\n+/* { dg-final { scan-assembler \"vpalignr\" } } */\n+\n+V t2 (V x)\n+{\n+  return __builtin_shuffle (x, (V) { 0,1,2,3, 4,5,6,7, 4,5,6,7, 12,13,14,15 });\n+}\n+\n+/* { dg-final { scan-assembler \"vpshufd\" } } */\n+\n+V t3 (V x)\n+{\n+  return __builtin_shuffle (x, (V) { 0,1, 2,3, 2,3, 6,7, 8,9,10,11,12,13,14,15 });\n+}\n+\n+/* { dg-final { scan-assembler \"vpshuflw\" } } */\n+\n+V t4 (V x)\n+{\n+  return __builtin_shuffle (x, (V) { 0,1,2,3,4,5,6,7, 8,9, 10,11, 10,11, 14,15 });\n+}\n+\n+/* { dg-final { scan-assembler \"vpshufhw\" } } */"}, {"sha": "1e046f7d990d02ab982059016660eb36d6d5679d", "filename": "gcc/testsuite/gcc.target/i386/pr101021-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101021-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101021-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101021-2.c?ref=1fa991d1d74cb1ce96c48ede70ae0be7a9683ce3", "patch": "@@ -0,0 +1,21 @@\n+/* PR target/101021 */\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-final { scan-assembler-not \"vpshufb\" } } */\n+\n+typedef char S;\n+typedef S V __attribute__((vector_size(8 * sizeof(S))));\n+\n+V t1 (V x)\n+{\n+  return __builtin_shuffle (x, (V) { 4,5,6,7, 0,1,2,3 });\n+}\n+\n+/* { dg-final { scan-assembler \"vpshufd\" } } */\n+\n+V t2 (V x)\n+{\n+  return __builtin_shuffle (x, (V) { 0,1, 2,3, 2,3, 6,7 });\n+}\n+\n+/* { dg-final { scan-assembler \"vpshuflw\" } } */"}]}