{"sha": "240d63482d9342b7ac8632ded9ec81785be5faa4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQwZDYzNDgyZDkzNDJiN2FjODYzMmRlZDllYzgxNzg1YmU1ZmFhNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-02-04T19:42:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-02-04T19:42:46Z"}, "message": "Add contrib/update-copyright.pl.\n\nFrom-SVN: r195734", "tree": {"sha": "aa01d28859ff4f758207559ec99b017ede5eecff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa01d28859ff4f758207559ec99b017ede5eecff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/240d63482d9342b7ac8632ded9ec81785be5faa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/240d63482d9342b7ac8632ded9ec81785be5faa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/240d63482d9342b7ac8632ded9ec81785be5faa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/240d63482d9342b7ac8632ded9ec81785be5faa4/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ea146e6da49a7fbd1fbace15c79aa372ebae3de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea146e6da49a7fbd1fbace15c79aa372ebae3de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ea146e6da49a7fbd1fbace15c79aa372ebae3de"}], "stats": {"total": 770, "additions": 770, "deletions": 0}, "files": [{"sha": "3d5b3fca7c5fd86ac38e20708d5f565b03ec5d4b", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/240d63482d9342b7ac8632ded9ec81785be5faa4/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/240d63482d9342b7ac8632ded9ec81785be5faa4/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=240d63482d9342b7ac8632ded9ec81785be5faa4", "patch": "@@ -1,3 +1,7 @@\n+2013-02-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* update-copyright.pl: New file.\n+\n 2013-01-15  David Blaikie <dblaikie@gmail.com>\n \n \t* dg-extract-results.sh: Handle KPASSes."}, {"sha": "db468724703d60a19dc9b1822e7c1a442153534b", "filename": "contrib/update-copyright.pl", "status": "added", "additions": 766, "deletions": 0, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/240d63482d9342b7ac8632ded9ec81785be5faa4/contrib%2Fupdate-copyright.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/240d63482d9342b7ac8632ded9ec81785be5faa4/contrib%2Fupdate-copyright.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fupdate-copyright.pl?ref=240d63482d9342b7ac8632ded9ec81785be5faa4", "patch": "@@ -0,0 +1,766 @@\n+#!/usr/bin/python\n+#\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+#\n+# This script is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# This script adjusts the copyright notices at the top of source files\n+# so that they have the form:\n+#\n+#   Copyright XXXX-YYYY Free Software Foundation, Inc.\n+#\n+# It doesn't change code that is known to be maintained elsewhere or\n+# that carries a non-FSF copyright.\n+#\n+# The script also doesn't change testsuite files, except those in\n+# libstdc++-v3.  This is because libstdc++-v3 has a conformance testsuite,\n+# while most tests in other directories are just things that failed at some\n+# point in the past.\n+#\n+# Pass --this-year to the script if you want it to add the current year\n+# to all applicable notices.  Pass --quilt if you are using quilt and\n+# want files to be added to the quilt before being changed.\n+#\n+# By default the script will update all directories for which the\n+# output has been vetted.  You can instead pass the names of individual\n+# directories, including those that haven't been approved.  So:\n+#\n+#    update-copyright.pl --this-year\n+#\n+# is the command that would be used at the beginning of a year to update\n+# all copyright notices (and possibly at other times to check whether\n+# new files have been added with old years).  On the other hand:\n+#\n+#    update-copyright.pl --this-year libjava\n+#\n+# would run the script on just libjava/.\n+#\n+# Note that things like --version output strings must be updated before\n+# this script is run.  There's already a separate procedure for that.\n+\n+import os\n+import re\n+import sys\n+import time\n+import subprocess\n+\n+class Errors:\n+    def __init__ (self):\n+        self.num_errors = 0\n+\n+    def report (self, filename, string):\n+        if filename:\n+            string = filename + ': ' + string\n+        sys.stderr.write (string + '\\n')\n+        self.num_errors += 1\n+\n+    def ok (self):\n+        return self.num_errors == 0\n+\n+class GenericFilter:\n+    def __init__ (self):\n+        self.skip_files = set()\n+        self.skip_dirs = set()\n+        self.skip_extensions = set()\n+        self.fossilised_files = set()\n+        self.own_files = set()\n+\n+        self.skip_files |= set ([\n+                # Skip licence files.\n+                'COPYING',\n+                'COPYING.LIB',\n+                'COPYING3',\n+                'COPYING3.LIB',\n+                'LICENSE',\n+                'fdl.texi',\n+                'gpl_v3.texi',\n+                'fdl-1.3.xml',\n+                'gpl-3.0.xml',\n+\n+                # Skip auto- and libtool-related files\n+                'aclocal.m4',\n+                'compile',\n+                'config.guess',\n+                'config.sub',\n+                'depcomp',\n+                'install-sh',\n+                'libtool.m4',\n+                'ltmain.sh',\n+                'ltoptions.m4',\n+                'ltsugar.m4',\n+                'ltversion.m4',\n+                'lt~obsolete.m4',\n+                'missing',\n+                'mkdep',\n+                'mkinstalldirs',\n+                'move-if-change',\n+                'shlibpath.m4',\n+                'symlink-tree',\n+                'ylwrap',\n+\n+                # Skip FSF mission statement, etc.\n+                'gnu.texi',\n+                'funding.texi',\n+                'appendix_free.xml',\n+\n+                # Skip imported texinfo files.\n+                'texinfo.tex',\n+                ])\n+\n+\n+    def get_line_filter (self, dir, filename):\n+        if filename.startswith ('ChangeLog'):\n+            # Ignore references to copyright in changelog entries.\n+            return re.compile ('\\t')\n+\n+        return None\n+\n+    def skip_file (self, dir, filename):\n+        if filename in self.skip_files:\n+            return True\n+\n+        (base, extension) = os.path.splitext (os.path.join (dir, filename))\n+        if extension in self.skip_extensions:\n+            return True\n+\n+        if extension == '.in':\n+            # Skip .in files produced by automake.\n+            if os.path.exists (base + '.am'):\n+                return True\n+\n+            # Skip files produced by autogen\n+            if (os.path.exists (base + '.def')\n+                and os.path.exists (base + '.tpl')):\n+                return True\n+\n+        # Skip configure files produced by autoconf\n+        if filename == 'configure':\n+            if os.path.exists (base + '.ac'):\n+                return True\n+            if os.path.exists (base + '.in'):\n+                return True\n+\n+        return False\n+\n+    def skip_dir (self, dir, subdir):\n+        return subdir in self.skip_dirs\n+\n+    def is_fossilised_file (self, dir, filename):\n+        if filename in self.fossilised_files:\n+            return True\n+        # Only touch current current ChangeLogs.\n+        if filename != 'ChangeLog' and filename.find ('ChangeLog') >= 0:\n+            return True\n+        return False\n+\n+    def by_package_author (self, dir, filename):\n+        return filename in self.own_files\n+\n+class Copyright:\n+    def __init__ (self, errors):\n+        self.errors = errors\n+\n+        # Characters in a range of years.  Include '.' for typos.\n+        ranges = '[0-9](?:[-0-9.,\\s]|\\s+and\\s+)*[0-9]'\n+\n+        # Non-whitespace characters in a copyright holder's name.\n+        name = '[\\w.,-]'\n+\n+        # Matches one year.\n+        self.year_re = re.compile ('[0-9]+')\n+\n+        # Matches part of a year or copyright holder.\n+        self.continuation_re = re.compile (ranges + '|' + name)\n+\n+        # Matches a full copyright notice:\n+        self.copyright_re = re.compile (\n+            # 1: 'Copyright (C)', etc.\n+            '([Cc]opyright'\n+            '|[Cc]opyright\\s+\\([Cc]\\)'\n+            '|[Cc]opyright\\s+%s'\n+            '|[Cc]opyright\\s+&copy;'\n+            '|[Cc]opyright\\s+@copyright{}'\n+            '|@set\\s+copyright[\\w-]+)'\n+\n+            # 2: the years.  Include the whitespace in the year, so that\n+            # we can remove any excess.\n+            '(\\s*(?:' + ranges + ',?'\n+            '|@value\\{[^{}]*\\})\\s*)'\n+\n+            # 3: 'by ', if used\n+            '(by\\s+)?'\n+\n+            # 4: the copyright holder.  Don't allow multiple consecutive\n+            # spaces, so that right-margin gloss doesn't get caught\n+            # (e.g. gnat_ugn.texi).\n+            '(' + name + '(?:\\s?' + name + ')*)?')\n+\n+        # A regexp for notices that might have slipped by.  Just matching\n+        # 'copyright' is too noisy, and 'copyright.*[0-9]' falls foul of\n+        # HTML header markers, so check for 'copyright' and two digits.\n+        self.other_copyright_re = re.compile ('copyright.*[0-9][0-9]',\n+                                              re.IGNORECASE)\n+        self.comment_re = re.compile('#+|[*]+|;+|%+|//+|@c |dnl ')\n+        self.holders = { '@copying': '@copying' }\n+        self.holder_prefixes = set()\n+\n+        # True to 'quilt add' files before changing them.\n+        self.use_quilt = False\n+\n+        # If set, force all notices to include this year.\n+        self.max_year = None\n+\n+        # Goes after the year(s).  Could be ', '.\n+        self.separator = ' '\n+\n+    def add_package_author (self, holder, canon_form = None):\n+        if not canon_form:\n+            canon_form = holder\n+        self.holders[holder] = canon_form\n+        index = holder.find (' ')\n+        while index >= 0:\n+            self.holder_prefixes.add (holder[:index])\n+            index = holder.find (' ', index + 1)\n+\n+    def add_external_author (self, holder):\n+        self.holders[holder] = None\n+\n+    class BadYear():\n+        def __init__ (self, year):\n+            self.year = year\n+\n+        def __str__ (self):\n+            return 'unrecognised year: ' + self.year\n+\n+    def parse_year (self, string):\n+        year = int (string)\n+        if len (string) == 2:\n+            if year > 70:\n+                return year + 1900\n+        elif len (string) == 4:\n+            return year\n+        raise self.BadYear (string)\n+\n+    def year_range (self, years):\n+        year_list = [self.parse_year (year)\n+                     for year in self.year_re.findall (years)]\n+        assert len (year_list) > 0\n+        return (min (year_list), max (year_list))\n+\n+    def set_use_quilt (self, use_quilt):\n+        self.use_quilt = use_quilt\n+\n+    def include_year (self, year):\n+        assert not self.max_year\n+        self.max_year = year\n+\n+    def canonicalise_years (self, dir, filename, filter, years):\n+        # Leave texinfo variables alone.\n+        if years.startswith ('@value'):\n+            return years\n+\n+        (min_year, max_year) = self.year_range (years)\n+\n+        # Update the upper bound, if enabled.\n+        if self.max_year and not filter.is_fossilised_file (dir, filename):\n+            max_year = max (max_year, self.max_year)\n+\n+        # Use a range.\n+        if min_year == max_year:\n+            return '%d' % min_year\n+        else:\n+            return '%d-%d' % (min_year, max_year)\n+\n+    def strip_continuation (self, line):\n+        line = line.lstrip()\n+        match = self.comment_re.match (line)\n+        if match:\n+            line = line[match.end():].lstrip()\n+        return line\n+\n+    def is_complete (self, match):\n+        holder = match.group (4)\n+        return (holder\n+                and (holder not in self.holder_prefixes\n+                     or holder in self.holders))\n+\n+    def update_copyright (self, dir, filename, filter, file, line, match):\n+        orig_line = line\n+        next_line = None\n+        pathname = os.path.join (dir, filename)\n+\n+        intro = match.group (1)\n+        if intro.startswith ('@set'):\n+            # Texinfo year variables should always be on one line\n+            after_years = line[match.end (2):].strip()\n+            if after_years != '':\n+                self.errors.report (pathname,\n+                                    'trailing characters in @set: '\n+                                    + after_years)\n+                return (False, orig_line, next_line)\n+        else:\n+            # If it looks like the copyright is incomplete, add the next line.\n+            while not self.is_complete (match):\n+                try:\n+                    next_line = file.next()\n+                except StopIteration:\n+                    break\n+\n+                # If the next line doesn't look like a proper continuation,\n+                # assume that what we've got is complete.\n+                continuation = self.strip_continuation (next_line)\n+                if not self.continuation_re.match (continuation):\n+                    break\n+\n+                # Merge the lines for matching purposes.\n+                orig_line += next_line\n+                line = line.rstrip() + ' ' + continuation\n+                next_line = None\n+\n+                # Rematch with the longer line, at the original position.\n+                match = self.copyright_re.match (line, match.start())\n+                assert match\n+\n+            holder = match.group (4)\n+\n+            # Use the filter to test cases where markup is getting in the way.\n+            if filter.by_package_author (dir, filename):\n+                assert holder not in self.holders\n+\n+            elif not holder:\n+                self.errors.report (pathname, 'missing copyright holder')\n+                return (False, orig_line, next_line)\n+\n+            elif holder not in self.holders:\n+                self.errors.report (pathname,\n+                                    'unrecognised copyright holder: ' + holder)\n+                return (False, orig_line, next_line)\n+\n+            else:\n+                # See whether the copyright is associated with the package\n+                # author.\n+                canon_form = self.holders[holder]\n+                if not canon_form:\n+                    return (False, orig_line, next_line)\n+\n+                # Make sure the author is given in a consistent way.\n+                line = (line[:match.start (4)]\n+                        + canon_form\n+                        + line[match.end (4):])\n+\n+                # Remove any 'by'\n+                line = line[:match.start (3)] + line[match.end (3):]\n+\n+        # Update the copyright years.\n+        years = match.group (2).strip()\n+        try:\n+            canon_form = self.canonicalise_years (dir, filename, filter, years)\n+        except self.BadYear as e:\n+            self.errors.report (pathname, str (e))\n+            return (False, orig_line, next_line)\n+\n+        line = (line[:match.start (2)]\n+                + ' ' + canon_form + self.separator\n+                + line[match.end (2):])\n+\n+        # Use the standard (C) form.\n+        if intro.endswith ('right'):\n+            intro += ' (C)'\n+        elif intro.endswith ('(c)'):\n+            intro = intro[:-3] + '(C)'\n+        line = line[:match.start (1)] + intro + line[match.end (1):]\n+\n+        # Strip trailing whitespace\n+        line = line.rstrip() + '\\n'\n+\n+        return (line != orig_line, line, next_line)\n+\n+    def process_file (self, dir, filename, filter):\n+        pathname = os.path.join (dir, filename)\n+        if filename.endswith ('.tmp'):\n+            # Looks like something we tried to create before.\n+            try:\n+                os.remove (pathname)\n+            except OSError:\n+                pass\n+            return\n+\n+        lines = []\n+        changed = False\n+        line_filter = filter.get_line_filter (dir, filename)\n+        with open (pathname, 'r') as file:\n+            prev = None\n+            for line in file:\n+                while line:\n+                    next_line = None\n+                    # Leave filtered-out lines alone.\n+                    if not (line_filter and line_filter.match (line)):\n+                        match = self.copyright_re.search (line)\n+                        if match:\n+                            res = self.update_copyright (dir, filename, filter,\n+                                                         file, line, match)\n+                            (this_changed, line, next_line) = res\n+                            changed = changed or this_changed\n+\n+                        # Check for copyright lines that might have slipped by.\n+                        elif self.other_copyright_re.search (line):\n+                            self.errors.report (pathname,\n+                                                'unrecognised copyright: %s'\n+                                                % line.strip())\n+                    lines.append (line)\n+                    line = next_line\n+\n+        # If something changed, write the new file out.\n+        if changed and self.errors.ok():\n+            tmp_pathname = pathname + '.tmp'\n+            with open (tmp_pathname, 'w') as file:\n+                for line in lines:\n+                    file.write (line)\n+            if self.use_quilt:\n+                subprocess.call (['quilt', 'add', pathname])\n+            os.rename (tmp_pathname, pathname)\n+\n+    def process_tree (self, tree, filter):\n+        for (dir, subdirs, filenames) in os.walk (tree):\n+            # Don't recurse through directories that should be skipped.\n+            for i in xrange (len (subdirs) - 1, -1, -1):\n+                if filter.skip_dir (dir, subdirs[i]):\n+                    del subdirs[i]\n+\n+            # Handle the files in this directory.\n+            for filename in filenames:\n+                if filter.skip_file (dir, filename):\n+                    sys.stdout.write ('Skipping %s\\n'\n+                                      % os.path.join (dir, filename))\n+                else:\n+                    self.process_file (dir, filename, filter)\n+\n+class CmdLine:\n+    def __init__ (self, copyright = Copyright):\n+        self.errors = Errors()\n+        self.copyright = copyright (self.errors)\n+        self.dirs = []\n+        self.default_dirs = []\n+        self.chosen_dirs = []\n+        self.option_handlers = dict()\n+        self.option_help = []\n+\n+        self.add_option ('--help', 'Print this help', self.o_help)\n+        self.add_option ('--quilt', '\"quilt add\" files before changing them',\n+                         self.o_quilt)\n+        self.add_option ('--this-year', 'Add the current year to every notice',\n+                         self.o_this_year)\n+\n+    def add_option (self, name, help, handler):\n+        self.option_help.append ((name, help))\n+        self.option_handlers[name] = handler\n+\n+    def add_dir (self, dir, filter = GenericFilter()):\n+        self.dirs.append ((dir, filter))\n+\n+    def o_help (self, option = None):\n+        sys.stdout.write ('Usage: %s [options] dir1 dir2...\\n\\n'\n+                          'Options:\\n' % sys.argv[0])\n+        format = '%-15s %s\\n'\n+        for (what, help) in self.option_help:\n+            sys.stdout.write (format % (what, help))\n+        sys.stdout.write ('\\nDirectories:\\n')\n+\n+        format = '%-25s'\n+        i = 0\n+        for (dir, filter) in self.dirs:\n+            i += 1\n+            if i % 3 == 0 or i == len (self.dirs):\n+                sys.stdout.write (dir + '\\n')\n+            else:\n+                sys.stdout.write (format % dir)\n+        sys.exit (0)\n+\n+    def o_quilt (self, option):\n+        self.copyright.set_use_quilt (True)\n+\n+    def o_this_year (self, option):\n+        self.copyright.include_year (time.localtime().tm_year)\n+\n+    def main (self):\n+        for arg in sys.argv[1:]:\n+            if arg[:1] != '-':\n+                self.chosen_dirs.append (arg)\n+            elif arg in self.option_handlers:\n+                self.option_handlers[arg] (arg)\n+            else:\n+                self.errors.report (None, 'unrecognised option: ' + arg)\n+        if self.errors.ok():\n+            if len (self.chosen_dirs) == 0:\n+                self.chosen_dirs = self.default_dirs\n+            if len (self.chosen_dirs) == 0:\n+                self.o_help()\n+            else:\n+                for chosen_dir in self.chosen_dirs:\n+                    canon_dir = os.path.join (chosen_dir, '')\n+                    count = 0\n+                    for (dir, filter) in self.dirs:\n+                        if (dir + os.sep).startswith (canon_dir):\n+                            count += 1\n+                            self.copyright.process_tree (dir, filter)\n+                    if count == 0:\n+                        self.errors.report (None, 'unrecognised directory: '\n+                                            + chosen_dir)\n+        sys.exit (0 if self.errors.ok() else 1)\n+\n+#----------------------------------------------------------------------------\n+\n+class TopLevelFilter (GenericFilter):\n+    def skip_dir (self, dir, subdir):\n+        return True\n+\n+class ConfigFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+    def skip_file (self, dir, filename):\n+        if filename.endswith ('.m4'):\n+            pathname = os.path.join (dir, filename)\n+            with open (pathname) as file:\n+                # Skip files imported from gettext.\n+                if file.readline().find ('gettext-') >= 0:\n+                    return True\n+        return GenericFilter.skip_file (self, dir, filename)\n+\n+class GCCFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_files |= set ([\n+                # Not part of GCC\n+                'math-68881.h',\n+                ])\n+\n+        self.skip_dirs |= set ([\n+                # Better not create a merge nightmare for the GNAT folks.\n+                'ada',\n+\n+                # Handled separately.\n+                'testsuite',\n+                ])\n+\n+        self.skip_extensions |= set ([\n+                # Maintained by the translation project.\n+                '.po',\n+\n+                # Automatically-generated.\n+                '.pot',\n+                ])\n+\n+        self.fossilised_files |= set ([\n+                # Old news won't be updated.\n+                'ONEWS',\n+                ])\n+\n+class TestsuiteFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_extensions |= set ([\n+                # Don't change the tests, which could be woend by anyone.\n+                '.c',\n+                '.C',\n+                '.cc',\n+                '.h',\n+                '.hs',\n+                '.f',\n+                '.f90',\n+                '.go',\n+                '.inc',\n+                '.java',\n+                ])\n+\n+    def skip_file (self, dir, filename):\n+        # g++.niklas/README contains historical copyright information\n+        # and isn't updated.\n+        if filename == 'README' and os.path.basename (dir) == 'g++.niklas':\n+            return True\n+        return GenericFilter.skip_file (self, dir, filename)\n+\n+class LibCppFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_extensions |= set ([\n+                # Maintained by the translation project.\n+                '.po',\n+\n+                # Automatically-generated.\n+                '.pot',\n+                ])\n+\n+class LibGCCFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_dirs |= set ([\n+                # Imported from GLIBC.\n+                'soft-fp',\n+                ])\n+\n+class LibJavaFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_dirs |= set ([\n+                # Handled separately.\n+                'testsuite',\n+\n+                # Not really part of the library\n+                'contrib',\n+\n+                # Imported from upstream\n+                'classpath',\n+                'libltdl',\n+                ])\n+\n+    def get_line_filter (self, dir, filename):\n+        if filename == 'NameDecoder.h':\n+            return re.compile ('.*NAME_COPYRIGHT')\n+        if filename == 'ICC_Profile.h':\n+            return re.compile ('.*icSigCopyrightTag')\n+        return GenericFilter.get_line_filter (self, dir, filename)\n+\n+class LibMudflapFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_dirs |= set ([\n+                # Handled separately.\n+                'testsuite',\n+                ])\n+\n+class LibStdCxxFilter (GenericFilter):\n+    def __init__ (self):\n+        GenericFilter.__init__ (self)\n+\n+        self.skip_files |= set ([\n+                # Contains no copyright of its own, but quotes the GPL.\n+                'intro.xml',\n+                ])\n+\n+        self.skip_dirs |= set ([\n+                # Contains automatically-generated sources.\n+                'html',\n+\n+                # The testsuite data files shouldn't be changed.\n+                'data',\n+\n+                # Contains imported images\n+                'images',\n+                ])\n+\n+        self.own_files |= set ([\n+                # Contains markup around the copyright owner.\n+                'spine.xml',\n+                ])\n+\n+    def get_line_filter (self, dir, filename):\n+        if filename == 'boost_concept_check.h':\n+            return re.compile ('// \\(C\\) Copyright Jeremy Siek')\n+        return GenericFilter.get_line_filter (self, dir, filename)\n+\n+class GCCCopyright (Copyright):\n+    def __init__ (self, errors):\n+        Copyright.__init__ (self, errors)\n+\n+        canon_fsf = 'Free Software Foundation, Inc.'\n+        self.add_package_author ('Free Software Foundation', canon_fsf)\n+        self.add_package_author ('Free Software Foundation.', canon_fsf)\n+        self.add_package_author ('Free Software Foundation Inc.', canon_fsf)\n+        self.add_package_author ('Free Software Foundation, Inc', canon_fsf)\n+        self.add_package_author ('Free Software Foundation, Inc.', canon_fsf)\n+        self.add_package_author ('The Free Software Foundation', canon_fsf)\n+        self.add_package_author ('The Free Software Foundation, Inc.', canon_fsf)\n+        self.add_package_author ('Software Foundation, Inc.', canon_fsf)\n+\n+        self.add_external_author ('ARM')\n+        self.add_external_author ('AdaCore')\n+        self.add_external_author ('Ami Tavory and Vladimir Dreizin, IBM-HRL.')\n+        self.add_external_author ('Cavium Networks.')\n+        self.add_external_author ('Faraday Technology Corp.')\n+        self.add_external_author ('Florida State University')\n+        self.add_external_author ('Greg Colvin and Beman Dawes.')\n+        self.add_external_author ('Hewlett-Packard Company')\n+        self.add_external_author ('Information Technology Industry Council.')\n+        self.add_external_author ('James Theiler, Brian Gough')\n+        self.add_external_author ('Makoto Matsumoto and Takuji Nishimura,')\n+        self.add_external_author ('National Research Council of Canada.')\n+        self.add_external_author ('Peter Dimov and Multi Media Ltd.')\n+        self.add_external_author ('Peter Dimov')\n+        self.add_external_author ('Pipeline Associates, Inc.')\n+        self.add_external_author ('Regents of the University of California.')\n+        self.add_external_author ('Silicon Graphics Computer Systems, Inc.')\n+        self.add_external_author ('Silicon Graphics')\n+        self.add_external_author ('Stephen L. Moshier')\n+        self.add_external_author ('Sun Microsystems, Inc. All rights reserved.')\n+        self.add_external_author ('The Go Authors.  All rights reserved.')\n+        self.add_external_author ('The Go Authors. All rights reserved.')\n+        self.add_external_author ('The Go Authors.')\n+        self.add_external_author ('The Regents of the University of California.')\n+        self.add_external_author ('Unicode, Inc.')\n+        self.add_external_author ('University of Toronto.')\n+\n+class GCCCmdLine (CmdLine):\n+    def __init__ (self):\n+        CmdLine.__init__ (self, GCCCopyright)\n+\n+        self.add_dir ('.', TopLevelFilter())\n+        # boehm-gc is imported from upstream.\n+        self.add_dir ('config', ConfigFilter())\n+        # contrib isn't really part of GCC.\n+        self.add_dir ('fixincludes')\n+        self.add_dir ('gcc', GCCFilter())\n+        self.add_dir (os.path.join ('gcc', 'testsuite'), TestsuiteFilter())\n+        self.add_dir ('gnattools')\n+        self.add_dir ('include')\n+        self.add_dir ('libada')\n+        self.add_dir ('libatomic')\n+        self.add_dir ('libbacktrace')\n+        self.add_dir ('libcpp', LibCppFilter())\n+        self.add_dir ('libdecnumber')\n+        # libffi is imported from upstream.\n+        self.add_dir ('libgcc', LibGCCFilter())\n+        self.add_dir ('libgfortran')\n+        self.add_dir ('libgomp')\n+        self.add_dir ('libiberty')\n+        self.add_dir ('libitm')\n+        self.add_dir ('libjava', LibJavaFilter())\n+        self.add_dir (os.path.join ('libjava', 'testsuite'), TestsuiteFilter())\n+        self.add_dir ('libmudflap', LibMudflapFilter())\n+        self.add_dir (os.path.join ('libmudflap', 'testsuite'),\n+                      TestsuiteFilter())\n+        self.add_dir ('libobjc')\n+        self.add_dir ('libquadmath')\n+        # libsanitiser is imported from upstream.\n+        self.add_dir ('libssp')\n+        self.add_dir ('libstdc++-v3', LibStdCxxFilter())\n+        self.add_dir ('lto-plugin')\n+        # zlib is imported from upstream.\n+\n+        self.default_dirs = [\n+            'gcc',\n+            'libada',\n+            'libatomic',\n+            'libbacktrace',\n+            'libcpp',\n+            'libgcc',\n+            'libgfortran',\n+            'libgomp',\n+            'libitm',\n+            'libmudflap',\n+            'libobjc',\n+            'libquadmath',\n+            'libssp',\n+            'libstdc++-v3',\n+            ]\n+\n+GCCCmdLine().main()"}]}