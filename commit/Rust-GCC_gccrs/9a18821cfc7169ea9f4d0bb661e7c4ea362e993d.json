{"sha": "9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExODgyMWNmYzcxNjllYTlmNGQwYmI2NjFlN2M0ZWEzNjJlOTkzZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-30T22:09:55Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-30T22:09:55Z"}, "message": "libgo: Update to weekly.2012-03-22.\n\nFrom-SVN: r186026", "tree": {"sha": "26322d11da7cc220190e0b8430565ea207eb3eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26322d11da7cc220190e0b8430565ea207eb3eab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/comments", "author": null, "committer": null, "parents": [{"sha": "57c7433fdc3fcb7b0cfd7b13bd11360a5e17c624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c7433fdc3fcb7b0cfd7b13bd11360a5e17c624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c7433fdc3fcb7b0cfd7b13bd11360a5e17c624"}], "stats": {"total": 780, "additions": 612, "deletions": 168}, "files": [{"sha": "e7e992c1e86ee1ee8d76031c708ea0362dd279b0", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -1,4 +1,4 @@\n-3cdba7b0650c\n+bce220d03774\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "5f1d1b28a989f43bcb8a7616d9bd48f99aa76c51", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -7,10 +7,12 @@ package zip\n import (\n \t\"bytes\"\n \t\"encoding/binary\"\n+\t\"encoding/hex\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"regexp\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -62,13 +64,14 @@ var tests = []ZipTest{\n \t\t},\n \t},\n \t{\n-\t\tName: \"r.zip\",\n+\t\tName:   \"r.zip\",\n+\t\tSource: returnRecursiveZip,\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:  \"r/r.zip\",\n-\t\t\t\tFile:  \"r.zip\",\n-\t\t\t\tMtime: \"03-04-10 00:24:16\",\n-\t\t\t\tMode:  0666,\n+\t\t\t\tName:    \"r/r.zip\",\n+\t\t\t\tContent: rZipBytes(),\n+\t\t\t\tMtime:   \"03-04-10 00:24:16\",\n+\t\t\t\tMode:    0666,\n \t\t\t},\n \t\t},\n \t},\n@@ -415,3 +418,49 @@ func returnCorruptNotStreamedZip() (r io.ReaderAt, size int64) {\n \t\t// is what matters.\n \t})\n }\n+\n+// rZipBytes returns the bytes of a recursive zip file, without\n+// putting it on disk and triggering certain virus scanners.\n+func rZipBytes() []byte {\n+\ts := `\n+0000000 50 4b 03 04 14 00 00 00 08 00 08 03 64 3c f9 f4\n+0000010 89 64 48 01 00 00 b8 01 00 00 07 00 00 00 72 2f\n+0000020 72 2e 7a 69 70 00 25 00 da ff 50 4b 03 04 14 00\n+0000030 00 00 08 00 08 03 64 3c f9 f4 89 64 48 01 00 00\n+0000040 b8 01 00 00 07 00 00 00 72 2f 72 2e 7a 69 70 00\n+0000050 2f 00 d0 ff 00 25 00 da ff 50 4b 03 04 14 00 00\n+0000060 00 08 00 08 03 64 3c f9 f4 89 64 48 01 00 00 b8\n+0000070 01 00 00 07 00 00 00 72 2f 72 2e 7a 69 70 00 2f\n+0000080 00 d0 ff c2 54 8e 57 39 00 05 00 fa ff c2 54 8e\n+0000090 57 39 00 05 00 fa ff 00 05 00 fa ff 00 14 00 eb\n+00000a0 ff c2 54 8e 57 39 00 05 00 fa ff 00 05 00 fa ff\n+00000b0 00 14 00 eb ff 42 88 21 c4 00 00 14 00 eb ff 42\n+00000c0 88 21 c4 00 00 14 00 eb ff 42 88 21 c4 00 00 14\n+00000d0 00 eb ff 42 88 21 c4 00 00 14 00 eb ff 42 88 21\n+00000e0 c4 00 00 00 00 ff ff 00 00 00 ff ff 00 34 00 cb\n+00000f0 ff 42 88 21 c4 00 00 00 00 ff ff 00 00 00 ff ff\n+0000100 00 34 00 cb ff 42 e8 21 5e 0f 00 00 00 ff ff 0a\n+0000110 f0 66 64 12 61 c0 15 dc e8 a0 48 bf 48 af 2a b3\n+0000120 20 c0 9b 95 0d c4 67 04 42 53 06 06 06 40 00 06\n+0000130 00 f9 ff 6d 01 00 00 00 00 42 e8 21 5e 0f 00 00\n+0000140 00 ff ff 0a f0 66 64 12 61 c0 15 dc e8 a0 48 bf\n+0000150 48 af 2a b3 20 c0 9b 95 0d c4 67 04 42 53 06 06\n+0000160 06 40 00 06 00 f9 ff 6d 01 00 00 00 00 50 4b 01\n+0000170 02 14 00 14 00 00 00 08 00 08 03 64 3c f9 f4 89\n+0000180 64 48 01 00 00 b8 01 00 00 07 00 00 00 00 00 00\n+0000190 00 00 00 00 00 00 00 00 00 00 00 72 2f 72 2e 7a\n+00001a0 69 70 50 4b 05 06 00 00 00 00 01 00 01 00 35 00\n+00001b0 00 00 6d 01 00 00 00 00`\n+\ts = regexp.MustCompile(`[0-9a-f]{7}`).ReplaceAllString(s, \"\")\n+\ts = regexp.MustCompile(`\\s+`).ReplaceAllString(s, \"\")\n+\tb, err := hex.DecodeString(s)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn b\n+}\n+\n+func returnRecursiveZip() (r io.ReaderAt, size int64) {\n+\tb := rZipBytes()\n+\treturn bytes.NewReader(b), int64(len(b))\n+}"}, {"sha": "2877f17387dcf272d678e153488e751e12277142", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -166,8 +166,11 @@ func (c *Conn) clientHandshake() error {\n \t}\n \n \tvar certToSend *Certificate\n+\tvar certRequested bool\n \tcertReq, ok := msg.(*certificateRequestMsg)\n \tif ok {\n+\t\tcertRequested = true\n+\n \t\t// RFC 4346 on the certificateAuthorities field:\n \t\t// A list of the distinguished names of acceptable certificate\n \t\t// authorities. These distinguished names may specify a desired\n@@ -238,9 +241,14 @@ func (c *Conn) clientHandshake() error {\n \t}\n \tfinishedHash.Write(shd.marshal())\n \n-\tif certToSend != nil {\n+\t// If the server requested a certificate then we have to send a\n+\t// Certificate message, even if it's empty because we don't have a\n+\t// certificate to send.\n+\tif certRequested {\n \t\tcertMsg = new(certificateMsg)\n-\t\tcertMsg.certificates = certToSend.Certificate\n+\t\tif certToSend != nil {\n+\t\t\tcertMsg.certificates = certToSend.Certificate\n+\t\t}\n \t\tfinishedHash.Write(certMsg.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \t}"}, {"sha": "96885f8ded4a2b8c0df4adb5147130a9f146ba51", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -226,7 +226,7 @@ where * signifies zero or more repetitions and the type id of a value must\n be predefined or be defined before the value in the stream.\n \n See \"Gobs of data\" for a design discussion of the gob wire format:\n-http://blog.golang.org/2011/03/gobs-of-data.html\n+http://golang.org/doc/articles/gobs_of_data.html\n */\n package gob\n "}, {"sha": "14957b8487ba1cc20e432f03202fddaeb08cf74f", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -6,7 +6,7 @@\n // RFC 4627.\n //\n // See \"JSON and Go\" for an introduction to this package:\n-// http://blog.golang.org/2011/01/json-and-go.html\n+// http://golang.org/doc/articles/json_and_go.html\n package json\n \n import ("}, {"sha": "c1d74f89d011d7690d4d8411b1543b59abbd330d", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -356,7 +356,7 @@ func lastBoundary(fd *formInfo, b []byte) int {\n \t\treturn -1\n \t}\n \tif info.size == 0 { // ends with incomplete rune\n-\t\tif p == 0 { // starts wtih incomplete rune\n+\t\tif p == 0 { // starts with incomplete rune\n \t\t\treturn -1\n \t\t}\n \t\ti = p"}, {"sha": "cb89397b2e5403d7b46bb5007a653b46a8acf9a9", "filename": "libgo/go/exp/types/universe.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -102,11 +102,6 @@ func init() {\n \tdefType(\"Pointer\")\n \n \tdefFun(\"Alignof\")\n-\tdefFun(\"New\")\n-\tdefFun(\"NewArray\")\n \tdefFun(\"Offsetof\")\n-\tdefFun(\"Reflect\")\n \tdefFun(\"Sizeof\")\n-\tdefFun(\"Typeof\")\n-\tdefFun(\"Unreflect\")\n }"}, {"sha": "04a0d20ee4ed827f668bcd05df477a21f8371016", "filename": "libgo/go/flag/example_test.go", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fflag%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fflag%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fexample_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// These examples demonstrate more intricate uses of the flag package.\n+package flag_test\n+\n+import (\n+\t\"errors\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// Example 1: A single string flag called \"species\" with default value \"gopher\".\n+var species = flag.String(\"species\", \"gopher\", \"the species we are studying\")\n+\n+// Example 2: Two flags sharing a variable, so we can have a shorthand.\n+// The order of initialization is undefined, so make sure both use the\n+// same default value. They must be set up with an init function.\n+var gopherType string\n+\n+func init() {\n+\tconst (\n+\t\tdefaultGopher = \"pocket\"\n+\t\tusage         = \"the variety of gopher\"\n+\t)\n+\tflag.StringVar(&gopherType, \"gopher_type\", defaultGopher, usage)\n+\tflag.StringVar(&gopherType, \"g\", defaultGopher, usage+\" (shorthand)\")\n+}\n+\n+// Example 3: A user-defined flag type, a slice of durations.\n+type interval []time.Duration\n+\n+// String is the method to format the flag's value, part of the flag.Value interface.\n+// The String method's output will be used in diagnostics.\n+func (i *interval) String() string {\n+\treturn fmt.Sprint(*i)\n+}\n+\n+// Set is the method to set the flag value, part of the flag.Value interface.\n+// Set's argument is a string to be parsed to set the flag.\n+// It's a comma-separated list, so we split it.\n+func (i *interval) Set(value string) error {\n+\t// If we wanted to allow the flag to be set multiple times,\n+\t// accumulating values, we would delete this if statement.\n+\t// That would permit usages such as\n+\t//\t-deltaT 10s -deltaT 15s\n+\t// and other combinations.\n+\tif len(*i) > 0 {\n+\t\treturn errors.New(\"interval flag already set\")\n+\t}\n+\tfor _, dt := range strings.Split(value, \",\") {\n+\t\tduration, err := time.ParseDuration(dt)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*i = append(*i, duration)\n+\t}\n+\treturn nil\n+}\n+\n+// Define a flag to accumulate durations. Because it has a special type,\n+// we need to use the Var function and therefore create the flag during\n+// init.\n+\n+var intervalFlag interval\n+\n+func init() {\n+\t// Tie the command-line flag to the intervalFlag variable and\n+\t// set a usage message.\n+\tflag.Var(&intervalFlag, \"deltaT\", \"comma-separated list of intervals to use between events\")\n+}\n+\n+func Example() {\n+\t// All the interesting pieces are with the variables declared above, but\n+\t// to enable the flag package to see the flags defined there, one must\n+\t// execute, typically at the start of main (not init!):\n+\t//\tflag.Parse()\n+\t// We don't run it here because this is not a main function and\n+\t// the testing suite has already parsed the flags.\n+}"}, {"sha": "320857b73e2ec249abc61c3a2fa584c037ed6a38", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -810,7 +810,7 @@ func TestMultiLine(t *testing.T) {\n \t}\n }\n \n-// RecursiveInt accepts an string matching %d.%d.%d....\n+// RecursiveInt accepts a string matching %d.%d.%d....\n // and parses it into a linked list.\n // It allows us to benchmark recursive descent style scanners.\n type RecursiveInt struct {\n@@ -826,7 +826,7 @@ func (r *RecursiveInt) Scan(state ScanState, verb rune) (err error) {\n \tnext := new(RecursiveInt)\n \t_, err = Fscanf(state, \".%v\", next)\n \tif err != nil {\n-\t\tif err == errors.New(\"input does not match format\") || err == io.ErrUnexpectedEOF {\n+\t\tif err == io.ErrUnexpectedEOF {\n \t\t\terr = nil\n \t\t}\n \t\treturn"}, {"sha": "d113dc135b15a58caa7f529b81648f90d48c4314", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -328,22 +328,22 @@ func (e *NoGoError) Error() string {\n }\n \n // Import returns details about the Go package named by the import path,\n-// interpreting local import paths relative to the src directory.  If the path\n-// is a local import path naming a package that can be imported using a\n-// standard import path, the returned package will set p.ImportPath to\n-// that path.\n+// interpreting local import paths relative to the srcDir directory.\n+// If the path is a local import path naming a package that can be imported\n+// using a standard import path, the returned package will set p.ImportPath\n+// to that path.\n //\n // In the directory containing the package, .go, .c, .h, and .s files are\n // considered part of the package except for:\n //\n //\t- .go files in package documentation\n-//\t- files starting with _ or .\n+//\t- files starting with _ or . (likely editor temporary files)\n //\t- files with build constraints not satisfied by the context\n //\n // If an error occurs, Import returns a non-nil error also returns a non-nil\n // *Package containing partial information.\n //\n-func (ctxt *Context) Import(path string, src string, mode ImportMode) (*Package, error) {\n+func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error) {\n \tp := &Package{\n \t\tImportPath: path,\n \t}\n@@ -363,11 +363,12 @@ func (ctxt *Context) Import(path string, src string, mode ImportMode) (*Package,\n \n \tbinaryOnly := false\n \tif IsLocalImport(path) {\n-\t\tif src == \"\" {\n+\t\tpkga = \"\" // local imports have no installed path\n+\t\tif srcDir == \"\" {\n \t\t\treturn p, fmt.Errorf(\"import %q: import relative to unknown directory\", path)\n \t\t}\n \t\tif !ctxt.isAbsPath(path) {\n-\t\t\tp.Dir = ctxt.joinPath(src, path)\n+\t\t\tp.Dir = ctxt.joinPath(srcDir, path)\n \t\t}\n \t\t// Determine canonical import path, if any.\n \t\tif ctxt.GOROOT != \"\" {\n@@ -640,8 +641,8 @@ func cleanImports(m map[string][]token.Position) ([]string, map[string][]token.P\n }\n \n // Import is shorthand for Default.Import.\n-func Import(path, src string, mode ImportMode) (*Package, error) {\n-\treturn Default.Import(path, src, mode)\n+func Import(path, srcDir string, mode ImportMode) (*Package, error) {\n+\treturn Default.Import(path, srcDir, mode)\n }\n \n // ImportDir is shorthand for Default.ImportDir.\n@@ -874,7 +875,7 @@ func splitQuoted(s string) (r []string, err error) {\n //\t!cgo (if cgo is disabled)\n //\ttag (if tag is listed in ctxt.BuildTags)\n //\t!tag (if tag is not listed in ctxt.BuildTags)\n-//\ta slash-separated list of any of these\n+//\ta comma-separated list of any of these\n //\n func (ctxt *Context) match(name string) bool {\n \tif name == \"\" {\n@@ -888,11 +889,11 @@ func (ctxt *Context) match(name string) bool {\n \t\treturn false\n \t}\n \tif strings.HasPrefix(name, \"!\") { // negation\n-\t\treturn !ctxt.match(name[1:])\n+\t\treturn len(name) > 1 && !ctxt.match(name[1:])\n \t}\n \n \t// Tags must be letters, digits, underscores.\n-\t// Unlike in Go identifiers, all digits is fine (e.g., \"386\").\n+\t// Unlike in Go identifiers, all digits are fine (e.g., \"386\").\n \tfor _, c := range name {\n \t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' {\n \t\t\treturn false"}, {"sha": "560ebad5c97a9cc0296f461d4f35a95bbe5795e0", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -36,6 +36,7 @@ func TestMatch(t *testing.T) {\n \tnomatch(runtime.GOOS + \",\" + runtime.GOARCH + \",!foo\")\n \tmatch(runtime.GOOS + \",\" + runtime.GOARCH + \",!bar\")\n \tnomatch(runtime.GOOS + \",\" + runtime.GOARCH + \",bar\")\n+\tnomatch(\"!\")\n }\n \n func TestDotSlashImport(t *testing.T) {"}, {"sha": "727d2a37147286845bb7e37748ceb4fd3a627e49", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -365,7 +365,7 @@ func (p *printer) setLineComment(text string) {\n }\n \n func (p *printer) isMultiLine(n ast.Node) bool {\n-\treturn p.lineFor(n.End())-p.lineFor(n.Pos()) > 1\n+\treturn p.lineFor(n.End())-p.lineFor(n.Pos()) > 0\n }\n \n func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool) {"}, {"sha": "71ed32ed145df34bf4e0f3e0c7c80e4cc3143985", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -500,7 +500,7 @@ type _ struct {\n \n type _ struct {\n \ta, b,\n-\tc, d\t\tint\t// this line should be indented\n+\tc, d\tint\t// this line should be indented\n \tu, v, w, x\tfloat\t// this line should be indented\n \tp, q,\n \tr, s\tfloat\t// this line should be indented\n@@ -562,10 +562,21 @@ var a2, b2,\n \n var (\n \ta3, b3,\n-\tc3, d3\t\tint\t// this line should be indented\n+\tc3, d3\tint\t// this line should be indented\n \ta4, b4, c4\tint\t// this line should be indented\n )\n \n+// Test case from issue 3304: multi-line declarations must end\n+// a formatting section and not influence indentation of the\n+// next line.\n+var (\n+\tminRefreshTimeSec\t= flag.Int64(\"min_refresh_time_sec\", 604800,\n+\t\t\"minimum time window between two refreshes for a given user.\")\n+\tx\t= flag.Int64(\"refresh_user_rollout_percent\", 100,\n+\t\t\"temporary flag to ramp up the refresh user rpc\")\n+\taVeryLongVariableName\t= stats.GetVarInt(\"refresh-user-count\")\n+)\n+\n func _() {\n \tvar privateKey2 = &Block{Type:\t\"RSA PRIVATE KEY\",\n \t\tHeaders:\tmap[string]string{},"}, {"sha": "d74cff25d1f4ccf70e14379b3edbbcf13d2f0584", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -577,6 +577,16 @@ c3, d3 int  // this line should be indented\n a4, b4, c4 int  // this line should be indented\n )\n \n+// Test case from issue 3304: multi-line declarations must end\n+// a formatting section and not influence indentation of the\n+// next line.\n+var (\n+\tminRefreshTimeSec = flag.Int64(\"min_refresh_time_sec\", 604800,\n+\t\t\"minimum time window between two refreshes for a given user.\")\n+\tx = flag.Int64(\"refresh_user_rollout_percent\", 100,\n+\t\t\"temporary flag to ramp up the refresh user rpc\")\n+\taVeryLongVariableName = stats.GetVarInt(\"refresh-user-count\")\n+)\n \n func _() {\n \tvar privateKey2 = &Block{Type: \"RSA PRIVATE KEY\","}, {"sha": "2663cddc24b84d3e892874c5184bec263d08667c", "filename": "libgo/go/html/template/clone_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fclone_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -113,3 +113,36 @@ func TestClone(t *testing.T) {\n \t\tt.Errorf(\"t3: got %q want %q\", got, want)\n \t}\n }\n+\n+func TestTemplates(t *testing.T) {\n+\tnames := []string{\"t0\", \"a\", \"lhs\", \"rhs\"}\n+\t// Some template definitions borrowed from TestClone.\n+\tconst tmpl = `\n+\t\t{{define \"a\"}}{{template \"lhs\"}}{{.}}{{template \"rhs\"}}{{end}}\n+\t\t{{define \"lhs\"}} <a href=\" {{end}}\n+\t\t{{define \"rhs\"}} \"></a> {{end}}`\n+\tt0 := Must(New(\"t0\").Parse(tmpl))\n+\ttemplates := t0.Templates()\n+\tif len(templates) != len(names) {\n+\t\tt.Errorf(\"expected %d templates; got %d\", len(names), len(templates))\n+\t}\n+\tfor _, name := range names {\n+\t\tfound := false\n+\t\tfor _, tmpl := range templates {\n+\t\t\tif name == tmpl.text.Name() {\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\tt.Error(\"could not find template\", name)\n+\t\t}\n+\t}\n+}\n+\n+// This used to crash; http://golang.org/issue/3281\n+func TestCloneCrash(t *testing.T) {\n+\tt1 := New(\"all\")\n+\tMust(t1.New(\"t1\").Parse(`{{define \"foo\"}}foo{{end}}`))\n+\tt1.Clone()\n+}"}, {"sha": "c1bd2e4949b4373458b31901dd401839a3757462", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -26,10 +26,10 @@ type (\n \tHTML string\n \n \t// HTMLAttr encapsulates an HTML attribute from a trusted source,\n-\t// for example: ` dir=\"ltr\"`.\n+\t// for example, ` dir=\"ltr\"`.\n \tHTMLAttr string\n \n-\t// JS encapsulates a known safe EcmaScript5 Expression, or example,\n+\t// JS encapsulates a known safe EcmaScript5 Expression, for example,\n \t// `(x + y * z())`. \n \t// Template authors are responsible for ensuring that typed expressions\n \t// do not break the intended precedence and that there is no"}, {"sha": "5f0e28e8c1ce0191e9c1e39442e4e15fef1e734f", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"html\"\n+\t\"io\"\n \t\"text/template\"\n \t\"text/template/parse\"\n )\n@@ -751,3 +752,44 @@ func (e *escaper) template(name string) *template.Template {\n \t}\n \treturn t\n }\n+\n+// Forwarding functions so that clients need only import this package\n+// to reach the general escaping functions of text/template.\n+\n+// HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n+func HTMLEscape(w io.Writer, b []byte) {\n+\ttemplate.HTMLEscape(w, b)\n+}\n+\n+// HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n+func HTMLEscapeString(s string) string {\n+\treturn template.HTMLEscapeString(s)\n+}\n+\n+// HTMLEscaper returns the escaped HTML equivalent of the textual\n+// representation of its arguments.\n+func HTMLEscaper(args ...interface{}) string {\n+\treturn template.HTMLEscaper(args...)\n+}\n+\n+// JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n+func JSEscape(w io.Writer, b []byte) {\n+\ttemplate.JSEscape(w, b)\n+}\n+\n+// JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n+func JSEscapeString(s string) string {\n+\treturn template.JSEscapeString(s)\n+}\n+\n+// JSEscaper returns the escaped JavaScript equivalent of the textual\n+// representation of its arguments.\n+func JSEscaper(args ...interface{}) string {\n+\treturn template.JSEscaper(args...)\n+}\n+\n+// URLQueryEscaper returns the escaped value of the textual representation of\n+// its arguments in a form suitable for embedding in a URL query.\n+func URLQueryEscaper(args ...interface{}) string {\n+\treturn template.URLQueryEscaper(args...)\n+}"}, {"sha": "ce12c1795c24ee81926523fab7695be789e5f836", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n \t\"text/template\"\n@@ -1637,6 +1638,14 @@ func TestIndirectPrint(t *testing.T) {\n \t}\n }\n \n+// This is a test for issue 3272.\n+func TestEmptyTemplate(t *testing.T) {\n+\tpage := Must(New(\"page\").ParseFiles(os.DevNull))\n+\tif err := page.ExecuteTemplate(os.Stdout, \"page\", \"nothing\"); err == nil {\n+\t\tt.Fatal(\"expected error\")\n+\t}\n+}\n+\n func BenchmarkEscapedExecute(b *testing.B) {\n \ttmpl := Must(New(\"t\").Parse(`<a onclick=\"alert('{{.}}')\">{{.}}</a>`))\n \tvar buf bytes.Buffer"}, {"sha": "edac7335cfdf39039a3484ccd60adaada93482de", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -31,6 +31,20 @@ type nameSpace struct {\n \tset map[string]*Template\n }\n \n+// Templates returns a slice of the templates associated with t, including t\n+// itself.\n+func (t *Template) Templates() []*Template {\n+\tns := t.nameSpace\n+\tns.mu.Lock()\n+\tdefer ns.mu.Unlock()\n+\t// Return a slice so we don't expose the map.\n+\tm := make([]*Template, 0, len(ns.set))\n+\tfor _, v := range ns.set {\n+\t\tm = append(m, v)\n+\t}\n+\treturn m\n+}\n+\n // Execute applies a parsed template to the specified data object,\n // writing the output to wr.\n func (t *Template) Execute(wr io.Writer, data interface{}) (err error) {\n@@ -64,7 +78,13 @@ func (t *Template) lookupAndEscapeTemplate(name string) (tmpl *Template, err err\n \tt.nameSpace.mu.Lock()\n \tdefer t.nameSpace.mu.Unlock()\n \ttmpl = t.set[name]\n-\tif (tmpl == nil) != (t.text.Lookup(name) == nil) {\n+\tif tmpl == nil {\n+\t\treturn nil, fmt.Errorf(\"html/template: %q is undefined\", name)\n+\t}\n+\tif tmpl.text.Tree == nil || tmpl.text.Root == nil {\n+\t\treturn nil, fmt.Errorf(\"html/template: %q is an incomplete template\", name)\n+\t}\n+\tif t.text.Lookup(name) == nil {\n \t\tpanic(\"html/template internal error: template escaping out of sync\")\n \t}\n \tif tmpl != nil && !tmpl.escaped {\n@@ -160,9 +180,11 @@ func (t *Template) Clone() (*Template, error) {\n \t\tif src == nil || src.escaped {\n \t\t\treturn nil, fmt.Errorf(\"html/template: cannot Clone %q after it has executed\", t.Name())\n \t\t}\n-\t\tx.Tree = &parse.Tree{\n-\t\t\tName: x.Tree.Name,\n-\t\t\tRoot: x.Tree.Root.CopyList(),\n+\t\tif x.Tree != nil {\n+\t\t\tx.Tree = &parse.Tree{\n+\t\t\t\tName: x.Tree.Name,\n+\t\t\t\tRoot: x.Tree.Root.CopyList(),\n+\t\t\t}\n \t\t}\n \t\tret.set[name] = &Template{\n \t\t\tfalse,\n@@ -274,7 +296,7 @@ func (t *Template) ParseFiles(filenames ...string) (*Template, error) {\n func parseFiles(t *Template, filenames ...string) (*Template, error) {\n \tif len(filenames) == 0 {\n \t\t// Not really a problem, but be consistent.\n-\t\treturn nil, fmt.Errorf(\"template: no files named in call to ParseFiles\")\n+\t\treturn nil, fmt.Errorf(\"html/template: no files named in call to ParseFiles\")\n \t}\n \tfor _, filename := range filenames {\n \t\tb, err := ioutil.ReadFile(filename)\n@@ -331,7 +353,7 @@ func parseGlob(t *Template, pattern string) (*Template, error) {\n \t\treturn nil, err\n \t}\n \tif len(filenames) == 0 {\n-\t\treturn nil, fmt.Errorf(\"template: pattern matches no files: %#q\", pattern)\n+\t\treturn nil, fmt.Errorf(\"html/template: pattern matches no files: %#q\", pattern)\n \t}\n \treturn parseFiles(t, filenames...)\n }"}, {"sha": "bef325c0c9df5960937e69b50e2f2f7f9e91a64b", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -5,7 +5,7 @@\n // Package draw provides image composition functions.\n //\n // See \"The Go image/draw package\" for an introduction to this package:\n-// http://blog.golang.org/2011/09/go-imagedraw-package.html\n+// http://golang.org/doc/articles/image_draw.html\n package draw\n \n import ("}, {"sha": "9c36a98f82d2679a410ec3bedeacb5f4b6ebe406", "filename": "libgo/go/index/suffixarray/qsufsort.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -11,7 +11,7 @@\n // Consecutive groups of suffixes in sa are labeled as sorted groups or\n // unsorted groups. For a given pass of the sorter, all suffixes are ordered\n // up to their first h characters, and sa is h-ordered. Suffixes in their\n-// final positions and unambiguouly sorted in h-order are in a sorted group.\n+// final positions and unambiguously sorted in h-order are in a sorted group.\n // Consecutive groups of suffixes with identical first h characters are an\n // unsorted group. In each pass of the algorithm, unsorted groups are sorted\n // according to the group number of their following suffix.\n@@ -78,7 +78,7 @@ func sortedByFirstByte(data []byte) []int {\n \tfor _, b := range data {\n \t\tcount[b]++\n \t}\n-\t// make count[b] equal index of first occurence of b in sorted array\n+\t// make count[b] equal index of first occurrence of b in sorted array\n \tsum := 0\n \tfor b := range count {\n \t\tcount[b], sum = sum, count[b]+sum"}, {"sha": "f072b8c754a53f14fafedfc4214c35385d4fa909", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -53,10 +53,13 @@ func ReadFile(filename string) ([]byte, error) {\n \tdefer f.Close()\n \t// It's a good but not certain bet that FileInfo will tell us exactly how much to\n \t// read, so let's try it but be prepared for the answer to be wrong.\n-\tfi, err := f.Stat()\n \tvar n int64\n-\tif size := fi.Size(); err == nil && size < 2e9 { // Don't preallocate a huge buffer, just in case.\n-\t\tn = size\n+\n+\tif fi, err := f.Stat(); err == nil {\n+\t\t// Don't preallocate a huge buffer, just in case.\n+\t\tif size := fi.Size(); size < 1e9 {\n+\t\t\tn = size\n+\t\t}\n \t}\n \t// As initial capacity for readAll, use n + a little extra in case Size is zero,\n \t// and to avoid another allocation after Read has filled the buffer.  The readAll"}, {"sha": "8d99e2e594d9d44e7f645718e1f003f7e65db141", "filename": "libgo/go/log/syslog/syslog_windows.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_windows.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package syslog provides a simple interface to the system log service.\n+package syslog\n+\n+// BUG(brainman): This package is not implemented on Windows yet."}, {"sha": "0bc6572b962a9bbd14436d293d74852a182afae8", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -826,7 +826,7 @@ func (x nat) string(charset string) string {\n // iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the \n // range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and \n // ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for \n-// specfic hardware.\n+// specific hardware.\n //\n func (q nat) convertWords(s []byte, charset string, b Word, ndigits int, bb Word, table []divisor) {\n \t// split larger blocks recursively"}, {"sha": "c6f32bdbe284087f1cc783d9dfd110706d72221b", "filename": "libgo/go/math/erf.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fmath%2Ferf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fmath%2Ferf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ferf.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -248,7 +248,7 @@ func Erf(x float64) float64 {\n \t\tR = rb0 + s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(rb5+s*rb6)))))\n \t\tS = 1 + s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(sb5+s*(sb6+s*sb7))))))\n \t}\n-\tz := Float64frombits(Float64bits(x) & 0xffffffff00000000) // pseudo-single (20-bit) precison x\n+\tz := Float64frombits(Float64bits(x) & 0xffffffff00000000) // pseudo-single (20-bit) precision x\n \tr := Exp(-z*z-0.5625) * Exp((z-x)*(z+x)+R/S)\n \tif sign {\n \t\treturn r/x - 1\n@@ -321,7 +321,7 @@ func Erfc(x float64) float64 {\n \t\t\tR = rb0 + s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(rb5+s*rb6)))))\n \t\t\tS = 1 + s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(sb5+s*(sb6+s*sb7))))))\n \t\t}\n-\t\tz := Float64frombits(Float64bits(x) & 0xffffffff00000000) // pseudo-single (20-bit) precison x\n+\t\tz := Float64frombits(Float64bits(x) & 0xffffffff00000000) // pseudo-single (20-bit) precision x\n \t\tr := Exp(-z*z-0.5625) * Exp((z-x)*(z+x)+R/S)\n \t\tif sign {\n \t\t\treturn 2 - r/x"}, {"sha": "232d6508906328a53855a995cd63db02bcc3f477", "filename": "libgo/go/net/http/triv.go", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -15,7 +15,9 @@ import (\n \t\"log\"\n \t\"net/http\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"strconv\"\n+\t\"sync\"\n )\n \n // hello world, the web server\n@@ -28,14 +30,21 @@ func HelloServer(w http.ResponseWriter, req *http.Request) {\n \n // Simple counter server. POSTing to it will set the value.\n type Counter struct {\n-\tn int\n+\tmu sync.Mutex // protects n\n+\tn  int\n }\n \n // This makes Counter satisfy the expvar.Var interface, so we can export\n // it directly.\n-func (ctr *Counter) String() string { return fmt.Sprintf(\"%d\", ctr.n) }\n+func (ctr *Counter) String() string {\n+\tctr.mu.Lock()\n+\tdefer ctr.mu.Unlock()\n+\treturn fmt.Sprintf(\"%d\", ctr.n)\n+}\n \n func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n+\tctr.mu.Lock()\n+\tdefer ctr.mu.Unlock()\n \tswitch req.Method {\n \tcase \"GET\":\n \t\tctr.n++\n@@ -95,54 +104,36 @@ func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n // exec a program, redirecting output\n func DateServer(rw http.ResponseWriter, req *http.Request) {\n \trw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n-\tr, w, err := os.Pipe()\n-\tif err != nil {\n-\t\tfmt.Fprintf(rw, \"pipe: %s\\n\", err)\n-\t\treturn\n-\t}\n \n-\tp, err := os.StartProcess(\"/bin/date\", []string{\"date\"}, &os.ProcAttr{Files: []*os.File{nil, w, w}})\n-\tdefer r.Close()\n-\tw.Close()\n-\tif err != nil {\n-\t\tfmt.Fprintf(rw, \"fork/exec: %s\\n\", err)\n-\t\treturn\n-\t}\n-\tio.Copy(rw, r)\n-\twait, err := p.Wait(0)\n+\tdate, err := exec.Command(\"/bin/date\").Output()\n \tif err != nil {\n-\t\tfmt.Fprintf(rw, \"wait: %s\\n\", err)\n-\t\treturn\n-\t}\n-\tif !wait.Exited() || wait.ExitStatus() != 0 {\n-\t\tfmt.Fprintf(rw, \"date: %v\\n\", wait)\n+\t\thttp.Error(rw, err.Error(), 500)\n \t\treturn\n \t}\n+\trw.Write(date)\n }\n \n func Logger(w http.ResponseWriter, req *http.Request) {\n-\tlog.Print(req.URL.Raw)\n-\tw.WriteHeader(404)\n-\tw.Write([]byte(\"oops\"))\n+\tlog.Print(req.URL)\n+\thttp.Error(w, \"oops\", 404)\n }\n \n-var webroot = flag.String(\"root\", \"/home/rsc\", \"web root directory\")\n+var webroot = flag.String(\"root\", os.Getenv(\"HOME\"), \"web root directory\")\n \n func main() {\n \tflag.Parse()\n \n \t// The counter is published as a variable directly.\n \tctr := new(Counter)\n-\thttp.Handle(\"/counter\", ctr)\n \texpvar.Publish(\"counter\", ctr)\n-\n+\thttp.Handle(\"/counter\", ctr)\n \thttp.Handle(\"/\", http.HandlerFunc(Logger))\n \thttp.Handle(\"/go/\", http.StripPrefix(\"/go/\", http.FileServer(http.Dir(*webroot))))\n-\thttp.Handle(\"/flags\", http.HandlerFunc(FlagServer))\n-\thttp.Handle(\"/args\", http.HandlerFunc(ArgServer))\n-\thttp.Handle(\"/go/hello\", http.HandlerFunc(HelloServer))\n \thttp.Handle(\"/chan\", ChanCreate())\n-\thttp.Handle(\"/date\", http.HandlerFunc(DateServer))\n+\thttp.HandleFunc(\"/flags\", FlagServer)\n+\thttp.HandleFunc(\"/args\", ArgServer)\n+\thttp.HandleFunc(\"/go/hello\", HelloServer)\n+\thttp.HandleFunc(\"/date\", DateServer)\n \terr := http.ListenAndServe(\":12345\", nil)\n \tif err != nil {\n \t\tlog.Panicln(\"ListenAndServe:\", err)"}, {"sha": "825b20227aeaa7e6b5d4a73f0c500ff5fcb294d8", "filename": "libgo/go/net/interface_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Finterface_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Finterface_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_linux.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -13,7 +13,7 @@ import (\n )\n \n // If the ifindex is zero, interfaceTable returns mappings of all\n-// network interfaces.  Otheriwse it returns a mapping of a specific\n+// network interfaces.  Otherwise it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n \ttab, err := syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)"}, {"sha": "d4d7ce9c7f88e1d2f374cd72c7f31f1dbe632bf2", "filename": "libgo/go/net/interface_stub.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Finterface_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Finterface_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_stub.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -9,7 +9,7 @@\n package net\n \n // If the ifindex is zero, interfaceTable returns mappings of all\n-// network interfaces.  Otheriwse it returns a mapping of a specific\n+// network interfaces.  Otherwise it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n \treturn nil, nil"}, {"sha": "4368b3306213b54c814cec6079e7373904eb7577", "filename": "libgo/go/net/interface_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Finterface_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Finterface_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_windows.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -56,7 +56,7 @@ func getInterfaceList() ([]syscall.InterfaceInfo, error) {\n }\n \n // If the ifindex is zero, interfaceTable returns mappings of all\n-// network interfaces.  Otheriwse it returns a mapping of a specific\n+// network interfaces.  Otherwise it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n \tai, err := getAdapterList()"}, {"sha": "e5dd013db670c9985419194ea38ee11acd7681d8", "filename": "libgo/go/net/unicast_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Funicast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fnet%2Funicast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funicast_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -5,7 +5,6 @@\n package net\n \n import (\n-\t\"io\"\n \t\"runtime\"\n \t\"syscall\"\n \t\"testing\"\n@@ -67,7 +66,7 @@ func TestTCPListener(t *testing.T) {\n \t\tcase syscall.AF_INET6:\n \t\t\ttestIPv6UnicastSocketOptions(t, fd)\n \t\t}\n-\t\tl1.(io.Closer).Close()\n+\t\tl1.Close()\n \t}\n }\n \n@@ -112,7 +111,7 @@ func TestUDPListener(t *testing.T) {\n \t\tcase syscall.AF_INET6:\n \t\t\ttestIPv6UnicastSocketOptions(t, fd)\n \t\t}\n-\t\tl1.(io.Closer).Close()\n+\t\tl1.Close()\n \t}\n }\n \n@@ -134,7 +133,7 @@ func TestSimpleTCPListener(t *testing.T) {\n \t\tcheckFirstListener(t, tt.net, tt.laddr+\":\"+port, l1)\n \t\tl2, err := Listen(tt.net, tt.laddr+\":\"+port)\n \t\tcheckSecondListener(t, tt.net, tt.laddr+\":\"+port, err, l2)\n-\t\tl1.(io.Closer).Close()\n+\t\tl1.Close()\n \t}\n }\n \n@@ -169,7 +168,7 @@ func TestSimpleUDPListener(t *testing.T) {\n \t\tcheckFirstListener(t, tt.net, tt.laddr+\":\"+port, l1)\n \t\tl2, err := ListenPacket(tt.net, tt.laddr+\":\"+port)\n \t\tcheckSecondListener(t, tt.net, tt.laddr+\":\"+port, err, l2)\n-\t\tl1.(io.Closer).Close()\n+\t\tl1.Close()\n \t}\n }\n \n@@ -530,8 +529,9 @@ func TestProhibitionaryDialArgs(t *testing.T) {\n \tdefer l.Close()\n \n \tfor _, tt := range prohibitionaryDialArgTests {\n-\t\t_, err := Dial(tt.net, tt.addr+\":\"+port)\n+\t\tc, err := Dial(tt.net, tt.addr+\":\"+port)\n \t\tif err == nil {\n+\t\t\tc.Close()\n \t\t\tt.Fatalf(\"Dial(%q, %q) should fail\", tt.net, tt.addr)\n \t\t}\n \t}"}, {"sha": "b88e49400de9a3356a1c8df853add3197d758c97", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -42,3 +42,21 @@ func NewSyscallError(syscall string, err error) error {\n \t}\n \treturn &SyscallError{syscall, err}\n }\n+\n+// IsExist returns whether the error is known to report that a file or directory \n+// already exists. It is satisfied by ErrExist as well as some syscall errors.\n+func IsExist(err error) bool {\n+\treturn isExist(err)\n+}\n+\n+// IsNotExist returns whether the error is known to report that a file or directory\n+// does not exist. It is satisfied by ErrNotExist as well as some syscall errors.\n+func IsNotExist(err error) bool {\n+\treturn isNotExist(err)\n+}\n+\n+// IsPermission returns whether the error is known to report that permission is denied.\n+// It is satisfied by ErrPermission as well as some syscall errors.\n+func IsPermission(err error) bool {\n+\treturn isPermission(err)\n+}"}, {"sha": "3c9dfb0b158b6381d73a8c7ea63303aebd9ca47e", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -4,24 +4,21 @@\n \n package os\n \n-// IsExist returns whether the error is known to report that a file already exists.\n-func IsExist(err error) bool {\n+func isExist(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n \treturn contains(err.Error(), \" exists\")\n }\n \n-// IsNotExist returns whether the error is known to report that a file does not exist.\n-func IsNotExist(err error) bool {\n+func isNotExist(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n \treturn contains(err.Error(), \"does not exist\")\n }\n \n-// IsPermission returns whether the error is known to report that permission is denied.\n-func IsPermission(err error) bool {\n+func isPermission(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}"}, {"sha": "1685c1f2132287caa221566f8afc36a888b215d8", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -8,27 +8,21 @@ package os\n \n import \"syscall\"\n \n-// IsExist returns whether the error is known to report that a file already exists.\n-// It is satisfied by ErrExist as well as some syscall errors.\n-func IsExist(err error) bool {\n+func isExist(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.EEXIST || err == ErrExist\n }\n \n-// IsNotExist returns whether the error is known to report that a file does not exist.\n-// It is satisfied by ErrNotExist as well as some syscall errors.\n-func IsNotExist(err error) bool {\n+func isNotExist(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.ENOENT || err == ErrNotExist\n }\n \n-// IsPermission returns whether the error is known to report that permission is denied.\n-// It is satisfied by ErrPermission as well as some syscall errors.\n-func IsPermission(err error) bool {\n+func isPermission(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}"}, {"sha": "42f846fa3c59b8fcf47071272be18047c32ab775", "filename": "libgo/go/os/error_test.go", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -5,8 +5,10 @@\n package os_test\n \n import (\n+\t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"testing\"\n )\n \n@@ -24,8 +26,56 @@ func TestErrIsExist(t *testing.T) {\n \t\tt.Fatal(\"Open should have failed\")\n \t\treturn\n \t}\n-\tif !os.IsExist(err) {\n-\t\tt.Fatalf(\"os.IsExist does not work as expected for %#v\", err)\n+\tif s := checkErrorPredicate(\"os.IsExist\", os.IsExist, err); s != \"\" {\n+\t\tt.Fatal(s)\n \t\treturn\n \t}\n }\n+\n+func testErrNotExist(name string) string {\n+\tf, err := os.Open(name)\n+\tif err == nil {\n+\t\tf.Close()\n+\t\treturn \"Open should have failed\"\n+\t}\n+\tif s := checkErrorPredicate(\"os.IsNotExist\", os.IsNotExist, err); s != \"\" {\n+\t\treturn s\n+\t}\n+\n+\terr = os.Chdir(name)\n+\tif err == nil {\n+\t\treturn \"Chdir should have failed\"\n+\t}\n+\tif s := checkErrorPredicate(\"os.IsNotExist\", os.IsNotExist, err); s != \"\" {\n+\t\treturn s\n+\t}\n+\treturn \"\"\n+}\n+\n+func TestErrIsNotExist(t *testing.T) {\n+\ttmpDir, err := ioutil.TempDir(\"\", \"_Go_ErrIsNotExist\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"create ErrIsNotExist tempdir: %s\", err)\n+\t\treturn\n+\t}\n+\tdefer os.RemoveAll(tmpDir)\n+\n+\tname := filepath.Join(tmpDir, \"NotExists\")\n+\tif s := testErrNotExist(name); s != \"\" {\n+\t\tt.Fatal(s)\n+\t\treturn\n+\t}\n+\n+\tname = filepath.Join(name, \"NotExists2\")\n+\tif s := testErrNotExist(name); s != \"\" {\n+\t\tt.Fatal(s)\n+\t\treturn\n+\t}\n+}\n+\n+func checkErrorPredicate(predName string, pred func(error) bool, err error) string {\n+\tif !pred(err) {\n+\t\treturn fmt.Sprintf(\"%s does not work as expected for %#v\", predName, err)\n+\t}\n+\treturn \"\"\n+}"}, {"sha": "5d692b07362bd6e2c10380909cceefa0633cc0d4", "filename": "libgo/go/os/error_windows.go", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ferror_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_windows.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -6,30 +6,25 @@ package os\n \n import \"syscall\"\n \n-// IsExist returns whether the error is known to report that a file already exists.\n-// It is satisfied by ErrExist as well as some syscall errors.\n-func IsExist(err error) bool {\n+func isExist(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n-\treturn err == syscall.EEXIST || err == syscall.ERROR_ALREADY_EXISTS ||\n+\treturn err == syscall.ERROR_ALREADY_EXISTS ||\n \t\terr == syscall.ERROR_FILE_EXISTS || err == ErrExist\n }\n \n-// IsNotExist returns whether the error is known to report that a file does not exist.\n-// It is satisfied by ErrNotExist as well as some syscall errors.\n-func IsNotExist(err error) bool {\n+func isNotExist(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n-\treturn err == syscall.ENOENT || err == ErrNotExist\n+\treturn err == syscall.ERROR_FILE_NOT_FOUND ||\n+\t\terr == syscall.ERROR_PATH_NOT_FOUND || err == ErrNotExist\n }\n \n-// IsPermission returns whether the error is known to report that permission is denied.\n-// It is satisfied by ErrPermission as well as some syscall errors.\n-func IsPermission(err error) bool {\n+func isPermission(err error) bool {\n \tif pe, ok := err.(*PathError); ok {\n \t\terr = pe.Err\n \t}\n-\treturn err == syscall.EACCES || err == syscall.EPERM || err == ErrPermission\n+\treturn err == ErrPermission\n }"}, {"sha": "b8fb2e22c9808c9a854d08a839cf66144e0966e8", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -179,7 +179,21 @@ func (f *File) pread(b []byte, off int64) (n int, err error) {\n // write writes len(b) bytes to the File.\n // It returns the number of bytes written and an error, if any.\n func (f *File) write(b []byte) (n int, err error) {\n-\treturn syscall.Write(f.fd, b)\n+\tfor {\n+\t\tm, err := syscall.Write(f.fd, b)\n+\t\tn += m\n+\n+\t\t// If the syscall wrote some data but not all (short write)\n+\t\t// or it returned EINTR, then assume it stopped early for\n+\t\t// reasons that are uninteresting to the caller, and try again.\n+\t\tif 0 < m && m < len(b) || err == syscall.EINTR {\n+\t\t\tb = b[m:]\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treturn n, err\n+\t}\n+\tpanic(\"not reached\")\n }\n \n // pwrite writes len(b) bytes to the File starting at byte offset off."}, {"sha": "8d3f677fd4e5a96930adc6f5bd69b96abb062038", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -1045,3 +1045,22 @@ func TestSameFile(t *testing.T) {\n \t\tt.Errorf(\"files should be different\")\n \t}\n }\n+\n+func TestDevNullFile(t *testing.T) {\n+\tf, err := Open(DevNull)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open(%s): %v\", DevNull, err)\n+\t}\n+\tdefer f.Close()\n+\tfi, err := f.Stat()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat(%s): %v\", DevNull, err)\n+\t}\n+\tname := filepath.Base(DevNull)\n+\tif fi.Name() != name {\n+\t\tt.Fatalf(\"wrong file name have %v want %v\", fi.Name(), name)\n+\t}\n+\tif fi.Size() != 0 {\n+\t\tt.Fatalf(\"wrong file size have %d want 0\", fi.Size())\n+\t}\n+}"}, {"sha": "db8b0260ca88d324cb334b586af70211e9b00fd8", "filename": "libgo/go/path/filepath/match.go", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -7,6 +7,7 @@ package filepath\n import (\n \t\"errors\"\n \t\"os\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"unicode/utf8\"\n@@ -37,6 +38,9 @@ var ErrBadPattern = errors.New(\"syntax error in pattern\")\n // The only possible returned error is ErrBadPattern, when pattern\n // is malformed.\n //\n+// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n+// path separator.\n+//\n func Match(pattern, name string) (matched bool, err error) {\n Pattern:\n \tfor len(pattern) > 0 {\n@@ -95,9 +99,11 @@ Scan:\n \tfor i = 0; i < len(pattern); i++ {\n \t\tswitch pattern[i] {\n \t\tcase '\\\\':\n-\t\t\t// error check handled in matchChunk: bad pattern.\n-\t\t\tif i+1 < len(pattern) {\n-\t\t\t\ti++\n+\t\t\tif runtime.GOOS != \"windows\" {\n+\t\t\t\t// error check handled in matchChunk: bad pattern.\n+\t\t\t\tif i+1 < len(pattern) {\n+\t\t\t\t\ti++\n+\t\t\t\t}\n \t\t\t}\n \t\tcase '[':\n \t\t\tinrange = true\n@@ -167,10 +173,12 @@ func matchChunk(chunk, s string) (rest string, ok bool, err error) {\n \t\t\tchunk = chunk[1:]\n \n \t\tcase '\\\\':\n-\t\t\tchunk = chunk[1:]\n-\t\t\tif len(chunk) == 0 {\n-\t\t\t\terr = ErrBadPattern\n-\t\t\t\treturn\n+\t\t\tif runtime.GOOS != \"windows\" {\n+\t\t\t\tchunk = chunk[1:]\n+\t\t\t\tif len(chunk) == 0 {\n+\t\t\t\t\terr = ErrBadPattern\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t}\n \t\t\tfallthrough\n \n@@ -191,7 +199,7 @@ func getEsc(chunk string) (r rune, nchunk string, err error) {\n \t\terr = ErrBadPattern\n \t\treturn\n \t}\n-\tif chunk[0] == '\\\\' {\n+\tif chunk[0] == '\\\\' && runtime.GOOS != \"windows\" {\n \t\tchunk = chunk[1:]\n \t\tif len(chunk) == 0 {\n \t\t\terr = ErrBadPattern"}, {"sha": "e3d365881cc898008ec33b59d8d021ada20fde6d", "filename": "libgo/go/path/filepath/match_test.go", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -7,6 +7,7 @@ package filepath_test\n import (\n \t. \"path/filepath\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -76,21 +77,26 @@ func errp(e error) string {\n }\n \n func TestMatch(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\t// XXX: Don't pass for windows.\n-\t\treturn\n-\t}\n \tfor _, tt := range matchTests {\n-\t\tok, err := Match(tt.pattern, tt.s)\n+\t\tpattern := tt.pattern\n+\t\ts := tt.s\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\tif strings.Index(pattern, \"\\\\\") >= 0 {\n+\t\t\t\t// no escape allowed on windows.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tpattern = Clean(pattern)\n+\t\t\ts = Clean(s)\n+\t\t}\n+\t\tok, err := Match(pattern, s)\n \t\tif ok != tt.match || err != tt.err {\n-\t\t\tt.Errorf(\"Match(%#q, %#q) = %v, %q want %v, %q\", tt.pattern, tt.s, ok, errp(err), tt.match, errp(tt.err))\n+\t\t\tt.Errorf(\"Match(%#q, %#q) = %v, %q want %v, %q\", pattern, s, ok, errp(err), tt.match, errp(tt.err))\n \t\t}\n \t}\n }\n \n // contains returns true if vector contains the string s.\n func contains(vector []string, s string) bool {\n-\ts = ToSlash(s)\n \tfor _, elem := range vector {\n \t\tif elem == s {\n \t\t\treturn true\n@@ -110,18 +116,20 @@ var globTests = []struct {\n }\n \n func TestGlob(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\t// XXX: Don't pass for windows.\n-\t\treturn\n-\t}\n \tfor _, tt := range globTests {\n-\t\tmatches, err := Glob(tt.pattern)\n+\t\tpattern := tt.pattern\n+\t\tresult := tt.result\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\tpattern = Clean(pattern)\n+\t\t\tresult = Clean(result)\n+\t\t}\n+\t\tmatches, err := Glob(pattern)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"Glob error for %q: %s\", tt.pattern, err)\n+\t\t\tt.Errorf(\"Glob error for %q: %s\", pattern, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif !contains(matches, tt.result) {\n-\t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", tt.pattern, matches, tt.result)\n+\t\tif !contains(matches, result) {\n+\t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", pattern, matches, result)\n \t\t}\n \t}\n \tfor _, pattern := range []string{\"no_match\", \"../*/no_match\"} {"}, {"sha": "7fe18a9d735722f71050812b7d4530363bd32aff", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -66,9 +66,10 @@ type Type interface {\n \t// It returns an empty string for unnamed types.\n \tName() string\n \n-\t// PkgPath returns the type's package path.\n-\t// The package path is a full package import path like \"encoding/base64\".\n-\t// PkgPath returns an empty string for unnamed or predeclared types.\n+\t// PkgPath returns a named type's package path, that is, the import path\n+\t// that uniquely identifies the package, such as \"encoding/base64\".\n+\t// If the type was predeclared (string, error) or unnamed (*T, struct{}, []int),\n+\t// the package path will be the empty string.\n \tPkgPath() string\n \n \t// Size returns the number of bytes needed to store\n@@ -351,11 +352,18 @@ type structType struct {\n \n // Method represents a single method.\n type Method struct {\n-\tPkgPath string // empty for uppercase Name\n+\t// Name is the method name.\n+\t// PkgPath is the package path that qualifies a lower case (unexported)\n+\t// method name.  It is empty for upper case (exported) method names.\n+\t// The combination of PkgPath and Name uniquely identifies a method\n+\t// in a method set. \n+\t// See http://golang.org/ref/spec#Uniqueness_of_identifiers\n \tName    string\n-\tType    Type\n-\tFunc    Value\n-\tIndex   int\n+\tPkgPath string\n+\n+\tType  Type  // method type\n+\tFunc  Value // func with receiver as first argument\n+\tIndex int   // index for Type.Method\n }\n \n // High bit says whether type has\n@@ -695,14 +703,20 @@ func (t *interfaceType) MethodByName(name string) (m Method, ok bool) {\n \treturn\n }\n \n+// A StructField describes a single field in a struct.\n type StructField struct {\n-\tPkgPath   string // empty for uppercase Name\n-\tName      string\n-\tType      Type\n-\tTag       StructTag\n-\tOffset    uintptr\n-\tIndex     []int\n-\tAnonymous bool\n+\t// Name is the field name.\n+\t// PkgPath is the package path that qualifies a lower case (unexported)\n+\t// field name.  It is empty for upper case (exported) field names.\n+\t// See http://golang.org/ref/spec#Uniqueness_of_identifiers\n+\tName    string\n+\tPkgPath string\n+\n+\tType      Type      // field type\n+\tTag       StructTag // field tag string\n+\tOffset    uintptr   // offset within struct, in bytes\n+\tIndex     []int     // index sequence for Type.FieldByIndex\n+\tAnonymous bool      // is an anonymous field\n }\n \n // A StructTag is the tag string in a struct field."}, {"sha": "a12fcb2668fecf6b921f7b6900a95283d553b5b3", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -1624,6 +1624,15 @@ func MakeSlice(typ Type, len, cap int) Value {\n \tif typ.Kind() != Slice {\n \t\tpanic(\"reflect.MakeSlice of non-slice type\")\n \t}\n+\tif len < 0 {\n+\t\tpanic(\"reflect.MakeSlice: negative len\")\n+\t}\n+\tif cap < 0 {\n+\t\tpanic(\"reflect.MakeSlice: negative cap\")\n+\t}\n+\tif len > cap {\n+\t\tpanic(\"reflect.MakeSlice: len > cap\")\n+\t}\n \n \t// Declare slice so that gc can see the base pointer in it.\n \tvar x []byte"}, {"sha": "62a4d55e798477ed6c71d3fb3778bda4f89ab394", "filename": "libgo/go/sort/sort.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fsort%2Fsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Fsort%2Fsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fsort.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -183,17 +183,21 @@ func quickSort(data Interface, a, b, maxDepth int) {\n \t}\n }\n \n+// Sort sorts data.\n+// It makes one call to data.Len to determine n, and O(n*log(n)) calls to\n+// data.Less and data.Swap. The sort is not guaranteed to be stable.\n func Sort(data Interface) {\n-\t// Switch to heapsort if depth of 2*ceil(lg(n)) is reached.\n+\t// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.\n \tn := data.Len()\n \tmaxDepth := 0\n-\tfor 1<<uint(maxDepth) < n {\n+\tfor i := n; i > 0; i >>= 1 {\n \t\tmaxDepth++\n \t}\n \tmaxDepth *= 2\n \tquickSort(data, 0, n, maxDepth)\n }\n \n+// IsSorted reports whether data is sorted.\n func IsSorted(data Interface) bool {\n \tn := data.Len()\n \tfor i := n - 1; i > 0; i-- {"}, {"sha": "9a720cf43e3743cf8db17423c4e995f5a0f42791", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -369,6 +369,7 @@ func (s *state) evalVariableNode(dot reflect.Value, v *parse.VariableNode, args\n \t// $x.Field has $x as the first ident, Field as the second. Eval the var, then the fields.\n \tvalue := s.varValue(v.Ident[0])\n \tif len(v.Ident) == 1 {\n+\t\ts.notAFunction(args, final)\n \t\treturn value\n \t}\n \treturn s.evalFieldChain(dot, value, v.Ident[1:], args, final)"}, {"sha": "5446027ff7ad0ae78425871a12fb81345bd57089", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -466,6 +466,10 @@ var execTests = []execTest{\n \t{\"bug6b\", \"{{vfunc .V0 .V0}}\", \"vfunc\", tVal, true},\n \t{\"bug6c\", \"{{vfunc .V1 .V0}}\", \"vfunc\", tVal, true},\n \t{\"bug6d\", \"{{vfunc .V1 .V1}}\", \"vfunc\", tVal, true},\n+\t// Legal parse but illegal execution: non-function should have no arguments.\n+\t{\"bug7a\", \"{{3 2}}\", \"\", tVal, false},\n+\t{\"bug7b\", \"{{$x := 1}}{{$x 2}}\", \"\", tVal, false},\n+\t{\"bug7c\", \"{{$x := 1}}{{3 | $x}}\", \"\", tVal, false},\n }\n \n func zeroArgs() string {"}, {"sha": "bd98bd047ec46b8cff57ea9f5f7634e4003cf215", "filename": "libgo/go/text/template/multi_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -93,7 +93,7 @@ var multiExecTests = []execTest{\n \t{\"invoke dot []int\", `{{template \"dot\" .SI}}`, \"[3 4 5]\", tVal, true},\n \t{\"invoke dotV\", `{{template \"dotV\" .U}}`, \"v\", tVal, true},\n \t{\"invoke nested int\", `{{template \"nested\" .I}}`, \"17\", tVal, true},\n-\t{\"variable declared by template\", `{{template \"nested\" $x=.SI}},{{index $x 1}}`, \"[3 4 5],4\", tVal, true},\n+\t{\"variable declared by template\", `{{template \"nested\" $x:=.SI}},{{index $x 1}}`, \"[3 4 5],4\", tVal, true},\n \n \t// User-defined function: test argument evaluator.\n \t{\"testFunc literal\", `{{oneArg \"joe\"}}`, \"oneArg=joe\", tVal, true},"}, {"sha": "7705c0b88ff8c0051620b5efd4af69ee7bbcc2f0", "filename": "libgo/go/text/template/parse/lex.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -347,6 +347,9 @@ Loop:\n \t\tdefault:\n \t\t\tl.backup()\n \t\t\tword := l.input[l.start:l.pos]\n+\t\t\tif !l.atTerminator() {\n+\t\t\t\treturn l.errorf(\"unexpected character %+U\", r)\n+\t\t\t}\n \t\t\tswitch {\n \t\t\tcase key[word] > itemKeyword:\n \t\t\t\tl.emit(key[word])\n@@ -365,6 +368,28 @@ Loop:\n \treturn lexInsideAction\n }\n \n+// atTerminator reports whether the input is at valid termination character to\n+// appear after an identifier. Mostly to catch cases like \"$x+2\" not being\n+// acceptable without a space, in case we decide one day to implement\n+// arithmetic.\n+func (l *lexer) atTerminator() bool {\n+\tr := l.peek()\n+\tif isSpace(r) {\n+\t\treturn true\n+\t}\n+\tswitch r {\n+\tcase eof, ',', '|', ':':\n+\t\treturn true\n+\t}\n+\t// Does r start the delimiter? This can be ambiguous (with delim==\"//\", $x/2 will\n+\t// succeed but should fail) but only in extremely rare cases caused by willfully\n+\t// bad choice of delimiter.\n+\tif rd, _ := utf8.DecodeRuneInString(l.rightDelim); rd == r {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // lexChar scans a character constant. The initial quote is already\n // scanned.  Syntax checking is done by the parse.\n func lexChar(l *lexer) stateFn {"}, {"sha": "c0087b2785b4ad5a4b7bff4b58b1fd3f0e20d11a", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -326,7 +326,7 @@ func (t *Tree) pipeline(context string) (pipe *PipeNode) {\n \tfor {\n \t\tif v := t.peek(); v.typ == itemVariable {\n \t\t\tt.next()\n-\t\t\tif next := t.peek(); next.typ == itemColonEquals || next.typ == itemChar {\n+\t\t\tif next := t.peek(); next.typ == itemColonEquals || (next.typ == itemChar && next.val == \",\") {\n \t\t\t\tt.next()\n \t\t\t\tvariable := newVariable(v.val)\n \t\t\t\tif len(variable.Ident) != 1 {"}, {"sha": "b2e788238d3acb200c3416e8c4fe21ce35b86385", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -201,6 +201,10 @@ var parseTests = []parseTest{\n \t\t`{{range .X | .M}}\"true\"{{else}}\"false\"{{end}}`},\n \t{\"range []int\", \"{{range .SI}}{{.}}{{end}}\", noError,\n \t\t`{{range .SI}}{{.}}{{end}}`},\n+\t{\"range 1 var\", \"{{range $x := .SI}}{{.}}{{end}}\", noError,\n+\t\t`{{range $x := .SI}}{{.}}{{end}}`},\n+\t{\"range 2 vars\", \"{{range $x, $y := .SI}}{{.}}{{end}}\", noError,\n+\t\t`{{range $x, $y := .SI}}{{.}}{{end}}`},\n \t{\"constants\", \"{{range .SI 1 -3.2i true false 'a'}}{{end}}\", noError,\n \t\t`{{range .SI 1 -3.2i true false 'a'}}{{end}}`},\n \t{\"template\", \"{{template `x`}}\", noError,\n@@ -226,6 +230,17 @@ var parseTests = []parseTest{\n \t{\"invalid punctuation\", \"{{printf 3, 4}}\", hasError, \"\"},\n \t{\"multidecl outside range\", \"{{with $v, $u := 3}}{{end}}\", hasError, \"\"},\n \t{\"too many decls in range\", \"{{range $u, $v, $w := 3}}{{end}}\", hasError, \"\"},\n+\t// Equals (and other chars) do not assignments make (yet).\n+\t{\"bug0a\", \"{{$x := 0}}{{$x}}\", noError, \"{{$x := 0}}{{$x}}\"},\n+\t{\"bug0b\", \"{{$x = 1}}{{$x}}\", hasError, \"\"},\n+\t{\"bug0c\", \"{{$x ! 2}}{{$x}}\", hasError, \"\"},\n+\t{\"bug0d\", \"{{$x % 3}}{{$x}}\", hasError, \"\"},\n+\t// Check the parse fails for := rather than comma.\n+\t{\"bug0e\", \"{{range $x := $y := 3}}{{end}}\", hasError, \"\"},\n+\t// Another bug: variable read must ignore following punctuation.\n+\t{\"bug1a\", \"{{$x:=.}}{{$x!2}}\", hasError, \"\"},                     // ! is just illegal here.\n+\t{\"bug1b\", \"{{$x:=.}}{{$x+2}}\", hasError, \"\"},                     // $x+2 should not parse as ($x) (+2).\n+\t{\"bug1c\", \"{{$x:=.}}{{$x +2}}\", noError, \"{{$x := .}}{{$x +2}}\"}, // It's OK with a space.\n }\n \n var builtins = map[string]interface{}{"}, {"sha": "9e2ca01cc96dab92d7ad9e6e535e339ee3673021", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -163,7 +163,7 @@ done\n   done\n done\n \n-runtime=\"chan.c cpuprof.c goc2c.c lock_futex.c lock_sema.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c msize.c proc.c runtime.c runtime.h signal_unix.c malloc.h malloc.goc mprof.goc runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n+runtime=\"chan.c cpuprof.c lock_futex.c lock_sema.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c msize.c proc.c runtime.c runtime.h signal_unix.c malloc.h malloc.goc mprof.goc runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n for f in $runtime; do\n   merge_c $f $f\n done"}, {"sha": "dbcfa0fed6d3ae31ab12feb67f867102586a3f4c", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -966,6 +966,11 @@ runtime_mstart(void* mp)\n \t}\n #endif\n \n+\t// Install signal handlers; after minit so that minit can\n+\t// prepare the thread to be able to handle the signals.\n+\tif(m == &runtime_m0)\n+\t\truntime_initsig();\n+\n \tschedule(nil);\n \treturn nil;\n }"}, {"sha": "a0dbf80b0a0b5cb22500814da502d3680f65e947", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a18821cfc7169ea9f4d0bb661e7c4ea362e993d/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=9a18821cfc7169ea9f4d0bb661e7c4ea362e993d", "patch": "@@ -74,7 +74,7 @@ void\n runtime_panicstring(const char *s)\n {\n \tEface err;\n-\t\n+\n \tif(runtime_m()->gcing) {\n \t\truntime_printf(\"panic: %s\\n\", s);\n \t\truntime_throw(\"panic during gc\");\n@@ -101,7 +101,7 @@ runtime_goargs(void)\n {\n \tString *s;\n \tint32 i;\n-\t\n+\n \t// for windows implementation see \"os\" package\n \tif(Windows)\n \t\treturn;\n@@ -119,7 +119,7 @@ runtime_goenvs_unix(void)\n {\n \tString *s;\n \tint32 i, n;\n-\t\n+\n \tfor(n=0; argv[argc+1+n] != 0; n++)\n \t\t;\n \n@@ -195,8 +195,6 @@ void\n runtime_check(void)\n {\n \t__go_register_gc_roots(&runtime_roots);\n-\n-\truntime_initsig ();\n }\n \n int64"}]}