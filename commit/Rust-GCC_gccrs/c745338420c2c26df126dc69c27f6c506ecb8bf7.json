{"sha": "c745338420c2c26df126dc69c27f6c506ecb8bf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0NTMzODQyMGMyYzI2ZGYxMjZkYzY5YzI3ZjZjNTA2ZWNiOGJmNw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2003-07-22T17:38:14Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-07-22T17:38:14Z"}, "message": "s390.c (s390_valid_pointer_mode): New.\n\n2003-07-22  Eric Christopher <echristo@redhat.com>\n\n\t* config/s390.c (s390_valid_pointer_mode): New.\n\t(TARGET_VALID_POINTER_MODE): Use.\n\t(s390_emit_prologue): Add tpf profiling hooks.\n\t(s390_emit_epilogue): Ditto.\n\t* config/s390.h (MASK_TPF): New.\n\t(TARGET_TPF): Use.\n\t(POINTERS_EXTEND_UNSIGNED): Define.\n\t* config/s390.md (ptr_extend): New pattern.\n\nFrom-SVN: r69674", "tree": {"sha": "9ddd3d2105ba7866f0fb764024276fb4464c7b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ddd3d2105ba7866f0fb764024276fb4464c7b0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c745338420c2c26df126dc69c27f6c506ecb8bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c745338420c2c26df126dc69c27f6c506ecb8bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c745338420c2c26df126dc69c27f6c506ecb8bf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c745338420c2c26df126dc69c27f6c506ecb8bf7/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "817aed6fc35ad24f7a04f6a9ac6616d4a6915ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817aed6fc35ad24f7a04f6a9ac6616d4a6915ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/817aed6fc35ad24f7a04f6a9ac6616d4a6915ff4"}], "stats": {"total": 1050, "additions": 574, "deletions": 476}, "files": [{"sha": "c586ec2bf8ab6053e0cb19ad9d50a157b4e8a933", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c745338420c2c26df126dc69c27f6c506ecb8bf7", "patch": "@@ -1,3 +1,14 @@\n+2003-07-22  Eric Christopher <echristo@redhat.com>\n+\n+\t* config/s390.c (s390_valid_pointer_mode): New.\n+\t(TARGET_VALID_POINTER_MODE): Use.\n+\t(s390_emit_prologue): Add tpf profiling hooks.\n+\t(s390_emit_epilogue): Ditto.\n+\t* config/s390.h (MASK_TPF): New.\n+\t(TARGET_TPF): Use.\n+\t(POINTERS_EXTEND_UNSIGNED): Define.\n+\t* config/s390.md (ptr_extend): New pattern.\n+\n 2003-07-22  Zack Weinberg  <zack@codesourcery.com>\n \n \t* hashtable.c (approx_sqrt): Make static."}, {"sha": "9d47de16ec2179785b2aea65beecc29c245ba3ad", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 354, "deletions": 295, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c745338420c2c26df126dc69c27f6c506ecb8bf7", "patch": "@@ -55,13 +55,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n \n static bool s390_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static void s390_select_rtx_section PARAMS ((enum machine_mode, rtx, \n+static void s390_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static void s390_encode_section_info PARAMS ((tree, rtx, int));\n static bool s390_cannot_force_const_mem PARAMS ((rtx));\n static rtx s390_delegitimize_address PARAMS ((rtx));\n static void s390_init_builtins PARAMS ((void));\n-static rtx s390_expand_builtin PARAMS ((tree, rtx, rtx, \n+static rtx s390_expand_builtin PARAMS ((tree, rtx, rtx,\n \t\t\t\t\tenum machine_mode, int));\n static void s390_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t  HOST_WIDE_INT, tree));\n@@ -76,7 +76,7 @@ static int s390_sched_reorder2 PARAMS ((FILE *, int, rtx *, int *, int));\n static bool s390_rtx_costs PARAMS ((rtx, int, int, int *));\n static int s390_address_cost PARAMS ((rtx));\n static void s390_reorg PARAMS ((void));\n-\n+static bool s390_valid_pointer_mode PARAMS ((enum machine_mode));\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n@@ -138,6 +138,9 @@ static void s390_reorg PARAMS ((void));\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG s390_reorg\n \n+#undef TARGET_VALID_POINTER_MODE\n+#define TARGET_VALID_POINTER_MODE s390_valid_pointer_mode\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n extern int reload_completed;\n@@ -233,11 +236,11 @@ static struct machine_function * s390_init_machine_status PARAMS ((void));\n #define DISP_IN_RANGE(d) \\\n   (TARGET_LONG_DISPLACEMENT? ((d) >= -524288 && (d) <= 524287) \\\n                            : ((d) >= 0 && (d) <= 4095))\n- \n+\n /* Return true if SET either doesn't set the CC register, or else\n-   the source and destination have matching CC modes and that \n+   the source and destination have matching CC modes and that\n    CC mode is at least as constrained as REQ_MODE.  */\n- \n+\n static int\n s390_match_ccmode_set (set, req_mode)\n      rtx set;\n@@ -279,19 +282,19 @@ s390_match_ccmode_set (set, req_mode)\n       if (req_mode != CCAmode)\n         return 0;\n       break;\n- \n+\n     default:\n       abort ();\n     }\n- \n+\n   return (GET_MODE (SET_SRC (set)) == set_mode);\n }\n \n-/* Return true if every SET in INSN that sets the CC register \n-   has source and destination with matching CC modes and that \n-   CC mode is at least as constrained as REQ_MODE.  \n+/* Return true if every SET in INSN that sets the CC register\n+   has source and destination with matching CC modes and that\n+   CC mode is at least as constrained as REQ_MODE.\n    If REQ_MODE is VOIDmode, always return false.  */\n- \n+\n int\n s390_match_ccmode (insn, req_mode)\n      rtx insn;\n@@ -318,9 +321,9 @@ s390_match_ccmode (insn, req_mode)\n   return 1;\n }\n \n-/* If a test-under-mask instruction can be used to implement \n+/* If a test-under-mask instruction can be used to implement\n    (compare (and ... OP1) OP2), return the CC mode required\n-   to do that.  Otherwise, return VOIDmode.  \n+   to do that.  Otherwise, return VOIDmode.\n    MIXED is true if the instruction can distinguish between\n    CC1 and CC2 for mixed selected bits (TMxx), it is false\n    if the instruction cannot (TM).  */\n@@ -357,12 +360,12 @@ s390_tm_ccmode (op1, op2, mixed)\n   return VOIDmode;\n }\n \n-/* Given a comparison code OP (EQ, NE, etc.) and the operands \n-   OP0 and OP1 of a COMPARE, return the mode to be used for the \n+/* Given a comparison code OP (EQ, NE, etc.) and the operands\n+   OP0 and OP1 of a COMPARE, return the mode to be used for the\n    comparison.  */\n \n enum machine_mode\n-s390_select_ccmode (code, op0, op1) \n+s390_select_ccmode (code, op0, op1)\n      enum rtx_code code;\n      rtx op0;\n      rtx op1;\n@@ -372,7 +375,7 @@ s390_select_ccmode (code, op0, op1)\n       case EQ:\n       case NE:\n \tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t    && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K')) \n+\t    && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K'))\n \t  return CCAPmode;\n \tif (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n \t    || GET_CODE (op1) == NEG)\n@@ -391,11 +394,11 @@ s390_select_ccmode (code, op0, op1)\n \t      }\n \t  }\n \n-\tif (register_operand (op0, HImode) \n+\tif (register_operand (op0, HImode)\n \t    && GET_CODE (op1) == CONST_INT\n \t    && (INTVAL (op1) == -1 || INTVAL (op1) == 65535))\n \t  return CCT3mode;\n-\tif (register_operand (op0, QImode) \n+\tif (register_operand (op0, QImode)\n \t    && GET_CODE (op1) == CONST_INT\n \t    && (INTVAL (op1) == -1 || INTVAL (op1) == 255))\n \t  return CCT3mode;\n@@ -407,7 +410,7 @@ s390_select_ccmode (code, op0, op1)\n       case GE:\n       case GT:\n \t  if (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K')) \n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op0, 1)), 'K'))\n             {\n \t      if (INTVAL (XEXP((op0), 1)) < 0)\n \t        return CCANmode;\n@@ -452,13 +455,13 @@ s390_select_ccmode (code, op0, op1)\n     }\n }\n \n-/* Return branch condition mask to implement a branch \n+/* Return branch condition mask to implement a branch\n    specified by CODE.  */\n \n static int\n s390_branch_condition_mask (code)\n     rtx code;\n-{ \n+{\n   const int CC0 = 1 << 3;\n   const int CC1 = 1 << 2;\n   const int CC2 = 1 << 1;\n@@ -646,8 +649,8 @@ s390_branch_condition_mask (code)\n     }\n }\n \n-/* If INV is false, return assembler mnemonic string to implement \n-   a branch specified by CODE.  If INV is true, return mnemonic \n+/* If INV is false, return assembler mnemonic string to implement\n+   a branch specified by CODE.  If INV is true, return mnemonic\n    for the corresponding inverted branch.  */\n \n static const char *\n@@ -675,7 +678,7 @@ s390_branch_condition_mnemonic (code, inv)\n }\n \n /* If OP is an integer constant of mode MODE with exactly one\n-   HImode subpart unequal to DEF, return the number of that \n+   HImode subpart unequal to DEF, return the number of that\n    subpart.  As a special case, all HImode subparts of OP are\n    equal to DEF, return zero.  Otherwise, return -1.  */\n \n@@ -738,10 +741,10 @@ s390_single_hi (op, mode, def)\n       return part == -1 ? 0 : (n_parts - 1 - part);\n     }\n \n-  return -1;      \n+  return -1;\n }\n \n-/* Extract the HImode part number PART from integer \n+/* Extract the HImode part number PART from integer\n    constant OP of mode MODE.  */\n \n int\n@@ -771,14 +774,14 @@ s390_extract_hi (op, mode, part)\n         value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op),\n         part -= HOST_BITS_PER_WIDE_INT / 16;\n \n-      return ((value >> (16 * part)) & 0xffff); \n+      return ((value >> (16 * part)) & 0xffff);\n     }\n \n   abort ();\n }\n \n /* If OP is an integer constant of mode MODE with exactly one\n-   QImode subpart unequal to DEF, return the number of that \n+   QImode subpart unequal to DEF, return the number of that\n    subpart.  As a special case, all QImode subparts of OP are\n    equal to DEF, return zero.  Otherwise, return -1.  */\n \n@@ -841,10 +844,10 @@ s390_single_qi (op, mode, def)\n       return part == -1 ? 0 : (n_parts - 1 - part);\n     }\n \n-  return -1;      \n+  return -1;\n }\n \n-/* Extract the QImode part number PART from integer \n+/* Extract the QImode part number PART from integer\n    constant OP of mode MODE.  */\n \n int\n@@ -874,14 +877,14 @@ s390_extract_qi (op, mode, part)\n         value = (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (op),\n         part -= HOST_BITS_PER_WIDE_INT / 8;\n \n-      return ((value >> (8 * part)) & 0xff); \n+      return ((value >> (8 * part)) & 0xff);\n     }\n \n   abort ();\n }\n \n-/* Check whether we can (and want to) split a double-word \n-   move in mode MODE from SRC to DST into two single-word \n+/* Check whether we can (and want to) split a double-word\n+   move in mode MODE from SRC to DST into two single-word\n    moves, moving the subword FIRST_SUBWORD first.  */\n \n bool\n@@ -917,7 +920,7 @@ s390_split_ok_p (dst, src, mode, first_subword)\n }\n \n \n-/* Change optimizations to be performed, depending on the \n+/* Change optimizations to be performed, depending on the\n    optimization level.\n \n    LEVEL is the optimization level specified; 2 if `-O2' is\n@@ -953,7 +956,7 @@ override_options ()\n       {\"g5\", PROCESSOR_9672_G5, PF_IEEE_FLOAT},\n       {\"g6\", PROCESSOR_9672_G6, PF_IEEE_FLOAT},\n       {\"z900\", PROCESSOR_2064_Z900, PF_IEEE_FLOAT | PF_ZARCH},\n-      {\"z990\", PROCESSOR_2084_Z990, PF_IEEE_FLOAT | PF_ZARCH \n+      {\"z990\", PROCESSOR_2084_Z990, PF_IEEE_FLOAT | PF_ZARCH\n \t\t\t\t    | PF_LONG_DISPLACEMENT},\n     };\n \n@@ -1026,7 +1029,7 @@ const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n-  ADDR_REGS,    NO_REGS,   ADDR_REGS \n+  ADDR_REGS,    NO_REGS,   ADDR_REGS\n };\n \n /* Return attribute type of insn.  */\n@@ -1044,7 +1047,7 @@ s390_safe_attr_type (insn)\n /* Return true if OP a (const_int 0) operand.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n- \n+\n int\n const0_operand (op, mode)\n      register rtx op;\n@@ -1066,7 +1069,7 @@ consttable_operand (op, mode)\n }\n \n /* Return true if the mode of operand OP matches MODE.\n-   If MODE is set to VOIDmode, set it to the mode of OP.  */ \n+   If MODE is set to VOIDmode, set it to the mode of OP.  */\n \n static int\n check_mode (op, mode)\n@@ -1118,7 +1121,7 @@ larl_operand (op, mode)\n       if (INTVAL (XEXP (op, 1)) >= (HOST_WIDE_INT)1 << 32\n \t  || INTVAL (XEXP (op, 1)) < -((HOST_WIDE_INT)1 << 32))\n         return 0;\n-#endif\t\n+#endif\n       op = XEXP (op, 0);\n     }\n \n@@ -1166,8 +1169,8 @@ general_s_operand (op, mode, allow_immediate)\n \n   /* Just like memory_operand, allow (subreg (mem ...))\n      after reload.  */\n-  if (reload_completed \n-      && GET_CODE (op) == SUBREG \n+  if (reload_completed\n+      && GET_CODE (op) == SUBREG\n       && GET_CODE (SUBREG_REG (op)) == MEM)\n     op = SUBREG_REG (op);\n \n@@ -1176,7 +1179,7 @@ general_s_operand (op, mode, allow_immediate)\n       /* Constants that we are sure will be forced to the\n          literal pool in reload are OK as s-operand.  Note\n \t that we cannot call s390_preferred_reload_class here\n-\t because it might not be known yet at this point \n+\t because it might not be known yet at this point\n \t whether the current function is a leaf or not.  */\n       case CONST_INT:\n       case CONST_DOUBLE:\n@@ -1193,7 +1196,7 @@ general_s_operand (op, mode, allow_immediate)\n       case MEM:\n \tif (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n \t  return 1;\n-\tif (s390_decompose_address (XEXP (op, 0), &addr) \n+\tif (s390_decompose_address (XEXP (op, 0), &addr)\n \t    && !addr.indx)\n \t  return 1;\n \tbreak;\n@@ -1217,8 +1220,8 @@ s_operand (op, mode)\n   return general_s_operand (op, mode, 0);\n }\n \n-/* Return true if OP is a valid S-type operand or an immediate \n-   operand that can be addressed as S-type operand by forcing \n+/* Return true if OP is a valid S-type operand or an immediate\n+   operand that can be addressed as S-type operand by forcing\n    it into the literal pool.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n@@ -1472,7 +1475,7 @@ tls_symbolic_operand (op)\n }\n \f\n /* Return true if OP is a load multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested. \n+   PARALLEL and the first section will be tested.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n@@ -1502,7 +1505,7 @@ load_multiple_operation (op, mode)\n   if (GET_CODE (src_addr) == REG)\n     off = 0;\n   else if (GET_CODE (src_addr) == PLUS\n-\t   && GET_CODE (XEXP (src_addr, 0)) == REG \n+\t   && GET_CODE (XEXP (src_addr, 0)) == REG\n \t   && GET_CODE (XEXP (src_addr, 1)) == CONST_INT)\n     {\n       off = INTVAL (XEXP (src_addr, 1));\n@@ -1536,7 +1539,7 @@ load_multiple_operation (op, mode)\n }\n \n /* Return true if OP is a store multiple operation.  It is known to be a\n-   PARALLEL and the first section will be tested. \n+   PARALLEL and the first section will be tested.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n@@ -1565,7 +1568,7 @@ store_multiple_operation (op, mode)\n   if (GET_CODE (dest_addr) == REG)\n     off = 0;\n   else if (GET_CODE (dest_addr) == PLUS\n-\t   && GET_CODE (XEXP (dest_addr, 0)) == REG \n+\t   && GET_CODE (XEXP (dest_addr, 0)) == REG\n \t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)\n     {\n       off = INTVAL (XEXP (dest_addr, 1));\n@@ -1661,8 +1664,8 @@ tls_symbolic_reference_mentioned_p (op)\n }\n \n \n-/* Return true if OP is a legitimate general operand when \n-   generating PIC code.  It is given that flag_pic is on \n+/* Return true if OP is a legitimate general operand when\n+   generating PIC code.  It is given that flag_pic is on\n    and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n int\n@@ -1673,7 +1676,7 @@ legitimate_pic_operand_p (op)\n   if (!SYMBOLIC_CONST (op))\n     return 1;\n \n-  /* Reject everything else; must be handled \n+  /* Reject everything else; must be handled\n      via emit_symbolic_move.  */\n   return 0;\n }\n@@ -1771,7 +1774,7 @@ s390_cannot_force_const_mem (x)\n }\n \n /* Returns true if the constant value OP is a legitimate general\n-   operand during and after reload.  The difference to \n+   operand during and after reload.  The difference to\n    legitimate_constant_p is that this function will not accept\n    a constant that would need to be forced to the literal pool\n    before it can be used as operand.  */\n@@ -1781,7 +1784,7 @@ legitimate_reload_constant_p (op)\n      register rtx op;\n {\n   /* Accept la(y) operands.  */\n-  if (GET_CODE (op) == CONST_INT \n+  if (GET_CODE (op) == CONST_INT\n       && DISP_IN_RANGE (INTVAL (op)))\n     return 1;\n \n@@ -1871,7 +1874,7 @@ s390_secondary_input_reload_class (class, mode, in)\n /* Return the register class of a scratch register needed to\n    store a register of class CLASS in MODE into OUT:\n \n-   We need a temporary when storing a double-word to a \n+   We need a temporary when storing a double-word to a\n    non-offsettable memory address.  */\n \n enum reg_class\n@@ -1892,7 +1895,7 @@ s390_secondary_output_reload_class (class, mode, out)\n }\n \n /* Return true if OP is a PLUS that is not a legitimate\n-   operand for the LA instruction. \n+   operand for the LA instruction.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n \n@@ -2147,7 +2150,7 @@ s390_decompose_address (addr, out)\n         {\n \t  pointer = TRUE;\n         }\n- \n+\n       /* Likewise if a constant offset is present.  */\n       else if (GET_CODE (disp) == CONST\n                && GET_CODE (XEXP (disp, 0)) == PLUS\n@@ -2159,7 +2162,7 @@ s390_decompose_address (addr, out)\n \t  pointer = TRUE;\n         }\n \n-      /* We can convert literal pool addresses to \n+      /* We can convert literal pool addresses to\n          displacements by basing them off the base register.  */\n       else\n         {\n@@ -2186,7 +2189,7 @@ s390_decompose_address (addr, out)\n           if (offset && offset >= GET_MODE_SIZE (get_pool_mode (disp)))\n             return FALSE;\n \n-          /* Either base or index must be free to \n+          /* Either base or index must be free to\n              hold the base register.  */\n           if (base && indx)\n             return FALSE;\n@@ -2197,7 +2200,7 @@ s390_decompose_address (addr, out)\n           else\n             base = gen_rtx_REG (Pmode, BASE_REGISTER);\n \n-          disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp), \n+          disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp),\n \t\t\t\t UNSPEC_LTREL_OFFSET);\n           disp = gen_rtx_CONST (Pmode, disp);\n \n@@ -2210,7 +2213,7 @@ s390_decompose_address (addr, out)\n \n   if (!base && !indx)\n     pointer = TRUE;\n-   \n+\n   if (out)\n     {\n       out->base = base;\n@@ -2273,7 +2276,7 @@ legitimate_la_operand_p (op)\n \n /* Return 1 if OP is a valid operand for the LA instruction,\n    and we prefer to use LA over addition to compute it.  */\n-   \n+\n int\n preferred_la_operand_p (op)\n      register rtx op;\n@@ -2343,8 +2346,8 @@ legitimize_pic_address (orig, reg)\n       /* This is a local symbol.  */\n       if (TARGET_64BIT && larl_operand (addr, VOIDmode))\n         {\n-          /* Access local symbols PC-relative via LARL.  \n-             This is the same as in the non-PIC case, so it is \n+          /* Access local symbols PC-relative via LARL.\n+             This is the same as in the non-PIC case, so it is\n              handled automatically ...  */\n         }\n       else\n@@ -2408,7 +2411,7 @@ legitimize_pic_address (orig, reg)\n         }\n       else\n         {\n-          /* If the GOT offset might be >= 4k, we have to load it \n+          /* If the GOT offset might be >= 4k, we have to load it\n              from the literal pool (@GOT).  */\n \n           rtx temp = gen_reg_rtx (Pmode);\n@@ -2427,7 +2430,7 @@ legitimize_pic_address (orig, reg)\n           emit_move_insn (reg, new);\n           new = reg;\n         }\n-    }      \n+    }\n   else\n     {\n       if (GET_CODE (addr) == CONST)\n@@ -2467,7 +2470,7 @@ legitimize_pic_address (orig, reg)\n \t\t\t  regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n                         addr = XVECEXP (addr, 0, 0);\n-                        addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), \n+                        addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n \t\t\t\t\t       UNSPEC_PLTOFF);\n                         addr = gen_rtx_CONST (Pmode, addr);\n                         addr = force_const_mem (Pmode, addr);\n@@ -2493,7 +2496,7 @@ legitimize_pic_address (orig, reg)\n       if (GET_CODE (addr) == PLUS)\n \t{\n \t  rtx op0 = XEXP (addr, 0), op1 = XEXP (addr, 1);\n-\t  /* Check first to see if this is a constant offset \n+\t  /* Check first to see if this is a constant offset\n              from a local symbol reference.  */\n \t  if ((GET_CODE (op0) == LABEL_REF\n \t\t|| (GET_CODE (op0) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op0)))\n@@ -2503,7 +2506,7 @@ legitimize_pic_address (orig, reg)\n                 {\n                   if (INTVAL (op1) & 1)\n                     {\n-                      /* LARL can't handle odd offsets, so emit a \n+                      /* LARL can't handle odd offsets, so emit a\n                          pair of LARL and LA.  */\n                       rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n@@ -2539,7 +2542,7 @@ legitimize_pic_address (orig, reg)\n \t\t  if (reload_in_progress || reload_completed)\n \t\t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n-                  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), \n+                  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0),\n \t\t\t\t\t UNSPEC_GOTOFF);\n                   addr = gen_rtx_PLUS (Pmode, addr, op1);\n                   addr = gen_rtx_CONST (Pmode, addr);\n@@ -2725,7 +2728,7 @@ legitimize_tls_address (addr, reg)\n \t  }\n \telse if (flag_pic)\n \t  {\n-\t    /* If the GOT offset might be >= 4k, we have to load it \n+\t    /* If the GOT offset might be >= 4k, we have to load it\n \t       from the literal pool.  */\n \n \t    if (reload_in_progress || reload_completed)\n@@ -2859,8 +2862,8 @@ legitimize_address (x, oldx, mode)\n   else if (flag_pic)\n     {\n       if (SYMBOLIC_CONST (x)\n-          || (GET_CODE (x) == PLUS \n-              && (SYMBOLIC_CONST (XEXP (x, 0)) \n+          || (GET_CODE (x) == PLUS\n+              && (SYMBOLIC_CONST (XEXP (x, 0))\n                   || SYMBOLIC_CONST (XEXP (x, 1)))))\n \t  x = legitimize_pic_address (x, 0);\n \n@@ -2872,7 +2875,7 @@ legitimize_address (x, oldx, mode)\n \n   /* Optimize loading of large displacements by splitting them\n      into the multiple of 4K and the rest; this allows the\n-     former to be CSE'd if possible. \n+     former to be CSE'd if possible.\n \n      Don't do this if the displacement is added to a register\n      pointing into the stack frame, as the offsets will\n@@ -2932,9 +2935,9 @@ s390_expand_movstr (dst, src, len)\n      rtx src;\n      rtx len;\n {\n-  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) = \n+  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) =\n     TARGET_64BIT ? gen_movstr_short_64 : gen_movstr_short_31;\n-  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) = \n+  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) =\n     TARGET_64BIT ? gen_movstr_long_64 : gen_movstr_long_31;\n \n \n@@ -2951,9 +2954,9 @@ s390_expand_movstr (dst, src, len)\n       rtx reg0 = gen_reg_rtx (double_mode);\n       rtx reg1 = gen_reg_rtx (double_mode);\n \n-      emit_move_insn (gen_highpart (single_mode, reg0), \n+      emit_move_insn (gen_highpart (single_mode, reg0),\n \t\t      force_operand (XEXP (dst, 0), NULL_RTX));\n-      emit_move_insn (gen_highpart (single_mode, reg1), \n+      emit_move_insn (gen_highpart (single_mode, reg1),\n \t\t      force_operand (XEXP (src, 0), NULL_RTX));\n \n       convert_move (gen_lowpart (single_mode, reg0), len, 1);\n@@ -2983,14 +2986,14 @@ s390_expand_movstr (dst, src, len)\n       blocks = gen_reg_rtx (mode);\n \n       convert_move (count, len, 1);\n-      emit_cmp_and_jump_insns (count, const0_rtx, \n+      emit_cmp_and_jump_insns (count, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n \n       emit_move_insn (dst_addr, force_operand (XEXP (dst, 0), NULL_RTX));\n       emit_move_insn (src_addr, force_operand (XEXP (src, 0), NULL_RTX));\n       dst = change_address (dst, VOIDmode, dst_addr);\n       src = change_address (src, VOIDmode, src_addr);\n-     \n+\n       temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n       if (temp != count)\n         emit_move_insn (count, temp);\n@@ -3005,11 +3008,11 @@ s390_expand_movstr (dst, src, len)\n \t\t\t\t\t   make_tree (type, const0_rtx)));\n \n       emit_insn ((*gen_short) (dst, src, GEN_INT (255)));\n-      s390_load_address (dst_addr, \n+      s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n-      s390_load_address (src_addr, \n+      s390_load_address (src_addr,\n \t\t\t gen_rtx_PLUS (Pmode, src_addr, GEN_INT (256)));\n-      \n+\n       temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n@@ -3028,9 +3031,9 @@ s390_expand_clrstr (dst, len)\n      rtx dst;\n      rtx len;\n {\n-  rtx (*gen_short) PARAMS ((rtx, rtx)) = \n+  rtx (*gen_short) PARAMS ((rtx, rtx)) =\n     TARGET_64BIT ? gen_clrstr_short_64 : gen_clrstr_short_31;\n-  rtx (*gen_long) PARAMS ((rtx, rtx, rtx)) = \n+  rtx (*gen_long) PARAMS ((rtx, rtx, rtx)) =\n     TARGET_64BIT ? gen_clrstr_long_64 : gen_clrstr_long_31;\n \n \n@@ -3047,7 +3050,7 @@ s390_expand_clrstr (dst, len)\n       rtx reg0 = gen_reg_rtx (double_mode);\n       rtx reg1 = gen_reg_rtx (double_mode);\n \n-      emit_move_insn (gen_highpart (single_mode, reg0), \n+      emit_move_insn (gen_highpart (single_mode, reg0),\n \t\t      force_operand (XEXP (dst, 0), NULL_RTX));\n       convert_move (gen_lowpart (single_mode, reg0), len, 1);\n \n@@ -3078,12 +3081,12 @@ s390_expand_clrstr (dst, len)\n       blocks = gen_reg_rtx (mode);\n \n       convert_move (count, len, 1);\n-      emit_cmp_and_jump_insns (count, const0_rtx, \n+      emit_cmp_and_jump_insns (count, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n \n       emit_move_insn (dst_addr, force_operand (XEXP (dst, 0), NULL_RTX));\n       dst = change_address (dst, VOIDmode, dst_addr);\n-     \n+\n       temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n       if (temp != count)\n         emit_move_insn (count, temp);\n@@ -3098,9 +3101,9 @@ s390_expand_clrstr (dst, len)\n \t\t\t\t\t   make_tree (type, const0_rtx)));\n \n       emit_insn ((*gen_short) (dst, GEN_INT (255)));\n-      s390_load_address (dst_addr, \n+      s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n-      \n+\n       temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n@@ -3122,9 +3125,9 @@ s390_expand_cmpmem (target, op0, op1, len)\n      rtx op1;\n      rtx len;\n {\n-  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) = \n+  rtx (*gen_short) PARAMS ((rtx, rtx, rtx)) =\n     TARGET_64BIT ? gen_cmpmem_short_64 : gen_cmpmem_short_31;\n-  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) = \n+  rtx (*gen_long) PARAMS ((rtx, rtx, rtx, rtx)) =\n     TARGET_64BIT ? gen_cmpmem_long_64 : gen_cmpmem_long_31;\n   rtx (*gen_result) PARAMS ((rtx)) =\n     GET_MODE (target) == DImode ? gen_cmpint_di : gen_cmpint_si;\n@@ -3151,9 +3154,9 @@ s390_expand_cmpmem (target, op0, op1, len)\n       rtx reg0 = gen_reg_rtx (double_mode);\n       rtx reg1 = gen_reg_rtx (double_mode);\n \n-      emit_move_insn (gen_highpart (single_mode, reg0), \n+      emit_move_insn (gen_highpart (single_mode, reg0),\n \t\t      force_operand (XEXP (op0, 0), NULL_RTX));\n-      emit_move_insn (gen_highpart (single_mode, reg1), \n+      emit_move_insn (gen_highpart (single_mode, reg1),\n \t\t      force_operand (XEXP (op1, 0), NULL_RTX));\n \n       convert_move (gen_lowpart (single_mode, reg0), len, 1);\n@@ -3187,14 +3190,14 @@ s390_expand_cmpmem (target, op0, op1, len)\n       blocks = gen_reg_rtx (mode);\n \n       convert_move (count, len, 1);\n-      emit_cmp_and_jump_insns (count, const0_rtx, \n+      emit_cmp_and_jump_insns (count, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n \n       emit_move_insn (addr0, force_operand (XEXP (op0, 0), NULL_RTX));\n       emit_move_insn (addr1, force_operand (XEXP (op1, 0), NULL_RTX));\n       op0 = change_address (op0, VOIDmode, addr0);\n       op1 = change_address (op1, VOIDmode, addr1);\n-     \n+\n       temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n       if (temp != count)\n         emit_move_insn (count, temp);\n@@ -3210,16 +3213,16 @@ s390_expand_cmpmem (target, op0, op1, len)\n \n       emit_insn ((*gen_short) (op0, op1, GEN_INT (255)));\n       temp = gen_rtx_NE (VOIDmode, gen_rtx_REG (CCSmode, 33), const0_rtx);\n-      temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp, \n+      temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp,\n \t\t\tgen_rtx_LABEL_REF (VOIDmode, end_label), pc_rtx);\n       temp = gen_rtx_SET (VOIDmode, pc_rtx, temp);\n       emit_jump_insn (temp);\n \n-      s390_load_address (addr0, \n+      s390_load_address (addr0,\n \t\t\t gen_rtx_PLUS (Pmode, addr0, GEN_INT (256)));\n-      s390_load_address (addr1, \n+      s390_load_address (addr1,\n \t\t\t gen_rtx_PLUS (Pmode, addr1, GEN_INT (256)));\n-      \n+\n       temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n@@ -3293,7 +3296,7 @@ s390_delegitimize_address (orig_x)\n       return orig_x;\n     }\n \n-  return orig_x;      \n+  return orig_x;\n }\n \n /* Locate some local-dynamic symbol still in use by this function\n@@ -3338,7 +3341,7 @@ get_some_local_dynamic_name_1 (px, data)\n   return 0;\n }\n \n-/* Output symbolic constant X in assembler syntax to \n+/* Output symbolic constant X in assembler syntax to\n    stdio stream FILE.  */\n \n void\n@@ -3380,7 +3383,7 @@ s390_output_symbolic_const (file, x)\n         {\n         case UNSPEC_LTREL_OFFSET:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"-\");\t\n+          fprintf (file, \"-\");\n \t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n  \t  break;\n \tcase UNSPEC_GOTENT:\n@@ -3439,7 +3442,7 @@ s390_output_symbolic_const (file, x)\n     }\n }\n \n-/* Output address operand ADDR in assembler syntax to \n+/* Output address operand ADDR in assembler syntax to\n    stdio stream FILE.  */\n \n void\n@@ -3453,7 +3456,7 @@ print_operand_address (file, addr)\n       || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n       || (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx)))\n     output_operand_lossage (\"Cannot decompose address.\");\n- \n+\n   if (ad.disp)\n     s390_output_symbolic_const (file, ad.disp);\n   else\n@@ -3466,8 +3469,8 @@ print_operand_address (file, addr)\n     fprintf (file, \"(%s)\", reg_names[REGNO (ad.base)]);\n }\n \n-/* Output operand X in assembler syntax to stdio stream FILE.  \n-   CODE specified the format flag.  The following format flags \n+/* Output operand X in assembler syntax to stdio stream FILE.\n+   CODE specified the format flag.  The following format flags\n    are recognized:\n \n     'C': print opcode suffix for branch condition.\n@@ -3638,7 +3641,7 @@ s390_assemble_integer (x, size, aligned_p)\n   return default_assemble_integer (x, size, aligned_p);\n }\n \n-/* Returns true if register REGNO is used  for forming \n+/* Returns true if register REGNO is used  for forming\n    a memory address in expression X.  */\n \n static int\n@@ -3649,14 +3652,14 @@ reg_used_in_mem_p (regno, x)\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n   const char *fmt;\n-  \n+\n   if (code == MEM)\n     {\n       if (refers_to_regno_p (regno, regno+1,\n \t\t\t     XEXP (x, 0), 0))\n \treturn 1;\n     }\n-  else if (code == SET \n+  else if (code == SET\n \t   && GET_CODE (SET_DEST (x)) == PC)\n     {\n       if (refers_to_regno_p (regno, regno+1,\n@@ -3670,7 +3673,7 @@ reg_used_in_mem_p (regno, x)\n       if (fmt[i] == 'e'\n \t  && reg_used_in_mem_p (regno, XEXP (x, i)))\n \treturn 1;\n-      \n+\n       else if (fmt[i] == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n \t  if (reg_used_in_mem_p (regno, XVECEXP (x, i, j)))\n@@ -3682,9 +3685,9 @@ reg_used_in_mem_p (regno, x)\n /* Returns true if expression DEP_RTX sets an address register\n    used by instruction INSN to address memory.  */\n \n-static int \n+static int\n addr_generation_dependency_p (dep_rtx, insn)\n-     rtx dep_rtx; \n+     rtx dep_rtx;\n      rtx insn;\n {\n   rtx target, pat;\n@@ -3727,15 +3730,15 @@ addr_generation_dependency_p (dep_rtx, insn)\n \n /* Return 1, if dep_insn sets register used in insn in the agen unit.  */\n \n-int \n+int\n s390_agen_dep_p(dep_insn, insn)\n      rtx dep_insn;\n      rtx insn;\n-{ \n+{\n   rtx dep_rtx = PATTERN (dep_insn);\n   int i;\n-  \n-  if (GET_CODE (dep_rtx) == SET  \n+\n+  if (GET_CODE (dep_rtx) == SET\n       && addr_generation_dependency_p (dep_rtx, insn))\n     return 1;\n   else if (GET_CODE (dep_rtx) == PARALLEL)\n@@ -3750,13 +3753,13 @@ s390_agen_dep_p(dep_insn, insn)\n }\n \n /* Return the modified cost of the dependency of instruction INSN\n-   on instruction DEP_INSN through the link LINK.  COST is the \n+   on instruction DEP_INSN through the link LINK.  COST is the\n    default cost of that dependency.\n \n    Data dependencies are all handled without delay.  However, if a\n-   register is modified and subsequently used as base or index \n+   register is modified and subsequently used as base or index\n    register of a memory reference, at least 4 cycles need to pass\n-   between setting and using the register to avoid pipeline stalls.  \n+   between setting and using the register to avoid pipeline stalls.\n    An exception is the LA instruction. An address generated by LA can\n    be used by introducing only a one cycle stall on the pipeline.  */\n \n@@ -3784,7 +3787,7 @@ s390_adjust_cost (insn, link, dep_insn, cost)\n   /* DFA based scheduling checks address dependency in md file.  */\n   if (s390_use_dfa_pipeline_interface ())\n   {\n-    /* Operand forward in case of lr, load and la.  */ \n+    /* Operand forward in case of lr, load and la.  */\n     if (s390_tune == PROCESSOR_2084_Z990\n         && cost == 1\n \t&& (s390_safe_attr_type (dep_insn) == TYPE_LA\n@@ -3796,15 +3799,15 @@ s390_adjust_cost (insn, link, dep_insn, cost)\n \n   dep_rtx = PATTERN (dep_insn);\n \n-  if (GET_CODE (dep_rtx) == SET \n+  if (GET_CODE (dep_rtx) == SET\n       && addr_generation_dependency_p (dep_rtx, insn))\n-    cost += (s390_safe_attr_type (dep_insn) == TYPE_LA) ? 1 : 4;  \n+    cost += (s390_safe_attr_type (dep_insn) == TYPE_LA) ? 1 : 4;\n   else if (GET_CODE (dep_rtx) == PARALLEL)\n     {\n       for (i = 0; i < XVECLEN (dep_rtx, 0); i++)\n \t{\n \t  if (addr_generation_dependency_p (XVECEXP (dep_rtx, 0, i), insn))\n-\t    cost += (s390_safe_attr_type (dep_insn) == TYPE_LA) ? 1 : 4;  \n+\t    cost += (s390_safe_attr_type (dep_insn) == TYPE_LA) ? 1 : 4;\n \t}\n     }\n \n@@ -3813,9 +3816,9 @@ s390_adjust_cost (insn, link, dep_insn, cost)\n /* A C statement (sans semicolon) to update the integer scheduling priority\n    INSN_PRIORITY (INSN).  Increase the priority to execute the INSN earlier,\n    reduce the priority to execute INSN later.  Do not define this macro if\n-   you do not need to adjust the scheduling priorities of insns. \n+   you do not need to adjust the scheduling priorities of insns.\n \n-   A STD instruction should be scheduled earlier, \n+   A STD instruction should be scheduled earlier,\n    in order to use the bypass.  */\n \n static int\n@@ -3849,7 +3852,7 @@ s390_adjust_priority (insn, priority)\n static int\n s390_issue_rate ()\n {\n-  if (s390_tune == PROCESSOR_2084_Z990) \n+  if (s390_tune == PROCESSOR_2084_Z990)\n     return 3;\n   return 1;\n }\n@@ -3888,14 +3891,14 @@ s390_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n }\n \n \n-/* Split all branches that exceed the maximum distance.  \n-   Returns true if this created a new literal pool entry.  \n+/* Split all branches that exceed the maximum distance.\n+   Returns true if this created a new literal pool entry.\n \n    Code generated by this routine is allowed to use\n    TEMP_REG as temporary scratch register.  If this is\n    done, TEMP_USED is set to true.  */\n \n-static int \n+static int\n s390_split_branches (temp_reg, temp_used)\n      rtx temp_reg;\n      bool *temp_used;\n@@ -3921,15 +3924,15 @@ s390_split_branches (temp_reg, temp_used)\n       if (GET_CODE (pat) != SET || SET_DEST (pat) != pc_rtx)\n \tcontinue;\n \n-      if (GET_CODE (SET_SRC (pat)) == LABEL_REF) \n+      if (GET_CODE (SET_SRC (pat)) == LABEL_REF)\n \t{\n \t  label = &SET_SRC (pat);\n-\t} \n-      else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE) \n+\t}\n+      else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n \t{\n-\t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF) \n+\t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF)\n \t    label = &XEXP (SET_SRC (pat), 1);\n-          else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF) \n+          else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF)\n             label = &XEXP (SET_SRC (pat), 2);\n \t  else\n \t    continue;\n@@ -3961,14 +3964,14 @@ s390_split_branches (temp_reg, temp_used)\n       else\n \t{\n \t  new_literal = 1;\n-\t  target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, *label), \n+\t  target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, *label),\n \t\t\t\t   UNSPEC_LTREL_OFFSET);\n \t  target = gen_rtx_CONST (Pmode, target);\n \t  target = force_const_mem (Pmode, target);\n \t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, target), insn);\n \t  INSN_ADDRESSES_NEW (tmp, -1);\n \n-          target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (target, 0)), \n+          target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (target, 0)),\n \t\t\t\t   UNSPEC_LTREL_BASE);\n \t  target = gen_rtx_PLUS (Pmode, temp_reg, target);\n \t}\n@@ -3981,12 +3984,12 @@ s390_split_branches (temp_reg, temp_used)\n }\n \n \n-/* Find a literal pool symbol referenced in RTX X, and store \n-   it at REF.  Will abort if X contains references to more than \n+/* Find a literal pool symbol referenced in RTX X, and store\n+   it at REF.  Will abort if X contains references to more than\n    one such pool symbol; multiple references to the same symbol\n-   are allowed, however. \n+   are allowed, however.\n \n-   The rtx pointed to by REF must be initialized to NULL_RTX \n+   The rtx pointed to by REF must be initialized to NULL_RTX\n    by the caller before calling this routine.  */\n \n static void\n@@ -4100,7 +4103,7 @@ replace_constant_pool_ref (x, ref, addr)\n     }\n }\n \n-/* Check whether X contains an UNSPEC_LTREL_BASE.  \n+/* Check whether X contains an UNSPEC_LTREL_BASE.\n    Return its constant pool symbol if found, NULL_RTX otherwise.  */\n \n static rtx\n@@ -4174,7 +4177,7 @@ replace_ltrel_base (x, base)\n    constant tables in the middle of large functions.  */\n \n #define NR_C_MODES 7\n-enum machine_mode constant_modes[NR_C_MODES] = \n+enum machine_mode constant_modes[NR_C_MODES] =\n {\n   TImode,\n   DFmode, DImode,\n@@ -4331,7 +4334,7 @@ s390_add_constant (pool, val, mode)\n /* Find constant VAL of mode MODE in the constant pool POOL.\n    Return an RTX describing the distance from the start of\n    the pool to the location of the new constant.  */\n- \n+\n static rtx\n s390_find_constant (pool, val, mode)\n      struct constant_pool *pool;\n@@ -4341,20 +4344,20 @@ s390_find_constant (pool, val, mode)\n   struct constant *c;\n   rtx offset;\n   int i;\n- \n+\n   for (i = 0; i < NR_C_MODES; i++)\n     if (constant_modes[i] == mode)\n       break;\n   if (i == NR_C_MODES)\n     abort ();\n- \n+\n   for (c = pool->constants[i]; c != NULL; c = c->next)\n     if (rtx_equal_p (val, c->value))\n       break;\n- \n+\n   if (c == NULL)\n     abort ();\n- \n+\n   offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label),\n                                  gen_rtx_LABEL_REF (Pmode, pool->label));\n   offset = gen_rtx_CONST (Pmode, offset);\n@@ -4371,7 +4374,7 @@ s390_dump_pool (pool)\n   rtx insn;\n   int i;\n \n-  /* Pool start insn switches to proper section \n+  /* Pool start insn switches to proper section\n      and guarantees necessary alignment.  */\n   if (TARGET_64BIT)\n     insn = emit_insn_after (gen_pool_start_64 (), pool->pool_insn);\n@@ -4405,7 +4408,7 @@ s390_dump_pool (pool)\n \tINSN_ADDRESSES_NEW (insn, -1);\n       }\n \n-  /* Pool end insn switches back to previous section \n+  /* Pool end insn switches back to previous section\n      and guarantees necessary alignment.  */\n   if (TARGET_64BIT)\n     insn = emit_insn_after (gen_pool_end_64 (), insn);\n@@ -4443,15 +4446,15 @@ s390_free_pool (pool)\n \n   BITMAP_XFREE (pool->insns);\n   free (pool);\n-} \n+}\n \n \n /* Chunkify the literal pool if required.  */\n \n #define S390_POOL_CHUNK_MIN\t0xc00\n #define S390_POOL_CHUNK_MAX\t0xe00\n \n-static struct constant_pool * \n+static struct constant_pool *\n s390_chunkify_start (void)\n {\n   rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n@@ -4529,7 +4532,7 @@ s390_chunkify_start (void)\n \t    abort ();\n \t}\n \n-      if (!curr_pool \n+      if (!curr_pool\n \t  || INSN_ADDRESSES_SIZE () <= (size_t) INSN_UID (insn)\n           || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n \tcontinue;\n@@ -4579,7 +4582,7 @@ s390_chunkify_start (void)\n \t      if (get_attr_length (insn) == 0)\n \t\tcontinue;\n \n-\t      /* Don't separate LTREL_BASE from the corresponding \n+\t      /* Don't separate LTREL_BASE from the corresponding\n \t\t LTREL_OFFSET load.  */\n \t      if (pending_ltrel)\n \t\tcontinue;\n@@ -4608,7 +4611,7 @@ s390_chunkify_start (void)\n     abort ();\n \n \n-  /* Find all labels that are branched into \n+  /* Find all labels that are branched into\n      from an insn belonging to a different chunk.  */\n \n   far_labels = BITMAP_XMALLOC ();\n@@ -4622,11 +4625,11 @@ s390_chunkify_start (void)\n \t Don't do that, however, if it is the label before\n \t a jump table.  */\n \n-      if (GET_CODE (insn) == CODE_LABEL \n+      if (GET_CODE (insn) == CODE_LABEL\n \t  && (LABEL_PRESERVE_P (insn) || LABEL_NAME (insn)))\n \t{\n \t  rtx vec_insn = next_real_insn (insn);\n-\t  rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ? \n+\t  rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ?\n \t\t\tPATTERN (vec_insn) : NULL_RTX;\n \t  if (!vec_pat\n \t      || !(GET_CODE (vec_pat) == ADDR_VEC\n@@ -4636,22 +4639,22 @@ s390_chunkify_start (void)\n \n       /* If we have a direct jump (conditional or unconditional)\n \t or a casesi jump, check all potential targets.  */\n-      else if (GET_CODE (insn) == JUMP_INSN) \n+      else if (GET_CODE (insn) == JUMP_INSN)\n \t{\n           rtx pat = PATTERN (insn);\n \t  if (GET_CODE (pat) == PARALLEL && XVECLEN (pat, 0) > 2)\n \t    pat = XVECEXP (pat, 0, 0);\n \n-          if (GET_CODE (pat) == SET) \n+          if (GET_CODE (pat) == SET)\n             {\n \t      rtx label = JUMP_LABEL (insn);\n \t      if (label)\n \t\t{\n-\t          if (s390_find_pool (pool_list, label) \n+\t          if (s390_find_pool (pool_list, label)\n \t\t      != s390_find_pool (pool_list, insn))\n \t\t    bitmap_set_bit (far_labels, CODE_LABEL_NUMBER (label));\n \t\t}\n-            } \n+            }\n \t  else if (GET_CODE (pat) == PARALLEL\n \t\t   && XVECLEN (pat, 0) == 2\n \t\t   && GET_CODE (XVECEXP (pat, 0, 0)) == SET\n@@ -4661,7 +4664,7 @@ s390_chunkify_start (void)\n \t      /* Find the jump table used by this casesi jump.  */\n \t      rtx vec_label = XEXP (XEXP (XVECEXP (pat, 0, 1), 0), 0);\n \t      rtx vec_insn = next_real_insn (vec_label);\n-\t      rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ? \n+\t      rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ?\n \t\t\t    PATTERN (vec_insn) : NULL_RTX;\n \t      if (vec_pat\n \t\t  && (GET_CODE (vec_pat) == ADDR_VEC\n@@ -4673,7 +4676,7 @@ s390_chunkify_start (void)\n \t\t    {\n \t\t      rtx label = XEXP (XVECEXP (vec_pat, diff_p, i), 0);\n \n-\t\t      if (s390_find_pool (pool_list, label) \n+\t\t      if (s390_find_pool (pool_list, label)\n \t\t\t  != s390_find_pool (pool_list, insn))\n \t\t\tbitmap_set_bit (far_labels, CODE_LABEL_NUMBER (label));\n \t\t    }\n@@ -4694,7 +4697,7 @@ s390_chunkify_start (void)\n   /* Insert base register reload insns at every far label.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CODE_LABEL \n+    if (GET_CODE (insn) == CODE_LABEL\n         && bitmap_bit_p (far_labels, CODE_LABEL_NUMBER (insn)))\n       {\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n@@ -4718,21 +4721,21 @@ s390_chunkify_start (void)\n }\n \n /* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n-   After we have decided to use this list, finish implementing \n+   After we have decided to use this list, finish implementing\n    all changes to the current function as required.  */\n- \n+\n static void\n s390_chunkify_finish (pool_list)\n      struct constant_pool *pool_list;\n {\n   rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n   struct constant_pool *curr_pool = NULL;\n   rtx insn;\n- \n- \n+\n+\n   /* Replace all literal pool references.  */\n \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn)) \n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \treplace_ltrel_base (&PATTERN (insn), base_reg);\n@@ -4757,10 +4760,10 @@ s390_chunkify_finish (pool_list)\n     }\n \n   /* Dump out all literal pools.  */\n- \n+\n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n     s390_dump_pool (curr_pool);\n- \n+\n   /* Free pool list.  */\n \n   while (pool_list)\n@@ -4774,7 +4777,7 @@ s390_chunkify_finish (pool_list)\n /* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n    We have decided we cannot use this list, so revert all changes\n    to the current function that were done by s390_chunkify_start.  */\n- \n+\n static void\n s390_chunkify_cancel (pool_list)\n      struct constant_pool *pool_list;\n@@ -4840,25 +4843,25 @@ int s390_pool_count = -1;\n /* Number of elements of current constant pool.  */\n int s390_nr_constants;\n \n-/* Output main constant pool to stdio stream FILE.  */ \n+/* Output main constant pool to stdio stream FILE.  */\n \n void\n s390_output_constant_pool (start_label, end_label)\n      rtx start_label;\n      rtx end_label;\n {\n-  if (TARGET_64BIT) \n+  if (TARGET_64BIT)\n     {\n       readonly_data_section ();\n       ASM_OUTPUT_ALIGN (asm_out_file, 3);\n-      (*targetm.asm_out.internal_label) (asm_out_file, \"L\", \n+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n \t\t\t\t\t CODE_LABEL_NUMBER (start_label));\n-    } \n-  else \n+    }\n+  else\n     {\n       (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n \t\t\t\t\t CODE_LABEL_NUMBER (start_label));\n-      ASM_OUTPUT_ALIGN (asm_out_file, 2);      \n+      ASM_OUTPUT_ALIGN (asm_out_file, 2);\n     }\n \n   s390_pool_count = 0;\n@@ -4869,15 +4872,15 @@ s390_output_constant_pool (start_label, end_label)\n   else\n     {\n       ASM_OUTPUT_ALIGN (asm_out_file, 1);\n-      (*targetm.asm_out.internal_label) (asm_out_file, \"L\", \n+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n \t\t\t\t\t CODE_LABEL_NUMBER (end_label));\n     }\n }\n \n /* Rework the prolog/epilog to avoid saving/restoring\n    registers unnecessarily.  If TEMP_REGNO is nonnegative,\n-   it specifies the number of a caller-saved register used \n-   as temporary scratch register by code emitted during \n+   it specifies the number of a caller-saved register used\n+   as temporary scratch register by code emitted during\n    machine dependent reorg.  */\n \n static void\n@@ -4894,12 +4897,12 @@ s390_optimize_prolog (temp_regno)\n   regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n   /* If there is (possibly) any pool entry, we need to\n-     load the base register.  \n+     load the base register.\n      ??? FIXME: this should be more precise.  */\n   if (get_pool_size ())\n     regs_ever_live[BASE_REGISTER] = 1;\n \n-  /* In non-leaf functions, the prolog/epilog code relies \n+  /* In non-leaf functions, the prolog/epilog code relies\n      on RETURN_REGNUM being saved in any case.  */\n   if (!current_function_is_leaf)\n     regs_ever_live[RETURN_REGNUM] = 1;\n@@ -4910,22 +4913,22 @@ s390_optimize_prolog (temp_regno)\n \n \n   /* Find first and last gpr to be saved.  */\n-  \n+\n   for (i = 6; i < 16; i++)\n     if (regs_ever_live[i])\n       if (!global_regs[i]\n-\t  || i == STACK_POINTER_REGNUM \n+\t  || i == STACK_POINTER_REGNUM\n           || i == RETURN_REGNUM\n-          || i == BASE_REGISTER \n+          || i == BASE_REGISTER\n           || (flag_pic && i == (int)PIC_OFFSET_TABLE_REGNUM))\n \tbreak;\n \n   for (j = 15; j > i; j--)\n     if (regs_ever_live[j])\n       if (!global_regs[j]\n-\t  || j == STACK_POINTER_REGNUM \n+\t  || j == STACK_POINTER_REGNUM\n           || j == RETURN_REGNUM\n-          || j == BASE_REGISTER \n+          || j == BASE_REGISTER\n           || (flag_pic && j == (int)PIC_OFFSET_TABLE_REGNUM))\n \tbreak;\n \n@@ -5098,38 +5101,38 @@ s390_reorg ()\n \n \n   /* There are two problematic situations we need to correct:\n- \n+\n      - the literal pool might be > 4096 bytes in size, so that\n        some of its elements cannot be directly accessed\n- \n+\n      - a branch target might be > 64K away from the branch, so that\n        it is not possible to use a PC-relative instruction.\n- \n+\n      To fix those, we split the single literal pool into multiple\n      pool chunks, reloading the pool base register at various\n      points throughout the function to ensure it always points to\n      the pool chunk the following code expects, and / or replace\n      PC-relative branches by absolute branches.\n- \n+\n      However, the two problems are interdependent: splitting the\n      literal pool can move a branch further away from its target,\n      causing the 64K limit to overflow, and on the other hand,\n      replacing a PC-relative branch by an absolute branch means\n      we need to put the branch target address into the literal\n      pool, possibly causing it to overflow.\n- \n+\n      So, we loop trying to fix up both problems until we manage\n      to satisfy both conditions at the same time.  Note that the\n      loop is guaranteed to terminate as every pass of the loop\n      strictly decreases the total number of PC-relative branches\n      in the function.  (This is not completely true as there\n      might be branch-over-pool insns introduced by chunkify_start.\n      Those never need to be split however.)  */\n- \n+\n   for (;;)\n     {\n       struct constant_pool *pool_list;\n- \n+\n       /* Try to chunkify the literal pool.  */\n       pool_list = s390_chunkify_start ();\n \n@@ -5140,7 +5143,7 @@ s390_reorg ()\n         {\n           if (pool_list)\n             s390_chunkify_cancel (pool_list);\n- \n+\n           continue;\n         }\n \n@@ -5158,15 +5161,15 @@ s390_reorg ()\n \n \t  continue;\n \t}\n- \n+\n       /* If we made it up to here, both conditions are satisfied.\n \t Finish up pool chunkification if required.  */\n       if (pool_list)\n \ts390_chunkify_finish (pool_list);\n- \n+\n       break;\n     }\n- \n+\n   s390_optimize_prolog (temp_used? RETURN_REGNUM : -1);\n }\n \n@@ -5194,7 +5197,7 @@ s390_return_addr_rtx (count, frame)\n   addr = plus_constant (frame, RETURN_REGNUM * UNITS_PER_WORD);\n   addr = memory_address (Pmode, addr);\n   return gen_rtx_MEM (Pmode, addr);\n-} \n+}\n \n /* Find first call clobbered register unsused in a function.\n    This could be used as base register in a leaf function\n@@ -5225,7 +5228,7 @@ s390_frame_info ()\n   /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n   cfun->machine->save_fprs_p = 0;\n   if (TARGET_64BIT)\n-    for (i = 24; i < 32; i++) \n+    for (i = 24; i < 32; i++)\n       if (regs_ever_live[i] && !global_regs[i])\n \t{\n           cfun->machine->save_fprs_p = 1;\n@@ -5235,10 +5238,10 @@ s390_frame_info ()\n   cfun->machine->frame_size = fsize + cfun->machine->save_fprs_p * 64;\n \n   /* Does function need to setup frame and save area.  */\n-  \n+\n   if (! current_function_is_leaf\n       || cfun->machine->frame_size > 0\n-      || current_function_calls_alloca \n+      || current_function_calls_alloca\n       || current_function_stdarg)\n     cfun->machine->frame_size += STARTING_FRAME_OFFSET;\n \n@@ -5258,7 +5261,7 @@ s390_frame_info ()\n   gprs_ever_live[BASE_REGISTER] = 1;\n   gprs_ever_live[RETURN_REGNUM] = 1;\n   gprs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n-  \n+\n   for (i = 6; i < 16; i++)\n     if (gprs_ever_live[i])\n       break;\n@@ -5278,10 +5281,10 @@ s390_frame_info ()\n     cfun->machine->first_save_gpr = 2;\n }\n \n-/* Return offset between argument pointer and frame pointer \n+/* Return offset between argument pointer and frame pointer\n    initially after prologue.  */\n \n-int \n+int\n s390_arg_frame_offset ()\n {\n   HOST_WIDE_INT fsize = get_frame_size ();\n@@ -5290,7 +5293,7 @@ s390_arg_frame_offset ()\n   /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n   save_fprs_p = 0;\n   if (TARGET_64BIT)\n-    for (i = 24; i < 32; i++) \n+    for (i = 24; i < 32; i++)\n       if (regs_ever_live[i] && !global_regs[i])\n \t{\n           save_fprs_p = 1;\n@@ -5300,23 +5303,23 @@ s390_arg_frame_offset ()\n   fsize = fsize + save_fprs_p * 64;\n \n   /* Does function need to setup frame and save area.  */\n-  \n+\n   if (! current_function_is_leaf\n       || fsize > 0\n-      || current_function_calls_alloca \n+      || current_function_calls_alloca\n       || current_function_stdarg)\n     fsize += STARTING_FRAME_OFFSET;\n   return fsize + STACK_POINTER_OFFSET;\n }\n \n /* Emit insn to save fpr REGNUM at offset OFFSET relative\n-   to register BASE.  Return generated insn.  */ \n+   to register BASE.  Return generated insn.  */\n \n static rtx\n save_fpr (base, offset, regnum)\n      rtx base;\n      int offset;\n-     int regnum;     \n+     int regnum;\n {\n   rtx addr;\n   addr = gen_rtx_MEM (DFmode, plus_constant (base, offset));\n@@ -5326,7 +5329,7 @@ save_fpr (base, offset, regnum)\n }\n \n /* Emit insn to restore fpr REGNUM from offset OFFSET relative\n-   to register BASE.  Return generated insn.  */ \n+   to register BASE.  Return generated insn.  */\n \n static rtx\n restore_fpr (base, offset, regnum)\n@@ -5342,7 +5345,7 @@ restore_fpr (base, offset, regnum)\n }\n \n /* Generate insn to save registers FIRST to LAST into\n-   the register save area located at offset OFFSET \n+   the register save area located at offset OFFSET\n    relative to register BASE.  */\n \n static rtx\n@@ -5381,7 +5384,7 @@ save_gprs (base, offset, first, last)\n      inside the store-multiple pattern.\n \n      However, we must not emit DWARF records for registers 2..5\n-     if they are stored for use by variable arguments ...  \n+     if they are stored for use by variable arguments ...\n \n      ??? Unfortunately, it is not enough to simply not the the\n      FRAME_RELATED flags for those SETs, because the first SET\n@@ -5402,13 +5405,13 @@ save_gprs (base, offset, first, last)\n   else if (last >= 6)\n     {\n       addr = plus_constant (base, offset + 6 * UNITS_PER_WORD);\n-      note = gen_store_multiple (gen_rtx_MEM (Pmode, addr), \n+      note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n \t\t\t\t gen_rtx_REG (Pmode, 6),\n \t\t\t\t GEN_INT (last - 6 + 1));\n       note = PATTERN (note);\n \n       REG_NOTES (insn) =\n-\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, \n+\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t   note, REG_NOTES (insn));\n \n       for (i = 0; i < XVECLEN (note, 0); i++)\n@@ -5422,7 +5425,7 @@ save_gprs (base, offset, first, last)\n }\n \n /* Generate insn to restore registers FIRST to LAST from\n-   the register save area located at offset OFFSET \n+   the register save area located at offset OFFSET\n    relative to register BASE.  */\n \n static rtx\n@@ -5480,7 +5483,7 @@ s390_load_got (maybe_dead)\n     {\n       rtx offset, insn;\n \n-      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got_symbol), \n+      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got_symbol),\n \t\t\t       UNSPEC_LTREL_OFFSET);\n       offset = gen_rtx_CONST (Pmode, offset);\n       offset = force_const_mem (Pmode, offset);\n@@ -5490,7 +5493,7 @@ s390_load_got (maybe_dead)\n \tREG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n \t\t\t\t\t     REG_NOTES (insn));\n \n-      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (offset, 0)), \n+      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (offset, 0)),\n \t\t\t       UNSPEC_LTREL_BASE);\n       offset = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, offset);\n \n@@ -5515,18 +5518,20 @@ s390_emit_prologue ()\n \n   s390_frame_info ();\n \n-  /* Choose best register to use for temp use within prologue.  */\n-  \n+  /* Choose best register to use for temp use within prologue.\n+     See below for why TPF must use the register 1.  */\n+\n   if (!current_function_is_leaf\n       && !has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n-      && get_pool_size () < S390_POOL_CHUNK_MAX / 2)\n+      && get_pool_size () < S390_POOL_CHUNK_MAX / 2\n+      && !TARGET_TPF)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);\n \n   /* Save call saved gprs.  */\n \n-  insn = save_gprs (stack_pointer_rtx, 0, \n+  insn = save_gprs (stack_pointer_rtx, 0,\n \t\t    cfun->machine->first_save_gpr, cfun->machine->last_save_gpr);\n   emit_insn (insn);\n \n@@ -5535,29 +5540,29 @@ s390_emit_prologue ()\n   pool_start_label = gen_label_rtx();\n   pool_end_label = gen_label_rtx();\n   cfun->machine->literal_pool_label = pool_start_label;\n-  \n+\n   if (TARGET_64BIT)\n     insn = emit_insn (gen_literal_pool_64 (gen_rtx_REG (Pmode, BASE_REGISTER),\n                  \t\t\t   pool_start_label, pool_end_label));\n   else\n     insn = emit_insn (gen_literal_pool_31 (gen_rtx_REG (Pmode, BASE_REGISTER),\n-\t\t\t\t\t     pool_start_label, pool_end_label));  \n-  \n+\t\t\t\t\t     pool_start_label, pool_end_label));\n+\n   /* Save fprs for variable args.  */\n \n   if (current_function_stdarg)\n     {\n-      /* Save fpr 0 and 2.  */ \n+      /* Save fpr 0 and 2.  */\n+\n+      save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 32, 16);\n+      save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 24, 17);\n \n-      save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 32, 16); \n-      save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 24, 17); \n-      \n       if (TARGET_64BIT)\n \t{\n \t  /* Save fpr 4 and 6.  */\n- \n-\t  save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 16, 18); \n-\t  save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 8, 19); \n+\n+\t  save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 16, 18);\n+\t  save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 8, 19);\n \t}\n     }\n \n@@ -5573,7 +5578,7 @@ s390_emit_prologue ()\n \t}\n       if (regs_ever_live[19] && !global_regs[19])\n \t{\n-\t  insn = save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 8, 19); \n+\t  insn = save_fpr (stack_pointer_rtx, STACK_POINTER_OFFSET - 8, 19);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n     }\n@@ -5585,18 +5590,18 @@ s390_emit_prologue ()\n       rtx frame_off = GEN_INT (-cfun->machine->frame_size);\n \n       /* Save incoming stack pointer into temp reg.  */\n-      \n+\n       if (TARGET_BACKCHAIN || cfun->machine->save_fprs_p)\n \t{\n \t  insn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n \t}\n-      \n+\n       /* Subtract frame size from stack pointer.  */\n \n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n-\t  insn = gen_rtx_SET (VOIDmode, stack_pointer_rtx, \n-\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx, \n+\t  insn = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t\t      \t    frame_off));\n \t  insn = emit_insn (insn);\n \t}\n@@ -5609,15 +5614,15 @@ s390_emit_prologue ()\n \t}\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n-      REG_NOTES (insn) = \n+      REG_NOTES (insn) =\n \tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t   gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n \t\t\t\t   gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t           GEN_INT (-cfun->machine->frame_size))),\n \t\t\t   REG_NOTES (insn));\n \n       /* Set backchain.  */\n-      \n+\n       if (TARGET_BACKCHAIN)\n \t{\n \t  addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n@@ -5637,40 +5642,62 @@ s390_emit_prologue ()\n     }\n \n   /* Save fprs 8 - 15 (64 bit ABI).  */\n-  \n+\n   if (cfun->machine->save_fprs_p)\n     {\n       insn = emit_insn (gen_add2_insn (temp_reg, GEN_INT(-64)));\n \n       for (i = 24; i < 32; i++)\n \tif (regs_ever_live[i] && !global_regs[i])\n \t  {\n-\t    rtx addr = plus_constant (stack_pointer_rtx, \n+\t    rtx addr = plus_constant (stack_pointer_rtx,\n \t\t\t\t      cfun->machine->frame_size - 64 + (i-24)*8);\n \n \t    insn = save_fpr (temp_reg, (i-24)*8, i);\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t    REG_NOTES (insn) = \n+\t    REG_NOTES (insn) =\n \t      gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode, \n+\t\tgen_rtx_SET (VOIDmode,\n \t\t\t     gen_rtx_MEM (DFmode, addr),\n \t\t\t     gen_rtx_REG (DFmode, i)),\n \t\tREG_NOTES (insn));\n \t  }\n     }\n-\t    \n+\n   /* Set frame pointer, if needed.  */\n-  \n+\n   if (frame_pointer_needed)\n     {\n       insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* Set up got pointer, if needed.  */\n-  \n+\n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    s390_load_got (true);\n+    s390_load_got(true);\n+\n+  if (TARGET_TPF)\n+    {\n+      /* Generate a BAS instruction to serve as a function\n+\t entry intercept to facilitate the use of tracing\n+\t algorithms located at the branch target.\n+\n+\t This must use register 1.  */\n+      rtx addr;\n+      rtx unkn;\n+      rtx link;\n+\n+      addr = GEN_INT (0xfe0);\n+      unkn = CONST0_RTX (SImode);\n+      link = gen_rtx_REG (Pmode, 1);\n+\n+      emit_call_insn (gen_call_exp (gen_rtx_MEM (QImode, addr), unkn, link));\n+\n+      /* Emit a blockage here so that all code\n+\t lies between the profiling mechanisms.  */\n+      emit_insn (gen_blockage ());\n+    }\n }\n \n /* Expand the epilogue into a bunch of separate insns.  */\n@@ -5682,9 +5709,33 @@ s390_emit_epilogue ()\n   int area_bottom, area_top, offset = 0;\n   rtvec p;\n \n+  if (TARGET_TPF)\n+    {\n+\n+      /* Generate a BAS instruction to serve as a function\n+\t entry intercept to facilitate the use of tracing\n+\t algorithms located at the branch target.\n+\n+\t This must use register 1.  */\n+\n+      rtx addr;\n+      rtx unkn;\n+      rtx link;\n+\n+      addr = GEN_INT (0xfe6);\n+      unkn = CONST0_RTX (SImode);\n+      link = gen_rtx_REG (Pmode, 1);\n+\n+      /* Emit a blockage here so that all code\n+         lies between the profiling mechanisms.  */\n+      emit_insn (gen_blockage ());\n+\n+      emit_call_insn (gen_call_exp (gen_rtx_MEM (QImode, addr), unkn, link));\n+    }\n+\n   /* Check whether to use frame or stack pointer for restore.  */\n \n-  frame_pointer = frame_pointer_needed ? \n+  frame_pointer = frame_pointer_needed ?\n     hard_frame_pointer_rtx : stack_pointer_rtx;\n \n   /* Compute which parts of the save area we need to access.  */\n@@ -5728,7 +5779,7 @@ s390_emit_epilogue ()\n \t}\n     }\n \n-  /* Check whether we can access the register save area.  \n+  /* Check whether we can access the register save area.\n      If not, increment the frame pointer as required.  */\n \n   if (area_top <= area_bottom)\n@@ -5745,12 +5796,12 @@ s390_emit_epilogue ()\n     {\n       rtx insn, frame_off;\n \n-      offset = area_bottom < 0 ? -area_bottom : 0; \n+      offset = area_bottom < 0 ? -area_bottom : 0;\n       frame_off = GEN_INT (cfun->machine->frame_size - offset);\n \n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n-\t  insn = gen_rtx_SET (VOIDmode, frame_pointer, \n+\t  insn = gen_rtx_SET (VOIDmode, frame_pointer,\n \t\t\t      gen_rtx_PLUS (Pmode, frame_pointer, frame_off));\n \t  insn = emit_insn (insn);\n \t}\n@@ -5772,7 +5823,7 @@ s390_emit_epilogue ()\n       if (cfun->machine->save_fprs_p)\n \tfor (i = 24; i < 32; i++)\n \t  if (regs_ever_live[i] && !global_regs[i])\n-\t    restore_fpr (frame_pointer, \n+\t    restore_fpr (frame_pointer,\n \t\t\t offset - 64 + (i-24) * 8, i);\n     }\n   else\n@@ -5785,7 +5836,7 @@ s390_emit_epilogue ()\n \n   /* Return register.  */\n \n-  return_reg = gen_rtx_REG (Pmode, RETURN_REGNUM); \n+  return_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n \n   /* Restore call saved gprs.  */\n \n@@ -5794,29 +5845,29 @@ s390_emit_epilogue ()\n       rtx insn, addr;\n       int i;\n \n-      /* Check for global register and save them \n+      /* Check for global register and save them\n \t to stack location from where they get restored.  */\n \n-      for (i = cfun->machine->first_restore_gpr; \n+      for (i = cfun->machine->first_restore_gpr;\n \t   i <= cfun->machine->last_save_gpr;\n \t   i++)\n \t{\n-\t  /* These registers are special and need to be \n+\t  /* These registers are special and need to be\n \t     restored in any case.  */\n-\t  if (i == STACK_POINTER_REGNUM \n+\t  if (i == STACK_POINTER_REGNUM\n               || i == RETURN_REGNUM\n-              || i == BASE_REGISTER \n+              || i == BASE_REGISTER\n               || (flag_pic && i == (int)PIC_OFFSET_TABLE_REGNUM))\n \t    continue;\n \n \t  if (global_regs[i])\n \t    {\n-\t      addr = plus_constant (frame_pointer, \n+\t      addr = plus_constant (frame_pointer,\n \t\t     offset + i * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, s390_sr_alias_set);\n \t      emit_move_insn (addr, gen_rtx_REG (Pmode, i));\n-\t    }  \n+\t    }\n \t}\n \n       /* Fetch return address from stack before load multiple,\n@@ -5828,9 +5879,9 @@ s390_emit_epilogue ()\n \t  if (!return_regnum)\n \t    return_regnum = 4;\n \t  return_reg = gen_rtx_REG (Pmode, return_regnum);\n-\t\n-\t  addr = plus_constant (frame_pointer, \n-\t\t\t\toffset + RETURN_REGNUM * UNITS_PER_WORD); \n+\n+\t  addr = plus_constant (frame_pointer,\n+\t\t\t\toffset + RETURN_REGNUM * UNITS_PER_WORD);\n \t  addr = gen_rtx_MEM (Pmode, addr);\n \t  set_mem_alias_set (addr, s390_sr_alias_set);\n \t  emit_move_insn (return_reg, addr);\n@@ -5840,25 +5891,25 @@ s390_emit_epilogue ()\n \t explicit in insn RTX code, we have to add a barrier here\n \t to prevent incorrect scheduling.  */\n \n-      emit_insn (gen_blockage());      \n+      emit_insn (gen_blockage());\n \n-      insn = restore_gprs (frame_pointer, offset, \n-\t\t\t   cfun->machine->first_restore_gpr, \n+      insn = restore_gprs (frame_pointer, offset,\n+\t\t\t   cfun->machine->first_restore_gpr,\n \t\t\t   cfun->machine->last_save_gpr);\n       emit_insn (insn);\n     }\n \n   /* Return to caller.  */\n \n   p = rtvec_alloc (2);\n-  \n+\n   RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n   RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);\n   emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n }\n \n \n-/* Return the size in bytes of a function argument of \n+/* Return the size in bytes of a function argument of\n    type TYPE and/or mode MODE.  At least one of TYPE or\n    MODE must be specified.  */\n \n@@ -5943,7 +5994,7 @@ s390_function_arg_pass_by_reference (mode, type)\n       if (TREE_CODE (type) == COMPLEX_TYPE)\n         return 1;\n     }\n-    \n+\n   return 0;\n }\n \n@@ -5986,7 +6037,7 @@ s390_function_arg_advance (cum, mode, type, named)\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n    NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  \n+    (otherwise it is an extra parameter matching an ellipsis).\n \n    On S/390, we use general purpose registers 2 through 6 to\n    pass integer, pointer, and certain structure arguments, and\n@@ -6034,12 +6085,12 @@ s390_function_arg (cum, mode, type, named)\n             long __fpr;\n             void *__overflow_arg_area;\n             void *__reg_save_area;\n-            \n+\n         } va_list[1];\n \n    where __gpr and __fpr hold the number of general purpose\n    or floating point arguments used up to now, respectively,\n-   __overflow_arg_area points to the stack location of the \n+   __overflow_arg_area points to the stack location of the\n    next argument passed on the stack, and __reg_save_area\n    always points to the start of the register area in the\n    call frame of the current function.  The function prologue\n@@ -6056,9 +6107,9 @@ s390_build_va_list ()\n   type_decl =\n     build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n \n-  f_gpr = build_decl (FIELD_DECL, get_identifier (\"__gpr\"), \n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"__gpr\"),\n \t\t      long_integer_type_node);\n-  f_fpr = build_decl (FIELD_DECL, get_identifier (\"__fpr\"), \n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"__fpr\"),\n \t\t      long_integer_type_node);\n   f_ovf = build_decl (FIELD_DECL, get_identifier (\"__overflow_arg_area\"),\n \t\t      ptr_type_node);\n@@ -6154,15 +6205,15 @@ s390_va_start (valist, nextarg)\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n-/* Implement va_arg by updating the va_list structure \n+/* Implement va_arg by updating the va_list structure\n    VALIST as required to retrieve an argument of type\n-   TYPE, and returning that argument. \n-   \n+   TYPE, and returning that argument.\n+\n    Generates code equivalent to:\n-   \n+\n    if (integral value) {\n      if (size  <= 4 && args.gpr < 5 ||\n-         size  > 4 && args.gpr < 4 ) \n+         size  > 4 && args.gpr < 4 )\n        ret = args.reg_save_area[args.gpr+8]\n      else\n        ret = *args.overflow_arg_area++;\n@@ -6248,6 +6299,7 @@ s390_va_arg (valist, type)\n       reg = gpr;\n       n_reg = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n       sav_ofs = 2 * UNITS_PER_WORD;\n+\n       if (size < UNITS_PER_WORD)\n \tsav_ofs += UNITS_PER_WORD - size;\n \n@@ -6316,10 +6368,10 @@ s390_va_arg (valist, type)\n \n   emit_label (lab_over);\n \n-  /* If less than max_regs a registers are retrieved out \n+  /* If less than max_regs a registers are retrieved out\n      of register save area, increment.  */\n \n-  u = build (PREINCREMENT_EXPR, TREE_TYPE (reg), reg, \n+  u = build (PREINCREMENT_EXPR, TREE_TYPE (reg), reg,\n \t     build_int_2 (n_reg, 0));\n   TREE_SIDE_EFFECTS (u) = 1;\n   expand_expr (u, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6388,7 +6440,7 @@ s390_expand_builtin (exp, target, subtarget, mode, ignore)\n {\n #define MAX_ARGS 2\n \n-  unsigned int const *code_for_builtin = \n+  unsigned int const *code_for_builtin =\n     TARGET_64BIT ? code_for_builtin_64 : code_for_builtin_31;\n \n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -6504,13 +6556,13 @@ s390_initialize_trampoline (addr, fnaddr, cxt)\n      rtx fnaddr;\n      rtx cxt;\n {\n-  emit_move_insn (gen_rtx \n+  emit_move_insn (gen_rtx\n \t\t  (MEM, Pmode,\n-\t\t   memory_address (Pmode, \n+\t\t   memory_address (Pmode,\n \t\t   plus_constant (addr, (TARGET_64BIT ? 20 : 12) ))), cxt);\n   emit_move_insn (gen_rtx\n \t\t  (MEM, Pmode,\n-\t\t   memory_address (Pmode, \n+\t\t   memory_address (Pmode,\n \t\t   plus_constant (addr, (TARGET_64BIT ? 28 : 16) ))), fnaddr);\n }\n \n@@ -6527,7 +6579,7 @@ s390_gen_rtx_const_DI (high, low)\n   val = (HOST_WIDE_INT)high;\n   val <<= 32;\n   val |= (HOST_WIDE_INT)low;\n-  \n+\n   return GEN_INT (val);\n #else\n #if HOST_BITS_PER_WIDE_INT >= 32\n@@ -6536,7 +6588,7 @@ s390_gen_rtx_const_DI (high, low)\n   abort ();\n #endif\n #endif\n-} \n+}\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n@@ -6636,13 +6688,13 @@ s390_encode_section_info (decl, rtl, first)\n \n   /* If a variable has a forced alignment to < 2 bytes, mark it with\n      SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL operand.  */\n-  if (TREE_CODE (decl) == VAR_DECL \n+  if (TREE_CODE (decl) == VAR_DECL\n       && DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)\n     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_ALIGN1;\n }\n \n /* Output thunk to FILE that implements a C++ virtual function call (with\n-   multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer \n+   multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer\n    by DELTA, and unless VCALL_OFFSET is zero, applies an additional adjustment\n    stored at VCALL_OFFSET in the vtable whose address is located at offset 0\n    relative to the resulting this pointer.  */\n@@ -6696,9 +6748,9 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n   if (TARGET_64BIT)\n     {\n       /* Setup literal pool pointer if required.  */\n-      if ((!DISP_IN_RANGE (delta) \n+      if ((!DISP_IN_RANGE (delta)\n \t   && !CONST_OK_FOR_LETTER_P (delta, 'K'))\n-\t  || (!DISP_IN_RANGE (vcall_offset) \n+\t  || (!DISP_IN_RANGE (vcall_offset)\n \t      && !CONST_OK_FOR_LETTER_P (vcall_offset, 'K')))\n \t{\n \t  op[5] = gen_label_rtx ();\n@@ -6743,7 +6795,7 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n \t      output_asm_insn (\"ag\\t%1,0(%4)\", op);\n \t    }\n \t}\n-        \n+\n       /* Jump to target.  */\n       output_asm_insn (\"jg\\t%0\", op);\n \n@@ -6889,6 +6941,13 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n     }\n }\n \n+bool\n+s390_valid_pointer_mode (mode)\n+     enum machine_mode mode;\n+{\n+  return (mode == SImode || (TARGET_64BIT && mode == DImode));\n+}\n+\n /* How to allocate a 'struct machine_function'.  */\n \n static struct machine_function *"}, {"sha": "48b7c5632ec38b7a8b4ff7a915e462236e57e65d", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=c745338420c2c26df126dc69c27f6c506ecb8bf7", "patch": "@@ -29,15 +29,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <s390/fixdfdi.h>\n #endif\n \n-/* Which processor to generate code or schedule for. The cpu attribute \n+/* Which processor to generate code or schedule for. The cpu attribute\n    defines a list that mirrors this list, so changes to s390.md must be\n    made at the same time.  */\n \n enum processor_type\n {\n-  PROCESSOR_9672_G5,\t\t\n-  PROCESSOR_9672_G6,\t\t\n-  PROCESSOR_2064_Z900,\t\t\n+  PROCESSOR_9672_G5,\n+  PROCESSOR_9672_G6,\n+  PROCESSOR_2064_Z900,\n   PROCESSOR_2084_Z990,\n   PROCESSOR_max\n };\n@@ -94,6 +94,7 @@ extern int target_flags;\n #define MASK_64BIT                 0x10\n #define MASK_ZARCH                 0x20\n #define MASK_MVCLE                 0x40\n+#define MASK_TPF                   0x80\n \n #define TARGET_HARD_FLOAT          (target_flags & MASK_HARD_FLOAT)\n #define TARGET_SOFT_FLOAT          (!(target_flags & MASK_HARD_FLOAT))\n@@ -103,6 +104,7 @@ extern int target_flags;\n #define TARGET_64BIT               (target_flags & MASK_64BIT)\n #define TARGET_ZARCH               (target_flags & MASK_ZARCH)\n #define TARGET_MVCLE               (target_flags & MASK_MVCLE)\n+#define TARGET_TPF                 (target_flags & MASK_TPF)\n \n /* ??? Once this actually works, it could be made a runtime option.  */\n #define TARGET_IBM_FLOAT           0\n@@ -129,6 +131,8 @@ extern int target_flags;\n   { \"esa\",         -32, N_(\"ESA/390 architecture\")},                   \\\n   { \"mvcle\",        64, N_(\"mvcle use\")},                              \\\n   { \"no-mvcle\",    -64, N_(\"mvc&ex\")},                                 \\\n+  { \"tpf\",         128, N_(\"enable tpf OS code\")},                     \\\n+  { \"no-tpf\",     -128, N_(\"disable tpf OS code\")},                    \\\n   { \"\", TARGET_DEFAULT, 0 } }\n \n #define TARGET_OPTIONS                                          \\\n@@ -264,15 +268,15 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n /* We have 16 general purpose registers (registers 0-15),\n    and 16 floating point registers (registers 16-31).\n    (On non-IEEE machines, we have only 4 fp registers.)\n- \n+\n    Amongst the general purpose registers, some are used\n    for specific purposes:\n    GPR 11: Hard frame pointer (if needed)\n    GPR 12: Global offset table pointer (if needed)\n    GPR 13: Literal pool base register\n    GPR 14: Return address register\n    GPR 15: Stack pointer\n- \n+\n    Registers 32-34 are 'fake' hard registers that do not\n    correspond to actual hardware:\n    Reg 32: Argument pointer\n@@ -376,19 +380,19 @@ do\t\t\t\t\t\t\t\t\\\n \n \n /* Fitting values into registers.  */\n- \n+\n /* Integer modes <= word size fit into any GPR.\n    Integer modes > word size fit into successive GPRs, starting with\n    an even-numbered register.\n    SImode and DImode fit into FPRs as well.\n- \n+\n    Floating point modes <= word size fit into any FPR or GPR.\n    Floating point modes > word size (i.e. DFmode on 32-bit) fit\n    into any FPR, or an even-odd GPR pair.\n- \n+\n    Complex floating point modes fit either into two FPRs, or into\n    successive GPRs (again starting with an even number).\n- \n+\n    Condition code modes fit only into the CC register.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n@@ -430,19 +434,19 @@ do\t\t\t\t\t\t\t\t\\\n    ? reg_classes_intersect_p (FP_REGS, CLASS) : 0)\n \n /* Register classes.  */\n- \n+\n /* We use the following register classes:\n    GENERAL_REGS     All general purpose registers\n    ADDR_REGS        All general purpose registers except %r0\n                     (These registers can be used in address generation)\n    FP_REGS          All floating point registers\n- \n+\n    GENERAL_FP_REGS  Union of GENERAL_REGS and FP_REGS\n    ADDR_FP_REGS     Union of ADDR_REGS and FP_REGS\n- \n+\n    NO_REGS          No registers\n    ALL_REGS         All registers\n- \n+\n    Note that the 'fake' frame pointer and argument pointer registers\n    are included amongst the address registers here.  The condition\n    code register is only included in ALL_REGS.  */\n@@ -539,7 +543,7 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n \n \n /* Stack layout and calling conventions.  */\n- \n+\n /* Our stack grows from higher to lower addresses.  However, local variables\n    are accessed by positive offsets, and function arguments are stored at\n    increasing addresses.  */\n@@ -569,15 +573,15 @@ extern int current_function_outgoing_args_size;\n    the argument area.  */\n #define FIRST_PARM_OFFSET(FNDECL) 0\n \n-/* The return address of the current frame is retrieved \n+/* The return address of the current frame is retrieved\n    from the initial value of register RETURN_REGNUM.\n    For frames farther back, we use the stack slot where\n    the corresponding RETURN_REGNUM register was saved.  */\n \n #define DYNAMIC_CHAIN_ADDRESS(FRAME)\t\t\t\t\t\t\\\n   ((FRAME) != hard_frame_pointer_rtx ? (FRAME) :\t\t\t\t\\\n    plus_constant (arg_pointer_rtx, -STACK_POINTER_OFFSET))\n-     \n+\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\t\\\n   s390_return_addr_rtx ((COUNT), DYNAMIC_CHAIN_ADDRESS ((FRAME)))\n \n@@ -586,7 +590,7 @@ extern int current_function_outgoing_args_size;\n \n \n /* Exception handling.  */\n- \n+\n /* Describe calling conventions for DWARF-2 exception handling.  */\n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, RETURN_REGNUM)\n #define INCOMING_FRAME_SP_OFFSET STACK_POINTER_OFFSET\n@@ -612,8 +616,8 @@ extern int current_function_outgoing_args_size;\n #define HARD_FRAME_POINTER_REGNUM 11\n #define ARG_POINTER_REGNUM 32\n \n-/* The static chain must be call-clobbered, but not used for \n-   function argument passing.  As register 1 is clobbered by \n+/* The static chain must be call-clobbered, but not used for\n+   function argument passing.  As register 1 is clobbered by\n    the trampoline code, we only have one option.  */\n #define STATIC_CHAIN_REGNUM 0\n \n@@ -633,7 +637,7 @@ extern int current_function_outgoing_args_size;\n {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n  { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},    \\\n  { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n- { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}  \n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n \n #define CAN_ELIMINATE(FROM, TO) (1)\n \n@@ -654,7 +658,7 @@ extern int current_function_outgoing_args_size;\n \n \n /* Stack arguments.  */\n- \n+\n /* We need current_function_outgoing_args to be valid.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n@@ -663,7 +667,7 @@ extern int current_function_outgoing_args_size;\n \n \n /* Register arguments.  */\n- \n+\n typedef struct s390_arg_structure\n {\n   int gprs;\t\t\t/* gpr so far */\n@@ -692,7 +696,7 @@ CUMULATIVE_ARGS;\n \n \n /* Scalar return values.  */\n- \n+\n /* We return scalars in general purpose register 2 for integral values,\n    and floating point register 0 for fp values.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n@@ -726,7 +730,7 @@ CUMULATIVE_ARGS;\n \n \n /* Function entry and exit.  */\n- \n+\n /* When returning from a function, the stack pointer does not matter.  */\n #define EXIT_IGNORE_STACK       1\n \n@@ -763,7 +767,7 @@ CUMULATIVE_ARGS;\n \n \n /* Library calls.  */\n- \n+\n /* We should use memcpy, not bcopy.  */\n #define TARGET_MEM_FUNCTIONS\n \n@@ -790,7 +794,7 @@ CUMULATIVE_ARGS;\n #define REG_OK_FOR_INDEX_NONSTRICT_P(X)   \t\\\n ((GET_MODE (X) == Pmode) &&\t\t\t\\\n  ((REGNO (X) >= FIRST_PSEUDO_REGISTER) \t\t\\\n-  || REGNO_REG_CLASS (REGNO (X)) == ADDR_REGS))  \n+  || REGNO_REG_CLASS (REGNO (X)) == ADDR_REGS))\n \n #define REG_OK_FOR_BASE_NONSTRICT_P(X)    REG_OK_FOR_INDEX_NONSTRICT_P (X)\n \n@@ -860,7 +864,7 @@ CUMULATIVE_ARGS;\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n #define SELECT_CC_MODE(OP, X, Y) s390_select_ccmode ((OP), (X), (Y))\n- \n+\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n@@ -933,7 +937,7 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n \n /* Position independent code.  */\n \n-extern int flag_pic; \n+extern int flag_pic;\n \n #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 12 : INVALID_REGNUM)\n \n@@ -1087,7 +1091,7 @@ extern int s390_nr_constants;\n #define CASE_VECTOR_MODE (TARGET_64BIT ? DImode : SImode)\n \n /* Load from integral MODE < SI from memory into register makes sign_extend\n-   or zero_extend  \n+   or zero_extend\n    In our case sign_extension happens for Halfwords, other no extension.  */\n #define LOAD_EXTEND_OP(MODE) \t\t\t\t\t\\\n (TARGET_64BIT ? ((MODE) == QImode ? ZERO_EXTEND :               \\\n@@ -1103,11 +1107,14 @@ extern int s390_nr_constants;\n    between pointers and any other objects of this machine mode.  */\n #define Pmode ((enum machine_mode) (TARGET_64BIT ? DImode : SImode))\n \n+/* This is -1 for \"pointer mode\" extend.  See ptr_extend in s390.md.  */\n+#define POINTERS_EXTEND_UNSIGNED -1\n+\n /* A function address in a call instruction is a byte address (for\n    indexing purposes) so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n \n /* This macro definition sets up a default value for `main' to return.  */\n #define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n \n-#endif \n+#endif"}, {"sha": "a82476f030368a2ef71c7bd36083510dd7caa553", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 171, "deletions": 150, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c745338420c2c26df126dc69c27f6c506ecb8bf7/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=c745338420c2c26df126dc69c27f6c506ecb8bf7", "patch": "@@ -115,7 +115,7 @@\n \t\t     fmuld,fmuls,fdivd,fdivs,\n \t\t     ftoi,itof,fsqrtd,fsqrts,\n                      other,o2,o3\"\n-  (const_string \"integer\")) \n+  (const_string \"integer\"))\n \n ;; Operand type. Used to default length attribute values\n \n@@ -147,7 +147,7 @@\n          (eq_attr \"op_type\" \"SIY\") (const_string \"agen\")]\n   (const_string \"reg\")))\n \n-;; Generic pipeline function unit.  \n+;; Generic pipeline function unit.\n \n (define_function_unit \"integer\" 1 0\n   (eq_attr \"type\" \"none\") 0 0)\n@@ -286,11 +286,11 @@\n ;   CCU:  Equal    ULess     UGreater  --           (CL, CLR, CLI, CLM)\n ;   CCS:  Equal    SLess     SGreater  --           (C, CR, CH, CHI, ICM)\n ;   CCT:  Zero     Mixed     Mixed     Ones         (TM, TMH, TML)\n- \n+\n ;   CCZ  -> CCL / CCZ1\n ;   CCZ1 -> CCA/CCU/CCS/CCT\n ;   CCS  -> CCA\n- \n+\n ;   String:    CLC, CLCL, CLCLE, CLST, CUSE, MVCL, MVCLE, MVPG, MVST, SRST\n ;   Clobber:   CKSM, CFC, CS, CDS, CUUTF, CUTFU, PLO, SPM, STCK, STCKE, TS, TRT, TRE, UPT\n \n@@ -357,7 +357,7 @@\n                                   (match_operand:DI 2 \"const_int_operand\" \"n\"))\n                  (const_int 0)))]\n   \"s390_match_ccmode(insn, CCTmode) && TARGET_64BIT\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0 \n+   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n    && INTVAL (operands[1]) + INTVAL (operands[2]) <= 64\n    && (INTVAL (operands[1]) + INTVAL (operands[2]) - 1) >> 4\n       == INTVAL (operands[2]) >> 4\"\n@@ -387,7 +387,7 @@\n                                   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n                  (const_int 0)))]\n   \"s390_match_ccmode(insn, CCTmode)\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0 \n+   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n    && INTVAL (operands[1]) + INTVAL (operands[2]) <= 32\n    && (INTVAL (operands[1]) + INTVAL (operands[2]) - 1) >> 4\n       == INTVAL (operands[2]) >> 4\"\n@@ -415,7 +415,7 @@\n                                   (match_operand:SI 2 \"const_int_operand\" \"n,n\"))\n                  (const_int 0)))]\n   \"s390_match_ccmode(insn, CCTmode)\n-   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0 \n+   && INTVAL (operands[1]) >= 1 && INTVAL (operands[2]) >= 0\n    && INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\"\n   \"*\n {\n@@ -442,7 +442,7 @@\n   int part = s390_single_qi (operands[1], DImode, 0);\n   operands[1] = GEN_INT (s390_extract_qi (operands[1], DImode, part));\n \n-  operands[0] = gen_rtx_MEM (QImode, \n+  operands[0] = gen_rtx_MEM (QImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), part));\n   return which_alternative == 0 ? \\\"tm\\\\t%0,%b1\\\" : \\\"tmy\\\\t%0,%b1\\\";\n }\"\n@@ -460,7 +460,7 @@\n   int part = s390_single_qi (operands[1], SImode, 0);\n   operands[1] = GEN_INT (s390_extract_qi (operands[1], SImode, part));\n \n-  operands[0] = gen_rtx_MEM (QImode, \n+  operands[0] = gen_rtx_MEM (QImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), part));\n   return which_alternative == 0 ? \\\"tm\\\\t%0,%b1\\\" : \\\"tmy\\\\t%0,%b1\\\";\n }\"\n@@ -478,7 +478,7 @@\n   int part = s390_single_qi (operands[1], HImode, 0);\n   operands[1] = GEN_INT (s390_extract_qi (operands[1], HImode, part));\n \n-  operands[0] = gen_rtx_MEM (QImode, \n+  operands[0] = gen_rtx_MEM (QImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), part));\n   return which_alternative == 0 ? \\\"tm\\\\t%0,%b1\\\" : \\\"tmy\\\\t%0,%b1\\\";\n }\"\n@@ -749,7 +749,7 @@\n    cghi\\\\t%0,%c1\n    cg\\\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE,RI,RXY\")])\n-   \n+\n (define_insn \"*cmpsi_ccs_sign\"\n   [(set (reg 33)\n         (compare (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"R,T\"))\n@@ -771,7 +771,7 @@\n    c\\\\t%0,%1\n    cy\\\\t%0,%1\"\n   [(set_attr \"op_type\" \"RR,RI,RX,RXY\")])\n-   \n+\n \n ; Compare (unsigned) instructions\n \n@@ -1045,7 +1045,7 @@\n   /* During and after reload, we need to force constants\n      to the literal pool ourselves, if necessary.  */\n   if ((reload_in_progress || reload_completed)\n-      && CONSTANT_P (operands[1]) \n+      && CONSTANT_P (operands[1])\n       && (!legitimate_reload_constant_p (operands[1])\n           || FP_REG_P (operands[0])))\n     operands[1] = force_const_mem (DImode, operands[1]);\n@@ -1085,7 +1085,7 @@\n (define_insn \"*movdi_lay\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (match_operand:DI 1 \"address_operand\" \"p\"))]\n-  \"TARGET_64BIT \n+  \"TARGET_64BIT\n    && TARGET_LONG_DISPLACEMENT\n    && GET_CODE (operands[1]) == CONST_INT\n    && !FP_REG_P (operands[0])\"\n@@ -1216,8 +1216,8 @@\n   if (!TARGET_64BIT && SYMBOLIC_CONST (operands[1]))\n     emit_symbolic_move (operands);\n \n-  /* expr.c tries to load an effective address using \n-     force_reg.  This fails because we don't have a \n+  /* expr.c tries to load an effective address using\n+     force_reg.  This fails because we don't have a\n      generic load_address pattern.  Convert the move\n      to a proper arithmetic operation instead, unless\n      it is guaranteed to be OK.  */\n@@ -1232,7 +1232,7 @@\n   /* During and after reload, we need to force constants\n      to the literal pool ourselves, if necessary.  */\n   if ((reload_in_progress || reload_completed)\n-      && CONSTANT_P (operands[1]) \n+      && CONSTANT_P (operands[1])\n       && (!legitimate_reload_constant_p (operands[1])\n           || FP_REG_P (operands[0])))\n     operands[1] = force_const_mem (SImode, operands[1]);\n@@ -1658,7 +1658,7 @@\n     (set_attr \"type\"    \"lm\")])\n \n ;\n-; store multiple pattern(s). \n+; store multiple pattern(s).\n ;\n \n (define_expand \"store_multiple\"\n@@ -1708,7 +1708,7 @@\n       if (to == frame_pointer_rtx || to == arg_pointer_rtx)\n \tFAIL;\n     }\n-  else\t\n+  else\n     {\n       to = force_reg (Pmode, XEXP (operands[0], 0));\n       off = 0;\n@@ -1993,7 +1993,7 @@\n    (use (match_operand:DI 3 \"general_operand\" \"\"))\n    (use (match_operand:DI 4 \"\" \"\"))]\n   \"TARGET_64BIT\"\n-  \"s390_expand_cmpmem (operands[0], operands[1], \n+  \"s390_expand_cmpmem (operands[0], operands[1],\n                        operands[2], operands[3]); DONE;\")\n \n (define_expand \"cmpmemsi\"\n@@ -2003,7 +2003,7 @@\n    (use (match_operand:SI 3 \"general_operand\" \"\"))\n    (use (match_operand:SI 4 \"\" \"\"))]\n   \"\"\n-  \"s390_expand_cmpmem (operands[0], operands[1], \n+  \"s390_expand_cmpmem (operands[0], operands[1],\n                        operands[2], operands[3]); DONE;\")\n \n ; Compare a block that is up to 256 bytes in length.\n@@ -2263,7 +2263,7 @@\n     {\n       operands[1] = gen_lowpart (DImode, operands[1]);\n       emit_insn (gen_ashldi3 (operands[0], operands[1], GEN_INT (48)));\n-      emit_insn (gen_ashrdi3 (operands[0], operands[0], GEN_INT (48))); \n+      emit_insn (gen_ashrdi3 (operands[0], operands[0], GEN_INT (48)));\n       DONE;\n     }\n }\n@@ -2297,7 +2297,7 @@\n     {\n       operands[1] = gen_lowpart (DImode, operands[1]);\n       emit_insn (gen_ashldi3 (operands[0], operands[1], GEN_INT (56)));\n-      emit_insn (gen_ashrdi3 (operands[0], operands[0], GEN_INT (56))); \n+      emit_insn (gen_ashrdi3 (operands[0], operands[0], GEN_INT (56)));\n       DONE;\n     }\n }\n@@ -2334,7 +2334,7 @@\n {\n   operands[1] = gen_lowpart (SImode, operands[1]);\n   emit_insn (gen_ashlsi3 (operands[0], operands[1], GEN_INT (16)));\n-  emit_insn (gen_ashrsi3 (operands[0], operands[0], GEN_INT (16))); \n+  emit_insn (gen_ashrsi3 (operands[0], operands[0], GEN_INT (16)));\n   DONE;\n }\n \")\n@@ -2360,7 +2360,7 @@\n {\n   operands[1] = gen_lowpart (SImode, operands[1]);\n   emit_insn (gen_ashlsi3 (operands[0], operands[1], GEN_INT (24)));\n-  emit_insn (gen_ashrsi3 (operands[0], operands[0], GEN_INT (24))); \n+  emit_insn (gen_ashrsi3 (operands[0], operands[0], GEN_INT (24)));\n   DONE;\n }\n \")\n@@ -2439,7 +2439,7 @@\n     {\n       operands[1] = gen_lowpart (DImode, operands[1]);\n       emit_insn (gen_ashldi3 (operands[0], operands[1], GEN_INT (48)));\n-      emit_insn (gen_lshrdi3 (operands[0], operands[0], GEN_INT (48))); \n+      emit_insn (gen_lshrdi3 (operands[0], operands[0], GEN_INT (48)));\n       DONE;\n     }\n }\n@@ -2473,7 +2473,7 @@\n     {\n       operands[1] = gen_lowpart (DImode, operands[1]);\n       emit_insn (gen_ashldi3 (operands[0], operands[1], GEN_INT (56)));\n-      emit_insn (gen_lshrdi3 (operands[0], operands[0], GEN_INT (56))); \n+      emit_insn (gen_lshrdi3 (operands[0], operands[0], GEN_INT (56)));\n       DONE;\n     }\n }\n@@ -2522,7 +2522,7 @@\n      (clobber (reg:CC 33))])]\n   \"operands[2] = gen_lowpart (HImode, operands[0]);\"\n   [(set_attr \"atype\" \"agen\")])\n- \n+\n ;\n ; zero_extendqisi2 instruction pattern(s).\n ;\n@@ -2556,7 +2556,7 @@\n    (set (strict_low_part (match_dup 2)) (match_dup 1))]\n   \"operands[2] = gen_lowpart (QImode, operands[0]);\"\n   [(set_attr \"atype\" \"agen\")])\n- \n+\n ;\n ; zero_extendqihi2 instruction pattern(s).\n ;\n@@ -2607,7 +2607,7 @@\n   rtx temp = gen_reg_rtx (DFmode);\n   operands[1] = force_reg (DFmode, operands[1]);\n \n-  emit_insn (gen_cmpdf (operands[1], \n+  emit_insn (gen_cmpdf (operands[1],\n \tCONST_DOUBLE_FROM_REAL_VALUE (\n           REAL_VALUE_ATOF (\\\"9223372036854775808.0\\\", DFmode), DFmode)));\n   emit_jump_insn (gen_blt (label1));\n@@ -2659,7 +2659,7 @@\n   rtx temp = gen_reg_rtx (DFmode);\n \n   operands[1] = force_reg (DFmode,operands[1]);\n-  emit_insn (gen_cmpdf (operands[1], \n+  emit_insn (gen_cmpdf (operands[1],\n \tCONST_DOUBLE_FROM_REAL_VALUE (\n           REAL_VALUE_ATOF (\\\"2147483648.0\\\", DFmode), DFmode)));\n   emit_jump_insn (gen_blt (label1));\n@@ -2681,7 +2681,7 @@\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n-  if (TARGET_IBM_FLOAT) \n+  if (TARGET_IBM_FLOAT)\n     {\n       /* This is the algorithm from POP chapter A.5.7.2.  */\n \n@@ -2690,10 +2690,10 @@\n       rtx two32  = s390_gen_rtx_const_DI (0x4e000001, 0x00000000);\n \n       operands[1] = force_reg (DFmode, operands[1]);\n-      emit_insn (gen_fix_truncdfsi2_ibm (operands[0], operands[1], \n+      emit_insn (gen_fix_truncdfsi2_ibm (operands[0], operands[1],\n \t\t\t\t\t two31r, two32, temp));\n-    } \n-  else \n+    }\n+  else\n     {\n       operands[1] = force_reg (DFmode, operands[1]);\n       emit_insn (gen_fix_truncdfsi2_ieee (operands[0], operands[1], GEN_INT (5)));\n@@ -2748,7 +2748,7 @@\n   rtx temp = gen_reg_rtx (SFmode);\n \n   operands[1] = force_reg (SFmode, operands[1]);\n-  emit_insn (gen_cmpsf (operands[1], \n+  emit_insn (gen_cmpsf (operands[1],\n \tCONST_DOUBLE_FROM_REAL_VALUE (\n           REAL_VALUE_ATOF (\\\"9223372036854775808.0\\\", SFmode), SFmode)));\n   emit_jump_insn (gen_blt (label1));\n@@ -2887,12 +2887,12 @@\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n-  if (TARGET_IBM_FLOAT) \n+  if (TARGET_IBM_FLOAT)\n     {\n       /* This is the algorithm from POP chapter A.5.7.1.  */\n \n       rtx temp  = assign_stack_local (BLKmode, 2 * UNITS_PER_WORD, BITS_PER_WORD);\n-      rtx two31 = s390_gen_rtx_const_DI (0x4e000000, 0x80000000);\t   \n+      rtx two31 = s390_gen_rtx_const_DI (0x4e000000, 0x80000000);\n \n       emit_insn (gen_floatsidf2_ibm (operands[0], operands[1], two31, temp));\n       DONE;\n@@ -3024,7 +3024,7 @@\n   [(set_attr \"op_type\"  \"NN,NN\")\n    (set_attr \"atype\"    \"reg,agen\")\n    (set_attr \"length\"   \"4,6\")\n-   (set_attr \"type\"     \"o2,o2\")]) \n+   (set_attr \"type\"     \"o2,o2\")])\n \n \n ;;\n@@ -3054,7 +3054,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*adddi3_zero_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:DI (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,m\"))\n                           (match_operand:DI 1 \"register_operand\" \"0,0\"))\n                  (const_int 0)))\n@@ -3067,7 +3067,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*adddi3_zero_cconly\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:DI (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,m\"))\n                           (match_operand:DI 1 \"register_operand\" \"0,0\"))\n                  (const_int 0)))\n@@ -3090,20 +3090,20 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*adddi3_imm_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n                           (match_operand:DI 2 \"const_int_operand\" \"K\"))\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (plus:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\t \n-   && s390_match_ccmode (insn, CCAmode) \n+  \"TARGET_64BIT\n+   && s390_match_ccmode (insn, CCAmode)\n    && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n   \"aghi\\\\t%0,%h2\"\n   [(set_attr \"op_type\"  \"RI\")])\n \n (define_insn \"*adddi3_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n                           (match_operand:DI 2 \"general_operand\" \"d,m\"))\n                  (const_int 0)))\n@@ -3116,7 +3116,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*adddi3_cconly\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n                           (match_operand:DI 2 \"general_operand\" \"d,m\"))\n                  (const_int 0)))\n@@ -3128,7 +3128,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*adddi3_cconly2\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n                  (neg:SI (match_operand:DI 2 \"general_operand\" \"d,m\"))))\n    (clobber (match_scratch:DI 0 \"=d,d\"))]\n@@ -3239,13 +3239,13 @@\n   DONE;\n }\")\n \n- \n+\n ;\n ; addsi3 instruction pattern(s).\n ;\n \n (define_insn \"*addsi3_imm_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n                           (match_operand:SI 2 \"const_int_operand\" \"K\"))\n                  (const_int 0)))\n@@ -3257,88 +3257,88 @@\n   [(set_attr \"op_type\"  \"RI\")])\n \n (define_insn \"*addsi3_carry1_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                           (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (match_dup 1)))\n    (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n         (plus:SI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode (insn, CCL1mode)\" \n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alr\\\\t%0,%2\n    al\\\\t%0,%2\n    aly\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n (define_insn \"*addsi3_carry1_cconly\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                           (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (match_dup 1)))\n    (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n-  \"s390_match_ccmode (insn, CCL1mode)\" \n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alr\\\\t%0,%2\n    al\\\\t%0,%2\n    aly\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n (define_insn \"*addsi3_carry2_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                           (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (match_dup 2)))\n    (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n         (plus:SI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode (insn, CCL1mode)\" \n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alr\\\\t%0,%2\n    al\\\\t%0,%2\n    aly\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n (define_insn \"*addsi3_carry2_cconly\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                           (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (match_dup 2)))\n    (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n-  \"s390_match_ccmode (insn, CCL1mode)\" \n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alr\\\\t%0,%2\n    al\\\\t%0,%2\n    aly\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n (define_insn \"*addsi3_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                           (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n         (plus:SI (match_dup 1) (match_dup 2)))]\n-  \"s390_match_ccmode (insn, CCLmode)\" \n+  \"s390_match_ccmode (insn, CCLmode)\"\n   \"@\n    alr\\\\t%0,%2\n    al\\\\t%0,%2\n    aly\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n (define_insn \"*addsi3_cconly\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                           (match_operand:SI 2 \"general_operand\" \"d,R,T\"))\n                  (const_int 0)))\n    (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n-  \"s390_match_ccmode (insn, CCLmode)\" \n+  \"s390_match_ccmode (insn, CCLmode)\"\n   \"@\n    alr\\\\t%0,%2\n    al\\\\t%0,%2\n    aly\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX,RXY\")])\n \n (define_insn \"*addsi3_cconly2\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0\")\n                  (neg:SI (match_operand:SI 2 \"general_operand\" \"d,R,T\"))))\n    (clobber (match_scratch:SI 0 \"=d,d,d\"))]\n@@ -3439,7 +3439,7 @@\n   \"!TARGET_64BIT\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 0) \n+  [(set (match_dup 0)\n         (and:SI (match_dup 1) (const_int 2147483647)))]\n   \"\"\n   [(set_attr \"op_type\"  \"RX\")\n@@ -3563,7 +3563,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*subdi3_zero_cc\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n                            (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,m\")))\n                  (const_int 0)))\n@@ -3576,7 +3576,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn \"*subdi3_zero_cconly\"\n-  [(set (reg 33) \n+  [(set (reg 33)\n         (compare (minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n                            (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"d,m\")))\n                  (const_int 0)))\n@@ -3910,17 +3910,17 @@\n   insn = emit_insn (gen_mulsi_6432 (operands[0], operands[0], operands[2]));\n \n   REG_NOTES (insn) =\n-\tgen_rtx_EXPR_LIST (REG_EQUAL, \n-                           gen_rtx_MULT (DImode, \n+\tgen_rtx_EXPR_LIST (REG_EQUAL,\n+                           gen_rtx_MULT (DImode,\n \t\t\t\tgen_rtx_SIGN_EXTEND (DImode, operands[1]),\n \t\t\t\tgen_rtx_SIGN_EXTEND (DImode, operands[2])),\n \t\t\t   REG_NOTES (insn));\n   DONE;\n }\")\n- \n+\n (define_insn \"mulsi_6432\"\n    [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-         (mult:DI (sign_extend:DI \n+         (mult:DI (sign_extend:DI\n \t            (truncate:SI (match_operand:DI 1 \"register_operand\" \"0,0\")))\n                   (sign_extend:DI\n \t            (match_operand:SI 2 \"nonimmediate_operand\" \"d,R\"))))]\n@@ -3930,7 +3930,7 @@\n     m\\\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR,RX\")\n    (set_attr \"type\"     \"imul\")])\n- \n+\n ;\n ; muldf3 instruction pattern(s).\n ;\n@@ -4061,7 +4061,7 @@\n                     (match_operand:DI 2 \"general_operand\" \"d,m\")))\n           (ashift:TI\n             (zero_extend:TI\n-              (mod:DI (truncate:DI (match_dup 1)) \n+              (mod:DI (truncate:DI (match_dup 1))\n                       (match_dup 2)))\n             (const_int 64))))]\n   \"TARGET_64BIT\"\n@@ -4079,7 +4079,7 @@\n                     (sign_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"d,m\"))))\n           (ashift:TI\n             (zero_extend:TI\n-              (mod:DI (truncate:DI (match_dup 1)) \n+              (mod:DI (truncate:DI (match_dup 1))\n                       (sign_extend:DI (match_dup 2))))\n             (const_int 64))))]\n   \"TARGET_64BIT\"\n@@ -4134,7 +4134,7 @@\n \n (define_insn \"udivmodtidi3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=d,d\")\n-        (ior:TI (zero_extend:TI \n+        (ior:TI (zero_extend:TI\n                   (truncate:DI\n                     (udiv:TI (match_operand:TI 1 \"register_operand\" \"0,0\")\n                              (zero_extend:TI\n@@ -4197,7 +4197,7 @@\n         (ior:DI (zero_extend:DI\n                   (truncate:SI\n                     (div:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n-                            (sign_extend:DI \n+                            (sign_extend:DI\n                               (match_operand:SI 2 \"nonimmediate_operand\" \"d,R\")))))\n                 (ashift:DI\n                   (zero_extend:DI\n@@ -4251,32 +4251,32 @@\n         }\n       else\n         {\n-          operands[2] = force_reg (SImode, operands[2]);\t\n-          operands[2] = make_safe_from (operands[2], operands[0]);\t\n+          operands[2] = force_reg (SImode, operands[2]);\n+          operands[2] = make_safe_from (operands[2], operands[0]);\n \n \t  emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n \t  insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n \t\t\t\t\t     operands[2]));\n \t  REG_NOTES (insn) =\n \t    gen_rtx_EXPR_LIST (REG_EQUAL, equal, REG_NOTES (insn));\n-\t  \n-\t  insn = emit_move_insn (operands[0], \n+\n+\t  insn = emit_move_insn (operands[0],\n \t\t\t\t gen_lowpart (SImode, operands[3]));\n \t  REG_NOTES (insn) =\n-\t    gen_rtx_EXPR_LIST (REG_EQUAL, \n+\t    gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t       udiv_equal, REG_NOTES (insn));\n         }\n     }\n   else\n-    {  \n+    {\n       rtx label1 = gen_label_rtx ();\n       rtx label2 = gen_label_rtx ();\n       rtx label3 = gen_label_rtx ();\n \n-      operands[1] = force_reg (SImode, operands[1]);\t\n-      operands[1] = make_safe_from (operands[1], operands[0]);\t\n-      operands[2] = force_reg (SImode, operands[2]);\t\n-      operands[2] = make_safe_from (operands[2], operands[0]);\t\n+      operands[1] = force_reg (SImode, operands[1]);\n+      operands[1] = make_safe_from (operands[1], operands[0]);\n+      operands[2] = force_reg (SImode, operands[2]);\n+      operands[2] = make_safe_from (operands[2], operands[0]);\n \n       emit_move_insn (operands[0], const0_rtx);\n       emit_insn (gen_cmpsi (operands[2], operands[1]));\n@@ -4290,11 +4290,11 @@\n \t\t\t\t\t operands[2]));\n       REG_NOTES (insn) =\n       gen_rtx_EXPR_LIST (REG_EQUAL, equal, REG_NOTES (insn));\n-      \n-      insn = emit_move_insn (operands[0], \n+\n+      insn = emit_move_insn (operands[0],\n \t\t\t     gen_lowpart (SImode, operands[3]));\n       REG_NOTES (insn) =\n-      gen_rtx_EXPR_LIST (REG_EQUAL, \n+      gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t       udiv_equal, REG_NOTES (insn));\n       emit_jump (label3);\n       emit_label (label1);\n@@ -4304,7 +4304,7 @@\n       emit_move_insn (operands[0], const1_rtx);\n       emit_label (label3);\n     }\n-  emit_move_insn (operands[0], operands[0]);\t\n+  emit_move_insn (operands[0], operands[0]);\n   DONE;\n }\")\n \n@@ -4344,19 +4344,19 @@\n         }\n       else\n         {\n-          operands[2] = force_reg (SImode, operands[2]);\t\n-          operands[2] = make_safe_from (operands[2], operands[0]);\t\n+          operands[2] = force_reg (SImode, operands[2]);\n+          operands[2] = make_safe_from (operands[2], operands[0]);\n \n \t  emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n \t  insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n \t\t\t\t\t     operands[2]));\n \t  REG_NOTES (insn) =\n \t    gen_rtx_EXPR_LIST (REG_EQUAL, equal, REG_NOTES (insn));\n-\t  \n-\t  insn = emit_move_insn (operands[0], \n+\n+\t  insn = emit_move_insn (operands[0],\n \t\t\t\t gen_highpart (SImode, operands[3]));\n \t  REG_NOTES (insn) =\n-\t    gen_rtx_EXPR_LIST (REG_EQUAL, \n+\t    gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t       umod_equal, REG_NOTES (insn));\n         }\n     }\n@@ -4366,12 +4366,12 @@\n       rtx label2 = gen_label_rtx ();\n       rtx label3 = gen_label_rtx ();\n \n-      operands[1] = force_reg (SImode, operands[1]);\t\n-      operands[1] = make_safe_from (operands[1], operands[0]);\t\n-      operands[2] = force_reg (SImode, operands[2]);\t\n-      operands[2] = make_safe_from (operands[2], operands[0]);\t\n+      operands[1] = force_reg (SImode, operands[1]);\n+      operands[1] = make_safe_from (operands[1], operands[0]);\n+      operands[2] = force_reg (SImode, operands[2]);\n+      operands[2] = make_safe_from (operands[2], operands[0]);\n \n-      emit_move_insn(operands[0], operands[1]);\t\n+      emit_move_insn(operands[0], operands[1]);\n       emit_insn (gen_cmpsi (operands[2], operands[1]));\n       emit_jump_insn (gen_bgtu (label3));\n       emit_insn (gen_cmpsi (operands[2], const1_rtx));\n@@ -4383,11 +4383,11 @@\n \t\t\t\t\t operands[2]));\n       REG_NOTES (insn) =\n       gen_rtx_EXPR_LIST (REG_EQUAL, equal, REG_NOTES (insn));\n-      \n-      insn = emit_move_insn (operands[0], \n+\n+      insn = emit_move_insn (operands[0],\n \t\t\t     gen_highpart (SImode, operands[3]));\n       REG_NOTES (insn) =\n-      gen_rtx_EXPR_LIST (REG_EQUAL, \n+      gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t umod_equal, REG_NOTES (insn));\n       emit_jump (label3);\n       emit_label (label1);\n@@ -5422,7 +5422,7 @@\n ;\n ; one_cmpldi2 instruction pattern(s).\n ;\n- \n+\n (define_expand \"one_cmpldi2\"\n   [(parallel\n     [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -5431,11 +5431,11 @@\n      (clobber (reg:CC 33))])]\n   \"TARGET_64BIT\"\n   \"\")\n- \n+\n ;\n ; one_cmplsi2 instruction pattern(s).\n ;\n- \n+\n (define_expand \"one_cmplsi2\"\n   [(parallel\n     [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -5444,11 +5444,11 @@\n      (clobber (reg:CC 33))])]\n   \"\"\n   \"\")\n- \n+\n ;\n ; one_cmplhi2 instruction pattern(s).\n ;\n- \n+\n (define_expand \"one_cmplhi2\"\n   [(parallel\n     [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -5457,11 +5457,11 @@\n      (clobber (reg:CC 33))])]\n   \"\"\n   \"\")\n- \n+\n ;\n ; one_cmplqi2 instruction pattern(s).\n ;\n- \n+\n (define_expand \"one_cmplqi2\"\n   [(parallel\n     [(set (match_operand:QI 0 \"register_operand\" \"\")\n@@ -5529,7 +5529,7 @@\n   \"!TARGET_64BIT\"\n   \"@\n    sldl\\\\t%0,%c2\n-   sldl\\\\t%0,0(%2)\"     \n+   sldl\\\\t%0,0(%2)\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n \n@@ -5567,7 +5567,7 @@\n   \"!TARGET_64BIT && s390_match_ccmode(insn, CCSmode)\"\n   \"@\n    srda\\\\t%0,%c2\n-   srda\\\\t%0,0(%2)\"     \n+   srda\\\\t%0,0(%2)\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n \n@@ -5580,7 +5580,7 @@\n   \"!TARGET_64BIT && s390_match_ccmode(insn, CCSmode)\"\n   \"@\n    srda\\\\t%0,%c2\n-   srda\\\\t%0,0(%2)\"     \n+   srda\\\\t%0,0(%2)\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n \n@@ -5592,10 +5592,10 @@\n   \"!TARGET_64BIT\"\n   \"@\n    srda\\\\t%0,%c2\n-   srda\\\\t%0,0(%2)\"     \n+   srda\\\\t%0,0(%2)\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")])\n- \n+\n (define_insn \"*ashrdi3_cc_64\"\n   [(set (reg 33)\n         (compare (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d,d\")\n@@ -5718,7 +5718,7 @@\n   \"!TARGET_64BIT\"\n   \"@\n    srdl\\\\t%0,%c2\n-   srdl\\\\t%0,0(%2)\"     \n+   srdl\\\\t%0,0(%2)\"\n    [(set_attr \"op_type\"  \"RS,RS\")\n     (set_attr \"atype\"    \"reg\")])\n \n@@ -5922,7 +5922,7 @@\n \n (define_insn \"cjump\"\n  [(set (pc)\n-       (if_then_else \n+       (if_then_else\n          (match_operator 1 \"comparison_operator\" [(reg 33) (const_int 0)])\n \t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))]\n@@ -5960,7 +5960,7 @@\n   else\n     return \\\"b%C1\\\\t%a0\\\";\n }\"\n-  [(set (attr \"op_type\") \n+  [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n    (set_attr \"type\"    \"branch\")\n@@ -5975,11 +5975,11 @@\n  [(set (pc)\n        (if_then_else\n          (match_operator 1 \"comparison_operator\" [(reg 33) (const_int 0)])\n-         (pc) \n+         (pc)\n \t (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n   \"*\n-{  \n+{\n   if (get_attr_length (insn) == 4)\n     return \\\"j%D1\\\\t%l0\\\";\n   else if (TARGET_64BIT)\n@@ -6011,7 +6011,7 @@\n   else\n     return \\\"b%D1\\\\t%a0\\\";\n }\"\n-  [(set (attr \"op_type\") \n+  [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n    (set_attr \"type\"  \"branch\")\n@@ -6038,10 +6038,10 @@\n {\n    enum machine_mode ccmode;\n \n-   if (operands[1] != const0_rtx) FAIL;\t\n+   if (operands[1] != const0_rtx) FAIL;\n \n-   ccmode = s390_select_ccmode (GET_CODE (operands[0]), \n-\t\t\t        s390_compare_op0, s390_compare_op1);    \n+   ccmode = s390_select_ccmode (GET_CODE (operands[0]),\n+\t\t\t        s390_compare_op0, s390_compare_op1);\n    operands[2] = gen_rtx_REG (ccmode, 33);\n    operands[3] = gen_rtx_COMPARE (ccmode, s390_compare_op0, s390_compare_op1);\n }\")\n@@ -6059,7 +6059,7 @@\n ;;\n ;;  This is all complicated by the fact that since this is a jump insn\n ;;  we must handle our own output reloads.\n- \n+\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n    (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n@@ -6129,7 +6129,7 @@\n   else\n     return \\\"bct\\\\t%1,%a0\\\";\n }\"\n-  [(set (attr \"op_type\") \n+  [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n    (set_attr \"type\"  \"branch\")\n@@ -6205,7 +6205,7 @@\n   else\n     return \\\"bctg\\\\t%1,%a0\\\";\n }\"\n-  [(set (attr \"op_type\") \n+  [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RRE\") (const_string \"RXE\")))\n    (set_attr \"type\"  \"branch\")\n@@ -6279,7 +6279,7 @@\n   else\n     return \\\"b\\\\t%a0\\\";\n }\"\n-  [(set (attr \"op_type\") \n+  [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n    (set_attr \"type\"  \"branch\")\n@@ -6300,7 +6300,7 @@\n   else\n     return \\\"b\\\\t%a0\\\";\n }\"\n-  [(set (attr \"op_type\") \n+  [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n    (set_attr \"type\"  \"branch\")\n@@ -6422,7 +6422,7 @@\n           sym = gen_rtx_CONST (Pmode, sym);\n         }\n \n-      /* Unless we can use the bras(l) insn, force the \n+      /* Unless we can use the bras(l) insn, force the\n          routine address into a register.  */\n       if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n \t{\n@@ -6532,7 +6532,7 @@\n           sym = gen_rtx_CONST (Pmode, sym);\n         }\n \n-      /* Unless we can use the bras(l) insn, force the \n+      /* Unless we can use the bras(l) insn, force the\n          routine address into a register.  */\n       if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n         {\n@@ -6667,7 +6667,7 @@\n    sar\\\\t%%a0,%0\n    lam\\\\t%%a0,%%a0,%0\"\n   [(set_attr \"op_type\" \"RRE,RS\")])\n-  \n+\n (define_insn \"*tls_load_64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")\n@@ -6704,7 +6704,7 @@\n   sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n   sym = gen_rtx_CONST (Pmode, sym);\n \n-  /* Unless we can use the bras(l) insn, force the \n+  /* Unless we can use the bras(l) insn, force the\n      routine address into a register.  */\n   if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n     {\n@@ -6828,7 +6828,7 @@\n     rtx stack = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);\n     rtx chain = gen_rtx (MEM, Pmode, stack);\n     rtx temp = gen_reg_rtx (Pmode);\n-\t\n+\n     emit_move_insn (temp, chain);\n \n     if (TARGET_64BIT)\n@@ -6838,7 +6838,7 @@\n \n     emit_move_insn (chain, temp);\n \n-    emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\t\n+    emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n     DONE;\n }\")\n \n@@ -6980,7 +6980,7 @@\n ;\n \n (define_insn \"consttable_qi\"\n-  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"X\")] \n+  [(unspec_volatile [(match_operand:QI 0 \"consttable_operand\" \"X\")]\n \t\t    UNSPECV_POOL_QI)]\n   \"\"\n {\n@@ -6991,7 +6991,7 @@\n    (set_attr \"length\"   \"1\")])\n \n (define_insn \"consttable_hi\"\n-  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"X\")] \n+  [(unspec_volatile [(match_operand:HI 0 \"consttable_operand\" \"X\")]\n \t\t    UNSPECV_POOL_HI)]\n   \"\"\n {\n@@ -7002,23 +7002,23 @@\n    (set_attr \"length\"   \"2\")])\n \n (define_insn \"consttable_si\"\n-  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"X\")] \n+  [(unspec_volatile [(match_operand:SI 0 \"consttable_operand\" \"X\")]\n \t\t    UNSPECV_POOL_SI)]\n   \"\"\n   \".long\\t%0\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"4\")])\n \n (define_insn \"consttable_di\"\n-  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"X\")] \n+  [(unspec_volatile [(match_operand:DI 0 \"consttable_operand\" \"X\")]\n \t\t    UNSPECV_POOL_DI)]\n   \"\"\n   \".quad\\t%0\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"8\")])\n \n (define_insn \"consttable_ti\"\n-  [(unspec_volatile [(match_operand:TI 0 \"consttable_operand\" \"X\")] \n+  [(unspec_volatile [(match_operand:TI 0 \"consttable_operand\" \"X\")]\n \t\t    UNSPECV_POOL_TI)]\n   \"\"\n {\n@@ -7029,7 +7029,7 @@\n    (set_attr \"length\"   \"16\")])\n \n (define_insn \"consttable_sf\"\n-  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"X\")] \n+  [(unspec_volatile [(match_operand:SF 0 \"consttable_operand\" \"X\")]\n \t\t    UNSPECV_POOL_SF)]\n   \"\"\n {\n@@ -7144,7 +7144,7 @@\n   \"!TARGET_64BIT\"\n   \"br\\\\t%0\"\n   [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\t\t\n+   (set_attr \"type\"    \"jsr\")\n    (set_attr \"atype\"   \"agen\")])\n \n (define_insn \"*return_di\"\n@@ -7153,47 +7153,68 @@\n   \"TARGET_64BIT\"\n   \"br\\\\t%0\"\n   [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\t\t\n+   (set_attr \"type\"    \"jsr\")\n    (set_attr \"atype\"   \"agen\")])\n \n (define_insn \"literal_pool_31\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)\n-   (set (match_operand:SI 0 \"register_operand\" \"=a\") \n-        (label_ref (match_operand 1 \"\" \"\")))\t\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (label_ref (match_operand 1 \"\" \"\")))\n    (use (label_ref (match_operand 2 \"\" \"\")))]\n   \"\"\n {\n-   if (s390_nr_constants) \n+   if (s390_nr_constants)\n      {\n        output_asm_insn (\"bras\\\\t%0,%2\", operands);\n        s390_output_constant_pool (operands[1], operands[2]);\n-     } \n+     }\n    else if (flag_pic)\n      {\n         /* We need the anchor label in any case.  */\n         (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n                                            CODE_LABEL_NUMBER (operands[1]));\n      }\n \n-   return \"\";\t\n+   return \"\";\n }\n   [(set_attr \"op_type\" \"NN\")\n    (set_attr \"type\"    \"larl\")])\n \n (define_insn \"literal_pool_64\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)\n-   (set (match_operand:DI 0 \"register_operand\" \"=a\") \n-        (label_ref (match_operand 1 \"\" \"\")))\t\n+   (set (match_operand:DI 0 \"register_operand\" \"=a\")\n+        (label_ref (match_operand 1 \"\" \"\")))\n    (use (label_ref (match_operand 2 \"\" \"\")))]\n   \"\"\n {\n-   if (s390_nr_constants) \n+   if (s390_nr_constants)\n      {\n        output_asm_insn (\"larl\\\\t%0,%1\", operands);\n        s390_output_constant_pool (operands[1], operands[2]);\n      }\n \n-   return \"\";\t\n+   return \"\";\n }\n   [(set_attr \"op_type\" \"NN\")\n    (set_attr \"type\"    \"larl\")])\n+\n+;; Instruction definition to extend a 31-bit pointer into a 64-bit\n+;; pointer. This is used for compatability.\n+\n+(define_expand \"ptr_extend\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"register_operand\" \"r\"))]\n+   \"\"\n+   \"\n+{\n+ /*\n+  emit_insn (gen_zero_extendsidi2 (operands[0], operands[1]));\n+  emit_insn (gen_anddi3 (operands[0], operands[0], GEN_INT (0x7fffffff)));\n+  */\n+\n+  emit_insn (gen_anddi3 (operands[0],\n+\t\t\t gen_lowpart (DImode, operands[1]),\n+\t\t\t GEN_INT (0x7fffffff)));\n+\n+  DONE;\n+}\")"}]}