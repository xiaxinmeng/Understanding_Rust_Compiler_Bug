{"sha": "d996473d67640a8bae9576749d70c53667e515ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk5NjQ3M2Q2NzY0MGE4YmFlOTU3Njc0OWQ3MGM1MzY2N2U1MTVhZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-02-12T20:52:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-02-12T20:52:37Z"}, "message": "dwarf2out.c (round_up_to_align): New static function.\n\n\t* dwarf2out.c (round_up_to_align): New static function.\n\t(field_byte_offset): Use it to round the offset.\n\nFrom-SVN: r121859", "tree": {"sha": "8a4a7fc6e1537501b30e5b819c28bc1552cee7fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4a7fc6e1537501b30e5b819c28bc1552cee7fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d996473d67640a8bae9576749d70c53667e515ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d996473d67640a8bae9576749d70c53667e515ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d996473d67640a8bae9576749d70c53667e515ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d996473d67640a8bae9576749d70c53667e515ae/comments", "author": null, "committer": null, "parents": [{"sha": "ffcce7bcd8e288e0608ef8af05c501a5cf44a44b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffcce7bcd8e288e0608ef8af05c501a5cf44a44b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffcce7bcd8e288e0608ef8af05c501a5cf44a44b"}], "stats": {"total": 33, "additions": 27, "deletions": 6}, "files": [{"sha": "e7a3bf3966b073ba98360804b9f0357e3ff852dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d996473d67640a8bae9576749d70c53667e515ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d996473d67640a8bae9576749d70c53667e515ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d996473d67640a8bae9576749d70c53667e515ae", "patch": "@@ -1,3 +1,8 @@\n+2007-02-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dwarf2out.c (round_up_to_align): New static function.\n+\t(field_byte_offset): Use it to round the offset.\n+\n 2007-02-12  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.md (bswapsi2, bswapdi2): New."}, {"sha": "92e14e541c3aefc363bbdf4e125986ac84af3c07", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d996473d67640a8bae9576749d70c53667e515ae/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d996473d67640a8bae9576749d70c53667e515ae/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d996473d67640a8bae9576749d70c53667e515ae", "patch": "@@ -9626,6 +9626,24 @@ simple_decl_align_in_bits (tree decl)\n   return (TREE_CODE (decl) != ERROR_MARK) ? DECL_ALIGN (decl) : BITS_PER_WORD;\n }\n \n+/* Return the result of rounding T up to ALIGN.  */\n+\n+static inline HOST_WIDE_INT\n+round_up_to_align (HOST_WIDE_INT t, unsigned int align)\n+{\n+  /* We must be careful if T is negative because HOST_WIDE_INT can be\n+     either \"above\" or \"below\" unsigned int as per the C promotion\n+     rules, depending on the host, thus making the signedness of the\n+     direct multiplication and division unpredictable.  */\n+  unsigned HOST_WIDE_INT u = (unsigned HOST_WIDE_INT) t;\n+\n+  u += align - 1;\n+  u /= align;\n+  u *= align;\n+\n+  return (HOST_WIDE_INT) u;\n+}\n+\n /* Given a pointer to a FIELD_DECL, compute and return the byte offset of the\n    lowest addressed byte of the \"containing object\" for the given FIELD_DECL,\n    or return 0 if we are unable to determine what that offset is, either\n@@ -9725,19 +9743,17 @@ field_byte_offset (tree decl)\n   object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n \n   /* Round up to type_align by default.  This works best for bitfields.  */\n-  object_offset_in_bits += type_align_in_bits - 1;\n-  object_offset_in_bits /= type_align_in_bits;\n-  object_offset_in_bits *= type_align_in_bits;\n+  object_offset_in_bits\n+    = round_up_to_align (object_offset_in_bits, type_align_in_bits);\n \n   if (object_offset_in_bits > bitpos_int)\n     {\n       /* Sigh, the decl must be packed.  */\n       object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n \n       /* Round up to decl_align instead.  */\n-      object_offset_in_bits += decl_align_in_bits - 1;\n-      object_offset_in_bits /= decl_align_in_bits;\n-      object_offset_in_bits *= decl_align_in_bits;\n+      object_offset_in_bits\n+\t= round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n     }\n \n   return object_offset_in_bits / BITS_PER_UNIT;"}]}