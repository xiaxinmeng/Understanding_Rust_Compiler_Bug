{"sha": "5e3b99538d552be301a13a7fd552163d9e7dd5ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUzYjk5NTM4ZDU1MmJlMzAxYTEzYTdmZDU1MjE2M2Q5ZTdkZDVhZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:16:55Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:16:55Z"}, "message": "Initial revision\n\nFrom-SVN: r477", "tree": {"sha": "4aa4081b17c663e7af93a9fabeab0ab947d03253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aa4081b17c663e7af93a9fabeab0ab947d03253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e3b99538d552be301a13a7fd552163d9e7dd5ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3b99538d552be301a13a7fd552163d9e7dd5ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3b99538d552be301a13a7fd552163d9e7dd5ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3b99538d552be301a13a7fd552163d9e7dd5ae/comments", "author": null, "committer": null, "parents": [{"sha": "96d3e8f1a4cecd5711fb465e59657371f38f501e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d3e8f1a4cecd5711fb465e59657371f38f501e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d3e8f1a4cecd5711fb465e59657371f38f501e"}], "stats": {"total": 1018, "additions": 1018, "deletions": 0}, "files": [{"sha": "aec2c4bfd173b3280120e84dcaf3b4f82448110b", "filename": "gcc/config/tahoe/tahoe.h", "status": "added", "additions": 1018, "deletions": 0, "changes": 1018, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3b99538d552be301a13a7fd552163d9e7dd5ae/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3b99538d552be301a13a7fd552163d9e7dd5ae/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.h?ref=5e3b99538d552be301a13a7fd552163d9e7dd5ae", "patch": "@@ -0,0 +1,1018 @@\n+/* Definitions of target machine for GNU compiler.  Tahoe version.\n+   Copyright (C) 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/*\n+ * File: tahoe.h\n+ *\n+ * Original port made at the University of Buffalo by Devon Bowen,\n+ * Dale Wiles and Kevin Zachmann.\n+ *\n+ * HCX/UX version by Piet van Oostrum (piet@cs.ruu.nl)\n+ *\n+ * Performance hacking by Michael Tiemann (tiemann@lurch.stanford.edu)\n+ *\n+ * Mail bugs reports or fixes to:\tgcc@cs.buffalo.edu\n+ */\n+\n+/* define this for the HCX/UX version */\n+\n+/* #define HCX_UX */\n+\n+/*\n+ * Run-time Target Specification\n+ */\n+\n+#ifdef HCX_UX\n+/* no predefines, see Makefile and hcx-universe.c */\n+/* have cc1 print that this is the hcx version */\n+#define TARGET_VERSION printf (\" (hcx)\");\n+#else\n+/* we want \"tahoe\" and \"unix\" defined for all future compilations */\n+#define CPP_PREDEFINES \"-Dtahoe -Dunix\"\n+/* have cc1 print that this is the tahoe version */\n+#define TARGET_VERSION printf (\" (tahoe)\");\n+#endif\n+\n+/* this is required in all tm files to hold flags */\n+\n+extern int target_flags;\n+\n+/* Zero if it is safe to output .dfloat and .float pseudos.  */\n+#define TARGET_HEX_FLOAT (target_flags & 1)\n+\n+#define TARGET_DEFAULT 1\n+\n+#define TARGET_SWITCHES\t\t\\\n+  { {\"hex-float\", 1},\t\t\\\n+    {\"no-hex-float\", -1},\t\\\n+    { \"\", TARGET_DEFAULT} }\n+\f\n+\n+/*\n+ * Storage Layout\n+ */\n+\n+/* This symbol was previously not mentioned, so apparently the tahoe\n+   is little-endian for bits, or else doesn't care.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* tahoe uses a big endian byte order */\n+\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* tahoe uses a big endian word order */\n+\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* standard byte size is usable on tahoe */\n+\n+#define BITS_PER_UNIT 8\n+\n+/* longs on the tahoe are 4 byte groups */\n+\n+#define BITS_PER_WORD 32\n+\n+/* from the last two params we get 4 bytes per word */\n+\n+#define UNITS_PER_WORD 4\n+\n+/* addresses are 32 bits (one word) */\n+\n+#define POINTER_SIZE 32\n+\n+/* all parameters line up on 32 boundaries */\n+\n+#define PARM_BOUNDARY 32\n+\n+/* stack should line up on 32 boundaries */\n+\n+#define STACK_BOUNDARY 32\n+\n+/* line functions up on 32 bits */\n+\n+#define FUNCTION_BOUNDARY 32\n+\n+/* the biggest alignment the tahoe needs in 32 bits */\n+\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* we have to align after an 'int : 0' in a structure */\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+#ifdef HCX_UX\n+/* structures must be made of full words */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+#else\n+/* structures must be made of full bytes */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+#endif\n+\n+/* tahoe is picky about data alignment */\n+\n+#define STRICT_ALIGNMENT 1\n+\n+/* keep things standard with pcc */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* this section is borrowed from the vax version since the */\n+/* formats are the same in both of the architectures\t   */\n+\n+#define CHECK_FLOAT_VALUE(mode, d) \\\n+  if ((mode) == SFmode) \\\n+    { \\\n+      if ((d) > 1.7014117331926443e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = 1.7014117331926443e+38; } \\\n+      else if ((d) < -1.7014117331926443e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = -1.7014117331926443e+38; } \\\n+      else if (((d) > 0) && ((d) < 2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+      else if (((d) < 0) && ((d) > -2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+    }\n+\n+\n+/*\n+ * Register Usage\n+ */\n+\n+/* define 15 general regs plus one for the floating point reg (FPP) */\n+\n+#define FIRST_PSEUDO_REGISTER 17\n+\n+/* let the compiler know what the fp, sp and pc are */\n+\n+#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0}\n+\n+/* lots of regs aren't guaranteed to return from a call. The FPP reg */\n+/* must be included in these since it can't be saved by the reg mask */\n+\n+#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+\n+/* A single fp reg can handle any type of float.\n+   CPU regs hold just 32 bits.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+ (REGNO != 16 ? ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)  \\\n+  : GET_MODE_NUNITS ((MODE)))\n+\n+/* any mode greater than 4 bytes (doubles) can only go in an even regs */\n+/* and the FPP can only hold SFmode and DFmode \t\t\t       */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+ (REGNO != 16\t\t\t\t\t\t\t\\\n+  ? (GET_MODE_UNIT_SIZE (MODE) <= 4 ? 1 : (REGNO % 2 - 1))\t\\\n+  : ((MODE) == SFmode || (MODE) == DFmode\t\t\t\\\n+     || (MODE) == SCmode || (MODE) == DCmode))\n+\n+/* if mode1 or mode2, but not both, are doubles then modes cannot be tied */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+ (((MODE1) == DFmode || (MODE1) == DCmode)\t\\\n+  == ((MODE2) == DFmode || (MODE2) == DCmode))\n+\n+/* return nonzero if register variable of mode MODE is not\n+   a priori a bad idea.  Used only if defined.  */\n+#define MODE_OK_FOR_USERVAR(MODE)\t\\\n+  ((MODE) == SImode)\n+\n+/* the program counter is reg 15 */\n+\n+#define PC_REGNUM 15\n+\n+/* the stack pointer is reg 14 */\n+\n+#define STACK_POINTER_REGNUM 14\n+\n+/* the frame pointer is reg 13 */\n+\n+#define FRAME_POINTER_REGNUM 13\n+\n+/* tahoe does require an fp */\n+\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* since tahoe doesn't have a argument pointer, make it the fp */\n+\n+#define ARG_POINTER_REGNUM 13\n+\n+/* this isn't currently used since C doesn't support this feature */\n+\n+#define STATIC_CHAIN_REGNUM 0\n+\n+/* we'll use reg 1 for structure passing cause the destination */\n+/* of the eventual movblk requires it to be there anyway.      */\n+\n+#define STRUCT_VALUE_REGNUM 1\n+\n+\n+/*\n+ * Register Classes\n+ */\n+\n+/* tahoe has two types of regs. GENERAL_REGS are all the regs up */\n+/* to number 15. FPP_REG is the special floating point processor  */\n+/* register class (only one reg).\t\t\t\t  */\n+\n+enum reg_class {NO_REGS,GENERAL_REGS,FPP_REG,ALL_REGS,LIM_REG_CLASSES};\n+\n+/* defines the number of reg classes.\t\t\t\t    */\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* this defines what the classes are officially named for debugging */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\",\"GENERAL_REGS\",\"FPP_REG\",\"ALL_REGS\"}\n+\n+/* set general regs to be the first 16 regs and the fpp reg to be 17th */\n+\n+#define REG_CLASS_CONTENTS {0,0xffff,0x10000,0x1ffff}\n+\n+/* register class for the fpp reg is FPP_REG, all others are GENERAL_REGS */\n+\n+#define REGNO_REG_CLASS(REGNO) (REGNO == 16 ? FPP_REG : GENERAL_REGS)\n+\n+/* only gereral registers can be used as a base reg */\n+\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* only gereral registers can be used to index */\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+\n+/* 'a' as a constraint in the md file means the FFP_REG class */\n+\n+#define REG_CLASS_FROM_LETTER(C) (C == 'a' ? FPP_REG : NO_REGS)\n+\n+/* any general reg but the fpp can be a base reg */\n+\n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+((regno) < FIRST_PSEUDO_REGISTER - 1 || reg_renumber[regno] >= 0)\n+\n+/* any general reg except the pc and fpp can be an index reg */\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)  \\\n+((regno) < FIRST_PSEUDO_REGISTER - 2 || reg_renumber[regno] >= 0)\n+\n+/* if your loading a floating point constant, it can't be done */\n+/* through a register. Force it to be a memory constant.       */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+\t((GET_CODE (X) == CONST_DOUBLE) ? NO_REGS : CLASS)\n+\n+/* for the fpp reg, all modes fit; for any others, you need two for doubles */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ (CLASS != FPP_REG ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) : 1)\n+\n+/* we don't define any special constant sizes so all should fail */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+/* we don't define any special double sizes so all should fail */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+\n+/*\n+ * Describing Stack Layout\n+ */\n+\n+/* tahoe stack grows from high to low memory */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if longjmp restores from saved registers\n+   rather than from what setjmp saved.  */\n+#define LONGJMP_RESTORE_FROM_STACK\n+\n+/* tahoe call frames grow from high to low memory on the stack */\n+\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* the tahoe fp points to the *top* of the frame instead of the   */\n+/* bottom, so we have to make this offset a constant large enough */\n+/* to jump over the biggest frame possible.\t\t\t  */\n+\n+#define STARTING_FRAME_OFFSET -52\n+\n+/* tahoe always pushes 4 bytes unless it's a double in which case */\n+/* it pushes a full 8 bytes.\t\t\t\t\t  */\n+\n+#define PUSH_ROUNDING(BYTES) (BYTES <= 4 ? 4 : 8)\n+\n+/* the first parameter in a function is at the fp + 4 */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 4\n+\n+/* the tahoe return function takes care of everything on the stack */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) (SIZE)\n+\n+/* function values for all types are returned in register 0 */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* libarary routines also return things in reg 0 */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+\n+/* Tahoe doesn't return structures in a reentrant way */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* we only return values from a function in reg 0 */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* we never pass args through a register */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+/* int is fine to hold the argument summary in FUNCTION_ARG */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* we just set CUM to 0 before the FUNCTION_ARG call. No matter what */\n+/* we make it, FUNCTION_ARG will return 0 anyway\t\t     */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* all modes push their size rounded to the nearest word boundary */\n+/* except block which is the size of the block rounded up\t  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* this is always false since we never pass params in regs */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\n+/* this code calculates the register entry mask and sets up    */\n+/* the stack pointer for the function. The stack is set down   */\n+/* far enough from the fp to jump over any push regs and local */\n+/* vars. This is a problem since the tahoe has the fp pointing */\n+/* to the top of the frame and the compiler must know the off- */\n+/* set off the fp to the local vars.\t\t\t       */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER-1; regno++)\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+       mask |= 1 << regno;\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.word 0x%x\\n\", mask);\t\t\t\\\n+  if (SIZE != 0) fprintf (FILE, \"\\tsubl3 $%d,fp,sp\\n\", (SIZE) - STARTING_FRAME_OFFSET); }\n+\n+/* Zero out global variable in case it was used in this function.  */\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\t\\\n+{ extern rtx tahoe_reg_conversion_loc;\t\t\t\t\\\n+  tahoe_reg_conversion_loc = 0;\t\t\t\t\t\\\n+}\n+\n+#ifdef HCX_UX\n+\n+/* to call the profiler, the address of the counter var is placed */\n+/* on the stack and then passed into mcount this way\t\t\t  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tpushal LP%d\\n\\tcallf $8,mcount\\n\", (LABELNO));\n+\n+#else\n+\n+/* to call the profiler, push the variable value onto the stack */\n+/* and call mcount like a regular function.\t\t\t*/\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tpushl $LP%d\\n\\tcallf $8,mcount\\n\", (LABELNO));\n+\n+#endif\n+\n+/* all stack handling at the end of a function is handled by the */\n+/* return command.\t\t\t\t\t\t */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/*\n+ * Library Subroutine Names\n+ */\n+\n+/* udiv is a valid C library routine in libc.a, so we call that */\n+\n+#define UDIVSI3_LIBCALL \"*udiv\"\n+\n+/* urem is a valid C library routine in libc.a, so we call that */\n+/* but not so on hcx/ux */\n+\n+#ifdef HCX_UX\n+#undef UMODSI3_LIBCALL\n+#else\n+#define UMODSI3_LIBCALL \"*urem\"\n+#endif\n+\n+\n+/*\n+ * Addressing Modes\n+ */\n+\n+/* constant addresses can be treated exactly the same as normal constants */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* we can have as many as two regs in any given address */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* The following is all the code for GO_IF_LEGITIMATE_ADDRESS */\n+/* most of this taken directly from the vax tm file since the */\n+/* tahoe and vax addressing modes are nearly identical.\t      */\n+\n+/* Is x an indirectable address? */\n+\n+#define INDIRECTABLE_ADDRESS_P(X)  \\\n+  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+       && CONSTANT_ADDRESS_P (XEXP (X, 1))))\n+\n+/* If x is a non-indexed-address, go to ADDR. */\n+\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if (GET_CODE (xfoob) == REG) goto ADDR;\t\t\t\t\\\n+  if (INDIRECTABLE_ADDRESS_P (xfoob)) goto ADDR;\t\t\t\\\n+  xfoob = XEXP (X, 0);\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == MEM && INDIRECTABLE_ADDRESS_P (xfoob))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n+      && GET_CODE (xfoob) == REG && REGNO (xfoob) == 14)\t\t\\\n+    goto ADDR; }\n+\n+/* Is PROD an index term in mode MODE. */\n+\n+#define INDEX_TERM_P(PROD, MODE)   \\\n+(GET_MODE_SIZE (MODE) == 1\t\t\t\t\t\t\\\n+ ? (GET_CODE (PROD) == REG && REG_OK_FOR_BASE_P (PROD))\t\t\t\\\n+ : (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n+    &&\t\t\t\t\t\t\t\t\t\\\n+    (xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\t\\\n+     ((GET_CODE (xfoo0) == CONST_INT\t\t\t\t\t\\\n+       && INTVAL (xfoo0) == GET_MODE_SIZE (MODE)\t\t\t\\\n+       && GET_CODE (xfoo1) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_INDEX_P (xfoo1))\t\t\t\t\t\\\n+      ||\t\t\t\t\t\t\t\t\\\n+      (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n+       && INTVAL (xfoo1) == GET_MODE_SIZE (MODE)\t\t\t\\\n+       && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_INDEX_P (xfoo0))))))\n+\n+/* Is the addition to the index a reg? */\n+\n+#define GO_IF_REG_PLUS_INDEX(X, MODE, ADDR)\t\\\n+{ register rtx xfooa;\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && (xfooa = XEXP (X, 1),\t\t\t\t\t\\\n+\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n+\t  && (xfooa = XEXP (X, 0),\t\t\t\t\t\\\n+\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n+\tgoto ADDR; } }\n+\n+/* Is the rtx X a valid memoy address for operand of mode MODE? */\n+/* If it is, go to ADDR */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ register rtx xfoo, xfoo0, xfoo1;\t\t\t\t\t\\\n+  GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n+\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 1), ADDR); }\t\t\\\n+      xfoo = XEXP (X, 1);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n+\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 0), ADDR); }\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\t\t\\\n+\t{ if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 1), MODE, ADDR); }\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\t\\\n+\t{ if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 0), MODE, ADDR); } } }\n+\n+/* Register 16 can never be used for index or base */\n+\n+#ifndef REG_OK_STRICT\n+#define REG_OK_FOR_INDEX_P(X) (REGNO(X) != 16)\n+#define REG_OK_FOR_BASE_P(X) (REGNO(X) != 16)\n+#else\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#endif\n+\n+/* Addressing is too simple to allow optimizing here */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Post_inc and pre_dec always adds 4 */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ { if (GET_CODE(ADDR) == POST_INC || GET_CODE(ADDR) == PRE_DEC)\t\t\\\n+       goto LABEL;\t\t\t\t\t\t\t\\\n+   if (GET_CODE (ADDR) == PLUS)\t\t\t\t\t\t\\\n+     { if (CONSTANT_ADDRESS_P (XEXP (ADDR, 0))\t\t\t\t\\\n+\t   && GET_CODE (XEXP (ADDR, 1)) == REG);\t\t\t\\\n+       else if (CONSTANT_ADDRESS_P (XEXP (ADDR, 1))\t\t\t\\\n+\t\t&& GET_CODE (XEXP (ADDR, 0)) == REG);\t\t\t\\\n+       else goto LABEL; }}\n+\n+/* Double's are not legitimate as immediate operands */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE (X) != CONST_DOUBLE)\n+\n+\n+/*\n+ * Miscellaneous Parameters\n+ */\n+\n+/* the elements in the case jump table are all words */\n+\n+#define CASE_VECTOR_MODE HImode\n+\n+/* each of the table elements in a case are relative to the jump address */\n+\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* tahoe case instructions just fall through to the next instruction */\n+/* if not satisfied. It doesn't support a default action\t     */\n+\n+#define CASE_DROPS_THROUGH\n+\n+/* the standard answer is given here and work ok */\n+\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* in a general div case, it's easiest to use TRUNC_DIV_EXPR */\n+\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* the standard seems to be leaving char's as signed so we left it */\n+/* this way even though we think they should be unsigned!\t   */\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* the most we can move without cutting down speed is 4 bytes */\n+\n+#define MOVE_MAX 4\n+\n+/* our int is 32 bits */\n+\n+#define INT_TYPE_SIZE 32\n+\n+/* byte access isn't really slower than anything else */\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* zero extension is more than one instruction so try to avoid it */\n+\n+#define SLOW_ZERO_EXTEND\n+\n+/* any bits higher than the low 4 are ignored in the shift count */\n+/* so don't bother zero extending or sign extending them         */\n+\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* we don't need to officially convert from one fixed type to another */\n+/* in order to use it as that type. We can just assume it's the same  */\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* pass chars as ints */\n+\n+#define PROMOTE_PROTOTYPES\n+\n+/* pointers can be represented by an si mode expression */\n+\n+#define Pmode SImode\n+\n+/* function addresses are made by specifying a byte address */\n+\n+#define FUNCTION_MODE QImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   On the tahoe a call with a constant address is much faster than one with a\n+   register. */\n+\n+#define NO_FUNCTION_CSE\n+\n+/* specify the costs of various sorts of constants,\n+   and also indicate that multiplication is cheap on this machine.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    /* Constant zero is super cheap due to clr instruction.  */\t\\\n+    if (RTX == const0_rtx) return 0;\t\t\t\t\\\n+    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n+    if (INTVAL (RTX) <= 127 && INTVAL (RTX) >= -128) return 2;\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\t\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\\\n+    total = 2;\n+\n+\n+/*\n+ * Condition Code Information\n+ */\n+\n+/* Nonzero if the results of the previous comparison are\n+   in the floating point condition code register.  */\n+\n+#define CC_UNCHANGED 04000\n+\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{ if (cc_status.flags & CC_UNCHANGED)\t\t\t\t\\\n+    /* Happens for cvtld and a few other insns.  */\t\t\\\n+    cc_status.flags &= ~CC_UNCHANGED;\t\t\t\t\\\n+  else if (GET_CODE (EXP) == SET)\t\t\t\t\\\n+    { if (GET_CODE (SET_SRC (EXP)) == CALL)\t\t\t\\\n+\tCC_STATUS_INIT;\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (EXP)) != PC)\t\t\t\\\n+\t{ cc_status.flags = 0;\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n+\t  cc_status.value2 = SET_SRC (EXP); } }\t\t\t\\\n+  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n+\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET\t\t\\\n+\t   && GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) != PC)\t\\\n+    { cc_status.flags = 0;\t\t\t\t\t\\\n+      cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n+      cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0)); }\t\\\n+  /* PARALLELs whose first element sets the PC are aob, sob insns.\t\\\n+     They do change the cc's.  So drop through and forget the cc's.  */ \\\n+  else CC_STATUS_INIT;\t\t\t\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n+    cc_status.value2 = 0;\t\t\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && GET_CODE (cc_status.value2) == MEM)\t\t\t\\\n+    cc_status.value2 = 0; }\n+/* Actual condition, one line up, should be that value2's address\n+   depends on value1, but that is too much of a pain.  */\n+\n+\n+/*\n+ * Output of Assembler Code\n+ */\n+\n+/* print which tahoe version compiled this code and print a directive */\n+/* to the gnu assembler to say that the following is normal assembly  */\n+\n+#ifdef HCX_UX\n+#define ASM_FILE_START(FILE)\t\t\\\n+{ fprintf (FILE, \"#gcc hcx 1.0\\n\\n\");\t\\\n+  output_file_directive ((FILE), main_input_filename);} while (0)\n+#else\n+#define ASM_FILE_START(FILE) fprintf (FILE, \"#gcc tahoe 1.0\\n#NO_APP\\n\");\n+#endif\n+\n+/* the instruction that turns on the APP for the gnu assembler */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* the instruction that turns off the APP for the gnu assembler */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* what to output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* what to output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* this is what we call each of the regs. notice that the FPP reg is   */\n+/* called \"ac\". This should never get used due to the way we've set    */\n+/* up FPP instructions in the md file. But we call it \"ac\" here to     */\n+/* fill the list.\t\t\t\t\t\t       */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \\\n+ \"r9\", \"r10\", \"r11\", \"r12\", \"fp\", \"sp\", \"pc\", \"ac\"}\n+\n+#ifdef HCX_UX\n+/* allow generation of sdb info in the assembly */\n+#define SDB_DEBUGGING_INFO\n+#else\n+/* allow generation of dbx info in the assembly */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* our dbx doesn't support this */\n+\n+#define DBX_NO_XREFS\n+\n+/* we don't want symbols broken up */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* this'll really never be used, but we'll leave it at this */\n+\n+#define DBX_CONTIN_CHAR '?'\n+\n+#endif /* HCX_UX */\n+\n+/* registers are called the same thing in dbx anything else */\n+/* This is necessary even if we generate SDB output */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* labels are the label followed by a colon and a newline */\n+/* must be a statement, so surround it in a null loop     */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* use the .globl directive to make labels global for the linker */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* output a label by appending an underscore to it */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* use the standard format for printing internal labels */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* a * is used for label indirection in unix assembly */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* outputting a double is easy cause we only have one kind */\n+\n+#ifdef HCX_UX\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n+#else\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+{\t\t\t\t\t\t\t\\\n+  union { int i[2]; double d;} temp;\t\t\t\\\n+  temp.d = (VALUE);\t\t\t\t\t\\\n+  if (TARGET_HEX_FLOAT)\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t.long 0x%x,0x%x  # %.20e\\n\",\t\\\n+\t     temp.i[0], temp.i[1], temp.d);\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.dfloat 0d%.20e\\n\", temp.d);\t\\\n+}\n+#endif\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#ifdef HCX_UX\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n+#else\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+{\t\t\t\t\t\t\t\\\n+  union { int i; float f;} temp;\t\t\t\\\n+  temp.f = (float) (VALUE);\t\t\t\t\\\n+  if (TARGET_HEX_FLOAT)\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t.long 0x%x  # %.20e\\n\",\t\t\\\n+\t     temp.i, temp.f);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.float 0f%.20e\\n\", temp.f);\t\\\n+}\n+#endif\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#ifdef HCX_UX\n+/* This is how to output an assembler line for an ASCII string.  */\n+\n+#define ASM_OUTPUT_ASCII(FILE, p, size)  \t\t\\\n+{\tregister int i;\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\t.ascii \\\"\"); \t\t\\\n+\t  for (i = 0; i < (size); i++) \t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t      register int c = (p)[i];\t\t\t\\\n+\t      if (c == '\\'' || c == '\\\\')\t\t\\\n+\t\tputc ('\\\\', (FILE));\t\t\t\\\n+\t      if (c >= ' ' && c < 0177 && c != '\\\"')\t\\\n+\t\tputc (c, (FILE));\t\t\t\\\n+\t      else\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\\%03o\", c);\t\\\n+\t\t}\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\\"\\n\"); }\n+#endif\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* this is the insn to push a register onto the stack */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\\\n+  fprintf (FILE, \"\\tpushl %s\\n\", reg_names[REGNO])\n+\n+/* this is the insn to pop a register from the stack */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\\\n+  fprintf (FILE, \"\\tmovl (sp)+,%s\\n\", reg_names[REGNO])\n+\n+/* this is required even thought tahoe doesn't support it */\n+/* cause the C code expects it to be defined\t\t  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#ifdef HCX_UX\n+#define CASE_ALIGNMENT 2\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n+#else\n+#define CASE_ALIGNMENT 1\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  LOG ? fprintf (FILE, \"\\t.align %d\\n\", (LOG)) : 0\n+#endif\n+\n+/* This is how to skip over some space */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n+\n+/* This defines common variables across files */\n+\n+#ifdef HCX_UX\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+#else\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+#endif\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#ifdef HCX_UX\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.bss \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u,4\\n\", (SIZE),(ROUNDED)))\n+#else\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+#endif\n+\n+/* code to generate a label */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'.\n+   On the Vax, the only code used is `#', indicating that either\n+   `d' or `g' should be printed, depending on whether we're using dfloat\n+   or gfloat.  */\n+/* Print an operand.  Some difference from the vax code,\n+   since the tahoe can't support immediate floats and doubles.\n+\n+   %@ means print the proper alignment operand for aligning after a casesi.\n+   This depends on the assembler syntax.\n+   This is 1 for our assembler, since .align is logarithmic.\n+\n+   %s means the number given is supposed to be a shift value, but on\n+   the tahoe it should be converted to a number that can be used as a\n+   multiplicative constant (cause multiplication is a whole lot faster\n+   than shifting). So make the number 2^n instead. */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '@')\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '@')\t\t\t\t\t\t\t\\\n+    putc ('0' + CASE_ALIGNMENT, FILE);\t\t\t\t\t\\\n+  else if (CODE == 's')\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"$%d\", 1 << INTVAL(X));\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+\n+/* When the operand is an address, call print_operand_address to */\n+/* do the work from output-tahoe.c.\t\t\t\t */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+ print_operand_address (FILE, ADDR)\n+\n+/* This is for G++ */\n+\n+#define CRT0_DUMMIES\n+#define DOT_GLOBAL_START\n+#ifdef HCX_UX\n+#define NO_GNU_LD /* because of COFF format */\n+#define LINK_SPEC \"-L/usr/staff/lib\"\n+#endif"}]}