{"sha": "3462aa02a699dc716bd366fee8fc1c85f7f94541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ2MmFhMDJhNjk5ZGM3MTZiZDM2NmZlZThmYzFjODVmN2Y5NDU0MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-08T16:42:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-08T16:42:21Z"}, "message": "devirt-11.C: Update template.\n\n\t* testsuite/g++.dg/ipa/devirt-11.C: Update template.\n\t* testsuite/g++.dg/ipa/devirt-16.C: New testcase.\n\t* testsuite/g++.dg/ipa/devirt-17.C: New testcase.\n\t* testsuite/g++.dg/ipa/devirt-18.C: New testcase.\n\n\t* cgraphunit.c (walk_polymorphic_call_targets): Permit 0 possible\n\ttargets and devirtualize to BUILT_IN_UNREACHABLE.\n\t* timevar.def (TV_IPA_UNREACHABLE): New timevar.\n\t* ipa.c (walk_polymorphic_call_targets): New function.\n\t(symtab_remove_unreachable_nodes): Use it; do not keep all virtual\n\tfunctions; use the new timevar.\n\t* ipa-devirt.c (maybe_record_node): Do not insert static nodes that\n\twas removed from the program.\n\t(record_binfo): If BINFO corresponds to an anonymous namespace, we may\n\tnot consider it in the walk when its vtable is dead.\n\t(possible_polymorphic_call_targets_1): Pass anonymous flag to\n\trecord_binfo.\n\t(devirt_variable_node_removal_hook): New function.\n\t(possible_polymorphic_call_targets): Also register\n\tdevirt_variable_node_removal_hook.\n\t(ipa_devirt): Do not do non-speculative devirtualization.\n\t(gate_ipa_devirt): One execute if devirtualizing speculatively.\n\nFrom-SVN: r202368", "tree": {"sha": "6aaf6ed20bc90f69bf381f4674ecd79f8abee69c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aaf6ed20bc90f69bf381f4674ecd79f8abee69c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3462aa02a699dc716bd366fee8fc1c85f7f94541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3462aa02a699dc716bd366fee8fc1c85f7f94541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3462aa02a699dc716bd366fee8fc1c85f7f94541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3462aa02a699dc716bd366fee8fc1c85f7f94541/comments", "author": null, "committer": null, "parents": [{"sha": "26e5b0fd2818c746fcd016bd1b6fa434204a5d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e5b0fd2818c746fcd016bd1b6fa434204a5d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e5b0fd2818c746fcd016bd1b6fa434204a5d72"}], "stats": {"total": 335, "additions": 297, "deletions": 38}, "files": [{"sha": "df3d29e530d36e9979d90af7c7d17052c6903e56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -1,3 +1,23 @@\n+2013-09-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (walk_polymorphic_call_targets): Permit 0 possible\n+\ttargets and devirtualize to BUILT_IN_UNREACHABLE.\n+\t* timevar.def (TV_IPA_UNREACHABLE): New timevar.\n+\t* ipa.c (walk_polymorphic_call_targets): New function.\n+\t(symtab_remove_unreachable_nodes): Use it; do not keep all virtual\n+\tfunctions; use the new timevar.\n+\t* ipa-devirt.c (maybe_record_node): Do not insert static nodes that\n+\twas removed from the program.\n+\t(record_binfo): If BINFO corresponds to an anonymous namespace, we may\n+\tnot consider it in the walk when its vtable is dead.\n+\t(possible_polymorphic_call_targets_1): Pass anonymous flag to\n+\trecord_binfo.\n+\t(devirt_variable_node_removal_hook): New function.\n+\t(possible_polymorphic_call_targets): Also register\n+\tdevirt_variable_node_removal_hook.\n+\t(ipa_devirt): Do not do non-speculative devirtualization.\n+\t(gate_ipa_devirt): One execute if devirtualizing speculatively.\n+\n 2013-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (varpool_node_hook, varpool_node_hook_list,"}, {"sha": "9681df518cda018b23c141b473035e511850ccfc", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -866,9 +866,15 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n      make the edge direct.  */\n   if (final)\n     {\n-      gcc_assert (targets.length());\n-      if (targets.length() == 1)\n+      if (targets.length() <= 1)\n \t{\n+\t  cgraph_node *target;\n+\t  if (targets.length () == 1)\n+\t    target = targets[0];\n+\t  else\n+\t    target = cgraph_get_create_node\n+\t\t       (builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n+\n \t  if (cgraph_dump_file)\n \t    {\n \t      fprintf (cgraph_dump_file,\n@@ -877,7 +883,7 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t\t\t\t edge->call_stmt, 0,\n \t\t\t\t TDF_SLIM);\n \t    }\n-\t  cgraph_make_edge_direct (edge, targets[0]);\n+\t  cgraph_make_edge_direct (edge, target);\n \t  cgraph_redirect_edge_call_stmt_to_callee (edge);\n \t  if (cgraph_dump_file)\n \t    {\n@@ -1092,7 +1098,7 @@ analyze_functions (void)\n      mangling and same body alias creation before we free DECL_ARGUMENTS\n      used by it.  */\n   if (!seen_error ())\n-  symtab_initialize_asm_name_hash ();\n+    symtab_initialize_asm_name_hash ();\n }\n \n /* Translate the ugly representation of aliases as alias pairs into nice"}, {"sha": "96622b25b1bdf1b7455819fbf5e38be605a06d79", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -570,6 +570,8 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n       && fcode != BUILT_IN_TRAP\n       && !pointer_set_insert (inserted, target)\n       && (target_node = cgraph_get_node (target)) != NULL\n+      && (TREE_PUBLIC (target)\n+\t  || target_node->symbol.definition)\n       && symtab_real_symbol_p ((symtab_node)target_node))\n     {\n       pointer_set_insert (cached_polymorphic_call_targets,\n@@ -591,6 +593,8 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \n    MATCHED_VTABLES tracks virtual tables we already did lookup\n    for virtual function in.\n+\n+   ANONYMOUS is true if BINFO is part of anonymous namespace.\n   */\n \n static void\n@@ -600,7 +604,8 @@ record_binfo (vec <cgraph_node *> &nodes,\n \t      tree type_binfo,\n \t      HOST_WIDE_INT otr_token,\n \t      pointer_set_t *inserted,\n-\t      pointer_set_t *matched_vtables)\n+\t      pointer_set_t *matched_vtables,\n+\t      bool anonymous)\n {\n   tree type = BINFO_TYPE (binfo);\n   int i;\n@@ -611,6 +616,19 @@ record_binfo (vec <cgraph_node *> &nodes,\n   if (types_same_for_odr (type, otr_type)\n       && !pointer_set_insert (matched_vtables, BINFO_VTABLE (type_binfo)))\n     {\n+      /* For types in anonymous namespace first check if the respective vtable\n+\t is alive. If not, we know the type can't be called.  */\n+      if (!flag_ltrans && anonymous)\n+\t{\n+\t  tree vtable = BINFO_VTABLE (type_binfo);\n+\t  struct varpool_node *vnode;\n+\n+\t  if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n+\t    vtable = TREE_OPERAND (TREE_OPERAND (vtable, 0), 0);\n+\t  vnode = varpool_get_node (vtable);\n+\t  if (!vnode || !vnode->symbol.definition)\n+\t    return;\n+\t}\n       tree target = gimple_get_virt_method_for_binfo (otr_token, type_binfo);\n       if (target)\n \tmaybe_record_node (nodes, target, inserted);\n@@ -626,7 +644,7 @@ record_binfo (vec <cgraph_node *> &nodes,\n \t\t       is shared with the outer type.  */\n \t\t    BINFO_VTABLE (base_binfo) ? base_binfo : type_binfo,\n \t\t    otr_token, inserted,\n-\t\t    matched_vtables);\n+\t\t    matched_vtables, anonymous);\n }\n      \n /* Lookup virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n@@ -646,7 +664,7 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n   unsigned int i;\n \n   record_binfo (nodes, binfo, otr_type, binfo, otr_token, inserted,\n-\t        matched_vtables);\n+\t        matched_vtables, type->anonymous_namespace);\n   for (i = 0; i < type->derived_types.length(); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,\n@@ -735,6 +753,18 @@ devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n     free_polymorphic_call_targets_hash ();\n }\n \n+/* When virtual table is removed, we may need to flush the cache.  */\n+\n+static void\n+devirt_variable_node_removal_hook (struct varpool_node *n,\n+\t\t\t\t   void *d ATTRIBUTE_UNUSED)\n+{\n+  if (cached_polymorphic_call_targets\n+      && DECL_VIRTUAL_P (n->symbol.decl)\n+      && type_in_anonymous_namespace_p (DECL_CONTEXT (n->symbol.decl)))\n+    free_polymorphic_call_targets_hash ();\n+}\n+\n /* Return vector containing possible targets of polymorphic call of type\n    OTR_TYPE caling method OTR_TOKEN with OFFSET.  If FINALp is non-NULL,\n    store true if the list is complette. \n@@ -782,8 +812,12 @@ possible_polymorphic_call_targets (tree otr_type,\n       cached_polymorphic_call_targets = pointer_set_create ();\n       polymorphic_call_target_hash.create (23);\n       if (!node_removal_hook_holder)\n-\tnode_removal_hook_holder =\n-\t  cgraph_add_node_removal_hook (&devirt_node_removal_hook, NULL);\n+\t{\n+\t  node_removal_hook_holder =\n+\t    cgraph_add_node_removal_hook (&devirt_node_removal_hook, NULL);\n+\t  varpool_add_node_removal_hook (&devirt_variable_node_removal_hook,\n+\t\t\t\t\t NULL);\n+\t}\n     }\n \n   /* Lookup cached answer.  */\n@@ -928,11 +962,8 @@ likely_target_p (struct cgraph_node *n)\n }\n \n /* The ipa-devirt pass.\n-   This performs very trivial devirtualization:\n-     1) when polymorphic call is known to have precisely one target,\n-        turn it into direct call\n-     2) when polymorphic call has only one likely target in the unit,\n-        turn it into speculative call.  */\n+   When polymorphic call has only one likely target in the unit,\n+   turn it into speculative call.  */\n \n static unsigned int\n ipa_devirt (void)\n@@ -965,26 +996,9 @@ ipa_devirt (void)\n \t    if (dump_file)\n \t      dump_possible_polymorphic_call_targets \n \t\t(dump_file, e);\n+\n \t    npolymorphic++;\n \n-\t    if (final)\n-\t      {\n-\t\tgcc_assert (targets.length());\n-\t\tif (targets.length() == 1)\n-\t\t  {\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"Devirtualizing call in %s/%i to %s/%i\\n\",\n-\t\t\t       cgraph_node_name (n), n->symbol.order,\n-\t\t\t       cgraph_node_name (targets[0]), targets[0]->symbol.order);\n-\t\t    cgraph_make_edge_direct (e, targets[0]);\n-\t\t    ndevirtualized++;\n-\t\t    update = true;\n-\t\t    continue;\n-\t\t  }\n-\t      }\n-\t    if (!flag_devirtualize_speculatively)\n-\t      continue;\n \t    if (!cgraph_maybe_hot_edge_p (e))\n \t      {\n \t\tif (dump_file)\n@@ -1114,7 +1128,7 @@ ipa_devirt (void)\n static bool\n gate_ipa_devirt (void)\n {\n-  return flag_devirtualize && !in_lto_p && optimize;\n+  return flag_devirtualize_speculatively && !in_lto_p && optimize;\n }\n \n namespace {"}, {"sha": "4b82d1d4bc59858accaadad5048bbd7386269345", "filename": "gcc/ipa.c", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -149,6 +149,84 @@ process_references (struct ipa_ref_list *list,\n     }\n }\n \n+/* EDGE is an polymorphic call.  If BEFORE_INLINING_P is set, mark\n+   all its potential targets as reachable to permit later inlining if\n+   devirtualization happens.  After inlining still keep their declarations\n+   around, so we can devirtualize to a direct call.\n+\n+   Also try to make trivial devirutalization when no or only one target is\n+   possible.  */\n+\n+static void\n+walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n+\t\t\t       struct cgraph_edge *edge,\n+\t\t\t       symtab_node *first,\n+\t\t\t       pointer_set_t *reachable, bool before_inlining_p)\n+{\n+  unsigned int i;\n+  void *cache_token;\n+  bool final;\n+  vec <cgraph_node *>targets\n+    = possible_polymorphic_call_targets\n+\t(edge, &final, &cache_token);\n+\n+  if (!pointer_set_insert (reachable_call_targets,\n+\t\t\t   cache_token))\n+    {\n+      for (i = 0; i < targets.length(); i++)\n+\t{\n+\t  struct cgraph_node *n = targets[i];\n+\n+\t  /* Do not bother to mark virtual methods in anonymous namespace;\n+\t     either we will find use of virtual table defining it, or it is\n+\t     unused.  */\n+\t  if (TREE_CODE (TREE_TYPE (n->symbol.decl)) == METHOD_TYPE\n+\t      && type_in_anonymous_namespace_p\n+\t\t    (method_class_type (TREE_TYPE (n->symbol.decl))))\n+\t    continue;\n+\n+\t  /* Prior inlining, keep alive bodies of possible targets for\n+\t     devirtualization.  */\n+\t   if (n->symbol.definition\n+\t       && before_inlining_p)\n+\t     pointer_set_insert (reachable, n);\n+\n+\t  /* Even after inlining we want to keep the possible targets in the\n+\t     boundary, so late passes can still produce direct call even if\n+\t     the chance for inlining is lost.  */\n+\t  enqueue_node ((symtab_node) n, first, reachable);\n+\t}\n+    }\n+\n+  /* Very trivial devirtualization; when the type is\n+     final or anonymous (so we know all its derivation)\n+     and there is only one possible virtual call target,\n+     make the edge direct.  */\n+  if (final)\n+    {\n+      if (targets.length() <= 1)\n+\t{\n+\t  cgraph_node *target;\n+\t  if (targets.length () == 1)\n+\t    target = targets[0];\n+\t  else\n+\t    target = cgraph_get_create_node\n+\t\t       (builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Devirtualizing call in %s/%i to %s/%i\\n\",\n+\t\t     cgraph_node_name (edge->caller),\n+\t\t     edge->caller->symbol.order,\n+\t\t     cgraph_node_name (target), target->symbol.order);\n+\t  edge = cgraph_make_edge_direct (edge, target);\n+\t  if (cgraph_state != CGRAPH_STATE_IPA_SSA)\n+\t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n+\t  else\n+\t    inline_update_overall_summary (edge->caller);\n+\t}\n+    }\n+}\n \n /* Perform reachability analysis and reclaim all unreachable nodes.\n \n@@ -214,7 +292,9 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   bool changed = false;\n   struct pointer_set_t *reachable = pointer_set_create ();\n   struct pointer_set_t *body_needed_for_clonning = pointer_set_create ();\n+  struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n \n+  timevar_push (TV_IPA_UNREACHABLE);\n #ifdef ENABLE_CHECKING\n   verify_symtab ();\n #endif\n@@ -238,10 +318,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       if (node->symbol.definition\n \t  && !node->global.inlined_to\n \t  && !node->symbol.in_other_partition\n-\t  && (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n-\t      /* Keep around virtual functions for possible devirtualization.  */\n-\t      || (before_inlining_p\n-\t\t  && DECL_VIRTUAL_P (node->symbol.decl))))\n+\t  && !cgraph_can_remove_if_no_direct_calls_and_refs_p (node))\n \t{\n \t  gcc_assert (!node->global.inlined_to);\n \t  pointer_set_insert (reachable, node);\n@@ -304,6 +381,19 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  if (!in_boundary_p)\n \t    {\n \t      struct cgraph_edge *e;\n+\t      /* Keep alive possible targets for devirtualization.  */\n+\t      if (optimize && flag_devirtualize)\n+\t\t{\n+\t\t  struct cgraph_edge *next;\n+\t\t  for (e = cnode->indirect_calls; e; e = next)\n+\t\t    {\n+\t\t      next = e->next_callee;\n+\t\t      if (e->indirect_info->polymorphic)\n+\t\t\twalk_polymorphic_call_targets (reachable_call_targets,\n+\t\t\t\t\t\t       e, &first, reachable,\n+\t\t\t\t\t\t       before_inlining_p);\n+\t\t    }\n+\t\t}\n \t      for (e = cnode->callees; e; e = e->next_callee)\n \t\t{\n \t\t  if (e->callee->symbol.definition\n@@ -449,6 +539,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n   pointer_set_destroy (reachable);\n   pointer_set_destroy (body_needed_for_clonning);\n+  pointer_set_destroy (reachable_call_targets);\n \n   /* Now update address_taken flags and try to promote functions to be local.  */\n   if (file)\n@@ -483,6 +574,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     FOR_EACH_DEFINED_FUNCTION (node)\n       ipa_propagate_frequency (node);\n \n+  timevar_pop (TV_IPA_UNREACHABLE);\n   return changed;\n }\n "}, {"sha": "9289831ced89035f63610373d911aa184a86aeff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -1,3 +1,10 @@\n+2013-09-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* testsuite/g++.dg/ipa/devirt-11.C: Update template.\n+\t* testsuite/g++.dg/ipa/devirt-16.C: New testcase.\n+\t* testsuite/g++.dg/ipa/devirt-17.C: New testcase.\n+\t* testsuite/g++.dg/ipa/devirt-18.C: New testcase.\n+\n 2013-09-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/54941"}, {"sha": "d30d56cff24e15528060315f59d512f9274914f2", "filename": "gcc/testsuite/g++.dg/ipa/devirt-11.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -46,5 +46,4 @@ bar ()\n    and two to fn3. While doing so the new symbol for fn2 needs to be\n    introduced.  */\n /* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 3 \"inline\"  } } */\n-/* { dg-final { scan-ipa-dump-times \"and turned into root of the clone tree\" 1 \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "85567867ff169345cda5357afecaf00ebd5c75c2", "filename": "gcc/testsuite/g++.dg/ipa/devirt-16.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-16.C?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -0,0 +1,39 @@\n+/* We shall devirtualize to unreachable.  No anonymous type method should surivve\n+   reachability.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-whole-program\"  } */\n+namespace {\n+class B {\n+public:\n+  virtual int foo(void)\n+{\n+  return 0;\n+}\n+};\n+class A : public B {\n+public:\n+  virtual int foo(void)\n+{\n+  return 1;\n+}\n+};\n+}\n+class B *b;\n+main()\n+{\n+  int c;\n+  if (c)\n+    {\n+    class A a;\n+    a.foo();\n+    class B b;\n+    b.foo();\n+    }\n+  return b->foo();\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Devirtualizing\" \"whole-program\"} } */\n+/* { dg-final { scan-ipa-dump \"builtin_unreachable\" \"whole-program\"} } */\n+/* { dg-final { scan-ipa-dump-not \"A::foo\" \"whole-program\"} } */\n+/* { dg-final { scan-ipa-dump-not \"A::foo\" \"whole-program\"} } */\n+/* { dg-final { cleanup-ipa-dump \"whole-program\" } } */"}, {"sha": "9edfd73af5644e0b1bbd157102e980dd484025e1", "filename": "gcc/testsuite/g++.dg/ipa/devirt-17.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-17.C?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -0,0 +1,44 @@\n+/* We shall devirtualize to B::foo since it is the only live candidate of an\n+   anonymous type.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-whole-program\"  } */\n+namespace {\n+class B {\n+public:\n+  virtual int foo(void)\n+{\n+  return 0;\n+}\n+};\n+class A : public B {\n+public:\n+  virtual int foo(void)\n+{\n+  return 1;\n+}\n+};\n+}\n+class B *b;\n+void get_me_lost (void *);\n+main()\n+{\n+  int c;\n+  if (c)\n+    {\n+    class A a;\n+    a.foo();\n+    }\n+  else\n+    {\n+    b = new (class B);\n+    b->foo();\n+\tget_me_lost ((void *)&b);\n+    }\n+  return b->foo();\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Devirtualizing\" \"whole-program\"} } */\n+/* { dg-final { scan-ipa-dump-not \"builtin_unreachable\" \"whole-program\"} } */\n+/* { dg-final { scan-ipa-dump \"B::foo\" \"whole-program\"} } */\n+/* { dg-final { scan-ipa-dump-not \"A::foo\" \"whole-program\"} } */\n+/* { dg-final { cleanup-ipa-dump \"whole-program\" } } */"}, {"sha": "dbbe597c92caca33cdbe63cf6de9024f82b2159a", "filename": "gcc/testsuite/g++.dg/ipa/devirt-18.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-18.C?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -0,0 +1,37 @@\n+/* We shall devirtualize to unreachable.  No anonymous type method should surivve\n+   reachability.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ssa\"  } */\n+namespace {\n+class B {\n+public:\n+  virtual int foo(void)\n+{\n+  return 0;\n+}\n+};\n+class A : public B {\n+public:\n+  virtual int foo(void)\n+{\n+  return 1;\n+}\n+};\n+}\n+class B *b;\n+main()\n+{\n+  if (0)\n+    {\n+    class A a;\n+    a.foo();\n+    class B b;\n+    b.foo();\n+    }\n+  return b->foo();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"A::foo\" \"ssa\"} } */\n+/* { dg-final { scan-tree-dump-not \"B::foo\" \"ssa\"} } */\n+/* { dg-final { scan-tree-dump \"builtin_unreachable\" \"ssa\"} } */\n+/* { dg-final { cleanup-tree-dump \"ssa\" } } */"}, {"sha": "5a880a8a3645da5e91b43c8d1eaaa1d881f87044", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3462aa02a699dc716bd366fee8fc1c85f7f94541/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=3462aa02a699dc716bd366fee8fc1c85f7f94541", "patch": "@@ -64,6 +64,7 @@ DEFTIMEVAR (TV_PCH_CPP_RESTORE       , \"PCH preprocessor state restore\")\n \n DEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\n DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n+DEFTIMEVAR (TV_IPA_UNREACHABLE       , \"ipa dead code removal\")\n DEFTIMEVAR (TV_IPA_INHERITANCE       , \"ipa inheritance graph\")\n DEFTIMEVAR (TV_IPA_VIRTUAL_CALL      , \"ipa virtual call target\")\n DEFTIMEVAR (TV_IPA_DEVIRT\t     , \"ipa devirtualization\")"}]}