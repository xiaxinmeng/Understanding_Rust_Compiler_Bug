{"sha": "e79498768f45a4021b4d6f518958c0dc0accc4dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc5NDk4NzY4ZjQ1YTQwMjFiNGQ2ZjUxODk1OGMwZGMwYWNjYzRkZA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-05-02T14:22:09Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-05-02T14:22:09Z"}, "message": "calls.c (struct arg_data): Move offset, slot_offset, size and alignment_pad to struct locate_and_pad_arg_data.\n\n\t* calls.c (struct arg_data): Move offset, slot_offset, size and\n\talignment_pad to struct locate_and_pad_arg_data.  Update all refs.\n\t(initialize_argument_information): Adjust call to locate_and_pad_parm.\n\tDelete alignment_pad var.  Don't calculate slot_offset here.\n\t(emit_library_call_value_1): Delete alignment_pad, offset and size\n\tvars.  Use struct locate_and_pad_arg_data instead.  Adjust refs.\n\tAdjust call to locate_and_pad_parm.  Don't tweak arg size for\n\tpartial in-regs here.  Formatting fixes.\n\t* expr.h (struct locate_and_pad_arg_data): New struct.\n\t(locate_and_pad_parm): Adjust declaration.\n\t* function.c (assign_parms): Localize vars.  Use \"locate\" instead of\n\tother arg location vars.  Don't invoke FUNCTION_ARG or\n\tFUNCTION_INCOMING_ARG unless pretend_named is different from\n\tnamed_arg.  Heed MUST_PASS_IN_STACK and set up \"partial\" before\n\tcalling locate_and_pad_parm.  Adjust locate_and_pad_parm call.\n\tUse slot_offset for stack home of reg parms.  Correct test for\n\tparm passed in memory.  Formatting fixes.\n\t(locate_and_pad_parm): Add \"partial\" to params.  Replace offset_ptr\n\targ_size_ptr and alignment pad with \"locate\".  Set slot_offset here.\n\tCorrect initial_offset_ptr handling.  Localize vars.  Always pad\n\tlocate->offset even when in_regs.\n\nFrom-SVN: r66383", "tree": {"sha": "3499480542d5aee3c1e4cc0cd83f51a439861617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3499480542d5aee3c1e4cc0cd83f51a439861617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e79498768f45a4021b4d6f518958c0dc0accc4dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79498768f45a4021b4d6f518958c0dc0accc4dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79498768f45a4021b4d6f518958c0dc0accc4dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79498768f45a4021b4d6f518958c0dc0accc4dd/comments", "author": null, "committer": null, "parents": [{"sha": "5ca5a6554e73c0c72d92751cf0f391912aef97b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca5a6554e73c0c72d92751cf0f391912aef97b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca5a6554e73c0c72d92751cf0f391912aef97b5"}], "stats": {"total": 515, "additions": 264, "deletions": 251}, "files": [{"sha": "c2b1e8da47f70fe427cd8092692d034f8a452aa5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e79498768f45a4021b4d6f518958c0dc0accc4dd", "patch": "@@ -1,3 +1,27 @@\n+2003-05-02  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* calls.c (struct arg_data): Move offset, slot_offset, size and\n+\talignment_pad to struct locate_and_pad_arg_data.  Update all refs.\n+\t(initialize_argument_information): Adjust call to locate_and_pad_parm.\n+\tDelete alignment_pad var.  Don't calculate slot_offset here.\n+\t(emit_library_call_value_1): Delete alignment_pad, offset and size\n+\tvars.  Use struct locate_and_pad_arg_data instead.  Adjust refs.\n+\tAdjust call to locate_and_pad_parm.  Don't tweak arg size for\n+\tpartial in-regs here.  Formatting fixes.\n+\t* expr.h (struct locate_and_pad_arg_data): New struct.\n+\t(locate_and_pad_parm): Adjust declaration.\n+\t* function.c (assign_parms): Localize vars.  Use \"locate\" instead of\n+\tother arg location vars.  Don't invoke FUNCTION_ARG or\n+\tFUNCTION_INCOMING_ARG unless pretend_named is different from\n+\tnamed_arg.  Heed MUST_PASS_IN_STACK and set up \"partial\" before\n+\tcalling locate_and_pad_parm.  Adjust locate_and_pad_parm call.\n+\tUse slot_offset for stack home of reg parms.  Correct test for\n+\tparm passed in memory.  Formatting fixes.\n+\t(locate_and_pad_parm): Add \"partial\" to params.  Replace offset_ptr\n+\targ_size_ptr and alignment pad with \"locate\".  Set slot_offset here.\n+\tCorrect initial_offset_ptr handling.  Localize vars.  Always pad\n+\tlocate->offset even when in_regs.\n+\n 2003-05-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* Makefile.in (TREE_H): Replace location.h with input.h."}, {"sha": "8fb84e9b906f3b461cd4089d7b27da58a5d0dcee", "filename": "gcc/calls.c", "status": "modified", "additions": 61, "deletions": 109, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e79498768f45a4021b4d6f518958c0dc0accc4dd", "patch": "@@ -98,16 +98,8 @@ struct arg_data\n      even though pass_on_stack is zero, just because FUNCTION_ARG says so.\n      pass_on_stack identifies arguments that *cannot* go in registers.  */\n   int pass_on_stack;\n-  /* Offset of this argument from beginning of stack-args.  */\n-  struct args_size offset;\n-  /* Similar, but offset to the start of the stack slot.  Different from\n-     OFFSET if this arg pads downward.  */\n-  struct args_size slot_offset;\n-  /* Size of this argument on the stack, rounded up for any padding it gets,\n-     parts of the argument passed in registers do not count.\n-     If REG_PARM_STACK_SPACE is defined, then register parms\n-     are counted here as well.  */\n-  struct args_size size;\n+  /* Some fields packaged up for locate_and_pad_parm.  */\n+  struct locate_and_pad_arg_data locate;\n   /* Location on the stack at which parameter should be stored.  The store\n      has already been done if STACK == VALUE.  */\n   rtx stack;\n@@ -123,9 +115,6 @@ struct arg_data\n      word-sized pseudos we made.  */\n   rtx *aligned_regs;\n   int n_aligned_regs;\n-  /* The amount that the stack pointer needs to be adjusted to\n-     force alignment for the next argument.  */\n-  struct args_size alignment_pad;\n };\n \n /* A vector of one char per byte of stack space.  A byte if nonzero if\n@@ -1120,7 +1109,6 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n   /* Count arg position in order args appear.  */\n   int argpos;\n \n-  struct args_size alignment_pad;\n   int i;\n   tree p;\n \n@@ -1331,39 +1319,14 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n #else\n \t\t\t     args[i].reg != 0,\n #endif\n-\t\t\t     fndecl, args_size, &args[i].offset,\n-\t\t\t     &args[i].size, &alignment_pad);\n-\n-#ifndef ARGS_GROW_DOWNWARD\n-      args[i].slot_offset = *args_size;\n-#endif\n-\n-      args[i].alignment_pad = alignment_pad;\n-\n-      /* If a part of the arg was put into registers,\n-\t don't include that part in the amount pushed.  */\n-      if (reg_parm_stack_space == 0 && ! args[i].pass_on_stack)\n-\targs[i].size.constant -= ((args[i].partial * UNITS_PER_WORD)\n-\t\t\t\t  / (PARM_BOUNDARY / BITS_PER_UNIT)\n-\t\t\t\t  * (PARM_BOUNDARY / BITS_PER_UNIT));\n+\t\t\t     args[i].pass_on_stack ? 0 : args[i].partial,\n+\t\t\t     fndecl, args_size, &args[i].locate);\n \n       /* Update ARGS_SIZE, the total stack space for args so far.  */\n \n-      args_size->constant += args[i].size.constant;\n-      if (args[i].size.var)\n-\t{\n-\t  ADD_PARM_SIZE (*args_size, args[i].size.var);\n-\t}\n-\n-      /* Since the slot offset points to the bottom of the slot,\n-\t we must record it after incrementing if the args grow down.  */\n-#ifdef ARGS_GROW_DOWNWARD\n-      args[i].slot_offset = *args_size;\n-\n-      args[i].slot_offset.constant = -args_size->constant;\n-      if (args_size->var)\n-\tSUB_PARM_SIZE (args[i].slot_offset, args_size->var);\n-#endif\n+      args_size->constant += args[i].locate.size.constant;\n+      if (args[i].locate.size.var)\n+\tADD_PARM_SIZE (*args_size, args[i].locate.size.var);\n \n       /* Increment ARGS_SO_FAR, which has info about which arg-registers\n \t have been used, etc.  */\n@@ -1616,8 +1579,8 @@ compute_argument_addresses (args, argblock, num_actuals)\n \n       for (i = 0; i < num_actuals; i++)\n \t{\n-\t  rtx offset = ARGS_SIZE_RTX (args[i].offset);\n-\t  rtx slot_offset = ARGS_SIZE_RTX (args[i].slot_offset);\n+\t  rtx offset = ARGS_SIZE_RTX (args[i].locate.offset);\n+\t  rtx slot_offset = ARGS_SIZE_RTX (args[i].locate.slot_offset);\n \t  rtx addr;\n \n \t  /* Skip this parm if it will not be passed on the stack.  */\n@@ -2060,12 +2023,12 @@ check_sibcall_argument_overlap (insn, arg, mark_stored_args_map)\n   if (mark_stored_args_map)\n     {\n #ifdef ARGS_GROW_DOWNWARD\n-      low = -arg->slot_offset.constant - arg->size.constant;\n+      low = -arg->locate.slot_offset.constant - arg->locate.size.constant;\n #else\n-      low = arg->slot_offset.constant;\n+      low = arg->locate.slot_offset.constant;\n #endif\n \n-      for (high = low + arg->size.constant; low < high; low++)\n+      for (high = low + arg->locate.size.constant; low < high; low++)\n \tSET_BIT (stored_args_map, low);\n     }\n   return insn != NULL_RTX;\n@@ -3364,7 +3327,7 @@ expand_call (exp, target, ignore)\n \t\t  emit_move_insn (stack_area, args[i].save_area);\n \t\telse\n \t\t  emit_block_move (stack_area, args[i].save_area,\n-\t\t\t\t   GEN_INT (args[i].size.constant),\n+\t\t\t\t   GEN_INT (args[i].locate.size.constant),\n \t\t\t\t   BLOCK_OP_CALL_PARM);\n \t      }\n \n@@ -3513,7 +3476,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   rtx fun;\n   int inc;\n   int count;\n-  struct args_size alignment_pad;\n   rtx argblock = 0;\n   CUMULATIVE_ARGS args_so_far;\n   struct arg\n@@ -3522,8 +3484,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n     enum machine_mode mode;\n     rtx reg;\n     int partial;\n-    struct args_size offset;\n-    struct args_size size;\n+    struct locate_and_pad_arg_data locate;\n     rtx save_area;\n   };\n   struct arg *argvec;\n@@ -3683,12 +3644,11 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #else\n \t\t\t   argvec[count].reg != 0,\n #endif\n-\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size, &alignment_pad);\n+\t\t\t   0, NULL_TREE, &args_size, &argvec[count].locate);\n \n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n \t  || reg_parm_stack_space > 0)\n-\targs_size.constant += argvec[count].size.constant;\n+\targs_size.constant += argvec[count].locate.size.constant;\n \n       FUNCTION_ARG_ADVANCE (args_so_far, Pmode, (tree) 0, 1);\n \n@@ -3802,18 +3762,15 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #else\n \t\t\t   argvec[count].reg != 0,\n #endif\n-\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size, &alignment_pad);\n+\t\t\t   argvec[count].partial,\n+\t\t\t   NULL_TREE, &args_size, &argvec[count].locate);\n \n-      if (argvec[count].size.var)\n+      if (argvec[count].locate.size.var)\n \tabort ();\n \n-      if (reg_parm_stack_space == 0 && argvec[count].partial)\n-\targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n-\n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n \t  || reg_parm_stack_space > 0)\n-\targs_size.constant += argvec[count].size.constant;\n+\targs_size.constant += argvec[count].locate.size.constant;\n \n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n@@ -3951,11 +3908,11 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #ifdef ARGS_GROW_DOWNWARD\n \t      /* stack_slot is negative, but we want to index stack_usage_map\n \t\t with positive values.  */\n-\t      upper_bound = -argvec[argnum].offset.constant + 1;\n-\t      lower_bound = upper_bound - argvec[argnum].size.constant;\n+\t      upper_bound = -argvec[argnum].locate.offset.constant + 1;\n+\t      lower_bound = upper_bound - argvec[argnum].locate.size.constant;\n #else\n-\t      lower_bound = argvec[argnum].offset.constant;\n-\t      upper_bound = lower_bound + argvec[argnum].size.constant;\n+\t      lower_bound = argvec[argnum].locate.offset.constant;\n+\t      upper_bound = lower_bound + argvec[argnum].locate.size.constant;\n #endif\n \n \t      i = lower_bound;\n@@ -3968,19 +3925,16 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n \t      if (i < upper_bound)\n \t\t{\n-\t\t  /* We need to make a save area.  See what mode we can make\n-\t\t     it.  */\n+\t\t  /* We need to make a save area.  */\n+\t\t  unsigned int size\n+\t\t    = argvec[argnum].locate.size.constant * BITS_PER_UNIT;\n \t\t  enum machine_mode save_mode\n-\t\t    = mode_for_size (argvec[argnum].size.constant\n-\t\t\t\t     * BITS_PER_UNIT,\n-\t\t\t\t     MODE_INT, 1);\n+\t\t    = mode_for_size (size, MODE_INT, 1);\n+\t\t  rtx adr\n+\t\t    = plus_constant (argblock,\n+\t\t\t\t     argvec[argnum].locate.offset.constant);\n \t\t  rtx stack_area\n-\t\t    = gen_rtx_MEM\n-\t\t      (save_mode,\n-\t\t       memory_address\n-\t\t       (save_mode,\n-\t\t\tplus_constant (argblock,\n-\t\t\t\t       argvec[argnum].offset.constant)));\n+\t\t    = gen_rtx_MEM (save_mode, memory_address (save_mode, adr));\n \t\t  argvec[argnum].save_area = gen_reg_rtx (save_mode);\n \n \t\t  emit_move_insn (argvec[argnum].save_area, stack_area);\n@@ -3989,8 +3943,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, PARM_BOUNDARY,\n \t\t\t  partial, reg, 0, argblock,\n-\t\t\t  GEN_INT (argvec[argnum].offset.constant),\n-\t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n+\t\t\t  GEN_INT (argvec[argnum].locate.offset.constant),\n+\t\t\t  reg_parm_stack_space,\n+\t\t\t  ARGS_SIZE_RTX (argvec[argnum].locate.alignment_pad));\n \n \t  /* Now mark the segment we just used.  */\n \t  if (ACCUMULATE_OUTGOING_ARGS)\n@@ -4195,12 +4150,10 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \tif (argvec[count].save_area)\n \t  {\n \t    enum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n-\t    rtx stack_area\n-\t      = gen_rtx_MEM (save_mode,\n-\t\t\t     memory_address\n-\t\t\t     (save_mode,\n-\t\t\t      plus_constant (argblock,\n-\t\t\t\t\t     argvec[count].offset.constant)));\n+\t    rtx adr = plus_constant (argblock,\n+\t\t\t\t     argvec[count].locate.offset.constant);\n+\t    rtx stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\t\t  memory_address (save_mode, adr));\n \n \t    emit_move_insn (stack_area, argvec[count].save_area);\n \t  }\n@@ -4327,14 +4280,14 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t  else\n \t    upper_bound = 0;\n \n-\t  lower_bound = upper_bound - arg->size.constant;\n+\t  lower_bound = upper_bound - arg->locate.size.constant;\n #else\n \t  if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n \t    lower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n \t  else\n \t    lower_bound = 0;\n \n-\t  upper_bound = lower_bound + arg->size.constant;\n+\t  upper_bound = lower_bound + arg->locate.size.constant;\n #endif\n \n \t  i = lower_bound;\n@@ -4347,13 +4300,11 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \n \t  if (i < upper_bound)\n \t    {\n-\t      /* We need to make a save area.  See what mode we can make it.  */\n-\t      enum machine_mode save_mode\n-\t\t= mode_for_size (arg->size.constant * BITS_PER_UNIT, MODE_INT, 1);\n-\t      rtx stack_area\n-\t\t= gen_rtx_MEM (save_mode,\n-\t\t\t       memory_address (save_mode,\n-\t\t\t\t\t       XEXP (arg->stack_slot, 0)));\n+\t      /* We need to make a save area.  */\n+\t      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;\n+\t      enum machine_mode save_mode = mode_for_size (size, MODE_INT, 1);\n+\t      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));\n+\t      rtx stack_area = gen_rtx_MEM (save_mode, adr);\n \n \t      if (save_mode == BLKmode)\n \t\t{\n@@ -4481,8 +4432,8 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t This can either be done with push or copy insns.  */\n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX, \n \t\t      PARM_BOUNDARY, partial, reg, used - size, argblock,\n-\t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n-\t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n+\t\t      ARGS_SIZE_RTX (arg->locate.offset), reg_parm_stack_space,\n+\t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad));\n \n       /* Unless this is a partially-in-register argument, the argument is now\n \t in the stack.  */\n@@ -4504,16 +4455,17 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n       /* Round its size up to a multiple\n \t of the allocation unit for arguments.  */\n \n-      if (arg->size.var != 0)\n+      if (arg->locate.size.var != 0)\n \t{\n \t  excess = 0;\n-\t  size_rtx = ARGS_SIZE_RTX (arg->size);\n+\t  size_rtx = ARGS_SIZE_RTX (arg->locate.size);\n \t}\n       else\n \t{\n \t  /* PUSH_ROUNDING has no effect on us, because\n \t     emit_push_insn for BLKmode is careful to avoid it.  */\n-\t  excess = (arg->size.constant - int_size_in_bytes (TREE_TYPE (pval))\n+\t  excess = (arg->locate.size.constant\n+\t\t    - int_size_in_bytes (TREE_TYPE (pval))\n \t\t    + partial * UNITS_PER_WORD);\n \t  size_rtx = expand_expr (size_in_bytes (TREE_TYPE (pval)),\n \t\t\t\t  NULL_RTX, TYPE_MODE (sizetype), 0);\n@@ -4527,7 +4479,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t PARM_BOUNDARY, but the actual argument isn't.  */\n       if (FUNCTION_ARG_PADDING (arg->mode, TREE_TYPE (pval)) == downward)\n \t{\n-\t  if (arg->size.var)\n+\t  if (arg->locate.size.var)\n \t    parm_align = BITS_PER_UNIT;\n \t  else if (excess)\n \t    {\n@@ -4539,7 +4491,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n       if ((flags & ECF_SIBCALL) && GET_CODE (arg->value) == MEM)\n \t{\n \t  /* emit_push_insn might not work properly if arg->value and\n-\t     argblock + arg->offset areas overlap.  */\n+\t     argblock + arg->locate.offset areas overlap.  */\n \t  rtx x = arg->value;\n \t  int i = 0;\n \n@@ -4553,26 +4505,26 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n \n \t      /* expand_call should ensure this */\n-\t      if (arg->offset.var || GET_CODE (size_rtx) != CONST_INT)\n+\t      if (arg->locate.offset.var || GET_CODE (size_rtx) != CONST_INT)\n \t\tabort ();\n \n-\t      if (arg->offset.constant > i)\n+\t      if (arg->locate.offset.constant > i)\n \t\t{\n-\t\t  if (arg->offset.constant < i + INTVAL (size_rtx))\n+\t\t  if (arg->locate.offset.constant < i + INTVAL (size_rtx))\n \t\t    sibcall_failure = 1;\n \t\t}\n-\t      else if (arg->offset.constant < i)\n+\t      else if (arg->locate.offset.constant < i)\n \t\t{\n-\t\t  if (i < arg->offset.constant + INTVAL (size_rtx))\n+\t\t  if (i < arg->locate.offset.constant + INTVAL (size_rtx))\n \t\t    sibcall_failure = 1;\n \t\t}\n \t    }\n \t}\n \n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      parm_align, partial, reg, excess, argblock,\n-\t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n-\t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n+\t\t      ARGS_SIZE_RTX (arg->locate.offset), reg_parm_stack_space,\n+\t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad));\n \n       /* Unless this is a partially-in-register argument, the argument is now\n \t in the stack."}, {"sha": "dfd83d43c230afe49b10a995f49ca34b492ab8df", "filename": "gcc/expr.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e79498768f45a4021b4d6f518958c0dc0accc4dd", "patch": "@@ -63,6 +63,8 @@ enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM = 2, EXPAND_SUM,\n    more information.  */\n #define OK_DEFER_POP (inhibit_defer_pop -= 1)\n \f\n+enum direction {none, upward, downward};\n+\n #ifdef TREE_CODE /* Don't lose if tree.h not included.  */\n /* Structure to record the size of a sequence of arguments\n    as the sum of a tree-expression and a constant.  This structure is\n@@ -74,6 +76,24 @@ struct args_size\n   HOST_WIDE_INT constant;\n   tree var;\n };\n+\n+/* Package up various arg related fields of struct args for\n+   locate_and_pad_parm.  */\n+struct locate_and_pad_arg_data\n+{\n+  /* Size of this argument on the stack, rounded up for any padding it\n+     gets.  If REG_PARM_STACK_SPACE is defined, then register parms are\n+     counted here, otherwise they aren't.  */\n+  struct args_size size;\n+  /* Offset of this argument from beginning of stack-args.  */\n+  struct args_size offset;\n+  /* Offset to the start of the stack slot.  Different from OFFSET\n+     if this arg pads downward.  */\n+  struct args_size slot_offset;\n+  /* The amount that the stack pointer needs to be adjusted to\n+     force alignment for the next argument.  */\n+  struct args_size alignment_pad;\n+};\n #endif\n \n /* Add the value of the tree INC to the `struct args_size' TO.  */\n@@ -119,8 +139,6 @@ do {\t\t\t\t\t\t\t\\\n    usually pad upward, but pad short args downward on\n    big-endian machines.  */\n \n-enum direction {none, upward, downward};  /* Value has this type.  */\n-\n #ifndef FUNCTION_ARG_PADDING\n #define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n   (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n@@ -570,11 +588,9 @@ extern rtx expand_shift PARAMS ((enum tree_code, enum machine_mode, rtx, tree,\n \t\t\t\t rtx, int));\n extern rtx expand_divmod PARAMS ((int, enum tree_code, enum machine_mode, rtx,\n \t\t\t\t  rtx, rtx, int));\n-extern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, tree,\n-\t\t\t\t\t struct args_size *,\n-\t\t\t\t\t struct args_size *,\n-\t\t\t\t\t struct args_size *,\n-\t\t\t\t\t struct args_size *));\n+extern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, int,\n+\t\t\t\t\t tree, struct args_size *,\n+\t\t\t\t\t struct locate_and_pad_arg_data *));\n extern rtx expand_inline_function PARAMS ((tree, tree, rtx, int, tree, rtx));\n \n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */"}, {"sha": "5684392b5e9502a50f4a952a601e4b60c66d1efd", "filename": "gcc/function.c", "status": "modified", "additions": 156, "deletions": 135, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79498768f45a4021b4d6f518958c0dc0accc4dd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e79498768f45a4021b4d6f518958c0dc0accc4dd", "patch": "@@ -4340,12 +4340,7 @@ assign_parms (fndecl)\n      tree fndecl;\n {\n   tree parm;\n-  rtx entry_parm = 0;\n-  rtx stack_parm = 0;\n   CUMULATIVE_ARGS args_so_far;\n-  enum machine_mode promoted_mode, passed_mode;\n-  enum machine_mode nominal_mode, promoted_nominal_mode;\n-  int unsignedp;\n   /* Total space needed so far for args on the stack,\n      given as a constant and a tree-expression.  */\n   struct args_size stack_args_size;\n@@ -4359,8 +4354,8 @@ assign_parms (fndecl)\n #ifdef SETUP_INCOMING_VARARGS\n   int varargs_setup = 0;\n #endif\n+  int reg_parm_stack_space = 0;\n   rtx conversion_insns = 0;\n-  struct args_size alignment_pad;\n \n   /* Nonzero if function takes extra anonymous args.\n      This means the last named arg must be on the stack\n@@ -4407,6 +4402,14 @@ assign_parms (fndecl)\n   max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n   parm_reg_stack_loc = (rtx *) ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n \n+#ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+#endif\n+\n #ifdef INIT_CUMULATIVE_INCOMING_ARGS\n   INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, NULL_RTX);\n #else\n@@ -4419,14 +4422,19 @@ assign_parms (fndecl)\n \n   for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     {\n-      struct args_size stack_offset;\n-      struct args_size arg_size;\n+      rtx entry_parm;\n+      rtx stack_parm;\n+      enum machine_mode promoted_mode, passed_mode;\n+      enum machine_mode nominal_mode, promoted_nominal_mode;\n+      int unsignedp;\n+      struct locate_and_pad_arg_data locate;\n       int passed_pointer = 0;\n       int did_conversion = 0;\n       tree passed_type = DECL_ARG_TYPE (parm);\n       tree nominal_type = TREE_TYPE (parm);\n-      int pretend_named;\n       int last_named = 0, named_arg;\n+      int in_regs;\n+      int partial = 0;\n \n       /* Set LAST_NAMED if this is last named arg before last\n \t anonymous args.  */\n@@ -4490,7 +4498,7 @@ assign_parms (fndecl)\n \t  || TREE_ADDRESSABLE (passed_type)\n #ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n \t  || FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, passed_mode,\n-\t\t\t\t\t      passed_type, named_arg)\n+\t\t\t\t\t     passed_type, named_arg)\n #endif\n \t  )\n \t{\n@@ -4560,27 +4568,52 @@ assign_parms (fndecl)\n \t it came in a register so that REG_PARM_STACK_SPACE isn't skipped.\n \t In this case, we call FUNCTION_ARG with NAMED set to 1 instead of\n \t 0 as it was the previous time.  */\n-\n-      pretend_named = named_arg || PRETEND_OUTGOING_VARARGS_NAMED;\n-      locate_and_pad_parm (promoted_mode, passed_type,\n+      in_regs = entry_parm != 0;\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n-\t\t\t   1,\n-#else\n+      in_regs = 1;\n+#endif\n+      if (!in_regs && !named_arg)\n+\t{\n+\t  int pretend_named = PRETEND_OUTGOING_VARARGS_NAMED;\n+\t  if (pretend_named)\n+\t    {\n #ifdef FUNCTION_INCOMING_ARG\n-\t\t\t   FUNCTION_INCOMING_ARG (args_so_far, promoted_mode,\n-\t\t\t\t\t\t  passed_type,\n-\t\t\t\t\t\t  pretend_named) != 0,\n+\t      in_regs = FUNCTION_INCOMING_ARG (args_so_far, promoted_mode,\n+\t\t\t\t\t       passed_type,\n+\t\t\t\t\t       pretend_named) != 0;\n #else\n-\t\t\t   FUNCTION_ARG (args_so_far, promoted_mode,\n-\t\t\t\t\t passed_type,\n-\t\t\t\t\t pretend_named) != 0,\n+\t      in_regs = FUNCTION_ARG (args_so_far, promoted_mode,\n+\t\t\t\t      passed_type,\n+\t\t\t\t      pretend_named) != 0;\n #endif\n+\t    }\n+\t}\n+\n+      /* If this parameter was passed both in registers and in the stack,\n+\t use the copy on the stack.  */\n+      if (MUST_PASS_IN_STACK (promoted_mode, passed_type))\n+\tentry_parm = 0;\n+\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+      if (entry_parm)\n+\tpartial = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, promoted_mode,\n+\t\t\t\t\t      passed_type, named_arg);\n #endif\n-\t\t\t   fndecl, &stack_args_size, &stack_offset, &arg_size,\n-\t\t\t   &alignment_pad);\n+\n+      memset (&locate, 0, sizeof (locate));\n+      locate_and_pad_parm (promoted_mode, passed_type, in_regs,\n+\t\t\t   entry_parm ? partial : 0, fndecl,\n+\t\t\t   &stack_args_size, &locate);\n \n       {\n-\trtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n+\trtx offset_rtx;\n+\n+\t/* If we're passing this arg using a reg, make its stack home\n+\t   the aligned stack slot.  */\n+\tif (entry_parm)\n+\t  offset_rtx = ARGS_SIZE_RTX (locate.slot_offset);\n+\telse\n+\t  offset_rtx = ARGS_SIZE_RTX (locate.offset);\n \n \tif (offset_rtx == const0_rtx)\n \t  stack_parm = gen_rtx_MEM (promoted_mode, internal_arg_pointer);\n@@ -4597,12 +4630,6 @@ assign_parms (fndecl)\n \t  set_reg_attrs_for_parm (entry_parm, stack_parm);\n       }\n \n-      /* If this parameter was passed both in registers and in the stack,\n-\t use the copy on the stack.  */\n-      if (MUST_PASS_IN_STACK (promoted_mode, passed_type))\n-\tentry_parm = 0;\n-\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n       /* If this parm was passed part in regs and part in memory,\n \t pretend it arrived entirely in memory\n \t by pushing the register-part onto the stack.\n@@ -4611,39 +4638,31 @@ assign_parms (fndecl)\n \t we could put it together in a pseudoreg directly,\n \t but for now that's not worth bothering with.  */\n \n-      if (entry_parm)\n+      if (partial)\n \t{\n-\t  int nregs = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, promoted_mode,\n-\t\t\t\t\t\t  passed_type, named_arg);\n-\n-\t  if (nregs > 0)\n-\t    {\n-#if defined (REG_PARM_STACK_SPACE) && !defined (MAYBE_REG_PARM_STACK_SPACE)\n-\t      /* When REG_PARM_STACK_SPACE is nonzero, stack space for\n-\t\t split parameters was allocated by our caller, so we\n-\t\t won't be pushing it in the prolog.  */\n-\t      if (REG_PARM_STACK_SPACE (fndecl) == 0)\n+#ifndef MAYBE_REG_PARM_STACK_SPACE\n+\t  /* When REG_PARM_STACK_SPACE is nonzero, stack space for\n+\t     split parameters was allocated by our caller, so we\n+\t     won't be pushing it in the prolog.  */\n+\t  if (reg_parm_stack_space)\n #endif\n-\t      current_function_pretend_args_size\n-\t\t= (((nregs * UNITS_PER_WORD) + (PARM_BOUNDARY / BITS_PER_UNIT) - 1)\n-\t\t   / (PARM_BOUNDARY / BITS_PER_UNIT)\n-\t\t   * (PARM_BOUNDARY / BITS_PER_UNIT));\n+\t  current_function_pretend_args_size\n+\t    = (((partial * UNITS_PER_WORD) + (PARM_BOUNDARY / BITS_PER_UNIT) - 1)\n+\t       / (PARM_BOUNDARY / BITS_PER_UNIT)\n+\t       * (PARM_BOUNDARY / BITS_PER_UNIT));\n \n-\t      /* Handle calls that pass values in multiple non-contiguous\n-\t\t locations.  The Irix 6 ABI has examples of this.  */\n-\t      if (GET_CODE (entry_parm) == PARALLEL)\n-\t\temit_group_store (validize_mem (stack_parm), entry_parm,\n-\t\t\t\t  int_size_in_bytes (TREE_TYPE (parm)));\n+\t  /* Handle calls that pass values in multiple non-contiguous\n+\t     locations.  The Irix 6 ABI has examples of this.  */\n+\t  if (GET_CODE (entry_parm) == PARALLEL)\n+\t    emit_group_store (validize_mem (stack_parm), entry_parm,\n+\t\t\t      int_size_in_bytes (TREE_TYPE (parm)));\n \n-\t      else\n-\t\tmove_block_from_reg (REGNO (entry_parm),\n-\t\t\t\t     validize_mem (stack_parm), nregs,\n-\t\t\t\t     int_size_in_bytes (TREE_TYPE (parm)));\n+\t  else\n+\t    move_block_from_reg (REGNO (entry_parm), validize_mem (stack_parm),\n+\t\t\t\t partial, int_size_in_bytes (TREE_TYPE (parm)));\n \n-\t      entry_parm = stack_parm;\n-\t    }\n+\t  entry_parm = stack_parm;\n \t}\n-#endif\n \n       /* If we didn't decide this parm came in a register,\n \t by default it came on the stack.  */\n@@ -4674,9 +4693,9 @@ assign_parms (fndecl)\n #endif\n \t  )\n \t{\n-\t  stack_args_size.constant += arg_size.constant;\n-\t  if (arg_size.var)\n-\t    ADD_PARM_SIZE (stack_args_size, arg_size.var);\n+\t  stack_args_size.constant += locate.size.constant;\n+\t  if (locate.size.var)\n+\t    ADD_PARM_SIZE (stack_args_size, locate.size.var);\n \t}\n       else\n \t/* No stack slot was pushed for this parm.  */\n@@ -4700,7 +4719,7 @@ assign_parms (fndecl)\n \n       /* If parm was passed in memory, and we need to convert it on entry,\n \t don't store it back in that same slot.  */\n-      if (entry_parm != 0\n+      if (entry_parm == stack_parm\n \t  && nominal_mode != BLKmode && nominal_mode != passed_mode)\n \tstack_parm = 0;\n \n@@ -5023,7 +5042,7 @@ assign_parms (fndecl)\n \t      && ! did_conversion\n \t      && stack_parm != 0\n \t      && GET_CODE (stack_parm) == MEM\n-\t      && stack_offset.var == 0\n+\t      && locate.offset.var == 0\n \t      && reg_mentioned_p (virtual_incoming_args_rtx,\n \t\t\t\t  XEXP (stack_parm, 0)))\n \t    {\n@@ -5109,7 +5128,8 @@ assign_parms (fndecl)\n \t\t{\n \t\t  stack_parm\n \t\t    = assign_stack_local (GET_MODE (entry_parm),\n-\t\t\t\t\t  GET_MODE_SIZE (GET_MODE (entry_parm)), 0);\n+\t\t\t\t\t  GET_MODE_SIZE (GET_MODE (entry_parm)),\n+\t\t\t\t\t  0);\n \t\t  set_mem_attributes (stack_parm, parm, 1);\n \t\t}\n \n@@ -5280,8 +5300,11 @@ promoted_input_arg (regno, pmode, punsignedp)\n    INITIAL_OFFSET_PTR points to the current offset into the stacked\n    arguments.\n \n-   The starting offset and size for this parm are returned in *OFFSET_PTR\n-   and *ARG_SIZE_PTR, respectively.\n+   The starting offset and size for this parm are returned in\n+   LOCATE->OFFSET and LOCATE->SIZE, respectively.  When IN_REGS is\n+   nonzero, the offset is that of stack slot, which is returned in\n+   LOCATE->SLOT_OFFSET.  LOCATE->ALIGNMENT_PAD is the amount of\n+   padding required from the initial offset ptr to the stack slot.\n \n    IN_REGS is nonzero if the argument will be passed in registers.  It will\n    never be set if REG_PARM_STACK_SPACE is not defined.\n@@ -5298,45 +5321,39 @@ promoted_input_arg (regno, pmode, punsignedp)\n    initial offset is not affected by this rounding, while the size always\n    is and the starting offset may be.  */\n \n-/*  offset_ptr will be negative for ARGS_GROW_DOWNWARD case;\n-    initial_offset_ptr is positive because locate_and_pad_parm's\n+/*  LOCATE->OFFSET will be negative for ARGS_GROW_DOWNWARD case;\n+    INITIAL_OFFSET_PTR is positive because locate_and_pad_parm's\n     callers pass in the total size of args so far as\n-    initial_offset_ptr. arg_size_ptr is always positive.  */\n+    INITIAL_OFFSET_PTR.  LOCATE->SIZE is always positive.  */\n \n void\n-locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n-\t\t     initial_offset_ptr, offset_ptr, arg_size_ptr,\n-\t\t     alignment_pad)\n+locate_and_pad_parm (passed_mode, type, in_regs, partial, fndecl,\n+\t\t     initial_offset_ptr, locate)\n      enum machine_mode passed_mode;\n      tree type;\n-     int in_regs ATTRIBUTE_UNUSED;\n+     int in_regs;\n+     int partial;\n      tree fndecl ATTRIBUTE_UNUSED;\n      struct args_size *initial_offset_ptr;\n-     struct args_size *offset_ptr;\n-     struct args_size *arg_size_ptr;\n-     struct args_size *alignment_pad;\n-\n+     struct locate_and_pad_arg_data *locate;\n {\n-  tree sizetree\n-    = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n-  enum direction where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n-  int boundary = FUNCTION_ARG_BOUNDARY (passed_mode, type);\n-#ifdef ARGS_GROW_DOWNWARD\n-  tree s2 = sizetree;\n-#endif\n+  tree sizetree;\n+  enum direction where_pad;\n+  int boundary;\n+  int reg_parm_stack_space = 0;\n+  int part_size_in_regs;\n \n #ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+\n   /* If we have found a stack parm before we reach the end of the\n      area reserved for registers, skip that area.  */\n   if (! in_regs)\n     {\n-      int reg_parm_stack_space = 0;\n-\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-      reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n-      reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n-#endif\n       if (reg_parm_stack_space > 0)\n \t{\n \t  if (initial_offset_ptr->var)\n@@ -5352,63 +5369,66 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n     }\n #endif /* REG_PARM_STACK_SPACE */\n \n-  arg_size_ptr->var = 0;\n-  arg_size_ptr->constant = 0;\n-  alignment_pad->var = 0;\n-  alignment_pad->constant = 0;\n+  part_size_in_regs = 0;\n+  if (reg_parm_stack_space == 0)\n+    part_size_in_regs = ((partial * UNITS_PER_WORD)\n+\t\t\t / (PARM_BOUNDARY / BITS_PER_UNIT)\n+\t\t\t * (PARM_BOUNDARY / BITS_PER_UNIT));\n+\n+  sizetree\n+    = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n+  where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n+  boundary = FUNCTION_ARG_BOUNDARY (passed_mode, type);\n \n #ifdef ARGS_GROW_DOWNWARD\n+  locate->slot_offset.constant = -initial_offset_ptr->constant;\n   if (initial_offset_ptr->var)\n-    {\n-      offset_ptr->constant = 0;\n-      offset_ptr->var = size_binop (MINUS_EXPR, ssize_int (0),\n-\t\t\t\t    initial_offset_ptr->var);\n-    }\n-  else\n-    {\n-      offset_ptr->constant = -initial_offset_ptr->constant;\n-      offset_ptr->var = 0;\n-    }\n+    locate->slot_offset.var = size_binop (MINUS_EXPR, ssize_int (0),\n+\t\t\t\t\t  initial_offset_ptr->var);\n \n-  if (where_pad != none\n-      && (!host_integerp (sizetree, 1)\n-\t  || (tree_low_cst (sizetree, 1) * BITS_PER_UNIT) % PARM_BOUNDARY))\n-    s2 = round_up (s2, PARM_BOUNDARY / BITS_PER_UNIT);\n-  SUB_PARM_SIZE (*offset_ptr, s2);\n+  {\n+    tree s2 = sizetree;\n+    if (where_pad != none\n+\t&& (!host_integerp (sizetree, 1)\n+\t    || (tree_low_cst (sizetree, 1) * BITS_PER_UNIT) % PARM_BOUNDARY))\n+      s2 = round_up (s2, PARM_BOUNDARY / BITS_PER_UNIT);\n+    SUB_PARM_SIZE (locate->slot_offset, s2);\n+  }\n+\n+  locate->slot_offset.constant += part_size_in_regs;\n \n   if (!in_regs\n #ifdef REG_PARM_STACK_SPACE\n       || REG_PARM_STACK_SPACE (fndecl) > 0\n #endif\n      )\n-    pad_to_arg_alignment (offset_ptr, boundary, alignment_pad);\n+    pad_to_arg_alignment (&locate->slot_offset, boundary,\n+\t\t\t  &locate->alignment_pad);\n \n+  locate->size.constant = (-initial_offset_ptr->constant\n+\t\t\t   - locate->slot_offset.constant);\n   if (initial_offset_ptr->var)\n-    arg_size_ptr->var = size_binop (MINUS_EXPR,\n-\t\t\t\t    size_binop (MINUS_EXPR,\n-\t\t\t\t\t\tssize_int (0),\n-\t\t\t\t\t\tinitial_offset_ptr->var),\n-\t\t\t\t    offset_ptr->var);\n-\n-  else\n-    arg_size_ptr->constant = (-initial_offset_ptr->constant\n-\t\t\t      - offset_ptr->constant);\n-\n-  /* Pad_below needs the pre-rounded size to know how much to pad below.\n-     We only pad parameters which are not in registers as they have their\n-     padding done elsewhere.  */\n-  if (where_pad == downward\n-      && !in_regs)\n-    pad_below (offset_ptr, passed_mode, sizetree);\n+    locate->size.var = size_binop (MINUS_EXPR,\n+\t\t\t\t   size_binop (MINUS_EXPR,\n+\t\t\t\t\t       ssize_int (0),\n+\t\t\t\t\t       initial_offset_ptr->var),\n+\t\t\t\t   locate->slot_offset.var);\n+\n+  /* Pad_below needs the pre-rounded size to know how much to pad\n+     below.  */\n+  locate->offset = locate->slot_offset;\n+  if (where_pad == downward)\n+    pad_below (&locate->offset, passed_mode, sizetree);\n \n #else /* !ARGS_GROW_DOWNWARD */\n   if (!in_regs\n #ifdef REG_PARM_STACK_SPACE\n       || REG_PARM_STACK_SPACE (fndecl) > 0\n #endif\n       )\n-    pad_to_arg_alignment (initial_offset_ptr, boundary, alignment_pad);\n-  *offset_ptr = *initial_offset_ptr;\n+    pad_to_arg_alignment (initial_offset_ptr, boundary,\n+\t\t\t  &locate->alignment_pad);\n+  locate->slot_offset = *initial_offset_ptr;\n \n #ifdef PUSH_ROUNDING\n   if (passed_mode != BLKmode)\n@@ -5417,18 +5437,18 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n \n   /* Pad_below needs the pre-rounded size to know how much to pad below\n      so this must be done before rounding up.  */\n-  if (where_pad == downward\n-    /* However, BLKmode args passed in regs have their padding done elsewhere.\n-       The stack slot must be able to hold the entire register.  */\n-      && !(in_regs && passed_mode == BLKmode))\n-    pad_below (offset_ptr, passed_mode, sizetree);\n+  locate->offset = locate->slot_offset;\n+  if (where_pad == downward)\n+    pad_below (&locate->offset, passed_mode, sizetree);\n \n   if (where_pad != none\n       && (!host_integerp (sizetree, 1)\n \t  || (tree_low_cst (sizetree, 1) * BITS_PER_UNIT) % PARM_BOUNDARY))\n     sizetree = round_up (sizetree, PARM_BOUNDARY / BITS_PER_UNIT);\n \n-  ADD_PARM_SIZE (*arg_size_ptr, sizetree);\n+  ADD_PARM_SIZE (locate->size, sizetree);\n+\n+  locate->size.constant -= part_size_in_regs;\n #endif /* ARGS_GROW_DOWNWARD */\n }\n \n@@ -5467,7 +5487,8 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n #endif\n \t      (ARGS_SIZE_TREE (*offset_ptr),\n \t       boundary / BITS_PER_UNIT);\n-\t  offset_ptr->constant = 0; /*?*/\n+\t  /* ARGS_SIZE_TREE includes constant term.  */\n+\t  offset_ptr->constant = 0;\n \t  if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n \t    alignment_pad->var = size_binop (MINUS_EXPR, offset_ptr->var,\n \t\t\t\t\t     save_var);"}]}