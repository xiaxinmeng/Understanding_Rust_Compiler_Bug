{"sha": "408de159d47ec1da831ec7c8fa752c68fad618c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA4ZGUxNTlkNDdlYzFkYTgzMWVjN2M4ZmE3NTJjNjhmYWQ2MThjOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-01-17T15:04:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-01-17T15:04:50Z"}, "message": "ipa-visibility.c (localize_node): New function, broken out of\t...\n\n\t* ipa-visibility.c (localize_node): New function, broken out of\t...\n\t(function_and_variable_visibility): ... here. Call it.\n\nFrom-SVN: r244529", "tree": {"sha": "e073406730177be073af1ff7574ccfdc5b7ce553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e073406730177be073af1ff7574ccfdc5b7ce553"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/408de159d47ec1da831ec7c8fa752c68fad618c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408de159d47ec1da831ec7c8fa752c68fad618c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408de159d47ec1da831ec7c8fa752c68fad618c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408de159d47ec1da831ec7c8fa752c68fad618c8/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0"}], "stats": {"total": 137, "additions": 55, "deletions": 82}, "files": [{"sha": "43419bec41a1aa647692354af7c61e52a5caf7c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408de159d47ec1da831ec7c8fa752c68fad618c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408de159d47ec1da831ec7c8fa752c68fad618c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=408de159d47ec1da831ec7c8fa752c68fad618c8", "patch": "@@ -1,3 +1,8 @@\n+2017-01-17  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* ipa-visibility.c (localize_node): New function, broken out of ...\n+\t(function_and_variable_visibility): ... here. Call it.\n+\n 2017-01-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR middle-end/77445"}, {"sha": "de96b692a0de882dd60405166944e44cdaa4f1b5", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 50, "deletions": 82, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408de159d47ec1da831ec7c8fa752c68fad618c8/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408de159d47ec1da831ec7c8fa752c68fad618c8/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=408de159d47ec1da831ec7c8fa752c68fad618c8", "patch": "@@ -529,6 +529,53 @@ optimize_weakref (symtab_node *node)\n   gcc_assert (node->alias);\n }\n \n+/* NODE is an externally visible definition, which we've discovered is\n+   not needed externally.  Make it local to this compilation.  */\n+\n+static void\n+localize_node (bool whole_program, symtab_node *node)\n+{\n+  gcc_assert (whole_program || in_lto_p || !TREE_PUBLIC (node->decl));\n+\n+  if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n+    {\n+      for (symtab_node *next = node->same_comdat_group;\n+\t   next != node; next = next->same_comdat_group)\n+\t{\n+\t  next->set_comdat_group (NULL);\n+\t  if (!next->alias)\n+\t    next->set_section (NULL);\n+\t  if (!next->transparent_alias)\n+\t    next->make_decl_local ();\n+\t  next->unique_name\n+\t    |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t&& TREE_PUBLIC (next->decl)\n+\t\t&& !flag_incremental_link);\n+\t}\n+\n+      /* Now everything's localized, the grouping has no meaning, and\n+\t will cause crashes if we keep it around.  */\n+      node->dissolve_same_comdat_group_list ();\n+    }\n+\n+  node->unique_name\n+    |= ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t&& TREE_PUBLIC (node->decl)\n+\t&& !flag_incremental_link);\n+\n+  if (TREE_PUBLIC (node->decl))\n+    node->set_comdat_group (NULL);\n+  if (DECL_COMDAT (node->decl) && !node->alias)\n+    node->set_section (NULL);\n+  if (!node->transparent_alias)\n+    {\n+      node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+      node->make_decl_local ();\n+    }\n+}\n+\n /* Decide on visibility of all symbols.  */\n \n static unsigned int\n@@ -606,48 +653,7 @@ function_and_variable_visibility (bool whole_program)\n       if (!node->externally_visible\n \t  && node->definition && !node->weakref\n \t  && !DECL_EXTERNAL (node->decl))\n-\t{\n-\t  gcc_assert (whole_program || in_lto_p\n-\t\t      || !TREE_PUBLIC (node->decl));\n-\t  node->unique_name\n-\t    |= ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t&& TREE_PUBLIC (node->decl)\n-\t\t&& !flag_incremental_link);\n-\t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n-\t    {\n-\t      symtab_node *next = node;\n-\n-\t      /* Set all members of comdat group local.  */\n-\t      for (next = node->same_comdat_group;\n-\t\t   next != node;\n-\t\t   next = next->same_comdat_group)\n-\t\t{\n-\t\t  next->set_comdat_group (NULL);\n-\t\t  if (!next->alias)\n-\t\t    next->set_section (NULL);\n-\t\t  if (!next->transparent_alias)\n-\t\t    next->make_decl_local ();\n-\t\t  next->unique_name\n-\t\t    |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t&& TREE_PUBLIC (next->decl)\n-\t\t\t&& !flag_incremental_link);\n-\t\t}\n-\t      /* cgraph_externally_visible_p has already checked all\n-\t         other nodes in the group and they will all be made\n-\t         local.  We need to dissolve the group at once so that\n-\t         the predicate does not segfault though. */\n-\t      node->dissolve_same_comdat_group_list ();\n-\t    }\n-\t  if (TREE_PUBLIC (node->decl))\n-\t    node->set_comdat_group (NULL);\n-\t  if (DECL_COMDAT (node->decl) && !node->alias)\n-\t    node->set_section (NULL);\n-\t  if (!node->transparent_alias)\n-\t    node->make_decl_local ();\n-\t}\n+\tlocalize_node (whole_program, node);\n \n       if (node->thunk.thunk_p\n \t  && !node->thunk.add_pointer_bounds_args\n@@ -757,49 +763,11 @@ function_and_variable_visibility (bool whole_program)\n       if (lookup_attribute (\"no_reorder\",\n \t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n \tvnode->no_reorder = 1;\n+\n       if (!vnode->externally_visible\n \t  && !vnode->transparent_alias)\n-\t{\n-\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n-\t  vnode->unique_name |= ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t          || vnode->resolution\n-\t\t\t\t      == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t         && TREE_PUBLIC (vnode->decl)\n-\t\t\t\t && !flag_incremental_link);\n-\t  if (vnode->same_comdat_group && TREE_PUBLIC (vnode->decl))\n-\t    {\n-\t      symtab_node *next = vnode;\n+\tlocalize_node (whole_program, vnode);\n \n-\t      /* Set all members of comdat group local.  */\n-\t      if (vnode->same_comdat_group)\n-\t\tfor (next = vnode->same_comdat_group;\n-\t\t     next != vnode;\n-\t\t     next = next->same_comdat_group)\n-\t\t{\n-\t\t  next->set_comdat_group (NULL);\n-\t\t  if (!next->alias)\n-\t\t    next->set_section (NULL);\n-\t\t  if (!next->transparent_alias)\n-\t\t    {\n-\t\t      next->make_decl_local ();\n-\t\t      next->unique_name |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t\t     || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t\t    && TREE_PUBLIC (next->decl)\n-\t\t\t\t\t    && !flag_incremental_link);\n-\t\t    }\n-\t\t}\n-\t      vnode->dissolve_same_comdat_group_list ();\n-\t    }\n-\t  if (TREE_PUBLIC (vnode->decl))\n-\t    vnode->set_comdat_group (NULL);\n-\t  if (DECL_COMDAT (vnode->decl) && !vnode->alias)\n-\t    vnode->set_section (NULL);\n-\t  if (!vnode->transparent_alias)\n-\t    {\n-\t      vnode->make_decl_local ();\n-\t      vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t    }\n-\t}\n       update_visibility_by_resolution_info (vnode);\n \n       /* Update virtual tables to point to local aliases where possible.  */"}]}