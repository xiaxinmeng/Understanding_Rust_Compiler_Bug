{"sha": "cb642590f317e30bd870b47934dac12a71f320b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I2NDI1OTBmMzE3ZTMwYmQ4NzBiNDc5MzRkYWMxMmE3MWYzMjBiMQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-09-04T17:52:45Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-09-04T17:52:45Z"}, "message": "[multiple changes]\n\n2007-09-04    <aph@redhat.com>\n\n\t* src/arm/sysv.S (UNWIND): New.\n\t(Whole file): Conditionally compile unwinder directives.\n\t* src/arm/sysv.S: Add unwinder directives.\n\n\t* src/arm/ffi.c (ffi_prep_args): Align structs by at least 4 bytes.\n\tOnly treat r0 as a struct address if we're actually returning a\n\tstruct by address.\n\tOnly copy the bytes that are actually within a struct.\n\t(ffi_prep_cif_machdep): A Composite Type not larger than 4 bytes\n\tis returned in r0, not passed by address.\n\t(ffi_call): Allocate a word-sized temporary for the case where\n\ta composite is returned in r0.\n\t(ffi_prep_incoming_args_SYSV): Align as necessary.\n\n2007-08-05  Steven Newbury  <s_j_newbury@yahoo.co.uk>\n\n\t* src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Use __clear_cache instead of \n\tdirectly using the sys_cacheflush syscall.\n\n2007-07-27  Andrew Haley  <aph@redhat.com>\n\n\t* src/arm/sysv.S (ffi_closure_SYSV): Add soft-float.\n\nFrom-SVN: r128093", "tree": {"sha": "d13cfee0ec940dc46a16be0b7f6a8544c13ae337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d13cfee0ec940dc46a16be0b7f6a8544c13ae337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb642590f317e30bd870b47934dac12a71f320b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb642590f317e30bd870b47934dac12a71f320b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb642590f317e30bd870b47934dac12a71f320b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb642590f317e30bd870b47934dac12a71f320b1/comments", "author": null, "committer": null, "parents": [{"sha": "4d4b8cb9c0f82c22252018b1b25cd8b3c63166b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4b8cb9c0f82c22252018b1b25cd8b3c63166b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4b8cb9c0f82c22252018b1b25cd8b3c63166b3"}], "stats": {"total": 126, "additions": 104, "deletions": 22}, "files": [{"sha": "0f434c862762c8ebb17df50c5d753643741e0f03", "filename": "libffi/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb642590f317e30bd870b47934dac12a71f320b1/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb642590f317e30bd870b47934dac12a71f320b1/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=cb642590f317e30bd870b47934dac12a71f320b1", "patch": "@@ -1,3 +1,28 @@\n+2007-09-04    <aph@redhat.com>\n+\n+\t* src/arm/sysv.S (UNWIND): New.\n+\t(Whole file): Conditionally compile unwinder directives.\n+\t* src/arm/sysv.S: Add unwinder directives.\n+\n+\t* src/arm/ffi.c (ffi_prep_args): Align structs by at least 4 bytes.\n+\tOnly treat r0 as a struct address if we're actually returning a\n+\tstruct by address.\n+\tOnly copy the bytes that are actually within a struct.\n+\t(ffi_prep_cif_machdep): A Composite Type not larger than 4 bytes\n+\tis returned in r0, not passed by address.\n+\t(ffi_call): Allocate a word-sized temporary for the case where\n+\ta composite is returned in r0.\n+\t(ffi_prep_incoming_args_SYSV): Align as necessary.\n+\n+2007-08-05  Steven Newbury  <s_j_newbury@yahoo.co.uk>\n+\n+\t* src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Use __clear_cache instead of \n+\tdirectly using the sys_cacheflush syscall.\n+\n+2007-07-27  Andrew Haley  <aph@redhat.com>\n+\n+\t* src/arm/sysv.S (ffi_closure_SYSV): Add soft-float.\n+\n 2007-09-03  Maciej W. Rozycki  <macro@linux-mips.org>\n \n \t* Makefile.am: Unify MIPS_IRIX and MIPS_LINUX into MIPS."}, {"sha": "35b2c3477a485f1425c7ba27bc689decc707befc", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb642590f317e30bd870b47934dac12a71f320b1/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb642590f317e30bd870b47934dac12a71f320b1/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=cb642590f317e30bd870b47934dac12a71f320b1", "patch": "@@ -40,7 +40,7 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \n   argp = stack;\n \n-  if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT ) {\n+  if ( ecif->cif->flags == FFI_TYPE_STRUCT ) {\n     *(void **) argp = ecif->rvalue;\n     argp += 4;\n   }\n@@ -58,6 +58,9 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \targp = (char *) ALIGN(argp, (*p_arg)->alignment);\n       }\n \n+      if ((*p_arg)->type == FFI_TYPE_STRUCT)\n+\targp = (char *) ALIGN(argp, 4);\n+\n \t  z = (*p_arg)->size;\n \t  if (z < sizeof(int))\n \t    {\n@@ -81,7 +84,7 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \t\t  break;\n \t\t  \n \t\tcase FFI_TYPE_STRUCT:\n-\t\t  *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n+\t\t  memcpy(argp, *p_argv, (*p_arg)->size);\n \t\t  break;\n \n \t\tdefault:\n@@ -115,7 +118,6 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   switch (cif->rtype->type)\n     {\n     case FFI_TYPE_VOID:\n-    case FFI_TYPE_STRUCT:\n     case FFI_TYPE_FLOAT:\n     case FFI_TYPE_DOUBLE:\n       cif->flags = (unsigned) cif->rtype->type;\n@@ -126,6 +128,17 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       cif->flags = (unsigned) FFI_TYPE_SINT64;\n       break;\n \n+    case FFI_TYPE_STRUCT:\n+      if (cif->rtype->size <= 4)\n+\t/* A Composite Type not larger than 4 bytes is returned in r0.  */\n+\tcif->flags = (unsigned)FFI_TYPE_INT;\n+      else\n+\t/* A Composite Type larger than 4 bytes, or whose size cannot\n+\t   be determined statically ... is stored in memory at an\n+\t   address passed [in r0].  */\n+\tcif->flags = (unsigned)FFI_TYPE_STRUCT;\n+      break;\n+\n     default:\n       cif->flags = FFI_TYPE_INT;\n       break;\n@@ -141,21 +154,27 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n+  int small_struct = (cif->flags == FFI_TYPE_INT \n+\t\t      && cif->rtype->type == FFI_TYPE_STRUCT);\n+\n   ecif.cif = cif;\n   ecif.avalue = avalue;\n+\n+  unsigned int temp;\n   \n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n \n   if ((rvalue == NULL) && \n-      (cif->rtype->type == FFI_TYPE_STRUCT))\n+      (cif->flags == FFI_TYPE_STRUCT))\n     {\n       ecif.rvalue = alloca(cif->rtype->size);\n     }\n+  else if (small_struct)\n+    ecif.rvalue = &temp;\n   else\n     ecif.rvalue = rvalue;\n-    \n-  \n+\n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n@@ -167,6 +186,8 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n       FFI_ASSERT(0);\n       break;\n     }\n+  if (small_struct)\n+    memcpy (rvalue, &temp, cif->rtype->size);\n }\n \n /** private members **/\n@@ -228,9 +249,12 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n     {\n       size_t z;\n \n+      size_t alignment = (*p_arg)->alignment;\n+      if (alignment < 4)\n+\talignment = 4;\n       /* Align if necessary */\n-      if ((sizeof(int) - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, sizeof(int));\n+      if ((alignment - 1) & (unsigned) argp) {\n+\targp = (char *) ALIGN(argp, alignment);\n       }\n \n       z = (*p_arg)->size;\n@@ -248,21 +272,16 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n \n /* How to make a trampoline.  */\n \n-#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \\\n-({ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n-   unsigned int  __fun = (unsigned int)(FUN); \\\n-   unsigned int  __ctx = (unsigned int)(CTX); \\\n+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)\t\t\t\t\\\n+({ unsigned char *__tramp = (unsigned char*)(TRAMP);\t\t\t\\\n+   unsigned int  __fun = (unsigned int)(FUN);\t\t\t\t\\\n+   unsigned int  __ctx = (unsigned int)(CTX);\t\t\t\t\\\n    *(unsigned int*) &__tramp[0] = 0xe92d000f; /* stmfd sp!, {r0-r3} */\t\\\n-   *(unsigned int*) &__tramp[4] = 0xe59f0000; /* ldr r0, [pc] */ \\\n-   *(unsigned int*) &__tramp[8] = 0xe59ff000; /* ldr pc, [pc] */ \\\n-   *(unsigned int*) &__tramp[12] = __ctx; \\\n-   *(unsigned int*) &__tramp[16] = __fun; \\\n-   register unsigned long _beg __asm (\"a1\") = (unsigned long) (&__tramp[0]);\t\\\n-   register unsigned long _end __asm (\"a2\") = (unsigned long) (&__tramp[19]);\t\\\n-   register unsigned long _flg __asm (\"a3\") = 0;\t\t\t\\\n-   __asm __volatile (\"swi 0x9f0002\t\t@ sys_cacheflush\"\t\\\n-\t   \t\t    : \"=r\" (_beg)\t\t\t\t\\\n-\t   \t\t    : \"0\" (_beg), \"r\" (_end), \"r\" (_flg));\t\\\n+   *(unsigned int*) &__tramp[4] = 0xe59f0000; /* ldr r0, [pc] */\t\\\n+   *(unsigned int*) &__tramp[8] = 0xe59ff000; /* ldr pc, [pc] */\t\\\n+   *(unsigned int*) &__tramp[12] = __ctx;\t\t\t\t\\\n+   *(unsigned int*) &__tramp[16] = __fun;\t\t\t\t\\\n+   __clear_cache((&__tramp[0]), (&__tramp[19]));\t\t\t\\\n  })\n \n "}, {"sha": "12876d1205435f6348e24a0c1ff186b44f5903bb", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb642590f317e30bd870b47934dac12a71f320b1/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb642590f317e30bd870b47934dac12a71f320b1/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=cb642590f317e30bd870b47934dac12a71f320b1", "patch": "@@ -82,6 +82,14 @@\n # define call_reg(x)\tmov\tlr, pc ; mov\tpc, x\n #endif\n \n+/* Conditionally compile unwinder directives.  */\n+#ifdef __ARM_EABI__\n+#define UNWIND\n+#else\n+#define UNWIND @\n+#endif\t\n+\n+\t\n #if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n .macro\tARM_FUNC_START name\n \t.text\n@@ -92,6 +100,7 @@\n \tbx\tpc\n \tnop\n \t.arm\n+\tUNWIND .fnstart\n /* A hook to tell gdb that we've switched to ARM mode.  Also used to call\n    directly from other local arm routines.  */\n _L__\\name:\t\t\n@@ -102,6 +111,7 @@ _L__\\name:\n \t.align 0\n \t.arm\n \tENTRY(\\name)\n+\tUNWIND .fnstart\n .endm\n #endif\n \n@@ -134,8 +144,11 @@ _L__\\name:\n ARM_FUNC_START ffi_call_SYSV\n \t@ Save registers\n         stmfd\tsp!, {r0-r3, fp, lr}\n+\tUNWIND .save\t{r0-r3, fp, lr}\n \tmov\tfp, sp\n \n+\tUNWIND .setfp\tfp, sp\n+\n \t@ Make room for all of the new args.\n \tsub\tsp, fp, r2\n \n@@ -205,6 +218,7 @@ LSYM(Lepilogue):\n \tRETLDM\t\"r0-r3,fp\"\n \n .ffi_call_SYSV_end:\n+\tUNWIND .fnend\n         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)\n \n /*\n@@ -216,21 +230,40 @@ LSYM(Lepilogue):\n */\n \n ARM_FUNC_START ffi_closure_SYSV\n+\tUNWIND .pad #16\n \tadd\tip, sp, #16\n \tstmfd\tsp!, {ip, lr}\n+\tUNWIND .save\t{r0, lr}\n \tadd\tr2, sp, #8\n+\t.pad #16\n \tsub\tsp, sp, #16\n \tstr\tsp, [sp, #8]\n \tadd\tr1, sp, #8\n \tbl\tffi_closure_SYSV_inner\n \tcmp\tr0, #FFI_TYPE_INT\n \tbeq\t.Lretint\n+\n \tcmp\tr0, #FFI_TYPE_FLOAT\n+#ifdef __SOFTFP__\n+\tbeq\t.Lretint\n+#else\n \tbeq\t.Lretfloat\n+#endif\n+\n \tcmp\tr0, #FFI_TYPE_DOUBLE\n+#ifdef __SOFTFP__\n+\tbeq\t.Lretlonglong\n+#else\n \tbeq\t.Lretdouble\n+#endif\n+\n \tcmp\tr0, #FFI_TYPE_LONGDOUBLE\n+#ifdef __SOFTFP__\n+\tbeq\t.Lretlonglong\n+#else\n \tbeq\t.Lretlongdouble\n+#endif\n+\n \tcmp\tr0, #FFI_TYPE_SINT64\n \tbeq\t.Lretlonglong\n .Lclosure_epilogue:\n@@ -243,6 +276,8 @@ ARM_FUNC_START ffi_closure_SYSV\n \tldr\tr0, [sp]\n \tldr\tr1, [sp, #4]\n \tb\t.Lclosure_epilogue\n+\n+#ifndef __SOFTFP__\n .Lretfloat:\n \tldfs\tf0, [sp]\n \tb\t.Lclosure_epilogue\n@@ -252,6 +287,9 @@ ARM_FUNC_START ffi_closure_SYSV\n .Lretlongdouble:\n \tldfd\tf0, [sp]\n \tb\t.Lclosure_epilogue\n+#endif\n+\n .ffi_closure_SYSV_end:\n+\tUNWIND .fnend\n         .size    CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)\n "}]}