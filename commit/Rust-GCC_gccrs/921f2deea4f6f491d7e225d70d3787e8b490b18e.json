{"sha": "921f2deea4f6f491d7e225d70d3787e8b490b18e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIxZjJkZWVhNGY2ZjQ5MWQ3ZTIyNWQ3MGQzNzg3ZThiNDkwYjE4ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2013-02-07T02:37:37Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-02-07T02:37:37Z"}, "message": "re PR target/54009 (incorrect code generated for DFmode lo_sum mem)\n\ngcc/\n\tPR target/54009\n\t* config/rs6000/rs6000.c (mem_operand_gpr): Check that LO_SUM\n\taddresses won't wrap when offsetting.\n\t(rs6000_secondary_reload): Provide secondary reloads needed for\n\twrapping LO_SUM addresses.\n\ngcc/testsuite/\n\tPR target/54009\n\t* gcc.target/powerpc/pr54009.c: New test.\n\nFrom-SVN: r195836", "tree": {"sha": "74f7dae5dd35b7b9606b665fc48d100c21ef808a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f7dae5dd35b7b9606b665fc48d100c21ef808a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/921f2deea4f6f491d7e225d70d3787e8b490b18e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921f2deea4f6f491d7e225d70d3787e8b490b18e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/921f2deea4f6f491d7e225d70d3787e8b490b18e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921f2deea4f6f491d7e225d70d3787e8b490b18e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cdf383b6498460f095ff6a385270ebcfcb39a42c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf383b6498460f095ff6a385270ebcfcb39a42c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf383b6498460f095ff6a385270ebcfcb39a42c"}], "stats": {"total": 163, "additions": 124, "deletions": 39}, "files": [{"sha": "148aa675c8a8b26a6b0dff54a3fe34d6de9cac5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=921f2deea4f6f491d7e225d70d3787e8b490b18e", "patch": "@@ -1,3 +1,11 @@\n+2013-02-07  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/54009\n+\t* config/rs6000/rs6000.c (mem_operand_gpr): Check that LO_SUM\n+\taddresses won't wrap when offsetting.\n+\t(rs6000_secondary_reload): Provide secondary reloads needed for\n+\twrapping LO_SUM addresses.\n+\n 2013-02-06  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* config/gnu.h (GNU_USER_TARGET_OS_CPP_BUILTINS): Never define"}, {"sha": "8b5f030c5511e74cd20d8aa2bb44dcced4790857", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 71, "deletions": 39, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=921f2deea4f6f491d7e225d70d3787e8b490b18e", "patch": "@@ -5135,17 +5135,14 @@ mem_operand_gpr (rtx op, enum machine_mode mode)\n   if (TARGET_POWERPC64 && (offset & 3) != 0)\n     return false;\n \n-  if (GET_CODE (addr) == LO_SUM)\n-    /* We know by alignment that ABI_AIX medium/large model toc refs\n-       will not cross a 32k boundary, since all entries in the\n-       constant pool are naturally aligned and we check alignment for\n-       other medium model toc-relative addresses.  For ABI_V4 and\n-       ABI_DARWIN lo_sum addresses, we just check that 64-bit\n-       offsets are 4-byte aligned.  */\n-    return true;\n-\n   extra = GET_MODE_SIZE (mode) - UNITS_PER_WORD;\n   gcc_assert (extra >= 0);\n+\n+  if (GET_CODE (addr) == LO_SUM)\n+    /* For lo_sum addresses, we must allow any offset except one that\n+       causes a wrap, so test only the low 16 bits.  */\n+    offset = ((offset & 0xffff) ^ 0x8000) - 0x8000;\n+\n   return offset + 0x8000 < 0x10000u - extra;\n }\n \f\n@@ -13823,19 +13820,36 @@ rs6000_secondary_reload (bool in_p,\n \t   && MEM_P (x)\n \t   && GET_MODE_SIZE (GET_MODE (x)) >= UNITS_PER_WORD)\n     {\n-      rtx off = address_offset (XEXP (x, 0));\n-      unsigned int extra = GET_MODE_SIZE (GET_MODE (x)) - UNITS_PER_WORD;\n-\n-      if (off != NULL_RTX\n-\t  && (INTVAL (off) & 3) != 0\n-\t  && (unsigned HOST_WIDE_INT) INTVAL (off) + 0x8000 < 0x10000 - extra)\n-\t{\n-\t  if (in_p)\n-\t    sri->icode = CODE_FOR_reload_di_load;\n+      rtx addr = XEXP (x, 0);\n+      rtx off = address_offset (addr);\n+\n+      if (off != NULL_RTX)\n+\t{\n+\t  unsigned int extra = GET_MODE_SIZE (GET_MODE (x)) - UNITS_PER_WORD;\n+\t  unsigned HOST_WIDE_INT offset = INTVAL (off);\n+\n+\t  /* We need a secondary reload when our legitimate_address_p\n+\t     says the address is good (as otherwise the entire address\n+\t     will be reloaded), and the offset is not a multiple of\n+\t     four or we have an address wrap.  Address wrap will only\n+\t     occur for LO_SUMs since legitimate_offset_address_p\n+\t     rejects addresses for 16-byte mems that will wrap.  */\n+\t  if (GET_CODE (addr) == LO_SUM\n+\t      ? (1 /* legitimate_address_p allows any offset for lo_sum */\n+\t\t && ((offset & 3) != 0\n+\t\t     || ((offset & 0xffff) ^ 0x8000) >= 0x10000 - extra))\n+\t      : (offset + 0x8000 < 0x10000 - extra /* legitimate_address_p */\n+\t\t && (offset & 3) != 0))\n+\t    {\n+\t      if (in_p)\n+\t\tsri->icode = CODE_FOR_reload_di_load;\n+\t      else\n+\t\tsri->icode = CODE_FOR_reload_di_store;\n+\t      sri->extra_cost = 2;\n+\t      ret = NO_REGS;\n+\t    }\n \t  else\n-\t    sri->icode = CODE_FOR_reload_di_store;\n-\t  sri->extra_cost = 2;\n-\t  ret = NO_REGS;\n+\t    default_p = true;\n \t}\n       else\n \tdefault_p = true;\n@@ -13845,25 +13859,43 @@ rs6000_secondary_reload (bool in_p,\n \t   && MEM_P (x)\n \t   && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n     {\n-      rtx off = address_offset (XEXP (x, 0));\n-      unsigned int extra = GET_MODE_SIZE (GET_MODE (x)) - UNITS_PER_WORD;\n-\n-      /* We need a secondary reload only when our legitimate_address_p\n-\t says the address is good (as otherwise the entire address\n-\t will be reloaded).  So for mode sizes of 8 and 16 this will\n-\t be when the offset is in the ranges [0x7ffc,0x7fff] and\n-\t [0x7ff4,0x7ff7] respectively.  Note that the address we see\n-\t here may have been manipulated by legitimize_reload_address.  */\n-      if (off != NULL_RTX\n-\t  && ((unsigned HOST_WIDE_INT) INTVAL (off) - (0x8000 - extra)\n-\t      < UNITS_PER_WORD))\n-\t{\n-\t  if (in_p)\n-\t    sri->icode = CODE_FOR_reload_si_load;\n+      rtx addr = XEXP (x, 0);\n+      rtx off = address_offset (addr);\n+\n+      if (off != NULL_RTX)\n+\t{\n+\t  unsigned int extra = GET_MODE_SIZE (GET_MODE (x)) - UNITS_PER_WORD;\n+\t  unsigned HOST_WIDE_INT offset = INTVAL (off);\n+\n+\t  /* We need a secondary reload when our legitimate_address_p\n+\t     says the address is good (as otherwise the entire address\n+\t     will be reloaded), and we have a wrap.\n+\n+\t     legitimate_lo_sum_address_p allows LO_SUM addresses to\n+\t     have any offset so test for wrap in the low 16 bits.\n+\n+\t     legitimate_offset_address_p checks for the range\n+\t     [-0x8000,0x7fff] for mode size of 8 and [-0x8000,0x7ff7]\n+\t     for mode size of 16.  We wrap at [0x7ffc,0x7fff] and\n+\t     [0x7ff4,0x7fff] respectively, so test for the\n+\t     intersection of these ranges, [0x7ffc,0x7fff] and\n+\t     [0x7ff4,0x7ff7] respectively.\n+\n+\t     Note that the address we see here may have been\n+\t     manipulated by legitimize_reload_address.  */\n+\t  if (GET_CODE (addr) == LO_SUM\n+\t      ? ((offset & 0xffff) ^ 0x8000) >= 0x10000 - extra\n+\t      : offset - (0x8000 - extra) < UNITS_PER_WORD)\n+\t    {\n+\t      if (in_p)\n+\t\tsri->icode = CODE_FOR_reload_si_load;\n+\t      else\n+\t\tsri->icode = CODE_FOR_reload_si_store;\n+\t      sri->extra_cost = 2;\n+\t      ret = NO_REGS;\n+\t    }\n \t  else\n-\t    sri->icode = CODE_FOR_reload_si_store;\n-\t  sri->extra_cost = 2;\n-\t  ret = NO_REGS;\n+\t    default_p = true;\n \t}\n       else\n \tdefault_p = true;"}, {"sha": "d3407fdcbf81b25f3aa033e5e23f290b7e87b37e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=921f2deea4f6f491d7e225d70d3787e8b490b18e", "patch": "@@ -1,5 +1,7 @@\n 2013-02-07  Alan Modra  <amodra@gmail.com>\n \n+\tPR target/54009\n+\t* gcc.target/powerpc/pr54009.c: New test.\n \tPR target/54131\n \t* gfortran.dg/pr54131.f: New test.\n "}, {"sha": "9af98ab6c8b7eeb664c682c74954f5bb6b87c78d", "filename": "gcc/testsuite/gcc.target/powerpc/pr54009.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr54009.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921f2deea4f6f491d7e225d70d3787e8b490b18e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr54009.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr54009.c?ref=921f2deea4f6f491d7e225d70d3787e8b490b18e", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target powerpc_fprs } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not \"\\[\\+\\]32768\" } } */\n+\n+/* -O2 -m32 store to x.d in w was\n+    lis 9,x+32764@ha\n+    stw 10,x+32764@l(9)\n+    stw 11,x+32768@l(9)  <--  wrap!  */\n+\n+struct big {\n+  char a[32764];\n+  double d __attribute__ ((aligned (4)));\n+} __attribute__ ((packed));\n+\n+extern struct big x;\n+double y;\n+\n+void r (void)\n+{\n+  double tmp = x.d;\n+#if 1\n+  asm (\"#\": \"+r\" (tmp)\n+       : : \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\",\n+           \"fr8\", \"fr9\", \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\",\n+           \"fr16\", \"fr17\", \"fr18\", \"fr19\", \"fr20\", \"fr21\", \"fr22\", \"fr23\",\n+           \"fr24\", \"fr25\", \"fr26\", \"fr27\", \"fr28\", \"fr29\", \"fr30\", \"fr31\");\n+#endif\n+  y = tmp;\n+}\n+\n+void w (void)\n+{\n+  double tmp = y;\n+#if 1\n+  asm (\"#\": \"+r\" (tmp)\n+       : : \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\",\n+           \"fr8\", \"fr9\", \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\",\n+           \"fr16\", \"fr17\", \"fr18\", \"fr19\", \"fr20\", \"fr21\", \"fr22\", \"fr23\",\n+           \"fr24\", \"fr25\", \"fr26\", \"fr27\", \"fr28\", \"fr29\", \"fr30\", \"fr31\");\n+#endif\n+  x.d = tmp;\n+}"}]}