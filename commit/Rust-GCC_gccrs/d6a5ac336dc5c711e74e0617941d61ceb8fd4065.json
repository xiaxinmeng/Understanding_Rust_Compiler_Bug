{"sha": "d6a5ac336dc5c711e74e0617941d61ceb8fd4065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZhNWFjMzM2ZGM1YzcxMWU3NGUwNjE3OTQxZDYxY2ViOGZkNDA2NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-16T13:24:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-16T13:24:29Z"}, "message": "(expand_expr): Update comments and fix formatting.\n\n(expand_expr, case VAR_DECL, STRING_CST, CONSTRUCTOR): If flag_force_addr, put\naddress in register unless REG.\n(expand_expr, case CONSTRUCTOR, CONVERT_EXPR): Make TARGET with TMODE, if\nspecified.\n(expand_expr, case IN_EXPR): Clean up.  Allow INDEX to be an unsigned type.\nAlways evaluate SET and INDEX in case of side effects.\n(expand_expr, case CONVERT_EXPR): Use convert_modes to handle consts.\n(expand_expr, case ABS_EXPR): Simplify processing of COMPLEX.\nCompare with zero word-by-word if required.\n(expand_expr, case ABS_EXPR, MIN_EXPR, COND_EXPR): Don't use TARGET if\nnot MODE.\n(expand_expr, case TRUTH_*_EXPR): Modes of input and output must agree.\n(expand_expr, case CONJ_EXPR): Remove redundant def of MODE.\n\nFrom-SVN: r6794", "tree": {"sha": "d16c1ed41408790444c91ccd20afcfc15c867b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d16c1ed41408790444c91ccd20afcfc15c867b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6a5ac336dc5c711e74e0617941d61ceb8fd4065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a5ac336dc5c711e74e0617941d61ceb8fd4065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6a5ac336dc5c711e74e0617941d61ceb8fd4065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a5ac336dc5c711e74e0617941d61ceb8fd4065/comments", "author": null, "committer": null, "parents": [{"sha": "8df0611867a09f498ddfaf28f68498a02789a8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df0611867a09f498ddfaf28f68498a02789a8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8df0611867a09f498ddfaf28f68498a02789a8fc"}], "stats": {"total": 322, "additions": 163, "deletions": 159}, "files": [{"sha": "a169d6d885f17b6a669a22e525c56b949c528e84", "filename": "gcc/expr.c", "status": "modified", "additions": 163, "deletions": 159, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a5ac336dc5c711e74e0617941d61ceb8fd4065/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a5ac336dc5c711e74e0617941d61ceb8fd4065/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d6a5ac336dc5c711e74e0617941d61ceb8fd4065", "patch": "@@ -3590,9 +3590,8 @@ fixed_type_p (exp)\n    TMODE is just a suggestion; callers must assume that\n    the rtx returned may not have mode TMODE.\n \n-   EXPAND_CONST_ADDRESS says that it is okay to return a MEM\n-   with a constant address even if that address is not normally legitimate.\n-   EXPAND_INITIALIZER and EXPAND_SUM also have this effect.\n+   Note that TARGET may have neither TMODE nor MODE.  In that case, it\n+   probably will not be used.\n \n    If MODIFIER is EXPAND_SUM then when EXP is an addition\n    we can return an rtx of the form (MULT (REG ...) (CONST_INT ...))\n@@ -3604,7 +3603,11 @@ fixed_type_p (exp)\n    EXPAND_INITIALIZER is much like EXPAND_SUM except that\n    it also marks a label as absolutely required (it can't be dead).\n    It also makes a ZERO_EXTEND or SIGN_EXTEND instead of emitting extend insns.\n-   This is used for outputting expressions used in initializers.  */\n+   This is used for outputting expressions used in initializers.\n+\n+   EXPAND_CONST_ADDRESS says that it is okay to return a MEM\n+   with a constant address even if that address is not normally legitimate.\n+   EXPAND_INITIALIZER and EXPAND_SUM also have this effect.  */\n \n rtx\n expand_expr (exp, target, tmode, modifier)\n@@ -3735,6 +3738,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  return CONST0_RTX (mode);\n \t}\n \n+      /* ... fall through ... */\n+\n     case VAR_DECL:\n       /* If a static var's type was incomplete when the decl was written,\n \t but the type is complete now, lay out the decl now.  */\n@@ -3747,10 +3752,14 @@ expand_expr (exp, target, tmode, modifier)\n \t  PUT_MODE (DECL_RTL (exp), DECL_MODE (exp));\n \t  pop_obstacks ();\n \t}\n+\n+      /* ... fall through ... */\n+\n     case FUNCTION_DECL:\n     case RESULT_DECL:\n       if (DECL_RTL (exp) == 0)\n \tabort ();\n+\n       /* Ensure variable marked as used even if it doesn't go through\n \t a parser.  If it hasn't be used yet, write out an external\n \t definition.  */\n@@ -3767,6 +3776,7 @@ expand_expr (exp, target, tmode, modifier)\n \t because that is the inline function whose vars, types, etc.\n \t are being merged into the current function.\n \t See expand_inline_function.  */\n+\n       if (context != 0 && context != current_function_decl\n \t  && context != inline_function_decl\n \t  /* If var is static, we don't need a static chain to access it.  */\n@@ -3782,7 +3792,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    abort ();\n \t  addr = XEXP (DECL_RTL (exp), 0);\n \t  if (GET_CODE (addr) == MEM)\n-\t    addr = gen_rtx (MEM, Pmode, fix_lexical_addr (XEXP (addr, 0), exp));\n+\t    addr = gen_rtx (MEM, Pmode,\n+\t\t\t    fix_lexical_addr (XEXP (addr, 0), exp));\n \t  else\n \t    addr = fix_lexical_addr (addr, exp);\n \t  return change_address (DECL_RTL (exp), mode, addr);\n@@ -3791,24 +3802,25 @@ expand_expr (exp, target, tmode, modifier)\n       /* This is the case of an array whose size is to be determined\n \t from its initializer, while the initializer is still being parsed.\n \t See expand_decl.  */\n+\n       if (GET_CODE (DECL_RTL (exp)) == MEM\n \t  && GET_CODE (XEXP (DECL_RTL (exp), 0)) == REG)\n \treturn change_address (DECL_RTL (exp), GET_MODE (DECL_RTL (exp)),\n \t\t\t       XEXP (DECL_RTL (exp), 0));\n+\n+      /* If DECL_RTL is memory, we are in the normal case and either\n+\t the address is not valid or it is not a register and -fforce-addr\n+\t is specified, get the address into a register.  */\n+\n       if (GET_CODE (DECL_RTL (exp)) == MEM\n \t  && modifier != EXPAND_CONST_ADDRESS\n \t  && modifier != EXPAND_SUM\n-\t  && modifier != EXPAND_INITIALIZER)\n-\t{\n-\t  /* DECL_RTL probably contains a constant address.\n-\t     On RISC machines where a constant address isn't valid,\n-\t     make some insns to get that address into a register.  */\n-\t  if (!memory_address_p (DECL_MODE (exp), XEXP (DECL_RTL (exp), 0))\n+\t  && modifier != EXPAND_INITIALIZER\n+\t  && (! memory_address_p (DECL_MODE (exp), XEXP (DECL_RTL (exp), 0))\n \t      || (flag_force_addr\n-\t\t  && CONSTANT_ADDRESS_P (XEXP (DECL_RTL (exp), 0))))\n-\t    return change_address (DECL_RTL (exp), VOIDmode,\n-\t\t\t\t   copy_rtx (XEXP (DECL_RTL (exp), 0)));\n-\t}\n+\t\t  && GET_CODE (XEXP (DECL_RTL (exp), 0)) != REG)))\n+\treturn change_address (DECL_RTL (exp), VOIDmode,\n+\t\t\t       copy_rtx (XEXP (DECL_RTL (exp), 0)));\n \n       /* If the mode of DECL_RTL does not match that of the decl, it\n \t must be a promoted value.  We return a SUBREG of the wanted mode,\n@@ -3868,13 +3880,16 @@ expand_expr (exp, target, tmode, modifier)\n \t  && modifier != EXPAND_CONST_ADDRESS\n \t  && modifier != EXPAND_INITIALIZER\n \t  && modifier != EXPAND_SUM\n-\t  && !memory_address_p (mode, XEXP (TREE_CST_RTL (exp), 0)))\n+\t  && (! memory_address_p (mode, XEXP (TREE_CST_RTL (exp), 0))\n+\t      || (flag_force_addr\n+\t\t  && GET_CODE (XEXP (TREE_CST_RTL (exp), 0)) != REG)))\n \treturn change_address (TREE_CST_RTL (exp), VOIDmode,\n \t\t\t       copy_rtx (XEXP (TREE_CST_RTL (exp), 0)));\n       return TREE_CST_RTL (exp);\n \n     case SAVE_EXPR:\n       context = decl_function_context (exp);\n+\n       /* We treat inline_function_decl as an alias for the current function\n \t because that is the inline function whose vars, types, etc.\n \t are being merged into the current function.\n@@ -4102,8 +4117,10 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (modifier != EXPAND_CONST_ADDRESS\n \t      && modifier != EXPAND_INITIALIZER\n \t      && modifier != EXPAND_SUM\n-\t      && !memory_address_p (GET_MODE (constructor),\n-\t\t\t\t    XEXP (constructor, 0)))\n+\t      && (! memory_address_p (GET_MODE (constructor),\n+\t\t\t\t      XEXP (constructor, 0))\n+\t\t  || (flag_force_addr\n+\t\t      && GET_CODE (XEXP (constructor, 0)) != REG)))\n \t    constructor = change_address (constructor, VOIDmode,\n \t\t\t\t\t  XEXP (constructor, 0));\n \t  return constructor;\n@@ -4114,7 +4131,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (target == 0 || ! safe_from_p (target, exp))\n \t    {\n \t      if (mode != BLKmode && ! TREE_ADDRESSABLE (exp))\n-\t\ttarget = gen_reg_rtx (mode);\n+\t\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n \t      else\n \t\t{\n \t\t  enum tree_code c = TREE_CODE (type);\n@@ -4488,55 +4505,49 @@ expand_expr (exp, target, tmode, modifier)\n     case BUFFER_REF:\n       abort ();\n \n-    /* IN_EXPR: Inlined pascal set IN expression.\n-\n-       Algorithm:\n-         rlo       = set_low - (set_low%bits_per_word);\n-\t the_word  = set [ (index - rlo)/bits_per_word ];\n-\t bit_index = index % bits_per_word;\n-\t bitmask   = 1 << bit_index;\n-\t return !!(the_word & bitmask);  */\n     case IN_EXPR:\n-      preexpand_calls (exp);\n       {\n+\t/* Pascal set IN expression.\n+\n+\t   Algorithm:\n+\t       rlo       = set_low - (set_low%bits_per_word);\n+\t       the_word  = set [ (index - rlo)/bits_per_word ];\n+\t       bit_index = index % bits_per_word;\n+\t       bitmask   = 1 << bit_index;\n+\t       return !!(the_word & bitmask);  */\n+\n \ttree set = TREE_OPERAND (exp, 0);\n \ttree index = TREE_OPERAND (exp, 1);\n+\tint iunsignedp = TREE_UNSIGNED (TREE_TYPE (index));\n \ttree set_type = TREE_TYPE (set);\n-\n \ttree set_low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (set_type));\n \ttree set_high_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (set_type));\n-\n-\trtx index_val;\n-\trtx lo_r;\n-\trtx hi_r;\n+\trtx index_val = expand_expr (index, 0, VOIDmode, 0);\n+\trtx lo_r = expand_expr (set_low_bound, 0, VOIDmode, 0);\n+\trtx hi_r = expand_expr (set_high_bound, 0, VOIDmode, 0);\n+\trtx setval = expand_expr (set, 0, VOIDmode, 0);\n+\trtx setaddr = XEXP (setval, 0);\n+\tenum machine_mode index_mode = TYPE_MODE (TREE_TYPE (index));\n \trtx rlow;\n \trtx diff, quo, rem, addr, bit, result;\n-\trtx setval, setaddr;\n-\tenum machine_mode index_mode = TYPE_MODE (TREE_TYPE (index));\n \n-\tif (target == 0)\n-\t  target = gen_reg_rtx (mode);\n-\n-\t/* If domain is empty, answer is no.  */\n-\tif (tree_int_cst_lt (set_high_bound, set_low_bound))\n+\tpreexpand_calls (exp);\n+\n+\t/* If domain is empty, answer is no.  Likewise if index is constant\n+\t   and out of bounds.  */\n+\tif ((TREE_CODE (set_high_bound) == INTEGER_CST\n+\t     && TREE_CODE (set_low_bound) == INTEGER_CST\n+\t     && tree_int_cst_lt (set_high_bound, set_low_bound)\n+\t     || (TREE_CODE (index) == INTEGER_CST\n+\t\t && TREE_CODE (set_low_bound) == INTEGER_CST\n+\t\t && tree_int_cst_lt (index, set_low_bound))\n+\t     || (TREE_CODE (set_high_bound) == INTEGER_CST\n+\t\t && TREE_CODE (index) == INTEGER_CST\n+\t\t && tree_int_cst_lt (set_high_bound, index))))\n \t  return const0_rtx;\n \n-\tindex_val = expand_expr (index, 0, VOIDmode, 0);\n-\tlo_r = expand_expr (set_low_bound, 0, VOIDmode, 0);\n-\thi_r = expand_expr (set_high_bound, 0, VOIDmode, 0);\n-\tsetval = expand_expr (set, 0, VOIDmode, 0);\n-\tsetaddr = XEXP (setval, 0); \n-\n-\t/* Compare index against bounds, if they are constant.  */\n-\tif (GET_CODE (index_val) == CONST_INT\n-\t    && GET_CODE (lo_r) == CONST_INT\n-\t    && INTVAL (index_val) < INTVAL (lo_r))\n-\t  return const0_rtx;\n-\n-\tif (GET_CODE (index_val) == CONST_INT\n-\t    && GET_CODE (hi_r) == CONST_INT\n-\t    && INTVAL (hi_r) < INTVAL (index_val))\n-\t  return const0_rtx;\n+\tif (target == 0)\n+\t  target = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n \n \t/* If we get here, we have to generate the code for both cases\n \t   (in range and out of range).  */\n@@ -4548,15 +4559,15 @@ expand_expr (exp, target, tmode, modifier)\n \t       && GET_CODE (lo_r) == CONST_INT))\n \t  {\n \t    emit_cmp_insn (index_val, lo_r, LT, NULL_RTX,\n-\t\t\t   GET_MODE (index_val), 0, 0);\n+\t\t\t   GET_MODE (index_val), iunsignedp, 0);\n \t    emit_jump_insn (gen_blt (op1));\n \t  }\n \n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (hi_r) == CONST_INT))\n \t  {\n \t    emit_cmp_insn (index_val, hi_r, GT, NULL_RTX,\n-\t\t\t   GET_MODE (index_val), 0, 0);\n+\t\t\t   GET_MODE (index_val), iunsignedp, 0);\n \t    emit_jump_insn (gen_bgt (op1));\n \t  }\n \n@@ -4568,19 +4579,21 @@ expand_expr (exp, target, tmode, modifier)\n \telse\n \t  rlow = expand_binop (index_mode, and_optab, lo_r,\n \t\t\t       GEN_INT (~((HOST_WIDE_INT) 1 << BITS_PER_UNIT)),\n-\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t\t\t       NULL_RTX, iunsignedp, OPTAB_LIB_WIDEN);\n \n-\tdiff = expand_binop (index_mode, sub_optab,\n-\t\t\t     index_val, rlow, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\tdiff = expand_binop (index_mode, sub_optab, index_val, rlow,\n+\t\t\t     NULL_RTX, iunsignedp, OPTAB_LIB_WIDEN);\n \n \tquo = expand_divmod (0, TRUNC_DIV_EXPR, index_mode, diff,\n-\t\t\t     GEN_INT (BITS_PER_UNIT), NULL_RTX, 0);\n+\t\t\t     GEN_INT (BITS_PER_UNIT), NULL_RTX, iunsignedp);\n \trem = expand_divmod (1, TRUNC_MOD_EXPR, index_mode, index_val,\n-\t\t\t     GEN_INT (BITS_PER_UNIT), NULL_RTX, 0);\n+\t\t\t     GEN_INT (BITS_PER_UNIT), NULL_RTX, iunsignedp);\n+\n \taddr = memory_address (byte_mode,\n-\t\t\t       expand_binop (index_mode, add_optab,\n-\t\t\t\t\t     diff, setaddr, NULL_RTX, 0,\n+\t\t\t       expand_binop (index_mode, add_optab, diff,\n+\t\t\t\t\t     setaddr, NULL_RTX, iunsignedp,\n \t\t\t\t\t     OPTAB_LIB_WIDEN));\n+\n \t/* Extract the bit we want to examine */\n \tbit = expand_shift (RSHIFT_EXPR, byte_mode,\n \t\t\t    gen_rtx (MEM, byte_mode, addr),\n@@ -4618,13 +4631,16 @@ expand_expr (exp, target, tmode, modifier)\n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) == FUNCTION_DECL\n+\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t      == FUNCTION_DECL)\n \t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n \treturn expand_builtin (exp, target, subtarget, tmode, ignore);\n+\n       /* If this call was expanded already by preexpand_calls,\n \t just return the result we got.  */\n       if (CALL_EXPR_RTL (exp) != 0)\n \treturn CALL_EXPR_RTL (exp);\n+\n       return expand_call (exp, target, ignore);\n \n     case NON_LVALUE_EXPR:\n@@ -4633,6 +4649,7 @@ expand_expr (exp, target, tmode, modifier)\n     case REFERENCE_EXPR:\n       if (mode == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n \treturn expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, modifier);\n+\n       if (TREE_CODE (type) == UNION_TYPE)\n \t{\n \t  tree valtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n@@ -4649,8 +4666,9 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t      / BITS_PER_UNIT, 0);\n \t\t}\n \t      else\n-\t\ttarget = gen_reg_rtx (mode);\n+\t\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n \t    }\n+\n \t  if (GET_CODE (target) == MEM)\n \t    /* Store data into beginning of memory target.  */\n \t    store_expr (TREE_OPERAND (exp, 0),\n@@ -4668,54 +4686,30 @@ expand_expr (exp, target, tmode, modifier)\n \t  /* Return the entire union.  */\n \t  return target;\n \t}\n+\n       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, 0);\n       if (GET_MODE (op0) == mode)\n \treturn op0;\n-      /* If arg is a constant integer being extended from a narrower mode,\n-\t we must really truncate to get the extended bits right.  Otherwise\n-\t (unsigned long) (unsigned char) (\"\\377\"[0])\n-\t would come out as ffffffff.  */\n-      if (GET_MODE (op0) == VOIDmode\n-\t  && (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t      < GET_MODE_BITSIZE (mode)))\n-\t{\n-\t  /* MODE must be narrower than HOST_BITS_PER_INT.  */\n-\t  int width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))));\n-\n-\t  if (width < HOST_BITS_PER_WIDE_INT)\n-\t    {\n-\t      HOST_WIDE_INT val = (GET_CODE (op0) == CONST_INT ? INTVAL (op0)\n-\t\t\t\t   : CONST_DOUBLE_LOW (op0));\n-\t      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t\t  || !(val & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\t\tval &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\t      else\n-\t\tval |= ~(((HOST_WIDE_INT) 1 << width) - 1);\n \n-\t      op0 = GEN_INT (val);\n-\t    }\n-\t  else\n-\t    {\n-\t      op0 = (simplify_unary_operation\n-\t\t     ((TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t\t       ? ZERO_EXTEND : SIGN_EXTEND),\n-\t\t      mode, op0,\n-\t\t      TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))));\n-\t      if (op0 == 0)\n-\t\tabort ();\n-\t    }\n-\t}\n-      if (GET_MODE (op0) == VOIDmode)\n-\treturn op0;\n+      /* If OP0 is a constant, just convert it into the proper mode.  */\n+      if (CONSTANT_P (op0))\n+\treturn\n+\t  convert_modes (mode, TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n+\t\t\t op0, TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\n       if (modifier == EXPAND_INITIALIZER)\n \treturn gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND, mode, op0);\n+\n       if (flag_force_mem && GET_CODE (op0) == MEM)\n \top0 = copy_to_reg (op0);\n \n       if (target == 0)\n-\treturn convert_to_mode (mode, op0, TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\treturn\n+\t  convert_to_mode (mode, op0,\n+\t\t\t   TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       else\n-\tconvert_move (target, op0, TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\tconvert_move (target, op0,\n+\t\t      TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       return target;\n \n     case PLUS_EXPR:\n@@ -5048,14 +5042,9 @@ expand_expr (exp, target, tmode, modifier)\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n \n       /* Handle complex values specially.  */\n-      {\n-\tenum machine_mode opmode\n-\t  = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\n-\tif (GET_MODE_CLASS (opmode) == MODE_COMPLEX_INT\n-\t    || GET_MODE_CLASS (opmode) == MODE_COMPLEX_FLOAT)\n-\t  return expand_complex_abs (opmode, op0, target, unsignedp);\n-      }\n+      if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n+\t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\treturn expand_complex_abs (mode, op0, target, unsignedp);\n \n       /* Unsigned abs is simply the operand.  Testing here means we don't\n \t risk generating incorrect code below.  */\n@@ -5089,23 +5078,41 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* If that does not win, use conditional jump and negate.  */\n       target = original_target;\n-      temp = gen_label_rtx ();\n+      op1 = gen_label_rtx ();\n       if (target == 0 || ! safe_from_p (target, TREE_OPERAND (exp, 0))\n+\t  || GET_MODE (target) != mode\n \t  || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n \t  || (GET_CODE (target) == REG\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n+\n       emit_move_insn (target, op0);\n-      emit_cmp_insn (target,\n-\t\t     expand_expr (convert (type, integer_zero_node),\n-\t\t\t\t  NULL_RTX, VOIDmode, 0),\n-\t\t     GE, NULL_RTX, mode, 0, 0);\n       NO_DEFER_POP;\n-      emit_jump_insn (gen_bge (temp));\n+\n+      /* If this mode is an integer too wide to compare properly,\n+\t compare word by word.  Rely on CSE to optimize constant cases.  */\n+      if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n+\tdo_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n+\t\t\t\t      NULL_RTX, op1);\n+      else\n+\t{\n+\t  temp = compare_from_rtx (target, const0_rtx, GE, 0, mode,\n+\t\t\t\t   NULL_RTX, 0);\n+\t  if (temp == const1_rtx)\n+\t    return target;\n+\t  else if (temp != const0_rtx)\n+\t    {\n+\t      if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n+\t\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op0));\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t}\n+\n       op0 = expand_unop (mode, neg_optab, target, target, 0);\n       if (op0 != target)\n \temit_move_insn (target, op0);\n-      emit_label (temp);\n+      emit_label (op1);\n       OK_DEFER_POP;\n       return target;\n \n@@ -5114,6 +5121,7 @@ expand_expr (exp, target, tmode, modifier)\n       target = original_target;\n       if (target == 0 || ! safe_from_p (target, TREE_OPERAND (exp, 1))\n \t  || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n+\t  || GET_MODE (target) != mode\n \t  || (GET_CODE (target) == REG\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n@@ -5134,16 +5142,19 @@ expand_expr (exp, target, tmode, modifier)\n \n       if (target != op0)\n \temit_move_insn (target, op0);\n+\n       op0 = gen_label_rtx ();\n+\n       /* If this mode is an integer too wide to compare properly,\n \t compare word by word.  Rely on cse to optimize constant cases.  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && !can_compare_p (mode))\n+      if (GET_MODE_CLASS (mode) == MODE_INT && !can_compare_p (mode))\n \t{\n \t  if (code == MAX_EXPR)\n-\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), target, op1, NULL, op0);\n+\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type),\n+\t\t\t\t\t  target, op1, NULL_RTX, op0);\n \t  else\n-\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type), op1, target, NULL, op0);\n+\t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type),\n+\t\t\t\t\t  op1, target, NULL_RTX, op0);\n \t  emit_move_insn (target, op1);\n \t}\n       else\n@@ -5170,8 +5181,6 @@ expand_expr (exp, target, tmode, modifier)\n       emit_label (op0);\n       return target;\n \n-/* ??? Can optimize when the operand of this is a bitwise operation,\n-   by using a different bitwise operation.  */\n     case BIT_NOT_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n       temp = expand_unop (mode, one_cmpl_optab, op0, target, 1);\n@@ -5186,41 +5195,30 @@ expand_expr (exp, target, tmode, modifier)\n \tabort ();\n       return temp;\n \n-/* ??? Can optimize bitwise operations with one arg constant.\n-   Can optimize (a bitwise1 n) bitwise2 (a bitwise3 b)\n-   and (a bitwise1 b) bitwise2 b (etc)\n-   but that is probably not worth while.  */\n-\n-/* BIT_AND_EXPR is for bitwise anding.\n-   TRUTH_AND_EXPR is for anding two boolean values\n-   when we want in all cases to compute both of them.\n-   In general it is fastest to do TRUTH_AND_EXPR by\n-   computing both operands as actual zero-or-1 values\n-   and then bitwise anding.  In cases where there cannot\n-   be any side effects, better code would be made by\n-   treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR;\n-   but the question is how to recognize those cases.  */\n-\n-      /* TRUTH_AND_EXPR can have a result whose mode doesn't match\n-\t th operands.  If so, don't use our target.  */\n+      /* ??? Can optimize bitwise operations with one arg constant.\n+\t Can optimize (a bitwise1 n) bitwise2 (a bitwise3 b)\n+\t and (a bitwise1 b) bitwise2 b (etc)\n+\t but that is probably not worth while.  */\n+\n+      /* BIT_AND_EXPR is for bitwise anding.  TRUTH_AND_EXPR is for anding two\n+\t boolean values when we want in all cases to compute both of them.  In\n+\t general it is fastest to do TRUTH_AND_EXPR by computing both operands\n+\t as actual zero-or-1 values and then bitwise anding.  In cases where\n+\t there cannot be any side effects, better code would be made by\n+\t treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR; but the question is\n+\t how to recognize those cases.  */\n+\n     case TRUTH_AND_EXPR:\n-      if (mode != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\tsubtarget = 0;\n     case BIT_AND_EXPR:\n       this_optab = and_optab;\n       goto binop;\n \n-/* See comment above about TRUTH_AND_EXPR; it applies here too.  */\n     case TRUTH_OR_EXPR:\n-      if (mode != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\tsubtarget = 0;\n     case BIT_IOR_EXPR:\n       this_optab = ior_optab;\n       goto binop;\n \n     case TRUTH_XOR_EXPR:\n-      if (mode != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\tsubtarget = 0;\n     case BIT_XOR_EXPR:\n       this_optab = xor_optab;\n       goto binop;\n@@ -5236,8 +5234,8 @@ expand_expr (exp, target, tmode, modifier)\n       return expand_shift (code, mode, op0, TREE_OPERAND (exp, 1), target,\n \t\t\t   unsignedp);\n \n-/* Could determine the answer when only additive constants differ.\n-   Also, the addition of one can be handled by changing the condition.  */\n+      /* Could determine the answer when only additive constants differ.  Also,\n+\t the addition of one can be handled by changing the condition.  */\n     case LT_EXPR:\n     case LE_EXPR:\n     case GT_EXPR:\n@@ -5248,16 +5246,20 @@ expand_expr (exp, target, tmode, modifier)\n       temp = do_store_flag (exp, target, tmode != VOIDmode ? tmode : mode, 0);\n       if (temp != 0)\n \treturn temp;\n+\n       /* For foo != 0, load foo, and if it is nonzero load 1 instead. */\n       if (code == NE_EXPR && integer_zerop (TREE_OPERAND (exp, 1))\n \t  && original_target\n \t  && GET_CODE (original_target) == REG\n \t  && (GET_MODE (original_target)\n \t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n \t{\n-\t  temp = expand_expr (TREE_OPERAND (exp, 0), original_target, VOIDmode, 0);\n+\t  temp = expand_expr (TREE_OPERAND (exp, 0), original_target,\n+\t\t\t      VOIDmode, 0);\n+\n \t  if (temp != original_target)\n \t    temp = copy_to_reg (temp);\n+\n \t  op1 = gen_label_rtx ();\n \t  emit_cmp_insn (temp, const0_rtx, EQ, NULL_RTX,\n \t\t\t GET_MODE (temp), unsignedp, 0);\n@@ -5266,6 +5268,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  emit_label (op1);\n \t  return temp;\n \t}\n+\n       /* If no set-flag instruction, must generate a conditional\n \t store into a temporary variable.  Drop through\n \t and handle this like && and ||.  */\n@@ -5340,6 +5343,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, modifier);\n \t    if (GET_MODE (op0) == mode)\n \t      return op0;\n+\n \t    if (target == 0)\n \t      target = gen_reg_rtx (mode);\n \t    convert_move (target, op0, unsignedp);\n@@ -5354,7 +5358,8 @@ expand_expr (exp, target, tmode, modifier)\n \tif (ignore)\n \t  temp = 0;\n \telse if (original_target\n-\t\t && safe_from_p (original_target, TREE_OPERAND (exp, 0)))\n+\t\t && safe_from_p (original_target, TREE_OPERAND (exp, 0))\n+\t\t && GET_MODE (original_target) == mode)\n \t  temp = original_target;\n \telse if (mode == BLKmode)\n \t  {\n@@ -5875,31 +5880,30 @@ expand_expr (exp, target, tmode, modifier)\n \n     case CONJ_EXPR:\n       {\n-\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \trtx imag_t;\n \trtx insns;\n \t\n \top0  = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n \n \tif (! target)\n-\t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\t  target = gen_reg_rtx (mode);\n \t\t\t\t\t\t\t\t    \n \tstart_sequence ();\n \n \t/* Store the realpart and the negated imagpart to target.  */\n \temit_move_insn (gen_realpart (mode, target), gen_realpart (mode, op0));\n \n \timag_t = gen_imagpart (mode, target);\n-\ttemp   = expand_unop (mode, neg_optab,\n-\t\t\t      gen_imagpart (mode, op0), imag_t, 0);\n+\ttemp = expand_unop (mode, neg_optab,\n+\t\t\t       gen_imagpart (mode, op0), imag_t, 0);\n \tif (temp != imag_t)\n \t  emit_move_insn (imag_t, temp);\n \n \tinsns = get_insns ();\n \tend_sequence ();\n \n-\t/* Conjugate should appear as a single unit */\n-\t/* If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS,\n+\t/* Conjugate should appear as a single unit \n+\t   If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS,\n \t   each with a separate pseudo as destination.\n \t   It's not correct for flow to treat them as a unit.  */\n \tif (GET_CODE (target) != CONCAT)"}]}