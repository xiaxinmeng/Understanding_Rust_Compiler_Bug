{"sha": "2b3d3db68da14b782f8d69ccebc18af04c61ce15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIzZDNkYjY4ZGExNGI3ODJmOGQ2OWNjZWJjMThhZjA0YzYxY2UxNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-10-02T14:31:47Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-10-02T14:31:47Z"}, "message": "javaprims.h: Rebuilt class list.\n\n\t* gcj/javaprims.h: Rebuilt class list.\n\t* boehm.cc (_Jv_GCRegisterDisappearingLink): New function.\n\t(_Jv_GCCanReclaimSoftReference): New function.\n\t* include/jvm.h (_Jv_GCRegisterDisappearingLink): Declare.\n\t(_Jv_GCCanReclaimSoftReference): Declare.\n\t* java/lang/ref/Reference.java (referent): Now a RawData.\n\t(create): Renamed from `created'.  Added object argument.\n\t(Reference): Don't initialize `referent' here.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (nat_source_files): Added new file.\n\t* java/lang/ref/natReference.cc: New file.\n\nFrom-SVN: r45958", "tree": {"sha": "64d840b2a9f59c9bf181680bd6e70172a0dc5e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64d840b2a9f59c9bf181680bd6e70172a0dc5e86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b3d3db68da14b782f8d69ccebc18af04c61ce15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3d3db68da14b782f8d69ccebc18af04c61ce15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3d3db68da14b782f8d69ccebc18af04c61ce15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3d3db68da14b782f8d69ccebc18af04c61ce15/comments", "author": null, "committer": null, "parents": [{"sha": "cacbc3505bac280b8db4f7d08a4a4b44ab69c0be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacbc3505bac280b8db4f7d08a4a4b44ab69c0be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cacbc3505bac280b8db4f7d08a4a4b44ab69c0be"}], "stats": {"total": 435, "additions": 401, "deletions": 34}, "files": [{"sha": "e98a20874c94685475e2e054ac9a072b6052e875", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -1,5 +1,17 @@\n 2001-10-01  Tom Tromey  <tromey@redhat.com>\n \n+\t* gcj/javaprims.h: Rebuilt class list.\n+\t* boehm.cc (_Jv_GCRegisterDisappearingLink): New function.\n+\t(_Jv_GCCanReclaimSoftReference): New function.\n+\t* include/jvm.h (_Jv_GCRegisterDisappearingLink): Declare.\n+\t(_Jv_GCCanReclaimSoftReference): Declare.\n+\t* java/lang/ref/Reference.java (referent): Now a RawData.\n+\t(create): Renamed from `created'.  Added object argument.\n+\t(Reference): Don't initialize `referent' here.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (nat_source_files): Added new file.\n+\t* java/lang/ref/natReference.cc: New file.\n+\n \t* prims.cc (_Jv_NewMultiArrayUnchecked): New method.\n \t(_Jv_NewMultiArray): Use it.  Check each array dimension.\n \t(_Jv_NewMultiArray): Likewise."}, {"sha": "d99334be5e163e21bdcddbc5f1ed93ea7e172023", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -1511,6 +1511,7 @@ java/lang/natStringBuffer.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/natThrowable.cc \\\n+java/lang/ref/natReference.cc \\\n java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\"}, {"sha": "53599026c50f7f319931d3065b4ae573c0d7a8e3", "filename": "libjava/Makefile.in", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -63,16 +63,13 @@ host_alias = @host_alias@\n host_triplet = @host@\n target_alias = @target_alias@\n target_triplet = @target@\n-AMTAR = @AMTAR@\n AM_RUNTESTFLAGS = @AM_RUNTESTFLAGS@\n AR = @AR@\n AS = @AS@\n-AWK = @AWK@\n CC = @CC@\n COMPPATH = @COMPPATH@\n CXX = @CXX@\n CXXCPP = @CXXCPP@\n-DEPDIR = @DEPDIR@\n DIRLTDL = @DIRLTDL@\n DIVIDESPEC = @DIVIDESPEC@\n DLLTOOL = @DLLTOOL@\n@@ -89,7 +86,6 @@ GCSPEC = @GCSPEC@\n GCTESTSPEC = @GCTESTSPEC@\n HASH_SYNC_SPEC = @HASH_SYNC_SPEC@\n INCLTDL = @INCLTDL@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n JC1GCSPEC = @JC1GCSPEC@\n LIBFFI = @LIBFFI@\n LIBGCJDEBUG = @LIBGCJDEBUG@\n@@ -122,34 +118,43 @@ ZINCS = @ZINCS@\n ZLIBS = @ZLIBS@\n ZLIBSPEC = @ZLIBSPEC@\n ZLIBTESTSPEC = @ZLIBTESTSPEC@\n-am__include = @am__include@\n-am__quote = @am__quote@\n here = @here@\n-install_sh = @install_sh@\n libgcj_basedir = @libgcj_basedir@\n mkinstalldirs = @mkinstalldirs@\n \n AUTOMAKE_OPTIONS = foreign\n-@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@XLIB_AWT_TRUE@cond_x_ltlibrary = @XLIB_AWT_TRUE@libgcjx.la\n-@XLIB_AWT_FALSE@cond_x_ltlibrary = \n+@TESTSUBDIR_TRUE@SUBDIRS = \\\n+@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = \\\n+@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = \\\n+@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = \\\n+@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = \\\n+@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@XLIB_AWT_TRUE@cond_x_ltlibrary = \\\n+@XLIB_AWT_TRUE@libgcjx.la\n+@XLIB_AWT_FALSE@cond_x_ltlibrary = \\\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.jar\n \n-@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij rmic rmiregistry\n+@NATIVE_TRUE@bin_PROGRAMS = \\\n+@NATIVE_TRUE@jv-convert gij rmic rmiregistry\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n-@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n+@CANADIAN_FALSE@ZIP = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = \\\n+@CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJ_WITH_FLAGS = $(GCJ) --encoding=UTF-8\n \n@@ -169,8 +174,10 @@ AM_CXXFLAGS = -fno-rtti -fnon-call-exceptions \\\n \t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE \\\n \t-DPREFIX=\"\\\"$(prefix)\\\"\"\n \n-@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = \\\n+@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = \\\n+@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = @LIBGCJ_JAVAFLAGS@ $(GCJFLAGS)\n@@ -239,7 +246,8 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -1243,6 +1251,7 @@ java/lang/natStringBuffer.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/natThrowable.cc \\\n+java/lang/ref/natReference.cc \\\n java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\\n java/lang/reflect/natField.cc \\\n@@ -1396,12 +1405,12 @@ java/lang/natDouble.lo java/lang/natFloat.lo java/lang/natMath.lo \\\n java/lang/natObject.lo java/lang/natRuntime.lo java/lang/natString.lo \\\n java/lang/natStringBuffer.lo java/lang/natSystem.lo \\\n java/lang/natThread.lo java/lang/natThrowable.lo \\\n-java/lang/reflect/natArray.lo java/lang/reflect/natConstructor.lo \\\n-java/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n-java/net/natInetAddress.lo java/net/natPlainDatagramSocketImpl.lo \\\n-java/net/natPlainSocketImpl.lo java/text/natCollator.lo \\\n-java/util/natResourceBundle.lo java/util/zip/natDeflater.lo \\\n-java/util/zip/natInflater.lo\n+java/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n+java/lang/reflect/natConstructor.lo java/lang/reflect/natField.lo \\\n+java/lang/reflect/natMethod.lo java/net/natInetAddress.lo \\\n+java/net/natPlainDatagramSocketImpl.lo java/net/natPlainSocketImpl.lo \\\n+java/text/natCollator.lo java/util/natResourceBundle.lo \\\n+java/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -1445,7 +1454,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1841,6 +1850,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/ref/PhantomReference.P .deps/java/lang/ref/Reference.P \\\n .deps/java/lang/ref/ReferenceQueue.P \\\n .deps/java/lang/ref/SoftReference.P .deps/java/lang/ref/WeakReference.P \\\n+.deps/java/lang/ref/natReference.P \\\n .deps/java/lang/reflect/AccessibleObject.P \\\n .deps/java/lang/reflect/Array.P .deps/java/lang/reflect/Constructor.P \\\n .deps/java/lang/reflect/Field.P \\\n@@ -2483,7 +2493,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "19b58bae908331fd7e8905f96ecebb0151ca023d", "filename": "libjava/boehm.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -543,6 +543,19 @@ _Jv_AllocTraceOne (jsize size /* includes vtable slot */)\n \n #endif /* JV_HASH_SYNCHRONIZATION */\n \n+void\n+_Jv_GCRegisterDisappearingLink (jobject *objp)\n+{\n+  GC_general_register_disappearing_link ((GC_PTR *) objp, (GC_PTR) *objp);\n+}\n+\n+jboolean\n+_Jv_GCCanReclaimSoftReference (jobject obj)\n+{\n+  // For now, always reclaim soft references.  FIXME.\n+  return true;\n+}\n+\n #if 0\n void\n _Jv_InitGC (void)"}, {"sha": "d32731558e0ffa760b04d652d4cd2dc25a57ac30", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -192,6 +192,7 @@ extern \"Java\"\n       class Short;\n       class StackOverflowError;\n       class String;\n+      class String$CaseInsensitiveComparator;\n       class StringBuffer;\n       class StringIndexOutOfBoundsException;\n       class System;"}, {"sha": "259d669c65040e4f0d52835a27e950afd0e9e67f", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -166,6 +166,13 @@ void _Jv_RunGC (void);\n /* Disable and enable GC.  */\n void _Jv_DisableGC (void);\n void _Jv_EnableGC (void);\n+/* Register a disappearing link.  This is a field F which should be\n+   cleared when *F is found to be inaccessible.  This is used in the\n+   implementation of java.lang.ref.Reference.  */\n+void _Jv_GCRegisterDisappearingLink (jobject *objp);\n+/* Return true if OBJECT should be reclaimed.  This is used to\n+   implement soft references.  */\n+jboolean _Jv_GCCanReclaimSoftReference (jobject obj);\n \n /* Return approximation of total size of heap.  */\n long _Jv_GCTotalMemory (void);"}, {"sha": "5a6c66324b2d014f751645fbc7ee22bc42887384", "filename": "libjava/java/lang/ref/Reference.java", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fjava%2Flang%2Fref%2FReference.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fjava%2Flang%2Fref%2FReference.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FReference.java?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -64,8 +64,21 @@\n   /**\n    * The underlying object.  This field is handled in a special way by\n    * the garbage collection.\n+   * GCJ LOCAL:\n+   * This is a RawData because it must be disguised from the GC.\n+   * END GCJ LOCAL\n    */\n-  Object referent;\n+  gnu.gcj.RawData referent;\n+\n+  /**\n+   * This is like REFERENT but is not scanned by the GC.  We keep a\n+   * copy around so that we can see when clear() has been called.\n+   * GCJ LOCAL:\n+   * This field doesn't exist in Classpath; we use it to detect\n+   * clearing.\n+   * END GCJ LOCAL\n+   */\n+  gnu.gcj.RawData copy;\n \n   /**\n    * The queue this reference is registered on. This is null, if this\n@@ -97,7 +110,7 @@\n    */\n   Reference(Object ref)\n   {\n-    referent = ref;\n+    create (ref);\n   }\n \n   /**\n@@ -112,10 +125,15 @@\n   {\n     if (q == null)\n       throw new NullPointerException();\n-    referent = ref;\n     queue = q;\n+    create (ref);\n   }\n \n+  /**\n+   * Notifies the VM that a new Reference has been created.\n+   */\n+  private native void create (Object o);\n+\n   /**\n    * Returns the object, this reference refers to.\n    * @return the object, this reference refers to, or null if the \n@@ -138,6 +156,7 @@ public Object get()\n   public void clear()\n   {\n     referent = null;\n+    copy = null;\n   }\n \n   /**"}, {"sha": "8e316ee38506a1b85ad921a0c596ec66825e49ac", "filename": "libjava/java/lang/ref/natReference.cc", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fjava%2Flang%2Fref%2FnatReference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d3db68da14b782f8d69ccebc18af04c61ce15/libjava%2Fjava%2Flang%2Fref%2FnatReference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fref%2FnatReference.cc?ref=2b3d3db68da14b782f8d69ccebc18af04c61ce15", "patch": "@@ -0,0 +1,304 @@\n+// natReference.cc - Native code for References\n+\n+/* Copyright (C) 2001  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Written by Tom Tromey <tromey@redhat.com>\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/lang/Throwable.h>\n+#include <java/lang/ref/Reference.h>\n+#include <java/lang/ref/SoftReference.h>\n+#include <java/lang/ref/WeakReference.h>\n+#include <java/lang/ref/PhantomReference.h>\n+#include <java/lang/ref/ReferenceQueue.h>\n+\n+static void finalize_reference (jobject ref);\n+static void finalize_referred_to_object (jobject obj);\n+\n+\f\n+\n+enum weight\n+{\n+  SOFT = 0,\n+  WEAK = 1,\n+  FINALIZE = 2,\n+  PHANTOM = 3,\n+\n+  // This is used to mark the head of a list.\n+  HEAD = 4,\n+\n+  // This is used to mark a deleted item.\n+  DELETED = 5\n+};\n+\n+// Objects of this type are used in the hash table to keep track of\n+// the mapping between a finalizable object and the various References\n+// which refer to it.\n+struct object_list\n+{\n+  // The reference object.  This is NULL for FINALIZE weight.\n+  jobject reference;\n+\n+  // The weight of this object.\n+  enum weight weight;\n+\n+  // Next in list.\n+  object_list *next;\n+};\n+\n+// Hash table used to hold mapping from object to References.  The\n+// object_list item in the hash holds the object itself in the\n+// reference field; chained to it are all the references sorted in\n+// order of weight (lowest first).\n+static object_list *hash = NULL;\n+\n+// Number of slots used in HASH.\n+static int hash_count = 0;\n+\n+// Number of slots total in HASH.  Must be power of 2.\n+static int hash_size = 0;\n+\n+static object_list *\n+find_slot (jobject key)\n+{\n+  jint hcode = _Jv_HashCode (key);\n+  /* step must be non-zero, and relatively prime with hash_size. */\n+  jint step = (hcode ^ (hcode >> 16)) | 1;\n+  int start_index = hcode & (hash_size - 1);\n+  int index = start_index;\n+  int deleted_index = -1;\n+  for (;;)\n+    {\n+      object_list *ptr = &hash[index];\n+      if (ptr->reference == key)\n+\treturn ptr;\n+      else if (ptr->reference == NULL)\n+\t{\n+\t  if (deleted_index == -1)\n+\t    return ptr;\n+\t  else\n+\t    return &hash[deleted_index];\n+\t}\n+      else if (ptr->weight == DELETED)\n+\tdeleted_index = index;\n+      index = (index + step) & (hash_size - 1);\n+      JvAssert (index != start_index);\n+    }\n+}\n+\n+static void\n+rehash ()\n+{\n+  if (hash == NULL)\n+    {\n+      hash_size = 1024;\n+      hash = (object_list *) _Jv_Malloc (hash_size * sizeof (object_list));\n+      memset (hash, 0, hash_size * sizeof (object_list));\n+    }\n+  else\n+    {\n+      object_list *old = hash;\n+      int i = hash_size;\n+\n+      hash_size *= 2;\n+      hash = (object_list *) _Jv_Malloc (hash_size * sizeof (object_list));\n+      memset (hash, 0, hash_size * sizeof (object_list));\n+\n+      while (--i >= 0)\n+\t{\n+\t  if (old[i].reference == NULL || old[i].weight == DELETED)\n+\t    continue;\n+\t  object_list *newslot = find_slot (old[i].reference);\n+\t  *newslot = old[i];\n+\t}\n+\n+      _Jv_Free (old);\n+    }\n+}\n+\n+// Remove a Reference.\n+static void\n+remove_from_hash (jobject obj)\n+{\n+  java::lang::ref::Reference *ref\n+    = reinterpret_cast<java::lang::ref::Reference *> (obj);\n+  object_list *head = find_slot (ref->copy);\n+  object_list **link = &head->next;\n+  head = head->next;\n+\n+  while (head && head->reference != ref)\n+    {\n+      link = &head->next;\n+      head = head->next;\n+    }\n+\n+  // Remove the slot.\n+  if (head)\n+    {\n+      *link = head->next;\n+      _Jv_Free (head);\n+    }\n+}\n+\n+// FIXME what happens if an object's finalizer creates a Reference to\n+// the object, and the object has never before been added to the hash?\n+// Madness!\n+\n+// Add an item to the hash table.  If the item is new, we also add a\n+// finalizer item.  We keep items in the hash table until they are\n+// completely collected; this lets us know when an item is new, even\n+// if it has been resurrected after its finalizer has been run.\n+static void\n+add_to_hash (java::lang::ref::Reference *the_reference)\n+{\n+  JvSynchronize sync (java::lang::ref::Reference::lock);\n+\n+  if (3 * hash_count >= 2 * hash_size)\n+    rehash ();\n+\n+  jobject referent = the_reference->referent;\n+  object_list *item = find_slot (referent);\n+  if (item->reference == NULL)\n+    {\n+      // New item, so make an entry for the finalizer.\n+      item->reference = referent;\n+      item->weight = HEAD;\n+\n+      item->next = (object_list *) _Jv_Malloc (sizeof (object_list));\n+      item->next->reference = NULL;\n+      item->next->weight = FINALIZE;\n+      item->next->next = NULL;\n+      ++hash_count;\n+    }\n+\n+  object_list *n = (object_list *) _Jv_Malloc (sizeof (object_list));\n+  n->reference = the_reference;\n+\n+  enum weight w = PHANTOM;\n+  if (java::lang::ref::SoftReference::class$.isInstance (the_reference))\n+    w = SOFT;\n+  else if (java::lang::ref::WeakReference::class$.isInstance (the_reference))\n+    w = WEAK;\n+  n->weight = w;\n+\n+  object_list **link = &item->next;\n+  object_list *iter = *link;\n+  while (iter && iter->weight < n->weight)\n+    {\n+      link = &iter->next;\n+      iter = *link;\n+    }\n+  *link = n;\n+  n->next = (*link) ? (*link)->next : NULL;\n+}\n+\n+// This is called when an object is ready to be finalized.  This\n+// actually implements the appropriate Reference semantics.\n+static void\n+finalize_referred_to_object (jobject obj)\n+{\n+  JvSynchronize sync (java::lang::ref::Reference::lock);\n+\n+  object_list *list = find_slot (obj);\n+  object_list *head = list->next;\n+  if (head == NULL)\n+    {\n+      // We have a truly dead object: the object's finalizer has been\n+      // run, all the object's references have been processed, and the\n+      // object is unreachable.  There is, at long last, no way to\n+      // resurrect it.\n+      list->weight = DELETED;\n+      --hash_count;\n+      return;\n+    }\n+\n+  enum weight w = head->weight;\n+  if (w == FINALIZE)\n+    {\n+      // If we have a Reference A to a Reference B, and B is\n+      // finalized, then we have to take special care to make sure\n+      // that B is properly deregistered.  This is super gross.  FIXME\n+      // will it fail if B's finalizer resurrects B?\n+      if (java::lang::ref::Reference::class$.isInstance (obj))\n+\tfinalize_reference (obj);\n+      else\n+\t_Jv_FinalizeObject (obj);\n+      list->next = head->next;\n+      _Jv_Free (head);\n+    }\n+  else if (w != SOFT || _Jv_GCCanReclaimSoftReference (obj))\n+    {\n+      // If we just decided to reclaim a soft reference, we might as\n+      // well do all the weak references at the same time.\n+      if (w == SOFT)\n+\tw = WEAK;\n+\n+      while (head && head->weight <= w)\n+\t{\n+\t  java::lang::ref::Reference *ref\n+\t    = reinterpret_cast<java::lang::ref::Reference *> (head->reference);\n+\t  // If the copy is already NULL then the user must have\n+\t  // called Reference.clear().\n+\t  if (ref->copy != NULL)\n+\t    {\n+\t      if (w == PHANTOM)\n+\t\tref->referent = ref->copy;\n+\t      else\n+\t\tref->copy = NULL;\n+\t      ref->enqueue ();\n+\t    }\n+\n+\t  object_list *next = head->next;\n+\t  _Jv_Free (head);\n+\t  head = next;\n+\t}\n+      list->next = head;\n+    }\n+\n+  // Re-register this finalizer.  We always re-register because we\n+  // can't know until the next collection cycle whether or not the\n+  // object is truly unreachable.\n+  _Jv_RegisterFinalizer (obj, finalize_referred_to_object);\n+}\n+\n+// This is called when a Reference object is finalized.  If there is a\n+// Reference pointing to this Reference then that case is handled by\n+// finalize_referred_to_object.\n+static void\n+finalize_reference (jobject ref)\n+{\n+  JvSynchronize sync (java::lang::ref::Reference::lock);\n+  remove_from_hash (ref);\n+  // The user might have a subclass of Reference with a finalizer.\n+  _Jv_FinalizeObject (ref);\n+}\n+\n+void\n+::java::lang::ref::Reference::create (jobject ref)\n+{\n+  // Nothing says you can't make a Reference with a NULL referent.\n+  // But there's nothing to do in such a case.\n+  referent = reinterpret_cast<gnu::gcj::RawData *> (ref);\n+  copy = referent;\n+  if (referent != NULL)\n+    {\n+      JvSynchronize sync (java::lang::ref::Reference::lock);\n+      // `this' is a new Reference object.  We register a new\n+      // finalizer for pointed-to object and we arrange a special\n+      // finalizer for ourselves as well.\n+      _Jv_RegisterFinalizer (this, finalize_reference);\n+      _Jv_RegisterFinalizer (referent, finalize_referred_to_object);\n+      jobject *objp = reinterpret_cast<jobject *> (&referent);\n+      _Jv_GCRegisterDisappearingLink (objp);\n+      add_to_hash (this);\n+    }\n+}"}]}