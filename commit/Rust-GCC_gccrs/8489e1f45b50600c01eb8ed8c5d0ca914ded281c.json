{"sha": "8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4OWUxZjQ1YjUwNjAwYzAxZWI4ZWQ4YzVkMGNhOTE0ZGVkMjgxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-18T15:26:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-18T15:26:55Z"}, "message": "Optimise WAR and WAW alias checks\n\nFor:\n\n  void\n  f1 (int *x, int *y)\n  {\n    for (int i = 0; i < 32; ++i)\n      x[i] += y[i];\n  }\n\nwe checked at runtime whether one vector at x would overlap one vector\nat y.  But in cases like this, the vector code would handle x <= y just\nfine, since any write to address A still happens after any read from\naddress A.  The only problem is if x is ahead of y by less than a\nvector.\n\nThe same is true for two writes:\n\n  void\n  f2 (int *x, int *y)\n  {\n    for (int i = 0; i < 32; ++i)\n      {\n        x[i] = i;\n        y[i] = 2;\n      }\n  }\n\nif y <= x then a vector write at y after a vector write at x would\nhave the same net effect as the original scalar writes.\n\nThis patch optimises the alias checks for these two cases.  E.g.,\nbefore the patch, f1 used:\n\n        add     x2, x0, 15\n        sub     x2, x2, x1\n        cmp     x2, 30\n        bls     .L2\n\nwhereas after the patch it uses:\n\n        add     x2, x1, 4\n        sub     x2, x0, x2\n        cmp     x2, 8\n        bls     .L2\n\nRead-after-write cases like:\n\n  int\n  f3 (int *x, int *y)\n  {\n    int res = 0;\n    for (int i = 0; i < 32; ++i)\n      {\n        x[i] = i;\n        res += y[i];\n      }\n    return res;\n  }\n\ncan cope with x == y, but otherwise don't allow overlap in either\ndirection.  Since checking for x == y at runtime would require extra\ncode, we're probably better off sticking with the current overlap test.\n\nAn overlap test is also needed if the scalar or vector accesses covered\nby the alias check are mixed together, rather than all statements for\nthe second access following all statements for the first access.\n\nThe new code for gcc.target/aarch64/sve/var_strict_[135].c is slightly\nbetter than before.\n\n2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-data-ref.c (create_intersect_range_checks_index): If the\n\talias pair describes simple WAW and WAR dependencies, just check\n\twhether the first B access overlaps later A accesses.\n\t(create_waw_or_war_checks): New function that performs the same\n\toptimization on addresses.\n\t(create_intersect_range_checks): Call it.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-alias-check-8.c: Expect WAR/WAW checks to be used.\n\t* gcc.dg/vect/vect-alias-check-14.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-15.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-18.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-19.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_1.c: Update expected sequence.\n\t* gcc.target/aarch64/sve/var_stride_2.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_3.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_5.c: Likewise.\n\nFrom-SVN: r278409", "tree": {"sha": "1e519a352bc06542b1ef8703ad437a501fadac9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e519a352bc06542b1ef8703ad437a501fadac9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1aeffdce2dfe718e1337d75eb4f22c3c300df9bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aeffdce2dfe718e1337d75eb4f22c3c300df9bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aeffdce2dfe718e1337d75eb4f22c3c300df9bb"}], "stats": {"total": 301, "additions": 260, "deletions": 41}, "files": [{"sha": "6ca0c57e6c62276c3dd6e19e78725ebb67cb7ee4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -1,3 +1,12 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-data-ref.c (create_intersect_range_checks_index): If the\n+\talias pair describes simple WAW and WAR dependencies, just check\n+\twhether the first B access overlaps later A accesses.\n+\t(create_waw_or_war_checks): New function that performs the same\n+\toptimization on addresses.\n+\t(create_intersect_range_checks): Call it.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* lra-constraints.c (valid_address_p): Take the operand and a"}, {"sha": "12a0d08238cebb72999d31730ed3cd268b247de3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -1,3 +1,15 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/vect-alias-check-8.c: Expect WAR/WAW checks to be used.\n+\t* gcc.dg/vect/vect-alias-check-14.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-15.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-18.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-19.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_1.c: Update expected sequence.\n+\t* gcc.target/aarch64/sve/var_stride_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_5.c: Likewise.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/acle/asm/ld1rq_f16.c: Remove XFAIL."}, {"sha": "1d148a04918d9a813b63ea57434bffa3670c3146", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-14.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -60,5 +60,5 @@ main (void)\n \n /* { dg-final { scan-tree-dump {flags: *WAR\\n} \"vect\" { target vect_int } } } */\n /* { dg-final { scan-tree-dump-not {flags: [^\\n]*ARBITRARY\\n} \"vect\" } } */\n-/* { dg-final { scan-tree-dump \"using an address-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an address-based WAR/WAW test\" \"vect\" } } */\n /* { dg-final { scan-tree-dump-not \"using an index-based\" \"vect\" } } */"}, {"sha": "fbe3f8431ff05e5727f7ce888d280a64670fbc4e", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-15.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -57,5 +57,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump {flags: *WAW\\n} \"vect\" { target vect_int } } } */\n-/* { dg-final { scan-tree-dump \"using an address-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an address-based WAR/WAW test\" \"vect\" } } */\n /* { dg-final { scan-tree-dump-not \"using an index-based\" \"vect\" } } */"}, {"sha": "9d0739151d956b1a2b136826d9260fe733f631d5", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-18.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-18.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -60,5 +60,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump {flags: *WAR\\n} \"vect\" { target vect_int } } } */\n-/* { dg-final { scan-tree-dump \"using an index-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an index-based WAR/WAW test\" \"vect\" } } */\n /* { dg-final { scan-tree-dump-not \"using an address-based\" \"vect\" } } */"}, {"sha": "7c0ff36a8c43f11197de413cb682bcd0a3afcae8", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-19.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-19.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -58,5 +58,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump {flags: *WAW\\n} \"vect\" { target vect_int } } } */\n-/* { dg-final { scan-tree-dump \"using an index-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an index-based WAR/WAW test\" \"vect\" } } */\n /* { dg-final { scan-tree-dump-not \"using an address-based\" \"vect\" } } */"}, {"sha": "7e5df1389991da8115df2c6784b52ff3e15f8124", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-8.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -60,5 +60,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump {flags: *WAR\\n} \"vect\" { target vect_int } } } */\n-/* { dg-final { scan-tree-dump \"using an index-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an index-based WAR/WAW test\" \"vect\" } } */\n /* { dg-final { scan-tree-dump-not \"using an address-based\" \"vect\" } } */"}, {"sha": "40ff2d561a812fb3924b31ee8a7ef6a760b1d7a9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_1.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -15,13 +15,9 @@ f (TYPE *x, TYPE *y, unsigned short n, long m __attribute__((unused)))\n /* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n-/* Should multiply by (VF-1)*4 rather than (257-1)*4.  */\n-/* { dg-final { scan-assembler-not {, 1024} } } */\n-/* { dg-final { scan-assembler-not {\\t.bfiz\\t} } } */\n-/* { dg-final { scan-assembler-not {lsl[^\\n]*[, ]10} } } */\n-/* { dg-final { scan-assembler-not {\\tcmp\\tx[0-9]+, 0} } } */\n-/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n-/* { dg-final { scan-assembler-not {\\tcsel\\tx[0-9]+} } } */\n-/* Two range checks and a check for n being zero.  */\n-/* { dg-final { scan-assembler-times {\\tcmp\\t} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */\n+/* Should use a WAR check that multiplies by (VF-2)*4 rather than\n+   an overlap check that multiplies by (257-1)*4.  */\n+/* { dg-final { scan-assembler {\\tcntb\\t(x[0-9]+)\\n.*\\tsub\\tx[0-9]+, \\1, #8\\n.*\\tmul\\tx[0-9]+,[^\\n]*\\1} } } */\n+/* One range check and a check for n being zero.  */\n+/* { dg-final { scan-assembler-times {\\t(?:cmp|tst)\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 1 } } */"}, {"sha": "b8afea70207f8ec2ed8f07eaa531bc3a01f1c0f0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -15,7 +15,7 @@ f (TYPE *x, TYPE *y, unsigned short n, unsigned short m)\n /* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n-/* Should multiply by (257-1)*4 rather than (VF-1)*4.  */\n+/* Should multiply by (257-1)*4 rather than (VF-1)*4 or (VF-2)*4.  */\n /* { dg-final { scan-assembler-times {\\tubfiz\\tx[0-9]+, x2, 10, 16\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tubfiz\\tx[0-9]+, x3, 10, 16\\n} 1 } } */\n /* { dg-final { scan-assembler-not {\\tcmp\\tx[0-9]+, 0} } } */"}, {"sha": "5ab6859ad4e3b6d7adcbefc36072c39318e98c97", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_3.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -15,13 +15,10 @@ f (TYPE *x, TYPE *y, int n, long m __attribute__((unused)))\n /* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n-/* Should multiply by (VF-1)*4 rather than (257-1)*4.  */\n-/* { dg-final { scan-assembler-not {, 1024} } } */\n-/* { dg-final { scan-assembler-not {\\t.bfiz\\t} } } */\n-/* { dg-final { scan-assembler-not {lsl[^\\n]*[, ]10} } } */\n-/* { dg-final { scan-assembler-not {\\tcmp\\tx[0-9]+, 0} } } */\n-/* { dg-final { scan-assembler {\\tcmp\\tw2, 0} } } */\n-/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 2 } } */\n-/* Two range checks and a check for n being zero.  */\n-/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n-/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */\n+/* Should use a WAR check that multiplies by (VF-2)*4 rather than\n+   an overlap check that multiplies by (257-1)*4.  */\n+/* { dg-final { scan-assembler {\\tcntb\\t(x[0-9]+)\\n.*\\tsub\\tx[0-9]+, \\1, #8\\n.*\\tmul\\tx[0-9]+,[^\\n]*\\1} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+[^\\n]*xzr} 1 } } */\n+/* One range check and a check for n being zero.  */\n+/* { dg-final { scan-assembler-times {\\tcmp\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 1 } } */"}, {"sha": "93c114193e90b87416c566fa6e14ef4d973506ee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_5.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -15,13 +15,10 @@ f (TYPE *x, TYPE *y, long n, long m __attribute__((unused)))\n /* { dg-final { scan-assembler {\\tst1d\\tz[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tldr\\td[0-9]+} } } */\n /* { dg-final { scan-assembler {\\tstr\\td[0-9]+} } } */\n-/* Should multiply by (VF-1)*8 rather than (257-1)*8.  */\n-/* { dg-final { scan-assembler-not {, 2048} } } */\n-/* { dg-final { scan-assembler-not {\\t.bfiz\\t} } } */\n-/* { dg-final { scan-assembler-not {lsl[^\\n]*[, ]11} } } */\n-/* { dg-final { scan-assembler {\\tcmp\\tx[0-9]+, 0} } } */\n-/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n-/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 2 } } */\n-/* Two range checks and a check for n being zero.  */\n-/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n-/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */\n+/* Should use a WAR check that multiplies by (VF-2)*8 rather than\n+   an overlap check that multiplies by (257-1)*4.  */\n+/* { dg-final { scan-assembler {\\tcntb\\t(x[0-9]+)\\n.*\\tsub\\tx[0-9]+, \\1, #16\\n.*\\tmul\\tx[0-9]+,[^\\n]*\\1} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+[^\\n]*xzr} 1 } } */\n+/* One range check and a check for n being zero.  */\n+/* { dg-final { scan-assembler-times {\\tcmp\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 1 } } */"}, {"sha": "bad80e1a23deb86e78aa12bbbb706ba022e3cbf8", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 213, "deletions": 5, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8489e1f45b50600c01eb8ed8c5d0ca914ded281c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "patch": "@@ -1805,6 +1805,8 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \t\t\t   abs_step, &niter_access2))\n     return false;\n \n+  bool waw_or_war_p = (alias_pair.flags & ~(DR_ALIAS_WAR | DR_ALIAS_WAW)) == 0;\n+\n   unsigned int i;\n   for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n     {\n@@ -1906,16 +1908,57 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \n \t Combining the tests requires limit to be computable in an unsigned\n \t form of the index type; if it isn't, we fall back to the usual\n-\t pointer-based checks.  */\n-      poly_offset_int limit = (idx_len1 + idx_access1 - 1\n-\t\t\t       + idx_len2 + idx_access2 - 1);\n+\t pointer-based checks.\n+\n+\t We can do better if DR_B is a write and if DR_A and DR_B are\n+\t well-ordered in both the original and the new code (see the\n+\t comment above the DR_ALIAS_* flags for details).  In this case\n+\t we know that for each i in [0, n-1], the write performed by\n+\t access i of DR_B occurs after access numbers j<=i of DR_A in\n+\t both the original and the new code.  Any write or anti\n+\t dependencies wrt those DR_A accesses are therefore maintained.\n+\n+\t We just need to make sure that each individual write in DR_B does not\n+\t overlap any higher-indexed access in DR_A; such DR_A accesses happen\n+\t after the DR_B access in the original code but happen before it in\n+\t the new code.\n+\n+\t We know the steps for both accesses are equal, so by induction, we\n+\t just need to test whether the first write of DR_B overlaps a later\n+\t access of DR_A.  In other words, we need to move min1 along by\n+\t one iteration:\n+\n+\t   min1' = min1 + idx_step\n+\n+\t and use the ranges:\n+\n+\t   [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]\n+\n+\t and:\n+\n+\t   [min2, min2 + idx_access2 - 1]\n+\n+\t where:\n+\n+\t    low_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)\n+\t   high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */\n+      if (waw_or_war_p)\n+\tidx_len1 -= abs_idx_step;\n+\n+      poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;\n+      if (!waw_or_war_p)\n+\tlimit += idx_len2;\n+\n       tree utype = unsigned_type_for (TREE_TYPE (min1));\n       if (!wi::fits_to_tree_p (limit, utype))\n \treturn false;\n \n       poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;\n-      poly_offset_int high_offset2 = neg_step ? 0 : idx_len2;\n+      poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;\n       poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;\n+      /* Equivalent to adding IDX_STEP to MIN1.  */\n+      if (waw_or_war_p)\n+\tbias -= wi::to_offset (idx_step);\n \n       tree subject = fold_build2 (MINUS_EXPR, utype,\n \t\t\t\t  fold_convert (utype, min2),\n@@ -1931,7 +1974,169 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \t*cond_expr = part_cond_expr;\n     }\n   if (dump_enabled_p ())\n-    dump_printf (MSG_NOTE, \"using an index-based overlap test\\n\");\n+    {\n+      if (waw_or_war_p)\n+\tdump_printf (MSG_NOTE, \"using an index-based WAR/WAW test\\n\");\n+      else\n+\tdump_printf (MSG_NOTE, \"using an index-based overlap test\\n\");\n+    }\n+  return true;\n+}\n+\n+/* A subroutine of create_intersect_range_checks, with a subset of the\n+   same arguments.  Try to optimize cases in which the second access\n+   is a write and in which some overlap is valid.  */\n+\n+static bool\n+create_waw_or_war_checks (tree *cond_expr,\n+\t\t\t  const dr_with_seg_len_pair_t &alias_pair)\n+{\n+  const dr_with_seg_len& dr_a = alias_pair.first;\n+  const dr_with_seg_len& dr_b = alias_pair.second;\n+\n+  /* Check for cases in which:\n+\n+     (a) DR_B is always a write;\n+     (b) the accesses are well-ordered in both the original and new code\n+\t (see the comment above the DR_ALIAS_* flags for details); and\n+     (c) the DR_STEPs describe all access pairs covered by ALIAS_PAIR.  */\n+  if (alias_pair.flags & ~(DR_ALIAS_WAR | DR_ALIAS_WAW))\n+    return false;\n+\n+  /* Check for equal (but possibly variable) steps.  */\n+  tree step = DR_STEP (dr_a.dr);\n+  if (!operand_equal_p (step, DR_STEP (dr_b.dr)))\n+    return false;\n+\n+  /* Make sure that we can operate on sizetype without loss of precision.  */\n+  tree addr_type = TREE_TYPE (DR_BASE_ADDRESS (dr_a.dr));\n+  if (TYPE_PRECISION (addr_type) != TYPE_PRECISION (sizetype))\n+    return false;\n+\n+  /* All addresses involved are known to have a common alignment ALIGN.\n+     We can therefore subtract ALIGN from an exclusive endpoint to get\n+     an inclusive endpoint.  In the best (and common) case, ALIGN is the\n+     same as the access sizes of both DRs, and so subtracting ALIGN\n+     cancels out the addition of an access size.  */\n+  unsigned int align = MIN (dr_a.align, dr_b.align);\n+  poly_uint64 last_chunk_a = dr_a.access_size - align;\n+  poly_uint64 last_chunk_b = dr_b.access_size - align;\n+\n+  /* Get a boolean expression that is true when the step is negative.  */\n+  tree indicator = dr_direction_indicator (dr_a.dr);\n+  tree neg_step = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t       fold_convert (ssizetype, indicator),\n+\t\t\t       ssize_int (0));\n+\n+  /* Get lengths in sizetype.  */\n+  tree seg_len_a\n+    = fold_convert (sizetype, rewrite_to_non_trapping_overflow (dr_a.seg_len));\n+  step = fold_convert (sizetype, rewrite_to_non_trapping_overflow (step));\n+\n+  /* Each access has the following pattern:\n+\n+\t  <- |seg_len| ->\n+\t  <--- A: -ve step --->\n+\t  +-----+-------+-----+-------+-----+\n+\t  | n-1 | ..... |  0  | ..... | n-1 |\n+\t  +-----+-------+-----+-------+-----+\n+\t\t\t<--- B: +ve step --->\n+\t\t\t<- |seg_len| ->\n+\t\t\t|\n+\t\t   base address\n+\n+     where \"n\" is the number of scalar iterations covered by the segment.\n+\n+     A is the range of bytes accessed when the step is negative,\n+     B is the range when the step is positive.\n+\n+     We know that DR_B is a write.  We also know (from checking that\n+     DR_A and DR_B are well-ordered) that for each i in [0, n-1],\n+     the write performed by access i of DR_B occurs after access numbers\n+     j<=i of DR_A in both the original and the new code.  Any write or\n+     anti dependencies wrt those DR_A accesses are therefore maintained.\n+\n+     We just need to make sure that each individual write in DR_B does not\n+     overlap any higher-indexed access in DR_A; such DR_A accesses happen\n+     after the DR_B access in the original code but happen before it in\n+     the new code.\n+\n+     We know the steps for both accesses are equal, so by induction, we\n+     just need to test whether the first write of DR_B overlaps a later\n+     access of DR_A.  In other words, we need to move addr_a along by\n+     one iteration:\n+\n+       addr_a' = addr_a + step\n+\n+     and check whether:\n+\n+       [addr_b, addr_b + last_chunk_b]\n+\n+     overlaps:\n+\n+       [addr_a' + low_offset_a, addr_a' + high_offset_a + last_chunk_a]\n+\n+     where [low_offset_a, high_offset_a] spans accesses [1, n-1].  I.e.:\n+\n+\tlow_offset_a = +ve step ? 0 : seg_len_a - step\n+       high_offset_a = +ve step ? seg_len_a - step : 0\n+\n+     This is equivalent to testing whether:\n+\n+       addr_a' + low_offset_a <= addr_b + last_chunk_b\n+       && addr_b <= addr_a' + high_offset_a + last_chunk_a\n+\n+     Converting this into a single test, there is an overlap if:\n+\n+       0 <= addr_b + last_chunk_b - addr_a' - low_offset_a <= limit\n+\n+     where limit = high_offset_a - low_offset_a + last_chunk_a + last_chunk_b\n+\n+     If DR_A is performed, limit + |step| - last_chunk_b is known to be\n+     less than the size of the object underlying DR_A.  We also know\n+     that last_chunk_b <= |step|; this is checked elsewhere if it isn't\n+     guaranteed at compile time.  There can therefore be no overflow if\n+     \"limit\" is calculated in an unsigned type with pointer precision.  */\n+  tree addr_a = fold_build_pointer_plus (DR_BASE_ADDRESS (dr_a.dr),\n+\t\t\t\t\t DR_OFFSET (dr_a.dr));\n+  addr_a = fold_build_pointer_plus (addr_a, DR_INIT (dr_a.dr));\n+\n+  tree addr_b = fold_build_pointer_plus (DR_BASE_ADDRESS (dr_b.dr),\n+\t\t\t\t\t DR_OFFSET (dr_b.dr));\n+  addr_b = fold_build_pointer_plus (addr_b, DR_INIT (dr_b.dr));\n+\n+  /* Advance ADDR_A by one iteration and adjust the length to compensate.  */\n+  addr_a = fold_build_pointer_plus (addr_a, step);\n+  tree seg_len_a_minus_step = fold_build2 (MINUS_EXPR, sizetype,\n+\t\t\t\t\t   seg_len_a, step);\n+  if (!CONSTANT_CLASS_P (seg_len_a_minus_step))\n+    seg_len_a_minus_step = build1 (SAVE_EXPR, sizetype, seg_len_a_minus_step);\n+\n+  tree low_offset_a = fold_build3 (COND_EXPR, sizetype, neg_step,\n+\t\t\t\t   seg_len_a_minus_step, size_zero_node);\n+  if (!CONSTANT_CLASS_P (low_offset_a))\n+    low_offset_a = build1 (SAVE_EXPR, sizetype, low_offset_a);\n+\n+  /* We could use COND_EXPR <neg_step, size_zero_node, seg_len_a_minus_step>,\n+     but it's usually more efficient to reuse the LOW_OFFSET_A result.  */\n+  tree high_offset_a = fold_build2 (MINUS_EXPR, sizetype, seg_len_a_minus_step,\n+\t\t\t\t    low_offset_a);\n+\n+  /* The amount added to addr_b - addr_a'.  */\n+  tree bias = fold_build2 (MINUS_EXPR, sizetype,\n+\t\t\t   size_int (last_chunk_b), low_offset_a);\n+\n+  tree limit = fold_build2 (MINUS_EXPR, sizetype, high_offset_a, low_offset_a);\n+  limit = fold_build2 (PLUS_EXPR, sizetype, limit,\n+\t\t       size_int (last_chunk_a + last_chunk_b));\n+\n+  tree subject = fold_build2 (POINTER_DIFF_EXPR, ssizetype, addr_b, addr_a);\n+  subject = fold_build2 (PLUS_EXPR, sizetype,\n+\t\t\t fold_convert (sizetype, subject), bias);\n+\n+  *cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject, limit);\n+  if (dump_enabled_p ())\n+    dump_printf (MSG_NOTE, \"using an address-based WAR/WAW test\\n\");\n   return true;\n }\n \n@@ -2035,6 +2240,9 @@ create_intersect_range_checks (class loop *loop, tree *cond_expr,\n   if (create_intersect_range_checks_index (loop, cond_expr, alias_pair))\n     return;\n \n+  if (create_waw_or_war_checks (cond_expr, alias_pair))\n+    return;\n+\n   unsigned HOST_WIDE_INT min_align;\n   tree_code cmp_code;\n   /* We don't have to check DR_ALIAS_MIXED_STEPS here, since both versions"}]}