{"sha": "0d354370f2e1b51efcf45c9241cabd0c7873b977", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQzNTQzNzBmMmUxYjUxZWZjZjQ1YzkyNDFjYWJkMGM3ODczYjk3Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-23T10:09:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-23T10:09:38Z"}, "message": "[multiple changes]\n\n2009-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Remove_Limited_With_Clause): Clean up code that handles\n\tincomplete type declarations. Previous code was potentially quadratic\n\tin the number of visible declarations in any package appearing in a\n\tlimited_with_clause.\n\n2009-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* prj-conf.ads, prj-part.adb, prj-proc.adb, prj-proc.ads, sem_ch8.adb,\n\txref_lib.adb: Minor reformatting\n\nFrom-SVN: r148843", "tree": {"sha": "4cf2eac6922db590544ebbe8c49c46f4c7b45b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cf2eac6922db590544ebbe8c49c46f4c7b45b6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d354370f2e1b51efcf45c9241cabd0c7873b977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d354370f2e1b51efcf45c9241cabd0c7873b977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d354370f2e1b51efcf45c9241cabd0c7873b977", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d354370f2e1b51efcf45c9241cabd0c7873b977/comments", "author": null, "committer": null, "parents": [{"sha": "85b7d482bb14e368989797ff40e6ae09dde2e820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b7d482bb14e368989797ff40e6ae09dde2e820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b7d482bb14e368989797ff40e6ae09dde2e820"}], "stats": {"total": 168, "additions": 92, "deletions": 76}, "files": [{"sha": "8546e6f88dafa2be413c6d9a6c2e46ba56dfe7fe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -1,3 +1,15 @@\n+2009-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Remove_Limited_With_Clause): Clean up code that handles\n+\tincomplete type declarations. Previous code was potentially quadratic\n+\tin the number of visible declarations in any package appearing in a\n+\tlimited_with_clause.\n+\n+2009-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* prj-conf.ads, prj-part.adb, prj-proc.adb, prj-proc.ads, sem_ch8.adb,\n+\txref_lib.adb: Minor reformatting\n+\n 2009-06-23  Robert Dewar  <dewar@adacore.com>\n \n \t* a-stzhas.adb: Provide dummy body to avoid build problems with old"}, {"sha": "091ae5429b7d7019573e792fafee2ba456b17ab1", "filename": "gcc/ada/prj-conf.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-conf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-conf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.ads?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -35,11 +35,11 @@ package Prj.Conf is\n       Project_Node_Tree : Prj.Tree.Project_Node_Tree_Ref);\n    --  Hook called after the config file has been parsed. This lets the\n    --  application do last minute changes to it (GPS uses this to add the\n-   --  default naming schemes for instance).\n-   --  At that point, the config file has not been applied to the project yet.\n-   --  When no config file was found, and automatic generation is disabled, it\n-   --  is possible that Config_File is set to Empty_Node when this procedure is\n-   --  called. You can then decide to create a new config file if you need.\n+   --  default naming schemes for instance). At that point, the config file\n+   --  has not been applied to the project yet. When no config file was found,\n+   --  and automatic generation is disabled, it is possible that Config_File\n+   --  is set to Empty_Node when this procedure is called. You can then decide\n+   --  to create a new config file if you need.\n \n    procedure Parse_Project_And_Apply_Config\n      (Main_Project               : out Prj.Project_Id;"}, {"sha": "6582e6b8183067a41a9ded5d9f4fd7f28812b170", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -1227,6 +1227,7 @@ package body Prj.Part is\n       end if;\n \n       if Is_Config_File and then Proj_Qualifier = Unspecified then\n+\n          --  Set the qualifier to Configuration, even if the token doesn't\n          --  exist in the source file itself, so that we can differentiate\n          --  project files and configuration files later on."}, {"sha": "677c59737469791d7c8198e8aed69645af0db100", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -79,11 +79,11 @@ package body Prj.Proc is\n    --  the package or project with declarations Decl.\n \n    procedure Check\n-     (In_Tree         : Project_Tree_Ref;\n-      Project         : Project_Id;\n-      Current_Dir     : String;\n-      When_No_Sources : Error_Warning;\n-      Is_Config_File  : Boolean;\n+     (In_Tree                   : Project_Tree_Ref;\n+      Project                   : Project_Id;\n+      Current_Dir               : String;\n+      When_No_Sources           : Error_Warning;\n+      Is_Config_File            : Boolean;\n       Compiler_Driver_Mandatory : Boolean);\n    --  Set all projects to not checked, then call Recursive_Check for the\n    --  main project Project. Project is set to No_Project if errors occurred.\n@@ -148,11 +148,11 @@ package body Prj.Proc is\n    --  project.\n \n    type Recursive_Check_Data is record\n-      In_Tree         : Project_Tree_Ref;\n-      Current_Dir     : String_Access;\n-      When_No_Sources : Error_Warning;\n-      Proc_Data       : Processing_Data;\n-      Is_Config_File  : Boolean;\n+      In_Tree                   : Project_Tree_Ref;\n+      Current_Dir               : String_Access;\n+      When_No_Sources           : Error_Warning;\n+      Proc_Data                 : Processing_Data;\n+      Is_Config_File            : Boolean;\n       Compiler_Driver_Mandatory : Boolean;\n    end record;\n    --  Data passed to Recursive_Check\n@@ -180,7 +180,6 @@ package body Prj.Proc is\n       elsif Str /= No_Name and then Str /= Empty_String then\n          declare\n             S : constant String := Get_Name_String (Str);\n-\n          begin\n             Get_Name_String (To_Exp);\n             Add_Str_To_Name_Buffer (S);\n@@ -296,11 +295,12 @@ package body Prj.Proc is\n       Data : Recursive_Check_Data;\n \n    begin\n-      Data.In_Tree         := In_Tree;\n-      Data.Current_Dir     := Dir'Unchecked_Access;\n-      Data.When_No_Sources := When_No_Sources;\n-      Data.Is_Config_File  := Is_Config_File;\n+      Data.In_Tree                   := In_Tree;\n+      Data.Current_Dir               := Dir'Unchecked_Access;\n+      Data.When_No_Sources           := When_No_Sources;\n+      Data.Is_Config_File            := Is_Config_File;\n       Data.Compiler_Driver_Mandatory := Compiler_Driver_Mandatory;\n+\n       Initialize (Data.Proc_Data);\n \n       Check_All_Projects (Project, Data, Imported_First => True);\n@@ -2310,15 +2310,15 @@ package body Prj.Proc is\n    ----------------------------------\n \n    procedure Process_Project_Tree_Phase_2\n-     (In_Tree                : Project_Tree_Ref;\n-      Project                : Project_Id;\n-      Success                : out Boolean;\n-      From_Project_Node      : Project_Node_Id;\n-      From_Project_Node_Tree : Project_Node_Tree_Ref;\n-      Report_Error           : Put_Line_Access;\n-      When_No_Sources        : Error_Warning := Error;\n-      Current_Dir            : String;\n-      Is_Config_File         : Boolean;\n+     (In_Tree                   : Project_Tree_Ref;\n+      Project                   : Project_Id;\n+      Success                   : out Boolean;\n+      From_Project_Node         : Project_Node_Id;\n+      From_Project_Node_Tree    : Project_Node_Tree_Ref;\n+      Report_Error              : Put_Line_Access;\n+      When_No_Sources           : Error_Warning := Error;\n+      Current_Dir               : String;\n+      Is_Config_File            : Boolean;\n       Compiler_Driver_Mandatory : Boolean)\n    is\n       Obj_Dir    : Path_Name_Type;\n@@ -2334,7 +2334,7 @@ package body Prj.Proc is\n \n       if Project /= No_Project then\n          Check (In_Tree, Project, Current_Dir, When_No_Sources,\n-                Is_Config_File => Is_Config_File,\n+                Is_Config_File            => Is_Config_File,\n                 Compiler_Driver_Mandatory => Compiler_Driver_Mandatory);\n       end if;\n \n@@ -2460,7 +2460,7 @@ package body Prj.Proc is\n         (Project, Data.In_Tree, Error_Report, Data.When_No_Sources,\n          Data.Current_Dir.all, Data.Proc_Data,\n          Compiler_Driver_Mandatory => Data.Compiler_Driver_Mandatory,\n-         Is_Config_File => Data.Is_Config_File);\n+         Is_Config_File            => Data.Is_Config_File);\n    end Recursive_Check;\n \n    -----------------------"}, {"sha": "11f6f488a1ccc2fa0c16a7bbaf364ea9fb0d4a37", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -58,15 +58,15 @@ package Prj.Proc is\n    --  project table before processing.\n \n    procedure Process_Project_Tree_Phase_2\n-     (In_Tree                : Project_Tree_Ref;\n-      Project                : Project_Id;\n-      Success                : out Boolean;\n-      From_Project_Node      : Project_Node_Id;\n-      From_Project_Node_Tree : Project_Node_Tree_Ref;\n-      Report_Error           : Put_Line_Access;\n-      When_No_Sources        : Error_Warning := Error;\n-      Current_Dir            : String;\n-      Is_Config_File         : Boolean;\n+     (In_Tree                   : Project_Tree_Ref;\n+      Project                   : Project_Id;\n+      Success                   : out Boolean;\n+      From_Project_Node         : Project_Node_Id;\n+      From_Project_Node_Tree    : Project_Node_Tree_Ref;\n+      Report_Error              : Put_Line_Access;\n+      When_No_Sources           : Error_Warning := Error;\n+      Current_Dir               : String;\n+      Is_Config_File            : Boolean;\n       Compiler_Driver_Mandatory : Boolean);\n    --  Perform the second phase of the processing, filling the rest of the\n    --  project with the information extracted from the project tree. This phase"}, {"sha": "8ae44ff704161d3dd20c537c337b372cb862a052", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -5650,50 +5650,53 @@ package body Sem_Ch10 is\n             if Ekind (Lim_Typ) /= E_Package\n               and then not Is_Child_Unit (Non_Limited_View (Lim_Typ))\n             then\n-               --  Handle incomplete types of the real view. For this purpose\n-               --  we traverse the list of visible entities to look for an\n-               --  incomplete type in the real-view associated with Lim_Typ.\n \n-               E := First_Entity (P);\n-               while Present (E) and then E /= First_Private_Entity (P) loop\n-                  exit when Ekind (E) = E_Incomplete_Type\n-                    and then Present (Full_View (E))\n-                    and then Full_View (E) = Lim_Typ;\n+               --  If the package has incomplete types, the limited view\n+               --  of the incomplete type is in fact never visible (AI05-129)\n+               --  but we have created a shadow entity E1 for it, that points\n+               --  to E2, a non-limited incomplete type. This in turn has a\n+               --  full view E3 that is the full declaration. There is a\n+               --  corresponding shadow entity E4. When reinstalling the\n+               --  non-limited view, E2 must become the current entity and\n+               --  E3 must be ignored.\n \n-                  Next_Entity (E);\n-               end loop;\n+               E := Non_Limited_View (Lim_Typ);\n \n-               --  If the previous search was not successful then the entity\n-               --  to be restored in the homonym list is the non-limited view\n+               if Present (Current_Entity (E))\n+                 and then Ekind (Current_Entity (E)) = E_Incomplete_Type\n+                 and then Full_View (Current_Entity (E)) = E\n+               then\n \n-               if E = First_Private_Entity (P) then\n-                  E := Non_Limited_View (Lim_Typ);\n-               end if;\n+                  --  Lim_Typ is the limited view of a full type declaration\n+                  --  that has a previous incomplete declaration, i.e. E3\n+                  --  from the previous description. Nothing to insert.\n \n-               pragma Assert (not In_Chain (E));\n+                  null;\n \n-               Prev := Current_Entity (Lim_Typ);\n+               else\n+                  pragma Assert (not In_Chain (E));\n \n-               if Prev = Lim_Typ then\n-                  Set_Current_Entity (E);\n+                  Prev := Current_Entity (Lim_Typ);\n \n-               else\n-                  while Present (Prev)\n-                    and then Homonym (Prev) /= Lim_Typ\n-                  loop\n-                     Prev := Homonym (Prev);\n-                  end loop;\n+                  if Prev = Lim_Typ then\n+                     Set_Current_Entity (E);\n \n-                  if Present (Prev) then\n-                     Set_Homonym (Prev, E);\n+                  else\n+                     while Present (Prev)\n+                       and then Homonym (Prev) /= Lim_Typ\n+                     loop\n+                        Prev := Homonym (Prev);\n+                     end loop;\n+\n+                     if Present (Prev) then\n+                        Set_Homonym (Prev, E);\n+                     end if;\n                   end if;\n-               end if;\n \n-               --  We must also set the next homonym entity of the real entity\n-               --  to handle the case in which the next homonym was a shadow\n-               --  entity.\n+                  --  Preserve structure of homonym chain.\n \n-               Set_Homonym (E, Homonym (Lim_Typ));\n+                  Set_Homonym (E, Homonym (Lim_Typ));\n+               end if;\n             end if;\n \n             Next_Entity (Lim_Typ);"}, {"sha": "afb0d4233ec4fb0f7c3dde4ae90bd4f3088d778c", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -4773,10 +4773,10 @@ package body Sem_Ch8 is\n                   then\n                      declare\n                         H : constant Entity_Id := Homonym (P_Name);\n+\n                      begin\n                         Id := First_Entity (H);\n                         while Present (Id) loop\n-\n                            if Chars (Id) = Chars (Selector) then\n                               Error_Msg_Qual_Level := 99;\n                               Error_Msg_Name_1 := Chars (Selector);"}, {"sha": "935291328fedec8304ebc47405b4a8391f0b6d0c", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d354370f2e1b51efcf45c9241cabd0c7873b977/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=0d354370f2e1b51efcf45c9241cabd0c7873b977", "patch": "@@ -49,7 +49,7 @@ package body Xref_Lib is\n \n    No_Xref_Information : exception;\n    --  Exception raised when there is no cross-referencing information in\n-   --  the .ali files\n+   --  the .ali files.\n \n    procedure Parse_EOL\n      (Source                 : not null access String;\n@@ -708,9 +708,9 @@ package body Xref_Lib is\n             Ptr := Ptr + 1;\n          end loop;\n \n-         if Source (Ptr) /= EOF then\n-            --  Skip CR or LF\n+         --  Skip CR or LF if not at end of file\n \n+         if Source (Ptr) /= EOF then\n             Ptr := Ptr + 1;\n          end if;\n "}]}