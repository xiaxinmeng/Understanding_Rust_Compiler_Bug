{"sha": "a7a64a77ef33be210374003a0b84dd8d60f75a49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhNjRhNzdlZjMzYmUyMTAzNzQwMDNhMGI4NGRkOGQ2MGY3NWE0OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-07-26T08:18:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-07-26T08:18:19Z"}, "message": "cp-tree.h (CP_INTEGRAL_TYPE_P): New macro.\n\n\t* cp-tree.h (CP_INTEGRAL_TYPE_P): New macro.\n\t(ARITHMETIC_TYPE_P): Adjust definition for standard conformance.\n\t(strip_top_quals): Declare.\n\t(ncp_convert): Likewise.\n\t(type_after_usual_arithmetic_converions): Likewise.\n\t(composite_pointer_type): Likewise.\n\t* call.c (strip_top_quals): Don't make it static.\n\t(promoted_arithmetic_type_p): New function.\n\t(conditional_conversion): Likewise.\n\t(null_ptr_cst_p): Allow `false' as a NULL pointer constant.\n\t(standard_conversion): Use same_type_p.  Don't build BASE_CONVs\n\tfor converting a type to itself.\n\t(reference_binding): Honor LOOKUP_NO_TEMP_BIND.\n\t(implicit_conversion): Make sure the from and to types are\n\tcomplete.\n\t(add_builtin_candidate): Correct handling of ?: operator.\n\t(add_builtin_candidates): Improve documentation.\n\t(build_conditional_expr): New function.\n\t(can_convert): Implement in terms of can_convert_arg.\n\t(ncp_convert): New function.\n\t* typeck.c (type_after_usual_arithmetic_conversions): New\n\tfunction, split out from common_type.\n\t(composite_pointer_type): New function, split out from\n\tbuild_conditional_expr.\n\t(common_type): Use type_after_usual_arithmetic_conversions.\n\tRemove redundant attribute merging.\n\t(comptypes): Tidy.  Handle COMPLEX_TYPE.\n\t(build_binary_op_nodefault): Use null_ptr_cst_p.\n\t(build_conditional_expr): Remove.\n\t(convert_for_assignment): Use new conversion functions.\n\n\t* cp-tree.h (abstract_virtuals_error): Change declaration.\n\t* typeck2.c (abstract_virtuals_error): Check to see if an error\n\tocurred, and return a boolean value accordingly.\n\t(build_functional_cast): Adjust accordingly.\n\t* class.c (finish_struct_1): Likewise.\n\t* cvt.c (ocp_convert): Likewise.\n\t* decl.c (cp_finish_decl): Likewise.\n\t(grokparams): Likewise.\n\t(grok_op_properties): Likewise.\n\t(start_function): Likewise.\n\t* init.c (build_new_1): Likewise.\n\n\t* pt.c (unify): Don't get confused by pointers-to-member functions.\n\n\t* search.c (build_cplus_new): Robustify.\n\nFrom-SVN: r28262", "tree": {"sha": "c9b772ea54e12c6cccfb0e0b435dbd04cdf6a698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9b772ea54e12c6cccfb0e0b435dbd04cdf6a698"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7a64a77ef33be210374003a0b84dd8d60f75a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a64a77ef33be210374003a0b84dd8d60f75a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a64a77ef33be210374003a0b84dd8d60f75a49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a64a77ef33be210374003a0b84dd8d60f75a49/comments", "author": null, "committer": null, "parents": [{"sha": "5cabd6f5f4b1c910709ab5beca3ad62e7d38ed7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cabd6f5f4b1c910709ab5beca3ad62e7d38ed7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cabd6f5f4b1c910709ab5beca3ad62e7d38ed7f"}], "stats": {"total": 1783, "additions": 891, "deletions": 892}, "files": [{"sha": "4dba90246fbf1eb1b3466671ab654aaf31c093c0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -1,3 +1,52 @@\n+1999-07-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CP_INTEGRAL_TYPE_P): New macro.\n+\t(ARITHMETIC_TYPE_P): Adjust definition for standard conformance.\n+\t(strip_top_quals): Declare.\n+\t(ncp_convert): Likewise.\n+\t(type_after_usual_arithmetic_converions): Likewise.\n+\t(composite_pointer_type): Likewise.\n+\t* call.c (strip_top_quals): Don't make it static.\n+\t(promoted_arithmetic_type_p): New function.\n+\t(conditional_conversion): Likewise.\n+\t(null_ptr_cst_p): Allow `false' as a NULL pointer constant.\n+\t(standard_conversion): Use same_type_p.  Don't build BASE_CONVs\n+\tfor converting a type to itself.\n+\t(reference_binding): Honor LOOKUP_NO_TEMP_BIND.\n+\t(implicit_conversion): Make sure the from and to types are\n+\tcomplete.\n+\t(add_builtin_candidate): Correct handling of ?: operator.\n+\t(add_builtin_candidates): Improve documentation.\n+\t(build_conditional_expr): New function.\n+\t(can_convert): Implement in terms of can_convert_arg.\n+\t(ncp_convert): New function.\n+\t* typeck.c (type_after_usual_arithmetic_conversions): New\n+\tfunction, split out from common_type.\n+\t(composite_pointer_type): New function, split out from\n+\tbuild_conditional_expr.\n+\t(common_type): Use type_after_usual_arithmetic_conversions.\n+\tRemove redundant attribute merging.\n+\t(comptypes): Tidy.  Handle COMPLEX_TYPE.\n+\t(build_binary_op_nodefault): Use null_ptr_cst_p.\n+\t(build_conditional_expr): Remove.\n+\t(convert_for_assignment): Use new conversion functions.\n+\t\n+\t* cp-tree.h (abstract_virtuals_error): Change declaration.\n+\t* typeck2.c (abstract_virtuals_error): Check to see if an error\n+\tocurred, and return a boolean value accordingly.\n+\t(build_functional_cast): Adjust accordingly.\n+\t* class.c (finish_struct_1): Likewise.\n+\t* cvt.c (ocp_convert): Likewise.\n+\t* decl.c (cp_finish_decl): Likewise.\n+\t(grokparams): Likewise.\n+\t(grok_op_properties): Likewise.\n+\t(start_function): Likewise.\n+\t* init.c (build_new_1): Likewise.\n+\n+\t* pt.c (unify): Don't get confused by pointers-to-member functions.\n+\n+\t* search.c (build_cplus_new): Robustify.\n+\t\n 1999-07-24  Richard Henderson  <rth@cygnus.com>\n \n \t* decl.c (ptr_type_node, va_list_type_node): New."}, {"sha": "cd5e77d6a2c5e323999f7e89d7031800c420756e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 461, "deletions": 42, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -82,7 +82,6 @@ static struct z_candidate * add_function_candidate\n static tree implicit_conversion PROTO((tree, tree, tree, int));\n static tree standard_conversion PROTO((tree, tree, tree));\n static tree reference_binding PROTO((tree, tree, tree, int));\n-static tree strip_top_quals PROTO((tree));\n static tree non_reference PROTO((tree));\n static tree build_conv PROTO((enum tree_code, tree, tree));\n static int is_subseq PROTO((tree, tree));\n@@ -96,6 +95,8 @@ static int reference_related_p PROTO ((tree, tree));\n static int reference_compatible_p PROTO ((tree, tree));\n static tree convert_class_to_reference PROTO ((tree, tree, tree));\n static tree direct_reference_binding PROTO ((tree, tree));\n+static int promoted_arithmetic_type_p PROTO ((tree));\n+static tree conditional_conversion PROTO ((tree, tree));\n \n tree\n build_vfield_ref (datum, type)\n@@ -550,8 +551,12 @@ int\n null_ptr_cst_p (t)\n      tree t;\n {\n+  /* [conv.ptr]\n+\n+     A null pointer constant is an integral constant expression\n+     (_expr.const_) rvalue of integer type that evaluates to zero.  */\n   if (t == null_node\n-      || (integer_zerop (t) && TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE))\n+      || (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t)))\n     return 1;\n   return 0;\n }\n@@ -595,7 +600,7 @@ non_reference (t)\n   return t;\n }\n \n-static tree\n+tree\n strip_top_quals (t)\n      tree t;\n {\n@@ -655,7 +660,7 @@ standard_conversion (to, from, expr)\n   else if (fromref || (expr && real_lvalue_p (expr)))\n     conv = build_conv (RVALUE_CONV, from, conv);\n \n-  if (from == to)\n+  if (same_type_p (from, to))\n     return conv;\n \n   if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n@@ -770,7 +775,7 @@ standard_conversion (to, from, expr)\n \tICS_STD_RANK (conv) = PROMO_RANK;\n     }\n   else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n-\t   && DERIVED_FROM_P (to, from))\n+\t   && is_properly_derived_from (from, to))\n     {\n       if (TREE_CODE (conv) == RVALUE_CONV)\n \tconv = TREE_OPERAND (conv, 0);\n@@ -1069,6 +1074,11 @@ reference_binding (rto, rfrom, expr, flags)\n \treturn direct_reference_binding (rto, conv);\n     }\n \n+  /* From this point on, we conceptually need temporaries, even if we\n+     elide them.  Only the cases above are \"direct bindings\".  */\n+  if (flags & LOOKUP_NO_TEMP_BIND)\n+    return NULL_TREE;\n+\n   /* [over.ics.rank]\n      \n      When a parameter of reference type is not bound directly to an\n@@ -1141,6 +1151,9 @@ implicit_conversion (to, from, expr, flags)\n   tree conv;\n   struct z_candidate *cand;\n \n+  complete_type (from);\n+  complete_type (to);\n+\n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr, flags);\n   else\n@@ -1461,6 +1474,24 @@ is_complete (t)\n   return TYPE_SIZE (complete_type (t)) != NULL_TREE;\n }\n \n+/* Returns non-zero if TYPE is a promoted arithmetic type.  */\n+\n+static int\n+promoted_arithmetic_type_p (type)\n+     tree type;\n+{\n+  /* [over.built]\n+\n+     In this section, the term promoted integral type is used to refer\n+     to those integral types which are preserved by integral promotion\n+     (including e.g.  int and long but excluding e.g.  char).\n+     Similarly, the term promoted arithmetic type refers to promoted\n+     integral types plus floating types.  */\n+  return ((INTEGRAL_TYPE_P (type)\n+\t   && same_type_p (type_promotes_to (type), type))\n+\t  || TREE_CODE (type) == REAL_TYPE);\n+}\n+\n /* Create any builtin operator overload candidates for the operator in\n    question given the converted operand types TYPE1 and TYPE2.  The other\n    args are passed through from add_builtin_candidates to\n@@ -1800,43 +1831,41 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n       break;\n \n     case COND_EXPR:\n-      /* Kludge around broken overloading rules whereby\n-\t bool ? const char& : enum is ambiguous\n-\t (between int and const char&).  */\n-      flags |= LOOKUP_NO_TEMP_BIND;\n+      /* [over.builtin]\n+\n+\t For every pair of promoted arithmetic types L and R, there\n+\t exist candidate operator functions of the form \n \n-      /* Extension: Support ?: of enumeral type.  Hopefully this will not\n-         be an extension for long.  */\n-      if (TREE_CODE (type1) == ENUMERAL_TYPE && type1 == type2)\n+\t LR operator?(bool, L, R); \n+\n+\t where LR is the result of the usual arithmetic conversions\n+\t between types L and R.\n+\n+\t For every type T, where T is a pointer or pointer-to-member\n+\t type, there exist candidate operator functions of the form T\n+\t operator?(bool, T, T);  */\n+\n+      if (promoted_arithmetic_type_p (type1)\n+\t  && promoted_arithmetic_type_p (type2))\n+\t/* That's OK.  */\n \tbreak;\n-      else if (TREE_CODE (type1) == ENUMERAL_TYPE\n-\t       || TREE_CODE (type2) == ENUMERAL_TYPE)\n+\n+      /* Otherwise, the types should be pointers.  */\n+      if (!(TREE_CODE (type1) == POINTER_TYPE\n+\t    || TYPE_PTRMEM_P (type1)\n+\t    || TYPE_PTRMEMFUNC_P (type1))\n+\t  || !(TREE_CODE (type2) == POINTER_TYPE\n+\t       || TYPE_PTRMEM_P (type2)\n+\t       || TYPE_PTRMEMFUNC_P (type2)))\n \treturn candidates;\n-      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\tbreak;\n-      if (TREE_CODE (type1) == TREE_CODE (type2)\n-\t  && (TREE_CODE (type1) == REFERENCE_TYPE\n-\t      || TREE_CODE (type1) == POINTER_TYPE\n-\t      || TYPE_PTRMEMFUNC_P (type1)\n-\t      || IS_AGGR_TYPE (type1)))\n+      \n+      /* We don't check that the two types are the same; the logic\n+\t below will actually create two candidates; one in which both\n+\t parameter types are TYPE1, and one in which both parameter\n+\t types are TYPE2.  */\n \tbreak;\n-      if (TREE_CODE (type1) == REFERENCE_TYPE\n-\t  || TREE_CODE (type2) == REFERENCE_TYPE)\n-\treturn candidates;\n-      if (((TYPE_PTRMEMFUNC_P (type1) || TREE_CODE (type1) == POINTER_TYPE)\n-\t   && null_ptr_cst_p (args[1]))\n-\t  || IS_AGGR_TYPE (type1))\n-\t{\n-\t  type2 = type1;\n-\t  break;\n-\t}\n-      if (((TYPE_PTRMEMFUNC_P (type2) || TREE_CODE (type2) == POINTER_TYPE)\n-\t   && null_ptr_cst_p (args[0]))\n-\t  || IS_AGGR_TYPE (type2))\n-\t{\n-\t  type1 = type2;\n-\t  break;\n-\t}\n+\n+      /* These arguments do not make for a legal overloaded operator.  */\n       return candidates;\n \n     default:\n@@ -1845,7 +1874,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \n   /* If we're dealing with two pointer types, we need candidates\n      for both of them.  */\n-  if (type2 && type1 != type2\n+  if (type2 && !same_type_p (type1, type2)\n       && TREE_CODE (type1) == TREE_CODE (type2)\n       && (TREE_CODE (type1) == REFERENCE_TYPE\n \t  || (TREE_CODE (type1) == POINTER_TYPE\n@@ -1890,7 +1919,12 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n      int flags;\n {\n   int ref1, i;\n-  tree type, argtypes[3], types[2];\n+  tree type, argtypes[3];\n+  /* TYPES[i] is the set of possible builtin-operator parameter types\n+     we will consider for the Ith argument.  These are represented as\n+     a TREE_LIST; the TREE_VALUE of each node is the potential\n+     parameter type.  */\n+  tree types[2];\n \n   for (i = 0; i < 3; ++i)\n     {\n@@ -2012,6 +2046,8 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t}\n     }\n \n+  /* Run through the possible parameter types of both arguments,\n+     creating candidates with those parameter types.  */\n   for (; types[0]; types[0] = TREE_CHAIN (types[0]))\n     {\n       if (types[1])\n@@ -2635,6 +2671,374 @@ op_error (code, code2, arg1, arg2, arg3, problem)\n     }\n }\n \n+/* Return the implicit conversion sequence that could be used to\n+   convert E1 to E2 in [expr.cond].  */\n+\n+static tree\n+conditional_conversion (e1, e2)\n+     tree e1;\n+     tree e2;\n+{\n+  tree t1 = non_reference (TREE_TYPE (e1));\n+  tree t2 = non_reference (TREE_TYPE (e2));\n+  tree conv;\n+\n+  /* [expr.cond]\n+\n+     If E2 is an lvalue: E1 can be converted to match E2 if E1 can be\n+     implicitly converted (clause _conv_) to the type \"reference to\n+     T2\", subject to the constraint that in the conversion the\n+     reference must bind directly (_dcl.init.ref_) to E1.  */\n+  if (real_lvalue_p (e2))\n+    {\n+      conv = implicit_conversion (build_reference_type (t2), \n+\t\t\t\t  t1,\n+\t\t\t\t  e1,\n+\t\t\t\t  LOOKUP_NO_TEMP_BIND);\n+      if (conv)\n+\treturn conv;\n+    }\n+\n+  /* [expr.cond]\n+\n+     If E1 and E2 have class type, and the underlying class types are\n+     the same or one is a base class of the other: E1 can be converted\n+     to match E2 if the class of T2 is the same type as, or a base\n+     class of, the class of T1, and the cv-qualification of T2 is the\n+     same cv-qualification as, or a greater cv-qualification than, the\n+     cv-qualification of T1.  If the conversion is applied, E1 is\n+     changed to an rvalue of type T2 that still refers to the original\n+     source class object (or the appropriate subobject thereof).  */\n+  if (CLASS_TYPE_P (t1) && CLASS_TYPE_P (t2)\n+      && same_or_base_type_p (TYPE_MAIN_VARIANT (t2), \n+\t\t\t      TYPE_MAIN_VARIANT (t1)))\n+    {\n+      if (at_least_as_qualified_p (t2, t1))\n+\t{\n+\t  conv = build1 (IDENTITY_CONV, t1, e1);\n+\t  conv = build_conv (BASE_CONV, t2, conv);\n+\t  return conv;\n+\t}\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n+  /* [expr.cond]\n+\n+     E1 can be converted to match E2 if E1 can be implicitly converted\n+     to the type that expression E2 would have if E2 were converted to\n+     an rvalue (or the type it has, if E2 is an rvalue).  */\n+  return implicit_conversion (t2, t1, e1, LOOKUP_NORMAL);\n+}\n+\n+/* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n+   arguments to the conditional expression.  As an extension, g++\n+   allows users to overload the ?: operator.  By the time this\n+   function is called, any suitable candidate functions are included\n+   in CANDIDATES.  */\n+\n+tree\n+build_conditional_expr (arg1, arg2, arg3)\n+     tree arg1;\n+     tree arg2;\n+     tree arg3;\n+{\n+  tree arg2_type;\n+  tree arg3_type;\n+  tree result;\n+  tree result_type = NULL_TREE;\n+  int lvalue_p = 1;\n+  struct z_candidate *candidates = 0;\n+  struct z_candidate *cand;\n+\n+  /* As a G++ extension, the second argument to the conditional can be\n+     omitted.  (So that `a ? : c' is roughly equivalent to `a ? a :\n+     c'.)  If second operand is omitted, make sure it is calculated\n+     only once.  */\n+  if (!arg2)\n+    {\n+      if (pedantic)\n+\tpedwarn (\"ANSI C++ forbids omitting the middle term of a ?: expression\");\n+      arg1 = arg2 = save_expr (arg1);\n+    }\n+\n+  /* If something has already gone wrong, just pass that fact up the\n+     tree.  */\n+  if (arg1 == error_mark_node \n+      || arg2 == error_mark_node \n+      || arg3 == error_mark_node \n+      || TREE_TYPE (arg1) == error_mark_node\n+      || TREE_TYPE (arg2) == error_mark_node\n+      || TREE_TYPE (arg3) == error_mark_node)\n+    return error_mark_node;\n+\n+  /* [expr.cond]\n+  \n+     The first expr ession is implicitly converted to bool (clause\n+     _conv_).  */\n+  arg1 = cp_convert (boolean_type_node, arg1);\n+\n+  /* [expr.cond]\n+\n+     If either the second or the third operand has type (possibly\n+     cv-qualified) void, then the lvalue-to-rvalue (_conv.lval_),\n+     array-to-pointer (_conv.array_), and function-to-pointer\n+     (_conv.func_) standard conversions are performed on the second\n+     and third operands.  */\n+  arg2_type = TREE_TYPE (arg2);\n+  arg3_type = TREE_TYPE (arg3);\n+  if (same_type_p (TYPE_MAIN_VARIANT (arg2_type), void_type_node)\n+      || same_type_p (TYPE_MAIN_VARIANT (arg3_type), void_type_node))\n+    {\n+      int arg2_void_p;\n+      int arg3_void_p;\n+\n+      /* Do the conversions.  We don't these for `void' type arguments\n+\t since it can't have any effect and since decay_conversion\n+\t does not handle that case gracefully.  */\n+      if (!same_type_p (TYPE_MAIN_VARIANT (arg2_type), void_type_node))\n+\targ2 = decay_conversion (arg2);\n+      if (!same_type_p (TYPE_MAIN_VARIANT (arg3_type), void_type_node))\n+\targ3 = decay_conversion (arg3);\n+      arg2_type = TREE_TYPE (arg2);\n+      arg3_type = TREE_TYPE (arg3);\n+\n+      arg2_void_p = same_type_p (TYPE_MAIN_VARIANT (arg2_type),\n+\t\t\t\t void_type_node);\n+      arg3_void_p = same_type_p (TYPE_MAIN_VARIANT (arg3_type),\n+\t\t\t\t void_type_node);\n+\n+      /* [expr.cond]\n+\n+\t One of the following shall hold:\n+\n+\t --The second or the third operand (but not both) is a\n+\t   throw-expression (_except.throw_); the result is of the\n+\t   type of the other and is an rvalue.\n+\n+\t --Both the second and the third operands have type void; the\n+\t   result is of type void and is an rvalue.   */\n+      if ((TREE_CODE (arg2) == THROW_EXPR)\n+\t  ^ (TREE_CODE (arg3) == THROW_EXPR))\n+\tresult_type = ((TREE_CODE (arg2) == THROW_EXPR) \n+\t\t       ? arg2_type : arg3_type);\n+      else if (arg2_void_p && arg3_void_p)\n+\tresult_type = void_type_node;\n+      else\n+\t{\n+\t  cp_error (\"`%E' has type `void' and is not a throw-expression\",\n+\t\t    arg2_void_p ? arg2 : arg3);\n+\t  return error_mark_node;\n+\t}\n+\n+      lvalue_p = 0;\n+      goto valid_operands;\n+    }\n+  /* [expr.cond]\n+\n+     Otherwise, if the second and third operand have different types,\n+     and either has (possibly cv-qualified) class type, an attempt is\n+     made to convert each of those operands to the type of the other.  */\n+  else if (!same_type_p (arg2_type, arg3_type)\n+\t   && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n+    {\n+      tree conv2 = conditional_conversion (arg2, arg3);\n+      tree conv3 = conditional_conversion (arg3, arg2);\n+      \n+      /* [expr.cond]\n+\n+\t If both can be converted, or one can be converted but the\n+\t conversion is ambiguous, the program is ill-formed.  If\n+\t neither can be converted, the operands are left unchanged and\n+\t further checking is performed as described below.  If exactly\n+\t one conversion is possible, that conversion is applied to the\n+\t chosen operand and the converted operand is used in place of\n+\t the original operand for the remainder of this section.  */\n+      if ((conv2 && !ICS_BAD_FLAG (conv2) \n+\t   && conv3 && !ICS_BAD_FLAG (conv3))\n+\t  || (conv2 && TREE_CODE (conv2) == AMBIG_CONV)\n+\t  || (conv3 && TREE_CODE (conv3) == AMBIG_CONV))\n+\t{\n+\t  cp_error (\"operands to ?: have different types\");\n+\t  return error_mark_node;\n+\t}\n+      else if (conv2 && !ICS_BAD_FLAG (conv2))\n+\t{\n+\t  arg2 = convert_like (conv2, arg2);\n+\t  arg2_type = TREE_TYPE (arg2);\n+\t}\n+      else if (conv3 && !ICS_BAD_FLAG (conv3))\n+\t{\n+\t  arg3 = convert_like (conv3, arg3);\n+\t  arg3_type = TREE_TYPE (arg3);\n+\t}\n+    }\n+\n+  /* [expr.cond]\n+\n+     If the second and third operands are lvalues and have the same\n+     type, the result is of that type and is an lvalue.  */\n+  arg2_type = non_reference (arg2_type);\n+  arg3_type = non_reference (arg3_type);\n+  if (real_lvalue_p (arg2) && real_lvalue_p (arg3) && \n+      same_type_p (arg2_type, arg3_type))\n+    {\n+      result_type = arg2_type;\n+      goto valid_operands;\n+    }\n+\n+  /* [expr.cond]\n+\n+     Otherwise, the result is an rvalue.  If the second and third\n+     operand do not have the same type, and either has (possibly\n+     cv-qualified) class type, overload resolution is used to\n+     determine the conversions (if any) to be applied to the operands\n+     (_over.match.oper_, _over.built_).  */\n+  lvalue_p = 0;\n+  if (!same_type_p (arg2_type, arg3_type)\n+      && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n+    {\n+      tree args[3];\n+      tree conv;\n+\n+      /* Rearrange the arguments so that add_builtin_candidate only has\n+\t to know about two args.  In build_builtin_candidates, the\n+\t arguments are unscrambled.  */\n+      args[0] = arg2;\n+      args[1] = arg3;\n+      args[2] = arg1;\n+      candidates = add_builtin_candidates (candidates, \n+\t\t\t\t\t   COND_EXPR, \n+\t\t\t\t\t   NOP_EXPR,\n+\t\t\t\t\t   ansi_opname[COND_EXPR],\n+\t\t\t\t\t   args,\n+\t\t\t\t\t   LOOKUP_NORMAL);\n+\n+      /* [expr.cond]\n+\n+\t If the overload resolution fails, the program is\n+\t ill-formed.  */\n+      if (!any_viable (candidates))\n+\t{\n+\t  op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n+\t  print_z_candidates (candidates);\n+\t  return error_mark_node;\n+\t}\n+      candidates = splice_viable (candidates);\n+      cand = tourney (candidates);\n+      if (!cand)\n+\t{\n+\t  op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n+\t  print_z_candidates (candidates);\n+\t  return error_mark_node;\n+\t}\n+\n+      /* [expr.cond]\n+\n+\t Otherwise, the conversions thus determined are applied, and\n+\t the converted operands are used in place of the original\n+\t operands for the remainder of this section.  */\n+      conv = TREE_VEC_ELT (cand->convs, 0);\n+      arg1 = convert_like (conv, arg1);\n+      conv = TREE_VEC_ELT (cand->convs, 1);\n+      arg2 = convert_like (conv, arg2);\n+      conv = TREE_VEC_ELT (cand->convs, 2);\n+      arg3 = convert_like (conv, arg3);\n+    }\n+\n+  /* [expr.cond]\n+\n+     Lvalue-to-rvalue (_conv.lval_), array-to-pointer (_conv.array_),\n+     and function-to-pointer (_conv.func_) standard conversions are\n+     performed on the second and third operands.  */\n+  arg2 = decay_conversion (arg2);\n+  arg2_type = TREE_TYPE (arg2);\n+  arg3 = decay_conversion (arg3);\n+  arg3_type = TREE_TYPE (arg3);\n+\n+  /* [expr.cond]\n+     \n+     After those conversions, one of the following shall hold:\n+\n+     --The second and third operands have the same type; the result  is  of\n+       that type.  */\n+  if (same_type_p (arg2_type, arg3_type))\n+    result_type = arg2_type;\n+  /* [expr.cond]\n+\n+     --The second and third operands have arithmetic or enumeration\n+       type; the usual arithmetic conversions are performed to bring\n+       them to a common type, and the result is of that type.  */\n+  else if ((ARITHMETIC_TYPE_P (arg2_type) \n+\t    || TREE_CODE (arg2_type) == ENUMERAL_TYPE)\n+\t   && (ARITHMETIC_TYPE_P (arg3_type)\n+\t       || TREE_CODE (arg3_type) == ENUMERAL_TYPE))\n+    {\n+      /* In this case, there is always a common type.  */\n+      result_type = type_after_usual_arithmetic_conversions (arg2_type, \n+\t\t\t\t\t\t\t     arg3_type);\n+      arg2 = ncp_convert (result_type, arg2);\n+      arg3 = ncp_convert (result_type, arg3);\n+    }\n+  /* [expr.cond]\n+\n+     --The second and third operands have pointer type, or one has\n+       pointer type and the other is a null pointer constant; pointer\n+       conversions (_conv.ptr_) and qualification conversions\n+       (_conv.qual_) are performed to bring them to their composite\n+       pointer type (_expr.rel_).  The result is of the composite\n+       pointer type.\n+\n+     --The second and third operands have pointer to member type, or\n+       one has pointer to member type and the other is a null pointer\n+       constant; pointer to member conversions (_conv.mem_) and\n+       qualification conversions (_conv.qual_) are performed to bring\n+       them to a common type, whose cv-qualification shall match the\n+       cv-qualification of either the second or the third operand.\n+       The result is of the common type.   */\n+  else if ((null_ptr_cst_p (arg2) \n+\t    && (TYPE_PTR_P (arg3_type) || TYPE_PTRMEM_P (arg3_type)\n+\t\t|| TYPE_PTRMEMFUNC_P (arg3_type)))\n+\t   || (null_ptr_cst_p (arg3) \n+\t       && (TYPE_PTR_P (arg2_type) || TYPE_PTRMEM_P (arg2_type)\n+\t\t|| TYPE_PTRMEMFUNC_P (arg2_type)))\n+\t   || (TYPE_PTR_P (arg2_type) && TYPE_PTR_P (arg3_type))\n+\t   || (TYPE_PTRMEM_P (arg2_type) && TYPE_PTRMEM_P (arg3_type))\n+\t   || (TYPE_PTRMEMFUNC_P (arg2_type) \n+\t       && TYPE_PTRMEMFUNC_P (arg3_type)))\n+    {\n+      result_type = composite_pointer_type (arg2_type, arg3_type, arg2,\n+\t\t\t\t\t    arg3, \"conditional expression\");\n+      arg2 = ncp_convert (result_type, arg2);\n+      arg3 = ncp_convert (result_type, arg3);\n+    }\n+\n+  if (!result_type)\n+    {\n+      cp_error (\"operands to ?: have different types\");\n+      return error_mark_node;\n+    }\n+\n+ valid_operands:\n+  result = fold (build (COND_EXPR, result_type, arg1, arg2, arg3));\n+  /* Expand both sides into the same slot, hopefully the target of the\n+     ?: expression.  */\n+  if (TREE_CODE (arg2) == TARGET_EXPR && TREE_CODE (arg3) == TARGET_EXPR)\n+    {\n+      tree slot = build (VAR_DECL, result_type);\n+      layout_decl (slot, 0);\n+      result = build (TARGET_EXPR, result_type,\n+\t\t      slot, result, NULL_TREE, NULL_TREE);\n+    }\n+  \n+  /* If this expression is an rvalue, but might be mistaken for an\n+     lvalue, we must add a NON_LVALUE_EXPR.  */\n+  if (!lvalue_p && real_lvalue_p (result))\n+    result = build1 (NON_LVALUE_EXPR, result_type, result);\n+\n+  return result;\n+}\n+\n tree\n build_new_op (code, flags, arg1, arg2, arg3)\n      enum tree_code code;\n@@ -4660,8 +5064,7 @@ int\n can_convert (to, from)\n      tree to, from;\n {\n-  tree t = implicit_conversion (to, from, NULL_TREE, LOOKUP_NORMAL);\n-  return (t && ! ICS_BAD_FLAG (t));\n+  return can_convert_arg (to, from, NULL_TREE);\n }\n \n int\n@@ -4672,6 +5075,22 @@ can_convert_arg (to, from, arg)\n   return (t && ! ICS_BAD_FLAG (t));\n }\n \n+tree\n+ncp_convert (type, expr)\n+     tree type;\n+     tree expr;\n+{\n+  tree conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n+\t\t\t\t   LOOKUP_NORMAL);\n+  if (!conv || ICS_BAD_FLAG (conv))\n+    {\n+      cp_error (\"could not convert `%E' to `%T'\", expr, type);\n+      return error_mark_node;\n+    }\n+\n+  return convert_like (conv, expr);\n+}\n+\n /* Convert EXPR to the indicated reference TYPE, in a way suitable for\n    initializing a variable of that TYPE.  Return the converted\n    expression.  */"}, {"sha": "a4cc5a507ace92c7035dd631819ea9bfc125b6d4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -3619,8 +3619,7 @@ finish_struct_1 (t)\n \t    {\n \t      /* Never let anything with uninheritable virtuals\n \t\t make it through without complaint.  */\n-\t      if (CLASSTYPE_ABSTRACT_VIRTUALS (type))\n-\t\tabstract_virtuals_error (x, type);\n+\t      abstract_virtuals_error (x, type);\n \t\t      \n \t      /* Don't let signatures make it through either.  */\n \t      if (IS_SIGNATURE (type))"}, {"sha": "4e13392a98ac861e603bd78a9d49255b86f5d1eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -1660,7 +1660,24 @@ extern int flag_new_for_scope;\n \n #define INTEGRAL_CODE_P(CODE) \\\n   (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)\n-#define ARITHMETIC_TYPE_P(TYPE) (INTEGRAL_TYPE_P (TYPE) || FLOAT_TYPE_P (TYPE))\n+\n+/* [basic.fundamental]\n+\n+   Types  bool, char, wchar_t, and the signed and unsigned integer types\n+   are collectively called integral types.  \n+\n+   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n+   types as well, which is incorrect in C++.  */\n+#define CP_INTEGRAL_TYPE_P(TYPE) \t\t\\\n+  (TREE_CODE ((TYPE)) == BOOLEAN_TYPE \t\t\\\n+   || TREE_CODE ((TYPE)) == INTEGER_TYPE)\n+\n+/* [basic.fundamental]\n+\n+   Integral and floating types are collectively called arithmetic\n+   types.  */\n+#define ARITHMETIC_TYPE_P(TYPE) \\\n+  (CP_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE)\n \n /* Mark which labels are explicitly declared.\n    These may be shadowed, and may be referenced from nested functions.  */\n@@ -2767,6 +2784,8 @@ extern tree convert_default_arg                 PROTO((tree, tree, tree));\n extern tree convert_arg_to_ellipsis             PROTO((tree));\n extern int is_properly_derived_from             PROTO((tree, tree));\n extern tree initialize_reference                PROTO((tree, tree));\n+extern tree strip_top_quals                     PROTO((tree));\n+extern tree ncp_convert                         PROTO((tree, tree));\n \n /* in class.c */\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n@@ -3534,12 +3553,14 @@ extern tree build_ptrmemfunc1                   PROTO((tree, tree, tree, tree, t\n extern void expand_ptrmemfunc_cst               PROTO((tree, tree *, tree *, tree *, tree *));\n extern tree delta2_from_ptrmemfunc              PROTO((tree));\n extern tree pfn_from_ptrmemfunc                 PROTO((tree));\n+extern tree type_after_usual_arithmetic_conversions PROTO((tree, tree));\n+extern tree composite_pointer_type              PROTO((tree, tree, tree, tree, char*));\n \n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n extern void readonly_error\t\t\tPROTO((tree, const char *, int));\n-extern void abstract_virtuals_error\t\tPROTO((tree, tree));\n+extern int abstract_virtuals_error\t\tPROTO((tree, tree));\n extern void signature_error\t\t\tPROTO((tree, tree));\n extern void incomplete_type_error\t\tPROTO((tree, tree));\n extern void my_friendly_abort\t\t\tPROTO((int))"}, {"sha": "e5c106426f1ead6d398b35b674d1c741dcccc2aa", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -826,11 +826,8 @@ ocp_convert (type, expr, convtype, flags)\n \n       ctor = e;\n \n-      if (IS_AGGR_TYPE (type) && CLASSTYPE_ABSTRACT_VIRTUALS (type))\n-\t{\n-\t  abstract_virtuals_error (NULL_TREE, type);\n-\t  return error_mark_node;\n-\t}\n+      if (abstract_virtuals_error (NULL_TREE, type))\n+\treturn error_mark_node;\n \n       if ((flags & LOOKUP_ONLYCONVERTING)\n \t  && ! (IS_AGGR_TYPE (dtype) && DERIVED_FROM_P (type, dtype)))"}, {"sha": "1dc070b108dfac5477e9d6ef67b5a2771772bcc0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -7857,14 +7857,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       if (was_temp)\n \tresume_temporary_allocation ();\n \n-      if (type != error_mark_node\n-\t  && TYPE_LANG_SPECIFIC (core_type)\n-\t  && CLASSTYPE_ABSTRACT_VIRTUALS (core_type))\n-\tabstract_virtuals_error (decl, core_type);\n-      else if ((TREE_CODE (type) == FUNCTION_TYPE\n-\t\t|| TREE_CODE (type) == METHOD_TYPE)\n-\t       && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n-\t       && CLASSTYPE_ABSTRACT_VIRTUALS (TREE_TYPE (type)))\n+      if (!abstract_virtuals_error (decl, core_type)\n+\t  && (TREE_CODE (type) == FUNCTION_TYPE\n+\t      || TREE_CODE (type) == METHOD_TYPE))\n \tabstract_virtuals_error (decl, TREE_TYPE (type));\n \n       if (TYPE_LANG_SPECIFIC (core_type) && IS_SIGNATURE (core_type))\n@@ -11614,13 +11609,8 @@ grokparms (first_parm, funcdef_flag)\n \t\t      type = build_pointer_type (type);\n \t\t      TREE_TYPE (decl) = type;\n \t\t    }\n-                  else if (TREE_CODE (type) == RECORD_TYPE\n-                           && TYPE_LANG_SPECIFIC (type)\n-                           && CLASSTYPE_ABSTRACT_VIRTUALS (type))\n-                    {\n-                      abstract_virtuals_error (decl, type);\n-                      any_error = 1;  /* Seems like a good idea. */\n-                    }\n+                  else if (abstract_virtuals_error (decl, type))\n+\t\t    any_error = 1;  /* Seems like a good idea. */\n                   else if (TREE_CODE (type) == RECORD_TYPE\n                            && TYPE_LANG_SPECIFIC (type)\n                            && IS_SIGNATURE (type))\n@@ -12033,9 +12023,7 @@ grok_op_properties (decl, virtualp, friendp)\n       else if (name == ansi_opname[(int) COND_EXPR])\n \t{\n \t  /* 13.4.0.3 */\n-\t  pedwarn (\"ANSI C++ prohibits overloading operator ?:\");\n-\t  if (list_length (argtypes) != 4)\n-\t    cp_error (\"`%D' must take exactly three arguments\", decl);\n+\t  cp_error (\"ANSI C++ prohibits overloading operator ?:\");\n \t}\t  \n       else if (ambi_op_p (name))\n \t{\n@@ -13113,9 +13101,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t    = CP_TYPE_VOLATILE_P (TREE_TYPE (fntype));\n \t}\n \n-      if (TYPE_LANG_SPECIFIC (TREE_TYPE (fntype))\n-\t  && CLASSTYPE_ABSTRACT_VIRTUALS (TREE_TYPE (fntype)))\n-\tabstract_virtuals_error (decl1, TREE_TYPE (fntype));\n+      abstract_virtuals_error (decl1, TREE_TYPE (fntype));\n     }\n \n   /* Effective C++ rule 15.  See also c_expand_return.  */"}, {"sha": "b3b9dcb0bc97f18af690083bf59b9ec992f58762", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -2206,12 +2206,8 @@ build_new_1 (exp)\n       return error_mark_node;\n     }\n \n-  if (TYPE_LANG_SPECIFIC (true_type)\n-      && CLASSTYPE_ABSTRACT_VIRTUALS (true_type))\n-    {\n-      abstract_virtuals_error (NULL_TREE, true_type);\n-      return error_mark_node;\n-    }\n+  if (abstract_virtuals_error (NULL_TREE, true_type))\n+    return error_mark_node;\n \n   if (TYPE_LANG_SPECIFIC (true_type) && IS_SIGNATURE (true_type))\n     {"}, {"sha": "ef84f74714ae1dfbf07344de250525d23c382c45", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -8338,10 +8338,6 @@ unify (tparms, targs, parm, arg, strict)\n       {\n \tint sub_strict;\n \n-\tif (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n-\t  return (unify (tparms, targs, parm, \n-\t\t\t TYPE_PTRMEMFUNC_FN_TYPE (arg), strict));\n-\t\n \tif (TREE_CODE (arg) != POINTER_TYPE)\n \t  return 1;\n \t\n@@ -8361,14 +8357,13 @@ unify (tparms, targs, parm, arg, strict)\n \t   this is probably OK.  */\n \tsub_strict = strict;\n \t\n-\tif (TREE_CODE (TREE_TYPE (arg)) != RECORD_TYPE\n-\t    || TYPE_PTRMEMFUNC_FLAG (TREE_TYPE (arg)))\n+\tif (TREE_CODE (TREE_TYPE (arg)) != RECORD_TYPE)\n \t  /* The derived-to-base conversion only persists through one\n \t     level of pointers.  */\n \t  sub_strict &= ~UNIFY_ALLOW_DERIVED;\n \n-\treturn unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE\n-\t\t      (arg), sub_strict);\n+\treturn unify (tparms, targs, TREE_TYPE (parm), \n+\t\t      TREE_TYPE (arg), sub_strict);\n       }\n \n     case REFERENCE_TYPE:\n@@ -8448,13 +8443,20 @@ unify (tparms, targs, parm, arg, strict)\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      if (TYPE_PTRMEMFUNC_FLAG (parm))\n-\treturn unify (tparms, targs, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n-\t\t      arg, strict);\n-\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n   \n+      if (TYPE_PTRMEMFUNC_P (parm))\n+\t{\n+\t  if (!TYPE_PTRMEMFUNC_P (arg))\n+\t    return 1;\n+\n+\t  return unify (tparms, targs, \n+\t\t\tTYPE_PTRMEMFUNC_FN_TYPE (parm),\n+\t\t\tTYPE_PTRMEMFUNC_FN_TYPE (arg),\n+\t\t\tstrict);\n+\t}\n+\n       if (CLASSTYPE_TEMPLATE_INFO (parm))\n \t{\n \t  tree t = NULL_TREE;"}, {"sha": "b7f3e18453ba2182e7673a155aa3858c871059d0", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -3130,6 +3130,10 @@ add_conversions (binfo, data)\n   tree method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n   tree *conversions = (tree *) data;\n \n+  /* Some builtin types have no method vector, not even an empty one.  */\n+  if (!method_vec)\n+    return NULL_TREE;\n+\n   for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n     {\n       tree tmp = TREE_VEC_ELT (method_vec, i);"}, {"sha": "c4bb18f801f103fb2a01a5b094954f0a9964c073", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 268, "deletions": 785, "changes": 1053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -403,6 +403,191 @@ original_type (t)\n   return t;\n }\n \n+/* T1 and T2 are arithmetic or enumeration types.  Return the type\n+   that will result from the \"usual arithmetic converions\" on T1 and\n+   T2 as described in [expr].  */\n+\n+tree\n+type_after_usual_arithmetic_conversions (t1, t2)\n+     tree t1;\n+     tree t2;\n+{\n+  enum tree_code code1 = TREE_CODE (t1);\n+  enum tree_code code2 = TREE_CODE (t2);\n+  tree attributes;\n+\n+  /* FIXME: Attributes.  */\n+  my_friendly_assert (ARITHMETIC_TYPE_P (t1) \n+\t\t      || TREE_CODE (t1) == ENUMERAL_TYPE,\n+\t\t      19990725);\n+  my_friendly_assert (ARITHMETIC_TYPE_P (t2) \n+\t\t      || TREE_CODE (t2) == ENUMERAL_TYPE,\n+\t\t      19990725);\n+\n+  /* In what follows, we slightly generalize the rules given in [expr]\n+     so as to deal with `long long'.  First, merge the attributes.  */\n+  attributes = merge_machine_type_attributes (t1, t2);\n+\n+  /* If only one is real, use it as the result.  */\n+  if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n+    return build_type_attribute_variant (t1, attributes);\n+  if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n+    return build_type_attribute_variant (t2, attributes);\n+\n+  /* Perform the integral promotions.  */\n+  if (code1 != REAL_TYPE)\n+    {\n+      t1 = type_promotes_to (t1);\n+      t2 = type_promotes_to (t2);\n+    }\n+\n+  /* Both real or both integers; use the one with greater precision.  */\n+  if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n+    return build_type_attribute_variant (t1, attributes);\n+  else if (TYPE_PRECISION (t2) > TYPE_PRECISION (t1))\n+    return build_type_attribute_variant (t2, attributes);\n+\n+  if (code1 != REAL_TYPE)\n+    {\n+      /* If one is unsigned long long, then convert the other to unsigned\n+\t long long.  */\n+      if (same_type_p (TYPE_MAIN_VARIANT (t1), long_long_unsigned_type_node)\n+\t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_long_unsigned_type_node))\n+\treturn build_type_attribute_variant (long_long_unsigned_type_node,\n+\t\t\t\t\t     attributes);\n+      /* If one is a long long, and the other is an unsigned long, and\n+\t long long can represent all the values of an unsigned long, then\n+\t convert to a long long.  Otherwise, convert to an unsigned long\n+\t long.  Otherwise, if either operand is long long, convert the\n+\t other to long long.\n+\t \n+\t Since we're here, we know the TYPE_PRECISION is the same;\n+\t therefore converting to long long cannot represent all the values\n+\t of an unsigned long, so we choose unsigned long long in that\n+\t case.  */\n+      if (same_type_p (TYPE_MAIN_VARIANT (t1), long_long_integer_type_node)\n+\t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_long_integer_type_node))\n+\t{\n+\t  tree t = ((TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n+\t\t    ? long_long_unsigned_type_node \n+\t\t    : long_long_integer_type_node);\n+\t  return build_type_attribute_variant (t, attributes);\n+\t}\n+      \n+      /* Go through the same procedure, but for longs.  */\n+      if (same_type_p (TYPE_MAIN_VARIANT (t1), long_unsigned_type_node)\n+\t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_unsigned_type_node))\n+\treturn build_type_attribute_variant (long_unsigned_type_node,\n+\t\t\t\t\t     attributes);\n+      if (same_type_p (TYPE_MAIN_VARIANT (t1), long_integer_type_node)\n+\t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_integer_type_node))\n+\t{\n+\t  tree t = ((TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n+\t\t    ? long_unsigned_type_node : long_integer_type_node);\n+\t  return build_type_attribute_variant (t, attributes);\n+\t}\n+      /* Otherwise prefer the unsigned one.  */\n+      if (TREE_UNSIGNED (t1))\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else\n+\treturn build_type_attribute_variant (t2, attributes);\n+    }\n+  else\n+    {\n+      if (same_type_p (TYPE_MAIN_VARIANT (t1), long_double_type_node)\n+\t  || same_type_p (TYPE_MAIN_VARIANT (t2), long_double_type_node))\n+\treturn build_type_attribute_variant (long_double_type_node,\n+\t\t\t\t\t     attributes);\n+      if (same_type_p (TYPE_MAIN_VARIANT (t1), double_type_node)\n+\t  || same_type_p (TYPE_MAIN_VARIANT (t2), double_type_node))\n+\treturn build_type_attribute_variant (double_type_node,\n+\t\t\t\t\t     attributes);\n+      else \n+\treturn build_type_attribute_variant (float_type_node,\n+\t\t\t\t\t     attributes);\n+    }\n+}\n+\n+/* Return the composite pointer type (see [expr.rel]) for T1 and T2.\n+   ARG1 and ARG2 are the values with those types.  The LOCATION is a\n+   string describing the current location, in case an error occurs.  */\n+\n+tree \n+composite_pointer_type (t1, t2, arg1, arg2, location)\n+     tree t1;\n+     tree t2;\n+     tree arg1;\n+     tree arg2;\n+     char* location;\n+{\n+  tree result_type;\n+\n+  /* [expr.rel]\n+\n+     If one operand is a null pointer constant, the composite pointer\n+     type is the type of the other operand.  */\n+  if (null_ptr_cst_p (arg1))\n+    return t2;\n+  if (null_ptr_cst_p (arg2))\n+    return t1;\n+ \n+  /* Deal with pointer-to-member functions in the same way as we deal\n+     with pointers to functions. */\n+  if (TYPE_PTRMEMFUNC_P (t1))\n+    t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n+  if (TYPE_PTRMEMFUNC_P (t2))\n+    t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n+  \n+  if (comp_target_types (t1, t2, 1))\n+    result_type = common_type (t1, t2);\n+  else if (TYPE_MAIN_VARIANT (TREE_TYPE (t1)) == void_type_node)\n+    {\n+      if (pedantic && TREE_CODE (t2) == FUNCTION_TYPE)\n+\tpedwarn (\"ANSI C++ forbids %s between `void *' and function pointer\",\n+\t\t location);\n+      result_type = qualify_type (t1, t2);\n+    }\n+  else if (TYPE_MAIN_VARIANT (TREE_TYPE (t2)) == void_type_node)\n+    {\n+      if (pedantic && TREE_CODE (t1) == FUNCTION_TYPE)\n+\tpedwarn (\"ANSI C++ forbids %s between `void *' and function pointer\",\n+\t\t location);\n+      result_type = qualify_type (t2, t1);\n+    }\n+  /* C++ */\n+  else if (same_or_base_type_p (t2, t1))\n+    result_type = t2;\n+  else if (IS_AGGR_TYPE (TREE_TYPE (t1))\n+\t   && IS_AGGR_TYPE (TREE_TYPE (t2))\n+\t   && (result_type = common_base_type (TREE_TYPE (t1),\n+\t\t\t\t\t       TREE_TYPE (t2))))\n+    {\n+      if (result_type == error_mark_node)\n+\t{\n+\t  cp_error (\"common base type of types `%T' and `%T' is ambiguous\",\n+\t\t    TREE_TYPE (t1), TREE_TYPE (t2));\n+\t  result_type = ptr_type_node;\n+\t}\n+      else\n+\t{\n+\t  if (pedantic\n+\t      && result_type != TREE_TYPE (t1)\n+\t      && result_type != TREE_TYPE (t2))\n+\t    cp_pedwarn (\"`%T' and `%T' converted to `%T *' in %s\",\n+\t\t\tt1, t2, result_type, location);\n+\t  \n+\t  result_type = build_pointer_type (result_type);\n+\t}\n+    }\n+  else\n+    {\n+      cp_pedwarn (\"pointer type mismatch in %s\", location);\n+      result_type = ptr_type_node;\n+    }\n+\n+  return result_type;\n+}\n+\n /* Return the common type of two types.\n    We assume that comptypes has already been done and returned 1;\n    if that isn't so, this may crash.\n@@ -435,44 +620,13 @@ common_type (t1, t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n+  if ((ARITHMETIC_TYPE_P (t1) || TREE_CODE (t1) == ENUMERAL_TYPE)\n+      && (ARITHMETIC_TYPE_P (t2) || TREE_CODE (t2) == ENUMERAL_TYPE))\n+    return type_after_usual_arithmetic_conversions (t1, t2);\n+\n   /* Merge the attributes.  */\n   attributes = merge_machine_type_attributes (t1, t2);\n \n-  { register tree a1, a2;\n-    a1 = TYPE_ATTRIBUTES (t1);\n-    a2 = TYPE_ATTRIBUTES (t2);\n-\n-    /* Either one unset?  Take the set one.  */\n-\n-    if (!(attributes = a1))\n-       attributes = a2;\n-\n-    /* One that completely contains the other?  Take it.  */\n-\n-    else if (a2 && !attribute_list_contained (a1, a2))\n-      {\n-\tif (attribute_list_contained (a2, a1))\n-\t  attributes = a2;\n-\telse\n-\t  {\n-\t    /* Pick the longest list, and hang on the other list.  */\n-\t    /* ??? For the moment we punt on the issue of attrs with args.  */\n-\t\n-\t    if (list_length (a1) < list_length (a2))\n-\t      attributes = a2, a2 = a1;\n-\n-\t    for (; a2; a2 = TREE_CHAIN (a2))\n-\t      if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\t    attributes) == NULL_TREE)\n-\t\t{\n-\t\t  a1 = copy_node (a2);\n-\t\t  TREE_CHAIN (a1) = attributes;\n-\t\t  attributes = a1;\n-\t\t}\n-\t  }\n-      }\n-  }\n-\n   /* Treat an enum type as the unsigned integer type of the same width.  */\n \n   if (TREE_CODE (t1) == ENUMERAL_TYPE)\n@@ -510,51 +664,10 @@ common_type (t1, t2)\n     {\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n-      /* If only one is real, use it as the result.  */\n-\n-      if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n-\treturn build_type_attribute_variant (t1, attributes);\n-\n-      if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n-        return build_type_attribute_variant (t2, attributes);\n-\n-      /* Both real or both integers; use the one with greater precision.  */\n-\n-      if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else if (TYPE_PRECISION (t2) > TYPE_PRECISION (t1))\n-        return build_type_attribute_variant (t2, attributes);\n-\n-      /* Same precision.  Prefer longs to ints even when same size.  */\n-  \n-      if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_unsigned_type_node)\n-        return build_type_attribute_variant (long_unsigned_type_node,\n-\t\t\t\t\t     attributes);\n-\n-      if (TYPE_MAIN_VARIANT (t1) == long_integer_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_integer_type_node)\n-\t{\n-\t  /* But preserve unsignedness from the other type,\n-\t     since long cannot hold all the values of an unsigned int.  */\n-\t  if (TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n-\t     t1 = long_unsigned_type_node;\n-\t  else\n-\t     t1 = long_integer_type_node;\n-\t  return build_type_attribute_variant (t1, attributes);\n-\t}\n-\n-      if (TYPE_MAIN_VARIANT (t1) == long_double_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_double_type_node)\n-\treturn build_type_attribute_variant (long_double_type_node,\n-\t\t\t\t\t     attributes);\t  \n-\n-      /* Otherwise prefer the unsigned one.  */\n-\n-      if (TREE_UNSIGNED (t1))\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else\n-\treturn build_type_attribute_variant (t2, attributes);\n+      /* We should have called type_after_usual_arithmetic_conversions\n+\t above.  */\n+      my_friendly_abort (19990725);\n+      break;\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -797,17 +910,16 @@ comp_array_types (cmp, t1, t2, strict)\n \t\t\t    TYPE_MAX_VALUE (d2)));\n }\n \n-/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n-   or various other operations.  STRICT is a bitwise-or of the\n-   COMPARE_* flags.  */\n+/* Return 1 if T1 and T2 are compatible types for assignment or\n+   various other operations.  STRICT is a bitwise-or of the COMPARE_*\n+   flags.  */\n \n int\n-comptypes (type1, type2, strict)\n-     tree type1, type2;\n+comptypes (t1, t2, strict)\n+     tree t1;\n+     tree t2;\n      int strict;\n {\n-  register tree t1 = type1;\n-  register tree t2 = type2;\n   int attrval, val;\n   int orig_strict = strict;\n \n@@ -969,6 +1081,9 @@ comptypes (type1, type2, strict)\n \treturn 0;\n       return same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n \n+    case COMPLEX_TYPE:\n+      return same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+\n     default:\n       break;\n     }\n@@ -3536,11 +3651,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  if (result_type == NULL_TREE)\n \t    result_type = ptr_type_node;\n \t}\n-      else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n-\t       && integer_zerop (op1))\n+      else if (code0 == POINTER_TYPE && null_ptr_cst_p (op1))\n \tresult_type = type0;\n-      else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n-\t       && integer_zerop (op0))\n+      else if (code1 == POINTER_TYPE && null_ptr_cst_p (op0))\n \tresult_type = type1;\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -3552,15 +3665,13 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  result_type = type1;\n \t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n-      else if (TYPE_PTRMEMFUNC_P (type0) && TREE_CODE (op1) == INTEGER_CST\n-\t       && integer_zerop (op1))\n+      else if (TYPE_PTRMEMFUNC_P (type0) && null_ptr_cst_p (op1))\n \t{\n \t  op0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n \t  op1 = integer_zero_node;\n \t  result_type = TREE_TYPE (op0);\n \t}\n-      else if (TYPE_PTRMEMFUNC_P (type1) && TREE_CODE (op0) == INTEGER_CST\n-\t       && integer_zerop (op0))\n+      else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (op0))\n \t{\n \t  op0 = build_component_ref (op1, index_identifier, NULL_TREE, 0);\n \t  op1 = integer_zero_node;\n@@ -4967,326 +5078,7 @@ build_x_conditional_expr (ifexp, op1, op2)\n   if (processing_template_decl)\n     return build_min_nt (COND_EXPR, ifexp, op1, op2);\n \n-  return build_new_op (COND_EXPR, LOOKUP_NORMAL, ifexp, op1, op2);\n-}\n-\n-tree\n-build_conditional_expr (ifexp, op1, op2)\n-     tree ifexp, op1, op2;\n-{\n-  register tree type1;\n-  register tree type2;\n-  register enum tree_code code1;\n-  register enum tree_code code2;\n-  register tree result_type = NULL_TREE;\n-\n-  /* If second operand is omitted, it is the same as the first one;\n-     make sure it is calculated only once.  */\n-  if (op1 == 0)\n-    {\n-      if (pedantic)\n-\tpedwarn (\"ANSI C++ forbids omitting the middle term of a ?: expression\");\n-      ifexp = op1 = save_expr (ifexp);\n-    }\n-\n-  type1 = TREE_TYPE (op1);\n-  code1 = TREE_CODE (type1);\n-  type2 = TREE_TYPE (op2);\n-  code2 = TREE_CODE (type2);\n-  if (op1 == error_mark_node || op2 == error_mark_node\n-      || type1 == error_mark_node || type2 == error_mark_node)\n-    return error_mark_node;\n-\n-  ifexp = cp_convert (boolean_type_node, ifexp);\n-\n-  if (TREE_CODE (ifexp) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  /* C++: REFERENCE_TYPES must be dereferenced.  */\n-  if (code1 == REFERENCE_TYPE)\n-    {\n-      op1 = convert_from_reference (op1);\n-      type1 = TREE_TYPE (op1);\n-      code1 = TREE_CODE (type1);\n-    }\n-  if (code2 == REFERENCE_TYPE)\n-    {\n-      op2 = convert_from_reference (op2);\n-      type2 = TREE_TYPE (op2);\n-      code2 = TREE_CODE (type2);\n-    }\n-\n-  /* Don't promote the operands separately if they promote\n-     the same way.  Return the unpromoted type and let the combined\n-     value get promoted if necessary.  */\n-\n-  if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2)\n-      && code2 != ARRAY_TYPE\n-      && code2 != FUNCTION_TYPE\n-      && code2 != METHOD_TYPE)\n-    {\n-      tree result;\n-\n-      if (TREE_CONSTANT (ifexp)\n-\t  && (TREE_CODE (ifexp) == INTEGER_CST\n-\t      || TREE_CODE (ifexp) == ADDR_EXPR))\n-\treturn (integer_zerop (ifexp) ? op2 : op1);\n-\n-      if (TREE_CODE (op1) == CONST_DECL)\n-\top1 = DECL_INITIAL (op1);\n-      else if (TREE_READONLY_DECL_P (op1))\n-\top1 = decl_constant_value (op1);\n-      if (TREE_CODE (op2) == CONST_DECL)\n-\top2 = DECL_INITIAL (op2);\n-      else if (TREE_READONLY_DECL_P (op2))\n-\top2 = decl_constant_value (op2);\n-      if (type1 != type2)\n-\ttype1 = cp_build_qualified_type\n-\t  (type1, (CP_TYPE_QUALS (TREE_TYPE (op1)) \n-\t\t   | CP_TYPE_QUALS (TREE_TYPE (op2))));\n-      /* ??? This is a kludge to deal with the fact that\n-\t we don't sort out integers and enums properly, yet.  */\n-      result = fold (build (COND_EXPR, type1, ifexp, op1, op2));\n-      if (TREE_TYPE (result) != type1)\n-\tresult = build1 (NOP_EXPR, type1, result);\n-      /* Expand both sides into the same slot,\n-\t hopefully the target of the ?: expression.  */\n-      if (TREE_CODE (op1) == TARGET_EXPR && TREE_CODE (op2) == TARGET_EXPR)\n-\t{\n-\t  tree slot = build (VAR_DECL, TREE_TYPE (result));\n-\t  layout_decl (slot, 0);\n-\t  result = build (TARGET_EXPR, TREE_TYPE (result),\n-\t\t\t  slot, result, NULL_TREE, NULL_TREE);\n-\t}\n-      return result;\n-    }\n-\n-  /* They don't match; promote them both and then try to reconcile them.\n-     But don't permit mismatching enum types.  */\n-  if (code1 == ENUMERAL_TYPE)\n-    {\n-      if (code2 == ENUMERAL_TYPE)\n-\t{\n-\t  cp_error (\"enumeral mismatch in conditional expression: `%T' vs `%T'\",\n-\t\t    type1, type2);\n-\t  return error_mark_node;\n-\t}\n-      else if (extra_warnings && ! IS_AGGR_TYPE_CODE (code2)\n-\t       && type2 != type_promotes_to (type1))\n-\twarning (\"enumeral and non-enumeral type in conditional expression\");\n-    }\n-  else if (extra_warnings\n-\t   && code2 == ENUMERAL_TYPE && ! IS_AGGR_TYPE_CODE (code1)\n-\t   && type1 != type_promotes_to (type2))\n-    warning (\"enumeral and non-enumeral type in conditional expression\");\n-\n-  if (code1 != VOID_TYPE)\n-    {\n-      op1 = default_conversion (op1);\n-      type1 = TREE_TYPE (op1);\n-      if (TYPE_PTRMEMFUNC_P (type1))\n-\ttype1 = TYPE_PTRMEMFUNC_FN_TYPE (type1);\n-      code1 = TREE_CODE (type1);\n-    }\n-  if (code2 != VOID_TYPE)\n-    {\n-      op2 = default_conversion (op2);\n-      type2 = TREE_TYPE (op2);\n-      if (TYPE_PTRMEMFUNC_P (type2))\n-\ttype2 = TYPE_PTRMEMFUNC_FN_TYPE (type2);\n-      code2 = TREE_CODE (type2);\n-    }\n-\n-  if (code1 == RECORD_TYPE && code2 == RECORD_TYPE\n-      && real_lvalue_p (op1) && real_lvalue_p (op2)\n-      && comptypes (type1, type2, COMPARE_BASE | COMPARE_RELAXED))\n-    {\n-      type1 = build_reference_type (type1);\n-      type2 = build_reference_type (type2);\n-      result_type = common_type (type1, type2);\n-      op1 = convert_to_reference (result_type, op1, CONV_IMPLICIT,\n-\t\t\t\t  LOOKUP_NORMAL, NULL_TREE);\n-      op2 = convert_to_reference (result_type, op2, CONV_IMPLICIT,\n-\t\t\t\t  LOOKUP_NORMAL, NULL_TREE);\n-    }\n-  /* Quickly detect the usual case where op1 and op2 have the same type\n-     after promotion.  */\n-  else if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2))\n-    {\n-      if (type1 == type2)\n-\tresult_type = type1;\n-      else\n-\tresult_type = \n-\t  cp_build_qualified_type (type1,\n-\t\t\t\t   CP_TYPE_QUALS (TREE_TYPE (op1))\n-\t\t\t\t   | CP_TYPE_QUALS (TREE_TYPE (op2)));\n-    }\n-  else if ((code1 == INTEGER_TYPE || code1 == REAL_TYPE)\n-           && (code2 == INTEGER_TYPE || code2 == REAL_TYPE))\n-    {\n-      result_type = common_type (type1, type2);\n-    }\n-  else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n-    {\n-      if (pedantic && (code1 != VOID_TYPE || code2 != VOID_TYPE))\n-\tpedwarn (\"ANSI C++ forbids conditional expr with only one void side\");\n-      result_type = void_type_node;\n-    }\n-  else if (code1 == POINTER_TYPE && null_ptr_cst_p (op2))\n-    result_type = qualify_type (type1, type2);\n-  else if (code2 == POINTER_TYPE && null_ptr_cst_p (op1))\n-    result_type = qualify_type (type2, type1);\n-  else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n-    {\n-      if (comp_target_types (type1, type2, 1))\n-\tresult_type = common_type (type1, type2);\n-      else if (TYPE_MAIN_VARIANT (TREE_TYPE (type1)) == void_type_node)\n-\t{\n-\t  if (pedantic && TREE_CODE (type2) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids conditional expr between `void *' and function pointer\");\n-\t  result_type = qualify_type (type1, type2);\n-\t}\n-      else if (TYPE_MAIN_VARIANT (TREE_TYPE (type2)) == void_type_node)\n-\t{\n-\t  if (pedantic && TREE_CODE (type1) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids conditional expr between `void *' and function pointer\");\n-\t  result_type = qualify_type (type2, type1);\n-\t}\n-      /* C++ */\n-      else if (same_or_base_type_p (type2, type1))\n-\tresult_type = type2;\n-      else if (IS_AGGR_TYPE (TREE_TYPE (type1))\n-\t       && IS_AGGR_TYPE (TREE_TYPE (type2))\n-\t       && (result_type = common_base_type (TREE_TYPE (type1),\n-\t\t\t\t\t\t   TREE_TYPE (type2))))\n-\t{\n-\t  if (result_type == error_mark_node)\n-\t    {\n-\t      cp_error (\"common base type of types `%T' and `%T' is ambiguous\",\n-\t\t\tTREE_TYPE (type1), TREE_TYPE (type2));\n-\t      result_type = ptr_type_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (pedantic\n-\t\t  && result_type != TREE_TYPE (type1)\n-\t\t  && result_type != TREE_TYPE (type2))\n-\t\tcp_pedwarn (\"`%T' and `%T' converted to `%T *' in conditional expression\",\n-\t\t\t    type1, type2, result_type);\n-\n-\t      result_type = build_pointer_type (result_type);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  pedwarn (\"pointer type mismatch in conditional expression\");\n-\t  result_type = ptr_type_node;\n-\t}\n-    }\n-  else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n-    {\n-      pedwarn (\"pointer/integer type mismatch in conditional expression\");\n-      result_type = type1;\n-    }\n-  else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n-    {\n-      pedwarn (\"pointer/integer type mismatch in conditional expression\");\n-      result_type = type2;\n-    }\n-  if (type2 == unknown_type_node)\n-    result_type = type1;\n-  else if (type1 == unknown_type_node)\n-    result_type = type2;\n-\n-  if (!result_type)\n-    {\n-      /* The match does not look good.  If either is\n-\t an aggregate value, try converting to a scalar type.  */\n-      if (code1 == RECORD_TYPE && code2 == RECORD_TYPE)\n-\t{\n-\t  cp_error (\"aggregate mismatch in conditional expression: `%T' vs `%T'\",\n-\t\t    type1, type2);\n-\t  return error_mark_node;\n-\t}\n-      /* Warning: this code assumes that conversion between cv-variants of\n-         a type is done using NOP_EXPRs.  */\n-      if (code1 == RECORD_TYPE && TYPE_HAS_CONVERSION (type1))\n-\t{\n-\t  /* There are other types besides pointers and records.  */\n-\t  tree tmp;\n-\t  if (code2 == POINTER_TYPE)\n-\t      tmp = build_pointer_type\n-\t\t(cp_build_qualified_type (TREE_TYPE (type2), \n-\t\t\t\t\t  TYPE_QUAL_CONST \n-\t\t\t\t\t  | TYPE_QUAL_VOLATILE\n-\t\t\t\t\t  | TYPE_QUAL_RESTRICT));\n-\t  else\n-\t    tmp = type2;\n-\t  tmp = build_type_conversion (tmp, op1, 0);\n-\t  if (tmp == NULL_TREE)\n-\t    {\n-\t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n-\t\t\ttype1, type2);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (tmp == error_mark_node)\n-\t    error (\"ambiguous pointer conversion\");\n-\t  else\n-\t    STRIP_NOPS (tmp);\n-\t  result_type = common_type (type2, TREE_TYPE (tmp));\n-\t  op1 = tmp;\n-\t}\n-      else if (code2 == RECORD_TYPE && TYPE_HAS_CONVERSION (type2))\n-\t{\n-\t  tree tmp;\n-\t  if (code1 == POINTER_TYPE)\n-\t    tmp = build_pointer_type\n-\t      (cp_build_qualified_type (TREE_TYPE (type1), \n-\t\t\t\t\tTYPE_QUAL_CONST \n-\t\t\t\t\t| TYPE_QUAL_VOLATILE\n-\t\t\t\t\t| TYPE_QUAL_RESTRICT));\n-\t  else\n-\t    tmp = type1;\n-\n-\t  tmp = build_type_conversion (tmp, op2, 0);\n-\t  if (tmp == NULL_TREE)\n-\t    {\n-\t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n-\t\t\ttype1, type2);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (tmp == error_mark_node)\n-\t    error (\"ambiguous pointer conversion\");\n-\t  else\n-\t    STRIP_NOPS (tmp);\n-\t  result_type = common_type (type1, TREE_TYPE (tmp));\n-\t  op2 = tmp;\n-\t}\n-      else if (flag_cond_mismatch)\n-\tresult_type = void_type_node;\n-      else\n-\t{\n-\t  error (\"type mismatch in conditional expression\");\n-\t  return error_mark_node;\n-\t}\n-    }\n-\n-  if (TREE_CODE (result_type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n-    result_type = build_ptrmemfunc_type (result_type);\n-\n-  if (result_type != TREE_TYPE (op1))\n-    op1 = convert_for_initialization\n-      (NULL_TREE, result_type, op1, LOOKUP_NORMAL, \"converting\", NULL_TREE, 0);\n-  if (result_type != TREE_TYPE (op2))\n-    op2 = convert_for_initialization\n-      (NULL_TREE, result_type, op2, LOOKUP_NORMAL, \"converting\", NULL_TREE, 0);\n-\n-  if (TREE_CODE (ifexp) == INTEGER_CST)\n-    return integer_zerop (ifexp) ? op2 : op1;\n-\n-  return convert_from_reference\n-    (fold (build (COND_EXPR, result_type, ifexp, op1, op2)));\n+  return build_conditional_expr (ifexp, op1, op2);\n }\n \f\n /* Handle overloading of the ',' operator when needed.  Otherwise,\n@@ -6628,18 +6420,11 @@ pfn_from_ptrmemfunc (t)\n \t   pfn_identifier, NULL_TREE, 0)); \n }\n \n-/* Convert value RHS to type TYPE as preparation for an assignment\n-   to an lvalue of type TYPE.\n-   The real work of conversion is done by `convert'.\n-   The purpose of this function is to generate error messages\n-   for assignments that are not allowed in C.\n-   ERRTYPE is a string to use in error messages:\n-   \"assignment\", \"return\", etc.\n-\n-   C++: attempts to allow `convert' to find conversions involving\n-   implicit type conversion between aggregate and scalar types\n-   as per 8.5.6 of C++ manual.  Does not randomly dereference\n-   pointers to aggregates!  */\n+/* Convert value RHS to type TYPE as preparation for an assignment to\n+   an lvalue of type TYPE.  ERRTYPE is a string to use in error\n+   messages: \"assignment\", \"return\", etc.  If FNDECL is non-NULL, we\n+   are doing the conversion in order to pass the PARMNUMth argument of\n+   FNDECL.  */\n \n static tree\n convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n@@ -6662,388 +6447,86 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n \n-  if (rhs == error_mark_node || TREE_TYPE (rhs) == error_mark_node)\n+  rhstype = TREE_TYPE (rhs);\n+  coder = TREE_CODE (rhstype);\n+\n+  if (rhs == error_mark_node || rhstype == error_mark_node)\n     return error_mark_node;\n   if (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n-      || is_overloaded_fn (rhs))\n-    rhs = default_conversion (rhs);\n-  else if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n-    rhs = convert_from_reference (rhs);\n-\n-  /* If rhs is some sort of overloaded function, ocp_convert will either\n-     do the right thing or complain; we don't need to check anything else.\n-     So just hand off.  */\n-  if (type_unknown_p (rhs))\n-    return ocp_convert (type, rhs, CONV_IMPLICIT, LOOKUP_NORMAL);\n-\n-  rhstype = TREE_TYPE (rhs);\n-  coder = TREE_CODE (rhstype);\n-\n   /* Issue warnings about peculiar, but legal, uses of NULL.  */\n   if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n     cp_warning (\"converting NULL to non-pointer type\");\n \n-  /* This should no longer change types on us.  */\n-  if (TREE_CODE (rhs) == CONST_DECL)\n-    rhs = DECL_INITIAL (rhs);\n-  else if (TREE_READONLY_DECL_P (rhs))\n-    rhs = decl_constant_value (rhs);\n-\n-  if (same_type_p (type, rhstype))\n-    {\n-      overflow_warning (rhs);\n-      return rhs;\n-    }\n-\n+  /* The RHS of an assignment cannot have void type.  */\n   if (coder == VOID_TYPE)\n     {\n       error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  /* Arithmetic types all interconvert.  */\n-  if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == BOOLEAN_TYPE\n-       || codel == COMPLEX_TYPE)\n-       && (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == BOOLEAN_TYPE\n-\t   || coder == COMPLEX_TYPE))\n-    {\n-      /* But we should warn if assigning REAL_TYPE to INTEGER_TYPE.  */\n-      if (coder == REAL_TYPE && codel == INTEGER_TYPE)\n-\t{\n-\t  if (fndecl)\n-\t    cp_warning (\"`%T' used for argument %P of `%D'\",\n-\t\t\trhstype, parmnum, fndecl);\n-\t  else\n-\t    cp_warning (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n-\t}\n-      /* And we should warn if assigning a negative value to\n-\t an unsigned variable.  */\n-      else if (TREE_UNSIGNED (type) && codel != BOOLEAN_TYPE)\n-\t{\n-\t  if (TREE_CODE (rhs) == INTEGER_CST\n-\t      && TREE_NEGATED_INT (rhs))\n-\t    {\n-\t      if (fndecl)\n-\t\tcp_warning (\"negative value `%E' passed as argument %P of `%D'\",\n-\t\t\t    rhs, parmnum, fndecl);\n-\t      else\n-\t\tcp_warning (\"%s of negative value `%E' to `%T'\",\n-\t\t\t    errtype, rhs, type);\n-\t    }\n-\t  overflow_warning (rhs);\n-\t  if (TREE_CONSTANT (rhs))\n-\t    rhs = fold (rhs);\n-\t}\n-\n-      return convert_and_check (type, rhs);\n-    }\n-  /* Conversions involving enums.  */\n-  else if ((codel == ENUMERAL_TYPE\n-\t    && (INTEGRAL_CODE_P (coder) || coder == REAL_TYPE))\n-\t   || (coder == ENUMERAL_TYPE\n-\t       && (INTEGRAL_CODE_P (codel) || codel == REAL_TYPE)))\n-    {\n-      return ocp_convert (type, rhs, CONV_IMPLICIT, LOOKUP_NORMAL);\n-    }\n-  /* Conversions among pointers */\n-  else if (codel == POINTER_TYPE\n-\t   && (coder == POINTER_TYPE\n-\t       || (coder == RECORD_TYPE\n-\t\t   && (IS_SIGNATURE_POINTER (rhstype)\n-\t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n-    {\n-      register tree ttl = TREE_TYPE (type);\n-      register tree ttr;\n-      int ctt = 0;\n \n-      if (coder == RECORD_TYPE)\n-\t{\n-\t  rhs = build_optr_ref (rhs);\n-\t  rhstype = TREE_TYPE (rhs);\n-\t}\n-      ttr = TREE_TYPE (rhstype);\n-\n-      /* If both pointers are of aggregate type, then we\n-\t can give better error messages, and save some work\n-\t as well.  */\n-      if (TREE_CODE (ttl) == RECORD_TYPE && TREE_CODE (ttr) == RECORD_TYPE)\n-\t{\n-\t  tree binfo;\n-\n-\t  if (TYPE_MAIN_VARIANT (ttl) == TYPE_MAIN_VARIANT (ttr)\n-\t      || type == class_star_type_node\n-\t      || rhstype == class_star_type_node)\n-\t    binfo = TYPE_BINFO (ttl);\n-\t  else\n-\t    binfo = get_binfo (ttl, ttr, 1);\n-\n-\t  if (binfo == error_mark_node)\n-\t    return error_mark_node;\n-\t  if (binfo == 0)\n-\t    return error_not_base_type (ttl, ttr);\n-\n-\t  if (!at_least_as_qualified_p (ttl, ttr))\n-\t    {\n-\t      if (fndecl)\n-\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards qualifiers\",\n-\t\t\t    rhstype, parmnum, fndecl);\n-\t      else\n-\t\tcp_pedwarn (\"%s to `%T' from `%T' discards qualifiers\",\n-\t\t\t    errtype, type, rhstype);\n-\t    }\n-\t}\n-\n-      /* Any non-function converts to a [const][volatile] void *\n-\t and vice versa; otherwise, targets must be the same.\n-\t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n-      else if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n-\t       || TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t       || (ctt = comp_target_types (type, rhstype, 1))\n-\t       || (unsigned_type (TYPE_MAIN_VARIANT (ttl))\n-\t\t   == unsigned_type (TYPE_MAIN_VARIANT (ttr))))\n-\t{\n-\t  /* ARM $4.8, commentary on p39.  */\n-\t  if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n-\t      && TREE_CODE (ttr) == OFFSET_TYPE)\n-\t    {\n-\t      cp_error (\"no standard conversion from `%T' to `void *'\", ttr);\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  if (ctt < 0 && TYPE_MAIN_VARIANT (ttl) != TYPE_MAIN_VARIANT (ttr))\n-\t    cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n-\t\t\trhstype, type);\n+  /* Simplify the RHS if possible.  */\n+  if (TREE_CODE (rhs) == CONST_DECL)\n+    rhs = DECL_INITIAL (rhs);\n+  else if (TREE_READONLY_DECL_P (rhs))\n+    rhs = decl_constant_value (rhs);\n \n-\t  if (TYPE_MAIN_VARIANT (ttl) != void_type_node\n-\t      && TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t      && ! null_ptr_cst_p (rhs))\n-\t    {\n-\t      if (coder == RECORD_TYPE)\n-\t\tcp_pedwarn (\"implicit conversion of signature pointer to type `%T'\",\n-\t\t\t    type);\n-\t      else\n-\t\tpedwarn (\"ANSI C++ forbids implicit conversion from `void *' in %s\",\n-\t\t\t errtype);\n-\t    }\n-\t  /* Const and volatile mean something different for function types,\n-\t     so the usual warnings are not appropriate.  */\n-\t  else if ((TREE_CODE (ttr) != FUNCTION_TYPE && TREE_CODE (ttr) != METHOD_TYPE)\n-\t\t   || (TREE_CODE (ttl) != FUNCTION_TYPE && TREE_CODE (ttl) != METHOD_TYPE))\n-\t    {\n-\t      if (TREE_CODE (ttl) == OFFSET_TYPE\n-\t\t  && binfo_member (TYPE_OFFSET_BASETYPE (ttr),\n-\t\t\t\t   CLASSTYPE_VBASECLASSES (TYPE_OFFSET_BASETYPE (ttl))))\n-\t\t{\n-\t\t  error (\"%s between pointer to members converting across virtual baseclasses\", errtype);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      else if (!at_least_as_qualified_p (ttl, ttr))\n-\t\t{\n-\t\t  if (string_conv_p (type, rhs, 1))\n-\t\t    /* converting from string constant to char *, OK.  */;\n-\t\t  else if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards qualifiers\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards qualifiers\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\t      else if (TREE_CODE (ttl) == TREE_CODE (ttr)\n-\t\t       && ! comp_target_types (type, rhstype, 1))\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes signedness\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes signedness\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\t    }\n-\t}\n+  /* Warn about assigning a floating-point type to an integer type.  */\n+  if (coder == REAL_TYPE && codel == INTEGER_TYPE)\n+    {\n+      if (fndecl)\n+\tcp_warning (\"`%T' used for argument %P of `%D'\",\n+\t\t    rhstype, parmnum, fndecl);\n       else\n-\t{\n-\t  int add_quals = 0;\n-\t  int drops_quals = 0;\n-\t  int left_const = 1;\n-\t  int unsigned_parity;\n-\t  int nptrs = 0;\n-\n-\t  /* This code is basically a duplicate of comp_ptr_ttypes_real.  */\n-\t  for (; ; ttl = TREE_TYPE (ttl), ttr = TREE_TYPE (ttr))\n-\t    {\n-\t      nptrs -= 1;\n-\t      drops_quals |= !at_least_as_qualified_p (ttl, ttr);\n-\n-\t      if (! left_const\n-\t\t  && !at_least_as_qualified_p (ttr, ttl))\n-\t\tadd_quals = 1;\n-\t      left_const &= TYPE_READONLY (ttl);\n-\n-\t      if (TREE_CODE (ttl) != POINTER_TYPE\n-\t\t  || TREE_CODE (ttr) != POINTER_TYPE)\n-\t\tbreak;\n-\t    }\n-\t  unsigned_parity = TREE_UNSIGNED (ttl) - TREE_UNSIGNED (ttr);\n-\t  if (unsigned_parity)\n-\t    {\n-\t      if (TREE_UNSIGNED (ttl))\n-\t\tttr = unsigned_type (ttr);\n-\t      else\n-\t\tttl = unsigned_type (ttl);\n-\t    }\n-\n-\t  if (comp_target_types (ttl, ttr, nptrs) > 0)\n-\t    {\n-\t      if (add_quals)\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' adds cv-quals without intervening `const'\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' adds cv-quals without intervening `const'\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\t      if (drops_quals)\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards qualifiers\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards qualifiers\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\t      if (unsigned_parity > 0)\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes signed to unsigned\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes signed to unsigned\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\t      else if (unsigned_parity < 0)\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes unsigned to signed\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes unsigned to signed\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\n-\t      /* C++ is not so friendly about converting function and\n-\t\t member function pointers as C.  Emit warnings here.  */\n-\t      if (TREE_CODE (ttl) == FUNCTION_TYPE\n-\t\t  || TREE_CODE (ttl) == METHOD_TYPE)\n-\t\tif (!same_or_base_type_p (ttl, ttr))\n-\t\t  {\n-\t\t    warning (\"conflicting function types in %s:\", errtype);\n-\t\t    cp_warning (\"\\t`%T' != `%T'\", type, rhstype);\n-\t\t  }\n-\t    }\n-\t  else\n-\t    {\n-\t      if (fndecl)\n-\t\tcp_error (\"passing `%T' as argument %P of `%D'\",\n-\t\t\t  rhstype, parmnum, fndecl);\n-\t      else\n-\t\tcp_error (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      return cp_convert (type, rhs);\n+\tcp_warning (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n     }\n-  else if (codel == POINTER_TYPE\n-\t   && (coder == INTEGER_TYPE\n-\t       || coder == BOOLEAN_TYPE))\n+  /* And warn about assigning a negative value to an unsigned\n+     variable.  */\n+  else if (TREE_UNSIGNED (type) && codel != BOOLEAN_TYPE)\n     {\n-      /* An explicit constant 0 can convert to a pointer,\n-         but not a 0 that results from casting or folding.  */\n-      if (! (TREE_CODE (rhs) == INTEGER_CST && integer_zerop (rhs)))\n+      if (TREE_CODE (rhs) == INTEGER_CST\n+\t  && TREE_NEGATED_INT (rhs))\n \t{\n \t  if (fndecl)\n-\t    cp_pedwarn (\"passing `%T' to argument %P of `%D' lacks a cast\",\n-\t\t\trhstype, parmnum, fndecl);\n+\t    cp_warning (\"negative value `%E' passed as argument %P of `%D'\",\n+\t\t\trhs, parmnum, fndecl);\n \t  else\n-\t    cp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n-\t\t\terrtype, type, rhstype);\n+\t    cp_warning (\"%s of negative value `%E' to `%T'\",\n+\t\t\terrtype, rhs, type);\n \t}\n-      return cp_convert (type, rhs);\n-    }\n-  else if (codel == INTEGER_TYPE\n-\t   && (coder == POINTER_TYPE\n-\t       || (coder == RECORD_TYPE\n-\t\t   && (IS_SIGNATURE_POINTER (rhstype)\n-\t\t       || TYPE_PTRMEMFUNC_FLAG (rhstype)\n-\t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n-    {\n-      if (fndecl)\n-\tcp_pedwarn (\"passing `%T' to argument %P of `%D' lacks a cast\",\n-\t\t    rhstype, parmnum, fndecl);\n+      overflow_warning (rhs);\n+      if (TREE_CONSTANT (rhs))\n+\trhs = fold (rhs);\n+    }\n+\n+  /* [expr.ass]\n+\n+     The expression is implicitly converted (clause _conv_) to the\n+     cv-unqualified type of the left operand.  */\n+  if (!can_convert_arg (type, rhstype, rhs))\n+    {\n+      /* When -Wno-pmf-converions is use, we just silently allow\n+\t conversions from pointers-to-members to plain pointers.  If\n+\t the conversion doesn't work, cp_convert will complain.  */\n+      if (!warn_pmf2ptr \n+\t  && TYPE_PTR_P (type) \n+\t  && TYPE_PTRMEMFUNC_P (rhstype))\n+\trhs = cp_convert (strip_top_quals (type), rhs);\n+      /* If the right-hand side has unknown type, then it is an\n+\t overloaded function.  Call instantiate_type to get error\n+\t messages.  */\n+      else if (rhstype == unknown_type_node)\n+\tinstantiate_type (type, rhs, 1);\n+      else if (fndecl)\n+\tcp_error (\"cannot convert `%T' to `%T' for argument `%P' to `%D'\",\n+\t\t  rhstype, type, parmnum, fndecl);\n       else\n-\tcp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n-\t\t    errtype, type, rhstype);\n-      return cp_convert (type, rhs);\n-    }\n-  else if (codel == BOOLEAN_TYPE\n-\t   && (coder == POINTER_TYPE\n-\t       || (coder == RECORD_TYPE\n-\t\t   && (IS_SIGNATURE_POINTER (rhstype)\n-\t\t       || TYPE_PTRMEMFUNC_FLAG (rhstype)\n-\t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n-    return cp_convert (type, rhs);\n-\n-  /* C++ */\n-  else if (((coder == POINTER_TYPE\n-\t     && TREE_CODE (TREE_TYPE (rhstype)) == METHOD_TYPE)\n-\t    || integer_zerop (rhs)\n-\t    || TYPE_PTRMEMFUNC_P (rhstype))\n-\t   && TYPE_PTRMEMFUNC_P (type))\n-    {\n-      tree ttl = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-      tree ttr = (TYPE_PTRMEMFUNC_P (rhstype)\n-\t\t  ? TYPE_PTRMEMFUNC_FN_TYPE (rhstype)\n-\t\t  : rhstype);\n-      int ctt = (TREE_CODE (rhstype) == INTEGER_TYPE ? 1\n-\t\t : comp_target_types (ttl, ttr, 1));\n-\n-      if (ctt < 0)\n-\tcp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n-\t\t    ttr, ttl);\n-      else if (ctt == 0)\n-\tcp_error (\"%s to `%T' from `%T'\", errtype, ttl, ttr);\n-\n-      /* compatible pointer to member functions.  */\n-      return build_ptrmemfunc (ttl, rhs, 0);\n-    }\n-  else if (codel == ERROR_MARK || coder == ERROR_MARK)\n-    return error_mark_node;\n-\n-  /* This should no longer happen.  References are initialized via\n-     `convert_for_initialization'.  They should otherwise be\n-     bashed before coming here.  */\n-  else if (codel == REFERENCE_TYPE)\n-    my_friendly_abort (317);\n-  else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (rhs)))\n-    {\n-      tree nrhs = build1 (NOP_EXPR, type, rhs);\n-      TREE_CONSTANT (nrhs) = TREE_CONSTANT (rhs);\n-      return nrhs;\n+\tcp_error (\"cannot convert `%T' to `%T' in %s\", rhstype, type, \n+\t\t  errtype);\n+      return error_mark_node;\n     }\n-  else if (TYPE_HAS_CONSTRUCTOR (type) || IS_AGGR_TYPE (TREE_TYPE (rhs)))\n-    return cp_convert (type, rhs);\n-  /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t       || TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n-\t   && TREE_TYPE (rhs)\n-\t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n-    return cp_convert (type, rhs);\n-\n-  cp_error (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n-  return error_mark_node;\n+  return ncp_convert (strip_top_quals (type), rhs);\n }\n \n /* Convert RHS to be of type TYPE."}, {"sha": "d1e96eda7799813101b0b1768f0004603663eaf3", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -125,21 +125,27 @@ readonly_error (arg, string, soft)\n     (*fn) (\"%s of read-only location\", string);\n }\n \n-/* Print an error message for invalid use of a type which declares\n-   virtual functions which are not inheritable.  */\n+/* If TYPE has abstract virtual functions, issue an error about trying\n+   to create an object of that type.  DECL is the object declared, or\n+   NULL_TREE if the declaration is unavailable.  Returns 1 if an error\n+   occurred; zero if all was well.  */\n \n-void\n+int\n abstract_virtuals_error (decl, type)\n      tree decl;\n      tree type;\n {\n-  tree u = CLASSTYPE_ABSTRACT_VIRTUALS (type);\n+  tree u;\n   tree tu;\n \n+  if (!CLASS_TYPE_P (type) || !CLASSTYPE_ABSTRACT_VIRTUALS (type))\n+    return 0;\n+\n+  u = CLASSTYPE_ABSTRACT_VIRTUALS (type);\n   if (decl)\n     {\n       if (TREE_CODE (decl) == RESULT_DECL)\n-\treturn;\n+\treturn 0;\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \tcp_error (\"cannot declare variable `%D' to be of type `%T'\",\n@@ -170,6 +176,8 @@ abstract_virtuals_error (decl, type)\n     }\n   else\n     cp_error (\"  since type `%T' has abstract virtual functions\", type);\n+\n+  return 1;\n }\n \n /* Print an error message for invalid use of a signature type.\n@@ -1486,11 +1494,8 @@ build_functional_cast (exp, parms)\n       cp_error (\"type `%T' is not yet defined\", type);\n       return error_mark_node;\n     }\n-  if (IS_AGGR_TYPE (type) && CLASSTYPE_ABSTRACT_VIRTUALS (type))\n-    {\n-      abstract_virtuals_error (NULL_TREE, type);\n-      return error_mark_node;\n-    }\n+  if (abstract_virtuals_error (NULL_TREE, type))\n+    return error_mark_node;\n \n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n     return build_c_cast (type, TREE_VALUE (parms));"}, {"sha": "de46668484bcdee3093bb425fe7468fa276fbf37", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash19.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash19.C?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -1168,8 +1168,8 @@ class dict : public object {\n \t\t\t DISPLAYER displayer, STRINGER str_f)\n \t\t{// ERROR - candidate for bad call\n \t\t\tif (799  >=  800 ) cout <<  \"Creating new dictionary...\"  << '\\n'; ;\n-\t\t\tif (cmp == __null )       cmp = &default_compare;\n-\t\t\tif (displayer == __null ) displayer = &default_displayer;\n+\t\t\tif (cmp == __null )       cmp = (COMPARE) &default_compare;\n+\t\t\tif (displayer == __null ) displayer = (DISPLAYER) &default_displayer;\n \t\t\tif (str_f == __null )     str_f = &default_stringer;\n \t\t\tcompare_f = cmp;\n \t\t\tdisplay_f = displayer;\n@@ -1417,7 +1417,7 @@ class queue : public object {\n \t\t         DISPLAYER displayer, STRINGER str_f)\n \t\t{// ERROR - candidate for bad call\n \t\t\tif (799  >=  800 ) cout <<  \"Creating new queue...\"  << '\\n'; ;\n-\t\t\tif (displayer == __null ) displayer = &default_displayer;\n+\t\t\tif (displayer == __null ) displayer = (DISPLAYER) &default_displayer;\n \t\t\tif (str_f == __null )     str_f = &default_stringer;\n \t\t\tdisplay_f = displayer;\n \t\t\tdestroy_f = destroyer;"}, {"sha": "c681c82d08d2baec74eee3443760c928d8137ae8", "filename": "gcc/testsuite/g++.old-deja/g++.jason/typedef.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypedef.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypedef.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypedef.C?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -2,8 +2,9 @@\n // Bug: g++ misinterprets typedefs of function type in class scope.\n // Build don't link:\n \n+typedef int (*F1) ();\n struct A {\n    typedef int F();\n    F *fp;\n-   void* g() { return fp; }\t// gets bogus error - typing\n+   F1 g() { return fp; }\t// gets bogus error - typing\n };"}, {"sha": "3dd5dc27e0a692887da326be7fd107000663506a", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p10769a.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp10769a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp10769a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp10769a.C?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -11,11 +11,11 @@ public:\n   void f1b() { ok += 5; }\n   void f2a() { ok += 7; }\t// gets bogus error XFAIL *-*-*\n   void f2b() { }\n-  const static void (*table[2][2])();\n+  static void (*table[2][2])();\n   void main();\n } a;\n \n-const void (*A::table[2][2])()\n+void (*A::table[2][2])()\n   = { { PMF2PF(&A::f1a), PMF2PF(&A::f1b) },\n       { PMF2PF(&A::f2a), PMF2PF(&A::f1b) },\n   };"}, {"sha": "c025beb3ffd80aad8936f4f836199835b5e246c4", "filename": "gcc/testsuite/g++.old-deja/g++.other/cond1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcond1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcond1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcond1.C?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -0,0 +1,26 @@\n+// Build don't run:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+void f (T&) ;\n+\n+template <>\n+void f (void (&)()) \n+{\n+}\n+\n+void g () \n+{\n+}\n+\n+void h ()\n+{\n+}\n+\n+bool b;\n+\n+int main ()\n+{\n+  f (b ? g : h);\n+}\n+"}, {"sha": "28c8e3b686d875486289e8f6c892acdf29ae4b38", "filename": "gcc/testsuite/g++.old-deja/g++.other/conv5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconv5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconv5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconv5.C?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -5,4 +5,4 @@\n // Special g++ Options:\n \n int foo();\n-const int (*bar)() = foo; // ERROR - adding const - XFAIL *-*-*\n+const int (*bar)() = foo; // ERROR - adding const"}, {"sha": "50ae8a91f1597d00ae00bb65e81f7a86c4e36a2a", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload10.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a64a77ef33be210374003a0b84dd8d60f75a49/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload10.C?ref=a7a64a77ef33be210374003a0b84dd8d60f75a49", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+// Origin: Jason Merrill <jason@cygnus.com>\n+\n+  const char *pc;\n+  enum A { x } a;\n+  int i;\n+\n+  int main()\n+  {\n+     return i ? *pc : a;\n+  }"}]}