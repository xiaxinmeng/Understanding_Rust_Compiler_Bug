{"sha": "b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5YjRhNzg3ZDMwY2NlOGU0YjEyZTdlNTIxZWE2NDJlNjgwZmE5ZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-04T17:51:34Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-04T17:51:34Z"}, "message": "63rd Cygnus<->FSF merge\n\nFrom-SVN: r9311", "tree": {"sha": "a5fc8c1ccd399d5c3c6e06747d4438b27dee2e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5fc8c1ccd399d5c3c6e06747d4438b27dee2e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/comments", "author": null, "committer": null, "parents": [{"sha": "9fa6d012c05feb0f76406b9b3d088fd1708bc721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa6d012c05feb0f76406b9b3d088fd1708bc721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa6d012c05feb0f76406b9b3d088fd1708bc721"}], "stats": {"total": 176, "additions": 140, "deletions": 36}, "files": [{"sha": "9b417031d3bba31a95c0096a537e4127fefdb758", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "patch": "@@ -1,3 +1,37 @@\n+Mon Apr  3 16:55:08 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* repo.c (get_base_filename): Take filename parm, fix logic bug.\n+\n+\t* typeck.c (build_compound_expr): Do not warn about a compound expr\n+\tin which the first expression has no side effects.\n+\t(build_x_compound_expr): Warn here instead.\n+\t(build_conditional_expr): Don't warn about a conditional expression\n+\tbetween an enum and the type it promotes to.\n+\n+\t* init.c (build_new): Handle initialization of arrays of builtins\n+\tproperly.\n+\n+Mon Apr  3 15:08:04 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* repo.c: Include config.h to get definitions of bcopy and rindex\n+\ton systems that don't have them (e.g., SVR4).\n+\n+Mon Apr  3 14:41:55 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_table): Pass NULL_TREE instead of init to\n+\tfinish_decl so that it won't try and do error checking on the\n+\tinitializer.\n+\n+Mon Apr  3 10:45:50 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* repo.c (get_base_filename): Analyze COLLECT_GCC_OPTIONS to\n+\tdetermine whether this compile used -c -o.\n+\t(open_repo_file): Use get_base_filename.  Remove the extension.\n+\t(finish_repo): Spit out the values of main_input_filename,\n+\tCOLLECT_GCC and COLLECT_GCC_OPTIONS.\n+\n+\t* parse.y (structsp): Add TYPENAME_KEYWORD complex_type_name.\n+\n Sun Apr  2 23:43:51 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* search.c (compute_access): Don't try to do access control on"}, {"sha": "2a4068f9f2ceb9156106ddf72547b13038eb4376", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "patch": "@@ -2291,7 +2291,7 @@ finish_table (name, type, init, publicp)\n \t  DECL_INITIAL (empty_table) = init;\n \t  asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (empty_table)),\n \t\t\t\t  IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n-\t  finish_decl (empty_table, init, asmspec, 0, 0);\n+\t  finish_decl (empty_table, NULL_TREE, asmspec, 0, 0);\n \t}\n       is_empty = 1;\n     }\n@@ -2329,7 +2329,7 @@ finish_table (name, type, init, publicp)\n \t\t\t      IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n     }\n \n-  finish_decl (decl, init, asmspec, 0, 0);\n+  finish_decl (decl, NULL_TREE, asmspec, 0, 0);\n   return decl;\n }\n "}, {"sha": "ee99ba2eb56e1e60e645ae321bf66e9f31e45835", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "patch": "@@ -3082,7 +3082,8 @@ build_new (placement, decl, init, use_global_new)\n \n   if (TYPE_NEEDS_CONSTRUCTING (type) || init)\n     {\n-      if (! TYPE_NEEDS_CONSTRUCTING (type) && ! IS_AGGR_TYPE (type))\n+      if (! TYPE_NEEDS_CONSTRUCTING (type)\n+\t  && ! IS_AGGR_TYPE (type) && ! has_array)\n \t{\n \t  /* New 2.0 interpretation: `new int (10)' means\n \t     allocate an int, and initialize it with 10.  */"}, {"sha": "b28d9a137bdd3093aac44302f6637224f956e2d0", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "patch": "@@ -167,7 +167,7 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME\n+%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n \n %left '{' ',' ';'\n \n@@ -2185,7 +2185,8 @@ structsp:\n \t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n \t| ENUM complex_type_name\n \t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n-\n+\t| TYPENAME_KEYWORD complex_type_name\n+\t\t{ $$ = $2; }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly opt.component_decl_list '}'\n \t\t{"}, {"sha": "9052eb89f9e0954a89075046a8ed1ce6cc5a6b52", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "patch": "@@ -22,18 +22,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n    Everything should be emitted in a translation unit where it is used.\n    The results of the automatic process should be easily reproducible with\n-   explicit code.\n-\n-   I'm thinking of compiling with -frepo, running a Perl script to update\n-   files, and then being able to rebuild everything with -fno-implicit.\n-   Full automation can come later.  */\n+   explicit code.  */\n \n #include <stdio.h>\n+#include \"config.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"input.h\"\n \n extern char * rindex ();\n+extern char * getenv ();\n \n static tree pending_repo;\n static char repo_name[1024];\n@@ -157,12 +155,61 @@ repo_tinfo_used (ti)\n {\n }\n \n+static char *\n+save_string (s, len)\n+     char *s;\n+     int len;\n+{\n+  register char *result = xmalloc (len + 1);\n+\n+  bcopy (s, result, len);\n+  result[len] = 0;\n+  return result;\n+}\n+\n+static char *\n+get_base_filename (filename)\n+     char *filename;\n+{\n+  char *p = getenv (\"COLLECT_GCC_OPTIONS\");\n+  char *output = 0;\n+  int compiling = 0;\n+\n+  if (p)\n+    while (*p)\n+      {\n+\tchar *q = p;\n+\twhile (*q && *q != ' ') q++;\n+\tif (*p == '-' && p[1] == 'o')\n+\t  {\n+\t    p += 2;\n+\t    if (p == q)\n+\t      {\n+\t\tp++; q++;\n+\t\tif (*q)\n+\t\t  while (*q && *q != ' ') q++;\n+\t      }\n+\n+\t    output = save_string (p, q - p);\n+\t  }\n+\telse if (*p == '-' && p[1] == 'c')\n+\t  compiling = 1;\n+\tif (*q) q++;\n+\tp = q;\n+      }\n+\n+  if (compiling && output)\n+    return output;\n+\n+  return save_string (filename, strlen (filename));\n+}        \n+\n static void\n open_repo_file (filename)\n      char *filename;\n {\n   register char *p, *q;\n-  char *file = filename;\n+  char *file = get_base_filename (filename);\n   char *s = rindex (file, '/');\n   if (s == NULL)\n     s = file;\n@@ -172,10 +219,15 @@ open_repo_file (filename)\n   for (p = repo_name, q = file; q < s; )\n     *p++ = *q++;\n   *p++ = '.';\n-  strcpy (p, q);\n+  if ((s = rindex (q, '.')) == NULL)\n+    strcpy (p, q);\n+  else\n+    for (; q < s;)\n+      *p++ = *q++;\n   strcat (p, \".repo\");\n \n   repo_file = fopen (repo_name, \"r\");\n+  free (file);\n }\n \n void\n@@ -187,7 +239,7 @@ init_repo (filename)\n   if (! flag_use_repository)\n     return;\n \n-  open_repo_file (filename);\n+  open_repo_file ();\n \n   if (repo_file == 0)\n     return;\n@@ -202,6 +254,7 @@ init_repo (filename)\n       switch (buf[0])\n \t{\n \tcase 'A':\n+\tcase 'G':\n \tcase 'M':\n \t  break;\n \tcase 'C':\n@@ -228,7 +281,7 @@ reopen_repo_file_for_write ()\n \n   if (repo_file == 0)\n     {\n-      error (\"man't create repository information file `%s'\", repo_name);\n+      error (\"can't create repository information file `%s'\", repo_name);\n       flag_use_repository = 0;\n     }\n }\n@@ -239,7 +292,7 @@ void\n finish_repo ()\n {\n   tree t;\n-  int changed = 0;\n+  char *p;\n \n   if (! flag_use_repository)\n     return;\n@@ -254,6 +307,16 @@ finish_repo ()\n   if (repo_file == 0)\n     goto out;\n \n+  fprintf (repo_file, \"M %s\\n\", main_input_filename);\n+\n+  p = getenv (\"COLLECT_GCC\");\n+  if (p != 0)\n+    fprintf (repo_file, \"G %s\\n\", p);\n+\n+  p = getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (p != 0)\n+    fprintf (repo_file, \"A %s\\n\", p);\n+\n   for (t = pending_repo; t; t = TREE_CHAIN (t))\n     {\n       tree val = TREE_VALUE (t);"}, {"sha": "6f261e9338a2ceaff7c8ec6e388b776198831a23", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19b4a787d30cce8e4b12e7e521ea642e680fa9d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b19b4a787d30cce8e4b12e7e521ea642e680fa9d", "patch": "@@ -3483,6 +3483,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t     all the values of the unsigned type.  */\n \t  if (! TREE_UNSIGNED (result_type))\n \t    /* OK */;\n+\t  /* Do not warn if both operands are unsigned.  */\n+\t  else if (op0_signed == op1_signed)\n+\t    /* OK */;\n \t  /* Do not warn if the signed quantity is an unsuffixed\n \t     integer literal (or some static constant expression\n \t     involving such literals) and it is non-negative.  */\n@@ -4592,11 +4595,13 @@ build_conditional_expr (ifexp, op1, op2)\n \t  cp_error (\"enumeral mismatch in conditional expression: `%T' vs `%T'\", type1, type2);\n \t  return error_mark_node;\n \t}\n-      else if (extra_warnings && ! IS_AGGR_TYPE_CODE (code2))\n+      else if (extra_warnings && ! IS_AGGR_TYPE_CODE (code2)\n+\t       && type2 != type_promotes_to (type1))\n \twarning (\"enumeral and non-enumeral type in conditional expression\");\n     }\n   else if (extra_warnings\n-\t   && code2 == ENUMERAL_TYPE && ! IS_AGGR_TYPE_CODE (code1))\n+\t   && code2 == ENUMERAL_TYPE && ! IS_AGGR_TYPE_CODE (code1)\n+\t   && type1 != type_promotes_to (type2))\n     warning (\"enumeral and non-enumeral type in conditional expression\");\n \n   if (code1 != VOID_TYPE)\n@@ -4828,6 +4833,22 @@ build_x_compound_expr (list)\n \t\t\t   TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n   if (result)\n     return build_x_compound_expr (tree_cons (NULL_TREE, result, TREE_CHAIN (rest)));\n+\n+  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n+    {\n+      /* the left-hand operand of a comma expression is like an expression\n+         statement: we should warn if it doesn't have any side-effects,\n+         unless it was explicitly cast to (void).  */\n+      if ((extra_warnings || warn_unused)\n+           && !(TREE_CODE (TREE_VALUE(list)) == CONVERT_EXPR\n+                && TREE_TYPE (TREE_VALUE(list)) == void_type_node))\n+        warning(\"left-hand operand of comma expression has no effect\");\n+    }\n+#if 0 /* this requires a gcc backend patch to export warn_if_unused_value */\n+  else if (warn_unused)\n+    warn_if_unused_value (TREE_VALUE(list));\n+#endif\n+\n   return build_compound_expr (tree_cons (NULL_TREE, TREE_VALUE (list),\n \t\t\t\t\t build_tree_list (NULL_TREE, build_x_compound_expr (rest))));\n }\n@@ -4861,25 +4882,9 @@ build_compound_expr (list)\n \n   rest = build_compound_expr (TREE_CHAIN (list));\n \n-  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n-    {\n-      /* the left-hand operand of a comma expression is like an expression\n-         statement: we should warn if it doesn't have any side-effects,\n-         unless it was explicitly cast to (void).  */\n-      if ((extra_warnings || warn_unused)\n-           && !(TREE_CODE (TREE_VALUE(list)) == CONVERT_EXPR\n-                && TREE_TYPE (TREE_VALUE(list)) == void_type_node))\n-        warning(\"left-hand operand of comma expression has no effect\");\n-\n-      /* When pedantic, a compound expression can be neither an lvalue\n-         nor an integer constant expression.  */\n-      if (! pedantic)\n-        return rest;\n-    }\n-#if 0 /* this requires a gcc backend patch to export warn_if_unused_value */\n-  else if (warn_unused)\n-    warn_if_unused_value (TREE_VALUE(list));\n-#endif\n+  /* When pedantic, a compound expression cannot be a constant expression.  */\n+  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)) && ! pedantic)\n+    return rest;\n \n   return build (COMPOUND_EXPR, TREE_TYPE (rest),\n \t\tbreak_out_cleanups (TREE_VALUE (list)), rest);"}]}