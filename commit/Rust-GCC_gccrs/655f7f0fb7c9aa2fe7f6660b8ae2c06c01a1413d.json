{"sha": "655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU1ZjdmMGZiN2M5YWEyZmU3ZjY2NjBiOGFlMmMwNmMwMWExNDEzZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-22T10:57:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-22T10:59:33Z"}, "message": "Refactor vect_analyze_slp_instance a bit\n\nIn preparation for a larger change this refactors vect_analyze_slp_instance\nso it doesn't need to know a vector type early.\n\n2020-10-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Refactor so\n\tcomputing a vector type early is not needed, for store group\n\tsplitting compute a new vector type based on the desired\n\tgroup size.", "tree": {"sha": "d58b50529c626c64447e2da08b515aa6ecb483ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d58b50529c626c64447e2da08b515aa6ecb483ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b960a9c83a93b58a84a7a370002990810675ac5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b960a9c83a93b58a84a7a370002990810675ac5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b960a9c83a93b58a84a7a370002990810675ac5d"}], "stats": {"total": 85, "additions": 38, "deletions": 47}, "files": [{"sha": "4544f0f84a8551e35180941b90dba0d41965a070", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 38, "deletions": 47, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=655f7f0fb7c9aa2fe7f6660b8ae2c06c01a1413d", "patch": "@@ -2009,7 +2009,6 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   slp_instance new_instance;\n   slp_tree node;\n   unsigned int group_size;\n-  tree vectype, scalar_type = NULL_TREE;\n   unsigned int i;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   vec<stmt_vec_info> scalar_stmts;\n@@ -2019,41 +2018,25 @@ vect_analyze_slp_instance (vec_info *vinfo,\n     vect_location = stmt_info->stmt;\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n-      scalar_type = TREE_TYPE (DR_REF (dr));\n       group_size = DR_GROUP_SIZE (stmt_info);\n-      vectype = get_vectype_for_scalar_type (vinfo, scalar_type, group_size);\n     }\n   else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       gcc_assert (is_a <loop_vec_info> (vinfo));\n-      vectype = STMT_VINFO_VECTYPE (stmt_info);\n       group_size = REDUC_GROUP_SIZE (stmt_info);\n     }\n   else if (is_gimple_assign (stmt_info->stmt)\n \t    && gimple_assign_rhs_code (stmt_info->stmt) == CONSTRUCTOR)\n     {\n-      vectype = TREE_TYPE (gimple_assign_rhs1 (stmt_info->stmt));\n       group_size = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt_info->stmt));\n       constructor = true;\n     }\n   else\n     {\n       gcc_assert (is_a <loop_vec_info> (vinfo));\n-      vectype = STMT_VINFO_VECTYPE (stmt_info);\n       group_size = as_a <loop_vec_info> (vinfo)->reductions.length ();\n     }\n \n-  if (!vectype)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"Build SLP failed: unsupported data-type %T\\n\",\n-\t\t\t scalar_type);\n-\n-      return false;\n-    }\n-  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\n   /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n   scalar_stmts.create (group_size);\n   stmt_vec_info next_info = stmt_info;\n@@ -2127,7 +2110,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Build the tree for the SLP instance.  */\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n-  poly_uint64 max_nunits = nunits;\n+  poly_uint64 max_nunits = 1;\n   unsigned tree_size = 0;\n   node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n \t\t\t      &max_nunits, matches, &npermutes,\n@@ -2201,7 +2184,9 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t     instructions do not generate this SLP instance.  */\n \t  if (is_a <loop_vec_info> (vinfo)\n \t      && loads_permuted\n-\t      && dr && vect_store_lanes_supported (vectype, group_size, false))\n+\t      && dr\n+\t      && vect_store_lanes_supported\n+\t\t   (STMT_VINFO_VECTYPE (scalar_stmts[0]), group_size, false))\n \t    {\n \t      slp_tree load_node;\n \t      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (new_instance), i, load_node)\n@@ -2284,51 +2269,57 @@ vect_analyze_slp_instance (vec_info *vinfo,\n     }\n \n   /* Try to break the group up into pieces.  */\n-  unsigned HOST_WIDE_INT const_nunits;\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info))\n-      && nunits.is_constant (&const_nunits))\n+      && DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info)))\n     {\n       for (i = 0; i < group_size; i++)\n \tif (!matches[i])\n \t  break;\n \n-      /* For basic block SLP, try to break the group up into multiples of the\n-\t vector size.  */\n+      /* For basic block SLP, try to break the group up into multiples of\n+\t a vector size.  */\n       if (is_a <bb_vec_info> (vinfo)\n-\t  && (i >= const_nunits && i < group_size))\n+\t  && (i > 1 && i < group_size))\n \t{\n-\t  /* Split into two groups at the first vector boundary before i.  */\n-\t  gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n-\t  unsigned group1_size = i & ~(const_nunits - 1);\n-\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"Splitting SLP group at stmt %u\\n\", i);\n-\t  stmt_vec_info rest = vect_split_slp_store_group (stmt_info,\n-\t\t\t\t\t\t\t   group1_size);\n-\t  bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n-\t\t\t\t\t\tmax_tree_size);\n-\t  /* If the first non-match was in the middle of a vector,\n-\t     skip the rest of that vector.  Do not bother to re-analyze\n-\t     single stmt groups.  */\n-\t  if (group1_size < i)\n+\t  tree scalar_type\n+\t    = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (stmt_info)));\n+\t  tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type,\n+\t\t\t\t\t\t      least_bit_hwi (i));\n+\t  unsigned HOST_WIDE_INT const_nunits;\n+\t  if (vectype\n+\t      && TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits))\n \t    {\n-\t      i = group1_size + const_nunits;\n+\t      /* Split into two groups at the first vector boundary.  */\n+\t      gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n+\t      unsigned group1_size = i & ~(const_nunits - 1);\n+\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Splitting SLP group at stmt %u\\n\", i);\n+\t      stmt_vec_info rest = vect_split_slp_store_group (stmt_info,\n+\t\t\t\t\t\t\t       group1_size);\n+\t      bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n+\t\t\t\t\t\t    max_tree_size);\n+\t      /* If the first non-match was in the middle of a vector,\n+\t\t skip the rest of that vector.  Do not bother to re-analyze\n+\t\t single stmt groups.  */\n+\t      if (group1_size < i)\n+\t\t{\n+\t\t  i = group1_size + const_nunits;\n+\t\t  if (i + 1 < group_size)\n+\t\t    rest = vect_split_slp_store_group (rest, const_nunits);\n+\t\t}\n \t      if (i + 1 < group_size)\n-\t\trest = vect_split_slp_store_group (rest, const_nunits);\n+\t\tres |= vect_analyze_slp_instance (vinfo, bst_map,\n+\t\t\t\t\t\t  rest, max_tree_size);\n+\t      return res;\n \t    }\n-\t  if (i + 1 < group_size)\n-\t    res |= vect_analyze_slp_instance (vinfo, bst_map,\n-\t\t\t\t\t      rest, max_tree_size);\n-\t  return res;\n \t}\n \n       /* For loop vectorization split into arbitrary pieces of size > 1.  */\n       if (is_a <loop_vec_info> (vinfo)\n \t  && (i > 1 && i < group_size))\n \t{\n-\t  gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n \t  unsigned group1_size = i;\n \n \t  if (dump_enabled_p ())"}]}