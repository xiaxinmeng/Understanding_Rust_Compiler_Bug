{"sha": "5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkYzU4NzgxYjgwMWQ0ZWMxY2Y2Yzk5NzFkN2U5NWJmM2QyZDI2Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-12-20T04:30:57Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-12-20T04:30:57Z"}, "message": "c-pretty-print.h: Fix comment typos.\n\n\t* c-pretty-print.h: Fix comment typos.\n\t* integrate.c: Likewise.\n\t* varasm.c: Likewise.\n\t* config/c4x/c4x.h: Likewise.\n\t* config/c4x/c4x.md: Likewise.\n\t* config/fr30/fr30.md: Likewise.\n\t* config/frv/frv.c: Likewise.\n\t* config/h8300/h8300.c: Likewise.\n\t* config/i386/i386.c: Likewise.\n\t* config/i386/i386.h: Likewise.\n\t* config/ia64/ia64.c: Likewise.\n\t* config/ia64/ia64.h: Likewise.\n\t* config/ip2k/ip2k.md: Likewise.\n\t* config/m68hc11/m68hc11-crt0.S: Likewise.\n\t* config/m68hc11/m68hc11.h: Likewise.\n\t* config/m68hc11/m68hc11.md: Likewise.\n\t* config/m68hc11/m68hc12.h: Likewise.\n\t* config/mcore/mcore.md: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/mips/mips.md: Likewise.\n\t* config/mmix/mmix-modes.def: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.h: Likewise.\n\t* config/rs6000/rs6000.md: Likewise.\n\nFrom-SVN: r60354", "tree": {"sha": "3d9985378bce8d2d63ec4a58cc8e57ab1acf6650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9985378bce8d2d63ec4a58cc8e57ab1acf6650"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/comments", "author": null, "committer": null, "parents": [{"sha": "539dbd15f3e90c346a11bea734b069e93dd14a55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539dbd15f3e90c346a11bea734b069e93dd14a55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539dbd15f3e90c346a11bea734b069e93dd14a55"}], "stats": {"total": 104, "additions": 66, "deletions": 38}, "files": [{"sha": "65ba2596a279b77682c52785b53d6d5aa6a61247", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -1,3 +1,31 @@\n+2002-12-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-pretty-print.h: Fix comment typos.\n+\t* integrate.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* config/c4x/c4x.h: Likewise.\n+\t* config/c4x/c4x.md: Likewise.\n+\t* config/fr30/fr30.md: Likewise.\n+\t* config/frv/frv.c: Likewise.\n+\t* config/h8300/h8300.c: Likewise.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/i386/i386.h: Likewise.\n+\t* config/ia64/ia64.c: Likewise.\n+\t* config/ia64/ia64.h: Likewise.\n+\t* config/ip2k/ip2k.md: Likewise.\n+\t* config/m68hc11/m68hc11-crt0.S: Likewise.\n+\t* config/m68hc11/m68hc11.h: Likewise.\n+\t* config/m68hc11/m68hc11.md: Likewise.\n+\t* config/m68hc11/m68hc12.h: Likewise.\n+\t* config/mcore/mcore.md: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/mips/mips.md: Likewise.\n+\t* config/mmix/mmix-modes.def: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.h: Likewise.\n+\t* config/rs6000/rs6000.md: Likewise.\n+\n 2002-12-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (output_a_shift): Clean up the code to"}, {"sha": "013ab6fa4a682a79c1fcb4b627b6ca8380a0334d", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -41,7 +41,7 @@ struct c_pretty_print_info\n      Not used yet.  */\n   int *offset_list;\n \n-  /* These must be overriden by each of the C and C++ front-end to\n+  /* These must be overridden by each of the C and C++ front-end to\n      reflect their understanding of syntatic productions when they differ.  */\n   c_pretty_print_fn declaration;\n   c_pretty_print_fn declaration_specifiers;\n@@ -141,7 +141,7 @@ struct c_pretty_print_info\n \n \n /* Returns the c_pretty_printer base object of PRETTY-PRINTER.  This\n-   macro must be overriden by any subclass of c_pretty_print_info.  */\n+   macro must be overridden by any subclass of c_pretty_print_info.  */\n #define pp_c_base(PP)  (PP)\n \n extern void pp_c_pretty_printer_init   PARAMS ((c_pretty_printer));"}, {"sha": "e75769b94074af206faaacb31bbfdb37616ec786", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -1334,7 +1334,7 @@ CUMULATIVE_ARGS;\n \n #ifndef REG_OK_STRICT\n \n-/* Nonzero if X is a hard or pseudo reg that can be used as an base.  */\n+/* Nonzero if X is a hard or pseudo reg that can be used as a base.  */\n \n #define REG_OK_FOR_BASE_P(X) IS_ADDR_OR_PSEUDO_REG(X)\n "}, {"sha": "68d933ba594f3dd2ab093a23e70c155b763b3626", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -231,7 +231,7 @@\n ;  a new spill register.\n \n ;  Note that the floating point representation of 0.0 on the C4x\n-;  is 0x80000000 (-2147483648).  This value produces an warning\n+;  is 0x80000000 (-2147483648).  This value produces a warning\n ;  message on 32-bit machines about the decimal constant being so large\n ;  that it is unsigned.\n "}, {"sha": "6d2a291f469a604294e9a5c81323e628a4df995c", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -36,7 +36,7 @@\n ;; Define an attribute to be used by the delay slot code.\n ;; An instruction by default is considered to be 'delyabable'\n ;; that is, it can be placed into a delay slot, but it is not\n-;; itself an delyaed branch type instruction.  An instruction\n+;; itself a delyaed branch type instruction.  An instruction\n ;; whoes type is 'delayed' is one which has a delay slot, and\n ;; an instruction whoes delay_type is 'other' is one which does\n ;; not have a delay slot, nor can it be placed into a delay slot."}, {"sha": "f1ad90b46ee56ebacea8ffdc6cea7ef1ba5f9599", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -1061,7 +1061,7 @@ frv_stack_info ()\n \tcase STACK_REGS_STDARG:\n \t  if (varargs_p)\n \t    {\n-\t      /* If this is a stdarg function with an non varardic argument split\n+\t      /* If this is a stdarg function with a non varardic argument split\n \t\t between registers and the stack, adjust the saved registers\n \t\t downward */\n \t      last -= (ADDR_ALIGN (cfun->pretend_args_size, UNITS_PER_WORD)\n@@ -4791,7 +4791,7 @@ call_operand (op, mode)\n   return gpr_or_int12_operand (op, mode);\n }\n \n-/* Return true if operator is an kind of relational operator */\n+/* Return true if operator is a kind of relational operator.  */\n \n int\n relational_operator (op, mode)"}, {"sha": "a01db55a4c939fc5974d6542ce79e55f09194b3c", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -667,7 +667,7 @@ h8300_output_function_epilogue (file, size)\n     }\n \n   /* Monitor epilogues are the same as interrupt function epilogues.\n-     Just make a note that we're in an monitor epilogue.  */\n+     Just make a note that we're in a monitor epilogue.  */\n   if (monitor)\n     fprintf (file, \";monitor epilogue\\n\");\n "}, {"sha": "78233283d93e8e76b297b6d4aa7cfc820af6d053", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -2414,7 +2414,7 @@ function_arg (cum, mode, type, named)\n     (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n-  /* Handle an hidden AL argument containing number of registers for varargs\n+  /* Handle a hidden AL argument containing number of registers for varargs\n      x86-64 functions.  For i386 ABI just return constm1_rtx to avoid\n      any AL settings.  */\n   if (mode == VOIDmode)\n@@ -8619,7 +8619,7 @@ ix86_fp_comparison_codes (code, bypass_code, first_code, second_code)\n }\n \n /* Return cost of comparison done fcom + arithmetics operations on AX.\n-   All following functions do use number of instructions as an cost metrics.\n+   All following functions do use number of instructions as a cost metrics.\n    In future this should be tweaked to compute bytes for optimize_size and\n    take into account performance of various instructions on various CPUs.  */\n static int"}, {"sha": "b05e7edcc02d362f24c40c515aa2325178dfe408", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -891,7 +891,7 @@ extern int x86_prefetch_sse;\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer.\n \n-   The value is an mask - bit 1 is set for fixed registers\n+   The value is a mask - bit 1 is set for fixed registers\n    for 32bit target, while 2 is set for fixed registers for 64bit.\n    Proper value is computed in the CONDITIONAL_REGISTER_USAGE.\n  */\n@@ -917,7 +917,7 @@ extern int x86_prefetch_sse;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.\n \n-   The value is an mask - bit 1 is set for call used\n+   The value is a mask - bit 1 is set for call used\n    for 32bit target, while 2 is set for call used for 64bit.\n    Proper value is computed in the CONDITIONAL_REGISTER_USAGE.\n */"}, {"sha": "16a5207666a52a2cb79f25e42c59859cbd2fe114", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -5320,7 +5320,7 @@\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n       /* ???? We ought to handle there the 32bit case too\n-\t - do we need new constrant?  */\n+\t - do we need new constraint?  */\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n@@ -5370,7 +5370,7 @@\n       if (! rtx_equal_p (operands[0], operands[1]))\n \tabort ();\n       /* ???? We ought to handle there the 32bit case too\n-\t - do we need new constrant?  */\n+\t - do we need new constraint?  */\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT"}, {"sha": "3009d1c1200a23393b008501f16cca8b3287c5b1", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -795,7 +795,7 @@ not_postinc_memory_operand (op, mode)\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != 'a');\n }\n \n-/* Return 1 if this is a comparison operator, which accepts an normal 8-bit\n+/* Return 1 if this is a comparison operator, which accepts a normal 8-bit\n    signed immediate operand.  */\n \n int\n@@ -5126,7 +5126,7 @@ safe_group_barrier_needed_p (insn)\n   return t;\n }\n \n-/* INSNS is an chain of instructions.  Scan the chain, and insert stop bits\n+/* INSNS is a chain of instructions.  Scan the chain, and insert stop bits\n    as necessary to eliminate dependendencies.  This function assumes that\n    a final instruction scheduling pass has been run which has already\n    inserted most of the necessary stop bits.  This function only inserts"}, {"sha": "091510c387c95746bf9b3e405d1c4837af4bbab7", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -277,7 +277,7 @@ extern const char *ia64_tls_size_string;\n \n /* A C expression whose value is zero if pointers that need to be extended\n    from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and one if\n-   they are zero-extended and negative one if there is an ptr_extend operation.\n+   they are zero-extended and negative one if there is a ptr_extend operation.\n \n    You need not define this macro if the `POINTER_SIZE' is equal to the width\n    of `Pmode'.  */"}, {"sha": "f29d05acb30add8bb730cf401ef7ebadeaf2018c", "filename": "gcc/config/ip2k/ip2k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fip2k%2Fip2k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fip2k%2Fip2k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -5089,7 +5089,7 @@\n \n ;; Nop instruction.\n ;;\n-;; We don't really want nops to appear in our code so just insert an comment.\n+;; We don't really want nops to appear in our code so just insert a comment.\n ;;\n (define_insn \"nop\"\n   [(const_int 0)]"}, {"sha": "5cd7384119ff0337df26168f5c2f2a3f1215ae3d", "filename": "gcc/config/m68hc11/m68hc11-crt0.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -74,7 +74,7 @@ _start:\n \t.sect\t.install2,\"ax\",@progbits\n ;;\n ;; Call a specific initialization operation.  The default is empty.\n-;; It can be overriden by applications.  It is intended to initialize\n+;; It can be overridden by applications.  It is intended to initialize\n ;; the 68hc11 registers.  Function prototype is:\n ;; \n ;;\tint __premain(void);"}, {"sha": "6911b41d150461879c94d445c3e00396e0242d49", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -47,7 +47,7 @@ Boston, MA 02111-1307, USA.\n #endif\n \n /* We need to tell the linker the target elf format.  Just pass an\n-   emulation option.  This can be overriden by -Wl option of gcc.  */\n+   emulation option.  This can be overridden by -Wl option of gcc.  */\n #ifndef LINK_SPEC\n #define LINK_SPEC      \"%{m68hc12:-m m68hc12elf}%{!m68hc12:-m m68hc11elf} %{mrelax:-relax}\"\n #endif"}, {"sha": "db1a8922dfefdd4a7d55b4ced9ae4535fe6d51b8", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -6820,7 +6820,7 @@\n \n ;;;\n ;;; Catch an xgdx/xgdy followed by a (set D X/Y). If X/Y is dead, we don't\n-;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.\n+;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.\n ;;;\n (define_peephole\n   [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))\n@@ -6836,7 +6836,7 @@\n \n ;;;\n ;;; Catch an xgdx/xgdy followed by a (set D X/Y). If X/Y is dead, we don't\n-;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.\n+;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.\n ;;;\n (define_peephole\n   [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 \"hard_reg_operand\" \"A\"))"}, {"sha": "a9f09dd42bbda7b152d1c8d966e24667a25550d5", "filename": "gcc/config/m68hc11/m68hc12.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #define CC1_SPEC       \"\"\n \n /* We need to tell the linker the target elf format.  Just pass an\n-   emulation option.  This can be overriden by -Wl option of gcc.  */\n+   emulation option.  This can be overridden by -Wl option of gcc.  */\n #define LINK_SPEC      \"%{m68hc11:-m m68hc11elf}%{!m68hc11:-m m68hc12elf}\"\n \n #define CPP_SPEC  \\"}, {"sha": "dd1c614dbf175619fdc693b453782a75f7458a6a", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -150,7 +150,7 @@\n ;; ;    This is done to allow bit field masks to fold together in combine.\n ;; ;    The reload phase will force the immediate into a register at the\n ;; ;    very end.  This helps in some cases, but hurts in others: we'd\n-;; ;    really like to cse these immediates.  However, there is an phase\n+;; ;    really like to cse these immediates.  However, there is a phase\n ;; ;    ordering problem here.  cse picks up individual masks and cse's\n ;; ;    those, but not folded masks (cse happens before combine).  It's\n ;; ;    not clear what the best solution is because we really want cse"}, {"sha": "6fb7eb4057c2216feeecd10b32bd255f09688912", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -5688,7 +5688,7 @@ mips_debugger_offset (addr, offset)\n    '^'\tPrint the name of the pic call-through register (t9 or $25).\n    '$'\tPrint the name of the stack pointer register (sp or $29).\n    '+'\tPrint the name of the gp register (gp or $28).\n-   '~'\tOutput an branch alignment to LABEL_ALIGN(NULL).  */\n+   '~'\tOutput a branch alignment to LABEL_ALIGN(NULL).  */\n \n void\n print_operand (file, op, letter)"}, {"sha": "3d2d617f69db378972110ecde0d7b857eed16f7c", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -1282,7 +1282,7 @@\n \t\t\t       (const_int 8))\n \t\t (const_int 4)])])\n \n-;; On the mips16, we can sometimes split an subtract of a constant\n+;; On the mips16, we can sometimes split a subtract of a constant\n ;; which is a 4 byte instruction into two adds which are both 2 byte\n ;; instructions.  There are two cases: one where we are setting a\n ;; register to a register minus a constant, and one where we are"}, {"sha": "001a04dce774c3a445335fab62df472b004780c0", "filename": "gcc/config/mmix/mmix-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmmix%2Fmmix-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fmmix%2Fmmix-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-modes.def?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -34,7 +34,7 @@ Boston, MA 02111-1307, USA.  */\n    the CMPU insn.  Result values correspond to those in CCmode.  */\n CC (CC_UNS)\n \n-/* The CC_FP mode is for an non-equality floating-point comparison, using\n+/* The CC_FP mode is for a non-equality floating-point comparison, using\n    the FCMP or FCMPE insn.  The result is (integer) -1 or 1 for\n    espectively a < b and a > b, otherwise 0.  */\n CC (CC_FP)"}, {"sha": "cd52977abb67abd8f4e78ce17c47137a2507c1b2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -1458,7 +1458,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n      use scratch_reg to hold the address of the memory location.\n \n      The proper fix is to change PREFERRED_RELOAD_CLASS to return\n-     NO_REGS when presented with a const_int and an register class\n+     NO_REGS when presented with a const_int and a register class\n      containing only FP registers.  Doing so unfortunately creates\n      more problems than it solves.   Fix this for 2.5.  */\n   else if (fp_reg_operand (operand0, mode)\n@@ -4300,7 +4300,7 @@ print_operand (file, x, code)\n \tfputs (\"\\n\\tnop\", file);\n       return;\n     case '*':\n-      /* Output an nullification completer if there's nothing for the */\n+      /* Output a nullification completer if there's nothing for the */\n       /* delay slot or nullification is requested.  */\n       if (dbr_sequence_length () == 0 ||\n \t  (final_sequence &&\n@@ -5428,7 +5428,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  strcat (buf, \" %2,%r1,%0\");\n \tbreak;\n \n-     /* All long conditionals.  Note an short backward branch with an\n+     /* All long conditionals.  Note a short backward branch with an\n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n       case 8:\n@@ -5650,7 +5650,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t  strcat (buf, \" %0,%1,%2\");\n \tbreak;\n \n-     /* All long conditionals.  Note an short backward branch with an\n+     /* All long conditionals.  Note a short backward branch with an\n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n       case 8:\n@@ -5798,7 +5798,7 @@ output_bvb (operands, nullify, length, negated, insn, which)\n \t  strcat (buf, \"{ %0,%2| %0,%%sar,%2}\");\n \tbreak;\n \n-     /* All long conditionals.  Note an short backward branch with an\n+     /* All long conditionals.  Note a short backward branch with an\n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n       case 8:"}, {"sha": "6ca020966a1953574acded69f911b01e7b12c305", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -2349,7 +2349,7 @@ rs6000_legitimize_reload_address (x, mode, opnum, type, ind_levels, win)\n    refers to a constant pool entry of an address (or the sum of it\n    plus a constant), a short (16-bit signed) constant plus a register,\n    the sum of two registers, or a register indirect, possibly with an\n-   auto-increment.  For DFmode and DImode with an constant plus register,\n+   auto-increment.  For DFmode and DImode with a constant plus register,\n    we must ensure that both words are addressable or PowerPC64 with offset\n    word aligned.\n "}, {"sha": "27954f2d2f2ed386ace0bcf58778dc8e2c30ba90", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -2021,7 +2021,7 @@ typedef struct rs6000_args\n    refers to a constant pool entry of an address (or the sum of it\n    plus a constant), a short (16-bit signed) constant plus a register,\n    the sum of two registers, or a register indirect, possibly with an\n-   auto-increment.  For DFmode and DImode with an constant plus register,\n+   auto-increment.  For DFmode and DImode with a constant plus register,\n    we must ensure that both words are addressable or PowerPC64 with offset\n    word aligned.\n "}, {"sha": "85d918235e84ffa1a86eb2b88de186e763e5b504", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -3306,7 +3306,7 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-;; Split an logical operation that we can't do in one insn into two insns, \n+;; Split a logical operation that we can't do in one insn into two insns, \n ;; each of which does one 16-bit part.  This is used by combine.\n \n (define_split\n@@ -7980,7 +7980,7 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-;; Split an logical operation that we can't do in one insn into two insns, \n+;; Split a logical operation that we can't do in one insn into two insns, \n ;; each of which does one 16-bit part.  This is used by combine.\n \n (define_split"}, {"sha": "eace82abe94f195cebd93c83470ee6e5ca24e15d", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -264,7 +264,7 @@ function_cannot_inline_p (fndecl)\n     }\n \n   /* If the function has a target specific attribute attached to it,\n-     then we assume that we should not inline it.  This can be overriden\n+     then we assume that we should not inline it.  This can be overridden\n      by the target if it defines TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P.  */\n   if (!function_attribute_inlinable_p (fndecl))\n     return N_(\"function with target specific attribute(s) cannot be inlined\");"}, {"sha": "ffa653ba877eaac7c7d4b413ab80c486f577e999", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5bdc58781b801d4ec1cf6c9971d7e95bf3d2d26c", "patch": "@@ -5418,7 +5418,7 @@ default_binds_local_p_1 (exp, shlib)\n }\n \n /* Determine whether or not a pointer mode is valid. Assume defaults\n-   of ptr_mode or Pmode - can be overriden.  */\n+   of ptr_mode or Pmode - can be overridden.  */\n bool\n default_valid_pointer_mode (mode)\n      enum machine_mode mode;"}]}