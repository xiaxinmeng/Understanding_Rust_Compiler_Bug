{"sha": "afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZkODJlZjVhYjk3YjQ3Y2JiOTQxM2RhNjRhOGJmNjkyOWNhZjI1YQ==", "commit": {"author": {"name": "Doug Kwan", "email": "dougkwan@google.com", "date": "2007-10-05T05:35:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-10-05T05:35:46Z"}, "message": "gthr-posix.h (__gthread_cond_broadcast, [...]): Add to extend interface for POSIX conditional variables.\n\n2007-09-13  Doug Kwan  <dougkwan@google.com>\n\n        * gcc/gthr-posix.h (__gthread_cond_broadcast, __gthread_cond_wait,\n        __gthread_cond_wait_recursive): Add to extend interface for POSIX\n        conditional variables. (__GTHREAD_HAS_COND): Macro defined to signify\n        support of conditional variables.\n        * gcc/gthr-posix95.h (__gthread_cond_broadcast, __gthread_cond_wait,\n        __gthread_cond_wait_recursive): Add to extend interface for POSIX\n        conditional variables. (__GTHREAD_HAS_COND): Macro defined to signify\n        support of conditional variables.\n        * gcc/gthr-single.h (__gthread_cond_broadcast, __gthread_cond_wait,\n        __gthread_cond_wait_recursive): Add to extend interface for POSIX\n        conditional variables.\n        * gcc/gthr.h: Update comments to document new interface.\n        * libstdc++-v3/include/ext/concurrent.h (class __mutex,\n        class __recursive_mutex): Add new method gthread_mutex to access\n        inner gthread mutex.\n        [__GTHREAD_HAS_COND] (class __concurrence_broadcast_error,\n        class __concurrence_wait_error, class __cond): Add.\n        * guard.cc (recursive_push, recursive_pop): Delete.\n        (init_in_progress_flag, set_init_in_progress_flag): Add to\n        replace recursive_push and recursive_pop.\n        (throw_recursive_init_exception): Add.\n        (acquire, __cxa_guard_acquire, __cxa_guard_abort and\n        __cxa_guard_release): [__GTHREAD_HAS_COND] Use a conditional\n        for synchronization of static variable initialization.\n        The global mutex is only held briefly when guards are\n        accessed. [!__GTHREAD_HAS_COND] Fall back to the old code,\n        which deadlocks.\n        * testsuite/thread/guard.cc: Add new test. It deadlocks with the\n        old locking code in libstdc++-v3/libsup++/guard.cc.\n\nFrom-SVN: r129030", "tree": {"sha": "7199ead87b016c417595eb8799a0e2e438399c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7199ead87b016c417595eb8799a0e2e438399c58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/comments", "author": {"login": "dougkwan", "id": 1399231, "node_id": "MDQ6VXNlcjEzOTkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1399231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dougkwan", "html_url": "https://github.com/dougkwan", "followers_url": "https://api.github.com/users/dougkwan/followers", "following_url": "https://api.github.com/users/dougkwan/following{/other_user}", "gists_url": "https://api.github.com/users/dougkwan/gists{/gist_id}", "starred_url": "https://api.github.com/users/dougkwan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dougkwan/subscriptions", "organizations_url": "https://api.github.com/users/dougkwan/orgs", "repos_url": "https://api.github.com/users/dougkwan/repos", "events_url": "https://api.github.com/users/dougkwan/events{/privacy}", "received_events_url": "https://api.github.com/users/dougkwan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "90e965bb845a73148758d4639058a59ad0801a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e965bb845a73148758d4639058a59ad0801a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e965bb845a73148758d4639058a59ad0801a06"}], "stats": {"total": 497, "additions": 454, "deletions": 43}, "files": [{"sha": "3dabeea2f41c4e3c7aca25b407ca83328cc8b1d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -1,3 +1,18 @@\n+2007-10-04  Doug Kwan  <dougkwan@google.com>\n+\n+\t* gthr-posix.h (__gthread_cond_broadcast, __gthread_cond_wait,\n+\t__gthread_cond_wait_recursive): Add to extend interface for POSIX\n+\tconditional variables. (__GTHREAD_HAS_COND): Macro defined to signify\n+\tsupport of conditional variables.\n+\t* gthr-posix95.h (__gthread_cond_broadcast, __gthread_cond_wait,\n+\t__gthread_cond_wait_recursive): Add to extend interface for POSIX\n+\tconditional variables. (__GTHREAD_HAS_COND): Macro defined to signify\n+\tsupport of conditional variables.\n+\t* gthr-single.h (__gthread_cond_broadcast, __gthread_cond_wait,\n+\t__gthread_cond_wait_recursive): Add to extend interface for POSIX\n+\tconditional variables.\n+\t* gthr.h: Update comments to document new interface.\n+\n 2007-10-04  Geoffrey Keating  <geoffk@apple.com>\n \n \t* cgraphunit.c (cgraph_build_static_cdtor): Don't set"}, {"sha": "5c00cd308623620048c1b37357559aaa2456de2f", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -47,6 +47,11 @@ typedef pthread_key_t __gthread_key_t;\n typedef pthread_once_t __gthread_once_t;\n typedef pthread_mutex_t __gthread_mutex_t;\n typedef pthread_mutex_t __gthread_recursive_mutex_t;\n+typedef pthread_cond_t __gthread_cond_t;\n+\n+/* POSIX like conditional variables are supported.  Please look at comments\n+   in gthr.h for details. */\n+#define __GTHREAD_HAS_COND\t1\t\n \n #define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n #define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n@@ -57,6 +62,7 @@ typedef pthread_mutex_t __gthread_recursive_mutex_t;\n #else\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n #endif\n+#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # ifndef __gthrw_pragma\n@@ -88,6 +94,8 @@ __gthrw3(pthread_mutex_lock)\n __gthrw3(pthread_mutex_trylock)\n __gthrw3(pthread_mutex_unlock)\n __gthrw3(pthread_mutex_init)\n+__gthrw3(pthread_cond_broadcast)\n+__gthrw3(pthread_cond_wait)\n #else\n __gthrw(pthread_once)\n __gthrw(pthread_getspecific)\n@@ -98,6 +106,8 @@ __gthrw(pthread_mutex_lock)\n __gthrw(pthread_mutex_trylock)\n __gthrw(pthread_mutex_unlock)\n __gthrw(pthread_mutex_init)\n+__gthrw(pthread_cond_broadcast)\n+__gthrw(pthread_cond_wait)\n #endif\n \n __gthrw(pthread_key_create)\n@@ -110,20 +120,16 @@ __gthrw(pthread_mutexattr_destroy)\n #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n /* Objective-C.  */\n #if defined(__osf__) && defined(_PTHREAD_USE_MANGLED_NAMES_)\n-__gthrw3(pthread_cond_broadcast)\n __gthrw3(pthread_cond_destroy)\n __gthrw3(pthread_cond_init)\n __gthrw3(pthread_cond_signal)\n-__gthrw3(pthread_cond_wait)\n __gthrw3(pthread_exit)\n __gthrw3(pthread_mutex_destroy)\n __gthrw3(pthread_self)\n #else\n-__gthrw(pthread_cond_broadcast)\n __gthrw(pthread_cond_destroy)\n __gthrw(pthread_cond_init)\n __gthrw(pthread_cond_signal)\n-__gthrw(pthread_cond_wait)\n __gthrw(pthread_exit)\n __gthrw(pthread_mutex_destroy)\n __gthrw(pthread_self)\n@@ -737,6 +743,25 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n   return __gthread_mutex_unlock (mutex);\n }\n \n+static inline int\n+__gthread_cond_broadcast (__gthread_cond_t *cond)\n+{\n+  return __gthrw_(pthread_cond_broadcast) (cond);\n+}\n+\n+static inline int\n+__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex)\n+{\n+  return __gthrw_(pthread_cond_wait) (cond, mutex);\n+}\n+\n+static inline int\n+__gthread_cond_wait_recursive (__gthread_cond_t *cond,\n+\t\t\t       __gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_cond_wait (cond, mutex);\n+}\n+\n #endif /* _LIBOBJC */\n \n #endif /* ! GCC_GTHR_POSIX_H */"}, {"sha": "df250d2bf4106a3e2aba7949677a0d2abdb392de", "filename": "gcc/gthr-posix95.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -45,6 +45,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n typedef pthread_key_t __gthread_key_t;\n typedef pthread_once_t __gthread_once_t;\n typedef pthread_mutex_t __gthread_mutex_t;\n+typedef pthread_cond_t __gthread_cond_t;\n+\n+/* POSIX like conditional variables are supported.  Please look at comments\n+   in gthr.h for details. */\n+#define __GTHREAD_HAS_COND\t1\n \n typedef struct {\n   long depth;\n@@ -55,6 +60,7 @@ typedef struct {\n #define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n #define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n+#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n # define __gthrw(name) \\\n@@ -81,14 +87,14 @@ __gthrw(pthread_mutexattr_init)\n __gthrw(pthread_mutexattr_destroy)\n \n __gthrw(pthread_mutex_init)\n+__gthrw(pthread_cond_broadcast)\n+__gthrw(pthread_cond_wait)\n \n #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n /* Objective-C.  */\n-__gthrw(pthread_cond_broadcast)\n __gthrw(pthread_cond_destroy)\n __gthrw(pthread_cond_init)\n __gthrw(pthread_cond_signal)\n-__gthrw(pthread_cond_wait)\n __gthrw(pthread_exit)\n __gthrw(pthread_mutex_destroy)\n #ifdef _POSIX_PRIORITY_SCHEDULING\n@@ -719,6 +725,25 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n   return 0;\n }\n \n+static inline int\n+__gthread_cond_broadcast (__gthread_cond_t *cond)\n+{\n+  return __gthrw_(pthread_cond_broadcast) (cond);\n+}\n+\n+static inline int\n+__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex)\n+{\n+  return __gthrw_(pthread_cond_wait) (cond, mutex);\n+}\n+\n+static inline int\n+__gthread_cond_wait_recursive (__gthread_cond_t *cond,\n+\t\t\t       __gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthrw_(pthread_cond_wait) (cond, mutex->actual);\n+}\n+\n #endif /* _LIBOBJC */\n \n #endif /* ! GCC_GTHR_POSIX_H */"}, {"sha": "56fd3a791761f5544dadbddc1c2fc37385452184", "filename": "gcc/gthr-single.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr-single.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr-single.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-single.h?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -251,6 +251,25 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n   return __gthread_mutex_unlock (mutex);\n }\n \n+static inline int\n+__gthread_cond_broadcast (__gthread_cond_t cond)\n+{\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_wait (__gthread_cond_t cond, __gthread_mutex_t *mutex)\n+{\n+  return 0;\n+}\n+\n+static inline int\n+__gthread_cond_wait_recursive (__gthread_cond_t cond,\n+\t\t\t       __gthread_recursive_mutex_t *mutex)\n+{\n+  return 0;\n+}\n+\n #endif /* _LIBOBJC */\n \n #undef UNUSED"}, {"sha": "a37b91199226135a238ca51705f68b0e0a8bde75", "filename": "gcc/gthr.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/gcc%2Fgthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr.h?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -81,6 +81,24 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      int __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);\n      int __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);\n \n+   The following are supported in POSIX threads only. They are required to\n+   fix a deadlock in static initialization inside libsupc++. The header file\n+   gthr-posix.h defines a symbol __GTHREAD_HAS_COND to signify that these extra\n+   features are supported.\n+\n+   Types:\n+     __gthread_cond_t\n+\n+   Macros:\n+     __GTHREAD_COND_INIT\n+     __GTHREAD_COND_INIT_FUNCTION\n+\n+   Interface:\n+     int __gthread_cond_broadcast (__gthread_cond_t *cond);\n+     int __gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex);\n+     int __gthread_cond_wait_recursive (__gthread_cond_t *cond,\n+\t\t\t\t\t__gthread_recursive_mutex_t *mutex);\n+\n    All functions returning int should return zero on success or the error\n    number.  If the operation is not supported, -1 is returned.\n "}, {"sha": "cfd6c2f54be59559f2f0cd3544e1a90b560f16d6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -1,3 +1,23 @@\n+2007-10-04  Doug Kwan  <dougkwan@google.com>\n+\n+\t* include/ext/concurrent.h (class __mutex,\n+\tclass __recursive_mutex): Add new method gthread_mutex to access\n+\tinner gthread mutex.\n+\t[__GTHREAD_HAS_COND] (class __concurrence_broadcast_error,\n+\tclass __concurrence_wait_error, class __cond): Add.\n+\t* libsupc++/guard.cc (recursive_push, recursive_pop): Delete.\n+\t(init_in_progress_flag, set_init_in_progress_flag): Add to\n+\treplace recursive_push and recursive_pop.\n+\t(throw_recursive_init_exception): Add.\n+\t(acquire, __cxa_guard_acquire, __cxa_guard_abort and\n+\t__cxa_guard_release): [__GTHREAD_HAS_COND] Use a conditional\n+\tfor synchronization of static variable initialization.\n+\tThe global mutex is only held briefly when guards are\n+\taccessed. [!__GTHREAD_HAS_COND] Fall back to the old code,\n+\twhich deadlocks.\n+\t* testsuite/thread/guard.cc: Add new test. It deadlocks with the\n+\told locking code in libstdc++-v3/libsup++/guard.cc.\n+\n 2007-10-04  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:"}, {"sha": "765b93dbdc29c964046277829a59c10f44a69c6c", "filename": "libstdc++-v3/include/ext/concurrence.h", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fconcurrence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fconcurrence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fconcurrence.h?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -81,6 +81,22 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     { return \"__gnu_cxx::__concurrence_unlock_error\"; }\n   };\n \n+  class __concurrence_broadcast_error : public std::exception\n+  {\n+  public:\n+    virtual char const*\n+    what() const throw()\n+    { return \"__gnu_cxx::__concurrence_broadcast_error\"; }\n+  };\n+\n+  class __concurrence_wait_error : public std::exception\n+  {\n+  public:\n+    virtual char const*\n+    what() const throw()\n+    { return \"__gnu_cxx::__concurrence_wait_error\"; }\n+  };\n+\n   // Substitute for concurrence_error object in the case of -fno-exceptions.\n   inline void\n   __throw_concurrence_lock_error()\n@@ -102,6 +118,28 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n #endif\n   }\n \n+#ifdef __GTHREAD_HAS_COND\n+  inline void\n+  __throw_concurrence_broadcast_error()\n+  {\n+#if __EXCEPTIONS\n+    throw __concurrence_broadcast_error();\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+\n+  inline void\n+  __throw_concurrence_wait_error()\n+  {\n+#if __EXCEPTIONS\n+    throw __concurrence_wait_error();\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+#endif\n+ \n   class __mutex \n   {\n   private:\n@@ -147,6 +185,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t}\n #endif\n     }\n+\n+    __gthread_mutex_t* gthread_mutex(void)\n+      { return &_M_mutex; }\n   };\n \n   class __recursive_mutex \n@@ -194,6 +235,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t}\n #endif\n     }\n+\n+    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)\n+      { return &_M_mutex; }\n   };\n \n   /// @brief  Scoped lock idiom.\n@@ -218,6 +262,66 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     { _M_device.unlock(); }\n   };\n \n+#ifdef __GTHREAD_HAS_COND\n+  class __cond\n+  {\n+  private:\n+    __gthread_cond_t _M_cond;\n+\n+    __cond(const __cond&);\n+    __cond& operator=(const __cond&);\n+\n+  public:\n+    __cond() \n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+#if defined __GTHREAD_COND_INIT\n+\t  __gthread_cond_t __tmp = __GTHREAD_COND_INIT;\n+\t  _M_cond = __tmp;\n+#else\n+\t  __GTHREAD_MUTEX_INIT_FUNCTION(&_M_cond);\n+#endif\n+\t}\n+#endif \n+    }\n+\n+    void broadcast()\n+    {\n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+\t  if (__gthread_cond_broadcast(&_M_cond) != 0)\n+\t    __throw_concurrence_broadcast_error();\n+\t}\n+#endif\n+    }\n+\n+    void wait(__mutex *mutex)\n+    {\n+#if __GTHREADS\n+      {\n+\t  if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)\n+\t    __throw_concurrence_wait_error();\n+      }\n+#endif\n+    }\n+\n+    void wait_recursive(__recursive_mutex *mutex)\n+    {\n+#if __GTHREADS\n+      {\n+\t  if (__gthread_cond_wait_recursive(&_M_cond,\n+\t\t\t\t\t    mutex->gthread_recursive_mutex())\n+\t      != 0)\n+\t    __throw_concurrence_wait_error();\n+      }\n+#endif\n+    }\n+  };\n+#endif\n+\n _GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "b714aec24ebbf8035cc68b12d98d935b631b0b0a", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 155, "deletions": 37, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -62,6 +62,28 @@ namespace\n   }\n }\n \n+namespace\n+{\n+  // A single conditional variable controlling all static initializations.\n+  static __gnu_cxx::__cond* static_cond;  \n+\n+  // using a fake type to avoid initializing a static class.\n+  typedef char fake_cond_t[sizeof(__gnu_cxx::__cond)]\n+  __attribute__ ((aligned(__alignof__(__gnu_cxx::__cond))));\n+  fake_cond_t fake_cond;\n+\n+  static void init_static_cond()\n+  { static_cond =  new (&fake_cond) __gnu_cxx::__cond(); }\n+\n+  __gnu_cxx::__cond&\n+  get_static_cond()\n+  {\n+    static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+    __gthread_once(&once, init_static_cond);\n+    return *static_cond;\n+  }\n+}\n+\n #ifndef _GLIBCXX_GUARD_TEST_AND_ACQUIRE\n inline bool\n __test_and_acquire (__cxxabiv1::__guard *g)\n@@ -110,34 +132,87 @@ namespace __gnu_cxx\n   recursive_init_error::~recursive_init_error() throw() { }\n }\n \n+//\n+// Here are C++ run-time routines for guarded initiailization of static\n+// variables. There are 4 scenarios under which these routines are called:\n+//\n+//   1. Threads not supported (__GTHREADS not defined)\n+//   2. Threads are supported but not enabled at run-time.\n+//   3. Threads enabled at run-time but __gthreads_* are not fully POSIX.\n+//   4. Threads enabled at run-time and __gthreads_* support all POSIX threads\n+//      primitives we need here.\n+//\n+// The old code supported scenarios 1-3 but was broken since it used a global\n+// mutex for all threads and had the mutex locked during the whole duration of\n+// initlization of a guarded static variable. The following created a dead-lock\n+// with the old code.\n+//\n+//\tThread 1 acquires the global mutex.\n+//\tThread 1 starts initializing static variable.\n+//\tThread 1 creates thread 2 during initialization.\n+//\tThread 2 attempts to acuqire mutex to initialize another variable.\n+//\tThread 2 blocks since thread 1 is locking the mutex.\n+//\tThread 1 waits for result from thread 2 and also blocks. A deadlock.\n+//\n+// The new code here can handle this situation and thus is more robust. Howere,\n+// we need to use the POSIX thread conditional variable, which is not supported\n+// in all platforms, notably older versions of Microsoft Windows. The gthr*.h\n+// headers define a symbol __GTHREAD_HAS_COND for platforms that support POSIX\n+// like conditional variables. For platforms that do not support conditional\n+// variables, we need to fall back to the old code.\n namespace __cxxabiv1 \n {\n   static inline int\n-  recursion_push (__guard* g)\n-  { return ((char *)g)[1]++; }\n+  init_in_progress_flag(__guard* g)\n+  { return ((char *)g)[1]; }\n \n   static inline void\n-  recursion_pop (__guard* g)\n-  { --((char *)g)[1]; }\n+  set_init_in_progress_flag(__guard* g, int v)\n+  { ((char *)g)[1] = v; }\n \n-  static int\n-  acquire (__guard *g)\n+  static inline void\n+  throw_recursive_init_exception()\n   {\n-    if (_GLIBCXX_GUARD_TEST (g))\n-      return 0;\n-\n-    if (recursion_push (g))\n-      {\n #ifdef __EXCEPTIONS\n \tthrow __gnu_cxx::recursive_init_error();\n #else\n \t// Use __builtin_trap so we don't require abort().\n-\t__builtin_trap ();\n+\t__builtin_trap();\n #endif\n-      }\n+  }\n+\n+  // acuire() is a helper function used to acquire guard if thread support is\n+  // not compiled in or is compiled in but not enabled at run-time.\n+  static int\n+  acquire(__guard *g)\n+  {\n+    // Quit if the object is already initialized.\n+    if (_GLIBCXX_GUARD_TEST(g))\n+      return 0;\n+\n+    if (init_in_progress_flag(g))\n+\tthrow_recursive_init_exception();\n+\n+    set_init_in_progress_flag(g, 1);\n     return 1;\n   }\n \n+  // Simple wrapper for exception safety.\n+  struct mutex_wrapper\n+  {\n+#ifdef __GTHREADS\n+    bool unlock;\n+    mutex_wrapper() : unlock(true)\n+    { get_static_mutex().lock(); }\n+\n+    ~mutex_wrapper()\n+    {\n+      if (unlock)\n+\tstatic_mutex->unlock();\n+    }\n+#endif\n+  };\n+\n   extern \"C\"\n   int __cxa_guard_acquire (__guard *g) \n   {\n@@ -150,28 +225,39 @@ namespace __cxxabiv1\n \n     if (__gthread_active_p ())\n       {\n-\t// Simple wrapper for exception safety.\n-\tstruct mutex_wrapper\n-\t{\n-\t  bool unlock;\n-\t  mutex_wrapper() : unlock(true)\n-\t  { get_static_mutex().lock(); }\n-\n-\t  ~mutex_wrapper()\n-\t  {\n-\t    if (unlock)\n-\t      static_mutex->unlock();\n-\t  }\n-\t};\n-\n \tmutex_wrapper mw;\n-\tif (acquire (g))\n+\n+\twhile (1)\t// When this loop is executing, mutex is locked.\n \t  {\n-\t    mw.unlock = false;\n-\t    return 1;\n-\t  }\n+#ifdef __GTHREAD_HAS_COND\n+\t    // The static is allready initialized.\n+\t    if (_GLIBCXX_GUARD_TEST(g))\n+\t      return 0;\t// The mutex will be unlocked via wrapper\n \n-\treturn 0;\n+\t    if (init_in_progress_flag(g))\n+\t      {\n+\t\t// The guarded static is currently being initialized by\n+\t\t// another thread, so we release mutex and wait for the\n+\t\t// conditional variable. We will lock the mutex again after\n+\t\t// this.\n+\t\tget_static_cond().wait_recursive(&get_static_mutex());\n+\t      }\n+\t    else\n+\t      {\n+\t\tset_init_in_progress_flag(g, 1);\n+\t\treturn 1; // The mutex will be unlocked via wrapper.\n+\t      }\n+#else\n+\t    // This provides compatibility with older systems not supporting\n+\t    // POSIX like conditional variables.\n+\t    if (acquire(g))\n+\t      {\n+\t\tmw.unlock = false;\n+\t\treturn 1; // The mutex still locked.\n+\t      }\n+\t    return 0; // The mutex will be unlocked via wrapper.\n+#endif\n+\t  }\n       }\n #endif\n \n@@ -181,8 +267,24 @@ namespace __cxxabiv1\n   extern \"C\"\n   void __cxa_guard_abort (__guard *g)\n   {\n-    recursion_pop (g);\n-#ifdef __GTHREADS\n+#ifdef __GTHREAD_HAS_COND\n+    if (__gthread_active_p())\n+      {\t\n+\tmutex_wrapper mw;\n+\n+\tset_init_in_progress_flag(g, 0);\n+\n+\t// If we abort, we still need to wake up all other threads waiting for\n+\t// the conditional variable.\n+        get_static_cond().broadcast();\n+\treturn;\n+      }\t\n+#endif\n+\n+    set_init_in_progress_flag(g, 0);\n+#if defined(__GTHREADS) && !defined(__GTHREAD_HAS_COND)\n+    // This provides compatibility with older systems not supporting POSIX like\n+    // conditional variables.\n     if (__gthread_active_p ())\n       static_mutex->unlock();\n #endif\n@@ -191,10 +293,26 @@ namespace __cxxabiv1\n   extern \"C\"\n   void __cxa_guard_release (__guard *g)\n   {\n-    recursion_pop (g);\n+#ifdef __GTHREAD_HAS_COND\n+    if (__gthread_active_p())\n+      {\n+\tmutex_wrapper mw;\n+\n+\tset_init_in_progress_flag(g, 0);\n+\t_GLIBCXX_GUARD_SET_AND_RELEASE(g);\n+\n+        get_static_cond().broadcast();\n+\treturn;\n+      }\t\n+#endif\n+\n+    set_init_in_progress_flag(g, 0);\n     _GLIBCXX_GUARD_SET_AND_RELEASE (g);\n-#ifdef __GTHREADS\n-    if (__gthread_active_p ())\n+\n+#if defined(__GTHREADS) && !defined(__GTHREAD_HAS_COND)\n+    // This provides compatibility with older systems not supporting POSIX like\n+    // conditional variables.\n+    if (__gthread_active_p())\n       static_mutex->unlock();\n #endif\n   }"}, {"sha": "0e9e827003d1c63f380ebd50e1df411f70f06a6b", "filename": "libstdc++-v3/testsuite/thread/guard.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd82ef5ab97b47cbb9413da64a8bf6929caf25a/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fthread%2Fguard.cc?ref=afd82ef5ab97b47cbb9413da64a8bf6929caf25a", "patch": "@@ -0,0 +1,67 @@\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* } }\n+// { dg-options \"-pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-darwin* alpha*-*-osf* } }\n+\n+#include <cstdlib>\n+#include <pthread.h>\n+\n+// This used to deadlock with the old libstdc++ because there is only one\n+// global mutex guarding initialization of statics and it is held during by\n+// the initializer thread of a static until the variable is completely\n+// initialized. If the initializer thread creates and waits for another thread\n+// which also initializes a static variable, there will be a deadlock because\n+// the first thread is holding the mutex and waiting for the second thread,\n+// which is blocked when it is acquiring the mutex.\n+\n+int\n+get_bar (void)\n+{\n+  return 1;\n+}\n+\n+void*\n+do_something (void *arg)\n+{\n+  static int bar = get_bar ();\n+  return NULL;\n+}\n+\n+int\n+get_foo (void)\n+{\n+  int status;\n+  pthread_t new_thread;\n+\n+  if (pthread_create (&new_thread, NULL, do_something, NULL) != 0)\n+    std::abort ();\n+\n+  if (pthread_join (new_thread, NULL) != 0)\n+    std::abort ();\n+\n+  return 1;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  static int foo = get_foo ();\n+  return 0;  \n+}"}]}