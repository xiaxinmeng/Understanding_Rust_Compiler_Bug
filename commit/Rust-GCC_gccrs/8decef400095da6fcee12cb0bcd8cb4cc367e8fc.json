{"sha": "8decef400095da6fcee12cb0bcd8cb4cc367e8fc", "node_id": "C_kwDOANBUbNoAKDhkZWNlZjQwMDA5NWRhNmZjZWUxMmNiMGJjZDhjYjRjYzM2N2U4ZmM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-11-17T13:19:45Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:26Z"}, "message": "[Ada] Enhance freezing code for instantiations\n\ngcc/ada/\n\n\t* sem_ch12.adb (Freeze_Package_Instance): Consistently consider\n\tthe freeze node of the parent and use large inequality for\n\tSlocs.\n\t(Freeze_Subprogram_Instance): Likewise.\n\t(Insert_Freeze_Node_For_Instance): For an instance in a package\n\tspec with no source body that immediately follows, consider the\n\tbody of the package for the placement of the freeze node and go\n\tto the outer level if there is no such body.", "tree": {"sha": "c3dadbc356d9f494bef21f8f7d91c77b64e8a19c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3dadbc356d9f494bef21f8f7d91c77b64e8a19c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8decef400095da6fcee12cb0bcd8cb4cc367e8fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8decef400095da6fcee12cb0bcd8cb4cc367e8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8decef400095da6fcee12cb0bcd8cb4cc367e8fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8decef400095da6fcee12cb0bcd8cb4cc367e8fc/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca89ac6e73026a8606e05e6f0486f963c02c4bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca89ac6e73026a8606e05e6f0486f963c02c4bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca89ac6e73026a8606e05e6f0486f963c02c4bc"}], "stats": {"total": 276, "additions": 158, "deletions": 118}, "files": [{"sha": "83ae95e9386e021eaa1479a6e64d500dbdbcb353", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 158, "deletions": 118, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8decef400095da6fcee12cb0bcd8cb4cc367e8fc/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8decef400095da6fcee12cb0bcd8cb4cc367e8fc/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8decef400095da6fcee12cb0bcd8cb4cc367e8fc", "patch": "@@ -732,9 +732,10 @@ package body Sem_Ch12 is\n    --  associated freeze node. Insert the freeze node before the first source\n    --  body which follows immediately after N. If no such body is found, the\n    --  freeze node is inserted at the end of the declarative region which\n-   --  contains N. This can also be invoked to insert the freeze node of a\n-   --  package that encloses an instantiation, in which case N may denote an\n-   --  arbitrary node.\n+   --  contains N, unless the instantiation is done in a package spec that is\n+   --  not at library level, in which case it is inserted at the outer level.\n+   --  This can also be invoked to insert the freeze node of a package that\n+   --  encloses an instantiation, in which case N may denote an arbitrary node.\n \n    procedure Install_Formal_Packages (Par : Entity_Id);\n    --  Install the visible part of any formal of the parent that is a formal\n@@ -9208,8 +9209,7 @@ package body Sem_Ch12 is\n                --  of a package declaration, and the inner instance is in\n                --  the corresponding private part.\n \n-               if Parent (List_Containing (Get_Unit_Instantiation_Node\n-                                                                     (Par_Id)))\n+               if Parent (List_Containing (Freeze_Node (Par_Id)))\n                     = Parent (List_Containing (N))\n                  and then Sloc (Freeze_Node (Par_Id)) <= Sloc (N)\n                then\n@@ -9266,7 +9266,8 @@ package body Sem_Ch12 is\n                      --  the body.\n \n                      elsif In_Same_List (Freeze_Node (Par_Id), Parent (N))\n-                       and then Sloc (Freeze_Node (Par_Id)) < Sloc (Parent (N))\n+                       and then\n+                         Sloc (Freeze_Node (Par_Id)) <= Sloc (Parent (N))\n                      then\n                         Insert_Freeze_Node_For_Instance\n                           (Parent (N), Freeze_Node (Enclosing));\n@@ -9403,7 +9404,7 @@ package body Sem_Ch12 is\n          --  after that of Parent_Inst. This relation is established by\n          --  comparing the Slocs of Parent_Inst freeze node and Inst.\n \n-         elsif In_Same_List (Get_Unit_Instantiation_Node (Par_Id), N)\n+         elsif In_Same_List (Freeze_Node (Par_Id), N)\n            and then Sloc (Freeze_Node (Par_Id)) <= Sloc (N)\n          then\n             Insert_Freeze_Node_For_Instance (N, F_Node);\n@@ -9844,12 +9845,6 @@ package body Sem_Ch12 is\n      (N      : Node_Id;\n       F_Node : Node_Id)\n    is\n-      Decl     : Node_Id;\n-      Decls    : List_Id;\n-      Inst     : Entity_Id;\n-      Par_Inst : Node_Id;\n-      Par_N    : Node_Id;\n-\n       function Enclosing_Body (N : Node_Id) return Node_Id;\n       --  Find enclosing package or subprogram body, if any. Freeze node may\n       --  be placed at end of current declarative list if previous instance\n@@ -9908,138 +9903,183 @@ package body Sem_Ch12 is\n          return Empty;\n       end Previous_Instance;\n \n+      --  Local variables\n+\n+      Decl     : Node_Id;\n+      Decls    : List_Id;\n+      Inst     : Entity_Id;\n+      Par_Inst : Node_Id;\n+      Par_N    : Node_Id;\n+\n    --  Start of processing for Insert_Freeze_Node_For_Instance\n \n    begin\n-      if not Is_List_Member (F_Node) then\n-         Decl  := N;\n-         Decls := List_Containing (N);\n-         Par_N := Parent (Decls);\n-         Inst  := Entity (F_Node);\n+      --  Nothing to do if the freeze node has already been inserted\n \n-         --  When processing a subprogram instantiation, utilize the actual\n-         --  subprogram instantiation rather than its package wrapper as it\n-         --  carries all the context information.\n+      if Is_List_Member (F_Node) then\n+         return;\n+      end if;\n \n-         if Is_Wrapper_Package (Inst) then\n-            Inst := Related_Instance (Inst);\n-         end if;\n+      Inst := Entity (F_Node);\n \n-         Par_Inst := Parent (Inst);\n+      --  When processing a subprogram instantiation, utilize the actual\n+      --  subprogram instantiation rather than its package wrapper as it\n+      --  carries all the context information.\n \n-         --  If this is a package instance, check whether the generic is\n-         --  declared in a previous instance and the current instance is\n-         --  not within the previous one.\n+      if Is_Wrapper_Package (Inst) then\n+         Inst := Related_Instance (Inst);\n+      end if;\n \n-         if Present (Generic_Parent (Par_Inst)) and then Is_In_Main_Unit (N)\n-         then\n-            declare\n-               Enclosing_N : constant Node_Id := Enclosing_Body (N);\n-               Par_I       : constant Entity_Id :=\n-                               Previous_Instance (Generic_Parent (Par_Inst));\n-               Scop        : Entity_Id;\n+      Par_Inst := Parent (Inst);\n \n-            begin\n-               if Present (Par_I)\n-                 and then Earlier (N, Freeze_Node (Par_I))\n-               then\n-                  Scop := Scope (Inst);\n-\n-                  --  If the current instance is within the one that contains\n-                  --  the generic, the freeze node for the current one must\n-                  --  appear in the current declarative part. Ditto, if the\n-                  --  current instance is within another package instance or\n-                  --  within a body that does not enclose the current instance.\n-                  --  In these three cases the freeze node of the previous\n-                  --  instance is not relevant.\n-\n-                  while Present (Scop) and then Scop /= Standard_Standard loop\n-                     exit when Scop = Par_I\n-                       or else\n-                         (Is_Generic_Instance (Scop)\n-                           and then Scope_Depth (Scop) > Scope_Depth (Par_I));\n-                     Scop := Scope (Scop);\n-                  end loop;\n+      --  If this is a package instance, check whether the generic is declared\n+      --  in a previous instance and the current instance is not within the\n+      --  previous one.\n \n-                  --  Previous instance encloses current instance\n+      if Present (Generic_Parent (Par_Inst)) and then Is_In_Main_Unit (N) then\n+         declare\n+            Enclosing_N : constant Node_Id   := Enclosing_Body (N);\n+            Par_I       : constant Entity_Id :=\n+                            Previous_Instance (Generic_Parent (Par_Inst));\n+            Scop        : Entity_Id;\n \n-                  if Scop = Par_I then\n-                     null;\n+         begin\n+            if Present (Par_I) and then Earlier (N, Freeze_Node (Par_I)) then\n+               Scop := Scope (Inst);\n \n-                  --  If the next node is a source body we must freeze in\n-                  --  the current scope as well.\n+               --  If the current instance is within the one that contains\n+               --  the generic, the freeze node for the current one must\n+               --  appear in the current declarative part. Ditto, if the\n+               --  current instance is within another package instance or\n+               --  within a body that does not enclose the current instance.\n+               --  In these three cases the freeze node of the previous\n+               --  instance is not relevant.\n \n-                  elsif Present (Next (N))\n-                    and then Nkind (Next (N)) in N_Subprogram_Body\n-                                               | N_Package_Body\n-                    and then Comes_From_Source (Next (N))\n-                  then\n-                     null;\n+               while Present (Scop) and then Scop /= Standard_Standard loop\n+                  exit when Scop = Par_I\n+                    or else\n+                      (Is_Generic_Instance (Scop)\n+                        and then Scope_Depth (Scop) > Scope_Depth (Par_I));\n+                  Scop := Scope (Scop);\n+               end loop;\n \n-                  --  Current instance is within an unrelated instance\n+               --  Previous instance encloses current instance\n \n-                  elsif Is_Generic_Instance (Scop) then\n-                     null;\n+               if Scop = Par_I then\n+                  null;\n \n-                  --  Current instance is within an unrelated body\n+               --  If the next node is a source body we must freeze in the\n+               --  current scope as well.\n \n-                  elsif Present (Enclosing_N)\n-                    and then Enclosing_N /= Enclosing_Body (Par_I)\n-                  then\n-                     null;\n+               elsif Present (Next (N))\n+                 and then Nkind (Next (N)) in N_Subprogram_Body\n+                                            | N_Package_Body\n+                 and then Comes_From_Source (Next (N))\n+               then\n+                  null;\n \n-                  else\n-                     Insert_After (Freeze_Node (Par_I), F_Node);\n-                     return;\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n+               --  Current instance is within an unrelated instance\n \n-         --  When the instantiation occurs in a package declaration, append the\n-         --  freeze node to the private declarations (if any).\n+               elsif Is_Generic_Instance (Scop) then\n+                  null;\n \n-         if Nkind (Par_N) = N_Package_Specification\n-           and then Decls = Visible_Declarations (Par_N)\n-           and then not Is_Empty_List (Private_Declarations (Par_N))\n-         then\n-            Decls := Private_Declarations (Par_N);\n-            Decl  := First (Decls);\n-         end if;\n-\n-         --  Determine the proper freeze point of a package instantiation. We\n-         --  adhere to the general rule of a package or subprogram body causing\n-         --  freezing of anything before it in the same declarative region. In\n-         --  this case, the proper freeze point of a package instantiation is\n-         --  before the first source body which follows, or before a stub. This\n-         --  ensures that entities coming from the instance are already frozen\n-         --  and usable in source bodies.\n-\n-         if Nkind (Par_N) /= N_Package_Declaration\n-           and then Ekind (Inst) = E_Package\n-           and then Is_Generic_Instance (Inst)\n-           and then not In_Same_Source_Unit (Generic_Parent (Par_Inst), Inst)\n-         then\n-            while Present (Decl) loop\n-               if (Nkind (Decl) in N_Unit_Body\n-                     or else\n-                   Nkind (Decl) in N_Body_Stub)\n-                 and then Comes_From_Source (Decl)\n+               --  Current instance is within an unrelated body\n+\n+               elsif Present (Enclosing_N)\n+                 and then Enclosing_N /= Enclosing_Body (Par_I)\n                then\n-                  Insert_Before (Decl, F_Node);\n+                  null;\n+\n+               else\n+                  Insert_After (Freeze_Node (Par_I), F_Node);\n                   return;\n                end if;\n+            end if;\n+         end;\n+      end if;\n \n-               Next (Decl);\n-            end loop;\n-         end if;\n+      Decl  := N;\n+      Decls := List_Containing (N);\n+      Par_N := Parent (Decls);\n \n-         --  In a package declaration, or if no previous body, insert at end\n-         --  of list.\n+      --  Determine the proper freeze point of an instantiation\n \n-         Set_Sloc (F_Node, Sloc (Last (Decls)));\n-         Insert_After (Last (Decls), F_Node);\n+      if Is_Generic_Instance (Inst) then\n+         loop\n+            --  When the instantiation occurs in a package spec, append the\n+            --  freeze node to the private declarations (if any).\n+\n+            if Nkind (Par_N) = N_Package_Specification\n+              and then Decls = Visible_Declarations (Par_N)\n+              and then not Is_Empty_List (Private_Declarations (Par_N))\n+            then\n+               Decls := Private_Declarations (Par_N);\n+               Decl  := First (Decls);\n+            end if;\n+\n+            --  We adhere to the general rule of a package or subprogram body\n+            --  causing freezing of anything before it in the same declarative\n+            --  region. In this respect, the proper freeze point of a package\n+            --  instantiation is before the first source body which follows, or\n+            --  before a stub. This ensures that entities from the instance are\n+            --  already frozen and therefore usable in source bodies.\n+\n+            if Nkind (Par_N) /= N_Package_Declaration\n+              and then\n+                not In_Same_Source_Unit (Generic_Parent (Par_Inst), Inst)\n+            then\n+               while Present (Decl) loop\n+                  if (Nkind (Decl) in N_Unit_Body\n+                        or else\n+                      Nkind (Decl) in N_Body_Stub)\n+                    and then Comes_From_Source (Decl)\n+                  then\n+                     Set_Sloc (F_Node, Sloc (Decl));\n+                     Insert_Before (Decl, F_Node);\n+                     return;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop;\n+            end if;\n+\n+            --  When the instantiation occurs in a package spec and there is\n+            --  no source body which follows, and the package has a body but\n+            --  is delayed, then insert immediately before its freeze node.\n+\n+            if Nkind (Par_N) = N_Package_Specification\n+              and then Present (Corresponding_Body (Parent (Par_N)))\n+              and then Present (Freeze_Node (Defining_Entity (Par_N)))\n+            then\n+               Set_Sloc (F_Node, Sloc (Freeze_Node (Defining_Entity (Par_N))));\n+               Insert_Before (Freeze_Node (Defining_Entity (Par_N)), F_Node);\n+               return;\n+\n+            --  When the instantiation occurs in a package spec and there is\n+            --  no source body which follows, not even of the package itself\n+            --  then insert into the declaration list of the outer level.\n+\n+            elsif Nkind (Par_N) = N_Package_Specification\n+              and then No (Corresponding_Body (Parent (Par_N)))\n+              and then Is_List_Member (Parent (Par_N))\n+            then\n+               Decl  := Parent (Par_N);\n+               Decls := List_Containing (Decl);\n+               Par_N := Parent (Decls);\n+\n+            --  In a package declaration, or if no source body which follows\n+            --  and at library level, then insert at end of list.\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n       end if;\n+\n+      --  Insert and adjust the Sloc of the freeze node\n+\n+      Set_Sloc (F_Node, Sloc (Last (Decls)));\n+      Insert_After (Last (Decls), F_Node);\n    end Insert_Freeze_Node_For_Instance;\n \n    -----------------------------"}]}