{"sha": "687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg3ZDVkZmUxNjVmNzA1Y2IwYjg2M2ZiZTFmODBiZjc3YzFiNjU1OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-04-09T16:33:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-04-09T16:33:51Z"}, "message": "re PR rtl-optimization/84058 (RTl partitioning fixup should drag very small blocks back to hot partition)\n\n\tPR rtl/84058\n\t* cfgcleanup.c (try_forward_edges): Do not give up on crossing\n\tjumps; choose last target that matches the criteria (i.e.\n\tno partition changes for non-crossing jumps).\n\t* cfgrtl.c (cfg_layout_redirect_edge_and_branch): Add basic\n\tsupport for redirecting crossing jumps to non-crossing.\n\nFrom-SVN: r259244", "tree": {"sha": "dce4694dfb3079937dc98a9e1ac671479324509d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dce4694dfb3079937dc98a9e1ac671479324509d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/comments", "author": null, "committer": null, "parents": [{"sha": "13c60208d0428ad14b4bd41a63a47d67bd35253f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c60208d0428ad14b4bd41a63a47d67bd35253f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c60208d0428ad14b4bd41a63a47d67bd35253f"}], "stats": {"total": 65, "additions": 32, "deletions": 33}, "files": [{"sha": "601a9ab86cf218c9c1ab00cee721beb0b018d9c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "patch": "@@ -1,3 +1,12 @@\n+2018-04-09  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR rtl/84058\n+\t* cfgcleanup.c (try_forward_edges): Do not give up on crossing\n+\tjumps; choose last target that matches the criteria (i.e.\n+\tno partition changes for non-crossing jumps).\n+\t* cfgrtl.c (cfg_layout_redirect_edge_and_branch): Add basic\n+\tsupport for redirecting crossing jumps to non-crossing.\n+\n 2018-04-09  Alexey Brodkin  <abrodkin@synopsys.com>\n \n \t* config/arc/arc.c (arc_expand_prologue): Set stack usage info"}, {"sha": "4a5dc29d14fb7ab7abf70a89a7512b4c4edc1440", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "patch": "@@ -394,19 +394,6 @@ try_forward_edges (int mode, basic_block b)\n   edge_iterator ei;\n   edge e, *threaded_edges = NULL;\n \n-  /* If we are partitioning hot/cold basic blocks, we don't want to\n-     mess up unconditional or indirect jumps that cross between hot\n-     and cold sections.\n-\n-     Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really\n-     must be left untouched (they are required to make it safely across\n-     partition boundaries).  See the comments at the top of\n-     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n-\n-  if (JUMP_P (BB_END (b)) && CROSSING_JUMP_P (BB_END (b)))\n-    return false;\n-\n   for (ei = ei_start (b->succs); (e = ei_safe_edge (ei)); )\n     {\n       basic_block target, first;\n@@ -415,6 +402,7 @@ try_forward_edges (int mode, basic_block b)\n       bool threaded = false;\n       int nthreaded_edges = 0;\n       bool may_thread = first_pass || (b->flags & BB_MODIFIED) != 0;\n+      bool new_target_threaded = false;\n \n       /* Skip complex edges because we don't know how to update them.\n \n@@ -431,29 +419,12 @@ try_forward_edges (int mode, basic_block b)\n       counter = NUM_FIXED_BLOCKS;\n       goto_locus = e->goto_locus;\n \n-      /* If we are partitioning hot/cold basic_blocks, we don't want to mess\n-\t up jumps that cross between hot/cold sections.\n-\n-\t Basic block partitioning may result in some jumps that appear\n-\t to be optimizable (or blocks that appear to be mergeable), but which\n-\t really must be left untouched (they are required to make it safely\n-\t across partition boundaries).  See the comments at the top of\n-\t bb-reorder.c:partition_hot_cold_basic_blocks for complete\n-\t details.  */\n-\n-      if (first != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t  && JUMP_P (BB_END (first))\n-\t  && CROSSING_JUMP_P (BB_END (first)))\n-\treturn changed;\n-\n       while (counter < n_basic_blocks_for_fn (cfun))\n \t{\n \t  basic_block new_target = NULL;\n-\t  bool new_target_threaded = false;\n \t  may_thread |= (target->flags & BB_MODIFIED) != 0;\n \n \t  if (FORWARDER_BLOCK_P (target)\n-\t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n \t      && single_succ (target) != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      /* Bypass trivial infinite loops.  */\n@@ -543,8 +514,14 @@ try_forward_edges (int mode, basic_block b)\n \t    break;\n \n \t  counter++;\n-\t  target = new_target;\n-\t  threaded |= new_target_threaded;\n+\t  /* Do not turn non-crossing jump to crossing.  Depending on target\n+\t     it may require different instruction pattern.  */\n+\t  if ((e->flags & EDGE_CROSSING)\n+\t      || BB_PARTITION (first) == BB_PARTITION (new_target))\n+\t    {\n+\t      target = new_target;\n+\t      threaded |= new_target_threaded;\n+\t    }\n \t}\n \n       if (counter >= n_basic_blocks_for_fn (cfun))"}, {"sha": "de704ce16d0640d26eebbab00d9428e42b0de762", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/687d5dfe165f705cb0b863fbe1f80bf77c1b6559/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=687d5dfe165f705cb0b863fbe1f80bf77c1b6559", "patch": "@@ -4361,6 +4361,18 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->dest == dest)\n     return e;\n \n+  if (e->flags & EDGE_CROSSING\n+      && BB_PARTITION (e->src) == BB_PARTITION (dest)\n+      && simplejump_p (BB_END (src)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t  \t \"Removing crossing jump while redirecting edge form %i to %i\\n\",\n+\t\t e->src->index, dest->index);\n+      delete_insn (BB_END (src));\n+      e->flags |= EDGE_FALLTHRU;\n+    }\n+\n   if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       && (ret = try_redirect_by_replacing_jump (e, dest, true)))\n     {\n@@ -4424,8 +4436,9 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   else\n     ret = redirect_branch_edge (e, dest);\n \n+  fixup_partition_crossing (ret);\n   /* We don't want simplejumps in the insn stream during cfglayout.  */\n-  gcc_assert (!simplejump_p (BB_END (src)));\n+  gcc_assert (!simplejump_p (BB_END (src)) || CROSSING_JUMP_P (BB_END (src)));\n \n   df_set_bb_dirty (src);\n   return ret;"}]}