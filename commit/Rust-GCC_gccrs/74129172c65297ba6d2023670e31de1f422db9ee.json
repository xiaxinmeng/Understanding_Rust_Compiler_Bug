{"sha": "74129172c65297ba6d2023670e31de1f422db9ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQxMjkxNzJjNjUyOTdiYTZkMjAyMzY3MGUzMWRlMWY0MjJkYjllZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2013-10-09T07:23:53Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-10-09T07:23:53Z"}, "message": "s390.c (s390_frame_info): Restructure function.\n\n2013-10-09  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/s390.c (s390_frame_info): Restructure function.\n\nFrom-SVN: r203304", "tree": {"sha": "8ae21d67f935b724942595930ce9381c2a4f8a9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ae21d67f935b724942595930ce9381c2a4f8a9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74129172c65297ba6d2023670e31de1f422db9ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74129172c65297ba6d2023670e31de1f422db9ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74129172c65297ba6d2023670e31de1f422db9ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74129172c65297ba6d2023670e31de1f422db9ee/comments", "author": null, "committer": null, "parents": [{"sha": "6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6455a49ed4fd8b6338cb21122722c0f7a26e83ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6455a49ed4fd8b6338cb21122722c0f7a26e83ce"}], "stats": {"total": 114, "additions": 53, "deletions": 61}, "files": [{"sha": "56940339fba5a3fb85d567b58e18cebbbc042246", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74129172c65297ba6d2023670e31de1f422db9ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74129172c65297ba6d2023670e31de1f422db9ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74129172c65297ba6d2023670e31de1f422db9ee", "patch": "@@ -1,3 +1,7 @@\n+2013-10-09  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_frame_info): Restructure function.\n+\n 2013-10-09  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/s390.c (struct s390_frame_layout): New field"}, {"sha": "28a09ecf34970dd722f9885cd02e8325687f3e0e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 49, "deletions": 61, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74129172c65297ba6d2023670e31de1f422db9ee/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74129172c65297ba6d2023670e31de1f422db9ee/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=74129172c65297ba6d2023670e31de1f422db9ee", "patch": "@@ -7781,7 +7781,7 @@ s390_optimize_register_info ()\n static void\n s390_frame_info (void)\n {\n-  int i;\n+  HOST_WIDE_INT lowest_offset;\n \n   cfun_frame_layout.first_save_gpr_slot = cfun_frame_layout.first_save_gpr;\n   cfun_frame_layout.last_save_gpr_slot = cfun_frame_layout.last_save_gpr;\n@@ -7805,52 +7805,38 @@ s390_frame_info (void)\n \n   if (!TARGET_PACKED_STACK)\n     {\n+      /* Fixed stack layout.  */\n       cfun_frame_layout.backchain_offset = 0;\n       cfun_frame_layout.f0_offset = 16 * UNITS_PER_LONG;\n       cfun_frame_layout.f4_offset = cfun_frame_layout.f0_offset + 2 * 8;\n       cfun_frame_layout.f8_offset = -cfun_frame_layout.high_fprs * 8;\n       cfun_frame_layout.gprs_offset = (cfun_frame_layout.first_save_gpr_slot\n \t\t\t\t       * UNITS_PER_LONG);\n     }\n-  else if (TARGET_BACKCHAIN) /* kernel stack layout */\n+  else if (TARGET_BACKCHAIN)\n     {\n+      /* Kernel stack layout - packed stack, backchain, no float  */\n+      gcc_assert (TARGET_SOFT_FLOAT);\n       cfun_frame_layout.backchain_offset = (STACK_POINTER_OFFSET\n \t\t\t\t\t    - UNITS_PER_LONG);\n-      cfun_frame_layout.gprs_offset\n-\t= (cfun_frame_layout.backchain_offset\n-\t   - (STACK_POINTER_REGNUM - cfun_frame_layout.first_save_gpr_slot + 1)\n-\t   * UNITS_PER_LONG);\n \n-      if (TARGET_64BIT)\n-\t{\n-\t  cfun_frame_layout.f4_offset\n-\t    = (cfun_frame_layout.gprs_offset\n-\t       - 8 * (cfun_fpr_save_p (FPR4_REGNUM)\n-\t\t      + cfun_fpr_save_p (FPR6_REGNUM)));\n+      /* The distance between the backchain and the return address\n+\t save slot must not change.  So we always need a slot for the\n+\t stack pointer which resides in between.  */\n+      cfun_frame_layout.last_save_gpr_slot = STACK_POINTER_REGNUM;\n \n-\t  cfun_frame_layout.f0_offset\n-\t    = (cfun_frame_layout.f4_offset\n-\t       - 8 * (cfun_fpr_save_p (FPR0_REGNUM)\n-\t\t      + cfun_fpr_save_p (FPR2_REGNUM)));\n-\t}\n-      else\n-\t{\n-\t  /* On 31 bit we have to care about alignment of the\n-\t     floating point regs to provide fastest access.  */\n-\t  cfun_frame_layout.f0_offset\n-\t    = ((cfun_frame_layout.gprs_offset\n-\t\t& ~(STACK_BOUNDARY / BITS_PER_UNIT - 1))\n-\t       - 8 * (cfun_fpr_save_p (FPR0_REGNUM)\n-\t\t      + cfun_fpr_save_p (FPR2_REGNUM)));\n+      cfun_frame_layout.gprs_offset\n+\t= cfun_frame_layout.backchain_offset - cfun_gprs_save_area_size;\n \n-\t  cfun_frame_layout.f4_offset\n-\t    = (cfun_frame_layout.f0_offset\n-\t       - 8 * (cfun_fpr_save_p (FPR4_REGNUM)\n-\t\t      + cfun_fpr_save_p (FPR6_REGNUM)));\n-\t}\n+      /* FPRs will not be saved.  Nevertheless pick sane values to\n+\t keep area calculations valid.  */\n+      cfun_frame_layout.f0_offset =\n+\tcfun_frame_layout.f4_offset =\n+\tcfun_frame_layout.f8_offset = cfun_frame_layout.gprs_offset;\n     }\n-  else /* no backchain */\n+  else\n     {\n+      /* Packed stack layout without backchain.  */\n       cfun_frame_layout.f4_offset\n \t= (STACK_POINTER_OFFSET\n \t   - 8 * (cfun_fpr_save_p (FPR4_REGNUM)\n@@ -7863,47 +7849,49 @@ s390_frame_info (void)\n \n       cfun_frame_layout.gprs_offset\n \t= cfun_frame_layout.f0_offset - cfun_gprs_save_area_size;\n+\n+      cfun_frame_layout.f8_offset = (cfun_frame_layout.gprs_offset\n+\t\t\t\t     - cfun_frame_layout.high_fprs * 8);\n     }\n \n+  if (cfun_save_high_fprs_p)\n+    cfun_frame_layout.frame_size += cfun_frame_layout.high_fprs * 8;\n+\n+  if (!crtl->is_leaf)\n+    cfun_frame_layout.frame_size += crtl->outgoing_args_size;\n+\n+  /* In the following cases we have to allocate a STACK_POINTER_OFFSET\n+     sized area at the bottom of the stack.  This is required also for\n+     leaf functions.  When GCC generates a local stack reference it\n+     will always add STACK_POINTER_OFFSET to all these references.  */\n   if (crtl->is_leaf\n       && !TARGET_TPF_PROFILING\n       && cfun_frame_layout.frame_size == 0\n-      && !cfun_save_high_fprs_p\n       && !cfun->calls_alloca)\n     return;\n \n-  if (!TARGET_PACKED_STACK)\n-    cfun_frame_layout.frame_size += (STACK_POINTER_OFFSET\n-\t\t\t\t     + crtl->outgoing_args_size\n-\t\t\t\t     + cfun_frame_layout.high_fprs * 8);\n-  else\n-    {\n-      if (TARGET_BACKCHAIN)\n-\tcfun_frame_layout.frame_size += UNITS_PER_LONG;\n+  /* Calculate the number of bytes we have used in our own register\n+     save area.  With the packed stack layout we can re-use the\n+     remaining bytes for normal stack elements.  */\n \n-      /* No alignment trouble here because f8-f15 are only saved under\n-\t 64 bit.  */\n-      cfun_frame_layout.f8_offset = (MIN (MIN (cfun_frame_layout.f0_offset,\n-\t\t\t\t\t       cfun_frame_layout.f4_offset),\n-\t\t\t\t\t  cfun_frame_layout.gprs_offset)\n-\t\t\t\t     - cfun_frame_layout.high_fprs * 8);\n-\n-      cfun_frame_layout.frame_size += cfun_frame_layout.high_fprs * 8;\n-\n-      for (i = FPR0_REGNUM; i <= FPR7_REGNUM; i++)\n-\tif (cfun_fpr_save_p (i))\n-\t  cfun_frame_layout.frame_size += 8;\n+  if (TARGET_PACKED_STACK)\n+    lowest_offset = MIN (MIN (cfun_frame_layout.f0_offset,\n+\t\t\t      cfun_frame_layout.f4_offset),\n+\t\t\t cfun_frame_layout.gprs_offset);\n+  else\n+    lowest_offset = 0;\n \n-      cfun_frame_layout.frame_size += cfun_gprs_save_area_size;\n+  if (TARGET_BACKCHAIN)\n+    lowest_offset = MIN (lowest_offset, cfun_frame_layout.backchain_offset);\n \n-      /* If under 31 bit an odd number of gprs has to be saved we have to adjust\n-\t the frame size to sustain 8 byte alignment of stack frames.  */\n-      cfun_frame_layout.frame_size = ((cfun_frame_layout.frame_size +\n-\t\t\t\t       STACK_BOUNDARY / BITS_PER_UNIT - 1)\n-\t\t\t\t      & ~(STACK_BOUNDARY / BITS_PER_UNIT - 1));\n+  cfun_frame_layout.frame_size += STACK_POINTER_OFFSET - lowest_offset;\n \n-      cfun_frame_layout.frame_size += crtl->outgoing_args_size;\n-    }\n+  /* If under 31 bit an odd number of gprs has to be saved we have to\n+     adjust the frame size to sustain 8 byte alignment of stack\n+     frames.  */\n+  cfun_frame_layout.frame_size = ((cfun_frame_layout.frame_size +\n+\t\t\t\t   STACK_BOUNDARY / BITS_PER_UNIT - 1)\n+\t\t\t\t  & ~(STACK_BOUNDARY / BITS_PER_UNIT - 1));\n }\n \n /* Generate frame layout.  Fills in register and frame data for the current"}]}