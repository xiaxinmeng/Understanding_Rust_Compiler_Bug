{"sha": "48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhjOGI2YjdiOGEzM2ZhOGUyNGM3OTIzYzgyYWQ5ZmVhNTI1Mjg5ZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-09T05:09:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-09T05:09:11Z"}, "message": "Initial revision\n\nFrom-SVN: r294", "tree": {"sha": "cdea19349c042085f9f30f0db511cc093043a07c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdea19349c042085f9f30f0db511cc093043a07c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d/comments", "author": null, "committer": null, "parents": [{"sha": "59a5c11b9cc4c1c571cc464b3fd2d1e107c015d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a5c11b9cc4c1c571cc464b3fd2d1e107c015d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a5c11b9cc4c1c571cc464b3fd2d1e107c015d8"}], "stats": {"total": 1544, "additions": 1544, "deletions": 0}, "files": [{"sha": "45fb624c46cf4590596c81fd56ad7493cd99d221", "filename": "gcc/config/a29k/a29k.h", "status": "added", "additions": 1544, "deletions": 0, "changes": 1544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "patch": "@@ -0,0 +1,1544 @@\n+/* Definitions of target machine for GNU compiler, for AMD Am29000 CPU.\n+   Copyright (C) 1988, 1990, 1991 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-D_AM29K -D_AM29000 -D_EPI\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION\n+\n+/* Pass -w to assembler.  */\n+#define ASM_SPEC \"-w\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+/* This means that the DW bit will be enabled, to allow direct loads\n+   of bytes.  */\n+\n+#define TARGET_DW_ENABLE\t(target_flags & 1)\n+\n+/* This means that the external hardware does supports byte writes.  */\n+\n+#define TARGET_BYTE_WRITES\t(target_flags & 2)\n+\n+/* This means that a \"small memory model\" has been selected where all\n+   function addresses are known to be within 256K.  This allows CALL to be\n+   used.  */\n+\n+#define TARGET_SMALL_MEMORY\t(target_flags & 4)\n+\n+/* This means that we are compiling for a 29050.  */\n+\n+#define TARGET_29050\t\t(target_flags & 8)\n+\n+/* This means that we are compiling for the kernel which means that we use\n+   gr64-gr95 instead of gr96-126.  */\n+\n+#define TARGET_KERNEL_REGISTERS\t(target_flags & 16)\n+\n+/* This means that a call to \"__msp_check\" should be inserted after each stack\n+   adjustment to check for stack overflow.  */\n+\n+#define TARGET_STACK_CHECK\t(target_flags & 32)\n+\n+/* This handles 29k processors which cannot handle the separation\n+   of a mtsrim insns and a storem insn (most 29000 chips to date, but\n+   not the 29050.  */\n+\n+#define TARGET_NO_STOREM_BUG\t(target_flags & 64)\n+\n+/* This forces the compiler not to use incoming argument registers except\n+   for copying out arguments.  It helps detect problems when a function is\n+   called with fewer arguments than it is declared with.  */\n+\n+#define TARGET_NO_REUSE_ARGS\t(target_flags & 128)\n+\n+#define TARGET_SWITCHES\t\t\t\\\n+  { {\"dw\", 1},\t\t\t\t\\\n+    {\"ndw\", -1},\t\t\t\\\n+    {\"bw\", 2},\t\t\t\t\\\n+    {\"nbw\", - (1|2)},\t\t\t\\\n+    {\"small\", 4},\t\t\t\\\n+    {\"large\", -4},\t\t\t\\\n+    {\"29050\", 8+64},\t\t\t\\\n+    {\"29000\", -8},\t\t\t\\\n+    {\"kernel-registers\", 16},\t\t\\\n+    {\"user-registers\", -16},\t\t\\\n+    {\"stack-check\", 32},\t\t\\\n+    {\"no-storem-bug\", 64},\t\t\\\n+    {\"reuse-arg-regs\", -128},\t\t\\\n+    {\"no-reuse-arg-regs\", 128},\t\t\\\n+    {\"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 3\n+\n+/* Define this to change the optimizations peformed by default.  */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\\\n+{\t\t\t\t\t\\\n+  if ((LEVEL) > 0)\t\t\t\\\n+    {\t\t\t\t\t\\\n+      flag_force_addr = 1;\t\t\\\n+      flag_force_mem = 1;\t\t\\\n+      flag_omit_frame_pointer = 1;\t\\\n+    }\t\t\t\t\t\\\n+}\n+\f\n+/* target machine storage layout */\n+\n+/* Define the types for size_t, ptrdiff_t, and wchar_t.  These are the\n+   same as those used by EPI.  The type for wchar_t does not make much\n+   sense, but is what is used.  */\n+\n+#define SIZE_TYPE \"unsigned int\"\n+#define PTRDIFF_TYPE \"int\"\n+#define WCHAR_TYPE \"char\"\n+#define WCHAR_TYPE_SIZE BITS_PER_UNIT\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is arbitrary on the 29k since it has no actual bit-field insns.\n+   It is better to define this as TRUE because BYTES_BIG_ENDIAN is TRUE\n+   and we want to be able to convert BP position to bit position with\n+   just a shift.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.\n+   This is true on 29k.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered. \n+\n+   For 29k we can decide arbitrarily since there are no machine instructions\n+   for them.  Might as well be consistent with bytes. */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* #define STRICT_ALIGNMENT */\n+\n+/* Define this if unaligned move instructions are extremely slow.\n+\n+   On the 29k, they trap.  */\n+#define SLOW_UNALIGNED_ACCESS\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   29k has 256 registers, of which 62 are not defined.  gr0 and gr1 are\n+   not produced in generated RTL so we can start at gr96, and call it\n+   register zero.\n+\n+   So 0-31 are gr96-gr127, lr0-lr127 are 32-159.  To represent the input\n+   arguments, whose register numbers we won't know until we are done,\n+   use register 160-175.  They cannot be modified.  Similarly, 176 is used\n+   for the frame pointer.  It is assigned the last local register number\n+   once the number of registers used is known.\n+\n+   We use 177, 178, 179, and 180 for the special registers BP, FC, CR, and Q,\n+   respectively.  Registers 181 through 199 are used for the other special\n+   registers that may be used by the programmer, but are never used by the\n+   compiler.\n+\n+   Registers 200-203 are the four floating-point accumulator register in\n+   the 29050.\n+\n+   When -mkernel-registers is specified, we still use the same register\n+   map but change the names so 0-31 print as gr64-gr95.  */\n+\n+#define FIRST_PSEUDO_REGISTER 204\n+\n+/* Because of the large number of registers on the 29k, we define macros\n+   to refer to each group of registers and then define the number for some\n+   registers used in the calling sequence.  */\n+\n+#define R_GR(N)\t\t((N) - 96)\t/* gr96 is register number 0 */\n+#define R_LR(N)\t\t((N) + 32)\t/* lr0 is register number 32 */\n+#define R_FP\t\t176\t\t/* frame pointer is register 176 */\n+#define R_AR(N)\t\t((N) + 160)\t/* first incoming arg reg is 160 */\n+\n+/* Define the numbers of the special registers.  */\n+#define R_BP\t177\n+#define R_FC\t178\n+#define R_CR\t179\n+#define R_Q\t180\n+\n+/* These special registers are not used by the compiler, but may be referenced\n+   by the programmer via asm declarations.  */\n+\n+#define R_VAB\t181\n+#define R_OPS\t182\n+#define R_CPS\t183\n+#define R_CFG\t184\n+#define R_CHA\t185\n+#define R_CHD\t186\n+#define R_CHC\t187\n+#define R_RBP\t188\n+#define R_TMC\t189\n+#define R_TMR\t190\n+#define R_PC0\t191\n+#define R_PC1\t192\n+#define R_PC2\t193\n+#define R_MMU\t194\n+#define R_LRU\t195\n+#define R_FPE\t196\n+#define R_INT\t197\n+#define R_FPS\t198\n+#define R_EXO\t199\n+\n+/* Define the number for floating-point accumulator N.  */\n+#define R_ACC(N)\t((N) + 200)\n+\n+/* Now define the registers used in the calling sequence.  */\n+#define R_TAV\tR_GR (121)\n+#define R_TPC\tR_GR (122)\n+#define R_LRP\tR_GR (123)\n+#define R_SLP\tR_GR (124)\n+#define R_MSP\tR_GR (125)\n+#define R_RAB\tR_GR (126)\n+#define R_RFB\tR_GR (127)\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, \\\n+  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\t\t  \\\n+  0, 0, 0, 0 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\t\t  \\\n+  1, 1, 1, 1 }\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   We allocate in the following order:\n+\tgr116-gr120\t(not used for anything but temps)\n+\tgr96-gr111\t(function return values, reverse order)\n+\targument registers (160-175)\n+\tlr0-lr127\t(locals, saved)\n+        acc3-0\t\t(acc0 special)\n+\teverything else  */\n+\n+#define REG_ALLOC_ORDER\t\t\\\n+  {R_GR (116), R_GR (117), R_GR (118), R_GR (119), R_GR (120),\t\t\\\n+   R_GR (111), R_GR (110), R_GR (109), R_GR (108), R_GR (107),\t\t\\\n+   R_GR (106), R_GR (105), R_GR (104), R_GR (103), R_GR (102),\t\t\\\n+   R_GR (101), R_GR (100), R_GR (99), R_GR (98), R_GR (97), R_GR (96),\t\\\n+   R_AR (0), R_AR (1), R_AR (2), R_AR (3), R_AR (4), R_AR (5),\t\t\\\n+   R_AR (6), R_AR (7), R_AR (8), R_AR (9), R_AR (10), R_AR (11),\t\\\n+   R_AR (12), R_AR (13), R_AR (14), R_AR (15),\t\t\t\t\\\n+   R_LR (0), R_LR (1), R_LR (2), R_LR (3), R_LR (4), R_LR (5),\t\t\\\n+   R_LR (6), R_LR (7), R_LR (8), R_LR (9), R_LR (10), R_LR (11),\t\\\n+   R_LR (12), R_LR (13), R_LR (14), R_LR (15), R_LR (16), R_LR (17),\t\\\n+   R_LR (18), R_LR (19), R_LR (20), R_LR (21), R_LR (22), R_LR (23),\t\\\n+   R_LR (24), R_LR (25), R_LR (26), R_LR (27), R_LR (28), R_LR (29),\t\\\n+   R_LR (30), R_LR (31), R_LR (32), R_LR (33), R_LR (34), R_LR (35),\t\\\n+   R_LR (36), R_LR (37), R_LR (38), R_LR (39), R_LR (40), R_LR (41),\t\\\n+   R_LR (42), R_LR (43), R_LR (44), R_LR (45), R_LR (46), R_LR (47), \t\\\n+   R_LR (48), R_LR (49), R_LR (50), R_LR (51), R_LR (52), R_LR (53),\t\\\n+   R_LR (54), R_LR (55), R_LR (56), R_LR (57), R_LR (58), R_LR (59),\t\\\n+   R_LR (60), R_LR (61), R_LR (62), R_LR (63), R_LR (64), R_LR (65),\t\\\n+   R_LR (66), R_LR (67), R_LR (68), R_LR (69), R_LR (70), R_LR (71),\t\\\n+   R_LR (72), R_LR (73), R_LR (74), R_LR (75), R_LR (76), R_LR (77),\t\\\n+   R_LR (78), R_LR (79), R_LR (80), R_LR (81), R_LR (82), R_LR (83),\t\\\n+   R_LR (84), R_LR (85), R_LR (86), R_LR (87), R_LR (88), R_LR (89),\t\\\n+   R_LR (90), R_LR (91), R_LR (92), R_LR (93), R_LR (94), R_LR (95),\t\\\n+   R_LR (96), R_LR (97), R_LR (98), R_LR (99), R_LR (100), R_LR (101),\t\\\n+   R_LR (102), R_LR (103), R_LR (104), R_LR (105), R_LR (106),\t\t\\\n+   R_LR (107), R_LR (108), R_LR (109), R_LR (110), R_LR (111),\t\t\\\n+   R_LR (112), R_LR (113), R_LR (114), R_LR (115), R_LR (116),\t\t\\\n+   R_LR (117), R_LR (118), R_LR (119), R_LR (120), R_LR (121),\t\t\\\n+   R_LR (122), R_LR (123), R_LR (124), R_LR (124), R_LR (126),\t\t\\\n+   R_LR (127),\t\t\t\t\t\t\t\t\\\n+   R_ACC (3), R_ACC (2), R_ACC (1), R_ACC (0),\t\t\t\t\\\n+   R_GR (112), R_GR (113), R_GR (114), R_GR (115), R_GR (121),\t\t\\\n+   R_GR (122), R_GR (123), R_GR (124), R_GR (125), R_GR (126),\t\t\\\n+   R_GR (127),\t\t\t\t\t\t\t\t\\\n+   R_FP, R_BP, R_FC, R_CR, R_Q,\t\t\t\t\t\t\\\n+   R_VAB, R_OPS, R_CPS, R_CFG, R_CHA, R_CHD, R_CHC, R_RBP, R_TMC,\t\\\n+   R_TMR, R_PC0, R_PC1, R_PC2, R_MMU, R_LRU, R_FPE, R_INT, R_FPS,\t\\\n+   R_EXO }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((REGNO) >= R_ACC (0) ? 1\t\t\\\n+   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On 29k, the cpu registers can hold any mode.  But a double-precision\n+   floating-point value should start at an even register.  The special\n+   registers cannot hold floating-point values and the accumulators cannot\n+   hold integer values.\n+\n+   (I'd like to use the \"?:\" syntax to make this more readable, but Sun's\n+   compiler doesn't seem to accept it.)  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)  \t\t\t\t\\\n+  (((REGNO) >= R_ACC (0)\t\t\t\t\t\t\\\n+    && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+\t|| GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT))\t\t\\\n+   || ((REGNO) >= R_BP && (REGNO) < R_ACC (0)\t\t\t\t\\\n+       && GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n+       && GET_MODE_CLASS (MODE) != MODE_COMPLEX_FLOAT)\t\t\t\\\n+   || ((REGNO) < R_BP\t\t\t\t\t\t\t\\\n+       && ((((REGNO) & 1) == 0) || GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+\t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT\t\t\t\\\n+\t   || GET_MODE_UNIT_SIZE (MODE) <= UNITS_PER_WORD)))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.\n+\n+   On the 29k, normally we'd just have problems with DFmode because of the\n+   even alignment.  However, we also have to be a bit concerned about\n+   the special register's restriction to non-floating and the floating-point\n+   accumulator's restriction to only floating.  This probably won't\n+   cause any great inefficiencies in practice.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n+  ((MODE1) == (MODE2)\t\t\t\t\t\\\n+   || (GET_MODE_CLASS (MODE1) != MODE_FLOAT\t\t\\\n+       && GET_MODE_CLASS (MODE1) != MODE_COMPLEX_FLOAT\t\\\n+       && GET_MODE_CLASS (MODE2) != MODE_FLOAT\t\t\\\n+       && GET_MODE_CLASS (MODE2) != MODE_COMPLEX_FLOAT))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* 29k pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM R_GR (125)\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM R_FP\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM R_FP\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM R_SLP\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM R_LRP\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.\n+   \n+   The 29k has six registers classes: GENERAL_REGS, SPECIAL_REGS,\n+   BP_REGS, Q_REGS, ACCUM_REGS, and ACCUM0_REGS.  BP_REGS contains just BP and\n+   is used for the extract and insert operations to allow combinations; Q\n+   contains just the Q register.  The latter two classes are used to represent\n+   the floating-point accumulator registers in the 29050.  We also define the\n+   union class FLOAT_REGS to represent any register that can be used to hold a\n+   floating-point value.  The union of SPECIAL_REGS and ACCUM_REGS isn't\n+   useful as the former cannot contain floating-point and the latter can only\n+   contain floating-point.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS, BP_REGS, Q_REGS, SPECIAL_REGS, \n+\t\t ACCUM0_REGS, ACCUM_REGS, FLOAT_REGS, ALL_REGS,\n+\t\t LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES\t\t\t\t\\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"BP_REGS\", \"Q_REGS\", \"SPECIAL_REGS\",\t\\\n+  \"ACCUM0_REGS\", \"ACCUM_REGS\", \"FLOAT_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+  { {0, 0, 0, 0, 0, 0, 0}, \t\\\n+    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, 0},  \\\n+    {0, 0, 0, 0, 0, 0x20000, 0}, \t\\\n+    {0, 0, 0, 0, 0, 0x100000, 0}, \t\\\n+    {0, 0, 0, 0, 0, 0xfffe0000, 0xff},\t\\\n+    {0, 0, 0, 0, 0, 0, 0x100},\t\t\\\n+    {0, 0, 0, 0, 0, 0, 0xf00},\t\t\\\n+    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, 0xf00}, \\\n+    {~0, ~0, ~0, ~0, ~0, ~0, ~0} }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\\\n+  ((REGNO) == R_BP ? BP_REGS\t\t\\\n+   : (REGNO) == R_Q ? Q_REGS\t\t\\\n+   : (REGNO) > R_BP && (REGNO) <= R_EXO ? SPECIAL_REGS\t\\\n+   : (REGNO) == R_ACC (0) ? ACCUM0_REGS\t\\\n+   : (REGNO) > R_ACC (0) ? ACCUM_REGS\t\\\n+   : GENERAL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\\\n+ ((C) == 'r' ? GENERAL_REGS\t\t\\\n+  : (C) == 'b' ? BP_REGS\t\t\\\n+  : (C) == 'q' ? Q_REGS\t\t\t\\\n+  : (C) == 'h' ? SPECIAL_REGS\t\t\\\n+  : (C) == 'a' ? ACCUM_REGS\t\t\\\n+  : (C) == 'A' ? ACCUM0_REGS\t\t\\\n+  : (C) == 'f' ? FLOAT_REGS\t\t\\\n+  : NO_REGS)\n+\n+/* Define this macro to change register usage conditional on target flags.\n+\n+   On the 29k, we use this to change the register names for kernel mapping.  */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static char *kernel_names[] = {\"gr64\", \"gr65\", \"gr66\", \"gr67\",\t\\\n+\t\t\t\t   \"gr68\", \"gr69\", \"gr70\", \"gr71\",\t\\\n+\t\t\t\t   \"gr72\", \"gr73\", \"gr74\", \"gr75\",\t\\\n+\t\t\t\t   \"gr76\", \"gr77\", \"gr78\", \"gr79\",\t\\\n+\t\t\t\t   \"gr80\", \"gr81\", \"gr82\", \"gr83\",\t\\\n+\t\t\t\t   \"gr84\", \"gr85\", \"gr86\", \"gr87\",\t\\\n+\t\t\t\t   \"gr88\", \"gr89\", \"gr90\", \"gr91\",\t\\\n+\t\t\t\t   \"gr92\", \"gr93\", \"gr94\", \"gr95\"};\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_KERNEL_REGISTERS)\t\t\t\t\t\\\n+      for (i = 0; i < 32; i++)\t\t\t\t\t\t\\\n+\treg_names[i] = kernel_names[i];\t\t\t\t\t\\\n+  }\n+\n+/* The letters I, J, K, L, M, N, O, and P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For 29k:\n+   `I' is used for the range of constants most insns can contain.\n+   `J' is for the few 16-bit insns.\n+   `K' is a constant whose high-order 24 bits are all one\n+   `L' is a HImode constant whose high-order 8 bits are all one\n+   `M' is a 32-bit constant whose high-order 16 bits are all one (for CONSTN)\n+   `N' is a 32-bit constant whose negative is 8 bits\n+   `O' is the 32-bit constant 0x80000000, any constant with low-order\n+          16 bits zero for 29050.\n+   `P' is a HImode constant whose negative is 8 bits  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'I' ? (unsigned) (VALUE) < 0x100\t\t\t\\\n+   : (C) == 'J' ? (unsigned) (VALUE) < 0x10000\t\t\t\\\n+   : (C) == 'K' ? ((VALUE) & 0xffffff00) == 0xffffff00\t\t\\\n+   : (C) == 'L' ? ((VALUE) & 0xff00) == 0xff00\t\t\t\\\n+   : (C) == 'M' ? ((VALUE) & 0xffff0000) == 0xffff0000\t\t\\\n+   : (C) == 'N' ? ((VALUE) < 0 && (VALUE) > -256)\t\t\\\n+   : (C) == 'O' ? ((VALUE) == 0x80000000\t\t\t\\\n+\t\t   || (TARGET_29050 && ((VALUE) & 0xffff) == 0)) \\\n+   : (C) == 'P' ? (((VALUE) | 0xffff0000) < 0\t\t\t\\\n+\t\t   && ((VALUE) | 0xffff0000) > -256)\t\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.\n+   All floating-point constants are valid on 29k.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\tCLASS\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class (CLASS, MODE, IN)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.\n+\n+   On 29k, this is the size of MODE in words except that the floating-point\n+   accumulators only require one word for anything they can hold.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\\\n+ (((CLASS) == ACCUM_REGS || (CLASS) == ACCUM0_REGS) ? 1\t\t\\\n+  : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Define the cost of moving between registers of various classes.  Everything\n+   involving a general register is cheap, but moving between the other types\n+   (even within a class) is two insns.  */\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\\\n+  ((CLASS1) == GENERAL_REGS || (CLASS2) == GENERAL_REGS ? 2 : 4)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET (- current_function_pretend_args_size)\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On 29k, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Define this if the maximum size of all the outgoing args is to be\n+   accumulated and pushed during the prologue.  The amount can be\n+   found in the variable current_function_outgoing_args_size.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) (- current_function_pretend_args_size)\n+\n+/* Define this if stack space is still allocated for a parameter passed\n+   in a register.  */\n+/* #define REG_PARM_STACK_SPACE */\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.\n+\n+   On 29k the value is found in gr96.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), R_GR (96))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, R_GR (96))\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+   On 29k, gr96-gr111 are used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) < R_GR (112))\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On 29k, these are lr2-lr17.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) ((N) <= R_LR (17) && (N) >= R_LR (2))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On 29k, this is a single integer, which is a number of words\n+   of arguments scanned so far.\n+   Thus 16 or more means all following args should go on the stack.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)  (CUM) = 0\n+\n+/* Same, but called for incoming args.\n+\n+   On the 29k, we use this to set all argument registers to fixed and\n+   set the last 16 local regs (lr112-lr127) to available.  Some\n+   will later be changed to call-saved by FUNCTION_INCOMING_ARG.  */\n+\n+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,IGNORE)\t\t\\\n+{ int i;\t\t\t\t\t\t\t\\\n+  for (i = R_AR (0); i < R_AR (16); i++)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 1; \\\n+      SET_HARD_REG_BIT (fixed_reg_set, i);\t\t\t\\\n+      SET_HARD_REG_BIT (call_used_reg_set, i);\t\t\t\\\n+      SET_HARD_REG_BIT (call_fixed_reg_set, i);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  for (i = R_LR (112); i < R_LR (128); i++)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 0; \\\n+      CLEAR_HARD_REG_BIT (fixed_reg_set, i);\t\t\t\\\n+      CLEAR_HARD_REG_BIT (call_used_reg_set, i);\t\t\\\n+      CLEAR_HARD_REG_BIT (call_fixed_reg_set, i);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  (CUM) = 0;\t\t\t\t\t\t\t\\\n+ }\n+\n+/* Define intermediate macro to compute the size (in registers) of an argument\n+   for the 29k.  */\n+\n+#define A29K_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n+(! (NAMED) ? 0\t\t\t\t\t\t\t\t\\\n+ : (MODE) != BLKmode\t\t\t\t\t\t\t\\\n+ ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n+ : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n+    (CUM) = 16;\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    (CUM) += A29K_ARG_SIZE (MODE, TYPE, NAMED)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On 29k the first 16 words of args are normally in registers\n+   and the rest are pushed.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+((CUM) < 16 && (NAMED) && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n+ ? gen_rtx(REG, (MODE), R_LR (2) + (CUM)) : 0)\n+\n+/* Define where a function finds its arguments.\n+   This is different from FUNCTION_ARG because of register windows.\n+\n+   On the 29k, we hack this to call a function that sets the used registers\n+   as non-fixed and not used by calls.  */\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+((CUM) < 16 && (NAMED) && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\t\\\n+ ? gen_rtx (REG, MODE,\t\t\t\t\t\t\t\\\n+\t    incoming_reg (CUM, A29K_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n+ : 0)\n+\n+/* This indicates that an argument is to be passed with an invisible reference\n+   (i.e., a pointer to the object is passed).\n+\n+   On the 29k, we do this if it must be passed on the stack.  */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (MUST_PASS_IN_STACK (MODE, TYPE))\n+\n+/* Specify the padding direction of arguments.\n+\n+   On the 29k, we must pad upwards in order to be able to pass args in\n+   registers.  */\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\tupward\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n+((CUM) < 16 && 16 < (CUM) + A29K_ARG_SIZE (MODE, TYPE, NAMED) && (NAMED) \\\n+ ? 16 - (CUM) : 0)\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n+{ if ((CUM) < 16)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int first_reg_offset = (CUM);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n+\tfirst_reg_offset += A29K_ARG_SIZE (TYPE_MODE (TYPE), TYPE, 1);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (first_reg_offset > 16)\t\t\t\t\t\\\n+\tfirst_reg_offset = 16;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL) && first_reg_offset != 16)\t\t\t\t\\\n+\tmove_block_from_reg\t\t\t\t\t\t\\\n+\t  (R_AR (0) + first_reg_offset,\t\t\t\t\t\\\n+\t   gen_rtx (MEM, BLKmode, virtual_incoming_args_rtx),\t\t\\\n+\t   16 - first_reg_offset);\t\t\t\t\t\\\n+      PRETEND_SIZE = (16 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def *a29k_compare_op0, *a29k_compare_op1;\n+extern int a29k_compare_fp_p;\n+\n+/* This macro produces the initial definition of a function name.\n+\n+   For the 29k, we need the prolog to contain one or two words prior to\n+   the declaration of the function name.  So just store away the name and\n+   write it as part of the prolog.  */\n+\n+extern char *a29k_function_name;\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n+  a29k_function_name = NAME;\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)  output_prolog (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\toutput_epilog (FILE, SIZE)\n+\n+/* Define the number of delay slots needed for the function epilogue.\n+\n+   On the 29k, we need a slot except when we have a register stack adjustment,\n+   have a memory stack adjustment, and have no frame pointer.  */\n+\n+#define DELAY_SLOTS_FOR_EPILOGUE \t\t\t\t\t\\\n+  (! (needs_regstack_p ()\t\t\t\t\t\t\\\n+      && (get_frame_size () + current_function_pretend_args_size\t\\\n+\t   + current_function_outgoing_args_size) != 0\t\t\t\\\n+      && ! frame_pointer_needed))\n+\n+/* Define whether INSN can be placed in delay slot N for the epilogue.\n+\n+   On the 29k, we must be able to place it in a delay slot, it must\n+   not use sp if the frame pointer cannot be eliminated, and it cannot\n+   use local regs if we need to push the register stack.  */\n+\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N)\t\t\t\t\\\n+  (get_attr_in_delay_slot (INSN) == IN_DELAY_SLOT_YES\t\t\t\\\n+   && ! (frame_pointer_needed\t\t\t\t\t\t\\\n+\t && reg_mentioned_p (stack_pointer_rtx, PATTERN (INSN)))\t\\\n+   && ! (needs_regstack_p () && uses_local_reg_p (PATTERN (INSN))))\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.  We\n+   use gr121 (tav) as a temporary.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tconst %s,0\\n\", reg_names[R_TAV]);\t\\\n+  fprintf (FILE, \"\\tconsth %s,0\\n\", reg_names[R_TAV]);\t\\\n+  fprintf (FILE, \"\\tconst %s,0\\n\", reg_names[R_SLP]);\t\\\n+  fprintf (FILE, \"\\tjmpi %s\\n\", reg_names[R_TAV]);\t\\\n+  fprintf (FILE, \"\\tconsth %s,0\\n\", reg_names[R_SLP]);\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE    20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   We do this on the 29k by writing the bytes of the addresses into the\n+   trampoline one byte at a time.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  INITIALIZE_TRAMPOLINE_VALUE (TRAMP, FNADDR, 0, 4);\t\t\t\\\n+  INITIALIZE_TRAMPOLINE_VALUE (TRAMP, CXT, 8, 16);\t\t\t\\\n+}\n+\n+/* Define a sub-macro to initialize one value into the trampoline.\n+   We specify the offsets of the CONST and CONSTH instructions, respectively\n+   and copy the value a byte at a time into these instructions.  */\n+\n+#define INITIALIZE_TRAMPOLINE_VALUE(TRAMP, VALUE, CONST, CONSTH)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx _addr, _temp;\t\t\t\t\t\t\t\\\n+  rtx _val = force_reg (SImode, VALUE);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _addr = memory_address (QImode, plus_constant (TRAMP, (CONST) + 3));\t\\\n+  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+\t\t  gen_lowpart (QImode, _val));\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\t\\\n+\t\t       build_int_2 (8, 0), 0, 1);\t\t\t\\\n+  _addr = memory_address (QImode, plus_constant (TRAMP, (CONST) + 1));\t\\\n+  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+\t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _temp = expand_shift (RSHIFT_EXPR, SImode, _temp,\t\t\t\\\n+\t\t       build_int_2 (8, 0), _temp, 1);\t\t\t\\\n+  _addr = memory_address (QImode, plus_constant (TRAMP, (CONSTH) + 3));\t\\\n+  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+\t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  _temp = expand_shift (RSHIFT_EXPR, SImode, _temp,\t\t\t\\\n+\t\t       build_int_2 (8, 0), _temp, 1);\t\t\t\\\n+  _addr = memory_address (QImode, plus_constant (TRAMP, (CONSTH) + 1));\t\\\n+  emit_move_insn (gen_rtx (MEM, QImode, _addr),\t\t\t\t\\\n+\t\t  gen_lowpart (QImode, _temp));\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+#define REGNO_OK_FOR_BASE_P(REGNO) 1\n+\n+/* Given the value returned from get_frame_size, compute the actual size\n+   of the frame we will allocate.   We include the pretend and outgoing\n+   arg sizes and round to a doubleword.  */\n+\n+#define ACTUAL_FRAME_SIZE(SIZE)\t\t\t\t\\\n+  (((SIZE) + current_function_pretend_args_size\t\t\\\n+    + current_function_outgoing_args_size + 7) & ~7)\n+\n+/* Define the initial offset between the frame and stack pointer.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\\\n+  (DEPTH) = ACTUAL_FRAME_SIZE (get_frame_size ())\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.\n+\n+   None are on the 29K.  */\n+#define CONSTANT_ADDRESS_P(X)  0\n+\n+/* Include all constant integers and constant doubles */\n+#define LEGITIMATE_CONSTANT_P(X)\t1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X)  1\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the 29k, a legitimate address is a register and so is a\n+   constant of less than 256.  */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+  if (GET_CODE (X) == CONST_INT\t\t\t\\\n+      && (unsigned) INTVAL (X) < 0x100)\t\t\\\n+    goto ADDR;\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the 29k, we need not do anything.  However, if we don't,\n+   `memory_address' will try lots of things to get a valid address, most of\n+   which will result in dead code and extra pseudos.  So we make the address\n+   valid here.\n+\n+   This is easy:  The only valid addresses are an offset from a register\n+   and we know the address isn't valid.  So just call either `force_operand'\n+   or `force_reg' unless this is a (plus (reg ...) (const_int 0)).  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+{ if (GET_CODE (X) == PLUS && XEXP (X, 1) == const0_rtx)\t\\\n+    X = XEXP (x, 0);\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == MULT || GET_CODE (X) == PLUS)\t\t\\\n+    X = force_operand (X, 0);\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    X = force_reg (Pmode, X);\t\t\t\t\t\\\n+  goto WIN;\t\t\t\t\t\t\t\\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the 29k this is never true.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\n+/* Compute the cost of an address.  For the 29k, all valid addresses are\n+   the same cost.  */\n+\n+#define ADDRESS_COST(X)  0\n+\n+/* Define this if some processing needs to be done immediately before\n+   emitting code for an insn.  */\n+\n+/* #define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) */\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.\n+\n+   We actually lie a bit here as overflow conditions are different.  But\n+   they aren't being checked anyway.  */\n+\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move to of from memory\n+   in one reasonably fast instruction.\n+\n+   For the 29k, we will define movti, so put this at 4 words.  */\n+#define MOVE_MAX 16\n+\n+/* Largest number of bytes of an object that can be placed in a register.\n+   On the 29k we have plenty of registers, so use TImode.  */\n+#define MAX_FIXED_MODE_SIZE\tGET_MODE_BITSIZE (TImode)\n+\n+/* Nonzero if access to memory by bytes is no faster than for words.\n+   Also non-zero if doing byte operations (specifically shifts) in registers\n+   is undesirable. \n+\n+   On the 29k, large masks are expensive, so we want to use bytes to\n+   manipulate fields.  */\n+#define SLOW_BYTE_ACCESS\t0\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* This uses COFF, so it wants SDB format.  */\n+#define SDB_DEBUGGING_INFO\n+\n+/* Define this to be the delimiter between SDB sub-sections.  The default\n+   is \";\".  */\n+#define SDB_DELIM\t\"\\n\"\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Don't try to use the `x' type-cross-reference character in DBX data.\n+   Also has the consequence of putting each struct, union or enum\n+   into a separate .stabs, containing only cross-refs to the others.  */\n+#define DBX_NO_XREFS\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 0x80000000\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* Mode of a function address in a call instruction (for indexing purposes).\n+\n+   Doesn't matter on 29k.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this if shift instructions ignore all but the low-order\n+   few bits. */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.\n+\n+   We only care about the cost if it is valid in an insn.  The only\n+   constants that cause an insn to generate more than one machine\n+   instruction are those involving floating-point or address.  So \n+   only these need be expensive.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    return 0;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 6;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return GET_MODE (RTX) == SFmode ? 6 : 8;\n+    \n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.\n+\n+   All MEMs cost the same if they are valid.  This is used to ensure\n+   that (mem (symbol_ref ...)) is placed into a CALL when valid.\n+\n+   The multiply cost depends on whether this is a 29050 or not.  */\n+\n+#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return TARGET_29050 ? COSTS_N_INSNS (2) : COSTS_N_INSNS (40);  \\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (50);\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (2);\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{ char *p, *after_dir = main_input_filename;\t\t\t\\\n+  if (TARGET_29050)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.cputype 29050\\n\");\t\t\t\\\n+  for (p = main_input_filename; *p; p++)\t\t\t\\\n+    if (*p == '/')\t\t\t\t\t\t\\\n+      after_dir = p + 1;\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.file \\\"%s\\\"\\n\", after_dir);\t\t\\\n+  fprintf (FILE, \"\\t.sect .lit,lit\\n\"); }\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before instructions.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+/* Output before read-only data.  */\n+\n+#define READONLY_DATA_SECTION_ASM_OP \"\\t.use .lit\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+/* Define an extra section for read-only data, a routine to enter it, and\n+   indicate that it is for read-only data.  */\n+\n+#define EXTRA_SECTIONS\treadonly_data\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+literal_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != readonly_data)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_SECTION_ASM_OP); \\\n+      in_section = readonly_data;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+\n+#define READONLY_DATA_SECTION\tliteral_section\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"gr96\", \"gr97\", \"gr98\", \"gr99\", \"gr100\", \"gr101\", \"gr102\", \"gr103\", \"gr104\", \\\n+ \"gr105\", \"gr106\", \"gr107\", \"gr108\", \"gr109\", \"gr110\", \"gr111\", \"gr112\", \\\n+ \"gr113\", \"gr114\", \"gr115\", \"gr116\", \"gr117\", \"gr118\", \"gr119\", \"gr120\", \\\n+ \"gr121\", \"gr122\", \"gr123\", \"gr124\", \"gr125\", \"gr126\", \"gr127\",\t\t \\\n+ \"lr0\", \"lr1\", \"lr2\", \"lr3\", \"lr4\", \"lr5\", \"lr6\", \"lr7\", \"lr8\", \"lr9\",   \\\n+ \"lr10\", \"lr11\", \"lr12\", \"lr13\", \"lr14\", \"lr15\", \"lr16\", \"lr17\", \"lr18\", \\\n+ \"lr19\", \"lr20\", \"lr21\", \"lr22\", \"lr23\", \"lr24\", \"lr25\", \"lr26\", \"lr27\", \\\n+ \"lr28\", \"lr29\", \"lr30\", \"lr31\", \"lr32\", \"lr33\", \"lr34\", \"lr35\", \"lr36\", \\\n+ \"lr37\", \"lr38\", \"lr39\", \"lr40\", \"lr41\", \"lr42\", \"lr43\", \"lr44\", \"lr45\", \\\n+ \"lr46\", \"lr47\", \"lr48\", \"lr49\", \"lr50\", \"lr51\", \"lr52\", \"lr53\", \"lr54\", \\\n+ \"lr55\", \"lr56\", \"lr57\", \"lr58\", \"lr59\", \"lr60\", \"lr61\", \"lr62\", \"lr63\", \\\n+ \"lr64\", \"lr65\", \"lr66\", \"lr67\", \"lr68\", \"lr69\", \"lr70\", \"lr71\", \"lr72\", \\\n+ \"lr73\", \"lr74\", \"lr75\", \"lr76\", \"lr77\", \"lr78\", \"lr79\", \"lr80\", \"lr81\", \\\n+ \"lr82\", \"lr83\", \"lr84\", \"lr85\", \"lr86\", \"lr87\", \"lr88\", \"lr89\", \"lr90\", \\\n+ \"lr91\", \"lr92\", \"lr93\", \"lr94\", \"lr95\", \"lr96\", \"lr97\", \"lr98\", \"lr99\", \\\n+ \"lr100\", \"lr101\", \"lr102\", \"lr103\", \"lr104\", \"lr105\", \"lr106\", \"lr107\", \\\n+ \"lr108\", \"lr109\", \"lr110\", \"lr111\", \"lr112\", \"lr113\", \"lr114\", \"lr115\", \\\n+ \"lr116\", \"lr117\", \"lr118\", \"lr119\", \"lr120\", \"lr121\", \"lr122\", \"lr123\", \\\n+ \"lr124\", \"lr125\", \"lr126\", \"lr127\",\t\t\t\t\t \\\n+  \"AI0\", \"AI1\", \"AI2\", \"AI3\", \"AI4\", \"AI5\", \"AI6\", \"AI7\", \"AI8\", \"AI9\",  \\\n+  \"AI10\", \"AI11\", \"AI12\", \"AI13\", \"AI14\", \"AI15\", \"FP\",\t\t\t \\\n+  \"bp\", \"fc\", \"cr\", \"q\",\t\t\t\t\t\t \\\n+  \"vab\", \"ops\", \"cps\", \"cfg\", \"cha\", \"chd\", \"chc\", \"rbp\", \"tmc\", \"tmr\",\t \\\n+  \"pc0\", \"pc1\", \"pc2\", \"mmu\", \"lru\", \"fpe\", \"int\", \"fps\", \"exo\",\t \\\n+  \"0\", \"1\", \"2\", \"3\" }\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+extern int a29k_debug_reg_map[];\n+#define DBX_REGISTER_NUMBER(REGNO) a29k_debug_reg_map[REGNO]\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output a label for a jump table.  Arguments are the same as\n+   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n+   passed. */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.double %.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.float %.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tsub %s,%s,4\\n\\tstore 0,0,%s,%s\\n\",\t\t\t\\\n+           reg_names[R_MSP], reg_names[R_MSP], reg_names[REGNO],\t\\\n+\t   reg_names[R_MSP]);\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tload 0,0,%s,%s\\n\\tadd %s,%s,4\\n\",\t\t\t\\\n+           reg_names[REGNO], reg_names[R_MSP], reg_names[R_MSP],\t\\\n+\t   reg_names[R_MSP]);\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (29k does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  abort ()\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.block %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n+\n+/* Determine which codes are valid without a following integer.  These must\n+   not be alphabetic.\n+\n+   We support `#' which is null if a delay slot exists, otherwise\n+   \"\\n\\tnop\" and `*' which prints the register name for TPC (gr122).  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#' || (CODE) == '*')\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx addr = ADDR;\t\t\t\t\t\\\n+  if (!REG_P (addr)\t\t\t\t\t\t\\\n+      && ! (GET_CODE (addr) == CONST_INT\t\t\t\\\n+\t    && INTVAL (addr) >= 0 && INTVAL (addr) < 256))\t\\\n+    abort ();\t\t\t\t\t\t\t\\\n+  output_operand (addr, 0);\t\t\t\t\t\\\n+}\n+/* Define the codes that are matched by predicates in a29k.c.  */\n+\n+#define PREDICATE_CODES \\\n+  {\"cint_8_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"cint_16_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"long_const_operand\", {CONST_INT, CONST, CONST_DOUBLE,\t\\\n+\t\t\t  LABEL_REF, SYMBOL_REF}},\t\t\\\n+  {\"shift_constant_operand\", {CONST_INT, ASHIFT}},\t\t\\\n+  {\"const_0__operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n+  {\"const_8__operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n+  {\"const_16__operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n+  {\"const_24__operand\", {CONST_INT, ASHIFT}},\t\t\t\\\n+  {\"float_const_operand\", {CONST_DOUBLE}},\t\t\t\\\n+  {\"gen_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"gen_reg_or_float_constant_operand\", {SUBREG, REG, CONST_DOUBLE}}, \\\n+  {\"gen_reg_or_integer_constant_operand\", {SUBREG, REG,\t\t\\\n+\t\t\t\t\t   CONST_INT, CONST_DOUBLE}}, \\\n+  {\"spec_reg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"accum_reg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"srcb_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"reg_or_immediate_operand\", {SUBREG, REG, CONST_INT, CONST,\t\\\n+\t\t\t\tCONST_DOUBLE, CONST, SYMBOL_REF, LABEL_REF}}, \\\n+  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"in_operand\", {SUBREG, MEM, REG, CONST_INT, CONST, SYMBOL_REF, \\\n+\t\t  LABEL_REF, CONST_DOUBLE}},\t\t\t\\\n+  {\"out_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n+  {\"extend_operator\", {ZERO_EXTEND, SIGN_EXTEND}},\t\t\\\n+  {\"fp_comparison_operator\", {EQ, GT, GE}},\t\t\t\\\n+  {\"branch_operator\", {GE, LT}},\t\t\t\t\\\n+  {\"epilogue_operand\", {CODE_LABEL}},"}]}