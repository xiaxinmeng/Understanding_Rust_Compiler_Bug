{"sha": "ad2ae3b294ddf550c982d115d5df83bece726aac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyYWUzYjI5NGRkZjU1MGM5ODJkMTE1ZDVkZjgzYmVjZTcyNmFhYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-11-20T05:17:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-11-20T05:17:01Z"}, "message": "pt.c (for_each_template_parm): Free allocated memory.\n\n\t* pt.c (for_each_template_parm): Free allocated memory.\n\t* search.c (is_subobject_of_p_1): New function.\n\t(is_subobject_of_p): Avoid walking virtual bases multiple times.\n\nFrom-SVN: r59287", "tree": {"sha": "949913f0e27f28ddb6b868a4c4ee333522b8689e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/949913f0e27f28ddb6b868a4c4ee333522b8689e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2ae3b294ddf550c982d115d5df83bece726aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2ae3b294ddf550c982d115d5df83bece726aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2ae3b294ddf550c982d115d5df83bece726aac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2ae3b294ddf550c982d115d5df83bece726aac/comments", "author": null, "committer": null, "parents": [{"sha": "ec5b0c68f3339e61bf37738f79c99252cdbfe3c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5b0c68f3339e61bf37738f79c99252cdbfe3c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5b0c68f3339e61bf37738f79c99252cdbfe3c1"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "d370dbd669b444ee92808305c96c7bc906268791", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2ae3b294ddf550c982d115d5df83bece726aac/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2ae3b294ddf550c982d115d5df83bece726aac/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ad2ae3b294ddf550c982d115d5df83bece726aac", "patch": "@@ -1,3 +1,9 @@\n+2002-11-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* pt.c (for_each_template_parm): Free allocated memory.\n+\t* search.c (is_subobject_of_p_1): New function.\n+\t(is_subobject_of_p): Avoid walking virtual bases multiple times.\n+\n 2002-11-19  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* g++spec.c (lang_specific_spec_functions): New."}, {"sha": "67252f939a9f481d383f0426dc68fceed09dcb8c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2ae3b294ddf550c982d115d5df83bece726aac/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2ae3b294ddf550c982d115d5df83bece726aac/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ad2ae3b294ddf550c982d115d5df83bece726aac", "patch": "@@ -4534,6 +4534,7 @@ for_each_template_parm (t, fn, data, visited)\n      htab_t visited;\n {\n   struct pair_fn_data pfd;\n+  int result;\n \n   /* Set up.  */\n   pfd.fn = fn;\n@@ -4549,10 +4550,16 @@ for_each_template_parm (t, fn, data, visited)\n   else\n     pfd.visited = htab_create (37, htab_hash_pointer, htab_eq_pointer, \n \t\t\t       NULL);\n-  return walk_tree (&t, \n-\t\t    for_each_template_parm_r, \n-\t\t    &pfd,\n-\t\t    NULL) != NULL_TREE;\n+  result = walk_tree (&t, \n+\t\t      for_each_template_parm_r, \n+\t\t      &pfd,\n+\t\t      NULL) != NULL_TREE;\n+\n+  /* Clean up.  */\n+  if (!visited)\n+    htab_delete (pfd.visited);\n+\n+  return result;\n }\n \n int"}, {"sha": "4170c161ca77dbf00f6e55a2eca1a225a9ea0228", "filename": "gcc/cp/search.c", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2ae3b294ddf550c982d115d5df83bece726aac/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2ae3b294ddf550c982d115d5df83bece726aac/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ad2ae3b294ddf550c982d115d5df83bece726aac", "patch": "@@ -82,6 +82,7 @@ struct vbase_info\n \n static tree lookup_field_1 PARAMS ((tree, tree));\n static int is_subobject_of_p PARAMS ((tree, tree, tree));\n+static int is_subobject_of_p_1 PARAMS ((tree, tree, tree));\n static tree dfs_check_overlap PARAMS ((tree, void *));\n static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n static base_kind lookup_base_r\n@@ -1099,13 +1100,11 @@ accessible_p (type, decl)\n   return t != NULL_TREE;\n }\n \n-/* Routine to see if the sub-object denoted by the binfo PARENT can be\n-   found as a base class and sub-object of the object denoted by\n-   BINFO.  MOST_DERIVED is the most derived type of the hierarchy being\n-   searched.  */\n+/* Recursive helper funciton for is_subobject_of_p; see that routine\n+   for documentation of the parameters.  */\n \n static int\n-is_subobject_of_p (parent, binfo, most_derived)\n+is_subobject_of_p_1 (parent, binfo, most_derived)\n      tree parent, binfo, most_derived;\n {\n   tree binfos;\n@@ -1121,19 +1120,50 @@ is_subobject_of_p (parent, binfo, most_derived)\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      if (!CLASS_TYPE_P (TREE_TYPE (base_binfo)))\n+      tree base_type;\n+\n+      base_type = TREE_TYPE (base_binfo);\n+      if (!CLASS_TYPE_P (base_type))\n \t/* If we see a TEMPLATE_TYPE_PARM, or some such, as a base\n \t   class there's no way to descend into it.  */\n \tcontinue;\n \n-      if (is_subobject_of_p (parent, \n-                             CANONICAL_BINFO (base_binfo, most_derived),\n-                             most_derived))\n+      /* Avoid walking into the same virtual base more than once.  */\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t{\n+\t  if (CLASSTYPE_MARKED4 (base_type))\n+\t    return 0;\n+\t  SET_CLASSTYPE_MARKED4 (base_type);\n+\t  base_binfo = binfo_for_vbase (base_type, most_derived);\n+\t}\n+\n+      if (is_subobject_of_p_1 (parent, base_binfo, most_derived))\n \treturn 1;\n     }\n   return 0;\n }\n \n+/* Routine to see if the sub-object denoted by the binfo PARENT can be\n+   found as a base class and sub-object of the object denoted by\n+   BINFO.  MOST_DERIVED is the most derived type of the hierarchy being\n+   searched.  */\n+\n+static int\n+is_subobject_of_p (tree parent, tree binfo, tree most_derived)\n+{\n+  int result;\n+  tree vbase;\n+\n+  result = is_subobject_of_p_1 (parent, binfo, most_derived);\n+  /* Clear the mark bits on virtual bases.  */\n+  for (vbase = CLASSTYPE_VBASECLASSES (most_derived);\n+       vbase;\n+       vbase = TREE_CHAIN (vbase))\n+    CLEAR_CLASSTYPE_MARKED4 (TREE_TYPE (TREE_VALUE (vbase)));\n+\n+  return result;\n+}\n+\n struct lookup_field_info {\n   /* The type in which we're looking.  */\n   tree type;"}]}