{"sha": "d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUwZDIwZWNjOGI4MTUyYjdiZjVhYTQ5OGM0YTZhNzU1NmU0OTNlYw==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2000-11-04T07:42:53Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2000-11-04T07:42:53Z"}, "message": "hashtab.c (htab_expand): Change to return int.\n\n\t* hashtab.c (htab_expand): Change to return int.  Use calloc or\n \txcalloc depending on htab->return_allocation_failure.  Return zero\n \tif calloc fails.\n\t(htab_create): Update comment to cover memory allocation.\n\t(htab_try_create): New.\n\t(htab_find_slot_with_hash): Return NULL if htab_expand fails.\n  \tUpdate comment to cover this.\n\nFrom-SVN: r37247", "tree": {"sha": "1c95543158a92a3624e0db715aa490c262af08e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c95543158a92a3624e0db715aa490c262af08e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec/comments", "author": null, "committer": null, "parents": [{"sha": "5dd0f480ae41ba813754743c0f040c030be62987", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd0f480ae41ba813754743c0f040c030be62987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd0f480ae41ba813754743c0f040c030be62987"}], "stats": {"total": 76, "additions": 68, "deletions": 8}, "files": [{"sha": "f74168796adf70d3118bf582c6041d28e6bed496", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec", "patch": "@@ -1,3 +1,13 @@\n+2000-11-04  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* hashtab.c (htab_expand): Change to return int.  Use calloc or\n+ \txcalloc depending on htab->return_allocation_failure.  Return zero\n+ \tif calloc fails.\n+\t(htab_create): Update comment to cover memory allocation.\n+\t(htab_try_create): New.\n+\t(htab_find_slot_with_hash): Return NULL if htab_expand fails.\n+  \tUpdate comment to cover this.\n+\n 2000-11-03  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* hashtab.c: Change void * to PTR where necessary."}, {"sha": "9778998b240a0ec1c1e769ebd980147ad6a48c6f", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=d50d20ecc8b8152b7bf5aa498c4a6a7556e493ec", "patch": "@@ -62,7 +62,7 @@ Boston, MA 02111-1307, USA.  */\n static unsigned long higher_prime_number PARAMS ((unsigned long));\n static hashval_t hash_pointer PARAMS ((const void *));\n static int eq_pointer PARAMS ((const void *, const void *));\n-static void htab_expand PARAMS ((htab_t));\n+static int htab_expand PARAMS ((htab_t));\n static PTR *find_empty_slot_for_expand  PARAMS ((htab_t, hashval_t));\n \n /* At some point, we could make these be NULL, and modify the\n@@ -124,7 +124,7 @@ eq_pointer (p1, p2)\n /* This function creates table with length slightly longer than given\n    source length.  Created hash table is initiated as empty (all the\n    hash table entries are EMPTY_ENTRY).  The function returns the\n-   created hash table.  */\n+   created hash table.  Memory allocation must not fail.  */\n \n htab_t\n htab_create (size, hash_f, eq_f, del_f)\n@@ -142,6 +142,41 @@ htab_create (size, hash_f, eq_f, del_f)\n   result->hash_f = hash_f;\n   result->eq_f = eq_f;\n   result->del_f = del_f;\n+  result->return_allocation_failure = 0;\n+  return result;\n+}\n+\n+/* This function creates table with length slightly longer than given\n+   source length.  The created hash table is initiated as empty (all the\n+   hash table entries are EMPTY_ENTRY).  The function returns the created\n+   hash table.  Memory allocation may fail; it may return NULL.  */\n+\n+htab_t\n+htab_try_create (size, hash_f, eq_f, del_f)\n+     size_t size;\n+     htab_hash hash_f;\n+     htab_eq eq_f;\n+     htab_del del_f;\n+{\n+  htab_t result;\n+\n+  size = higher_prime_number (size);\n+  result = (htab_t) calloc (1, sizeof (struct htab));\n+  if (result == NULL)\n+    return NULL;\n+\n+  result->entries = (PTR *) calloc (size, sizeof (PTR));\n+  if (result->entries == NULL)\n+    {\n+      free (result);\n+      return NULL;\n+    }\n+\n+  result->size = size;\n+  result->hash_f = hash_f;\n+  result->eq_f = eq_f;\n+  result->del_f = del_f;\n+  result->return_allocation_failure = 1;\n   return result;\n }\n \n@@ -216,9 +251,11 @@ find_empty_slot_for_expand (htab, hash)\n    entries and repeatedly inserts the table elements.  The occupancy\n    of the table after the call will be about 50%.  Naturally the hash\n    table must already exist.  Remember also that the place of the\n-   table entries is changed.  */\n+   table entries is changed.  If memory allocation failures are allowed,\n+   this function will return zero, indicating that the table could not be\n+   expanded.  If all goes well, it will return a non-zero value.  */\n \n-static void\n+static int\n htab_expand (htab)\n      htab_t htab;\n {\n@@ -230,7 +267,16 @@ htab_expand (htab)\n   olimit = oentries + htab->size;\n \n   htab->size = higher_prime_number (htab->size * 2);\n-  htab->entries = (PTR *) xcalloc (htab->size, sizeof (PTR *));\n+\n+  if (htab->return_allocation_failure)\n+    {\n+      PTR *nentries = (PTR *) calloc (htab->size, sizeof (PTR *));\n+      if (nentries == NULL)\n+\treturn 0;\n+      htab->entries = nentries;\n+    }\n+  else\n+    htab->entries = (PTR *) xcalloc (htab->size, sizeof (PTR *));\n \n   htab->n_elements -= htab->n_deleted;\n   htab->n_deleted = 0;\n@@ -252,6 +298,7 @@ htab_expand (htab)\n   while (p < olimit);\n \n   free (oentries);\n+  return 1;\n }\n \n /* This function searches for a hash table entry equal to the given\n@@ -308,7 +355,9 @@ htab_find (htab, element)\n    equal to the given element.  To delete an entry, call this with\n    INSERT = 0, then call htab_clear_slot on the slot returned (possibly\n    after doing some checks).  To insert an entry, call this with\n-   INSERT = 1, then write the value you want into the returned slot.  */\n+   INSERT = 1, then write the value you want into the returned slot.\n+   When inserting an entry, NULL may be returned if memory allocation\n+   fails.  */\n \n PTR *\n htab_find_slot_with_hash (htab, element, hash, insert)\n@@ -322,8 +371,9 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n   hashval_t hash2;\n   size_t size;\n \n-  if (insert == INSERT && htab->size * 3 <= htab->n_elements * 4)\n-    htab_expand (htab);\n+  if (insert == INSERT && htab->size * 3 <= htab->n_elements * 4\n+      && htab_expand (htab) == 0)\n+    return NULL;\n \n   size = htab->size;\n   hash2 = 1 + hash % (size - 2);"}]}