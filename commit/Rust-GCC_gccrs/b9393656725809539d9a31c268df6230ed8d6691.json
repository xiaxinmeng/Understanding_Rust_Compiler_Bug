{"sha": "b9393656725809539d9a31c268df6230ed8d6691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzOTM2NTY3MjU4MDk1MzlkOWEzMWMyNjhkZjYyMzBlZDhkNjY5MQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-08-11T12:02:34Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-08-11T12:02:34Z"}, "message": "tree-streamer-out.c (lto_output_ts_decl_with_vis_tree_pointers): Call stream_write_tree instead of output_record_start.\n\n\t* tree-streamer-out.c (lto_output_ts_decl_with_vis_tree_pointers):\n\tCall stream_write_tree instead of output_record_start.\n\t(lto_output_ts_binfo_tree_pointers): Likewise.\n\n\t* streamer-hooks.h (stream_write_tree): Move from tree-streamer.h.\n\tConvert it to a macro.\n\t(stream_read_tree): Likewise.\n\n\t* lto-streamer.h (lto_stream_as_builtin_p): Move ...\n\t* tree-streamer.h (lto_stream_as_builtin_p): ... here.\n\n\t* lto-streamer-in.c (lto_read_tree): Call lto_streamer_cache_append\n\tand tree_read_bitfields.\n\t* lto-streamer-out.c (lto_is_streamable): Move from lto-streamer.c\n\t(lto_write_tree): Call it.\n\t* lto-streamer.c (lto_is_streamable): Move to lto-streamer-out.c\n\t* streamer-hooks.h (struct streamer_hooks): Remove fields\n\tname, is_streamable and alloc_tree. Update all users.\n\t* tree-streamer-in.c (tree_read_bitfields): Factor out of ...\n\t(lto_materialize_tree): ... here.\n\tHandle CALL_EXPR codes.\n\tRemove call to lto_streamer_cache_append.\n\t* tree-streamer-out.c (lto_output_tree_header): Handle\n\tCALL_EXPR nodes.\n\t* tree-streamer.h (tree_read_bitfields): Declare.\n\n\t* Makefile.in (TREE_STREAMER_H): Add STREAMER_HOOKS_H.\n\t(gimple-streamer-in.o): Add dependency on TREE_STREAMER_H.\n\t* tree-streamer.h (stream_read_tree): New.  Replace all calls\n\tto lto_input_tree with it.\n\t(stream_write_tree): New.  Replace all calls to lto_output_tree,\n\tlto_output_tree_ref and lto_output_tree_or_ref with it.\n\t* lto-streamer-in.c (lto_read_tree): Inline code from\n\tlto_streamer_read_tree.\n\t(lto_input_tree): Move from tree-streamer-in.c.\n\t* lto-streamer-out.c (lto_output_tree_ref): Make static.\n\tRemove handling of NULL values for EXPR.\n\tDo not handle EXPRs that are not indexable.\n\t(lto_write_tree): Move from tree-streamer-out.c.\n\tInline lto_streamer_write_tree.\n\t(lto_output_tree): Move from tree-streamer-out.c.\n\tIf REF_P is true and EXPR is indexable, call lto_output_tree_ref.\n\t* lto-streamer.c (lto_record_common_node): Move to tree-streamer.c.\n\t(lto_preload_common_nodes): Likewise.\n\tRemove assertions and adjustments for nodes\n\tmain_identifier_node, ptrdiff_type_node and fileptr_type_node.\n\t(lto_streamer_hooks_init): Set streamer_hooks.write_tree to\n\tlto_output_tree and streamer_hooks.read_tree to\n\tlto_input_tree.\n\t* lto-streamer.h (lto_input_tree): Declare.\n\t(lto_output_tree_ref): Remove.\n\t* streamer-hooks.h (struct streamer_hooks): Remove fields\n\tpreload_common_nodes, indexable_with_decls_p,\n\tpack_value_fields, unpack_value_fields, output_tree_header and\n\thas_unique_integer_csts_p.\n\tUpdate all users.\n\t* tree-streamer-in.c (lto_materialize_tree): Make extern.\n\t(lto_input_tree_pointers): Likewise.\n\t(lto_read_tree): Move to lto-streamer-in.c.\n\t(lto_input_integer_cst): Make extern.\n\t(lto_get_pickled_tree): Likewise.\n\t(lto_get_builtin_tree): Likewise.\n\t(lto_input_tree): Move to lto-streamer-in.c.\n\t* tree-streamer-out.c (pack_value_fields): Make extern.\n\t(lto_output_tree_or_ref): Remove.  Replace all callers with\n\tcalls to stream_write_tree.\n\t(lto_output_builtin_tree): Make extern.\n\t(lto_streamer_write_tree): Inline into lto_write_tree.\n\t(lto_output_tree_pointers): Make extern.\n\t(lto_output_tree_header): Likewise.\n\t(lto_output_integer_cst): Likewise.\n\t(lto_write_tree): Move to lto-streamer-out.c.\n\t(lto_output_tree): Likewise.\n\t* tree-streamer.c (lto_record_common_node): Move from\n\tlto-streamer.c\n\t(preload_common_nodes): Likewise.\n\t(lto_streamer_cache_create): Call it.\n\t* tree-streamer.h: Include streamer-hooks.h.\n\t(stream_write_tree): New.\n\t(stream_read_tree): New.\n\t(lto_input_tree): Remove.\n\t(lto_materialize_tree): Declare.\n\t(lto_input_tree_pointers): Declare.\n\t(lto_get_pickled_tree): Declare.\n\t(lto_get_builtin_tree): Declare.\n\t(lto_input_integer_cst): Declare.\n\t(lto_output_tree_header): Declare.\n\t(pack_value_fields): Declare.\n\t(lto_output_tree_pointers): Declare.\n\t(lto_output_integer_cst): Declare.\n\t(lto_output_builtin_tree): Declare.\n\nFrom-SVN: r177661", "tree": {"sha": "c67c6c54079ea71a807b5373467385939adc98f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c67c6c54079ea71a807b5373467385939adc98f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9393656725809539d9a31c268df6230ed8d6691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9393656725809539d9a31c268df6230ed8d6691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9393656725809539d9a31c268df6230ed8d6691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9393656725809539d9a31c268df6230ed8d6691/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf596bc73f4158c9b6a999e5a921b0616e2e1d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf596bc73f4158c9b6a999e5a921b0616e2e1d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf596bc73f4158c9b6a999e5a921b0616e2e1d6c"}], "stats": {"total": 1382, "additions": 682, "deletions": 700}, "files": [{"sha": "4fc79a08fdf22caf370e73a6f2466559f4387a23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -1,3 +1,96 @@\n+2011-08-11   Diego Novillo  <dnovillo@google.com>\n+\n+\t* tree-streamer-out.c (lto_output_ts_decl_with_vis_tree_pointers):\n+\tCall stream_write_tree instead of output_record_start.\n+\t(lto_output_ts_binfo_tree_pointers): Likewise.\n+\n+\t* streamer-hooks.h (stream_write_tree): Move from tree-streamer.h.\n+\tConvert it to a macro.\n+\t(stream_read_tree): Likewise.\n+\n+\t* lto-streamer.h (lto_stream_as_builtin_p): Move ...\n+\t* tree-streamer.h (lto_stream_as_builtin_p): ... here.\n+\n+\t* lto-streamer-in.c (lto_read_tree): Call lto_streamer_cache_append\n+\tand tree_read_bitfields.\n+\t* lto-streamer-out.c (lto_is_streamable): Move from lto-streamer.c\n+\t(lto_write_tree): Call it.\n+\t* lto-streamer.c (lto_is_streamable): Move to lto-streamer-out.c\n+\t* streamer-hooks.h (struct streamer_hooks): Remove fields\n+\tname, is_streamable and alloc_tree. Update all users.\n+\t* tree-streamer-in.c (tree_read_bitfields): Factor out of ...\n+\t(lto_materialize_tree): ... here.\n+\tHandle CALL_EXPR codes.\n+\tRemove call to lto_streamer_cache_append.\n+\t* tree-streamer-out.c (lto_output_tree_header): Handle\n+\tCALL_EXPR nodes.\n+\t* tree-streamer.h (tree_read_bitfields): Declare.\n+\n+\t* Makefile.in (TREE_STREAMER_H): Add STREAMER_HOOKS_H.\n+\t(gimple-streamer-in.o): Add dependency on TREE_STREAMER_H.\n+\t* tree-streamer.h (stream_read_tree): New.  Replace all calls\n+\tto lto_input_tree with it.\n+\t(stream_write_tree): New.  Replace all calls to lto_output_tree,\n+\tlto_output_tree_ref and lto_output_tree_or_ref with it.\n+\t* lto-streamer-in.c (lto_read_tree): Inline code from\n+\tlto_streamer_read_tree.\n+\t(lto_input_tree): Move from tree-streamer-in.c.\n+\t* lto-streamer-out.c (lto_output_tree_ref): Make static.\n+\tRemove handling of NULL values for EXPR.\n+\tDo not handle EXPRs that are not indexable.\n+\t(lto_write_tree): Move from tree-streamer-out.c.\n+\tInline lto_streamer_write_tree.\n+\t(lto_output_tree): Move from tree-streamer-out.c.\n+\tIf REF_P is true and EXPR is indexable, call lto_output_tree_ref.\n+\t* lto-streamer.c (lto_record_common_node): Move to tree-streamer.c.\n+\t(lto_preload_common_nodes): Likewise.\n+\tRemove assertions and adjustments for nodes\n+\tmain_identifier_node, ptrdiff_type_node and fileptr_type_node.\n+\t(lto_streamer_hooks_init): Set streamer_hooks.write_tree to\n+\tlto_output_tree and streamer_hooks.read_tree to\n+\tlto_input_tree.\n+\t* lto-streamer.h (lto_input_tree): Declare.\n+\t(lto_output_tree_ref): Remove.\n+\t* streamer-hooks.h (struct streamer_hooks): Remove fields\n+\tpreload_common_nodes, indexable_with_decls_p,\n+\tpack_value_fields, unpack_value_fields and output_tree_header.\n+\tUpdate all users.\n+\t* tree-streamer-in.c (lto_materialize_tree): Make extern.\n+\t(lto_input_tree_pointers): Likewise.\n+\t(lto_read_tree): Move to lto-streamer-in.c.\n+\t(lto_input_integer_cst): Make extern.\n+\t(lto_get_pickled_tree): Likewise.\n+\t(lto_get_builtin_tree): Likewise.\n+\t(lto_input_tree): Move to lto-streamer-in.c.\n+\t* tree-streamer-out.c (pack_value_fields): Make extern.\n+\t(lto_output_tree_or_ref): Remove.  Replace all callers with\n+\tcalls to stream_write_tree.\n+\t(lto_output_builtin_tree): Make extern.\n+\t(lto_streamer_write_tree): Inline into lto_write_tree.\n+\t(lto_output_tree_pointers): Make extern.\n+\t(lto_output_tree_header): Likewise.\n+\t(lto_output_integer_cst): Likewise.\n+\t(lto_write_tree): Move to lto-streamer-out.c.\n+\t(lto_output_tree): Likewise.\n+\t* tree-streamer.c (lto_record_common_node): Move from\n+\tlto-streamer.c\n+\t(preload_common_nodes): Likewise.\n+\t(lto_streamer_cache_create): Call it.\n+\t* tree-streamer.h: Include streamer-hooks.h.\n+\t(stream_write_tree): New.\n+\t(stream_read_tree): New.\n+\t(lto_input_tree): Remove.\n+\t(lto_materialize_tree): Declare.\n+\t(lto_input_tree_pointers): Declare.\n+\t(lto_get_pickled_tree): Declare.\n+\t(lto_get_builtin_tree): Declare.\n+\t(lto_input_integer_cst): Declare.\n+\t(lto_output_tree_header): Declare.\n+\t(pack_value_fields): Declare.\n+\t(lto_output_tree_pointers): Declare.\n+\t(lto_output_integer_cst): Declare.\n+\t(lto_output_builtin_tree): Declare.\n+\n 2011-08-11  Sergey Grechanik  <mouseentity@ispras.ru>\n \n \t* sel-sched-ir.c (get_seqno_of_a_pred): Rename to"}, {"sha": "d7c6641545cd3c11fa4e0e0e4c261a230df7c61f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -1000,7 +1000,8 @@ LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n DATA_STREAMER_H = data-streamer.h $(VEC_H) $(LTO_STREAMER_H)\n GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n \t\t    $(FUNCTION_H)\n-TREE_STREAMER_H = tree-streamer.h $(TREE_H) $(LTO_STREAMER_H)\n+TREE_STREAMER_H = tree-streamer.h $(TREE_H) $(LTO_STREAMER_H) \\\n+\t\t  $(STREAMER_HOOKS_H)\n STREAMER_HOOKS_H = streamer-hooks.h $(TREE_H)\n TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H) alloc-pool.h\n@@ -2305,7 +2306,7 @@ gimple-streamer-in.o: gimple-streamer-in.c $(CONFIG_H) $(SYSTEM_H) \\\n     $(TREE_STREAMER_H) $(DIAGNOSTIC_H)\n gimple-streamer-out.o: gimple-streamer-out.c $(CONFIG_H) $(SYSTEM_H) \\\n     coretypes.h $(GIMPLE_STREAMER_H) $(DATA_STREAMER_H) $(TREE_FLOW_H) \\\n-    $(LTO_STREAMER_H)\n+    $(LTO_STREAMER_H) $(TREE_STREAMER_H)\n tree-streamer.o: tree-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n     $(TREE_STREAMER_H) $(STREAMER_HOOKS_H)\n tree-streamer-in.o: tree-streamer-in.c $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "78ab729062b6c59d21925d4392255e1153fbc0e2", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -52,7 +52,7 @@ input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n      were in the original program.  */\n   for (i = 0; i < len; i++)\n     {\n-      tree def = lto_input_tree (ib, data_in);\n+      tree def = stream_read_tree (ib, data_in);\n       int src_index = lto_input_uleb128 (ib);\n       location_t arg_loc = lto_input_location (ib, data_in);\n       basic_block sbb = BASIC_BLOCK_FOR_FUNCTION (fn, src_index);\n@@ -103,7 +103,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   gimple_set_location (stmt, lto_input_location (ib, data_in));\n \n   /* Read lexical block reference.  */\n-  gimple_set_block (stmt, lto_input_tree (ib, data_in));\n+  gimple_set_block (stmt, stream_read_tree (ib, data_in));\n \n   /* Read in all the operands.  */\n   switch (code)\n@@ -113,7 +113,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n-      gimple_eh_must_not_throw_set_fndecl (stmt, lto_input_tree (ib, data_in));\n+      gimple_eh_must_not_throw_set_fndecl (stmt, stream_read_tree (ib, data_in));\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n@@ -143,7 +143,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n     case GIMPLE_DEBUG:\n       for (i = 0; i < num_ops; i++)\n \t{\n-\t  tree op = lto_input_tree (ib, data_in);\n+\t  tree op = stream_read_tree (ib, data_in);\n \t  gimple_set_op (stmt, i, op);\n \t  if (!op)\n \t    continue;\n@@ -223,7 +223,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t    gimple_call_set_internal_fn\n \t      (stmt, lto_input_enum (ib, internal_fn, IFN_LAST));\n \t  else\n-\t    gimple_call_set_fntype (stmt, lto_input_tree (ib, data_in));\n+\t    gimple_call_set_fntype (stmt, stream_read_tree (ib, data_in));\n \t}\n       break;\n "}, {"sha": "233862c96ace2589bc097f4ae6ad231466089169", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"data-streamer.h\"\n #include \"gimple-streamer.h\"\n #include \"lto-streamer.h\"\n+#include \"tree-streamer.h\"\n \n /* Output PHI function PHI to the main stream in OB.  */\n \n@@ -40,7 +41,7 @@ output_phi (struct output_block *ob, gimple phi)\n \n   for (i = 0; i < len; i++)\n     {\n-      lto_output_tree_ref (ob, gimple_phi_arg_def (phi, i));\n+      stream_write_tree (ob, gimple_phi_arg_def (phi, i), true);\n       output_uleb128 (ob, gimple_phi_arg_edge (phi, i)->src->index);\n       lto_output_location (ob, gimple_phi_arg_location (phi, i));\n     }\n@@ -76,7 +77,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   lto_output_location (ob, gimple_location (stmt));\n \n   /* Emit the lexical block holding STMT.  */\n-  lto_output_tree (ob, gimple_block (stmt), true);\n+  stream_write_tree (ob, gimple_block (stmt), true);\n \n   /* Emit the operands.  */\n   switch (gimple_code (stmt))\n@@ -86,7 +87,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n-      lto_output_tree_ref (ob, gimple_eh_must_not_throw_fndecl (stmt));\n+      stream_write_tree (ob, gimple_eh_must_not_throw_fndecl (stmt), true);\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n@@ -133,15 +134,15 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n \t\t  TREE_THIS_VOLATILE (*basep) = volatilep;\n \t\t}\n \t    }\n-\t  lto_output_tree_ref (ob, op);\n+\t  stream_write_tree (ob, op, true);\n \t}\n       if (is_gimple_call (stmt))\n \t{\n \t  if (gimple_call_internal_p (stmt))\n \t    lto_output_enum (ob->main_stream, internal_fn,\n \t\t\t     IFN_LAST, gimple_call_internal_fn (stmt));\n \t  else\n-\t    lto_output_tree_ref (ob, gimple_call_fntype (stmt));\n+\t    stream_write_tree (ob, gimple_call_fntype (stmt), true);\n \t}\n       break;\n "}, {"sha": "f3214e2caea2f5a06e6116228e4b31ce2d5e7c4d", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -2407,7 +2407,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  struct condition c;\n \t  c.operand_num = lto_input_uleb128 (&ib);\n \t  c.code = (enum tree_code) lto_input_uleb128 (&ib);\n-\t  c.val = lto_input_tree (&ib, data_in);\n+\t  c.val = stream_read_tree (&ib, data_in);\n \t  VEC_safe_push (condition, gc, info->conds, &c);\n \t}\n       count2 = lto_input_uleb128 (&ib);\n@@ -2552,7 +2552,7 @@ inline_write_summary (cgraph_node_set set,\n \t\t\t\t\t c->operand_num);\n \t      lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t\t c->code);\n-\t      lto_output_tree (ob, c->val, true);\n+\t      stream_write_tree (ob, c->val, true);\n \t    }\n \t  lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t     VEC_length (size_time_entry, info->entry));"}, {"sha": "0997cf5e7e8b00f2fae4edcbf771d903cbfe4bd7", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -2652,13 +2652,13 @@ ipa_write_jump_function (struct output_block *ob,\n     case IPA_JF_UNKNOWN:\n       break;\n     case IPA_JF_KNOWN_TYPE:\n-      lto_output_tree (ob, jump_func->value.base_binfo, true);\n+      stream_write_tree (ob, jump_func->value.base_binfo, true);\n       break;\n     case IPA_JF_CONST:\n-      lto_output_tree (ob, jump_func->value.constant, true);\n+      stream_write_tree (ob, jump_func->value.constant, true);\n       break;\n     case IPA_JF_PASS_THROUGH:\n-      lto_output_tree (ob, jump_func->value.pass_through.operand, true);\n+      stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n       lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t jump_func->value.pass_through.formal_id);\n       lto_output_uleb128_stream (ob->main_stream,\n@@ -2667,13 +2667,13 @@ ipa_write_jump_function (struct output_block *ob,\n     case IPA_JF_ANCESTOR:\n       lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t jump_func->value.ancestor.offset);\n-      lto_output_tree (ob, jump_func->value.ancestor.type, true);\n+      stream_write_tree (ob, jump_func->value.ancestor.type, true);\n       lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t jump_func->value.ancestor.formal_id);\n       break;\n     case IPA_JF_CONST_MEMBER_PTR:\n-      lto_output_tree (ob, jump_func->value.member_cst.pfn, true);\n-      lto_output_tree (ob, jump_func->value.member_cst.delta, false);\n+      stream_write_tree (ob, jump_func->value.member_cst.pfn, true);\n+      stream_write_tree (ob, jump_func->value.member_cst.delta, false);\n       break;\n     }\n }\n@@ -2692,24 +2692,24 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     case IPA_JF_UNKNOWN:\n       break;\n     case IPA_JF_KNOWN_TYPE:\n-      jump_func->value.base_binfo = lto_input_tree (ib, data_in);\n+      jump_func->value.base_binfo = stream_read_tree (ib, data_in);\n       break;\n     case IPA_JF_CONST:\n-      jump_func->value.constant = lto_input_tree (ib, data_in);\n+      jump_func->value.constant = stream_read_tree (ib, data_in);\n       break;\n     case IPA_JF_PASS_THROUGH:\n-      jump_func->value.pass_through.operand = lto_input_tree (ib, data_in);\n+      jump_func->value.pass_through.operand = stream_read_tree (ib, data_in);\n       jump_func->value.pass_through.formal_id = lto_input_uleb128 (ib);\n       jump_func->value.pass_through.operation = (enum tree_code) lto_input_uleb128 (ib);\n       break;\n     case IPA_JF_ANCESTOR:\n       jump_func->value.ancestor.offset = lto_input_uleb128 (ib);\n-      jump_func->value.ancestor.type = lto_input_tree (ib, data_in);\n+      jump_func->value.ancestor.type = stream_read_tree (ib, data_in);\n       jump_func->value.ancestor.formal_id = lto_input_uleb128 (ib);\n       break;\n     case IPA_JF_CONST_MEMBER_PTR:\n-      jump_func->value.member_cst.pfn = lto_input_tree (ib, data_in);\n-      jump_func->value.member_cst.delta = lto_input_tree (ib, data_in);\n+      jump_func->value.member_cst.pfn = stream_read_tree (ib, data_in);\n+      jump_func->value.member_cst.delta = stream_read_tree (ib, data_in);\n       break;\n     }\n }\n@@ -2733,7 +2733,7 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   if (ii->polymorphic)\n     {\n       lto_output_sleb128_stream (ob->main_stream, ii->otr_token);\n-      lto_output_tree (ob, ii->otr_type, true);\n+      stream_write_tree (ob, ii->otr_type, true);\n     }\n }\n \n@@ -2755,7 +2755,7 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   if (ii->polymorphic)\n     {\n       ii->otr_token = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n-      ii->otr_type = lto_input_tree (ib, data_in);\n+      ii->otr_type = stream_read_tree (ib, data_in);\n     }\n }\n "}, {"sha": "00462d81e3d0d91a95439a37918ff82f6fcc300d", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -1581,7 +1581,7 @@ output_node_opt_summary (struct output_block *ob,\n          mechanism to store function local declarations into summaries.  */\n       gcc_assert (parm);\n       lto_output_uleb128_stream (ob->main_stream, parm_num);\n-      lto_output_tree (ob, map->new_tree, true);\n+      stream_write_tree (ob, map->new_tree, true);\n       bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, map->replace_p, 1);\n       bp_pack_value (&bp, map->ref_p, 1);\n@@ -1688,7 +1688,7 @@ input_node_opt_summary (struct cgraph_node *node,\n \tparm_num --;\n       map->parm_num = lto_input_uleb128 (ib_main);\n       map->old_tree = NULL;\n-      map->new_tree = lto_input_tree (ib_main, data_in);\n+      map->new_tree = stream_read_tree (ib_main, data_in);\n       bp = lto_input_bitpack (ib_main);\n       map->replace_p = bp_unpack_value (&bp, 1);\n       map->ref_p = bp_unpack_value (&bp, 1);"}, {"sha": "16947c7338b8b7a9506a42ec0fdfb32104339e56", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 109, "deletions": 29, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -195,7 +195,7 @@ lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n    TAG is the expected node that should be found in IB, if TAG belongs\n    to one of the indexable trees, expect to read a reference index to\n    be looked up in one of the symbol tables, otherwise read the pysical\n-   representation of the tree using lto_input_tree.  FN is the\n+   representation of the tree using stream_read_tree.  FN is the\n    function scope for the read tree.  */\n \n tree\n@@ -280,9 +280,9 @@ lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n \n       /* Read the catch node.  */\n       n = ggc_alloc_cleared_eh_catch_d ();\n-      n->type_list = lto_input_tree (ib, data_in);\n-      n->filter_list = lto_input_tree (ib, data_in);\n-      n->label = lto_input_tree (ib, data_in);\n+      n->type_list = stream_read_tree (ib, data_in);\n+      n->filter_list = stream_read_tree (ib, data_in);\n+      n->label = stream_read_tree (ib, data_in);\n \n       /* Register all the types in N->FILTER_LIST.  */\n       for (list = n->filter_list; list; list = TREE_CHAIN (list))\n@@ -351,8 +351,8 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n \t  tree l;\n \n \t  r->type = ERT_ALLOWED_EXCEPTIONS;\n-\t  r->u.allowed.type_list = lto_input_tree (ib, data_in);\n-\t  r->u.allowed.label = lto_input_tree (ib, data_in);\n+\t  r->u.allowed.type_list = stream_read_tree (ib, data_in);\n+\t  r->u.allowed.label = stream_read_tree (ib, data_in);\n \t  r->u.allowed.filter = lto_input_uleb128 (ib);\n \n \t  for (l = r->u.allowed.type_list; l ; l = TREE_CHAIN (l))\n@@ -362,7 +362,7 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n \n       case LTO_ert_must_not_throw:\n \tr->type = ERT_MUST_NOT_THROW;\n-\tr->u.must_not_throw.failure_decl = lto_input_tree (ib, data_in);\n+\tr->u.must_not_throw.failure_decl = stream_read_tree (ib, data_in);\n \tr->u.must_not_throw.failure_loc = lto_input_location (ib, data_in);\n \tbreak;\n \n@@ -397,7 +397,7 @@ input_eh_lp (struct lto_input_block *ib, struct data_in *data_in, int ix)\n   gcc_assert (lp->index == ix);\n   lp->next_lp = (eh_landing_pad) (intptr_t) lto_input_sleb128 (ib);\n   lp->region = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n-  lp->post_landing_pad = lto_input_tree (ib, data_in);\n+  lp->post_landing_pad = stream_read_tree (ib, data_in);\n \n   return lp;\n }\n@@ -542,7 +542,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n       VEC_safe_grow (tree, gc, fn->eh->ttype_data, len);\n       for (i = 0; i < len; i++)\n \t{\n-\t  tree ttype = lto_input_tree (ib, data_in);\n+\t  tree ttype = stream_read_tree (ib, data_in);\n \t  VEC_replace (tree, fn->eh->ttype_data, i, ttype);\n \t}\n     }\n@@ -557,7 +557,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n \t  VEC_safe_grow (tree, gc, fn->eh->ehspec_data.arm_eabi, len);\n \t  for (i = 0; i < len; i++)\n \t    {\n-\t      tree t = lto_input_tree (ib, data_in);\n+\t      tree t = stream_read_tree (ib, data_in);\n \t      VEC_replace (tree, fn->eh->ehspec_data.arm_eabi, i, t);\n \t    }\n \t}\n@@ -700,7 +700,7 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n \tVEC_quick_push (tree, SSANAMES (fn), NULL_TREE);\n \n       is_default_def = (lto_input_1_unsigned (ib) != 0);\n-      name = lto_input_tree (ib, data_in);\n+      name = stream_read_tree (ib, data_in);\n       ssa_name = make_ssa_name_fn (fn, name, gimple_build_nop ());\n \n       if (is_default_def)\n@@ -800,8 +800,8 @@ input_function (tree fn_decl, struct data_in *data_in,\n   fn->curr_properties = lto_input_uleb128 (ib);\n \n   /* Read the static chain and non-local goto save area.  */\n-  fn->static_chain_decl = lto_input_tree (ib, data_in);\n-  fn->nonlocal_goto_save_area = lto_input_tree (ib, data_in);\n+  fn->static_chain_decl = stream_read_tree (ib, data_in);\n+  fn->nonlocal_goto_save_area = stream_read_tree (ib, data_in);\n \n   /* Read all the local symbols.  */\n   len = lto_input_sleb128 (ib);\n@@ -811,14 +811,14 @@ input_function (tree fn_decl, struct data_in *data_in,\n       VEC_safe_grow (tree, gc, fn->local_decls, len);\n       for (i = 0; i < len; i++)\n \t{\n-\t  tree t = lto_input_tree (ib, data_in);\n+\t  tree t = stream_read_tree (ib, data_in);\n \t  VEC_replace (tree, fn->local_decls, i, t);\n \t}\n     }\n \n   /* Read all function arguments.  We need to re-map them here to the\n      arguments of the merged function declaration.  */\n-  args = lto_input_tree (ib, data_in);\n+  args = stream_read_tree (ib, data_in);\n   for (oarg = args, narg = DECL_ARGUMENTS (fn_decl);\n        oarg && narg;\n        oarg = TREE_CHAIN (oarg), narg = TREE_CHAIN (narg))\n@@ -839,7 +839,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n   input_eh_regions (ib, data_in, fn);\n \n   /* Read the tree of lexical scopes for the function.  */\n-  DECL_INITIAL (fn_decl) = lto_input_tree (ib, data_in);\n+  DECL_INITIAL (fn_decl) = stream_read_tree (ib, data_in);\n   gcc_assert (DECL_INITIAL (fn_decl));\n   DECL_SAVED_TREE (fn_decl) = NULL_TREE;\n   node = cgraph_get_create_node (fn_decl);\n@@ -920,15 +920,15 @@ input_alias_pairs (struct lto_input_block *ib, struct data_in *data_in)\n \n   clear_line_info (data_in);\n \n-  var = lto_input_tree (ib, data_in);\n+  var = stream_read_tree (ib, data_in);\n   while (var)\n     {\n       const char *orig_name, *new_name;\n       alias_pair *p;\n \n       p = VEC_safe_push (alias_pair, gc, alias_pairs, NULL);\n       p->decl = var;\n-      p->target = lto_input_tree (ib, data_in);\n+      p->target = stream_read_tree (ib, data_in);\n \n       /* If the target is a static object, we may have registered a\n \t new name for it to avoid clashes between statics coming from\n@@ -938,7 +938,7 @@ input_alias_pairs (struct lto_input_block *ib, struct data_in *data_in)\n       if (strcmp (orig_name, new_name) != 0)\n \tp->target = get_identifier (new_name);\n \n-      var = lto_input_tree (ib, data_in);\n+      var = stream_read_tree (ib, data_in);\n     }\n }\n \n@@ -1044,18 +1044,98 @@ lto_input_constructors_and_inits (struct lto_file_decl_data *file_data,\n }\n \n \n-/* LTO streamer hook for reading GIMPLE trees.  IB and DATA_IN are as in\n-   lto_read_tree.  EXPR is the tree was materialized by lto_read_tree and\n-   needs GIMPLE specific data to be filled in.  */\n+/* Read the physical representation of a tree node with tag TAG from\n+   input block IB using the per-file context in DATA_IN.  */\n \n-void\n-lto_streamer_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t\ttree expr)\n+static tree\n+lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t       enum LTO_tags tag)\n {\n-  if (DECL_P (expr)\n-      && TREE_CODE (expr) != FUNCTION_DECL\n-      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-    DECL_INITIAL (expr) = lto_input_tree (ib, data_in);\n+  /* Instantiate a new tree node.  */\n+  tree result = lto_materialize_tree (ib, data_in, tag);\n+\n+  /* Enter RESULT in the reader cache.  This will make RESULT\n+     available so that circular references in the rest of the tree\n+     structure can be resolved in subsequent calls to stream_read_tree.  */\n+  lto_streamer_cache_append (data_in->reader_cache, result);\n+\n+  /* Read all the bitfield values in RESULT.  Note that for LTO, we\n+     only write language-independent bitfields, so no more unpacking is\n+     needed.  */\n+  tree_read_bitfields (ib, result);\n+\n+  /* Read all the pointer fields in RESULT.  */\n+  lto_input_tree_pointers (ib, data_in, result);\n+\n+  /* Read any LTO-specific data not read by the tree streamer.  */\n+  if (DECL_P (result)\n+      && TREE_CODE (result) != FUNCTION_DECL\n+      && TREE_CODE (result) != TRANSLATION_UNIT_DECL)\n+    DECL_INITIAL (result) = stream_read_tree (ib, data_in);\n+\n+  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n+  if (TREE_CODE (result) == FUNCTION_DECL)\n+    gcc_assert (!lto_stream_as_builtin_p (result));\n+\n+  /* end_marker = */ lto_input_1_unsigned (ib);\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Remove the mapping to RESULT's original address set by\n+     lto_materialize_tree.  */\n+  lto_orig_address_remove (result);\n+#endif\n+\n+  return result;\n+}\n+\n+\n+/* Read a tree from input block IB using the per-file context in\n+   DATA_IN.  This context is used, for example, to resolve references\n+   to previously read nodes.  */\n+\n+tree\n+lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  enum LTO_tags tag;\n+  tree result;\n+\n+  tag = input_record_start (ib);\n+  gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n+\n+  if (tag == LTO_null)\n+    result = NULL_TREE;\n+  else if (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n+    {\n+      /* If TAG is a reference to an indexable tree, the next value\n+\t in IB is the index into the table where we expect to find\n+\t that tree.  */\n+      result = lto_input_tree_ref (ib, data_in, cfun, tag);\n+    }\n+  else if (tag == LTO_tree_pickle_reference)\n+    {\n+      /* If TAG is a reference to a previously read tree, look it up in\n+\t the reader cache.  */\n+      result = lto_get_pickled_tree (ib, data_in);\n+    }\n+  else if (tag == LTO_builtin_decl)\n+    {\n+      /* If we are going to read a built-in function, all we need is\n+\t the code and class.  */\n+      result = lto_get_builtin_tree (ib, data_in);\n+    }\n+  else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n+    {\n+      /* For integer constants we only need the type and its hi/low\n+\t words.  */\n+      result = lto_input_integer_cst (ib, data_in);\n+    }\n+  else\n+    {\n+      /* Otherwise, materialize a new node from IB.  */\n+      result = lto_read_tree (ib, data_in, tag);\n+    }\n+\n+  return result;\n }\n \n "}, {"sha": "14bf878724555480ae0c59e42e43c20c27f5d7e6", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 167, "deletions": 51, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -188,25 +188,11 @@ lto_output_location (struct output_block *ob, location_t loc)\n    output block OB.  Otherwise, output the physical representation of\n    EXPR to OB.  */\n \n-void\n+static void\n lto_output_tree_ref (struct output_block *ob, tree expr)\n {\n   enum tree_code code;\n \n-  if (expr == NULL_TREE)\n-    {\n-      output_record_start (ob, LTO_null);\n-      return;\n-    }\n-\n-  if (!tree_is_indexable (expr))\n-    {\n-      /* Even though we are emitting the physical representation of\n-\t EXPR, its leaves must be emitted as references.  */\n-      lto_output_tree (ob, expr, true);\n-      return;\n-    }\n-\n   if (TYPE_P (expr))\n     {\n       output_type_ref (ob, expr);\n@@ -233,8 +219,7 @@ lto_output_tree_ref (struct output_block *ob, tree expr)\n \n     case VAR_DECL:\n     case DEBUG_EXPR_DECL:\n-      gcc_assert (decl_function_context (expr) == NULL\n-\t\t  || TREE_STATIC (expr));\n+      gcc_assert (decl_function_context (expr) == NULL || TREE_STATIC (expr));\n       output_record_start (ob, LTO_global_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n@@ -276,22 +261,153 @@ lto_output_tree_ref (struct output_block *ob, tree expr)\n       break;\n \n     default:\n-      {\n-\t/* See if the streamer allows this node to be indexable\n-\t   like other global declarations.  */\n-\tif (streamer_hooks.indexable_with_decls_p\n-\t    && streamer_hooks.indexable_with_decls_p (expr))\n-\t  {\n-\t    output_record_start (ob, LTO_global_decl_ref);\n-\t    lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-\t  }\n-\telse\n-\t  {\n-\t    /* No other node is indexable, so it should have been\n-\t      handled by lto_output_tree.  */\n-\t    gcc_unreachable ();\n-\t  }\n-      }\n+      /* No other node is indexable, so it should have been handled by\n+\t lto_output_tree.  */\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Return true if EXPR is a tree node that can be written to disk.  */\n+\n+static inline bool\n+lto_is_streamable (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  /* Notice that we reject SSA_NAMEs as well.  We only emit the SSA\n+     name version in lto_output_tree_ref (see output_ssa_names).  */\n+  return !is_lang_specific (expr)\n+\t && code != SSA_NAME\n+\t && code != CALL_EXPR\n+\t && code != LANG_TYPE\n+\t && code != MODIFY_EXPR\n+\t && code != INIT_EXPR\n+\t && code != TARGET_EXPR\n+\t && code != BIND_EXPR\n+\t && code != WITH_CLEANUP_EXPR\n+\t && code != STATEMENT_LIST\n+\t && code != OMP_CLAUSE\n+\t && code != OPTIMIZATION_NODE\n+\t && (code == CASE_LABEL_EXPR\n+\t     || code == DECL_EXPR\n+\t     || TREE_CODE_CLASS (code) != tcc_statement);\n+}\n+\n+\n+/* Write a physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  IX is the index into the streamer cache\n+   where EXPR is stored.  */\n+\n+static void\n+lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  struct bitpack_d bp;\n+\n+  if (!lto_is_streamable (expr))\n+    internal_error (\"tree code %qs is not supported in LTO streams\",\n+\t            tree_code_name[TREE_CODE (expr)]);\n+\n+  /* Write the header, containing everything needed to materialize\n+     EXPR on the reading side.  */\n+  lto_output_tree_header (ob, expr);\n+\n+  /* Pack all the non-pointer fields in EXPR into a bitpack and write\n+     the resulting bitpack.  */\n+  bp = bitpack_create (ob->main_stream);\n+  pack_value_fields (&bp, expr);\n+  lto_output_bitpack (&bp);\n+\n+  /* Write all the pointer fields in EXPR.  */\n+  lto_output_tree_pointers (ob, expr, ref_p);\n+\n+  /* Write any LTO-specific data to OB.  */\n+  if (DECL_P (expr)\n+      && TREE_CODE (expr) != FUNCTION_DECL\n+      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+    {\n+      /* Handle DECL_INITIAL for symbols.  */\n+      tree initial = DECL_INITIAL (expr);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n+\t  && initial)\n+\t{\n+\t  lto_varpool_encoder_t varpool_encoder;\n+\t  struct varpool_node *vnode;\n+\n+\t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n+\t  vnode = varpool_get_node (expr);\n+\t  if (!vnode)\n+\t    initial = error_mark_node;\n+\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t\t\t\t\t\t\t      vnode))\n+\t    initial = NULL;\n+\t}\n+\n+      stream_write_tree (ob, initial, ref_p);\n+    }\n+\n+  /* Mark the end of EXPR.  */\n+  output_zero (ob);\n+}\n+\n+\n+/* Emit the physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  */\n+\n+void\n+lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  unsigned ix;\n+  bool existed_p;\n+\n+  if (expr == NULL_TREE)\n+    {\n+      output_record_start (ob, LTO_null);\n+      return;\n+    }\n+\n+  if (ref_p && tree_is_indexable (expr))\n+    {\n+      lto_output_tree_ref (ob, expr);\n+      return;\n+    }\n+\n+  /* INTEGER_CST nodes are special because they need their original type\n+     to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    {\n+      lto_output_integer_cst (ob, expr, ref_p);\n+      return;\n+    }\n+\n+  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix);\n+  if (existed_p)\n+    {\n+      /* If a node has already been streamed out, make sure that\n+\t we don't write it more than once.  Otherwise, the reader\n+\t will instantiate two different nodes for the same object.  */\n+      output_record_start (ob, LTO_tree_pickle_reference);\n+      output_uleb128 (ob, ix);\n+      lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n+\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n+    }\n+  else if (lto_stream_as_builtin_p (expr))\n+    {\n+      /* MD and NORMAL builtins do not need to be written out\n+\t completely as they are always instantiated by the\n+\t compiler on startup.  The only builtins that need to\n+\t be written out are BUILT_IN_FRONTEND.  For all other\n+\t builtins, we simply write the class and code.  */\n+      lto_output_builtin_tree (ob, expr);\n+    }\n+  else\n+    {\n+      /* This is the first time we see EXPR, write its fields\n+\t to OB.  */\n+      lto_write_tree (ob, expr, ref_p);\n     }\n }\n \n@@ -306,9 +422,9 @@ output_eh_try_list (struct output_block *ob, eh_catch first)\n   for (n = first; n; n = n->next_catch)\n     {\n       output_record_start (ob, LTO_eh_catch);\n-      lto_output_tree_ref (ob, n->type_list);\n-      lto_output_tree_ref (ob, n->filter_list);\n-      lto_output_tree_ref (ob, n->label);\n+      stream_write_tree (ob, n->type_list, true);\n+      stream_write_tree (ob, n->filter_list, true);\n+      stream_write_tree (ob, n->label, true);\n     }\n \n   output_record_start (ob, LTO_null);\n@@ -365,13 +481,13 @@ output_eh_region (struct output_block *ob, eh_region r)\n     }\n   else if (r->type == ERT_ALLOWED_EXCEPTIONS)\n     {\n-      lto_output_tree_ref (ob, r->u.allowed.type_list);\n-      lto_output_tree_ref (ob, r->u.allowed.label);\n+      stream_write_tree (ob, r->u.allowed.type_list, true);\n+      stream_write_tree (ob, r->u.allowed.label, true);\n       output_uleb128 (ob, r->u.allowed.filter);\n     }\n   else if (r->type == ERT_MUST_NOT_THROW)\n     {\n-      lto_output_tree_ref (ob, r->u.must_not_throw.failure_decl);\n+      stream_write_tree (ob, r->u.must_not_throw.failure_decl, true);\n       lto_output_location (ob, r->u.must_not_throw.failure_loc);\n     }\n \n@@ -405,7 +521,7 @@ output_eh_lp (struct output_block *ob, eh_landing_pad lp)\n   else\n     output_zero (ob);\n \n-  lto_output_tree_ref (ob, lp->post_landing_pad);\n+  stream_write_tree (ob, lp->post_landing_pad, true);\n }\n \n \n@@ -439,15 +555,15 @@ output_eh_regions (struct output_block *ob, struct function *fn)\n       /* Emit all the runtime type data.  */\n       output_sleb128 (ob, VEC_length (tree, fn->eh->ttype_data));\n       FOR_EACH_VEC_ELT (tree, fn->eh->ttype_data, i, ttype)\n-\tlto_output_tree_ref (ob, ttype);\n+\tstream_write_tree (ob, ttype, true);\n \n       /* Emit the table of action chains.  */\n       if (targetm.arm_eabi_unwinder)\n \t{\n \t  tree t;\n \t  output_sleb128 (ob, VEC_length (tree, fn->eh->ehspec_data.arm_eabi));\n \t  FOR_EACH_VEC_ELT (tree, fn->eh->ehspec_data.arm_eabi, i, t)\n-\t    lto_output_tree_ref (ob, t);\n+\t    stream_write_tree (ob, t, true);\n \t}\n       else\n \t{\n@@ -485,7 +601,7 @@ output_ssa_names (struct output_block *ob, struct function *fn)\n \n       output_uleb128 (ob, i);\n       lto_output_1_stream (ob->main_stream, SSA_NAME_IS_DEFAULT_DEF (ptr));\n-      lto_output_tree_ref (ob, SSA_NAME_VAR (ptr));\n+      stream_write_tree (ob, SSA_NAME_VAR (ptr), true);\n     }\n \n   output_zero (ob);\n@@ -651,16 +767,16 @@ output_function (struct cgraph_node *node)\n   output_uleb128 (ob, fn->curr_properties);\n \n   /* Output the static chain and non-local goto save area.  */\n-  lto_output_tree_ref (ob, fn->static_chain_decl);\n-  lto_output_tree_ref (ob, fn->nonlocal_goto_save_area);\n+  stream_write_tree (ob, fn->static_chain_decl, true);\n+  stream_write_tree (ob, fn->nonlocal_goto_save_area, true);\n \n   /* Output all the local variables in the function.  */\n   output_sleb128 (ob, VEC_length (tree, fn->local_decls));\n   FOR_EACH_VEC_ELT (tree, fn->local_decls, i, t)\n-    lto_output_tree_ref (ob, t);\n+    stream_write_tree (ob, t, true);\n \n   /* Output the head of the arguments list.  */\n-  lto_output_tree_ref (ob, DECL_ARGUMENTS (function));\n+  stream_write_tree (ob, DECL_ARGUMENTS (function), true);\n \n   /* Output all the SSA names used in the function.  */\n   output_ssa_names (ob, fn);\n@@ -670,7 +786,7 @@ output_function (struct cgraph_node *node)\n \n   /* Output DECL_INITIAL for the function, which contains the tree of\n      lexical scopes.  */\n-  lto_output_tree (ob, DECL_INITIAL (function), true);\n+  stream_write_tree (ob, DECL_INITIAL (function), true);\n \n   /* We will renumber the statements.  The code that does this uses\n      the same ordering that we use for serializing them so we can use\n@@ -803,8 +919,8 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n   FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     if (output_alias_pair_p (p, defined, set, vset))\n       {\n-\tlto_output_tree_ref (ob, p->decl);\n-\tlto_output_tree_ref (ob, p->target);\n+\tstream_write_tree (ob, p->decl, true);\n+\tstream_write_tree (ob, p->target, true);\n       }\n   symbol_alias_set_destroy (defined);\n \n@@ -974,7 +1090,7 @@ write_global_stream (struct output_block *ob,\n     {\n       t = lto_tree_ref_encoder_get_tree (encoder, index);\n       if (!lto_streamer_cache_lookup (ob->writer_cache, t, NULL))\n-\tlto_output_tree (ob, t, false);\n+\tstream_write_tree (ob, t, false);\n     }\n }\n "}, {"sha": "01a681fbd183c280b96ab6a8059b5e859fd7e834", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 2, "deletions": 111, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -257,86 +257,6 @@ print_lto_report (void)\n }\n \n \n-/* Record NODE in CACHE.  */\n-\n-static void\n-lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n-{\n-  /* We have to make sure to fill exactly the same number of\n-     elements for all frontends.  That can include NULL trees.\n-     As our hash table can't deal with zero entries we'll simply stream\n-     a random other tree.  A NULL tree never will be looked up so it\n-     doesn't matter which tree we replace it with, just to be sure\n-     use error_mark_node.  */\n-  if (!node)\n-    node = error_mark_node;\n-\n-  lto_streamer_cache_append (cache, node);\n-\n-  if (POINTER_TYPE_P (node)\n-      || TREE_CODE (node) == COMPLEX_TYPE\n-      || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_record_common_node (cache, TREE_TYPE (node));\n-  else if (TREE_CODE (node) == RECORD_TYPE)\n-    {\n-      /* The FIELD_DECLs of structures should be shared, so that every\n-\t COMPONENT_REF uses the same tree node when referencing a field.\n-\t Pointer equality between FIELD_DECLs is used by the alias\n-\t machinery to compute overlapping memory references (See\n-\t nonoverlapping_component_refs_p).  */\n-      tree f;\n-      for (f = TYPE_FIELDS (node); f; f = TREE_CHAIN (f))\n-\tlto_record_common_node (cache, f);\n-    }\n-}\n-\n-/* Preload common nodes into CACHE and make sure they are merged\n-   properly according to the gimple type table.  */\n-\n-static void\n-lto_preload_common_nodes (struct lto_streamer_cache_d *cache)\n-{\n-  unsigned i;\n-\n-  /* The MAIN_IDENTIFIER_NODE is normally set up by the front-end, but the\n-     LTO back-end must agree. Currently, the only languages that set this\n-     use the name \"main\".  */\n-  if (main_identifier_node)\n-    {\n-      const char *main_name = IDENTIFIER_POINTER (main_identifier_node);\n-      gcc_assert (strcmp (main_name, \"main\") == 0);\n-    }\n-  else\n-    main_identifier_node = get_identifier (\"main\");\n-\n-  gcc_assert (ptrdiff_type_node == integer_type_node);\n-\n-  /* FIXME lto.  In the C++ front-end, fileptr_type_node is defined as a\n-     variant copy of of ptr_type_node, rather than ptr_node itself.  The\n-     distinction should only be relevant to the front-end, so we always\n-     use the C definition here in lto1.\n-\n-     These should be assured in pass_ipa_free_lang_data.  */\n-  gcc_assert (fileptr_type_node == ptr_type_node);\n-  gcc_assert (TYPE_MAIN_VARIANT (fileptr_type_node) == ptr_type_node);\n-\n-  for (i = 0; i < itk_none; i++)\n-    /* Skip itk_char.  char_type_node is dependent on -f[un]signed-char.  */\n-    if (i != itk_char)\n-      lto_record_common_node (cache, integer_types[i]);\n-\n-  for (i = 0; i < TYPE_KIND_LAST; i++)\n-    lto_record_common_node (cache, sizetype_tab[i]);\n-\n-  for (i = 0; i < TI_MAX; i++)\n-    /* Skip boolean type and constants, they are frontend dependent.  */\n-    if (i != TI_BOOLEAN_TYPE\n-\t&& i != TI_BOOLEAN_FALSE\n-\t&& i != TI_BOOLEAN_TRUE)\n-      lto_record_common_node (cache, global_trees[i]);\n-}\n-\n-\n #ifdef LTO_STREAMER_DEBUG\n static htab_t tree_htab;\n \n@@ -464,41 +384,12 @@ lto_check_version (int major, int minor)\n }\n \n \n-/* Return true if EXPR is a tree node that can be written to disk.  */\n-static inline bool\n-lto_is_streamable (tree expr)\n-{\n-  enum tree_code code = TREE_CODE (expr);\n-\n-  /* Notice that we reject SSA_NAMEs as well.  We only emit the SSA\n-     name version in lto_output_tree_ref (see output_ssa_names).  */\n-  return !is_lang_specific (expr)\n-\t && code != SSA_NAME\n-\t && code != CALL_EXPR\n-\t && code != LANG_TYPE\n-\t && code != MODIFY_EXPR\n-\t && code != INIT_EXPR\n-\t && code != TARGET_EXPR\n-\t && code != BIND_EXPR\n-\t && code != WITH_CLEANUP_EXPR\n-\t && code != STATEMENT_LIST\n-\t && code != OMP_CLAUSE\n-\t && code != OPTIMIZATION_NODE\n-\t && (code == CASE_LABEL_EXPR\n-\t     || code == DECL_EXPR\n-\t     || TREE_CODE_CLASS (code) != tcc_statement);\n-}\n-\n-\n /* Initialize all the streamer hooks used for streaming GIMPLE.  */\n \n void\n lto_streamer_hooks_init (void)\n {\n   streamer_hooks_init ();\n-  streamer_hooks.name = \"gimple\";\n-  streamer_hooks.preload_common_nodes = lto_preload_common_nodes;\n-  streamer_hooks.is_streamable = lto_is_streamable;\n-  streamer_hooks.write_tree = lto_streamer_write_tree;\n-  streamer_hooks.read_tree = lto_streamer_read_tree;\n+  streamer_hooks.write_tree = lto_output_tree;\n+  streamer_hooks.read_tree = lto_input_tree;\n }"}, {"sha": "57d0be49634c51dec756e79b54cdc8851c78b0b1", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -809,6 +809,7 @@ tree lto_input_tree_ref (struct lto_input_block *, struct data_in *,\n \t\t\t struct function *, enum LTO_tags);\n void lto_tag_check_set (enum LTO_tags, int, ...);\n void lto_init_eh (void);\n+tree lto_input_tree (struct lto_input_block *, struct data_in *);\n \n \n /* In lto-streamer-out.c  */\n@@ -822,7 +823,6 @@ void lto_output_decl_state_streams (struct output_block *,\n void lto_output_decl_state_refs (struct output_block *,\n \t\t\t         struct lto_output_stream *,\n \t\t\t         struct lto_out_decl_state *);\n-void lto_output_tree_ref (struct output_block *, tree);\n void lto_output_location (struct output_block *, location_t);\n \n \n@@ -1016,17 +1016,6 @@ emit_label_in_global_context_p (tree label)\n   return DECL_NONLOCAL (label) || FORCED_LABEL (label);\n }\n \n-/* Return true if tree node EXPR should be streamed as a builtin.  For\n-   these nodes, we just emit the class and function code.  */\n-static inline bool\n-lto_stream_as_builtin_p (tree expr)\n-{\n-  return (TREE_CODE (expr) == FUNCTION_DECL\n-\t  && DECL_IS_BUILTIN (expr)\n-\t  && (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_NORMAL\n-\t      || DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD));\n-}\n-\n DEFINE_DECL_STREAM_FUNCS (TYPE, type)\n DEFINE_DECL_STREAM_FUNCS (FIELD_DECL, field_decl)\n DEFINE_DECL_STREAM_FUNCS (FN_DECL, fn_decl)"}, {"sha": "83c41e6c1aaeb5d104740dbedfcace6056964966", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -1099,6 +1099,7 @@ lto_init (void)\n      distinction should only be relevant to the front-end, so we\n      always use the C definition here in lto1.  */\n   gcc_assert (fileptr_type_node == ptr_type_node);\n+  gcc_assert (TYPE_MAIN_VARIANT (fileptr_type_node) == ptr_type_node);\n \n   ptrdiff_type_node = integer_type_node;\n "}, {"sha": "bf2aab19c30419f865b2d809f5514bde87a1d9bd", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -834,7 +834,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n     {\n       tree t;\n       unsigned from = VEC_length (tree, data_in->reader_cache->nodes);\n-      t = lto_input_tree (&ib_main, data_in);\n+      t = stream_read_tree (&ib_main, data_in);\n       gcc_assert (t && ib_main.p <= ib_main.len);\n       uniquify_nodes (data_in, from);\n     }"}, {"sha": "6c45102376a27bdbc497c93652f481d09c5bc493", "filename": "gcc/streamer-hooks.h", "status": "modified", "additions": 18, "deletions": 66, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -39,76 +39,28 @@ struct lto_streamer_cache_d;\n    Hooks marked [REQ] are required to be set.  Those marked [OPT] may\n    be NULL, if the streamer does not need to implement them.  */\n struct streamer_hooks {\n-  /* [REQ] A string identifying this streamer.  */\n-  const char *name;\n-\n-  /* [REQ] Called by lto_streamer_cache_create to instantiate a cache of\n-     well-known nodes.  These are tree nodes that are always\n-     instantiated by the compiler on startup.  Additionally, these\n-     nodes need to be shared.  This function should call\n-     lto_streamer_cache_append on every tree node that it wishes to\n-     preload in the streamer cache.  This way, the writer will only\n-     write out a reference to the tree and the reader will instantiate\n-     the tree out of this pre-populated cache.  */\n-  void (*preload_common_nodes) (struct lto_streamer_cache_d *);\n-\n-  /* [REQ] Return true if the given tree is supported by this streamer.  */\n-  bool (*is_streamable) (tree);\n-\n-  /* [OPT] Called by lto_write_tree after writing all the common parts of\n-     a tree.  If defined, the callback is in charge of writing all\n-     the fields that lto_write_tree did not write out.  Arguments\n-     are as in lto_write_tree.\n-\n-     The following tree fields are not handled by common code:\n-\n-\tDECL_ABSTRACT_ORIGIN\n-\tDECL_INITIAL\n-\tDECL_SAVED_TREE\n-\n-     Callbacks may choose to ignore or handle them.  If handled,\n-     the reader should read them in the exact same sequence written\n-     by the writer.  */\n+  /* [REQ] Called by every tree streaming routine that needs to write\n+     a tree node.  The arguments are: output_block where to write the\n+     node, the tree node to write and a boolean flag that should be true\n+     if the caller wants to write a reference to the tree, instead of the\n+     tree itself.  The referencing mechanism is up to each streamer to\n+     implement.  */\n   void (*write_tree) (struct output_block *, tree, bool);\n \n-  /* [OPT] Called by lto_read_tree after reading all the common parts of\n-     a tree.  If defined, the callback is in charge of reading all\n-     the fields that lto_read_tree did not read in.  Arguments\n-     are as in lto_read_tree.  */\n-  void (*read_tree) (struct lto_input_block *, struct data_in *, tree);\n-\n-  /* [OPT] Called by lto_output_tree_ref to determine if the given tree node\n-     should be emitted as a reference to the table of declarations\n-     (the same table that holds global declarations).  */\n-  bool (*indexable_with_decls_p) (tree);\n-\n-  /* [OPT] Called by pack_value_fields to store any non-pointer fields\n-     in the tree structure.  The arguments are as in pack_value_fields.  */\n-  void (*pack_value_fields) (struct bitpack_d *, tree);\n-\n-  /* [OPT] Called by unpack_value_fields to retrieve any non-pointer fields\n-     in the tree structure.  The arguments are as in unpack_value_fields.  */\n-  void (*unpack_value_fields) (struct bitpack_d *, tree);\n-\n-  /* [OPT] Called by lto_materialize_tree for tree nodes that it does not\n-     know how to allocate memory for.  If defined, this hook should\n-     return a new tree node of the given code.  The data_in and\n-     input_block arguments are passed in case the hook needs to\n-     read more data from the stream to allocate the node.\n-     If this hook returns NULL, then lto_materialize_tree will attempt\n-     to allocate the tree by calling make_node directly.  */\n-  tree (*alloc_tree) (enum tree_code, struct lto_input_block *,\n-                      struct data_in *);\n-\n-  /* [OPT] Called by lto_output_tree_header to write any streamer-specific\n-     information needed to allocate the tree.  This hook may assume\n-     that the basic header data (tree code, etc) has already been\n-     written.  It should only write any extra data needed to allocate\n-     the node (e.g., in the case of CALL_EXPR, this hook would write\n-     the number of arguments to the CALL_EXPR).  */\n-  void (*output_tree_header) (struct output_block *, tree);\n+  /* [REQ] Called by every tree streaming routine that needs to read\n+     a tree node.  It takes two arguments: an lto_input_block pointing\n+     to the buffer where to read from and a data_in instance with tables\n+     and descriptors needed by the unpickling routines.  It returns the\n+     tree instantiated from the stream.  */\n+  tree (*read_tree) (struct lto_input_block *, struct data_in *);\n };\n \n+#define stream_write_tree(OB, EXPR, REF_P) \\\n+    streamer_hooks.write_tree(OB, EXPR, REF_P)\n+\n+#define stream_read_tree(IB, DATA_IN) \\\n+    streamer_hooks.read_tree(IB, DATA_IN)\n+\n /* Streamer hooks.  */\n extern struct streamer_hooks streamer_hooks;\n "}, {"sha": "f2ff35f874c7e85f7a2e340ad688d9c09848c04c", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 99, "deletions": 180, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -75,7 +75,7 @@ lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n   count = lto_input_sleb128 (ib);\n   for (i = 0; i < count; i++)\n     {\n-      curr = lto_input_tree (ib, data_in);\n+      curr = stream_read_tree (ib, data_in);\n       if (prev)\n \tTREE_CHAIN (prev) = curr;\n       else\n@@ -401,21 +401,43 @@ unpack_value_fields (struct bitpack_d *bp, tree expr)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n     unpack_ts_translation_unit_decl_value_fields (bp, expr);\n+}\n+\n+\n+/* Read all the language-independent bitfield values for EXPR from IB.\n+   Return the partially unpacked bitpack so the caller can unpack any other\n+   bitfield values that the writer may have written.  */\n \n-  if (streamer_hooks.unpack_value_fields)\n-    streamer_hooks.unpack_value_fields (bp, expr);\n+struct bitpack_d\n+tree_read_bitfields (struct lto_input_block *ib, tree expr)\n+{\n+  enum tree_code code;\n+  struct bitpack_d bp;\n+\n+  /* Read the bitpack of non-pointer values from IB.  */\n+  bp = lto_input_bitpack (ib);\n+\n+  /* The first word in BP contains the code of the tree that we\n+     are about to read.  */\n+  code = (enum tree_code) bp_unpack_value (&bp, 16);\n+  lto_tag_check (lto_tree_code_to_tag (code),\n+\t\t lto_tree_code_to_tag (TREE_CODE (expr)));\n+\n+  /* Unpack all the value fields from BP.  */\n+  unpack_value_fields (&bp, expr);\n+\n+  return bp;\n }\n \n \n /* Materialize a new tree from input block IB using descriptors in\n    DATA_IN.  The code for the new tree should match TAG.  Store in\n    *IX_P the index into the reader cache where the new tree is stored.  */\n \n-static tree\n+tree\n lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n \t\t      enum LTO_tags tag)\n {\n-  struct bitpack_d bp;\n   enum tree_code code;\n   tree result;\n #ifdef LTO_STREAMER_DEBUG\n@@ -453,17 +475,16 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n       unsigned HOST_WIDE_INT len = lto_input_uleb128 (ib);\n       result = make_tree_binfo (len);\n     }\n+  else if (code == CALL_EXPR)\n+    {\n+      unsigned HOST_WIDE_INT nargs = lto_input_uleb128 (ib);\n+      return build_vl_exp (CALL_EXPR, nargs + 3);\n+    }\n   else\n     {\n-      /* For all other nodes, see if the streamer knows how to allocate\n-\t it.  */\n-      if (streamer_hooks.alloc_tree)\n-\tresult = streamer_hooks.alloc_tree (code, ib, data_in);\n-\n-      /* If the hook did not handle it, materialize the tree with a raw\n+      /* For all other nodes, materialize the tree with a raw\n \t make_node call.  */\n-      if (result == NULL_TREE)\n-\tresult = make_node (code);\n+      result = make_node (code);\n     }\n \n #ifdef LTO_STREAMER_DEBUG\n@@ -475,22 +496,6 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n   lto_orig_address_map (result, (intptr_t) orig_address_in_writer);\n #endif\n \n-  /* Read the bitpack of non-pointer values from IB.  */\n-  bp = lto_input_bitpack (ib);\n-\n-  /* The first word in BP contains the code of the tree that we\n-     are about to read.  */\n-  code = (enum tree_code) bp_unpack_value (&bp, 16);\n-  lto_tag_check (lto_tree_code_to_tag (code), tag);\n-\n-  /* Unpack all the value fields from BP.  */\n-  unpack_value_fields (&bp, result);\n-\n-  /* Enter RESULT in the reader cache.  This will make RESULT\n-     available so that circular references in the rest of the tree\n-     structure can be resolved in subsequent calls to lto_input_tree.  */\n-  lto_streamer_cache_append (data_in->reader_cache, result);\n-\n   return result;\n }\n \n@@ -505,7 +510,7 @@ lto_input_ts_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t   struct data_in *data_in, tree expr)\n {\n   if (TREE_CODE (expr) != IDENTIFIER_NODE)\n-    TREE_TYPE (expr) = lto_input_tree (ib, data_in);\n+    TREE_TYPE (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -529,8 +534,8 @@ static void\n lto_input_ts_complex_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t    struct data_in *data_in, tree expr)\n {\n-  TREE_REALPART (expr) = lto_input_tree (ib, data_in);\n-  TREE_IMAGPART (expr) = lto_input_tree (ib, data_in);\n+  TREE_REALPART (expr) = stream_read_tree (ib, data_in);\n+  TREE_IMAGPART (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -542,8 +547,8 @@ static void\n lto_input_ts_decl_minimal_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\t struct data_in *data_in, tree expr)\n {\n-  DECL_NAME (expr) = lto_input_tree (ib, data_in);\n-  DECL_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  DECL_NAME (expr) = stream_read_tree (ib, data_in);\n+  DECL_CONTEXT (expr) = stream_read_tree (ib, data_in);\n   DECL_SOURCE_LOCATION (expr) = lto_input_location (ib, data_in);\n }\n \n@@ -556,9 +561,9 @@ static void\n lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\tstruct data_in *data_in, tree expr)\n {\n-  DECL_SIZE (expr) = lto_input_tree (ib, data_in);\n-  DECL_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n-  DECL_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+  DECL_SIZE (expr) = stream_read_tree (ib, data_in);\n+  DECL_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n+  DECL_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n \n   /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n@@ -570,11 +575,11 @@ lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n   if ((TREE_CODE (expr) == VAR_DECL\n        || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))\n-    SET_DECL_VALUE_EXPR (expr, lto_input_tree (ib, data_in));\n+    SET_DECL_VALUE_EXPR (expr, stream_read_tree (ib, data_in));\n \n   if (TREE_CODE (expr) == VAR_DECL)\n     {\n-      tree dexpr = lto_input_tree (ib, data_in);\n+      tree dexpr = stream_read_tree (ib, data_in);\n       if (dexpr)\n \tSET_DECL_DEBUG_EXPR (expr, dexpr);\n     }\n@@ -591,10 +596,10 @@ lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *ib,\n {\n   if (TREE_CODE (expr) == FUNCTION_DECL)\n     {\n-      DECL_ARGUMENTS (expr) = lto_input_tree (ib, data_in);\n-      DECL_RESULT (expr) = lto_input_tree (ib, data_in);\n+      DECL_ARGUMENTS (expr) = stream_read_tree (ib, data_in);\n+      DECL_RESULT (expr) = stream_read_tree (ib, data_in);\n     }\n-  DECL_VINDEX (expr) = lto_input_tree (ib, data_in);\n+  DECL_VINDEX (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -608,15 +613,15 @@ lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n {\n   tree id;\n \n-  id = lto_input_tree (ib, data_in);\n+  id = stream_read_tree (ib, data_in);\n   if (id)\n     {\n       gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n       SET_DECL_ASSEMBLER_NAME (expr, id);\n     }\n \n-  DECL_SECTION_NAME (expr) = lto_input_tree (ib, data_in);\n-  DECL_COMDAT_GROUP (expr) = lto_input_tree (ib, data_in);\n+  DECL_SECTION_NAME (expr) = stream_read_tree (ib, data_in);\n+  DECL_COMDAT_GROUP (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -628,11 +633,11 @@ static void\n lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t       struct data_in *data_in, tree expr)\n {\n-  DECL_FIELD_OFFSET (expr) = lto_input_tree (ib, data_in);\n-  DECL_BIT_FIELD_TYPE (expr) = lto_input_tree (ib, data_in);\n-  DECL_QUALIFIER (expr) = lto_input_tree (ib, data_in);\n-  DECL_FIELD_BIT_OFFSET (expr) = lto_input_tree (ib, data_in);\n-  DECL_FCONTEXT (expr) = lto_input_tree (ib, data_in);\n+  DECL_FIELD_OFFSET (expr) = stream_read_tree (ib, data_in);\n+  DECL_BIT_FIELD_TYPE (expr) = stream_read_tree (ib, data_in);\n+  DECL_QUALIFIER (expr) = stream_read_tree (ib, data_in);\n+  DECL_FIELD_BIT_OFFSET (expr) = stream_read_tree (ib, data_in);\n+  DECL_FCONTEXT (expr) = stream_read_tree (ib, data_in);\n   TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n }\n \n@@ -647,9 +652,9 @@ lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n {\n   /* DECL_STRUCT_FUNCTION is handled by lto_input_function.  FIXME lto,\n      maybe it should be handled here?  */\n-  DECL_FUNCTION_PERSONALITY (expr) = lto_input_tree (ib, data_in);\n-  DECL_FUNCTION_SPECIFIC_TARGET (expr) = lto_input_tree (ib, data_in);\n-  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr) = lto_input_tree (ib, data_in);\n+  DECL_FUNCTION_PERSONALITY (expr) = stream_read_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_TARGET (expr) = stream_read_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr) = stream_read_tree (ib, data_in);\n \n   /* If the file contains a function with an EH personality set,\n      then it was compiled with -fexceptions.  In that case, initialize\n@@ -667,19 +672,19 @@ static void\n lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\tstruct data_in *data_in, tree expr)\n {\n-  TYPE_SIZE (expr) = lto_input_tree (ib, data_in);\n-  TYPE_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n-  TYPE_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n-  TYPE_NAME (expr) = lto_input_tree (ib, data_in);\n+  TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n+  TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n+  TYPE_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n+  TYPE_NAME (expr) = stream_read_tree (ib, data_in);\n   /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n      reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n-  TYPE_MAIN_VARIANT (expr) = lto_input_tree (ib, data_in);\n-  TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_MAIN_VARIANT (expr) = stream_read_tree (ib, data_in);\n+  TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n   /* TYPE_CANONICAL gets re-computed during type merging.  */\n   TYPE_CANONICAL (expr) = NULL_TREE;\n-  TYPE_STUB_DECL (expr) = lto_input_tree (ib, data_in);\n+  TYPE_STUB_DECL (expr) = stream_read_tree (ib, data_in);\n }\n \n /* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n@@ -692,20 +697,20 @@ lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\t    tree expr)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    TYPE_VALUES (expr) = lto_input_tree (ib, data_in);\n+    TYPE_VALUES (expr) = stream_read_tree (ib, data_in);\n   else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    TYPE_DOMAIN (expr) = lto_input_tree (ib, data_in);\n+    TYPE_DOMAIN (expr) = stream_read_tree (ib, data_in);\n   else if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_FIELDS (expr) = lto_input_tree (ib, data_in);\n+    TYPE_FIELDS (expr) = stream_read_tree (ib, data_in);\n   else if (TREE_CODE (expr) == FUNCTION_TYPE\n \t   || TREE_CODE (expr) == METHOD_TYPE)\n-    TYPE_ARG_TYPES (expr) = lto_input_tree (ib, data_in);\n+    TYPE_ARG_TYPES (expr) = stream_read_tree (ib, data_in);\n \n   if (!POINTER_TYPE_P (expr))\n-    TYPE_MINVAL (expr) = lto_input_tree (ib, data_in);\n-  TYPE_MAXVAL (expr) = lto_input_tree (ib, data_in);\n+    TYPE_MINVAL (expr) = stream_read_tree (ib, data_in);\n+  TYPE_MAXVAL (expr) = stream_read_tree (ib, data_in);\n   if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_BINFO (expr) = lto_input_tree (ib, data_in);\n+    TYPE_BINFO (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -717,8 +722,8 @@ static void\n lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t struct data_in *data_in, tree expr)\n {\n-  TREE_PURPOSE (expr) = lto_input_tree (ib, data_in);\n-  TREE_VALUE (expr) = lto_input_tree (ib, data_in);\n+  TREE_PURPOSE (expr) = stream_read_tree (ib, data_in);\n+  TREE_VALUE (expr) = stream_read_tree (ib, data_in);\n   TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n }\n \n@@ -736,7 +741,7 @@ lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n   /* Note that TREE_VEC_LENGTH was read by lto_materialize_tree to\n      instantiate EXPR.  */\n   for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n-    TREE_VEC_ELT (expr, i) = lto_input_tree (ib, data_in);\n+    TREE_VEC_ELT (expr, i) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -756,11 +761,11 @@ lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n   gcc_assert (length == TREE_OPERAND_LENGTH (expr));\n \n   for (i = 0; i < length; i++)\n-    TREE_OPERAND (expr, i) = lto_input_tree (ib, data_in);\n+    TREE_OPERAND (expr, i) = stream_read_tree (ib, data_in);\n \n   loc = lto_input_location (ib, data_in);\n   SET_EXPR_LOCATION (expr, loc);\n-  TREE_BLOCK (expr) = lto_input_tree (ib, data_in);\n+  TREE_BLOCK (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -781,13 +786,13 @@ lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n \n-  BLOCK_SUPERCONTEXT (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_SUPERCONTEXT (expr) = stream_read_tree (ib, data_in);\n \n   /* Do not stream BLOCK_ABSTRACT_ORIGIN.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n-  BLOCK_FRAGMENT_ORIGIN (expr) = lto_input_tree (ib, data_in);\n-  BLOCK_FRAGMENT_CHAIN (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_FRAGMENT_ORIGIN (expr) = stream_read_tree (ib, data_in);\n+  BLOCK_FRAGMENT_CHAIN (expr) = stream_read_tree (ib, data_in);\n \n   /* We re-compute BLOCK_SUBBLOCKS of our parent here instead\n      of streaming it.  For non-BLOCK BLOCK_SUPERCONTEXTs we still\n@@ -828,31 +833,31 @@ lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n      list on the writer side.  */\n   do\n     {\n-      t = lto_input_tree (ib, data_in);\n+      t = stream_read_tree (ib, data_in);\n       if (t)\n \tVEC_quick_push (tree, BINFO_BASE_BINFOS (expr), t);\n     }\n   while (t);\n \n-  BINFO_OFFSET (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VTABLE (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VIRTUALS (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VPTR_FIELD (expr) = lto_input_tree (ib, data_in);\n+  BINFO_OFFSET (expr) = stream_read_tree (ib, data_in);\n+  BINFO_VTABLE (expr) = stream_read_tree (ib, data_in);\n+  BINFO_VIRTUALS (expr) = stream_read_tree (ib, data_in);\n+  BINFO_VPTR_FIELD (expr) = stream_read_tree (ib, data_in);\n \n   len = lto_input_uleb128 (ib);\n   if (len > 0)\n     {\n       VEC_reserve_exact (tree, gc, BINFO_BASE_ACCESSES (expr), len);\n       for (i = 0; i < len; i++)\n \t{\n-\t  tree a = lto_input_tree (ib, data_in);\n+\t  tree a = stream_read_tree (ib, data_in);\n \t  VEC_quick_push (tree, BINFO_BASE_ACCESSES (expr), a);\n \t}\n     }\n \n-  BINFO_INHERITANCE_CHAIN (expr) = lto_input_tree (ib, data_in);\n-  BINFO_SUBVTT_INDEX (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VPTR_INDEX (expr) = lto_input_tree (ib, data_in);\n+  BINFO_INHERITANCE_CHAIN (expr) = stream_read_tree (ib, data_in);\n+  BINFO_SUBVTT_INDEX (expr) = stream_read_tree (ib, data_in);\n+  BINFO_VPTR_INDEX (expr) = stream_read_tree (ib, data_in);\n }\n \n \n@@ -871,8 +876,8 @@ lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n     {\n       tree index, value;\n \n-      index = lto_input_tree (ib, data_in);\n-      value = lto_input_tree (ib, data_in);\n+      index = stream_read_tree (ib, data_in);\n+      value = stream_read_tree (ib, data_in);\n       CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (expr), index, value);\n     }\n }\n@@ -906,11 +911,10 @@ lto_input_ts_translation_unit_decl_tree_pointers (struct lto_input_block *ib,\n   VEC_safe_push (tree, gc, all_translation_units, expr);\n }\n \n-/* Helper for lto_input_tree.  Read all pointer fields in EXPR from\n-   input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n+/* Read all pointer fields in EXPR from input block IB.  DATA_IN\n+   contains tables and descriptors for the file being read.  */\n \n-static void\n+void\n lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n \t\t\t tree expr)\n {\n@@ -977,52 +981,17 @@ lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n-/* Read the physical representation of a tree node with tag TAG from\n-   input block IB using the per-file context in DATA_IN.  */\n-\n-static tree\n-lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t       enum LTO_tags tag)\n-{\n-  tree result;\n-\n-  result = lto_materialize_tree (ib, data_in, tag);\n-\n-  /* Read all the pointer fields in RESULT.  */\n-  lto_input_tree_pointers (ib, data_in, result);\n-\n-  /* Call back into the streaming module to read anything else it\n-     may need.  */\n-  if (streamer_hooks.read_tree)\n-    streamer_hooks.read_tree (ib, data_in, result);\n-\n-  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n-  if (TREE_CODE (result) == FUNCTION_DECL)\n-    gcc_assert (!lto_stream_as_builtin_p (result));\n-\n-  /* end_marker = */ lto_input_1_unsigned (ib);\n-\n-#ifdef LTO_STREAMER_DEBUG\n-  /* Remove the mapping to RESULT's original address set by\n-     lto_materialize_tree.  */\n-  lto_orig_address_remove (result);\n-#endif\n-\n-  return result;\n-}\n-\n-\n /* Read and INTEGER_CST node from input block IB using the per-file\n    context in DATA_IN.  */\n \n-static tree\n+tree\n lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n {\n   tree result, type;\n   HOST_WIDE_INT low, high;\n   bool overflow_p;\n \n-  type = lto_input_tree (ib, data_in);\n+  type = stream_read_tree (ib, data_in);\n   overflow_p = (lto_input_1_unsigned (ib) != 0);\n   low = lto_input_uleb128 (ib);\n   high = lto_input_uleb128 (ib);\n@@ -1043,7 +1012,7 @@ lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n /* Read an index IX from input block IB and return the tree node at\n    DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n \n-static tree\n+tree\n lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n {\n   unsigned HOST_WIDE_INT ix;\n@@ -1062,9 +1031,9 @@ lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n \n \n /* Read a code and class from input block IB and return the\n-   corresponding builtin.  DATA_IN is as in lto_input_tree.  */\n+   corresponding builtin.  DATA_IN is as in stream_read_tree.  */\n \n-static tree\n+tree\n lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n {\n   enum built_in_class fclass;\n@@ -1101,53 +1070,3 @@ lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n \n   return result;\n }\n-\n-\n-/* Read a tree from input block IB using the per-file context in\n-   DATA_IN.  This context is used, for example, to resolve references\n-   to previously read nodes.  */\n-\n-tree\n-lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  enum LTO_tags tag;\n-  tree result;\n-\n-  tag = input_record_start (ib);\n-  gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n-\n-  if (tag == LTO_null)\n-    result = NULL_TREE;\n-  else if (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n-    {\n-      /* If TAG is a reference to an indexable tree, the next value\n-\t in IB is the index into the table where we expect to find\n-\t that tree.  */\n-      result = lto_input_tree_ref (ib, data_in, cfun, tag);\n-    }\n-  else if (tag == LTO_tree_pickle_reference)\n-    {\n-      /* If TAG is a reference to a previously read tree, look it up in\n-\t the reader cache.  */\n-      result = lto_get_pickled_tree (ib, data_in);\n-    }\n-  else if (tag == LTO_builtin_decl)\n-    {\n-      /* If we are going to read a built-in function, all we need is\n-\t the code and class.  */\n-      result = lto_get_builtin_tree (ib, data_in);\n-    }\n-  else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n-    {\n-      /* For integer constants we only need the type and its hi/low\n-\t words.  */\n-      result = lto_input_integer_cst (ib, data_in);\n-    }\n-  else\n-    {\n-      /* Otherwise, materialize a new node from IB.  */\n-      result = lto_read_tree (ib, data_in, tag);\n-    }\n-\n-  return result;\n-}"}, {"sha": "8bab9304b747ab5d544636141cf3db97d1c9093c", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 72, "deletions": 215, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -305,7 +305,7 @@ pack_ts_translation_unit_decl_value_fields (struct bitpack_d *bp ATTRIBUTE_UNUSE\n \n /* Pack all the non-pointer fields in EXPR into a bit pack.  */\n \n-static void\n+void\n pack_value_fields (struct bitpack_d *bp, tree expr)\n {\n   enum tree_code code;\n@@ -342,29 +342,13 @@ pack_value_fields (struct bitpack_d *bp, tree expr)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n     pack_ts_translation_unit_decl_value_fields (bp, expr);\n-\n-  if (streamer_hooks.pack_value_fields)\n-    streamer_hooks.pack_value_fields (bp, expr);\n-}\n-\n-\n-/* If REF_P is true, emit a reference to EXPR in output block OB,\n-   otherwise emit the physical representation of EXPR in OB.  */\n-\n-static inline void\n-lto_output_tree_or_ref (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  if (ref_p)\n-    lto_output_tree_ref (ob, expr);\n-  else\n-    lto_output_tree (ob, expr, false);\n }\n \n \n /* Write the code and class of builtin EXPR to output block OB.  IX is\n    the index into the streamer cache where EXPR is stored.*/\n \n-static void\n+void\n lto_output_builtin_tree (struct output_block *ob, tree expr)\n {\n   gcc_assert (lto_stream_as_builtin_p (expr));\n@@ -396,44 +380,11 @@ lto_output_builtin_tree (struct output_block *ob, tree expr)\n }\n \n \n-/* GIMPLE hook for writing GIMPLE-specific parts of trees.  OB, EXPR\n-   and REF_P are as in lto_write_tree.  */\n-\n-void\n-lto_streamer_write_tree (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  if (DECL_P (expr)\n-      && TREE_CODE (expr) != FUNCTION_DECL\n-      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-    {\n-      /* Handle DECL_INITIAL for symbols.  */\n-      tree initial = DECL_INITIAL (expr);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n-\t  && initial)\n-\t{\n-\t  lto_varpool_encoder_t varpool_encoder;\n-\t  struct varpool_node *vnode;\n-\n-\t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n-\t  vnode = varpool_get_node (expr);\n-\t  if (!vnode)\n-\t    initial = error_mark_node;\n-\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n-\t\t\t\t\t\t\t      vnode))\n-\t    initial = NULL;\n-\t}\n-\n-      lto_output_tree_or_ref (ob, initial, ref_p);\n-    }\n-}\n-\n-\n /* Emit the chain of tree nodes starting at T.  OB is the output block\n    to write to.  REF_P is true if chain elements should be emitted\n    as references.  */\n \n-static void\n+void\n lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n {\n   int i, count;\n@@ -449,7 +400,7 @@ lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n       saved_chain = TREE_CHAIN (t);\n       TREE_CHAIN (t) = NULL_TREE;\n \n-      lto_output_tree_or_ref (ob, t, ref_p);\n+      stream_write_tree (ob, t, ref_p);\n \n       TREE_CHAIN (t) = saved_chain;\n       t = TREE_CHAIN (t);\n@@ -466,7 +417,7 @@ lto_output_ts_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t    bool ref_p)\n {\n   if (TREE_CODE (expr) != IDENTIFIER_NODE)\n-    lto_output_tree_or_ref (ob, TREE_TYPE (expr), ref_p);\n+    stream_write_tree (ob, TREE_TYPE (expr), ref_p);\n }\n \n \n@@ -490,8 +441,8 @@ static void\n lto_output_ts_complex_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t     bool ref_p)\n {\n-  lto_output_tree_or_ref (ob, TREE_REALPART (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TREE_IMAGPART (expr), ref_p);\n+  stream_write_tree (ob, TREE_REALPART (expr), ref_p);\n+  stream_write_tree (ob, TREE_IMAGPART (expr), ref_p);\n }\n \n \n@@ -503,8 +454,8 @@ static void\n lto_output_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t\t  bool ref_p)\n {\n-  lto_output_tree_or_ref (ob, DECL_NAME (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_CONTEXT (expr), ref_p);\n+  stream_write_tree (ob, DECL_NAME (expr), ref_p);\n+  stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n   lto_output_location (ob, DECL_SOURCE_LOCATION (expr));\n }\n \n@@ -517,13 +468,13 @@ static void\n lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t\t bool ref_p)\n {\n-  lto_output_tree_or_ref (ob, DECL_SIZE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_SIZE_UNIT (expr), ref_p);\n+  stream_write_tree (ob, DECL_SIZE (expr), ref_p);\n+  stream_write_tree (ob, DECL_SIZE_UNIT (expr), ref_p);\n \n   /* Note, DECL_INITIAL is not handled here.  Since DECL_INITIAL needs\n      special handling in LTO, it must be handled by streamer hooks.  */\n \n-  lto_output_tree_or_ref (ob, DECL_ATTRIBUTES (expr), ref_p);\n+  stream_write_tree (ob, DECL_ATTRIBUTES (expr), ref_p);\n \n   /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n@@ -535,10 +486,10 @@ lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n   if ((TREE_CODE (expr) == VAR_DECL\n        || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))\n-    lto_output_tree_or_ref (ob, DECL_VALUE_EXPR (expr), ref_p);\n+    stream_write_tree (ob, DECL_VALUE_EXPR (expr), ref_p);\n \n   if (TREE_CODE (expr) == VAR_DECL)\n-    lto_output_tree_or_ref (ob, DECL_DEBUG_EXPR (expr), ref_p);\n+    stream_write_tree (ob, DECL_DEBUG_EXPR (expr), ref_p);\n }\n \n \n@@ -552,10 +503,10 @@ lto_output_ts_decl_non_common_tree_pointers (struct output_block *ob,\n {\n   if (TREE_CODE (expr) == FUNCTION_DECL)\n     {\n-      lto_output_tree_or_ref (ob, DECL_ARGUMENTS (expr), ref_p);\n-      lto_output_tree_or_ref (ob, DECL_RESULT (expr), ref_p);\n+      stream_write_tree (ob, DECL_ARGUMENTS (expr), ref_p);\n+      stream_write_tree (ob, DECL_RESULT (expr), ref_p);\n     }\n-  lto_output_tree_or_ref (ob, DECL_VINDEX (expr), ref_p);\n+  stream_write_tree (ob, DECL_VINDEX (expr), ref_p);\n }\n \n \n@@ -569,12 +520,12 @@ lto_output_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n {\n   /* Make sure we don't inadvertently set the assembler name.  */\n   if (DECL_ASSEMBLER_NAME_SET_P (expr))\n-    lto_output_tree_or_ref (ob, DECL_ASSEMBLER_NAME (expr), ref_p);\n+    stream_write_tree (ob, DECL_ASSEMBLER_NAME (expr), ref_p);\n   else\n-    output_record_start (ob, LTO_null);\n+    stream_write_tree (ob, NULL_TREE, false);\n \n-  lto_output_tree_or_ref (ob, DECL_SECTION_NAME (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_COMDAT_GROUP (expr), ref_p);\n+  stream_write_tree (ob, DECL_SECTION_NAME (expr), ref_p);\n+  stream_write_tree (ob, DECL_COMDAT_GROUP (expr), ref_p);\n }\n \n \n@@ -586,11 +537,11 @@ static void\n lto_output_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t\tbool ref_p)\n {\n-  lto_output_tree_or_ref (ob, DECL_FIELD_OFFSET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_QUALIFIER (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FCONTEXT (expr), ref_p);\n+  stream_write_tree (ob, DECL_FIELD_OFFSET (expr), ref_p);\n+  stream_write_tree (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n+  stream_write_tree (ob, DECL_QUALIFIER (expr), ref_p);\n+  stream_write_tree (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n+  stream_write_tree (ob, DECL_FCONTEXT (expr), ref_p);\n   lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n }\n \n@@ -605,10 +556,9 @@ lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n {\n   /* DECL_STRUCT_FUNCTION is handled by lto_output_function.  FIXME lto,\n      maybe it should be handled here?  */\n-  lto_output_tree_or_ref (ob, DECL_FUNCTION_PERSONALITY (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr),\n-\t\t\t  ref_p);\n+  stream_write_tree (ob, DECL_FUNCTION_PERSONALITY (expr), ref_p);\n+  stream_write_tree (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr), ref_p);\n+  stream_write_tree (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr), ref_p);\n }\n \n \n@@ -620,19 +570,19 @@ static void\n lto_output_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t\t bool ref_p)\n {\n-  lto_output_tree_or_ref (ob, TYPE_SIZE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_SIZE_UNIT (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_ATTRIBUTES (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_NAME (expr), ref_p);\n+  stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n+  stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n+  stream_write_tree (ob, TYPE_ATTRIBUTES (expr), ref_p);\n+  stream_write_tree (ob, TYPE_NAME (expr), ref_p);\n   /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n      reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n-  lto_output_tree_or_ref (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n+  stream_write_tree (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n+  stream_write_tree (ob, TYPE_CONTEXT (expr), ref_p);\n   /* TYPE_CANONICAL is re-computed during type merging, so no need\n      to stream it here.  */\n-  lto_output_tree_or_ref (ob, TYPE_STUB_DECL (expr), ref_p);\n+  stream_write_tree (ob, TYPE_STUB_DECL (expr), ref_p);\n }\n \n /* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n@@ -644,20 +594,20 @@ lto_output_ts_type_non_common_tree_pointers (struct output_block *ob,\n \t\t\t\t\t     tree expr, bool ref_p)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    lto_output_tree_or_ref (ob, TYPE_VALUES (expr), ref_p);\n+    stream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n   else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    lto_output_tree_or_ref (ob, TYPE_DOMAIN (expr), ref_p);\n+    stream_write_tree (ob, TYPE_DOMAIN (expr), ref_p);\n   else if (RECORD_OR_UNION_TYPE_P (expr))\n-    lto_output_tree_or_ref (ob, TYPE_FIELDS (expr), ref_p);\n+    stream_write_tree (ob, TYPE_FIELDS (expr), ref_p);\n   else if (TREE_CODE (expr) == FUNCTION_TYPE\n \t   || TREE_CODE (expr) == METHOD_TYPE)\n-    lto_output_tree_or_ref (ob, TYPE_ARG_TYPES (expr), ref_p);\n+    stream_write_tree (ob, TYPE_ARG_TYPES (expr), ref_p);\n \n   if (!POINTER_TYPE_P (expr))\n-    lto_output_tree_or_ref (ob, TYPE_MINVAL (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_MAXVAL (expr), ref_p);\n+    stream_write_tree (ob, TYPE_MINVAL (expr), ref_p);\n+  stream_write_tree (ob, TYPE_MAXVAL (expr), ref_p);\n   if (RECORD_OR_UNION_TYPE_P (expr))\n-    lto_output_tree_or_ref (ob, TYPE_BINFO (expr), ref_p);\n+    stream_write_tree (ob, TYPE_BINFO (expr), ref_p);\n }\n \n \n@@ -669,8 +619,8 @@ static void\n lto_output_ts_list_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t  bool ref_p)\n {\n-  lto_output_tree_or_ref (ob, TREE_PURPOSE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TREE_VALUE (expr), ref_p);\n+  stream_write_tree (ob, TREE_PURPOSE (expr), ref_p);\n+  stream_write_tree (ob, TREE_VALUE (expr), ref_p);\n   lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n }\n \n@@ -687,7 +637,7 @@ lto_output_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n   /* Note that the number of slots for EXPR has already been emitted\n      in EXPR's header (see lto_output_tree_header).  */\n   for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n-    lto_output_tree_or_ref (ob, TREE_VEC_ELT (expr, i), ref_p);\n+    stream_write_tree (ob, TREE_VEC_ELT (expr, i), ref_p);\n }\n \n \n@@ -702,9 +652,9 @@ lto_output_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n \n   output_sleb128 (ob, TREE_OPERAND_LENGTH (expr));\n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n-    lto_output_tree_or_ref (ob, TREE_OPERAND (expr, i), ref_p);\n+    stream_write_tree (ob, TREE_OPERAND (expr, i), ref_p);\n   lto_output_location (ob, EXPR_LOCATION (expr));\n-  lto_output_tree_or_ref (ob, TREE_BLOCK (expr), ref_p);\n+  stream_write_tree (ob, TREE_BLOCK (expr), ref_p);\n }\n \n \n@@ -725,12 +675,12 @@ lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n \n-  lto_output_tree_or_ref (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n+  stream_write_tree (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n   /* Do not stream BLOCK_ABSTRACT_ORIGIN.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n-  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_ORIGIN (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_CHAIN (expr), ref_p);\n+  stream_write_tree (ob, BLOCK_FRAGMENT_ORIGIN (expr), ref_p);\n+  stream_write_tree (ob, BLOCK_FRAGMENT_CHAIN (expr), ref_p);\n   /* Do not output BLOCK_SUBBLOCKS.  Instead on streaming-in this\n      list is re-constructed from BLOCK_SUPERCONTEXT.  */\n }\n@@ -751,25 +701,25 @@ lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n      EXPR's header (see lto_output_tree_header) because this length\n      is needed to build the empty BINFO node on the reader side.  */\n   FOR_EACH_VEC_ELT (tree, BINFO_BASE_BINFOS (expr), i, t)\n-    lto_output_tree_or_ref (ob, t, ref_p);\n-  output_record_start (ob, LTO_null);\n+    stream_write_tree (ob, t, ref_p);\n+  stream_write_tree (ob, NULL_TREE, false);\n \n-  lto_output_tree_or_ref (ob, BINFO_OFFSET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_VTABLE (expr), ref_p);\n+  stream_write_tree (ob, BINFO_OFFSET (expr), ref_p);\n+  stream_write_tree (ob, BINFO_VTABLE (expr), ref_p);\n   /* BINFO_VIRTUALS is used to drive type based devirtualizatoin.  It often links\n      together large portions of programs making it harder to partition.  Becuase\n      devirtualization is interesting before inlining, only, there is no real\n      need to ship it into ltrans partition.  */\n-  lto_output_tree_or_ref (ob, flag_wpa ? NULL : BINFO_VIRTUALS (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_VPTR_FIELD (expr), ref_p);\n+  stream_write_tree (ob, flag_wpa ? NULL : BINFO_VIRTUALS (expr), ref_p);\n+  stream_write_tree (ob, BINFO_VPTR_FIELD (expr), ref_p);\n \n   output_uleb128 (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n   FOR_EACH_VEC_ELT (tree, BINFO_BASE_ACCESSES (expr), i, t)\n-    lto_output_tree_or_ref (ob, t, ref_p);\n+    stream_write_tree (ob, t, ref_p);\n \n-  lto_output_tree_or_ref (ob, BINFO_INHERITANCE_CHAIN (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_SUBVTT_INDEX (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_VPTR_INDEX (expr), ref_p);\n+  stream_write_tree (ob, BINFO_INHERITANCE_CHAIN (expr), ref_p);\n+  stream_write_tree (ob, BINFO_SUBVTT_INDEX (expr), ref_p);\n+  stream_write_tree (ob, BINFO_VPTR_INDEX (expr), ref_p);\n }\n \n \n@@ -787,8 +737,8 @@ lto_output_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n   output_uleb128 (ob, CONSTRUCTOR_NELTS (expr));\n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n     {\n-      lto_output_tree_or_ref (ob, index, ref_p);\n-      lto_output_tree_or_ref (ob, value, ref_p);\n+      stream_write_tree (ob, index, ref_p);\n+      stream_write_tree (ob, value, ref_p);\n     }\n }\n \n@@ -823,11 +773,10 @@ lto_output_ts_translation_unit_decl_tree_pointers (struct output_block *ob,\n \t\t     TRANSLATION_UNIT_LANGUAGE (expr), true);\n }\n \n-/* Helper for lto_output_tree.  Write all pointer fields in EXPR to output\n-   block OB.  If REF_P is true, the leaves of EXPR are emitted as\n-   references.  */\n+/* Write all pointer fields in EXPR to output block OB.  If REF_P is true,\n+   the leaves of EXPR are emitted as references.  */\n \n-static void\n+void\n lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   enum tree_code code;\n@@ -896,19 +845,16 @@ lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n /* Emit header information for tree EXPR to output block OB.  The header\n    contains everything needed to instantiate an empty skeleton for\n    EXPR on the reading side.  IX is the index into the streamer cache\n-   where EXPR is stored.  REF_P is as in lto_output_tree.  */\n+   where EXPR is stored.  */\n \n-static void\n+void\n lto_output_tree_header (struct output_block *ob, tree expr)\n {\n   enum LTO_tags tag;\n   enum tree_code code;\n \n   /* We should not see any tree nodes not handled by the streamer.  */\n   code = TREE_CODE (expr);\n-  if (!streamer_hooks.is_streamable (expr))\n-    internal_error (\"tree code %qs is not supported in %s streams\",\n-\t\t    tree_code_name[code], streamer_hooks.name);\n \n   /* The header of a tree node consists of its tag, the size of\n      the node, and any other information needed to instantiate\n@@ -937,109 +883,20 @@ lto_output_tree_header (struct output_block *ob, tree expr)\n     output_sleb128 (ob, TREE_VEC_LENGTH (expr));\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n     output_uleb128 (ob, BINFO_N_BASE_BINFOS (expr));\n-\n-  /* Allow the streamer to write any streamer-specific information\n-     needed to instantiate the node when reading.  */\n-  if (streamer_hooks.output_tree_header)\n-    streamer_hooks.output_tree_header (ob, expr);\n+  else if (TREE_CODE (expr) == CALL_EXPR)\n+    output_uleb128 (ob, call_expr_nargs (expr));\n }\n \n \n /* Emit the integer constant CST to output block OB.  If REF_P is true,\n    CST's type will be emitted as a reference.  */\n \n-static void\n+void\n lto_output_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n {\n   output_record_start (ob, lto_tree_code_to_tag (INTEGER_CST));\n-  lto_output_tree_or_ref (ob, TREE_TYPE (cst), ref_p);\n+  stream_write_tree (ob, TREE_TYPE (cst), ref_p);\n   lto_output_1_stream (ob->main_stream, TREE_OVERFLOW_P (cst));\n   output_uleb128 (ob, TREE_INT_CST_LOW (cst));\n   output_uleb128 (ob, TREE_INT_CST_HIGH (cst));\n }\n-\n-\n-/* Write a physical representation of tree node EXPR to output block\n-   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n-   via lto_output_tree_ref.  IX is the index into the streamer cache\n-   where EXPR is stored.  */\n-\n-static void\n-lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  struct bitpack_d bp;\n-\n-  /* Write the header, containing everything needed to materialize\n-     EXPR on the reading side.  */\n-  lto_output_tree_header (ob, expr);\n-\n-  /* Pack all the non-pointer fields in EXPR into a bitpack and write\n-     the resulting bitpack.  */\n-  bp = bitpack_create (ob->main_stream);\n-  pack_value_fields (&bp, expr);\n-  lto_output_bitpack (&bp);\n-\n-  /* Write all the pointer fields in EXPR.  */\n-  lto_output_tree_pointers (ob, expr, ref_p);\n-\n-  /* Call back into the streaming module to see if it needs to write\n-     anything that was not written by the common streamer.  */\n-  if (streamer_hooks.write_tree)\n-    streamer_hooks.write_tree (ob, expr, ref_p);\n-\n-  /* Mark the end of EXPR.  */\n-  output_zero (ob);\n-}\n-\n-\n-/* Emit the physical representation of tree node EXPR to output block\n-   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n-   via lto_output_tree_ref.  */\n-\n-void\n-lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  unsigned ix;\n-  bool existed_p;\n-\n-  if (expr == NULL_TREE)\n-    {\n-      output_record_start (ob, LTO_null);\n-      return;\n-    }\n-\n-  /* INTEGER_CST nodes are special because they need their original type\n-     to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n-  if (TREE_CODE (expr) == INTEGER_CST)\n-    {\n-      lto_output_integer_cst (ob, expr, ref_p);\n-      return;\n-    }\n-\n-  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix);\n-  if (existed_p)\n-    {\n-      /* If a node has already been streamed out, make sure that\n-\t we don't write it more than once.  Otherwise, the reader\n-\t will instantiate two different nodes for the same object.  */\n-      output_record_start (ob, LTO_tree_pickle_reference);\n-      output_uleb128 (ob, ix);\n-      lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n-\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n-    }\n-  else if (lto_stream_as_builtin_p (expr))\n-    {\n-      /* MD and NORMAL builtins do not need to be written out\n-\t completely as they are always instantiated by the\n-\t compiler on startup.  The only builtins that need to\n-\t be written out are BUILT_IN_FRONTEND.  For all other\n-\t builtins, we simply write the class and code.  */\n-      lto_output_builtin_tree (ob, expr);\n-    }\n-  else\n-    {\n-      /* This is the first time we see EXPR, write its fields\n-\t to OB.  */\n-      lto_write_tree (ob, expr, ref_p);\n-    }\n-}"}, {"sha": "0517441013aeaf8c24cbf2c9d7729d8b1c696eea", "filename": "gcc/tree-streamer.c", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -245,6 +245,66 @@ lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n   return VEC_index (tree, cache->nodes, ix);\n }\n \n+\n+/* Record NODE in CACHE.  */\n+\n+static void\n+lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n+{\n+  /* We have to make sure to fill exactly the same number of\n+     elements for all frontends.  That can include NULL trees.\n+     As our hash table can't deal with zero entries we'll simply stream\n+     a random other tree.  A NULL tree never will be looked up so it\n+     doesn't matter which tree we replace it with, just to be sure\n+     use error_mark_node.  */\n+  if (!node)\n+    node = error_mark_node;\n+\n+  lto_streamer_cache_append (cache, node);\n+\n+  if (POINTER_TYPE_P (node)\n+      || TREE_CODE (node) == COMPLEX_TYPE\n+      || TREE_CODE (node) == ARRAY_TYPE)\n+    lto_record_common_node (cache, TREE_TYPE (node));\n+  else if (TREE_CODE (node) == RECORD_TYPE)\n+    {\n+      /* The FIELD_DECLs of structures should be shared, so that every\n+\t COMPONENT_REF uses the same tree node when referencing a field.\n+\t Pointer equality between FIELD_DECLs is used by the alias\n+\t machinery to compute overlapping memory references (See\n+\t nonoverlapping_component_refs_p).  */\n+      tree f;\n+      for (f = TYPE_FIELDS (node); f; f = TREE_CHAIN (f))\n+\tlto_record_common_node (cache, f);\n+    }\n+}\n+\n+\n+/* Preload common nodes into CACHE and make sure they are merged\n+   properly according to the gimple type table.  */\n+\n+static void\n+preload_common_nodes (struct lto_streamer_cache_d *cache)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < itk_none; i++)\n+    /* Skip itk_char.  char_type_node is dependent on -f[un]signed-char.  */\n+    if (i != itk_char)\n+      lto_record_common_node (cache, integer_types[i]);\n+\n+  for (i = 0; i < TYPE_KIND_LAST; i++)\n+    lto_record_common_node (cache, sizetype_tab[i]);\n+\n+  for (i = 0; i < TI_MAX; i++)\n+    /* Skip boolean type and constants, they are frontend dependent.  */\n+    if (i != TI_BOOLEAN_TYPE\n+\t&& i != TI_BOOLEAN_FALSE\n+\t&& i != TI_BOOLEAN_TRUE)\n+      lto_record_common_node (cache, global_trees[i]);\n+}\n+\n+\n /* Create a cache of pickled nodes.  */\n \n struct lto_streamer_cache_d *\n@@ -259,7 +319,7 @@ lto_streamer_cache_create (void)\n   /* Load all the well-known tree nodes that are always created by\n      the compiler on startup.  This prevents writing them out\n      unnecessarily.  */\n-  streamer_hooks.preload_common_nodes (cache);\n+  preload_common_nodes (cache);\n \n   return cache;\n }"}, {"sha": "ee1c0b15ffee6fa1b37a08e8e3ec9e59eafb5162", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9393656725809539d9a31c268df6230ed8d6691/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=b9393656725809539d9a31c268df6230ed8d6691", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_STREAMER_H\n \n #include \"tree.h\"\n+#include \"streamer-hooks.h\"\n #include \"lto-streamer.h\"\n \n /* Cache of pickled nodes.  Used to avoid writing the same node more\n@@ -51,14 +52,35 @@ struct lto_streamer_cache_d\n   VEC(tree,heap) *nodes;\n };\n \n+/* Return true if tree node EXPR should be streamed as a builtin.  For\n+   these nodes, we just emit the class and function code.  */\n+static inline bool\n+lto_stream_as_builtin_p (tree expr)\n+{\n+  return (TREE_CODE (expr) == FUNCTION_DECL\n+\t  && DECL_IS_BUILTIN (expr)\n+\t  && (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_NORMAL\n+\t      || DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD));\n+}\n+\n /* In tree-streamer-in.c.  */\n tree input_string_cst (struct data_in *, struct lto_input_block *);\n-tree lto_input_tree (struct lto_input_block *, struct data_in *);\n-void lto_streamer_read_tree (struct lto_input_block *,\n-\t\t\t\t     struct data_in *, tree);\n+void lto_streamer_read_tree (struct lto_input_block *, struct data_in *, tree);\n+tree lto_materialize_tree (struct lto_input_block *, struct data_in *,\n+\t\t\t   enum LTO_tags);\n+void lto_input_tree_pointers (struct lto_input_block *, struct data_in *, tree);\n+tree lto_get_pickled_tree (struct lto_input_block *, struct data_in *);\n+tree lto_get_builtin_tree (struct lto_input_block *, struct data_in *);\n+tree lto_input_integer_cst (struct lto_input_block *, struct data_in *);\n+struct bitpack_d tree_read_bitfields (struct lto_input_block *, tree);\n \n /* In tree-streamer-out.c.  */\n-void lto_streamer_write_tree (struct output_block *, tree, bool);\n+void lto_output_chain (struct output_block *, tree, bool);\n+void lto_output_tree_header (struct output_block *, tree);\n+void pack_value_fields (struct bitpack_d *, tree);\n+void lto_output_tree_pointers (struct output_block *, tree, bool);\n+void lto_output_integer_cst (struct output_block *, tree, bool);\n+void lto_output_builtin_tree (struct output_block *, tree);\n \n /* In tree-streamer.c.  */\n void check_handled_ts_structures (void);"}]}