{"sha": "c95c47f3e966ecff92e01cadb023976220b2b29a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1YzQ3ZjNlOTY2ZWNmZjkyZTAxY2FkYjAyMzk3NjIyMGIyYjI5YQ==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-03-18T21:28:43Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-03-18T21:28:43Z"}, "message": "(expand_float): When converting an unsigned type U to a smaller or equal-sized floating type F where there's no hardware support for unsigned-to-float conversion...\n\n(expand_float): When converting an unsigned type U\nto a smaller or equal-sized floating type F where there's no\nhardware support for unsigned-to-float conversion, use a temporary\nfloating type larger than F if possible, since this avoids\nrounding problems that are worst when U is just greater than\nthe maximum signed integer of the same size.\n\nFrom-SVN: r3778", "tree": {"sha": "438d0c17c50bfb92e65fa8fbbe055db48c213c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438d0c17c50bfb92e65fa8fbbe055db48c213c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c95c47f3e966ecff92e01cadb023976220b2b29a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95c47f3e966ecff92e01cadb023976220b2b29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c95c47f3e966ecff92e01cadb023976220b2b29a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95c47f3e966ecff92e01cadb023976220b2b29a/comments", "author": null, "committer": null, "parents": [{"sha": "0cdd3dddaec089933fadb35754aeb93f16f2117b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cdd3dddaec089933fadb35754aeb93f16f2117b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cdd3dddaec089933fadb35754aeb93f16f2117b"}], "stats": {"total": 24, "additions": 20, "deletions": 4}, "files": [{"sha": "95f1b212b19649a49f04fac696fb2422ea04b7ad", "filename": "gcc/optabs.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95c47f3e966ecff92e01cadb023976220b2b29a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95c47f3e966ecff92e01cadb023976220b2b29a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c95c47f3e966ecff92e01cadb023976220b2b29a", "patch": "@@ -3572,11 +3572,27 @@ expand_float (to, from, unsignedp)\n       if (flag_force_mem)\n \tfrom = force_not_mem (from);\n \n+      /* Look for a usable floating mode FMODE wider than the source and at\n+\t least as wide as the target.  Using FMODE will avoid rounding woes\n+\t with unsigned values greater than the signed maximum value.  */\n+      for (fmode = GET_MODE (to);  fmode != VOIDmode;\n+\t   fmode = GET_MODE_WIDER_MODE (fmode))\n+\tif (GET_MODE_BITSIZE (GET_MODE (from)) < GET_MODE_BITSIZE (fmode)\n+\t    && can_float_p (fmode, GET_MODE (from), 0) != CODE_FOR_nothing)\n+\t  break;\n+      if (fmode == VOIDmode)\n+\t{\n+\t  /* There is no such mode.  Pretend the target is wide enough.\n+\t     This may cause rounding problems, unfortunately.  */\n+\t  fmode = GET_MODE (to);\n+\t}\n+\n       /* If we are about to do some arithmetic to correct for an\n \t unsigned operand, do it in a pseudo-register.  */\n \n-      if (GET_CODE (to) != REG || REGNO (to) <= LAST_VIRTUAL_REGISTER)\n-\ttarget = gen_reg_rtx (GET_MODE (to));\n+      if (GET_MODE (to) != fmode\n+\t  || GET_CODE (to) != REG || REGNO (to) <= LAST_VIRTUAL_REGISTER)\n+\ttarget = gen_reg_rtx (fmode);\n \n       /* Convert as signed integer to floating.  */\n       expand_float (target, from, 0);\n@@ -3591,8 +3607,8 @@ expand_float (to, from, unsignedp)\n \t Rather than setting up a dconst_dot_5, let's hope SCO\n \t fixes the bug.  */\n       offset = REAL_VALUE_LDEXP (dconst1, GET_MODE_BITSIZE (GET_MODE (from)));\n-      temp = expand_binop (GET_MODE (to), add_optab, target,\n-\t\t\t   immed_real_const_1 (offset, GET_MODE (to)),\n+      temp = expand_binop (fmode, add_optab, target,\n+\t\t\t   immed_real_const_1 (offset, fmode),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n       if (temp != target)\n \temit_move_insn (target, temp);"}]}