{"sha": "82a04cd1d37bfaf10de8f648e35d40c91853d026", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJhMDRjZDFkMzdiZmFmMTBkZThmNjQ4ZTM1ZDQwYzkxODUzZDAyNg==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2018-05-13T18:23:06Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2018-05-13T18:23:06Z"}, "message": "Introduce gcc_qsort\n\n\t* sort.cc: New file.\n\t* system.h [!CHECKING_P] (qsort): Redirect to gcc_qsort.\n\t* vec.c (qsort_chk): Use gcc_qsort.\n\t* Makefile.in (OBJS-libcommon): Add sort.o.\n\t(build/sort.o): New target.  Use it...\n\t(BUILD_RTL): ... here, and...\n\t(build/gencfn-macros): ... here, and...\n\t(build/genmatch): ... here.\n\nFrom-SVN: r260216", "tree": {"sha": "0f08f3d658c0f7ea3c270d1428051151b0c20614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f08f3d658c0f7ea3c270d1428051151b0c20614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82a04cd1d37bfaf10de8f648e35d40c91853d026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a04cd1d37bfaf10de8f648e35d40c91853d026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82a04cd1d37bfaf10de8f648e35d40c91853d026", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a04cd1d37bfaf10de8f648e35d40c91853d026/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "628332f85dbcd0996f68afae47b2b6d134b7b268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628332f85dbcd0996f68afae47b2b6d134b7b268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628332f85dbcd0996f68afae47b2b6d134b7b268"}], "stats": {"total": 261, "additions": 254, "deletions": 7}, "files": [{"sha": "2a246289ed4f9fdc71e26e080d9d9ea803e8d2e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82a04cd1d37bfaf10de8f648e35d40c91853d026", "patch": "@@ -1,3 +1,14 @@\n+2018-05-13  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* sort.cc: New file.\n+\t* system.h [!CHECKING_P] (qsort): Redirect to gcc_qsort.\n+\t* vec.c (qsort_chk): Use gcc_qsort.\n+\t* Makefile.in (OBJS-libcommon): Add sort.o.\n+\t(build/sort.o): New target.  Use it...\n+\t(BUILD_RTL): ... here, and...\n+\t(build/gencfn-macros): ... here, and...\n+\t(build/genmatch): ... here.\n+\n 2018-05-13  Kito Cheng  <kito.cheng@gmail.com>\n \t    Chung-Ju Wu  <jasonwucj@gmail.com>\n "}, {"sha": "8ec0511704de0034b53946e6137d9f51809bec01", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=82a04cd1d37bfaf10de8f648e35d40c91853d026", "patch": "@@ -1076,7 +1076,7 @@ BUILD_LIBS = $(BUILD_LIBIBERTY)\n \n BUILD_RTL = build/rtl.o build/read-rtl.o build/ggc-none.o \\\n \t    build/vec.o build/min-insn-modes.o build/gensupport.o \\\n-\t    build/print-rtl.o build/hash-table.o\n+\t    build/print-rtl.o build/hash-table.o build/sort.o\n BUILD_MD = build/read-md.o\n BUILD_ERRORS = build/errors.o\n \n@@ -1611,7 +1611,7 @@ OBJS-libcommon = diagnostic.o diagnostic-color.o diagnostic-show-locus.o \\\n \tpretty-print.o intl.o \\\n \tsbitmap.o \\\n \tvec.o input.o version.o hash-table.o ggc-none.o memory-block.o \\\n-\tselftest.o selftest-diagnostic.o\n+\tselftest.o selftest-diagnostic.o sort.o\n \n # Objects in libcommon-target.a, used by drivers and by the core\n # compiler and containing target-dependent code.\n@@ -2681,6 +2681,7 @@ build/vec.o : vec.c $(BCONFIG_H) $(SYSTEM_H) $(CORETYPES_H) $(VEC_H)\t\\\n   $(GGC_H) toplev.h $(DIAGNOSTIC_CORE_H)\n build/hash-table.o : hash-table.c $(BCONFIG_H) $(SYSTEM_H)\t\t\\\n   $(CORETYPES_H) $(HASH_TABLE_H) $(GGC_H) toplev.h $(DIAGNOSTIC_CORE_H)\n+build/sort.o : sort.cc $(BCONFIG_H) $(SYSTEM_H)\n build/inchash.o : inchash.c $(BCONFIG_H) $(SYSTEM_H) $(CORETYPES_H)\t\\\n   $(HASHTAB_H) inchash.h\n build/gencondmd.o : build/gencondmd.c $(BCONFIG_H) $(SYSTEM_H)\t\t\\\n@@ -2817,7 +2818,7 @@ build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n build/genrecog$(build_exeext) : build/hash-table.o build/inchash.o\n build/gencfn-macros$(build_exeext) : build/hash-table.o build/vec.o \\\n-  build/ggc-none.o\n+  build/ggc-none.o build/sort.o\n \n # For stage1 and when cross-compiling use the build libcpp which is\n # built with NLS disabled.  For stage2+ use the host library and\n@@ -2831,7 +2832,7 @@ build/genmatch$(build_exeext): BUILD_LIBS += $(LIBINTL) $(LIBICONV)\n endif\n \n build/genmatch$(build_exeext) : $(BUILD_CPPLIB) \\\n-  $(BUILD_ERRORS) build/vec.o build/hash-table.o\n+  $(BUILD_ERRORS) build/vec.o build/hash-table.o build/sort.o\n \n # These programs are not linked with the MD reader.\n build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o \\"}, {"sha": "28d52268afd88d11f51955552dadf109bbbac076", "filename": "gcc/sort.cc", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2Fsort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2Fsort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsort.cc?ref=82a04cd1d37bfaf10de8f648e35d40c91853d026", "patch": "@@ -0,0 +1,232 @@\n+/* Platform-independent deterministic sort function.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Alexander Monakov.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This implements a sort function suitable for GCC use cases:\n+   - signature-compatible to C qsort, but relaxed contract:\n+     - may apply the comparator to elements in a temporary buffer\n+     - may abort on allocation failure\n+   - deterministic (but not necessarily stable)\n+   - fast, especially for common cases (0-5 elements of size 8 or 4)\n+\n+   The implementation uses a network sort for up to 5 elements and\n+   a merge sort on top of that.  Neither stage has branches depending on\n+   comparator result, trading extra arithmetic for branch mispredictions.  */\n+\n+#ifdef GENERATOR_FILE\n+#include \"bconfig.h\"\n+#else\n+#include \"config.h\"\n+#endif\n+\n+#include \"system.h\"\n+\n+#define likely(cond) __builtin_expect ((cond), 1)\n+\n+#ifdef __GNUC__\n+#define noinline __attribute__ ((__noinline__))\n+#else\n+#define noinline\n+#endif\n+\n+/* C-style qsort comparator function type.  */\n+typedef int cmp_fn (const void *, const void *);\n+\n+/* Structure holding read-mostly (read-only in netsort) context.  */\n+struct sort_ctx\n+{\n+  cmp_fn *cmp; // pointer to comparator\n+  char   *out; // output buffer\n+  size_t n;    // number of elements\n+  size_t size; // element size\n+};\n+\n+/* Helper for netsort. Permute, possibly in-place, 2 or 3 elements,\n+   placing E0 to C->OUT, E1 to C->OUT + C->SIZE, and so on.  */\n+static void\n+reorder23 (sort_ctx *c, char *e0, char *e1, char *e2)\n+{\n+#define REORDER_23(SIZE, STRIDE, OFFSET)        \\\n+do {                                            \\\n+  size_t t0, t1;                                \\\n+  memcpy (&t0, e0 + OFFSET, SIZE);              \\\n+  memcpy (&t1, e1 + OFFSET, SIZE);              \\\n+  char *out = c->out + OFFSET;                  \\\n+  if (likely (c->n == 3))                       \\\n+    memcpy (out + 2*STRIDE, e2 + OFFSET, SIZE); \\\n+  memcpy (out, &t0, SIZE); out += STRIDE;       \\\n+  memcpy (out, &t1, SIZE);                      \\\n+} while (0)\n+\n+  if (sizeof (size_t) == 8 && likely (c->size == 8))\n+    REORDER_23 (8, 8, 0);\n+  else if (likely (c->size == 4))\n+    REORDER_23 (4, 4, 0);\n+  else\n+    {\n+      size_t offset = 0, step = sizeof (size_t);\n+      for (; offset + step <= c->size; offset += step)\n+\tREORDER_23 (step, c->size, offset);\n+      for (; offset < c->size; offset++)\n+\tREORDER_23 (1, c->size, offset);\n+    }\n+}\n+\n+/* Like reorder23, but permute 4 or 5 elements.  */\n+static void\n+reorder45 (sort_ctx *c, char *e0, char *e1, char *e2, char *e3, char *e4)\n+{\n+#define REORDER_45(SIZE, STRIDE, OFFSET)        \\\n+do {                                            \\\n+  size_t t0, t1, t2, t3;                        \\\n+  memcpy (&t0, e0 + OFFSET, SIZE);              \\\n+  memcpy (&t1, e1 + OFFSET, SIZE);              \\\n+  memcpy (&t2, e2 + OFFSET, SIZE);              \\\n+  memcpy (&t3, e3 + OFFSET, SIZE);              \\\n+  char *out = c->out + OFFSET;                  \\\n+  if (likely (c->n == 5))                       \\\n+    memcpy (out + 4*STRIDE, e4 + OFFSET, SIZE); \\\n+  memcpy (out, &t0, SIZE); out += STRIDE;       \\\n+  memcpy (out, &t1, SIZE); out += STRIDE;       \\\n+  memcpy (out, &t2, SIZE); out += STRIDE;       \\\n+  memcpy (out, &t3, SIZE);                      \\\n+} while (0)\n+\n+  if (sizeof (size_t) == 8 && likely (c->size == 8))\n+    REORDER_45 (8, 8, 0);\n+  else if (likely(c->size == 4))\n+    REORDER_45 (4, 4, 0);\n+  else\n+    {\n+      size_t offset = 0, step = sizeof (size_t);\n+      for (; offset + step <= c->size; offset += step)\n+\tREORDER_45 (step, c->size, offset);\n+      for (; offset < c->size; offset++)\n+\tREORDER_45 (1, c->size, offset);\n+    }\n+}\n+\n+/* Helper for netsort. Invoke comparator CMP on E0 and E1.\n+   Return E0^E1 if E0 compares less than E1, zero otherwise.\n+   This is noinline to avoid code growth and confine invocation\n+   to a single call site, assisting indirect branch prediction.  */\n+noinline static intptr_t\n+cmp1 (char *e0, char *e1, cmp_fn *cmp)\n+{\n+  intptr_t x = (intptr_t)e0 ^ (intptr_t)e1;\n+  return x & (cmp (e0, e1) >> 31);\n+}\n+\n+/* Execute network sort on 2 to 5 elements from IN, placing them into C->OUT.\n+   IN may be equal to C->OUT, in which case elements are sorted in place.  */\n+static void\n+netsort (char *in, sort_ctx *c)\n+{\n+#define CMP(e0, e1)                   \\\n+do {                                  \\\n+  intptr_t x = cmp1 (e1, e0, c->cmp); \\\n+  e0 = (char *)((intptr_t)e0 ^ x);    \\\n+  e1 = (char *)((intptr_t)e1 ^ x);    \\\n+} while (0)\n+\n+  char *e0 = in, *e1 = e0 + c->size, *e2 = e1 + c->size;\n+  CMP (e0, e1);\n+  if (likely (c->n == 3))\n+    {\n+      CMP (e1, e2);\n+      CMP (e0, e1);\n+    }\n+  if (c->n <= 3)\n+    return reorder23 (c, e0, e1, e2);\n+  char *e3 = e2 + c->size, *e4 = e3 + c->size;\n+  if (likely (c->n == 5))\n+    {\n+      CMP (e3, e4);\n+      CMP (e2, e4);\n+    }\n+  CMP (e2, e3);\n+  if (likely (c->n == 5))\n+    {\n+      CMP (e0, e3);\n+      CMP (e1, e4);\n+    }\n+  CMP (e0, e2);\n+  CMP (e1, e3);\n+  CMP (e1, e2);\n+  reorder45 (c, e0, e1, e2, e3, e4);\n+}\n+\n+/* Execute merge sort on N elements from IN, placing them into OUT,\n+   using TMP as temporary storage if IN is equal to OUT.\n+   This is a stable sort if netsort is used only for 2 or 3 elements.  */\n+static void\n+mergesort (char *in, sort_ctx *c, size_t n, char *out, char *tmp)\n+{\n+  if (likely (n <= 5))\n+    {\n+      c->out = out;\n+      c->n = n;\n+      return netsort (in, c);\n+    }\n+  size_t nl = n / 2, nr = n - nl, sz = nl * c->size;\n+  char *mid = in + sz, *r = out + sz, *l = in == out ? tmp : in;\n+  /* Sort the right half, outputting to right half of OUT.  */\n+  mergesort (mid, c, nr, r, tmp);\n+  /* Sort the left half, leaving left half of OUT free.  */\n+  mergesort (in, c, nl, l, mid);\n+  /* Merge sorted halves given by L, R to [OUT, END).  */\n+#define MERGE_ELTSIZE(SIZE)                     \\\n+do {                                            \\\n+  intptr_t mr = c->cmp (r, l) >> 31;            \\\n+  intptr_t lr = (intptr_t)l ^ (intptr_t)r;      \\\n+  lr = (intptr_t)l ^ (lr & mr);                 \\\n+  out = (char *)memcpy (out, (char *)lr, SIZE); \\\n+  out += SIZE;                                  \\\n+  r += mr & SIZE;                               \\\n+  if (r == out) return;                         \\\n+  l += ~mr & SIZE;                              \\\n+} while (r != end)\n+\n+  if (likely (c->cmp(r, l + (r - out) - c->size) < 0))\n+    {\n+      char *end = out + n * c->size;\n+      if (sizeof (size_t) == 8 && likely (c->size == 8))\n+\tMERGE_ELTSIZE (8);\n+      else if (likely (c->size == 4))\n+\tMERGE_ELTSIZE (4);\n+      else\n+\tMERGE_ELTSIZE (c->size);\n+    }\n+  memcpy (out, l, r - out);\n+}\n+\n+void\n+gcc_qsort (void *vbase, size_t n, size_t size, cmp_fn *cmp)\n+{\n+  if (n < 2)\n+    return;\n+  char *base = (char *)vbase;\n+  sort_ctx c = {cmp, base, n, size};\n+  long long scratch[32];\n+  size_t bufsz = (n / 2) * size;\n+  void *buf = bufsz <= sizeof scratch ? scratch : xmalloc (bufsz);\n+  mergesort (base, &c, n, base, (char *)buf);\n+  if (buf != scratch)\n+    free (buf);\n+}"}, {"sha": "88dffccb8ab876a4d7403f328b79af1492f54e41", "filename": "gcc/system.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=82a04cd1d37bfaf10de8f648e35d40c91853d026", "patch": "@@ -1202,11 +1202,14 @@ helper_const_non_const_cast (const char *p)\n /* qsort comparator consistency checking: except in release-checking compilers,\n    redirect 4-argument qsort calls to qsort_chk; keep 1-argument invocations\n    corresponding to vec::qsort (cmp): they use C qsort internally anyway.  */\n-#if CHECKING_P\n+void qsort_chk (void *, size_t, size_t, int (*)(const void *, const void *));\n+void gcc_qsort (void *, size_t, size_t, int (*)(const void *, const void *));\n #define PP_5th(a1, a2, a3, a4, a5, ...) a5\n #undef qsort\n+#if CHECKING_P\n #define qsort(...) PP_5th (__VA_ARGS__, qsort_chk, 3, 2, qsort, 0) (__VA_ARGS__)\n-void qsort_chk (void *, size_t, size_t, int (*)(const void *, const void *));\n+#else\n+#define qsort(...) PP_5th (__VA_ARGS__, gcc_qsort, 3, 2, qsort, 0) (__VA_ARGS__)\n #endif\n \n #endif /* ! GCC_SYSTEM_H */"}, {"sha": "2941715a34a66b15aa8e65865471f891a99a71ad", "filename": "gcc/vec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82a04cd1d37bfaf10de8f648e35d40c91853d026/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=82a04cd1d37bfaf10de8f648e35d40c91853d026", "patch": "@@ -215,7 +215,7 @@ void\n qsort_chk (void *base, size_t n, size_t size,\n \t   int (*cmp)(const void *, const void *))\n {\n-  (qsort) (base, n, size, cmp);\n+  gcc_qsort (base, n, size, cmp);\n #if 0\n #define LIM(n) (n)\n #else"}]}