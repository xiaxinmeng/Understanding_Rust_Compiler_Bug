{"sha": "83e3f98b8dd2baa580609846282e17f8a2313eae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNlM2Y5OGI4ZGQyYmFhNTgwNjA5ODQ2MjgyZTE3ZjhhMjMxM2VhZQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-14T23:46:34Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-14T23:46:34Z"}, "message": "re PR target/53988 ([SH] tst Rm,Rn not used for QI/HImode)\n\ngcc/\n\tPR target/53988\n\t* config/sh/sh-protos.h (sh_find_set_of_reg): Add option to ignore\n\treg-reg copies.\n\t(sh_extending_set_of_reg): New struct.\n\t(sh_find_extending_set_of_reg, sh_split_tst_subregs,\n\tsh_remove_reg_dead_or_unused_notes): New Declarations.\n\t* config/sh/sh.c (sh_remove_reg_dead_or_unused_notes,\n\tsh_find_extending_set_of_reg, sh_split_tst_subregs,\n\tsh_extending_set_of_reg::use_as_extended_reg): New functions.\n\t* config/sh/sh.md (*tst<mode>_t_zero): Rename to *tst<mode>_t_subregs,\n\tconvert to insn_and_split and use new function sh_split_tst_subregs.\n\ngcc/testsuite/\n\tPR target/53988\n\t* gcc.target/sh/pr53988-1.c: New.\n\nFrom-SVN: r219623", "tree": {"sha": "c350038554cd489a1334d9caa397aa1aad59d472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c350038554cd489a1334d9caa397aa1aad59d472"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83e3f98b8dd2baa580609846282e17f8a2313eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e3f98b8dd2baa580609846282e17f8a2313eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e3f98b8dd2baa580609846282e17f8a2313eae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e3f98b8dd2baa580609846282e17f8a2313eae/comments", "author": null, "committer": null, "parents": [{"sha": "ce2c3163d2a136471d5f581893a93f869428cd98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2c3163d2a136471d5f581893a93f869428cd98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2c3163d2a136471d5f581893a93f869428cd98"}], "stats": {"total": 365, "additions": 349, "deletions": 16}, "files": [{"sha": "5e959c20f984ff9d4251757d1d986a6dda81934b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83e3f98b8dd2baa580609846282e17f8a2313eae", "patch": "@@ -1,3 +1,17 @@\n+2015-01-14  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53988\n+\t* config/sh/sh-protos.h (sh_find_set_of_reg): Add option to ignore\n+\treg-reg copies.\n+\t(sh_extending_set_of_reg): New struct.\n+\t(sh_find_extending_set_of_reg, sh_split_tst_subregs,\n+\tsh_remove_reg_dead_or_unused_notes): New Declarations.\n+\t* config/sh/sh.c (sh_remove_reg_dead_or_unused_notes,\n+\tsh_find_extending_set_of_reg, sh_split_tst_subregs,\n+\tsh_extending_set_of_reg::use_as_extended_reg): New functions.\n+\t* config/sh/sh.md (*tst<mode>_t_zero): Rename to *tst<mode>_t_subregs,\n+\tconvert to insn_and_split and use new function sh_split_tst_subregs.\n+\n 2015-01-14  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi (Option Summary): Reclassify -fuse-ld as a linker"}, {"sha": "181062c07838fcf1afe21a111c3b8f90857cd343", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=83e3f98b8dd2baa580609846282e17f8a2313eae", "patch": "@@ -181,7 +181,8 @@ struct set_of_reg\n    'prev_nonnote_insn_bb'.  When the insn is found, try to extract the rtx\n    of the reg set.  */\n template <typename F> inline set_of_reg\n-sh_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc)\n+sh_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc,\n+\t\t    bool ignore_reg_reg_copies = false)\n {\n   set_of_reg result;\n   result.insn = insn;\n@@ -206,17 +207,70 @@ sh_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc)\n \t    return result;\n \n \t  result.set_src = XEXP (result.set_rtx, 1);\n+\n+\t  if (ignore_reg_reg_copies && REG_P (result.set_src))\n+\t    {\n+\t      reg = result.set_src;\n+\t      continue;\n+\t    }\n+\t  if (ignore_reg_reg_copies && SUBREG_P (result.set_src)\n+\t      && REG_P (SUBREG_REG (result.set_src)))\n+\t    {\n+\t      reg = SUBREG_REG (result.set_src);\n+\t      continue;\n+\t    }\n+\n \t  return result;\n \t}\n     }\n \n   return result;\n }\n \n+/* Result value of sh_find_extending_set_of_reg.  */\n+struct sh_extending_set_of_reg : public set_of_reg\n+{\n+  /* The mode the set is extending from (QImode or HImode), or VOIDmode if\n+     this is not a zero/sign extending set.  */\n+  machine_mode from_mode;\n+\n+  /* ZERO_EXTEND, SIGN_EXTEND or UNKNOWN.  */\n+  rtx_code ext_code;\n+\n+  sh_extending_set_of_reg (rtx_insn* i)\n+  {\n+    insn = i;\n+    set_rtx = NULL;\n+    set_src = NULL;\n+    from_mode = VOIDmode;\n+    ext_code = UNKNOWN;\n+  }\n+\n+  sh_extending_set_of_reg (const set_of_reg& rhs)\n+  {\n+    *((set_of_reg*)this) = rhs;\n+    from_mode = VOIDmode;\n+    ext_code = UNKNOWN;\n+  }\n+\n+  /* Returns the reg rtx of the sign or zero extending result, that can be\n+     safely used at the specified insn in SImode.  If the set source is an\n+     implicitly sign extending mem load, the mem load is converted into an\n+     explicitly sign extending mem load.  */\n+  rtx use_as_extended_reg (rtx_insn* use_at_insn) const;\n+};\n+\n+extern sh_extending_set_of_reg sh_find_extending_set_of_reg (rtx reg,\n+\t\t\t\t\t\t\t     rtx_insn* insn);\n+\n extern bool sh_is_logical_t_store_expr (rtx op, rtx_insn* insn);\n extern rtx sh_try_omit_signzero_extend (rtx extended_op, rtx_insn* insn);\n extern bool sh_split_movrt_negc_to_movt_xor (rtx_insn* curr_insn,\n \t\t\t\t\t     rtx operands[]);\n+extern void sh_split_tst_subregs (rtx_insn* curr_insn,\n+\t\t\t\t  machine_mode subreg_mode, int subreg_offset,\n+\t\t\t\t  rtx operands[]);\n+extern void sh_remove_reg_dead_or_unused_notes (rtx_insn* i, int regno);\n #endif /* RTX_CODE */\n \n extern void sh_cpu_cpp_builtins (cpp_reader* pfile);"}, {"sha": "8acb1841e0bb5e14465e9da55f6a18848fafdc2d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=83e3f98b8dd2baa580609846282e17f8a2313eae", "patch": "@@ -13769,6 +13769,17 @@ sh_insn_operands_modified_between_p (rtx_insn* operands_insn,\n   return false;\n }\n \n+/* Given an insn and a reg number, remove reg dead or reg unused notes to\n+   mark it as being used after the insn.  */\n+void\n+sh_remove_reg_dead_or_unused_notes (rtx_insn* i, int regno)\n+{\n+  if (rtx n = find_regno_note (i, REG_DEAD, regno))\n+    remove_note (i, n);\n+  if (rtx n = find_regno_note (i, REG_UNUSED, regno))\n+    remove_note (i, n);\n+}\n+\n /* Given an op rtx and an insn, try to find out whether the result of the\n    specified op consists only of logical operations on T bit stores.  */\n bool\n@@ -13881,6 +13892,175 @@ sh_split_movrt_negc_to_movt_xor (rtx_insn* curr_insn, rtx operands[])\n     return false;\n }\n \n+/* Given a reg and the current insn, see if the value of the reg originated\n+   from a sign or zero extension and return the discovered information.  */\n+sh_extending_set_of_reg\n+sh_find_extending_set_of_reg (rtx reg, rtx_insn* curr_insn)\n+{\n+  if (reg == NULL)\n+    return sh_extending_set_of_reg (curr_insn);\n+\n+  if (SUBREG_P (reg))\n+    reg = SUBREG_REG (reg);\n+\n+  if (!REG_P (reg))\n+    return sh_extending_set_of_reg (curr_insn);\n+\n+  /* FIXME: Also search the predecessor basic blocks.  It seems that checking\n+     only the adjacent predecessor blocks would cover most of the cases.\n+     Also try to look through the first extension that we hit.  There are some\n+     cases, where a zero_extend is followed an (implicit) sign_extend, and it\n+     fails to see the sign_extend.  */\n+  sh_extending_set_of_reg result =\n+\tsh_find_set_of_reg (reg, curr_insn, prev_nonnote_insn_bb, true);\n+\n+  if (result.set_src != NULL)\n+    {\n+      if (GET_CODE (result.set_src) == SIGN_EXTEND\n+\t  || GET_CODE (result.set_src) == ZERO_EXTEND)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"sh_find_szexnteded_reg: reg %d is \"\n+\t\t\t\t\"explicitly sign/zero extended in insn %d\\n\",\n+\t\t\t\tREGNO (reg), INSN_UID (result.insn));\n+\t  result.from_mode = GET_MODE (XEXP (result.set_src, 0));\n+\t  result.ext_code = GET_CODE (result.set_src);\n+\t}\n+      else if (MEM_P (result.set_src)\n+\t       && (GET_MODE (result.set_src) == QImode\n+\t\t   || GET_MODE (result.set_src) == HImode))\n+\t{\n+\t  /* On SH QIHImode memory loads always sign extend.  However, in\n+\t     some cases where it seems that the higher bits are not\n+\t     interesting, the loads will not be expanded as sign extending\n+\t     insns, but as QIHImode loads into QIHImode regs.  We report that\n+\t     the reg has been sign extended by the mem load.  When it is used\n+\t     as such, we must convert the mem load into a sign extending insn,\n+\t     see also sh_extending_set_of_reg::use_as_extended_reg.  */\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"sh_find_extending_set_of_reg: reg %d is \"\n+\t\t\t\t\"implicitly sign extended in insn %d\\n\",\n+\t\t\t\tREGNO (reg), INSN_UID (result.insn));\n+\t  result.from_mode = GET_MODE (result.set_src);\n+\t  result.ext_code = SIGN_EXTEND;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+/* Given a reg that is known to be sign or zero extended at some insn,\n+   take the appropriate measures so that the extended value can be used as\n+   a reg at the specified insn and return the resulting reg rtx.  */\n+rtx\n+sh_extending_set_of_reg::use_as_extended_reg (rtx_insn* use_at_insn) const\n+{\n+  gcc_assert (insn != NULL && set_src != NULL && set_rtx != NULL);\n+  gcc_assert (ext_code == SIGN_EXTEND || ext_code == ZERO_EXTEND);\n+  gcc_assert (from_mode == QImode || from_mode == HImode);\n+\n+  if (MEM_P (set_src) && ext_code == SIGN_EXTEND)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"use_as_extended_reg: converting non-extending mem load in \"\n+\t\t \"insn %d into sign-extending load\\n\", INSN_UID (insn));\n+\n+\trtx r = gen_reg_rtx (SImode);\n+\trtx_insn* i0;\n+\tif (from_mode == QImode)\n+\t  i0 = emit_insn_after (gen_extendqisi2 (r, set_src), insn);\n+\telse if (from_mode == HImode)\n+\t  i0 = emit_insn_after (gen_extendhisi2 (r, set_src), insn);\n+\telse\n+\t  gcc_unreachable ();\n+\n+\temit_insn_after (\n+\t\tgen_move_insn (XEXP (set_rtx, 0),\n+\t\t\t       gen_lowpart (GET_MODE (set_src), r)), i0);\n+\tset_insn_deleted (insn);\n+\treturn r;\n+    }\n+  else\n+    {\n+      rtx extension_dst = XEXP (set_rtx, 0);\n+      if (modified_between_p (extension_dst, insn, use_at_insn))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"use_as_extended_reg: dest reg %d of extending insn %d is \"\n+\t\t     \"modified, inserting a reg-reg copy\\n\",\n+\t\t     REGNO (extension_dst), INSN_UID (insn));\n+\n+\t  rtx r = gen_reg_rtx (SImode);\n+\t  emit_insn_after (gen_move_insn (r, extension_dst), insn);\n+\t  return r;\n+\t}\n+      else\n+\t{\n+\t  sh_remove_reg_dead_or_unused_notes (insn, REGNO (extension_dst));\n+\t  return extension_dst;\n+\t}\n+    }\n+}\n+\n+/* Given the current insn, which is assumed to be the *tst<mode>_t_subregs insn,\n+   perform the necessary checks on the operands and split it accordingly.  */\n+void\n+sh_split_tst_subregs (rtx_insn* curr_insn, machine_mode subreg_mode,\n+\t\t      int subreg_offset, rtx operands[])\n+{\n+  gcc_assert (subreg_mode == QImode || subreg_mode == HImode);\n+\n+  sh_extending_set_of_reg eop0 = sh_find_extending_set_of_reg (operands[0],\n+\t\t\t\t\t\t\t       curr_insn);\n+  sh_extending_set_of_reg eop1 = sh_find_extending_set_of_reg (operands[1],\n+\t\t\t\t\t\t\t       curr_insn);\n+\n+  /* If one of the operands is known to be zero extended, that's already\n+     sufficient to mask out the unwanted high bits.  */\n+  if (eop0.ext_code == ZERO_EXTEND && eop0.from_mode == subreg_mode)\n+    {\n+      emit_insn (gen_tstsi_t (eop0.use_as_extended_reg (curr_insn),\n+\t\t\t      operands[1]));\n+      return;\n+    }\n+  if (eop1.ext_code == ZERO_EXTEND && eop1.from_mode == subreg_mode)\n+    {\n+      emit_insn (gen_tstsi_t (operands[0],\n+\t\t\t      eop1.use_as_extended_reg (curr_insn)));\n+      return;\n+    }\n+\n+  /* None of the operands seem to be zero extended.\n+     If both are sign extended it's OK, too.  */\n+  if (eop0.ext_code == SIGN_EXTEND && eop1.ext_code == SIGN_EXTEND\n+      && eop0.from_mode == subreg_mode && eop1.from_mode == subreg_mode)\n+    {\n+      emit_insn (gen_tstsi_t (eop0.use_as_extended_reg (curr_insn),\n+\t\t\t      eop1.use_as_extended_reg (curr_insn)));\n+      return;\n+    }\n+\n+  /* Otherwise we have to insert a zero extension on one of the operands to\n+     mask out the unwanted high bits.\n+     Prefer the operand that has no known extension.  */\n+  if (eop0.ext_code != UNKNOWN && eop1.ext_code == UNKNOWN)\n+    std::swap (operands[0], operands[1]);\n+\n+  rtx tmp0 = gen_reg_rtx (SImode);\n+  rtx tmp1 = simplify_gen_subreg (subreg_mode, operands[0],\n+\t\t\t\t  GET_MODE (operands[0]), subreg_offset);\n+  emit_insn (subreg_mode == QImode\n+\t     ? gen_zero_extendqisi2 (tmp0, tmp1)\n+\t     : gen_zero_extendhisi2 (tmp0, tmp1));\n+  emit_insn (gen_tstsi_t (tmp0, operands[1]));\n+}\n+\n+/*------------------------------------------------------------------------------\n+  Mode switching support code.\n+*/\n+\n static void\n sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,\n \t\t  int prev_mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)\n@@ -13949,6 +14129,10 @@ sh_mode_priority (int entity ATTRIBUTE_UNUSED, int n)\n   return ((TARGET_FPU_SINGLE != 0) ^ (n) ? FP_MODE_SINGLE : FP_MODE_DOUBLE);\n }\n \n+/*------------------------------------------------------------------------------\n+  Misc\n+*/\n+\n /* Return true if we use LRA instead of reload pass.  */\n static bool\n sh_lra_p (void)"}, {"sha": "d9d5d0a810bcaec75d82b1f1567bea538b408a86", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=83e3f98b8dd2baa580609846282e17f8a2313eae", "patch": "@@ -666,30 +666,40 @@\n   [(set_attr \"type\" \"mt_group\")])\n \n ;; This pattern might be risky because it also tests the upper bits and not\n-;; only the subreg.  However, it seems that combine will get to this only\n-;; when testing sign/zero extended values.  In this case the extended upper\n-;; bits do not matter.\n-(define_insn \"*tst<mode>_t_zero\"\n+;; only the subreg.  We have to check whether the operands have been sign\n+;; or zero extended.  In the worst case, a zero extension has to be inserted\n+;; to mask out the unwanted bits.\n+(define_insn_and_split \"*tst<mode>_t_subregs\"\n   [(set (reg:SI T_REG)\n \t(eq:SI\n \t  (subreg:QIHI\n-\t    (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n-\t\t    (match_operand:SI 1 \"arith_reg_operand\" \"r\")) <lowpart_le>)\n+\t    (and:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t    (match_operand:SI 1 \"arith_reg_operand\")) <lowpart_le>)\n \t  (const_int 0)))]\n-  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN\"\n-  \"tst\t%0,%1\"\n-  [(set_attr \"type\" \"mt_group\")])\n+  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_split_tst_subregs (curr_insn, <MODE>mode, <lowpart_le>, operands);\n+  DONE;\n+})\n \n-(define_insn \"*tst<mode>_t_zero\"\n+(define_insn_and_split \"*tst<mode>_t_subregs\"\n   [(set (reg:SI T_REG)\n \t(eq:SI\n \t  (subreg:QIHI\n-\t    (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n-\t\t    (match_operand:SI 1 \"arith_reg_operand\" \"r\")) <lowpart_be>)\n+\t    (and:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t    (match_operand:SI 1 \"arith_reg_operand\")) <lowpart_be>)\n \t  (const_int 0)))]\n-  \"TARGET_SH1 && TARGET_BIG_ENDIAN\"\n-  \"tst\t%0,%1\"\n-  [(set_attr \"type\" \"mt_group\")])\n+  \"TARGET_SH1 && TARGET_BIG_ENDIAN && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_split_tst_subregs (curr_insn, <MODE>mode, <lowpart_be>, operands);\n+  DONE;\n+})\n \n ;; Extract LSB, negate and store in T bit.\n (define_insn \"tstsi_t_and_not\""}, {"sha": "cfbbde81847aada9ce66bc9abc1e46a056bf1dc8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=83e3f98b8dd2baa580609846282e17f8a2313eae", "patch": "@@ -1,3 +1,8 @@\n+2015-01-14  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53988\n+\t* gcc.target/sh/pr53988-1.c: New.\n+\n 2015-01-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58671"}, {"sha": "4e0d49edfaffc42eee465e07f904ae5bb14ae0f4", "filename": "gcc/testsuite/gcc.target/sh/pr53988-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53988-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e3f98b8dd2baa580609846282e17f8a2313eae/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53988-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53988-1.c?ref=83e3f98b8dd2baa580609846282e17f8a2313eae", "patch": "@@ -0,0 +1,66 @@\n+/* Check that sign/zero extensions are emitted where needed when the\n+   tst Rm,Rn instruction is used.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"tst\\tr\" 8 } }  */\n+/* { dg-final { scan-assembler-times \"mov.b\" 4 } }  */\n+/* { dg-final { scan-assembler-times \"mov.w\" 4 } }  */\n+/* { dg-final { scan-assembler-times \"extu.b\" 4 } }  */\n+/* { dg-final { scan-assembler-times \"extu.w\" 2 } }  */\n+\n+int\n+test_00 (char* x, char* y)\n+{\n+  /* 2x mov.b (sign extending)  */\n+  return *x & *y ? -40 : 60;\n+}\n+\n+int\n+test_01 (short* x, short* y)\n+{\n+  /* 2x mov.w (sign extending)  */\n+  return *x & *y ? -40 : 60;\n+}\n+\n+int\n+test_02 (char x, char y)\n+{\n+  /* 1x extu.b  */\n+  return x & y ? -40 : 60;\n+}\n+\n+int\n+test_03 (short x, short y)\n+{\n+  /* 1x extu.w  */\n+  return x & y ? -40 : 60;\n+}\n+\n+int\n+test_04 (char* x, unsigned char y)\n+{\n+  /* 1x mov.b, 1x extu.b  */\n+  return *x & y ? -40 : 60;\n+}\n+\n+int\n+test_05 (short* x, unsigned char y)\n+{\n+  /* 1x mov.w, 1x extu.b  */\n+  return *x & y ? -40 : 60;\n+}\n+\n+int\n+test_06 (short x, short* y, int z, int w)\n+{\n+  /* 1x mov.w, 1x extu.w  */\n+  return x & y[0] ? z : w;\n+}\n+\n+int\n+test_07 (char x, char* y, int z, int w)\n+{\n+  /* 1x mov.b, 1x extu.b  */\n+  return x & y[0] ? z : w;\n+}"}]}