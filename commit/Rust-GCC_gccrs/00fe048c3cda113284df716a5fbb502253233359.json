{"sha": "00fe048c3cda113284df716a5fbb502253233359", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmZTA0OGMzY2RhMTEzMjg0ZGY3MTZhNWZiYjUwMjI1MzIzMzM1OQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-15T21:24:33Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-15T21:24:33Z"}, "message": "Initial revision\n\nFrom-SVN: r327", "tree": {"sha": "f27064f3cc5745fca657e3725aaea0ed3e30f538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f27064f3cc5745fca657e3725aaea0ed3e30f538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00fe048c3cda113284df716a5fbb502253233359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fe048c3cda113284df716a5fbb502253233359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00fe048c3cda113284df716a5fbb502253233359", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fe048c3cda113284df716a5fbb502253233359/comments", "author": null, "committer": null, "parents": [{"sha": "b3a5ad9cbd1f25648a8115f0fb62b367c65b3caa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a5ad9cbd1f25648a8115f0fb62b367c65b3caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a5ad9cbd1f25648a8115f0fb62b367c65b3caa"}], "stats": {"total": 2160, "additions": 2160, "deletions": 0}, "files": [{"sha": "feff991c059a0ff93776849b5ce93c536cd2d27c", "filename": "gcc/dbxout.c", "status": "added", "additions": 2160, "deletions": 0, "changes": 2160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00fe048c3cda113284df716a5fbb502253233359/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00fe048c3cda113284df716a5fbb502253233359/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=00fe048c3cda113284df716a5fbb502253233359", "patch": "@@ -0,0 +1,2160 @@\n+/* Output dbx-format symbol table information from GNU compiler.\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Output dbx-format symbol table data.\n+   This consists of many symbol table entries, each of them\n+   a .stabs assembler pseudo-op with four operands:\n+   a \"name\" which is really a description of one symbol and its type,\n+   a \"code\", which is a symbol defined in stab.h whose name starts with N_,\n+   an unused operand always 0,\n+   and a \"value\" which is an address or an offset.\n+   The name is enclosed in doublequote characters.\n+\n+   Each function, variable, typedef, and structure tag\n+   has a symbol table entry to define it.\n+   The beginning and end of each level of name scoping within\n+   a function are also marked by special symbol table entries.\n+\n+   The \"name\" consists of the symbol name, a colon, a kind-of-symbol letter,\n+   and a data type number.  The data type number may be followed by\n+   \"=\" and a type definition; normally this will happen the first time\n+   the type number is mentioned.  The type definition may refer to\n+   other types by number, and those type numbers may be followed\n+   by \"=\" and nested definitions.\n+\n+   This can make the \"name\" quite long.\n+   When a name is more than 80 characters, we split the .stabs pseudo-op\n+   into two .stabs pseudo-ops, both sharing the same \"code\" and \"value\".\n+   The first one is marked as continued with a double-backslash at the\n+   end of its \"name\".\n+\n+   The kind-of-symbol letter distinguished function names from global\n+   variables from file-scope variables from parameters from auto\n+   variables in memory from typedef names from register variables.\n+   See `dbxout_symbol'.\n+\n+   The \"code\" is mostly redundant with the kind-of-symbol letter\n+   that goes in the \"name\", but not entirely: for symbols located\n+   in static storage, the \"code\" says which segment the address is in,\n+   which controls how it is relocated.\n+\n+   The \"value\" for a symbol in static storage\n+   is the core address of the symbol (actually, the assembler\n+   label for the symbol).  For a symbol located in a stack slot\n+   it is the stack offset; for one in a register, the register number.\n+   For a typedef symbol, it is zero.\n+\n+   If DEBUG_SYMS_TEXT is defined, all debugging symbols must be\n+   output while in the text section.\n+\n+   For more on data type definitions, see `dbxout_type'.  */\n+\n+/* Include these first, because they may define MIN and MAX.  */\n+#include <stdio.h>\n+#include <sys/param.h>\n+#include <errno.h>\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"reload.h\"\n+\n+#ifndef errno\n+extern int errno;\n+#endif\n+\n+#ifndef ASM_STABS_OP\n+#define ASM_STABS_OP \".stabs\"\n+#endif\n+\n+#ifndef ASM_STABN_OP\n+#define ASM_STABN_OP \".stabn\"\n+#endif\n+\n+/* Nonzero means if the type has methods, only output debugging\n+   information if methods are actually written to the asm file.  */\n+\n+static int flag_minimal_debug = 1;\n+\n+/* Nonzero if we have actually used any of the GDB extensions\n+   to the debugging format.  The idea is that we use them for the\n+   first time only if there's a strong reason, but once we have done that,\n+   we use them whenever convenient.  */\n+\n+static int have_used_extensions = 0;\n+\n+/* Virtually every UN*X system now in common use (except for pre-4.3-tahoe\n+   BSD systems) now provides getcwd as called for by POSIX.  Allow for\n+   the few exceptions to the general rule here.  */\n+\n+#if !(defined (USG) || defined (VMS))\n+extern char *getwd ();\n+#define getcwd(buf,len) getwd(buf)\n+#define GUESSPATHLEN (MAXPATHLEN + 1)\n+#else /* (defined (USG) || defined (VMS)) */\n+extern char *getcwd ();\n+/* We actually use this as a starting point, not a limit.  */\n+#define GUESSPATHLEN 100\n+#endif /* (defined (USG) || defined (VMS)) */\n+\n+/* Typical USG systems don't have stab.h, and they also have\n+   no use for DBX-format debugging info.  */\n+\n+#ifdef DBX_DEBUGGING_INFO\n+\n+#ifdef DEBUG_SYMS_TEXT\n+#define FORCE_TEXT text_section ();\n+#else\n+#define FORCE_TEXT\n+#endif\n+\n+#ifdef USG\n+#include \"gstab.h\"  /* If doing DBX on sysV, use our own stab.h.  */\n+#else\n+#include <stab.h>  /* On BSD, use the system's stab.h.  */\n+\n+/* This is a GNU extension we need to reference in this file.  */\n+#ifndef N_CATCH\n+#define N_CATCH 0x54\n+#endif\n+#endif /* not USG */\n+\n+#ifdef __GNU_STAB__\n+#define STAB_CODE_TYPE enum __stab_debug_code\n+#else\n+#define STAB_CODE_TYPE int\n+#endif\n+\n+/* 1 if PARM is passed to this function in memory.  */\n+\n+#define PARM_PASSED_IN_MEMORY(PARM) \\\n+ (GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)\n+\n+/* A C expression for the integer offset value of an automatic variable\n+   (N_LSYM) having address X (an RTX).  */\n+#ifndef DEBUGGER_AUTO_OFFSET\n+#define DEBUGGER_AUTO_OFFSET(X) \\\n+  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n+#endif\n+\n+/* A C expression for the integer offset value of an argument (N_PSYM)\n+   having address X (an RTX).  The nominal offset is OFFSET.  */\n+#ifndef DEBUGGER_ARG_OFFSET\n+#define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n+#endif\n+\n+/* Stream for writing to assembler file.  */\n+\n+static FILE *asmfile;\n+\n+/* Last source file name mentioned in a NOTE insn.  */\n+\n+static char *lastfile;\n+\n+/* Current working directory.  */\n+\n+static char *cwd;\n+static enum {not_gotten, gotten, error_getting} cwd_status = not_gotten;\n+\n+enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};\n+\n+/* Vector recording the status of describing C data types.\n+   When we first notice a data type (a tree node),\n+   we assign it a number using next_type_number.\n+   That is its index in this vector.\n+   The vector element says whether we have yet output\n+   the definition of the type.  TYPE_XREF says we have\n+   output it as a cross-reference only.  */\n+\n+enum typestatus *typevec;\n+\n+/* Number of elements of space allocated in `typevec'.  */\n+\n+static int typevec_len;\n+\n+/* In dbx output, each type gets a unique number.\n+   This is the number for the next type output.\n+   The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */\n+\n+static int next_type_number;\n+\n+/* In dbx output, we must assign symbol-blocks id numbers\n+   in the order in which their beginnings are encountered.\n+   We output debugging info that refers to the beginning and\n+   end of the ranges of code in each block\n+   with assembler labels LBBn and LBEn, where n is the block number.\n+   The labels are generated in final, which assigns numbers to the\n+   blocks in the same way.  */\n+\n+static int next_block_number;\n+\n+/* These variables are for dbxout_symbol to communicate to\n+   dbxout_finish_symbol.\n+   current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.\n+   current_sym_value and current_sym_addr are two ways to address the\n+   value to store in the symtab entry.\n+   current_sym_addr if nonzero represents the value as an rtx.\n+   If that is zero, current_sym_value is used.  This is used\n+   when the value is an offset (such as for auto variables,\n+   register variables and parms).  */\n+\n+static STAB_CODE_TYPE current_sym_code;\n+static int current_sym_value;\n+static rtx current_sym_addr;\n+\n+/* Number of chars of symbol-description generated so far for the\n+   current symbol.  Used by CHARS and CONTIN.  */\n+\n+static int current_sym_nchars;\n+\n+/* Report having output N chars of the current symbol-description.  */\n+\n+#define CHARS(N) (current_sym_nchars += (N))\n+\n+/* Break the current symbol-description, generating a continuation,\n+   if it has become long.  */\n+\n+#ifndef DBX_CONTIN_LENGTH\n+#define DBX_CONTIN_LENGTH 80\n+#endif\n+\n+#if DBX_CONTIN_LENGTH > 0\n+#define CONTIN  \\\n+  do {if (current_sym_nchars > DBX_CONTIN_LENGTH) dbxout_continue ();} while (0)\n+#else\n+#define CONTIN\n+#endif\n+\n+void dbxout_types ();\n+void dbxout_args ();\n+void dbxout_symbol ();\n+static void dbxout_type_name ();\n+static void dbxout_type ();\n+static void dbxout_typedefs ();\n+static void dbxout_prepare_symbol ();\n+static void dbxout_finish_symbol ();\n+static void dbxout_continue ();\n+static void print_int_cst_octal ();\n+static void print_octal ();\n+\f\n+#if 0 /* Not clear we will actually need this.  */\n+\n+/* Return the absolutized filename for the given relative\n+   filename.  Note that if that filename is already absolute, it may\n+   still be returned in a modified form because this routine also\n+   eliminates redundant slashes and single dots and eliminates double\n+   dots to get a shortest possible filename from the given input\n+   filename.  The absolutization of relative filenames is made by\n+   assuming that the given filename is to be taken as relative to\n+   the first argument (cwd) or to the current directory if cwd is\n+   NULL.  */\n+\n+static char *\n+abspath (rel_filename)\n+     char *rel_filename;\n+{\n+  /* Setup the current working directory as needed.  */\n+  char *abs_buffer\n+    = (char *) alloca (strlen (cwd) + strlen (rel_filename) + 1);\n+  char *endp = abs_buffer;\n+  char *outp, *inp;\n+  char *value;\n+\n+  /* Copy the  filename (possibly preceeded by the current working\n+     directory name) into the absolutization buffer.  */\n+\n+  {\n+    char *src_p;\n+\n+    if (rel_filename[0] != '/')\n+      {\n+        src_p = cwd;\n+        while (*endp++ = *src_p++)\n+          continue;\n+        *(endp-1) = '/';        \t\t/* overwrite null */\n+      }\n+    src_p = rel_filename;\n+    while (*endp++ = *src_p++)\n+      continue;\n+    if (endp[-1] == '/')\n+      *endp = '\\0';\n+  }\n+\n+  /* Now make a copy of abs_buffer into abs_buffer, shortening the\n+     filename (by taking out slashes and dots) as we go.  */\n+\n+  outp = inp = abs_buffer;\n+  *outp++ = *inp++;        \t/* copy first slash */\n+  for (;;)\n+    {\n+      if (!inp[0])\n+        break;\n+      else if (inp[0] == '/' && outp[-1] == '/')\n+        {\n+          inp++;\n+          continue;\n+        }\n+      else if (inp[0] == '.' && outp[-1] == '/')\n+        {\n+          if (!inp[1])\n+                  break;\n+          else if (inp[1] == '/')\n+            {\n+                    inp += 2;\n+                    continue;\n+            }\n+          else if ((inp[1] == '.') && (inp[2] == 0 || inp[2] == '/'))\n+            {\n+                    inp += (inp[2] == '/') ? 3 : 2;\n+                    outp -= 2;\n+                    while (outp >= abs_buffer && *outp != '/')\n+              \toutp--;\n+                    if (outp < abs_buffer)\n+                {\n+                  /* Catch cases like /.. where we try to backup to a\n+                     point above the absolute root of the logical file\n+                     system.  */\n+\n+              \t  fprintf (stderr, \"%s: invalid file name: %s\\n\",\n+\t\t\t   pname, rel_filename);\n+              \t  exit (1);\n+              \t}\n+                    *++outp = '\\0';\n+                    continue;\n+            }\n+        }\n+      *outp++ = *inp++;\n+    }\n+\n+  /* On exit, make sure that there is a trailing null, and make sure that\n+     the last character of the returned string is *not* a slash.  */\n+\n+  *outp = '\\0';\n+  if (outp[-1] == '/')\n+    *--outp  = '\\0';\n+\n+  /* Make a copy (in the heap) of the stuff left in the absolutization\n+     buffer and return a pointer to the copy.  */\n+\n+  value = (char *) oballoc (strlen (abs_buffer) + 1);\n+  strcpy (value, abs_buffer);\n+  return value;\n+}\n+#endif /* 0 */\n+\f\n+/* At the beginning of compilation, start writing the symbol table.\n+   Initialize `typevec' and output the standard data types of C.  */\n+\n+void\n+dbxout_init (asm_file, input_file_name, syms)\n+     FILE *asm_file;\n+     char *input_file_name;\n+     tree syms;\n+{\n+  char ltext_label_name[100];\n+\n+  asmfile = asm_file;\n+\n+  typevec_len = 100;\n+  typevec = (enum typestatus *) xmalloc (typevec_len * sizeof typevec[0]);\n+  bzero (typevec, typevec_len * sizeof typevec[0]);\n+\n+  /* Convert Ltext into the appropriate format for local labels in case\n+     the system doesn't insert underscores in front of user generated\n+     labels.  */\n+  ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n+\n+  /* Put the current working directory in an N_SO symbol.  */\n+  {\n+    int size;\n+\n+    if (cwd_status == not_gotten)\n+      {\n+\tchar *value;\n+\n+\t/* Read the working directory, avoiding arbitrary limit.  */\n+\tsize = GUESSPATHLEN;\n+\twhile (1)\n+\t  {\n+\t    cwd = (char *) xmalloc (size);\n+\t    value = getcwd (cwd, size);\n+\t    if (value != 0 || errno != ERANGE)\n+\t      break;\n+\t    free (cwd);\n+\t    size *= 2;\n+\t  }\n+\n+\tif (value != 0)\n+\t  cwd_status = gotten;\n+\telse\n+\t  cwd_status = error_getting;\n+      }\n+\n+    if (cwd_status == gotten)\n+      {\n+#ifdef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n+\tDBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asmfile, cwd);\n+#else /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n+\tfprintf (asmfile, \"%s \\\"%s/\\\",%d,0,0,%s\\n\", ASM_STABS_OP,\n+\t\t cwd, N_SO, &ltext_label_name[1]);\n+#endif /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n+      }\n+  }\n+\n+#ifdef DBX_OUTPUT_MAIN_SOURCE_FILENAME\n+  /* This should NOT be DBX_OUTPUT_SOURCE_FILENAME. That\n+     would give us an N_SOL, and we want an N_SO.  */\n+  DBX_OUTPUT_MAIN_SOURCE_FILENAME (asmfile, input_file_name);\n+#else /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n+  /* We include outputting `Ltext:' here,\n+     because that gives you a way to override it.  */\n+  /* Used to put `Ltext:' before the reference, but that loses on sun 4.  */\n+  fprintf (asmfile, \"%s \\\"%s\\\",%d,0,0,%s\\n\", ASM_STABS_OP, input_file_name,\n+\t   N_SO, &ltext_label_name[1]);\n+  text_section ();\n+  ASM_OUTPUT_INTERNAL_LABEL (asmfile, \"Ltext\", 0);\n+#endif /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n+\n+  lastfile = input_file_name;\n+\n+  next_type_number = 1;\n+  next_block_number = 2;\n+\n+  /* Make sure that types `int' and `char' have numbers 1 and 2.\n+     Definitions of other integer types will refer to those numbers.\n+     (Actually it should no longer matter what their numbers are.\n+     Also, if any types with tags have been defined, dbxout_symbol\n+     will output them first, so the numbers won't be 1 and 2.  That\n+     happens in C++.  So it's a good thing it should no longer matter).  */\n+\n+#ifdef DBX_OUTPUT_STANDARD_TYPES\n+  DBX_OUTPUT_STANDARD_TYPES (syms);\n+#else\n+  dbxout_symbol (TYPE_NAME (integer_type_node), 0);\n+  dbxout_symbol (TYPE_NAME (char_type_node), 0);\n+#endif\n+\n+  /* Get all permanent types that have typedef names,\n+     and output them all, except for those already output.  */\n+\n+  dbxout_typedefs (syms);\n+}\n+\n+/* Output any typedef names for types described by TYPE_DECLs in SYMS,\n+   in the reverse order from that which is found in SYMS.  */\n+\n+static void\n+dbxout_typedefs (syms)\n+     tree syms;\n+{\n+  if (syms)\n+    {\n+      dbxout_typedefs (TREE_CHAIN (syms));\n+      if (TREE_CODE (syms) == TYPE_DECL)\n+\t{\n+\t  tree type = TREE_TYPE (syms);\n+\t  if (TYPE_NAME (type)\n+\t      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t      && ! TREE_ASM_WRITTEN (TYPE_NAME (type)))\n+\t    dbxout_symbol (TYPE_NAME (type), 0);\n+\t}\n+    }\n+}\n+\n+/* Output debugging info to FILE to switch to sourcefile FILENAME.  */\n+\n+void\n+dbxout_source_file (file, filename)\n+     FILE *file;\n+     char *filename;\n+{\n+  char ltext_label_name[100];\n+\n+  if (filename && (lastfile == 0 || strcmp (filename, lastfile)))\n+    {\n+#ifdef DBX_OUTPUT_SOURCE_FILENAME\n+      DBX_OUTPUT_SOURCE_FILENAME (file, filename);\n+#else\n+      ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n+      fprintf (file, \"%s \\\"%s\\\",%d,0,0,%s\\n\", ASM_STABS_OP,\n+\t       filename, N_SOL, &ltext_label_name[1]);\n+#endif\n+      lastfile = filename;\n+    }\n+}\n+\n+/* At the end of compilation, finish writing the symbol table.\n+   Unless you define DBX_OUTPUT_MAIN_SOURCE_FILE_END, the default is\n+   to do nothing. */\n+\n+void\n+dbxout_finish (file, filename)\n+     FILE *file;\n+     char *filename;\n+{\n+#ifdef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n+  DBX_OUTPUT_MAIN_SOURCE_FILE_END (file, filename);\n+#endif /* DBX_OUTPUT_MAIN_SOURCE_FILE_END */\n+}\n+\n+/* Continue a symbol-description that gets too big.\n+   End one symbol table entry with a double-backslash\n+   and start a new one, eventually producing something like\n+   .stabs \"start......\\\\\",code,0,value\n+   .stabs \"...rest\",code,0,value   */\n+\n+static void\n+dbxout_continue ()\n+{\n+#ifdef DBX_CONTIN_CHAR\n+  fprintf (asmfile, \"%c\", DBX_CONTIN_CHAR);\n+#else\n+  fprintf (asmfile, \"\\\\\\\\\");\n+#endif\n+  dbxout_finish_symbol (0);\n+  fprintf (asmfile, \"%s \\\"\", ASM_STABS_OP);\n+  current_sym_nchars = 0;\n+}\n+\f\n+/* Subtroutine of `dbxout_type'.  Output the type fields of TYPE.\n+   This must be a separate function because anonymous unions require\n+   recursive calls.  */\n+\n+static void\n+dbxout_type_fields (type)\n+     tree type;\n+{\n+  tree tem;\n+  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+    {\n+      /* Output the name, type, position (in bits), size (in bits)\n+\t of each field.  */\n+      if (DECL_NAME (tem) == NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE)\n+\tdbxout_type_fields (TREE_TYPE (tem));\n+      /* Omit here local type decls until we know how to support them.  */\n+      else if (TREE_CODE (tem) == TYPE_DECL)\n+\tcontinue;\n+      /* Omit here the nameless fields that are used to skip bits.  */\n+      else if (DECL_NAME (tem) != 0 && TREE_CODE (tem) != CONST_DECL)\n+\t{\n+\t  /* Continue the line if necessary,\n+\t     but not before the first field.  */\n+\t  if (tem != TYPE_FIELDS (type))\n+\t    CONTIN;\n+\n+\t  if (use_gdb_dbx_extensions\n+\t      && flag_minimal_debug\n+\t      && TREE_CODE (tem) == FIELD_DECL\n+\t      && DECL_VIRTUAL_P (tem)\n+\t      && DECL_ASSEMBLER_NAME (tem))\n+\t    {\n+\t      have_used_extensions = 1;\n+\t      CHARS (3 + IDENTIFIER_LENGTH (DECL_NAME (TYPE_NAME (DECL_FCONTEXT (tem)))));\n+\t      fputs (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (tem)), asmfile);\n+\t      dbxout_type (DECL_FCONTEXT (tem), 0);\n+\t      fprintf (asmfile, \":\");\n+\t      dbxout_type (TREE_TYPE (tem), 0);\n+\t      fprintf (asmfile, \",%d;\",\n+\t\t       TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)));\n+\t      continue;\n+\t    }\n+\n+\t  fprintf (asmfile, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (tem)));\n+\t  CHARS (2 + IDENTIFIER_LENGTH (DECL_NAME (tem)));\n+\n+\t  if (use_gdb_dbx_extensions\n+\t      && (TREE_PRIVATE (tem) || TREE_PROTECTED (tem)\n+\t\t  || TREE_CODE (tem) != FIELD_DECL))\n+\t    {\n+\t      have_used_extensions = 1;\n+\t      putc ('/', asmfile);\n+\t      putc ((TREE_PRIVATE (tem) ? '0'\n+\t\t     : TREE_PROTECTED (tem) ? '1' : '2'),\n+\t\t    asmfile);\n+\t      CHARS (2);\n+\t    }\n+\n+\t  dbxout_type ((TREE_CODE (tem) == FIELD_DECL\n+\t\t\t&& DECL_BIT_FIELD_TYPE (tem))\n+\t\t       ? DECL_BIT_FIELD_TYPE (tem)\n+\t\t       : TREE_TYPE (tem), 0);\n+\n+\t  if (TREE_CODE (tem) == VAR_DECL)\n+\t    {\n+\t      if (TREE_STATIC (tem) && use_gdb_dbx_extensions)\n+\t\t{\n+\t\t  char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (tem));\n+\t\t  have_used_extensions = 1;\n+\n+#if 0 /* ??? Comment below makes it clear this is unacceptable.  */\n+\t\t  /* Adding 1 here only works on systems\n+\t\t     which flush an initial underscore from\n+\t\t     the .stabs entry.  This loses for static names\n+\t\t     which have an initial leading '_' on systems which\n+\t\t     don't use leading underscores.  */\n+\t\t  if (name[0] == '_')\n+\t\t    name += 1;\n+#endif\n+\n+\t\t  fprintf (asmfile, \":%s;\", name);\n+\t\t  CHARS (strlen (name));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* If TEM is non-static, GDB won't understand it.  */\n+\t\t  fprintf (asmfile, \",0,0;\");\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (DECL_FIELD_BITPOS (tem)) == INTEGER_CST)\n+\t    {\n+\t      fprintf (asmfile, \",%d,%d;\",\n+\t\t       TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)),\n+\t\t       TREE_INT_CST_LOW (DECL_SIZE (tem)));\n+\t    }\n+\t  else\n+\t    /* This has yet to be implemented.  */\n+\t    abort ();\n+\t  CHARS (23);\n+\t}\n+    }\n+}\n+\f\n+/* Subtroutine of `dbxout_type_methods'.  Output debug info about the\n+   method described DECL.  DEBUG_NAME is an encoding of the method's\n+   type signature.  ??? We may be able to do without DEBUG_NAME altogether\n+   now.  */\n+\n+static void\n+dbxout_type_method_1 (decl, debug_name)\n+     tree decl;\n+     char *debug_name;\n+{\n+  tree firstarg = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)));\n+  char c1 = 'A', c2;\n+\n+  if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n+    c2 = '?';\n+  else /* it's a METHOD_TYPE.  */\n+    {\n+      /* A for normal functions.\n+\t B for `const' member functions.\n+\t C for `volatile' member functions.\n+\t D for `const volatile' member functions.  */\n+      if (TYPE_READONLY (TREE_TYPE (firstarg)))\n+\tc1 += 1;\n+      if (TYPE_VOLATILE (TREE_TYPE (firstarg)))\n+\tc1 += 2;\n+\n+      if (DECL_VINDEX (decl))\n+\tc2 = '*';\n+      else\n+\tc2 = '.';\n+    }\n+\n+  fprintf (asmfile, \":%s;%c%c%c\", debug_name,\n+\t   TREE_PRIVATE (decl) ? '0' : TREE_PROTECTED (decl) ? '1' : '2', c1, c2);\n+  CHARS (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl)) + 6\n+\t - (debug_name - IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))));\n+  if (DECL_VINDEX (decl))\n+    {\n+      fprintf (asmfile, \"%d;\",\n+\t       TREE_INT_CST_LOW (DECL_VINDEX (decl)));\n+      dbxout_type (DECL_CONTEXT (decl), 0);\n+      fprintf (asmfile, \";\");\n+      CHARS (8);\n+    }\n+}\n+\f\n+/* Subroutine of `dbxout_type'.  Output debug info about the methods defined\n+   in TYPE.  */\n+\n+static void\n+dbxout_type_methods (type)\n+     register tree type;\n+{\n+  /* C++: put out the method names and their parameter lists */\n+  tree ctor_name;\n+  tree methods = TYPE_METHODS (type);\n+  register tree fndecl;\n+  register tree last;\n+  register int type_identifier_length;\n+\n+  if (methods == NULL_TREE)\n+    return;\n+\n+  ctor_name = DECL_NAME (TYPE_NAME (type));\n+  type_identifier_length = IDENTIFIER_LENGTH (ctor_name);\n+  if (TREE_CODE (methods) == FUNCTION_DECL)\n+    fndecl = methods;\n+  else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n+    fndecl = TREE_VEC_ELT (methods, 0);\n+  else fndecl = TREE_VEC_ELT (methods, 1);\n+\n+  if (TREE_CODE (type) == RECORD_TYPE && DECL_NAME (fndecl) == ctor_name)\n+    {\n+      tree ctor = fndecl;\n+      tree dtor;\n+\n+      /* Destructors lie in a special place.\n+         n.b.  TYPE_HAS_DESTRUCTOR == TYPE_LANG_FLAG_2 */\n+      if (TYPE_LANG_FLAG_2 (type))\n+\t{\n+\t  dtor = fndecl;\n+\t  fndecl = ctor = TREE_CHAIN (dtor);\n+\t}\n+      else\n+\tdtor = NULL_TREE;\n+\n+      CHARS (2);\n+\n+      if (ctor)\n+\t{\n+\t  int need_prefix = 1;\n+\n+\t  while (ctor)\n+\t    {\n+\t      /* Output the name of the field (after overloading), as\n+\t\t well as the name of the field before overloading, along\n+\t\t with its parameter list.  */\n+\t      char *debug_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (ctor));\n+\t      int old_minimal_debug = flag_minimal_debug;\n+\n+\t      CONTIN;\n+\n+\t      if (DECL_NAME (ctor) == ctor_name && ! DECL_IGNORED_P (ctor))\n+\t\t{\n+\t\t  if (need_prefix)\n+\t\t    {\n+\t\t      fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (DECL_NAME (ctor)));\n+\t\t      CHARS (IDENTIFIER_LENGTH (DECL_NAME (ctor)) + 3);\n+\t\t      need_prefix = 0;\n+\t\t    }\n+\n+\t\t  if (ctor == dtor)\n+\t\t    /* Always output destructors with full information.  */\n+\t\t    flag_minimal_debug = 0;\n+\n+\t\t  dbxout_type (TREE_TYPE (ctor), 0);\n+\t\t  flag_minimal_debug = old_minimal_debug;\n+\n+\t\t  if (flag_minimal_debug && ctor != dtor)\n+\t\t    {\n+\t\t      /* Cut down on debugging information by not outputting\n+\t\t\t the parts of the name we can just as easily\n+\t\t\t have the debugger figure out.  */\n+\n+\t\t      /* Get past '__'.  */\n+\t\t      debug_name += 2;\n+\t\t      /* Get past const and volatile qualifiers.  */\n+\t\t      while (*debug_name == 'C' || *debug_name == 'V')\n+\t\t\tdebug_name++;\n+\t\t      /* Get past numeric type length prefix.  */\n+\t\t      while (*debug_name >= '0' && *debug_name <= '9')\n+\t\t\tdebug_name++;\n+\t\t      /* Get past type of `this'.  */\n+\t\t      debug_name += type_identifier_length;\n+\t\t    }\n+\t\t  dbxout_type_method_1 (ctor, debug_name);\n+\t\t}\n+\n+\t      if (ctor == dtor)\n+\t\tbreak;\n+\n+\t      ctor = TREE_CHAIN (ctor);\n+\t      if (ctor == NULL_TREE || DECL_NAME (ctor) != ctor_name)\n+\t\t{\n+\t\t  fndecl = ctor;\n+\t\t  ctor = dtor;\n+\t\t}\n+\t    }\n+\t  if (! need_prefix)\n+\t    putc (';', asmfile);\n+\t}\n+    }\n+\n+  while (fndecl)\n+    {\n+      tree name = DECL_NAME (fndecl);\n+      fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (name));\n+      CHARS (IDENTIFIER_LENGTH (name) + 3);\n+\n+      for (last = NULL_TREE;\n+\t   fndecl && (last == NULL_TREE || DECL_NAME (fndecl) == DECL_NAME (last));\n+\t   fndecl = TREE_CHAIN (fndecl))\n+\t/* Output the name of the field (after overloading), as\n+\t   well as the name of the field before overloading, along\n+\t   with its parameter list */\n+\t{\n+\t  char *debug_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n+\n+\t  CONTIN;\n+\n+\t  last = fndecl;\n+\t  dbxout_type (TREE_TYPE (fndecl), 0);\n+\t  if (flag_minimal_debug)\n+\t    {\n+\t      debug_name += IDENTIFIER_LENGTH (DECL_NAME (fndecl)) + 2;\n+\t      /* Get past const and volatile qualifiers.  */\n+\t      while (*debug_name == 'C' || *debug_name == 'V')\n+\t\tdebug_name++;\n+\t      while (*debug_name >= '0' && *debug_name <= '9')\n+\t\tdebug_name++;\n+\t      debug_name += type_identifier_length;\n+\t    }\n+\t  dbxout_type_method_1 (fndecl, debug_name);\n+\t}\n+      putc (';', asmfile);\n+      CHARS (1);\n+    }\n+}\n+\f\n+/* Output a reference to a type.  If the type has not yet been\n+   described in the dbx output, output its definition now.\n+   For a type already defined, just refer to its definition\n+   using the type number.\n+\n+   If FULL is nonzero, and the type has been described only with\n+   a forward-reference, output the definition now.\n+   If FULL is zero in this case, just refer to the forward-reference\n+   using the number previously allocated.  */\n+\n+static void\n+dbxout_type (type, full)\n+     tree type;\n+     int full;\n+{\n+  register tree tem;\n+\n+  /* If there was an input error and we don't really have a type,\n+     avoid crashing and write something that is at least valid\n+     by assuming `int'.  */\n+  if (type == error_mark_node)\n+    type = integer_type_node;\n+  else\n+    {\n+      type = TYPE_MAIN_VARIANT (type);\n+      if (TYPE_NAME (type)\n+\t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t  && DECL_IGNORED_P (TYPE_NAME (type)))\n+\tfull = 0;\n+    }\n+\n+  if (TYPE_SYMTAB_ADDRESS (type) == 0)\n+    {\n+      /* Type has no dbx number assigned.  Assign next available number.  */\n+      TYPE_SYMTAB_ADDRESS (type) = next_type_number++;\n+\n+      /* Make sure type vector is long enough to record about this type.  */\n+\n+      if (next_type_number == typevec_len)\n+\t{\n+\t  typevec = (enum typestatus *) xrealloc (typevec, typevec_len * 2 * sizeof typevec[0]);\n+\t  bzero (typevec + typevec_len, typevec_len * sizeof typevec[0]);\n+\t  typevec_len *= 2;\n+\t}\n+    }\n+\n+  /* Output the number of this type, to refer to it.  */\n+  fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n+  CHARS (3);\n+\n+  /* If this type's definition has been output or is now being output,\n+     that is all.  */\n+\n+  switch (typevec[TYPE_SYMTAB_ADDRESS (type)])\n+    {\n+    case TYPE_UNSEEN:\n+      break;\n+    case TYPE_XREF:\n+      if (! full)\n+\treturn;\n+      break;\n+    case TYPE_DEFINED:\n+      return;\n+    }\n+\n+#ifdef DBX_NO_XREFS\n+  /* For systems where dbx output does not allow the `=xsNAME:' syntax,\n+     leave the type-number completely undefined rather than output\n+     a cross-reference.  */\n+  if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == ENUMERAL_TYPE)\n+\n+    if ((TYPE_NAME (type) != 0 && !full)\n+\t|| TYPE_SIZE (type) == 0)\n+      {\n+\ttypevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_XREF;\n+\treturn;\n+      }\n+#endif\n+\n+  /* Output a definition now.  */\n+\n+  fprintf (asmfile, \"=\");\n+  CHARS (1);\n+\n+  /* Mark it as defined, so that if it is self-referent\n+     we will not get into an infinite recursion of definitions.  */\n+\n+  typevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_DEFINED;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+    case LANG_TYPE:\n+      /* For a void type, just define it as itself; ie, \"5=5\".\n+\t This makes us consider it defined\n+\t without saying what it is.  The debugger will make it\n+\t a void type when the reference is seen, and nothing will\n+\t ever override that default.  */\n+      fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n+      CHARS (3);\n+      break;\n+\n+    case INTEGER_TYPE:\n+      if (type == char_type_node && ! TREE_UNSIGNED (type))\n+\t/* Output the type `char' as a subrange of itself!\n+\t   I don't understand this definition, just copied it\n+\t   from the output of pcc.\n+\t   This used to use `r2' explicitly and we used to\n+\t   take care to make sure that `char' was type number 2.  */\n+\tfprintf (asmfile, \"r%d;0;127;\", TYPE_SYMTAB_ADDRESS (type));\n+#ifdef WINNING_GDB\n+      else if (TYPE_PRECISION (type) > BITS_PER_WORD)\n+\t{\n+\t  /* This used to say `r1' and we used to take care\n+\t     to make sure that `int' was type number 1.  */\n+\t  fprintf (asmfile, \"r%d;\", TYPE_SYMTAB_ADDRESS (integer_type_node));\n+\t  print_int_cst_octal (TYPE_MIN_VALUE (type));\n+\t  fprintf (asmfile, \";\");\n+\t  print_int_cst_octal (TYPE_MAX_VALUE (type));\n+\t  fprintf (asmfile, \";\");\n+\t}\n+#endif\n+      else\n+\t/* Output other integer types as subranges of `int'.  */\n+\t/* This used to say `r1' and we used to take care\n+\t   to make sure that `int' was type number 1.  */\n+\tfprintf (asmfile, \"r%d;%d;%d;\",\n+\t\t TYPE_SYMTAB_ADDRESS (integer_type_node),\n+\t\t TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)),\n+\t\t TREE_INT_CST_LOW (TYPE_MAX_VALUE (type)));\n+      CHARS (25);\n+      break;\n+\n+    case REAL_TYPE:\n+      /* This used to say `r1' and we used to take care\n+\t to make sure that `int' was type number 1.  */\n+      fprintf (asmfile, \"r%d;%d;0;\", TYPE_SYMTAB_ADDRESS (integer_type_node),\n+\t       TREE_INT_CST_LOW (size_in_bytes (type)));\n+      CHARS (16);\n+      break;\n+\n+    case ARRAY_TYPE:\n+      /* Output \"a\" followed by a range type definition\n+\t for the index type of the array\n+\t followed by a reference to the target-type.\n+\t ar1;0;N;M for an array of type M and size N.  */\n+      /* This used to say `r1' and we used to take care\n+\t to make sure that `int' was type number 1.  */\n+      fprintf (asmfile, \"ar%d;0;%d;\", TYPE_SYMTAB_ADDRESS (integer_type_node),\n+\n+\t       (TYPE_DOMAIN (type)\n+\t\t? TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t        : -1));\n+      CHARS (17);\n+      dbxout_type (TREE_TYPE (type), 0);\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      {\n+\tint i, n_baseclasses = 0;\n+\n+\tif (TYPE_BINFO (type) != 0 && TYPE_BINFO_BASETYPES (type) != 0)\n+\t  n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type));\n+\n+\t/* Output a structure type.  */\n+\tif ((TYPE_NAME (type) != 0 && !full)\n+\t    || TYPE_SIZE (type) == 0)\n+\t  {\n+\t    /* If the type is just a cross reference, output one\n+\t       and mark the type as partially described.\n+\t       If it later becomes defined, we will output\n+\t       its real definition.\n+\t       If the type has a name, don't nest its definition within\n+\t       another type's definition; instead, output an xref\n+\t       and let the definition come when the name is defined.  */\n+\t    fprintf (asmfile, (TREE_CODE (type) == RECORD_TYPE) ? \"xs\" : \"xu\");\n+\t    CHARS (3);\n+#if 0\t\t\t\t/* This assertion is legitimately false in C++.  */\n+\t    /* We shouldn't be outputting a reference to a type before its\n+\t       definition unless the type has a tag name.\n+\t       A typedef name without a tag name should be impossible.  */\n+\t    if (TREE_CODE (TYPE_NAME (type)) != IDENTIFIER_NODE)\n+\t      abort ();\n+#endif\n+\t    dbxout_type_name (type);\n+\t    fprintf (asmfile, \":\");\n+\t    typevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_XREF;\n+\t    break;\n+\t  }\n+\ttem = size_in_bytes (type);\n+\n+\t/* The code below assumes the size is an integer constant.  */\n+\tif (TREE_CODE (tem) != INTEGER_CST)\n+\t  abort ();\n+\n+\t/* Identify record or union, and print its size.  */\n+\tfprintf (asmfile, (TREE_CODE (type) == RECORD_TYPE) ? \"s%d\" : \"u%d\",\n+\t\t TREE_INT_CST_LOW (tem));\n+\n+\tif (use_gdb_dbx_extensions)\n+\t  {\n+\t    if (n_baseclasses)\n+\t      {\n+\t\thave_used_extensions = 1;\n+\t\tfprintf (asmfile, \"!%d,\", n_baseclasses);\n+\t\tCHARS (8);\n+\t      }\n+\t  }\n+\tfor (i = 0; i < n_baseclasses; i++)\n+\t  {\n+\t    tree child = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), i);\n+\t    if (use_gdb_dbx_extensions)\n+\t      {\n+\t\thave_used_extensions = 1;\n+\t\tputc (TREE_VIA_VIRTUAL (child) ? '1'\n+\t\t      : '0',\n+\t\t      asmfile);\n+\t\tputc (TREE_VIA_PUBLIC (child) ? '2'\n+\t\t      : '0',\n+\t\t      asmfile);\n+\t\tfprintf (asmfile, \"%d,\",\n+\t\t\t TREE_INT_CST_LOW (BINFO_OFFSET (child)) * BITS_PER_UNIT);\n+\t\tCHARS (15);\n+\t\tdbxout_type (BINFO_TYPE (child), 0);\n+\t\tputc (';', asmfile);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Print out the base class information with fields\n+\t\t   which have the same names at the types they hold.  */\n+\t\tdbxout_type_name (BINFO_TYPE (child));\n+\t\tputc (':', asmfile);\n+\t\tdbxout_type (BINFO_TYPE (child), full);\n+\t\tfprintf (asmfile, \",%d,%d;\",\n+\t\t\t TREE_INT_CST_LOW (BINFO_OFFSET (child)) * BITS_PER_UNIT,\n+\t\t\t TREE_INT_CST_LOW (DECL_SIZE (TYPE_NAME (BINFO_TYPE (child)))) * BITS_PER_UNIT);\n+\t\tCHARS (20);\n+\t      }\n+\t  }\n+      }\n+\n+      CHARS (11);\n+\n+      /* Write out the field declarations.  */\n+      dbxout_type_fields (type);\n+      if (use_gdb_dbx_extensions)\n+\t{\n+\t  have_used_extensions = 1;\n+\t  dbxout_type_methods (type);\n+\t}\n+      putc (';', asmfile);\n+\n+      if (use_gdb_dbx_extensions && TREE_CODE (type) == RECORD_TYPE\n+\t  /* Avoid the ~ if we don't really need it--it confuses dbx.  */\n+\t  && TYPE_VFIELD (type))\n+\t{\n+\t  have_used_extensions = 1;\n+\n+\t  /* Tell GDB+ that it may keep reading.  */\n+\t  putc ('~', asmfile);\n+\n+\t  /* We need to write out info about what field this class\n+\t     uses as its \"main\" vtable pointer field, because if this\n+\t     field is inherited from a base class, GDB cannot necessarily\n+\t     figure out which field it's using in time.  */\n+\t  if (TYPE_VFIELD (type))\n+\t    {\n+\t      putc ('%', asmfile);\n+\t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n+\t    }\n+\t  putc (';', asmfile);\n+\t  CHARS (3);\n+\t}\n+      break;\n+\n+    case ENUMERAL_TYPE:\n+      if ((TYPE_NAME (type) != 0 && !full\n+\t   && (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t       && ! DECL_IGNORED_P (TYPE_NAME (type))))\n+\t  || TYPE_SIZE (type) == 0)\n+\t{\n+\t  fprintf (asmfile, \"xe\");\n+\t  CHARS (3);\n+\t  dbxout_type_name (type);\n+\t  typevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_XREF;\n+\t  fprintf (asmfile, \":\");\n+\t  return;\n+\t}\n+      putc ('e', asmfile);\n+      CHARS (1);\n+      for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n+\t{\n+\t  fprintf (asmfile, \"%s:%d,\", IDENTIFIER_POINTER (TREE_PURPOSE (tem)),\n+\t\t   TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+\t  CHARS (11 + IDENTIFIER_LENGTH (TREE_PURPOSE (tem)));\n+\t  if (TREE_CHAIN (tem) != 0)\n+\t    CONTIN;\n+\t}\n+      putc (';', asmfile);\n+      CHARS (1);\n+      break;\n+\n+    case POINTER_TYPE:\n+      putc ('*', asmfile);\n+      CHARS (1);\n+      dbxout_type (TREE_TYPE (type), 0);\n+      break;\n+\n+    case METHOD_TYPE:\n+      if (use_gdb_dbx_extensions)\n+\t{\n+\t  have_used_extensions = 1;\n+\t  putc ('#', asmfile);\n+\t  CHARS (1);\n+\t  if (flag_minimal_debug)\n+\t    {\n+\t      putc ('#', asmfile);\n+\t      dbxout_type (TREE_TYPE (type), 0);\n+\t      putc (';', asmfile);\n+\t      CHARS (1);\n+\t    }\n+\t  else\n+\t    {\n+\t      dbxout_type (TYPE_METHOD_BASETYPE (type), 0);\n+\t      putc (',', asmfile);\n+\t      CHARS (1);\n+\t      dbxout_type (TREE_TYPE (type), 0);\n+\t      dbxout_args (TYPE_ARG_TYPES (type));\n+\t      putc (';', asmfile);\n+\t      CHARS (1);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Treat it as a function type.  */\n+\t  dbxout_type (TREE_TYPE (type), 0);\n+\t}\n+      break;\n+\n+    case OFFSET_TYPE:\n+      if (use_gdb_dbx_extensions)\n+\t{\n+\t  have_used_extensions = 1;\n+\t  putc ('@', asmfile);\n+\t  CHARS (1);\n+\t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);\n+\t  putc (',', asmfile);\n+\t  CHARS (1);\n+\t  dbxout_type (TREE_TYPE (type), 0);\n+\t}\n+      else\n+\t{\n+\t  /* Should print as an int, because it is really\n+\t     just an offset.  */\n+\t  dbxout_type (integer_type_node, 0);\n+\t}\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      if (use_gdb_dbx_extensions)\n+\thave_used_extensions = 1;\n+      putc (use_gdb_dbx_extensions ? '&' : '*', asmfile);\n+      CHARS (1);\n+      dbxout_type (TREE_TYPE (type), 0);\n+      break;\n+\n+    case FUNCTION_TYPE:\n+      putc ('f', asmfile);\n+      CHARS (1);\n+      dbxout_type (TREE_TYPE (type), 0);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Print the value of integer constant C, in octal,\n+   handling double precision.  */\n+\n+static void\n+print_int_cst_octal (c)\n+     tree c;\n+{\n+  unsigned int high = TREE_INT_CST_HIGH (c);\n+  unsigned int low = TREE_INT_CST_LOW (c);\n+  int excess = (3 - (HOST_BITS_PER_INT % 3));\n+\n+  fprintf (asmfile, \"0\");\n+\n+  if (excess == 3)\n+    {\n+      print_octal (high, HOST_BITS_PER_INT / 3);\n+      print_octal (low, HOST_BITS_PER_INT / 3);\n+    }\n+  else\n+    {\n+      unsigned int beg = high >> excess;\n+      unsigned int middle\n+\t= ((high & ((1 << excess) - 1)) << (3 - excess)\n+\t   | (low >> (HOST_BITS_PER_INT / 3 * 3)));\n+      unsigned int end = low & ((1 << (HOST_BITS_PER_INT / 3 * 3)) - 1);\n+      fprintf (asmfile, \"%o%01o\", beg, middle);\n+      print_octal (end, HOST_BITS_PER_INT / 3);\n+    }\n+}\n+\n+static void\n+print_octal (value, digits)\n+     unsigned int value;\n+     int digits;\n+{\n+  int i;\n+\n+  for (i = digits - 1; i >= 0; i--)\n+    fprintf (asmfile, \"%01o\", ((value >> (3 * i)) & 7));\n+}\n+\n+/* Output the name of type TYPE, with no punctuation.\n+   Such names can be set up either by typedef declarations\n+   or by struct, enum and union tags.  */\n+\n+static void\n+dbxout_type_name (type)\n+     register tree type;\n+{\n+  tree t;\n+  if (TYPE_NAME (type) == 0)\n+    abort ();\n+  if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n+    {\n+      t = TYPE_NAME (type);\n+    }\n+  else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+    {\n+      t = DECL_NAME (TYPE_NAME (type));\n+    }\n+  else\n+    abort ();\n+\n+  fprintf (asmfile, \"%s\", IDENTIFIER_POINTER (t));\n+  CHARS (IDENTIFIER_LENGTH (t));\n+}\n+\f\n+/* Output a .stabs for the symbol defined by DECL,\n+   which must be a ..._DECL node in the normal namespace.\n+   It may be a CONST_DECL, a FUNCTION_DECL, a PARM_DECL or a VAR_DECL.\n+   LOCAL is nonzero if the scope is less than the entire file.  */\n+\n+void\n+dbxout_symbol (decl, local)\n+     tree decl;\n+     int local;\n+{\n+  int letter = 0;\n+  tree type = TREE_TYPE (decl);\n+  tree context = NULL_TREE;\n+  int regno = -1;\n+\n+  /* Cast avoids warning in old compilers.  */\n+  current_sym_code = (STAB_CODE_TYPE) 0;\n+  current_sym_value = 0;\n+  current_sym_addr = 0;\n+\n+  /* Ignore nameless syms, but don't ignore type tags.  */\n+\n+  if ((DECL_NAME (decl) == 0 && TREE_CODE (decl) != TYPE_DECL)\n+      || DECL_IGNORED_P (decl))\n+    return;\n+\n+  dbxout_prepare_symbol (decl);\n+\n+  /* The output will always start with the symbol name,\n+     so always count that in the length-output-so-far.  */\n+\n+  if (DECL_NAME (decl) != 0)\n+    current_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (decl));\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    case CONST_DECL:\n+      /* Enum values are defined by defining the enum type.  */\n+      break;\n+\n+    case FUNCTION_DECL:\n+      if (DECL_RTL (decl) == 0)\n+\treturn;\n+      if (TREE_EXTERNAL (decl))\n+\tbreak;\n+      /* Don't mention a nested function under its parent.  */\n+      context = decl_function_context (decl);\n+      if (context == current_function_decl)\n+\tbreak;\n+      if (GET_CODE (DECL_RTL (decl)) != MEM\n+\t  || GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n+\tbreak;\n+      FORCE_TEXT;\n+\n+      fprintf (asmfile, \"%s \\\"%s:%c\", ASM_STABS_OP,\n+\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t       TREE_PUBLIC (decl) ? 'F' : 'f');\n+\n+      current_sym_code = N_FUN;\n+      current_sym_addr = XEXP (DECL_RTL (decl), 0);\n+\n+      if (TREE_TYPE (type))\n+\tdbxout_type (TREE_TYPE (type), 0);\n+      else\n+\tdbxout_type (void_type_node, 0);\n+\n+      /* For a nested function, when that function is compiled,\n+\t mention the containing function name\n+\t as well as (since dbx wants it) our own assembler-name.  */\n+      if (context != 0)\n+\tfprintf (asmfile, \",%s,%s\",\n+\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t\t IDENTIFIER_POINTER (DECL_NAME (context)));\n+\n+      dbxout_finish_symbol (decl);\n+      break;\n+\n+    case TYPE_DECL:\n+#if 0\n+      /* This seems all wrong.  Outputting most kinds of types gives no name\n+\t at all.  A true definition gives no name; a cross-ref for a\n+\t structure can give the tag name, but not a type name.\n+\t It seems that no typedef name is defined by outputting a type.  */\n+\n+      /* If this typedef name was defined by outputting the type,\n+\t don't duplicate it.  */\n+      if (typevec[TYPE_SYMTAB_ADDRESS (type)] == TYPE_DEFINED\n+\t  && TYPE_NAME (TREE_TYPE (decl)) == decl)\n+\treturn;\n+#endif\n+      /* Don't output the same typedef twice.\n+         And don't output what language-specific stuff doesn't want output.  */\n+      if (TREE_ASM_WRITTEN (decl) || DECL_IGNORED_P (decl))\n+\treturn;\n+\n+      FORCE_TEXT;\n+\n+      if (DECL_NAME (decl))\n+\t{\n+\t  /* Output typedef name.  */\n+\t  fprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\n+\t  /* If there is a typedecl for this type with the same name\n+\t     as the tag, output an abbreviated form for that typedecl.  */\n+\t  if (use_gdb_dbx_extensions && have_used_extensions\n+\t      && (TREE_CODE (type) == RECORD_TYPE\n+\t\t  || TREE_CODE (type) == UNION_TYPE)\n+\t      && (TYPE_NAME (type) == decl))\n+\t\t{\n+\t\t  putc ('T', asmfile);\n+\t\t  TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;\n+\t        }\n+\t  putc ('t', asmfile);\n+\t  current_sym_code = N_LSYM;\n+\n+\t  dbxout_type (type, 1);\n+\t  dbxout_finish_symbol (decl);\n+\t}\n+      else if (TYPE_NAME (type) != 0 && !TREE_ASM_WRITTEN (TYPE_NAME (type)))\n+\t{\n+\t  /* Output a tag (a TYPE_DECL with no name, but the type has a name).\n+\t     This is what represents `struct foo' with no typedef.  */\n+\t  /* In C++, the name of a type is the corresponding typedef.\n+\t     In C, it is an IDENTIFIER_NODE.  */\n+\t  tree name = TYPE_NAME (type);\n+\t  if (TREE_CODE (name) == TYPE_DECL)\n+\t    name = DECL_NAME (name);\n+\n+\t  current_sym_code = N_LSYM;\n+\t  current_sym_value = 0;\n+\t  current_sym_addr = 0;\n+\t  current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n+\n+\t  fprintf (asmfile, \"%s \\\"%s:T\", ASM_STABS_OP,\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  dbxout_type (type, 1);\n+\t  dbxout_finish_symbol (0);\n+\t}\n+\n+      /* Prevent duplicate output of a typedef.  */\n+      TREE_ASM_WRITTEN (decl) = 1;\n+      break;\n+\n+    case PARM_DECL:\n+      /* Parm decls go in their own separate chains\n+\t and are output by dbxout_reg_parms and dbxout_parms.  */\n+      abort ();\n+\n+    case RESULT_DECL:\n+      /* Named return value, treat like a VAR_DECL.  */\n+    case VAR_DECL:\n+      if (DECL_RTL (decl) == 0)\n+\treturn;\n+      /* Don't mention a variable that is external.\n+\t Let the file that defines it describe it.  */\n+      if (TREE_EXTERNAL (decl))\n+\tbreak;\n+\n+      /* If the variable is really a constant\n+\t and not written in memory, inform the debugger.  */\n+      if (TREE_STATIC (decl) && TREE_READONLY (decl)\n+\t  && DECL_INITIAL (decl) != 0\n+\t  && ! TREE_ASM_WRITTEN (decl)\n+\t  && (DECL_FIELD_CONTEXT (decl) == NULL_TREE\n+\t      || TREE_CODE (DECL_FIELD_CONTEXT (decl)) == BLOCK))\n+\t{\n+\t  if (TREE_PUBLIC (decl) == 0)\n+\t    {\n+\t      /* The sun4 assembler does not grok this.  */\n+\t      char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+\t      if (TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE\n+\t\t  || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n+\t\t{\n+\t\t  int ival = TREE_INT_CST_LOW (DECL_INITIAL (decl));\n+#ifdef DBX_OUTPUT_CONSTANT_SYMBOL\n+\t\t  DBX_OUTPUT_CONSTANT_SYMBOL (asmfile, name, ival);\n+#else\n+\t\t  fprintf (asmfile, \"%s \\\"%s:c=i%d\\\",0x%x,0,0,0\\n\",\n+\t\t\t   ASM_STABS_OP, name, ival, N_LSYM);\n+#endif\n+\t\t  return;\n+\t\t}\n+\t      else if (TREE_CODE (TREE_TYPE (decl)) == REAL_TYPE)\n+\t\t{\n+\t\t  /* don't know how to do this yet.  */\n+\t\t}\n+\t      break;\n+\t    }\n+\t  /* else it is something we handle like a normal variable.  */\n+\t}\n+\n+      DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl));\n+#ifdef LEAF_REG_REMAP\n+      if (leaf_function)\n+\tleaf_renumber_regs_insn (DECL_RTL (decl));\n+#endif\n+\n+      /* Don't mention a variable at all\n+\t if it was completely optimized into nothingness.\n+\n+\t If DECL was from an inline function, then it's rtl\n+\t is not identically the rtl that was used in this\n+\t particular compilation.  */\n+      if (GET_CODE (DECL_RTL (decl)) == REG)\n+\t{\n+\t  regno = REGNO (DECL_RTL (decl));\n+\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t    regno = reg_renumber[REGNO (DECL_RTL (decl))];\n+\t  if (regno < 0)\n+\t    break;\n+\t}\n+      else if (GET_CODE (DECL_RTL (decl)) == SUBREG)\n+\t{\n+\t  rtx value = DECL_RTL (decl);\n+\t  int offset = 0;\n+\t  while (GET_CODE (value) == SUBREG)\n+\t    {\n+\t      offset += SUBREG_WORD (value);\n+\t      value = SUBREG_REG (value);\n+\t    }\n+\t  if (GET_CODE (value) == REG)\n+\t    {\n+\t      regno = REGNO (value);\n+\t      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t\tregno = reg_renumber[REGNO (value)];\n+\t      if (regno >= 0)\n+\t\tregno += offset;\n+\t    }\n+\t}\n+\n+      /* The kind-of-variable letter depends on where\n+\t the variable is and on the scope of its name:\n+\t G and N_GSYM for static storage and global scope,\n+\t S for static storage and file scope,\n+\t V for static storage and local scope,\n+\t    for those two, use N_LCSYM if data is in bss segment,\n+\t    N_STSYM if in data segment, N_FUN otherwise.\n+\t    (We used N_FUN originally, then changed to N_STSYM\n+\t    to please GDB.  However, it seems that confused ld.\n+\t    Now GDB has been fixed to like N_FUN, says Kingdon.)\n+\t no letter at all, and N_LSYM, for auto variable,\n+\t r and N_RSYM for register variable.  */\n+\n+      if (GET_CODE (DECL_RTL (decl)) == MEM\n+\t  && GET_CODE (XEXP (DECL_RTL (decl), 0)) == SYMBOL_REF)\n+\t{\n+\t  if (TREE_PUBLIC (decl))\n+\t    {\n+\t      letter = 'G';\n+\t      current_sym_code = N_GSYM;\n+\t    }\n+\t  else\n+\t    {\n+\t      current_sym_addr = XEXP (DECL_RTL (decl), 0);\n+\n+\t      letter = TREE_PERMANENT (decl) ? 'S' : 'V';\n+\n+\t      if (!DECL_INITIAL (decl))\n+\t\tcurrent_sym_code = N_LCSYM;\n+\t      else if (TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl))\n+\t\t/* This is not quite right, but it's the closest\n+\t\t   of all the codes that Unix defines.  */\n+\t\tcurrent_sym_code = N_FUN;\n+\t      else\n+\t\t{\n+/* Ultrix `as' seems to need this.  */\n+#ifdef DBX_STATIC_STAB_DATA_SECTION\n+\t\t  data_section ();\n+#endif\n+\t\t  current_sym_code = N_STSYM;\n+\t\t}\n+\t    }\n+\t}\n+      else if (regno >= 0)\n+\t{\n+\t  letter = 'r';\n+\t  current_sym_code = N_RSYM;\n+\t  current_sym_value = DBX_REGISTER_NUMBER (regno);\n+\t}\n+      else if (GET_CODE (DECL_RTL (decl)) == SUBREG)\n+\t{\n+\t  rtx value = DECL_RTL (decl);\n+\t  int offset = 0;\n+\t  while (GET_CODE (value) == SUBREG)\n+\t    {\n+\t      offset += SUBREG_WORD (value);\n+\t      value = SUBREG_REG (value);\n+\t    }\n+\t  letter = 'r';\n+\t  current_sym_code = N_RSYM;\n+\t  current_sym_value = DBX_REGISTER_NUMBER (REGNO (value) + offset);\n+\t}\n+      else if (GET_CODE (DECL_RTL (decl)) == MEM\n+\t       && (GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n+\t\t   || (GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG\n+\t\t       && REGNO (XEXP (DECL_RTL (decl), 0)) != FRAME_POINTER_REGNUM)))\n+\t/* If the value is indirect by memory or by a register\n+\t   that isn't the frame pointer\n+\t   then it means the object is variable-sized and address through\n+\t   that register or stack slot.  DBX has no way to represent this\n+\t   so all we can do is output the variable as a pointer.\n+\t   If it's not a parameter, ignore it.\n+\t   (VAR_DECLs like this can be made by integrate.c.)  */\n+\t{\n+\t  if (GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG)\n+\t    {\n+\t      letter = 'r';\n+\t      current_sym_code = N_RSYM;\n+\t      current_sym_value = DBX_REGISTER_NUMBER (REGNO (XEXP (DECL_RTL (decl), 0)));\n+\t    }\n+\t  else\n+\t    {\n+\t      current_sym_code = N_LSYM;\n+\t      /* DECL_RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))).\n+\t\t We want the value of that CONST_INT.  */\n+\t      current_sym_value\n+\t\t= DEBUGGER_AUTO_OFFSET (XEXP (XEXP (DECL_RTL (decl), 0), 0));\n+\t    }\n+\n+\t  /* Effectively do build_pointer_type, but don't cache this type,\n+\t     since it might be temporary whereas the type it points to\n+\t     might have been saved for inlining.  */\n+\t  type = make_node (REFERENCE_TYPE);\n+\t  TREE_TYPE (type) = TREE_TYPE (decl);\n+\t}\n+      else if (GET_CODE (DECL_RTL (decl)) == MEM\n+\t       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG)\n+\t{\n+\t  current_sym_code = N_LSYM;\n+\t  current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (decl), 0));\n+\t}\n+      else if (GET_CODE (DECL_RTL (decl)) == MEM\n+\t       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 1)) == CONST_INT)\n+\t{\n+\t  current_sym_code = N_LSYM;\n+\t  /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n+\t     We want the value of that CONST_INT.  */\n+\t  current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (decl), 0));\n+\t}\n+      else\n+\t/* Address might be a MEM, when DECL is a variable-sized object.\n+\t   Or it might be const0_rtx, meaning previous passes\n+\t   want us to ignore this variable.  */\n+\tbreak;\n+\n+      /* Ok, start a symtab entry and output the variable name.  */\n+      FORCE_TEXT;\n+      /* One slight hitch: if this is a VAR_DECL which is a static\n+\t class member, we must put out the mangled name instead of the\n+\t DECL_NAME.  */\n+      {\n+\tchar *name;\n+\t/* Note also that static member (variable) names DO NOT begin\n+\t   with underscores in .stabs directives.  */\n+\tif (DECL_LANG_SPECIFIC (decl))\n+\t  {\n+\t    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+\t    /* Adding 1 here only works on systems\n+\t       which flush an initial underscore.  */\n+\t    if (name[0] == '_')\n+\t      name += 1;\n+\t  }\n+\telse\n+\t  name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+\tfprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP, name);\n+      }\n+      if (letter) putc (letter, asmfile);\n+      dbxout_type (type, 0);\n+      dbxout_finish_symbol (decl);\n+      break;\n+    }\n+}\n+\n+static void\n+dbxout_prepare_symbol (decl)\n+     tree decl;\n+{\n+#ifdef WINNING_GDB\n+  char *filename = DECL_SOURCE_FILE (decl);\n+\n+  dbxout_source_file (asmfile, filename);\n+#endif\n+}\n+\n+static void\n+dbxout_finish_symbol (sym)\n+     tree sym;\n+{\n+  int line = 0;\n+#ifdef WINNING_GDB\n+  if (sym != 0)\n+    line = DECL_SOURCE_LINE (sym);\n+#endif\n+  fprintf (asmfile, \"\\\",%d,0,%d,\", current_sym_code, line);\n+  if (current_sym_addr)\n+    output_addr_const (asmfile, current_sym_addr);\n+  else\n+    fprintf (asmfile, \"%d\", current_sym_value);\n+  putc ('\\n', asmfile);\n+}\n+\n+/* Output definitions of all the decls in a chain.  */\n+\n+static void\n+dbxout_syms (syms)\n+     tree syms;\n+{\n+  while (syms)\n+    {\n+      dbxout_symbol (syms, 1);\n+      syms = TREE_CHAIN (syms);\n+    }\n+}\n+\f\n+/* The following two functions output definitions of function parameters.\n+   Each parameter gets a definition locating it in the parameter list.\n+   Each parameter that is a register variable gets a second definition\n+   locating it in the register.\n+\n+   Printing or argument lists in gdb uses the definitions that\n+   locate in the parameter list.  But reference to the variable in\n+   expressions uses preferentially the definition as a register.  */\n+\n+/* Output definitions, referring to storage in the parmlist,\n+   of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */\n+\n+static void\n+dbxout_parms (parms)\n+     tree parms;\n+{\n+  for (; parms; parms = TREE_CHAIN (parms))\n+    if (DECL_NAME (parms) && TREE_TYPE (parms) != error_mark_node)\n+      {\n+\tdbxout_prepare_symbol (parms);\n+\n+\t/* Perform any necessary register eliminations on the parameter's rtl,\n+\t   so that the debugging output will be accurate.  */\n+\tDECL_INCOMING_RTL (parms)\n+\t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, 0);\n+\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, 0);\n+#ifdef LEAF_REG_REMAP\n+\tif (leaf_function)\n+\t  {\n+\t    leaf_renumber_regs_insn (DECL_INCOMING_RTL (parms));\n+\t    leaf_renumber_regs_insn (DECL_RTL (parms));\n+\t  }\n+#endif\n+\n+\tif (PARM_PASSED_IN_MEMORY (parms))\n+\t  {\n+\t    rtx addr = XEXP (DECL_INCOMING_RTL (parms), 0);\n+\n+\t    /* ??? Here we assume that the parm address is indexed\n+\t       off the frame pointer or arg pointer.\n+\t       If that is not true, we produce meaningless results,\n+\t       but do not crash.  */\n+\t    if (GET_CODE (addr) == PLUS\n+\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t      current_sym_value = INTVAL (XEXP (addr, 1));\n+\t    else\n+\t      current_sym_value = 0;\n+\n+\t    current_sym_code = N_PSYM;\n+\t    current_sym_addr = 0;\n+\n+\t    FORCE_TEXT;\n+\t    if (DECL_NAME (parms))\n+\t      {\n+\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n+\n+\t\tfprintf (asmfile, \"%s \\\"%s:p\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t      }\n+\t    else\n+\t      {\n+\t\tcurrent_sym_nchars = 8;\n+\t\tfprintf (asmfile, \"%s \\\"(anon):p\", ASM_STABS_OP);\n+\t      }\n+\n+\t    if (GET_CODE (DECL_RTL (parms)) == REG\n+\t\t&& REGNO (DECL_RTL (parms)) >= 0\n+\t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n+\t      dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t    else\n+\t      {\n+\t\tint original_value = current_sym_value;\n+\n+\t\t/* This is the case where the parm is passed as an int or double\n+\t\t   and it is converted to a char, short or float and stored back\n+\t\t   in the parmlist.  In this case, describe the parm\n+\t\t   with the variable's declared type, and adjust the address\n+\t\t   if the least significant bytes (which we are using) are not\n+\t\t   the first ones.  */\n+#if BYTES_BIG_ENDIAN\n+\t\tif (TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t\t  current_sym_value += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n+\t\t\t\t\t- GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n+#endif\n+\n+\t\tif (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n+\t\t    && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n+\t\t    && INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == current_sym_value)\n+\t\t  dbxout_type (TREE_TYPE (parms), 0);\n+\t\telse\n+\t\t  {\n+\t\t    current_sym_value = original_value;\n+\t\t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t\t  }\n+\t      }\n+\t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n+\t    dbxout_finish_symbol (parms);\n+\t  }\n+\telse if (GET_CODE (DECL_RTL (parms)) == REG)\n+\t  {\n+\t    rtx best_rtl;\n+\t    /* Parm passed in registers and lives in registers or nowhere.  */\n+\n+\t    current_sym_code = N_RSYM;\n+\t    current_sym_addr = 0;\n+\n+\t    /* If parm lives in a register, use that register;\n+\t       pretend the parm was passed there.  It would be more consistent\n+\t       to describe the register where the parm was passed,\n+\t       but in practice that register usually holds something else.  */\n+\t    if (REGNO (DECL_RTL (parms)) >= 0\n+\t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n+\t      best_rtl = DECL_RTL (parms);\n+\t    /* If the parm lives nowhere,\n+\t       use the register where it was passed.  */\n+\t    else\n+\t      best_rtl = DECL_INCOMING_RTL (parms);\n+\t    current_sym_value = DBX_REGISTER_NUMBER (REGNO (best_rtl));\n+\n+\t    FORCE_TEXT;\n+\t    if (DECL_NAME (parms))\n+\t      {\n+\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n+\t\tfprintf (asmfile, \"%s \\\"%s:P\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t      }\n+\t    else\n+\t      {\n+\t\tcurrent_sym_nchars = 8;\n+\t\tfprintf (asmfile, \"%s \\\"(anon):P\", ASM_STABS_OP);\n+\t      }\n+\n+\t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t    dbxout_finish_symbol (parms);\n+\t  }\n+\telse if (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t && XEXP (DECL_RTL (parms), 0) != const0_rtx)\n+\t  {\n+\t    /* Parm was passed in registers but lives on the stack.  */\n+\n+\t    current_sym_code = N_PSYM;\n+\t    /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))),\n+\t       in which case we want the value of that CONST_INT,\n+\t       or (MEM (REG ...)) or (MEM (MEM ...)),\n+\t       in which case we use a value of zero.  */\n+\t    if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG\n+\t\t|| GET_CODE (XEXP (DECL_RTL (parms), 0)) == MEM)\n+\t      current_sym_value = 0;\n+\t    else\n+\t      current_sym_value = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n+\t    current_sym_addr = 0;\n+\n+\t    FORCE_TEXT;\n+\t    if (DECL_NAME (parms))\n+\t      {\n+\t\tcurrent_sym_nchars = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\n+\t\tfprintf (asmfile, \"%s \\\"%s:p\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t      }\n+\t    else\n+\t      {\n+\t\tcurrent_sym_nchars = 8;\n+\t\tfprintf (asmfile, \"%s \\\"(anon):p\", ASM_STABS_OP);\n+\t      }\n+\n+\t    current_sym_value\n+\t      = DEBUGGER_ARG_OFFSET (current_sym_value,\n+\t\t\t\t     XEXP (DECL_RTL (parms), 0));\n+\t    dbxout_type (TREE_TYPE (parms), 0);\n+\t    dbxout_finish_symbol (parms);\n+\t  }\n+      }\n+}\n+\n+/* Output definitions for the places where parms live during the function,\n+   when different from where they were passed, when the parms were passed\n+   in memory.\n+\n+   It is not useful to do this for parms passed in registers\n+   that live during the function in different registers, because it is\n+   impossible to look in the passed register for the passed value,\n+   so we use the within-the-function register to begin with.\n+\n+   PARMS is a chain of PARM_DECL nodes.  */\n+\n+static void\n+dbxout_reg_parms (parms)\n+     tree parms;\n+{\n+  for (; parms; parms = TREE_CHAIN (parms))\n+    if (DECL_NAME (parms))\n+      {\n+\tdbxout_prepare_symbol (parms);\n+\n+\t/* Report parms that live in registers during the function\n+\t   but were passed in memory.  */\n+\tif (GET_CODE (DECL_RTL (parms)) == REG\n+\t    && REGNO (DECL_RTL (parms)) >= 0\n+\t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER\n+\t    && PARM_PASSED_IN_MEMORY (parms))\n+\t  {\n+\t    current_sym_code = N_RSYM;\n+\t    current_sym_value = DBX_REGISTER_NUMBER (REGNO (DECL_RTL (parms)));\n+\t    current_sym_addr = 0;\n+\n+\t    FORCE_TEXT;\n+\t    if (DECL_NAME (parms))\n+\t      {\n+\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n+\t\tfprintf (asmfile, \"%s \\\"%s:r\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t      }\n+\t    else\n+\t      {\n+\t\tcurrent_sym_nchars = 8;\n+\t\tfprintf (asmfile, \"%s \\\"(anon):r\", ASM_STABS_OP);\n+\t      }\n+\t    dbxout_type (TREE_TYPE (parms), 0);\n+\t    dbxout_finish_symbol (parms);\n+\t  }\n+\t/* Report parms that live in memory but not where they were passed.  */\n+\telse if (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n+\t\t && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n+\t\t && PARM_PASSED_IN_MEMORY (parms)\n+\t\t && ! rtx_equal_p (DECL_RTL (parms), DECL_INCOMING_RTL (parms)))\n+\t  {\n+#if 0 /* ??? It is not clear yet what should replace this.  */\n+\t    int offset = DECL_OFFSET (parms) / BITS_PER_UNIT;\n+\t    /* A parm declared char is really passed as an int,\n+\t       so it occupies the least significant bytes.\n+\t       On a big-endian machine those are not the low-numbered ones.  */\n+#if BYTES_BIG_ENDIAN\n+\t    if (offset != -1 && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n+\t\t\t - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n+#endif\n+\t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n+#endif\n+\t    current_sym_code = N_LSYM;\n+\t    current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (DECL_RTL (parms), 0));\n+\t    current_sym_addr = 0;\n+\t    FORCE_TEXT;\n+\t    if (DECL_NAME (parms))\n+\t      {\n+\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n+\t\tfprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t      }\n+\t    else\n+\t      {\n+\t\tcurrent_sym_nchars = 8;\n+\t\tfprintf (asmfile, \"%s \\\"(anon):\", ASM_STABS_OP);\n+\t      }\n+\t    dbxout_type (TREE_TYPE (parms), 0);\n+\t    dbxout_finish_symbol (parms);\n+\t  }\n+      }\n+}\n+\f\n+/* Given a chain of ..._TYPE nodes (as come in a parameter list),\n+   output definitions of those names, in raw form */\n+\n+void\n+dbxout_args (args)\n+     tree args;\n+{\n+  while (args)\n+    {\n+      putc (',', asmfile);\n+      dbxout_type (TREE_VALUE (args), 0);\n+      CHARS (1);\n+      args = TREE_CHAIN (args);\n+    }\n+}\n+\f\n+/* Given a chain of ..._TYPE nodes,\n+   find those which have typedef names and output those names.\n+   This is to ensure those types get output.  */\n+\n+void\n+dbxout_types (types)\n+     register tree types;\n+{\n+  while (types)\n+    {\n+      if (TYPE_NAME (types)\n+\t  && TREE_CODE (TYPE_NAME (types)) == TYPE_DECL\n+\t  && ! TREE_ASM_WRITTEN (TYPE_NAME (types)))\n+\tdbxout_symbol (TYPE_NAME (types), 1);\n+      types = TREE_CHAIN (types);\n+    }\n+}\n+\f\n+/* Output everything about a symbol block (a BLOCK node\n+   that represents a scope level),\n+   including recursive output of contained blocks.\n+\n+   BLOCK is the BLOCK node.\n+   DEPTH is its depth within containing symbol blocks.\n+   ARGS is usually zero; but for the outermost block of the\n+   body of a function, it is a chain of PARM_DECLs for the function parameters.\n+   We output definitions of all the register parms\n+   as if they were local variables of that block.\n+\n+   If -g1 was used, we count blocks just the same, but output nothing\n+   except for the outermost block.\n+\n+   Actually, BLOCK may be several blocks chained together.\n+   We handle them all in sequence.  */\n+\n+static void\n+dbxout_block (block, depth, args)\n+     register tree block;\n+     int depth;\n+     tree args;\n+{\n+  int blocknum;\n+\n+  while (block)\n+    {\n+      /* Ignore blocks never expanded or otherwise marked as real.  */\n+      if (TREE_USED (block))\n+\t{\n+#ifndef DBX_LBRAC_FIRST\n+\t  /* In dbx format, the syms of a block come before the N_LBRAC.  */\n+\t  if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)\n+\t    dbxout_syms (BLOCK_VARS (block));\n+\t  if (args)\n+\t    dbxout_reg_parms (args);\n+#endif\n+\n+\t  /* Now output an N_LBRAC symbol to represent the beginning of\n+\t     the block.  Use the block's tree-walk order to generate\n+\t     the assembler symbols LBBn and LBEn\n+\t     that final will define around the code in this block.  */\n+\t  if (depth > 0 && debug_info_level != DINFO_LEVEL_TERSE)\n+\t    {\n+\t      char buf[20];\n+\t      blocknum = next_block_number++;\n+\t      ASM_GENERATE_INTERNAL_LABEL (buf, \"LBB\", blocknum);\n+\n+\t      if (BLOCK_HANDLER_BLOCK (block))\n+\t\t{\n+\t\t  /* A catch block.  Must precede N_LBRAC.  */\n+\t\t  tree decl = BLOCK_VARS (block);\n+\t\t  while (decl)\n+\t\t    {\n+#ifdef DBX_OUTPUT_CATCH\n+\t\t      DBX_OUTPUT_CATCH (asmfile, decl, buf);\n+#else\n+\t\t      fprintf (asmfile, \"%s \\\"%s:C1\\\",%d,0,0,\",\n+\t\t\t       ASM_STABS_OP,\n+\t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)), N_CATCH);\n+\t\t      assemble_name (asmfile, buf);\n+\t\t      fprintf (asmfile, \"\\n\");\n+#endif\n+\t\t      decl = TREE_CHAIN (decl);\n+\t\t    }\n+\t\t}\n+\n+\t      fprintf (asmfile, \"%s %d,0,0,\", ASM_STABN_OP, N_LBRAC);\n+\t      assemble_name (asmfile, buf);\n+\t      fprintf (asmfile, \"\\n\");\n+\t    }\n+\t  else if (depth > 0)\n+\t    /* Count blocks the same way regardless of debug_info_level.  */\n+\t    next_block_number++;\n+\n+#ifdef DBX_LBRAC_FIRST\n+\t  /* On some weird machines, the syms of a block\n+\t     come after the N_LBRAC.  */\n+\t  if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)\n+\t    dbxout_syms (BLOCK_VARS (block));\n+\t  if (args)\n+\t    dbxout_reg_parms (args);\n+#endif\n+\n+\t  /* Output the subblocks.  */\n+\t  dbxout_block (BLOCK_SUBBLOCKS (block), depth + 1, 0);\n+\n+\t  /* Refer to the marker for the end of the block.  */\n+\t  if (depth > 0 && debug_info_level != DINFO_LEVEL_TERSE)\n+\t    {\n+\t      char buf[20];\n+\t      ASM_GENERATE_INTERNAL_LABEL (buf, \"LBE\", blocknum);\n+\t      fprintf (asmfile, \"%s %d,0,0,\", ASM_STABN_OP, N_RBRAC);\n+\t      assemble_name (asmfile, buf);\n+\t      fprintf (asmfile, \"\\n\");\n+\t    }\n+\t}\n+      block = BLOCK_CHAIN (block);\n+    }\n+}\n+\n+/* Output the information about a function and its arguments and result.\n+   Usually this follows the function's code,\n+   but on some systems, it comes before.  */\n+\n+static void\n+dbxout_really_begin_function (decl)\n+     tree decl;\n+{\n+  dbxout_symbol (decl, 0);\n+  dbxout_parms (DECL_ARGUMENTS (decl));\n+  if (DECL_NAME (DECL_RESULT (decl)) != 0)\n+    dbxout_symbol (DECL_RESULT (decl), 1);\n+}\n+\n+/* Called at beginning of output of function definition.  */\n+\n+void\n+dbxout_begin_function (decl)\n+     tree decl;\n+{\n+#ifdef DBX_FUNCTION_FIRST\n+  dbxout_really_begin_function (decl);\n+#endif\n+}\n+\n+/* Output dbx data for a function definition.\n+   This includes a definition of the function name itself (a symbol),\n+   definitions of the parameters (locating them in the parameter list)\n+   and then output the block that makes up the function's body\n+   (including all the auto variables of the function).  */\n+\n+void\n+dbxout_function (decl)\n+     tree decl;\n+{\n+#ifndef DBX_FUNCTION_FIRST\n+  dbxout_really_begin_function (decl);\n+#endif\n+  dbxout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl));\n+#ifdef DBX_OUTPUT_FUNCTION_END\n+  DBX_OUTPUT_FUNCTION_END (asmfile, decl);\n+#endif\n+}\n+\f\n+#else /* not DBX_DEBUGGING_INFO */\n+\n+void\n+dbxout_init (asm_file, input_file_name)\n+     FILE *asm_file;\n+     char *input_file_name;\n+{}\n+\n+void\n+dbxout_symbol (decl, local)\n+     tree decl;\n+     int local;\n+{}\n+\n+void\n+dbxout_types (types)\n+     register tree types;\n+{}\n+\n+void\n+dbxout_function (decl)\n+     tree decl;\n+{}\n+\n+#endif /* DBX_DEBUGGING_INFO */"}]}