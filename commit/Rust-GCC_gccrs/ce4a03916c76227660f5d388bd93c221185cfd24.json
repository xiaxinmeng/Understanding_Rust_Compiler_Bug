{"sha": "ce4a03916c76227660f5d388bd93c221185cfd24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U0YTAzOTE2Yzc2MjI3NjYwZjVkMzg4YmQ5M2MyMjExODVjZmQyNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-11T00:07:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-11T00:07:25Z"}, "message": "cp-tree.h (finish_unary_op_expr): New function.\n\n\t* cp-tree.h (finish_unary_op_expr): New function.\n\t(finish_id_expr): Likewise.\n\t(begin_new_placement): Likewise.\n\t(finish_new_placement): Likewise.\n\t(finish_declarator): Likewise.\n\t(finish_translation_unit): Likewise.\n\t(finish_parmlist): Likewise.\n\t(begin_class_definition): Likewise.\n\t(finish_class_definition): Likewise.\n\t(finish_default_args): Likewise.\n\t(finish_inline_definitions): Likewise.\n\t* parse.y (GCC_ASM_KEYWORD): Remove.\n\t(TYPENAME_ELLIPSIS): Likewise.\n\t* parse.c: Regenerated.\n\tUse new functions in semantics.c in the actions for many rules.\n\t* gxx.gperf (GCC_ASM_KEYWORD): Just use ASM_KEYWORD.\n\t* hash.h: Regenerated.\n\t* semantics.c (finish_expr_stmt): Allow NULL expr.\n\t(finish_unary_op_expr): New function, containing\n\tcode previously in parse.y.\n\t(finish_id_expr): Likewise.\n\t(begin_new_placement): Likewise.\n\t(finish_new_placement): Likewise.\n\t(finish_declarator): Likewise.\n\t(finish_translation_unit): Likewise.\n\t(finish_parmlist): Likewise.\n\t(begin_class_definition): Likewise.\n\t(finish_class_definition): Likewise.\n\t(finish_default_args): Likewise.\n\t(finish_inline_definitions): Likewise.\n\nFrom-SVN: r19660", "tree": {"sha": "ab2d452b18a4eec96202dee9f3470cae51dd4522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab2d452b18a4eec96202dee9f3470cae51dd4522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce4a03916c76227660f5d388bd93c221185cfd24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4a03916c76227660f5d388bd93c221185cfd24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce4a03916c76227660f5d388bd93c221185cfd24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4a03916c76227660f5d388bd93c221185cfd24/comments", "author": null, "committer": null, "parents": [{"sha": "4785faf11744c7e86ac93032075b23becebef200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4785faf11744c7e86ac93032075b23becebef200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4785faf11744c7e86ac93032075b23becebef200"}], "stats": {"total": 625, "additions": 417, "deletions": 208}, "files": [{"sha": "95fa40af7a9cb2c48f6b62d903ef140089232d53", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -1,3 +1,36 @@\n+Mon May 11 00:03:34 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* cp-tree.h (finish_unary_op_expr): New function.\n+\t(finish_id_expr): Likewise.\n+\t(begin_new_placement): Likewise.\n+\t(finish_new_placement): Likewise.\n+\t(finish_declarator): Likewise.\n+\t(finish_translation_unit): Likewise.\n+\t(finish_parmlist): Likewise.\n+\t(begin_class_definition): Likewise.\n+\t(finish_class_definition): Likewise.\n+\t(finish_default_args): Likewise.\n+\t(finish_inline_definitions): Likewise.\n+\t* parse.y (GCC_ASM_KEYWORD): Remove.\n+\t(TYPENAME_ELLIPSIS): Likewise.\n+\t* parse.c: Regenerated.\n+\tUse new functions in semantics.c in the actions for many rules.\n+\t* gxx.gperf (GCC_ASM_KEYWORD): Just use ASM_KEYWORD.\n+\t* hash.h: Regenerated.\n+\t* semantics.c (finish_expr_stmt): Allow NULL expr.\n+\t(finish_unary_op_expr): New function, containing\n+\tcode previously in parse.y.\n+\t(finish_id_expr): Likewise.\n+\t(begin_new_placement): Likewise.\n+\t(finish_new_placement): Likewise.\n+\t(finish_declarator): Likewise.\n+\t(finish_translation_unit): Likewise.\n+\t(finish_parmlist): Likewise.\n+\t(begin_class_definition): Likewise.\n+\t(finish_class_definition): Likewise.\n+\t(finish_default_args): Likewise.\n+\t(finish_inline_definitions): Likewise.\n+\n Sun May 10 23:43:13 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* typeck.c (build_c_cast): Don't decay arrays and functions to"}, {"sha": "f044553d9ff339d856bb9fec35f4ad553837504e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -2634,10 +2634,21 @@ extern tree finish_qualified_object_call_expr   PROTO((tree, tree, tree));\n extern tree finish_pseudo_destructor_call_expr  PROTO((tree, tree, tree));\n extern tree finish_globally_qualified_member_call_expr PROTO ((tree, tree));\n extern tree finish_label_address_expr           PROTO((tree));\n+extern tree finish_unary_op_expr                PROTO((enum tree_code, tree));\n+extern tree finish_id_expr                      PROTO((tree));\n+extern int  begin_new_placement                 PROTO((void));\n+extern tree finish_new_placement                PROTO((tree, int));\n extern int begin_function_definition            PROTO((tree, tree));\n extern tree begin_constructor_declarator        PROTO((tree, tree));\n+extern tree finish_declarator                   PROTO((tree, tree, tree, tree, int));\n+extern void finish_translation_unit             PROTO((void));\n extern tree finish_template_type_parm           PROTO((tree, tree));\n extern tree finish_template_template_parm       PROTO((tree, tree));\n+extern tree finish_parmlist                     PROTO((tree, int));\n+extern tree begin_class_definition              PROTO((tree));\n+extern tree finish_class_definition             PROTO((tree, tree, tree, int));\n+extern void finish_default_args                 PROTO((void));\n+extern void begin_inline_definitions            PROTO((void));\n \n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));"}, {"sha": "71538567c135567122b353f1159601761f8b64e8", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -5,8 +5,8 @@ struct resword { char *name; short token; enum rid rid;};\n %%\n __alignof, ALIGNOF, NORID\n __alignof__, ALIGNOF, NORID\n-__asm, GCC_ASM_KEYWORD, NORID\n-__asm__, GCC_ASM_KEYWORD, NORID\n+__asm, ASM_KEYWORD, NORID\n+__asm__, ASM_KEYWORD, NORID\n __attribute, ATTRIBUTE, NORID\n __attribute__, ATTRIBUTE, NORID\n __complex, TYPESPEC, RID_COMPLEX"}, {"sha": "1e31a354724a80bcd71c790f69f7d96953c634f3", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -1,5 +1,6 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../gcc/cp/gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n #define TOTAL_KEYWORDS 103\n@@ -72,7 +73,7 @@ is_reserved_word (str, len)\n       {\"\",}, \n       {\"true\",  CXX_TRUE, NORID,},\n       {\"\",}, \n-      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"__asm__\",  ASM_KEYWORD, NORID},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"this\",  THIS, NORID,},\n       {\"\",}, \n@@ -104,7 +105,7 @@ is_reserved_word (str, len)\n       {\"short\",  TYPESPEC, RID_SHORT,},\n       {\"__imag__\",  IMAGPART, NORID},\n       {\"delete\",  DELETE, NORID,},\n-      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n+      {\"__asm\",  ASM_KEYWORD, NORID},\n       {\"xor\",  '^', NORID,},\n       {\"not_eq\",  EQCOMPARE, NORID,},\n       {\"xor_eq\",  ASSIGN, NORID,},"}, {"sha": "d9df9b8919fed3c39b8f48e6517efaa61a66c98a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 35, "deletions": 192, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -129,7 +129,7 @@ empty_parms ()\n /* the reserved words */\n /* SCO include files test \"ASM\", so use something else.  */\n %token SIZEOF ENUM /* STRUCT UNION */ IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n-%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD GCC_ASM_KEYWORD TYPEOF ALIGNOF\n+%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF\n %token SIGOF\n %token ATTRIBUTE EXTENSION LABEL\n %token REALPART IMAGPART\n@@ -228,7 +228,7 @@ empty_parms ()\n %type <ftype> structsp typespecqual_reserved parm named_parm full_parm\n \n /* C++ extensions */\n-%token <ttype> TYPENAME_ELLIPSIS PTYPENAME\n+%token <ttype> PTYPENAME\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n %type <ttype> component_constructor_declarator\n@@ -328,15 +328,7 @@ parse_decl(declarator, specs_attrs, attributes, initialized, decl)\n program:\n \t  /* empty */\n \t| extdefs\n-\t\t{\n-\t\t  /* In case there were missing closebraces,\n-\t\t     get us back to the global binding level.  */\n-\t\t  while (! toplevel_bindings_p ())\n-\t\t    poplevel (0, 0, 0);\n-\t\t  while (current_namespace != global_namespace)\n-\t\t    pop_namespace ();\n-\t\t  finish_file ();\n-\t\t}\n+               { finish_translation_unit (); }\n \t;\n \n /* the reason for the strange actions in this rule\n@@ -373,7 +365,6 @@ extension:\n \n asm_keyword:\n \t  ASM_KEYWORD\n-\t| GCC_ASM_KEYWORD\n \t;\n \n lang_extdef:\n@@ -1010,11 +1001,7 @@ unary_expr:\n \t| '~' cast_expr\n \t\t{ $$ = build_x_unary_op (BIT_NOT_EXPR, $2); }\n \t| unop cast_expr  %prec UNARY\n-\t\t{ $$ = build_x_unary_op ($1, $2);\n-\t\t  if ($1 == NEGATE_EXPR && TREE_CODE ($2) == INTEGER_CST)\n-\t\t    TREE_NEGATED_INT ($$) = 1;\n-\t\t  overflow_warning ($$);\n-\t\t}\n+                { $$ = finish_unary_op_expr ($1, $2); }\n \t/* Refer to the address of a label as a pointer.  */\n \t| ANDAND identifier\n \t\t{ if (pedantic)\n@@ -1075,13 +1062,15 @@ unary_expr:\n \t;\n \n new_placement:\n-\t  '(' nonnull_exprlist ')'\n-\t\t{ $$ = $2; }\n-\t| '{' nonnull_exprlist '}'\n-\t\t{\n-\t\t  $$ = $2; \n-\t\t  pedwarn (\"old style placement syntax, use () instead\");\n-\t\t}\n+\t  '(' \n+                { $<itype>$ = begin_new_placement (); }\n+            nonnull_exprlist ')'\n+                { $$ = finish_new_placement ($3, $<itype>1); }\n+\t| '{' \n+                { cp_pedwarn (\"old style placement syntax, use () instead\");\n+\t\t  $<itype>$ = begin_new_placement (); }\n+\t    nonnull_exprlist '}'\n+                { $$ = finish_new_placement ($3, $<itype>1); }\n \t;\n \n new_initializer:\n@@ -1112,13 +1101,11 @@ new_initializer:\n /* This is necessary to postpone reduction of `int ((int)(int)(int))'.  */\n regcast_or_absdcl:\n \t  '(' type_id ')'  %prec EMPTY\n-\t\t{ $2.t = tree_cons (NULL_TREE, $2.t, void_list_node);\n-\t\t  TREE_PARMLIST ($2.t) = 1;\n+\t\t{ $2.t = finish_parmlist (build_tree_list (NULL_TREE, $2.t), 0);\n \t\t  $$ = make_call_declarator (NULL_TREE, $2.t, NULL_TREE, NULL_TREE);\n \t\t  check_for_new_type (\"cast\", $2); }\n \t| regcast_or_absdcl '(' type_id ')'  %prec EMPTY\n-\t\t{ $3.t = tree_cons (NULL_TREE, $3.t, void_list_node);\n-\t\t  TREE_PARMLIST ($3.t) = 1;\n+\t\t{ $3.t = finish_parmlist (build_tree_list (NULL_TREE, $3.t), 0); \n \t\t  $$ = make_call_declarator ($$, $3.t, NULL_TREE, NULL_TREE);\n \t\t  check_for_new_type (\"cast\", $3); }\n \t;\n@@ -1272,10 +1259,10 @@ direct_notype_declarator:\n primary:\n \t  notype_unqualified_id\n \t\t{\n-\t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n-\t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n-\t\t  else if (TREE_CODE ($$) != TEMPLATE_ID_EXPR)\n-\t\t    $$ = do_identifier ($$, 1);\n+\t\t  if (TREE_CODE ($1) == BIT_NOT_EXPR)\n+\t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($1, 0));\n+\t\t  else \n+\t\t    $$ = finish_id_expr ($1);\n \t\t}\t\t\n \t| CONSTANT\n \t| boolean.literal\n@@ -2005,54 +1992,21 @@ structsp:\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly \n           opt.component_decl_list '}' maybe_attribute\n-\t\t{\n+\t\t{ \n \t\t  int semi;\n \n-\t\t  $<ttype>$ = $1;\n-#if 0\n-\t\t  /* Need to rework class nesting in the\n-\t\t     presence of nested classes, etc.  */\n-\t\t  shadow_tag (CLASSTYPE_AS_LIST ($1)); */\n-#endif\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n-\t\t  /* finish_struct nukes this anyway; if\n-\t\t     finish_exception does too, then it can go.  */\n-\t\t  if (semi)\n-\t\t    note_got_semicolon ($1);\n-\n-\t\t  if (TREE_CODE ($1) == ENUMERAL_TYPE)\n-\t\t    ;\n-\t\t  else\n-\t\t    {\n-\t\t      $<ttype>$ = finish_struct ($1, $3, $5, semi);\n-\t\t      if (semi) note_got_semicolon ($<ttype>$);\n-\t\t    }\n-\n-\t\t  pop_obstacks ();\n \n-\t\t  if (! semi)\n-\t\t    check_for_missing_semicolon ($1); \n-\t\t  if (current_scope () == current_function_decl)\n-\t\t    do_pending_defargs ();\n+\t\t  $<ttype>$ = finish_class_definition ($1, $3, $5, semi); \n \t\t}\n \t  pending_defargs\n-\t\t{\n-\t\t  if (pending_inlines \n-\t\t      && current_scope () == current_function_decl)\n-\t\t    do_pending_inlines ();\n-\t\t}\n+                { finish_default_args (); }\n \t  pending_inlines\n-\t\t{ \n-\t\t  $$.t = $<ttype>6;\n+                { $$.t = $<ttype>6;\n \t\t  $$.new_type_flag = 1; \n-\t\t  if (current_class_type == NULL_TREE)\n-\t\t    clear_inline_text_obstack (); \n-\n-\t\t  /* Undo the begin_tree in left_curly.  */\n-\t\t  end_tree ();\n-\t\t}\n+\t\t  begin_inline_definitions (); }\n \t| class_head  %prec EMPTY\n \t\t{\n \t\t  $$.new_type_flag = 0;\n@@ -2334,92 +2288,7 @@ base_class_access_list:\n \n left_curly:\n \t  '{'\n-\t\t{ tree t = $<ttype>0;\n-\t\t  push_obstacks_nochange ();\n-\t\t  end_temporary_allocation ();\n-\n-\t\t  if (t == error_mark_node\n-\t\t      || ! IS_AGGR_TYPE (t))\n-\t\t    {\n-\t\t      t = $<ttype>0 = make_lang_type (RECORD_TYPE);\n-\t\t      pushtag (make_anon_name (), t, 0);\n-\t\t    }\n-\t\t  if (TYPE_SIZE (t))\n-\t\t    duplicate_tag_error (t);\n-                  if (TYPE_SIZE (t) || TYPE_BEING_DEFINED (t))\n-                    {\n-                      t = make_lang_type (TREE_CODE (t));\n-                      pushtag (TYPE_IDENTIFIER ($<ttype>0), t, 0);\n-                      $<ttype>0 = t;\n-                    }\n-\t\t  if (processing_template_decl && TYPE_CONTEXT (t)\n-\t\t      && TREE_CODE (TYPE_CONTEXT (t)) != NAMESPACE_DECL\n-\t\t      && ! current_class_type)\n-\t\t    push_template_decl (TYPE_STUB_DECL (t));\n-\t\t  pushclass (t, 0);\n-\t\t  TYPE_BEING_DEFINED (t) = 1;\n-\t\t  if (IS_AGGR_TYPE (t) && CLASSTYPE_USE_TEMPLATE (t))\n-\t\t    {\n-\t\t      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)\n-\t\t\t  && TYPE_SIZE (t) == NULL_TREE)\n-\t\t\t{\n-\t\t\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n-\t\t\t  if (processing_template_decl)\n-\t\t\t    push_template_decl (TYPE_MAIN_DECL (t));\n-\t\t\t}\n-\t\t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n-\t\t\tcp_error (\"specialization after instantiation of `%T'\", t);\n-\t\t    }\n-\t\t  /* Reset the interface data, at the earliest possible\n-\t\t     moment, as it might have been set via a class foo;\n-\t\t     before.  */\n-\t\t  /* Don't change signatures.  */\n-\t\t  if (! IS_SIGNATURE (t))\n-\t\t    {\n-\t\t      extern tree pending_vtables;\n-\t\t      int needs_writing;\n-\t\t      tree name = TYPE_IDENTIFIER (t);\n-\n-\t\t      if (! ANON_AGGRNAME_P (name))\n-\t\t\t{\n-\t\t\t  CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-\t\t\t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n-\t\t\t    (t, interface_unknown);\n-\t\t\t}\n-\n-\t\t      /* Record how to set the access of this class's\n-\t\t\t virtual functions.  If write_virtuals == 2 or 3, then\n-\t\t\t inline virtuals are ``extern inline''.  */\n-\t\t      switch (write_virtuals)\n-\t\t\t{\n-\t\t\tcase 0:\n-\t\t\tcase 1:\n-\t\t\t  needs_writing = 1;\n-\t\t\t  break;\n-\t\t\tcase 2:\n-\t\t\t  needs_writing = !! value_member (name, pending_vtables);\n-\t\t\t  break;\n-\t\t\tcase 3:\n-\t\t\t  needs_writing = ! CLASSTYPE_INTERFACE_ONLY (t)\n-\t\t\t    && CLASSTYPE_INTERFACE_KNOWN (t);\n-\t\t\t  break;\n-\t\t\tdefault:\n-\t\t\t  needs_writing = 0;\n-\t\t\t}\n-\t\t      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = needs_writing;\n-\t\t    }\n-#if 0\n-\t\t  t = TYPE_IDENTIFIER ($<ttype>0);\n-\t\t  if (t && IDENTIFIER_TEMPLATE (t))\n-\t\t    overload_template_name (t, 1);\n-#endif\n-\t\t  reset_specialization();\n-\n-\t\t  /* In case this is a local class within a template\n-\t\t     function, we save the current tree structure so\n-\t\t     that we can get it back later.  */\n-\t\t  begin_tree ();\n-\t\t}\n+                { $<ttype>0 = begin_class_definition ($<ttype>0); }\n \t;\n \n self_reference:\n@@ -3497,58 +3366,32 @@ parmlist:\n \t\t}\n \t| complex_parmlist\n \t| type_id\n-\t\t{ $$ = tree_cons (NULL_TREE, $1.t, void_list_node);\n-\t\t  TREE_PARMLIST ($$) = 1; \n+\t\t{ $$ = finish_parmlist (build_tree_list (NULL_TREE, $1.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", $1); }\n \t;\n \n /* This nonterminal does not include the common sequence '(' type_id ')',\n    as it is ambiguous and must be disambiguated elsewhere.  */\n complex_parmlist:\n \t  parms\n-\t\t{\n-\t\t  $$ = chainon ($$, void_list_node);\n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n+                { $$ = finish_parmlist ($$, 0); }\n \t| parms_comma ELLIPSIS\n-\t\t{\n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n+                { $$ = finish_parmlist ($1, 1); }\n \t/* C++ allows an ellipsis without a separating ',' */\n \t| parms ELLIPSIS\n-\t\t{\n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n+                { $$ = finish_parmlist ($1, 1); }\n \t| type_id ELLIPSIS\n-\t\t{\n-\t\t  $$ = build_tree_list (NULL_TREE, $1.t); \n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n+                { $$ = finish_parmlist (build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t $1.t), 1); } \n \t| ELLIPSIS\n-\t\t{\n-\t\t  $$ = NULL_TREE;\n-\t\t}\n-\t| TYPENAME_ELLIPSIS\n-\t\t{\n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n-\t| parms TYPENAME_ELLIPSIS\n-\t\t{\n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n-\t| type_id TYPENAME_ELLIPSIS\n-\t\t{\n-\t\t  $$ = build_tree_list (NULL_TREE, $1.t);\n-\t\t  TREE_PARMLIST ($$) = 1;\n-\t\t}\n+                { $$ = finish_parmlist (NULL_TREE, 1); }\n \t| parms ':'\n \t\t{\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n \t\t     parenthesis.  */\n \t\t  yyerror (\"possibly missing ')'\");\n-\t\t  $$ = chainon ($$, void_list_node);\n-\t\t  TREE_PARMLIST ($$) = 1;\n+\t\t  $$ = finish_parmlist ($1, 0);\n \t\t  yyungetc (':', 0);\n \t\t  yychar = ')';\n \t\t}\n@@ -3558,8 +3401,8 @@ complex_parmlist:\n \t\t     parse errors, for example, a missing right\n \t\t     parenthesis.  */\n \t\t  yyerror (\"possibly missing ')'\");\n-\t\t  $$ = tree_cons (NULL_TREE, $1.t, void_list_node);\n-\t\t  TREE_PARMLIST ($$) = 1;\n+\t\t  $$ = finish_parmlist (build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t $1.t), 0); \n \t\t  yyungetc (':', 0);\n \t\t  yychar = ')';\n \t\t}"}, {"sha": "d58ba1db84b7c5060b04d20a0fcf9e55db018a31", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 275, "deletions": 11, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -66,19 +66,23 @@ void\n finish_expr_stmt (expr)\n      tree expr;\n {\n-  if (!processing_template_decl)\n+  if (expr != NULL_TREE)\n     {\n-      emit_line_note (input_filename, lineno);\n-      /* Do default conversion if safe and possibly important,\n-\t in case within ({...}).  */\n-      if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t   && lvalue_p (expr))\n-\t  || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n-\texpr = default_conversion (expr);\n+      if (!processing_template_decl)\n+\t{\n+\t  emit_line_note (input_filename, lineno);\n+\t  /* Do default conversion if safe and possibly important,\n+\t     in case within ({...}).  */\n+\t  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+\t       && lvalue_p (expr))\n+\t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n+\t    expr = default_conversion (expr);\n+\t}\n+      \n+      cplus_expand_expr_stmt (expr);\n+      clear_momentary ();\n     }\n-  \n-  cplus_expand_expr_stmt (expr);\n-  clear_momentary ();\n+\n   finish_stmt ();\n }\n \n@@ -993,6 +997,58 @@ finish_label_address_expr (label)\n   return result;\n }\n \n+/* Finish an expression of the form CODE EXPR.  */\n+\n+tree\n+finish_unary_op_expr (code, expr)\n+     enum tree_code code;\n+     tree expr;\n+{\n+  tree result = build_x_unary_op (code, expr);\n+  if (code == NEGATE_EXPR && TREE_CODE (expr) == INTEGER_CST)\n+    TREE_NEGATED_INT (result) = 1;\n+  overflow_warning (result);\n+  return result;\n+}\n+\n+/* Finish an id-expression.  */\n+\n+tree\n+finish_id_expr (expr)\n+     tree expr;\n+{\n+  if (TREE_CODE (expr) == IDENTIFIER_NODE)\n+    expr = do_identifier (expr, 1);\n+\n+  return expr;\n+}\n+\n+/* Begin a new-placement.  */\n+\n+int\n+begin_new_placement ()\n+{\n+  /* The arguments to a placement new might be passed to a\n+     deallocation function, in the event that the allocation throws an\n+     exception.  Since we don't expand exception handlers until the\n+     end of a function, we must make sure the arguments stay around\n+     that long.  */\n+  return suspend_momentary ();\n+}\n+\n+/* Finish a new-placement.  The ARGS are the placement arguments.  The\n+   COOKIE is the value returned by the previous call to\n+   begin_new_placement.  */\n+\n+tree\n+finish_new_placement (args, cookie)\n+     tree args;\n+     int cookie;\n+{\n+  resume_momentary (cookie);\n+  return args;\n+}\n+\n /* Begin a function defniition declared with DECL_SPECS and\n    DECLARATOR.  Returns non-zero if the function-declaration is\n    legal.  */\n@@ -1031,6 +1087,35 @@ begin_constructor_declarator (scope, name)\n   return result;\n }\n \n+/* Finish an init-declarator.  Returns a DECL.  */\n+\n+tree\n+finish_declarator (declarator, declspecs, attributes,\n+\t\t   prefix_attributes, initialized)\n+     tree declarator;\n+     tree declspecs;\n+     tree attributes;\n+     tree prefix_attributes;\n+     int initialized;\n+{\n+  return start_decl (declarator, declspecs, initialized, attributes,\n+\t\t     prefix_attributes); \n+}\n+\n+/* Finish a transltation unit.  */\n+\n+void \n+finish_translation_unit ()\n+{\n+  /* In case there were missing closebraces,\n+     get us back to the global binding level.  */\n+  while (! toplevel_bindings_p ())\n+    poplevel (0, 0, 0);\n+  while (current_namespace != global_namespace)\n+    pop_namespace ();\n+  finish_file ();\n+}\n+\n /* Finish a template type parameter, specified as AGGR IDENTIFIER.\n    Returns the parameter.  */\n \n@@ -1067,3 +1152,182 @@ finish_template_template_parm (aggr, identifier)\n \n   return finish_template_type_parm (aggr, tmpl);\n }\n+\n+/* Finish a parameter list, indicated by PARMS.  If ELLIPSIS is\n+   non-zero, the parameter list was terminated by a `...'.  */\n+\n+tree\n+finish_parmlist (parms, ellipsis)\n+     tree parms;\n+     int ellipsis;\n+{\n+  if (!ellipsis)\n+    chainon (parms, void_list_node);\n+  /* We mark the PARMS as a parmlist so that declarator processing can\n+     disambiguate certain constructs.  */\n+  if (parms != NULL_TREE)\n+    TREE_PARMLIST (parms) = 1;\n+\n+  return parms;\n+}\n+\n+/* Begin a class definition, as indicated by T.  */\n+\n+tree\n+begin_class_definition (t)\n+     tree t;\n+{\n+  tree new_type = t;\n+\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+  \n+  if (t == error_mark_node\n+      || ! IS_AGGR_TYPE (t))\n+    {\n+      t = new_type = make_lang_type (RECORD_TYPE);\n+      pushtag (make_anon_name (), t, 0);\n+    }\n+  if (TYPE_SIZE (t))\n+    duplicate_tag_error (t);\n+  if (TYPE_SIZE (t) || TYPE_BEING_DEFINED (t))\n+    {\n+      t = make_lang_type (TREE_CODE (t));\n+      pushtag (TYPE_IDENTIFIER (t), t, 0);\n+      new_type = t;\n+    }\n+  if (processing_template_decl && TYPE_CONTEXT (t)\n+      && TREE_CODE (TYPE_CONTEXT (t)) != NAMESPACE_DECL\n+      && ! current_class_type)\n+    push_template_decl (TYPE_STUB_DECL (t));\n+  pushclass (t, 0);\n+  TYPE_BEING_DEFINED (t) = 1;\n+  if (IS_AGGR_TYPE (t) && CLASSTYPE_USE_TEMPLATE (t))\n+    {\n+      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)\n+\t  && TYPE_SIZE (t) == NULL_TREE)\n+\t{\n+\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n+\t  if (processing_template_decl)\n+\t    push_template_decl (TYPE_MAIN_DECL (t));\n+\t}\n+      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n+\tcp_error (\"specialization after instantiation of `%T'\", t);\n+    }\n+  /* Reset the interface data, at the earliest possible\n+     moment, as it might have been set via a class foo;\n+     before.  */\n+  /* Don't change signatures.  */\n+  if (! IS_SIGNATURE (t))\n+    {\n+      extern tree pending_vtables;\n+      int needs_writing;\n+      tree name = TYPE_IDENTIFIER (t);\n+      \n+      if (! ANON_AGGRNAME_P (name))\n+\t{\n+\t  CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+\t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n+\t    (t, interface_unknown);\n+\t}\n+      \n+      /* Record how to set the access of this class's\n+\t virtual functions.  If write_virtuals == 2 or 3, then\n+\t inline virtuals are ``extern inline''.  */\n+      switch (write_virtuals)\n+\t{\n+\tcase 0:\n+\tcase 1:\n+\t  needs_writing = 1;\n+\t  break;\n+\tcase 2:\n+\t  needs_writing = !! value_member (name, pending_vtables);\n+\t  break;\n+\tcase 3:\n+\t  needs_writing = ! CLASSTYPE_INTERFACE_ONLY (t)\n+\t    && CLASSTYPE_INTERFACE_KNOWN (t);\n+\t  break;\n+\tdefault:\n+\t  needs_writing = 0;\n+\t}\n+      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = needs_writing;\n+    }\n+#if 0\n+  t = TYPE_IDENTIFIER ($<ttype>0);\n+  if (t && IDENTIFIER_TEMPLATE (t))\n+    overload_template_name (t, 1);\n+#endif\n+  reset_specialization();\n+  \n+  /* In case this is a local class within a template\n+     function, we save the current tree structure so\n+     that we can get it back later.  */\n+  begin_tree ();\n+\n+  return new_type;\n+}\n+\n+/* Finish a class definition T, with the indicated COMPONENTS, and\n+   with the indicate ATTRIBUTES.  If SEMI, the definition is\n+   immediately followed by a semicolon.  Returns the type.  */\n+\n+tree\n+finish_class_definition (t, components, attributes, semi)\n+     tree t;\n+     tree components;\n+     tree attributes;\n+     int semi;\n+{\n+#if 0\n+  /* Need to rework class nesting in the presence of nested classes,\n+     etc.  */\n+  shadow_tag (CLASSTYPE_AS_LIST (t)); */\n+#endif\n+\n+  /* finish_struct nukes this anyway; if finish_exception does too,\n+     then it can go.  */\n+  if (semi)\n+    note_got_semicolon (t);\n+\n+  if (TREE_CODE (t) == ENUMERAL_TYPE)\n+    ;\n+  else\n+    {\n+      t = finish_struct (t, components, attributes, semi);\n+      if (semi) \n+\tnote_got_semicolon (t);\n+    }\n+\n+  pop_obstacks ();\n+\n+  if (! semi)\n+    check_for_missing_semicolon (t); \n+  if (current_scope () == current_function_decl)\n+    do_pending_defargs ();\n+\n+  return t;\n+}\n+\n+/* Finish processing the default argument expressions cached during\n+   the processing of a class definition.  */\n+\n+void\n+finish_default_args ()\n+{\n+  if (pending_inlines \n+      && current_scope () == current_function_decl)\n+    do_pending_inlines ();\n+}\n+\n+/* Finish processing the inline function definitions cached during the\n+   processing of a class definition.  */\n+\n+void\n+begin_inline_definitions ()\n+{\n+  if (current_class_type == NULL_TREE)\n+    clear_inline_text_obstack (); \n+  \n+  /* Undo the begin_tree in begin_class_definition.  */\n+  end_tree ();\n+}"}, {"sha": "829db70e868eca6dbf3556fe023d160ba03a2b85", "filename": "gcc/testsuite/g++.old-deja/g++.other/new.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a03916c76227660f5d388bd93c221185cfd24/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew.C?ref=ce4a03916c76227660f5d388bd93c221185cfd24", "patch": "@@ -0,0 +1,57 @@\n+// Build don't link:\n+\n+typedef unsigned int size_t;\n+inline void *\n+operator new(size_t alloc_sz, const char *fname, unsigned lineno)\n+{\n+}\n+inline void *\n+operator new[](size_t alloc_sz, const char *fname, unsigned lineno) \n+{\n+}\n+inline void\n+operator delete(void *ptr, const char *fname, unsigned lineno) \n+{\n+}\n+inline void\n+operator delete[](void *ptr, const char *fname, unsigned lineno)\n+{\n+}\n+\n+class DEF {\t\t\t\t\t\t \n+public:\n+    DEF( DEF *parent=0, const char *name=0 );\n+};\n+\n+class ABC\n+{\n+public:\n+    enum stuff { ID0, ID1 };\n+    ABC( stuff, DEF *parent=0, const char *name=0 );\n+};\n+\n+class GHI : public DEF\t\t\t \n+{\n+};\n+\n+class LMNFrame;\n+class LMN : public DEF\n+{\n+  friend class LMNFrame;\n+  public:\n+public:\n+  LMN();\n+private:\n+  LMNFrame *draw_area;\n+\t\t\t\t \n+  ABC *scroll_h;\t\t \n+};\n+class LMNFrame : public GHI {\n+};\n+LMN::LMN()\n+{\n+  draw_area = new (\"abc\", 69) LMNFrame;\n+\t\t\t\t \n+  scroll_h = new (\"def\", 71)  ABC(ABC::ID0, this);\n+}\n+"}]}