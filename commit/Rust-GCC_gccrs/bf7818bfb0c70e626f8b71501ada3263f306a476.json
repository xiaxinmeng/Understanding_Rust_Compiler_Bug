{"sha": "bf7818bfb0c70e626f8b71501ada3263f306a476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY3ODE4YmZiMGM3MGU2MjZmOGI3MTUwMWFkYTMyNjNmMzA2YTQ3Ng==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2015-06-30T13:26:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-06-30T13:26:49Z"}, "message": "Implement N4387, \"Improving pair and tuple\", and LWG 2367.\n\n2015-06-30  Ville Voutilainen  <ville.voutilainen@gmail.com>\n\n\tImplement N4387, \"Improving pair and tuple\", and LWG 2367.\n\n\t* include/bits/stl_pair.h (_ConstructiblePair,\n\t_ImplicitlyConvertiblePair, _MoveConstructiblePair,\n\t_ImplicitlyMoveConvertiblePair): New.\n\t(pair()): Constrain it.\n\t(pair(const _T1&, const _T2&), pair(const pair<_U1, _U2>&),\n\tpair(_U1&&, const _T2&), pair(const _T1&, _U2&&), pair(_U1&&, _U2&&),\n\tpair(pair<_U1, _U2>&&)): Make conditionally explicit.\n\t* include/std/tuple (_TC, tuple::_TC2, tuple::TCC, tuple::TMC): New.\n\t(tuple()): Constrain it.\n\t(tuple(const _UElements&...), tuple(_UElements&&...),\n\ttuple(const tuple<_UElements...>&), tuple(tuple<_UElements...>&&),\n\ttuple(allocator_arg_t, const _Alloc&, const _UElements&...),\n\ttuple(allocator_arg_t, const _Alloc&, _UElements&&...),\n\ttuple(allocator_arg_t, const _Alloc&, const tuple<_UElements...>&),\n\ttuple(allocator_arg_t, const _Alloc&, tuple<_UElements...>&&),\n\ttuple(const pair<_U1, _U2>&), tuple(pair<_U1, _U2>&&),\n\ttuple(allocator_arg_t, const _Alloc&, const pair<_U1, _U2>&),\n\ttuple(allocator_arg_t, const _Alloc&, pair<_U1, _U2>&&)): Make\n\tconditionally explicit.\n\t* include/experimental/functional (__boyer_moore_array_base): Name\n\tarray type explicitly instead of using an empty braced-init-list.\n\t* testsuite/20_util/pair/cons/explicit_construct.cc: New.\n\t* testsuite/20_util/pair/piecewise.cc: Use piecewise_construct.\n\t* testsuite/20_util/pair/requirements/dr2367.cc: New.\n\t* testsuite/20_util/tuple/cons/explicit_construct.cc: New.\n\t* testsuite/20_util/tuple/requirements/dr2367.cc: New.\n\nFrom-SVN: r225189", "tree": {"sha": "5770dbb72d84d352966d13e54956bd6d597dfcd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5770dbb72d84d352966d13e54956bd6d597dfcd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf7818bfb0c70e626f8b71501ada3263f306a476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7818bfb0c70e626f8b71501ada3263f306a476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf7818bfb0c70e626f8b71501ada3263f306a476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7818bfb0c70e626f8b71501ada3263f306a476/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe95b0366a02855988d4c626de2045dae6e11502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe95b0366a02855988d4c626de2045dae6e11502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe95b0366a02855988d4c626de2045dae6e11502"}], "stats": {"total": 1165, "additions": 1091, "deletions": 74}, "files": [{"sha": "3a3192fabb64827d9fd6024f7887a38c1d733685", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -1,3 +1,34 @@\n+2015-06-30  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement N4387, \"Improving pair and tuple\", and LWG 2367.\n+\n+\t* include/bits/stl_pair.h (_ConstructiblePair,\n+\t_ImplicitlyConvertiblePair, _MoveConstructiblePair,\n+\t_ImplicitlyMoveConvertiblePair): New.\n+\t(pair()): Constrain it.\n+\t(pair(const _T1&, const _T2&), pair(const pair<_U1, _U2>&),\n+\tpair(_U1&&, const _T2&), pair(const _T1&, _U2&&), pair(_U1&&, _U2&&),\n+\tpair(pair<_U1, _U2>&&)): Make conditionally explicit.\n+\t* include/std/tuple (_TC, tuple::_TC2, tuple::TCC, tuple::TMC): New.\n+\t(tuple()): Constrain it.\n+\t(tuple(const _UElements&...), tuple(_UElements&&...),\n+\ttuple(const tuple<_UElements...>&), tuple(tuple<_UElements...>&&),\n+\ttuple(allocator_arg_t, const _Alloc&, const _UElements&...),\n+\ttuple(allocator_arg_t, const _Alloc&, _UElements&&...),\n+\ttuple(allocator_arg_t, const _Alloc&, const tuple<_UElements...>&),\n+\ttuple(allocator_arg_t, const _Alloc&, tuple<_UElements...>&&),\n+\ttuple(const pair<_U1, _U2>&), tuple(pair<_U1, _U2>&&),\n+\ttuple(allocator_arg_t, const _Alloc&, const pair<_U1, _U2>&),\n+\ttuple(allocator_arg_t, const _Alloc&, pair<_U1, _U2>&&)): Make\n+\tconditionally explicit.\n+\t* include/experimental/functional (__boyer_moore_array_base): Name\n+\tarray type explicitly instead of using an empty braced-init-list.\n+\t* testsuite/20_util/pair/cons/explicit_construct.cc: New.\n+\t* testsuite/20_util/pair/piecewise.cc: Use piecewise_construct.\n+\t* testsuite/20_util/pair/requirements/dr2367.cc: New.\n+\t* testsuite/20_util/tuple/cons/explicit_construct.cc: New.\n+\t* testsuite/20_util/tuple/requirements/dr2367.cc: New.\n+\n 2015-06-30  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* configure: Regenerate."}, {"sha": "6672ecb227377d199df830bc475f6ebecd03beed", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 137, "deletions": 21, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -84,6 +84,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<std::size_t...>\n     struct _Index_tuple;\n+\n+  // Concept utility functions, reused in conditionally-explicit\n+  // constructors.\n+  template <typename _T1, typename _T2, typename _U1, typename _U2>\n+  constexpr bool _ConstructiblePair()\n+  {\n+    return __and_<is_constructible<_T1, const _U1&>,\n+\t\t  is_constructible<_T2, const _U2&>>::value;\n+  }\n+\n+  template <typename _T1, typename _T2, typename _U1, typename _U2>\n+  constexpr bool _ImplicitlyConvertiblePair()\n+  {\n+    return __and_<is_convertible<const _U1&, _T1>,\n+\t\t  is_convertible<const _U2&, _T2>>::value;\n+  }\n+\n+  template <typename _T1, typename _T2, typename _U1, typename _U2>\n+  constexpr bool _MoveConstructiblePair()\n+  {\n+    return __and_<is_constructible<_T1, _U1&&>,\n+\t\t  is_constructible<_T2, _U2&&>>::value;\n+  }\n+\n+  template <typename _T1, typename _T2, typename _U1, typename _U2>\n+  constexpr bool _ImplicitlyMoveConvertiblePair()\n+  {\n+    return __and_<is_convertible<_U1&&, _T1>,\n+\t\t  is_convertible<_U2&&, _T2>>::value;\n+  }\n+\n+\n #endif\n \n  /**\n@@ -105,52 +137,136 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // 265.  std::pair::pair() effects overly restrictive\n       /** The default constructor creates @c first and @c second using their\n        *  respective default constructors.  */\n+#if __cplusplus >= 201103L\n+      template <typename _U1 = _T1,\n+                typename _U2 = _T2,\n+                typename enable_if<__and_<\n+                                     is_default_constructible<_U1>,\n+                                     is_default_constructible<_U2>>\n+                                   ::value, bool>::type = true>\n+#endif\n       _GLIBCXX_CONSTEXPR pair()\n       : first(), second() { }\n \n       /** Two objects may be passed to a @c pair constructor to be copied.  */\n-      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)\n+#if __cplusplus < 201103L\n+      pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) { }\n+#else\n+      template<typename _U1 = _T1, typename _U2=_T2, typename\n+                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+                         bool>::type=true>\n+      constexpr pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n \n+       template<typename _U1 = _T1, typename _U2=_T2, typename\n+\t       enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+                         bool>::type=false>\n+      explicit constexpr pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) { }\n+#endif\n+\n       /** There is also a templated copy ctor for the @c pair class itself.  */\n #if __cplusplus < 201103L\n       template<class _U1, class _U2>\n \tpair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n #else\n-      template<class _U1, class _U2, class = typename\n-\t       enable_if<__and_<is_convertible<const _U1&, _T1>,\n-\t\t\t\tis_convertible<const _U2&, _T2>>::value>::type>\n-\tconstexpr pair(const pair<_U1, _U2>& __p)\n+      template<class _U1, class _U2, typename\n+\t       enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+                         bool>::type=true>\n+        constexpr pair(const pair<_U1, _U2>& __p)\n+        : first(__p.first), second(__p.second) { }\n+\n+      template<class _U1, class _U2, typename\n+               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),\n+                         bool>::type=false>\n+\texplicit constexpr pair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n \n       constexpr pair(const pair&) = default;\n       constexpr pair(pair&&) = default;\n \n       // DR 811.\n-      template<class _U1, class = typename\n-\t       enable_if<is_convertible<_U1, _T1>::value>::type>\n-\tconstexpr pair(_U1&& __x, const _T2& __y)\n-\t: first(std::forward<_U1>(__x)), second(__y) { }\n-\n-      template<class _U2, class = typename\n-\t       enable_if<is_convertible<_U2, _T2>::value>::type>\n-\tconstexpr pair(const _T1& __x, _U2&& __y)\n-\t: first(__x), second(std::forward<_U2>(__y)) { }\n-\n-      template<class _U1, class _U2, class = typename\n-\t       enable_if<__and_<is_convertible<_U1, _T1>,\n-\t\t\t\tis_convertible<_U2, _T2>>::value>::type>\n+      template<class _U1, typename\n+               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()\n+                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()\n+                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()\n+                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n+\t\t\t\t\t\t\t  _U1, _T2>(),\n+                         bool>::type=true>\n+       constexpr pair(_U1&& __x, const _T2& __y)\n+       : first(std::forward<_U1>(__x)), second(__y) { }\n+\n+      template<class _U1, typename\n+               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()\n+                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()\n+                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()\n+                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n+                                                                _U1, _T2>()),\n+                         bool>::type=false>\n+       explicit constexpr pair(_U1&& __x, const _T2& __y)\n+       : first(std::forward<_U1>(__x)), second(__y) { }\n+\n+      template<class _U2, typename\n+               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()\n+                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()\n+                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()\n+                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n+                                                           _T1, _U2>(),\n+                         bool>::type=true>\n+       constexpr pair(const _T1& __x, _U2&& __y)\n+       : first(__x), second(std::forward<_U2>(__y)) { }\n+\n+      template<class _U2, typename\n+               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()\n+                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()\n+                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()\n+                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n+                                                                _T1, _U2>()),\n+                         bool>::type=false>\n+       explicit pair(const _T1& __x, _U2&& __y)\n+       : first(__x), second(std::forward<_U2>(__y)) { }\n+\n+      template<class _U1, class _U2, typename\n+\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n+\t\t\t\t\t\t\t   _U1, _U2>(),\n+                         bool>::type=true>\n \tconstexpr pair(_U1&& __x, _U2&& __y)\n \t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n \n-      template<class _U1, class _U2, class = typename\n-\t       enable_if<__and_<is_convertible<_U1, _T1>,\n-\t\t\t\tis_convertible<_U2, _T2>>::value>::type>\n+      template<class _U1, class _U2, typename\n+\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n+\t\t\t\t\t\t\t    _U1, _U2>(),\n+                         bool>::type=false>\n+\texplicit constexpr pair(_U1&& __x, _U2&& __y)\n+\t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }\n+\n+\n+      template<class _U1, class _U2, typename\n+\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,\n+\t\t\t\t\t\t\t   _U1, _U2>(),\n+                         bool>::type=true>\n \tconstexpr pair(pair<_U1, _U2>&& __p)\n \t: first(std::forward<_U1>(__p.first)),\n \t  second(std::forward<_U2>(__p.second)) { }\n \n+      template<class _U1, class _U2, typename\n+\t       enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()\n+                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,\n+\t\t\t\t\t\t\t   _U1, _U2>(),\n+                         bool>::type=false>\n+\texplicit constexpr pair(pair<_U1, _U2>&& __p)\n+\t: first(std::forward<_U1>(__p.first)),\n+\t  second(std::forward<_U2>(__p.second)) { }\n+\n       template<typename... _Args1, typename... _Args2>\n         pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);\n "}, {"sha": "c6b9800f7a6f1083da906d5d5e4bbf9ac0c4a75c", "filename": "libstdc++-v3/include/experimental/functional", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffunctional?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _RAIter, typename _Unused>\n \t__boyer_moore_array_base(_RAIter __pat, size_t __patlen,\n \t\t\t\t _Unused&&, _Pred&& __pred)\n-\t: _M_bad_char{ {}, std::move(__pred) }\n+\t: _M_bad_char{ std::array<_Tp, _Len>{}, std::move(__pred) }\n \t{\n \t  std::get<0>(_M_bad_char).fill(__patlen);\n \t  if (__patlen > 0)"}, {"sha": "59b992a4a06a40e8c35bc579b0d41966d0d3fc60", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 441, "deletions": 49, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -457,63 +457,236 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+\n+  // Concept utility functions, reused in conditionally-explicit\n+  // constructors.\n+  template<bool, typename... _Elements>\n+  struct _TC\n+  {\n+    template<typename... _UElements>\n+    static constexpr bool _ConstructibleTuple()\n+    {\n+      return __and_<is_constructible<_Elements, const _UElements&>...>::value;\n+    }\n+\n+    template<typename... _UElements>\n+    static constexpr bool _ImplicitlyConvertibleTuple()\n+    {\n+      return __and_<is_convertible<const _UElements&, _Elements>...>::value;\n+    }\n+\n+    template<typename... _UElements>\n+    static constexpr bool _MoveConstructibleTuple()\n+    {\n+      return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n+    }\n+\n+    template<typename... _UElements>\n+    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n+    {\n+      return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n+    }\n+  };\n+\n+  template<typename... _Elements>\n+  struct _TC<false, _Elements...>\n+  {\n+    template<typename... _UElements>\n+    static constexpr bool _ConstructibleTuple()\n+    {\n+      return false;\n+    }\n+\n+    template<typename... _UElements>\n+    static constexpr bool _ImplicitlyConvertibleTuple()\n+    {\n+      return false;\n+    }\n+\n+    template<typename... _UElements>\n+    static constexpr bool _MoveConstructibleTuple()\n+    {\n+      return false;\n+    }\n+\n+    template<typename... _UElements>\n+    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n+    {\n+      return false;\n+    }\n+  };\n+\n   /// Primary class template, tuple\n   template<typename... _Elements> \n     class tuple : public _Tuple_impl<0, _Elements...>\n     {\n       typedef _Tuple_impl<0, _Elements...> _Inherited;\n \n+      // Used for constraining the default constructor so\n+      // that it becomes dependent on the constraints.\n+      template<typename _Dummy>\n+      struct _TC2\n+      {\n+        static constexpr bool _DefaultConstructibleTuple()\n+        {\n+          return __and_<is_default_constructible<_Elements>...>::value;\n+        }\n+      };\n+\n     public:\n+      template<typename _Dummy = void,\n+               typename enable_if<_TC2<_Dummy>::\n+                                    _DefaultConstructibleTuple(),\n+                                  bool>::type = true>\n       constexpr tuple()\n       : _Inherited() { }\n \n-      explicit\n-      constexpr tuple(const _Elements&... __elements)\n+      // Shortcut for the cases where constructors taking _Elements...\n+      // need to be constrained.\n+      template<typename _Dummy> using _TCC =\n+        _TC<is_same<_Dummy, void>::value,\n+            _Elements...>;\n+\n+      template<typename _Dummy = void,\n+               typename enable_if<\n+                 _TCC<_Dummy>::template\n+                   _ConstructibleTuple<_Elements...>()\n+                 && _TCC<_Dummy>::template\n+                   _ImplicitlyConvertibleTuple<_Elements...>()\n+                 && (sizeof...(_Elements) >= 1),\n+               bool>::type=true>\n+        constexpr tuple(const _Elements&... __elements)\n       : _Inherited(__elements...) { }\n \n-      template<typename... _UElements, typename = typename\n-        enable_if<__and_<is_convertible<_UElements,\n-\t\t\t\t\t_Elements>...>::value>::type>\n-\texplicit\n+      template<typename _Dummy = void,\n+               typename enable_if<\n+                 _TCC<_Dummy>::template\n+                   _ConstructibleTuple<_Elements...>()\n+                 && !_TCC<_Dummy>::template\n+                   _ImplicitlyConvertibleTuple<_Elements...>()\n+                 && (sizeof...(_Elements) >= 1),\n+               bool>::type=false>\n+      explicit constexpr tuple(const _Elements&... __elements)\n+      : _Inherited(__elements...) { }\n+\n+      // Shortcut for the cases where constructors taking _UElements...\n+      // need to be constrained.\n+      template<typename... _UElements> using _TMC =\n+                  _TC<(sizeof...(_Elements) == sizeof...(_UElements)),\n+                      _Elements...>;\n+\n+      template<typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && _TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n+                  && (sizeof...(_Elements) >= 1),\n+        bool>::type=true>\n         constexpr tuple(_UElements&&... __elements)\n+        : _Inherited(std::forward<_UElements>(__elements)...) { }\n+\n+      template<typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && !_TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n+                  && (sizeof...(_Elements) >= 1),\n+        bool>::type=false>\n+        explicit constexpr tuple(_UElements&&... __elements)\n \t: _Inherited(std::forward<_UElements>(__elements)...) {\t}\n \n       constexpr tuple(const tuple&) = default;\n \n       constexpr tuple(tuple&&) = default; \n \n-      template<typename... _UElements, typename = typename\n-        enable_if<__and_<is_convertible<const _UElements&,\n-\t\t\t\t\t_Elements>...>::value>::type>\n+      template<typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _ConstructibleTuple<_UElements...>()\n+                  && _TMC<_UElements...>::template\n+                    _ImplicitlyConvertibleTuple<_UElements...>(),\n+        bool>::type=true>\n         constexpr tuple(const tuple<_UElements...>& __in)\n         : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n         { }\n \n-      template<typename... _UElements, typename = typename\n-        enable_if<__and_<is_convertible<_UElements,\n-\t\t\t\t\t_Elements>...>::value>::type>\n+      template<typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _ConstructibleTuple<_UElements...>()\n+                  && !_TMC<_UElements...>::template\n+                    _ImplicitlyConvertibleTuple<_UElements...>(),\n+        bool>::type=false>\n+        explicit constexpr tuple(const tuple<_UElements...>& __in)\n+        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+        { }\n+\n+      template<typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && _TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+        bool>::type=true>\n         constexpr tuple(tuple<_UElements...>&& __in)\n         : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n \n+      template<typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && !_TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+        bool>::type=false>\n+        explicit constexpr tuple(tuple<_UElements...>&& __in)\n+        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n+\n       // Allocator-extended constructors.\n \n       template<typename _Alloc>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a)\n \t: _Inherited(__tag, __a) { }\n \n-      template<typename _Alloc>\n+      template<typename _Alloc, typename _Dummy = void,\n+               typename enable_if<\n+                 _TCC<_Dummy>::template\n+                   _ConstructibleTuple<_Elements...>()\n+                 && _TCC<_Dummy>::template\n+                   _ImplicitlyConvertibleTuple<_Elements...>(),\n+               bool>::type=true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const _Elements&... __elements)\n \t: _Inherited(__tag, __a, __elements...) { }\n \n-      template<typename _Alloc, typename... _UElements, typename = typename\n-\t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)>::type>\n+      template<typename _Alloc, typename _Dummy = void,\n+               typename enable_if<\n+                 _TCC<_Dummy>::template\n+                   _ConstructibleTuple<_Elements...>()\n+                 && !_TCC<_Dummy>::template\n+                   _ImplicitlyConvertibleTuple<_Elements...>(),\n+               bool>::type=false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+                       const _Elements&... __elements)\n+\t: _Inherited(__tag, __a, __elements...) { }\n+\n+      template<typename _Alloc, typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && _TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+        bool>::type=true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      _UElements&&... __elements)\n \t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n        \t{ }\n \n+      template<typename _Alloc, typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && !_TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+        bool>::type=false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      _UElements&&... __elements)\n+\t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n+        { }\n+\n       template<typename _Alloc>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n \t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n@@ -522,24 +695,54 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n \n-      template<typename _Alloc, typename... _UElements, typename = typename\n-\t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)>::type>\n+      template<typename _Alloc, typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _ConstructibleTuple<_UElements...>()\n+                  && _TMC<_UElements...>::template\n+                    _ImplicitlyConvertibleTuple<_UElements...>(),\n+        bool>::type=true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_UElements...>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename... _UElements, typename = typename\n-\t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)>::type>\n+      template<typename _Alloc, typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _ConstructibleTuple<_UElements...>()\n+                  && !_TMC<_UElements...>::template\n+                    _ImplicitlyConvertibleTuple<_UElements...>(),\n+        bool>::type=false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const tuple<_UElements...>& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && _TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+        bool>::type=true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      tuple<_UElements...>&& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n \t{ }\n \n+      template<typename _Alloc, typename... _UElements, typename\n+        enable_if<_TMC<_UElements...>::template\n+                    _MoveConstructibleTuple<_UElements...>()\n+                  && !_TMC<_UElements...>::template\n+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n+        bool>::type=false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      tuple<_UElements...>&& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n+\t{ }\n+\n       tuple&\n       operator=(const tuple& __in)\n       {\n@@ -582,7 +785,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   // Explicit specialization, zero-element tuple.\n-  template<>  \n+  template<>\n     class tuple<>\n     {\n     public:\n@@ -597,65 +800,190 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n \n     public:\n+      template <typename _U1 = _T1,\n+                typename _U2 = _T2,\n+                typename enable_if<__and_<\n+                                     is_default_constructible<_U1>,\n+                                     is_default_constructible<_U2>>\n+                                   ::value, bool>::type = true>\n+\n       constexpr tuple()\n       : _Inherited() { }\n \n-      explicit\n-      constexpr tuple(const _T1& __a1, const _T2& __a2)\n-      : _Inherited(__a1, __a2) { }\n-\n-      template<typename _U1, typename _U2, typename = typename\n-\t       enable_if<__and_<is_convertible<_U1, _T1>,\n-\t\t\t\tis_convertible<_U2, _T2>>::value>::type>\n-        explicit\n+      // Shortcut for the cases where constructors taking _T1, _T2\n+      // need to be constrained.\n+      template<typename _Dummy> using _TCC =\n+        _TC<is_same<_Dummy, void>::value, _T1, _T2>;\n+\n+      template<typename _Dummy = void, typename\n+               enable_if<_TCC<_Dummy>::template\n+                           _ConstructibleTuple<_T1, _T2>()\n+                         && _TCC<_Dummy>::template\n+                           _ImplicitlyConvertibleTuple<_T1, _T2>(),\n+\tbool>::type = true>\n+        constexpr tuple(const _T1& __a1, const _T2& __a2)\n+        : _Inherited(__a1, __a2) { }\n+\n+      template<typename _Dummy = void, typename\n+               enable_if<_TCC<_Dummy>::template\n+                           _ConstructibleTuple<_T1, _T2>()\n+                         && !_TCC<_Dummy>::template\n+                           _ImplicitlyConvertibleTuple<_T1, _T2>(),\n+\tbool>::type = false>\n+        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)\n+        : _Inherited(__a1, __a2) { }\n+\n+      // Shortcut for the cases where constructors taking _U1, _U2\n+      // need to be constrained.\n+      using _TMC = _TC<true, _T1, _T2>;\n+\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         constexpr tuple(_U1&& __a1, _U2&& __a2)\n \t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n \n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)\n+\t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n+\n       constexpr tuple(const tuple&) = default;\n \n       constexpr tuple(tuple&&) = default;\n \n-      template<typename _U1, typename _U2, typename = typename\n-\tenable_if<__and_<is_convertible<const _U1&, _T1>,\n-\t\t\t is_convertible<const _U2&, _T2>>::value>::type>\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         constexpr tuple(const tuple<_U1, _U2>& __in)\n \t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n \n-      template<typename _U1, typename _U2, typename = typename\n-\t       enable_if<__and_<is_convertible<_U1, _T1>,\n-\t\t\t\tis_convertible<_U2, _T2>>::value>::type>\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit constexpr tuple(const tuple<_U1, _U2>& __in)\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n+\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         constexpr tuple(tuple<_U1, _U2>&& __in)\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n \n-      template<typename _U1, typename _U2, typename = typename\n-\tenable_if<__and_<is_convertible<const _U1&, _T1>,\n-\t\t\t is_convertible<const _U2&, _T2>>::value>::type>\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit constexpr tuple(tuple<_U1, _U2>&& __in)\n+\t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n+\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         constexpr tuple(const pair<_U1, _U2>& __in)\n \t: _Inherited(__in.first, __in.second) { }\n \n-      template<typename _U1, typename _U2, typename = typename\n-\t       enable_if<__and_<is_convertible<_U1, _T1>,\n-\t\t\t\tis_convertible<_U2, _T2>>::value>::type>\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit constexpr tuple(const pair<_U1, _U2>& __in)\n+\t: _Inherited(__in.first, __in.second) { }\n+\n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         constexpr tuple(pair<_U1, _U2>&& __in)\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n+      template<typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit constexpr tuple(pair<_U1, _U2>&& __in)\n+\t: _Inherited(std::forward<_U1>(__in.first),\n+\t\t     std::forward<_U2>(__in.second)) { }\n+\n       // Allocator-extended constructors.\n \n       template<typename _Alloc>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a)\n \t: _Inherited(__tag, __a) { }\n \n-      template<typename _Alloc>\n+      template<typename _Alloc, typename _Dummy = void,\n+               typename enable_if<\n+                 _TCC<_Dummy>::template\n+                   _ConstructibleTuple<_T1, _T2>()\n+                 && _TCC<_Dummy>::template\n+                   _ImplicitlyConvertibleTuple<_T1, _T2>(),\n+               bool>::type=true>\n+\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const _T1& __a1, const _T2& __a2)\n \t: _Inherited(__tag, __a, __a1, __a2) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2>\n+      template<typename _Alloc, typename _Dummy = void,\n+               typename enable_if<\n+                 _TCC<_Dummy>::template\n+                   _ConstructibleTuple<_T1, _T2>()\n+                 && !_TCC<_Dummy>::template\n+                   _ImplicitlyConvertibleTuple<_T1, _T2>(),\n+               bool>::type=false>\n+\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const _T1& __a1, const _T2& __a2)\n+\t: _Inherited(__tag, __a, __a1, __a2) { }\n+\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)\n \t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n \t             std::forward<_U2>(__a2)) { }\n \n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+                       _U1&& __a1, _U2&& __a2)\n+\t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n+\t             std::forward<_U2>(__a2)) { }\n+\n       template<typename _Alloc>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n \t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n@@ -664,28 +992,92 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2>\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_U1, _U2>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _U1, typename _U2>\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const tuple<_U1, _U2>& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _U1, typename _U2>\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+                       tuple<_U1, _U2>&& __in)\n+\t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         tuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const pair<_U1, _U2>& __in)\n \t: _Inherited(__tag, __a, __in.first, __in.second) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2>\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _ConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const pair<_U1, _U2>& __in)\n+\t: _Inherited(__tag, __a, __in.first, __in.second) { }\n+\n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && _TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = true>\n         tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n \t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n+      template<typename _Alloc, typename _U1, typename _U2, typename\n+        enable_if<_TMC::template\n+                    _MoveConstructibleTuple<_U1, _U2>()\n+                  && !_TMC::template\n+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n+\tbool>::type = false>\n+        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+                       pair<_U1, _U2>&& __in)\n+\t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n+\t\t     std::forward<_U2>(__in.second)) { }\n+\n       tuple&\n       operator=(const tuple& __in)\n       {"}, {"sha": "50edda9151a26bb50ab914b58a8479c1ab62e8f5", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/explicit_construct.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -0,0 +1,108 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+\n+struct Explicit\n+{\n+  Explicit() = default;\n+  explicit Explicit(int) {}\n+};\n+\n+std::pair<int, int> f1() {return {1,2};}\n+\n+std::pair<Explicit, Explicit> f2() {return {1,2};} // { dg-error \"explicit\" }\n+\n+std::pair<long, long> f3() {return std::pair<int, int>{1,2};}\n+\n+std::pair<Explicit, Explicit> f4()\n+{\n+  return std::pair<int, int>{1,2};  // { dg-error \"could not convert\" }\n+}\n+\n+std::pair<long, long> f5() {return {1,2};}\n+\n+std::pair<int, int> v0{1,2};\n+\n+std::pair<Explicit, Explicit> v1{1,2};\n+\n+std::pair<Explicit, Explicit> v2 = {1,2}; // { dg-error \"explicit\" }\n+\n+std::pair<Explicit, Explicit> v3{std::pair<int,int>{1,2}};\n+\n+std::pair<Explicit, Explicit> v4 =\n+  std::pair<int,int>{1,2}; // { dg-error \"conversion\" }\n+\n+std::pair<char *, char *> v5(0,0);\n+\n+std::pair<long, long> v6{1,2};\n+\n+std::pair<long, long> v7 = {1,2};\n+\n+std::pair<long, long> v8{std::pair<int,int>{1,2}};\n+\n+std::pair<long, long> v9 = std::pair<int,int>{1,2};\n+\n+std::pair<Explicit, Explicit> v10{v0};\n+\n+std::pair<Explicit, Explicit> v11 = v0; // { dg-error \"conversion\" }\n+\n+std::pair<long, long> v12{v0};\n+\n+std::pair<long, long> v13 = v0;\n+\n+void f6(std::pair<Explicit, Explicit>) {}\n+\n+void f7(std::pair<long, long>) {}\n+\n+void test_arg_passing()\n+{\n+  f6(v0); // { dg-error \"could not convert\" }\n+  f6(v1);\n+  f6({1,2}); // { dg-error \"explicit\" }\n+  f6(std::pair<Explicit, Explicit>{});\n+  f6(std::pair<int, int>{}); // { dg-error \"could not convert\" }\n+  f7(v0);\n+  f7(v6);\n+  f7({1,2});\n+  f7(std::pair<int, int>{});\n+  f7(std::pair<long, long>{});\n+}\n+\n+struct MoveOnly\n+{\n+  MoveOnly() = default;\n+  MoveOnly(MoveOnly&&) {}\n+};\n+\n+struct ExplicitMoveOnly\n+{\n+  ExplicitMoveOnly() = default;\n+  ExplicitMoveOnly(ExplicitMoveOnly&&) {}\n+  explicit ExplicitMoveOnly(MoveOnly&&) {}\n+};\n+\n+std::pair<int*, ExplicitMoveOnly> v14{0, MoveOnly{}};\n+std::pair<ExplicitMoveOnly, int*> v15{MoveOnly{}, 0};\n+\n+std::pair<int*, ExplicitMoveOnly> v16 =\n+  {0, MoveOnly{}}; // { dg-error \"explicit\" }\n+std::pair<ExplicitMoveOnly, int*> v17 =\n+  {MoveOnly{}, 0}; // { dg-error \"explicit\" }"}, {"sha": "40ab16b14b920152d6032ee197b6d7137a3e8c82", "filename": "libstdc++-v3/testsuite/20_util/pair/piecewise.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fpiecewise.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fpiecewise.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fpiecewise.cc?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -69,20 +69,20 @@ void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::pair<type_one, type_zero> pp0(std::piecewise_construct_t(),\n+  std::pair<type_one, type_zero> pp0(std::piecewise_construct,\n \t\t\t\t     std::forward_as_tuple(-3),\n \t\t\t\t     std::forward_as_tuple());\n   VERIFY( pp0.first.get() == -3 );\n   VERIFY( pp0.second.get() == 757 );\n \n-  std::pair<type_one, type_two> pp1(std::piecewise_construct_t(),\n+  std::pair<type_one, type_two> pp1(std::piecewise_construct,\n \t\t\t\t    std::forward_as_tuple(6),\n \t\t\t\t    std::forward_as_tuple(5, 4));\n   VERIFY( pp1.first.get() == 6 );\n   VERIFY( pp1.second.get1() == 5 );\n   VERIFY( pp1.second.get2() == 4 );\n \n-  std::pair<type_two, type_two> pp2(std::piecewise_construct_t(),\n+  std::pair<type_two, type_two> pp2(std::piecewise_construct,\n \t\t\t\t    std::forward_as_tuple(2, 1),\n \t\t\t\t    std::forward_as_tuple(-1, -3));\n   VERIFY( pp2.first.get1() == 2 );"}, {"sha": "603b7c5707412ad8ca3769c351308006a27a3025", "filename": "libstdc++-v3/testsuite/20_util/pair/requirements/dr2367.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Frequirements%2Fdr2367.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Frequirements%2Fdr2367.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Frequirements%2Fdr2367.cc?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <type_traits>\n+\n+// DR 2367, pair and tuple are not correctly implemented for is_constructible with no args\n+void test_default_constructible()\n+{\n+  struct X\n+  {\n+    X() = delete;\n+  };\n+\n+  typedef std::pair<int, X> P;\n+  static_assert(!std::is_constructible<P>::value, \"\");\n+  static_assert(!std::is_default_constructible<P>::value, \"\");\n+}\n+\n+int main()\n+{\n+  test_default_constructible();\n+  return 0;\n+}"}, {"sha": "114a4906f1f6d58ee93c104ec8942b6ecdeb3bd4", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/explicit_construct.cc", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fexplicit_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fexplicit_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fexplicit_construct.cc?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -0,0 +1,282 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+#include <utility>\n+#include <memory>\n+\n+struct Explicit\n+{\n+  Explicit() = default;\n+  explicit Explicit(int) {}\n+};\n+\n+std::tuple<int> f1a() {return {1};}\n+std::tuple<int, int> f1b() {return {1,2};}\n+std::tuple<int, int, int> f1c() {return {1,2,3};}\n+\n+std::tuple<Explicit> f2_a() {return {1};} // { dg-error \"explicit\" }\n+std::tuple<Explicit, Explicit> f2_b() {return {1,2};} // { dg-error \"explicit\" }\n+std::tuple<Explicit, Explicit, Explicit> f2_c() {return {1,2,3};} // { dg-error \"explicit\" }\n+\n+std::tuple<long> f3_a() {return std::tuple<int>{1};}\n+std::tuple<long, long> f3_b() {return std::tuple<int, int>{1,2};}\n+std::tuple<long, long, long> f3_c() {return std::tuple<int, int, int>{1,2,3};}\n+\n+std::tuple<Explicit> f4_a()\n+{\n+  return std::tuple<int>{1};  // { dg-error \"could not convert\" }\n+}\n+std::tuple<Explicit, Explicit> f4_b()\n+{\n+  return std::tuple<int, int>{1,2};  // { dg-error \"could not convert\" }\n+}\n+std::tuple<Explicit, Explicit, Explicit> f4_c()\n+{\n+  return std::tuple<int, int,int>{1,2,3};  // { dg-error \"could not convert\" }\n+}\n+\n+std::tuple<long> f5_a() {return {1};}\n+std::tuple<long, long> f5_b() {return {1,2};}\n+std::tuple<long, long, long> f5_c() {return {1,2,3};}\n+\n+std::tuple<int, int> fp1() {return std::pair<int, int>{1,2}; }\n+std::tuple<long, long> fp2() {return std::pair<int, int>{1,2}; }\n+std::tuple<Explicit, Explicit> fp3()\n+  {return std::pair<int, int>{1,2}; } // { dg-error \"could not convert\" }\n+\n+std::tuple<int> v0_a{1};\n+std::tuple<int, int> v0_b{1,2};\n+std::tuple<int, int, int> v0_c{1,2,3};\n+\n+std::tuple<Explicit> v1_a{1};\n+std::tuple<Explicit, Explicit> v1_b{1,2};\n+std::tuple<Explicit, Explicit, Explicit> v1_c{1,2,3};\n+\n+std::tuple<Explicit> v2_a = {1}; // { dg-error \"explicit\" }\n+std::tuple<Explicit, Explicit> v2_b = {1,2}; // { dg-error \"explicit\" }\n+std::tuple<Explicit, Explicit, Explicit> v2_c = {1,2,3}; // { dg-error \"explicit\" }\n+\n+std::tuple<Explicit> v3_a{std::tuple<int>{1}};\n+std::tuple<Explicit, Explicit> v3_b{std::tuple<int,int>{1,2}};\n+std::tuple<Explicit, Explicit, Explicit> v3_c{std::tuple<int,int,int>{1,2,3}};\n+\n+std::tuple<Explicit, Explicit> v4_a =\n+  std::tuple<int>{1}; // { dg-error \"conversion\" }\n+std::tuple<Explicit, Explicit> v4_b =\n+  std::tuple<int,int>{1,2}; // { dg-error \"conversion\" }\n+std::tuple<Explicit, Explicit, Explicit> v4_c =\n+  std::tuple<int,int,int>{1,2,3}; // { dg-error \"conversion\" }\n+\n+std::tuple<long> v6_a{1};\n+std::tuple<long, long> v6_b{1,2};\n+std::tuple<long, long, long> v6_c{1,2,3};\n+\n+std::tuple<long> v7_a = {1};\n+std::tuple<long, long> v7_b = {1,2};\n+std::tuple<long, long, long> v7_c = {1,2,3};\n+\n+std::tuple<long> v8_a{std::tuple<int>{1}};\n+std::tuple<long, long> v8_b{std::tuple<int,int>{1,2}};\n+std::tuple<long, long, long> v8_c{std::tuple<int,int,int>{1,2,3}};\n+\n+std::tuple<long> v9_a = std::tuple<int>{1};\n+std::tuple<long, long> v9_b = std::tuple<int,int>{1,2};\n+std::tuple<long, long, long> v9_c = std::tuple<int,int,int>{1,2,3};\n+\n+std::tuple<Explicit> v10_a{v0_a};\n+std::tuple<Explicit, Explicit> v10_b{v0_b};\n+std::tuple<Explicit, Explicit, Explicit> v10_c{v0_c};\n+\n+std::tuple<Explicit> v11_a = v0_a; // { dg-error \"conversion\" }\n+std::tuple<Explicit, Explicit> v11_b = v0_b; // { dg-error \"conversion\" }\n+std::tuple<Explicit, Explicit, Explicit> v11_c\n+  = v0_c; // { dg-error \"conversion\" }\n+\n+std::tuple<long> v12_a{v0_a};\n+std::tuple<long, long> v12_b{v0_b};\n+std::tuple<long, long, long> v12_c{v0_c};\n+\n+std::tuple<long> v13_a = v0_a;\n+std::tuple<long, long> v13_b = v0_b;\n+std::tuple<long, long, long> v13_c = v0_c;\n+\n+std::tuple<int, int> v14{std::pair<int, int>{1,2}};\n+std::tuple<long, long> v15{std::pair<int, int>{1,2}};\n+std::tuple<Explicit, Explicit> v16{std::pair<int, int>{1,2}};\n+\n+std::tuple<int, int> v17 = std::pair<int, int>{1,2};\n+std::tuple<long, long> v18 = std::pair<int, int>{1,2};\n+std::tuple<Explicit, Explicit> v19\n+  = std::pair<int, int>{1,2}; // { dg-error \"conversion\" }\n+\n+std::pair<int, int> v20;\n+\n+std::tuple<int, int> v21{v20};\n+std::tuple<long, long> v22{v20};\n+std::tuple<Explicit, Explicit> v23{v20};\n+\n+std::tuple<int, int> v24 = v20;\n+std::tuple<long, long> v25 = v20;\n+std::tuple<Explicit, Explicit> v26 = v20; // { dg-error \"conversion\" }\n+\n+std::tuple<int> v27_a{std::allocator_arg, std::allocator<int>{}, 1};\n+std::tuple<int, int> v27_b{std::allocator_arg, std::allocator<int>{}, 1, 2};\n+std::tuple<int, int, int> v27_c{std::allocator_arg, std::allocator<int>{}, 1,2,3};\n+\n+std::tuple<long> v28_a{std::allocator_arg, std::allocator<int>{}, 1};\n+std::tuple<long, long> v28_b{std::allocator_arg, std::allocator<int>{}, 1, 2};\n+std::tuple<long, long, long>\n+  v28_c{std::allocator_arg, std::allocator<int>{}, 1,2,3};\n+\n+std::tuple<Explicit> v29_a{std::allocator_arg, std::allocator<int>{}, 1};\n+std::tuple<Explicit, Explicit>\n+  v29_b{std::allocator_arg, std::allocator<int>{}, 1, 2};\n+std::tuple<Explicit, Explicit, Explicit>\n+  v29_c{std::allocator_arg, std::allocator<int>{}, 1,2,3};\n+\n+std::tuple<int> v30_a = {std::allocator_arg, std::allocator<int>{}, 1};\n+std::tuple<int, int> v30_b = {std::allocator_arg, std::allocator<int>{}, 1, 2};\n+std::tuple<int, int, int> v30_c\n+  = {std::allocator_arg, std::allocator<int>{}, 1,2,3};\n+\n+std::tuple<long> v31_a = {std::allocator_arg, std::allocator<int>{}, 1};\n+std::tuple<long, long> v31_b = {std::allocator_arg, std::allocator<int>{}, 1, 2};\n+std::tuple<long, long, long>\n+  v31_c{std::allocator_arg, std::allocator<int>{}, 1,2,3};\n+\n+std::tuple<Explicit> v32_a\n+  = {std::allocator_arg, std::allocator<int>{}, 1}; // { dg-error \"explicit\" }\n+std::tuple<Explicit, Explicit> v32_b\n+  = {std::allocator_arg, std::allocator<int>{}, 1, 2}; // { dg-error \"explicit\" }\n+std::tuple<Explicit, Explicit, Explicit> v32_c\n+  = {std::allocator_arg, std::allocator<int>{}, 1,2,3}; // { dg-error \"explicit\" }\n+\n+std::tuple<int, int> v33{std::allocator_arg, std::allocator<int>{},\n+  std::pair<int, int>{1, 2}};\n+\n+std::tuple<long, long> v34{std::allocator_arg, std::allocator<int>{},\n+  std::pair<int, int>{1, 2}};\n+\n+std::tuple<Explicit, Explicit>\n+  v35{std::allocator_arg, std::allocator<int>{}, std::pair<int, int>{1, 2}};\n+\n+std::tuple<int, int> v36 = {std::allocator_arg, std::allocator<int>{},\n+  std::pair<int, int>{1, 2}};\n+\n+std::tuple<long, long> v37 = {std::allocator_arg, std::allocator<int>{},\n+  std::pair<int, int>{1, 2}};\n+\n+std::tuple<Explicit, Explicit> v38\n+= {std::allocator_arg, std::allocator<int>{}, std::pair<int, int>{1, 2}}; // { dg-error \"explicit\" }\n+\n+std::tuple<int, int> v39{std::allocator_arg, std::allocator<int>{}, v20};\n+\n+std::tuple<long, long> v40{std::allocator_arg, std::allocator<int>{}, v20};\n+\n+std::tuple<Explicit, Explicit>\n+  v41{std::allocator_arg, std::allocator<int>{}, v20};\n+\n+std::tuple<int, int> v42 = {std::allocator_arg, std::allocator<int>{}, v20};\n+\n+std::tuple<long, long> v43 = {std::allocator_arg, std::allocator<int>{}, v20};\n+\n+std::tuple<Explicit, Explicit> v44\n+= {std::allocator_arg, std::allocator<int>{}, v20}; // { dg-error \"explicit\" }\n+\n+struct DeletedCopy\n+{\n+  DeletedCopy(int);\n+  DeletedCopy(const DeletedCopy&) = delete;\n+};\n+\n+std::tuple<DeletedCopy> v45{42};\n+std::tuple<DeletedCopy> v46{std::allocator_arg,\n+    std::allocator<DeletedCopy>{}, 42};\n+\n+struct Sanity\n+{\n+  int v;\n+};\n+\n+std::tuple<int, Sanity> v47(3, {42});\n+std::tuple<int, int, Sanity> v48(3, 4, {42});\n+std::tuple<int, Sanity> v49(std::allocator_arg,\n+                            std::allocator<Sanity>{},\n+                            3, {42});\n+std::tuple<int, int, Sanity> v50(std::allocator_arg,\n+                                 std::allocator<Sanity>{},\n+                                 3, 4, {42});\n+\n+void f6_a(std::tuple<Explicit>) {}\n+void f6_b(std::tuple<Explicit, Explicit>) {}\n+void f6_c(std::tuple<Explicit, Explicit, Explicit>) {}\n+\n+void f7_a(std::tuple<long>) {}\n+void f7_b(std::tuple<long, long>) {}\n+void f7_c(std::tuple<long, long, long>) {}\n+\n+void test_arg_passing()\n+{\n+  f6_a(v0_a); // { dg-error \"could not convert\" }\n+  f6_b(v0_b); // { dg-error \"could not convert\" }\n+  f6_c(v0_c); // { dg-error \"could not convert\" }\n+  f6_b(v20); // { dg-error \"could not convert\" }\n+\n+  f6_a(v1_a);\n+  f6_b(v1_b);\n+  f6_c(v1_c);\n+\n+  f6_a({1}); // { dg-error \"explicit\" }\n+  f6_b({1,2}); // { dg-error \"explicit\" }\n+  f6_c({1,2,3}); // { dg-error \"explicit\" }\n+\n+  f6_a(std::tuple<Explicit>{});\n+  f6_b(std::tuple<Explicit, Explicit>{});\n+  f6_c(std::tuple<Explicit, Explicit, Explicit>{});\n+\n+  f6_a(std::tuple<int>{}); // { dg-error \"could not convert\" }\n+  f6_b(std::tuple<int, int>{}); // { dg-error \"could not convert\" }\n+  f6_c(std::tuple<int, int, int>{}); // { dg-error \"could not convert\" }\n+  f6_b(std::pair<int, int>{}); // { dg-error \"could not convert\" }\n+\n+  f7_a(v0_a);\n+  f7_b(v0_b);\n+  f7_c(v0_c);\n+  f7_b(v20);\n+\n+  f7_a(v6_a);\n+  f7_b(v6_b);\n+  f7_c(v6_c);\n+\n+  f7_a({1});\n+  f7_b({1,2});\n+  f7_c({1,2,3});\n+\n+  f7_a(std::tuple<int>{});\n+  f7_b(std::tuple<int, int>{});\n+  f7_c(std::tuple<int, int, int>{});\n+  f7_b(std::pair<int, int>{});\n+\n+\n+  f7_a(std::tuple<long>{});\n+  f7_b(std::tuple<long, long>{});\n+  f7_c(std::tuple<long, long, long>{});\n+}"}, {"sha": "d3b975bd0f19191eb7be49299afc8ecb67f5cfb4", "filename": "libstdc++-v3/testsuite/20_util/tuple/requirements/dr2367.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Frequirements%2Fdr2367.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf7818bfb0c70e626f8b71501ada3263f306a476/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Frequirements%2Fdr2367.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Frequirements%2Fdr2367.cc?ref=bf7818bfb0c70e626f8b71501ada3263f306a476", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+#include <type_traits>\n+\n+// DR 2367, pair and tuple are not correctly implemented for is_constructible with no args\n+void test_default_constructible()\n+{\n+  struct X\n+  {\n+    X() = delete;\n+  };\n+\n+  typedef std::tuple<int, X> T;\n+  static_assert(!std::is_constructible<T>::value, \"\");\n+  static_assert(!std::is_default_constructible<T>::value, \"\");\n+\n+  typedef std::tuple<int, int, X> T2;\n+  static_assert(!std::is_constructible<T2>::value, \"\");\n+  static_assert(!std::is_default_constructible<T2>::value, \"\");\n+\n+\n+}\n+\n+int main()\n+{\n+  test_default_constructible();\n+  return 0;\n+}"}]}