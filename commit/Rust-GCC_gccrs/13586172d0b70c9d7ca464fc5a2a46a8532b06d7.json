{"sha": "13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM1ODYxNzJkMGI3MGM5ZDdjYTQ2NGZjNWEyYTQ2YTg1MzJiMDZkNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-07-27T08:02:38Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-07-27T08:03:17Z"}, "message": "ipa: Adjust references to identify read-only globals\n\nthis patch has been motivated by SPEC 2017's 544.nab_r in which there is\na static variable which is never written to and so zero throughout the\nrun-time of the benchmark.  However, it is passed by reference to a\nfunction in which it is read and (after some multiplications) passed\ninto __builtin_exp which in turn unnecessarily consumes almost 10% of\nthe total benchmark run-time.  The situation is illustrated by the added\ntestcase remref-3.c.\n\nThe patch adds a flag to ipa-prop descriptor of each parameter to mark\nsuch parameters.  IPA-CP and inling then take the effort to remove\nIPA_REF_ADDR references in the caller and only add IPA_REF_LOAD\nreference to the clone/overall inlined function.  This is sufficient\nfor subsequent symbol table analysis code to identify the read-only\nvariable as such and optimize the code.\n\nThere are two changes from the RFC version posted to the list earlier.\nFirst, three missing calls to get_base_address were added (there was\nanother one in an assert).  Second, references are not stripped off\nthe callers if the cloned function cannot change the signature.  The\nsecond change reveals a real shortcoming stemming from the fact we\ncannot adjust function prototypes with fnspecs.  But that is a more\ngeneral problem.\n\ngcc/ChangeLog:\n\n2021-07-20  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (ipa_replace_map): New field force_load_ref.\n\t* ipa-prop.h (ipa_param_descriptor): Reduce precision of move_cost,\n\taded new flag load_dereferenced, adjusted comments.\n\t(ipa_get_param_dereferenced): New function.\n\t(ipa_set_param_dereferenced): Likewise.\n\t* cgraphclones.c (cgraph_node::create_virtual_clone): Follow it.\n\t* ipa-cp.c: Include gimple.h.\n\t(ipcp_discover_new_direct_edges): Take into account dereferenced flag.\n\t(get_replacement_map): New parameter force_load_ref, set the\n\tappropriate flag in ipa_replace_map if set.\n\t(struct symbol_and_index_together): New type.\n\t(adjust_refs_in_act_callers): New function.\n\t(adjust_references_in_caller): Likewise.\n\t(create_specialized_node): When appropriate, call\n\tadjust_references_in_caller and force only load references.\n\t* ipa-prop.c (load_from_dereferenced_name): New function.\n\t(ipa_analyze_controlled_uses): Also detect loads from a\n\tdereference, harden testing of call statements.\n\t(ipa_write_node_info): Stream the dereferenced flag.\n\t(ipa_read_node_info): Likewise.\n\t(ipa_set_jf_constant): Also create refdesc when jump function\n\treferences a variable.\n\t(cgraph_node_for_jfunc): Rename to symtab_node_for_jfunc, work\n\talso on references of variables and return a symtab_node.  Adjust\n\tall callers.\n\t(propagate_controlled_uses): Also remove references to VAR_DECLs.\n\ngcc/testsuite/ChangeLog:\n\n2021-06-29  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/remref-3.c: New test.\n\t* gcc.dg/ipa/remref-4.c: Likewise.\n\t* gcc.dg/ipa/remref-5.c: Likewise.\n\t* gcc.dg/ipa/remref-6.c: Likewise.", "tree": {"sha": "d9b3cd1eab248ec0adbf6334a9fa4b8663107b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9b3cd1eab248ec0adbf6334a9fa4b8663107b06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmD/vcUACgkQv2PBvD+k\nNUDvPg/8D52Ejx6YHEXwota6aAYBmNQJgJL99sOTEQjoCPPcFibe2etA1KYcJvZN\nGJsYubvL/PsYwJsvqtXgA/7B0nOHBHvKadVop+Go3N1s6W+kX3IJhQo9s33tN8JK\nSGiaJ35i3/AW5tlIivOQCGn16WkexbaYQVfr1oMRo2kpuHAIyp3VxCiP+0lDAypn\nnU/JshfWS/UeneGns20daivsqUX2rP7NJNVHdwdqd4dwU9awod8soRk1Oi15WDJ+\nITiM7TOfHEbMWEhtea4dliisQGNqA95J9SzULvIu7Vab3V76zZPdmTShnPVJ7LnD\nj1YH+gATBC6zVKnRcRa5pWw1Eiu8EFf+pWhtscrUz9QY2xKoCmBUDUv1CZKIw1k2\nCJaA0OMyeqkkke73ixEeY+H9czuJuE4EcuyTg/aaSX/Z8Xociiq9VR0sb83z4Jqx\n++9oooq+EpTzLlB8cDBJDpfhSnegzk7G/QfNcCfuVpRZ7XJLSmwt85QN4sGNF6P8\nXdI05oQGXcNyI54D3UmoB4WfmfzG/rfPLktUY/wF4OyhwXZbJ8/b/HHqSwg2Z0m3\neGTHEk2sH0vdZLEgUmhwGEjS1OIW/DLju5PRVd2I6TNxHX4r6WHUxb6yS6WCmbPU\n8QFcMUMQw9chkYuFZDJnKzowqPKfED6cXj34H1YKdNa9AWu8OnE=\n=d6kO\n-----END PGP SIGNATURE-----", "payload": "tree d9b3cd1eab248ec0adbf6334a9fa4b8663107b06\nparent a21bd3cebd6f54af70a37c18b8fbeae933fb6515\nauthor Martin Jambor <mjambor@suse.cz> 1627372958 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1627372997 +0200\n\nipa: Adjust references to identify read-only globals\n\nthis patch has been motivated by SPEC 2017's 544.nab_r in which there is\na static variable which is never written to and so zero throughout the\nrun-time of the benchmark.  However, it is passed by reference to a\nfunction in which it is read and (after some multiplications) passed\ninto __builtin_exp which in turn unnecessarily consumes almost 10% of\nthe total benchmark run-time.  The situation is illustrated by the added\ntestcase remref-3.c.\n\nThe patch adds a flag to ipa-prop descriptor of each parameter to mark\nsuch parameters.  IPA-CP and inling then take the effort to remove\nIPA_REF_ADDR references in the caller and only add IPA_REF_LOAD\nreference to the clone/overall inlined function.  This is sufficient\nfor subsequent symbol table analysis code to identify the read-only\nvariable as such and optimize the code.\n\nThere are two changes from the RFC version posted to the list earlier.\nFirst, three missing calls to get_base_address were added (there was\nanother one in an assert).  Second, references are not stripped off\nthe callers if the cloned function cannot change the signature.  The\nsecond change reveals a real shortcoming stemming from the fact we\ncannot adjust function prototypes with fnspecs.  But that is a more\ngeneral problem.\n\ngcc/ChangeLog:\n\n2021-07-20  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (ipa_replace_map): New field force_load_ref.\n\t* ipa-prop.h (ipa_param_descriptor): Reduce precision of move_cost,\n\taded new flag load_dereferenced, adjusted comments.\n\t(ipa_get_param_dereferenced): New function.\n\t(ipa_set_param_dereferenced): Likewise.\n\t* cgraphclones.c (cgraph_node::create_virtual_clone): Follow it.\n\t* ipa-cp.c: Include gimple.h.\n\t(ipcp_discover_new_direct_edges): Take into account dereferenced flag.\n\t(get_replacement_map): New parameter force_load_ref, set the\n\tappropriate flag in ipa_replace_map if set.\n\t(struct symbol_and_index_together): New type.\n\t(adjust_refs_in_act_callers): New function.\n\t(adjust_references_in_caller): Likewise.\n\t(create_specialized_node): When appropriate, call\n\tadjust_references_in_caller and force only load references.\n\t* ipa-prop.c (load_from_dereferenced_name): New function.\n\t(ipa_analyze_controlled_uses): Also detect loads from a\n\tdereference, harden testing of call statements.\n\t(ipa_write_node_info): Stream the dereferenced flag.\n\t(ipa_read_node_info): Likewise.\n\t(ipa_set_jf_constant): Also create refdesc when jump function\n\treferences a variable.\n\t(cgraph_node_for_jfunc): Rename to symtab_node_for_jfunc, work\n\talso on references of variables and return a symtab_node.  Adjust\n\tall callers.\n\t(propagate_controlled_uses): Also remove references to VAR_DECLs.\n\ngcc/testsuite/ChangeLog:\n\n2021-06-29  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/remref-3.c: New test.\n\t* gcc.dg/ipa/remref-4.c: Likewise.\n\t* gcc.dg/ipa/remref-5.c: Likewise.\n\t* gcc.dg/ipa/remref-6.c: Likewise.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a21bd3cebd6f54af70a37c18b8fbeae933fb6515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21bd3cebd6f54af70a37c18b8fbeae933fb6515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a21bd3cebd6f54af70a37c18b8fbeae933fb6515"}], "stats": {"total": 481, "additions": 431, "deletions": 50}, "files": [{"sha": "d54a258c2ee3f33ab542c988a03e6bdcc4dfbeaa", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -700,6 +700,10 @@ struct GTY(()) ipa_replace_map\n   tree new_tree;\n   /* Parameter number to replace, when old_tree is NULL.  */\n   int parm_num;\n+  /* Set if the newly added reference should not be an address one, but a load\n+     one from the operand of the ADDR_EXPR in NEW_TREE.  This is for cases when\n+     the corresponding parameter p is used only as *p.  */\n+  unsigned force_load_ref : 1;\n };\n \n enum cgraph_simd_clone_arg_type"}, {"sha": "b16e68194e1b5a69c7f42639f75e0fe290b4da50", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -633,7 +633,15 @@ cgraph_node::create_virtual_clone (const vec<cgraph_edge *> &redirect_callers,\n       || in_lto_p)\n     new_node->unique_name = true;\n   FOR_EACH_VEC_SAFE_ELT (tree_map, i, map)\n-    new_node->maybe_create_reference (map->new_tree, NULL);\n+    {\n+      tree repl = map->new_tree;\n+      if (map->force_load_ref)\n+\t{\n+\t  gcc_assert (TREE_CODE (repl) == ADDR_EXPR);\n+\t  repl = get_base_address (TREE_OPERAND (repl, 0));\n+\t}\n+      new_node->maybe_create_reference (repl, NULL);\n+    }\n \n   if (ipa_transforms_to_apply.exists ())\n     new_node->ipa_transforms_to_apply"}, {"sha": "55b9216337f41212ed9158d7e094db62baea357a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 145, "deletions": 11, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -106,6 +106,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"tree.h\"\n #include \"gimple-expr.h\"\n+#include \"gimple.h\"\n #include \"predict.h\"\n #include \"alloc-pool.h\"\n #include \"tree-pass.h\"\n@@ -4008,7 +4009,8 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t    {\n \t      ipa_node_params *info = ipa_node_params_sum->get (node);\n \t      int c = ipa_get_controlled_uses (info, param_index);\n-\t      if (c != IPA_UNDESCRIBED_USE)\n+\t      if (c != IPA_UNDESCRIBED_USE\n+\t\t  && !ipa_get_param_load_dereferenced (info, param_index))\n \t\t{\n \t\t  struct ipa_ref *to_del;\n \n@@ -4317,10 +4319,14 @@ gather_edges_for_value (ipcp_value<valtype> *val, cgraph_node *dest,\n }\n \n /* Construct a replacement map for a know VALUE for a formal parameter PARAM.\n-   Return it or NULL if for some reason it cannot be created.  */\n+   Return it or NULL if for some reason it cannot be created.  FORCE_LOAD_REF\n+   should be set to true when the reference created for the constant should be\n+   a load one and not an address one because the corresponding parameter p is\n+   only used as *p.  */\n \n static struct ipa_replace_map *\n-get_replacement_map (class ipa_node_params *info, tree value, int parm_num)\n+get_replacement_map (class ipa_node_params *info, tree value, int parm_num,\n+\t\t     bool force_load_ref)\n {\n   struct ipa_replace_map *replace_map;\n \n@@ -4332,10 +4338,15 @@ get_replacement_map (class ipa_node_params *info, tree value, int parm_num)\n \n       fprintf (dump_file, \" with const \");\n       print_generic_expr (dump_file, value);\n-      fprintf (dump_file, \"\\n\");\n+\n+      if (force_load_ref)\n+\tfprintf (dump_file, \" - forcing load reference\\n\");\n+      else\n+\tfprintf (dump_file, \"\\n\");\n     }\n   replace_map->parm_num = parm_num;\n   replace_map->new_tree = value;\n+  replace_map->force_load_ref = force_load_ref;\n   return replace_map;\n }\n \n@@ -4488,6 +4499,113 @@ update_specialized_profile (struct cgraph_node *new_node,\n     dump_profile_updates (orig_node, new_node);\n }\n \n+static void adjust_references_in_caller (cgraph_edge *cs,\n+\t\t\t\t\t symtab_node *symbol, int index);\n+\n+/* Simple structure to pass a symbol and index (with same meaning as parameters\n+   of adjust_references_in_caller) through a void* parameter of a\n+   call_for_symbol_thunks_and_aliases callback. */\n+struct symbol_and_index_together\n+{\n+  symtab_node *symbol;\n+  int index;\n+};\n+\n+/* Worker callback of call_for_symbol_thunks_and_aliases to recursively call\n+   adjust_references_in_caller on edges up in the call-graph, if necessary. */\n+static bool\n+adjust_refs_in_act_callers (struct cgraph_node *node, void *data)\n+{\n+  symbol_and_index_together *pack = (symbol_and_index_together *) data;\n+  for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n+    if (!cs->caller->thunk)\n+      adjust_references_in_caller (cs, pack->symbol, pack->index);\n+  return false;\n+}\n+\n+/* At INDEX of a function being called by CS there is an ADDR_EXPR of a\n+   variable which is only dereferenced and which is represented by SYMBOL.  See\n+   if we can remove ADDR reference in callers assosiated witht the call. */\n+\n+static void\n+adjust_references_in_caller (cgraph_edge *cs, symtab_node *symbol, int index)\n+{\n+  ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n+  ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, index);\n+  if (jfunc->type == IPA_JF_CONST)\n+    {\n+      ipa_ref *to_del = cs->caller->find_reference (symbol, cs->call_stmt,\n+\t\t\t\t\t\t    cs->lto_stmt_uid);\n+      if (!to_del)\n+\treturn;\n+      to_del->remove_reference ();\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Removed a reference from %s to %s.\\n\",\n+\t\t cs->caller->dump_name (), symbol->dump_name ());\n+      return;\n+    }\n+\n+  if (jfunc->type != IPA_JF_PASS_THROUGH\n+      || ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n+    return;\n+\n+  int fidx = ipa_get_jf_pass_through_formal_id (jfunc);\n+  cgraph_node *caller = cs->caller;\n+  ipa_node_params *caller_info = ipa_node_params_sum->get (caller);\n+  /* TODO: This consistency check may be too big and not really\n+     that useful.  Consider removing it.  */\n+  tree cst;\n+  if (caller_info->ipcp_orig_node)\n+    cst = caller_info->known_csts[fidx];\n+  else\n+    {\n+      ipcp_lattice<tree> *lat = ipa_get_scalar_lat (caller_info, fidx);\n+      gcc_assert (lat->is_single_const ());\n+      cst = lat->values->value;\n+    }\n+  gcc_assert (TREE_CODE (cst) == ADDR_EXPR\n+\t      && (symtab_node::get (get_base_address (TREE_OPERAND (cst, 0)))\n+\t\t  == symbol));\n+\n+  int cuses = ipa_get_controlled_uses (caller_info, fidx);\n+  if (cuses == IPA_UNDESCRIBED_USE)\n+    return;\n+  gcc_assert (cuses > 0);\n+  cuses--;\n+  ipa_set_controlled_uses (caller_info, fidx, cuses);\n+  if (cuses)\n+    return;\n+\n+  if (caller_info->ipcp_orig_node)\n+    {\n+      /* Cloning machinery has created a reference here, we need to either\n+\t remove it or change it to a read one.  */\n+      ipa_ref *to_del = caller->find_reference (symbol, NULL, 0);\n+      if (to_del && to_del->use == IPA_REF_ADDR)\n+\t{\n+\t  to_del->remove_reference ();\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    Removed a reference from %s to %s.\\n\",\n+\t\t     cs->caller->dump_name (), symbol->dump_name ());\n+\t  if (ipa_get_param_load_dereferenced (caller_info, fidx))\n+\t    {\n+\t      caller->create_reference (symbol, IPA_REF_LOAD, NULL);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"      ...and replaced it with LOAD one.\\n\");\n+\t    }\n+\t}\n+    }\n+\n+  symbol_and_index_together pack;\n+  pack.symbol = symbol;\n+  pack.index = fidx;\n+  if (caller->can_change_signature)\n+    caller->call_for_symbol_thunks_and_aliases (adjust_refs_in_act_callers,\n+\t\t\t\t\t\t&pack, true);\n+}\n+\n+\n /* Return true if we would like to remove a parameter from NODE when cloning it\n    with KNOWN_CSTS scalar constants.  */\n \n@@ -4595,15 +4713,31 @@ create_specialized_node (struct cgraph_node *node,\n   for (i = 0; i < count; i++)\n     {\n       tree t = known_csts[i];\n-      if (t)\n-\t{\n-\t  struct ipa_replace_map *replace_map;\n+      if (!t)\n+\tcontinue;\n \n-\t  gcc_checking_assert (TREE_CODE (t) != TREE_BINFO);\n-\t  replace_map = get_replacement_map (info, t, i);\n-\t  if (replace_map)\n-\t    vec_safe_push (replace_trees, replace_map);\n+      gcc_checking_assert (TREE_CODE (t) != TREE_BINFO);\n+\n+      bool load_ref = false;\n+      symtab_node *ref_symbol;\n+      if (TREE_CODE (t) == ADDR_EXPR)\n+\t{\n+\t  tree base = get_base_address (TREE_OPERAND (t, 0));\n+\t  if (TREE_CODE (base) == VAR_DECL\n+\t      && ipa_get_controlled_uses (info, i) == 0\n+\t      && ipa_get_param_load_dereferenced (info, i)\n+\t      && (ref_symbol = symtab_node::get (base)))\n+\t    {\n+\t      load_ref = true;\n+\t      if (node->can_change_signature)\n+\t\tfor (cgraph_edge *caller : callers)\n+\t\t  adjust_references_in_caller (caller, ref_symbol, i);\n+\t    }\n \t}\n+\n+      ipa_replace_map *replace_map = get_replacement_map (info, t, i, load_ref);\n+      if (replace_map)\n+\tvec_safe_push (replace_trees, replace_map);\n     }\n   auto_vec<cgraph_edge *, 2> self_recursive_calls;\n   for (i = callers.length () - 1; i >= 0; i--)"}, {"sha": "0afd05eb95c360b6717fe0ad00139d50682859c6", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 130, "deletions": 36, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -544,7 +544,9 @@ ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant,\n   jfunc->value.constant.value = unshare_expr_without_location (constant);\n \n   if (TREE_CODE (constant) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (constant, 0)) == FUNCTION_DECL)\n+      && (TREE_CODE (TREE_OPERAND (constant, 0)) == FUNCTION_DECL\n+\t  || (TREE_CODE (TREE_OPERAND (constant, 0)) == VAR_DECL\n+\t      && TREE_STATIC (TREE_OPERAND (constant, 0)))))\n     {\n       struct ipa_cst_ref_desc *rdesc;\n \n@@ -2876,6 +2878,16 @@ ipa_analyze_params_uses_in_bb (struct ipa_func_body_info *fbi, basic_block bb)\n \t\t\t\t   visit_ref_for_mod_analysis);\n }\n \n+/* Return true EXPR is a load from a dereference of SSA_NAME NAME.  */\n+\n+static bool\n+load_from_dereferenced_name (tree expr, tree name)\n+{\n+  tree base = get_base_address (expr);\n+  return (TREE_CODE (base) == MEM_REF\n+\t  && TREE_OPERAND (base, 0) == name);\n+}\n+\n /* Calculate controlled uses of parameters of NODE.  */\n \n static void\n@@ -2886,7 +2898,8 @@ ipa_analyze_controlled_uses (struct cgraph_node *node)\n   for (int i = 0; i < ipa_get_param_count (info); i++)\n     {\n       tree parm = ipa_get_param (info, i);\n-      int controlled_uses = 0;\n+      int call_uses = 0;\n+      bool load_dereferenced = false;\n \n       /* For SSA regs see if parameter is used.  For non-SSA we compute\n \t the flag during modification analysis.  */\n@@ -2897,27 +2910,77 @@ ipa_analyze_controlled_uses (struct cgraph_node *node)\n \t  if (ddef && !has_zero_uses (ddef))\n \t    {\n \t      imm_use_iterator imm_iter;\n-\t      use_operand_p use_p;\n+\t      gimple *stmt;\n \n \t      ipa_set_param_used (info, i, true);\n-\t      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ddef)\n-\t\tif (!is_gimple_call (USE_STMT (use_p)))\n-\t\t  {\n-\t\t    if (!is_gimple_debug (USE_STMT (use_p)))\n-\t\t      {\n-\t\t\tcontrolled_uses = IPA_UNDESCRIBED_USE;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  controlled_uses++;\n+\t      FOR_EACH_IMM_USE_STMT (stmt, imm_iter, ddef)\n+\t\t{\n+\t\t  if (is_gimple_debug (stmt))\n+\t\t    continue;\n+\n+\t\t  int all_stmt_uses = 0;\n+\t\t  use_operand_p use_p;\n+\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t    all_stmt_uses++;\n+\n+\t\t  if (is_gimple_call (stmt))\n+\t\t    {\n+\t\t      if (gimple_call_internal_p (stmt))\n+\t\t\t{\n+\t\t\t  call_uses = IPA_UNDESCRIBED_USE;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      int recognized_stmt_uses;\n+\t\t      if (gimple_call_fn (stmt) == ddef)\n+\t\t\trecognized_stmt_uses = 1;\n+\t\t      else\n+\t\t\trecognized_stmt_uses = 0;\n+\t\t      unsigned arg_count = gimple_call_num_args (stmt);\n+\t\t      for (unsigned i = 0; i < arg_count; i++)\n+\t\t\t{\n+\t\t\t  tree arg = gimple_call_arg (stmt, i);\n+\t\t\t  if (arg == ddef)\n+\t\t\t    recognized_stmt_uses++;\n+\t\t\t  else if (load_from_dereferenced_name (arg, ddef))\n+\t\t\t    {\n+\t\t\t      load_dereferenced = true;\n+\t\t\t      recognized_stmt_uses++;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      if (recognized_stmt_uses != all_stmt_uses)\n+\t\t\t{\n+\t\t\t  call_uses = IPA_UNDESCRIBED_USE;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      if (call_uses >= 0)\n+\t\t\tcall_uses += all_stmt_uses;\n+\t\t    }\n+\t\t  else if (gimple_assign_single_p (stmt))\n+\t\t    {\n+\t\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t\t      if (all_stmt_uses != 1\n+\t\t\t  || !load_from_dereferenced_name (rhs, ddef))\n+\t\t\t{\n+\t\t\t  call_uses = IPA_UNDESCRIBED_USE;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      load_dereferenced = true;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      call_uses = IPA_UNDESCRIBED_USE;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t    }\n \t  else\n-\t    controlled_uses = 0;\n+\t    call_uses = 0;\n \t}\n       else\n-\tcontrolled_uses = IPA_UNDESCRIBED_USE;\n-      ipa_set_controlled_uses (info, i, controlled_uses);\n+\tcall_uses = IPA_UNDESCRIBED_USE;\n+      ipa_set_controlled_uses (info, i, call_uses);\n+      ipa_set_param_load_dereferenced (info, i, load_dereferenced);\n     }\n }\n \n@@ -3640,16 +3703,17 @@ jfunc_rdesc_usable (struct ipa_jump_func *jfunc)\n    declaration, return the associated call graph node.  Otherwise return\n    NULL.  */\n \n-static cgraph_node *\n-cgraph_node_for_jfunc (struct ipa_jump_func *jfunc)\n+static symtab_node *\n+symtab_node_for_jfunc (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n   tree cst = ipa_get_jf_constant (jfunc);\n   if (TREE_CODE (cst) != ADDR_EXPR\n-      || TREE_CODE (TREE_OPERAND (cst, 0)) != FUNCTION_DECL)\n+      || (TREE_CODE (TREE_OPERAND (cst, 0)) != FUNCTION_DECL\n+\t  && TREE_CODE (TREE_OPERAND (cst, 0)) != VAR_DECL))\n     return NULL;\n \n-  return cgraph_node::get (TREE_OPERAND (cst, 0));\n+  return symtab_node::get (TREE_OPERAND (cst, 0));\n }\n \n \n@@ -3666,7 +3730,7 @@ try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n       && (rdesc = jfunc_rdesc_usable (jfunc))\n       && --rdesc->refcount == 0)\n     {\n-      symtab_node *symbol = cgraph_node_for_jfunc (jfunc);\n+      symtab_node *symbol = symtab_node_for_jfunc (jfunc);\n       if (!symbol)\n \treturn false;\n \n@@ -3721,8 +3785,8 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n       gcc_checking_assert (cs->callee\n \t\t\t   && (cs != ie\n \t\t\t       || jfunc->type != IPA_JF_CONST\n-\t\t\t       || !cgraph_node_for_jfunc (jfunc)\n-\t\t\t       || cs->callee == cgraph_node_for_jfunc (jfunc)));\n+\t\t\t       || !symtab_node_for_jfunc (jfunc)\n+\t\t\t       || cs->callee == symtab_node_for_jfunc (jfunc)));\n       ok = try_decrement_rdesc_refcount (jfunc);\n       gcc_checking_assert (ok);\n     }\n@@ -4085,7 +4149,15 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t       == NOP_EXPR || c == IPA_UNDESCRIBED_USE);\n \t  c = combine_controlled_uses_counters (c, d);\n \t  ipa_set_controlled_uses (new_root_info, src_idx, c);\n-\t  if (c == 0 && new_root_info->ipcp_orig_node)\n+\t  bool lderef = true;\n+\t  if (c != IPA_UNDESCRIBED_USE)\n+\t    {\n+\t      lderef = (ipa_get_param_load_dereferenced (new_root_info, src_idx)\n+\t\t\t|| ipa_get_param_load_dereferenced (old_root_info, i));\n+\t      ipa_set_param_load_dereferenced (new_root_info, src_idx, lderef);\n+\t    }\n+\n+\t  if (c == 0 && !lderef && new_root_info->ipcp_orig_node)\n \t    {\n \t      struct cgraph_node *n;\n \t      struct ipa_ref *ref;\n@@ -4114,17 +4186,27 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t  if (rdesc->refcount == 0)\n \t    {\n \t      tree cst = ipa_get_jf_constant (jf);\n-\t      struct cgraph_node *n;\n \t      gcc_checking_assert (TREE_CODE (cst) == ADDR_EXPR\n-\t\t\t\t   && TREE_CODE (TREE_OPERAND (cst, 0))\n-\t\t\t\t   == FUNCTION_DECL);\n-\t      n = cgraph_node::get (TREE_OPERAND (cst, 0));\n+\t\t\t\t   && ((TREE_CODE (TREE_OPERAND (cst, 0))\n+\t\t\t\t\t== FUNCTION_DECL)\n+\t\t\t\t       || (TREE_CODE (TREE_OPERAND (cst, 0))\n+\t\t\t\t\t   == VAR_DECL)));\n+\n+\t      symtab_node *n = symtab_node::get (TREE_OPERAND (cst, 0));\n \t      if (n)\n \t\t{\n \t\t  struct cgraph_node *clone;\n-\t\t  bool ok;\n-\t\t  ok = remove_described_reference (n, rdesc);\n-\t\t  gcc_checking_assert (ok);\n+\t\t  bool removed = remove_described_reference (n, rdesc);\n+\t\t  /* The reference might have been removed by IPA-CP.  */\n+\t\t  if (removed\n+\t\t      && ipa_get_param_load_dereferenced (old_root_info, i))\n+\t\t    {\n+\t\t      new_root->create_reference (n, IPA_REF_LOAD, NULL);\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"ipa-prop: ...replaced it with \"\n+\t\t\t\t \" LOAD one from %s to %s.\\n\",\n+\t\t\t\t new_root->dump_name (), n->dump_name ());\n+\t\t    }\n \n \t\t  clone = cs->caller;\n \t\t  while (clone->inlined_to\n@@ -4347,7 +4429,7 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t  else if (src->caller == dst->caller)\n \t    {\n \t      struct ipa_ref *ref;\n-\t      symtab_node *n = cgraph_node_for_jfunc (src_jf);\n+\t      symtab_node *n = symtab_node_for_jfunc (src_jf);\n \t      gcc_checking_assert (n);\n \t      ref = src->caller->find_reference (n, src->call_stmt,\n \t\t\t\t\t\t src->lto_stmt_uid);\n@@ -4574,7 +4656,9 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n       if (c == IPA_UNDESCRIBED_USE)\n \tfprintf (f, \" undescribed_use\");\n       else\n-\tfprintf (f, \"  controlled_uses=%i\", c);\n+\tfprintf (f, \"  controlled_uses=%i %s\", c,\n+\t\t ipa_get_param_load_dereferenced (info, i)\n+\t\t ? \"(load_dereferenced)\" : \"\");\n       fprintf (f, \"\\n\");\n     }\n }\n@@ -4969,7 +5053,13 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   gcc_assert (!info->node_enqueued);\n   gcc_assert (!info->ipcp_orig_node);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n-    bp_pack_value (&bp, ipa_is_param_used (info, j), 1);\n+    {\n+      /* TODO: We could just not stream the bit in the undescribed case. */\n+      bool d = (ipa_get_controlled_uses (info, j) != IPA_UNDESCRIBED_USE)\n+\t? ipa_get_param_load_dereferenced (info, j) : true;\n+      bp_pack_value (&bp, d, 1);\n+      bp_pack_value (&bp, ipa_is_param_used (info, j), 1);\n+    }\n   streamer_write_bitpack (&bp);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n     {\n@@ -5095,10 +5185,14 @@ ipa_read_node_info (class lto_input_block *ib, struct cgraph_node *node,\n   bp = streamer_read_bitpack (ib);\n   for (k = 0; k < param_count; k++)\n     {\n+      bool load_dereferenced = bp_unpack_value (&bp, 1);\n       bool used = bp_unpack_value (&bp, 1);\n \n       if (prevails)\n-        ipa_set_param_used (info, k, used);\n+\t{\n+\t  ipa_set_param_load_dereferenced (info, k, load_dereferenced);\n+\t  ipa_set_param_used (info, k, used);\n+\t}\n     }\n   for (k = 0; k < param_count; k++)\n     {"}, {"sha": "19751f10974e21e30240431590c7d7056e503d61", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -550,14 +550,21 @@ struct GTY(()) ipa_param_descriptor\n   tree decl_or_type;\n   /* If all uses of the parameter are described by ipa-prop structures, this\n      says how many there are.  If any use could not be described by means of\n-     ipa-prop structures, this is IPA_UNDESCRIBED_USE.  */\n+     ipa-prop structures (which include flag dereferenced below), this is\n+     IPA_UNDESCRIBED_USE.  */\n   int controlled_uses;\n-  unsigned int move_cost : 28;\n+  unsigned int move_cost : 27;\n   /* The parameter is used.  */\n   unsigned used : 1;\n   unsigned used_by_ipa_predicates : 1;\n   unsigned used_by_indirect_call : 1;\n   unsigned used_by_polymorphic_call : 1;\n+  /* Set to true when in addition to being used in call statements, the\n+     parameter has also been used for loads (but not for writes, does not\n+     escape, etc.).  This allows us to identify parameters p which are only\n+     used as *p, and so when we propagate a constant to them, we can generate a\n+     LOAD and not ADDR reference to them.  */\n+  unsigned load_dereferenced : 1;\n };\n \n /* ipa_node_params stores information related to formal parameters of functions\n@@ -795,6 +802,24 @@ ipa_set_controlled_uses (class ipa_node_params *info, int i, int val)\n   (*info->descriptors)[i].controlled_uses = val;\n }\n \n+/* Assuming a parameter does not have IPA_UNDESCRIBED_USE controlled uses,\n+   return flag which indicates it has been dereferenced but only in a load.  */\n+static inline int\n+ipa_get_param_load_dereferenced (class ipa_node_params *info, int i)\n+{\n+  gcc_assert (ipa_get_controlled_uses (info, i) != IPA_UNDESCRIBED_USE);\n+  return (*info->descriptors)[i].load_dereferenced;\n+}\n+\n+/* Set the load_dereferenced flag of a given parameter.  */\n+\n+static inline void\n+ipa_set_param_load_dereferenced (class ipa_node_params *info, int i, bool val)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  (*info->descriptors)[i].load_dereferenced = val;\n+}\n+\n /* Return the used flag corresponding to the Ith formal parameter of the\n    function associated with INFO.  */\n "}, {"sha": "8a82ca65c684bcb75caa0b2adfd320b06a3244e7", "filename": "gcc/testsuite/gcc.dg/ipa/remref-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-3.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp-details -fdump-tree-optimized\"  }  */\n+\n+static double global = 0.0;\n+\n+double foo_temp5;\n+\n+static void foo(double *ptr) {\n+  static double abcd;\n+  double v, exp_res;\n+  v = *ptr;\n+  exp_res = __builtin_exp(v);\n+  foo_temp5 = exp_res * abcd;\n+  abcd += foo_temp5;\n+}\n+\n+void entry()\n+{\n+  foo(&global);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Removed a reference\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-not \"builtin_exp\"  \"optimized\"  } } */"}, {"sha": "5a55437e971175cae0bd198b9f1b3717741d5cb1", "filename": "gcc/testsuite/gcc.dg/ipa/remref-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-4.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp-details -fdump-tree-optimized\"  }  */\n+\n+static double global = 0.0;\n+double foo_temp5;\n+\n+static void foo(double *ptr) {\n+  static double abcd;\n+  double v, exp_res;\n+  v = *ptr;\n+  exp_res = __builtin_exp(v);\n+  foo_temp5 = exp_res * abcd;\n+  abcd += foo_temp5;\n+}\n+\n+double last_value;\n+\n+static void bar(double *ptr)\n+{\n+  last_value = *ptr;\n+  foo (ptr);\n+}\n+\n+void entry()\n+{\n+  bar (&global);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Removed a reference\"  \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"replaced it with LOAD\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-not \"builtin_exp\"  \"optimized\"  } } */"}, {"sha": "c520e34d809ccc010e6d0bf3820ea1fed8f12107", "filename": "gcc/testsuite/gcc.dg/ipa/remref-5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-5.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fdump-ipa-cp-details -fdump-tree-optimized\"  }  */\n+\n+static double global = 0.0;\n+double foo_temp5;\n+\n+static void foo(double *ptr) {\n+  static double abcd;\n+  double v, exp_res;\n+  v = *ptr;\n+  exp_res = __builtin_exp(v);\n+  foo_temp5 = exp_res * abcd;\n+  abcd += foo_temp5;\n+}\n+\n+double last_value;\n+\n+static void bar(double *ptr)\n+{\n+  last_value = *ptr;\n+  for (unsigned i = 0; i < 200; i++)\n+    foo (ptr);\n+}\n+\n+void entry()\n+{\n+  bar (&global);\n+}\n+\n+void decoy(double *ptr)\n+{\n+  bar (ptr);\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump \"Removed a reference\"  \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"replaced it with LOAD\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"builtin_exp\" 1 \"optimized\"  } } */"}, {"sha": "de3649315c236bdaa5f03d299f896397e1db409e", "filename": "gcc/testsuite/gcc.dg/ipa/remref-6.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13586172d0b70c9d7ca464fc5a2a46a8532b06d7/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-6.c?ref=13586172d0b70c9d7ca464fc5a2a46a8532b06d7", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fno-ipa-cp -fdump-tree-optimized\"  }  */\n+\n+static double global = 0.0;\n+\n+double foo_temp5;\n+\n+static void foo(double *ptr) {\n+  static double abcd;\n+  double v, exp_res;\n+  v = *ptr;\n+  exp_res = __builtin_exp(v);\n+  foo_temp5 = exp_res * abcd;\n+  abcd += foo_temp5;\n+}\n+\n+void entry()\n+{\n+  foo(&global);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Removed a reference\"  \"inline\" } }  */\n+/* { dg-final { scan-ipa-dump \"replaced it with LOAD\"  \"inline\"  } } */\n+/* { dg-final { scan-tree-dump-not \"builtin_exp\"  \"optimized\"  } } */"}]}