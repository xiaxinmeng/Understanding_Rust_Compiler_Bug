{"sha": "2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFlZWRmNThlMGRjMjNjYzZiNjE2N2Y0ZWQ3NDdkNjM3YzhjMDgwMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-11T16:58:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-11T16:58:09Z"}, "message": "md.texi (regclass_for_constraint): Rename to...\n\ngcc/\n\t* doc/md.texi (regclass_for_constraint): Rename to...\n\t(reg_class_for_constraint): ...this.\n\t* genpreds.c (num_constraints, enum_order, register_start)\n\t(register_end, satisfied_start, memory_start, memory_end)\n\t(address_start, address_end): New variables.\n\t(add_constraint): Count the number of constraints.\n\t(choose_enum_order): New function.\n\t(write_enum_constraint_num): Iterate over enum_order.\n\t(write_regclass_for_constraint): Rename to...\n\t(write_reg_class_for_constraint_1): ...this and update output\n\taccordingly.\n\t(write_constraint_satisfied_p): Rename to...\n\t(write_constraint_satisfied_p_1): ...this and update output\n\taccordingly.  Do nothing if all extra constraints are register\n\tconstraints.\n\t(write_insn_extra_memory_constraint): Delete.\n\t(write_insn_extra_address_constraint): Delete.\n\t(write_range_function): New function.\n\t(write_tm_preds_h): Define constraint_satisfied_p and\n\treg_class_for_constraint as inline functions that do a range check\n\tbefore calling the out-of-line function.  Use write_range_function\n\tto implement insn_extra_{register,memory,address}_constraint,\n\tthe first of which is new.\n\t(write_insn_preds_c): Update after above changes to write_* functions.\n\t(main): Call choose_enum_order.\n\nFrom-SVN: r211468", "tree": {"sha": "36ede94abe3a78cf89a75fdf82c1d88dd4781fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36ede94abe3a78cf89a75fdf82c1d88dd4781fcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0ba67dc043059f7eeaece0f6460709d20133cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ba67dc043059f7eeaece0f6460709d20133cc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0ba67dc043059f7eeaece0f6460709d20133cc0"}], "stats": {"total": 226, "additions": 153, "deletions": 73}, "files": [{"sha": "ff93bc87a82e1ce750bd0e9b86d519fe5238ea13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "patch": "@@ -1,3 +1,31 @@\n+2014-06-11  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* doc/md.texi (regclass_for_constraint): Rename to...\n+\t(reg_class_for_constraint): ...this.\n+\t* genpreds.c (num_constraints, enum_order, register_start)\n+\t(register_end, satisfied_start, memory_start, memory_end)\n+\t(address_start, address_end): New variables.\n+\t(add_constraint): Count the number of constraints.\n+\t(choose_enum_order): New function.\n+\t(write_enum_constraint_num): Iterate over enum_order.\n+\t(write_regclass_for_constraint): Rename to...\n+\t(write_reg_class_for_constraint_1): ...this and update output\n+\taccordingly.\n+\t(write_constraint_satisfied_p): Rename to...\n+\t(write_constraint_satisfied_p_1): ...this and update output\n+\taccordingly.  Do nothing if all extra constraints are register\n+\tconstraints.\n+\t(write_insn_extra_memory_constraint): Delete.\n+\t(write_insn_extra_address_constraint): Delete.\n+\t(write_range_function): New function.\n+\t(write_tm_preds_h): Define constraint_satisfied_p and\n+\treg_class_for_constraint as inline functions that do a range check\n+\tbefore calling the out-of-line function.  Use write_range_function\n+\tto implement insn_extra_{register,memory,address}_constraint,\n+\tthe first of which is new.\n+\t(write_insn_preds_c): Update after above changes to write_* functions.\n+\t(main): Call choose_enum_order.\n+\n 2014-06-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR tree-optimization/61306"}, {"sha": "27a8f49182088aeec565f19f41a6a50175936930", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "patch": "@@ -4414,7 +4414,7 @@ specifies a register constraint, this function will always return\n @code{false}.\n @end deftypefun\n \n-@deftypefun {enum reg_class} regclass_for_constraint (enum constraint_num @var{c})\n+@deftypefun {enum reg_class} reg_class_for_constraint (enum constraint_num @var{c})\n Returns the register class associated with @var{c}.  If @var{c} is not\n a register constraint, or those registers are not available for the\n currently selected subtarget, returns @code{NO_REGS}."}, {"sha": "3edd233f05a894b7f131d4ee2ae660feca2e1600", "filename": "gcc/genpreds.c", "status": "modified", "additions": 124, "deletions": 72, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aeedf58e0dc23cc6b6167f4ed747d637c8c0803/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=2aeedf58e0dc23cc6b6167f4ed747d637c8c0803", "patch": "@@ -685,6 +685,13 @@ static bool have_address_constraints;\n static bool have_extra_constraints;\n static bool have_const_int_constraints;\n static bool have_const_dbl_constraints;\n+static unsigned int num_constraints;\n+\n+static const constraint_data **enum_order;\n+static unsigned int register_start, register_end;\n+static unsigned int satisfied_start;\n+static unsigned int memory_start, memory_end;\n+static unsigned int address_start, address_end;\n \n /* Convert NAME, which contains angle brackets and/or underscores, to\n    a string that can be used as part of a C identifier.  The string\n@@ -884,6 +891,7 @@ add_constraint (const char *name, const char *regclass,\n   have_extra_constraints |= c->is_extra;\n   have_memory_constraints |= c->is_memory;\n   have_address_constraints |= c->is_address;\n+  num_constraints += 1;\n }\n \n /* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT, or\n@@ -904,19 +912,54 @@ process_define_register_constraint (rtx c, int lineno)\n   add_constraint (XSTR (c, 0), XSTR (c, 1), 0, false, false, lineno);\n }\n \n+/* Put the constraints into enum order.  We want to keep constraints\n+   of the same type together so that query functions can be simple\n+   range checks.  */\n+static void\n+choose_enum_order (void)\n+{\n+  struct constraint_data *c;\n+\n+  enum_order = XNEWVEC (const constraint_data *, num_constraints);\n+  unsigned int next = 0;\n+\n+  register_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_register)\n+      enum_order[next++] = c;\n+  register_end = next;\n+\n+  satisfied_start = next;\n+\n+  memory_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_memory)\n+      enum_order[next++] = c;\n+  memory_end = next;\n+\n+  address_start = next;\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_address)\n+      enum_order[next++] = c;\n+  address_end = next;\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (!c->is_register && !c->is_memory && !c->is_address)\n+      enum_order[next++] = c;\n+  gcc_assert (next == num_constraints);\n+}\n+\n /* Write out an enumeration with one entry per machine-specific\n    constraint.  */\n static void\n write_enum_constraint_num (void)\n {\n-  struct constraint_data *c;\n-\n   fputs (\"#define CONSTRAINT_NUM_DEFINED_P 1\\n\", stdout);\n   fputs (\"enum constraint_num\\n\"\n \t \"{\\n\"\n \t \"  CONSTRAINT__UNKNOWN = 0\", stdout);\n-  FOR_ALL_CONSTRAINTS (c)\n-    printf (\",\\n  CONSTRAINT_%s\", c->c_name);\n+  for (unsigned int i = 0; i < num_constraints; ++i)\n+    printf (\",\\n  CONSTRAINT_%s\", enum_order[i]->c_name);\n   puts (\",\\n  CONSTRAINT__LIMIT\\n};\\n\");\n }\n \n@@ -1010,12 +1053,12 @@ write_insn_constraint_len (void)\n /* Write out the function which computes the register class corresponding\n    to a register constraint.  */\n static void\n-write_regclass_for_constraint (void)\n+write_reg_class_for_constraint_1 (void)\n {\n   struct constraint_data *c;\n \n   puts (\"enum reg_class\\n\"\n-\t\"regclass_for_constraint (enum constraint_num c)\\n\"\n+\t\"reg_class_for_constraint_1 (enum constraint_num c)\\n\"\n \t\"{\\n\"\n \t\"  switch (c)\\n\"\n \t\"    {\");\n@@ -1100,12 +1143,15 @@ write_tm_constrs_h (void)\n    a CONSTRAINT_xxx constant to one of the predicate functions generated\n    above.  */\n static void\n-write_constraint_satisfied_p (void)\n+write_constraint_satisfied_p_1 (void)\n {\n   struct constraint_data *c;\n \n+  if (satisfied_start == num_constraints)\n+    return;\n+\n   puts (\"bool\\n\"\n-\t\"constraint_satisfied_p (rtx op, enum constraint_num c)\\n\"\n+\t\"constraint_satisfied_p_1 (rtx op, enum constraint_num c)\\n\"\n \t\"{\\n\"\n \t\"  switch (c)\\n\"\n \t\"    {\");\n@@ -1153,55 +1199,26 @@ write_insn_const_int_ok_for_constraint (void)\n \t\"  return false;\\n\"\n \t\"}\\n\");\n }\n-\n-\n-/* Write out the function which computes whether a given constraint is\n-   a memory constraint.  */\n-static void\n-write_insn_extra_memory_constraint (void)\n-{\n-  struct constraint_data *c;\n-\n-  puts (\"bool\\n\"\n-\t\"insn_extra_memory_constraint (enum constraint_num c)\\n\"\n-\t\"{\\n\"\n-\t\"  switch (c)\\n\"\n-\t\"    {\");\n-\n-  FOR_ALL_CONSTRAINTS (c)\n-    if (c->is_memory)\n-      printf (\"    case CONSTRAINT_%s:\\n      return true;\\n\\n\", c->c_name);\n-\n-  puts (\"    default: break;\\n\"\n-\t\"    }\\n\"\n-\t\"  return false;\\n\"\n-\t\"}\\n\");\n-}\n-\n-/* Write out the function which computes whether a given constraint is\n-   an address constraint.  */\n+\f\n+/* Write a definition for a function NAME that returns true if a given\n+   constraint_num is in the range [START, END).  */\n static void\n-write_insn_extra_address_constraint (void)\n+write_range_function (const char *name, unsigned int start, unsigned int end)\n {\n-  struct constraint_data *c;\n-\n-  puts (\"bool\\n\"\n-\t\"insn_extra_address_constraint (enum constraint_num c)\\n\"\n-\t\"{\\n\"\n-\t\"  switch (c)\\n\"\n-\t\"    {\");\n-\n-  FOR_ALL_CONSTRAINTS (c)\n-    if (c->is_address)\n-      printf (\"    case CONSTRAINT_%s:\\n      return true;\\n\\n\", c->c_name);\n-\n-  puts (\"    default: break;\\n\"\n-\t\"    }\\n\"\n-\t\"  return false;\\n\"\n-\t\"}\\n\");\n+  printf (\"static inline bool\\n\");\n+  if (start != end)\n+    printf (\"%s (enum constraint_num c)\\n\"\n+\t    \"{\\n\"\n+\t    \"  return c >= CONSTRAINT_%s && c <= CONSTRAINT_%s;\\n\"\n+\t    \"}\\n\\n\",\n+\t    name, enum_order[start]->c_name, enum_order[end - 1]->c_name);\n+  else\n+    printf (\"%s (enum constraint_num)\\n\"\n+\t    \"{\\n\"\n+\t    \"  return false;\\n\"\n+\t    \"}\\n\\n\", name);\n }\n \n-\f\n /* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare\n    an enumeration in portable C, so we have to condition all these\n    prototypes on HAVE_MACHINE_MODES.  */\n@@ -1228,8 +1245,36 @@ write_tm_preds_h (void)\n   if (constraint_max_namelen > 0)\n     {\n       write_enum_constraint_num ();\n-      puts (\"extern enum constraint_num lookup_constraint (const char *);\\n\"\n-\t    \"extern bool constraint_satisfied_p (rtx, enum constraint_num);\\n\");\n+      puts (\"extern enum constraint_num lookup_constraint (const char *);\");\n+      if (satisfied_start == num_constraints)\n+\tputs (\"/* Return true if X satisfies constraint C.  */\\n\"\n+\t      \"\\n\"\n+\t      \"static inline bool\\n\"\n+\t      \"constraint_satisfied_p (rtx, enum constraint_num)\\n\"\n+\t      \"{\\n\"\n+\t      \"  return false;\\n\"\n+\t      \"}\\n\");\n+      else\n+\tprintf (\"extern bool constraint_satisfied_p_1 (rtx,\"\n+\t\t\" enum constraint_num);\\n\"\n+\t\t\"\\n\"\n+\t\t\"/* Return true if X satisfies constraint C.  */\\n\"\n+\t\t\"\\n\"\n+\t\t\"static inline bool\\n\"\n+\t\t\"constraint_satisfied_p (rtx x, enum constraint_num c)\\n\"\n+\t\t\"{\\n\"\n+\t\t\"  return c >= CONSTRAINT_%s\"\n+\t\t\" && constraint_satisfied_p_1 (x, c);\\n\"\n+\t\t\"}\\n\"\n+\t\t\"\\n\",\n+\t\tenum_order[satisfied_start]->name);\n+\n+      write_range_function (\"insn_extra_register_constraint\",\n+\t\t\t    register_start, register_end);\n+      write_range_function (\"insn_extra_memory_constraint\",\n+\t\t\t    memory_start, memory_end);\n+      write_range_function (\"insn_extra_address_constraint\",\n+\t\t\t    address_start, address_end);\n \n       if (constraint_max_namelen > 1)\n         {\n@@ -1240,14 +1285,28 @@ write_tm_preds_h (void)\n       else\n \tputs (\"#define CONSTRAINT_LEN(c_,s_) 1\\n\");\n       if (have_register_constraints)\n-\tputs (\"extern enum reg_class regclass_for_constraint \"\n+\tputs (\"extern enum reg_class reg_class_for_constraint_1 \"\n \t      \"(enum constraint_num);\\n\"\n+\t      \"\\n\"\n+\t      \"static inline enum reg_class\\n\"\n+\t      \"reg_class_for_constraint (enum constraint_num c)\\n\"\n+\t      \"{\\n\"\n+\t      \"  if (insn_extra_register_constraint (c))\\n\"\n+\t      \"    return reg_class_for_constraint_1 (c);\\n\"\n+\t      \"  return NO_REGS;\\n\"\n+\t      \"}\\n\"\n+\t      \"\\n\"\n \t      \"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) \\\\\\n\"\n-\t      \"    regclass_for_constraint (lookup_constraint (s_))\\n\"\n+\t      \"    reg_class_for_constraint (lookup_constraint (s_))\\n\"\n \t      \"#define REG_CLASS_FOR_CONSTRAINT(x_) \\\\\\n\"\n-\t      \"    regclass_for_constraint (x_)\\n\");\n+\t      \"    reg_class_for_constraint (x_)\\n\");\n       else\n-\tputs (\"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) NO_REGS\\n\"\n+\tputs (\"static inline enum reg_class\\n\"\n+\t      \"reg_class_for_constraint (enum constraint_num)\\n\"\n+\t      \"{\\n\"\n+\t      \"  return NO_REGS;\\n\"\n+\t      \"}\\n\\n\"\n+\t      \"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) NO_REGS\\n\"\n \t      \"#define REG_CLASS_FOR_CONSTRAINT(x_) \\\\\\n\"\n \t      \"    NO_REGS\\n\");\n       if (have_const_int_constraints)\n@@ -1265,16 +1324,12 @@ write_tm_preds_h (void)\n \tputs (\"#define EXTRA_CONSTRAINT_STR(v_,c_,s_) \\\\\\n\"\n \t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n       if (have_memory_constraints)\n-\tputs (\"extern bool \"\n-\t      \"insn_extra_memory_constraint (enum constraint_num);\\n\"\n-\t      \"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) \"\n+\tputs (\"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) \"\n \t      \"insn_extra_memory_constraint (lookup_constraint (s_))\\n\");\n       else\n \tputs (\"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) false\\n\");\n       if (have_address_constraints)\n-\tputs (\"extern bool \"\n-\t      \"insn_extra_address_constraint (enum constraint_num);\\n\"\n-\t      \"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) \"\n+\tputs (\"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) \"\n \t      \"insn_extra_address_constraint (lookup_constraint (s_))\\n\");\n       else\n \tputs (\"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) false\\n\");\n@@ -1330,16 +1385,11 @@ write_insn_preds_c (void)\n     {\n       write_lookup_constraint ();\n       if (have_register_constraints)\n-\twrite_regclass_for_constraint ();\n-      write_constraint_satisfied_p ();\n+\twrite_reg_class_for_constraint_1 ();\n+      write_constraint_satisfied_p_1 ();\n \n       if (have_const_int_constraints)\n \twrite_insn_const_int_ok_for_constraint ();\n-\n-      if (have_memory_constraints)\n-\twrite_insn_extra_memory_constraint ();\n-      if (have_address_constraints)\n-\twrite_insn_extra_address_constraint ();\n     }\n }\n \n@@ -1399,6 +1449,8 @@ main (int argc, char **argv)\n \tbreak;\n       }\n \n+  choose_enum_order ();\n+\n   if (gen_header)\n     write_tm_preds_h ();\n   else if (gen_constrs)"}]}