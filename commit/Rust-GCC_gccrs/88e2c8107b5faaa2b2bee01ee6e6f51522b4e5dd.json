{"sha": "88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlMmM4MTA3YjVmYWFhMmIyYmVlMDFlZTZlNmY1MTUyMmI0ZTVkZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-07-31T18:08:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-07-31T18:08:36Z"}, "message": "re PR rtl-optimization/36419 (Wrong unwind info with -Os -fasynchronous-unwind-tables)\n\n\tPR rtl-optimization/36419\n\t* dwarf2out.c (barrier_args_size): New variable.\n\t(compute_barrier_args_size, compute_barrier_args_size_1): New\n\tfunctions.\n\t(dwarf2out_stack_adjust): For BARRIERs call compute_barrier_args_size\n\tif not called yet in the current function, use barrier_args_size\n\tarray to find the new args_size value.\n\t(dwarf2out_frame_debug): Free and clear barrier_args_size.\n\n\t* g++.dg/eh/async-unwind2.C: New test.\n\nFrom-SVN: r138427", "tree": {"sha": "9ac1473b1819c6c87fa2981649c1d918ce6b312a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ac1473b1819c6c87fa2981649c1d918ce6b312a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41b059f3d869b456bec3eee7e3eb0ed5ba0a9300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b059f3d869b456bec3eee7e3eb0ed5ba0a9300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41b059f3d869b456bec3eee7e3eb0ed5ba0a9300"}], "stats": {"total": 446, "additions": 439, "deletions": 7}, "files": [{"sha": "28a956c443e30d415d6387d6b5e24b8e7608a21c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "patch": "@@ -1,3 +1,14 @@\n+2008-07-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/36419\n+\t* dwarf2out.c (barrier_args_size): New variable.\n+\t(compute_barrier_args_size, compute_barrier_args_size_1): New\n+\tfunctions.\n+\t(dwarf2out_stack_adjust): For BARRIERs call compute_barrier_args_size\n+\tif not called yet in the current function, use barrier_args_size\n+\tarray to find the new args_size value.\n+\t(dwarf2out_frame_debug): Free and clear barrier_args_size.\n+\n 2008-07-31  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR debug/36980"}, {"sha": "1219892f2002dcb2e7f286fc0aaaf4eec10ddaeb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 171, "deletions": 7, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "patch": "@@ -1156,6 +1156,162 @@ stack_adjust_offset (const_rtx pattern)\n   return offset;\n }\n \n+/* Precomputed args_size for CODE_LABELs and BARRIERs preceeding them,\n+   indexed by INSN_UID.  */\n+\n+static HOST_WIDE_INT *barrier_args_size;\n+\n+/* Helper function for compute_barrier_args_size.  Handle one insn.  */\n+\n+static HOST_WIDE_INT\n+compute_barrier_args_size_1 (rtx insn, HOST_WIDE_INT cur_args_size,\n+\t\t\t     VEC (rtx, heap) **next)\n+{\n+  HOST_WIDE_INT offset = 0;\n+  int i;\n+\n+  if (! RTX_FRAME_RELATED_P (insn))\n+    {\n+      if (prologue_epilogue_contains (insn)\n+\t  || sibcall_epilogue_contains (insn))\n+\t/* Nothing */;\n+      else if (GET_CODE (PATTERN (insn)) == SET)\n+\toffset = stack_adjust_offset (PATTERN (insn));\n+      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t{\n+\t  /* There may be stack adjustments inside compound insns.  Search\n+\t     for them.  */\n+\t  for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n+\t      offset += stack_adjust_offset (XVECEXP (PATTERN (insn), 0, i));\n+\t}\n+    }\n+  else\n+    {\n+      rtx expr = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n+\n+      if (expr)\n+\t{\n+\t  expr = XEXP (expr, 0);\n+\t  if (GET_CODE (expr) == PARALLEL\n+\t      || GET_CODE (expr) == SEQUENCE)\n+\t    for (i = 1; i < XVECLEN (expr, 0); i++)\n+\t      {\n+\t\trtx elem = XVECEXP (expr, 0, i);\n+\n+\t\tif (GET_CODE (elem) == SET && !RTX_FRAME_RELATED_P (elem))\n+\t\t  offset += stack_adjust_offset (elem);\n+\t      }\n+\t}\n+    }\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  offset = -offset;\n+#endif\n+\n+  cur_args_size += offset;\n+  if (cur_args_size < 0)\n+    cur_args_size = 0;\n+\n+  if (JUMP_P (insn))\n+    {\n+      rtx dest = JUMP_LABEL (insn);\n+\n+      if (dest)\n+\t{\n+\t  if (barrier_args_size [INSN_UID (dest)] < 0)\n+\t    {\n+\t      barrier_args_size [INSN_UID (dest)] = cur_args_size;\n+\t      VEC_safe_push (rtx, heap, *next, dest);\n+\t    }\n+\t  else\n+\t    gcc_assert (barrier_args_size[INSN_UID (dest)]\n+\t\t\t== cur_args_size);\n+\t}\n+    }\n+\n+  return cur_args_size;\n+}\n+\n+/* Walk the whole function and compute args_size on BARRIERs.  */\n+\n+static void\n+compute_barrier_args_size (void)\n+{\n+  int max_uid = get_max_uid (), i;\n+  rtx insn;\n+  VEC (rtx, heap) *worklist, *next, *tmp;\n+\n+  barrier_args_size = XNEWVEC (HOST_WIDE_INT, max_uid);\n+  for (i = 0; i < max_uid; i++)\n+    barrier_args_size[i] = -1;\n+\n+  worklist = VEC_alloc (rtx, heap, 20);\n+  next = VEC_alloc (rtx, heap, 20);\n+  insn = get_insns ();\n+  barrier_args_size[INSN_UID (insn)] = 0;\n+  VEC_quick_push (rtx, worklist, insn);\n+  for (;;)\n+    {\n+      while (!VEC_empty (rtx, worklist))\n+\t{\n+\t  rtx prev, body;\n+\t  HOST_WIDE_INT cur_args_size;\n+\n+\t  insn = VEC_pop (rtx, worklist);\n+\t  cur_args_size = barrier_args_size[INSN_UID (insn)];\n+\t  prev = prev_nonnote_insn (insn);\n+\t  if (prev && BARRIER_P (prev))\n+\t    barrier_args_size[INSN_UID (prev)] = cur_args_size;\n+\n+\t  for (; insn; insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (INSN_DELETED_P (insn) || NOTE_P (insn))\n+\t\tcontinue;\n+\t      if (BARRIER_P (insn))\n+\t\tbreak;\n+\n+\t      if (LABEL_P (insn))\n+\t\t{\n+\t\t  gcc_assert (barrier_args_size[INSN_UID (insn)] < 0\n+\t\t\t      || barrier_args_size[INSN_UID (insn)]\n+\t\t\t\t  == cur_args_size);\n+\t\t  continue;\n+\t\t}\n+\n+\t      body = PATTERN (insn);\n+\t      if (GET_CODE (body) == SEQUENCE)\n+\t\t{\n+\t\t  for (i = 1; i < XVECLEN (body, 0); i++)\n+\t\t    cur_args_size\n+\t\t      = compute_barrier_args_size_1 (XVECEXP (body, 0, i),\n+\t\t\t\t\t\t     cur_args_size, &next);\n+\t\t  cur_args_size\n+\t\t    = compute_barrier_args_size_1 (XVECEXP (body, 0, 0),\n+\t\t\t\t\t\t   cur_args_size, &next);\n+\t\t}\n+\t      else\n+\t\tcur_args_size\n+\t\t  = compute_barrier_args_size_1 (insn, cur_args_size, &next);\n+\t    }\n+\t}\n+\n+      if (VEC_empty (rtx, next))\n+\tbreak;\n+\n+      /* Swap WORKLIST with NEXT and truncate NEXT for next iteration.  */\n+      tmp = next;\n+      next = worklist;\n+      worklist = tmp;\n+      VEC_truncate (rtx, next, 0);\n+    }\n+\n+  VEC_free (rtx, heap, worklist);\n+  VEC_free (rtx, heap, next);\n+}\n+\n+\n /* Check INSN to see if it looks like a push or a stack adjustment, and\n    make a note of it if it does.  EH uses this information to find out how\n    much extra space it needs to pop off the stack.  */\n@@ -1200,13 +1356,15 @@ dwarf2out_stack_adjust (rtx insn, bool after_p)\n     }\n   else if (BARRIER_P (insn))\n     {\n-      /* When we see a BARRIER, we know to reset args_size to 0.  Usually\n-\t the compiler will have already emitted a stack adjustment, but\n-\t doesn't bother for calls to noreturn functions.  */\n-#ifdef STACK_GROWS_DOWNWARD\n-      offset = -args_size;\n-#else\n-      offset = args_size;\n+      if (barrier_args_size == NULL)\n+\tcompute_barrier_args_size ();\n+      offset = barrier_args_size[INSN_UID (insn)];\n+      if (offset < 0)\n+\toffset = 0;\n+\n+      offset -= args_size;\n+#ifndef STACK_GROWS_DOWNWARD\n+      offset = -offset;\n #endif\n     }\n   else if (GET_CODE (PATTERN (insn)) == SET)\n@@ -2160,6 +2318,12 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \t  regs_saved_in_regs[i].saved_in_reg = NULL_RTX;\n \t}\n       num_regs_saved_in_regs = 0;\n+\n+      if (barrier_args_size)\n+\t{\n+\t  XDELETEVEC (barrier_args_size);\n+\t  barrier_args_size = NULL;\n+\t}\n       return;\n     }\n "}, {"sha": "0d2ebbf6a7f81e6f1e37d0dda54a10ed9f848aa5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "patch": "@@ -1,5 +1,8 @@\n 2008-07-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR rtl-optimization/36419\n+\t* g++.dg/eh/async-unwind2.C: New test.\n+\n \tPR c++/36405\n \t* g++.dg/rtti/typeid8.C: New test.\n "}, {"sha": "694fad6aca1a1548774d3eefa31e7688483082b5", "filename": "gcc/testsuite/g++.dg/eh/async-unwind2.C", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fasync-unwind2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fasync-unwind2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fasync-unwind2.C?ref=88e2c8107b5faaa2b2bee01ee6e6f51522b4e5dd", "patch": "@@ -0,0 +1,254 @@\n+// PR rtl-optimization/36419\n+// { dg-do run { target { { i?86-*-* x86_64-*-* } && ilp32 } } }\n+// { dg-options \"-Os -fasynchronous-unwind-tables -fpic -fno-inline\" }\n+\n+#include <stdarg.h>\n+\n+extern \"C\" void abort ();\n+\n+extern \"C\"\n+{\n+  struct R { int r1; unsigned short r2[1]; };\n+  int bar1 (unsigned short *, int, short) throw ();\n+  void bar2 (R *) throw ();\n+  void bar3 (R **, const unsigned short *, int) throw ();\n+  void bar4 (R **, const char *) throw ();\n+  void bar5 (void *, const char *, ...);\n+}\n+\n+struct S\n+{\n+  R *s;\n+  struct T { };\n+  S (R *x, T *) { s = x; }\n+  ~S () { bar2 (s); }\n+  S &operator= (const S &x);\n+  S &operator+= (const S &x);\n+  S sfn1 (const S &x) const;\n+  friend S operator+ (const S &x1, const S &x2);\n+  static S sfn2 (int i)\n+  {\n+    unsigned short q[33];\n+    R *p = 0;\n+    bar3 (&p, q, bar1 (q, i, 10));\n+    return S (p, (T *) 0);\n+  }\n+  static S sfn3 (const char *x)\n+  {\n+    R *p = 0;\n+    bar4 (&p, x);\n+    return S (p, (T *) 0);\n+  }\n+};\n+\n+struct U { };\n+template <class C> unsigned char operator >>= (const U &, C &);\n+\n+struct V;\n+struct W\n+{\n+  V *w;\n+  unsigned char is () const;\n+};\n+\n+template <class T> struct X : public W\n+{\n+  inline ~X ();\n+  X ();\n+  X (const W &);\n+  T *operator -> () const;\n+};\n+\n+struct E\n+{\n+  E ();\n+  E (const S &, const X <V> &);\n+  E (E const &);\n+  ~E ();\n+  E &operator = (E const &);\n+};\n+\n+struct V\n+{\n+  virtual void release () throw ();\n+};\n+\n+template <class T> X <T>::~X ()\n+{\n+  if (w)\n+    w->release ();\n+}\n+\n+struct Y\n+{\n+  virtual U yfn1 (const S &);\n+};\n+\n+struct Z;\n+\n+X <V> baz1 (const S &) throw (E);\n+X <Z> baz2 (const X <Z> &) throw (E);\n+\n+template <typename T> X<T>::X ()\n+{\n+  w = __null;\n+}\n+\n+template <typename T> X<T>::X (W const &)\n+{\n+  w = __null;\n+}\n+\n+U Y::yfn1 (const S &)\n+{\n+  throw 12;\n+}\n+\n+Y y;\n+\n+template <typename T> T *X<T>::operator -> () const\n+{\n+  return &y;\n+}\n+\n+X <V> baz1 (const S &) throw (E)\n+{\n+  return X<V> ();\n+}\n+\n+E::E ()\n+{\n+}\n+\n+E::~E ()\n+{\n+}\n+\n+X <Z> baz2 (const X <Z> &) throw (E)\n+{\n+  throw E ();\n+}\n+\n+int bar1 (unsigned short *, int, short) throw ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+  return 0;\n+}\n+\n+void bar2 (R *) throw ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+void bar3 (R **, const unsigned short *, int) throw ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+void bar4 (R **, const char *) throw ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+int events[2];\n+void *sp;\n+\n+void bar5 (void *p, const char *s, ...)\n+{\n+  va_list ap;\n+  va_start (ap, s);\n+  if (p)\n+    throw 19;\n+  switch (*s)\n+    {\n+    case 't':\n+      if (events[0] != va_arg (ap, int))\n+\tabort ();\n+      events[0]++;\n+      break;\n+    case 'f':\n+      abort ();\n+    case 'c':\n+      if (events[1] != va_arg (ap, int))\n+\tabort ();\n+      events[1]++;\n+      if (events[1] == 1)\n+\tsp = va_arg (ap, void *);\n+      else if (sp != va_arg (ap, void *))\n+\tabort ();\n+      break;\n+    }\n+}\n+\n+unsigned char W::is () const\n+{\n+  return 1;\n+}\n+\n+S &S::operator += (const S &)\n+{\n+  return *this;\n+}\n+\n+template <class C> unsigned char operator >>= (const U &, C &)\n+{\n+  throw 1;\n+}\n+\n+template X<Y>::X ();\n+template X<Z>::X ();\n+template unsigned char operator >>= (const U &, X<Z> &);\n+template X<Y>::X (W const &);\n+\n+template Y *X<Y>::operator-> () const;\n+\n+X <Z> foo () throw ()\n+{\n+  X <Z> a;\n+  X <Y> b;\n+  try\n+  {\n+    b = X <Y> (baz1 (S::sfn3 (\"defg\")));\n+  }\n+  catch (E &)\n+  {\n+  }\n+  if (b.is ())\n+    {\n+      for (int n = 0; n < 10; n++)\n+\t{\n+\t  S c = S::sfn3 (\"abcd\");\n+\t  c += S::sfn2 (n);\n+\t  X <Z> d;\n+\t  try\n+\t  {\n+\t    bar5 ((void *) 0, \"trying %d\\n\", n);\n+\t    if ((b->yfn1 (c) >>= d))\n+\t      if (d.is ())\n+\t\t{\n+\t\t  bar5 ((void *) 0, \"failure1 on %d\\n\", n);\n+\t\t  a = baz2 (d);\n+\t\t  if (a.is ())\n+\t\t    break;\n+\t\t}\n+\t      bar5 ((void *) 0, \"failure2 on %d\\n\", n);\n+\t  }\n+\t  catch (...)\n+\t  {\n+\t    void *p;\n+\t    asm volatile (\"movl %%esp, %0\" : \"=r\" (p));\n+\t    bar5 ((void *) 0, \"caught %d %p\\n\", n, p);\n+\t  }\n+\t}\n+    }\n+  return a;\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  if (events[0] != 10 || events[1] != 10)\n+    abort ();\n+  return 0;\n+}"}]}