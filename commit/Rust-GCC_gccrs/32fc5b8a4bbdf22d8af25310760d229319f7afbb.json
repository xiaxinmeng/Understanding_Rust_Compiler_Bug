{"sha": "32fc5b8a4bbdf22d8af25310760d229319f7afbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJmYzViOGE0YmJkZjIyZDhhZjI1MzEwNzYwZDIyOTMxOWY3YWZiYg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2013-01-22T20:58:37Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-01-22T20:58:37Z"}, "message": "re PR target/56028 (Splitting a 64-bit volatile store)\n\n\tPR target/56028\n\t* config/i386/i386.md (*movti_internal_rex64): Change (o,riF)\n\talternative to (o,r).\n\t(*movdi_internal_rex64): Remove (!o,n) alternative.\n\t(DImode immediate->memory splitter): Remove.\n\t(DImode immediate->memory peephole2): Remove.\n\t(movtf): Enable for TARGET_64BIT || TARGET_SSE.\n\t(*movtf_internal_rex64): Rename from *movtf_internal. Change (!o,F*r)\n\talternative to (!o,*r).\n\t(*movtf_internal_sse): New pattern.\n\t(*movxf_internal_rex64): New pattern.\n\t(*movxf_internal): Disable for TARGET_64BIT.\n\t(*movdf_internal_rex64): Remove (!o,F) alternative.\n\ntestsuite/ChangeLog:\n\n2012-01-22  Uros Bizjak  <ubizjak@gmail.com>\n\n\tPR target/56028\n\t* gcc.target/i386/pr56028.c: New test.\n\nFrom-SVN: r195386", "tree": {"sha": "8226453e17a4937086d6a589be0e9b7f3be43c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8226453e17a4937086d6a589be0e9b7f3be43c80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32fc5b8a4bbdf22d8af25310760d229319f7afbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32fc5b8a4bbdf22d8af25310760d229319f7afbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32fc5b8a4bbdf22d8af25310760d229319f7afbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32fc5b8a4bbdf22d8af25310760d229319f7afbb/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a18c815f9567ee8b9f3be6badd68ae5648c467e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a18c815f9567ee8b9f3be6badd68ae5648c467e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a18c815f9567ee8b9f3be6badd68ae5648c467e"}], "stats": {"total": 265, "additions": 192, "deletions": 73}, "files": [{"sha": "bdf173f9b4d05a594b1c3e5a6a173c928c3e82d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32fc5b8a4bbdf22d8af25310760d229319f7afbb", "patch": "@@ -1,3 +1,19 @@\n+2012-01-22  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/56028\n+\t* config/i386/i386.md (*movti_internal_rex64): Change (o,riF)\n+\talternative to (o,r).\n+\t(*movdi_internal_rex64): Remove (!o,n) alternative.\n+\t(DImode immediate->memory splitter): Remove.\n+\t(DImode immediate->memory peephole2): Remove.\n+\t(movtf): Enable for TARGET_64BIT || TARGET_SSE.\n+\t(*movtf_internal_rex64): Rename from *movtf_internal. Change (!o,F*r)\n+\talternative to (!o,*r).\n+\t(*movtf_internal_sse): New pattern.\n+\t(*movxf_internal_rex64): New pattern.\n+\t(*movxf_internal): Disable for TARGET_64BIT.\n+\t(*movdf_internal_rex64): Remove (!o,F) alternative.\n+\n 2013-01-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/56074"}, {"sha": "a15a803240f4279b3e8ff29f9cfc425722d9ce74", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 117, "deletions": 73, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=32fc5b8a4bbdf22d8af25310760d229319f7afbb", "patch": "@@ -1757,8 +1757,8 @@\n \t      (const_string \"OI\")))])\n \n (define_insn \"*movti_internal_rex64\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=!r ,o  ,x,x ,m\")\n-\t(match_operand:TI 1 \"general_operand\"      \"riFo,riF,C,xm,x\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=!r ,o,x,x ,m\")\n+\t(match_operand:TI 1 \"general_operand\"      \"riFo,r,C,xm,x\"))]\n   \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (which_alternative)\n@@ -1867,9 +1867,9 @@\n \n (define_insn \"*movdi_internal_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t  \"=r,r  ,r,m ,!o,*y,m*y,?*y,?r ,?*Ym,*x,m ,*x,*x,?r ,?*Yi,?*x,?*Ym\")\n+\t  \"=r,r  ,r,m ,*y,m*y,?*y,?r ,?*Ym,*x,m ,*x,*x,?r ,?*Yi,?*x,?*Ym\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t  \"Z ,rem,i,re,n ,C ,*y ,m  ,*Ym,r   ,C ,*x,*x,m ,*Yi,r   ,*Ym,*x\"))]\n+\t  \"Z ,rem,i,re,C ,*y ,m  ,*Ym,r   ,C ,*x,*x,m ,*Yi,r   ,*Ym,*x\"))]\n   \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -1905,9 +1905,6 @@\n     case TYPE_MMX:\n       return \"pxor\\t%0, %0\";\n \n-    case TYPE_MULTI:\n-      return \"#\";\n-\n     case TYPE_LEA:\n       return \"lea{q}\\t{%E1, %0|%0, %E1}\";\n \n@@ -1925,16 +1922,14 @@\n }\n   [(set (attr \"type\")\n      (cond [(eq_attr \"alternative\" \"4\")\n-\t      (const_string \"multi\")\n-\t    (eq_attr \"alternative\" \"5\")\n \t      (const_string \"mmx\")\n-\t    (eq_attr \"alternative\" \"6,7,8,9\")\n+\t    (eq_attr \"alternative\" \"5,6,7,8\")\n \t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"10\")\n+\t    (eq_attr \"alternative\" \"9\")\n \t      (const_string \"sselog1\")\n-\t    (eq_attr \"alternative\" \"11,12,13,14,15\")\n+\t    (eq_attr \"alternative\" \"10,11,12,13,14\")\n \t      (const_string \"ssemov\")\n-\t    (eq_attr \"alternative\" \"16,17\")\n+\t    (eq_attr \"alternative\" \"15,16\")\n \t      (const_string \"ssecvt\")\n  \t    (match_operand 1 \"pic_32bit_operand\")\n \t      (const_string \"lea\")\n@@ -1951,21 +1946,21 @@\n \t (const_string \"8\")\n \t (const_string \"*\")))\n    (set (attr \"prefix_rex\")\n-     (if_then_else (eq_attr \"alternative\" \"8,9\")\n+     (if_then_else (eq_attr \"alternative\" \"7,8\")\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set (attr \"prefix_data16\")\n-     (if_then_else (eq_attr \"alternative\" \"11\")\n+     (if_then_else (eq_attr \"alternative\" \"10\")\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"10,11,12,13,14,15\")\n+     (if_then_else (eq_attr \"alternative\" \"9,10,11,12,13,14\")\n        (const_string \"maybe_vex\")\n        (const_string \"orig\")))\n    (set (attr \"mode\")\n-   \t(cond [(eq_attr \"alternative\" \"0,4\")\n+   \t(cond [(eq_attr \"alternative\" \"0\")\n \t\t  (const_string \"SI\")\n-\t       (eq_attr \"alternative\" \"10,12\")\n+\t       (eq_attr \"alternative\" \"9,11\")\n \t\t  (cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n \t\t\t   (const_string \"V4SF\")\n \t\t\t (match_test \"TARGET_AVX\")\n@@ -2011,41 +2006,6 @@\n   DONE;\n })\n \n-;; Convert impossible stores of immediate to existing instructions.\n-;; First try to get scratch register and go through it.  In case this\n-;; fails, move by 32bit parts.\n-(define_peephole2\n-  [(match_scratch:DI 2 \"r\")\n-   (set (match_operand:DI 0 \"memory_operand\")\n-        (match_operand:DI 1 \"immediate_operand\"))]\n-  \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n-   && !x86_64_immediate_operand (operands[1], DImode)\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (match_dup 2))])\n-\n-;; We need to define this as both peepholer and splitter for case\n-;; peephole2 pass is not run.\n-;; \"&& 1\" is needed to keep it from matching the previous pattern.\n-(define_peephole2\n-  [(set (match_operand:DI 0 \"memory_operand\")\n-        (match_operand:DI 1 \"immediate_operand\"))]\n-  \"TARGET_64BIT && !symbolic_operand (operands[1], DImode)\n-   && !x86_64_immediate_operand (operands[1], DImode) && 1\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n-  \"split_double_mode (DImode, &operands[0], 2, &operands[2], &operands[4]);\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"memory_operand\")\n-        (match_operand:DI 1 \"immediate_operand\"))]\n-  \"TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t    ? epilogue_completed : reload_completed)\n-   && !symbolic_operand (operands[1], DImode)\n-   && !x86_64_immediate_operand (operands[1], DImode)\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n-  \"split_double_mode (DImode, &operands[0], 2, &operands[2], &operands[4]);\")\n-\n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n \t  \"=r  ,o  ,*y,m*y,*y,*x,m ,*x,*x,*x,m ,*x,*x,?*x,?*Ym\")\n@@ -2773,7 +2733,7 @@\n (define_expand \"movtf\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\")\n \t(match_operand:TF 1 \"nonimmediate_operand\"))]\n-  \"TARGET_SSE\"\n+  \"TARGET_64BIT || TARGET_SSE\"\n {\n   ix86_expand_move (TFmode, operands);\n   DONE;\n@@ -2785,11 +2745,10 @@\n   \"\"\n   \"ix86_expand_move (<MODE>mode, operands); DONE;\")\n \n-(define_insn \"*movtf_internal\"\n+(define_insn \"*movtf_internal_rex64\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,x ,m,?*r ,!o\")\n-\t(match_operand:TF 1 \"general_operand\"\t   \"C ,xm,x,*roF,F*r\"))]\n-  \"TARGET_SSE\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+\t(match_operand:TF 1 \"general_operand\"\t   \"C ,xm,x,*roF,*r\"))]\n+  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -2849,11 +2808,101 @@\n \t       ]\n \t       (const_string \"TI\")))])\n \n+(define_insn \"*movtf_internal_sse\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,x ,m\")\n+\t(match_operand:TF 1 \"general_operand\"  \t   \"C ,xm,x\"))]\n+  \"TARGET_SSE && !TARGET_64BIT\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && (!can_create_pseudo_p ()\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (optimize_function_for_size_p (cfun)\n+\t   && standard_sse_constant_p (operands[1])\n+\t   && !memory_operand (operands[0], TFmode))\n+       || (!TARGET_MEMORY_MISMATCH_STALL\n+\t   && memory_operand (operands[0], TFmode)))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+    case 1:\n+    case 2:\n+      /* Handle misaligned load/store since we\n+         don't have movmisaligntf pattern. */\n+      if (misaligned_operand (operands[0], TFmode)\n+\t  || misaligned_operand (operands[1], TFmode))\n+\t{\n+\t  if (get_attr_mode (insn) == MODE_V4SF)\n+\t    return \"%vmovups\\t{%1, %0|%0, %1}\";\n+\t  else\n+\t    return \"%vmovdqu\\t{%1, %0|%0, %1}\";\n+\t}\n+      else\n+\t{\n+\t  if (get_attr_mode (insn) == MODE_V4SF)\n+\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\t  else\n+\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\t}\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n+   (set_attr \"prefix\" \"maybe_vex\")\n+   (set (attr \"mode\")\n+        (cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n+\t\t (const_string \"V4SF\")\n+\t       (and (eq_attr \"alternative\" \"2\")\n+\t\t    (match_test \"TARGET_SSE_TYPELESS_STORES\"))\n+\t\t (const_string \"V4SF\")\n+\t       (match_test \"TARGET_AVX\")\n+\t\t (const_string \"TI\")\n+\t       (ior (not (match_test \"TARGET_SSE2\"))\n+\t\t    (match_test \"optimize_function_for_size_p (cfun)\"))\n+\t\t (const_string \"V4SF\")\n+\t       ]\n+\t       (const_string \"TI\")))])\n+\n+(define_insn \"*movxf_internal_rex64\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,?Yx*r ,!o\")\n+\t(match_operand:XF 1 \"general_operand\"\t   \"fm,f,G,Yx*roF,Yx*r\"))]\n+  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && (!can_create_pseudo_p ()\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || (optimize_function_for_size_p (cfun)\n+\t   && standard_80387_constant_p (operands[1]) > 0\n+\t   && !memory_operand (operands[0], XFmode))\n+       || (!TARGET_MEMORY_MISMATCH_STALL\n+\t   && memory_operand (operands[0], XFmode)))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return output_387_reg_move (insn, operands);\n+\n+    case 2:\n+      return standard_80387_constant_opcode (operands[1]);\n+\n+    case 3:\n+    case 4:\n+      return \"#\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n+   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n+\n ;; Possible store forwarding (partial memory) stall in alternative 4.\n (define_insn \"*movxf_internal\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,?Yx*r ,!o\")\n \t(match_operand:XF 1 \"general_operand\"\t   \"fm,f,G,Yx*roF,FYx*r\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+  \"!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -2885,9 +2934,9 @@\n \n (define_insn \"*movdf_internal_rex64\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=f,m,f,?r,?m,?r,!o,x,x,x,m,Yi,r \")\n+\t\t\"=f,m,f,?r,?m,?r,x,x,x,m,Yi,r \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\"fm,f,G,rm,r ,F ,F ,C,x,m,x,r ,Yi\"))]\n+\t\t\"fm,f,G,rm,r ,F ,C,x,m,x,r ,Yi\"))]\n   \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n@@ -2916,14 +2965,11 @@\n       return \"movabs{q}\\t{%1, %0|%0, %1}\";\n \n     case 6:\n-      return \"#\";\n-\n-    case 7:\n       return standard_sse_constant_opcode (insn, operands[1]);\n \n+    case 7:\n     case 8:\n     case 9:\n-    case 10:\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V2DF:\n@@ -2945,8 +2991,8 @@\n \t  gcc_unreachable ();\n \t}\n \n+    case 10:\n     case 11:\n-    case 12:\n       /* Handle broken assemblers that require movd instead of movq.  */\n       return \"%vmovd\\t{%1, %0|%0, %1}\";\n \n@@ -2960,8 +3006,6 @@\n \t       (eq_attr \"alternative\" \"3,4,5\")\n \t\t (const_string \"imov\")\n \t       (eq_attr \"alternative\" \"6\")\n-\t\t (const_string \"multi\")\n-\t       (eq_attr \"alternative\" \"7\")\n \t\t (const_string \"sselog1\")\n \t      ]\n \t      (const_string \"ssemov\")))\n@@ -2976,7 +3020,7 @@\n \t (const_string \"8\")\n \t (const_string \"*\")))\n    (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4,5,6\")\n+     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4,5\")\n        (const_string \"orig\")\n        (const_string \"maybe_vex\")))\n    (set (attr \"prefix_data16\")\n@@ -2986,11 +3030,11 @@\n    (set (attr \"mode\")\n         (cond [(eq_attr \"alternative\" \"0,1,2\")\n \t\t (const_string \"DF\")\n-\t       (eq_attr \"alternative\" \"3,4,5,6,11,12\")\n+\t       (eq_attr \"alternative\" \"3,4,5,10,11\")\n \t\t (const_string \"DI\")\n \n \t       /* xorps is one byte shorter for !TARGET_AVX.  */\n-\t       (eq_attr \"alternative\" \"7\")\n+\t       (eq_attr \"alternative\" \"6\")\n \t\t (cond [(match_test \"TARGET_AVX\")\n \t\t\t  (const_string \"V2DF\")\n \t\t\t(match_test \"optimize_function_for_size_p (cfun)\")\n@@ -3005,7 +3049,7 @@\n \t\t  chains, otherwise use short move to avoid extra work.\n \n \t\t  movaps encodes one byte shorter for !TARGET_AVX.  */\n-\t       (eq_attr \"alternative\" \"8\")\n+\t       (eq_attr \"alternative\" \"7\")\n \t\t (cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n \t\t\t  (const_string \"V4SF\")\n \t\t\t(match_test \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n@@ -3019,7 +3063,7 @@\n \t       /* For architectures resolving dependencies on register\n \t\t  parts we may avoid extra work to zero out upper part\n \t\t  of register.  */\n-\t       (eq_attr \"alternative\" \"9\")\n+\t       (eq_attr \"alternative\" \"8\")\n \t\t (if_then_else\n \t\t   (match_test \"TARGET_SSE_SPLIT_REGS\")\n \t\t   (const_string \"V1DF\")"}, {"sha": "c129f58308513945c59fe0e09c187c627c707ef0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32fc5b8a4bbdf22d8af25310760d229319f7afbb", "patch": "@@ -1,3 +1,8 @@\n+2012-01-22  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/56028\n+\t* gcc.target/i386/pr56028.c: New test.\n+\n 2013-01-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/55686"}, {"sha": "18ae25398b8d2b85b3e005f0ea3b9a3ba6f9fdd6", "filename": "gcc/testsuite/gcc.target/i386/pr56028.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56028.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc5b8a4bbdf22d8af25310760d229319f7afbb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56028.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr56028.c?ref=32fc5b8a4bbdf22d8af25310760d229319f7afbb", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile  { target { ! { ia32 } } } } */\n+/* { dg-options \"-O2\" } */\n+\n+volatile int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p;\n+\n+volatile long long y;\n+\n+void\n+test ()\n+{\n+  int a_ = a;\n+  int b_ = b;\n+  int c_ = c;\n+  int d_ = d;\n+  int e_ = e;\n+  int f_ = f;\n+  int g_ = g;\n+  int h_ = h;\n+  int i_ = i;\n+  int j_ = j;\n+  int k_ = k;\n+  int l_ = l;\n+  int m_ = m;\n+  int n_ = n;\n+  int o_ = o;\n+  int p_ = p;\n+\n+  int z;\n+\n+  for (z = 0; z < 1000; z++)\n+    {\n+      y = 0x100000002ll;\n+      y = 0x300000004ll;\n+    }\n+\n+  a = a_;\n+  b = b_;\n+  c = c_;\n+  d = d_;\n+  e = e_;\n+  f = f_;\n+  g = g_;\n+  h = h_;\n+  i = i_;\n+  j = j_;\n+  k = k_;\n+  l = l_;\n+  m = m_;\n+  n = n_;\n+  o = o_;\n+  p = p_;\n+}\n+\n+/* { dg-final { scan-assembler-times \"movabs\" 2 } } */"}]}