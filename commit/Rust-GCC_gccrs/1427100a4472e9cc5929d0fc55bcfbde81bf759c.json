{"sha": "1427100a4472e9cc5929d0fc55bcfbde81bf759c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyNzEwMGE0NDcyZTljYzU5MjlkMGZjNTViY2ZiZGU4MWJmNzU5Yw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@mhpcc.edu", "date": "1998-08-24T12:32:03Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-08-24T12:32:03Z"}, "message": "rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Use TARGET_POWERPC64 when testing LEGITIMATE_INDEXED_ADDRESS_P DFmode and DImode.\n\n        * rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Use TARGET_POWERPC64\n        when testing LEGITIMATE_INDEXED_ADDRESS_P DFmode and DImode.\n        (LEGITIMIZE_ADDRESS): Use TARGET_POWERPC64 for INDEXED fixup.\n        * rs6000.c (print_operand, case 'L'): Add UNITS_PER_WORD, not 4.\n        (print_operand, cases 'O' and 'T'): Fix typos in lossage strings.\n        * rs6000.md (fix_truncdfsi2_store): Remove %w from non-CONST_INT\n        operand.\n        (movdf_softfloat32, movdf_hardfloat64, movdf_softfloat64): Change\n        'o' to 'm' for GPR variant constraints.\n\nFrom-SVN: r21947", "tree": {"sha": "82f6393dc1f7e2da8e565251be79b666c94255e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f6393dc1f7e2da8e565251be79b666c94255e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1427100a4472e9cc5929d0fc55bcfbde81bf759c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1427100a4472e9cc5929d0fc55bcfbde81bf759c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1427100a4472e9cc5929d0fc55bcfbde81bf759c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1427100a4472e9cc5929d0fc55bcfbde81bf759c/comments", "author": null, "committer": null, "parents": [{"sha": "b19abc2818fd0036e8c5b14f1c2e1d3531fc9572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19abc2818fd0036e8c5b14f1c2e1d3531fc9572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19abc2818fd0036e8c5b14f1c2e1d3531fc9572"}], "stats": {"total": 58, "additions": 38, "deletions": 20}, "files": [{"sha": "d7eaad55107c9c9c76886f54d720813f3184e51e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1427100a4472e9cc5929d0fc55bcfbde81bf759c", "patch": "@@ -1,3 +1,15 @@\n+Mon Aug 24 15:20:19 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Use TARGET_POWERPC64\n+\twhen testing LEGITIMATE_INDEXED_ADDRESS_P DFmode and DImode.\n+\t(LEGITIMIZE_ADDRESS): Use TARGET_POWERPC64 for INDEXED fixup.\n+\t* rs6000.c (print_operand, case 'L'): Add UNITS_PER_WORD, not 4.\n+\t(print_operand, cases 'O' and 'T'): Fix typos in lossage strings.\n+\t* rs6000.md (fix_truncdfsi2_store): Remove %w from non-CONST_INT\n+\toperand. \n+\t(movdf_softfloat32, movdf_hardfloat64, movdf_softfloat64): Change\n+\t'o' to 'm' for GPR variant constraints.\n+\n Mon Aug 24 10:25:46 1998  Jeffrey A Law  (law@cygnus.com)\n \n         * loop.c (scan_loop): Honor AVOID_CC_MODE_COPIES."}, {"sha": "022e3cf42cf77cced5828d5368f0b974acc8abd8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1427100a4472e9cc5929d0fc55bcfbde81bf759c", "patch": "@@ -2187,7 +2187,7 @@ secondary_reload_class (class, mode, in)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     regno = -1;\n \n-  /* We can not copy a symbolic operand directly into anyting other than\n+  /* We can not copy a symbolic operand directly into anything other than\n      BASE_REGS for TARGET_ELF.  So indicate that a register from BASE_REGS\n      is needed as an intermediate register.  */\n   if (TARGET_ELF\n@@ -2695,12 +2695,13 @@ print_operand (file, x, code)\n       else if (GET_CODE (x) == MEM)\n \t{\n \t  /* Handle possible auto-increment.  Since it is pre-increment and\n-\t     we have already done it, we can just use an offset of four.  */\n+\t     we have already done it, we can just use an offset of word.  */\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t   UNITS_PER_WORD));\n \t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t    output_address (plus_constant (XEXP (x, 0), UNITS_PER_WORD));\n \t  if (small_data_operand (x, GET_MODE (x)))\n \t    fprintf (file, \"@%s(%s)\", SMALL_DATA_RELOC,\n \t\t     reg_names[SMALL_DATA_REG]);\n@@ -2789,7 +2790,7 @@ print_operand (file, x, code)\n     case 'O':\n       /* Similar, but subtract 1 first.  */\n       if (GET_CODE (x) != PARALLEL)\n-\toutput_operand_lossage (\"invalid %%N value\");\n+\toutput_operand_lossage (\"invalid %%O value\");\n \n       fprintf (file, \"%d\", (XVECLEN (x, 0) - 1) * 4);\n       return;\n@@ -2912,7 +2913,7 @@ print_operand (file, x, code)\n       /* Opposite of 't': write 4 if this jump operation will branch if true,\n \t 12 otherwise.   */\n       if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n-\toutput_operand_lossage (\"invalid %%t value\");\n+\toutput_operand_lossage (\"invalid %%T value\");\n \n       else if ((GET_MODE (XEXP (x, 0)) == CCFPmode\n \t\t&& GET_CODE (x) != NE)"}, {"sha": "3d9e7010be70c05d87cae53f1de2715a4500913b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=1427100a4472e9cc5929d0fc55bcfbde81bf759c", "patch": "@@ -716,7 +716,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n \tmq\t\t(not saved; best to use it if we can)\n \tctr\t\t(not saved; when we have the choice ctr is better)\n \tlr\t\t(saved)\n-        cr5, r1, r2, ap\t(fixed)  */\n+        cr5, r1, r2, ap, fpmem (fixed)  */\n \n #define REG_ALLOC_ORDER\t\t\t\t\t\\\n   {32, \t\t\t\t\t\t\t\\\n@@ -1798,7 +1798,12 @@ typedef struct rs6000_args\n    the sum of two registers, or a register indirect, possibly with an\n    auto-increment.  For DFmode and DImode with an constant plus register,\n    we must ensure that both words are addressable or PowerPC64 with offset\n-   word aligned.  */\n+   word aligned.\n+\n+   For modes spanning multiple registers (DFmode in 32-bit GPRs,\n+   32-bit DImode, TImode), indexed addressing cannot be used because\n+   adjacent memory cells are accessed by adding word-sized offsets\n+   during assembly output.  */\n \n #define LEGITIMATE_CONSTANT_POOL_BASE_P(X)\t\t\t\t\\\n   (TARGET_TOC && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n@@ -1875,8 +1880,8 @@ typedef struct rs6000_args\n   if (LEGITIMATE_OFFSET_ADDRESS_P (MODE, X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if ((MODE) != TImode\t\t\t\t\t\\\n-      && (TARGET_HARD_FLOAT || TARGET_64BIT || (MODE) != DFmode) \\\n-      && (TARGET_64BIT || (MODE) != DImode)\t\t\\\n+      && (TARGET_HARD_FLOAT || TARGET_POWERPC64 || (MODE) != DFmode) \\\n+      && (TARGET_POWERPC64 || (MODE) != DImode)\t\t\\\n       && LEGITIMATE_INDEXED_ADDRESS_P (X))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if (LEGITIMATE_LO_SUM_ADDRESS_P (MODE, X))\t\t\\\n@@ -1923,8 +1928,8 @@ typedef struct rs6000_args\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n \t   && GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n-\t   && (TARGET_HARD_FLOAT || TARGET_64BIT || (MODE) != DFmode)\t\\\n-\t   && (TARGET_64BIT || (MODE) != DImode)\t\t\t\\\n+\t   && (TARGET_HARD_FLOAT || TARGET_POWERPC64 || (MODE) != DFmode) \\\n+\t   && (TARGET_POWERPC64 || (MODE) != DImode)\t\t\t\\\n \t   && (MODE) != TImode)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\t\\"}, {"sha": "65af9622cb10c2d0b0d8cc0b9acfedc422fe1aa5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1427100a4472e9cc5929d0fc55bcfbde81bf759c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1427100a4472e9cc5929d0fc55bcfbde81bf759c", "patch": "@@ -3892,7 +3892,7 @@\n \t\t\t\t  GEN_INT ((((rs6000_fpmem_offset & 0xffff)\n \t\t\t\t\t     ^ 0x8000) - 0x8000))));\n \n-  return \\\"stfd %0,%w2\\\";\n+  return \\\"stfd %0,%2\\\";\n }\"\n   [(set_attr \"type\" \"fpstore\")])\n \n@@ -5942,7 +5942,7 @@\n }\")\n \n ;; Don't have reload use general registers to load a constant.  First,\n-;; it might not work if the output operand has is the equivalent of\n+;; it might not work if the output operand is the equivalent of\n ;; a non-offsettable memref, but also it is less efficient than loading\n ;; the constant into an FP register, since it will probably be used there.\n ;; The \"??\" is a kludge until we can figure out a more reasonable way\n@@ -5995,8 +5995,8 @@\n    (set_attr \"length\" \"8,8,8,8,12,16,*,*,*\")])\n \n (define_insn \"*movdf_softfloat32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r,r,r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,m,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -6036,8 +6036,8 @@\n    (set_attr \"length\" \"8,8,8,8,12,16\")])\n \n (define_insn \"*movdf_hardfloat64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,!r,!r,f,f,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F,f,m,f\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,m,!r,!r,!r,f,f,m\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,m,r,G,H,F,f,m,f\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -6055,8 +6055,8 @@\n    (set_attr \"length\" \"4,4,4,8,12,16,4,4,4\")])\n \n (define_insn \"*movdf_softfloat64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r,r,r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,H,F\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,m,r,G,H,F\"))]\n   \"TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\""}]}