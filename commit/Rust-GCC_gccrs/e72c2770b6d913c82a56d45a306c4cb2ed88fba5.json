{"sha": "e72c2770b6d913c82a56d45a306c4cb2ed88fba5", "node_id": "C_kwDOANBUbNoAKGU3MmMyNzcwYjZkOTEzYzgyYTU2ZDQ1YTMwNmM0Y2IyZWQ4OGZiYTU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-14T13:51:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-14T15:18:57Z"}, "message": "Improve VN PHI hash table handling\n\nThe hash function of PHIs is weak since we want to be able to CSE\nthem even across basic-blocks in some cases.  The following avoids\nweakening the hash for cases we are never going to CSE, reducing\nthe number of collisions and avoiding redundant work in the\nhash and equality functions.\n\n\t* tree-ssa-sccvn.cc (vn_phi_compute_hash): Key skipping\n\tbasic block index hashing on the availability of ->cclhs.\n\t(vn_phi_eq): Avoid re-doing sanity checks for CSE but\n\trely on ->cclhs availability.\n\t(vn_phi_lookup): Set ->cclhs only when we are eventually\n\tgoing to CSE the PHI.\n\t(vn_phi_insert): Likewise.", "tree": {"sha": "064d8ce01b29c10c8d578295c2a58e4210a60f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/064d8ce01b29c10c8d578295c2a58e4210a60f6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e72c2770b6d913c82a56d45a306c4cb2ed88fba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72c2770b6d913c82a56d45a306c4cb2ed88fba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72c2770b6d913c82a56d45a306c4cb2ed88fba5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72c2770b6d913c82a56d45a306c4cb2ed88fba5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1434eee54e57ad4839c0697f1294f9e8fe0a3044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1434eee54e57ad4839c0697f1294f9e8fe0a3044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1434eee54e57ad4839c0697f1294f9e8fe0a3044"}], "stats": {"total": 77, "additions": 43, "deletions": 34}, "files": [{"sha": "8ee77fd2b7877539649c0f760ef373d29c595cac", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72c2770b6d913c82a56d45a306c4cb2ed88fba5/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72c2770b6d913c82a56d45a306c4cb2ed88fba5/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=e72c2770b6d913c82a56d45a306c4cb2ed88fba5", "patch": "@@ -4629,9 +4629,9 @@ vn_phi_compute_hash (vn_phi_t vp1)\n     case 1:\n       break;\n     case 2:\n-      if (vp1->block->loop_father->header == vp1->block)\n-\t;\n-      else\n+      /* When this is a PHI node subject to CSE for different blocks\n+\t avoid hashing the block index.  */\n+      if (vp1->cclhs)\n \tbreak;\n       /* Fallthru.  */\n     default:\n@@ -4715,32 +4715,33 @@ vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)\n \n \tcase 2:\n \t  {\n-\t    /* Rule out backedges into the PHI.  */\n-\t    if (vp1->block->loop_father->header == vp1->block\n-\t\t|| vp2->block->loop_father->header == vp2->block)\n+\t    /* Make sure both PHIs are classified as CSEable.  */\n+\t    if (! vp1->cclhs || ! vp2->cclhs)\n \t      return false;\n \n+\t    /* Rule out backedges into the PHI.  */\n+\t    gcc_checking_assert\n+\t      (vp1->block->loop_father->header != vp1->block\n+\t       && vp2->block->loop_father->header != vp2->block);\n+\n \t    /* If the PHI nodes do not have compatible types\n \t       they are not the same.  */\n \t    if (!types_compatible_p (vp1->type, vp2->type))\n \t      return false;\n \n+\t    /* If the immediate dominator end in switch stmts multiple\n+\t       values may end up in the same PHI arg via intermediate\n+\t       CFG merges.  */\n \t    basic_block idom1\n \t      = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n \t    basic_block idom2\n \t      = get_immediate_dominator (CDI_DOMINATORS, vp2->block);\n-\t    /* If the immediate dominator end in switch stmts multiple\n-\t       values may end up in the same PHI arg via intermediate\n-\t       CFG merges.  */\n-\t    if (EDGE_COUNT (idom1->succs) != 2\n-\t\t|| EDGE_COUNT (idom2->succs) != 2)\n-\t      return false;\n+\t    gcc_checking_assert (EDGE_COUNT (idom1->succs) == 2\n+\t\t\t\t && EDGE_COUNT (idom2->succs) == 2);\n \n \t    /* Verify the controlling stmt is the same.  */\n-\t    gcond *last1 = safe_dyn_cast <gcond *> (last_stmt (idom1));\n-\t    gcond *last2 = safe_dyn_cast <gcond *> (last_stmt (idom2));\n-\t    if (! last1 || ! last2)\n-\t      return false;\n+\t    gcond *last1 = as_a <gcond *> (last_stmt (idom1));\n+\t    gcond *last2 = as_a <gcond *> (last_stmt (idom2));\n \t    bool inverted_p;\n \t    if (! cond_stmts_equal_p (last1, vp1->cclhs, vp1->ccrhs,\n \t\t\t\t      last2, vp2->cclhs, vp2->ccrhs,\n@@ -4835,15 +4836,19 @@ vn_phi_lookup (gimple *phi, bool backedges_varying_p)\n   /* Extract values of the controlling condition.  */\n   vp1->cclhs = NULL_TREE;\n   vp1->ccrhs = NULL_TREE;\n-  basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n-  if (EDGE_COUNT (idom1->succs) == 2)\n-    if (gcond *last1 = safe_dyn_cast <gcond *> (last_stmt (idom1)))\n-      {\n-\t/* ???  We want to use SSA_VAL here.  But possibly not\n-\t   allow VN_TOP.  */\n-\tvp1->cclhs = vn_valueize (gimple_cond_lhs (last1));\n-\tvp1->ccrhs = vn_valueize (gimple_cond_rhs (last1));\n-      }\n+  if (EDGE_COUNT (vp1->block->preds) == 2\n+      && vp1->block->loop_father->header != vp1->block)\n+    {\n+      basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n+      if (EDGE_COUNT (idom1->succs) == 2)\n+\tif (gcond *last1 = safe_dyn_cast <gcond *> (last_stmt (idom1)))\n+\t  {\n+\t    /* ???  We want to use SSA_VAL here.  But possibly not\n+\t       allow VN_TOP.  */\n+\t    vp1->cclhs = vn_valueize (gimple_cond_lhs (last1));\n+\t    vp1->ccrhs = vn_valueize (gimple_cond_rhs (last1));\n+\t  }\n+    }\n   vp1->hashcode = vn_phi_compute_hash (vp1);\n   slot = valid_info->phis->find_slot_with_hash (vp1, vp1->hashcode, NO_INSERT);\n   if (!slot)\n@@ -4885,15 +4890,19 @@ vn_phi_insert (gimple *phi, tree result, bool backedges_varying_p)\n   /* Extract values of the controlling condition.  */\n   vp1->cclhs = NULL_TREE;\n   vp1->ccrhs = NULL_TREE;\n-  basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n-  if (EDGE_COUNT (idom1->succs) == 2)\n-    if (gcond *last1 = safe_dyn_cast <gcond *> (last_stmt (idom1)))\n-      {\n-\t/* ???  We want to use SSA_VAL here.  But possibly not\n-\t   allow VN_TOP.  */\n-\tvp1->cclhs = vn_valueize (gimple_cond_lhs (last1));\n-\tvp1->ccrhs = vn_valueize (gimple_cond_rhs (last1));\n-      }\n+  if (EDGE_COUNT (vp1->block->preds) == 2\n+      && vp1->block->loop_father->header != vp1->block)\n+    {\n+      basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n+      if (EDGE_COUNT (idom1->succs) == 2)\n+\tif (gcond *last1 = safe_dyn_cast <gcond *> (last_stmt (idom1)))\n+\t  {\n+\t    /* ???  We want to use SSA_VAL here.  But possibly not\n+\t       allow VN_TOP.  */\n+\t    vp1->cclhs = vn_valueize (gimple_cond_lhs (last1));\n+\t    vp1->ccrhs = vn_valueize (gimple_cond_rhs (last1));\n+\t  }\n+    }\n   vp1->result = result;\n   vp1->hashcode = vn_phi_compute_hash (vp1);\n "}]}