{"sha": "5986c254bf5f2b4115c823710103d2f3df1957aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4NmMyNTRiZjVmMmI0MTE1YzgyMzcxMDEwM2QyZjNkZjE5NTdhYQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-09-23T20:17:25Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-09-23T20:17:25Z"}, "message": "re PR fortran/87397 (Clobbering intent(out) variables caused regression in OpenCoarrays testsuite)\n\n2018-09-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/87397\n\t* gfc_conv_procedure_call: Do not add clobber on INTENT(OUT)\n\tfor variables having the dimension attribute.\n\n2018-09-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/87395\n\t* gfortran.dg/intent_out_11.f90: New test.\n\nFrom-SVN: r264518", "tree": {"sha": "a233d8389f99e7c747b8307ebc4f916c473e18f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a233d8389f99e7c747b8307ebc4f916c473e18f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5986c254bf5f2b4115c823710103d2f3df1957aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5986c254bf5f2b4115c823710103d2f3df1957aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5986c254bf5f2b4115c823710103d2f3df1957aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5986c254bf5f2b4115c823710103d2f3df1957aa/comments", "author": null, "committer": null, "parents": [{"sha": "d18cbbf6770446ea7eb0d6ad2595ad4937953f55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18cbbf6770446ea7eb0d6ad2595ad4937953f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18cbbf6770446ea7eb0d6ad2595ad4937953f55"}], "stats": {"total": 321, "additions": 321, "deletions": 0}, "files": [{"sha": "98e1dd645b8a9467c3e529f42e1b0284b23f3206", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5986c254bf5f2b4115c823710103d2f3df1957aa", "patch": "@@ -1,3 +1,9 @@\n+2018-09-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/87397\n+\t* gfc_conv_procedure_call: Do not add clobber on INTENT(OUT)\n+\tfor variables having the dimension attribute.\n+\n 2018-09-23  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* trans-expr.c (gfc_caf_get_image_index): Do array index"}, {"sha": "b3808dfa0a04b1a20ca5fc74ef42d45434518db4", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5986c254bf5f2b4115c823710103d2f3df1957aa", "patch": "@@ -5276,6 +5276,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      bool add_clobber;\n \t\t      add_clobber = fsym && fsym->attr.intent == INTENT_OUT\n \t\t\t&& !fsym->attr.allocatable && !fsym->attr.pointer\n+\t\t\t&& !e->symtree->n.sym->attr.dimension\n \t\t\t&& !e->symtree->n.sym->attr.pointer\n \t\t\t/* See PR 41453.  */\n \t\t\t&& !e->symtree->n.sym->attr.dummy"}, {"sha": "c112b3529d0f14edd90859043beb629de23c65a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5986c254bf5f2b4115c823710103d2f3df1957aa", "patch": "@@ -1,3 +1,8 @@\n+2018-09-23  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/87395\n+\t* gfortran.dg/intent_out_11.f90: New test.\n+\n 2018-09-23  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* gfortran.dg/coarray_lib_alloc_4.f90: Fix scan patterns."}, {"sha": "c266385b49f146e077fabc263b5e60c9c9f709b7", "filename": "gcc/testsuite/gfortran.dg/intent_out_11.f90", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5986c254bf5f2b4115c823710103d2f3df1957aa/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_11.f90?ref=5986c254bf5f2b4115c823710103d2f3df1957aa", "patch": "@@ -0,0 +1,309 @@\n+! { dg-do compile }\n+! { dg-options \"-cpp -fcoarray=lib\" }\n+! PR 87397 - this used to generate an ICE.\n+\n+! Coarray Distributed Transpose Test\n+!\n+! Copyright (c) 2012-2014, Sourcery, Inc.\n+! All rights reserved.\n+!\n+! Redistribution and use in source and binary forms, with or without\n+! modification, are permitted provided that the following conditions are met:\n+!     * Redistributions of source code must retain the above copyright\n+!       notice, this list of conditions and the following disclaimer.\n+!     * Redistributions in binary form must reproduce the above copyright\n+!       notice, this list of conditions and the following disclaimer in the\n+!       documentation and/or other materials provided with the distribution.\n+!     * Neither the name of the Sourcery, Inc., nor the\n+!       names of its contributors may be used to endorse or promote products\n+!       derived from this software without specific prior written permission.\n+!\n+! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY\n+! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+!\n+! Robodoc header:\n+!****m* dist_transpose/run_size\n+! NAME\n+!   run_size\n+!  SYNOPSIS\n+!   Encapsulate problem state, wall-clock timer interface, integer broadcasts, and a data copy.\n+!******\n+!==================  test transposes with integer x,y,z values  ===============================\n+module run_size\n+    use iso_fortran_env\n+    implicit none\n+\n+    integer(int64), codimension[*] :: nx, ny, nz\n+    integer(int64), codimension[*] :: my, mx, first_y, last_y, first_x, last_x\n+    integer(int64) :: my_node, num_nodes\n+    real(real64), codimension[*] :: tran_time\n+\n+\n+contains\n+\n+!****s* run_size/broadcast_int\n+! NAME\n+!   broadcast_int\n+!  SYNOPSIS\n+!   Broadcast a scalar coarray integer from image 1 to all other images.\n+!******\n+    subroutine broadcast_int( variable )\n+        integer(int64), codimension[*] :: variable\n+        integer(int64) :: i\n+        if( my_node == 1 ) then\n+            do i = 2, num_nodes;    variable[i] = variable;      end do\n+        end if\n+    end subroutine broadcast_int\n+\n+subroutine copy3( A,B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3 )\n+  implicit none\n+  complex, intent(in)  :: A(0:*)\n+  complex, intent(out) :: B(0:*)\n+  integer(int64), intent(in) :: n1, sA1, sB1\n+  integer(int64), intent(in) :: n2, sA2, sB2\n+  integer(int64), intent(in) :: n3, sA3, sB3\n+  integer(int64) i,j,k\n+\n+  do k=0,n3-1\n+     do j=0,n2-1\n+        do i=0,n1-1\n+           B(i*sB1+j*sB2+k*sB3) = A(i*sA1+j*sA2+k*sA3)\n+        end do\n+     end do\n+  end do\n+end subroutine copy3\n+\n+end module run_size\n+\n+!****e* dist_transpose/coarray_distributed_transpose\n+! NAME\n+!   coarray_distributed_transpose\n+! SYNOPSIS\n+!   This program tests the transpose routines used in Fourier-spectral simulations of homogeneous turbulence.\n+!   The data is presented to the physics routines as groups of y-z or x-z planes distributed among the images.\n+!   The (out-of-place) transpose routines do the x <--> y transposes required and consist of transposes within\n+!   data blocks (intra-image) and a transpose of the distribution of these blocks among the images (inter-image).\n+!\n+!   Two methods are tested here:\n+!   RECEIVE: receive block from other image and transpose it\n+!   SEND:    transpose block and send it to other image\n+!\n+!   This code is the coarray analog of mpi_distributed_transpose.\n+!******\n+\n+program coarray_distributed_transpose\n+  !(***********************************************************************************************************\n+  !                   m a i n   p r o g r a m\n+  !***********************************************************************************************************)\n+      use run_size\n+      implicit none\n+\n+      complex, allocatable ::  u(:,:,:,:)[:]    ! u(nz,4,first_x:last_x,ny)[*]    !(*-- ny = my * num_nodes --*)\n+      complex, allocatable ::  ur(:,:,:,:)[:]   !ur(nz,4,first_y:last_y,nx/2)[*]  !(*-- nx/2 = mx * num_nodes --*)\n+      complex, allocatable :: bufr_X_Y(:,:,:,:)\n+      complex, allocatable :: bufr_Y_X(:,:,:,:)\n+      integer(int64) :: x, y, z, msg_size, iter\n+\n+      num_nodes = num_images()\n+      my_node = this_image()\n+\n+      if( my_node == 1 ) then\n+           !write(6,*) \"nx,ny,nz : \";      read(5,*) nx, ny, nz\n+            nx=32; ny=32; nz=32\n+            call broadcast_int( nx );        call broadcast_int( ny );        call broadcast_int( nz );\n+       end if\n+      sync all  !-- other nodes wait for broadcast!\n+\n+\n+      if ( mod(ny,num_nodes) == 0)  then;   my = ny / num_nodes\n+                                    else;   write(6,*) \"node \", my_node, \" ny not multiple of num_nodes\";     error stop\n+      end if\n+\n+      if ( mod(nx/2,num_nodes) == 0)  then;   mx = nx/2 / num_nodes\n+                                    else;   write(6,*) \"node \", my_node, \"nx/2 not multiple of num_nodes\";     error stop\n+      end if\n+\n+      first_y = (my_node-1)*my + 1;   last_y  = (my_node-1)*my + my\n+      first_x = (my_node-1)*mx + 1;   last_x  = (my_node-1)*mx + mx\n+\n+      allocate (  u(nz , 4 , first_x:last_x , ny)  [*] )   !(*-- y-z planes --*)\n+      allocate ( ur(nz , 4 , first_y:last_y , nx/2)[*] )   !(*-- x-z planes --*)\n+      allocate ( bufr_X_Y(nz,4,mx,my) )\n+      allocate ( bufr_Y_X(nz,4,my,mx) )\n+\n+      msg_size = nz*4*mx*my     !-- message size (complex data items)\n+\n+!---------  initialize data u (mx y-z planes per image) ----------\n+\n+        do x = first_x, last_x\n+            do y = 1, ny\n+                do z = 1, nz\n+                    u(z,1,x,y) = x\n+                    u(z,2,x,y) = y\n+                    u(z,3,x,y) = z\n+                end do\n+            end do\n+        end do\n+\n+    tran_time = 0\n+    do iter = 1, 2  !--- 2 transform pairs per second-order time step\n+\n+!---------  transpose data u -> ur (mx y-z planes to my x-z planes per image)  --------\n+\n+      ur = 0\n+\n+      call transpose_X_Y\n+\n+!--------- test data ur (my x-z planes per image) ----------\n+\n+        do x = 1, nx/2\n+            do y = first_y, last_y\n+                do z = 1, nz\n+                    if ( real(ur(z,1,y,x)) /= x .or. real(ur(z,2,y,x)) /= y .or. real(ur(z,3,y,x)) /= z )then\n+                        write(6,fmt=\"(A,i3,3(6X,A,f7.3,i4))\") \"transpose_X_Y failed:  image \", my_node &\n+                            , \" X \",real(ur(z,1,y,x)),x, \"  Y \",real(ur(z,2,y,x)),y, \"  Z \", real(ur(z,3,y,x)),z\n+                        stop\n+                    end if\n+                end do\n+            end do\n+        end do\n+\n+!---------  transpose data ur -> u (my x-z planes to mx y-z planes per image)  --------\n+\n+      u = 0\n+      call transpose_Y_X\n+\n+!--------- test data u (mx y-z planes per image) ----------\n+\n+        do x = first_x, last_x\n+            do y = 1, ny\n+                do z = 1, nz\n+                    if ( real(u(z,1,x,y)) /= x .or. real(u(z,2,x,y)) /= y .or. real(u(z,3,x,y)) /= z )then\n+                        write(6,fmt=\"(A,i3,3(6X,A,f7.3,i4))\") \"transpose_Y_X failed:  image \", my_node &\n+                            , \" X \",real(u(z,1,x,y)),x, \"  Y \",real(u(z,2,x,y)),y, \"  Z \", real(u(z,3,x,y)),z\n+                        stop\n+                    end if\n+                end do\n+            end do\n+        end do\n+    end do\n+\n+        sync all\n+        if( my_node == 1 )  write(6,fmt=\"(A,f8.3)\")  \"test passed:  tran_time \", tran_time\n+\n+    deallocate ( bufr_X_Y );    deallocate ( bufr_Y_X )\n+\n+!=========================   end of main executable  =============================\n+\n+contains\n+\n+!-------------   out-of-place transpose data_s --> data_r  ----------------------------\n+\n+ subroutine transpose_X_Y\n+\n+    use run_size\n+    implicit none\n+\n+    integer(int64) :: i,stage\n+    real(real64) :: tmp\n+\n+    sync all   !--  wait for other nodes to finish compute\n+    call cpu_time(tmp)\n+    tran_time = tran_time - tmp\n+\n+    call copy3 (    u(1,1,first_x,1+(my_node-1)*my) &                   !-- intra-node transpose\n+                ,  ur(1,1,first_y,1+(my_node-1)*mx) &                   !-- no inter-node transpose needed\n+                ,   nz*3, 1_8, 1_8        &                                 !-- note: only 3 of 4 words needed\n+                ,   mx, nz*4, nz*4*my &\n+                ,   my, nz*4*mx, nz*4 )\n+\n+#define RECEIVE\n+#ifdef RECEIVE\n+\n+    do stage = 1, num_nodes-1\n+        i = 1 + mod( my_node-1+stage, num_nodes )\n+        bufr_X_Y(:,:,:,:) = u(:,:,:,1+(my_node-1)*my:my_node*my)[i]         !-- inter-node transpose to buffer\n+        call copy3 ( bufr_X_Y, ur(1,1,first_y,1+(i-1)*mx)  &                !-- intra-node transpose from buffer\n+                        ,   nz*3, 1_8, 1_8        &                             !-- note: only 3 of 4 words needed\n+                        ,   mx, nz*4, nz*4*my &\n+                        ,   my, nz*4*mx, nz*4 )\n+    end do\n+\n+#else\n+\n+    do stage = 1, num_nodes-1\n+        i = 1 + mod( my_node-1+stage, num_nodes )\n+        call  copy3 ( u(1,1,first_x,1+(i-1)*my), bufr_Y_X   &        !-- intra-node transpose to buffer\n+                    ,   nz*3, 1_8, 1_8        &\n+                    ,   mx, nz*4, nz*4*my &\n+                    ,   my, nz*4*mx, nz*4 )\n+        ur(:,:,:,1+(my_node-1)*mx:my_node*mx)[i] = bufr_Y_X(:,:,:,:)        !-- inter-node transpose from buffer\n+    end do\n+\n+#endif\n+\n+    sync all     !--  wait for other nodes to finish transpose\n+    call cpu_time(tmp)\n+    tran_time = tran_time + tmp\n+\n+ end  subroutine transpose_X_Y\n+\n+!-------------   out-of-place transpose data_r --> data_s  ----------------------------\n+\n+subroutine transpose_Y_X\n+    use run_size\n+    implicit none\n+\n+    integer(int64) :: i, stage\n+    real(real64) :: tmp\n+\n+    sync all   !--  wait for other nodes to finish compute\n+    call cpu_time(tmp)\n+    tran_time = tran_time - tmp\n+\n+    call copy3 (   ur(1,1,first_y,1+(my_node-1)*mx) &                   !-- intra-node transpose\n+                ,   u(1,1,first_x,1+(my_node-1)*my) &                   !-- no inter-node transpose needed\n+                ,   nz*4, 1_8, 1_8        &                                 !-- note: all 4 words needed\n+                ,   my, nz*4, nz*4*mx &\n+                ,   mx, nz*4*my, nz*4 )\n+\n+#define RECEIVE\n+#ifdef RECEIVE\n+\n+    do stage = 1, num_nodes-1\n+        i = 1 + mod( my_node-1+stage, num_nodes )\n+        bufr_Y_X(:,:,:,:) = ur(:,:,:,1+(my_node-1)*mx:my_node*mx)[i]        !-- inter-node transpose to buffer\n+        call copy3 ( bufr_Y_X, u(1,1,first_x,1+(i-1)*my)  &                 !-- intra-node transpose from buffer\n+                    ,   nz*4, 1_8, 1_8        &\n+                    ,   my, nz*4, nz*4*mx &\n+                    ,   mx, nz*4*my, nz*4 )\n+    end do\n+\n+#else\n+\n+    do stage = 1, num_nodes-1\n+        i = 1 + mod( my_node-1+stage, num_nodes )\n+        call copy3 ( ur(1,1,first_y,1+(i-1)*mx), bufr_X_Y  &                 !-- intra-node transpose from buffer\n+                    ,   nz*4, 1_8, 1_8        &\n+                    ,   my, nz*4, nz*4*mx &\n+                    ,   mx, nz*4*my, nz*4 )\n+        u(:,:,:,1+(my_node-1)*my:my_node*my)[i] = bufr_X_Y(:,:,:,:)        !-- inter-node transpose from buffer\n+    end do\n+\n+#endif\n+\n+    sync all     !--  wait for other nodes to finish transpose\n+    call cpu_time(tmp)\n+    tran_time = tran_time + tmp\n+\n+ end  subroutine transpose_Y_X\n+\n+\n+end program coarray_distributed_transpose"}]}