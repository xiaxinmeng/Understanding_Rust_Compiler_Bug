{"sha": "81bd8c9075b533aab81a9778119b92f4b7cd7737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFiZDhjOTA3NWI1MzNhYWI4MWE5Nzc4MTE5YjkyZjRiN2NkNzczNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-04T14:28:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-04T14:28:24Z"}, "message": "[multiple changes]\n\n2014-02-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads: Further comments on N_Expression_With_Actions node.\n\n2014-02-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Remove global\n\tvariables Out_Items and Ref_Global. Remove local constant\n\tBody_Id along with dummy variables D1, D2, D3, D4, D5, D6, D7\n\tand D8. Remove the useless collection of global items as this\n\twas a leftover from an earlier version of the routine. Move\n\tseveral routines out to avoid deep nesting and indentation.\n\t(Inputs_Match): Add formal parameter Dep_Clause. Rename formal\n\tparameter Do_Checks to Post_Errors. Update the comment on usage.\n\t(Is_Matching_Input): Renamed to Input_Match. Add formal parameters\n\tRef_Inputs and Do_Checks. Rename formal parameter Do_Checks\n\tto Post_Errors. Update the comment on usage. Account for the\n\tcase where a self referential state may have a null input_list.\n\t(Is_Self_Referential): New routine.\n\n2014-02-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): If the\n\tentity renames an expression, as in the case of an object of\n\tan unconstrained type initialized by a function call, defer the\n\trewriting of the expression to the expander.\n\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n\t'Alignment): If the entity renames an expression, introduce\n\ttemporary to capture value, and rewrite original declaration to\n\tuse temporary.\n\nFrom-SVN: r207467", "tree": {"sha": "f84c9361ab2c0d9df53e390ceb083f8f202fde01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f84c9361ab2c0d9df53e390ceb083f8f202fde01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81bd8c9075b533aab81a9778119b92f4b7cd7737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bd8c9075b533aab81a9778119b92f4b7cd7737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bd8c9075b533aab81a9778119b92f4b7cd7737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bd8c9075b533aab81a9778119b92f4b7cd7737/comments", "author": null, "committer": null, "parents": [{"sha": "ebdaa81b017726b7d7bd6407c77bcbb1dd97702f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebdaa81b017726b7d7bd6407c77bcbb1dd97702f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebdaa81b017726b7d7bd6407c77bcbb1dd97702f"}], "stats": {"total": 891, "additions": 527, "deletions": 364}, "files": [{"sha": "330ff75d32b0e01bbc86b4484584182528b7033d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=81bd8c9075b533aab81a9778119b92f4b7cd7737", "patch": "@@ -1,3 +1,34 @@\n+2014-02-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads: Further comments on N_Expression_With_Actions node.\n+\n+2014-02-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Remove global\n+\tvariables Out_Items and Ref_Global. Remove local constant\n+\tBody_Id along with dummy variables D1, D2, D3, D4, D5, D6, D7\n+\tand D8. Remove the useless collection of global items as this\n+\twas a leftover from an earlier version of the routine. Move\n+\tseveral routines out to avoid deep nesting and indentation.\n+\t(Inputs_Match): Add formal parameter Dep_Clause. Rename formal\n+\tparameter Do_Checks to Post_Errors. Update the comment on usage.\n+\t(Is_Matching_Input): Renamed to Input_Match. Add formal parameters\n+\tRef_Inputs and Do_Checks. Rename formal parameter Do_Checks\n+\tto Post_Errors. Update the comment on usage. Account for the\n+\tcase where a self referential state may have a null input_list.\n+\t(Is_Self_Referential): New routine.\n+\n+2014-02-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): If the\n+\tentity renames an expression, as in the case of an object of\n+\tan unconstrained type initialized by a function call, defer the\n+\trewriting of the expression to the expander.\n+\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n+\t'Alignment): If the entity renames an expression, introduce\n+\ttemporary to capture value, and rewrite original declaration to\n+\tuse temporary.\n+\n 2014-02-04  Gary Dismukes  <dismukes@adacore.com>\n \n \t* g-comlin.adb: Minor typo fix."}, {"sha": "72d3f2add3a972555dfd25b295b5c81d180ed348", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=81bd8c9075b533aab81a9778119b92f4b7cd7737", "patch": "@@ -157,6 +157,46 @@ package body Exp_Ch13 is\n                  (Exp, Make_Integer_Literal (Loc, Expr_Value (Exp)));\n             end if;\n \n+            --  A complex case arises if the alignment clause applies to an\n+            --  unconstrained object initialized with a function call. The\n+            --  result of the call is placed on the secondary stack, and the\n+            --  declaration is rewritten as a renaming of a dereference, which\n+            --  fails expansion. We must introduce a temporary and assign its\n+            --  value to the existing entity.\n+\n+            if Nkind (Parent (Ent)) = N_Object_Renaming_Declaration\n+              and then not Is_Entity_Name (Renamed_Object (Ent))\n+            then\n+               declare\n+                  Loc      : constant Source_Ptr := Sloc (N);\n+                  Decl     : constant Node_Id    := Parent (Ent);\n+                  Temp     : constant Entity_Id  := Make_Temporary (Loc, 'T');\n+                  New_Decl : Node_Id;\n+\n+               begin\n+                  --  Replace entity with temporary and renalyze\n+\n+                  Set_Defining_Identifier (Decl, Temp);\n+                  Set_Analyzed (Decl, False);\n+                  Analyze (Decl);\n+\n+                  --  Introduce new declaration for entity but do not reanalyze\n+                  --  because entity is already in scope. Type and expression\n+                  --  are already resolved.\n+\n+                  New_Decl :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Ent,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of (Etype (Ent), Loc),\n+                      Expression          => New_Occurrence_Of (Temp, Loc));\n+\n+                  Set_Renamed_Object (Ent, Empty);\n+                  Insert_After (Decl, New_Decl);\n+                  Set_Analyzed (Decl);\n+               end;\n+            end if;\n+\n          ------------------\n          -- Storage_Size --\n          ------------------"}, {"sha": "10fc6da31a776e8a2880f4e39f64f224bc636291", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=81bd8c9075b533aab81a9778119b92f4b7cd7737", "patch": "@@ -3526,13 +3526,23 @@ package body Sem_Ch13 is\n          --  expander. The easiest general way to handle this is to create a\n          --  copy of the attribute definition clause for this object.\n \n-         else\n+         elsif Is_Entity_Name (Renamed_Object (Ent)) then\n             Insert_Action (N,\n               Make_Attribute_Definition_Clause (Loc,\n                 Name       =>\n                   New_Occurrence_Of (Entity (Renamed_Object (Ent)), Loc),\n                 Chars      => Chars (N),\n                 Expression => Duplicate_Subexpr (Expression (N))));\n+\n+         --  If the renamed object is not an entity, it must be a dereference\n+         --  of an unconstrained function call, and we must introduce a new\n+         --  declaration to capture the expression. This is needed in the case\n+         --  of 'Alignment, where the original declaration must be rewritten.\n+\n+         else\n+            pragma Assert\n+              (Nkind (Renamed_Object (Ent)) = N_Explicit_Dereference);\n+            null;\n          end if;\n \n       --  If no underlying entity, use entity itself, applies to some"}, {"sha": "dce9b8d8d8b2390b3098093c29ad9e6dfa70fbb0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 440, "deletions": 362, "changes": 802, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=81bd8c9075b533aab81a9778119b92f4b7cd7737", "patch": "@@ -21201,12 +21201,6 @@ package body Sem_Prag is\n       Depends      : Node_Id;\n       --  The corresponding Depends pragma along with its clauses\n \n-      Out_Items : Elist_Id := No_Elist;\n-      --  All output items as defined in pragma Refined_Global (if any)\n-\n-      Ref_Global : Node_Id := Empty;\n-      --  The corresponding Refined_Global pragma (if any)\n-\n       Refinements : List_Id := No_List;\n       --  The clauses of pragma Refined_Depends\n \n@@ -21216,6 +21210,27 @@ package body Sem_Prag is\n       procedure Check_Dependency_Clause (Dep_Clause : Node_Id);\n       --  Verify the legality of a single clause\n \n+      function Input_Match\n+        (Dep_Input   : Node_Id;\n+         Ref_Inputs  : List_Id;\n+         Post_Errors : Boolean) return Boolean;\n+      --  Determine whether input Dep_Input matches one of inputs found in list\n+      --  Ref_Inputs. If flag Post_Errors is set, the routine reports missed or\n+      --  extra input items.\n+\n+      function Inputs_Match\n+        (Dep_Clause  : Node_Id;\n+         Ref_Clause  : Node_Id;\n+         Post_Errors : Boolean) return Boolean;\n+      --  Determine whether the inputs of Depends clause Dep_Clause match those\n+      --  of refinement clause Ref_Clause. If flag Post_Errors is set, then the\n+      --  routine reports missed or extra input items.\n+\n+      function Is_Self_Referential (Item_Id : Entity_Id) return Boolean;\n+      --  Determine whether a formal parameter, variable or state denoted by\n+      --  Item_Id appears both as input and an output in a single clause of\n+      --  pragma Depends.\n+\n       procedure Report_Extra_Clauses;\n       --  Emit an error for each extra clause the appears in Refined_Depends\n \n@@ -21224,327 +21239,6 @@ package body Sem_Prag is\n       -----------------------------\n \n       procedure Check_Dependency_Clause (Dep_Clause : Node_Id) is\n-         function Inputs_Match\n-           (Ref_Clause : Node_Id;\n-            Do_Checks  : Boolean) return Boolean;\n-         --  Determine whether the inputs of clause Dep_Clause match those of\n-         --  clause Ref_Clause. If flag Do_Checks is set, the routine reports\n-         --  missed or extra input items.\n-\n-         ------------------\n-         -- Inputs_Match --\n-         ------------------\n-\n-         function Inputs_Match\n-           (Ref_Clause : Node_Id;\n-            Do_Checks  : Boolean) return Boolean\n-         is\n-            Ref_Inputs : List_Id;\n-            --  The input list of the refinement clause\n-\n-            function Is_Matching_Input (Dep_Input : Node_Id) return Boolean;\n-            --  Determine whether input Dep_Input matches one of the inputs of\n-            --  clause Ref_Clause.\n-\n-            procedure Report_Extra_Inputs;\n-            --  Emit errors for all extra inputs that appear in Ref_Clause\n-\n-            -----------------------\n-            -- Is_Matching_Input --\n-            -----------------------\n-\n-            function Is_Matching_Input (Dep_Input : Node_Id) return Boolean is\n-               procedure Match_Error (Msg : String; N : Node_Id);\n-               --  Emit a matching error if flag Do_Checks is set\n-\n-               -----------------\n-               -- Match_Error --\n-               -----------------\n-\n-               procedure Match_Error (Msg : String; N : Node_Id) is\n-               begin\n-                  if Do_Checks then\n-                     Error_Msg_N (Msg, N);\n-                  end if;\n-               end Match_Error;\n-\n-               --  Local variables\n-\n-               Dep_Id         : Node_Id;\n-               Next_Ref_Input : Node_Id;\n-               Ref_Id         : Entity_Id;\n-               Ref_Input      : Node_Id;\n-\n-               Has_Constituent : Boolean := False;\n-               --  Flag set when the refinement input list contains at least\n-               --  one constituent of the state denoted by Dep_Id.\n-\n-               Has_Null_State : Boolean := False;\n-               --  Flag set when the dependency input is a state with a null\n-               --  refinement.\n-\n-               Has_Refined_State : Boolean := False;\n-               --  Flag set when the dependency input is a state with visible\n-               --  refinement.\n-\n-            --  Start of processing for Is_Matching_Input\n-\n-            begin\n-               --  Match a null input with another null input\n-\n-               if Nkind (Dep_Input) = N_Null then\n-                  Ref_Input := First (Ref_Inputs);\n-\n-                  --  Remove the matching null from the pool of candidates\n-\n-                  if Nkind (Ref_Input) = N_Null then\n-                     Remove (Ref_Input);\n-                     return True;\n-\n-                  else\n-                     Match_Error\n-                       (\"null input cannot be matched in corresponding \"\n-                        & \"refinement clause\", Dep_Input);\n-                  end if;\n-\n-               --  Remaining cases are formal parameters, variables, and states\n-\n-               else\n-                  --  Handle abstract views of states and variables generated\n-                  --  for limited with clauses.\n-\n-                  Dep_Id := Available_View (Entity_Of (Dep_Input));\n-\n-                  --  Inspect all inputs of the refinement clause and attempt\n-                  --  to match against the inputs of the dependence clause.\n-\n-                  Ref_Input := First (Ref_Inputs);\n-                  while Present (Ref_Input) loop\n-\n-                     --  Store the next input now because a match will remove\n-                     --  it from the list.\n-\n-                     Next_Ref_Input := Next (Ref_Input);\n-\n-                     if Ekind (Dep_Id) = E_Abstract_State then\n-\n-                        --  A state with a null refinement matches either a\n-                        --  null input list or nothing at all (no input):\n-\n-                        --    Refined_State   => (State => null)\n-\n-                        --  No input\n-\n-                        --    Depends         => (<output> => (State, Input))\n-                        --    Refined_Depends => (<output> => Input)  --  OK\n-\n-                        --  Null input list\n-\n-                        --    Depends         => (<output> => State)\n-                        --    Refined_Depends => (<output> => null)   --  OK\n-\n-                        if Has_Null_Refinement (Dep_Id) then\n-                           Has_Null_State := True;\n-\n-                           --  Remove the matching null from the pool of\n-                           --  candidates.\n-\n-                           if Nkind (Ref_Input) = N_Null then\n-                              Remove (Ref_Input);\n-                           end if;\n-\n-                           return True;\n-\n-                        --  The state has a non-null refinement in which case\n-                        --  remove all the matching constituents of the state:\n-\n-                        --    Refined_State   => (State    => (C1, C2))\n-                        --    Depends         => (<output> =>  State)\n-                        --    Refined_Depends => (<output> => (C1, C2))\n-\n-                        elsif Has_Non_Null_Refinement (Dep_Id) then\n-                           Has_Refined_State := True;\n-\n-                           --  Ref_Input is an entity name\n-\n-                           if Is_Entity_Name (Ref_Input) then\n-                              Ref_Id := Entity_Of (Ref_Input);\n-\n-                              --  The input of the refinement clause is a valid\n-                              --  constituent of the state. Remove the input\n-                              --  from the pool of candidates. Note that the\n-                              --  search continues because the state may be\n-                              --  represented by multiple constituents.\n-\n-                              if Ekind_In (Ref_Id, E_Abstract_State,\n-                                                   E_Variable)\n-                                and then Present (Encapsulating_State (Ref_Id))\n-                                and then Encapsulating_State (Ref_Id) = Dep_Id\n-                              then\n-                                 Has_Constituent := True;\n-                                 Remove (Ref_Input);\n-                              end if;\n-                           end if;\n-\n-                        --  The abstract view of a state matches its\n-                        --  corresponding non-abstract view:\n-\n-                        --    Depends         => (<output> => Lim_Pack.State)\n-                        --    Refined_Depends => (<output> => State)\n-\n-                        elsif Is_Entity_Name (Ref_Input)\n-                          and then Entity_Of (Ref_Input) = Dep_Id\n-                        then\n-                           Remove (Ref_Input);\n-                           return True;\n-                        end if;\n-\n-                     --  Formal parameters and variables are matched on\n-                     --  entities. If this is the case, remove the input from\n-                     --  the candidate list.\n-\n-                     elsif Is_Entity_Name (Ref_Input)\n-                       and then Entity_Of (Ref_Input) = Dep_Id\n-                     then\n-                        Remove (Ref_Input);\n-                        return True;\n-                     end if;\n-\n-                     Ref_Input := Next_Ref_Input;\n-                  end loop;\n-\n-                  --  When a state with a null refinement appears as the last\n-                  --  input, it matches nothing:\n-\n-                  --    Refined_State   => (State => null)\n-                  --    Depends         => (<output> => (Input, State))\n-                  --    Refined_Depends => (<output> => Input)  --  OK\n-\n-                  if Ekind (Dep_Id) = E_Abstract_State\n-                    and then Has_Null_Refinement (Dep_Id)\n-                    and then No (Ref_Input)\n-                  then\n-                     Has_Null_State := True;\n-                  end if;\n-               end if;\n-\n-               --  A state with visible refinement was matched against one or\n-               --  more of its constituents.\n-\n-               if Has_Constituent then\n-                  return True;\n-\n-               --  A state with a null refinement matched null or nothing\n-\n-               elsif Has_Null_State then\n-                  return True;\n-\n-               --  The input of a dependence clause does not have a matching\n-               --  input in the refinement clause, emit an error.\n-\n-               else\n-                  Match_Error\n-                    (\"input cannot be matched in corresponding refinement \"\n-                     & \"clause\", Dep_Input);\n-\n-                  if Has_Refined_State then\n-                     Match_Error\n-                       (\"\\check the use of constituents in dependence \"\n-                        & \"refinement\", Dep_Input);\n-                  end if;\n-\n-                  return False;\n-               end if;\n-            end Is_Matching_Input;\n-\n-            -------------------------\n-            -- Report_Extra_Inputs --\n-            -------------------------\n-\n-            procedure Report_Extra_Inputs is\n-               Input : Node_Id;\n-\n-            begin\n-               if Present (Ref_Inputs) and then Do_Checks then\n-                  Input := First (Ref_Inputs);\n-                  while Present (Input) loop\n-                     Error_Msg_N\n-                       (\"unmatched or extra input in refinement clause\",\n-                        Input);\n-\n-                     Next (Input);\n-                  end loop;\n-               end if;\n-            end Report_Extra_Inputs;\n-\n-            --  Local variables\n-\n-            Dep_Inputs : constant Node_Id := Expression (Dep_Clause);\n-            Inputs     : constant Node_Id := Expression (Ref_Clause);\n-            Dep_Input  : Node_Id;\n-            Result     : Boolean;\n-\n-         --  Start of processing for Inputs_Match\n-\n-         begin\n-            --  Construct a list of all refinement inputs. Note that the input\n-            --  list is copied because the algorithm modifies its contents and\n-            --  this should not be visible in Refined_Depends.\n-\n-            if Nkind (Inputs) = N_Aggregate then\n-               Ref_Inputs := New_Copy_List (Expressions (Inputs));\n-            else\n-               Ref_Inputs := New_List (Inputs);\n-            end if;\n-\n-            --  Depending on whether the original dependency clause mentions\n-            --  states with visible refinement, the corresponding refinement\n-            --  clause may differ greatly in structure and contents:\n-\n-            --  State with null refinement\n-\n-            --    Refined_State   => (State    => null)\n-            --    Depends         => (<output> => State)\n-            --    Refined_Depends => (<output> => null)\n-\n-            --    Depends         => (<output> => (State, Input))\n-            --    Refined_Depends => (<output> => Input)\n-\n-            --    Depends         => (<output> => (Input_1, State, Input_2))\n-            --    Refined_Depends => (<output> => (Input_1, Input_2))\n-\n-            --  State with non-null refinement\n-\n-            --    Refined_State   => (State_1 => (C1, C2))\n-            --    Depends         => (<output> => State)\n-            --    Refined_Depends => (<output> => C1)\n-            --  or\n-            --    Refined_Depends => (<output> => (C1, C2))\n-\n-            if Nkind (Dep_Inputs) = N_Aggregate then\n-               Dep_Input := First (Expressions (Dep_Inputs));\n-               while Present (Dep_Input) loop\n-                  if not Is_Matching_Input (Dep_Input) then\n-                     Result := False;\n-                  end if;\n-\n-                  Next (Dep_Input);\n-               end loop;\n-\n-               Result := True;\n-\n-            --  Solitary input\n-\n-            else\n-               Result := Is_Matching_Input (Dep_Inputs);\n-            end if;\n-\n-            Report_Extra_Inputs;\n-            return Result;\n-         end Inputs_Match;\n-\n-         --  Local variables\n-\n          Dep_Output      : constant Node_Id := First (Choices (Dep_Clause));\n          Dep_Id          : Entity_Id;\n          Matching_Clause : Node_Id := Empty;\n@@ -21565,8 +21259,6 @@ package body Sem_Prag is\n          --  Flag set when the output of clause Dep_Clause is a state with\n          --  visible refinement.\n \n-      --  Start of processing for Check_Dependency_Clause\n-\n       begin\n          --  The analysis of pragma Depends should produce normalized clauses\n          --  with exactly one output. This is important because output items\n@@ -21681,7 +21373,9 @@ package body Sem_Prag is\n                           and then Present (Encapsulating_State (Ref_Id))\n                           and then Encapsulating_State (Ref_Id) = Dep_Id\n                           and then Inputs_Match\n-                                     (Ref_Clause, Do_Checks => False)\n+                                     (Dep_Clause  => Dep_Clause,\n+                                      Ref_Clause  => Ref_Clause,\n+                                      Post_Errors => False)\n                         then\n                            Has_Constituent := True;\n                            Remove (Ref_Clause);\n@@ -21742,7 +21436,11 @@ package body Sem_Prag is\n          --  from the pool of candidates.\n \n          if Present (Matching_Clause) then\n-            if Inputs_Match (Matching_Clause, Do_Checks => True) then\n+            if Inputs_Match\n+                 (Ref_Clause  => Ref_Clause,\n+                  Dep_Clause  => Matching_Clause,\n+                  Post_Errors => True)\n+            then\n                Remove (Matching_Clause);\n             end if;\n \n@@ -21773,6 +21471,415 @@ package body Sem_Prag is\n          end if;\n       end Check_Dependency_Clause;\n \n+      -----------------\n+      -- Input_Match --\n+      -----------------\n+\n+      function Input_Match\n+        (Dep_Input   : Node_Id;\n+         Ref_Inputs  : List_Id;\n+         Post_Errors : Boolean) return Boolean\n+      is\n+         procedure Match_Error (Msg : String; N : Node_Id);\n+         --  Emit a matching error if flag Post_Errors is set\n+\n+         -----------------\n+         -- Match_Error --\n+         -----------------\n+\n+         procedure Match_Error (Msg : String; N : Node_Id) is\n+         begin\n+            if Post_Errors then\n+               Error_Msg_N (Msg, N);\n+            end if;\n+         end Match_Error;\n+\n+         --  Local variables\n+\n+         Dep_Id         : Node_Id;\n+         Next_Ref_Input : Node_Id;\n+         Ref_Id         : Entity_Id;\n+         Ref_Input      : Node_Id;\n+\n+         Has_Constituent : Boolean := False;\n+         --  Flag set when the refinement input list contains at least one\n+         --  constituent of the state denoted by Dep_Id.\n+\n+         Has_Null_State : Boolean := False;\n+         --  Flag set when the dependency input is a state with a visible null\n+         --  refinement.\n+\n+         Has_Refined_State : Boolean := False;\n+         --  Flag set when the dependency input is a state with visible non-\n+         --  null refinement.\n+\n+      --  Start of processing for Input_Match\n+\n+      begin\n+         --  Match a null input with another null input\n+\n+         if Nkind (Dep_Input) = N_Null then\n+            Ref_Input := First (Ref_Inputs);\n+\n+            --  Remove the matching null from the pool of candidates\n+\n+            if Nkind (Ref_Input) = N_Null then\n+               Remove (Ref_Input);\n+               return True;\n+\n+            else\n+               Match_Error\n+                 (\"null input cannot be matched in corresponding refinement \"\n+                  & \"clause\", Dep_Input);\n+            end if;\n+\n+         --  Remaining cases are formal parameters, variables, and states\n+\n+         else\n+            --  Handle abstract views of states and variables generated for\n+            --  limited with clauses.\n+\n+            Dep_Id := Available_View (Entity_Of (Dep_Input));\n+\n+            --  Inspect all inputs of the refinement clause and attempt to\n+            --  match against the inputs of the dependence clause.\n+\n+            Ref_Input := First (Ref_Inputs);\n+            while Present (Ref_Input) loop\n+\n+               --  Store the next input now because a match will remove it from\n+               --  the list.\n+\n+               Next_Ref_Input := Next (Ref_Input);\n+\n+               if Ekind (Dep_Id) = E_Abstract_State then\n+\n+                  --  A state with a null refinement matches either a null\n+                  --  input list or nothing at all (no input):\n+\n+                  --    Refined_State   => (State => null)\n+\n+                  --  No input\n+\n+                  --    Depends         => (<output> => (State, Input))\n+                  --    Refined_Depends => (<output> => Input)  --  OK\n+\n+                  --  Null input list\n+\n+                  --    Depends         => (<output> => State)\n+                  --    Refined_Depends => (<output> => null)   --  OK\n+\n+                  if Has_Null_Refinement (Dep_Id) then\n+                     Has_Null_State := True;\n+\n+                     --  Remove the matching null from the pool of candidates\n+\n+                     if Nkind (Ref_Input) = N_Null then\n+                        Remove (Ref_Input);\n+                     end if;\n+\n+                     return True;\n+\n+                  --  The state has a non-null refinement in which case remove\n+                  --  all the matching constituents of the state:\n+\n+                  --    Refined_State   => (State    => (C1, C2))\n+                  --    Depends         => (<output> =>  State)\n+                  --    Refined_Depends => (<output> => (C1, C2))\n+\n+                  elsif Has_Non_Null_Refinement (Dep_Id) then\n+                     Has_Refined_State := True;\n+\n+                     --  A state with a visible non-null refinement may have a\n+                     --  null input_list only when it is self referential.\n+\n+                     --    Refined_State   => (State => (C1, C2))\n+                     --    Depends         => (State => State)\n+                     --    Refined_Depends => (C2 => null)  --  OK\n+\n+                     if Nkind (Ref_Input) = N_Null\n+                       and then Is_Self_Referential (Dep_Id)\n+                     then\n+                        --  Remove the null from the pool of candidates. Note\n+                        --  that the search continues because the state may be\n+                        --  represented by multiple constituents.\n+\n+                        Has_Constituent := True;\n+                        Remove (Ref_Input);\n+\n+                     --  Ref_Input is an entity name\n+\n+                     elsif Is_Entity_Name (Ref_Input) then\n+                        Ref_Id := Entity_Of (Ref_Input);\n+\n+                        --  The input of the refinement clause is a valid\n+                        --  constituent of the state. Remove the input from the\n+                        --  pool of candidates. Note that the search continues\n+                        --  because the state may be represented by multiple\n+                        --  constituents.\n+\n+                        if Ekind_In (Ref_Id, E_Abstract_State,\n+                                             E_Variable)\n+                          and then Present (Encapsulating_State (Ref_Id))\n+                          and then Encapsulating_State (Ref_Id) = Dep_Id\n+                        then\n+                           Has_Constituent := True;\n+                           Remove (Ref_Input);\n+                        end if;\n+                     end if;\n+\n+                  --  The abstract view of a state matches its corresponding\n+                  --  non-abstract view:\n+\n+                  --    Depends         => (<output> => Lim_Pack.State)\n+                  --    Refined_Depends => (<output> => State)\n+\n+                  elsif Is_Entity_Name (Ref_Input)\n+                    and then Entity_Of (Ref_Input) = Dep_Id\n+                  then\n+                     Remove (Ref_Input);\n+                     return True;\n+                  end if;\n+\n+               --  Formal parameters and variables are matched on entities. If\n+               --  this is the case, remove the input from the candidate list.\n+\n+               elsif Is_Entity_Name (Ref_Input)\n+                 and then Entity_Of (Ref_Input) = Dep_Id\n+               then\n+                  Remove (Ref_Input);\n+                  return True;\n+               end if;\n+\n+               Ref_Input := Next_Ref_Input;\n+            end loop;\n+\n+            --  When a state with a null refinement appears as the last input,\n+            --  it matches nothing:\n+\n+            --    Refined_State   => (State => null)\n+            --    Depends         => (<output> => (Input, State))\n+            --    Refined_Depends => (<output> => Input)  --  OK\n+\n+            if Ekind (Dep_Id) = E_Abstract_State\n+              and then Has_Null_Refinement (Dep_Id)\n+              and then No (Ref_Input)\n+            then\n+               Has_Null_State := True;\n+            end if;\n+         end if;\n+\n+         --  A state with visible refinement was matched against one or more of\n+         --  its constituents.\n+\n+         if Has_Constituent then\n+            return True;\n+\n+         --  A state with a null refinement matched null or nothing\n+\n+         elsif Has_Null_State then\n+            return True;\n+\n+         --  The input of a dependence clause does not have a matching input in\n+         --  the refinement clause, emit an error.\n+\n+         else\n+            Match_Error\n+              (\"input cannot be matched in corresponding refinement clause\",\n+               Dep_Input);\n+\n+            if Has_Refined_State then\n+               Match_Error\n+                 (\"\\check the use of constituents in dependence refinement\",\n+                  Dep_Input);\n+            end if;\n+\n+            return False;\n+         end if;\n+      end Input_Match;\n+\n+      ------------------\n+      -- Inputs_Match --\n+      ------------------\n+\n+      function Inputs_Match\n+        (Dep_Clause  : Node_Id;\n+         Ref_Clause  : Node_Id;\n+         Post_Errors : Boolean) return Boolean\n+      is\n+         Ref_Inputs : List_Id;\n+         --  The input list of the refinement clause\n+\n+         procedure Report_Extra_Inputs;\n+         --  Emit errors for all extra inputs that appear in Ref_Inputs\n+\n+         -------------------------\n+         -- Report_Extra_Inputs --\n+         -------------------------\n+\n+         procedure Report_Extra_Inputs is\n+            Input : Node_Id;\n+\n+         begin\n+            if Present (Ref_Inputs) and then Post_Errors then\n+               Input := First (Ref_Inputs);\n+               while Present (Input) loop\n+                  Error_Msg_N\n+                    (\"unmatched or extra input in refinement clause\", Input);\n+\n+                  Next (Input);\n+               end loop;\n+            end if;\n+         end Report_Extra_Inputs;\n+\n+         --  Local variables\n+\n+         Dep_Inputs : constant Node_Id := Expression (Dep_Clause);\n+         Inputs     : constant Node_Id := Expression (Ref_Clause);\n+         Dep_Input  : Node_Id;\n+         Result     : Boolean;\n+\n+      --  Start of processing for Inputs_Match\n+\n+      begin\n+         --  Construct a list of all refinement inputs. Note that the input\n+         --  list is copied because the algorithm modifies its contents and\n+         --  this should not be visible in Refined_Depends.\n+\n+         if Nkind (Inputs) = N_Aggregate then\n+            Ref_Inputs := New_Copy_List (Expressions (Inputs));\n+         else\n+            Ref_Inputs := New_List (Inputs);\n+         end if;\n+\n+         --  Depending on whether the original dependency clause mentions\n+         --  states with visible refinement, the corresponding refinement\n+         --  clause may differ greatly in structure and contents:\n+\n+         --  State with null refinement\n+\n+         --    Refined_State   => (State    => null)\n+         --    Depends         => (<output> => State)\n+         --    Refined_Depends => (<output> => null)\n+\n+         --    Depends         => (<output> => (State, Input))\n+         --    Refined_Depends => (<output> => Input)\n+\n+         --    Depends         => (<output> => (Input_1, State, Input_2))\n+         --    Refined_Depends => (<output> => (Input_1, Input_2))\n+\n+         --  State with non-null refinement\n+\n+         --    Refined_State   => (State_1 => (C1, C2))\n+         --    Depends         => (<output> => State)\n+         --    Refined_Depends => (<output> => C1)\n+         --  or\n+         --    Refined_Depends => (<output> => (C1, C2))\n+\n+         if Nkind (Dep_Inputs) = N_Aggregate then\n+            Dep_Input := First (Expressions (Dep_Inputs));\n+            while Present (Dep_Input) loop\n+               if not Input_Match\n+                        (Dep_Input   => Dep_Input,\n+                         Ref_Inputs  => Ref_Inputs,\n+                         Post_Errors => Post_Errors)\n+               then\n+                  Result := False;\n+               end if;\n+\n+               Next (Dep_Input);\n+            end loop;\n+\n+            Result := True;\n+\n+         --  Solitary input\n+\n+         else\n+            Result :=\n+              Input_Match\n+                (Dep_Input   => Dep_Inputs,\n+                 Ref_Inputs  => Ref_Inputs,\n+                 Post_Errors => Post_Errors);\n+         end if;\n+\n+         --  List all inputs that appear as extras\n+\n+         Report_Extra_Inputs;\n+\n+         return Result;\n+      end Inputs_Match;\n+\n+      -------------------------\n+      -- Is_Self_Referential --\n+      -------------------------\n+\n+      function Is_Self_Referential (Item_Id : Entity_Id) return Boolean is\n+         function Denotes_Item (N : Node_Id) return Boolean;\n+         --  Determine whether an arbitrary node N denotes item Item_Id\n+\n+         ------------------\n+         -- Denotes_Item --\n+         ------------------\n+\n+         function Denotes_Item (N : Node_Id) return Boolean is\n+         begin\n+            return\n+              Is_Entity_Name (N)\n+                and then Present (Entity (N))\n+                and then Entity (N) = Item_Id;\n+         end Denotes_Item;\n+\n+         --  Local variables\n+\n+         Clauses : constant Node_Id :=\n+                     Get_Pragma_Arg\n+                       (First (Pragma_Argument_Associations (Depends)));\n+         Clause  : Node_Id;\n+         Input   : Node_Id;\n+         Output  : Node_Id;\n+\n+      --  Start of processing for Is_Self_Referential\n+\n+      begin\n+         Clause := First (Component_Associations (Clauses));\n+         while Present (Clause) loop\n+\n+            --  Due to normalization, a dependence clause has exactly one\n+            --  output even if the original clause had multiple outputs.\n+\n+            Output := First (Choices (Clause));\n+\n+            --  Detect the following scenario:\n+            --\n+            --    Item_Id => [(...,] Item_Id [, ...)]\n+\n+            if Denotes_Item (Output) then\n+               Input := Expression (Clause);\n+\n+               --  Multiple inputs appear as an aggregate\n+\n+               if Nkind (Input) = N_Aggregate then\n+                  Input := First (Expressions (Input));\n+\n+                  if Denotes_Item (Input) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Input);\n+\n+               --  Solitary input\n+\n+               elsif Denotes_Item (Input) then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next (Clause);\n+         end loop;\n+\n+         return False;\n+      end Is_Self_Referential;\n+\n       --------------------------\n       -- Report_Extra_Clauses --\n       --------------------------\n@@ -21803,19 +21910,12 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Body_Decl : constant Node_Id   := Parent (N);\n-      Body_Id   : constant Entity_Id := Defining_Entity (Body_Decl);\n-      Errors    : constant Nat       := Serious_Errors_Detected;\n+      Body_Decl : constant Node_Id := Parent (N);\n+      Errors    : constant Nat     := Serious_Errors_Detected;\n       Clause    : Node_Id;\n       Deps      : Node_Id;\n       Refs      : Node_Id;\n \n-      --  The following are dummy variables that capture unused output of\n-      --  routine Collect_Global_Items.\n-\n-      D1, D2, D3         : Elist_Id := No_Elist;\n-      D4, D5, D6, D7, D8 : Boolean;\n-\n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n    begin\n@@ -21859,28 +21959,6 @@ package body Sem_Prag is\n       Refs := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n       if Serious_Errors_Detected = Errors then\n-\n-         --  The related subprogram may be subject to pragma Refined_Global. If\n-         --  this is the case, gather all output items. These are needed when\n-         --  verifying the use of constituents that apply to output states with\n-         --  visible refinement.\n-\n-         Ref_Global := Get_Pragma (Body_Id, Pragma_Refined_Global);\n-\n-         if Present (Ref_Global) then\n-            Collect_Global_Items\n-              (Prag               => Ref_Global,\n-               In_Items           => D1,\n-               In_Out_Items       => D2,\n-               Out_Items          => Out_Items,\n-               Proof_In_Items     => D3,\n-               Has_In_State       => D4,\n-               Has_In_Out_State   => D5,\n-               Has_Out_State      => D6,\n-               Has_Proof_In_State => D7,\n-               Has_Null_State     => D8);\n-         end if;\n-\n          if Nkind (Refs) = N_Null then\n             Refinements := No_List;\n "}, {"sha": "d89f12e0196e363f55096cc76d3bd09ddcabcc02", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81bd8c9075b533aab81a9778119b92f4b7cd7737/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=81bd8c9075b533aab81a9778119b92f4b7cd7737", "patch": "@@ -7359,7 +7359,11 @@ package Sinfo is\n       --  the actions list is always non-null, since there is no point in this\n       --  node if the actions are Empty. During semantic analysis there are\n       --  cases where it is convenient to temporarily generate an empty actions\n-      --  list, but the Expander removes such cases.\n+      --  list. This arises in cases where we create such an empty actions\n+      --  list, and it may or may not end up being a place where additional\n+      --  actions are inserted. The expander removes such empty cases after\n+      --  the expression of the node is fully analyzed and expanded, at which\n+      --  point it is safe to remove it, since no more actions can be inserted.\n \n       --  Note: Expression may be a Null_Statement, in which case the\n       --  N_Expression_With_Actions has type Standard_Void_Type. However some"}]}