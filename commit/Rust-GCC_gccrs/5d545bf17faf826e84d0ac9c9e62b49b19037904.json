{"sha": "5d545bf17faf826e84d0ac9c9e62b49b19037904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1NDViZjE3ZmFmODI2ZTg0ZDBhYzljOWU2MmI0OWIxOTAzNzkwNA==", "commit": {"author": {"name": "Seongbae Park", "email": "seongbae.park@gmail.com", "date": "2007-07-30T20:30:38Z"}, "committer": {"name": "Seongbae Park", "email": "spark@gcc.gnu.org", "date": "2007-07-30T20:30:38Z"}, "message": "df-scan.c (df_scan_verify): Remove artificial limit on the number of blocks for verification.\n\n2007-07-30  Seongbae Park <seongbae.park@gmail.com>\n\n\t* df-scan.c (df_scan_verify): Remove artificial limit on\n\tthe number of blocks for verification.\n\t* df-problems.c (df_lr_bb_local_compute, df_simulate_find_defs,\n\tdf_simulate_defs): Avoid unnecessary insn checking for defs.\n\nFrom-SVN: r127070", "tree": {"sha": "3bcc94976b0a80a290a65e6c023be4528677d5e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bcc94976b0a80a290a65e6c023be4528677d5e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d545bf17faf826e84d0ac9c9e62b49b19037904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d545bf17faf826e84d0ac9c9e62b49b19037904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d545bf17faf826e84d0ac9c9e62b49b19037904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d545bf17faf826e84d0ac9c9e62b49b19037904/comments", "author": null, "committer": null, "parents": [{"sha": "2786eb8dbf8909fc0af3991043eaae77741cbeb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2786eb8dbf8909fc0af3991043eaae77741cbeb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2786eb8dbf8909fc0af3991043eaae77741cbeb0"}], "stats": {"total": 154, "additions": 28, "deletions": 126}, "files": [{"sha": "5cd25a9b7a7bea8ea9d3202a28d2ac66f9e64632", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d545bf17faf826e84d0ac9c9e62b49b19037904/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d545bf17faf826e84d0ac9c9e62b49b19037904/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d545bf17faf826e84d0ac9c9e62b49b19037904", "patch": "@@ -1,3 +1,10 @@\n+2007-07-30  Seongbae Park <seongbae.park@gmail.com>\n+\n+\t* df-scan.c (df_scan_verify): Remove artificial limit on\n+\tthe number of blocks for verification.\n+\t* df-problems.c (df_lr_bb_local_compute, df_simulate_find_defs,\n+\tdf_simulate_defs): Avoid unnecessary insn checking for defs.\n+\n 2007-07-29  Mark Mitchell  <mark@codesourcery.com>\n \n \tgcc/"}, {"sha": "b28fb16e1776111c8c168e535d2d9f6a4270e098", "filename": "gcc/df-problems.c", "status": "modified", "additions": 21, "deletions": 120, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d545bf17faf826e84d0ac9c9e62b49b19037904/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d545bf17faf826e84d0ac9c9e62b49b19037904/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=5d545bf17faf826e84d0ac9c9e62b49b19037904", "patch": "@@ -1389,53 +1389,16 @@ df_lr_bb_local_compute (unsigned int bb_index)\n       if (!INSN_P (insn))\n \tcontinue;\t\n \n-      if (CALL_P (insn))\n+      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t  struct df_ref *def = *def_rec;\n+\t  /* If the def is to only part of the reg, it does\n+\t     not kill the other defs that reach here.  */\n+\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n \t    {\n-\t      struct df_ref *def = *def_rec;\n \t      unsigned int dregno = DF_REF_REGNO (def);\n-\t      \n-\t      if (DF_REF_FLAGS (def) & DF_REF_MUST_CLOBBER)\n-\t\t{\n-\t\t  if (dregno >= FIRST_PSEUDO_REGISTER\n-\t\t      || !(SIBLING_CALL_P (insn)\n-\t\t\t   && bitmap_bit_p (df->exit_block_uses, dregno)\n-\t\t\t   && !refers_to_regno_p (dregno, dregno+1,\n-\t\t\t\t\t\t  current_function_return_rtx,\n-\t\t\t\t\t\t  (rtx *)0)))\n-\t\t    {\n-\t\t      /* If the def is to only part of the reg, it does\n-\t\t\t not kill the other defs that reach here.  */\n-\t\t      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t\t{\n-\t\t\t  bitmap_set_bit (bb_info->def, dregno);\n-\t\t\t  bitmap_clear_bit (bb_info->use, dregno);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t/* This is the return value.  */\n-\t\tif (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t  {\n-\t\t    bitmap_set_bit (bb_info->def, dregno);\n-\t\t    bitmap_clear_bit (bb_info->use, dregno);\n-\t\t  }\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t    {\n-\t      struct df_ref *def = *def_rec;\n-\t      /* If the def is to only part of the reg, it does\n-\t\t     not kill the other defs that reach here.  */\n-\t      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t{\n-\t\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t\t  bitmap_set_bit (bb_info->def, dregno);\n-\t\t  bitmap_clear_bit (bb_info->use, dregno);\n-\t\t}\n+\t      bitmap_set_bit (bb_info->def, dregno);\n+\t      bitmap_clear_bit (bb_info->use, dregno);\n \t    }\n \t}\n \n@@ -4218,44 +4181,13 @@ df_simulate_find_defs (rtx insn, bitmap defs)\n   struct df_ref **def_rec;\n   unsigned int uid = INSN_UID (insn);\n \n-  if (CALL_P (insn))\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  struct df_ref *def = *def_rec;\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  \n-\t  if (DF_REF_FLAGS (def) & DF_REF_MUST_CLOBBER)\n-\t    {\n-\t      if (dregno >= FIRST_PSEUDO_REGISTER\n-\t\t  || !(SIBLING_CALL_P (insn)\n-\t\t       && bitmap_bit_p (df->exit_block_uses, dregno)\n-\t\t       && !refers_to_regno_p (dregno, dregno+1,\n-\t\t\t\t\t      current_function_return_rtx,\n-\t\t\t\t\t      (rtx *)0)))\n-\t\t{\n-\t\t  /* If the def is to only part of the reg, it does\n-\t\t     not kill the other defs that reach here.  */\n-\t\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t    bitmap_set_bit (defs, dregno);\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* This is the return value.  */\n-\t    if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t      bitmap_set_bit (defs, dregno);\n-\t}\n-    }\n-  else\n-    {\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  struct df_ref *def = *def_rec;\n-\t  /* If the def is to only part of the reg, it does\n-\t     not kill the other defs that reach here.  */\n-\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t    bitmap_set_bit (defs, DF_REF_REGNO (def));\n-\t}\n+      struct df_ref *def = *def_rec;\n+      /* If the def is to only part of the reg, it does\n+\t not kill the other defs that reach here.  */\n+      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\tbitmap_set_bit (defs, DF_REF_REGNO (def));\n     }\n }\n \n@@ -4268,46 +4200,15 @@ df_simulate_defs (rtx insn, bitmap live)\n   struct df_ref **def_rec;\n   unsigned int uid = INSN_UID (insn);\n \n-  if (CALL_P (insn))\n+  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n     {\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  struct df_ref *def = *def_rec;\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  \n-\t  if (DF_REF_FLAGS (def) & DF_REF_MUST_CLOBBER)\n-\t    {\n-\t      if (dregno >= FIRST_PSEUDO_REGISTER\n-\t\t  || !(SIBLING_CALL_P (insn)\n-\t\t       && bitmap_bit_p (df->exit_block_uses, dregno)\n-\t\t       && !refers_to_regno_p (dregno, dregno+1,\n-\t\t\t\t\t      current_function_return_rtx,\n-\t\t\t\t\t      (rtx *)0)))\n-\t\t{\n-\t\t  /* If the def is to only part of the reg, it does\n-\t\t     not kill the other defs that reach here.  */\n-\t\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t    bitmap_clear_bit (live, dregno);\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* This is the return value.  */\n-\t    if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t      bitmap_clear_bit (live, dregno);\n-\t}\n-    }\n-  else\n-    {\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t{\n-\t  struct df_ref *def = *def_rec;\n-\t  unsigned int dregno = DF_REF_REGNO (def);\n-  \n-\t  /* If the def is to only part of the reg, it does\n-\t     not kill the other defs that reach here.  */\n-\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t    bitmap_clear_bit (live, dregno);\n-\t}\n+      struct df_ref *def = *def_rec;\n+      unsigned int dregno = DF_REF_REGNO (def);\n+\n+      /* If the def is to only part of the reg, it does\n+\t not kill the other defs that reach here.  */\n+      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\tbitmap_clear_bit (live, dregno);\n     }\n }  \n "}, {"sha": "76f85c142af6a1173abe614cda7cfd70dbd13e8d", "filename": "gcc/df-scan.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d545bf17faf826e84d0ac9c9e62b49b19037904/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d545bf17faf826e84d0ac9c9e62b49b19037904/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=5d545bf17faf826e84d0ac9c9e62b49b19037904", "patch": "@@ -4265,12 +4265,6 @@ df_scan_verify (void)\n   if (!df)\n     return;\n \n-  /* This is a hack, but a necessary one.  If you do not do this,\n-     insn_attrtab can never be compiled in a bootstrap.  This\n-     verification is just too expensive.  */\n-  if (n_basic_blocks > 250)\n-    return;\n-\n   /* Verification is a 4 step process. */\n \n   /* (1) All of the refs are marked by going thru the reg chains.  */"}]}