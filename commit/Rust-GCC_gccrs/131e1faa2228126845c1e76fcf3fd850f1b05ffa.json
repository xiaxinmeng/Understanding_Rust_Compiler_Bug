{"sha": "131e1faa2228126845c1e76fcf3fd850f1b05ffa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxZTFmYWEyMjI4MTI2ODQ1YzFlNzZmY2YzZmQ4NTBmMWIwNWZmYQ==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2017-01-06T17:26:11Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2017-01-06T17:26:11Z"}, "message": "[ARM] Refactor NEON builtin framework to work for other builtins\n\ngcc/ChangeLog:\n2017-01-06  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/arm/arm-builtins.c (neon_builtin_datum): Rename to ..\n\t(arm_builtin_datum): ... this.\n\t(arm_init_neon_builtin): Rename to ...\n\t(arm_init_builtin): ... this. Add a new parameters PREFIX\n\tand USE_SIG_IN_NAME.\n\t(arm_init_neon_builtins): Replace 'arm_init_neon_builtin' with\n\t'arm_init_builtin'. Replace type 'neon_builtin_datum' with\n\t'arm_builtin_datum'.\n\t(arm_init_vfp_builtins): Likewise.\n\t(builtin_arg): Rename enum's replacing 'NEON_ARG' with\n\t'ARG_BUILTIN' and add a 'ARG_BUILTIN_NEON_MEMORY.\n\t(arm_expand_neon_args): Rename to ...\n\t(arm_expand_builtin_args): ... this. Rename builtin_arg\n\tenum values and differentiate between ARG_BUILTIN_MEMORY\n\tand ARG_BUILTIN_NEON_MEMORY.\n\t(arm_expand_neon_builtin_1): Rename to ...\n\t(arm_expand_builtin_1): ... this. Rename builtin_arg enum\n\tvalues, arm_expand_builtin_args and add bool parameter NEON.\n\t(arm_expand_neon_builtin): Use arm_expand_builtin_1.\n\t(arm_expand_vfp_builtin): Likewise.\n\t(NEON_MAX_BUILTIN_ARGS): Remove, it was unused.\n\nFrom-SVN: r244170", "tree": {"sha": "c3dc9b03bdde8f3135615fb234e99b4c03bcd5b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3dc9b03bdde8f3135615fb234e99b4c03bcd5b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/131e1faa2228126845c1e76fcf3fd850f1b05ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131e1faa2228126845c1e76fcf3fd850f1b05ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/131e1faa2228126845c1e76fcf3fd850f1b05ffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131e1faa2228126845c1e76fcf3fd850f1b05ffa/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea4ad78e2c35e19b9a3387ecb4f021419e37ea9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4ad78e2c35e19b9a3387ecb4f021419e37ea9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea4ad78e2c35e19b9a3387ecb4f021419e37ea9d"}], "stats": {"total": 153, "additions": 96, "deletions": 57}, "files": [{"sha": "ede69fbf0775ef15d56d2a550c121680e222d0f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131e1faa2228126845c1e76fcf3fd850f1b05ffa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131e1faa2228126845c1e76fcf3fd850f1b05ffa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=131e1faa2228126845c1e76fcf3fd850f1b05ffa", "patch": "@@ -1,3 +1,27 @@\n+2017-01-06  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/arm/arm-builtins.c (neon_builtin_datum): Rename to ..\n+\t(arm_builtin_datum): ... this.\n+\t(arm_init_neon_builtin): Rename to ...\n+\t(arm_init_builtin): ... this. Add a new parameters PREFIX\n+\tand USE_SIG_IN_NAME.\n+\t(arm_init_neon_builtins): Replace 'arm_init_neon_builtin' with\n+\t'arm_init_builtin'. Replace type 'neon_builtin_datum' with\n+\t'arm_builtin_datum'.\n+\t(arm_init_vfp_builtins): Likewise.\n+\t(builtin_arg): Rename enum's replacing 'NEON_ARG' with\n+\t'ARG_BUILTIN' and add a 'ARG_BUILTIN_NEON_MEMORY.\n+\t(arm_expand_neon_args): Rename to ...\n+\t(arm_expand_builtin_args): ... this. Rename builtin_arg\n+\tenum values and differentiate between ARG_BUILTIN_MEMORY\n+\tand ARG_BUILTIN_NEON_MEMORY.\n+\t(arm_expand_neon_builtin_1): Rename to ...\n+\t(arm_expand_builtin_1): ... this. Rename builtin_arg enum\n+\tvalues, arm_expand_builtin_args and add bool parameter NEON.\n+\t(arm_expand_neon_builtin): Use arm_expand_builtin_1.\n+\t(arm_expand_vfp_builtin): Likewise.\n+\t(NEON_MAX_BUILTIN_ARGS): Remove, it was unused.\n+\n 2017-01-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR middle-end/77484"}, {"sha": "9101ad216eb70fb64ef90d225474520b8113fd3f", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 72, "deletions": 57, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131e1faa2228126845c1e76fcf3fd850f1b05ffa/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131e1faa2228126845c1e76fcf3fd850f1b05ffa/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=131e1faa2228126845c1e76fcf3fd850f1b05ffa", "patch": "@@ -203,7 +203,7 @@ typedef struct {\n   const enum insn_code code;\n   unsigned int fcode;\n   enum arm_type_qualifiers *qualifiers;\n-} neon_builtin_datum;\n+} arm_builtin_datum;\n \n #define CF(N,X) CODE_FOR_neon_##N##X\n \n@@ -243,7 +243,7 @@ typedef struct {\n   VAR11 (T, N, A, B, C, D, E, F, G, H, I, J, K) \\\n   VAR1 (T, N, L)\n \n-/* The NEON builtin data can be found in arm_neon_builtins.def and\n+/* The builtin data can be found in arm_neon_builtins.def,\n    arm_vfp_builtins.def.  The entries in arm_neon_builtins.def require\n    TARGET_NEON to be true.  The feature tests are checked when the\n    builtins are expanded.\n@@ -253,14 +253,14 @@ typedef struct {\n    would be specified after the assembler mnemonic, which usually\n    refers to the last vector operand.  The modes listed per\n    instruction should be the same as those defined for that\n-   instruction's pattern in neon.md.  */\n+   instruction's pattern, for instance in neon.md.  */\n \n-static neon_builtin_datum vfp_builtin_data[] =\n+static arm_builtin_datum vfp_builtin_data[] =\n {\n #include \"arm_vfp_builtins.def\"\n };\n \n-static neon_builtin_datum neon_builtin_data[] =\n+static arm_builtin_datum neon_builtin_data[] =\n {\n #include \"arm_neon_builtins.def\"\n };\n@@ -919,11 +919,15 @@ arm_init_simd_builtin_scalar_types (void)\n \t\t\t\t\t     \"__builtin_neon_uti\");\n }\n \n-/* Set up a NEON builtin.  */\n+/* Set up a builtin.  It will use information stored in the argument struct D to\n+   derive the builtin's type signature and name.  It will append the name in D\n+   to the PREFIX passed and use these to create a builtin declaration that is\n+   then stored in 'arm_builtin_decls' under index FCODE.  This FCODE is also\n+   written back to D for future use.  */\n \n static void\n-arm_init_neon_builtin (unsigned int fcode,\n-\t\t       neon_builtin_datum *d)\n+arm_init_builtin (unsigned int fcode, arm_builtin_datum *d,\n+\t\t  const char * prefix)\n {\n   bool print_type_signature_p = false;\n   char type_signature[SIMD_MAX_BUILTIN_ARGS] = { 0 };\n@@ -1011,12 +1015,13 @@ arm_init_neon_builtin (unsigned int fcode,\n \n   gcc_assert (ftype != NULL);\n \n-  if (print_type_signature_p)\n-    snprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s_%s\",\n-\t      d->name, type_signature);\n+  if (print_type_signature_p\n+      && IN_RANGE (fcode, ARM_BUILTIN_VFP_BASE, ARM_BUILTIN_MAX - 1))\n+    snprintf (namebuf, sizeof (namebuf), \"%s_%s_%s\",\n+\t      prefix, d->name, type_signature);\n   else\n-    snprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s\",\n-\t      d->name);\n+    snprintf (namebuf, sizeof (namebuf), \"%s_%s\",\n+\t      prefix, d->name);\n \n   fndecl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD,\n \t\t\t\t NULL, NULL_TREE);\n@@ -1052,8 +1057,8 @@ arm_init_neon_builtins (void)\n \n   for (i = 0; i < ARRAY_SIZE (neon_builtin_data); i++, fcode++)\n     {\n-      neon_builtin_datum *d = &neon_builtin_data[i];\n-      arm_init_neon_builtin (fcode, d);\n+      arm_builtin_datum *d = &neon_builtin_data[i];\n+      arm_init_builtin (fcode, d, \"__builtin_neon\");\n     }\n }\n \n@@ -1066,8 +1071,8 @@ arm_init_vfp_builtins (void)\n \n   for (i = 0; i < ARRAY_SIZE (vfp_builtin_data); i++, fcode++)\n     {\n-      neon_builtin_datum *d = &vfp_builtin_data[i];\n-      arm_init_neon_builtin (fcode, d);\n+      arm_builtin_datum *d = &vfp_builtin_data[i];\n+      arm_init_builtin (fcode, d, \"__builtin_neon\");\n     }\n }\n \n@@ -2031,15 +2036,15 @@ arm_expand_unop_builtin (enum insn_code icode,\n }\n \n typedef enum {\n-  NEON_ARG_COPY_TO_REG,\n-  NEON_ARG_CONSTANT,\n-  NEON_ARG_LANE_INDEX,\n-  NEON_ARG_STRUCT_LOAD_STORE_LANE_INDEX,\n-  NEON_ARG_MEMORY,\n-  NEON_ARG_STOP\n+  ARG_BUILTIN_COPY_TO_REG,\n+  ARG_BUILTIN_CONSTANT,\n+  ARG_BUILTIN_LANE_INDEX,\n+  ARG_BUILTIN_STRUCT_LOAD_STORE_LANE_INDEX,\n+  ARG_BUILTIN_NEON_MEMORY,\n+  ARG_BUILTIN_MEMORY,\n+  ARG_BUILTIN_STOP\n } builtin_arg;\n \n-#define NEON_MAX_BUILTIN_ARGS 5\n \n /* EXP is a pointer argument to a Neon load or store intrinsic.  Derive\n    and return an expression for the accessed memory.\n@@ -2089,9 +2094,9 @@ neon_dereference_pointer (tree exp, tree type, machine_mode mem_mode,\n \t\t      build_int_cst (build_pointer_type (array_type), 0));\n }\n \n-/* Expand a Neon builtin.  */\n+/* Expand a builtin.  */\n static rtx\n-arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n+arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n \t\t      int icode, int have_retval, tree exp,\n \t\t      builtin_arg *args)\n {\n@@ -2115,14 +2120,14 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n     {\n       builtin_arg thisarg = args[argc];\n \n-      if (thisarg == NEON_ARG_STOP)\n+      if (thisarg == ARG_BUILTIN_STOP)\n \tbreak;\n       else\n \t{\n \t  int opno = argc + have_retval;\n \t  arg[argc] = CALL_EXPR_ARG (exp, argc);\n \t  mode[argc] = insn_data[icode].operand[opno].mode;\n-          if (thisarg == NEON_ARG_MEMORY)\n+\t  if (thisarg == ARG_BUILTIN_NEON_MEMORY)\n             {\n               machine_mode other_mode\n \t\t= insn_data[icode].operand[1 - opno].mode;\n@@ -2132,15 +2137,17 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n \t\t\t\t\t\t    map_mode);\n             }\n \n-\t  /* Use EXPAND_MEMORY for NEON_ARG_MEMORY to ensure a MEM_P\n-\t     be returned.  */\n+\t  /* Use EXPAND_MEMORY for ARG_BUILTIN_MEMORY and\n+\t     ARG_BUILTIN_NEON_MEMORY to ensure a MEM_P be returned.  */\n \t  op[argc] = expand_expr (arg[argc], NULL_RTX, VOIDmode,\n-\t\t\t\t  (thisarg == NEON_ARG_MEMORY\n+\t\t\t\t  ((thisarg == ARG_BUILTIN_MEMORY\n+\t\t\t\t    || thisarg == ARG_BUILTIN_NEON_MEMORY)\n \t\t\t\t   ? EXPAND_MEMORY : EXPAND_NORMAL));\n \n \t  switch (thisarg)\n \t    {\n-\t    case NEON_ARG_COPY_TO_REG:\n+\t    case ARG_BUILTIN_MEMORY:\n+\t    case ARG_BUILTIN_COPY_TO_REG:\n \t      if (POINTER_TYPE_P (TREE_TYPE (arg[argc])))\n \t\top[argc] = convert_memory_address (Pmode, op[argc]);\n \t      /*gcc_assert (GET_MODE (op[argc]) == mode[argc]); */\n@@ -2149,7 +2156,7 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n \t\top[argc] = copy_to_mode_reg (mode[argc], op[argc]);\n \t      break;\n \n-\t    case NEON_ARG_STRUCT_LOAD_STORE_LANE_INDEX:\n+\t    case ARG_BUILTIN_STRUCT_LOAD_STORE_LANE_INDEX:\n \t      gcc_assert (argc > 1);\n \t      if (CONST_INT_P (op[argc]))\n \t\t{\n@@ -2161,7 +2168,7 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n \t\t}\n \t      goto constant_arg;\n \n-\t    case NEON_ARG_LANE_INDEX:\n+\t    case ARG_BUILTIN_LANE_INDEX:\n \t      /* Previous argument must be a vector, which this indexes.  */\n \t      gcc_assert (argc > 0);\n \t      if (CONST_INT_P (op[argc]))\n@@ -2172,7 +2179,7 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n \t      /* If the lane index isn't a constant then the next\n \t\t case will error.  */\n \t      /* Fall through.  */\n-\t    case NEON_ARG_CONSTANT:\n+\t    case ARG_BUILTIN_CONSTANT:\n constant_arg:\n \t      if (!(*insn_data[icode].operand[opno].predicate)\n \t\t  (op[argc], mode[argc]))\n@@ -2183,7 +2190,7 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n \t\t}\n \t      break;\n \n-            case NEON_ARG_MEMORY:\n+\t      case ARG_BUILTIN_NEON_MEMORY:\n \t      /* Check if expand failed.  */\n \t      if (op[argc] == const0_rtx)\n \t\treturn 0;\n@@ -2200,7 +2207,7 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n \t\t\t     copy_to_mode_reg (Pmode, XEXP (op[argc], 0))));\n               break;\n \n-\t    case NEON_ARG_STOP:\n+\t    case ARG_BUILTIN_STOP:\n \t      gcc_unreachable ();\n \t    }\n \n@@ -2269,21 +2276,24 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n   return target;\n }\n \n-/* Expand a neon builtin.  This is also used for vfp builtins, which behave in\n-   the same way.  These builtins are \"special\" because they don't have symbolic\n-   constants defined per-instruction or per instruction-variant.  Instead, the\n-   required info is looked up in the NEON_BUILTIN_DATA record that is passed\n-   into the function.  */\n+/* Expand a builtin.  These builtins are \"special\" because they don't have\n+   symbolic constants defined per-instruction or per instruction-variant.\n+   Instead, the required info is looked up in the ARM_BUILTIN_DATA record that\n+   is passed into the function.  */\n \n static rtx\n-arm_expand_neon_builtin_1 (int fcode, tree exp, rtx target,\n-\t\t\t   neon_builtin_datum *d)\n+arm_expand_builtin_1 (int fcode, tree exp, rtx target,\n+\t\t\t   arm_builtin_datum *d)\n {\n   enum insn_code icode = d->code;\n   builtin_arg args[SIMD_MAX_BUILTIN_ARGS + 1];\n   int num_args = insn_data[d->code].n_operands;\n   int is_void = 0;\n   int k;\n+  bool neon = false;\n+\n+  if (IN_RANGE (fcode, ARM_BUILTIN_VFP_BASE, ARM_BUILTIN_MAX - 1))\n+    neon = true;\n \n   is_void = !!(d->qualifiers[0] & qualifier_void);\n \n@@ -2303,11 +2313,11 @@ arm_expand_neon_builtin_1 (int fcode, tree exp, rtx target,\n       int expr_args_k = k - 1;\n \n       if (d->qualifiers[qualifiers_k] & qualifier_lane_index)\n-\targs[k] = NEON_ARG_LANE_INDEX;\n+\targs[k] = ARG_BUILTIN_LANE_INDEX;\n       else if (d->qualifiers[qualifiers_k] & qualifier_struct_load_store_lane_index)\n-\targs[k] = NEON_ARG_STRUCT_LOAD_STORE_LANE_INDEX;\n+\targs[k] = ARG_BUILTIN_STRUCT_LOAD_STORE_LANE_INDEX;\n       else if (d->qualifiers[qualifiers_k] & qualifier_immediate)\n-\targs[k] = NEON_ARG_CONSTANT;\n+\targs[k] = ARG_BUILTIN_CONSTANT;\n       else if (d->qualifiers[qualifiers_k] & qualifier_maybe_immediate)\n \t{\n \t  rtx arg\n@@ -2318,18 +2328,23 @@ arm_expand_neon_builtin_1 (int fcode, tree exp, rtx target,\n \t    (CONST_INT_P (arg)\n \t     && (*insn_data[icode].operand[operands_k].predicate)\n \t     (arg, insn_data[icode].operand[operands_k].mode));\n-\t  args[k] = op_const_int_p ? NEON_ARG_CONSTANT : NEON_ARG_COPY_TO_REG;\n+\t  args[k] = op_const_int_p ? ARG_BUILTIN_CONSTANT : ARG_BUILTIN_COPY_TO_REG;\n \t}\n       else if (d->qualifiers[qualifiers_k] & qualifier_pointer)\n-\targs[k] = NEON_ARG_MEMORY;\n+\t{\n+\t  if (neon)\n+\t    args[k] = ARG_BUILTIN_NEON_MEMORY;\n+\t  else\n+\t    args[k] = ARG_BUILTIN_MEMORY;\n+\t}\n       else\n-\targs[k] = NEON_ARG_COPY_TO_REG;\n+\targs[k] = ARG_BUILTIN_COPY_TO_REG;\n     }\n-  args[k] = NEON_ARG_STOP;\n+  args[k] = ARG_BUILTIN_STOP;\n \n-  /* The interface to arm_expand_neon_args expects a 0 if\n+  /* The interface to arm_expand_builtin_args expects a 0 if\n      the function is void, and a 1 if it is not.  */\n-  return arm_expand_neon_args\n+  return arm_expand_builtin_args\n     (target, d->mode, fcode, icode, !is_void, exp,\n      &args[1]);\n }\n@@ -2367,10 +2382,10 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n       return const0_rtx;\n     }\n \n-  neon_builtin_datum *d\n+  arm_builtin_datum *d\n     = &neon_builtin_data[fcode - ARM_BUILTIN_NEON_PATTERN_START];\n \n-  return arm_expand_neon_builtin_1 (fcode, exp, target, d);\n+  return arm_expand_builtin_1 (fcode, exp, target, d);\n }\n \n /* Expand a VFP builtin.  These builtins are treated like\n@@ -2388,10 +2403,10 @@ arm_expand_vfp_builtin (int fcode, tree exp, rtx target)\n       return const0_rtx;\n     }\n \n-  neon_builtin_datum *d\n+  arm_builtin_datum *d\n     = &vfp_builtin_data[fcode - ARM_BUILTIN_VFP_PATTERN_START];\n \n-  return arm_expand_neon_builtin_1 (fcode, exp, target, d);\n+  return arm_expand_builtin_1 (fcode, exp, target, d);\n }\n \n /* Expand an expression EXP that calls a built-in function,"}]}