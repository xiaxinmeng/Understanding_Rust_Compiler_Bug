{"sha": "0c3317563e01d865568dd8baa2986e0f4fa122a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzMzE3NTYzZTAxZDg2NTU2OGRkOGJhYTI5ODZlMGY0ZmExMjJhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-04T17:34:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-04T17:34:49Z"}, "message": "lra-int.h (lra_static_insn_data): Make operand_alternative a const pointer.\n\ngcc/\n\t* lra-int.h (lra_static_insn_data): Make operand_alternative a\n\tconst pointer.\n\t(target_lra_int, default_target_lra_int, this_target_lra_int)\n\t(op_alt_data): Delete.\n\t* lra.h (lra_init): Delete.\n\t* lra.c (default_target_lra_int, this_target_lra_int): Delete.\n\t(init_insn_code_data_once): Remove op_alt_data handling.\n\t(finish_insn_code_data_once): Likewise.\n\t(init_op_alt_data): Delete.\n\t(get_static_insn_data): Initialize operand_alternative to null.\n\t(free_insn_recog_data): Cast operand_alternative before freeing it.\n\t(setup_operand_alternative): Take the operand_alternative as\n\tparameter and assume it isn't already cached in the static\n\tinsn data.\n\t(lra_set_insn_recog_data): Update accordingly.\n\t(lra_init): Delete.\n\t* ira.c (ira_init): Don't call lra_init.\n\t* target-globals.h (this_target_lra_int): Declare.\n\t(target_globals): Remove lra_int.\n\t(restore_target_globals): Update accordingly.\n\t* target-globals.c: Don't include lra-int.h.\n\t(default_target_globals, save_target_globals): Remove lra_int.\n\nFrom-SVN: r211241", "tree": {"sha": "4d20cb81abcbd2bea386b3be0574e656bdc919f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d20cb81abcbd2bea386b3be0574e656bdc919f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c3317563e01d865568dd8baa2986e0f4fa122a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3317563e01d865568dd8baa2986e0f4fa122a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c3317563e01d865568dd8baa2986e0f4fa122a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3317563e01d865568dd8baa2986e0f4fa122a8/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1145837df5c8c6c7664551878d216671ecf8ef6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1145837df5c8c6c7664551878d216671ecf8ef6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1145837df5c8c6c7664551878d216671ecf8ef6e"}], "stats": {"total": 284, "additions": 66, "deletions": 218}, "files": [{"sha": "eb0220a36ed514a9fddde5b24ef0979a8f07d2f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -1,3 +1,28 @@\n+2014-06-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lra-int.h (lra_static_insn_data): Make operand_alternative a\n+\tconst pointer.\n+\t(target_lra_int, default_target_lra_int, this_target_lra_int)\n+\t(op_alt_data): Delete.\n+\t* lra.h (lra_init): Delete.\n+\t* lra.c (default_target_lra_int, this_target_lra_int): Delete.\n+\t(init_insn_code_data_once): Remove op_alt_data handling.\n+\t(finish_insn_code_data_once): Likewise.\n+\t(init_op_alt_data): Delete.\n+\t(get_static_insn_data): Initialize operand_alternative to null.\n+\t(free_insn_recog_data): Cast operand_alternative before freeing it.\n+\t(setup_operand_alternative): Take the operand_alternative as\n+\tparameter and assume it isn't already cached in the static\n+\tinsn data.\n+\t(lra_set_insn_recog_data): Update accordingly.\n+\t(lra_init): Delete.\n+\t* ira.c (ira_init): Don't call lra_init.\n+\t* target-globals.h (this_target_lra_int): Declare.\n+\t(target_globals): Remove lra_int.\n+\t(restore_target_globals): Update accordingly.\n+\t* target-globals.c: Don't include lra-int.h.\n+\t(default_target_globals, save_target_globals): Remove lra_int.\n+\n 2014-06-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* recog.h (operand_alternative): Convert reg_class, reject,"}, {"sha": "9d9bdf9bdda073b594ca148601a8acd3df50b3ac", "filename": "gcc/ira.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -1715,7 +1715,6 @@ ira_init (void)\n   clarify_prohibited_class_mode_regs ();\n   setup_hard_regno_aclass ();\n   ira_init_costs ();\n-  lra_init ();\n }\n \n /* Function called once at the end of compiler work.  */"}, {"sha": "24ae03b85a79f6bd967f3d47ab04665d9e102757", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -202,7 +202,7 @@ struct lra_static_insn_data\n   /* Array [n_alternatives][n_operand] of static constraint info for\n      given operand in given alternative.  This info can be changed if\n      the target reg info is changed.  */\n-  struct operand_alternative *operand_alternative;\n+  const struct operand_alternative *operand_alternative;\n };\n \n /* LRA internal info about an insn (LRA internal insn\n@@ -499,21 +499,3 @@ lra_assign_reg_val (int from, int to)\n   lra_reg_info[to].val = lra_reg_info[from].val;\n   lra_reg_info[to].offset = lra_reg_info[from].offset;\n }\n-\f\n-\n-struct target_lra_int\n-{\n-  /* Map INSN_UID -> the operand alternative data (NULL if unknown).\n-     We assume that this data is valid until register info is changed\n-     because classes in the data can be changed.  */\n-  struct operand_alternative *x_op_alt_data[LAST_INSN_CODE];\n-};\n-\n-extern struct target_lra_int default_target_lra_int;\n-#if SWITCHABLE_TARGET\n-extern struct target_lra_int *this_target_lra_int;\n-#else\n-#define this_target_lra_int (&default_target_lra_int)\n-#endif\n-\n-#define op_alt_data (this_target_lra_int->x_op_alt_data)"}, {"sha": "6442b1d751421901257a3f8fc0fac16b690e7a7b", "filename": "gcc/lra.c", "status": "modified", "additions": 40, "deletions": 191, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -553,11 +553,6 @@ finish_insn_regs (void)\n /* This page contains code dealing LRA insn info (or in other words\n    LRA internal insn representation).  */\n \n-struct target_lra_int default_target_lra_int;\n-#if SWITCHABLE_TARGET\n-struct target_lra_int *this_target_lra_int = &default_target_lra_int;\n-#endif\n-\n /* Map INSN_CODE -> the static insn data.  This info is valid during\n    all translation unit.  */\n struct lra_static_insn_data *insn_code_data[LAST_INSN_CODE];\n@@ -599,7 +594,6 @@ static void\n init_insn_code_data_once (void)\n {\n   memset (insn_code_data, 0, sizeof (insn_code_data));\n-  memset (op_alt_data, 0, sizeof (op_alt_data));\n }\n \n /* Called once per compiler work to finalize some LRA data related to\n@@ -613,25 +607,9 @@ finish_insn_code_data_once (void)\n     {\n       if (insn_code_data[i] != NULL)\n \tfree (insn_code_data[i]);\n-      if (op_alt_data[i] != NULL)\n-\tfree (op_alt_data[i]);\n     }\n }\n \n-/* Initialize LRA info about operands in insn alternatives.  */\n-static void\n-init_op_alt_data (void)\n-{\n- int i;\n-\n-  for (i = 0; i < LAST_INSN_CODE; i++)\n-    if (op_alt_data[i] != NULL)\n-      {\n-\tfree (op_alt_data[i]);\n-\top_alt_data[i] = NULL;\n-      }\n-}\n-\n /* Return static insn data, allocate and setup if necessary.  Although\n    dup_num is static data (it depends only on icode), to set it up we\n    need to extract insn first.\tSo recog_data should be valid for\n@@ -650,6 +628,7 @@ get_static_insn_data (int icode, int nop, int ndup, int nalt)\n \t    + sizeof (struct lra_operand_data) * nop\n \t    + sizeof (int) * ndup;\n   data = XNEWVAR (struct lra_static_insn_data, n_bytes);\n+  data->operand_alternative = NULL;\n   data->n_operands = nop;\n   data->n_dups = ndup;\n   data->n_alternatives = nalt;\n@@ -727,7 +706,8 @@ free_insn_recog_data (lra_insn_recog_data_t data)\n   if (data->icode < 0 && NONDEBUG_INSN_P (data->insn))\n     {\n       if (data->insn_static_data->operand_alternative != NULL)\n-\tfree (data->insn_static_data->operand_alternative);\n+\tfree (const_cast <operand_alternative *>\n+\t      (data->insn_static_data->operand_alternative));\n       free_insn_regs (data->insn_static_data->hard_regs);\n       free (data->insn_static_data);\n     }\n@@ -752,173 +732,38 @@ finish_insn_recog_data (void)\n \n /* Setup info about operands in alternatives of LRA DATA of insn.  */\n static void\n-setup_operand_alternative (lra_insn_recog_data_t data)\n+setup_operand_alternative (lra_insn_recog_data_t data,\n+\t\t\t   const operand_alternative *op_alt)\n {\n-  int i, nop, nalt;\n+  int i, j, nop, nalt;\n   int icode = data->icode;\n   struct lra_static_insn_data *static_data = data->insn_static_data;\n \n-  if (icode >= 0\n-      && (static_data->operand_alternative = op_alt_data[icode]) != NULL)\n-    return;\n   static_data->commutative = -1;\n   nop = static_data->n_operands;\n-  if (nop == 0)\n-    {\n-      static_data->operand_alternative = NULL;\n-      return;\n-    }\n   nalt = static_data->n_alternatives;\n-  static_data->operand_alternative = XNEWVEC (struct operand_alternative,\n-\t\t\t\t\t      nalt * nop);\n-  memset (static_data->operand_alternative, 0,\n-\t  nalt * nop * sizeof (struct operand_alternative));\n-  if (icode >= 0)\n-    op_alt_data[icode] = static_data->operand_alternative;\n+  static_data->operand_alternative = op_alt;\n   for (i = 0; i < nop; i++)\n     {\n-      int j;\n-      struct operand_alternative *op_alt_start, *op_alt;\n-      const char *p = static_data->operand[i].constraint;\n-\n-      static_data->operand[i].early_clobber = 0;\n-      op_alt_start = &static_data->operand_alternative[i];\n-\n-      for (j = 0; j < nalt; j++)\n+      static_data->operand[i].early_clobber = false;\n+      static_data->operand[i].is_address = false;\n+      if (static_data->operand[i].constraint[0] == '%')\n \t{\n-\t  op_alt = op_alt_start + j * nop;\n-\t  op_alt->cl = NO_REGS;\n-\t  op_alt->constraint = p;\n-\t  op_alt->matches = -1;\n-\t  op_alt->matched = -1;\n-\n-\t  if (*p == '\\0' || *p == ',')\n-\t    {\n-\t      op_alt->anything_ok = 1;\n-\t      continue;\n-\t    }\n-\n-\t  for (;;)\n-\t    {\n-\t      char c = *p;\n-\t      if (c == '#')\n-\t\tdo\n-\t\t  c = *++p;\n-\t\twhile (c != ',' && c != '\\0');\n-\t      if (c == ',' || c == '\\0')\n-\t\t{\n-\t\t  p++;\n-\t\t  break;\n-\t\t}\n-\n-\t      switch (c)\n-\t\t{\n-\t\tcase '=': case '+': case '*':\n-\t\tcase 'E': case 'F': case 'G': case 'H':\n-\t\tcase 's': case 'i': case 'n':\n-\t\tcase 'I': case 'J': case 'K': case 'L':\n-\t\tcase 'M': case 'N': case 'O': case 'P':\n-\t\t  /* These don't say anything we care about.  */\n-\t\t  break;\n-\n-\t\tcase '%':\n-\t\t  /* We currently only support one commutative pair of\n-\t\t     operands.\t*/\n-\t\t  if (static_data->commutative < 0)\n-\t\t    static_data->commutative = i;\n-\t\t  else\n-\t\t    lra_assert (data->icode < 0); /* Asm  */\n-\n-\t\t  /* The last operand should not be marked\n-\t\t     commutative.  */\n-\t\t  lra_assert (i != nop - 1);\n-\t\t  break;\n-\n-\t\tcase '?':\n-\t\t  op_alt->reject += LRA_LOSER_COST_FACTOR;\n-\t\t  break;\n-\t\tcase '!':\n-\t\t  op_alt->reject += LRA_MAX_REJECT;\n-\t\t  break;\n-\t\tcase '&':\n-\t\t  op_alt->earlyclobber = 1;\n-\t\t  static_data->operand[i].early_clobber = 1;\n-\t\t  break;\n-\n-\t\tcase '0': case '1': case '2': case '3': case '4':\n-\t\tcase '5': case '6': case '7': case '8': case '9':\n-\t\t  {\n-\t\t    char *end;\n-\t\t    op_alt->matches = strtoul (p, &end, 10);\n-\t\t    static_data->operand_alternative\n-\t\t      [j * nop + op_alt->matches].matched = i;\n-\t\t    p = end;\n-\t\t  }\n-\t\t  continue;\n-\n-\t\tcase TARGET_MEM_CONSTRAINT:\n-\t\t  op_alt->memory_ok = 1;\n-\t\t  break;\n-\t\tcase '<':\n-\t\t  op_alt->decmem_ok = 1;\n-\t\t  break;\n-\t\tcase '>':\n-\t\t  op_alt->incmem_ok = 1;\n-\t\t  break;\n-\t\tcase 'V':\n-\t\t  op_alt->nonoffmem_ok = 1;\n-\t\t  break;\n-\t\tcase 'o':\n-\t\t  op_alt->offmem_ok = 1;\n-\t\t  break;\n-\t\tcase 'X':\n-\t\t  op_alt->anything_ok = 1;\n-\t\t  break;\n-\n-\t\tcase 'p':\n-\t\t  static_data->operand[i].is_address = true;\n-\t\t  op_alt->is_address = 1;\n-\t\t  op_alt->cl = (reg_class_subunion[(int) op_alt->cl]\n-\t\t\t\t[(int) base_reg_class (VOIDmode,\n-\t\t\t\t\t\t       ADDR_SPACE_GENERIC,\n-\t\t\t\t\t\t       ADDRESS, SCRATCH)]);\n-\t\t  break;\n-\n-\t\tcase 'g':\n-\t\tcase 'r':\n-\t\t  op_alt->cl =\n-\t\t   reg_class_subunion[(int) op_alt->cl][(int) GENERAL_REGS];\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t    {\n-\t\t      op_alt->memory_ok = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t    {\n-\t\t      static_data->operand[i].is_address = true;\n-\t\t      op_alt->is_address = 1;\n-\t\t      op_alt->cl\n-\t\t\t= (reg_class_subunion\n-\t\t\t   [(int) op_alt->cl]\n-\t\t\t   [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t\t  ADDRESS, SCRATCH)]);\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  op_alt->cl\n-\t\t    = (reg_class_subunion\n-\t\t       [(int) op_alt->cl]\n-\t\t       [(int)\n-\t\t\tREG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n-\t\t  break;\n-\t\t}\n-\t      p += CONSTRAINT_LEN (c, p);\n-\t    }\n+\t  /* We currently only support one commutative pair of operands.  */\n+\t  if (static_data->commutative < 0)\n+\t    static_data->commutative = i;\n+\t  else\n+\t    lra_assert (icode < 0); /* Asm  */\n+\t  /* The last operand should not be marked commutative.  */\n+\t  lra_assert (i != nop - 1);\n \t}\n     }\n+  for (j = 0; j < nalt; j++)\n+    for (i = 0; i < nop; i++, op_alt++)\n+      {\n+\tstatic_data->operand[i].early_clobber |= op_alt->earlyclobber;\n+\tstatic_data->operand[i].is_address |= op_alt->is_address;\n+      }\n }\n \n /* Recursively process X and collect info about registers, which are\n@@ -1077,12 +922,13 @@ lra_set_insn_recog_data (rtx insn)\n     }\n   if (icode < 0)\n     {\n-      int nop;\n+      int nop, nalt;\n       enum machine_mode operand_mode[MAX_RECOG_OPERANDS];\n       const char *constraints[MAX_RECOG_OPERANDS];\n \n       nop = asm_noperands (PATTERN (insn));\n       data->operand_loc = data->dup_loc = NULL;\n+      nalt = 1;\n       if (nop < 0)\n \t{\n \t  /* Its is a special insn like USE or CLOBBER.  We should\n@@ -1092,7 +938,7 @@ lra_set_insn_recog_data (rtx insn)\n \t\t      || GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t      || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n \t  data->insn_static_data = insn_static_data\n-\t    = get_static_insn_data (-1, 0, 0, 1);\n+\t    = get_static_insn_data (-1, 0, 0, nalt);\n \t}\n       else\n \t{\n@@ -1106,16 +952,15 @@ lra_set_insn_recog_data (rtx insn)\n \t  decode_asm_operands (PATTERN (insn), NULL,\n \t\t\t       data->operand_loc,\n \t\t\t       constraints, operand_mode, NULL);\n-\t  n = 1;\n \t  if (nop > 0)\n \t    {\n \t      const char *p =  recog_data.constraints[0];\n \n \t      for (p =\tconstraints[0]; *p; p++)\n-\t\tn += *p == ',';\n+\t\tnalt += *p == ',';\n \t    }\n \t  data->insn_static_data = insn_static_data\n-\t    = get_static_insn_data (-1, nop, 0, n);\n+\t    = get_static_insn_data (-1, nop, 0, nalt);\n \t  for (i = 0; i < nop; i++)\n \t    {\n \t      insn_static_data->operand[i].mode = operand_mode[i];\n@@ -1131,6 +976,13 @@ lra_set_insn_recog_data (rtx insn)\n \t     : insn_static_data->operand[i].constraint[0] == '+' ? OP_INOUT\n \t     : OP_IN);\n       data->enabled_alternatives = ALL_ALTERNATIVES;\n+      if (nop > 0)\n+\t{\n+\t  operand_alternative *op_alt = XCNEWVEC (operand_alternative,\n+\t\t\t\t\t\t  nalt * nop);\n+\t  preprocess_constraints (nop, nalt, constraints, op_alt);\n+\t  setup_operand_alternative (data, op_alt);\n+\t}\n     }\n   else\n     {\n@@ -1158,14 +1010,18 @@ lra_set_insn_recog_data (rtx insn)\n \t}\n       data->dup_loc = locs;\n       data->enabled_alternatives = get_enabled_alternatives (insn);\n+      const operand_alternative *op_alt = preprocess_insn_constraints (icode);\n+      if (!insn_static_data->operand_alternative)\n+\tsetup_operand_alternative (data, op_alt);\n+      else if (op_alt != insn_static_data->operand_alternative)\n+\tinsn_static_data->operand_alternative = op_alt;\n     }\n   if (GET_CODE (PATTERN (insn)) == CLOBBER || GET_CODE (PATTERN (insn)) == USE)\n     insn_static_data->hard_regs = NULL;\n   else\n     insn_static_data->hard_regs\n       = collect_non_operand_hard_regs (&PATTERN (insn), data,\n \t\t\t\t       NULL, OP_IN, false);\n-  setup_operand_alternative (data);\n   data->arg_hard_regs = NULL;\n   if (CALL_P (insn))\n     {\n@@ -2463,13 +2319,6 @@ lra_init_once (void)\n   init_insn_code_data_once ();\n }\n \n-/* Initialize LRA whenever register-related information is changed.  */\n-void\n-lra_init (void)\n-{\n-  init_op_alt_data ();\n-}\n-\n /* Called once per compiler to finish LRA data which are initialize\n    once.  */\n void"}, {"sha": "4d67484b77f2375f3a149a45b5897d888bde1d4e", "filename": "gcc/lra.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Flra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Flra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.h?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -36,5 +36,4 @@ extern rtx lra_create_new_reg (enum machine_mode, rtx, enum reg_class,\n extern rtx lra_eliminate_regs (rtx, enum machine_mode, rtx);\n extern void lra (FILE *);\n extern void lra_init_once (void);\n-extern void lra_init (void);\n extern void lra_finish_once (void);"}, {"sha": "ac661623fc69a4fb7c5417c2a3f4313725578a8e", "filename": "gcc/target-globals.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -38,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"libfuncs.h\"\n #include \"cfgloop.h\"\n #include \"ira-int.h\"\n-#include \"lra-int.h\"\n #include \"builtins.h\"\n #include \"gcse.h\"\n #include \"bb-reorder.h\"\n@@ -59,7 +58,6 @@ struct target_globals default_target_globals = {\n   &default_target_cfgloop,\n   &default_target_ira,\n   &default_target_ira_int,\n-  &default_target_lra_int,\n   &default_target_builtins,\n   &default_target_gcse,\n   &default_target_bb_reorder,\n@@ -96,7 +94,6 @@ save_target_globals (void)\n   g->cfgloop = &p->cfgloop;\n   g->ira = ggc_internal_cleared_alloc (sizeof (struct target_ira));\n   g->ira_int = ggc_internal_cleared_alloc (sizeof (struct target_ira_int));\n-  g->lra_int = ggc_internal_cleared_alloc (sizeof (struct target_lra_int));\n   g->builtins = &p->builtins;\n   g->gcse = &p->gcse;\n   g->bb_reorder = &p->bb_reorder;"}, {"sha": "4e1a94807777bb5c2d4bb0700acc24bcc442537c", "filename": "gcc/target-globals.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3317563e01d865568dd8baa2986e0f4fa122a8/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=0c3317563e01d865568dd8baa2986e0f4fa122a8", "patch": "@@ -33,7 +33,6 @@ extern struct target_libfuncs *this_target_libfuncs;\n extern struct target_cfgloop *this_target_cfgloop;\n extern struct target_ira *this_target_ira;\n extern struct target_ira_int *this_target_ira_int;\n-extern struct target_lra_int *this_target_lra_int;\n extern struct target_builtins *this_target_builtins;\n extern struct target_gcse *this_target_gcse;\n extern struct target_bb_reorder *this_target_bb_reorder;\n@@ -53,7 +52,6 @@ struct GTY(()) target_globals {\n   struct target_cfgloop *GTY((skip)) cfgloop;\n   void *GTY((atomic)) ira;\n   void *GTY((atomic)) ira_int;\n-  void *GTY((atomic)) lra_int;\n   struct target_builtins *GTY((skip)) builtins;\n   struct target_gcse *GTY((skip)) gcse;\n   struct target_bb_reorder *GTY((skip)) bb_reorder;\n@@ -81,7 +79,6 @@ restore_target_globals (struct target_globals *g)\n   this_target_cfgloop = g->cfgloop;\n   this_target_ira = (struct target_ira *) g->ira;\n   this_target_ira_int = (struct target_ira_int *) g->ira_int;\n-  this_target_lra_int = (struct target_lra_int *) g->lra_int;\n   this_target_builtins = g->builtins;\n   this_target_gcse = g->gcse;\n   this_target_bb_reorder = g->bb_reorder;"}]}