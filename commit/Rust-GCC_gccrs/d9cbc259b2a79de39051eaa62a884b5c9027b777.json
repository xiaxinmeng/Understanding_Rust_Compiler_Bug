{"sha": "d9cbc259b2a79de39051eaa62a884b5c9027b777", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDljYmMyNTliMmE3OWRlMzkwNTFlYWE2MmE4ODRiNWM5MDI3Yjc3Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-05T23:23:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-05T23:23:22Z"}, "message": "(make_node, copy_node): Set TYPE_OBSTACK.\n\n(build_type_variant, build_type_copy, build_pointer_type): Put new node in\nsame obstack as old node; use push/pop obstacks.\n\nFrom-SVN: r5078", "tree": {"sha": "5bfd20350ccf1a09e6990137d693a4d7c4051b0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bfd20350ccf1a09e6990137d693a4d7c4051b0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9cbc259b2a79de39051eaa62a884b5c9027b777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9cbc259b2a79de39051eaa62a884b5c9027b777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9cbc259b2a79de39051eaa62a884b5c9027b777", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9cbc259b2a79de39051eaa62a884b5c9027b777/comments", "author": null, "committer": null, "parents": [{"sha": "b20e883e39f607b4b40058afad360fda1330f7b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20e883e39f607b4b40058afad360fda1330f7b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20e883e39f607b4b40058afad360fda1330f7b3"}], "stats": {"total": 36, "additions": 16, "deletions": 20}, "files": [{"sha": "b25bc70bc8fae4e282bc1698592c8a787c1f6824", "filename": "gcc/tree.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cbc259b2a79de39051eaa62a884b5c9027b777/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cbc259b2a79de39051eaa62a884b5c9027b777/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d9cbc259b2a79de39051eaa62a884b5c9027b777", "patch": "@@ -913,6 +913,7 @@ make_node (code)\n       TYPE_UID (t) = next_type_uid++;\n       TYPE_ALIGN (t) = 1;\n       TYPE_MAIN_VARIANT (t) = t;\n+      TYPE_OBSTACK (t) = obstack;\n       break;\n \n     case 'c':\n@@ -988,7 +989,10 @@ copy_node (node)\n   if (TREE_CODE_CLASS (code) == 'd')\n     DECL_UID (t) = next_decl_uid++;\n   else if (TREE_CODE_CLASS (code) == 't')\n-    TYPE_UID (t) = next_type_uid++;\n+    {\n+      TYPE_UID (t) = next_type_uid++;\n+      TYPE_OBSTACK (t) = current_obstack;\n+    }\n \n   TREE_PERMANENT (t) = (current_obstack == &permanent_obstack);\n \n@@ -2263,10 +2267,11 @@ build_type_variant (type, constp, volatilep)\n         return t;\n \n   /* We need a new one.  */\n-  current_obstack\n-    = TREE_PERMANENT (type) ? &permanent_obstack : saveable_obstack;\n \n+  current_obstack = TYPE_OBSTACK (type);\n   t = copy_node (type);\n+  current_obstack = ambient_obstack;\n+\n   TYPE_READONLY (t) = constp;\n   TYPE_VOLATILE (t) = volatilep;\n   TYPE_POINTER_TO (t) = 0;\n@@ -2276,7 +2281,6 @@ build_type_variant (type, constp, volatilep)\n   TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n   TYPE_NEXT_VARIANT (m) = t;\n \n-  current_obstack = ambient_obstack;\n   return t;\n }\n \n@@ -2318,18 +2322,17 @@ build_type_copy (type)\n   register tree t, m = TYPE_MAIN_VARIANT (type);\n   register struct obstack *ambient_obstack = current_obstack;\n \n-  current_obstack\n-    = TREE_PERMANENT (type) ? &permanent_obstack : saveable_obstack;\n-\n+  current_obstack = TYPE_OBSTACK (type);\n   t = copy_node (type);\n+  current_obstack = ambient_obstack;\n+\n   TYPE_POINTER_TO (t) = 0;\n   TYPE_REFERENCE_TO (t) = 0;\n \n   /* Add this type to the chain of variants of TYPE.  */\n   TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n   TYPE_NEXT_VARIANT (m) = t;\n \n-  current_obstack = ambient_obstack;\n   return t;\n }\n \f\n@@ -2676,34 +2679,27 @@ build_pointer_type (to_type)\n      tree to_type;\n {\n   register tree t = TYPE_POINTER_TO (to_type);\n-  register struct obstack *ambient_obstack = current_obstack;\n-  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n \n   /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n \n   if (t)\n     return t;\n \n-  /* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */\n-  if (TREE_PERMANENT (to_type))\n-    {\n-      current_obstack = &permanent_obstack;\n-      saveable_obstack = &permanent_obstack;\n-    }\n-\n+  /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n+  push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));\n   t = make_node (POINTER_TYPE);\n+  pop_obstacks ();\n+\n   TREE_TYPE (t) = to_type;\n \n   /* Record this type as the pointer to TO_TYPE.  */\n   TYPE_POINTER_TO (to_type) = t;\n \n   /* Lay out the type.  This function has many callers that are concerned\n      with expression-construction, and this simplifies them all.\n-     Also, it guarantees the TYPE_SIZE is permanent if the type is.  */\n+     Also, it guarantees the TYPE_SIZE is in the same obstack as the type.  */\n   layout_type (t);\n \n-  current_obstack = ambient_obstack;\n-  saveable_obstack = ambient_saveable_obstack;\n   return t;\n }\n "}]}