{"sha": "aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVkN2IyYTZlMjExZTAwMmFhN2JkYTFmNThmZTQyNjliZjdhNWZjYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-14T11:09:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-14T11:09:07Z"}, "message": "cp-tree.h (lang_type): Add has_non_private_static_mem_fn.\n\n\t* cp-tree.h (lang_type): Add has_non_private_static_mem_fn.\n\t(CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN): New macro, to access it.\n\t* class.c (maybe_class_too_private_p): New function.\n\t(finish_struct_methods): Use it.\n\t(finish_struct_1): Likewise.\n\t(finish_struct): Set CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN if\n\tappropriate.\n\nFrom-SVN: r22415", "tree": {"sha": "4ea788828d006d5d60d5cec38f41ff4e010f3703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ea788828d006d5d60d5cec38f41ff4e010f3703"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/comments", "author": null, "committer": null, "parents": [{"sha": "fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd4de5ff4abb75e0d9ccae7b920059bcc5f90486"}], "stats": {"total": 56, "additions": 44, "deletions": 12}, "files": [{"sha": "83c33cfd41013e09183955e50ab364242dc2919e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "patch": "@@ -100,6 +100,7 @@ static void modify_all_indirect_vtables PROTO((tree, int, int, tree,\n \t\t\t\t\t       tree, tree));\n static void build_class_init_list PROTO((tree));\n static int finish_base_struct PROTO((tree, struct base_info *));\n+static int maybe_class_too_private_p PROTO((tree));\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -1897,6 +1898,32 @@ grow_method (fndecl, method_vec_ptr)\n     }\n }\n \n+/* Returns non-zero if T is the sort of class for which we should\n+   check issue warnings like \"all constructors are private\".  */\n+\n+static int\n+maybe_class_too_private_p (t)\n+    tree t;\n+{\n+  if (!warn_ctor_dtor_privacy)\n+    /* The user doesn't want to here these warnings.  */\n+    return 0;\n+\n+  if (CLASSTYPE_FRIEND_CLASSES (t) \n+      || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))\n+    /* The class has friends.  Maybe they can make use of the class,\n+       even though it's very private.  */\n+    return 0;\n+\n+  if (CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN (t))\n+    /* The class has a non-private static member function.  Such a\n+       thing might be used, like a friend, to create instances of the\n+       class.  */\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Warn about duplicate methods in fn_fields.  Also compact method\n    lists so that lookup can be made faster.\n \n@@ -2023,9 +2050,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   obstack_finish (&class_obstack);\n   CLASSTYPE_METHOD_VEC (t) = method_vec;\n \n-  if (nonprivate_method == 0\n-      && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-      && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE)\n+  if (nonprivate_method == 0 && maybe_class_too_private_p (t))\n     {\n       tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n       for (i = 0; i < n_baseclasses; i++)\n@@ -2035,8 +2060,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t    nonprivate_method = 1;\n \t    break;\n \t  }\n-      if (nonprivate_method == 0 \n-\t  && warn_ctor_dtor_privacy)\n+      if (nonprivate_method == 0)\n \tcp_warning (\"all member functions in class `%T' are private\", t);\n     }\n \n@@ -2049,10 +2073,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n       /* Wild parse errors can cause this to happen.  */\n       if (dtor == NULL_TREE)\n \tTYPE_HAS_DESTRUCTOR (t) = 0;\n-      else if (TREE_PRIVATE (dtor)\n-\t       && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-\t       && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE\n-\t       && warn_ctor_dtor_privacy)\n+      else if (TREE_PRIVATE (dtor) && maybe_class_too_private_p (t))\n \tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n \t\t    t);\n     }\n@@ -3629,7 +3650,7 @@ finish_struct_1 (t, warn_anon)\n \t\tbreak;\n \t      }\n \n-\t  if (nonprivate_ctor == 0 && warn_ctor_dtor_privacy)\n+\t  if (nonprivate_ctor == 0 && maybe_class_too_private_p (t))\n \t    cp_warning (\"`%#T' only defines private constructors and has no friends\",\n \t\t\tt);\n \t}\n@@ -4208,6 +4229,12 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t  TREE_PRIVATE (x) = access == access_private_node;\n \t  TREE_PROTECTED (x) = access == access_protected_node;\n \n+\t  if (!TREE_PRIVATE (x) \n+\t      && TREE_CODE (x) == FUNCTION_DECL \n+\t      && DECL_LANG_SPECIFIC (x)\n+\t      && DECL_STATIC_FUNCTION_P (x))\n+\t    CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN (t) = 1;\n+\n \t  if (TREE_CODE (x) == TEMPLATE_DECL)\n \t    {\n \t      TREE_PRIVATE (DECL_RESULT (x)) = TREE_PRIVATE (x);"}, {"sha": "b58c06e9165373f1b8e5af08311346d920008d27", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "patch": "@@ -621,11 +621,12 @@ struct lang_type\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n+      unsigned has_non_private_static_mem_fn : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 11;\n+      unsigned dummy : 10;\n     } type_flags;\n \n   int n_ancestors;\n@@ -1451,6 +1452,10 @@ extern int flag_new_for_scope;\n #define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n   (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n+/* Nonzero if NODE has a non-private static member function.  */\n+#define CLASSTYPE_HAS_NON_PRIVATE_STATIC_MEM_FN(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->type_flags.has_non_private_static_mem_fn)\n+\n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n #define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assign_ref)\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_assign_ref)"}, {"sha": "c2c481075fffbf038952ffac28b64fedf723d6f4", "filename": "gcc/testsuite/g++.old-deja/g++.other/singleton.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsingleton.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsingleton.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fsingleton.C?ref=aed7b2a6e211e002aa7bda1f58fe4269bf7a5fcc", "patch": "@@ -24,7 +24,7 @@ private:\n        void operator=( const singleton& rhs );\n        int initialized;\n        static int counter;\n-};  // gets bogus error - class is not useless XFAIL *-*-*\n+};  \n \n int singleton::counter;\n "}]}