{"sha": "c0bbf652c53cf976d4318b2228fb96148b16b8ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBiYmY2NTJjNTNjZjk3NmQ0MzE4YjIyMjhmYjk2MTQ4YjE2YjhhZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-29T03:59:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-29T03:59:09Z"}, "message": "cp-tree.def (THUNK_DECL): Discuss vcall indices.\n\n\t* cp-tree.def (THUNK_DECL): Discuss vcall indices.\n\t* cp-tree.h (BINFO_VIRTUALS): Update documentation.\n\t(BF_DELTA): New macro.\n\t(BF_VCALL_INDEX): Likewise.\n\t(BF_FN): Likewise.\n\t(THUNK_VCALL_OFFSET): Likewise.\n\t(make_thunk): Change prototype.\n\t* class.c (build_vtable_entry): Integrate\n\tbuild_vtable_entry_for_fn.  Handle vcall indices.\n\t(build_vtable_entry_for_fn): Remove.\n\t(set_rtti_entry): Handle vcall indices.  Use BF_DELTA,\n\tBF_VCALL_INDEX, BF_FN.\n\t(modify_vtable_entry): Integrate common code from\n\tmodify_one_vtable and dfs_fixup_vtable_deltas.\n\t(add_virtual_function): Set BF_VCALL_INDEX.\n\t(build_vtbl_initializer): Simplify.  Use BF_DELTA, BF_VCALL_INDEX,\n\tand BF_FN.\n\t(modify_one_vtable): Simplify.\n\t(dfs_fixup_vtable_deltas): Likewise.\n\t(override_one_vtable): Use BF_DELTA, BF_VCALL_INDEX, BF_FN.\n\t* method.c (make_thunk): Handle vcall indices.\n\nFrom-SVN: r31684", "tree": {"sha": "3e1741ec7085c29d211f549e709d89cdd7289c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e1741ec7085c29d211f549e709d89cdd7289c08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0bbf652c53cf976d4318b2228fb96148b16b8ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bbf652c53cf976d4318b2228fb96148b16b8ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0bbf652c53cf976d4318b2228fb96148b16b8ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bbf652c53cf976d4318b2228fb96148b16b8ae/comments", "author": null, "committer": null, "parents": [{"sha": "4fda2521e9a1b2062c07df7f26c8b49adf036833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fda2521e9a1b2062c07df7f26c8b49adf036833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fda2521e9a1b2062c07df7f26c8b49adf036833"}], "stats": {"total": 403, "additions": 209, "deletions": 194}, "files": [{"sha": "b742854e73fe71f079b8f9d3b48ca3f674385de4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c0bbf652c53cf976d4318b2228fb96148b16b8ae", "patch": "@@ -1,3 +1,27 @@\n+2000-01-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (THUNK_DECL): Discuss vcall indices.\n+\t* cp-tree.h (BINFO_VIRTUALS): Update documentation.\n+\t(BF_DELTA): New macro.\n+\t(BF_VCALL_INDEX): Likewise.\n+\t(BF_FN): Likewise.\n+\t(THUNK_VCALL_OFFSET): Likewise.\n+\t(make_thunk): Change prototype.\n+\t* class.c (build_vtable_entry): Integrate\n+\tbuild_vtable_entry_for_fn.  Handle vcall indices.\n+\t(build_vtable_entry_for_fn): Remove.\n+\t(set_rtti_entry): Handle vcall indices.  Use BF_DELTA,\n+\tBF_VCALL_INDEX, BF_FN.\n+\t(modify_vtable_entry): Integrate common code from\n+\tmodify_one_vtable and dfs_fixup_vtable_deltas.\n+\t(add_virtual_function): Set BF_VCALL_INDEX.\n+\t(build_vtbl_initializer): Simplify.  Use BF_DELTA, BF_VCALL_INDEX,\n+\tand BF_FN.\n+\t(modify_one_vtable): Simplify.\n+\t(dfs_fixup_vtable_deltas): Likewise.\n+\t(override_one_vtable): Use BF_DELTA, BF_VCALL_INDEX, BF_FN. \n+\t* method.c (make_thunk): Handle vcall indices.\n+\t\n 2000-01-28  Nathan Sidwell  <sidwell@codesourcery.com>\n \n \tCompiler side new abi rtti (not enabled)."}, {"sha": "416f2b7cafd8ee87f93a5feaa7f874ca3585a1f2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 132, "deletions": 182, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c0bbf652c53cf976d4318b2228fb96148b16b8ae", "patch": "@@ -75,7 +75,7 @@ static class_stack_node_t current_class_stack;\n static tree get_vfield_name PARAMS ((tree));\n static void finish_struct_anon PARAMS ((tree));\n static tree build_vbase_pointer PARAMS ((tree, tree));\n-static tree build_vtable_entry PARAMS ((tree, tree));\n+static tree build_vtable_entry PARAMS ((tree, tree, tree));\n static tree get_vtable_name PARAMS ((tree));\n static tree get_derived_offset PARAMS ((tree, tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n@@ -85,8 +85,7 @@ static void prepare_fresh_vtable PARAMS ((tree, tree));\n static tree dfs_fixup_vtable_deltas PARAMS ((tree, void *));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n static void finish_vtbls PARAMS ((tree));\n-static void modify_vtable_entry PARAMS ((tree, tree, tree));\n-static tree get_vtable_entry_n PARAMS ((tree, unsigned HOST_WIDE_INT));\n+static void modify_vtable_entry PARAMS ((tree, tree, tree, tree));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n static void delete_duplicate_fields PARAMS ((tree));\n@@ -114,7 +113,6 @@ static tree fixed_type_or_null PARAMS ((tree, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n \t\t\t\t\t\t\t  int, tree));\n static void build_vtable_entry_ref PARAMS ((tree, tree, tree));\n-static tree build_vtable_entry_for_fn PARAMS ((tree, tree));\n static tree build_vtbl_initializer PARAMS ((tree, tree));\n static int count_fields PARAMS ((tree));\n static int add_fields_to_vec PARAMS ((tree, tree, int));\n@@ -683,23 +681,37 @@ build_vbase_path (code, type, expr, path, nonnull)\n \f\n /* Virtual function things.  */\n \n-/* Build an entry in the virtual function table.\n-   DELTA is the offset for the `this' pointer.\n-   PFN is an ADDR_EXPR containing a pointer to the virtual function.\n-   Note that the index (DELTA2) in the virtual function table\n-   is always 0.  */\n+/* Build an entry in the virtual function table.  DELTA is the offset\n+   for the `this' pointer.  VCALL_INDEX is the vtable index containing\n+   the vcall offset; zero if none.  FNDECL is the virtual function\n+   itself.  */\n \n static tree\n-build_vtable_entry (delta, pfn)\n-     tree delta, pfn;\n+build_vtable_entry (delta, vcall_index, fndecl)\n+     tree delta;\n+     tree vcall_index;\n+     tree fndecl;\n {\n+  tree pfn;\n+\n+  /* Take the address of the function, considering it to be of an\n+     appropriate generic type.  */\n+  pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n+  /* The address of a function can't change.  */\n+  TREE_CONSTANT (pfn) = 1;\n+\n   if (flag_vtable_thunks)\n     {\n-      HOST_WIDE_INT idelta = TREE_INT_CST_LOW (delta);\n-      if (idelta && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (pfn, 0)))\n+      HOST_WIDE_INT idelta;\n+      HOST_WIDE_INT ivindex;\n+\n+      idelta = TREE_INT_CST_LOW (delta);\n+      ivindex = TREE_INT_CST_LOW (vcall_index);\n+      if ((idelta || ivindex) \n+\t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (pfn, 0)))\n \t{\n-\t  pfn = build1 (ADDR_EXPR, vtable_entry_type,\n-\t\t\tmake_thunk (pfn, idelta));\n+\t  pfn = make_thunk (pfn, idelta, ivindex);\n+\t  pfn = build1 (ADDR_EXPR, vtable_entry_type, pfn);\n \t  TREE_READONLY (pfn) = 1;\n \t  TREE_CONSTANT (pfn) = 1;\n \t}\n@@ -716,6 +728,9 @@ build_vtable_entry (delta, pfn)\n \t\t\t\t\t build_tree_list (NULL_TREE, pfn)));\n       tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n+      /* We don't use vcall offsets when not using vtable thunks.  */\n+      my_friendly_assert (integer_zerop (vcall_index), 20000125);\n+\n       /* DELTA used to be constructed by `size_int' and/or size_binop,\n \t which caused overflow problems when it was negative.  That should\n \t be fixed now.  */\n@@ -740,25 +755,6 @@ build_vtable_entry (delta, pfn)\n     }\n }\n \n-/* Build a vtable entry for FNDECL.  DELTA is the amount by which we\n-   must adjust the this pointer when calling F.  */\n-\n-static tree\n-build_vtable_entry_for_fn (delta, fndecl)\n-     tree delta;\n-     tree fndecl;\n-{\n-  tree pfn;\n-\n-  /* Take the address of the function, considering it to be of an\n-     appropriate generic type.  */\n-  pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n-  /* The address of a function can't change.  */\n-  TREE_CONSTANT (pfn) = 1;\n-  /* Now build the vtable entry itself.  */\n-  return build_vtable_entry (delta, pfn);\n-}\n-\n /* We want to give the assembler the vtable identifier as well as\n    the offset to the function pointer.  So we generate\n \n@@ -984,16 +980,18 @@ set_rtti_entry (virtuals, offset, type)\n   if (flag_vtable_thunks)\n     {\n       /* The first slot holds the offset.  */\n-      TREE_PURPOSE (virtuals) = offset;\n+      BF_DELTA (virtuals) = offset;\n+      BF_VCALL_INDEX (virtuals) = integer_zero_node;\n \n       /* The next node holds the decl.  */\n       virtuals = TREE_CHAIN (virtuals);\n       offset = integer_zero_node;\n     }\n \n-  /* This slot holds the decl.  */\n-  TREE_PURPOSE (virtuals) = offset;\n-  TREE_VALUE (virtuals) = decl;\n+  /* This slot holds the function to call.  */\n+  BF_DELTA (virtuals) = offset;\n+  BF_VCALL_INDEX (virtuals) = integer_zero_node;\n+  BF_FN (virtuals) = decl;\n }\n \n /* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,\n@@ -1263,42 +1261,71 @@ prepare_fresh_vtable (binfo, for_type)\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n }\n \n-/* Change the offset for the FNDECL entry to NEW_OFFSET.  Also update\n-   DECL_VINDEX (FNDECL).  */\n+/* Make V, an entry on the BINFO_VIRTUALS list for BINFO (which is in\n+   the hierarchy dominated by T) list FNDECL as its BF_FN.  */\n \n static void\n-modify_vtable_entry (old_entry_in_list, new_offset, fndecl)\n-     tree old_entry_in_list, new_offset, fndecl;\n+modify_vtable_entry (t, binfo, fndecl, v)\n+     tree t;\n+     tree binfo;\n+     tree fndecl;\n+     tree v;\n {\n-  tree base_fndecl = TREE_VALUE (old_entry_in_list);\n-\n-  /* Update the entry.  */\n-  TREE_PURPOSE (old_entry_in_list) = new_offset;\n-  TREE_VALUE (old_entry_in_list) = fndecl;\n-\n-  /* Now assign virtual dispatch information, if unset.  We can\n-     dispatch this, through any overridden base function.  */\n-  if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n-    {\n-      DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n-      DECL_VIRTUAL_CONTEXT (fndecl) = DECL_VIRTUAL_CONTEXT (base_fndecl);\n-    }\n-}\n+  tree base_offset, offset;\n+  tree context = DECL_CLASS_CONTEXT (fndecl);\n+  tree vfield = TYPE_VFIELD (t);\n+  tree this_offset;\n+  tree vcall_index;\n+\n+  offset = get_class_offset (context, t, binfo, fndecl);\n+\n+  /* Find the right offset for ythe this pointer based on the\n+     base class we just found.  We have to take into\n+     consideration the virtual base class pointers that we\n+     stick in before the virtual function table pointer.\n+\n+     Also, we want just the delta between the most base class\n+     that we derived this vfield from and us.  */\n+  base_offset \n+    = size_binop (PLUS_EXPR,\n+\t\t  get_derived_offset (binfo, \n+\t\t\t\t      DECL_VIRTUAL_CONTEXT (BF_FN (v))),\n+\t\t  BINFO_OFFSET (binfo));\n+  this_offset = ssize_binop (MINUS_EXPR, offset, base_offset);\n+  vcall_index = integer_zero_node;\n+\n+  if (fndecl != BF_FN (v)\n+      || !tree_int_cst_equal (this_offset, BF_DELTA (v))\n+      || !tree_int_cst_equal (vcall_index, BF_VCALL_INDEX (v)))\n+    {\n+      tree base_fndecl;\n+\n+      /* Make sure we can modify the derived association with immunity.  */\n+      if (binfo == TYPE_BINFO (t))\n+\t/* In this case, it is *type*'s vtable we are modifying.  We\n+\t   start with the approximation that it's vtable is that of\n+\t   the immediate base class.  */\n+\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n+      else\n+\t/* This is our very own copy of `basetype' to play with.\n+\t   Later, we will fill in all the virtual functions that\n+\t   override the virtual functions in these base classes which\n+\t   are not defined by the current type.  */\n+\tprepare_fresh_vtable (binfo, t);\n \n-/* Access the virtual function table entry N.  VIRTUALS is the virtual\n-   function table's initializer.  */\n+      base_fndecl = BF_FN (v);\n+      BF_DELTA (v) = this_offset;\n+      BF_VCALL_INDEX (v) = vcall_index;\n+      BF_FN (v) = fndecl;\n \n-static tree\n-get_vtable_entry_n (virtuals, n)\n-     tree virtuals;\n-     unsigned HOST_WIDE_INT n;\n-{\n-  while (n > 0)\n-    {\n-      --n;\n-      virtuals = TREE_CHAIN (virtuals);\n+      /* Now assign virtual dispatch information, if unset.  We can\n+\t dispatch this, through any overridden base function.  */\n+      if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n+\t{\n+\t  DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n+\t  DECL_VIRTUAL_CONTEXT (fndecl) = DECL_VIRTUAL_CONTEXT (base_fndecl);\n+\t}\n     }\n-  return virtuals;\n }\n \n /* Call this function whenever its known that a vtable for T is going\n@@ -1340,14 +1367,20 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n      tree fndecl;\n      tree t; /* Structure type.  */\n {\n+  tree new_virtual;\n+\n   /* If this function doesn't override anything from a base class, we\n      can just assign it a new DECL_VINDEX now.  Otherwise, if it does\n      override something, we keep it around and assign its DECL_VINDEX\n      later, in modify_all_vtables.  */\n   if (TREE_CODE (DECL_VINDEX (fndecl)) == INTEGER_CST)\n     /* We've already dealt with this function.  */\n-    ;\n-  else if (DECL_VINDEX (fndecl) == error_mark_node)\n+    return;\n+\n+  new_virtual = build_tree_list (integer_zero_node, fndecl);\n+  BF_VCALL_INDEX (new_virtual) = integer_zero_node;\n+\n+  if (DECL_VINDEX (fndecl) == error_mark_node)\n     {\n       /* FNDECL is a new virtual function; it doesn't override any\n \t virtual function in a base class.  */\n@@ -1362,15 +1395,15 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n       DECL_VIRTUAL_CONTEXT (fndecl) = t;\n \n       /* Save the state we've computed on the NEW_VIRTUALS list.  */\n-      *new_virtuals_p = tree_cons (integer_zero_node,\n-\t\t\t\t   fndecl,\n-\t\t\t\t   *new_virtuals_p);\n-    }\n-  else if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n-    /* FNDECL overrides a function from a base class.  */\n-    *overridden_virtuals_p = tree_cons (NULL_TREE, \n-\t\t\t\t\tfndecl, \n-\t\t\t\t\t*overridden_virtuals_p);\n+      TREE_CHAIN (new_virtual) = *new_virtuals_p;\n+      *new_virtuals_p = new_virtual;\n+    }\n+  else\n+    {\n+      /* FNDECL overrides a function from a base class.  */\n+      TREE_CHAIN (new_virtual) = *overridden_virtuals_p;\n+      *overridden_virtuals_p = new_virtual;\n+    }\n }\n \f\n extern struct obstack *current_obstack;\n@@ -2615,7 +2648,6 @@ build_vtbl_initializer (binfo, t)\n \t we can put it in the vtable.  */\n       init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n       TREE_CONSTANT (init) = 1;\n-      init = build_vtable_entry (integer_zero_node, init);\n       inits = tree_cons (NULL_TREE, init, inits);\n \n       v = TREE_CHAIN (v);\n@@ -2645,13 +2677,15 @@ build_vtbl_initializer (binfo, t)\n   while (v)\n     {\n       tree delta;\n+      tree vcall_index;\n       tree fn;\n       tree init;\n \n       /* Pull the offset for `this', and the function to call, out of\n \t the list.  */\n-      delta = TREE_PURPOSE (v);\n-      fn = TREE_VALUE (v);\n+      delta = BF_DELTA (v);\n+      vcall_index = BF_VCALL_INDEX (v);\n+      fn = BF_FN (v);\n       my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n       my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n \n@@ -2661,7 +2695,7 @@ build_vtbl_initializer (binfo, t)\n \tfn = abort_fndecl;\n \n       /* Package up that information for the vtable.  */\n-      init = build_vtable_entry_for_fn (delta, fn);\n+      init = build_vtable_entry (delta, vcall_index, fn);\n       /* And add it to the chain of initializers.  */\n       inits = tree_cons (NULL_TREE, init, inits);\n \n@@ -2928,11 +2962,11 @@ modify_one_vtable (binfo, t, fndecl)\n   if (fndecl == NULL_TREE)\n     return;\n \n-  virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n-\n-  while (virtuals)\n+  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n+       virtuals;\n+       virtuals = TREE_CHAIN (virtuals), ++n)\n     {\n-      tree current_fndecl = TREE_VALUE (virtuals);\n+      tree current_fndecl = BF_FN (virtuals);\n \n       /* We should never have an instance of __pure_virtual on the\n \t BINFO_VIRTUALS list.  If we do, then we will never notice\n@@ -2942,47 +2976,7 @@ modify_one_vtable (binfo, t, fndecl)\n \t\t\t  19990727);\n \n       if (current_fndecl && overrides (fndecl, current_fndecl))\n-\t{\n-\t  tree base_offset, offset;\n-\t  tree context = DECL_CLASS_CONTEXT (fndecl);\n-\t  tree vfield = TYPE_VFIELD (t);\n-\t  tree this_offset;\n-\n-\t  offset = get_class_offset (context, t, binfo, fndecl);\n-\n-\t  /* Find the right offset for the this pointer based on the\n-\t     base class we just found.  We have to take into\n-\t     consideration the virtual base class pointers that we\n-\t     stick in before the virtual function table pointer.\n-\n-\t     Also, we want just the delta between the most base class\n-\t     that we derived this vfield from and us.  */\n-\t  base_offset = size_binop (PLUS_EXPR,\n-\t\t\t\t    get_derived_offset (binfo, DECL_CONTEXT (current_fndecl)),\n-\t\t\t\t    BINFO_OFFSET (binfo));\n-\t  this_offset = ssize_binop (MINUS_EXPR, offset, base_offset);\n-\n-\t  if (binfo == TYPE_BINFO (t))\n-\t    /* In this case, it is *type*'s vtable we are modifying.\n-\t       We start with the approximation that it's vtable is\n-\t       that of the immediate base class.  */\n-\t      build_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-\t  else\n-\t    /* This is our very own copy of `basetype' to play with.\n-\t       Later, we will fill in all the virtual functions that\n-\t       override the virtual functions in these base classes\n-\t       which are not defined by the current type.  */\n-\t    prepare_fresh_vtable (binfo, t);\n-\n-#ifdef NOTQUITE\n-\t  cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n-#endif\n-\t  modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n-\t\t\t       this_offset,\n-\t\t\t       fndecl);\n-\t}\n-      ++n;\n-      virtuals = TREE_CHAIN (virtuals);\n+\tmodify_vtable_entry (t, binfo, fndecl, virtuals);\n     }\n }\n \n@@ -3104,58 +3098,14 @@ dfs_fixup_vtable_deltas (binfo, data)\n \treturn NULL_TREE;\n     }\n \n-  virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n-\n-  while (virtuals)\n+  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n+       virtuals;\n+       virtuals = TREE_CHAIN (virtuals), ++n)\n     {\n-      tree fndecl = TREE_VALUE (virtuals);\n-      tree delta = TREE_PURPOSE (virtuals);\n+      tree fndecl = BF_FN (virtuals);\n \n       if (fndecl)\n-\t{\n-\t  tree base_offset, offset;\n-\t  tree context = DECL_CLASS_CONTEXT (fndecl);\n-\t  tree vfield = TYPE_VFIELD (t);\n-\t  tree this_offset;\n-\n-\t  offset = get_class_offset (context, t, binfo, fndecl);\n-\n-\t  /* Find the right offset for the this pointer based on the\n-\t     base class we just found.  We have to take into\n-\t     consideration the virtual base class pointers that we\n-\t     stick in before the virtual function table pointer.\n-\n-\t     Also, we want just the delta between the most base class\n-\t     that we derived this vfield from and us.  */\n-\t  base_offset = size_binop (PLUS_EXPR,\n-\t\t\t\t    get_derived_offset (binfo,\n-\t\t\t\t\t\t\tDECL_CONTEXT (fndecl)),\n-\t\t\t\t    BINFO_OFFSET (binfo));\n-\t  this_offset = ssize_binop (MINUS_EXPR, offset, base_offset);\n-\n-\t  if (! tree_int_cst_equal (this_offset, delta))\n-\t    {\n-\t      /* Make sure we can modify the derived association with immunity.  */\n-\t      if (binfo == TYPE_BINFO (t))\n-\t\t/* In this case, it is *type*'s vtable we are modifying.\n-\t\t   We start with the approximation that it's vtable is that\n-\t\t   of the immediate base class.  */\n-\t\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-\t      else\n-\t\t/* This is our very own copy of `basetype' to play\n-\t\t   with.  Later, we will fill in all the virtual\n-\t\t   functions that override the virtual functions in\n-\t\t   these base classes which are not defined by the\n-\t\t   current type.  */\n-\t\tprepare_fresh_vtable (binfo, t);\n-\n-\t      modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n-\t\t\t\t   this_offset,\n-\t\t\t\t   fndecl);\n-\t    }\n-\t}\n-      ++n;\n-      virtuals = TREE_CHAIN (virtuals);\n+\tmodify_vtable_entry (t, binfo, fndecl, virtuals);\n     }\n \n   return NULL_TREE;\n@@ -3226,8 +3176,8 @@ override_one_vtable (binfo, old, t)\n \n   while (orig_virtuals)\n     {\n-      tree fndecl = TREE_VALUE (virtuals);\n-      tree old_fndecl = TREE_VALUE (old_virtuals);\n+      tree fndecl = BF_FN (virtuals);\n+      tree old_fndecl = BF_FN (old_virtuals);\n \n       /* First check to see if they are the same.  */\n       if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (old_fndecl))\n@@ -3280,7 +3230,7 @@ override_one_vtable (binfo, old, t)\n \t    }\n \t  {\n \t    /* This MUST be overridden, or the class is ill-formed.  */\n-\t    tree fndecl = TREE_VALUE (virtuals);\n+\t    tree fndecl = BF_FN (virtuals);\n \n \t    fndecl = copy_node (fndecl);\n \t    copy_lang_decl (fndecl);\n@@ -3291,8 +3241,8 @@ override_one_vtable (binfo, old, t)\n \n \t    /* We can use integer_zero_node, as we will core dump\n \t       if this is used anyway.  */\n-\t    TREE_PURPOSE (virtuals) = integer_zero_node;\n-\t    TREE_VALUE (virtuals) = fndecl;\n+\t    BF_DELTA (virtuals) = integer_zero_node;\n+\t    BF_FN (virtuals) = fndecl;\n \t  }\n \t}\n       virtuals = TREE_CHAIN (virtuals);"}, {"sha": "a57742ce7896418673b739f2182f2c3c1d07b9b8", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=c0bbf652c53cf976d4318b2228fb96148b16b8ae", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the\n    additional tree codes used in the GNU C++ compiler (see tree.def\n    for the standard codes).\n-   Copyright (C) 1987,88,90,93,97-8,1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987,88,90,93,97-8,1999, 2000 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -159,12 +159,22 @@ DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", 't', 0)\n \n /* A thunk is a stub function.\n \n-   Thunks are used to implement multiple inheritance:\n-   At run-time, such a thunk subtracts THUNK_DELTA (an int, not a tree)\n-   from the this pointer, and then jumps to DECL_INITIAL\n-   (which is an ADDR_EXPR whose operand is a FUNCTION_DECL).\n+   A THUNK_DECL is an alternate entry point for an ordinary\n+   FUNCTION_DECL.  It's job is to adjust the `this' poitner before\n+   transferring control to the FUNCTION_DECL.\n \n-   Other kinds of thunks may be defined later. */\n+   A thunk may perform either, or both, of the following operations:\n+\n+   o Adjust the `this' pointer by a constant offset.\n+   o Adjust the `this' pointer by looking up a vcall-offset\n+     in the vtable.\n+\n+   If both operations are performed, then the constant adjument to\n+   `this' is performed first.\n+\n+   The constant adjustment is given by THUNK_DELTA.  If the\n+   vcall-offset is required, the index into the vtable is given by\n+   THUNK_VCALL_OFFSET.  */\n DEFTREECODE (THUNK_DECL, \"thunk_decl\", 'd', 0)\n \n /* A using declaration.  DECL_INITIAL contains the specified scope.  "}, {"sha": "d7aabbefc6af8dfc596d68fab4f427f505d283f8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c0bbf652c53cf976d4318b2228fb96148b16b8ae", "patch": "@@ -115,15 +115,18 @@ Boston, MA 02111-1307, USA.  */\n      For a static VAR_DECL, this is DECL_INIT_PRIORITY.\n \n    BINFO_VIRTUALS\n-     For a binfo, this is a TREE_LIST.  The TREE_PURPOSE of each node\n+     For a binfo, this is a TREE_LIST.  The BF_DELTA of each node\n      gives the amount by which to adjust the `this' pointer when\n      calling the function.  If the method is an overriden version of a\n      base class method, then it is assumed that, prior to adjustment,\n      the this pointer points to an object of the base class.\n \n-     The TREE_VALUE is the declaration for the virtual function\n-     itself.  When CLASSTYPE_COM_INTERFACE_P does not hold, the first\n-     entry does not have a TREE_VALUE; it is just an offset.\n+     The BF_VCALL_INDEX of each node, if non-NULL, gives the vtable\n+     index of the vcall offset for this entry.\n+\n+     The BF_FN is the declaration for the virtual function itself.\n+     When CLASSTYPE_COM_INTERFACE_P does not hold, the first entry\n+     does not have a BF_FN; it is just an offset.\n \n    DECL_ARGUMENTS\n      For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  \n@@ -1720,6 +1723,18 @@ struct lang_type\n \n /* Get the value of the top-most type dominating the non-`normal' vfields.  */\n #define VF_DERIVED_VALUE(NODE) (VF_BINFO_VALUE (NODE) ? BINFO_TYPE (VF_BINFO_VALUE (NODE)) : NULL_TREE)\n+\n+/* The number of bytes by which to adjust the `this' pointer when\n+   calling this virtual function.  */\n+#define BF_DELTA(NODE) (TREE_PURPOSE (NODE))\n+\n+/* If non-NULL, the vtable index at which to find the vcall offset\n+   when calling this virtual function.  */\n+#define BF_VCALL_INDEX(NODE) (TREE_TYPE (NODE))\n+\n+/* The function to call.  */\n+#define BF_FN(NODE) (TREE_VALUE (NODE))\n+\n \f\n /* Nonzero for TREE_LIST node means that this list of things\n    is a list of parameters, as opposed to a list of expressions.  */\n@@ -2789,8 +2804,16 @@ extern int flag_new_for_scope;\n #define DECL_REALLY_EXTERN(NODE) \\\n   (DECL_EXTERNAL (NODE) && ! DECL_NOT_REALLY_EXTERN (NODE))\n \n+/* An integer indicating how many bytes should be subtracted from the\n+   `this' pointer when this function is called.  */\n #define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.i)\n \n+/* An integer indicating how many bytes should be subtracted from the\n+   vtable for the `this' pointer to find the vcall offset.  (The vptr\n+   is always located at offset zero from the `this' pointer.)  If\n+   zero, then there is no vcall offset.  */\n+#define THUNK_VCALL_OFFSET(DECL) (DECL_FIELD_SIZE (DECL))\n+\n /* DECL_NEEDED_P holds of a declaration when we need to emit its\n    definition.  This is true when the back-end tells us that\n    the symbol has been referenced in the generated code.  If, however,\n@@ -3918,7 +3941,7 @@ extern tree build_overload_with_type\t\tPARAMS ((tree, tree));\n extern tree build_destructor_name\t\tPARAMS ((tree));\n extern tree build_opfncall\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPARAMS ((tree, tree));\n-extern tree make_thunk\t\t\t\tPARAMS ((tree, int));\n+extern tree make_thunk\t\t\t\tPROTO((tree, int, int));\n extern void emit_thunk\t\t\t\tPARAMS ((tree));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n extern tree get_id_2\t\t\t\tPARAMS ((const char *, tree));"}, {"sha": "406a156cce418710348d69f71d1931e42d38abfa", "filename": "gcc/cp/method.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bbf652c53cf976d4318b2228fb96148b16b8ae/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c0bbf652c53cf976d4318b2228fb96148b16b8ae", "patch": "@@ -2008,9 +2008,10 @@ hack_identifier (value, name)\n \n \f\n tree\n-make_thunk (function, delta)\n+make_thunk (function, delta, vcall_index)\n      tree function;\n      int delta;\n+     int vcall_index;\n {\n   tree thunk_id;\n   tree thunk;\n@@ -2033,6 +2034,11 @@ make_thunk (function, delta)\n     icat (-delta);\n   OB_PUTC ('_');\n   OB_PUTID (DECL_ASSEMBLER_NAME (func_decl));\n+  if (vcall_index)\n+    {\n+      OB_PUTC ('_');\n+      icat (vcall_index);\n+    }\n   OB_FINISH ();\n   thunk_id = get_identifier (obstack_base (&scratch_obstack));\n \n@@ -2052,6 +2058,8 @@ make_thunk (function, delta)\n       TREE_SET_CODE (thunk, THUNK_DECL);\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n+      THUNK_VCALL_OFFSET (thunk) \n+\t= vcall_index * TREE_INT_CST_LOW (TYPE_SIZE (vtable_entry_type));\n       DECL_EXTERNAL (thunk) = 1;\n       DECL_ARTIFICIAL (thunk) = 1;\n       /* So that finish_file can write out any thunks that need to be: */"}]}