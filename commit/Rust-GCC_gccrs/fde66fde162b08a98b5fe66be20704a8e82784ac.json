{"sha": "fde66fde162b08a98b5fe66be20704a8e82784ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRlNjZmZGUxNjJiMDhhOThiNWZlNjZiZTIwNzA0YThlODI3ODRhYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-12-06T11:31:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-12-06T11:31:56Z"}, "message": "re PR target/59316 (gcc.dg/atomic/c11-atomic-exec-5.c FAILs on Solaris/SPARC)\n\n\tPR target/59316\n\t* config/sparc/sparc.h (SPARC_LOW_FE_EXCEPT_VALUES): Define.\n\t* config/sparc/sol2.h (SPARC_LOW_FE_EXCEPT_VALUES): Redefine.\n\t* config/sparc/sparc.c (TARGET_INIT_BUILTINS): Move around.\n\t(TARGET_BUILTIN_DECL): Define.\n\t(TARGET_ATOMIC_ASSIGN_EXPAND_FENV): Likewise.\n\t(sparc32_initialize_trampoline): Adjust call to gen_flush.\n\t(enum sparc_builtins): New enumeral type.\n\t(sparc_builtins): New static array.\n\t(sparc_builtins_icode): Likewise.\n\t(def_builtin): Accept a separate icode and save the result.\n\t(def_builtin_const): Likewise.\n\t(sparc_fpu_init_builtins): New function.\n\t(sparc_vis_init_builtins): Pass the builtin code.\n\t(sparc_init_builtins): Call it if TARGET_FPU.\n\t(sparc_builtin_decl): New function.\n\t(sparc_expand_builtin): Deal with SPARC_BUILTIN_{LD,ST}FSR.\n\t(sparc_handle_vis_mul8x16): Use the builtin code.\n\t(sparc_fold_builtin): Likewise.  Deal with SPARC_BUILTIN_{LD,ST}FSR\n\tand SPARC_BUILTIN_PDISTN.\n\t(compound_expr): New helper function.\n\t(sparc_atomic_assign_expand_fenv): New function.\n\t* config/sparc/sparc.md (unspecv): Reorder values, add UNSPECV_LDFSR\n\tand UNSPECV_STFSR.\n\t(flush, flushdi): Merge into single pattern.\n\t(ldfsr): New instruction.\n\t(stfsr): Likewise.\n\nFrom-SVN: r205735", "tree": {"sha": "696751ad82b90968d6718287d90a84b3fe9b59ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/696751ad82b90968d6718287d90a84b3fe9b59ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fde66fde162b08a98b5fe66be20704a8e82784ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde66fde162b08a98b5fe66be20704a8e82784ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fde66fde162b08a98b5fe66be20704a8e82784ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde66fde162b08a98b5fe66be20704a8e82784ac/comments", "author": null, "committer": null, "parents": [{"sha": "2c8326a568110fcecb88677b521ef4e3ba4effe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8326a568110fcecb88677b521ef4e3ba4effe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8326a568110fcecb88677b521ef4e3ba4effe9"}], "stats": {"total": 810, "additions": 581, "deletions": 229}, "files": [{"sha": "662fae31cf20f29e6daa64067344660f6a94ca51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -1,3 +1,33 @@\n+2013-12-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/59316\n+\t* config/sparc/sparc.h (SPARC_LOW_FE_EXCEPT_VALUES): Define.\n+\t* config/sparc/sol2.h (SPARC_LOW_FE_EXCEPT_VALUES): Redefine.\n+\t* config/sparc/sparc.c (TARGET_INIT_BUILTINS): Move around.\n+\t(TARGET_BUILTIN_DECL): Define.\n+\t(TARGET_ATOMIC_ASSIGN_EXPAND_FENV): Likewise.\n+\t(sparc32_initialize_trampoline): Adjust call to gen_flush.\n+\t(enum sparc_builtins): New enumeral type.\n+\t(sparc_builtins): New static array.\n+\t(sparc_builtins_icode): Likewise.\n+\t(def_builtin): Accept a separate icode and save the result.\n+\t(def_builtin_const): Likewise.\n+\t(sparc_fpu_init_builtins): New function.\n+\t(sparc_vis_init_builtins): Pass the builtin code.\n+\t(sparc_init_builtins): Call it if TARGET_FPU.\n+\t(sparc_builtin_decl): New function.\n+\t(sparc_expand_builtin): Deal with SPARC_BUILTIN_{LD,ST}FSR.\n+\t(sparc_handle_vis_mul8x16): Use the builtin code.\n+\t(sparc_fold_builtin): Likewise.  Deal with SPARC_BUILTIN_{LD,ST}FSR\n+\tand SPARC_BUILTIN_PDISTN.\n+\t(compound_expr): New helper function.\n+\t(sparc_atomic_assign_expand_fenv): New function.\n+\t* config/sparc/sparc.md (unspecv): Reorder values, add UNSPECV_LDFSR\n+\tand UNSPECV_STFSR.\n+\t(flush, flushdi): Merge into single pattern.\n+\t(ldfsr): New instruction.\n+\t(stfsr): Likewise.\n+\n 2013-12-06  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* asan.c: Remove struct tags when referring to class varpool_node."}, {"sha": "c9a3f43fd40403dba6deb91d763174c47909f3cd", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -406,3 +406,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #undef SUN_INTEGER_MULTIPLY_64\n #define SUN_INTEGER_MULTIPLY_64 1\n+\n+#undef SPARC_LOW_FE_EXCEPT_VALUES\n+#define SPARC_LOW_FE_EXCEPT_VALUES 1"}, {"sha": "d7456722568de6eed7548abdea030fde4ff332cb", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 488, "deletions": 213, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -570,11 +570,11 @@ static void emit_hard_tfmode_operation (enum rtx_code, rtx *);\n static bool sparc_function_ok_for_sibcall (tree, tree);\n static void sparc_init_libfuncs (void);\n static void sparc_init_builtins (void);\n+static void sparc_fpu_init_builtins (void);\n static void sparc_vis_init_builtins (void);\n+static tree sparc_builtin_decl (unsigned, bool);\n static rtx sparc_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static tree sparc_fold_builtin (tree, int, tree *, bool);\n-static int sparc_vis_mul8x16 (int, int);\n-static void sparc_handle_vis_mul8x16 (tree *, int, tree, tree, tree);\n static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT, tree);\n static bool sparc_can_output_mi_thunk (const_tree, HOST_WIDE_INT,\n@@ -638,6 +638,7 @@ static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t   secondary_reload_info *);\n static enum machine_mode sparc_cstore_mode (enum insn_code icode);\n+static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -693,8 +694,6 @@ char sparc_hard_reg_printed[8];\n \n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS sparc_init_libfuncs\n-#undef TARGET_INIT_BUILTINS\n-#define TARGET_INIT_BUILTINS sparc_init_builtins\n \n #undef TARGET_LEGITIMIZE_ADDRESS\n #define TARGET_LEGITIMIZE_ADDRESS sparc_legitimize_address\n@@ -703,6 +702,10 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_MODE_DEPENDENT_ADDRESS_P\n #define TARGET_MODE_DEPENDENT_ADDRESS_P sparc_mode_dependent_address_p\n \n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS sparc_init_builtins\n+#undef TARGET_BUILTIN_DECL\n+#define TARGET_BUILTIN_DECL sparc_builtin_decl\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN sparc_expand_builtin\n #undef TARGET_FOLD_BUILTIN\n@@ -843,6 +846,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CSTORE_MODE\n #define TARGET_CSTORE_MODE sparc_cstore_mode\n \n+#undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n+#define TARGET_ATOMIC_ASSIGN_EXPAND_FENV sparc_atomic_assign_expand_fenv\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -9237,14 +9243,14 @@ sparc32_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n \n   /* On UltraSPARC a flush flushes an entire cache line.  The trampoline is\n      aligned on a 16 byte boundary so one flush clears it all.  */\n-  emit_insn (gen_flush (validize_mem (adjust_address (m_tramp, SImode, 0))));\n+  emit_insn (gen_flushsi (validize_mem (adjust_address (m_tramp, SImode, 0))));\n   if (sparc_cpu != PROCESSOR_ULTRASPARC\n       && sparc_cpu != PROCESSOR_ULTRASPARC3\n       && sparc_cpu != PROCESSOR_NIAGARA\n       && sparc_cpu != PROCESSOR_NIAGARA2\n       && sparc_cpu != PROCESSOR_NIAGARA3\n       && sparc_cpu != PROCESSOR_NIAGARA4)\n-    emit_insn (gen_flush (validize_mem (adjust_address (m_tramp, SImode, 8))));\n+    emit_insn (gen_flushsi (validize_mem (adjust_address (m_tramp, SImode, 8))));\n \n   /* Call __enable_execute_stack after writing onto the stack to make sure\n      the stack address is accessible.  */\n@@ -9969,15 +9975,145 @@ sparc_init_libfuncs (void)\n     }\n }\n \f\n-static tree def_builtin(const char *name, int code, tree type)\n+/* SPARC builtins.  */\n+enum sparc_builtins\n+{\n+  /* FPU builtins.  */\n+  SPARC_BUILTIN_LDFSR,\n+  SPARC_BUILTIN_STFSR,\n+\n+  /* VIS 1.0 builtins.  */\n+  SPARC_BUILTIN_FPACK16,\n+  SPARC_BUILTIN_FPACK32,\n+  SPARC_BUILTIN_FPACKFIX,\n+  SPARC_BUILTIN_FEXPAND,\n+  SPARC_BUILTIN_FPMERGE,\n+  SPARC_BUILTIN_FMUL8X16,\n+  SPARC_BUILTIN_FMUL8X16AU,\n+  SPARC_BUILTIN_FMUL8X16AL,\n+  SPARC_BUILTIN_FMUL8SUX16,\n+  SPARC_BUILTIN_FMUL8ULX16,\n+  SPARC_BUILTIN_FMULD8SUX16,\n+  SPARC_BUILTIN_FMULD8ULX16,\n+  SPARC_BUILTIN_FALIGNDATAV4HI,\n+  SPARC_BUILTIN_FALIGNDATAV8QI,\n+  SPARC_BUILTIN_FALIGNDATAV2SI,\n+  SPARC_BUILTIN_FALIGNDATADI,\n+  SPARC_BUILTIN_WRGSR,\n+  SPARC_BUILTIN_RDGSR,\n+  SPARC_BUILTIN_ALIGNADDR,\n+  SPARC_BUILTIN_ALIGNADDRL,\n+  SPARC_BUILTIN_PDIST,\n+  SPARC_BUILTIN_EDGE8,\n+  SPARC_BUILTIN_EDGE8L,\n+  SPARC_BUILTIN_EDGE16,\n+  SPARC_BUILTIN_EDGE16L,\n+  SPARC_BUILTIN_EDGE32,\n+  SPARC_BUILTIN_EDGE32L,\n+  SPARC_BUILTIN_FCMPLE16,\n+  SPARC_BUILTIN_FCMPLE32,\n+  SPARC_BUILTIN_FCMPNE16,\n+  SPARC_BUILTIN_FCMPNE32,\n+  SPARC_BUILTIN_FCMPGT16,\n+  SPARC_BUILTIN_FCMPGT32,\n+  SPARC_BUILTIN_FCMPEQ16,\n+  SPARC_BUILTIN_FCMPEQ32,\n+  SPARC_BUILTIN_FPADD16,\n+  SPARC_BUILTIN_FPADD16S,\n+  SPARC_BUILTIN_FPADD32,\n+  SPARC_BUILTIN_FPADD32S,\n+  SPARC_BUILTIN_FPSUB16,\n+  SPARC_BUILTIN_FPSUB16S,\n+  SPARC_BUILTIN_FPSUB32,\n+  SPARC_BUILTIN_FPSUB32S,\n+  SPARC_BUILTIN_ARRAY8,\n+  SPARC_BUILTIN_ARRAY16,\n+  SPARC_BUILTIN_ARRAY32,\n+\n+  /* VIS 2.0 builtins.  */\n+  SPARC_BUILTIN_EDGE8N,\n+  SPARC_BUILTIN_EDGE8LN,\n+  SPARC_BUILTIN_EDGE16N,\n+  SPARC_BUILTIN_EDGE16LN,\n+  SPARC_BUILTIN_EDGE32N,\n+  SPARC_BUILTIN_EDGE32LN,\n+  SPARC_BUILTIN_BMASK,\n+  SPARC_BUILTIN_BSHUFFLEV4HI,\n+  SPARC_BUILTIN_BSHUFFLEV8QI,\n+  SPARC_BUILTIN_BSHUFFLEV2SI,\n+  SPARC_BUILTIN_BSHUFFLEDI,\n+\n+  /* VIS 3.0 builtins.  */\n+  SPARC_BUILTIN_CMASK8,\n+  SPARC_BUILTIN_CMASK16,\n+  SPARC_BUILTIN_CMASK32,\n+  SPARC_BUILTIN_FCHKSM16,\n+  SPARC_BUILTIN_FSLL16,\n+  SPARC_BUILTIN_FSLAS16,\n+  SPARC_BUILTIN_FSRL16,\n+  SPARC_BUILTIN_FSRA16,\n+  SPARC_BUILTIN_FSLL32,\n+  SPARC_BUILTIN_FSLAS32,\n+  SPARC_BUILTIN_FSRL32,\n+  SPARC_BUILTIN_FSRA32,\n+  SPARC_BUILTIN_PDISTN,\n+  SPARC_BUILTIN_FMEAN16,\n+  SPARC_BUILTIN_FPADD64,\n+  SPARC_BUILTIN_FPSUB64,\n+  SPARC_BUILTIN_FPADDS16,\n+  SPARC_BUILTIN_FPADDS16S,\n+  SPARC_BUILTIN_FPSUBS16,\n+  SPARC_BUILTIN_FPSUBS16S,\n+  SPARC_BUILTIN_FPADDS32,\n+  SPARC_BUILTIN_FPADDS32S,\n+  SPARC_BUILTIN_FPSUBS32,\n+  SPARC_BUILTIN_FPSUBS32S,\n+  SPARC_BUILTIN_FUCMPLE8,\n+  SPARC_BUILTIN_FUCMPNE8,\n+  SPARC_BUILTIN_FUCMPGT8,\n+  SPARC_BUILTIN_FUCMPEQ8,\n+  SPARC_BUILTIN_FHADDS,\n+  SPARC_BUILTIN_FHADDD,\n+  SPARC_BUILTIN_FHSUBS,\n+  SPARC_BUILTIN_FHSUBD,\n+  SPARC_BUILTIN_FNHADDS,\n+  SPARC_BUILTIN_FNHADDD,\n+  SPARC_BUILTIN_UMULXHI,\n+  SPARC_BUILTIN_XMULX,\n+  SPARC_BUILTIN_XMULXHI,\n+\n+  SPARC_BUILTIN_MAX\n+};\n+\n+static GTY (()) tree sparc_builtins[(int) SPARC_BUILTIN_MAX];\n+static enum insn_code sparc_builtins_icode[(int) SPARC_BUILTIN_MAX];\n+\n+/* Add a SPARC builtin function with NAME, ICODE, CODE and TYPE.  Return the\n+   function decl or NULL_TREE if the builtin was not added.  */\n+\n+static tree\n+def_builtin (const char *name, enum insn_code icode, enum sparc_builtins code,\n+\t     tree type)\n {\n-  return add_builtin_function(name, type, code, BUILT_IN_MD, NULL,\n-\t\t\t      NULL_TREE);\n+  tree t\n+    = add_builtin_function (name, type, code, BUILT_IN_MD, NULL, NULL_TREE);\n+\n+  if (t)\n+    {\n+      sparc_builtins[code] = t;\n+      sparc_builtins_icode[code] = icode;\n+    }\n+\n+  return t;\n }\n \n-static tree def_builtin_const(const char *name, int code, tree type)\n+/* Likewise, but also marks the function as \"const\".  */\n+\n+static tree\n+def_builtin_const (const char *name, enum insn_code icode,\n+\t\t   enum sparc_builtins code, tree type)\n {\n-  tree t = def_builtin(name, code, type);\n+  tree t = def_builtin (name, icode, code, type);\n \n   if (t)\n     TREE_READONLY (t) = 1;\n@@ -9991,11 +10127,28 @@ static tree def_builtin_const(const char *name, int code, tree type)\n static void\n sparc_init_builtins (void)\n {\n+  if (TARGET_FPU)\n+    sparc_fpu_init_builtins ();\n+\n   if (TARGET_VIS)\n     sparc_vis_init_builtins ();\n }\n \n-/* Create builtin functions for VIS 1.0 instructions.  */\n+/* Create builtin functions for FPU instructions.  */\n+\n+static void\n+sparc_fpu_init_builtins (void)\n+{\n+  tree ftype\n+    = build_function_type_list (void_type_node,\n+\t\t\t\tbuild_pointer_type (unsigned_type_node), 0);\n+  def_builtin (\"__builtin_load_fsr\", CODE_FOR_ldfsr,\n+\t       SPARC_BUILTIN_LDFSR, ftype);\n+  def_builtin (\"__builtin_store_fsr\", CODE_FOR_stfsr,\n+\t       SPARC_BUILTIN_STFSR, ftype);\n+}\n+\n+/* Create builtin functions for VIS instructions.  */\n \n static void\n sparc_vis_init_builtins (void)\n@@ -10069,360 +10222,371 @@ sparc_vis_init_builtins (void)\n \n   /* Packing and expanding vectors.  */\n   def_builtin (\"__builtin_vis_fpack16\", CODE_FOR_fpack16_vis,\n-\t       v4qi_ftype_v4hi);\n+\t       SPARC_BUILTIN_FPACK16, v4qi_ftype_v4hi);\n   def_builtin (\"__builtin_vis_fpack32\", CODE_FOR_fpack32_vis,\n-\t       v8qi_ftype_v2si_v8qi);\n+\t       SPARC_BUILTIN_FPACK32, v8qi_ftype_v2si_v8qi);\n   def_builtin (\"__builtin_vis_fpackfix\", CODE_FOR_fpackfix_vis,\n-\t       v2hi_ftype_v2si);\n+\t       SPARC_BUILTIN_FPACKFIX, v2hi_ftype_v2si);\n   def_builtin_const (\"__builtin_vis_fexpand\", CODE_FOR_fexpand_vis,\n-\t\t     v4hi_ftype_v4qi);\n+\t\t     SPARC_BUILTIN_FEXPAND, v4hi_ftype_v4qi);\n   def_builtin_const (\"__builtin_vis_fpmerge\", CODE_FOR_fpmerge_vis,\n-\t\t     v8qi_ftype_v4qi_v4qi);\n+\t\t     SPARC_BUILTIN_FPMERGE, v8qi_ftype_v4qi_v4qi);\n \n   /* Multiplications.  */\n   def_builtin_const (\"__builtin_vis_fmul8x16\", CODE_FOR_fmul8x16_vis,\n-\t\t     v4hi_ftype_v4qi_v4hi);\n+\t\t     SPARC_BUILTIN_FMUL8X16, v4hi_ftype_v4qi_v4hi);\n   def_builtin_const (\"__builtin_vis_fmul8x16au\", CODE_FOR_fmul8x16au_vis,\n-\t\t     v4hi_ftype_v4qi_v2hi);\n+\t\t     SPARC_BUILTIN_FMUL8X16AU, v4hi_ftype_v4qi_v2hi);\n   def_builtin_const (\"__builtin_vis_fmul8x16al\", CODE_FOR_fmul8x16al_vis,\n-\t\t     v4hi_ftype_v4qi_v2hi);\n+\t\t     SPARC_BUILTIN_FMUL8X16AL, v4hi_ftype_v4qi_v2hi);\n   def_builtin_const (\"__builtin_vis_fmul8sux16\", CODE_FOR_fmul8sux16_vis,\n-\t\t     v4hi_ftype_v8qi_v4hi);\n+\t\t     SPARC_BUILTIN_FMUL8SUX16, v4hi_ftype_v8qi_v4hi);\n   def_builtin_const (\"__builtin_vis_fmul8ulx16\", CODE_FOR_fmul8ulx16_vis,\n-\t\t     v4hi_ftype_v8qi_v4hi);\n+\t\t     SPARC_BUILTIN_FMUL8ULX16, v4hi_ftype_v8qi_v4hi);\n   def_builtin_const (\"__builtin_vis_fmuld8sux16\", CODE_FOR_fmuld8sux16_vis,\n-\t\t     v2si_ftype_v4qi_v2hi);\n+\t\t     SPARC_BUILTIN_FMULD8SUX16, v2si_ftype_v4qi_v2hi);\n   def_builtin_const (\"__builtin_vis_fmuld8ulx16\", CODE_FOR_fmuld8ulx16_vis,\n-\t\t     v2si_ftype_v4qi_v2hi);\n+\t\t     SPARC_BUILTIN_FMULD8ULX16, v2si_ftype_v4qi_v2hi);\n \n   /* Data aligning.  */\n   def_builtin (\"__builtin_vis_faligndatav4hi\", CODE_FOR_faligndatav4hi_vis,\n-\t       v4hi_ftype_v4hi_v4hi);\n+\t       SPARC_BUILTIN_FALIGNDATAV4HI, v4hi_ftype_v4hi_v4hi);\n   def_builtin (\"__builtin_vis_faligndatav8qi\", CODE_FOR_faligndatav8qi_vis,\n-\t       v8qi_ftype_v8qi_v8qi);\n+\t       SPARC_BUILTIN_FALIGNDATAV8QI, v8qi_ftype_v8qi_v8qi);\n   def_builtin (\"__builtin_vis_faligndatav2si\", CODE_FOR_faligndatav2si_vis,\n-\t       v2si_ftype_v2si_v2si);\n+\t       SPARC_BUILTIN_FALIGNDATAV2SI, v2si_ftype_v2si_v2si);\n   def_builtin (\"__builtin_vis_faligndatadi\", CODE_FOR_faligndatav1di_vis,\n-\t       di_ftype_di_di);\n+\t       SPARC_BUILTIN_FALIGNDATADI, di_ftype_di_di);\n \n   def_builtin (\"__builtin_vis_write_gsr\", CODE_FOR_wrgsr_vis,\n-\t       void_ftype_di);\n+\t       SPARC_BUILTIN_WRGSR, void_ftype_di);\n   def_builtin (\"__builtin_vis_read_gsr\", CODE_FOR_rdgsr_vis,\n-\t       di_ftype_void);\n+\t       SPARC_BUILTIN_RDGSR, di_ftype_void);\n \n   if (TARGET_ARCH64)\n     {\n       def_builtin (\"__builtin_vis_alignaddr\", CODE_FOR_alignaddrdi_vis,\n-\t\t   ptr_ftype_ptr_di);\n+\t\t   SPARC_BUILTIN_ALIGNADDR, ptr_ftype_ptr_di);\n       def_builtin (\"__builtin_vis_alignaddrl\", CODE_FOR_alignaddrldi_vis,\n-\t\t   ptr_ftype_ptr_di);\n+\t\t   SPARC_BUILTIN_ALIGNADDRL, ptr_ftype_ptr_di);\n     }\n   else\n     {\n       def_builtin (\"__builtin_vis_alignaddr\", CODE_FOR_alignaddrsi_vis,\n-\t\t   ptr_ftype_ptr_si);\n+\t\t   SPARC_BUILTIN_ALIGNADDR, ptr_ftype_ptr_si);\n       def_builtin (\"__builtin_vis_alignaddrl\", CODE_FOR_alignaddrlsi_vis,\n-\t\t   ptr_ftype_ptr_si);\n+\t\t   SPARC_BUILTIN_ALIGNADDRL, ptr_ftype_ptr_si);\n     }\n \n   /* Pixel distance.  */\n   def_builtin_const (\"__builtin_vis_pdist\", CODE_FOR_pdist_vis,\n-\t\t     di_ftype_v8qi_v8qi_di);\n+\t\t     SPARC_BUILTIN_PDIST, di_ftype_v8qi_v8qi_di);\n \n   /* Edge handling.  */\n   if (TARGET_ARCH64)\n     {\n       def_builtin_const (\"__builtin_vis_edge8\", CODE_FOR_edge8di_vis,\n-\t\t\t di_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE8, di_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge8l\", CODE_FOR_edge8ldi_vis,\n-\t\t\t di_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE8L, di_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge16\", CODE_FOR_edge16di_vis,\n-\t\t\t di_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE16, di_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge16l\", CODE_FOR_edge16ldi_vis,\n-\t\t\t di_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE16L, di_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge32\", CODE_FOR_edge32di_vis,\n-\t\t\t di_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE32, di_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge32l\", CODE_FOR_edge32ldi_vis,\n-\t\t\t di_ftype_ptr_ptr);\n-      if (TARGET_VIS2)\n-\t{\n-\t  def_builtin_const (\"__builtin_vis_edge8n\", CODE_FOR_edge8ndi_vis,\n-\t\t\t     di_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge8ln\", CODE_FOR_edge8lndi_vis,\n-\t\t\t     di_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge16n\", CODE_FOR_edge16ndi_vis,\n-\t\t\t     di_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge16ln\", CODE_FOR_edge16lndi_vis,\n-\t\t\t     di_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge32n\", CODE_FOR_edge32ndi_vis,\n-\t\t\t     di_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge32ln\", CODE_FOR_edge32lndi_vis,\n-\t\t\t     di_ftype_ptr_ptr);\n-\t}\n+\t\t\t SPARC_BUILTIN_EDGE32L, di_ftype_ptr_ptr);\n     }\n   else\n     {\n       def_builtin_const (\"__builtin_vis_edge8\", CODE_FOR_edge8si_vis,\n-\t\t\t si_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE8, si_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge8l\", CODE_FOR_edge8lsi_vis,\n-\t\t\t si_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE8L, si_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge16\", CODE_FOR_edge16si_vis,\n-\t\t\t si_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE16, si_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge16l\", CODE_FOR_edge16lsi_vis,\n-\t\t\t si_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE16L, si_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge32\", CODE_FOR_edge32si_vis,\n-\t\t\t si_ftype_ptr_ptr);\n+\t\t\t SPARC_BUILTIN_EDGE32, si_ftype_ptr_ptr);\n       def_builtin_const (\"__builtin_vis_edge32l\", CODE_FOR_edge32lsi_vis,\n-\t\t\t si_ftype_ptr_ptr);\n-      if (TARGET_VIS2)\n-\t{\n-\t  def_builtin_const (\"__builtin_vis_edge8n\", CODE_FOR_edge8nsi_vis,\n-\t\t\t     si_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge8ln\", CODE_FOR_edge8lnsi_vis,\n-\t\t\t     si_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge16n\", CODE_FOR_edge16nsi_vis,\n-\t\t\t     si_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge16ln\", CODE_FOR_edge16lnsi_vis,\n-\t\t\t     si_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge32n\", CODE_FOR_edge32nsi_vis,\n-\t\t\t     si_ftype_ptr_ptr);\n-\t  def_builtin_const (\"__builtin_vis_edge32ln\", CODE_FOR_edge32lnsi_vis,\n-\t\t\t     si_ftype_ptr_ptr);\n-\t}\n+\t\t\t SPARC_BUILTIN_EDGE32L, si_ftype_ptr_ptr);\n     }\n \n   /* Pixel compare.  */\n   if (TARGET_ARCH64)\n     {\n       def_builtin_const (\"__builtin_vis_fcmple16\", CODE_FOR_fcmple16di_vis,\n-\t\t\t di_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPLE16, di_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmple32\", CODE_FOR_fcmple32di_vis,\n-\t\t\t di_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPLE32, di_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fcmpne16\", CODE_FOR_fcmpne16di_vis,\n-\t\t\t di_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPNE16, di_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmpne32\", CODE_FOR_fcmpne32di_vis,\n-\t\t\t di_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPNE32, di_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fcmpgt16\", CODE_FOR_fcmpgt16di_vis,\n-\t\t\t di_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPGT16, di_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmpgt32\", CODE_FOR_fcmpgt32di_vis,\n-\t\t\t di_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPGT32, di_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fcmpeq16\", CODE_FOR_fcmpeq16di_vis,\n-\t\t\t di_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPEQ16, di_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmpeq32\", CODE_FOR_fcmpeq32di_vis,\n-\t\t\t di_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPEQ32, di_ftype_v2si_v2si);\n     }\n   else\n     {\n       def_builtin_const (\"__builtin_vis_fcmple16\", CODE_FOR_fcmple16si_vis,\n-\t\t\t si_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPLE16, si_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmple32\", CODE_FOR_fcmple32si_vis,\n-\t\t\t si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPLE32, si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fcmpne16\", CODE_FOR_fcmpne16si_vis,\n-\t\t\t si_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPNE16, si_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmpne32\", CODE_FOR_fcmpne32si_vis,\n-\t\t\t si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPNE32, si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fcmpgt16\", CODE_FOR_fcmpgt16si_vis,\n-\t\t\t si_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPGT16, si_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmpgt32\", CODE_FOR_fcmpgt32si_vis,\n-\t\t\t si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPGT32, si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fcmpeq16\", CODE_FOR_fcmpeq16si_vis,\n-\t\t\t si_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCMPEQ16, si_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fcmpeq32\", CODE_FOR_fcmpeq32si_vis,\n-\t\t\t si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FCMPEQ32, si_ftype_v2si_v2si);\n     }\n \n   /* Addition and subtraction.  */\n   def_builtin_const (\"__builtin_vis_fpadd16\", CODE_FOR_addv4hi3,\n-\t\t     v4hi_ftype_v4hi_v4hi);\n+\t\t     SPARC_BUILTIN_FPADD16, v4hi_ftype_v4hi_v4hi);\n   def_builtin_const (\"__builtin_vis_fpadd16s\", CODE_FOR_addv2hi3,\n-\t\t     v2hi_ftype_v2hi_v2hi);\n+\t\t     SPARC_BUILTIN_FPADD16S, v2hi_ftype_v2hi_v2hi);\n   def_builtin_const (\"__builtin_vis_fpadd32\", CODE_FOR_addv2si3,\n-\t\t     v2si_ftype_v2si_v2si);\n+\t\t     SPARC_BUILTIN_FPADD32, v2si_ftype_v2si_v2si);\n   def_builtin_const (\"__builtin_vis_fpadd32s\", CODE_FOR_addv1si3,\n-\t\t     v1si_ftype_v1si_v1si);\n+\t\t     SPARC_BUILTIN_FPADD32S, v1si_ftype_v1si_v1si);\n   def_builtin_const (\"__builtin_vis_fpsub16\", CODE_FOR_subv4hi3,\n-\t\t     v4hi_ftype_v4hi_v4hi);\n+\t\t     SPARC_BUILTIN_FPSUB16, v4hi_ftype_v4hi_v4hi);\n   def_builtin_const (\"__builtin_vis_fpsub16s\", CODE_FOR_subv2hi3,\n-\t\t     v2hi_ftype_v2hi_v2hi);\n+\t\t     SPARC_BUILTIN_FPSUB16S, v2hi_ftype_v2hi_v2hi);\n   def_builtin_const (\"__builtin_vis_fpsub32\", CODE_FOR_subv2si3,\n-\t\t     v2si_ftype_v2si_v2si);\n+\t\t     SPARC_BUILTIN_FPSUB32, v2si_ftype_v2si_v2si);\n   def_builtin_const (\"__builtin_vis_fpsub32s\", CODE_FOR_subv1si3,\n-\t\t     v1si_ftype_v1si_v1si);\n+\t\t     SPARC_BUILTIN_FPSUB32S, v1si_ftype_v1si_v1si);\n \n   /* Three-dimensional array addressing.  */\n   if (TARGET_ARCH64)\n     {\n       def_builtin_const (\"__builtin_vis_array8\", CODE_FOR_array8di_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_ARRAY8, di_ftype_di_di);\n       def_builtin_const (\"__builtin_vis_array16\", CODE_FOR_array16di_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_ARRAY16, di_ftype_di_di);\n       def_builtin_const (\"__builtin_vis_array32\", CODE_FOR_array32di_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_ARRAY32, di_ftype_di_di);\n     }\n   else\n     {\n       def_builtin_const (\"__builtin_vis_array8\", CODE_FOR_array8si_vis,\n-\t\t\t si_ftype_si_si);\n+\t\t\t SPARC_BUILTIN_ARRAY8, si_ftype_si_si);\n       def_builtin_const (\"__builtin_vis_array16\", CODE_FOR_array16si_vis,\n-\t\t\t si_ftype_si_si);\n+\t\t\t SPARC_BUILTIN_ARRAY16, si_ftype_si_si);\n       def_builtin_const (\"__builtin_vis_array32\", CODE_FOR_array32si_vis,\n-\t\t\t si_ftype_si_si);\n-  }\n+\t\t\t SPARC_BUILTIN_ARRAY32, si_ftype_si_si);\n+    }\n \n   if (TARGET_VIS2)\n     {\n-      /* Byte mask and shuffle */\n+      /* Edge handling.  */\n+      if (TARGET_ARCH64)\n+\t{\n+\t  def_builtin_const (\"__builtin_vis_edge8n\", CODE_FOR_edge8ndi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE8N, di_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge8ln\", CODE_FOR_edge8lndi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE8LN, di_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge16n\", CODE_FOR_edge16ndi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE16N, di_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge16ln\", CODE_FOR_edge16lndi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE16LN, di_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge32n\", CODE_FOR_edge32ndi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE32N, di_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge32ln\", CODE_FOR_edge32lndi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE32LN, di_ftype_ptr_ptr);\n+\t}\n+      else\n+\t{\n+\t  def_builtin_const (\"__builtin_vis_edge8n\", CODE_FOR_edge8nsi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE8N, si_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge8ln\", CODE_FOR_edge8lnsi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE8LN, si_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge16n\", CODE_FOR_edge16nsi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE16N, si_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge16ln\", CODE_FOR_edge16lnsi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE16LN, si_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge32n\", CODE_FOR_edge32nsi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE32N, si_ftype_ptr_ptr);\n+\t  def_builtin_const (\"__builtin_vis_edge32ln\", CODE_FOR_edge32lnsi_vis,\n+\t\t\t     SPARC_BUILTIN_EDGE32LN, si_ftype_ptr_ptr);\n+\t}\n+\n+      /* Byte mask and shuffle.  */\n       if (TARGET_ARCH64)\n \tdef_builtin (\"__builtin_vis_bmask\", CODE_FOR_bmaskdi_vis,\n-\t\t     di_ftype_di_di);\n+\t\t     SPARC_BUILTIN_BMASK, di_ftype_di_di);\n       else\n \tdef_builtin (\"__builtin_vis_bmask\", CODE_FOR_bmasksi_vis,\n-\t\t     si_ftype_si_si);\n+\t\t     SPARC_BUILTIN_BMASK, si_ftype_si_si);\n       def_builtin (\"__builtin_vis_bshufflev4hi\", CODE_FOR_bshufflev4hi_vis,\n-\t\t   v4hi_ftype_v4hi_v4hi);\n+\t\t   SPARC_BUILTIN_BSHUFFLEV4HI, v4hi_ftype_v4hi_v4hi);\n       def_builtin (\"__builtin_vis_bshufflev8qi\", CODE_FOR_bshufflev8qi_vis,\n-\t\t   v8qi_ftype_v8qi_v8qi);\n+\t\t   SPARC_BUILTIN_BSHUFFLEV8QI, v8qi_ftype_v8qi_v8qi);\n       def_builtin (\"__builtin_vis_bshufflev2si\", CODE_FOR_bshufflev2si_vis,\n-\t\t   v2si_ftype_v2si_v2si);\n+\t\t   SPARC_BUILTIN_BSHUFFLEV2SI, v2si_ftype_v2si_v2si);\n       def_builtin (\"__builtin_vis_bshuffledi\", CODE_FOR_bshufflev1di_vis,\n-\t\t   di_ftype_di_di);\n+\t\t   SPARC_BUILTIN_BSHUFFLEDI, di_ftype_di_di);\n     }\n \n   if (TARGET_VIS3)\n     {\n       if (TARGET_ARCH64)\n \t{\n \t  def_builtin (\"__builtin_vis_cmask8\", CODE_FOR_cmask8di_vis,\n-\t\t       void_ftype_di);\n+\t\t       SPARC_BUILTIN_CMASK8, void_ftype_di);\n \t  def_builtin (\"__builtin_vis_cmask16\", CODE_FOR_cmask16di_vis,\n-\t\t       void_ftype_di);\n+\t\t       SPARC_BUILTIN_CMASK16, void_ftype_di);\n \t  def_builtin (\"__builtin_vis_cmask32\", CODE_FOR_cmask32di_vis,\n-\t\t       void_ftype_di);\n+\t\t       SPARC_BUILTIN_CMASK32, void_ftype_di);\n \t}\n       else\n \t{\n \t  def_builtin (\"__builtin_vis_cmask8\", CODE_FOR_cmask8si_vis,\n-\t\t       void_ftype_si);\n+\t\t       SPARC_BUILTIN_CMASK8, void_ftype_si);\n \t  def_builtin (\"__builtin_vis_cmask16\", CODE_FOR_cmask16si_vis,\n-\t\t       void_ftype_si);\n+\t\t       SPARC_BUILTIN_CMASK16, void_ftype_si);\n \t  def_builtin (\"__builtin_vis_cmask32\", CODE_FOR_cmask32si_vis,\n-\t\t       void_ftype_si);\n+\t\t       SPARC_BUILTIN_CMASK32, void_ftype_si);\n \t}\n \n       def_builtin_const (\"__builtin_vis_fchksm16\", CODE_FOR_fchksm16_vis,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FCHKSM16, v4hi_ftype_v4hi_v4hi);\n \n       def_builtin_const (\"__builtin_vis_fsll16\", CODE_FOR_vashlv4hi3,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FSLL16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fslas16\", CODE_FOR_vssashlv4hi3,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FSLAS16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fsrl16\", CODE_FOR_vlshrv4hi3,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FSRL16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fsra16\", CODE_FOR_vashrv4hi3,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FSRA16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fsll32\", CODE_FOR_vashlv2si3,\n-\t\t\t v2si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FSLL32, v2si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fslas32\", CODE_FOR_vssashlv2si3,\n-\t\t\t v2si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FSLAS32, v2si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fsrl32\", CODE_FOR_vlshrv2si3,\n-\t\t\t v2si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FSRL32, v2si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fsra32\", CODE_FOR_vashrv2si3,\n-\t\t\t v2si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FSRA32, v2si_ftype_v2si_v2si);\n \n       if (TARGET_ARCH64)\n \tdef_builtin_const (\"__builtin_vis_pdistn\", CODE_FOR_pdistndi_vis,\n-\t\t\t   di_ftype_v8qi_v8qi);\n+\t\t\t   SPARC_BUILTIN_PDISTN, di_ftype_v8qi_v8qi);\n       else\n \tdef_builtin_const (\"__builtin_vis_pdistn\", CODE_FOR_pdistnsi_vis,\n-\t\t\t   si_ftype_v8qi_v8qi);\n+\t\t\t   SPARC_BUILTIN_PDISTN, si_ftype_v8qi_v8qi);\n \n       def_builtin_const (\"__builtin_vis_fmean16\", CODE_FOR_fmean16_vis,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FMEAN16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fpadd64\", CODE_FOR_fpadd64_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_FPADD64, di_ftype_di_di);\n       def_builtin_const (\"__builtin_vis_fpsub64\", CODE_FOR_fpsub64_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_FPSUB64, di_ftype_di_di);\n \n       def_builtin_const (\"__builtin_vis_fpadds16\", CODE_FOR_ssaddv4hi3,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FPADDS16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fpadds16s\", CODE_FOR_ssaddv2hi3,\n-\t\t\t v2hi_ftype_v2hi_v2hi);\n+\t\t\t SPARC_BUILTIN_FPADDS16S, v2hi_ftype_v2hi_v2hi);\n       def_builtin_const (\"__builtin_vis_fpsubs16\", CODE_FOR_sssubv4hi3,\n-\t\t\t v4hi_ftype_v4hi_v4hi);\n+\t\t\t SPARC_BUILTIN_FPSUBS16, v4hi_ftype_v4hi_v4hi);\n       def_builtin_const (\"__builtin_vis_fpsubs16s\", CODE_FOR_sssubv2hi3,\n-\t\t\t v2hi_ftype_v2hi_v2hi);\n+\t\t\t SPARC_BUILTIN_FPSUBS16S, v2hi_ftype_v2hi_v2hi);\n       def_builtin_const (\"__builtin_vis_fpadds32\", CODE_FOR_ssaddv2si3,\n-\t\t\t v2si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FPADDS32, v2si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fpadds32s\", CODE_FOR_ssaddv1si3,\n-\t\t\t v1si_ftype_v1si_v1si);\n+\t\t\t SPARC_BUILTIN_FPADDS32S, v1si_ftype_v1si_v1si);\n       def_builtin_const (\"__builtin_vis_fpsubs32\", CODE_FOR_sssubv2si3,\n-\t\t\t v2si_ftype_v2si_v2si);\n+\t\t\t SPARC_BUILTIN_FPSUBS32, v2si_ftype_v2si_v2si);\n       def_builtin_const (\"__builtin_vis_fpsubs32s\", CODE_FOR_sssubv1si3,\n-\t\t\t v1si_ftype_v1si_v1si);\n+\t\t\t SPARC_BUILTIN_FPSUBS32S, v1si_ftype_v1si_v1si);\n \n       if (TARGET_ARCH64)\n \t{\n \t  def_builtin_const (\"__builtin_vis_fucmple8\", CODE_FOR_fucmple8di_vis,\n-\t\t\t     di_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPLE8, di_ftype_v8qi_v8qi);\n \t  def_builtin_const (\"__builtin_vis_fucmpne8\", CODE_FOR_fucmpne8di_vis,\n-\t\t\t     di_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPNE8, di_ftype_v8qi_v8qi);\n \t  def_builtin_const (\"__builtin_vis_fucmpgt8\", CODE_FOR_fucmpgt8di_vis,\n-\t\t\t     di_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPGT8, di_ftype_v8qi_v8qi);\n \t  def_builtin_const (\"__builtin_vis_fucmpeq8\", CODE_FOR_fucmpeq8di_vis,\n-\t\t\t     di_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPEQ8, di_ftype_v8qi_v8qi);\n \t}\n       else\n \t{\n \t  def_builtin_const (\"__builtin_vis_fucmple8\", CODE_FOR_fucmple8si_vis,\n-\t\t\t     si_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPLE8, si_ftype_v8qi_v8qi);\n \t  def_builtin_const (\"__builtin_vis_fucmpne8\", CODE_FOR_fucmpne8si_vis,\n-\t\t\t     si_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPNE8, si_ftype_v8qi_v8qi);\n \t  def_builtin_const (\"__builtin_vis_fucmpgt8\", CODE_FOR_fucmpgt8si_vis,\n-\t\t\t     si_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPGT8, si_ftype_v8qi_v8qi);\n \t  def_builtin_const (\"__builtin_vis_fucmpeq8\", CODE_FOR_fucmpeq8si_vis,\n-\t\t\t     si_ftype_v8qi_v8qi);\n+\t\t\t     SPARC_BUILTIN_FUCMPEQ8, si_ftype_v8qi_v8qi);\n \t}\n \n       def_builtin_const (\"__builtin_vis_fhadds\", CODE_FOR_fhaddsf_vis,\n-\t\t\t sf_ftype_sf_sf);\n+\t\t\t SPARC_BUILTIN_FHADDS, sf_ftype_sf_sf);\n       def_builtin_const (\"__builtin_vis_fhaddd\", CODE_FOR_fhadddf_vis,\n-\t\t\t df_ftype_df_df);\n+\t\t\t SPARC_BUILTIN_FHADDD, df_ftype_df_df);\n       def_builtin_const (\"__builtin_vis_fhsubs\", CODE_FOR_fhsubsf_vis,\n-\t\t\t sf_ftype_sf_sf);\n+\t\t\t SPARC_BUILTIN_FHSUBS, sf_ftype_sf_sf);\n       def_builtin_const (\"__builtin_vis_fhsubd\", CODE_FOR_fhsubdf_vis,\n-\t\t\t df_ftype_df_df);\n+\t\t\t SPARC_BUILTIN_FHSUBD, df_ftype_df_df);\n       def_builtin_const (\"__builtin_vis_fnhadds\", CODE_FOR_fnhaddsf_vis,\n-\t\t\t sf_ftype_sf_sf);\n+\t\t\t SPARC_BUILTIN_FNHADDS, sf_ftype_sf_sf);\n       def_builtin_const (\"__builtin_vis_fnhaddd\", CODE_FOR_fnhadddf_vis,\n-\t\t\t df_ftype_df_df);\n+\t\t\t SPARC_BUILTIN_FNHADDD, df_ftype_df_df);\n \n       def_builtin_const (\"__builtin_vis_umulxhi\", CODE_FOR_umulxhi_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_UMULXHI, di_ftype_di_di);\n       def_builtin_const (\"__builtin_vis_xmulx\", CODE_FOR_xmulx_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_XMULX, di_ftype_di_di);\n       def_builtin_const (\"__builtin_vis_xmulxhi\", CODE_FOR_xmulxhi_vis,\n-\t\t\t di_ftype_di_di);\n+\t\t\t SPARC_BUILTIN_XMULXHI, di_ftype_di_di);\n     }\n }\n \n-/* Handle TARGET_EXPAND_BUILTIN target hook.\n-   Expand builtin functions for sparc intrinsics.  */\n+/* Implement TARGET_BUILTIN_DECL hook.  */\n+\n+static tree\n+sparc_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n+{\n+  if (code >= SPARC_BUILTIN_MAX)\n+    return error_mark_node;\n+\n+  return sparc_builtins[code];\n+}\n+\n+/* Implemented TARGET_EXPAND_BUILTIN hook.  */\n \n static rtx\n sparc_expand_builtin (tree exp, rtx target,\n \t\t      rtx subtarget ATTRIBUTE_UNUSED,\n \t\t      enum machine_mode tmode ATTRIBUTE_UNUSED,\n \t\t      int ignore ATTRIBUTE_UNUSED)\n {\n-  tree arg;\n-  call_expr_arg_iterator iter;\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-  unsigned int icode = DECL_FUNCTION_CODE (fndecl);\n-  rtx pat, op[4];\n+  enum sparc_builtins code = (enum sparc_builtins) DECL_FUNCTION_CODE (fndecl);\n+  enum insn_code icode = sparc_builtins_icode[code];\n+  bool nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n+  call_expr_arg_iterator iter;\n   int arg_count = 0;\n-  bool nonvoid;\n-\n-  nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n+  rtx pat, op[4];\n+  tree arg;\n \n   if (nonvoid)\n     {\n@@ -10434,6 +10598,7 @@ sparc_expand_builtin (tree exp, rtx target,\n       else\n \top[0] = target;\n     }\n+\n   FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n     {\n       const struct insn_operand_data *insn_op;\n@@ -10447,11 +10612,22 @@ sparc_expand_builtin (tree exp, rtx target,\n       insn_op = &insn_data[icode].operand[idx];\n       op[arg_count] = expand_normal (arg);\n \n-      if (insn_op->mode == V1DImode\n-\t  && GET_MODE (op[arg_count]) == DImode)\n+      if (code == SPARC_BUILTIN_LDFSR || code == SPARC_BUILTIN_STFSR)\n+\t{\n+\t  if (!address_operand (op[arg_count], SImode))\n+\t    {\n+\t      op[arg_count] = convert_memory_address (Pmode, op[arg_count]);\n+\t      op[arg_count] = copy_addr_to_reg (op[arg_count]);\n+\t    }\n+\t  op[arg_count] = gen_rtx_MEM (SImode, op[arg_count]);\n+\t}\n+\n+      else if (insn_op->mode == V1DImode\n+\t       && GET_MODE (op[arg_count]) == DImode)\n \top[arg_count] = gen_lowpart (V1DImode, op[arg_count]);\n+\n       else if (insn_op->mode == V1SImode\n-\t  && GET_MODE (op[arg_count]) == SImode)\n+\t       && GET_MODE (op[arg_count]) == SImode)\n \top[arg_count] = gen_lowpart (V1SImode, op[arg_count]);\n \n       if (! (*insn_data[icode].operand[idx].predicate) (op[arg_count],\n@@ -10485,12 +10661,11 @@ sparc_expand_builtin (tree exp, rtx target,\n \n   emit_insn (pat);\n \n-  if (nonvoid)\n-    return op[0];\n-  else\n-    return const0_rtx;\n+  return (nonvoid ? op[0] : const0_rtx);\n }\n \n+/* Return the upper 16 bits of the 8x16 multiplication.  */\n+\n static int\n sparc_vis_mul8x16 (int e8, int e16)\n {\n@@ -10501,15 +10676,15 @@ sparc_vis_mul8x16 (int e8, int e16)\n    the result into the array N_ELTS, whose elements are of INNER_TYPE.  */\n \n static void\n-sparc_handle_vis_mul8x16 (tree *n_elts, int fncode, tree inner_type,\n-\t\t\t  tree cst0, tree cst1)\n+sparc_handle_vis_mul8x16 (tree *n_elts, enum sparc_builtins fncode,\n+\t\t\t  tree inner_type, tree cst0, tree cst1)\n {\n   unsigned i, num = VECTOR_CST_NELTS (cst0);\n   int scale;\n \n   switch (fncode)\n     {\n-    case CODE_FOR_fmul8x16_vis:\n+    case SPARC_BUILTIN_FMUL8X16:\n       for (i = 0; i < num; ++i)\n \t{\n \t  int val\n@@ -10519,7 +10694,7 @@ sparc_handle_vis_mul8x16 (tree *n_elts, int fncode, tree inner_type,\n \t}\n       break;\n \n-    case CODE_FOR_fmul8x16au_vis:\n+    case SPARC_BUILTIN_FMUL8X16AU:\n       scale = TREE_INT_CST_LOW (VECTOR_CST_ELT (cst1, 0));\n \n       for (i = 0; i < num; ++i)\n@@ -10531,7 +10706,7 @@ sparc_handle_vis_mul8x16 (tree *n_elts, int fncode, tree inner_type,\n \t}\n       break;\n \n-    case CODE_FOR_fmul8x16al_vis:\n+    case SPARC_BUILTIN_FMUL8X16AL:\n       scale = TREE_INT_CST_LOW (VECTOR_CST_ELT (cst1, 1));\n \n       for (i = 0; i < num; ++i)\n@@ -10548,7 +10723,8 @@ sparc_handle_vis_mul8x16 (tree *n_elts, int fncode, tree inner_type,\n     }\n }\n \n-/* Handle TARGET_FOLD_BUILTIN target hook.\n+/* Implement TARGET_FOLD_BUILTIN hook.\n+\n    Fold builtin functions for SPARC intrinsics.  If IGNORE is true the\n    result of the function call is ignored.  NULL_TREE is returned if the\n    function could not be folded.  */\n@@ -10557,34 +10733,30 @@ static tree\n sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t\t    tree *args, bool ignore)\n {\n-  tree arg0, arg1, arg2;\n+  enum sparc_builtins code = (enum sparc_builtins) DECL_FUNCTION_CODE (fndecl);\n   tree rtype = TREE_TYPE (TREE_TYPE (fndecl));\n-  enum insn_code icode = (enum insn_code) DECL_FUNCTION_CODE (fndecl);\n+  tree arg0, arg1, arg2;\n \n   if (ignore)\n-    {\n-      /* Note that a switch statement instead of the sequence of tests would\n-\t be incorrect as many of the CODE_FOR values could be CODE_FOR_nothing\n-\t and that would yield multiple alternatives with identical values.  */\n-      if (icode == CODE_FOR_alignaddrsi_vis\n-\t  || icode == CODE_FOR_alignaddrdi_vis\n-\t  || icode == CODE_FOR_wrgsr_vis\n-\t  || icode == CODE_FOR_bmasksi_vis\n-\t  || icode == CODE_FOR_bmaskdi_vis\n-\t  || icode == CODE_FOR_cmask8si_vis\n-\t  || icode == CODE_FOR_cmask8di_vis\n-\t  || icode == CODE_FOR_cmask16si_vis\n-\t  || icode == CODE_FOR_cmask16di_vis\n-\t  || icode == CODE_FOR_cmask32si_vis\n-\t  || icode == CODE_FOR_cmask32di_vis)\n-\t;\n-      else\n+    switch (code)\n+      {\n+      case SPARC_BUILTIN_LDFSR:\n+      case SPARC_BUILTIN_STFSR:\n+      case SPARC_BUILTIN_ALIGNADDR:\n+      case SPARC_BUILTIN_WRGSR:\n+      case SPARC_BUILTIN_BMASK:\n+      case SPARC_BUILTIN_CMASK8:\n+      case SPARC_BUILTIN_CMASK16:\n+      case SPARC_BUILTIN_CMASK32:\n+\tbreak;\n+\n+      default:\n \treturn build_zero_cst (rtype);\n-    }\n+      }\n \n-  switch (icode)\n+  switch (code)\n     {\n-    case CODE_FOR_fexpand_vis:\n+    case SPARC_BUILTIN_FEXPAND:\n       arg0 = args[0];\n       STRIP_NOPS (arg0);\n \n@@ -10603,9 +10775,9 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t}\n       break;\n \n-    case CODE_FOR_fmul8x16_vis:\n-    case CODE_FOR_fmul8x16au_vis:\n-    case CODE_FOR_fmul8x16al_vis:\n+    case SPARC_BUILTIN_FMUL8X16:\n+    case SPARC_BUILTIN_FMUL8X16AU:\n+    case SPARC_BUILTIN_FMUL8X16AL:\n       arg0 = args[0];\n       arg1 = args[1];\n       STRIP_NOPS (arg0);\n@@ -10615,12 +10787,12 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t{\n \t  tree inner_type = TREE_TYPE (rtype);\n \t  tree *n_elts = XALLOCAVEC (tree, VECTOR_CST_NELTS (arg0));\n-\t  sparc_handle_vis_mul8x16 (n_elts, icode, inner_type, arg0, arg1);\n+\t  sparc_handle_vis_mul8x16 (n_elts, code, inner_type, arg0, arg1);\n \t  return build_vector (rtype, n_elts);\n \t}\n       break;\n \n-    case CODE_FOR_fpmerge_vis:\n+    case SPARC_BUILTIN_FPMERGE:\n       arg0 = args[0];\n       arg1 = args[1];\n       STRIP_NOPS (arg0);\n@@ -10640,13 +10812,19 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t}\n       break;\n \n-    case CODE_FOR_pdist_vis:\n+    case SPARC_BUILTIN_PDIST:\n+    case SPARC_BUILTIN_PDISTN:\n       arg0 = args[0];\n       arg1 = args[1];\n-      arg2 = args[2];\n       STRIP_NOPS (arg0);\n       STRIP_NOPS (arg1);\n-      STRIP_NOPS (arg2);\n+      if (code == SPARC_BUILTIN_PDIST)\n+\t{\n+\t  arg2 = args[2];\n+\t  STRIP_NOPS (arg2);\n+\t}\n+      else\n+\targ2 = integer_zero_node;\n \n       if (TREE_CODE (arg0) == VECTOR_CST\n \t  && TREE_CODE (arg1) == VECTOR_CST\n@@ -12325,9 +12503,106 @@ sparc_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n   return true;\n }\n \n-static enum machine_mode sparc_cstore_mode (enum insn_code icode ATTRIBUTE_UNUSED)\n+/* Implement TARGET_CSTORE_MODE.  */\n+\n+static enum machine_mode\n+sparc_cstore_mode (enum insn_code icode ATTRIBUTE_UNUSED)\n {\n   return (TARGET_ARCH64 ? DImode : SImode);\n }\n \n+/* Return the compound expression made of T1 and T2.  */\n+\n+static inline tree\n+compound_expr (tree t1, tree t2)\n+{\n+  return build2 (COMPOUND_EXPR, void_type_node, t1, t2);\n+}\n+\n+/* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV hook.  */\n+\n+static void\n+sparc_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n+{\n+  if (!TARGET_FPU)\n+    return;\n+\n+  const unsigned HOST_WIDE_INT accrued_exception_mask = 0x1f << 5;\n+  const unsigned HOST_WIDE_INT trap_enable_mask = 0x1f << 23;\n+\n+  /* We generate the equivalent of feholdexcept (&fenv_var):\n+\n+       unsigned int fenv_var;\n+       __builtin_store_fsr (&fenv_var);\n+\n+       unsigned int tmp1_var;\n+       tmp1_var = fenv_var & ~(accrued_exception_mask | trap_enable_mask);\n+\n+       __builtin_load_fsr (&tmp1_var);  */\n+\n+  tree fenv_var = create_tmp_var (unsigned_type_node, NULL);\n+  mark_addressable (fenv_var);\n+  tree fenv_addr = build_fold_addr_expr (fenv_var);\n+  tree stfsr = sparc_builtins[SPARC_BUILTIN_STFSR];\n+  tree hold_stfsr = build_call_expr (stfsr, 1, fenv_addr);\n+\n+  tree tmp1_var = create_tmp_var (unsigned_type_node, NULL);\n+  mark_addressable (tmp1_var);\n+  tree masked_fenv_var\n+    = build2 (BIT_AND_EXPR, unsigned_type_node, fenv_var,\n+\t      build_int_cst (unsigned_type_node,\n+\t\t\t     ~(accrued_exception_mask | trap_enable_mask)));\n+  tree hold_mask\n+    = build2 (MODIFY_EXPR, void_type_node, tmp1_var, masked_fenv_var);\n+\n+  tree tmp1_addr = build_fold_addr_expr (tmp1_var);\n+  tree ldfsr = sparc_builtins[SPARC_BUILTIN_LDFSR];\n+  tree hold_ldfsr = build_call_expr (ldfsr, 1, tmp1_addr);\n+\n+  *hold = compound_expr (compound_expr (hold_stfsr, hold_mask), hold_ldfsr);\n+\n+  /* We reload the value of tmp1_var to clear the exceptions:\n+\n+       __builtin_load_fsr (&tmp1_var);  */\n+\n+  *clear = build_call_expr (ldfsr, 1, tmp1_addr);\n+\n+  /* We generate the equivalent of feupdateenv (&fenv_var):\n+\n+       unsigned int tmp2_var;\n+       __builtin_store_fsr (&tmp2_var);\n+\n+       __builtin_load_fsr (&fenv_var);\n+\n+       if (SPARC_LOW_FE_EXCEPT_VALUES)\n+         tmp2_var >>= 5;\n+       __atomic_feraiseexcept ((int) tmp2_var);  */\n+\n+  tree tmp2_var = create_tmp_var (unsigned_type_node, NULL);\n+  mark_addressable (tmp2_var);\n+  tree tmp3_addr = build_fold_addr_expr (tmp2_var);\n+  tree update_stfsr = build_call_expr (stfsr, 1, tmp3_addr);\n+\n+  tree update_ldfsr = build_call_expr (ldfsr, 1, fenv_addr);\n+\n+  tree atomic_feraiseexcept\n+    = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);\n+  tree update_call\n+    = build_call_expr (atomic_feraiseexcept, 1,\n+\t\t       fold_convert (integer_type_node, tmp2_var));\n+\n+  if (SPARC_LOW_FE_EXCEPT_VALUES)\n+    {\n+      tree shifted_tmp2_var\n+\t= build2 (RSHIFT_EXPR, unsigned_type_node, tmp2_var,\n+\t\t  build_int_cst (unsigned_type_node, 5));\n+      tree update_shift\n+\t= build2 (MODIFY_EXPR, void_type_node, tmp2_var, shifted_tmp2_var);\n+      update_call = compound_expr (update_shift, update_call);\n+    }\n+\n+  *update\n+    = compound_expr (compound_expr (update_stfsr, update_ldfsr), update_call);\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "7533e88491b2bf5c883cc5f5f48045be6b60546c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -1777,3 +1777,6 @@ extern int sparc_indent_opcode;\n #ifndef SUBTARGET_DEFAULT_MEMORY_MODEL\n #define SUBTARGET_DEFAULT_MEMORY_MODEL\tSMM_DEFAULT\n #endif\n+\n+/* Define this to 1 if the FE_EXCEPT values defined in fenv.h start at 1.  */\n+#define SPARC_LOW_FE_EXCEPT_VALUES 0"}, {"sha": "b3fb2eb18fb6eb1925ce2555f2d6e77c023d7413", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -96,13 +96,19 @@\n \n (define_c_enum \"unspecv\" [\n   UNSPECV_BLOCKAGE\n+  UNSPECV_PROBE_STACK_RANGE\n+\n   UNSPECV_FLUSHW\n-  UNSPECV_FLUSH\n   UNSPECV_SAVEW\n-  UNSPECV_CAS\n-  UNSPECV_SWAP\n+\n+  UNSPECV_FLUSH\n+\n   UNSPECV_LDSTUB\n-  UNSPECV_PROBE_STACK_RANGE\n+  UNSPECV_SWAP\n+  UNSPECV_CAS\n+\n+  UNSPECV_LDFSR\n+  UNSPECV_STFSR\n ])\n \n (define_constants\n@@ -6783,22 +6789,26 @@\n \n ;; Special pattern for the FLUSH instruction.\n \n-; We do SImode and DImode versions of this to quiet down genrecog's complaints\n-; of the define_insn otherwise missing a mode.  We make \"flush\", aka\n-; gen_flush, the default one since sparc_initialize_trampoline uses\n-; it on SImode mem values.\n-\n-(define_insn \"flush\"\n-  [(unspec_volatile [(match_operand:SI 0 \"memory_operand\" \"m\")] UNSPECV_FLUSH)]\n+(define_insn \"flush<P:mode>\"\n+  [(unspec_volatile [(match_operand:P 0 \"memory_operand\" \"m\")] UNSPECV_FLUSH)]\n   \"\"\n   { return TARGET_V9 ? \"flush\\t%f0\" : \"iflush\\t%f0\"; }\n   [(set_attr \"type\" \"iflush\")])\n \n-(define_insn \"flushdi\"\n-  [(unspec_volatile [(match_operand:DI 0 \"memory_operand\" \"m\")] UNSPECV_FLUSH)]\n-  \"\"\n-  { return TARGET_V9 ? \"flush\\t%f0\" : \"iflush\\t%f0\"; }\n-  [(set_attr \"type\" \"iflush\")])\n+;; Special insns to load and store the 32-bit FP Status Register.\n+\n+(define_insn \"ldfsr\"\n+  [(unspec_volatile [(match_operand:SI 0 \"memory_operand\" \"m\")] UNSPECV_LDFSR)]\n+  \"TARGET_FPU\"\n+  \"ld\\t%0, %%fsr\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"stfsr\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+        (unspec_volatile:SI [(const_int 0)] UNSPECV_STFSR))]\n+  \"TARGET_FPU\"\n+  \"st\\t%%fsr, %0\"\n+  [(set_attr \"type\" \"store\")])\n \n \n ;; Find first set instructions."}, {"sha": "c47187d351dd206d2c9d2826f9b6b4c9474c51a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -1,3 +1,8 @@\n+2013-12-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/pdistn.c: New test.\n+\t* gcc.target/sparc/pdistn-2.c: Likewise.\n+\n 2013-12-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59058"}, {"sha": "008496f9ae746edc550f895918e561408298e111", "filename": "gcc/testsuite/gcc.target/sparc/pdistn-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fpdistn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fpdistn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fpdistn-2.c?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis3 -O1 -fdump-tree-optimized\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+\n+#define _(A) (unsigned char)A\n+\n+long foo () {\n+  vec8 a = { _(1), _(2), _(3), _(4), _(5), _(6), _(7), _(255) };\n+  vec8 b = { _(2), _(4), _(8), _(16), _(32), _(64), _(128), _(8) };\n+  return __builtin_vis_pdistn (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-not \"pdistn\\t%\" } } */\n+/* { dg-final { scan-tree-dump \"return 473\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "2f534f70b7d0dff1acccfb4be93e8f2450ad9116", "filename": "gcc/testsuite/gcc.target/sparc/pdistn.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fpdistn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde66fde162b08a98b5fe66be20704a8e82784ac/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fpdistn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fpdistn.c?ref=fde66fde162b08a98b5fe66be20704a8e82784ac", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis3\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+\n+long foo (vec8 a, vec8 b) {\n+  return __builtin_vis_pdistn (a, b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"pdistn\\t%\" 1 } } */"}]}