{"sha": "892a981f1efb398768ad5a138fb7c971462d1e79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkyYTk4MWYxZWZiMzk4NzY4YWQ1YTEzOGZiN2M5NzE0NjJkMWU3OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-07-06T08:11:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-07-06T08:11:31Z"}, "message": "[2/7] Clean up vectorizer load/store costs\n\nAdd a bit more commentary and try to make the structure more obvious.\nThe horrendous:\n\n      if (grouped_access_p\n          && represents_group_p\n          && !store_lanes_p\n          && !STMT_VINFO_STRIDED_P (stmt_info)\n          && !slp_node)\n\nchecks go away in patch 6.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* tree-vect-stmts.c (vect_cost_group_size): Delete.\n\t(vect_model_store_cost): Avoid calling it.  Use first_stmt_p\n\tvariable to indicate when once-per-group costs are being used.\n\t(vect_model_load_cost): Likewise.  Fix comment and misindented code.\n\nFrom-SVN: r238034", "tree": {"sha": "1f91e7c6c78093e4eabfdff3d368482457806d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f91e7c6c78093e4eabfdff3d368482457806d98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/892a981f1efb398768ad5a138fb7c971462d1e79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892a981f1efb398768ad5a138fb7c971462d1e79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/892a981f1efb398768ad5a138fb7c971462d1e79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892a981f1efb398768ad5a138fb7c971462d1e79/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01e092fb3a8fb91602b54d8b5f10cc23c27089c"}], "stats": {"total": 126, "additions": 57, "deletions": 69}, "files": [{"sha": "408f4af44a2256c4a8e52054ad1b25cac4136caa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892a981f1efb398768ad5a138fb7c971462d1e79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892a981f1efb398768ad5a138fb7c971462d1e79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=892a981f1efb398768ad5a138fb7c971462d1e79", "patch": "@@ -1,3 +1,10 @@\n+2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-stmts.c (vect_cost_group_size): Delete.\n+\t(vect_model_store_cost): Avoid calling it.  Use first_stmt_p\n+\tvariable to indicate when once-per-group costs are being used.\n+\t(vect_model_load_cost): Likewise.  Fix comment and misindented code.\n+\n 2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (vectorizable_load): Remove unnecessary"}, {"sha": "aff0cc6851fd7f275eebeb0f5a551e696cda58e0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 50, "deletions": 69, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892a981f1efb398768ad5a138fb7c971462d1e79/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892a981f1efb398768ad5a138fb7c971462d1e79/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=892a981f1efb398768ad5a138fb7c971462d1e79", "patch": "@@ -865,24 +865,6 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n                      \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n-/* Function vect_cost_group_size\n-\n-   For grouped load or store, return the group_size only if it is the first\n-   load or store of a group, else return 1.  This ensures that group size is\n-   only returned once per group.  */\n-\n-static int\n-vect_cost_group_size (stmt_vec_info stmt_info)\n-{\n-  gimple *first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-\n-  if (first_stmt == STMT_VINFO_STMT (stmt_info))\n-    return GROUP_SIZE (stmt_info);\n-\n-  return 1;\n-}\n-\n-\n /* Function vect_model_store_cost\n \n    Models cost for stores.  In the case of grouped accesses, one access\n@@ -895,47 +877,43 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t       stmt_vector_for_cost *prologue_cost_vec,\n \t\t       stmt_vector_for_cost *body_cost_vec)\n {\n-  int group_size;\n   unsigned int inside_cost = 0, prologue_cost = 0;\n-  struct data_reference *first_dr;\n-  gimple *first_stmt;\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n+  bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n   if (dt == vect_constant_def || dt == vect_external_def)\n     prologue_cost += record_stmt_cost (prologue_cost_vec, 1, scalar_to_vec,\n \t\t\t\t       stmt_info, 0, vect_prologue);\n \n-  /* Grouped access?  */\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+  /* Grouped stores update all elements in the group at once,\n+     so we want the DR for the first statement.  */\n+  if (!slp_node && grouped_access_p)\n     {\n-      if (slp_node)\n-        {\n-          first_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n-          group_size = 1;\n-        }\n-      else\n-        {\n-          first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-          group_size = vect_cost_group_size (stmt_info);\n-        }\n-\n-      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-    }\n-  /* Not a grouped access.  */\n-  else\n-    {\n-      group_size = 1;\n-      first_dr = STMT_VINFO_DATA_REF (stmt_info);\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n     }\n \n+  /* True if we should include any once-per-group costs as well as\n+     the cost of the statement itself.  For SLP we only get called\n+     once per group anyhow.  */\n+  bool first_stmt_p = (first_stmt == STMT_VINFO_STMT (stmt_info));\n+\n   /* We assume that the cost of a single store-lanes instruction is\n      equivalent to the cost of GROUP_SIZE separate stores.  If a grouped\n      access is instead being provided by a permute-and-store operation,\n-     include the cost of the permutes.  */\n-  if (!store_lanes_p && group_size > 1\n-      && !STMT_VINFO_STRIDED_P (stmt_info))\n+     include the cost of the permutes.\n+\n+     For SLP, the caller has already counted the permutation, if any.  */\n+  if (grouped_access_p\n+      && first_stmt_p\n+      && !store_lanes_p\n+      && !STMT_VINFO_STRIDED_P (stmt_info)\n+      && !slp_node)\n     {\n       /* Uses a high and low interleave or shuffle operations for each\n \t needed permute.  */\n+      int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n@@ -957,7 +935,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n     }\n   else\n-    vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n+    vect_get_store_cost (dr, ncopies, &inside_cost, body_cost_vec);\n \n   if (STMT_VINFO_STRIDED_P (stmt_info))\n     inside_cost += record_stmt_cost (body_cost_vec,\n@@ -1026,8 +1004,8 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \n /* Function vect_model_load_cost\n \n-   Models cost for loads.  In the case of grouped accesses, the last access\n-   has the overhead of the grouped access attributed to it.  Since unaligned\n+   Models cost for loads.  In the case of grouped accesses, one access has\n+   the overhead of the grouped access attributed to it.  Since unaligned\n    accesses are supported for loads, we also account for the costs of the\n    access scheme chosen.  */\n \n@@ -1037,34 +1015,39 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t      stmt_vector_for_cost *prologue_cost_vec,\n \t\t      stmt_vector_for_cost *body_cost_vec)\n {\n-  int group_size;\n-  gimple *first_stmt;\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n+  gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   unsigned int inside_cost = 0, prologue_cost = 0;\n+  bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n-  /* Grouped accesses?  */\n-  first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info) && first_stmt && !slp_node)\n+  /* Grouped loads read all elements in the group at once,\n+     so we want the DR for the first statement.  */\n+  if (!slp_node && grouped_access_p)\n     {\n-      group_size = vect_cost_group_size (stmt_info);\n-      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-    }\n-  /* Not a grouped access.  */\n-  else\n-    {\n-      group_size = 1;\n-      first_dr = dr;\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n     }\n \n+  /* True if we should include any once-per-group costs as well as\n+     the cost of the statement itself.  For SLP we only get called\n+     once per group anyhow.  */\n+  bool first_stmt_p = (first_stmt == STMT_VINFO_STMT (stmt_info));\n+\n   /* We assume that the cost of a single load-lanes instruction is\n      equivalent to the cost of GROUP_SIZE separate loads.  If a grouped\n      access is instead being provided by a load-and-permute operation,\n-     include the cost of the permutes.  */\n-  if (!load_lanes_p && group_size > 1\n-      && !STMT_VINFO_STRIDED_P (stmt_info))\n+     include the cost of the permutes.\n+\n+     For SLP, the caller has already counted the permutation, if any.  */\n+  if (grouped_access_p\n+      && first_stmt_p\n+      && !load_lanes_p\n+      && !STMT_VINFO_STRIDED_P (stmt_info)\n+      && !slp_node)\n     {\n       /* Uses an even and odd extract operations or shuffle operations\n \t for each needed permute.  */\n+      int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n@@ -1086,14 +1069,12 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t\t       scalar_load, stmt_info, 0, vect_body);\n     }\n   else\n-    vect_get_load_cost (first_dr, ncopies,\n-\t\t\t((!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t\t\t || group_size > 1 || slp_node),\n+    vect_get_load_cost (dr, ncopies, first_stmt_p,\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tprologue_cost_vec, body_cost_vec, true);\n   if (STMT_VINFO_STRIDED_P (stmt_info))\n-      inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_construct,\n-\t\t\t\t       stmt_info, 0, vect_body);\n+    inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_construct,\n+\t\t\t\t     stmt_info, 0, vect_body);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,"}]}