{"sha": "f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjliZjVhOGU5NmVjOWM2ZjA0ODc3YTBjNDkyMjIwMWQ4MGI4MGE2ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-08-11T08:25:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-08-11T08:25:41Z"}, "message": "md.texi (define_bypass): Say that the instruction names can be filename-style globs.\n\ngcc/\n\t* doc/md.texi (define_bypass): Say that the instruction names can\n\tbe filename-style globs.\n\t* Makefile.in (FNMATCH_H): Define.\n\t(build/genattrtab.o, build/genautomata.o): Depend on $(FNMATCH_H).\n\t* genattrtab.c: Include fnmatch.h.\n\t(bypass_list): Change field name from \"insn\" to \"pattern\".\n\t(gen_bypass_1): Update accordingly.\n\t(process_bypasses): Use fnmatch to check for matches between\n\tinsn reservations and define_bypasses.\n\t* genautomata.c: Include fnmatch.h.\n\t(bypass_decl): Rename in_insn_name and out_insn_name to in_pattern\n\tand out_pattern respectively.\n\t(gen_bypass, insert_bypass): Update accordingly.\n\t(for_each_matching_insn, process_bypass_2, process_bypass_1)\n\t(process_bypass): New functions.\n\t(process_decls): Use process_bypass.  Update after field name changes.\n\nFrom-SVN: r177649", "tree": {"sha": "fcc79dff36759b0668e8d8f0629a52b95e1330eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcc79dff36759b0668e8d8f0629a52b95e1330eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/comments", "author": null, "committer": null, "parents": [{"sha": "7ece388150bbbfb0c946b28efa43ad1eeb2f0bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ece388150bbbfb0c946b28efa43ad1eeb2f0bf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ece388150bbbfb0c946b28efa43ad1eeb2f0bf8"}], "stats": {"total": 189, "additions": 143, "deletions": 46}, "files": [{"sha": "3b84e8bfe699890e323cf0913f57119cbf9f9c6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "patch": "@@ -1,3 +1,22 @@\n+2011-08-11  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/md.texi (define_bypass): Say that the instruction names can\n+\tbe filename-style globs.\n+\t* Makefile.in (FNMATCH_H): Define.\n+\t(build/genattrtab.o, build/genautomata.o): Depend on $(FNMATCH_H).\n+\t* genattrtab.c: Include fnmatch.h.\n+\t(bypass_list): Change field name from \"insn\" to \"pattern\".\n+\t(gen_bypass_1): Update accordingly.\n+\t(process_bypasses): Use fnmatch to check for matches between\n+\tinsn reservations and define_bypasses.\n+\t* genautomata.c: Include fnmatch.h.\n+\t(bypass_decl): Rename in_insn_name and out_insn_name to in_pattern\n+\tand out_pattern respectively.\n+\t(gen_bypass, insert_bypass): Update accordingly.\n+\t(for_each_matching_insn, process_bypass_2, process_bypass_1)\n+\t(process_bypass): New functions.\n+\t(process_decls): Use process_bypass.  Update after field name changes.\n+\n 2011-08-11  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \tPR target/49687"}, {"sha": "b0874bcac6443b4817c449149f6811ea4c566867", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "patch": "@@ -444,6 +444,7 @@ PARTITION_H = $(srcdir)/../include/partition.h\n MD5_H\t    = $(srcdir)/../include/md5.h\n DWARF2_H    = $(srcdir)/../include/dwarf2.h\n XREGEX_H    =  $(srcdir)/../include/xregex.h\n+FNMATCH_H   = $(srcdir)/../include/fnmatch.h\n \n # Linker plugin API headers\n LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n@@ -3939,10 +3940,10 @@ build/genattr-common.o : genattr-common.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n-  $(READ_MD_H) gensupport.h vecprim.h\n+  $(READ_MD_H) gensupport.h vecprim.h $(FNMATCH_H)\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VEC_H)\t\\\n-  $(HASHTAB_H) gensupport.h\n+  $(HASHTAB_H) gensupport.h $(FNMATCH_H)\n build/gencheck.o : gencheck.c all-tree.def $(BCONFIG_H) $(GTM_H)\t\\\n \t$(SYSTEM_H) coretypes.h $(lang_tree_files) gimple.def\n build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)"}, {"sha": "49dfda9db6c0526e91ff19b87b96f231d5a60af1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "patch": "@@ -7783,8 +7783,16 @@ latency time for given instruction pair.  This is so called bypasses.\n \n @var{number} defines when the result generated by the instructions\n given in string @var{out_insn_names} will be ready for the\n-instructions given in string @var{in_insn_names}.  The instructions in\n-the string are separated by commas.\n+instructions given in string @var{in_insn_names}.  Each of these\n+strings is a comma-separated list of filename-style globs and\n+they refer to the names of @code{define_insn_reservation}s.\n+For example:\n+@smallexample\n+(define_bypass 1 \"cpu1_load_*, cpu1_store_*\" \"cpu1_load_*\")\n+@end smallexample\n+defines a bypass between instructions that start with\n+@samp{cpu1_load_} or @samp{cpu1_store_} and those that start with\n+@samp{cpu1_load_}.\n \n @var{guard} is an optional string giving the name of a C function which\n defines an additional guard for the bypass.  The function will get the"}, {"sha": "a3da97868a99d5ae4efe9119d16295e492891fd7", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "patch": "@@ -114,6 +114,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"read-md.h\"\n #include \"gensupport.h\"\n #include \"vecprim.h\"\n+#include \"fnmatch.h\"\n \n /* Flags for make_internal_attr's `special' parameter.  */\n #define ATTR_NONE\t\t0\n@@ -4553,7 +4554,7 @@ gen_insn_reserv (rtx def)\n struct bypass_list\n {\n   struct bypass_list *next;\n-  const char *insn;\n+  const char *pattern;\n };\n \n static struct bypass_list *all_bypasses;\n@@ -4569,11 +4570,11 @@ gen_bypass_1 (const char *s, size_t len)\n \n   s = attr_string (s, len);\n   for (b = all_bypasses; b; b = b->next)\n-    if (s == b->insn)\n+    if (s == b->pattern)\n       return;  /* already got that one */\n \n   b = oballoc (struct bypass_list);\n-  b->insn = s;\n+  b->pattern = s;\n   b->next = all_bypasses;\n   all_bypasses = b;\n   n_bypasses++;\n@@ -4607,7 +4608,7 @@ process_bypasses (void)\n      list.  */\n   for (r = all_insn_reservs; r; r = r->next)\n     for (b = all_bypasses; b; b = b->next)\n-      if (r->name == b->insn)\n+      if (fnmatch (b->pattern, r->name, 0) == 0)\n \tr->bypassed = true;\n }\n "}, {"sha": "e5260fa3c3d9ff0f9daf9690318150e264b09401", "filename": "gcc/genautomata.c", "status": "modified", "additions": 106, "deletions": 38, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=f9bf5a8e96ec9c6f04877a0c4922201d80b80a6e", "patch": "@@ -117,6 +117,7 @@ along with GCC; see the file COPYING3.  If not see\n #include <math.h>\n #include \"hashtab.h\"\n #include \"vec.h\"\n+#include \"fnmatch.h\"\n \n #ifndef CHAR_BIT\n #define CHAR_BIT 8\n@@ -384,8 +385,8 @@ struct unit_decl\n struct bypass_decl\n {\n   int latency;\n-  const char *out_insn_name;\n-  const char *in_insn_name;\n+  const char *out_pattern;\n+  const char *in_pattern;\n   const char *bypass_guard_name;\n \n   /* The following fields are defined by checker.  */\n@@ -1306,17 +1307,17 @@ static void\n gen_bypass (rtx def)\n {\n   decl_t decl;\n-  char **out_insns;\n+  char **out_patterns;\n   int out_length;\n-  char **in_insns;\n+  char **in_patterns;\n   int in_length;\n   int i, j;\n \n-  out_insns = get_str_vect (XSTR (def, 1), &out_length, ',', FALSE);\n-  if (out_insns == NULL)\n+  out_patterns = get_str_vect (XSTR (def, 1), &out_length, ',', FALSE);\n+  if (out_patterns == NULL)\n     fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 1));\n-  in_insns = get_str_vect (XSTR (def, 2), &in_length, ',', FALSE);\n-  if (in_insns == NULL)\n+  in_patterns = get_str_vect (XSTR (def, 2), &in_length, ',', FALSE);\n+  if (in_patterns == NULL)\n     fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 2));\n   for (i = 0; i < out_length; i++)\n     for (j = 0; j < in_length; j++)\n@@ -1325,8 +1326,8 @@ gen_bypass (rtx def)\n \tdecl->mode = dm_bypass;\n \tdecl->pos = 0;\n \tDECL_BYPASS (decl)->latency = XINT (def, 0);\n-\tDECL_BYPASS (decl)->out_insn_name = out_insns [i];\n-\tDECL_BYPASS (decl)->in_insn_name = in_insns [j];\n+\tDECL_BYPASS (decl)->out_pattern = out_patterns[i];\n+\tDECL_BYPASS (decl)->in_pattern = in_patterns[j];\n \tDECL_BYPASS (decl)->bypass_guard_name = XSTR (def, 3);\n \tVEC_safe_push (decl_t, heap, decls, decl);\n       }\n@@ -2397,19 +2398,19 @@ insert_bypass (struct bypass_decl *bypass)\n \t      {\n \t\tif (!w_flag)\n \t\t  error (\"the same bypass `%s - %s' is already defined\",\n-\t\t\t bypass->out_insn_name, bypass->in_insn_name);\n+\t\t\t bypass->out_pattern, bypass->in_pattern);\n \t\telse\n \t\t  warning (\"the same bypass `%s - %s' is already defined\",\n-\t\t\t   bypass->out_insn_name, bypass->in_insn_name);\n+\t\t\t   bypass->out_pattern, bypass->in_pattern);\n \t      }\n \t    else if (!w_flag)\n \t      error (\"the same bypass `%s - %s' (guard %s) is already defined\",\n-\t\t     bypass->out_insn_name, bypass->in_insn_name,\n+\t\t     bypass->out_pattern, bypass->in_pattern,\n \t\t     bypass->bypass_guard_name);\n \t    else\n \t      warning\n \t\t(\"the same bypass `%s - %s' (guard %s) is already defined\",\n-\t\t bypass->out_insn_name, bypass->in_insn_name,\n+\t\t bypass->out_pattern, bypass->in_pattern,\n \t\t bypass->bypass_guard_name);\n \t    return;\n \t  }\n@@ -2434,6 +2435,92 @@ insert_bypass (struct bypass_decl *bypass)\n     }\n }\n \n+/* BYPASS is a define_bypass decl that includes glob pattern PATTERN.\n+   Call FN (BYPASS, INSN, DATA) for each matching instruction INSN.  */\n+\n+static void\n+for_each_matching_insn (decl_t bypass, const char *pattern,\n+\t\t\tvoid (*fn) (decl_t, decl_t, void *), void *data)\n+{\n+  decl_t insn_reserv;\n+  bool matched_p;\n+  int i;\n+\n+  matched_p = false;\n+  if (strpbrk (pattern, \"*?[\"))\n+    for (i = 0; i < description->decls_num; i++)\n+      {\n+\tinsn_reserv = description->decls[i];\n+\tif (insn_reserv->mode == dm_insn_reserv\n+\t    && fnmatch (pattern, DECL_INSN_RESERV (insn_reserv)->name, 0) == 0)\n+\t  {\n+\t    fn (bypass, insn_reserv, data);\n+\t    matched_p = true;\n+\t  }\n+      }\n+  else\n+    {\n+      insn_reserv = find_insn_decl (pattern);\n+      if (insn_reserv)\n+\t{\n+\t  fn (bypass, insn_reserv, data);\n+\t  matched_p = true;\n+\t}\n+    }\n+  if (!matched_p)\n+    error (\"there is no insn reservation that matches `%s'\", pattern);\n+}\n+\n+/* A subroutine of process_bypass that is called for each pair\n+   of matching instructions.  OUT_INSN_RESERV is the output\n+   instruction and DATA is the input instruction.  */\n+\n+static void\n+process_bypass_2 (decl_t model, decl_t out_insn_reserv, void *data)\n+{\n+  struct bypass_decl *bypass;\n+  decl_t in_insn_reserv;\n+\n+  in_insn_reserv = (decl_t) data;\n+  if (strcmp (DECL_INSN_RESERV (in_insn_reserv)->name,\n+\t      DECL_BYPASS (model)->in_pattern) == 0\n+      && strcmp (DECL_INSN_RESERV (out_insn_reserv)->name,\n+\t\t DECL_BYPASS (model)->out_pattern) == 0)\n+    bypass = DECL_BYPASS (model);\n+  else\n+    {\n+      bypass = XCNEW (struct bypass_decl);\n+      bypass->latency = DECL_BYPASS (model)->latency;\n+      bypass->out_pattern = DECL_INSN_RESERV (out_insn_reserv)->name;\n+      bypass->in_pattern = DECL_INSN_RESERV (in_insn_reserv)->name;\n+      bypass->bypass_guard_name = DECL_BYPASS (model)->bypass_guard_name;\n+    }\n+  bypass->out_insn_reserv = DECL_INSN_RESERV (out_insn_reserv);\n+  bypass->in_insn_reserv = DECL_INSN_RESERV (in_insn_reserv);\n+  insert_bypass (bypass);\n+}\n+\n+/* A subroutine of process_bypass that is called for each input\n+   instruction IN_INSN_RESERV.  */\n+\n+static void\n+process_bypass_1 (decl_t bypass, decl_t in_insn_reserv,\n+\t\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  for_each_matching_insn (bypass, DECL_BYPASS (bypass)->out_pattern,\n+\t\t\t  process_bypass_2, in_insn_reserv);\n+}\n+\n+/* Process define_bypass decl BYPASS, inserting a bypass for each specific\n+   pair of insn reservations.  */\n+\n+static void\n+process_bypass (decl_t bypass)\n+{\n+  for_each_matching_insn (bypass, DECL_BYPASS (bypass)->in_pattern,\n+\t\t\t  process_bypass_1, NULL);\n+}\n+\n /* The function processes pipeline description declarations, checks\n    their correctness, and forms exclusion/presence/absence sets.  */\n static void\n@@ -2442,8 +2529,6 @@ process_decls (void)\n   decl_t decl;\n   decl_t automaton_decl;\n   decl_t decl_in_table;\n-  decl_t out_insn_reserv;\n-  decl_t in_insn_reserv;\n   int automaton_presence;\n   int i;\n \n@@ -2489,8 +2574,8 @@ process_decls (void)\n \t{\n \t  if (DECL_BYPASS (decl)->latency < 0)\n \t    error (\"define_bypass `%s - %s' has negative latency time\",\n-\t\t   DECL_BYPASS (decl)->out_insn_name,\n-\t\t   DECL_BYPASS (decl)->in_insn_name);\n+\t\t   DECL_BYPASS (decl)->out_pattern,\n+\t\t   DECL_BYPASS (decl)->in_pattern);\n \t}\n       else if (decl->mode == dm_unit || decl->mode == dm_reserv)\n \t{\n@@ -2551,24 +2636,7 @@ process_decls (void)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_bypass)\n-\t{\n-\t  out_insn_reserv = find_insn_decl (DECL_BYPASS (decl)->out_insn_name);\n-\t  in_insn_reserv = find_insn_decl (DECL_BYPASS (decl)->in_insn_name);\n-\t  if (out_insn_reserv == NULL)\n-\t    error (\"there is no insn reservation `%s'\",\n-\t\t   DECL_BYPASS (decl)->out_insn_name);\n-\t  else if (in_insn_reserv == NULL)\n-\t    error (\"there is no insn reservation `%s'\",\n-\t\t   DECL_BYPASS (decl)->in_insn_name);\n-\t  else\n-\t    {\n-\t      DECL_BYPASS (decl)->out_insn_reserv\n-\t\t= DECL_INSN_RESERV (out_insn_reserv);\n-\t      DECL_BYPASS (decl)->in_insn_reserv\n-\t\t= DECL_INSN_RESERV (in_insn_reserv);\n-\t      insert_bypass (DECL_BYPASS (decl));\n-\t    }\n-\t}\n+\tprocess_bypass (decl);\n     }\n \n   /* Check exclusion set declarations and form exclusion sets.  */\n@@ -8757,8 +8825,8 @@ output_description (void)\n       else if (decl->mode == dm_bypass)\n \tfprintf (output_description_file, \"bypass %d %s %s\\n\",\n \t\t DECL_BYPASS (decl)->latency,\n-\t\t DECL_BYPASS (decl)->out_insn_name,\n-\t\t DECL_BYPASS (decl)->in_insn_name);\n+\t\t DECL_BYPASS (decl)->out_pattern,\n+\t\t DECL_BYPASS (decl)->in_pattern);\n     }\n   fprintf (output_description_file, \"\\n\\f\\n\");\n }"}]}