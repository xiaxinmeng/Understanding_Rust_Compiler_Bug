{"sha": "2f133f4681a88304902476384965eb214ddf7a9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYxMzNmNDY4MWE4ODMwNDkwMjQ3NjM4NDk2NWViMjE0ZGRmN2E5ZA==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-08-09T04:24:56Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-08-09T04:24:56Z"}, "message": "tree-ssa-loop-niter.c (tree_simplify_using_condition_1): Use fold_binary instead of fold_build2 since we don't care about the resulting tree.\n\n2005-08-09  James A. Morrison  <phython@gcc.gnu.org>\n\n        * tree-ssa-loop-niter.c (tree_simplify_using_condition_1): Use\n        fold_binary instead of fold_build2 since we don't care about the\n        resulting tree.\n        (loop_niter_by_eval): Likewise.\n        (compare_trees): Likewise.\n        (proved_non_wrapping_p): Likewise.\n\nFrom-SVN: r102897", "tree": {"sha": "fbfcd859174fdbaed058790f4ba71524cea74b2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbfcd859174fdbaed058790f4ba71524cea74b2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f133f4681a88304902476384965eb214ddf7a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f133f4681a88304902476384965eb214ddf7a9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f133f4681a88304902476384965eb214ddf7a9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f133f4681a88304902476384965eb214ddf7a9d/comments", "author": null, "committer": null, "parents": [{"sha": "f14e694e82ff0a1aff4a9b8da707fda2209fded7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14e694e82ff0a1aff4a9b8da707fda2209fded7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f14e694e82ff0a1aff4a9b8da707fda2209fded7"}], "stats": {"total": 35, "additions": 23, "deletions": 12}, "files": [{"sha": "7e11985e56b287dbbfb49856c04bc8e166f7ec4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f133f4681a88304902476384965eb214ddf7a9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f133f4681a88304902476384965eb214ddf7a9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f133f4681a88304902476384965eb214ddf7a9d", "patch": "@@ -1,3 +1,12 @@\n+2005-08-09  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* tree-ssa-loop-niter.c (tree_simplify_using_condition_1): Use\n+\tfold_binary instead of fold_build2 since we don't care about the\n+\tresulting tree.\n+\t(loop_niter_by_eval): Likewise.\n+\t(compare_trees): Likewise.\n+\t(proved_non_wrapping_p): Likewise.\n+\n 2005-08-09  James A. Morrison  <phython@gcc.gnu.org>\n \n \tPR c/23161"}, {"sha": "21dc9eca8ae048255cc201a9072f422e1827f9fc", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f133f4681a88304902476384965eb214ddf7a9d/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f133f4681a88304902476384965eb214ddf7a9d/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=2f133f4681a88304902476384965eb214ddf7a9d", "patch": "@@ -778,13 +778,13 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n \n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n-  e = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, notcond, te);\n+  e = fold_binary (TRUTH_OR_EXPR, boolean_type_node, notcond, te);\n   if (nonzero_p (e))\n     return e;\n \n   /* Check whether COND ==> not EXPR.  */\n-  e = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond, te);\n-  if (zero_p (e))\n+  e = fold_binary (TRUTH_AND_EXPR, boolean_type_node, cond, te);\n+  if (e && zero_p (e))\n     return e;\n \n   return expr;\n@@ -1296,8 +1296,8 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n       for (j = 0; j < 2; j++)\n \taval[j] = get_val_for (op[j], val[j]);\n \n-      acnd = fold_build2 (cmp, boolean_type_node, aval[0], aval[1]);\n-      if (zero_p (acnd))\n+      acnd = fold_binary (cmp, boolean_type_node, aval[0], aval[1]);\n+      if (acnd && zero_p (acnd))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -1462,11 +1462,11 @@ compare_trees (tree a, tree b)\n   a = fold_convert (type, a);\n   b = fold_convert (type, b);\n \n-  if (nonzero_p (fold_build2 (EQ_EXPR, boolean_type_node, a, b)))\n+  if (nonzero_p (fold_binary (EQ_EXPR, boolean_type_node, a, b)))\n     return 0;\n-  if (nonzero_p (fold_build2 (LT_EXPR, boolean_type_node, a, b)))\n+  if (nonzero_p (fold_binary (LT_EXPR, boolean_type_node, a, b)))\n     return 1;\n-  if (nonzero_p (fold_build2 (GT_EXPR, boolean_type_node, a, b)))\n+  if (nonzero_p (fold_binary (GT_EXPR, boolean_type_node, a, b)))\n     return -1;\n \n   return 2;\n@@ -1530,6 +1530,7 @@ proved_non_wrapping_p (tree at_stmt,\n {\n   tree cond;\n   tree bound = niter_bound->bound;\n+  enum tree_code cmp;\n \n   if (TYPE_PRECISION (new_type) > TYPE_PRECISION (TREE_TYPE (bound)))\n     bound = fold_convert (unsigned_type_for (new_type), bound);\n@@ -1539,18 +1540,19 @@ proved_non_wrapping_p (tree at_stmt,\n   /* After the statement niter_bound->at_stmt we know that anything is\n      executed at most BOUND times.  */\n   if (at_stmt && stmt_dominates_stmt_p (niter_bound->at_stmt, at_stmt))\n-    cond = fold_build2 (GE_EXPR, boolean_type_node, valid_niter, bound);\n-\n+    cmp = GE_EXPR;\n   /* Before the statement niter_bound->at_stmt we know that anything\n      is executed at most BOUND + 1 times.  */\n   else\n-    cond = fold_build2 (GT_EXPR, boolean_type_node, valid_niter, bound);\n+    cmp = GT_EXPR;\n \n+  cond = fold_binary (cmp, boolean_type_node, valid_niter, bound);\n   if (nonzero_p (cond))\n     return true;\n \n+  cond = build2 (cmp, boolean_type_node, valid_niter, bound);\n   /* Try taking additional conditions into account.  */\n-  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+  cond = fold_binary (TRUTH_OR_EXPR, boolean_type_node,\n \t\t      invert_truthvalue (niter_bound->additional),\n \t\t      cond);\n "}]}