{"sha": "66e61a34b5ba3d0748578bb553d9ef15202eee9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlNjFhMzRiNWJhM2QwNzQ4NTc4YmI1NTNkOWVmMTUyMDJlZWU5Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:30:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:30:51Z"}, "message": "cp-tree.h (register_constexpr_fundef): Declare.\n\n\t* cp-tree.h (register_constexpr_fundef): Declare.\n\t* decl.c (maybe_save_function_definition): New.\n\t(finish_function): Use it.\n\t* semantics.c (constexpr_fundef): New datatype.\n\t(constexpr_fundef_table): New global table.\n\t(constexpr_fundef_equal): New.\n\t(constexpr_fundef_hash): Likewise.\n\t(retrieve_constexpr_fundef): Likewise.\n\t(validate_constexpr_fundecl): Store in the table.\n\t(build_data_member_initialization): New fn.\n\t(build_constexpr_constructor_member_initializers): New.\n\t(register_constexpr_fundef): Define.\n\t(is_this_parameter): New.\n\t(get_function_named_in_call): Likewise.\n\t(get_nth_callarg): Likewise.\n\t(check_automatic_or_tls): New.\n\t(morally_constexpr_builtin_function_p): New.\n\t(potential_constant_expression): New.\n\nFrom-SVN: r166165", "tree": {"sha": "cee12743618f7b54280bbe28abf0374e6e46b7e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cee12743618f7b54280bbe28abf0374e6e46b7e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66e61a34b5ba3d0748578bb553d9ef15202eee9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e61a34b5ba3d0748578bb553d9ef15202eee9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e61a34b5ba3d0748578bb553d9ef15202eee9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e61a34b5ba3d0748578bb553d9ef15202eee9f/comments", "author": null, "committer": null, "parents": [{"sha": "aef4a21519866e460d2baa161a402164af67547d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef4a21519866e460d2baa161a402164af67547d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef4a21519866e460d2baa161a402164af67547d"}], "stats": {"total": 781, "additions": 781, "deletions": 0}, "files": [{"sha": "f790525f1c68a295a364f9ee6ef90fdfafa3dc51", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=66e61a34b5ba3d0748578bb553d9ef15202eee9f", "patch": "@@ -1,3 +1,25 @@\n+2010-11-01  Gabriel Dos Reis  <gdr@cse.tamu.edu>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-tree.h (register_constexpr_fundef): Declare.\n+\t* decl.c (maybe_save_function_definition): New.\n+\t(finish_function): Use it.\n+\t* semantics.c (constexpr_fundef): New datatype.\n+\t(constexpr_fundef_table): New global table.\n+\t(constexpr_fundef_equal): New.\n+\t(constexpr_fundef_hash): Likewise.\n+\t(retrieve_constexpr_fundef): Likewise.\n+\t(validate_constexpr_fundecl): Store in the table.\n+\t(build_data_member_initialization): New fn.\n+\t(build_constexpr_constructor_member_initializers): New.\n+\t(register_constexpr_fundef): Define.\n+\t(is_this_parameter): New.\n+\t(get_function_named_in_call): Likewise.\n+\t(get_nth_callarg): Likewise.\n+\t(check_automatic_or_tls): New.\n+\t(morally_constexpr_builtin_function_p): New.\n+\t(potential_constant_expression): New.\n+\n 2010-11-01  Jason Merrill  <jason@redhat.com>\n \n \t* decl2.c (decl_constant_var_p): New fn."}, {"sha": "4dfa8e9c4f03fa688964d5e577e479f1704b1e41", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=66e61a34b5ba3d0748578bb553d9ef15202eee9f", "patch": "@@ -5252,6 +5252,7 @@ extern void finish_handler\t\t\t(tree);\n extern void finish_cleanup\t\t\t(tree, tree);\n extern bool literal_type_p (tree);\n extern tree validate_constexpr_fundecl (tree);\n+extern tree register_constexpr_fundef (tree, tree);\n extern tree ensure_literal_type_for_constexpr_object (tree);\n \n enum {"}, {"sha": "de6f0c4ff2777a272873dda4315b90a5a75b23e3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=66e61a34b5ba3d0748578bb553d9ef15202eee9f", "patch": "@@ -12667,6 +12667,19 @@ record_key_method_defined (tree fndecl)\n     }\n }\n \n+/* Subroutine of finish_function.\n+   Save the body of constexpr functions for possible\n+   future compile time evaluation.  */\n+\n+static void\n+maybe_save_function_definition (tree fun)\n+{\n+  if (!processing_template_decl\n+      && DECL_DECLARED_CONSTEXPR_P (fun)\n+      && !DECL_CLONED_FUNCTION_P (fun))\n+    register_constexpr_fundef (fun, DECL_SAVED_TREE (fun));\n+}\n+\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n    for the function definition.\n@@ -12778,6 +12791,10 @@ finish_function (int flags)\n      of curly braces for a function.  */\n   gcc_assert (stmts_are_full_exprs_p ());\n \n+  /* Save constexpr function body before it gets munged by\n+     the NRV transformation.   */\n+  maybe_save_function_definition (fndecl);\n+\n   /* Set up the named return value optimization, if we can.  Candidate\n      variables are selected in check_return_expr.  */\n   if (current_function_return_value)"}, {"sha": "0420d37789e50ae9394794c8816b455defa2b3a5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 726, "deletions": 0, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=66e61a34b5ba3d0748578bb553d9ef15202eee9f", "patch": "@@ -5282,6 +5282,55 @@ ensure_literal_type_for_constexpr_object (tree decl)\n   return decl;\n }\n \n+/* Representation of entries in the constexpr function definition table.  */\n+\n+typedef struct GTY(()) constexpr_fundef {\n+  tree decl;\n+  tree body;\n+} constexpr_fundef;\n+\n+/* This table holds all constexpr function definitions seen in\n+   the current translation unit.  */\n+\n+static GTY ((param_is (constexpr_fundef))) htab_t constexpr_fundef_table;\n+\n+static bool potential_constant_expression (tree, tsubst_flags_t);\n+\n+/* Utility function used for managing the constexpr function table.\n+   Return true if the entries pointed to by P and Q are for the\n+   same constexpr function.  */\n+\n+static inline int\n+constexpr_fundef_equal (const void *p, const void *q)\n+{\n+  const constexpr_fundef *lhs = (const constexpr_fundef *) p;\n+  const constexpr_fundef *rhs = (const constexpr_fundef *) q;\n+  return lhs->decl == rhs->decl;\n+}\n+\n+/* Utility function used for managing the constexpr function table.\n+   Return a hash value for the entry pointed to by Q.  */\n+\n+static inline hashval_t\n+constexpr_fundef_hash (const void *p)\n+{\n+  const constexpr_fundef *fundef = (const constexpr_fundef *) p;\n+  return DECL_UID (fundef->decl);\n+}\n+\n+/* Return a previously saved definition of function FUN.   */\n+\n+static constexpr_fundef *\n+retrieve_constexpr_fundef (tree fun)\n+{\n+  constexpr_fundef fundef = { NULL, NULL };\n+  if (constexpr_fundef_table == NULL)\n+    return NULL;\n+\n+  fundef.decl = fun;\n+  return (constexpr_fundef *) htab_find (constexpr_fundef_table, &fundef);\n+}\n+\n /* Return true if type expression T is a valid parameter type, or\n    a valid return type, of a constexpr function.  */\n \n@@ -5343,6 +5392,9 @@ is_valid_constexpr_fn (tree fun, bool complain)\n tree\n validate_constexpr_fundecl (tree fun)\n {\n+  constexpr_fundef entry;\n+  constexpr_fundef **slot;\n+\n   if (processing_template_decl || !DECL_DECLARED_CONSTEXPR_P (fun))\n     return NULL;\n   else if (DECL_CLONED_FUNCTION_P (fun))\n@@ -5355,10 +5407,684 @@ validate_constexpr_fundecl (tree fun)\n       return NULL;\n     }\n \n+  /* Create the constexpr function table if necessary.  */\n+  if (constexpr_fundef_table == NULL)\n+    constexpr_fundef_table = htab_create_ggc (101,\n+                                              constexpr_fundef_hash,\n+                                              constexpr_fundef_equal,\n+                                              ggc_free);\n+  entry.decl = fun;\n+  entry.body = NULL;\n+  slot = (constexpr_fundef **)\n+    htab_find_slot (constexpr_fundef_table, &entry, INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = ggc_alloc_constexpr_fundef ();\n+      **slot = entry;\n+    }\n+  return fun;\n+}\n+\n+/* Subroutine of  build_constexpr_constructor_member_initializers.\n+   The expression tree T represents a data member initialization\n+   in a (constexpr) constructor definition.  Build a pairing of\n+   the data member with its initializer, and prepend that pair\n+   to the existing initialization pair INITS.  */\n+\n+static bool\n+build_data_member_initialization (tree t, VEC(constructor_elt,gc) **vec)\n+{\n+  tree member, init;\n+  if (TREE_CODE (t) == CLEANUP_POINT_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == EXPR_STMT)\n+    t = TREE_OPERAND (t, 0);\n+  if (t == error_mark_node)\n+    return false;\n+  if (TREE_CODE (t) == CLEANUP_STMT)\n+    /* We can't see a CLEANUP_STMT in a constructor for a literal class,\n+       but we can in a constexpr constructor for a non-literal class.  Just\n+       ignore it; either all the initialization will be constant, in which\n+       case the cleanup can't run, or it can't be constexpr.  */\n+    return true;\n+  if (TREE_CODE (t) == CONVERT_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == INIT_EXPR\n+      || TREE_CODE (t) == MODIFY_EXPR)\n+    {\n+      member = TREE_OPERAND (t, 0);\n+      init = unshare_expr (TREE_OPERAND (t, 1));\n+    }\n+  else\n+    {\n+      tree memtype;\n+      gcc_assert (TREE_CODE (t) == CALL_EXPR);\n+      member = CALL_EXPR_ARG (t, 0);\n+      memtype = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (member)));\n+      if (TREE_CODE (member) == NOP_EXPR)\n+\t{\n+\t  /* We don't put out anything for an empty base.  */\n+\t  gcc_assert (is_empty_class (memtype));\n+\t  /* But if the constructor used isn't constexpr, leave in the call\n+\t     so we complain later.  */\n+\t  if (potential_constant_expression (t, tf_none))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (member) == ADDR_EXPR);\n+\t  member = TREE_OPERAND (member, 0);\n+\t}\n+      /* We don't use build_cplus_new here because it complains about\n+\t abstract bases.  T has the wrong type, but\n+\t cxx_eval_constant_expression doesn't care.  */\n+      init = unshare_expr (t);\n+    }\n+  if (TREE_CODE (member) == COMPONENT_REF)\n+    member = TREE_OPERAND (member, 1);\n+  CONSTRUCTOR_APPEND_ELT (*vec, member, init);\n+  return true;\n+}\n+\n+/* Build compile-time evalable representations of member-initializer list\n+   for a constexpr constructor.  */\n+\n+static tree\n+build_constexpr_constructor_member_initializers (tree type, tree body)\n+{\n+  VEC(constructor_elt,gc) *vec = NULL;\n+  bool ok = true;\n+  if (TREE_CODE (body) == MUST_NOT_THROW_EXPR\n+      || TREE_CODE (body) == EH_SPEC_BLOCK)\n+    body = TREE_OPERAND (body, 0);\n+  if (TREE_CODE (body) == BIND_EXPR)\n+    body = BIND_EXPR_BODY (body);\n+  if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n+    ok = build_data_member_initialization (body, &vec);\n+  else\n+    {\n+      tree_stmt_iterator i;\n+      gcc_assert (TREE_CODE (body) == STATEMENT_LIST);\n+      for (i = tsi_start (body); !tsi_end_p (i); tsi_next (&i))\n+\t{\n+\t  ok = build_data_member_initialization (tsi_stmt (i), &vec);\n+\t  if (!ok)\n+\t    break;\n+\t}\n+    }\n+  if (ok)\n+    return build_constructor (type, vec);\n+  else\n+    return error_mark_node;\n+}\n+\n+/* We are processing the definition of the constexpr function FUN.\n+   Check that its BODY fulfills the propriate requirements and\n+   enter it in the constexpr function definition table.\n+   For constructor BODY is actually the TREE_LIST of the\n+   member-initializer list.  */\n+\n+tree\n+register_constexpr_fundef (tree fun, tree body)\n+{\n+  constexpr_fundef *fundef = retrieve_constexpr_fundef (fun);\n+  gcc_assert (fundef != NULL && fundef->body == NULL);\n+\n+  if (DECL_CONSTRUCTOR_P (fun))\n+    body = build_constexpr_constructor_member_initializers\n+      (DECL_CONTEXT (fun), body);\n+  else\n+    {\n+      if (TREE_CODE (body) == BIND_EXPR)\n+\tbody = BIND_EXPR_BODY (body);\n+      if (TREE_CODE (body) == EH_SPEC_BLOCK)\n+        body = EH_SPEC_STMTS (body);\n+      if (TREE_CODE (body) == MUST_NOT_THROW_EXPR)\n+\tbody = TREE_OPERAND (body, 0);\n+      if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n+        body = TREE_OPERAND (body, 0);\n+      if (TREE_CODE (body) != RETURN_EXPR)\n+        {\n+          error (\"body of constexpr function %qD not a return-statement\", fun);\n+          DECL_DECLARED_CONSTEXPR_P (fun) = false;\n+          return NULL;\n+        }\n+      body = unshare_expr (TREE_OPERAND (body, 0));\n+    }\n+\n+  if (!potential_constant_expression (body, (DECL_TEMPLATE_INSTANTIATION (fun)\n+\t\t\t\t\t     ? tf_none : tf_error)))\n+    {\n+      DECL_DECLARED_CONSTEXPR_P (fun) = false;\n+      return NULL;\n+    }\n+  fundef->body = body;\n+  return fun;\n+}\n+\n+/* Return true if T designates the implied `this' parameter.  */\n+\n+static inline bool\n+is_this_parameter (tree t)\n+{\n+  return t == current_class_ptr;\n+}\n+\n+/* We have an expression tree T that represents a call, either CALL_EXPR\n+   or AGGR_INIT_EXPR.  If the call is lexically to a named function,\n+   retrun the _DECL for that function.  */\n+\n+static tree\n+get_function_named_in_call (tree t)\n+{\n+  tree fun = NULL;\n+  switch (TREE_CODE (t))\n+    {\n+    case CALL_EXPR:\n+      fun = CALL_EXPR_FN (t);\n+      break;\n+\n+    case AGGR_INIT_EXPR:\n+      fun = AGGR_INIT_EXPR_FN (t);\n+      break;\n+\n+    default:\n+      gcc_unreachable();\n+      break;\n+    }\n+  if (TREE_CODE (fun) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (fun, 0)) == FUNCTION_DECL)\n+    fun = TREE_OPERAND (fun, 0);\n   return fun;\n }\n \n+/* We have an expression tree T that represents a call, either CALL_EXPR\n+   or AGGR_INIT_EXPR.  Return the Nth argument.  */\n+\n+static inline tree\n+get_nth_callarg (tree t, int n)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case CALL_EXPR:\n+      return CALL_EXPR_ARG (t, n);\n+\n+    case AGGR_INIT_EXPR:\n+      return AGGR_INIT_EXPR_ARG (t, n);\n+\n+    default:\n+      gcc_unreachable ();\n+      return NULL;\n+    }\n+}\n+\n+/* Return true if the object referred to by REF has automatic or thread\n+   local storage.  */\n+\n+enum { ck_ok, ck_bad, ck_unknown };\n+static int\n+check_automatic_or_tls (tree ref)\n+{\n+  enum machine_mode mode;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  int volatilep = 0, unsignedp = 0;\n+  tree decl = get_inner_reference (ref, &bitsize, &bitpos, &offset,\n+\t\t\t\t   &mode, &unsignedp, &volatilep, false);\n+  duration_kind dk;\n+\n+  /* If there isn't a decl in the middle, we don't know the linkage here,\n+     and this isn't a constant expression anyway.  */\n+  if (!DECL_P (decl))\n+    return ck_unknown;\n+  dk = decl_storage_duration (decl);\n+  return (dk == dk_auto || dk == dk_thread) ? ck_bad : ck_ok;\n+}\n+\n+/* Return true if the DECL designates a builtin function that is\n+   morally constexpr, in the sense that its parameter types and\n+   return type are literal types and the compiler is allowed to\n+   fold its invocations.  */\n+\n+static bool\n+morally_constexpr_builtin_function_p (tree decl)\n+{\n+  tree funtype = TREE_TYPE (decl);\n+  tree t;\n+\n+  if (!is_builtin_fn (decl))\n+    return false;\n+  if (!literal_type_p (TREE_TYPE (funtype)))\n+    return false;\n+  for (t = TYPE_ARG_TYPES (funtype); t != NULL ; t = TREE_CHAIN (t))\n+    {\n+      if (t == void_list_node)\n+        return true;\n+      if (!literal_type_p (TREE_VALUE (t)))\n+        return false;\n+    }\n+  /* We assume no varargs builtins are suitable.  */\n+  return t != NULL;\n+}\n+\n+/* Return true if T denotes a constant expression, or potential constant\n+   expression if POTENTIAL is true.\n+   Issue diagnostic as appropriate under control of flags.  Variables\n+   with static storage duration initialized by constant expressions\n+   are guaranteed to be statically initialized.\n+\n+   C++0x [expr.const]\n+\n+   6 An expression is a potential constant expression if it is\n+     a constant expression where all occurences of function\n+     parameters are replaced by arbitrary constant expressions\n+     of the appropriate type.\n+\n+   2  A conditional expression is a constant expression unless it\n+      involves one of the following as a potentially evaluated\n+      subexpression (3.2), but subexpressions of logical AND (5.14),\n+      logical OR (5.15), and conditional (5.16) operations that are\n+      not evaluated are not considered.   */\n+\n+static bool\n+potential_constant_expression (tree t, tsubst_flags_t flags)\n+{\n+  int i;\n+  tree tmp;\n+  if (t == error_mark_node)\n+    return false;\n+  if (TREE_THIS_VOLATILE (t))\n+    {\n+      if (flags & tf_error)\n+        error (\"expression %qE has side-effects\", t);\n+      return false;\n+    }\n+  if (CONSTANT_CLASS_P (t))\n+    return true;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case FUNCTION_DECL:\n+    case LABEL_DECL:\n+    case CONST_DECL:\n+      return true;\n+\n+    case PARM_DECL:\n+      /* -- this (5.1) unless it appears as the postfix-expression in a\n+            class member access expression, including the result of the\n+            implicit transformation in the body of the non-static\n+            member function (9.3.1);  */\n+      if (is_this_parameter (t))\n+        {\n+          if (flags & tf_error)\n+            error (\"%qE is not a potential constant expression\", t);\n+          return false;\n+        }\n+      return true;\n+\n+    case AGGR_INIT_EXPR:\n+    case CALL_EXPR:\n+      /* -- an invocation of a function other than a constexpr function\n+            or a constexpr constructor.  */\n+      {\n+        tree fun = get_function_named_in_call (t);\n+        const int nargs = call_expr_nargs (t);\n+        if (TREE_CODE (fun) != FUNCTION_DECL)\n+          {\n+\t    if (potential_constant_expression (fun, flags))\n+\t      /* Might end up being a constant function pointer.  */\n+\t      return true;\n+            if (flags & tf_error)\n+              error (\"%qE is not a function name\", fun);\n+            return false;\n+          }\n+\t/* Skip initial arguments to base constructors.  */\n+\tif (DECL_BASE_CONSTRUCTOR_P (fun))\n+\t  i = num_artificial_parms_for (fun);\n+\telse\n+\t  i = 0;\n+\tfun = DECL_ORIGIN (fun);\n+        if (builtin_valid_in_constant_expr_p (fun))\n+          return true;\n+        if (!DECL_DECLARED_CONSTEXPR_P (fun)\n+            && !morally_constexpr_builtin_function_p (fun))\n+          {\n+            if (flags & tf_error)\n+              error (\"%qD is not %<constexpr%>\", fun);\n+            return false;\n+          }\n+        for (; i < nargs; ++i)\n+          {\n+            tree x = get_nth_callarg (t, i);\n+            /* A call to a non-static member function takes the\n+               address of the object as the first argument.\n+               But in a constant expression the address will be folded\n+\t       away, so look through it now.  */\n+            if (i == 0 && DECL_NONSTATIC_MEMBER_P (fun)\n+                && !DECL_CONSTRUCTOR_P (fun))\n+\t      {\n+\t\tif (TREE_CODE (x) == ADDR_EXPR)\n+\t\t  x = TREE_OPERAND (x, 0);\n+\t\tif (is_this_parameter (x))\n+\t\t  /* OK.  */;\n+                else if (!potential_constant_expression (x, flags))\n+\t\t  {\n+\t\t    if (flags & tf_error)\n+\t\t      error (\"object argument is not a potential constant \"\n+\t\t\t     \"expression\");\n+\t\t    return false;\n+\t\t  }\n+              }\n+\t    else if (!potential_constant_expression (x, flags))\n+\t      {\n+\t\tif (flags & tf_error)\n+\t\t  error (\"argument in position %qP is not a \"\n+\t\t\t \"potential constant expression\", i);\n+\t\treturn false;\n+              }\n+          }\n+        return true;\n+      }\n+\n+    case NON_LVALUE_EXPR:\n+      /* -- an lvalue-to-rvalue conversion (4.1) unless it is applied to\n+            -- an lvalue of integral type that refers to a non-volatile\n+               const variable or static data member initialized with\n+               constant expressions, or\n+\n+            -- an lvalue of literal type that refers to non-volatile\n+               object defined with constexpr, or that refers to a\n+               sub-object of such an object;  */\n+      return potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+\n+    case VAR_DECL:\n+      if (!decl_constant_var_p (t))\n+        {\n+          if (flags & tf_error)\n+            error (\"variable %qD is not declared constexpr\", t);\n+          return false;\n+        }\n+      return true;\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      /* -- an array-to-pointer conversion that is applied to an lvalue\n+            that designates an object with thread or automatic storage\n+            duration;  FIXME not implemented as it breaks constexpr arrays;\n+\t    need to fix the standard\n+         -- a type conversion from a pointer or pointer-to-member type\n+            to a literal type.  */\n+      {\n+        tree from = TREE_OPERAND (t, 0);\n+        tree source = TREE_TYPE (from);\n+        tree target = TREE_TYPE (t);\n+        if (TYPE_PTR_P (source) && ARITHMETIC_TYPE_P (target)\n+\t    && !(TREE_CODE (from) == COMPONENT_REF\n+\t\t && TYPE_PTRMEMFUNC_P (TREE_TYPE (TREE_OPERAND (from, 0)))))\n+          {\n+            if (flags & tf_error)\n+              error (\"conversion of expression %qE of pointer type \"\n+                     \"cannot yield a constant expression\", from);\n+            return false;\n+          }\n+        return potential_constant_expression (from, flags);\n+      }\n+\n+    case ADDR_EXPR:\n+      /* -- a unary operator & that is applied to an lvalue that\n+            designates an object with thread or automatic storage\n+            duration;  */\n+      t = TREE_OPERAND (t, 0);\n+      i = check_automatic_or_tls (t);\n+      if (i == ck_ok)\n+\treturn true;\n+      if (i == ck_bad)\n+        {\n+          if (flags & tf_error)\n+            error (\"address-of an object %qE with thread local or \"\n+                   \"automatic storage is not a constant expression\", t);\n+          return false;\n+        }\n+      return potential_constant_expression (t, flags);\n+\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+      /* -- a class member access unless its postfix-expression is\n+            of literal type or of pointer to literal type.  */\n+      /* This test would be redundant, as it follows from the\n+\t postfix-expression being a potential constant expression.  */\n+      return potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+\n+    case INDIRECT_REF:\n+      {\n+        tree x = TREE_OPERAND (t, 0);\n+        STRIP_NOPS (x);\n+        if (is_this_parameter (x))\n+\t  return true;\n+\treturn potential_constant_expression (x, flags);\n+      }\n+\n+    case LAMBDA_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+    case PSEUDO_DTOR_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+    case DELETE_EXPR:\n+    case VEC_DELETE_EXPR:\n+    case THROW_EXPR:\n+    case MODIFY_EXPR:\n+    case MODOP_EXPR:\n+      /* GCC internal stuff.  */\n+    case VA_ARG_EXPR:\n+    case OBJ_TYPE_REF:\n+    case WITH_CLEANUP_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case MUST_NOT_THROW_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case STATEMENT_LIST:\n+    case BIND_EXPR:\n+      if (flags & tf_error)\n+        error (\"expression %qE is not a constant-expression\", t);\n+      return false;\n \n+    case TYPEID_EXPR:\n+      /* -- a typeid expression whose operand is of polymorphic\n+            class type;  */\n+      {\n+        tree e = TREE_OPERAND (t, 0);\n+        if (!TYPE_P (e) && TYPE_POLYMORPHIC_P (TREE_TYPE (e)))\n+          {\n+            if (flags & tf_error)\n+              error (\"typeid-expression is not a constant expression \"\n+                     \"because %qE is of polymorphic type\", e);\n+            return false;\n+          }\n+        return true;\n+      }\n+\n+    case MINUS_EXPR:\n+      /* -- a subtraction where both operands are pointers.   */\n+      if (TYPE_PTR_P (TREE_OPERAND (t, 0))\n+          && TYPE_PTR_P (TREE_OPERAND (t, 1)))\n+        {\n+          if (flags & tf_error)\n+            error (\"difference of two pointer expressions is not \"\n+                   \"a constant expression\");\n+          return false;\n+        }\n+      goto binary;\n+\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      /* -- a relational or equality operator where at least\n+            one of the operands is a pointer.  */\n+      if (TYPE_PTR_P (TREE_OPERAND (t, 0))\n+          || TYPE_PTR_P (TREE_OPERAND (t, 1)))\n+        {\n+          if (flags & tf_error)\n+            error (\"pointer comparison expression is not a \"\n+                   \"constant expression\");\n+          return false;\n+        }\n+      goto binary;\n+\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case CONJ_EXPR:\n+    case SAVE_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case PAREN_EXPR:\n+    case FIXED_CONVERT_EXPR:\n+      /* For convenience.  */\n+    case RETURN_EXPR:\n+      return potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+\n+    case INIT_EXPR:\n+    case TARGET_EXPR:\n+      return potential_constant_expression (TREE_OPERAND (t, 1), flags);\n+\n+    case CONSTRUCTOR:\n+      {\n+        VEC(constructor_elt, gc) *v = CONSTRUCTOR_ELTS (t);\n+        constructor_elt *ce;\n+        for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+\t  if (!potential_constant_expression (ce->value, flags))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+    case TREE_LIST:\n+      {\n+\tgcc_assert (TREE_PURPOSE (t) == NULL_TREE\n+\t\t    || DECL_P (TREE_PURPOSE (t)));\n+\tif (!potential_constant_expression (TREE_VALUE (t), flags))\n+\t  return false;\n+\tif (TREE_CHAIN (t) == NULL_TREE)\n+\t  return true;\n+\treturn potential_constant_expression (TREE_CHAIN (t), flags);\n+      }\n+\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+      if (integer_zerop (decl_constant_value (TREE_OPERAND (t, 1))))\n+\treturn false;\n+      else\n+\tgoto binary;\n+\n+    case COMPOUND_EXPR:\n+      {\n+\t/* check_return_expr sometimes wraps a TARGET_EXPR in a\n+\t   COMPOUND_EXPR; don't get confused.  Also handle EMPTY_CLASS_EXPR\n+\t   introduced by build_call_a.  */\n+\ttree op0 = TREE_OPERAND (t, 0);\n+\ttree op1 = TREE_OPERAND (t, 1);\n+\tSTRIP_NOPS (op1);\n+\tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n+\t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n+\t  return potential_constant_expression (op0, flags);\n+\telse\n+\t  goto binary;\n+      }\n+\n+      /* If the first operand is the non-short-circuit constant, look at\n+\t the second operand; otherwise we only care about the first one for\n+\t potentiality.  */\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+      tmp = boolean_true_node;\n+      goto truth;\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      tmp = boolean_false_node;\n+    truth:\n+      if (TREE_OPERAND (t, 0) == tmp)\n+\treturn potential_constant_expression (TREE_OPERAND (t, 1), flags);\n+      else\n+\treturn potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case RANGE_EXPR:\n+    case COMPLEX_EXPR:\n+    binary:\n+      for (i = 0; i < 2; ++i)\n+\tif (!potential_constant_expression (TREE_OPERAND (t, i),\n+\t\t\t\t      flags))\n+\t  return false;\n+      return true;\n+\n+    case COND_EXPR:\n+    case VEC_COND_EXPR:\n+      /* If the condition is a known constant, we know which of the legs we\n+\t care about; otherwise we only require that the condition and\n+\t either of the legs be potentially constant.  */\n+      tmp = TREE_OPERAND (t, 0);\n+      if (!potential_constant_expression (tmp, flags))\n+\treturn false;\n+      else if (tmp == boolean_true_node)\n+\treturn potential_constant_expression (TREE_OPERAND (t, 1), flags);\n+      else if (tmp == boolean_false_node)\n+\treturn potential_constant_expression (TREE_OPERAND (t, 2), flags);\n+      for (i = 1; i < 3; ++i)\n+\tif (potential_constant_expression (TREE_OPERAND (t, i), tf_none))\n+\t  return true;\n+      if (flags & tf_error)\n+        error (\"expression %qE is not a constant-expression\", t);\n+      return false;\n+\n+    case VEC_INIT_EXPR:\n+      /* We should only see this in a defaulted constructor for a class\n+\t with a non-static data member of array type; if we get here we\n+\t know this is a potential constant expression.  */\n+      gcc_assert (DECL_DEFAULTED_FN (current_function_decl));\n+      return true;\n+\n+    default:\n+      sorry (\"unexpected ast of kind %s\", tree_code_name[TREE_CODE (t)]);\n+      gcc_unreachable();\n+      return false;\n+    }\n+}\n+\n+\f\n /* Constructor for a lambda expression.  */\n \n tree"}, {"sha": "c5be6e9f14299987b686706792ee1e8896d3a309", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=66e61a34b5ba3d0748578bb553d9ef15202eee9f", "patch": "@@ -1,3 +1,7 @@\n+2010-11-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/constexpr-ctor2.C: New.\n+\n 2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented format and noreturn attributes for Objective-C methods."}, {"sha": "5280b131b7b85d91b9279d975939e5cb8b28ca64", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ctor2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e61a34b5ba3d0748578bb553d9ef15202eee9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor2.C?ref=66e61a34b5ba3d0748578bb553d9ef15202eee9f", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  A();\n+};\n+\n+struct B : A\n+{\n+  constexpr B(): A() { }\t// { dg-error \"A::A\" }\n+};"}]}