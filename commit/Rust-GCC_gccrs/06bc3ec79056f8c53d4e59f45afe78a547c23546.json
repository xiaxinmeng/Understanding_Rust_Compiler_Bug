{"sha": "06bc3ec79056f8c53d4e59f45afe78a547c23546", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiYzNlYzc5MDU2ZjhjNTNkNGU1OWY0NWFmZTc4YTU0N2MyMzU0Ng==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2011-06-07T15:12:04Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2011-06-07T15:12:04Z"}, "message": "re PR tree-optimization/46728 (GCC does not generate fmadd for pow (x, 0.75)+y on powerpc)\n\n2011-06-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/46728\n\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Change FIXME\n\tto use gimple_val_nonnegative_real_p.\n\t* gimple-fold.c (gimple_val_nonnegative_real_p): New function.\n\t* gimple.h (gimple_val_nonnegative_real_p): New declaration.\n\nFrom-SVN: r174752", "tree": {"sha": "44dc6b8481b3a6a81e091f03fc34efc38e60abff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44dc6b8481b3a6a81e091f03fc34efc38e60abff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06bc3ec79056f8c53d4e59f45afe78a547c23546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bc3ec79056f8c53d4e59f45afe78a547c23546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bc3ec79056f8c53d4e59f45afe78a547c23546", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bc3ec79056f8c53d4e59f45afe78a547c23546/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c395ecf7d41384016acbcc18d4847c72685013c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c395ecf7d41384016acbcc18d4847c72685013c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c395ecf7d41384016acbcc18d4847c72685013c"}], "stats": {"total": 164, "additions": 143, "deletions": 21}, "files": [{"sha": "932e8e1d1ff4b3e2c661fa270f63791e33948998", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06bc3ec79056f8c53d4e59f45afe78a547c23546", "patch": "@@ -1,3 +1,11 @@\n+2011-06-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/46728\n+\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Change FIXME\n+\tto use gimple_val_nonnegative_real_p.\n+\t* gimple-fold.c (gimple_val_nonnegative_real_p): New function.\n+\t* gimple.h (gimple_val_nonnegative_real_p): New declaration.\n+\t\n 2011-06-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.md (*movsf_internal): Optimize AVX check."}, {"sha": "180a51e095a6c06de93e1e299eb4134daa20028c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=06bc3ec79056f8c53d4e59f45afe78a547c23546", "patch": "@@ -3447,3 +3447,134 @@ fold_const_aggregate_ref (tree t)\n {\n   return fold_const_aggregate_ref_1 (t, NULL);\n }\n+\n+/* Return true iff VAL is a gimple expression that is known to be\n+   non-negative.  Restricted to floating-point inputs.  */\n+\n+bool\n+gimple_val_nonnegative_real_p (tree val)\n+{\n+  gimple def_stmt;\n+\n+  gcc_assert (val && SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)));\n+\n+  /* Use existing logic for non-gimple trees.  */\n+  if (tree_expr_nonnegative_p (val))\n+    return true;\n+\n+  if (TREE_CODE (val) != SSA_NAME)\n+    return false;\n+\n+  /* Currently we look only at the immediately defining statement\n+     to make this determination, since recursion on defining \n+     statements of operands can lead to quadratic behavior in the\n+     worst case.  This is expected to catch almost all occurrences\n+     in practice.  It would be possible to implement limited-depth\n+     recursion if important cases are lost.  Alternatively, passes\n+     that need this information (such as the pow/powi lowering code\n+     in the cse_sincos pass) could be revised to provide it through\n+     dataflow propagation.  */\n+\n+  def_stmt = SSA_NAME_DEF_STMT (val);\n+\n+  if (is_gimple_assign (def_stmt))\n+    {\n+      tree op0, op1;\n+\n+      /* See fold-const.c:tree_expr_nonnegative_p for additional\n+\t cases that could be handled with recursion.  */\n+\n+      switch (gimple_assign_rhs_code (def_stmt))\n+\t{\n+\tcase ABS_EXPR:\n+\t  /* Always true for floating-point operands.  */\n+\t  return true;\n+\n+\tcase MULT_EXPR:\n+\t  /* True if the two operands are identical (since we are\n+\t     restricted to floating-point inputs).  */\n+\t  op0 = gimple_assign_rhs1 (def_stmt);\n+\t  op1 = gimple_assign_rhs2 (def_stmt);\n+\n+\t  if (op0 == op1\n+\t      || operand_equal_p (op0, op1, 0))\n+\t    return true;\n+\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+  else if (is_gimple_call (def_stmt))\n+    {\n+      tree fndecl = gimple_call_fndecl (def_stmt);\n+      if (fndecl\n+\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t{\n+\t  tree arg1;\n+\n+\t  switch (DECL_FUNCTION_CODE (fndecl))\n+\t    {\n+\t    CASE_FLT_FN (BUILT_IN_ACOS):\n+\t    CASE_FLT_FN (BUILT_IN_ACOSH):\n+\t    CASE_FLT_FN (BUILT_IN_CABS):\n+\t    CASE_FLT_FN (BUILT_IN_COSH):\n+\t    CASE_FLT_FN (BUILT_IN_ERFC):\n+\t    CASE_FLT_FN (BUILT_IN_EXP):\n+\t    CASE_FLT_FN (BUILT_IN_EXP10):\n+\t    CASE_FLT_FN (BUILT_IN_EXP2):\n+\t    CASE_FLT_FN (BUILT_IN_FABS):\n+\t    CASE_FLT_FN (BUILT_IN_FDIM):\n+\t    CASE_FLT_FN (BUILT_IN_HYPOT):\n+\t    CASE_FLT_FN (BUILT_IN_POW10):\n+\t      return true;\n+\n+\t    CASE_FLT_FN (BUILT_IN_SQRT):\n+\t      /* sqrt(-0.0) is -0.0, and sqrt is not defined over other\n+\t\t nonnegative inputs.  */\n+\t      if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (val))))\n+\t\treturn true;\n+\n+\t      break;\n+\n+\t    CASE_FLT_FN (BUILT_IN_POWI):\n+\t      /* True if the second argument is an even integer.  */\n+\t      arg1 = gimple_call_arg (def_stmt, 1);\n+\n+\t      if (TREE_CODE (arg1) == INTEGER_CST\n+\t\t  && (TREE_INT_CST_LOW (arg1) & 1) == 0)\n+\t\treturn true;\n+\n+\t      break;\n+\t      \n+\t    CASE_FLT_FN (BUILT_IN_POW):\n+\t      /* True if the second argument is an even integer-valued\n+\t\t real.  */\n+\t      arg1 = gimple_call_arg (def_stmt, 1);\n+\n+\t      if (TREE_CODE (arg1) == REAL_CST)\n+\t\t{\n+\t\t  REAL_VALUE_TYPE c;\n+\t\t  HOST_WIDE_INT n;\n+\n+\t\t  c = TREE_REAL_CST (arg1);\n+\t\t  n = real_to_integer (&c);\n+\n+\t\t  if ((n & 1) == 0)\n+\t\t    {\n+\t\t      REAL_VALUE_TYPE cint;\n+\t\t      real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n+\t\t      if (real_identical (&c, &cint))\n+\t\t\treturn true;\n+\t\t    }\n+\t\t}\n+\n+\t      break;\n+\n+\t    default:\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}"}, {"sha": "c39eb574c87e1ba7ee0c132789dbbe0ad5c7eaaf", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=06bc3ec79056f8c53d4e59f45afe78a547c23546", "patch": "@@ -4988,4 +4988,5 @@ extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree,\n extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n \n+bool gimple_val_nonnegative_real_p (tree);\n #endif  /* GCC_GIMPLE_H */"}, {"sha": "e6b585723e9143dd4c2ae46e576101035fcc96b8", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bc3ec79056f8c53d4e59f45afe78a547c23546/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=06bc3ec79056f8c53d4e59f45afe78a547c23546", "patch": "@@ -1172,13 +1172,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n \n   if (flag_unsafe_math_optimizations\n       && cbrtfn\n-      /* FIXME: The following line was originally\n-\t && (tree_expr_nonnegative_p (arg0) || !HONOR_NANS (mode)),\n-\t but since arg0 is a gimple value, the first predicate\n-\t will always return false.  It needs to be replaced with a\n-\t call to a similar gimple_val_nonnegative_p function to be\n-         added in gimple-fold.c.  */\n-      && !HONOR_NANS (mode)\n+      && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n       && REAL_VALUES_EQUAL (c, dconst1_3))\n     return build_and_insert_call (gsi, loc, &target, cbrtfn, arg0);\n   \n@@ -1190,13 +1184,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n   if (flag_unsafe_math_optimizations\n       && sqrtfn\n       && cbrtfn\n-      /* FIXME: The following line was originally\n-\t && (tree_expr_nonnegative_p (arg0) || !HONOR_NANS (mode)),\n-\t but since arg0 is a gimple value, the first predicate\n-\t will always return false.  It needs to be replaced with a\n-\t call to a similar gimple_val_nonnegative_p function to be\n-         added in gimple-fold.c.  */\n-      && !HONOR_NANS (mode)\n+      && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n       && optimize_function_for_speed_p (cfun)\n       && hw_sqrt_exists\n       && REAL_VALUES_EQUAL (c, dconst1_6))\n@@ -1270,13 +1258,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n \n   if (flag_unsafe_math_optimizations\n       && cbrtfn\n-      /* FIXME: The following line was originally\n-\t && (tree_expr_nonnegative_p (arg0) || !HONOR_NANS (mode)),\n-\t but since arg0 is a gimple value, the first predicate\n-\t will always return false.  It needs to be replaced with a\n-\t call to a similar gimple_val_nonnegative_p function to be\n-         added in gimple-fold.c.  */\n-      && !HONOR_NANS (mode)\n+      && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n       && real_identical (&c2, &c)\n       && optimize_function_for_speed_p (cfun)\n       && powi_cost (n / 3) <= POWI_MAX_MULTS)"}]}