{"sha": "1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "node_id": "C_kwDOANBUbNoAKDE3MzZiZjVhNjFjNzM2NGM1ZGE2ZmE1MmU1ZTJiZmRiYzk1MDdjOTc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-07T16:37:07Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-13T01:10:45Z"}, "message": "libstdc++: Add C++20 clocks\n\nAlso add the basic types for timezones, without the non-inline\ndefinitions needed to actually use them.\n\nThe get_leap_second_info function currently uses a hardcoded list of\nleap seconds, correct as of the end of 2022. That needs to be replaced\nwith a dynamically generated list read from the system tzdata. That will\nbe done in a later patch.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/chrono (utc_clock, tai_clock, gps_clock): Define.\n\t(clock_time_conversion, clock_cast): Define.\n\t(sys_info, local_info): Define structs for timezone information.\n\t(nonexistent_local_time, ambiguous_local_time): Define\n\texceptions for invalid times.\n\t(time_zone, time_zone_link, leap_second, zoned_traits, tzdb)\n\t(tzdb_list): Define classes representing time zones.\n\t(get_leap_second_info): Define new function returning leap\n\tsecond offset for a given time point.\n\t* testsuite/std/time/clock/gps/1.cc: New test.\n\t* testsuite/std/time/clock/tai/1.cc: New test.\n\t* testsuite/std/time/clock/utc/1.cc: New test.", "tree": {"sha": "e5ad071c8af7a4684bd2c2734affe49027bfbe8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5ad071c8af7a4684bd2c2734affe49027bfbe8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d9454aba615eadd0d85c93713dd848227345f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d9454aba615eadd0d85c93713dd848227345f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d9454aba615eadd0d85c93713dd848227345f67"}], "stats": {"total": 847, "additions": 844, "deletions": 3}, "files": [{"sha": "90b73f8198e434b6fdc4accca8d1314e6779b28c", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 741, "deletions": 3, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "patch": "@@ -39,9 +39,15 @@\n #else\n \n #include <bits/chrono.h>\n-#if __cplusplus > 201703L\n-# include <sstream> // ostringstream\n-# include <bits/charconv.h>\n+\n+#if __cplusplus >= 202002L\n+# include <sstream>\n+# include <string>\n+# include <vector>\n+# include <bits/charconv.h> // __to_chars_len, __to_chars_10_impl\n+# include <bits/stl_algo.h> // upper_bound TODO: move leap_second_info to .so\n+# include <bits/shared_ptr.h>\n+# include <bits/unique_ptr.h>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -102,6 +108,357 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       seconds elapsed;\n     };\n \n+    template<typename _Duration>\n+      leap_second_info\n+      get_leap_second_info(const utc_time<_Duration>& __ut);\n+\n+    /** A clock that measures Universal Coordinated Time (UTC).\n+     *\n+     * The epoch is 1970-01-01 00:00:00.\n+     *\n+     * @since C++20\n+     */\n+    class utc_clock\n+    {\n+    public:\n+      using rep                       = system_clock::rep;\n+      using period                    = system_clock::period;\n+      using duration                  = chrono::duration<rep, period>;\n+      using time_point                = chrono::time_point<utc_clock>;\n+      static constexpr bool is_steady = false;\n+\n+      static time_point\n+      now()\n+      { return from_sys(system_clock::now()); }\n+\n+      template<typename _Duration>\n+\tstatic sys_time<common_type_t<_Duration, seconds>>\n+\tto_sys(const utc_time<_Duration>& __t)\n+\t{\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  const auto __li = chrono::get_leap_second_info(__t);\n+\t  sys_time<_CDur> __s{__t.time_since_epoch() - seconds{__li.elapsed}};\n+\t  if (__li.is_leap_second)\n+\t    __s = chrono::floor<seconds>(__s) + seconds{1} - _CDur{1};\n+\t  return __s;\n+\t}\n+\n+      template<typename _Duration>\n+\tstatic utc_time<common_type_t<_Duration, seconds>>\n+\tfrom_sys(const sys_time<_Duration>& __t)\n+\t{\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  utc_time<_Duration> __u(__t.time_since_epoch());\n+\t  const auto __li = chrono::get_leap_second_info(__u);\n+\t  return utc_time<_CDur>{__u} + seconds{__li.elapsed};\n+\t}\n+    };\n+\n+    /** A clock that measures International Atomic Time.\n+     *\n+     * The epoch is 1958-01-01 00:00:00.\n+     *\n+     * @since C++20\n+     */\n+    class tai_clock\n+    {\n+    public:\n+      using rep                       = system_clock::rep;\n+      using period                    = system_clock::period;\n+      using duration                  = chrono::duration<rep, period>;\n+      using time_point                = chrono::time_point<tai_clock>;\n+      static constexpr bool is_steady = false; // XXX true for CLOCK_TAI?\n+\n+      // TODO move into lib, use CLOCK_TAI on linux, add extension point.\n+      static time_point\n+      now()\n+      { return from_utc(utc_clock::now()); }\n+\n+      template<typename _Duration>\n+\tstatic utc_time<common_type_t<_Duration, seconds>>\n+\tto_utc(const tai_time<_Duration>& __t)\n+\t{\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  return utc_time<_CDur>{__t.time_since_epoch()} - 378691210s;\n+\t}\n+\n+      template<typename _Duration>\n+\tstatic tai_time<common_type_t<_Duration, seconds>>\n+\tfrom_utc(const utc_time<_Duration>& __t)\n+\t{\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  return tai_time<_CDur>{__t.time_since_epoch()} + 378691210s;\n+\t}\n+    };\n+\n+    /** A clock that measures GPS time.\n+     *\n+     * The epoch is 1980-01-06 00:00:00.\n+     *\n+     * @since C++20\n+     */\n+    class gps_clock\n+    {\n+    public:\n+      using rep                       = system_clock::rep;\n+      using period                    = system_clock::period;\n+      using duration                  = chrono::duration<rep, period>;\n+      using time_point                = chrono::time_point<gps_clock>;\n+      static constexpr bool is_steady = false; // XXX\n+\n+      // TODO move into lib, add extension point.\n+      static time_point\n+      now()\n+      { return from_utc(utc_clock::now()); }\n+\n+      template<typename _Duration>\n+\tstatic utc_time<common_type_t<_Duration, seconds>>\n+\tto_utc(const gps_time<_Duration>& __t)\n+\t{\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  return utc_time<_CDur>{__t.time_since_epoch()} + 315964809s;\n+\t}\n+\n+      template<typename _Duration>\n+\tstatic gps_time<common_type_t<_Duration, seconds>>\n+\tfrom_utc(const utc_time<_Duration>& __t)\n+\t{\n+\t  using _CDur = common_type_t<_Duration, seconds>;\n+\t  return gps_time<_CDur>{__t.time_since_epoch()} - 315964809s;\n+\t}\n+    };\n+\n+\n+    template<typename _DestClock, typename _SourceClock>\n+      struct clock_time_conversion\n+      { };\n+\n+    // Identity conversions\n+\n+    template<typename _Clock>\n+      struct clock_time_conversion<_Clock, _Clock>\n+      {\n+\ttemplate<typename _Duration>\n+\t  time_point<_Clock, _Duration>\n+\t  operator()(const time_point<_Clock, _Duration>& __t) const\n+\t  { return __t; }\n+      };\n+\n+    template<>\n+      struct clock_time_conversion<system_clock, system_clock>\n+      {\n+\ttemplate<typename _Duration>\n+\t  sys_time<_Duration>\n+\t  operator()(const sys_time<_Duration>& __t) const\n+\t  { return __t; }\n+      };\n+\n+    template<>\n+      struct clock_time_conversion<utc_clock, utc_clock>\n+      {\n+\ttemplate<typename _Duration>\n+\t  utc_time<_Duration>\n+\t  operator()(const utc_time<_Duration>& __t) const\n+\t  { return __t; }\n+      };\n+\n+    // Conversions between system_clock and utc_clock\n+\n+    template<>\n+      struct clock_time_conversion<utc_clock, system_clock>\n+      {\n+\ttemplate<typename _Duration>\n+\t  utc_time<common_type_t<_Duration, seconds>>\n+\t  operator()(const sys_time<_Duration>& __t) const\n+\t  { return utc_clock::from_sys(__t); }\n+      };\n+\n+    template<>\n+      struct clock_time_conversion<system_clock, utc_clock>\n+      {\n+\ttemplate<typename _Duration>\n+\t  sys_time<common_type_t<_Duration, seconds>>\n+\t  operator()(const utc_time<_Duration>& __t) const\n+\t  { return utc_clock::to_sys(__t); }\n+      };\n+\n+    template<typename _Tp, typename _Clock>\n+      inline constexpr bool __is_time_point_for_v = false;\n+\n+    template<typename _Clock, typename _Duration>\n+      inline constexpr bool\n+       __is_time_point_for_v<time_point<_Clock, _Duration>, _Clock> = true;\n+\n+    // Conversions between system_clock and other clocks\n+\n+    template<typename _SourceClock>\n+      struct clock_time_conversion<system_clock, _SourceClock>\n+      {\n+\ttemplate<typename _Duration, typename _Src = _SourceClock>\n+\t  auto\n+\t  operator()(const time_point<_SourceClock, _Duration>& __t) const\n+\t  -> decltype(_Src::to_sys(__t))\n+\t  {\n+\t    using _Ret = decltype(_SourceClock::to_sys(__t));\n+\t    static_assert(__is_time_point_for_v<_Ret, system_clock>);\n+\t    return _SourceClock::to_sys(__t);\n+\t  }\n+      };\n+\n+    template<typename _DestClock>\n+      struct clock_time_conversion<_DestClock, system_clock>\n+      {\n+\ttemplate<typename _Duration, typename _Dest = _DestClock>\n+\t  auto\n+\t  operator()(const sys_time<_Duration>& __t) const\n+\t  -> decltype(_Dest::from_sys(__t))\n+\t  {\n+\t    using _Ret = decltype(_DestClock::from_sys(__t));\n+\t    static_assert(__is_time_point_for_v<_Ret, _DestClock>);\n+\t    return _DestClock::from_sys(__t);\n+\t  }\n+      };\n+\n+    // Conversions between utc_clock and other clocks\n+\n+    template<typename _SourceClock>\n+      struct clock_time_conversion<utc_clock, _SourceClock>\n+      {\n+\ttemplate<typename _Duration, typename _Src = _SourceClock>\n+\t  auto\n+\t  operator()(const time_point<_SourceClock, _Duration>& __t) const\n+\t  -> decltype(_Src::to_utc(__t))\n+\t  {\n+\t    using _Ret = decltype(_SourceClock::to_utc(__t));\n+\t    static_assert(__is_time_point_for_v<_Ret, utc_clock>);\n+\t    return _SourceClock::to_utc(__t);\n+\t  }\n+      };\n+\n+    template<typename _DestClock>\n+      struct clock_time_conversion<_DestClock, utc_clock>\n+      {\n+\ttemplate<typename _Duration, typename _Dest = _DestClock>\n+\t  auto\n+\t  operator()(const utc_time<_Duration>& __t) const\n+\t  -> decltype(_Dest::from_utc(__t))\n+\t  {\n+\t    using _Ret = decltype(_DestClock::from_utc(__t));\n+\t    static_assert(__is_time_point_for_v<_Ret, _DestClock>);\n+\t    return _DestClock::from_utc(__t);\n+\t  }\n+      };\n+\n+    /// @cond undocumented\n+    namespace __detail\n+    {\n+      template<typename _DestClock, typename _SourceClock, typename _Duration>\n+       concept __clock_convs\n+\t  = requires (const time_point<_SourceClock, _Duration>& __t) {\n+\t    clock_time_conversion<_DestClock, _SourceClock>{}(__t);\n+\t  };\n+\n+      template<typename _DestClock, typename _SourceClock, typename _Duration>\n+       concept __clock_convs_sys\n+\t  = requires (const time_point<_SourceClock, _Duration>& __t) {\n+\t    clock_time_conversion<_DestClock, system_clock>{}(\n+\t      clock_time_conversion<system_clock, _SourceClock>{}(__t));\n+\t  };\n+\n+      template<typename _DestClock, typename _SourceClock, typename _Duration>\n+       concept __clock_convs_utc\n+\t  = requires (const time_point<_SourceClock, _Duration>& __t) {\n+\t    clock_time_conversion<_DestClock, utc_clock>{}(\n+\t      clock_time_conversion<utc_clock, _SourceClock>{}(__t));\n+\t  };\n+\n+      template<typename _DestClock, typename _SourceClock, typename _Duration>\n+\tconcept __clock_convs_sys_utc\n+\t  = requires (const time_point<_SourceClock, _Duration>& __t) {\n+\t    clock_time_conversion<_DestClock, utc_clock>{}(\n+\t      clock_time_conversion<utc_clock, system_clock>{}(\n+\t\tclock_time_conversion<system_clock, _SourceClock>{}(__t)));\n+\t  };\n+\n+      template<typename _DestClock, typename _SourceClock, typename _Duration>\n+       concept __clock_convs_utc_sys\n+\t  = requires (const time_point<_SourceClock, _Duration>& __t) {\n+\t    clock_time_conversion<_DestClock, system_clock>{}(\n+\t      clock_time_conversion<system_clock, utc_clock>{}(\n+\t\tclock_time_conversion<utc_clock, _SourceClock>{}(__t)));\n+\t  };\n+\n+    } // namespace __detail\n+    /// @endcond\n+\n+    /// Convert a time point to a different clock.\n+    template<typename _DestClock, typename _SourceClock, typename _Duration>\n+      inline auto\n+      clock_cast(const time_point<_SourceClock, _Duration>& __t)\n+      requires __detail::__clock_convs<_DestClock, _SourceClock, _Duration>\n+\t|| __detail::__clock_convs_sys<_DestClock, _SourceClock, _Duration>\n+\t|| __detail::__clock_convs_utc<_DestClock, _SourceClock, _Duration>\n+\t|| __detail::__clock_convs_sys_utc<_DestClock, _SourceClock, _Duration>\n+\t|| __detail::__clock_convs_utc_sys<_DestClock, _SourceClock, _Duration>\n+      {\n+       constexpr bool __direct\n+\t = __detail::__clock_convs<_DestClock, _SourceClock, _Duration>;\n+       if constexpr (__direct)\n+\t {\n+\t   return clock_time_conversion<_DestClock, _SourceClock>{}(__t);\n+\t }\n+       else\n+\t {\n+\t   constexpr bool __convert_via_sys_clock\n+\t     = __detail::__clock_convs_sys<_DestClock, _SourceClock, _Duration>;\n+\t   constexpr bool __convert_via_utc_clock\n+\t     = __detail::__clock_convs_utc<_DestClock, _SourceClock, _Duration>;\n+\t   if constexpr (__convert_via_sys_clock)\n+\t     {\n+\t       static_assert(!__convert_via_utc_clock,\n+\t\t \"clock_cast requires a unique best conversion, but \"\n+\t\t \"conversion is possible via system_clock and also via\"\n+\t\t \"utc_clock\");\n+\t       return clock_time_conversion<_DestClock, system_clock>{}(\n+\t\t\tclock_time_conversion<system_clock, _SourceClock>{}(__t));\n+\t     }\n+\t   else if constexpr (__convert_via_utc_clock)\n+\t     {\n+\t       return clock_time_conversion<_DestClock, utc_clock>{}(\n+\t\t\tclock_time_conversion<utc_clock, _SourceClock>{}(__t));\n+\t     }\n+\t   else\n+\t     {\n+\t       constexpr bool __convert_via_sys_and_utc_clocks\n+\t\t = __detail::__clock_convs_sys_utc<_DestClock,\n+\t\t\t\t\t\t   _SourceClock,\n+\t\t\t\t\t\t   _Duration>;\n+\n+\t       if constexpr (__convert_via_sys_and_utc_clocks)\n+\t\t {\n+\t\t   constexpr bool __convert_via_utc_and_sys_clocks\n+\t\t     = __detail::__clock_convs_utc_sys<_DestClock,\n+\t\t\t\t\t\t       _SourceClock,\n+\t\t\t\t\t\t       _Duration>;\n+\t\t   static_assert(!__convert_via_utc_and_sys_clocks,\n+\t\t     \"clock_cast requires a unique best conversion, but \"\n+\t\t     \"conversion is possible via system_clock followed by \"\n+\t\t     \"utc_clock, and also via utc_clock followed by \"\n+\t\t     \"system_clock\");\n+\t\t   return clock_time_conversion<_DestClock, utc_clock>{}(\n+\t\t\t    clock_time_conversion<utc_clock, system_clock>{}(\n+\t\t\t      clock_time_conversion<system_clock, _SourceClock>{}(__t)));\n+\t\t }\n+\t       else\n+\t\t {\n+\t\t   return clock_time_conversion<_DestClock, system_clock>{}(\n+\t\t\t    clock_time_conversion<system_clock, utc_clock>{}(\n+\t\t\t      clock_time_conversion<utc_clock, _SourceClock>{}(__t)));\n+\t\t }\n+\t     }\n+\t }\n+      }\n+\n     // CALENDRICAL TYPES\n \n     // CLASS DECLARATIONS\n@@ -2055,6 +2412,387 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return __h + 12h;\n \t}\n     }\n+\n+    // C++20 [time.zones] Time zones\n+\n+    struct sys_info\n+    {\n+      sys_seconds begin;\n+      sys_seconds end;\n+      seconds offset;\n+      minutes save;\n+      string abbrev;\n+    };\n+\n+    struct local_info\n+    {\n+      static constexpr int unique      = 0;\n+      static constexpr int nonexistent = 1;\n+      static constexpr int ambiguous   = 2;\n+\n+      int result;\n+      sys_info first;\n+      sys_info second;\n+    };\n+\n+    class nonexistent_local_time : public runtime_error\n+    {\n+    public:\n+      template<typename _Duration>\n+\tnonexistent_local_time(const local_time<_Duration>& __tp,\n+\t\t\t       const local_info& __i)\n+\t: runtime_error(_S_make_what_str(__tp, __i))\n+\t{ __glibcxx_assert(__i.result == local_info::nonexistent); }\n+\n+    private:\n+      template<typename _Duration> // TODO\n+\tstatic string\n+\t_S_make_what_str(const local_time<_Duration>&, const local_info&);\n+    };\n+\n+    class ambiguous_local_time : public runtime_error\n+    {\n+    public:\n+      template<typename _Duration>\n+\tambiguous_local_time(const local_time<_Duration>& __tp,\n+\t\t\t       const local_info& __i)\n+\t: runtime_error(_S_make_what_str(__tp, __i))\n+\t{ __glibcxx_assert(__i.result == local_info::nonexistent); }\n+\n+    private:\n+      template<typename _Duration> // TODO\n+\tstatic string\n+\t_S_make_what_str(const local_time<_Duration>&, const local_info&);\n+    };\n+\n+    enum class choose { earliest, latest };\n+\n+    class time_zone\n+    {\n+    public:\n+      time_zone(time_zone&&) = default;\n+      time_zone& operator=(time_zone&&) = default;\n+\n+      string_view name() const noexcept { return _M_name; }\n+\n+      template<typename _Duration>\n+\tsys_info\n+\tget_info(const sys_time<_Duration>& __st) const;\n+\n+      template<typename _Duration>\n+\tlocal_info\n+\tget_info(const local_time<_Duration>& __tp) const;\n+\n+      template<typename _Duration>\n+\tsys_time<common_type_t<_Duration, seconds>>\n+\tto_sys(const local_time<_Duration>& __tp) const;\n+\n+      template<typename _Duration>\n+\tsys_time<common_type_t<_Duration, seconds>>\n+\tto_sys(const local_time<_Duration>& __tp, choose __z) const;\n+\n+      template<typename _Duration>\n+\tlocal_time<common_type_t<_Duration, seconds>>\n+\tto_local(const sys_time<_Duration>& __tp) const;\n+\n+      friend bool\n+      operator==(const time_zone& __x, const time_zone& __y) noexcept\n+      { return __x.name() == __y.name(); }\n+\n+      friend strong_ordering\n+      operator<=>(const time_zone& __x, const time_zone& __y) noexcept\n+      { return __x.name() <=> __y.name(); }\n+\n+    private:\n+      string _M_name;\n+      struct _Impl;\n+      unique_ptr<_Impl> _M_impl;\n+    };\n+\n+    struct tzdb;\n+    const time_zone* locate_zone(string_view __tz_name);\n+    const time_zone* current_zone();\n+\n+    class time_zone_link\n+    {\n+    public:\n+      time_zone_link(time_zone_link&&) = default;\n+      time_zone_link& operator=(time_zone_link&&) = default;\n+\n+      string_view name() const noexcept { return _M_name; }\n+      string_view target() const noexcept { return _M_target; }\n+\n+      friend bool\n+      operator==(const time_zone_link& __x, const time_zone_link& __y) noexcept\n+      { return __x.name() == __y.name(); }\n+\n+      friend strong_ordering\n+      operator<=>(const time_zone_link& __x, const time_zone_link& __y) noexcept\n+      { return __x.name() <=> __y.name(); }\n+\n+    private:\n+      friend const tzdb& reload_tzdb();\n+      // TODO unspecified additional constructors\n+      string _M_name;\n+      string _M_target;\n+    };\n+\n+    class leap_second\n+    {\n+    public:\n+      leap_second(const leap_second&) = default;\n+      leap_second& operator=(const leap_second&) = default;\n+\n+      constexpr sys_seconds\n+      date() const noexcept\n+      {\n+\tif (_M_s >= _M_s.zero()) [[likely]]\n+\t  return sys_seconds(_M_s);\n+\treturn sys_seconds(-_M_s);\n+      }\n+\n+      constexpr seconds\n+      value() const noexcept\n+      {\n+\tif (_M_s >= _M_s.zero()) [[likely]]\n+\t  return seconds(1);\n+\treturn seconds(-1);\n+      }\n+\n+      // This can be defaulted because the database will never contain two\n+      // leap_second objects with the same date but different signs.\n+      friend constexpr bool\n+      operator==(const leap_second&, const leap_second&) noexcept = default;\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const leap_second& __x, const leap_second& __y) noexcept\n+      { return __x.date() <=> __y.date(); }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator==(const leap_second& __x,\n+\t\t   const sys_time<_Duration>& __y) noexcept\n+\t{ return __x.date() == __y; }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator<(const leap_second& __x,\n+\t\t  const sys_time<_Duration>& __y) noexcept\n+\t{ return __x.date() < __y; }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator<(const sys_time<_Duration>& __x,\n+\t\t  const leap_second& __y) noexcept\n+\t{ return __x < __y.date(); }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator>(const leap_second& __x,\n+\t\t  const sys_time<_Duration>& __y) noexcept\n+\t{ return __y < __x.date(); }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator>(const sys_time<_Duration>& __x,\n+\t\t  const leap_second& __y) noexcept\n+\t{ return __y.date() < __x; }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator<=(const leap_second& __x,\n+\t\t  const sys_time<_Duration>& __y) noexcept\n+\t{ return !(__y < __x.date()); }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator<=(const sys_time<_Duration>& __x,\n+\t\t  const leap_second& __y) noexcept\n+\t{ return !(__y.date() < __x); }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator>=(const leap_second& __x,\n+\t\t  const sys_time<_Duration>& __y) noexcept\n+\t{ return !(__x.date() < __y); }\n+\n+      template<typename _Duration>\n+\tfriend constexpr bool\n+\toperator>=(const sys_time<_Duration>& __x,\n+\t\t  const leap_second& __y) noexcept\n+\t{ return !(__x < __y.date()); }\n+\n+      template<three_way_comparable_with<seconds> _Duration>\n+\tfriend constexpr auto\n+\toperator<=>(const leap_second& __x,\n+\t\t   const sys_time<_Duration>& __y) noexcept\n+\t{ return __x.date() <=> __y; }\n+\n+    private:\n+      explicit leap_second(seconds::rep __s) : _M_s(__s) { }\n+\n+      friend const tzdb& reload_tzdb();\n+      template<typename _Dur>\n+\tfriend leap_second_info\n+\tget_leap_second_info(const utc_time<_Dur>&);\n+\n+      seconds _M_s; // == date().time_since_epoch() * value().count()\n+    };\n+\n+    template<class _Tp> struct zoned_traits { };\n+\n+    template<>\n+      struct zoned_traits<const time_zone*>\n+      {\n+\tstatic const time_zone*\n+\tdefault_zone()\n+\t{ return std::chrono::locate_zone(\"UTC\"); }\n+\n+\tstatic const time_zone*\n+\tlocate_zone(string_view __name)\n+\t{ return std::chrono::locate_zone(__name); }\n+      };\n+\n+    struct tzdb\n+    {\n+      string version;\n+      vector<time_zone> zones;\n+      vector<time_zone_link> links;\n+      vector<leap_second> leap_seconds;\n+\n+      const time_zone*\n+      locate_zone(string_view __tz_name) const;\n+\n+      const time_zone*\n+      current_zone() const;\n+\n+    private:\n+      friend const tzdb& reload_tzdb();\n+\n+      struct _Rule;\n+      vector<_Rule> _M_rules;\n+    };\n+\n+    class tzdb_list\n+    {\n+      struct _Node;\n+    public:\n+      tzdb_list(const tzdb_list&) = delete;\n+      tzdb_list& operator=(const tzdb_list&) = delete;\n+\n+      class const_iterator\n+      {\n+      public:\n+\tusing value_type        = tzdb;\n+\tusing reference         = const tzdb&;\n+\tusing pointer           = const tzdb*;\n+\tusing difference_type   = ptrdiff_t;\n+\tusing iterator_category = forward_iterator_tag;\n+\n+\tconstexpr const_iterator() = default;\n+\tconst_iterator(const const_iterator&) = default;\n+\tconst_iterator(const_iterator&&) = default;\n+\tconst_iterator& operator=(const const_iterator&) = default;\n+\tconst_iterator& operator=(const_iterator&&) = default;\n+\n+\treference operator*() const noexcept;\n+\tpointer operator->() const noexcept { return &**this; }\n+\tconst_iterator& operator++();\n+\tconst_iterator operator++(int);\n+\n+\tbool operator==(const const_iterator&) const noexcept = default;\n+\n+      private:\n+\texplicit const_iterator(const shared_ptr<_Node>&) noexcept;\n+\n+\tshared_ptr<_Node> _M_node;\n+\tvoid* _M_reserved = nullptr;\n+      };\n+\n+      // TODO const tzdb& front() const noexcept;\n+\n+      const_iterator erase_after(const_iterator);\n+\n+      const_iterator begin() const noexcept;\n+      const_iterator end() const noexcept { return {}; }\n+      const_iterator cbegin() const noexcept { return begin(); }\n+      const_iterator cend() const noexcept { return end(); }\n+\n+    private:\n+      constexpr explicit tzdb_list(nullptr_t);\n+\n+      friend const tzdb_list& get_tzdb_list();\n+      friend const tzdb& get_tzdb();\n+      friend const tzdb& reload_tzdb();\n+\n+      static _Node* _S_head;\n+      static shared_ptr<_Node> _S_head_owner;\n+    };\n+\n+    // TODO\n+    // const tzdb_list& get_tzdb_list();\n+    // const tzdb& get_tzdb();\n+\n+    // const tzdb& reload_tzdb();\n+    // string remove_version();\n+\n+    template<typename _Duration, typename _TimeZonePtr = const time_zone*>\n+      class zoned_time; // TODO\n+\n+    using zoned_seconds = zoned_time<seconds>;\n+\n+    template<typename _Duration>\n+      leap_second_info\n+      get_leap_second_info(const utc_time<_Duration>& __ut)\n+      {\n+\tif constexpr (is_same_v<_Duration, seconds>)\n+\t  {\n+\t    // TODO move this function into the library and get leaps from tzdb.\n+\t    vector<seconds::rep> __leaps\n+\t    {\n+\t\t78796800, // 1 Jul 1972\n+\t\t94694400, // 1 Jan 1973\n+\t       126230400, // 1 Jan 1974\n+\t       157766400, // 1 Jan 1975\n+\t       189302400, // 1 Jan 1976\n+\t       220924800, // 1 Jan 1977\n+\t       252460800, // 1 Jan 1978\n+\t       283996800, // 1 Jan 1979\n+\t       315532800, // 1 Jan 1980\n+\t       362793600, // 1 Jul 1981\n+\t       394329600, // 1 Jul 1982\n+\t       425865600, // 1 Jul 1983\n+\t       489024000, // 1 Jul 1985\n+\t       567993600, // 1 Jan 1988\n+\t       631152000, // 1 Jan 1990\n+\t       662688000, // 1 Jan 1991\n+\t       709948800, // 1 Jul 1992\n+\t       741484800, // 1 Jul 1993\n+\t       773020800, // 1 Jul 1994\n+\t       820454400, // 1 Jan 1996\n+\t       867715200, // 1 Jul 1997\n+\t       915148800, // 1 Jan 1999\n+\t      1136073600, // 1 Jan 2006\n+\t      1230768000, // 1 Jan 2009\n+\t      1341100800, // 1 Jul 2012\n+\t      1435708800, // 1 Jul 2015\n+\t      1483228800, // 1 Jan 2017\n+\t    };\n+\n+\t    auto __s = __ut.time_since_epoch().count();\n+\t    auto __pos = std::upper_bound(__leaps.begin(), __leaps.end(), __s);\n+\t    return {\n+\t      __pos != __leaps.begin() && __pos[-1] == __s,\n+\t      seconds{__pos - __leaps.begin()}\n+\t    };\n+\t  }\n+\telse\n+\t  {\n+\t    auto __s = chrono::time_point_cast<seconds>(__ut);\n+\t    return chrono::get_leap_second_info(__s);\n+\t  }\n+      }\n+\n     /// @} group chrono\n #endif // C++20\n   } // namespace chrono"}, {"sha": "9403ee1eccab6e9cbcd5a258befc36397783e246", "filename": "libstdc++-v3/testsuite/std/time/clock/gps/1.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2F1.cc?ref=1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std::chrono;\n+\n+  gps_seconds gps_epoch{0s};\n+  utc_seconds gps_as_utc{sys_days{1980y/January/Sunday[1]}.time_since_epoch() + 9s};\n+\n+  VERIFY( clock_cast<utc_clock>(gps_epoch) == gps_as_utc );\n+  VERIFY( gps_epoch == clock_cast<gps_clock>(gps_as_utc) );\n+\n+  tai_seconds tai_epoch{0s};\n+  VERIFY( clock_cast<tai_clock>(clock_cast<gps_clock>(tai_epoch)) == tai_epoch );\n+}\n+\n+void\n+test02()\n+{\n+  using namespace std::chrono;\n+\n+  sys_days d{2022y/November/12};\n+  VERIFY( clock_cast<system_clock>(clock_cast<gps_clock>(d)) == d );\n+  gps_seconds t(1234567s);\n+  VERIFY( clock_cast<gps_clock>(clock_cast<system_clock>(t)) == t );\n+  VERIFY( clock_cast<gps_clock>(clock_cast<utc_clock>(t)) == t );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "9b36f023c683cde82823e9f14390fa0546738174", "filename": "libstdc++-v3/testsuite/std/time/clock/tai/1.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2F1.cc?ref=1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std::chrono;\n+\n+  tai_seconds tai_epoch{0s};\n+  utc_seconds tai_as_utc{sys_days{1958y/January/1}.time_since_epoch() - 10s};\n+\n+  VERIFY( clock_cast<utc_clock>(tai_epoch) == tai_as_utc );\n+  VERIFY( tai_epoch == clock_cast<tai_clock>(tai_as_utc) );\n+\n+  sys_days y2k{2000y/January/1};\n+  tai_seconds y2k_as_tai{clock_cast<tai_clock>(y2k)};\n+  utc_seconds y2k_as_utc = utc_clock::from_sys(y2k);\n+  VERIFY( clock_cast<utc_clock>(y2k_as_tai) == y2k_as_utc );\n+  VERIFY( y2k_as_tai == clock_cast<tai_clock>(y2k_as_utc) );\n+}\n+\n+void\n+test02()\n+{\n+  using namespace std::chrono;\n+\n+  sys_days d{2022y/November/12};\n+  VERIFY( clock_cast<system_clock>(clock_cast<tai_clock>(d)) == d );\n+  tai_seconds t(1234567s);\n+  VERIFY( clock_cast<tai_clock>(clock_cast<system_clock>(t)) == t );\n+  VERIFY( clock_cast<tai_clock>(clock_cast<utc_clock>(t)) == t );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "eef5f3c3a48582f078520cee555195ea21a628c8", "filename": "libstdc++-v3/testsuite/std/time/clock/utc/1.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2F1.cc?ref=1736bf5a61c7364c5da6fa52e5e2bfdbc9507c97", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std::chrono;\n+\n+  auto epoch = sys_seconds{sys_days{1970y/January/1}};\n+  auto utc_epoch = clock_cast<utc_clock>(epoch);\n+  VERIFY( utc_epoch.time_since_epoch() == 0s );\n+\n+  auto y2k = sys_seconds{sys_days{2000y/January/1}};\n+  auto utc_y2k = clock_cast<utc_clock>(y2k);\n+  VERIFY( utc_y2k.time_since_epoch() == 946'684'822s );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}