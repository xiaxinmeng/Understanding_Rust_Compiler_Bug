{"sha": "58782098af9dfb58f6fc42800748c45252965923", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3ODIwOThhZjlkZmI1OGY2ZmM0MjgwMDc0OGM0NTI1Mjk2NTkyMw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-17T15:55:18Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-17T15:55:18Z"}, "message": "toplev.c: PROTO -> PARAMS.\n\n        * toplev.c: PROTO -> PARAMS.\n        * toplev.h: Likewise.\n        * tree.c: Likewise.\n        * tree.h: Likewise.\n        * unroll.c: Likewise.\n        * varasm.c: Likewise.\n        * varray.c: Likewise.\n        * varray.h: Likewise.\n\nFrom-SVN: r31462", "tree": {"sha": "55ae9d1eeeb8329d97ea7ba1a6acca1e606fef5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55ae9d1eeeb8329d97ea7ba1a6acca1e606fef5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58782098af9dfb58f6fc42800748c45252965923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58782098af9dfb58f6fc42800748c45252965923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58782098af9dfb58f6fc42800748c45252965923", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58782098af9dfb58f6fc42800748c45252965923/comments", "author": null, "committer": null, "parents": [{"sha": "cdadb1dda076203885b3a3845fe41a9a87a249ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdadb1dda076203885b3a3845fe41a9a87a249ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdadb1dda076203885b3a3845fe41a9a87a249ba"}], "stats": {"total": 1045, "additions": 528, "deletions": 517}, "files": [{"sha": "949f05aa222046f13640cdf716d728326e00b225", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -1,3 +1,14 @@\n+2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* toplev.c: PROTO -> PARAMS.\n+\t* toplev.h: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* unroll.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varray.c: Likewise.\n+\t* varray.h: Likewise.\n+\n 2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* reload.c: PROTO -> PARAMS."}, {"sha": "7fac2af36011a485564b24d7e23fac126a597582", "filename": "gcc/toplev.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -149,35 +149,35 @@ extern char *version_string;\n extern int size_directive_output;\n extern tree last_assemble_variable_decl;\n \n-static void set_target_switch PROTO((const char *));\n-static const char *decl_name PROTO((tree, int));\n+static void set_target_switch PARAMS ((const char *));\n+static const char *decl_name PARAMS ((tree, int));\n \n-extern void set_fatal_function PROTO((void (*)(const char *, va_list)));\n-static void float_signal PROTO((int)) ATTRIBUTE_NORETURN;\n-static void pipe_closed PROTO((int)) ATTRIBUTE_NORETURN;\n+extern void set_fatal_function PARAMS ((void (*)(const char *, va_list)));\n+static void float_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n+static void pipe_closed PARAMS ((int)) ATTRIBUTE_NORETURN;\n #ifdef ASM_IDENTIFY_LANGUAGE\n /* This might or might not be used in ASM_IDENTIFY_LANGUAGE. */\n-static void output_lang_identify PROTO((FILE *)) ATTRIBUTE_UNUSED;\n+static void output_lang_identify PARAMS ((FILE *)) ATTRIBUTE_UNUSED;\n #endif\n-static void open_dump_file PROTO((const char *, const char *));\n-static void close_dump_file PROTO((void (*) (FILE *, rtx), rtx));\n-static void dump_rtl PROTO((const char *, tree, void (*) (FILE *, rtx), rtx));\n-static void clean_dump_file PROTO((const char *));\n-static void compile_file PROTO((char *));\n-static void display_help PROTO ((void));\n-static void mark_file_stack PROTO ((void *));\n-\n-static void decode_d_option PROTO ((const char *));\n-static int  decode_f_option PROTO ((const char *));\n-static int  decode_W_option PROTO ((const char *));\n-static int  decode_g_option PROTO ((const char *));\n-static unsigned independent_decode_option PROTO ((int, char **, unsigned));\n-\n-static void print_version PROTO((FILE *, const char *));\n-static int print_single_switch PROTO((FILE *, int, int, const char *,\n+static void open_dump_file PARAMS ((const char *, const char *));\n+static void close_dump_file PARAMS ((void (*) (FILE *, rtx), rtx));\n+static void dump_rtl PARAMS ((const char *, tree, void (*) (FILE *, rtx), rtx));\n+static void clean_dump_file PARAMS ((const char *));\n+static void compile_file PARAMS ((char *));\n+static void display_help PARAMS ((void));\n+static void mark_file_stack PARAMS ((void *));\n+\n+static void decode_d_option PARAMS ((const char *));\n+static int  decode_f_option PARAMS ((const char *));\n+static int  decode_W_option PARAMS ((const char *));\n+static int  decode_g_option PARAMS ((const char *));\n+static unsigned independent_decode_option PARAMS ((int, char **, unsigned));\n+\n+static void print_version PARAMS ((FILE *, const char *));\n+static int print_single_switch PARAMS ((FILE *, int, int, const char *,\n \t\t\t\t      const char *, const char *,\n \t\t\t\t      const char *, const char *));\n-static void print_switch_values PROTO((FILE *, int, int, const char *,\n+static void print_switch_values PARAMS ((FILE *, int, int, const char *,\n \t\t\t\t       const char *, const char *));\n \n /* Length of line when printing switch values.  */\n@@ -315,22 +315,22 @@ int sorrycount = 0;\n      2: and any other information that might be interesting, such as function\n         parameter types in C++.  */\n \n-const char *(*decl_printable_name)\tPROTO ((tree, int));\n+const char *(*decl_printable_name)\tPARAMS ((tree, int));\n \n /* Pointer to function to compute rtl for a language-specific tree code.  */\n \n typedef rtx (*lang_expand_expr_t)\n-  PROTO ((union tree_node *, rtx, enum machine_mode,\n+  PARAMS ((union tree_node *, rtx, enum machine_mode,\n \t  enum expand_modifier modifier));\n \n lang_expand_expr_t lang_expand_expr = 0;\n \n-tree (*lang_expand_constant) PROTO((tree)) = 0;\n+tree (*lang_expand_constant) PARAMS ((tree)) = 0;\n \n /* Pointer to function to finish handling an incomplete decl at the\n    end of compilation.  */\n \n-void (*incomplete_decl_finalize_hook) PROTO((tree)) = 0;\n+void (*incomplete_decl_finalize_hook) PARAMS ((tree)) = 0;\n \n /* Nonzero if generating code to do profiling.  */\n \n@@ -1557,7 +1557,7 @@ set_float_handler (handler)\n \n int\n do_float_handler (fn, data)\n-  void (*fn) PROTO ((PTR));\n+  void (*fn) PARAMS ((PTR));\n   PTR data;\n {\n   jmp_buf buf;\n@@ -1742,7 +1742,7 @@ open_dump_file (suffix, function_name)\n /* Routine to close a dump file.  */\n static void\n close_dump_file (func, insns)\n-     void (*func) PROTO ((FILE *, rtx));\n+     void (*func) PARAMS ((FILE *, rtx));\n      rtx    insns;\n {\n   TIMEVAR\n@@ -1765,7 +1765,7 @@ static void\n dump_rtl (suffix, decl, func, insns)\n      const char *suffix;\n      tree   decl;\n-     void (*func) PROTO ((FILE *, rtx));\n+     void (*func) PARAMS ((FILE *, rtx));\n      rtx    insns;\n {\n   open_dump_file (suffix, decl_printable_name (decl, 2));\n@@ -4486,7 +4486,7 @@ independent_decode_option (argc, argv, strings_processed)\n    Exit code is 35 if can't open files, 34 if fatal error,\n    33 if had nonfatal errors, else success.  */\n \n-extern int main PROTO ((int, char **));\n+extern int main PARAMS ((int, char **));\n \n int\n main (argc, argv)"}, {"sha": "7145dd2e549154f1de1de124cc485e7a59dcd2f8", "filename": "gcc/toplev.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -26,26 +26,26 @@ union tree_node;\n struct rtx_def;\n #endif\n \n-extern int read_integral_parameter\tPROTO ((const char *, const char *,\n+extern int read_integral_parameter\tPARAMS ((const char *, const char *,\n \t\t\t\t\t\tconst int));\n-extern int count_error\t\t\tPROTO ((int));\n-extern void strip_off_ending\t\tPROTO ((char *, int));\n-extern void print_time\t\t\tPROTO ((const char *, int));\n-extern void debug_start_source_file\tPROTO ((char *));\n-extern void debug_end_source_file\tPROTO ((unsigned));\n-extern void debug_define\t\tPROTO ((unsigned, char *));\n-extern void debug_undef\t\t\tPROTO ((unsigned, char *));\n-extern void fatal\t\t\tPVPROTO ((const char *, ...))\n+extern int count_error\t\t\tPARAMS ((int));\n+extern void strip_off_ending\t\tPARAMS ((char *, int));\n+extern void print_time\t\t\tPARAMS ((const char *, int));\n+extern void debug_start_source_file\tPARAMS ((char *));\n+extern void debug_end_source_file\tPARAMS ((unsigned));\n+extern void debug_define\t\tPARAMS ((unsigned, char *));\n+extern void debug_undef\t\t\tPARAMS ((unsigned, char *));\n+extern void fatal\t\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void fatal_io_error\t\tPROTO ((const char *))\n+extern void fatal_io_error\t\tPARAMS ((const char *))\n   ATTRIBUTE_NORETURN;\n-extern void pfatal_with_name\t\tPROTO ((const char *))\n+extern void pfatal_with_name\t\tPARAMS ((const char *))\n   ATTRIBUTE_NORETURN;\n-extern void _fatal_insn_not_found\tPROTO ((struct rtx_def *,\n+extern void _fatal_insn_not_found\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\tconst char *, int,\n \t\t\t\t\t\tconst char *))\n   ATTRIBUTE_NORETURN;\n-extern void _fatal_insn\t\t\tPROTO ((const char *,\n+extern void _fatal_insn\t\t\tPARAMS ((const char *,\n \t\t\t\t\t\tstruct rtx_def *,\n \t\t\t\t\t\tconst char *, int,\n \t\t\t\t\t\tconst char *))\n@@ -62,73 +62,73 @@ extern void _fatal_insn\t\t\tPROTO ((const char *,\n #define fatal_insn_not_found(insn) \\\n \t_fatal_insn_not_found (insn, __FILE__, __LINE__, 0)\n #endif\n-extern void warning\t\t\tPVPROTO ((const char *, ...))\n+extern void warning\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void error\t\t\tPVPROTO ((const char *, ...))\n+extern void error\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void pedwarn\t\t\tPVPROTO ((const char *, ...))\n+extern void pedwarn\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern void pedwarn_with_file_and_line\tPVPROTO ((const char *, int,\n+extern void pedwarn_with_file_and_line\tPARAMS ((const char *, int,\n \t\t\t\t\t\t  const char *, ...))\n   ATTRIBUTE_PRINTF_3;\n-extern void warning_with_file_and_line\tPVPROTO ((const char *, int,\n+extern void warning_with_file_and_line\tPARAMS ((const char *, int,\n \t\t\t\t\t\t  const char *, ...))\n   ATTRIBUTE_PRINTF_3;\n-extern void error_with_file_and_line\tPVPROTO ((const char *, int,\n+extern void error_with_file_and_line\tPARAMS ((const char *, int,\n \t\t\t\t\t\t  const char *, ...))\n   ATTRIBUTE_PRINTF_3;\n-extern void sorry\t\t\tPVPROTO ((const char *, ...))\n+extern void sorry\t\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1;\n-extern void really_sorry\t\tPVPROTO((const char *, ...))\n+extern void really_sorry\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void default_print_error_function PROTO ((const char *));\n-extern void report_error_function\tPROTO ((const char *));\n+extern void default_print_error_function PARAMS ((const char *));\n+extern void report_error_function\tPARAMS ((const char *));\n \n-extern void rest_of_decl_compilation\tPROTO ((union tree_node *,\n+extern void rest_of_decl_compilation\tPARAMS ((union tree_node *,\n \t\t\t\t\t\tconst char *, int, int));\n-extern void rest_of_type_compilation\tPROTO ((union tree_node *, int));\n-extern void rest_of_compilation\t\tPROTO ((union tree_node *));\n+extern void rest_of_type_compilation\tPARAMS ((union tree_node *, int));\n+extern void rest_of_compilation\t\tPARAMS ((union tree_node *));\n \n /* The *_with_decl functions aren't suitable for ATTRIBUTE_PRINTF. */\n-extern void pedwarn_with_decl\t\tPVPROTO ((union tree_node *,\n+extern void pedwarn_with_decl\t\tPARAMS ((union tree_node *,\n \t\t\t\t\t\t  const char *, ...));\n-extern void warning_with_decl\t\tPVPROTO ((union tree_node *,\n+extern void warning_with_decl\t\tPARAMS ((union tree_node *,\n \t\t\t\t\t\t  const char *, ...));\n-extern void error_with_decl\t\tPVPROTO ((union tree_node *,\n+extern void error_with_decl\t\tPARAMS ((union tree_node *,\n \t\t\t\t\t\t  const char *, ...));\n \n-extern void announce_function\t\tPROTO ((union tree_node *));\n+extern void announce_function\t\tPARAMS ((union tree_node *));\n \n-extern void error_for_asm\t\tPVPROTO((struct rtx_def *,\n+extern void error_for_asm\t\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\t const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n-extern void warning_for_asm\t\tPVPROTO((struct rtx_def *,\n+extern void warning_for_asm\t\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\t const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n #if defined (_JBLEN) || defined (setjmp)\n-extern void set_float_handler PROTO((jmp_buf));\n-extern int push_float_handler PROTO((jmp_buf, jmp_buf));\n-extern void pop_float_handler PROTO((int, jmp_buf));\n+extern void set_float_handler PARAMS ((jmp_buf));\n+extern int push_float_handler PARAMS ((jmp_buf, jmp_buf));\n+extern void pop_float_handler PARAMS ((int, jmp_buf));\n #endif\n-extern int do_float_handler PROTO((void (*) (PTR), PTR));\n+extern int do_float_handler PARAMS ((void (*) (PTR), PTR));\n \n #ifdef BUFSIZ\n-extern void output_quoted_string\tPROTO ((FILE *, const char *));\n-extern void output_file_directive\tPROTO ((FILE *, const char *));\n+extern void output_quoted_string\tPARAMS ((FILE *, const char *));\n+extern void output_file_directive\tPARAMS ((FILE *, const char *));\n #endif\n-extern void do_abort\t\t\tPROTO ((void)) ATTRIBUTE_NORETURN;\n-extern void botch\t\t\tPROTO ((const char *))\n+extern void do_abort\t\t\tPARAMS ((void)) ATTRIBUTE_NORETURN;\n+extern void botch\t\t\tPARAMS ((const char *))\n   ATTRIBUTE_NORETURN;\n \n #ifdef BUFSIZ\n-extern void fnotice\t\t\tPROTO ((FILE *, const char *, ...))\n+extern void fnotice\t\t\tPARAMS ((FILE *, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n #endif\n \n-extern int wrapup_global_declarations   PROTO ((union tree_node **, int));\n-extern void check_global_declarations   PROTO ((union tree_node **, int));\n-extern void note_deferral_of_defined_inline_function PROTO ((union tree_node *));\n-extern void set_message_length\t\tPROTO ((int));\n+extern int wrapup_global_declarations   PARAMS ((union tree_node **, int));\n+extern void check_global_declarations   PARAMS ((union tree_node **, int));\n+extern void note_deferral_of_defined_inline_function PARAMS ((union tree_node *));\n+extern void set_message_length\t\tPARAMS ((int));\n extern int errorcount;\n extern int warningcount;\n extern int sorrycount;"}, {"sha": "5dcc32b14e4fcbbb479b298349089565b223c993", "filename": "gcc/tree.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -46,9 +46,9 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n /* obstack.[ch] explicitly declined to prototype this. */\n-extern int _obstack_allocated_p PROTO ((struct obstack *h, PTR obj));\n+extern int _obstack_allocated_p PARAMS ((struct obstack *h, PTR obj));\n \n-static void unsave_expr_now_r PROTO ((tree));\n+static void unsave_expr_now_r PARAMS ((tree));\n \n /* Tree nodes of permanent duration are allocated in this obstack.\n    They are the identifier nodes, and everything outside of\n@@ -245,7 +245,7 @@ static int next_type_uid = 1;\n \n /* The language-specific function for alias analysis.  If NULL, the\n    language does not do any special alias analysis.  */\n-int (*lang_get_alias_set) PROTO((tree));\n+int (*lang_get_alias_set) PARAMS ((tree));\n \n /* Here is how primitive or already-canonicalized types' hash\n    codes are made.  */\n@@ -271,19 +271,19 @@ struct type_hash\n #define TYPE_HASH_SIZE 59\n struct type_hash *type_hash_table[TYPE_HASH_SIZE];\n \n-static void build_real_from_int_cst_1 PROTO((PTR));\n-static void set_type_quals PROTO((tree, int));\n-static void append_random_chars PROTO((char *));\n-static void mark_type_hash PROTO ((void *));\n-static void fix_sizetype PROTO ((tree));\n+static void build_real_from_int_cst_1 PARAMS ((PTR));\n+static void set_type_quals PARAMS ((tree, int));\n+static void append_random_chars PARAMS ((char *));\n+static void mark_type_hash PARAMS ((void *));\n+static void fix_sizetype PARAMS ((tree));\n \n /* If non-null, these are language-specific helper functions for\n    unsave_expr_now.  If present, LANG_UNSAVE is called before its\n    argument (an UNSAVE_EXPR) is to be unsaved, and all other\n    processing in unsave_expr_now is aborted.  LANG_UNSAVE_EXPR_NOW is\n    called from unsave_expr_1 for language-specific tree codes.  */\n-void (*lang_unsave) PROTO((tree *));\n-void (*lang_unsave_expr_now) PROTO((tree));\n+void (*lang_unsave) PARAMS ((tree *));\n+void (*lang_unsave_expr_now) PARAMS ((tree));\n \n /* The string used as a placeholder instead of a source file name for\n    built-in tree nodes.  The variable, which is dynamically allocated,\n@@ -348,8 +348,8 @@ gcc_obstack_init (obstack)\n #define OBSTACK_CHUNK_FREE free\n #endif\n   _obstack_begin (obstack, OBSTACK_CHUNK_SIZE, 0,\n-\t\t  (void *(*) PROTO ((long))) OBSTACK_CHUNK_ALLOC,\n-\t\t  (void (*) PROTO ((void *))) OBSTACK_CHUNK_FREE);\n+\t\t  (void *(*) PARAMS ((long))) OBSTACK_CHUNK_ALLOC,\n+\t\t  (void (*) PARAMS ((void *))) OBSTACK_CHUNK_FREE);\n }\n \n /* Save all variables describing the current status into the structure\n@@ -1117,7 +1117,7 @@ make_node (code)\n /* A front-end can reset this to an appropriate function if types need\n    special handling.  */\n \n-tree (*make_lang_type_fn) PROTO((enum tree_code)) = make_node;\n+tree (*make_lang_type_fn) PARAMS ((enum tree_code)) = make_node;\n \n /* Return a new type (with the indicated CODE), doing whatever\n    language-specific processing is required.  */\n@@ -3035,7 +3035,7 @@ stabilize_reference_1 (e)\n    Constants, decls, types and misc nodes cannot be.  */\n \n tree\n-build VPROTO((enum tree_code code, tree tt, ...))\n+build VPARAMS ((enum tree_code code, tree tt, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum tree_code code;\n@@ -3202,7 +3202,7 @@ build1 (code, type, node)\n    or even garbage if their values do not matter.  */\n \n tree\n-build_nt VPROTO((enum tree_code code, ...))\n+build_nt VPARAMS ((enum tree_code code, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum tree_code code;\n@@ -3232,7 +3232,7 @@ build_nt VPROTO((enum tree_code code, ...))\n    on the temp_decl_obstack, regardless.  */\n \n tree\n-build_parse_node VPROTO((enum tree_code code, ...))\n+build_parse_node VPARAMS ((enum tree_code code, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum tree_code code;"}, {"sha": "84a333de367a17b75d065ad9f78839c11c56a3e2", "filename": "gcc/tree.h", "status": "modified", "additions": 379, "deletions": 379, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -353,10 +353,10 @@ struct tree_common\n \t\t\t      __LINE__, __PRETTY_FUNCTION__);\t\t\\\n     __t; })\n \n-extern void tree_check_failed PROTO((const tree, enum tree_code,\n+extern void tree_check_failed PARAMS ((const tree, enum tree_code,\n \t\t\t\t     const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n-extern void tree_class_check_failed PROTO((const tree, char,\n+extern void tree_class_check_failed PARAMS ((const tree, char,\n \t\t\t\t\t   const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n \n@@ -1568,142 +1568,142 @@ extern tree global_trees[TI_MAX];\n #define exact_log2(N) exact_log2_wide ((unsigned HOST_WIDE_INT) (N))\n #define floor_log2(N) floor_log2_wide ((unsigned HOST_WIDE_INT) (N))\n #endif\n-extern int exact_log2_wide             PROTO((unsigned HOST_WIDE_INT));\n-extern int floor_log2_wide             PROTO((unsigned HOST_WIDE_INT));\n+extern int exact_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n+extern int floor_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n \n-extern char *oballoc\t\t\tPROTO((int));\n-extern char *permalloc\t\t\tPROTO((int));\n-extern char *savealloc\t\t\tPROTO((int));\n-extern char *expralloc\t\t\tPROTO((int));\n+extern char *oballoc\t\t\tPARAMS ((int));\n+extern char *permalloc\t\t\tPARAMS ((int));\n+extern char *savealloc\t\t\tPARAMS ((int));\n+extern char *expralloc\t\t\tPARAMS ((int));\n \n /* Lowest level primitive for allocating a node.\n    The TREE_CODE is the only argument.  Contents are initialized\n    to zero except for a few of the common fields.  */\n \n-extern tree make_node\t\t\tPROTO((enum tree_code));\n-extern tree make_lang_type\t\tPROTO((enum tree_code));\n-extern tree (*make_lang_type_fn)\t\tPROTO((enum tree_code));\n+extern tree make_node\t\t\tPARAMS ((enum tree_code));\n+extern tree make_lang_type\t\tPARAMS ((enum tree_code));\n+extern tree (*make_lang_type_fn)\t\tPARAMS ((enum tree_code));\n \n /* Make a copy of a node, with all the same contents except\n    for TREE_PERMANENT.  (The copy is permanent\n    iff nodes being made now are permanent.)  */\n \n-extern tree copy_node\t\t\tPROTO((tree));\n+extern tree copy_node\t\t\tPARAMS ((tree));\n \n /* Make a copy of a chain of TREE_LIST nodes.  */\n \n-extern tree copy_list\t\t\tPROTO((tree));\n+extern tree copy_list\t\t\tPARAMS ((tree));\n \n /* Make a TREE_VEC.  */\n \n-extern tree make_tree_vec\t\tPROTO((int));\n+extern tree make_tree_vec\t\tPARAMS ((int));\n \n /* Return the (unique) IDENTIFIER_NODE node for a given name.\n    The name is supplied as a char *.  */\n \n-extern tree get_identifier\t\tPROTO((const char *));\n+extern tree get_identifier\t\tPARAMS ((const char *));\n \n /* If an identifier with the name TEXT (a null-terminated string) has\n    previously been referred to, return that node; otherwise return\n    NULL_TREE.  */\n \n-extern tree maybe_get_identifier\tPROTO((const char *));\n+extern tree maybe_get_identifier\tPARAMS ((const char *));\n \n /* Construct various types of nodes.  */\n \n #define build_int_2(LO,HI)  \\\n   build_int_2_wide ((HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))\n \n-extern tree build\t\t\tPVPROTO((enum tree_code, tree, ...));\n-extern tree build_nt\t\t\tPVPROTO((enum tree_code, ...));\n-extern tree build_parse_node\t\tPVPROTO((enum tree_code, ...));\n-\n-extern tree build_int_2_wide\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT));\n-extern tree build_real\t\t\tPROTO((tree, REAL_VALUE_TYPE));\n-extern tree build_real_from_int_cst \tPROTO((tree, tree));\n-extern tree build_complex\t\tPROTO((tree, tree, tree));\n-extern tree build_string\t\tPROTO((int, const char *));\n-extern tree build1\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree build_tree_list\t\tPROTO((tree, tree));\n-extern tree build_decl_list\t\tPROTO((tree, tree));\n-extern tree build_expr_list\t\tPROTO((tree, tree));\n-extern tree build_decl\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree build_block\t\t\tPROTO((tree, tree, tree, tree, tree));\n-extern tree build_expr_wfl              PROTO((tree, const char *, int, int));\n+extern tree build\t\t\tPARAMS ((enum tree_code, tree, ...));\n+extern tree build_nt\t\t\tPARAMS ((enum tree_code, ...));\n+extern tree build_parse_node\t\tPARAMS ((enum tree_code, ...));\n+\n+extern tree build_int_2_wide\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT));\n+extern tree build_real\t\t\tPARAMS ((tree, REAL_VALUE_TYPE));\n+extern tree build_real_from_int_cst \tPARAMS ((tree, tree));\n+extern tree build_complex\t\tPARAMS ((tree, tree, tree));\n+extern tree build_string\t\tPARAMS ((int, const char *));\n+extern tree build1\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern tree build_tree_list\t\tPARAMS ((tree, tree));\n+extern tree build_decl_list\t\tPARAMS ((tree, tree));\n+extern tree build_expr_list\t\tPARAMS ((tree, tree));\n+extern tree build_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern tree build_block\t\t\tPARAMS ((tree, tree, tree, tree, tree));\n+extern tree build_expr_wfl              PARAMS ((tree, const char *, int, int));\n \n /* Construct various nodes representing data types.  */\n \n-extern tree make_signed_type\t\tPROTO((int));\n-extern tree make_unsigned_type\t\tPROTO((int));\n-extern void set_sizetype\t\tPROTO((tree));\n-extern tree signed_or_unsigned_type \tPROTO((int, tree));\n-extern void fixup_unsigned_type\t\tPROTO((tree));\n-extern tree build_pointer_type\t\tPROTO((tree));\n-extern tree build_reference_type \tPROTO((tree));\n-extern tree build_index_type\t\tPROTO((tree));\n-extern tree build_index_2_type\t\tPROTO((tree, tree));\n-extern tree build_array_type\t\tPROTO((tree, tree));\n-extern tree build_function_type\t\tPROTO((tree, tree));\n-extern tree build_method_type\t\tPROTO((tree, tree));\n-extern tree build_offset_type\t\tPROTO((tree, tree));\n-extern tree build_complex_type\t\tPROTO((tree));\n-extern tree array_type_nelts\t\tPROTO((tree));\n-\n-extern tree value_member\t\tPROTO((tree, tree));\n-extern tree purpose_member\t\tPROTO((tree, tree));\n-extern tree binfo_member\t\tPROTO((tree, tree));\n-extern int attribute_hash_list\t\tPROTO((tree));\n-extern int attribute_list_equal\t\tPROTO((tree, tree));\n-extern int attribute_list_contained\tPROTO((tree, tree));\n-extern int tree_int_cst_equal\t\tPROTO((tree, tree));\n-extern int tree_int_cst_lt\t\tPROTO((tree, tree));\n-extern int tree_int_cst_sgn\t\tPROTO((tree));\n-extern int index_type_equal\t\tPROTO((tree, tree));\n-extern tree get_inner_array_type\tPROTO((tree));\n+extern tree make_signed_type\t\tPARAMS ((int));\n+extern tree make_unsigned_type\t\tPARAMS ((int));\n+extern void set_sizetype\t\tPARAMS ((tree));\n+extern tree signed_or_unsigned_type \tPARAMS ((int, tree));\n+extern void fixup_unsigned_type\t\tPARAMS ((tree));\n+extern tree build_pointer_type\t\tPARAMS ((tree));\n+extern tree build_reference_type \tPARAMS ((tree));\n+extern tree build_index_type\t\tPARAMS ((tree));\n+extern tree build_index_2_type\t\tPARAMS ((tree, tree));\n+extern tree build_array_type\t\tPARAMS ((tree, tree));\n+extern tree build_function_type\t\tPARAMS ((tree, tree));\n+extern tree build_method_type\t\tPARAMS ((tree, tree));\n+extern tree build_offset_type\t\tPARAMS ((tree, tree));\n+extern tree build_complex_type\t\tPARAMS ((tree));\n+extern tree array_type_nelts\t\tPARAMS ((tree));\n+\n+extern tree value_member\t\tPARAMS ((tree, tree));\n+extern tree purpose_member\t\tPARAMS ((tree, tree));\n+extern tree binfo_member\t\tPARAMS ((tree, tree));\n+extern int attribute_hash_list\t\tPARAMS ((tree));\n+extern int attribute_list_equal\t\tPARAMS ((tree, tree));\n+extern int attribute_list_contained\tPARAMS ((tree, tree));\n+extern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\n+extern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\n+extern int tree_int_cst_sgn\t\tPARAMS ((tree));\n+extern int index_type_equal\t\tPARAMS ((tree, tree));\n+extern tree get_inner_array_type\tPARAMS ((tree));\n \n /* From expmed.c.  Since rtl.h is included after tree.h, we can't\n    put the prototype here.  Rtl.h does declare the prototype if\n    tree.h had been included.  */\n \n-extern tree make_tree\t\t\tPROTO((tree, struct rtx_def *));\n+extern tree make_tree\t\t\tPARAMS ((tree, struct rtx_def *));\n \f\n /* Return a type like TTYPE except that its TYPE_ATTRIBUTES\n    is ATTRIBUTE.\n \n    Such modified types already made are recorded so that duplicates\n    are not made. */\n \n-extern tree build_type_attribute_variant PROTO((tree, tree));\n-extern tree build_decl_attribute_variant PROTO((tree, tree));\n+extern tree build_type_attribute_variant PARAMS ((tree, tree));\n+extern tree build_decl_attribute_variant PARAMS ((tree, tree));\n \n-extern tree merge_machine_decl_attributes PROTO((tree, tree));\n-extern tree merge_machine_type_attributes PROTO((tree, tree));\n+extern tree merge_machine_decl_attributes PARAMS ((tree, tree));\n+extern tree merge_machine_type_attributes PARAMS ((tree, tree));\n \n /* Split a list of declspecs and attributes into two.  */\n \n-extern void split_specs_attrs\t\tPROTO((tree, tree *, tree *));\n+extern void split_specs_attrs\t\tPARAMS ((tree, tree *, tree *));\n \n /* Strip attributes from a list of combined specs and attrs.  */\n \n-extern tree strip_attrs\t\t\tPROTO((tree));\n+extern tree strip_attrs\t\t\tPARAMS ((tree));\n \n /* Return 1 if an attribute and its arguments are valid for a decl or type.  */\n \n-extern int valid_machine_attribute\tPROTO((tree, tree, tree, tree));\n+extern int valid_machine_attribute\tPARAMS ((tree, tree, tree, tree));\n \n /* Given a tree node and a string, return non-zero if the tree node is\n    a valid attribute name for the string.  */\n \n-extern int is_attribute_p\t\tPROTO((const char *, tree));\n+extern int is_attribute_p\t\tPARAMS ((const char *, tree));\n \n /* Given an attribute name and a list of attributes, return the list element\n    of the attribute or NULL_TREE if not found.  */\n \n-extern tree lookup_attribute\t\tPROTO((const char *, tree));\n+extern tree lookup_attribute\t\tPARAMS ((const char *, tree));\n \n /* Given two attributes lists, return a list of their union.  */\n \n-extern tree merge_attributes\t\tPROTO((tree, tree));\n+extern tree merge_attributes\t\tPARAMS ((tree, tree));\n \n /* Given a type node TYPE and a TYPE_QUALIFIER_SET, return a type for\n    the same kind of data as TYPE describes.  Variants point to the\n@@ -1712,7 +1712,7 @@ extern tree merge_attributes\t\tPROTO((tree, tree));\n    variants are never made.  Only main variants should ever appear as\n    types of expressions.  */\n \n-extern tree build_qualified_type        PROTO((tree, int));\n+extern tree build_qualified_type        PARAMS ((tree, int));\n \n /* Like build_qualified_type, but only deals with the `const' and\n    `volatile' qualifiers.  This interface is retained for backwards\n@@ -1726,21 +1726,21 @@ extern tree build_qualified_type        PROTO((tree, int));\n \n /* Make a copy of a type node.  */\n \n-extern tree build_type_copy\t\tPROTO((tree));\n+extern tree build_type_copy\t\tPARAMS ((tree));\n \n /* Given a ..._TYPE node, calculate the TYPE_SIZE, TYPE_SIZE_UNIT,\n    TYPE_ALIGN and TYPE_MODE fields.\n    If called more than once on one node, does nothing except\n    for the first time.  */\n \n-extern void layout_type\t\t\tPROTO((tree));\n+extern void layout_type\t\t\tPARAMS ((tree));\n \n /* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n    return a canonicalized ..._TYPE node, so that duplicates are not made.\n    How the hash code is computed is up to the caller, as long as any two\n    callers that could hash identical-looking type nodes agree.  */\n \n-extern tree type_hash_canon\t\tPROTO((int, tree));\n+extern tree type_hash_canon\t\tPARAMS ((int, tree));\n \n /* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n    calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n@@ -1750,29 +1750,29 @@ extern tree type_hash_canon\t\tPROTO((int, tree));\n    be starting at (in bits).  Zero means it can be assumed aligned\n    on any boundary that may be needed.  */\n \n-extern void layout_decl\t\t\tPROTO((tree, unsigned));\n+extern void layout_decl\t\t\tPARAMS ((tree, unsigned));\n \n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n-extern tree non_lvalue\t\t\tPROTO((tree));\n-extern tree pedantic_non_lvalue\t\tPROTO((tree));\n+extern tree non_lvalue\t\t\tPARAMS ((tree));\n+extern tree pedantic_non_lvalue\t\tPARAMS ((tree));\n \n-extern tree convert\t\t\tPROTO((tree, tree));\n-extern tree size_in_bytes\t\tPROTO((tree));\n-extern HOST_WIDE_INT int_size_in_bytes\tPROTO((tree));\n-extern tree size_binop\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree ssize_binop\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree size_int_wide\t\tPROTO((unsigned HOST_WIDE_INT,\n+extern tree convert\t\t\tPARAMS ((tree, tree));\n+extern tree size_in_bytes\t\tPARAMS ((tree));\n+extern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\n+extern tree size_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern tree ssize_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n+extern tree size_int_wide\t\tPARAMS ((unsigned HOST_WIDE_INT,\n \t\t\t\t\t       unsigned HOST_WIDE_INT, int));\n #define size_int(L) size_int_2 ((L), 0, 0)\n #define bitsize_int(L, H) size_int_2 ((L), (H), 1)\n #define size_int_2(L, H, T)\t\t\t\\\n   size_int_wide ((unsigned HOST_WIDE_INT) (L),\t\\\n \t\t (unsigned HOST_WIDE_INT) (H), (T))\n \n-extern tree round_up\t\t\tPROTO((tree, int));\n-extern tree get_pending_sizes\t\tPROTO((void));\n-extern void put_pending_sizes\t\tPROTO((tree));\n+extern tree round_up\t\t\tPARAMS ((tree, int));\n+extern tree get_pending_sizes\t\tPARAMS ((void));\n+extern void put_pending_sizes\t\tPARAMS ((tree));\n \n /* Type for sizes of data-type.  */\n \n@@ -1807,210 +1807,210 @@ extern int set_alignment;\n    by making the last node in X point to Y.\n    Returns X, except if X is 0 returns Y.  */\n \n-extern tree chainon\t\t\tPROTO((tree, tree));\n+extern tree chainon\t\t\tPARAMS ((tree, tree));\n \n /* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n \n-extern tree tree_cons\t\t\tPROTO((tree, tree, tree));\n-extern tree perm_tree_cons\t\tPROTO((tree, tree, tree));\n-extern tree temp_tree_cons\t\tPROTO((tree, tree, tree));\n-extern tree saveable_tree_cons\t\tPROTO((tree, tree, tree));\n-extern tree decl_tree_cons\t\tPROTO((tree, tree, tree));\n-extern tree expr_tree_cons\t\tPROTO((tree, tree, tree));\n+extern tree tree_cons\t\t\tPARAMS ((tree, tree, tree));\n+extern tree perm_tree_cons\t\tPARAMS ((tree, tree, tree));\n+extern tree temp_tree_cons\t\tPARAMS ((tree, tree, tree));\n+extern tree saveable_tree_cons\t\tPARAMS ((tree, tree, tree));\n+extern tree decl_tree_cons\t\tPARAMS ((tree, tree, tree));\n+extern tree expr_tree_cons\t\tPARAMS ((tree, tree, tree));\n \n /* Return the last tree node in a chain.  */\n \n-extern tree tree_last\t\t\tPROTO((tree));\n+extern tree tree_last\t\t\tPARAMS ((tree));\n \n /* Reverse the order of elements in a chain, and return the new head.  */\n \n-extern tree nreverse\t\t\tPROTO((tree));\n+extern tree nreverse\t\t\tPARAMS ((tree));\n \n /* Returns the length of a chain of nodes\n    (number of chain pointers to follow before reaching a null pointer).  */\n \n-extern int list_length\t\t\tPROTO((tree));\n+extern int list_length\t\t\tPARAMS ((tree));\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0 */\n \n-extern int integer_zerop\t\tPROTO((tree));\n+extern int integer_zerop\t\tPARAMS ((tree));\n \n /* integer_onep (tree x) is nonzero if X is an integer constant of value 1 */\n \n-extern int integer_onep\t\t\tPROTO((tree));\n+extern int integer_onep\t\t\tPARAMS ((tree));\n \n /* integer_all_onesp (tree x) is nonzero if X is an integer constant\n    all of whose significant bits are 1.  */\n \n-extern int integer_all_onesp\t\tPROTO((tree));\n+extern int integer_all_onesp\t\tPARAMS ((tree));\n \n /* integer_pow2p (tree x) is nonzero is X is an integer constant with\n    exactly one bit 1.  */\n \n-extern int integer_pow2p\t\tPROTO((tree));\n+extern int integer_pow2p\t\tPARAMS ((tree));\n \n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  */\n \n-extern int staticp\t\t\tPROTO((tree));\n+extern int staticp\t\t\tPARAMS ((tree));\n \n /* Gets an error if argument X is not an lvalue.\n    Also returns 1 if X is an lvalue, 0 if not.  */\n \n-extern int lvalue_or_else\t\tPROTO((tree, const char *));\n+extern int lvalue_or_else\t\tPARAMS ((tree, const char *));\n \n /* save_expr (EXP) returns an expression equivalent to EXP\n    but it can be used multiple times within context CTX\n    and only evaluate EXP once.  */\n \n-extern tree save_expr\t\t\tPROTO((tree));\n+extern tree save_expr\t\t\tPARAMS ((tree));\n \n /* Returns the index of the first non-tree operand for CODE, or the number\n    of operands if all are trees.  */\n \n-extern int first_rtl_op\t\t\tPROTO((enum tree_code));\n+extern int first_rtl_op\t\t\tPARAMS ((enum tree_code));\n \n /* unsave_expr (EXP) returns an expression equivalent to EXP but it\n    can be used multiple times and will evaluate EXP in its entirety\n    each time.  */\n \n-extern tree unsave_expr\t\t\tPROTO((tree));\n+extern tree unsave_expr\t\t\tPARAMS ((tree));\n \n /* Reset EXP in place so that it can be expaned again.  Does not\n    recurse into subtrees.  */\n \n-extern void unsave_expr_1               PROTO((tree));\n+extern void unsave_expr_1               PARAMS ((tree));\n \n /* Like unsave_expr_1, but recurses into all subtrees.  */\n \n-extern tree unsave_expr_now\t\tPROTO((tree));\n+extern tree unsave_expr_now\t\tPARAMS ((tree));\n \n /* If non-null, these are language-specific helper functions for\n    unsave_expr_now.  If present, LANG_UNSAVE is called before its\n    argument (an UNSAVE_EXPR) is to be unsaved, and all other\n    processing in unsave_expr_now is aborted.  LANG_UNSAVE_EXPR_NOW is\n    called from unsave_expr_1 for language-specific tree codes.  */\n-extern void (*lang_unsave)              PROTO((tree *));\n-extern void (*lang_unsave_expr_now)     PROTO((tree));\n+extern void (*lang_unsave)              PARAMS ((tree *));\n+extern void (*lang_unsave_expr_now)     PARAMS ((tree));\n \n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.\n \n    Note that we only allow such expressions within simple arithmetic\n    or a COND_EXPR.  */\n \n-extern int contains_placeholder_p\tPROTO((tree));\n+extern int contains_placeholder_p\tPARAMS ((tree));\n \n /* Return 1 if EXP contains any expressions that produce cleanups for an\n    outer scope to deal with.  Used by fold.  */\n \n-extern int has_cleanups\t\t\tPROTO((tree));\n+extern int has_cleanups\t\t\tPARAMS ((tree));\n \n /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n    return a tree with all occurrences of references to F in a\n    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n    contains only arithmetic expressions.  */\n \n-extern tree substitute_in_expr\t\tPROTO((tree, tree, tree));\n+extern tree substitute_in_expr\t\tPARAMS ((tree, tree, tree));\n \n /* variable_size (EXP) is like save_expr (EXP) except that it\n    is for the special case of something that is part of a\n    variable size for a data type.  It makes special arrangements\n    to compute the value at the right time when the data type\n    belongs to a function parameter.  */\n \n-extern tree variable_size\t\tPROTO((tree));\n+extern tree variable_size\t\tPARAMS ((tree));\n \n /* stabilize_reference (EXP) returns an reference equivalent to EXP\n    but it can be used multiple times\n    and only evaluate the subexpressions once.  */\n \n-extern tree stabilize_reference\t\tPROTO((tree));\n+extern tree stabilize_reference\t\tPARAMS ((tree));\n \n /* Subroutine of stabilize_reference; this is called for subtrees of\n    references.  Any expression with side-effects must be put in a SAVE_EXPR\n    to ensure that it is only evaluated once.  */\n \n-extern tree stabilize_reference_1\tPROTO((tree));\n+extern tree stabilize_reference_1\tPARAMS ((tree));\n \n /* Return EXP, stripped of any conversions to wider types\n    in such a way that the result of converting to type FOR_TYPE\n    is the same as if EXP were converted to FOR_TYPE.\n    If FOR_TYPE is 0, it signifies EXP's type.  */\n \n-extern tree get_unwidened\t\tPROTO((tree, tree));\n+extern tree get_unwidened\t\tPARAMS ((tree, tree));\n \n /* Return OP or a simpler expression for a narrower value\n    which can be sign-extended or zero-extended to give back OP.\n    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended\n    or 0 if the value should be sign-extended.  */\n \n-extern tree get_narrower\t\tPROTO((tree, int *));\n+extern tree get_narrower\t\tPARAMS ((tree, int *));\n \n /* Given MODE and UNSIGNEDP, return a suitable type-tree\n    with that mode.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree type_for_mode\t\tPROTO((enum machine_mode, int));\n+extern tree type_for_mode\t\tPARAMS ((enum machine_mode, int));\n \n /* Given PRECISION and UNSIGNEDP, return a suitable type-tree\n    for an integer type with at least that precision.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree type_for_size\t\tPROTO((unsigned, int));\n+extern tree type_for_size\t\tPARAMS ((unsigned, int));\n \n /* Given an integer type T, return a type like T but unsigned.\n    If T is unsigned, the value is T.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree unsigned_type\t\tPROTO((tree));\n+extern tree unsigned_type\t\tPARAMS ((tree));\n \n /* Given an integer type T, return a type like T but signed.\n    If T is signed, the value is T.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree signed_type\t\t\tPROTO((tree));\n+extern tree signed_type\t\t\tPARAMS ((tree));\n \n /* This function must be defined in the language-specific files.\n    expand_expr calls it to build the cleanup-expression for a TARGET_EXPR.\n    This is defined in a language-specific file.  */\n \n-extern tree maybe_build_cleanup\t\tPROTO((tree));\n+extern tree maybe_build_cleanup\t\tPARAMS ((tree));\n \n /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n    look for nested component-refs or array-refs at constant positions\n    and find the ultimate containing object, which is returned.  */\n \n-extern tree get_inner_reference\t\tPROTO((tree, int *, int *, tree *,\n+extern tree get_inner_reference\t\tPARAMS ((tree, int *, int *, tree *,\n \t\t\t\t\t       enum machine_mode *, int *,\n \t\t\t\t\t       int *, int *));\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */\n \n-extern tree get_containing_scope        PROTO((tree));\n+extern tree get_containing_scope        PARAMS ((tree));\n \n /* Return the FUNCTION_DECL which provides this _DECL with its context,\n    or zero if none.  */\n-extern tree decl_function_context \tPROTO((tree));\n+extern tree decl_function_context \tPARAMS ((tree));\n \n /* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides\n    this _DECL with its context, or zero if none.  */\n-extern tree decl_type_context\t\tPROTO((tree));\n+extern tree decl_type_context\t\tPARAMS ((tree));\n \n /* Given the FUNCTION_DECL for the current function,\n    return zero if it is ok for this function to be inline.\n    Otherwise return a warning message with a single %s\n    for the function's name.  */\n \n-extern const char *function_cannot_inline_p \tPROTO((tree));\n+extern const char *function_cannot_inline_p \tPARAMS ((tree));\n \n /* Return 1 if EXPR is the real constant zero.  */\n-extern int real_zerop PROTO((tree));\n+extern int real_zerop PARAMS ((tree));\n \f\n /* Declare commonly used variables for tree structure.  */\n \n@@ -2051,91 +2051,91 @@ extern int all_types_permanent;\n      2: and any other information that might be interesting, such as function\n         parameter types in C++.  */\n \n-extern const char *(*decl_printable_name)\tPROTO((tree, int));\n+extern const char *(*decl_printable_name)\tPARAMS ((tree, int));\n \n /* Pointer to function to finish handling an incomplete decl at the\n    end of compilation.  */\n \n-extern void (*incomplete_decl_finalize_hook)\tPROTO((tree));\n+extern void (*incomplete_decl_finalize_hook)\tPARAMS ((tree));\n \n-extern char *init_parse\t\t\t\tPROTO((char *));\n-extern void finish_parse\t\t\tPROTO((void));\n+extern char *init_parse\t\t\t\tPARAMS ((char *));\n+extern void finish_parse\t\t\tPARAMS ((void));\n \n extern const char * const language_string;\n \n /* Declare a predefined function.  Return the declaration.  This function is\n    provided by each language frontend.  */\n-extern tree builtin_function\t\t\tPROTO((const char *, tree, int,\n+extern tree builtin_function\t\t\tPARAMS ((const char *, tree, int,\n \t\t\t\t\t\t       enum built_in_class,\n \t\t\t\t\t\t       const char *));\n \f\n /* In tree.c */\n-extern char *perm_calloc\t\t\tPROTO((int, long));\n-extern tree get_file_function_name\t\tPROTO((int));\n-extern tree get_file_function_name_long \tPROTO((const char *));\n-extern tree get_set_constructor_bits\t\tPROTO((tree, char *, int));\n-extern tree get_set_constructor_bytes\t\tPROTO((tree,\n+extern char *perm_calloc\t\t\tPARAMS ((int, long));\n+extern tree get_file_function_name\t\tPARAMS ((int));\n+extern tree get_file_function_name_long \tPARAMS ((const char *));\n+extern tree get_set_constructor_bits\t\tPARAMS ((tree, char *, int));\n+extern tree get_set_constructor_bytes\t\tPARAMS ((tree,\n \t\t\t\t\t\t       unsigned char *, int));\n-extern int get_alias_set                        PROTO((tree));\n-extern int new_alias_set\t\t\tPROTO((void));\n-extern int (*lang_get_alias_set)                PROTO((tree));\n-extern tree get_callee_fndecl                   PROTO((tree));\n+extern int get_alias_set                        PARAMS ((tree));\n+extern int new_alias_set\t\t\tPARAMS ((void));\n+extern int (*lang_get_alias_set)                PARAMS ((tree));\n+extern tree get_callee_fndecl                   PARAMS ((tree));\n \f\n /* In stmt.c */\n \n-extern int in_control_zone_p\t\t\tPROTO((void));\n-extern void expand_fixups\t\t\tPROTO((struct rtx_def *));\n-extern tree expand_start_stmt_expr\t\tPROTO((void));\n-extern tree expand_end_stmt_expr\t\tPROTO((tree));\n-extern void expand_expr_stmt\t\t\tPROTO((tree));\n-extern int warn_if_unused_value\t\t\tPROTO((tree));\n-extern void expand_decl_init\t\t\tPROTO((tree));\n-extern void clear_last_expr\t\t\tPROTO((void));\n-extern void expand_label\t\t\tPROTO((tree));\n-extern void expand_goto\t\t\t\tPROTO((tree));\n-extern void expand_asm\t\t\t\tPROTO((tree));\n-extern void expand_start_cond\t\t\tPROTO((tree, int));\n-extern void expand_end_cond\t\t\tPROTO((void));\n-extern void expand_start_else\t\t\tPROTO((void));\n-extern void expand_start_elseif\t\t\tPROTO((tree));\n-extern struct nesting *expand_start_loop \tPROTO((int));\n-extern struct nesting *expand_start_loop_continue_elsewhere \tPROTO((int));\n-extern void expand_loop_continue_here\t\tPROTO((void));\n-extern void expand_end_loop\t\t\tPROTO((void));\n-extern int expand_continue_loop\t\t\tPROTO((struct nesting *));\n-extern int expand_exit_loop\t\t\tPROTO((struct nesting *));\n-extern int expand_exit_loop_if_false\t\tPROTO((struct nesting *,\n+extern int in_control_zone_p\t\t\tPARAMS ((void));\n+extern void expand_fixups\t\t\tPARAMS ((struct rtx_def *));\n+extern tree expand_start_stmt_expr\t\tPARAMS ((void));\n+extern tree expand_end_stmt_expr\t\tPARAMS ((tree));\n+extern void expand_expr_stmt\t\t\tPARAMS ((tree));\n+extern int warn_if_unused_value\t\t\tPARAMS ((tree));\n+extern void expand_decl_init\t\t\tPARAMS ((tree));\n+extern void clear_last_expr\t\t\tPARAMS ((void));\n+extern void expand_label\t\t\tPARAMS ((tree));\n+extern void expand_goto\t\t\t\tPARAMS ((tree));\n+extern void expand_asm\t\t\t\tPARAMS ((tree));\n+extern void expand_start_cond\t\t\tPARAMS ((tree, int));\n+extern void expand_end_cond\t\t\tPARAMS ((void));\n+extern void expand_start_else\t\t\tPARAMS ((void));\n+extern void expand_start_elseif\t\t\tPARAMS ((tree));\n+extern struct nesting *expand_start_loop \tPARAMS ((int));\n+extern struct nesting *expand_start_loop_continue_elsewhere \tPARAMS ((int));\n+extern void expand_loop_continue_here\t\tPARAMS ((void));\n+extern void expand_end_loop\t\t\tPARAMS ((void));\n+extern int expand_continue_loop\t\t\tPARAMS ((struct nesting *));\n+extern int expand_exit_loop\t\t\tPARAMS ((struct nesting *));\n+extern int expand_exit_loop_if_false\t\tPARAMS ((struct nesting *,\n \t\t\t\t\t\t       tree));\n-extern int expand_exit_something\t\tPROTO((void));\n+extern int expand_exit_something\t\tPARAMS ((void));\n \n-extern void expand_null_return\t\t\tPROTO((void));\n-extern void expand_return\t\t\tPROTO((tree));\n-extern int optimize_tail_recursion\t\tPROTO((tree, struct rtx_def *));\n-extern void expand_start_bindings_and_block     PROTO((int, tree));\n+extern void expand_null_return\t\t\tPARAMS ((void));\n+extern void expand_return\t\t\tPARAMS ((tree));\n+extern int optimize_tail_recursion\t\tPARAMS ((tree, struct rtx_def *));\n+extern void expand_start_bindings_and_block     PARAMS ((int, tree));\n #define expand_start_bindings(flags) \\\n   expand_start_bindings_and_block(flags, NULL_TREE)\n-extern void expand_end_bindings\t\t\tPROTO((tree, int, int));\n-extern void warn_about_unused_variables         PROTO((tree));\n-extern void start_cleanup_deferral\t\tPROTO((void));\n-extern void end_cleanup_deferral\t\tPROTO((void));\n-extern void mark_block_as_eh_region\t\tPROTO((void));\n-extern void mark_block_as_not_eh_region\t\tPROTO((void));\n-extern int is_eh_region\t\t\t\tPROTO((void));\n-extern int conditional_context\t\t\tPROTO((void));\n-extern tree last_cleanup_this_contour\t\tPROTO((void));\n-extern int expand_dhc_cleanup\t\t\tPROTO((tree));\n-extern int expand_dcc_cleanup\t\t\tPROTO((tree));\n-extern void expand_start_case\t\t\tPROTO((int, tree, tree,\n+extern void expand_end_bindings\t\t\tPARAMS ((tree, int, int));\n+extern void warn_about_unused_variables         PARAMS ((tree));\n+extern void start_cleanup_deferral\t\tPARAMS ((void));\n+extern void end_cleanup_deferral\t\tPARAMS ((void));\n+extern void mark_block_as_eh_region\t\tPARAMS ((void));\n+extern void mark_block_as_not_eh_region\t\tPARAMS ((void));\n+extern int is_eh_region\t\t\t\tPARAMS ((void));\n+extern int conditional_context\t\t\tPARAMS ((void));\n+extern tree last_cleanup_this_contour\t\tPARAMS ((void));\n+extern int expand_dhc_cleanup\t\t\tPARAMS ((tree));\n+extern int expand_dcc_cleanup\t\t\tPARAMS ((tree));\n+extern void expand_start_case\t\t\tPARAMS ((int, tree, tree,\n \t\t\t\t\t\t       const char *));\n-extern void expand_end_case\t\t\tPROTO((tree));\n-extern int pushcase\t\t\t\tPROTO((tree,\n+extern void expand_end_case\t\t\tPARAMS ((tree));\n+extern int pushcase\t\t\t\tPARAMS ((tree,\n \t\t\t\t\t\t       tree (*) (tree, tree),\n \t\t\t\t\t\t       tree, tree *));\n-extern int pushcase_range\t\t\tPROTO((tree, tree,\n+extern int pushcase_range\t\t\tPARAMS ((tree, tree,\n \t\t\t\t\t\t       tree (*) (tree, tree),\n \t\t\t\t\t\t       tree, tree *));\n-extern void using_eh_for_cleanups\t\tPROTO((void));\n-extern int stmt_loop_nest_empty\t\t\tPROTO((void));\n+extern void using_eh_for_cleanups\t\tPARAMS ((void));\n+extern int stmt_loop_nest_empty\t\t\tPARAMS ((void));\n \n /* In fold-const.c */\n \n@@ -2145,327 +2145,327 @@ extern int stmt_loop_nest_empty\t\t\tPROTO((void));\n    if the argument itself cannot be simplified, its\n    subexpressions are not changed.  */\n \n-extern tree fold\t\tPROTO((tree));\n+extern tree fold\t\tPARAMS ((tree));\n \n-extern int force_fit_type\tPROTO((tree, int));\n-extern int add_double\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern int force_fit_type\tPARAMS ((tree, int));\n+extern int add_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int neg_double\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern int neg_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int mul_double\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern int mul_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern void lshift_double\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void lshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, int, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *, int));\n-extern void rshift_double\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void rshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, int,\n \t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *, int));\n-extern void lrotate_double\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void lrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, int, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *));\n-extern void rrotate_double\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void rrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, int, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *));\n-extern int operand_equal_p\tPROTO((tree, tree, int));\n-extern tree invert_truthvalue\tPROTO((tree));\n+extern int operand_equal_p\tPARAMS ((tree, tree, int));\n+extern tree invert_truthvalue\tPARAMS ((tree));\n \n /* In builtins.c.  Given a type, apply default promotions wrt unnamed\n    function arguments and return the new type.  Return NULL_TREE if no\n    change.  Required by any language that supports variadic arguments.  */\n \n-extern tree (*lang_type_promotes_to)\tPROTO((tree));\n+extern tree (*lang_type_promotes_to)\tPARAMS ((tree));\n \f\n /* Interface of the DWARF2 unwind info support.  */\n \n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n-extern int dwarf2out_do_frame\t\tPROTO((void));\n+extern int dwarf2out_do_frame\t\tPARAMS ((void));\n \n /* Generate a new label for the CFI info to refer to.  */\n \n-extern char *dwarf2out_cfi_label\tPROTO((void));\n+extern char *dwarf2out_cfi_label\tPARAMS ((void));\n \n /* Entry point to update the canonical frame address (CFA).  */\n \n-extern void dwarf2out_def_cfa\t\tPROTO((char *, unsigned, long));\n+extern void dwarf2out_def_cfa\t\tPARAMS ((char *, unsigned, long));\n \n /* Add the CFI for saving a register window.  */\n \n-extern void dwarf2out_window_save\tPROTO((char *));\n+extern void dwarf2out_window_save\tPARAMS ((char *));\n \n /* Add a CFI to update the running total of the size of arguments pushed\n    onto the stack.  */\n \n-extern void dwarf2out_args_size\t\tPROTO((char *, long));\n+extern void dwarf2out_args_size\t\tPARAMS ((char *, long));\n \n /* Entry point for saving a register to the stack.  */\n \n-extern void dwarf2out_reg_save\t\tPROTO((char *, unsigned, long));\n+extern void dwarf2out_reg_save\t\tPARAMS ((char *, unsigned, long));\n \n /* Entry point for saving the return address in the stack.  */\n \n-extern void dwarf2out_return_save\tPROTO((char *, long));\n+extern void dwarf2out_return_save\tPARAMS ((char *, long));\n \n /* Entry point for saving the return address in a register.  */\n \n-extern void dwarf2out_return_reg\tPROTO((char *, unsigned));\n+extern void dwarf2out_return_reg\tPARAMS ((char *, unsigned));\n \n /* Output a marker (i.e. a label) for the beginning of a function, before\n    the prologue.  */\n \n-extern void dwarf2out_begin_prologue\tPROTO((void));\n+extern void dwarf2out_begin_prologue\tPARAMS ((void));\n \n /* Output a marker (i.e. a label) for the absolute end of the generated\n    code for a function definition.  */\n \n-extern void dwarf2out_end_epilogue\tPROTO((void));\n+extern void dwarf2out_end_epilogue\tPARAMS ((void));\n \f\n /* The language front-end must define these functions.  */\n \n /* Function of no arguments for initializing options.  */\n-extern void lang_init_options\t\t\tPROTO((void));\n+extern void lang_init_options\t\t\tPARAMS ((void));\n \n /* Function of no arguments for initializing lexical scanning.  */\n-extern void init_lex\t\t\t\tPROTO((void));\n+extern void init_lex\t\t\t\tPARAMS ((void));\n /* Function of no arguments for initializing the symbol table.  */\n-extern void init_decl_processing\t\tPROTO((void));\n+extern void init_decl_processing\t\tPARAMS ((void));\n \n /* Functions called with no arguments at the beginning and end or processing\n    the input source file.  */\n-extern void lang_init\t\t\t\tPROTO((void));\n-extern void lang_finish\t\t\t\tPROTO((void));\n+extern void lang_init\t\t\t\tPARAMS ((void));\n+extern void lang_finish\t\t\t\tPARAMS ((void));\n \n /* Function to identify which front-end produced the output file. */\n-extern const char *lang_identify\t\t\tPROTO((void));\n+extern const char *lang_identify\t\t\tPARAMS ((void));\n \n /* Called by report_error_function to print out function name.\n  * Default may be overridden by language front-ends.  */\n-extern void (*print_error_function) PROTO((const char *));\n+extern void (*print_error_function) PARAMS ((const char *));\n \n /* Function to replace the DECL_LANG_SPECIFIC field of a DECL with a copy.  */\n-extern void copy_lang_decl\t\t\tPROTO((tree));\n+extern void copy_lang_decl\t\t\tPARAMS ((tree));\n \n /* Function called with no arguments to parse and compile the input.  */\n-extern int yyparse\t\t\t\tPROTO((void));\n+extern int yyparse\t\t\t\tPARAMS ((void));\n /* Function called with option as argument\n    to decode options starting with -f or -W or +.\n    It should return nonzero if it handles the option.  */\n-extern int lang_decode_option\t\t\tPROTO((int, char **));\n+extern int lang_decode_option\t\t\tPARAMS ((int, char **));\n \n /* Functions for processing symbol declarations.  */\n /* Function to enter a new lexical scope.\n    Takes one argument: always zero when called from outside the front end.  */\n-extern void pushlevel\t\t\t\tPROTO((int));\n+extern void pushlevel\t\t\t\tPARAMS ((int));\n /* Function to exit a lexical scope.  It returns a BINDING for that scope.\n    Takes three arguments:\n      KEEP -- nonzero if there were declarations in this scope.\n      REVERSE -- reverse the order of decls before returning them.\n      FUNCTIONBODY -- nonzero if this level is the body of a function.  */\n-extern tree poplevel\t\t\t\tPROTO((int, int, int));\n+extern tree poplevel\t\t\t\tPARAMS ((int, int, int));\n /* Set the BLOCK node for the current scope level.  */\n-extern void set_block\t\t\t\tPROTO((tree));\n+extern void set_block\t\t\t\tPARAMS ((tree));\n /* Function to add a decl to the current scope level.\n    Takes one argument, a decl to add.\n    Returns that decl, or, if the same symbol is already declared, may\n    return a different decl for that name.  */\n-extern tree pushdecl\t\t\t\tPROTO((tree));\n+extern tree pushdecl\t\t\t\tPARAMS ((tree));\n /* Function to return the chain of decls so far in the current scope level.  */\n-extern tree getdecls\t\t\t\tPROTO((void));\n+extern tree getdecls\t\t\t\tPARAMS ((void));\n /* Function to return the chain of structure tags in the current scope level.  */\n-extern tree gettags\t\t\t\tPROTO((void));\n+extern tree gettags\t\t\t\tPARAMS ((void));\n \n-extern tree build_range_type PROTO((tree, tree, tree));\n+extern tree build_range_type PARAMS ((tree, tree, tree));\n \n /* Call when starting to parse a declaration:\n    make expressions in the declaration last the length of the function.\n    Returns an argument that should be passed to resume_momentary later.  */\n-extern int suspend_momentary PROTO((void));\n+extern int suspend_momentary PARAMS ((void));\n \n-extern int allocation_temporary_p PROTO((void));\n+extern int allocation_temporary_p PARAMS ((void));\n \n /* Call when finished parsing a declaration:\n    restore the treatment of node-allocation that was\n    in effect before the suspension.\n    YES should be the value previously returned by suspend_momentary.  */\n-extern void resume_momentary PROTO((int));\n+extern void resume_momentary PARAMS ((int));\n \n /* Called after finishing a record, union or enumeral type.  */\n-extern void rest_of_type_compilation PROTO((tree, int));\n+extern void rest_of_type_compilation PARAMS ((tree, int));\n \n /* Save the current set of obstacks, but don't change them.  */\n-extern void push_obstacks_nochange PROTO((void));\n+extern void push_obstacks_nochange PARAMS ((void));\n \n-extern void permanent_allocation PROTO((int));\n+extern void permanent_allocation PARAMS ((int));\n \n-extern void push_momentary PROTO((void));\n+extern void push_momentary PARAMS ((void));\n \n-extern void clear_momentary PROTO((void));\n+extern void clear_momentary PARAMS ((void));\n \n-extern void pop_momentary PROTO((void));\n+extern void pop_momentary PARAMS ((void));\n \n-extern void end_temporary_allocation PROTO((void));\n+extern void end_temporary_allocation PARAMS ((void));\n \n /* Pop the obstack selection stack.  */\n-extern void pop_obstacks PROTO((void));\n+extern void pop_obstacks PARAMS ((void));\n \n /* In tree.c */\n-extern int really_constant_p\t\tPROTO ((tree));\n-extern void push_obstacks\t\tPROTO ((struct obstack *,\n+extern int really_constant_p\t\tPARAMS ((tree));\n+extern void push_obstacks\t\tPARAMS ((struct obstack *,\n \t\t\t\t\t\tstruct obstack *));\n-extern void pop_momentary_nofree\tPROTO ((void));\n-extern void preserve_momentary\t\tPROTO ((void));\n-extern void saveable_allocation\t\tPROTO ((void));\n-extern void temporary_allocation\tPROTO ((void));\n-extern void resume_temporary_allocation\tPROTO ((void));\n-extern tree get_file_function_name\tPROTO ((int));\n-extern void set_identifier_size\t\tPROTO ((int));\n-extern int int_fits_type_p\t\tPROTO ((tree, tree));\n-extern int tree_log2\t\t\tPROTO ((tree));\n-extern void preserve_initializer\tPROTO ((void));\n-extern void preserve_data\t\tPROTO ((void));\n-extern int object_permanent_p\t\tPROTO ((tree));\n-extern int type_precision\t\tPROTO ((tree));\n-extern int simple_cst_equal\t\tPROTO ((tree, tree));\n-extern int type_list_equal\t\tPROTO ((tree, tree));\n-extern int chain_member\t\t\tPROTO ((tree, tree));\n-extern int chain_member_purpose\t\tPROTO ((tree, tree));\n-extern int chain_member_value\t\tPROTO ((tree, tree));\n-extern tree listify\t\t\tPROTO ((tree));\n-extern tree type_hash_lookup\t\tPROTO ((int, tree));\n-extern void type_hash_add\t\tPROTO ((int, tree));\n-extern int type_hash_list\t\tPROTO ((tree));\n-extern int simple_cst_list_equal\tPROTO ((tree, tree));\n-extern void debug_obstack\t\tPROTO ((char *));\n-extern void rtl_in_current_obstack\tPROTO ((void));\n-extern void rtl_in_saveable_obstack\tPROTO ((void));\n-extern void init_tree_codes\t\tPROTO ((void));\n-extern void dump_tree_statistics\tPROTO ((void));\n-extern void print_obstack_statistics\tPROTO ((const char *,\n+extern void pop_momentary_nofree\tPARAMS ((void));\n+extern void preserve_momentary\t\tPARAMS ((void));\n+extern void saveable_allocation\t\tPARAMS ((void));\n+extern void temporary_allocation\tPARAMS ((void));\n+extern void resume_temporary_allocation\tPARAMS ((void));\n+extern tree get_file_function_name\tPARAMS ((int));\n+extern void set_identifier_size\t\tPARAMS ((int));\n+extern int int_fits_type_p\t\tPARAMS ((tree, tree));\n+extern int tree_log2\t\t\tPARAMS ((tree));\n+extern void preserve_initializer\tPARAMS ((void));\n+extern void preserve_data\t\tPARAMS ((void));\n+extern int object_permanent_p\t\tPARAMS ((tree));\n+extern int type_precision\t\tPARAMS ((tree));\n+extern int simple_cst_equal\t\tPARAMS ((tree, tree));\n+extern int type_list_equal\t\tPARAMS ((tree, tree));\n+extern int chain_member\t\t\tPARAMS ((tree, tree));\n+extern int chain_member_purpose\t\tPARAMS ((tree, tree));\n+extern int chain_member_value\t\tPARAMS ((tree, tree));\n+extern tree listify\t\t\tPARAMS ((tree));\n+extern tree type_hash_lookup\t\tPARAMS ((int, tree));\n+extern void type_hash_add\t\tPARAMS ((int, tree));\n+extern int type_hash_list\t\tPARAMS ((tree));\n+extern int simple_cst_list_equal\tPARAMS ((tree, tree));\n+extern void debug_obstack\t\tPARAMS ((char *));\n+extern void rtl_in_current_obstack\tPARAMS ((void));\n+extern void rtl_in_saveable_obstack\tPARAMS ((void));\n+extern void init_tree_codes\t\tPARAMS ((void));\n+extern void dump_tree_statistics\tPARAMS ((void));\n+extern void print_obstack_statistics\tPARAMS ((const char *,\n \t\t\t\t\t\tstruct obstack *));\n #ifdef BUFSIZ\n-extern void print_obstack_name\t\tPROTO ((char *, FILE *, const char *));\n+extern void print_obstack_name\t\tPARAMS ((char *, FILE *, const char *));\n #endif\n-extern void expand_function_end\t\tPROTO ((char *, int, int));\n-extern void expand_function_start\tPROTO ((tree, int));\n-extern int real_onep\t\t\tPROTO ((tree));\n-extern int real_twop\t\t\tPROTO ((tree));\n-extern void start_identifier_warnings\tPROTO ((void));\n-extern void gcc_obstack_init\t\tPROTO ((struct obstack *));\n-extern void init_obstacks\t\tPROTO ((void));\n-extern void obfree\t\t\tPROTO ((char *));\n-extern void build_common_tree_nodes\tPROTO ((int));\n-extern void build_common_tree_nodes_2\tPROTO ((int));\n+extern void expand_function_end\t\tPARAMS ((char *, int, int));\n+extern void expand_function_start\tPARAMS ((tree, int));\n+extern int real_onep\t\t\tPARAMS ((tree));\n+extern int real_twop\t\t\tPARAMS ((tree));\n+extern void start_identifier_warnings\tPARAMS ((void));\n+extern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\n+extern void init_obstacks\t\tPARAMS ((void));\n+extern void obfree\t\t\tPARAMS ((char *));\n+extern void build_common_tree_nodes\tPARAMS ((int));\n+extern void build_common_tree_nodes_2\tPARAMS ((int));\n \n /* In function.c */\n-extern void setjmp_protect_args\t\tPROTO ((void));\n-extern void setjmp_protect\t\tPROTO ((tree));\n-extern void expand_main_function\tPROTO ((void));\n-extern void mark_varargs\t\tPROTO ((void));\n-extern void init_dummy_function_start\tPROTO ((void));\n-extern void expand_dummy_function_end\tPROTO ((void));\n-extern void init_function_for_compilation\tPROTO ((void));\n-extern void init_function_start\t\tPROTO ((tree, char *, int));\n-extern void assign_parms\t\tPROTO ((tree));\n-extern void put_var_into_stack\t\tPROTO ((tree));\n-extern void uninitialized_vars_warning\tPROTO ((tree));\n-extern void setjmp_args_warning\t\tPROTO ((void));\n-extern void mark_all_temps_used\t\tPROTO ((void));\n-extern void init_temp_slots\t\tPROTO ((void));\n-extern void combine_temp_slots\t\tPROTO ((void));\n-extern void free_temp_slots\t\tPROTO ((void));\n-extern void pop_temp_slots\t\tPROTO ((void));\n-extern void push_temp_slots\t\tPROTO ((void));\n-extern void preserve_temp_slots\t\tPROTO ((struct rtx_def *));\n-extern int aggregate_value_p\t\tPROTO ((tree));\n-extern tree reorder_blocks\t\tPROTO ((tree,\n+extern void setjmp_protect_args\t\tPARAMS ((void));\n+extern void setjmp_protect\t\tPARAMS ((tree));\n+extern void expand_main_function\tPARAMS ((void));\n+extern void mark_varargs\t\tPARAMS ((void));\n+extern void init_dummy_function_start\tPARAMS ((void));\n+extern void expand_dummy_function_end\tPARAMS ((void));\n+extern void init_function_for_compilation\tPARAMS ((void));\n+extern void init_function_start\t\tPARAMS ((tree, char *, int));\n+extern void assign_parms\t\tPARAMS ((tree));\n+extern void put_var_into_stack\t\tPARAMS ((tree));\n+extern void uninitialized_vars_warning\tPARAMS ((tree));\n+extern void setjmp_args_warning\t\tPARAMS ((void));\n+extern void mark_all_temps_used\t\tPARAMS ((void));\n+extern void init_temp_slots\t\tPARAMS ((void));\n+extern void combine_temp_slots\t\tPARAMS ((void));\n+extern void free_temp_slots\t\tPARAMS ((void));\n+extern void pop_temp_slots\t\tPARAMS ((void));\n+extern void push_temp_slots\t\tPARAMS ((void));\n+extern void preserve_temp_slots\t\tPARAMS ((struct rtx_def *));\n+extern int aggregate_value_p\t\tPARAMS ((tree));\n+extern tree reorder_blocks\t\tPARAMS ((tree,\n \t\t\t\t\t\tstruct rtx_def *));\n-extern void free_temps_for_rtl_expr\tPROTO ((tree));\n-extern void instantiate_virtual_regs\tPROTO ((tree, struct rtx_def *));\n-extern int max_parm_reg_num\t\tPROTO ((void));\n-extern void push_function_context\tPROTO ((void));\n-extern void pop_function_context\tPROTO ((void));\n-extern void push_function_context_to\tPROTO ((tree));\n-extern void pop_function_context_from\tPROTO ((tree));\n+extern void free_temps_for_rtl_expr\tPARAMS ((tree));\n+extern void instantiate_virtual_regs\tPARAMS ((tree, struct rtx_def *));\n+extern int max_parm_reg_num\t\tPARAMS ((void));\n+extern void push_function_context\tPARAMS ((void));\n+extern void pop_function_context\tPARAMS ((void));\n+extern void push_function_context_to\tPARAMS ((tree));\n+extern void pop_function_context_from\tPARAMS ((tree));\n \n /* In print-rtl.c */\n #ifdef BUFSIZ\n-extern void print_rtl\t\t\tPROTO ((FILE *, struct rtx_def *));\n+extern void print_rtl\t\t\tPARAMS ((FILE *, struct rtx_def *));\n #endif\n \n /* In print-tree.c */\n-extern void debug_tree\t\t\tPROTO ((tree));\n+extern void debug_tree\t\t\tPARAMS ((tree));\n #ifdef BUFSIZ\n-extern void print_node\t\t\tPROTO ((FILE *, const char *, tree, int));\n-extern void print_node_brief\t\tPROTO ((FILE *, const char *, tree, int));\n-extern void indent_to\t\t\tPROTO ((FILE *, int));\n+extern void print_node\t\t\tPARAMS ((FILE *, const char *, tree, int));\n+extern void print_node_brief\t\tPARAMS ((FILE *, const char *, tree, int));\n+extern void indent_to\t\t\tPARAMS ((FILE *, int));\n #endif\n \n /* In expr.c */\n-extern void emit_queue\t\t\t\tPROTO ((void));\n-extern int apply_args_register_offset\t\tPROTO ((int));\n+extern void emit_queue\t\t\t\tPARAMS ((void));\n+extern int apply_args_register_offset\t\tPARAMS ((int));\n extern struct rtx_def *expand_builtin_return_addr\n-\tPROTO ((enum built_in_function, int, struct rtx_def *));\n-extern void do_pending_stack_adjust\t\tPROTO ((void));\n-extern struct rtx_def *expand_assignment\tPROTO ((tree, tree, int, int));\n-extern struct rtx_def *store_expr\t\tPROTO ((tree, struct rtx_def *,\n+\tPARAMS ((enum built_in_function, int, struct rtx_def *));\n+extern void do_pending_stack_adjust\t\tPARAMS ((void));\n+extern struct rtx_def *expand_assignment\tPARAMS ((tree, tree, int, int));\n+extern struct rtx_def *store_expr\t\tPARAMS ((tree, struct rtx_def *,\n \t\t\t\t\t\t\tint));\n-extern void check_max_integer_computation_mode\tPROTO ((tree));\n+extern void check_max_integer_computation_mode\tPARAMS ((tree));\n \n /* In emit-rtl.c */\n-extern void start_sequence_for_rtl_expr\t\tPROTO ((tree));\n-extern struct rtx_def *emit_line_note_after\tPROTO ((char *, int,\n+extern void start_sequence_for_rtl_expr\t\tPARAMS ((tree));\n+extern struct rtx_def *emit_line_note_after\tPARAMS ((char *, int,\n \t\t\t\t\t\t\tstruct rtx_def *));\n-extern struct rtx_def *emit_line_note\t\tPROTO ((char *, int));\n-extern struct rtx_def *emit_line_note_force\tPROTO ((char *, int));\n+extern struct rtx_def *emit_line_note\t\tPARAMS ((char *, int));\n+extern struct rtx_def *emit_line_note_force\tPARAMS ((char *, int));\n \n /* In calls.c */\n-extern void special_function_p\t        PROTO ((tree, int *, int *,\n+extern void special_function_p\t        PARAMS ((tree, int *, int *,\n \t\t\t\t\t\tint *, int *));\n \n /* In c-typeck.c */\n-extern int mark_addressable\t\tPROTO ((tree));\n-extern void incomplete_type_error\tPROTO ((tree, tree));\n+extern int mark_addressable\t\tPARAMS ((tree));\n+extern void incomplete_type_error\tPARAMS ((tree, tree));\n \n /* In c-lang.c */\n-extern void print_lang_statistics\tPROTO ((void));\n+extern void print_lang_statistics\tPARAMS ((void));\n \n /* In c-common.c */\n-extern tree truthvalue_conversion\tPROTO ((tree));\n-extern int min_precision\t\tPROTO ((tree, int));\n-extern void split_specs_attrs\t\tPROTO ((tree, tree *, tree *));\n+extern tree truthvalue_conversion\tPARAMS ((tree));\n+extern int min_precision\t\tPARAMS ((tree, int));\n+extern void split_specs_attrs\t\tPARAMS ((tree, tree *, tree *));\n \n /* In c-decl.c */\n #ifdef BUFSIZ\n-extern void print_lang_decl\t\tPROTO ((FILE *, tree, int));\n-extern void print_lang_type\t\tPROTO ((FILE *, tree, int));\n-extern void print_lang_identifier\tPROTO ((FILE *, tree, int));\n+extern void print_lang_decl\t\tPARAMS ((FILE *, tree, int));\n+extern void print_lang_type\t\tPARAMS ((FILE *, tree, int));\n+extern void print_lang_identifier\tPARAMS ((FILE *, tree, int));\n #endif\n-extern int global_bindings_p\t\tPROTO ((void));\n-extern void insert_block\t\tPROTO ((tree));\n+extern int global_bindings_p\t\tPARAMS ((void));\n+extern void insert_block\t\tPARAMS ((tree));\n \n /* In integrate.c */\n-extern void save_for_inline_nocopy\tPROTO ((tree));\n-extern void save_for_inline_copying\tPROTO ((tree));\n-extern void set_decl_abstract_flags\tPROTO ((tree, int));\n-extern void output_inline_function\tPROTO ((tree));\n+extern void save_for_inline_nocopy\tPARAMS ((tree));\n+extern void save_for_inline_copying\tPARAMS ((tree));\n+extern void set_decl_abstract_flags\tPARAMS ((tree, int));\n+extern void output_inline_function\tPARAMS ((tree));\n \n /* In c-lex.c */\n-extern void set_yydebug\t\t\tPROTO ((int));\n+extern void set_yydebug\t\t\tPARAMS ((int));\n \n /* In stor-layout.c */\n-extern void fixup_signed_type\t\tPROTO ((tree));\n+extern void fixup_signed_type\t\tPARAMS ((tree));\n \n /* varasm.c */\n-extern void make_decl_rtl\t\tPROTO ((tree, const char *, int));\n-extern void make_decl_one_only\t\tPROTO ((tree));\n-extern int supports_one_only\t\tPROTO ((void));\n-extern void variable_section\t\tPROTO ((tree, int));\n+extern void make_decl_rtl\t\tPARAMS ((tree, const char *, int));\n+extern void make_decl_one_only\t\tPARAMS ((tree));\n+extern int supports_one_only\t\tPARAMS ((void));\n+extern void variable_section\t\tPARAMS ((tree, int));\n \n /* In fold-const.c */\n-extern int div_and_round_double\t\tPROTO ((enum tree_code, int,\n+extern int div_and_round_double\t\tPARAMS ((enum tree_code, int,\n \t\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\t\tHOST_WIDE_INT *,\n@@ -2474,90 +2474,90 @@ extern int div_and_round_double\t\tPROTO ((enum tree_code, int,\n \t\t\t\t\t\tHOST_WIDE_INT *));\n \n /* In stmt.c */\n-extern void emit_nop\t\t\tPROTO ((void));\n-extern void expand_computed_goto\tPROTO ((tree));\n-extern struct rtx_def *label_rtx\tPROTO ((tree));\n-extern void expand_asm_operands\t\tPROTO ((tree, tree, tree, tree, int,\n+extern void emit_nop\t\t\tPARAMS ((void));\n+extern void expand_computed_goto\tPARAMS ((tree));\n+extern struct rtx_def *label_rtx\tPARAMS ((tree));\n+extern void expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int,\n \t\t\t\t\t\tchar *, int));\n-extern int any_pending_cleanups\t\tPROTO ((int));\n-extern void init_stmt\t\t\tPROTO ((void));\n-extern void init_stmt_for_function\tPROTO ((void));\n-extern int drop_through_at_end_p\tPROTO ((void));\n-extern void expand_start_target_temps\tPROTO ((void));\n-extern void expand_end_target_temps\tPROTO ((void));\n-extern void expand_elseif\t\tPROTO ((tree));\n-extern void expand_decl\t\t\tPROTO ((tree));\n-extern int expand_decl_cleanup\t\tPROTO ((tree, tree));\n-extern void expand_anon_union_decl\tPROTO ((tree, tree, tree));\n-extern void move_cleanups_up\t\tPROTO ((void));\n-extern void expand_start_case_dummy\tPROTO ((void));\n-extern void expand_end_case_dummy\tPROTO ((void));\n-extern tree case_index_expr_type\tPROTO ((void));\n-extern HOST_WIDE_INT all_cases_count\tPROTO ((tree, int *));\n-extern void check_for_full_enumeration_handling PROTO ((tree));\n-extern void declare_nonlocal_label\tPROTO ((tree));\n+extern int any_pending_cleanups\t\tPARAMS ((int));\n+extern void init_stmt\t\t\tPARAMS ((void));\n+extern void init_stmt_for_function\tPARAMS ((void));\n+extern int drop_through_at_end_p\tPARAMS ((void));\n+extern void expand_start_target_temps\tPARAMS ((void));\n+extern void expand_end_target_temps\tPARAMS ((void));\n+extern void expand_elseif\t\tPARAMS ((tree));\n+extern void expand_decl\t\t\tPARAMS ((tree));\n+extern int expand_decl_cleanup\t\tPARAMS ((tree, tree));\n+extern void expand_anon_union_decl\tPARAMS ((tree, tree, tree));\n+extern void move_cleanups_up\t\tPARAMS ((void));\n+extern void expand_start_case_dummy\tPARAMS ((void));\n+extern void expand_end_case_dummy\tPARAMS ((void));\n+extern tree case_index_expr_type\tPARAMS ((void));\n+extern HOST_WIDE_INT all_cases_count\tPARAMS ((tree, int *));\n+extern void check_for_full_enumeration_handling PARAMS ((tree));\n+extern void declare_nonlocal_label\tPARAMS ((tree));\n #ifdef BUFSIZ\n-extern void lang_print_xnode \t\tPROTO ((FILE *, tree, int));\n+extern void lang_print_xnode \t\tPARAMS ((FILE *, tree, int));\n #endif\n \n \n /* If KIND=='I', return a suitable global initializer (constructor) name.\n    If KIND=='D', return a suitable global clean-up (destructor) name.  */\n-extern tree get_file_function_name PROTO((int));\n+extern tree get_file_function_name PARAMS ((int));\n \f\n /* Interface of the DWARF2 unwind info support.  */\n \n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n-extern int dwarf2out_do_frame\t\tPROTO((void));\n+extern int dwarf2out_do_frame\t\tPARAMS ((void));\n \n /* Generate a new label for the CFI info to refer to.  */\n \n-extern char *dwarf2out_cfi_label\tPROTO((void));\n+extern char *dwarf2out_cfi_label\tPARAMS ((void));\n \n /* Entry point to update the canonical frame address (CFA).  */\n \n-extern void dwarf2out_def_cfa\t\tPROTO((char *, unsigned, long));\n+extern void dwarf2out_def_cfa\t\tPARAMS ((char *, unsigned, long));\n \n /* Add the CFI for saving a register window.  */\n \n-extern void dwarf2out_window_save\tPROTO((char *));\n+extern void dwarf2out_window_save\tPARAMS ((char *));\n \n /* Add a CFI to update the running total of the size of arguments pushed\n    onto the stack.  */\n \n-extern void dwarf2out_args_size\t\tPROTO((char *, long));\n+extern void dwarf2out_args_size\t\tPARAMS ((char *, long));\n \n /* Entry point for saving a register to the stack.  */\n \n-extern void dwarf2out_reg_save\t\tPROTO((char *, unsigned, long));\n+extern void dwarf2out_reg_save\t\tPARAMS ((char *, unsigned, long));\n \n /* Entry point for saving the return address in the stack.  */\n \n-extern void dwarf2out_return_save\tPROTO((char *, long));\n+extern void dwarf2out_return_save\tPARAMS ((char *, long));\n \n /* Entry point for saving the return address in a register.  */\n \n-extern void dwarf2out_return_reg\tPROTO((char *, unsigned));\n+extern void dwarf2out_return_reg\tPARAMS ((char *, unsigned));\n \n /* Output a marker (i.e. a label) for the beginning of a function, before\n    the prologue.  */\n \n-extern void dwarf2out_begin_prologue\tPROTO((void));\n+extern void dwarf2out_begin_prologue\tPARAMS ((void));\n \n /* Output a marker (i.e. a label) for the absolute end of the generated\n    code for a function definition.  */\n \n-extern void dwarf2out_end_epilogue\tPROTO((void));\n+extern void dwarf2out_end_epilogue\tPARAMS ((void));\n \n /* Redefine abort to report an internal error w/o coredump, and\n    reporting the location of the error in the source file.  This logic\n    is duplicated in rtl.h and tree.h because every file that needs the\n    special abort includes one or both.  toplev.h gets too few files,\n    system.h gets too many.  */\n \n-extern void fancy_abort PROTO((const char *, int, const char *))\n+extern void fancy_abort PARAMS ((const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n #if (GCC_VERSION >= 2007)\n #define abort() fancy_abort (__FILE__, __LINE__, __PRETTY_FUNCTION__)"}, {"sha": "9225a9c1e9b94712629cc0df4c786f841a678440", "filename": "gcc/unroll.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -194,24 +194,24 @@ static int *splittable_regs_updates;\n \n /* Forward declarations.  */\n \n-static void init_reg_map PROTO((struct inline_remap *, int));\n-static rtx calculate_giv_inc PROTO((rtx, rtx, int));\n-static rtx initial_reg_note_copy PROTO((rtx, struct inline_remap *));\n-static void final_reg_note_copy PROTO((rtx, struct inline_remap *));\n-static void copy_loop_body PROTO((rtx, rtx, struct inline_remap *, rtx, int,\n+static void init_reg_map PARAMS ((struct inline_remap *, int));\n+static rtx calculate_giv_inc PARAMS ((rtx, rtx, int));\n+static rtx initial_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n+static void final_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n+static void copy_loop_body PARAMS ((rtx, rtx, struct inline_remap *, rtx, int,\n \t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n-static void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n-static int find_splittable_regs PROTO((enum unroll_types, rtx, rtx, rtx, int,\n+static void iteration_info PARAMS ((rtx, rtx *, rtx *, rtx, rtx));\n+static int find_splittable_regs PARAMS ((enum unroll_types, rtx, rtx, rtx, int,\n \t\t\t\t       unsigned HOST_WIDE_INT));\n-static int find_splittable_givs PROTO((struct iv_class *, enum unroll_types,\n+static int find_splittable_givs PARAMS ((struct iv_class *, enum unroll_types,\n \t\t\t\t       rtx, rtx, rtx, int));\n-static int reg_dead_after_loop PROTO((rtx, rtx, rtx));\n-static rtx fold_rtx_mult_add PROTO((rtx, rtx, rtx, enum machine_mode));\n-static int verify_addresses PROTO((struct induction *, rtx, int));\n-static rtx remap_split_bivs PROTO((rtx));\n-static rtx find_common_reg_term PROTO((rtx, rtx));\n-static rtx subtract_reg_term PROTO((rtx, rtx));\n-static rtx loop_find_equiv_value PROTO((rtx, rtx));\n+static int reg_dead_after_loop PARAMS ((rtx, rtx, rtx));\n+static rtx fold_rtx_mult_add PARAMS ((rtx, rtx, rtx, enum machine_mode));\n+static int verify_addresses PARAMS ((struct induction *, rtx, int));\n+static rtx remap_split_bivs PARAMS ((rtx));\n+static rtx find_common_reg_term PARAMS ((rtx, rtx));\n+static rtx subtract_reg_term PARAMS ((rtx, rtx));\n+static rtx loop_find_equiv_value PARAMS ((rtx, rtx));\n \n /* Try to unroll one loop and split induction variables in the loop.\n "}, {"sha": "ff3b45eeeecc28d11c953463946c5df01a380258", "filename": "gcc/varasm.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -149,45 +149,45 @@ int size_directive_output;\n \n tree last_assemble_variable_decl;\n \n-static const char *strip_reg_name\tPROTO((const char *));\n-static int contains_pointers_p\t\tPROTO((tree));\n-static void decode_addr_const\t\tPROTO((tree, struct addr_const *));\n-static int const_hash\t\t\tPROTO((tree));\n-static int compare_constant\t\tPROTO((tree,\n+static const char *strip_reg_name\tPARAMS ((const char *));\n+static int contains_pointers_p\t\tPARAMS ((tree));\n+static void decode_addr_const\t\tPARAMS ((tree, struct addr_const *));\n+static int const_hash\t\t\tPARAMS ((tree));\n+static int compare_constant\t\tPARAMS ((tree,\n \t\t\t\t\t       struct constant_descriptor *));\n-static char *compare_constant_1\t\tPROTO((tree, char *));\n-static struct constant_descriptor *record_constant PROTO((tree));\n-static void record_constant_1\t\tPROTO((tree));\n-static tree copy_constant\t\tPROTO((tree));\n-static void output_constant_def_contents  PROTO((tree, int, int));\n-static void decode_rtx_const\t\tPROTO((enum machine_mode, rtx,\n+static char *compare_constant_1\t\tPARAMS ((tree, char *));\n+static struct constant_descriptor *record_constant PARAMS ((tree));\n+static void record_constant_1\t\tPARAMS ((tree));\n+static tree copy_constant\t\tPARAMS ((tree));\n+static void output_constant_def_contents  PARAMS ((tree, int, int));\n+static void decode_rtx_const\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t       struct rtx_const *));\n-static int const_hash_rtx\t\tPROTO((enum machine_mode, rtx));\n-static int compare_constant_rtx\t\tPROTO((enum machine_mode, rtx,\n+static int const_hash_rtx\t\tPARAMS ((enum machine_mode, rtx));\n+static int compare_constant_rtx\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t       struct constant_descriptor *));\n-static struct constant_descriptor *record_constant_rtx PROTO((enum machine_mode,\n+static struct constant_descriptor *record_constant_rtx PARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t      rtx));\n-static struct pool_constant *find_pool_constant PROTO((struct function *, rtx));\n-static void mark_constant_pool\t\tPROTO((void));\n-static void mark_constants\t\tPROTO((rtx));\n-static int output_addressed_constants\tPROTO((tree));\n-static void output_after_function_constants PROTO((void));\n-static void output_constructor\t\tPROTO((tree, int));\n+static struct pool_constant *find_pool_constant PARAMS ((struct function *, rtx));\n+static void mark_constant_pool\t\tPARAMS ((void));\n+static void mark_constants\t\tPARAMS ((rtx));\n+static int output_addressed_constants\tPARAMS ((tree));\n+static void output_after_function_constants PARAMS ((void));\n+static void output_constructor\t\tPARAMS ((tree, int));\n #ifdef ASM_WEAKEN_LABEL\n-static void remove_from_pending_weak_list\tPROTO ((char *));\n+static void remove_from_pending_weak_list\tPARAMS ((char *));\n #endif\n #ifdef ASM_OUTPUT_BSS\n-static void asm_output_bss\t\tPROTO((FILE *, tree, char *, int, int));\n+static void asm_output_bss\t\tPARAMS ((FILE *, tree, char *, int, int));\n #endif\n #ifdef BSS_SECTION_ASM_OP\n #ifdef ASM_OUTPUT_ALIGNED_BSS\n-static void asm_output_aligned_bss\tPROTO((FILE *, tree, char *, int, int));\n+static void asm_output_aligned_bss\tPARAMS ((FILE *, tree, char *, int, int));\n #endif\n #endif /* BSS_SECTION_ASM_OP */\n-static void mark_pool_constant          PROTO((struct pool_constant *));\n-static void mark_pool_sym_hash_table\tPROTO((struct pool_sym **));\n-static void mark_const_hash_entry\tPROTO((void *));\n-static void asm_emit_uninitialised\tPROTO((tree, char *, int, int));\n+static void mark_pool_constant          PARAMS ((struct pool_constant *));\n+static void mark_pool_sym_hash_table\tPARAMS ((struct pool_sym **));\n+static void mark_const_hash_entry\tPARAMS ((void *));\n+static void asm_emit_uninitialised\tPARAMS ((tree, char *, int, int));\n \f\n static enum in_section { no_section, in_text, in_data, in_named\n #ifdef BSS_SECTION_ASM_OP"}, {"sha": "9807b882aebd05590f8216c974964fe3e4ae0467", "filename": "gcc/varray.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -74,7 +74,7 @@ varray_grow (va, n)\n \n #if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n \n-extern void error PVPROTO ((const char *, ...))\tATTRIBUTE_PRINTF_1;\n+extern void error PARAMS ((const char *, ...))\tATTRIBUTE_PRINTF_1;\n \n void\n varray_check_failed (va, n, file, line, function)"}, {"sha": "836343369137c93a85567be8f688bb019d149dd6", "filename": "gcc/varray.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58782098af9dfb58f6fc42800748c45252965923/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58782098af9dfb58f6fc42800748c45252965923/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=58782098af9dfb58f6fc42800748c45252965923", "patch": "@@ -90,7 +90,7 @@ typedef struct varray_head_tag {\n \n /* Allocate a virtual array with NUM elements, each of which is SIZE bytes\n    long, named NAME.  Array elements are zeroed.  */\n-extern varray_type varray_init\tPROTO ((size_t, size_t, const char *));\n+extern varray_type varray_init\tPARAMS ((size_t, size_t, const char *));\n \n #define VARRAY_CHAR_INIT(va, num, name) \\\n   va = varray_init (num, sizeof (char), name)\n@@ -158,15 +158,15 @@ extern varray_type varray_init\tPROTO ((size_t, size_t, const char *));\n   do { if (vp) { free (vp); vp = (varray_type)0; } } while (0)\n \n /* Grow/shrink the virtual array VA to N elements.  */\n-extern varray_type varray_grow\tPROTO((varray_type, size_t));\n+extern varray_type varray_grow\tPARAMS ((varray_type, size_t));\n \n #define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n \n #define VARRAY_SIZE(VA)\t((VA)->num_elements)\n \n /* Check for VARRAY_xxx macros being in bound.  */\n #if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n-extern void varray_check_failed PROTO ((varray_type, size_t,\n+extern void varray_check_failed PARAMS ((varray_type, size_t,\n \t\t\t\t\tconst char *, int,\n \t\t\t\t\tconst char *)) ATTRIBUTE_NORETURN;\n #define VARRAY_CHECK(VA, N, T)\t\t\t\t\t\\"}]}