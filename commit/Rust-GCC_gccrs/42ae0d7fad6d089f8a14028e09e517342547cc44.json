{"sha": "42ae0d7fad6d089f8a14028e09e517342547cc44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhZTBkN2ZhZDZkMDg5ZjhhMTQwMjhlMDllNTE3MzQyNTQ3Y2M0NA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-04-29T23:57:00Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-04-29T23:57:00Z"}, "message": "ira.c tidies: split update_reg_equivs\n\n\t* ira.c (add_store_equivs, combine_and_move_insns): New functions,\n\tsplit out from..\n\t(update_reg_equivs): ..here.  Move allocation and freeing of\n\treg_equiv, and calls to grow_reg_equivs, init_alias_analysis,\n\tend_alias_analysis to..\n\t(ira): ..here.\n\nFrom-SVN: r235657", "tree": {"sha": "0c546238785d4d13326374cbdd7c27d952f6e432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c546238785d4d13326374cbdd7c27d952f6e432"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42ae0d7fad6d089f8a14028e09e517342547cc44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ae0d7fad6d089f8a14028e09e517342547cc44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ae0d7fad6d089f8a14028e09e517342547cc44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ae0d7fad6d089f8a14028e09e517342547cc44/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c1d8b59fe62e3e5ab6c735adeaba41d725367b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1d8b59fe62e3e5ab6c735adeaba41d725367b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1d8b59fe62e3e5ab6c735adeaba41d725367b6"}], "stats": {"total": 134, "additions": 71, "deletions": 63}, "files": [{"sha": "0065a2c944d82e838e6b8da4a970dcbfe5088a4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae0d7fad6d089f8a14028e09e517342547cc44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae0d7fad6d089f8a14028e09e517342547cc44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42ae0d7fad6d089f8a14028e09e517342547cc44", "patch": "@@ -1,3 +1,12 @@\n+2016-04-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* ira.c (add_store_equivs, combine_and_move_insns): New functions,\n+\tsplit out from..\n+\t(update_reg_equivs): ..here.  Move allocation and freeing of\n+\treg_equiv, and calls to grow_reg_equivs, init_alias_analysis,\n+\tend_alias_analysis to..\n+\t(ira): ..here.\n+\n 2016-04-30  Alan Modra  <amodra@gmail.com>\n \n \t* ira.c (pdx_subregs): Delete."}, {"sha": "e10a2fd4ac606674b4a4e2df98740da5e349b6c4", "filename": "gcc/ira.c", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ae0d7fad6d089f8a14028e09e517342547cc44/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ae0d7fad6d089f8a14028e09e517342547cc44/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=42ae0d7fad6d089f8a14028e09e517342547cc44", "patch": "@@ -3343,13 +3343,6 @@ update_equiv_regs (void)\n   rtx_insn *insn;\n   basic_block bb;\n   int loop_depth;\n-  bitmap cleared_regs;\n-  bitmap_head seen_insns;\n-\n-  reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n-  grow_reg_equivs ();\n-\n-  init_alias_analysis ();\n \n   /* Scan insns and set pdx_subregs if the reg is used in a\n      paradoxical subreg.  Don't set such reg equivalent to a mem,\n@@ -3604,18 +3597,24 @@ update_equiv_regs (void)\n \t    }\n \t}\n     }\n+}\n \n-  if (!optimize)\n-    goto out;\n-\n-  /* A second pass, to gather additional equivalences with memory.  This needs\n-     to be done after we know which registers we are going to replace.  */\n+/* For insns that set a MEM to the contents of a REG that is only used\n+   in a single basic block, see if the register is always equivalent\n+   to that memory location and if moving the store from INSN to the\n+   insn that sets REG is safe.  If so, put a REG_EQUIV note on the\n+   initializing insn.  */\n+static void\n+add_store_equivs (void)\n+{\n+  bitmap_head seen_insns;\n \n   bitmap_initialize (&seen_insns, NULL);\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx set, src, dest;\n       unsigned regno;\n+      rtx_insn *init_insn;\n \n       bitmap_set_bit (&seen_insns, INSN_UID (insn));\n \n@@ -3629,66 +3628,60 @@ update_equiv_regs (void)\n       dest = SET_DEST (set);\n       src = SET_SRC (set);\n \n-      /* If this sets a MEM to the contents of a REG that is only used\n-\t in a single basic block, see if the register is always equivalent\n-\t to that memory location and if moving the store from INSN to the\n-\t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n-\t initializing insn.\n-\n-\t Don't add a REG_EQUIV note if the insn already has one.  The existing\n+      /* Don't add a REG_EQUIV note if the insn already has one.  The existing\n \t REG_EQUIV is likely more useful than the one we are adding.\n \n \t If one of the regs in the address has reg_equiv[REGNO].replace set,\n \t then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n \t optimization may move the set of this register immediately before\n-\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n-\t the mention in the REG_EQUIV note would be to an uninitialized\n-\t pseudo.  */\n-\n+\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence the\n+\t mention in the REG_EQUIV note would be to an uninitialized pseudo.  */\n       if (MEM_P (dest) && REG_P (src)\n \t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n \t  && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n \t  && DF_REG_DEF_COUNT (regno) == 1\n \t  && ! reg_equiv[regno].pdx_subregs\n \t  && reg_equiv[regno].init_insns != NULL\n-\t  && reg_equiv[regno].init_insns->insn () != NULL\n-\t  && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n-\t\t\t      REG_EQUIV, NULL_RTX)\n-\t  && ! contains_replace_regs (XEXP (dest, 0)))\n+\t  && (init_insn = reg_equiv[regno].init_insns->insn ()) != 0\n+\t  && bitmap_bit_p (&seen_insns, INSN_UID (init_insn))\n+\t  && ! find_reg_note (init_insn, REG_EQUIV, NULL_RTX)\n+\t  && ! contains_replace_regs (XEXP (dest, 0))\n+\t  && validate_equiv_mem (init_insn, src, dest)\n+\t  && ! memref_used_between_p (dest, init_insn, insn)\n+\t  /* Attaching a REG_EQUIV note will fail if INIT_INSN has\n+\t     multiple sets.  */\n+\t  && set_unique_reg_note (init_insn, REG_EQUIV, copy_rtx (dest)))\n \t{\n-\t  rtx_insn *init_insn =\n-\t    as_a <rtx_insn *> (XEXP (reg_equiv[regno].init_insns, 0));\n-\t  if (validate_equiv_mem (init_insn, src, dest)\n-\t      && bitmap_bit_p (&seen_insns, INSN_UID (init_insn))\n-\t      && ! memref_used_between_p (dest, init_insn, insn)\n-\t      /* Attaching a REG_EQUIV note will fail if INIT_INSN has\n-\t\t multiple sets.  */\n-\t      && set_unique_reg_note (init_insn, REG_EQUIV, copy_rtx (dest)))\n-\t    {\n-\t      /* This insn makes the equivalence, not the one initializing\n-\t\t the register.  */\n-\t      ira_reg_equiv[regno].init_insns\n-\t\t= gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n-\t      df_notes_rescan (init_insn);\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Adding REG_EQUIV to insn %d for source of insn %d\\n\",\n-\t\t\t INSN_UID (init_insn),\n-\t\t\t INSN_UID (insn));\n-\t    }\n+\t  /* This insn makes the equivalence, not the one initializing\n+\t     the register.  */\n+\t  ira_reg_equiv[regno].init_insns\n+\t    = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t  df_notes_rescan (init_insn);\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Adding REG_EQUIV to insn %d for source of insn %d\\n\",\n+\t\t     INSN_UID (init_insn),\n+\t\t     INSN_UID (insn));\n \t}\n     }\n   bitmap_clear (&seen_insns);\n+}\n+\n+/* Scan all regs killed in an insn to see if any of them are registers\n+   only used that once.  If so, see if we can replace the reference\n+   with the equivalent form.  If we can, delete the initializing\n+   reference and this register will go away.  If we can't replace the\n+   reference, and the initializing reference is within the same loop\n+   (or in an inner loop), then move the register initialization just\n+   before the use, so that they are in the same basic block.  */\n+static void\n+combine_and_move_insns (void)\n+{\n+  rtx_insn *insn;\n+  basic_block bb;\n+  int loop_depth;\n+  bitmap cleared_regs = BITMAP_ALLOC (NULL);\n \n-  cleared_regs = BITMAP_ALLOC (NULL);\n-  /* Now scan all regs killed in an insn to see if any of them are\n-     registers only used that once.  If so, see if we can replace the\n-     reference with the equivalent form.  If we can, delete the\n-     initializing reference and this register will go away.  If we\n-     can't replace the reference, and the initializing reference is\n-     within the same loop (or in an inner loop), then move the register\n-     initialization just before the use, so that they are in the same\n-     basic block.  */\n   FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     {\n       loop_depth = bb_loop_depth (bb);\n@@ -3848,12 +3841,6 @@ update_equiv_regs (void)\n     }\n \n   BITMAP_FREE (cleared_regs);\n-\n-  out:\n-  /* Clean up.  */\n-\n-  end_alias_analysis ();\n-  free (reg_equiv);\n }\n \n /* A pass over indirect jumps, converting simple cases to direct jumps.\n@@ -5230,7 +5217,19 @@ ira (FILE *f)\n   if (resize_reg_info () && flag_ira_loop_pressure)\n     ira_set_pseudo_classes (true, ira_dump_file);\n \n+  reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n+  grow_reg_equivs ();\n+  init_alias_analysis ();\n   update_equiv_regs ();\n+  if (optimize)\n+    {\n+      /* Gather additional equivalences with memory.  */\n+      add_store_equivs ();\n+      combine_and_move_insns ();\n+    }\n+  end_alias_analysis ();\n+  free (reg_equiv);\n+\n   setup_reg_equiv ();\n   setup_reg_equiv_init ();\n "}]}