{"sha": "4ce86f522f1a062c457aa86350026d389ad7d672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlODZmNTIyZjFhMDYyYzQ1N2FhODYzNTAwMjZkMzg5YWQ3ZDY3Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-12T12:18:14Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-12T12:18:14Z"}, "message": "Initial revision\n\nFrom-SVN: r455", "tree": {"sha": "57f0c7309ab34c08d0723d06c877ff1520848a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57f0c7309ab34c08d0723d06c877ff1520848a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce86f522f1a062c457aa86350026d389ad7d672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce86f522f1a062c457aa86350026d389ad7d672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce86f522f1a062c457aa86350026d389ad7d672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce86f522f1a062c457aa86350026d389ad7d672/comments", "author": null, "committer": null, "parents": [{"sha": "6a8c88c8a4c4efda4999c7fd741897a7ff72d072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8c88c8a4c4efda4999c7fd741897a7ff72d072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a8c88c8a4c4efda4999c7fd741897a7ff72d072"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "e6da7403011bd8e0eb21f46149e874c844c46f5b", "filename": "gcc/xcoffout.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce86f522f1a062c457aa86350026d389ad7d672/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce86f522f1a062c457aa86350026d389ad7d672/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=4ce86f522f1a062c457aa86350026d389ad7d672", "patch": "@@ -0,0 +1,172 @@\n+/* XCOFF definitions.  These are needed in dbxout.c, final.c,\n+   and xcoffout.h.  */\n+\n+#define ASM_STABS_OP \".stabx\"\n+\n+/* Tags and typedefs are C_DECL in XCOFF, not C_LSYM.  */\n+\n+#define DBX_DECL_STABS_CODE N_DECL\n+\n+/* Use the XCOFF predefined type numbers.  */\n+\n+/* ??? According to metin, typedef stabx must go in text control section,\n+   but he did not make this changes everywhere where such typedef stabx\n+   can be emitted, so it is really needed or not?  */\n+\n+#define DBX_OUTPUT_STANDARD_TYPES(SYMS)\t\t\\\n+{\t\t\t\t\t\t\\\n+  text_section ();\t\t\t\t\\\n+  xcoff_output_standard_types (SYMS);\t\t\\\n+}\n+\n+/* Any type with a negative type index has already been output.  */\n+\n+#define DBX_TYPE_DEFINED(TYPE) (TYPE_SYMTAB_ADDRESS (TYPE) < 0)\n+\n+/* Must use N_STSYM for static const variables (those in the text section)\n+   instead of N_FUN.  */\n+\n+#define DBX_STATIC_CONST_VAR_CODE N_STSYM\n+\n+/* For static variables, output code to define the start of a static block.  */\n+\n+#define DBX_STATIC_BLOCK_START(ASMFILE,CODE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((CODE) == N_STSYM)\t\t\t\t\t\t\\\n+    fprintf ((ASMFILE), \"\\t.bs\\t%s[RW]\\n\", xcoff_private_data_section_name);\\\n+  else if ((CODE) == N_LCSYM)\t\t\t\t\t\t\\\n+    fprintf ((ASMFILE), \"\\t.bs\\t%s\\n\", xcoff_bss_section_name);\t\t\\\n+}\n+\n+/* For static variables, output code to define the end of a static block.  */\n+\n+#define DBX_STATIC_BLOCK_END(ASMFILE,CODE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (current_sym_code == N_STSYM || current_sym_code == N_LCSYM)\t\\\n+    fprintf (asmfile, \"\\t.es\\n\");\t\t\t\t\t\\\n+}\n+\n+/* We must use N_RPYSM instead of N_RSYM for register parameters.  */\n+\n+#define DBX_REGPARM_STABS_CODE N_RPSYM\n+\n+/* We must use 'R' instead of 'P' for register parameters.  */\n+\n+#define DBX_REGPARM_STABS_LETTER 'R'\n+\n+/* Define our own finish symbol function, since xcoff stabs have their\n+   own different format.  */\n+\n+#define DBX_FINISH_SYMBOL(SYM)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (current_sym_addr && current_sym_code == N_FUN)\t\t\\\n+    fprintf (asmfile, \"\\\",.\");\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (asmfile, \"\\\",\");\t\t\t\t\t\\\n+  /* If we are writing a function name, we must ensure that\t\\\n+     there is no storage-class suffix on the name.  */\t\t\\\n+  if (current_sym_addr && current_sym_code == N_FUN\t\t\\\n+      && GET_CODE (current_sym_addr) == SYMBOL_REF)\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char *_p;\t\t\t\t\t\t\t\\\n+      for (_p = XSTR (current_sym_addr, 0); *_p != '[' && *_p; _p++) \\\n+\tfprintf (asmfile, \"%c\", *_p);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (current_sym_addr)\t\t\t\t\t\\\n+    output_addr_const (asmfile, current_sym_addr);\t\t\\\n+  else if (current_sym_code == N_GSYM)\t\t\t\t\\\n+    fprintf (asmfile, \"%s\", IDENTIFIER_POINTER (DECL_NAME (SYM))); \\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (asmfile, \"%d\", current_sym_value);\t\t\t\\\n+  fprintf (asmfile, \",%d,0\\n\", stab_to_sclass (current_sym_code)); \\\n+}\n+\n+/* These are IBM XCOFF extensions we need to reference in dbxout.c\n+   and xcoffout.c.  */\n+\n+/* AIX XCOFF uses this for typedefs.  This can have any value, since it is\n+   only used for translation into a C_DECL storage class.  */\n+#ifndef N_DECL\n+#define N_DECL 0x8c\n+#endif\n+/* AIX XCOFF uses this for parameters passed in registers.  This can have\n+   any value, since it is only used for translation into a C_RPSYM storage\n+   class.  */\n+#ifndef N_RPSYM\n+#define N_RPSYM 0x8e\n+#endif\n+\n+/* The line number of the beginning of the current function.\n+   xcoffout.c needs this so that it can output relative linenumbers.  */\n+\n+extern int xcoff_begin_function_line;\n+\n+/* Name of the current include file.  */\n+\n+extern char *xcoff_current_include_file;\n+\n+/* Name of the current function file.  This is the file the `.bf' is\n+   emitted from.  In case a line is emitted from a different file,\n+   (by including that file of course), then the line number will be\n+   absolute.  */\n+\n+extern char *xcoff_current_function_file;\n+\n+/* Names of bss and data sections.  These should be unique names for each\n+   compilation unit.  */\n+\n+extern char *xcoff_bss_section_name;\n+extern char *xcoff_private_data_section_name;\n+extern char *xcoff_read_only_section_name;\n+\n+/* Don't write out path name for main source file.  */\n+#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(FILE,FILENAME)\n+\n+/* Write out main source file name using \".file\" rather than \".stabs\".  */\n+#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(FILE,FILENAME) \\\n+  fprintf (FILE, \"\\t.file\\t\\\"%s\\\"\\n\", FILENAME);\n+\n+#define ABS_OR_RELATIVE_LINENO(LINENO)\t\t\\\n+((xcoff_current_include_file\t\t\t\\\n+  && xcoff_current_include_file != xcoff_current_function_file)\t\\\n+ ? (LINENO) : (LINENO) - xcoff_begin_function_line)\n+\n+/* Output source line numbers via \".line\" rather than \".stabd\".  */\n+#define ASM_OUTPUT_SOURCE_LINE(FILE,LINENUM) \\\n+  do {\t\t\t\t\t\t\\\n+    if (xcoff_begin_function_line >= 0)\t\t\\\n+      fprintf (FILE, \"\\t.line\\t%d\\n\", ABS_OR_RELATIVE_LINENO (LINENUM)); \\\n+  } while (0)\n+\n+/* We don't want to emit source file names in dbx style. */\n+#define DBX_OUTPUT_SOURCE_FILENAME(FILE, FILENAME)\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (xcoff_current_include_file)\t\t\t\\\n+    fprintf (FILE, \"\\t.ei\\t\\\"%s\\\"\\n\", xcoff_current_include_file);\\\n+  if (strcmp (main_input_filename, FILENAME))\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.bi\\t\\\"%s\\\"\\n\", FILENAME);\t\\\n+      xcoff_current_include_file = FILENAME;\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    xcoff_current_include_file = NULL;\t\t\t\\\n+}\n+\n+/* If we are still in an include file, its end must be marked.  */\n+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (xcoff_current_include_file)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t.ei\\t\\\"%s\\\"\\n\",\t\t\\\n+\t       xcoff_current_include_file);\t\t\\\n+      xcoff_current_include_file = NULL;\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Don't try to use the `x' type-cross-reference character in DBX data.\n+   Also has the consequence of putting each struct, union or enum\n+   into a separate .stabs, containing only cross-refs to the others.  */\n+#define DBX_NO_XREFS"}]}