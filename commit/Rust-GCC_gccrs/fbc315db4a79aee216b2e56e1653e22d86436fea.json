{"sha": "fbc315db4a79aee216b2e56e1653e22d86436fea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJjMzE1ZGI0YTc5YWVlMjE2YjJlNTZlMTY1M2UyMmQ4NjQzNmZlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-04-09T03:18:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-04-09T03:18:18Z"}, "message": "c-common.def: Move FOR_STMT...\n\n./\t* c-common.def: Move FOR_STMT, WHILE_STMT, DO_STMT, BREAK_STMT,\n\tCONTINUE_STMT, and SWITCH_STMT to cp/cp-tree.def.\n\t* c-common.h (WHILE_COND, WHILE_BODY): Move to cp/cp-tree.h.\n\t(DO_COND, DO_BODY): Likewise.\n\t(FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY): Likewise.\n\t(SWITCH_STMT_COND, SWITCH_STMT_BODY, SWITCH_STMT_TYPE): Likewise.\n\t(c_common_stmt_codes): Remove FOR_STMT, WHILE_STMT, DO_STMT,\n\tBREAK_STMT, CONTINUE_STMT, and SWITCH_STMT.\n\t(build_continue_stmt, build_break_stmt): Don't declare.\n\t(c_do_switch_warnings): Update declaration.\n\t* c-gimplify.c (enum bc_t): Remove.\n\t(struct c_gimplify_ctx, ctxp): Remove.\n\t(push_context, pop_context): Remove static functions.\n\t(c_genericize): Don't call push_context or pop_context.\n\t(begin_bc_block, finish_bc_block): Remove static functions.\n\t(build_bc_goto): Likewise.\n\t(gimplify_c_loop): Likewise.\n\t(gimplify_for_stmt, gimplify_while_stmt): Likewise.\n\t(gimplify_do_stmt, gimplify_switch_stmt): Likewise.\n\t(c_gimplify_expr): Remove handling of FOR_STMT, WHILE_STMT,\n\tDO_STMT, SWITCH_STMT, CONTINUE_STMT, BREAK_STMT.\n\t* c-common.c (c_do_switch_warnings): Rename from\n\tc_do_switch_warnings_1.\n\t(c_do_switch_warnings) [old version]: Remove.\n\t(c_do_switch_expr_warnings): Remove.\n\t* c-typeck.c (c_finish_case): Call new c_do_switch_warnings\n\tfunction instead of c_do_switch_expr_warnings.\n\t* c-dump.c (c_dump_tree): Remove handling of BREAK_STMT,\n\tCONTINUE_STMT, DO_STMT, FOR_STMT, SWITCH_STMT, and WHILE_STMT.\n\t* c-pretty-print.c (pp_c_statement): Likewise.\n\t* c-semantics.c (build_break_stmt, build_continue_stmt): Remove.\ncp/\n\t* cp-tree.def: Define FOR_STMT, WHILE_STMT, DO_STMT, BREAK_STMT,\n\tCONTINUE_STMT, SWITCH_STMT.\n\t* cp-tree.h (cp_stmt_codes): Add FOR_STMT, WHILE_STMT, DO_STMT,\n\tBREAK_STMT, CONTINUE_STMT, SWITCH_STMT.\n\t(WHILE_COND, WHILE_BODY): Define.\n\t(DO_COND, DO_BODY): Define.\n\t(FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY): Define.\n\t(SWITCH_STMT_COND, SWITCH_STMT_BODY, SWITCH_STMT_TYPE): Define.\n\t* cp-gimplify.c (enum bc_t): Define.\n\t(struct cp_gimplify_ctx, ctxp): Define.\n\t(push_context, pop_context): New static functions.\n\t(begin_bc_block, finish_bc_block): New static functions.\n\t(build_bc_goto): New static function.\n\t(gimplify_cp_loop, gimplify_for_stmt): New static functions.\n\t(gimplify_while_stmt, gimplify_do_stmt): Likewise.\n\t(gimplify_switch_stmt): Likewise.\n\t(cp_gimplify_expr): Handle FOR_STMT, WHILE_STMT, DO_STMT,\n\tSWITCH_STMT, CONTINUE_STMT, BREAK_STMT.\n\t(cp_genericize): Call push_context and pop_context.\n\t* semantics.c (finish_break_stmt): Just call build_stmt\n\t(BREAK_STMT) rather than build_break_stmt.\n\t(finish_continue_stmt): Corresponding change.\n\t* decl.c (pop_switch): Update call to c_do_switch_warnings for new\n\tparameters.\n\t* cxx-pretty-print.c (pp_cxx_statement): Handle SWITCH_STMT,\n\tWHILE_STMT, DO_STMT, FOR_STMT, BREAK_STMT, CONTINUE_STMT.\n\t* dump.c (cp_dump_tree): Likewise.\n\nFrom-SVN: r97885", "tree": {"sha": "54b12532b3129c3528d3e2a058b89210eef0f85b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54b12532b3129c3528d3e2a058b89210eef0f85b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbc315db4a79aee216b2e56e1653e22d86436fea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc315db4a79aee216b2e56e1653e22d86436fea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc315db4a79aee216b2e56e1653e22d86436fea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc315db4a79aee216b2e56e1653e22d86436fea/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0bca51f080dfff5e943b1f1775d874a73bbc441a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bca51f080dfff5e943b1f1775d874a73bbc441a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bca51f080dfff5e943b1f1775d874a73bbc441a"}], "stats": {"total": 1014, "additions": 517, "deletions": 497}, "files": [{"sha": "b2324c6906eb5f9fdd3983c89d33438823d71882", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -1,3 +1,37 @@\n+2005-04-08  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* c-common.def: Move FOR_STMT, WHILE_STMT, DO_STMT, BREAK_STMT,\n+\tCONTINUE_STMT, and SWITCH_STMT to cp/cp-tree.def.\n+\t* c-common.h (WHILE_COND, WHILE_BODY): Move to cp/cp-tree.h.\n+\t(DO_COND, DO_BODY): Likewise.\n+\t(FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY): Likewise.\n+\t(SWITCH_STMT_COND, SWITCH_STMT_BODY, SWITCH_STMT_TYPE): Likewise.\n+\t(c_common_stmt_codes): Remove FOR_STMT, WHILE_STMT, DO_STMT,\n+\tBREAK_STMT, CONTINUE_STMT, and SWITCH_STMT.\n+\t(build_continue_stmt, build_break_stmt): Don't declare.\n+\t(c_do_switch_warnings): Update declaration.\n+\t* c-gimplify.c (enum bc_t): Remove.\n+\t(struct c_gimplify_ctx, ctxp): Remove.\n+\t(push_context, pop_context): Remove static functions.\n+\t(c_genericize): Don't call push_context or pop_context.\n+\t(begin_bc_block, finish_bc_block): Remove static functions.\n+\t(build_bc_goto): Likewise.\n+\t(gimplify_c_loop): Likewise.\n+\t(gimplify_for_stmt, gimplify_while_stmt): Likewise.\n+\t(gimplify_do_stmt, gimplify_switch_stmt): Likewise.\n+\t(c_gimplify_expr): Remove handling of FOR_STMT, WHILE_STMT,\n+\tDO_STMT, SWITCH_STMT, CONTINUE_STMT, BREAK_STMT.\n+\t* c-common.c (c_do_switch_warnings): Rename from\n+\tc_do_switch_warnings_1.\n+\t(c_do_switch_warnings) [old version]: Remove.\n+\t(c_do_switch_expr_warnings): Remove.\n+\t* c-typeck.c (c_finish_case): Call new c_do_switch_warnings\n+\tfunction instead of c_do_switch_expr_warnings.\n+\t* c-dump.c (c_dump_tree): Remove handling of BREAK_STMT,\n+\tCONTINUE_STMT, DO_STMT, FOR_STMT, SWITCH_STMT, and WHILE_STMT.\n+\t* c-pretty-print.c (pp_c_statement): Likewise.\n+\t* c-semantics.c (build_break_stmt, build_continue_stmt): Remove.\n+\n 2005-04-08  Diego Novillo  <dnovillo@redhat.com>\n \n \tMerge from tree-cleanup-branch: VRP, store CCP, store"}, {"sha": "050a1eb979149187d9f3efa60649c1020833ee4d", "filename": "gcc/c-common.c", "status": "modified", "additions": 9, "deletions": 43, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -3708,11 +3708,16 @@ match_case_to_enum (splay_tree_node node, void *data)\n   return 0;\n }\n \n-/* Common code for -Wswitch*.  */\n+/* Handle -Wswitch*.  Called from the front end after parsing the\n+   switch construct.  */\n+/* ??? Should probably be somewhere generic, since other languages\n+   besides C and C++ would want this.  At the moment, however, C/C++\n+   are the only tree-ssa languages that support enumerations at all,\n+   so the point is moot.  */\n \n-static void\n-c_do_switch_warnings_1 (splay_tree cases, location_t switch_location,\n-\t\t\ttree type, tree cond)\n+void\n+c_do_switch_warnings (splay_tree cases, location_t switch_location,\n+\t\t      tree type, tree cond)\n {\n   splay_tree_node default_node;\n \n@@ -3773,45 +3778,6 @@ c_do_switch_warnings_1 (splay_tree cases, location_t switch_location,\n     }\n }\n \n-/* Handle -Wswitch* for a SWITCH_STMT.  Called from the front end\n-   after parsing the switch construct.  */\n-/* ??? Should probably be somewhere generic, since other languages besides\n-   C and C++ would want this.  We'd want to agree on the data structure,\n-   however, which is a problem.  Alternately, we operate on gimplified\n-   switch_exprs, which I don't especially like.  At the moment, however,\n-   C/C++ are the only tree-ssa languages that support enumerations at all,\n-   so the point is moot.  */\n-\n-void\n-c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n-{\n-  location_t switch_location;\n-\n-  if (EXPR_HAS_LOCATION (switch_stmt))\n-    switch_location = EXPR_LOCATION (switch_stmt);\n-  else\n-    switch_location = input_location;\n-  c_do_switch_warnings_1 (cases, switch_location,\n-\t\t\t  SWITCH_STMT_TYPE (switch_stmt),\n-\t\t\t  SWITCH_STMT_COND (switch_stmt));\n-}\n-\n-/* Like c_do_switch_warnings, but takes a SWITCH_EXPR rather than a\n-   SWITCH_STMT.  */\n-\n-void\n-c_do_switch_expr_warnings (splay_tree cases, tree switch_expr)\n-{\n-  location_t switch_location;\n-\n-  if (EXPR_HAS_LOCATION (switch_expr))\n-    switch_location = EXPR_LOCATION (switch_expr);\n-  else\n-    switch_location = input_location;\n-  c_do_switch_warnings_1 (cases, switch_location, TREE_TYPE (switch_expr),\n-\t\t\t  SWITCH_COND (switch_expr));\n-}\n-\n /* Finish an expression taking the address of LABEL (an\n    IDENTIFIER_NODE).  Returns an expression for the address.  */\n "}, {"sha": "381fe4ef75c423105f8fcd739806c778a3b406b7", "filename": "gcc/c-common.def", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -33,28 +33,6 @@ DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", tcc_unary, 1)\n    obtain the expression.  */\n DEFTREECODE (EXPR_STMT, \"expr_stmt\", tcc_expression, 1)\n \n-/* Used to represent a `for' statement. The operands are\n-   FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n-DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_expression, 4)\n-\n-/* Used to represent a 'while' statement. The operands are WHILE_COND\n-   and WHILE_BODY, respectively.  */\n-DEFTREECODE (WHILE_STMT, \"while_stmt\", tcc_expression, 2)\n-\n-/* Used to represent a 'do' statement. The operands are DO_BODY and\n-   DO_COND, respectively.  */\n-DEFTREECODE (DO_STMT, \"do_stmt\", tcc_expression, 2)\n-\n-/* Used to represent a 'break' statement.  */\n-DEFTREECODE (BREAK_STMT, \"break_stmt\", tcc_expression, 0)\n-\n-/* Used to represent a 'continue' statement.  */\n-DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", tcc_expression, 0)\n-\n-/* Used to represent a 'switch' statement. The operands are\n-   SWITCH_STMT_COND, SWITCH_STMT_BODY and SWITCH_STMT_TYPE, respectively.  */\n-DEFTREECODE (SWITCH_STMT, \"switch_stmt\", tcc_expression, 3)\n-\n /* A STMT_EXPR represents a statement-expression.  The\n    STMT_EXPR_STMT is the statement given by the expression.  */\n DEFTREECODE (STMT_EXPR, \"stmt_expr\", tcc_expression, 1)"}, {"sha": "d2b9a4a9cbdb6984f2f9be6b283763ce5f8d74f6", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -709,32 +709,10 @@ extern void finish_file\t(void);\n #define STATEMENT_LIST_HAS_LABEL(NODE) \\\n   TREE_LANG_FLAG_3 (STATEMENT_LIST_CHECK (NODE))\n \n-/* WHILE_STMT accessors. These give access to the condition of the\n-   while statement and the body of the while statement, respectively.  */\n-#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n-#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n-\n-/* DO_STMT accessors. These give access to the condition of the do\n-   statement and the body of the do statement, respectively.  */\n-#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n-#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n-\n /* EXPR_STMT accessor. This gives the expression associated with an\n    expression statement.  */\n #define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n \n-/* FOR_STMT accessors. These give access to the init statement,\n-   condition, update expression, and body of the for statement,\n-   respectively.  */\n-#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n-#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n-#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n-#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n-\n-#define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n-#define SWITCH_STMT_BODY(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n-#define SWITCH_STMT_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n-\n /* STMT_EXPR accessor.  */\n #define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n \n@@ -759,9 +737,7 @@ enum c_tree_code {\n #undef DEFTREECODE\n \n #define c_common_stmt_codes\t\t\t\t\\\n-   EXPR_STMT,\t\tFOR_STMT,\t\t\t\\\n-   WHILE_STMT,\t\tDO_STMT,\t\t\t\\\n-   BREAK_STMT,\t\tCONTINUE_STMT,\tSWITCH_STMT\n+   EXPR_STMT\n \n /* TRUE if a code represents a statement.  The front end init\n    langhook should take care of initialization of this array.  */\n@@ -796,8 +772,6 @@ extern void emit_local_var (tree);\n extern tree do_case (tree, tree);\n extern tree build_stmt (enum tree_code, ...);\n extern tree build_case_label (tree, tree, tree);\n-extern tree build_continue_stmt (void);\n-extern tree build_break_stmt (void);\n \n /* These functions must be defined by each front-end which implements\n    a variant of the C language.  They are used in c-common.c.  */\n@@ -820,8 +794,7 @@ extern int case_compare (splay_tree_key, splay_tree_key);\n \n extern tree c_add_case_label (splay_tree, tree, tree, tree, tree);\n \n-extern void c_do_switch_warnings (splay_tree, tree);\n-extern void c_do_switch_expr_warnings (splay_tree, tree);\n+extern void c_do_switch_warnings (splay_tree, location_t, tree, tree);\n \n extern tree build_function_call (tree, tree);\n "}, {"sha": "09850e6c810ed95432c1bf3386fdd9e4efa8faf6", "filename": "gcc/c-dump.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -54,42 +54,11 @@ c_dump_tree (void *dump_info, tree t)\n \tdump_string (di, \"bitfield\");\n       break;\n \n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-      dump_stmt (di, t);\n-      break;\n-\n-    case DO_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"body\", DO_BODY (t));\n-      dump_child (\"cond\", DO_COND (t));\n-      break;\n-\n     case EXPR_STMT:\n       dump_stmt (di, t);\n       dump_child (\"expr\", EXPR_STMT_EXPR (t));\n       break;\n \n-    case FOR_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"init\", FOR_INIT_STMT (t));\n-      dump_child (\"cond\", FOR_COND (t));\n-      dump_child (\"expr\", FOR_EXPR (t));\n-      dump_child (\"body\", FOR_BODY (t));\n-      break;\n-\n-    case SWITCH_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", SWITCH_STMT_COND (t));\n-      dump_child (\"body\", SWITCH_STMT_BODY (t));\n-      break;\n-\n-    case WHILE_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", WHILE_COND (t));\n-      dump_child (\"body\", WHILE_BODY (t));\n-      break;\n-\n     case STMT_EXPR:\n       dump_child (\"stmt\", STMT_EXPR_STMT (t));\n       break;"}, {"sha": "bea288ea0e8d1b752950eef4dfef888f7ff19d3e", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 0, "deletions": 269, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -70,34 +70,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n     walk back up, we check that they fit our constraints, and copy them\n     into temporaries if not.  */\n \n-/* Local declarations.  */\n-\n-enum bc_t { bc_break = 0, bc_continue = 1 };\n-\n-static struct c_gimplify_ctx\n-{\n-  /* For handling break and continue.  */\n-  tree current_bc_label;\n-  tree bc_id[2];\n-} *ctxp;\n-\n-static void\n-push_context (void)\n-{\n-  gcc_assert (!ctxp);\n-  ctxp = (struct c_gimplify_ctx *) xcalloc (1, sizeof (struct c_gimplify_ctx));\n-  ctxp->bc_id[bc_continue] = get_identifier (\"continue\");\n-  ctxp->bc_id[bc_break] = get_identifier (\"break\");\n-}\n-\n-static void\n-pop_context (void)\n-{\n-  gcc_assert (ctxp && !ctxp->current_bc_label);\n-  free (ctxp);\n-  ctxp = NULL;\n-}\n-\n /* Gimplification of statement trees.  */\n \n /* Convert the tree representation of FNDECL from C frontend trees to\n@@ -132,9 +104,7 @@ c_genericize (tree fndecl)\n     }\n \n   /* Go ahead and gimplify for now.  */\n-  push_context ();\n   gimplify_function_tree (fndecl);\n-  pop_context ();\n \n   /* Dump the genericized tree IR.  */\n   dump_function (TDI_generic, fndecl);\n@@ -248,225 +218,6 @@ gimplify_expr_stmt (tree *stmt_p)\n   return GS_OK;\n }\n \n-/* Begin a scope which can be exited by a break or continue statement.  BC\n-   indicates which.\n-\n-   Just creates a label and pushes it into the current context.  */\n-\n-static tree\n-begin_bc_block (enum bc_t bc)\n-{\n-  tree label = create_artificial_label ();\n-  DECL_NAME (label) = ctxp->bc_id[bc];\n-  TREE_CHAIN (label) = ctxp->current_bc_label;\n-  ctxp->current_bc_label = label;\n-  return label;\n-}\n-\n-/* Finish a scope which can be exited by a break or continue statement.\n-   LABEL was returned from the most recent call to begin_bc_block.  BODY is\n-   an expression for the contents of the scope.\n-\n-   If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n-   body.  Otherwise, just forget the label.  */\n-\n-static tree\n-finish_bc_block (tree label, tree body)\n-{\n-  gcc_assert (label == ctxp->current_bc_label);\n-\n-  if (TREE_USED (label))\n-    {\n-      tree t, sl = NULL;\n-\n-      /* Clear the name so flow can delete the label.  */\n-      DECL_NAME (label) = NULL_TREE;\n-      t = build1 (LABEL_EXPR, void_type_node, label);\n-\n-      append_to_statement_list (body, &sl);\n-      append_to_statement_list (t, &sl);\n-      body = sl;\n-    }\n-\n-  ctxp->current_bc_label = TREE_CHAIN (label);\n-  TREE_CHAIN (label) = NULL_TREE;\n-  return body;\n-}\n-\n-/* Build a GOTO_EXPR to represent a break or continue statement.  BC\n-   indicates which.  */\n-\n-static tree\n-build_bc_goto (enum bc_t bc)\n-{\n-  tree label;\n-  tree target_name = ctxp->bc_id[bc];\n-\n-  /* Look for the appropriate type of label.  */\n-  for (label = ctxp->current_bc_label;\n-       label;\n-       label = TREE_CHAIN (label))\n-    if (DECL_NAME (label) == target_name)\n-      break;\n-\n-  if (label == NULL_TREE)\n-    {\n-      if (bc == bc_break)\n-\terror (\"break statement not within loop or switch\");\n-      else\n-\terror (\"continue statement not within loop or switch\");\n-\n-      return NULL_TREE;\n-    }\n-\n-  /* Mark the label used for finish_bc_block.  */\n-  TREE_USED (label) = 1;\n-  return build1 (GOTO_EXPR, void_type_node, label);\n-}\n-\n-/* Build a generic representation of one of the C loop forms.  COND is the\n-   loop condition or NULL_TREE.  BODY is the (possibly compound) statement\n-   controlled by the loop.  INCR is the increment expression of a for-loop,\n-   or NULL_TREE.  COND_IS_FIRST indicates whether the condition is\n-   evaluated before the loop body as in while and for loops, or after the\n-   loop body as in do-while loops.  */\n-\n-static tree\n-gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n-{\n-  tree top, entry, exit, cont_block, break_block, stmt_list, t;\n-  location_t stmt_locus;\n-\n-  stmt_locus = input_location;\n-  stmt_list = NULL_TREE;\n-  entry = NULL_TREE;\n-\n-  break_block = begin_bc_block (bc_break);\n-  cont_block = begin_bc_block (bc_continue);\n-\n-  /* If condition is zero don't generate a loop construct.  */\n-  if (cond && integer_zerop (cond))\n-    {\n-      top = NULL_TREE;\n-      exit = NULL_TREE;\n-      if (cond_is_first)\n-\t{\n-\t  t = build_bc_goto (bc_break);\n-\t  append_to_statement_list (t, &stmt_list);\n-\t}\n-    }\n-  else\n-    {\n-      /* If we use a LOOP_EXPR here, we have to feed the whole thing\n-\t back through the main gimplifier to lower it.  Given that we\n-\t have to gimplify the loop body NOW so that we can resolve\n-\t break/continue stmts, seems easier to just expand to gotos.  */\n-      top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\n-      /* If we have an exit condition, then we build an IF with gotos either\n-\t out of the loop, or to the top of it.  If there's no exit condition,\n-\t then we just build a jump back to the top.  */\n-      exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n-      if (cond && !integer_nonzerop (cond))\n-\t{\n-\t  t = build_bc_goto (bc_break);\n-\t  exit = build3 (COND_EXPR, void_type_node, cond, exit, t);\n-\t  exit = fold (exit);\n-\t  gimplify_stmt (&exit);\n-\n-\t  if (cond_is_first)\n-\t    {\n-\t      if (incr)\n-\t\t{\n-\t\t  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\t\t  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n-\t\t}\n-\t      else\n-\t\tt = build_bc_goto (bc_continue);\n-\t      append_to_statement_list (t, &stmt_list);\n-\t    }\n-\t}\n-    }\n-\n-  gimplify_stmt (&body);\n-  gimplify_stmt (&incr);\n-\n-  body = finish_bc_block (cont_block, body);\n-\n-  append_to_statement_list (top, &stmt_list);\n-  append_to_statement_list (body, &stmt_list);\n-  append_to_statement_list (incr, &stmt_list);\n-  append_to_statement_list (entry, &stmt_list);\n-  append_to_statement_list (exit, &stmt_list);\n-\n-  annotate_all_with_locus (&stmt_list, stmt_locus);\n-\n-  return finish_bc_block (break_block, stmt_list);\n-}\n-\n-/* Gimplify a FOR_STMT node.  Move the stuff in the for-init-stmt into the\n-   prequeue and hand off to gimplify_c_loop.  */\n-\n-static enum gimplify_status\n-gimplify_for_stmt (tree *stmt_p, tree *pre_p)\n-{\n-  tree stmt = *stmt_p;\n-\n-  if (FOR_INIT_STMT (stmt))\n-    gimplify_and_add (FOR_INIT_STMT (stmt), pre_p);\n-\n-  *stmt_p = gimplify_c_loop (FOR_COND (stmt), FOR_BODY (stmt),\n-\t\t\t     FOR_EXPR (stmt), 1);\n-\n-  return GS_ALL_DONE;\n-}\n-\n-/* Gimplify a WHILE_STMT node.  */\n-\n-static enum gimplify_status\n-gimplify_while_stmt (tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  *stmt_p = gimplify_c_loop (WHILE_COND (stmt), WHILE_BODY (stmt),\n-\t\t\t     NULL_TREE, 1);\n-  return GS_ALL_DONE;\n-}\n-\n-/* Gimplify a DO_STMT node.  */\n-\n-static enum gimplify_status\n-gimplify_do_stmt (tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  *stmt_p = gimplify_c_loop (DO_COND (stmt), DO_BODY (stmt),\n-\t\t\t     NULL_TREE, 0);\n-  return GS_ALL_DONE;\n-}\n-\n-/* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */\n-\n-static enum gimplify_status\n-gimplify_switch_stmt (tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  tree break_block, body;\n-  location_t stmt_locus = input_location;\n-\n-  break_block = begin_bc_block (bc_break);\n-\n-  body = SWITCH_STMT_BODY (stmt);\n-  if (!body)\n-    body = build_empty_stmt ();\n-\n-  *stmt_p = build3 (SWITCH_EXPR, SWITCH_STMT_TYPE (stmt),\n-\t\t    SWITCH_STMT_COND (stmt), body, NULL_TREE);\n-  SET_EXPR_LOCATION (*stmt_p, stmt_locus);\n-  gimplify_stmt (stmt_p);\n-\n-  *stmt_p = finish_bc_block (break_block, *stmt_p);\n-  return GS_ALL_DONE;\n-}\n-\n /* Gimplification of expression trees.  */\n \n /* Gimplify a C99 compound literal expression.  This just means adding the\n@@ -515,29 +266,9 @@ c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n     case COMPOUND_LITERAL_EXPR:\n       return gimplify_compound_literal_expr (expr_p, pre_p);\n \n-    case FOR_STMT:\n-      return gimplify_for_stmt (expr_p, pre_p);\n-\n-    case WHILE_STMT:\n-      return gimplify_while_stmt (expr_p);\n-\n-    case DO_STMT:\n-      return gimplify_do_stmt (expr_p);\n-\n-    case SWITCH_STMT:\n-      return gimplify_switch_stmt (expr_p);\n-\n     case EXPR_STMT:\n       return gimplify_expr_stmt (expr_p);\n \n-    case CONTINUE_STMT:\n-      *expr_p = build_bc_goto (bc_continue);\n-      return GS_ALL_DONE;\n-\n-    case BREAK_STMT:\n-      *expr_p = build_bc_goto (bc_break);\n-      return GS_ALL_DONE;\n-\n     default:\n       return GS_UNHANDLED;\n     }"}, {"sha": "21af965b13818a95fe1711915f1290b144c89f69", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -1965,84 +1965,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       pp_needs_newline (pp) = true;\n       break;\n \n-    case SWITCH_STMT:\n-      pp_c_identifier (pp, \"switch\");\n-      pp_space (pp);\n-      pp_c_left_paren (pp);\n-      pp_expression (pp, SWITCH_COND (stmt));\n-      pp_c_right_paren (pp);\n-      pp_indentation (pp) += 3;\n-      pp_needs_newline (pp) = true;\n-      pp_statement (pp, SWITCH_BODY (stmt));\n-      pp_newline_and_indent (pp, -3);\n-      break;\n-\n-      /* iteration-statement:\n-            while ( expression ) statement\n-            do statement while ( expression ) ;\n-            for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n-            for ( declaration expression(opt) ; expression(opt) ) statement  */\n-    case WHILE_STMT:\n-      pp_c_identifier (pp, \"while\");\n-      pp_space (pp);\n-      pp_c_left_paren (pp);\n-      pp_expression (pp, WHILE_COND (stmt));\n-      pp_c_right_paren (pp);\n-      pp_newline_and_indent (pp, 3);\n-      pp_statement (pp, WHILE_BODY (stmt));\n-      pp_indentation (pp) -= 3;\n-      pp_needs_newline (pp) = true;\n-      break;\n-\n-    case DO_STMT:\n-      pp_c_identifier (pp, \"do\");\n-      pp_newline_and_indent (pp, 3);\n-      pp_statement (pp, DO_BODY (stmt));\n-      pp_newline_and_indent (pp, -3);\n-      pp_c_identifier (pp, \"while\");\n-      pp_space (pp);\n-      pp_c_left_paren (pp);\n-      pp_expression (pp, DO_COND (stmt));\n-      pp_c_right_paren (pp);\n-      pp_c_semicolon (pp);\n-      pp_needs_newline (pp) = true;\n-      break;\n-\n-    case FOR_STMT:\n-      pp_c_identifier (pp, \"for\");\n-      pp_space (pp);\n-      pp_c_left_paren (pp);\n-      if (FOR_INIT_STMT (stmt))\n-        pp_statement (pp, FOR_INIT_STMT (stmt));\n-      else\n-        pp_c_semicolon (pp);\n-      pp_needs_newline (pp) = false;\n-      pp_c_whitespace (pp);\n-      if (FOR_COND (stmt))\n-\tpp_expression (pp, FOR_COND (stmt));\n-      pp_c_semicolon (pp);\n-      pp_needs_newline (pp) = false;\n-      pp_c_whitespace (pp);\n-      if (FOR_EXPR (stmt))\n-\tpp_expression (pp, FOR_EXPR (stmt));\n-      pp_c_right_paren (pp);\n-      pp_newline_and_indent (pp, 3);\n-      pp_statement (pp, FOR_BODY (stmt));\n-      pp_indentation (pp) -= 3;\n-      pp_needs_newline (pp) = true;\n-      break;\n-\n-      /* jump-statement:\n-            goto identifier;\n-            continue ;\n-            return expression(opt) ;  */\n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-      pp_identifier (pp, code == BREAK_STMT ? \"break\" : \"continue\");\n-      pp_c_semicolon (pp);\n-      pp_needs_newline (pp) = true;\n-      break;\n-\n     default:\n       dump_generic_node (pp_base (pp), stmt, pp_indentation (pp), 0, true);\n       break;"}, {"sha": "567a440706b2a1738853bc6e45db442242803caf", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -193,22 +193,6 @@ emit_local_var (tree decl)\n     }\n }\n \n-/* Build a break statement node and return it.  */\n-\n-tree\n-build_break_stmt (void)\n-{\n-  return (build_stmt (BREAK_STMT));\n-}\n-\n-/* Build a continue statement node and return it.  */\n-\n-tree\n-build_continue_stmt (void)\n-{\n-  return (build_stmt (CONTINUE_STMT));\n-}\n-\n /* Create a CASE_LABEL_EXPR tree node and return it.  */\n \n tree"}, {"sha": "8c3996613e30b3990c0a2deb1ad75b832719b891", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -6728,13 +6728,20 @@ void\n c_finish_case (tree body)\n {\n   struct c_switch *cs = c_switch_stack;\n+  location_t switch_location;\n \n   SWITCH_BODY (cs->switch_expr) = body;\n \n   gcc_assert (!cs->blocked_stmt_expr);\n \n   /* Emit warnings as needed.  */\n-  c_do_switch_expr_warnings (cs->cases, cs->switch_expr);\n+  if (EXPR_HAS_LOCATION (cs->switch_expr))\n+    switch_location = EXPR_LOCATION (cs->switch_expr);\n+  else\n+    switch_location = input_location;\n+  c_do_switch_warnings (cs->cases, switch_location,\n+\t\t\tTREE_TYPE (cs->switch_expr),\n+\t\t\tSWITCH_COND (cs->switch_expr));\n \n   /* Pop the stack.  */\n   c_switch_stack = cs->next;"}, {"sha": "c63486e39dffc26ef8bea4a43ce85bbfa4f9bd06", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -1,3 +1,33 @@\n+2005-04-08  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* cp-tree.def: Define FOR_STMT, WHILE_STMT, DO_STMT, BREAK_STMT,\n+\tCONTINUE_STMT, SWITCH_STMT.\n+\t* cp-tree.h (cp_stmt_codes): Add FOR_STMT, WHILE_STMT, DO_STMT,\n+\tBREAK_STMT, CONTINUE_STMT, SWITCH_STMT.\n+\t(WHILE_COND, WHILE_BODY): Define.\n+\t(DO_COND, DO_BODY): Define.\n+\t(FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY): Define.\n+\t(SWITCH_STMT_COND, SWITCH_STMT_BODY, SWITCH_STMT_TYPE): Define.\n+\t* cp-gimplify.c (enum bc_t): Define.\n+\t(struct cp_gimplify_ctx, ctxp): Define.\n+\t(push_context, pop_context): New static functions.\n+\t(begin_bc_block, finish_bc_block): New static functions.\n+\t(build_bc_goto): New static function.\n+\t(gimplify_cp_loop, gimplify_for_stmt): New static functions.\n+\t(gimplify_while_stmt, gimplify_do_stmt): Likewise.\n+\t(gimplify_switch_stmt): Likewise.\n+\t(cp_gimplify_expr): Handle FOR_STMT, WHILE_STMT, DO_STMT,\n+\tSWITCH_STMT, CONTINUE_STMT, BREAK_STMT.\n+\t(cp_genericize): Call push_context and pop_context.\n+\t* semantics.c (finish_break_stmt): Just call build_stmt\n+\t(BREAK_STMT) rather than build_break_stmt.\n+\t(finish_continue_stmt): Corresponding change.\n+\t* decl.c (pop_switch): Update call to c_do_switch_warnings for new\n+\tparameters.\n+\t* cxx-pretty-print.c (pp_cxx_statement): Handle SWITCH_STMT,\n+\tWHILE_STMT, DO_STMT, FOR_STMT, BREAK_STMT, CONTINUE_STMT.\n+\t* dump.c (cp_dump_tree): Likewise.\n+\n 2005-04-08  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/20905"}, {"sha": "4d8880acb3b637656d0ac785403b69e796d32653", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 265, "deletions": 1, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -1,6 +1,6 @@\n /* C++-specific tree lowering bits; see also c-gimplify.c and tree-gimple.c.\n \n-   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Jason Merrill <jason@redhat.com>\n \n This file is part of GCC.\n@@ -32,6 +32,100 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hashtab.h\"\n #include \"pointer-set.h\"\n \n+/* Local declarations.  */\n+\n+enum bc_t { bc_break = 0, bc_continue = 1 };\n+\n+static struct cp_gimplify_ctx\n+{\n+  /* Stack of labels which are targets for \"break\" or \"continue\",\n+     linked through TREE_CHAIN.  */\n+  tree current_label[2];\n+} *ctxp;\n+\n+static void\n+push_context (void)\n+{\n+  gcc_assert (!ctxp);\n+  ctxp = ((struct cp_gimplify_ctx *)\n+\t  xcalloc (1, sizeof (struct cp_gimplify_ctx)));\n+}\n+\n+static void\n+pop_context (void)\n+{\n+  gcc_assert (ctxp\n+\t      && !ctxp->current_label[0]\n+\t      && !ctxp->current_label[1]);\n+  free (ctxp);\n+  ctxp = NULL;\n+}\n+\n+/* Begin a scope which can be exited by a break or continue statement.  BC\n+   indicates which.\n+\n+   Just creates a label and pushes it into the current context.  */\n+\n+static tree\n+begin_bc_block (enum bc_t bc)\n+{\n+  tree label = create_artificial_label ();\n+  TREE_CHAIN (label) = ctxp->current_label[bc];\n+  ctxp->current_label[bc] = label;\n+  return label;\n+}\n+\n+/* Finish a scope which can be exited by a break or continue statement.\n+   LABEL was returned from the most recent call to begin_bc_block.  BODY is\n+   an expression for the contents of the scope.\n+\n+   If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n+   body.  Otherwise, just forget the label.  */\n+\n+static tree\n+finish_bc_block (enum bc_t bc, tree label, tree body)\n+{\n+  gcc_assert (label == ctxp->current_label[bc]);\n+\n+  if (TREE_USED (label))\n+    {\n+      tree t, sl = NULL;\n+\n+      t = build1 (LABEL_EXPR, void_type_node, label);\n+\n+      append_to_statement_list (body, &sl);\n+      append_to_statement_list (t, &sl);\n+      body = sl;\n+    }\n+\n+  ctxp->current_label[bc] = TREE_CHAIN (label);\n+  TREE_CHAIN (label) = NULL_TREE;\n+  return body;\n+}\n+\n+/* Build a GOTO_EXPR to represent a break or continue statement.  BC\n+   indicates which.  */\n+\n+static tree\n+build_bc_goto (enum bc_t bc)\n+{\n+  tree label = ctxp->current_label[bc];\n+\n+  if (label == NULL_TREE)\n+    {\n+      if (bc == bc_break)\n+\terror (\"break statement not within loop or switch\");\n+      else\n+\terror (\"continue statement not within loop or switch\");\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Mark the label used for finish_bc_block.  */\n+  TREE_USED (label) = 1;\n+  return build1 (GOTO_EXPR, void_type_node, label);\n+}\n+\n /* Genericize a TRY_BLOCK.  */\n \n static void\n@@ -106,6 +200,144 @@ gimplify_if_stmt (tree *stmt_p)\n   *stmt_p = stmt;\n }\n \n+/* Build a generic representation of one of the C loop forms.  COND is the\n+   loop condition or NULL_TREE.  BODY is the (possibly compound) statement\n+   controlled by the loop.  INCR is the increment expression of a for-loop,\n+   or NULL_TREE.  COND_IS_FIRST indicates whether the condition is\n+   evaluated before the loop body as in while and for loops, or after the\n+   loop body as in do-while loops.  */\n+\n+static tree\n+gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n+{\n+  tree top, entry, exit, cont_block, break_block, stmt_list, t;\n+  location_t stmt_locus;\n+\n+  stmt_locus = input_location;\n+  stmt_list = NULL_TREE;\n+  entry = NULL_TREE;\n+\n+  break_block = begin_bc_block (bc_break);\n+  cont_block = begin_bc_block (bc_continue);\n+\n+  /* If condition is zero don't generate a loop construct.  */\n+  if (cond && integer_zerop (cond))\n+    {\n+      top = NULL_TREE;\n+      exit = NULL_TREE;\n+      if (cond_is_first)\n+\t{\n+\t  t = build_bc_goto (bc_break);\n+\t  append_to_statement_list (t, &stmt_list);\n+\t}\n+    }\n+  else\n+    {\n+      /* If we use a LOOP_EXPR here, we have to feed the whole thing\n+\t back through the main gimplifier to lower it.  Given that we\n+\t have to gimplify the loop body NOW so that we can resolve\n+\t break/continue stmts, seems easier to just expand to gotos.  */\n+      top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+\n+      /* If we have an exit condition, then we build an IF with gotos either\n+\t out of the loop, or to the top of it.  If there's no exit condition,\n+\t then we just build a jump back to the top.  */\n+      exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n+      if (cond && !integer_nonzerop (cond))\n+\t{\n+\t  t = build_bc_goto (bc_break);\n+\t  exit = build3 (COND_EXPR, void_type_node, cond, exit, t);\n+\t  exit = fold (exit);\n+\t  gimplify_stmt (&exit);\n+\n+\t  if (cond_is_first)\n+\t    {\n+\t      if (incr)\n+\t\t{\n+\t\t  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+\t\t  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n+\t\t}\n+\t      else\n+\t\tt = build_bc_goto (bc_continue);\n+\t      append_to_statement_list (t, &stmt_list);\n+\t    }\n+\t}\n+    }\n+\n+  gimplify_stmt (&body);\n+  gimplify_stmt (&incr);\n+\n+  body = finish_bc_block (bc_continue, cont_block, body);\n+\n+  append_to_statement_list (top, &stmt_list);\n+  append_to_statement_list (body, &stmt_list);\n+  append_to_statement_list (incr, &stmt_list);\n+  append_to_statement_list (entry, &stmt_list);\n+  append_to_statement_list (exit, &stmt_list);\n+\n+  annotate_all_with_locus (&stmt_list, stmt_locus);\n+\n+  return finish_bc_block (bc_break, break_block, stmt_list);\n+}\n+\n+/* Gimplify a FOR_STMT node.  Move the stuff in the for-init-stmt into the\n+   prequeue and hand off to gimplify_cp_loop.  */\n+\n+static void\n+gimplify_for_stmt (tree *stmt_p, tree *pre_p)\n+{\n+  tree stmt = *stmt_p;\n+\n+  if (FOR_INIT_STMT (stmt))\n+    gimplify_and_add (FOR_INIT_STMT (stmt), pre_p);\n+\n+  *stmt_p = gimplify_cp_loop (FOR_COND (stmt), FOR_BODY (stmt),\n+\t\t\t      FOR_EXPR (stmt), 1);\n+}\n+\n+/* Gimplify a WHILE_STMT node.  */\n+\n+static void\n+gimplify_while_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  *stmt_p = gimplify_cp_loop (WHILE_COND (stmt), WHILE_BODY (stmt),\n+\t\t\t      NULL_TREE, 1);\n+}\n+\n+/* Gimplify a DO_STMT node.  */\n+\n+static void\n+gimplify_do_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  *stmt_p = gimplify_cp_loop (DO_COND (stmt), DO_BODY (stmt),\n+\t\t\t      NULL_TREE, 0);\n+}\n+\n+/* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */\n+\n+static void\n+gimplify_switch_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  tree break_block, body;\n+  location_t stmt_locus = input_location;\n+\n+  break_block = begin_bc_block (bc_break);\n+\n+  body = SWITCH_STMT_BODY (stmt);\n+  if (!body)\n+    body = build_empty_stmt ();\n+\n+  *stmt_p = build3 (SWITCH_EXPR, SWITCH_STMT_TYPE (stmt),\n+\t\t    SWITCH_STMT_COND (stmt), body, NULL_TREE);\n+  SET_EXPR_LOCATION (*stmt_p, stmt_locus);\n+  gimplify_stmt (stmt_p);\n+\n+  *stmt_p = finish_bc_block (bc_break, break_block, *stmt_p);\n+}\n+\n /* Gimplify initialization from an AGGR_INIT_EXPR.  */\n \n static void\n@@ -254,6 +486,36 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       ret = GS_OK;\n       break;\n \n+    case FOR_STMT:\n+      gimplify_for_stmt (expr_p, pre_p);\n+      ret = GS_ALL_DONE;\n+      break;\n+\n+    case WHILE_STMT:\n+      gimplify_while_stmt (expr_p);\n+      ret = GS_ALL_DONE;\n+      break;\n+\n+    case DO_STMT:\n+      gimplify_do_stmt (expr_p);\n+      ret = GS_ALL_DONE;\n+      break;\n+\n+    case SWITCH_STMT:\n+      gimplify_switch_stmt (expr_p);\n+      ret = GS_ALL_DONE;\n+      break;\n+\n+    case CONTINUE_STMT:\n+      *expr_p = build_bc_goto (bc_continue);\n+      ret = GS_ALL_DONE;\n+      break;\n+\n+    case BREAK_STMT:\n+      *expr_p = build_bc_goto (bc_break);\n+      ret = GS_ALL_DONE;\n+      break;\n+\n     default:\n       ret = c_gimplify_expr (expr_p, pre_p, post_p);\n       break;\n@@ -369,5 +631,7 @@ cp_genericize (tree fndecl)\n   pointer_set_destroy (p_set);\n \n   /* Do everything else.  */\n+  push_context ();\n   c_genericize (fndecl);\n+  pop_context ();\n }"}, {"sha": "674de59f7b5075a0a2841fcb3d1e025975efdc95", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -2,7 +2,7 @@\n    additional tree codes used in the GNU C++ compiler (see tree.def\n    for the standard codes).\n    Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998, 2003, 2004, 2005, \n-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -283,6 +283,28 @@ DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", tcc_expression, 3)\n    and COND_EXPR for the benefit of templates.  */\n DEFTREECODE (IF_STMT, \"if_stmt\", tcc_expression, 3)\n \n+/* Used to represent a `for' statement. The operands are\n+   FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n+DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_expression, 4)\n+\n+/* Used to represent a 'while' statement. The operands are WHILE_COND\n+   and WHILE_BODY, respectively.  */\n+DEFTREECODE (WHILE_STMT, \"while_stmt\", tcc_expression, 2)\n+\n+/* Used to represent a 'do' statement. The operands are DO_BODY and\n+   DO_COND, respectively.  */\n+DEFTREECODE (DO_STMT, \"do_stmt\", tcc_expression, 2)\n+\n+/* Used to represent a 'break' statement.  */\n+DEFTREECODE (BREAK_STMT, \"break_stmt\", tcc_expression, 0)\n+\n+/* Used to represent a 'continue' statement.  */\n+DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", tcc_expression, 0)\n+\n+/* Used to represent a 'switch' statement. The operands are\n+   SWITCH_STMT_COND, SWITCH_STMT_BODY and SWITCH_STMT_TYPE, respectively.  */\n+DEFTREECODE (SWITCH_STMT, \"switch_stmt\", tcc_expression, 3)\n+\n DEFTREECODE (TAG_DEFN, \"tag_defn\", tcc_expression, 0)\n \n /* Template instantiation level node."}, {"sha": "3ab569f7b7beb45e2e9052b342c1f937bda8688d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -845,8 +845,9 @@ enum cplus_tree_code {\n #define cp_stmt_codes\t\t\t\t\t\\\n    CTOR_INITIALIZER,\tTRY_BLOCK,\tHANDLER,\t\\\n    EH_SPEC_BLOCK,\tUSING_STMT,\tTAG_DEFN,\t\\\n-   IF_STMT,\t\tCLEANUP_STMT\n-\n+   IF_STMT,\t\tCLEANUP_STMT,\tFOR_STMT,\t\\\n+   WHILE_STMT,\t\tDO_STMT,\tBREAK_STMT,\t\\\n+   CONTINUE_STMT,\tSWITCH_STMT\n enum languages { lang_c, lang_cplusplus, lang_java };\n \n /* Macros to make error reporting functions' lives easier.  */\n@@ -2948,6 +2949,28 @@ struct lang_decl GTY(())\n #define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n #define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n \n+/* WHILE_STMT accessors. These give access to the condition of the\n+   while statement and the body of the while statement, respectively.  */\n+#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n+#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n+\n+/* DO_STMT accessors. These give access to the condition of the do\n+   statement and the body of the do statement, respectively.  */\n+#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n+#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n+\n+/* FOR_STMT accessors. These give access to the init statement,\n+   condition, update expression, and body of the for statement,\n+   respectively.  */\n+#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n+#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n+#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n+#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n+\n+#define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n+#define SWITCH_STMT_BODY(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n+#define SWITCH_STMT_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n   none_type = 0, /* Not a tag type.  */"}, {"sha": "e185defa88e26794fd9055ac71bd92b0eedbafa6", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -1551,6 +1551,84 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \t}\n       break;\n \n+    case SWITCH_STMT:\n+      pp_cxx_identifier (pp, \"switch\");\n+      pp_space (pp);\n+      pp_cxx_left_paren (pp);\n+      pp_expression (pp, SWITCH_STMT_COND (t));\n+      pp_cxx_right_paren (pp);\n+      pp_indentation (pp) += 3;\n+      pp_needs_newline (pp) = true;\n+      pp_statement (pp, SWITCH_STMT_BODY (t));\n+      pp_newline_and_indent (pp, -3);\n+      break;\n+\n+      /* iteration-statement:\n+            while ( expression ) statement\n+            do statement while ( expression ) ;\n+            for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n+            for ( declaration expression(opt) ; expression(opt) ) statement  */\n+    case WHILE_STMT:\n+      pp_cxx_identifier (pp, \"while\");\n+      pp_space (pp);\n+      pp_cxx_left_paren (pp);\n+      pp_expression (pp, WHILE_COND (t));\n+      pp_cxx_right_paren (pp);\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, WHILE_BODY (t));\n+      pp_indentation (pp) -= 3;\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n+    case DO_STMT:\n+      pp_cxx_identifier (pp, \"do\");\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, DO_BODY (t));\n+      pp_newline_and_indent (pp, -3);\n+      pp_cxx_identifier (pp, \"while\");\n+      pp_space (pp);\n+      pp_cxx_left_paren (pp);\n+      pp_expression (pp, DO_COND (t));\n+      pp_cxx_right_paren (pp);\n+      pp_cxx_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n+    case FOR_STMT:\n+      pp_cxx_identifier (pp, \"for\");\n+      pp_space (pp);\n+      pp_cxx_left_paren (pp);\n+      if (FOR_INIT_STMT (t))\n+        pp_statement (pp, FOR_INIT_STMT (t));\n+      else\n+        pp_cxx_semicolon (pp);\n+      pp_needs_newline (pp) = false;\n+      pp_cxx_whitespace (pp);\n+      if (FOR_COND (t))\n+\tpp_expression (pp, FOR_COND (t));\n+      pp_cxx_semicolon (pp);\n+      pp_needs_newline (pp) = false;\n+      pp_cxx_whitespace (pp);\n+      if (FOR_EXPR (t))\n+\tpp_expression (pp, FOR_EXPR (t));\n+      pp_cxx_right_paren (pp);\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, FOR_BODY (t));\n+      pp_indentation (pp) -= 3;\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n+      /* jump-statement:\n+            goto identifier;\n+            continue ;\n+            return expression(opt) ;  */\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      pp_identifier (pp, TREE_CODE (t) == BREAK_STMT ? \"break\" : \"continue\");\n+      pp_cxx_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n     case CLEANUP_STMT:\n       pp_cxx_identifier (pp, \"try\");\n       pp_newline_and_indent (pp, 2);"}, {"sha": "c39ed7b8a511212f5de4050da544509d735e5ad2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -2369,9 +2369,16 @@ void\n pop_switch (void)\n {\n   struct cp_switch *cs = switch_stack;\n+  location_t switch_location;\n \n   /* Emit warnings as needed.  */\n-  c_do_switch_warnings (cs->cases, cs->switch_stmt);\n+  if (EXPR_HAS_LOCATION (cs->switch_stmt))\n+    switch_location = EXPR_LOCATION (cs->switch_stmt);\n+  else\n+    switch_location = input_location;\n+  c_do_switch_warnings (cs->cases, switch_location,\n+\t\t\tSWITCH_STMT_TYPE (cs->switch_stmt),\n+\t\t\tSWITCH_STMT_COND (cs->switch_stmt));\n \n   splay_tree_delete (cs->cases);\n   switch_stack = switch_stack->next;"}, {"sha": "f653d3ab3e737a83abd8578d036743fee29f2ff8", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -1,5 +1,6 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n This file is part of GCC.\n@@ -423,6 +424,37 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"else\", ELSE_CLAUSE (t));\n       break;\n \n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      dump_stmt (di, t);\n+      break;\n+\n+    case DO_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", DO_BODY (t));\n+      dump_child (\"cond\", DO_COND (t));\n+      break;\n+\n+    case FOR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"init\", FOR_INIT_STMT (t));\n+      dump_child (\"cond\", FOR_COND (t));\n+      dump_child (\"expr\", FOR_EXPR (t));\n+      dump_child (\"body\", FOR_BODY (t));\n+      break;\n+\n+    case SWITCH_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", SWITCH_STMT_COND (t));\n+      dump_child (\"body\", SWITCH_STMT_BODY (t));\n+      break;\n+\n+    case WHILE_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", WHILE_COND (t));\n+      dump_child (\"body\", WHILE_BODY (t));\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "e8240e8b29d60bdee0d08a89d444e12aae1cbf7e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc315db4a79aee216b2e56e1653e22d86436fea/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fbc315db4a79aee216b2e56e1653e22d86436fea", "patch": "@@ -834,15 +834,15 @@ finish_for_stmt (tree for_stmt)\n tree\n finish_break_stmt (void)\n {\n-  return add_stmt (build_break_stmt ());\n+  return add_stmt (build_stmt (BREAK_STMT));\n }\n \n /* Finish a continue-statement.  */\n \n tree\n finish_continue_stmt (void)\n {\n-  return add_stmt (build_continue_stmt ());\n+  return add_stmt (build_stmt (CONTINUE_STMT));\n }\n \n /* Begin a switch-statement.  Returns a new SWITCH_STMT if"}]}