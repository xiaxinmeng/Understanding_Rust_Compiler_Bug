{"sha": "865257c447cc50f5819e9b53da83145f3c36c305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1MjU3YzQ0N2NjNTBmNTgxOWU5YjUzZGE4MzE0NWYzYzM2YzMwNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-16T19:22:20Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-17T12:17:11Z"}, "message": "aarch64: Don't raise FE_INVALID for -__builtin_isgreater [PR93133]\n\nAIUI, the main purpose of REVERSE_CONDITION is to take advantage of\nany integer vs. FP information encoded in the CC mode, particularly\nwhen handling LT, LE, GE and GT.  For integer comparisons we can\nsafely map LT->GE, LE->GT, GE->LT and GT->LE, but for float comparisons\nthis would usually be invalid without -ffinite-math-only.\n\nThe aarch64 definition of REVERSE_CONDITION used\nreverse_condition_maybe_unordered for FP comparisons, which had the\neffect of converting an unordered-signalling LT, LE, GE or GT into a\nquiet UNGE, UNGT, UNLT or UNLE.  And it would do the same in reverse:\nconvert a quiet UN* into an unordered-signalling comparison.\n\nThis would be safe in practice (although a little misleading) if we\nalways used a compare:CCFP or compare:CCFPE to do the comparison and\nthen used (gt (reg:CCFP/CCFPE CC_REGNUM) (const_int 0)) etc. to test\nthe result.  In that case any signal is raised by the compare and the\nchoice of quiet vs. signalling relations doesn't matter when testing\nthe result.  The problem is that we also want to use GT directly on\nfloat registers, where any signal is raised by the comparison operation\nitself and so must follow the normal rtl rules (GT signalling,\nUNLE quiet).\n\nI think the safest fix is to make REVERSIBLE_CC_MODE return false\nfor FP comparisons.  We can then use the default REVERSE_CONDITION\nfor integer comparisons and the usual conservatively-correct\nreversed_comparison_code_parts behaviour for FP comparisons.\nUnfortunately reversed_comparison_code_parts doesn't yet handle\n-ffinite-math-only, but that's probably GCC 11 material.\n\nA downside is that:\n\n    int f (float x, float y) { return !(x < y); }\n\nnow generates:\n\n        fcmpe   s0, s1\n        cset    w0, mi\n        eor     w0, w0, 1\n        ret\n\nwithout -ffinite-math-only.  Maybe for GCC 11 we should define rtx\ncodes for all IEEE comparisons, so that we don't have this kind of\nrepresentational gap.\n\nChanging REVERSE_CONDITION itself is pretty easy.  However, the macro\nwas also used in the ccmp handling, which relied on being able to\nreverse all comparisons.  The patch adds new reversed patterns for\ncases in which the original condition needs to be kept.\n\nThe test is based on gcc.dg/torture/pr91323.c.  It might well fail\non other targets that have similar bugs; please XFAIL as appropriate\nif you don't want to fix the target for GCC 10.\n\n2020-01-17  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.h (REVERSIBLE_CC_MODE): Return false\n\tfor FP modes.\n\t(REVERSE_CONDITION): Delete.\n\t* config/aarch64/iterators.md (CC_ONLY): New mode iterator.\n\t(CCFP_CCFPE): Likewise.\n\t(e): New mode attribute.\n\t* config/aarch64/aarch64.md (ccmp<GPI:mode>): Rename to...\n\t(@ccmp<CC_ONLY:mode><GPI:mode>): ...this, using CC_ONLY instead of CC.\n\t(fccmp<GPF:mode>, fccmpe<GPF:mode>): Merge into...\n\t(@ccmp<CCFP_CCFPE:mode><GPF:mode>): ...this combined pattern.\n\t(@ccmp<CC_ONLY:mode><GPI:mode>_rev): New pattern.\n\t(@ccmp<CCFP_CCFPE:mode><GPF:mode>_rev): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_gen_compare_reg): Update\n\tname of generator from gen_ccmpdi to gen_ccmpccdi.\n\t(aarch64_gen_ccmp_next): Use code_for_ccmp.  If we want to reverse\n\tthe previous comparison but aren't able to, use the new ccmp_rev\n\tpatterns instead.", "tree": {"sha": "6be457f73f1b89446cdc3e933c7073391d95a2f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6be457f73f1b89446cdc3e933c7073391d95a2f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/865257c447cc50f5819e9b53da83145f3c36c305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865257c447cc50f5819e9b53da83145f3c36c305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/865257c447cc50f5819e9b53da83145f3c36c305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865257c447cc50f5819e9b53da83145f3c36c305/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "507de5ee23efdc8a16d6b0b6488e118055c711cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507de5ee23efdc8a16d6b0b6488e118055c711cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/507de5ee23efdc8a16d6b0b6488e118055c711cd"}], "stats": {"total": 171, "additions": 136, "deletions": 35}, "files": [{"sha": "6c6d586ca75de8878d63ca6731a09715a9079e13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=865257c447cc50f5819e9b53da83145f3c36c305", "patch": "@@ -1,3 +1,23 @@\n+2020-01-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.h (REVERSIBLE_CC_MODE): Return false\n+\tfor FP modes.\n+\t(REVERSE_CONDITION): Delete.\n+\t* config/aarch64/iterators.md (CC_ONLY): New mode iterator.\n+\t(CCFP_CCFPE): Likewise.\n+\t(e): New mode attribute.\n+\t* config/aarch64/aarch64.md (ccmp<GPI:mode>): Rename to...\n+\t(@ccmp<CC_ONLY:mode><GPI:mode>): ...this, using CC_ONLY instead of CC.\n+\t(fccmp<GPF:mode>, fccmpe<GPF:mode>): Merge into...\n+\t(@ccmp<CCFP_CCFPE:mode><GPF:mode>): ...this combined pattern.\n+\t(@ccmp<CC_ONLY:mode><GPI:mode>_rev): New pattern.\n+\t(@ccmp<CCFP_CCFPE:mode><GPF:mode>_rev): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_gen_compare_reg): Update\n+\tname of generator from gen_ccmpdi to gen_ccmpccdi.\n+\t(aarch64_gen_ccmp_next): Use code_for_ccmp.  If we want to reverse\n+\tthe previous comparison but aren't able to, use the new ccmp_rev\n+\tpatterns instead.\n+\n 2020-01-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gimplify.c (gimplify_return_expr): Use poly_int_tree_p rather"}, {"sha": "3660ce7bde09256668185a1f6a37ff0a13cdeb5d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=865257c447cc50f5819e9b53da83145f3c36c305", "patch": "@@ -2345,9 +2345,9 @@ aarch64_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n \n       rtx x_hi = operand_subword (x, 1, 0, TImode);\n       rtx y_hi = operand_subword (y, 1, 0, TImode);\n-      emit_insn (gen_ccmpdi (cc_reg, cc_reg, x_hi, y_hi,\n-\t\t\t     gen_rtx_EQ (cc_mode, cc_reg, const0_rtx),\n-\t\t\t     GEN_INT (AARCH64_EQ)));\n+      emit_insn (gen_ccmpccdi (cc_reg, cc_reg, x_hi, y_hi,\n+\t\t\t       gen_rtx_EQ (cc_mode, cc_reg, const0_rtx),\n+\t\t\t       GEN_INT (AARCH64_EQ)));\n     }\n   else\n     {\n@@ -20270,31 +20270,29 @@ aarch64_gen_ccmp_next (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev,\n     case E_HImode:\n     case E_SImode:\n       cmp_mode = SImode;\n-      icode = CODE_FOR_ccmpsi;\n       break;\n \n     case E_DImode:\n       cmp_mode = DImode;\n-      icode = CODE_FOR_ccmpdi;\n       break;\n \n     case E_SFmode:\n       cmp_mode = SFmode;\n       cc_mode = aarch64_select_cc_mode ((rtx_code) cmp_code, op0, op1);\n-      icode = cc_mode == CCFPEmode ? CODE_FOR_fccmpesf : CODE_FOR_fccmpsf;\n       break;\n \n     case E_DFmode:\n       cmp_mode = DFmode;\n       cc_mode = aarch64_select_cc_mode ((rtx_code) cmp_code, op0, op1);\n-      icode = cc_mode == CCFPEmode ? CODE_FOR_fccmpedf : CODE_FOR_fccmpdf;\n       break;\n \n     default:\n       end_sequence ();\n       return NULL_RTX;\n     }\n \n+  icode = code_for_ccmp (cc_mode, cmp_mode);\n+\n   op0 = prepare_operand (icode, op0, 2, op_mode, cmp_mode, unsignedp);\n   op1 = prepare_operand (icode, op1, 3, op_mode, cmp_mode, unsignedp);\n   if (!op0 || !op1)\n@@ -20310,9 +20308,21 @@ aarch64_gen_ccmp_next (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev,\n \n   if (bit_code != AND)\n     {\n-      prev = gen_rtx_fmt_ee (REVERSE_CONDITION (GET_CODE (prev),\n-\t\t\t\t\t\tGET_MODE (XEXP (prev, 0))),\n-\t\t\t     VOIDmode, XEXP (prev, 0), const0_rtx);\n+      /* Treat the ccmp patterns as canonical and use them where possible,\n+\t but fall back to ccmp_rev patterns if there's no other option.  */\n+      rtx_code prev_code = GET_CODE (prev);\n+      machine_mode prev_mode = GET_MODE (XEXP (prev, 0));\n+      if ((prev_mode == CCFPmode || prev_mode == CCFPEmode)\n+\t  && !(prev_code == EQ\n+\t       || prev_code == NE\n+\t       || prev_code == ORDERED\n+\t       || prev_code == UNORDERED))\n+\ticode = code_for_ccmp_rev (cc_mode, cmp_mode);\n+      else\n+\t{\n+\t  rtx_code code = reverse_condition (prev_code);\n+\t  prev = gen_rtx_fmt_ee (code, VOIDmode, XEXP (prev, 0), const0_rtx);\n+\t}\n       aarch64_cond = AARCH64_INVERSE_CONDITION_CODE (aarch64_cond);\n     }\n "}, {"sha": "f46b01c0ff8bcb4547d127cab81d684793f85116", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=865257c447cc50f5819e9b53da83145f3c36c305", "patch": "@@ -1026,12 +1026,10 @@ typedef struct\n \n #define SELECT_CC_MODE(OP, X, Y)\taarch64_select_cc_mode (OP, X, Y)\n \n-#define REVERSIBLE_CC_MODE(MODE) 1\n-\n-#define REVERSE_CONDITION(CODE, MODE)\t\t\\\n-  (((MODE) == CCFPmode || (MODE) == CCFPEmode)\t\\\n-   ? reverse_condition_maybe_unordered (CODE)\t\\\n-   : reverse_condition (CODE))\n+/* Having an integer comparison mode guarantees that we can use\n+   reverse_condition, but the usual restrictions apply to floating-point\n+   comparisons.  */\n+#define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPmode && (MODE) != CCFPEmode)\n \n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n   ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)"}, {"sha": "41dc4ed4bc47904f94de2adf2e0f36cb1c104a43", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=865257c447cc50f5819e9b53da83145f3c36c305", "patch": "@@ -493,16 +493,18 @@\n   \"\"\n   \"\")\n \n-(define_insn \"ccmp<mode>\"\n-  [(set (match_operand:CC 1 \"cc_register\" \"\")\n-\t(if_then_else:CC\n+(define_insn \"@ccmp<CC_ONLY:mode><GPI:mode>\"\n+  [(set (match_operand:CC_ONLY 1 \"cc_register\" \"\")\n+\t(if_then_else:CC_ONLY\n \t  (match_operator 4 \"aarch64_comparison_operator\"\n \t   [(match_operand 0 \"cc_register\" \"\")\n \t    (const_int 0)])\n-\t  (compare:CC\n+\t  (compare:CC_ONLY\n \t    (match_operand:GPI 2 \"register_operand\" \"r,r,r\")\n \t    (match_operand:GPI 3 \"aarch64_ccmp_operand\" \"r,Uss,Usn\"))\n-\t  (unspec:CC [(match_operand 5 \"immediate_operand\")] UNSPEC_NZCV)))]\n+\t  (unspec:CC_ONLY\n+\t    [(match_operand 5 \"immediate_operand\")]\n+\t    UNSPEC_NZCV)))]\n   \"\"\n   \"@\n    ccmp\\\\t%<w>2, %<w>3, %k5, %m4\n@@ -511,33 +513,57 @@\n   [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n-(define_insn \"fccmp<mode>\"\n-  [(set (match_operand:CCFP 1 \"cc_register\" \"\")\n-\t(if_then_else:CCFP\n+(define_insn \"@ccmp<CCFP_CCFPE:mode><GPF:mode>\"\n+  [(set (match_operand:CCFP_CCFPE 1 \"cc_register\" \"\")\n+\t(if_then_else:CCFP_CCFPE\n \t  (match_operator 4 \"aarch64_comparison_operator\"\n \t   [(match_operand 0 \"cc_register\" \"\")\n \t    (const_int 0)])\n-\t  (compare:CCFP\n+\t  (compare:CCFP_CCFPE\n \t    (match_operand:GPF 2 \"register_operand\" \"w\")\n \t    (match_operand:GPF 3 \"register_operand\" \"w\"))\n-\t  (unspec:CCFP [(match_operand 5 \"immediate_operand\")] UNSPEC_NZCV)))]\n+\t  (unspec:CCFP_CCFPE\n+\t    [(match_operand 5 \"immediate_operand\")]\n+\t    UNSPEC_NZCV)))]\n   \"TARGET_FLOAT\"\n-  \"fccmp\\\\t%<s>2, %<s>3, %k5, %m4\"\n+  \"fccmp<e>\\\\t%<s>2, %<s>3, %k5, %m4\"\n   [(set_attr \"type\" \"fccmp<s>\")]\n )\n \n-(define_insn \"fccmpe<mode>\"\n-  [(set (match_operand:CCFPE 1 \"cc_register\" \"\")\n-\t (if_then_else:CCFPE\n+(define_insn \"@ccmp<CC_ONLY:mode><GPI:mode>_rev\"\n+  [(set (match_operand:CC_ONLY 1 \"cc_register\" \"\")\n+\t(if_then_else:CC_ONLY\n \t  (match_operator 4 \"aarch64_comparison_operator\"\n \t   [(match_operand 0 \"cc_register\" \"\")\n-\t  (const_int 0)])\n-\t   (compare:CCFPE\n+\t    (const_int 0)])\n+\t  (unspec:CC_ONLY\n+\t    [(match_operand 5 \"immediate_operand\")]\n+\t    UNSPEC_NZCV)\n+\t  (compare:CC_ONLY\n+\t    (match_operand:GPI 2 \"register_operand\" \"r,r,r\")\n+\t    (match_operand:GPI 3 \"aarch64_ccmp_operand\" \"r,Uss,Usn\"))))]\n+  \"\"\n+  \"@\n+   ccmp\\\\t%<w>2, %<w>3, %k5, %M4\n+   ccmp\\\\t%<w>2, %3, %k5, %M4\n+   ccmn\\\\t%<w>2, #%n3, %k5, %M4\"\n+  [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n+)\n+\n+(define_insn \"@ccmp<CCFP_CCFPE:mode><GPF:mode>_rev\"\n+  [(set (match_operand:CCFP_CCFPE 1 \"cc_register\" \"\")\n+\t(if_then_else:CCFP_CCFPE\n+\t  (match_operator 4 \"aarch64_comparison_operator\"\n+\t   [(match_operand 0 \"cc_register\" \"\")\n+\t    (const_int 0)])\n+\t  (unspec:CCFP_CCFPE\n+\t    [(match_operand 5 \"immediate_operand\")]\n+\t    UNSPEC_NZCV)\n+\t  (compare:CCFP_CCFPE\n \t    (match_operand:GPF 2 \"register_operand\" \"w\")\n-\t    (match_operand:GPF 3 \"register_operand\" \"w\"))\n-\t  (unspec:CCFPE [(match_operand 5 \"immediate_operand\")] UNSPEC_NZCV)))]\n+\t    (match_operand:GPF 3 \"register_operand\" \"w\"))))]\n   \"TARGET_FLOAT\"\n-  \"fccmpe\\\\t%<s>2, %<s>3, %k5, %m4\"\n+  \"fccmp<e>\\\\t%<s>2, %<s>3, %k5, %M4\"\n   [(set_attr \"type\" \"fccmp<s>\")]\n )\n "}, {"sha": "fc973086cb91ae0dc54eeeb0b832d522539d7982", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=865257c447cc50f5819e9b53da83145f3c36c305", "patch": "@@ -22,6 +22,9 @@\n ;; Mode Iterators\n ;; -------------------------------------------------------------------\n \n+;; Condition-code iterators.\n+(define_mode_iterator CC_ONLY [CC])\n+(define_mode_iterator CCFP_CCFPE [CCFP CCFPE])\n \n ;; Iterator for General Purpose Integer registers (32- and 64-bit modes)\n (define_mode_iterator GPI [SI DI])\n@@ -833,6 +836,9 @@\n ;; Mode attributes\n ;; -------------------------------------------------------------------\n \n+;; \"e\" for signaling operations, \"\" for quiet operations.\n+(define_mode_attr e [(CCFP \"\") (CCFPE \"e\")])\n+\n ;; In GPI templates, a string like \"%<w>0\" will expand to \"%w0\" in the\n ;; 32-bit version and \"%x0\" in the 64-bit version.\n (define_mode_attr w [(QI \"w\") (HI \"w\") (SI \"w\") (DI \"x\") (SF \"s\") (DF \"d\")])"}, {"sha": "21eae1eb3dd7d5483b635c08e3e0de3b998b978b", "filename": "gcc/testsuite/gcc.dg/torture/pr93133.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93133.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865257c447cc50f5819e9b53da83145f3c36c305/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93133.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93133.c?ref=865257c447cc50f5819e9b53da83145f3c36c305", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+/* { dg-skip-if \"fenv\" { powerpc-ibm-aix* } } */\n+\n+#include <fenv.h>\n+\n+int\n+__attribute__ ((noinline, noclone))\n+f1 (float a, float b)\n+{\n+  return -__builtin_isgreater (a, b);\n+}\n+\n+int\n+__attribute__ ((noinline, noclone))\n+f2 (float a, float b)\n+{\n+  return -(a > b);\n+}\n+\n+int\n+main (void)\n+{\n+  volatile int r;\n+\n+  float nanf = __builtin_nanf (\"\");\n+  float argf = 1.0f;\n+\n+  feclearexcept (FE_INVALID);\n+\n+  r = f1 (nanf, argf);\n+  if (r != 0 || fetestexcept (FE_INVALID))\n+    __builtin_abort ();\n+\n+  r = f2 (nanf, argf);\n+  if (r != 0 || !fetestexcept (FE_INVALID))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}