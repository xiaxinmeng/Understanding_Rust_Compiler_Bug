{"sha": "665f250366b2cd1528c32b0d7d2fea6aae006e85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY1ZjI1MDM2NmIyY2QxNTI4YzMyYjBkN2QyZmVhNmFhZTAwNmU4NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-17T17:31:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-17T17:31:58Z"}, "message": "* Clean up usages of TREE_INT_CST_LOW.\n\n\t* c-parse.in (RESTORE_WARN_FLAGS): Use tree_low_cst.\n\t* c-parse.y, c-parse.c, objc/objc-parse.y, objc/objc-parse.c:\n\tRegenerated.\n\t* c-tree.h (min_precision): Move declaration to here.\n\t* c-typeck.c (build_binary_op): Use host_integerp and tree_low_cst.\n\t(build_unary_op, add_pending_init): Use bit_position.\n\t(pending_init_member, process_init_element): Likewise.\n\t(really_start_incremental_init, push_init_level, pop_init_level):\n\tDon't make copies of nodes or modify them in place, use consistent\n\ttypes when tracking positions, and use tree routines computations.\n\t(set_init_index, output_init_element): Likewise.\n\t(output_pending_init_elements, process_init_element): Likewise.\n\t* dbxout.c (dbxout_type_fields): Use bit_position, host_integerp,\n\ttree_low_cst and int_bit_position; also minor cleanup.\n\t(dbxout_type_method_1, dbxout_range_type, dbxout_type): Likewise.\n\t(print_cst_octal): Precision is unsigned.\n\t(dbxout_symbol): Ensure DECL_INITIAL is in-range and use tree_low_cst.\n\t* dwarf2out.c (ceiling): Input and output are unsigned HOST_WIDE_INT.\n\t(simple_type_align_in_bits): Result is unsigned int.\n\tUse tree_int_low_cst and host_integerp.\n\t(simple_type_size_in_bits): Result is unsigned HOST_WIDE_INT.\n\t(field_byte_offset): Result is HOST_WIDE_INT.\n\tChange types of internal variables so alignments are unsigned int,\n\toffsets are HOST_WIDE_INT and sizes are unsigned HOST_WIDE_INT.\n\tUse host_integerp, tree_low_cst, and int_bit_position.\n\t(add_bit_offset_attribute): Likewise.\n\t(add_data_member_location_attribute): Use tree_cst_low.\n\t(add_bound_info): Use host_integerp, integer_zerop, and integer_onep.\n\t(add_bit_size_attribute): Use tree_low_cst.\n\t(add_pure_or_virtual_attribute, gen_enumeration_type_die): Likewise.\n\t* dwarfout.c: Similar changes to dwarf2out.c.\n\t* expr.c (expand_expr, case ARRAY_REF): Remove redundant code.\n\t* genoutput.c (n_occurences): Return -1 for null string.\n\t(strip_whitespace): Accept null string and make into function.\n\t(scan_operands): Reflect above changes.\n\t* sdbout.c (plain_type_1): Use host_integerp and tree_low_cst.\n\t(sdbout_field_types, sdbout_one_type): Likewise; also use bit_position.\n\t* ssa.c (rename_registers): Add missing cast of arg to bzero.\n\t* tree.c (int_size_in_bytes): Check for too big to represent.\n\t(bit_position, int_bit_position, host_integerp, tree_low_cst): New fns.\n\t* tree.h (host_integerp, tree_low_cst, bit_position, int_bit_position):\n\tNew declarations.\n\t(min_precision): Delete from here.\n\t* varasm.c (decode_addr_const): Use host_integerp, bit_position,\n\tand int_bit_position.\n\t* objc/objc-act.c (encode_method_prototype): Sizes are HOST_WIDE_INT.\n\t(encode_method_def): Likewise.\n\t(build_ivar_list_initializer): Use int_bit_position.\n\t(generate_shared_structures): Convert size.\n\t(encode_type, encode_complete_bitfield): Use integer_zerop.\n\t(encode_bitfield): Use tree_low_cst and int_bit_position.\n\t* ch/typeck.c (min_precision): New function.\n\t(build_chill_slice): Use host_integerp and tree_low_cst.\n\t(expand_constant_to_buffer): Likewise and also int_bit_position.\n\tLO is unsigned HOST_WIDE_INT\n\t(build_chill_array_ref_1): Make `i' be HOST_WIDE_INT; use tree_low_cst.\n\t(extract_constant_from_buffer): Sizes are now HOST_WIDE_INT.\n\tUse host_integerp and tree_low_cst.\n\t(build_chill_bin_type): Use host_integerp and tree_low_cst.\n\t(layout_chill_range_type): Use tree_int_cst_sgn, compare_tree_int,\n\ttree_low_cst, and min_precision.\n\t(apply_chill_array_layout): Cleanups for types of variables\n\tand use tree_int_cst_sgn, compare_tree_int, and tree_low_cst.\n\t(apply_chill_field_layout): Likewise.\n\t* cp/class.c (build_vbase_path): Use integer_zerop.\n\t(build_vtable_entry): Use tree_low_cst.\n\t(get_vfield_offset): Use bit_position.\n\t(dfs_modify_vtables): New variable vindex_val; `i' is HOST_WIDE_INT.\n\tUse tree_low_cst.\n\t(check_bitfield_decl): Set DECL_SIZE using convert.\n\t(build_base_field): Set DECL_SIZE and DECL_SIZE_UNIT using size_binop.\n\t(layout_virtual_bases): DSIZE is unsigned HOST_WIDE_INT.\n\tUse tree_low_cst.\n\t(finish_struct_1): Use bit_position.\n\t(dump_class_hierarchy): Use tree_low_cst.\n\t* cp/cp-tree.h (min_precision): Add declaration.\n\t* cp/decl.c (xref_tag, xref_basetypes): Use tree_low_cst.\n\t* cp/error.c (dump_type_suffix): Use host_integerp and tree_low_cst.\n\t(dump_expr): Use integer_zerop, host_integerp, and tree_low_cst.\n\t* cp/expr.c (cplus_expand_constant): Use bit_position.\n\t* cp/init.c (build_vec_init): Use host_integerp and tree_low_cst.\n\t* cp/rtti.c (get_base_offset): Use bit_position.\n\t* cp/typeck.c (build_binary_op): Use integer_zerop, compare_tree_int,\n\thost_integerp, and tree_low_cst.\n\t(pointer_int_sum): Use integer_zerop.\n\t(build_component_addr): Use bit_position.\n\t* java/class.c (make_field_value): Properly handle sizes.\n\t(get_dispatch_vector): Use tree_low_cst and host_integerp.\n\t(layout_class_method): Count using trees.\n\t* java/decl.c (push_promoted_type): Set TYPE_{MIN,MAX}_VALUE with\n\tcopy_node.\n\t* java/expr.c (java_array_data_offset): Use int_bit_position.\n\t(build_newarray, build_anewarray): Use host_integerp and tree_low_cst.\n\t(build_invokevirtual): Use tree_low_cst and do computations with trees.\n\nFrom-SVN: r32607", "tree": {"sha": "0d31e5a8b4d8432cfb9d20e84ce3b4a97056fdf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d31e5a8b4d8432cfb9d20e84ce3b4a97056fdf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/665f250366b2cd1528c32b0d7d2fea6aae006e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665f250366b2cd1528c32b0d7d2fea6aae006e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/665f250366b2cd1528c32b0d7d2fea6aae006e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665f250366b2cd1528c32b0d7d2fea6aae006e85/comments", "author": null, "committer": null, "parents": [{"sha": "63f034bfe3afe558171d79c95166e3e86ee2c515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f034bfe3afe558171d79c95166e3e86ee2c515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f034bfe3afe558171d79c95166e3e86ee2c515"}], "stats": {"total": 1361, "additions": 756, "deletions": 605}, "files": [{"sha": "8816c16dbf4e403cbe1e6852e60ecb6da7e9c86f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -1,3 +1,58 @@\n+Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Clean up usages of TREE_INT_CST_LOW.\n+\t* c-parse.in (RESTORE_WARN_FLAGS): Use tree_low_cst.\n+\t* c-parse.y, c-parse.c, objc/objc-parse.y, objc/objc-parse.c:\n+\tRegenerated.\n+\t* c-tree.h (min_precision): Move declaration to here.\n+\t* c-typeck.c (build_binary_op): Use host_integerp and tree_low_cst.\n+\t(build_unary_op, add_pending_init): Use bit_position.\n+\t(pending_init_member, process_init_element): Likewise.\n+\t(really_start_incremental_init, push_init_level, pop_init_level):\n+\tDon't make copies of nodes or modify them in place, use consistent\n+\ttypes when tracking positions, and use tree routines computations.\n+\t(set_init_index, output_init_element): Likewise.\n+\t(output_pending_init_elements, process_init_element): Likewise.\n+\t* dbxout.c (dbxout_type_fields): Use bit_position, host_integerp,\n+\ttree_low_cst and int_bit_position; also minor cleanup.\n+\t(dbxout_type_method_1, dbxout_range_type, dbxout_type): Likewise.\n+\t(print_cst_octal): Precision is unsigned.\n+\t(dbxout_symbol): Ensure DECL_INITIAL is in-range and use tree_low_cst.\n+\t* dwarf2out.c (ceiling): Input and output are unsigned HOST_WIDE_INT.\n+\t(simple_type_align_in_bits): Result is unsigned int.\n+\tUse tree_int_low_cst and host_integerp.\n+\t(simple_type_size_in_bits): Result is unsigned HOST_WIDE_INT.\n+\t(field_byte_offset): Result is HOST_WIDE_INT.\n+\tChange types of internal variables so alignments are unsigned int,\n+\toffsets are HOST_WIDE_INT and sizes are unsigned HOST_WIDE_INT.\n+\tUse host_integerp, tree_low_cst, and int_bit_position.\n+\t(add_bit_offset_attribute): Likewise.\n+\t(add_data_member_location_attribute): Use tree_cst_low.\n+\t(add_bound_info): Use host_integerp, integer_zerop, and integer_onep.\n+\t(add_bit_size_attribute): Use tree_low_cst.\n+\t(add_pure_or_virtual_attribute, gen_enumeration_type_die): Likewise.\n+\t* dwarfout.c: Similar changes to dwarf2out.c.\n+\t* expr.c (expand_expr, case ARRAY_REF): Remove redundant code.\n+\t* genoutput.c (n_occurences): Return -1 for null string.\n+\t(strip_whitespace): Accept null string and make into function.\n+\t(scan_operands): Reflect above changes.\n+\t* sdbout.c (plain_type_1): Use host_integerp and tree_low_cst.\n+\t(sdbout_field_types, sdbout_one_type): Likewise; also use bit_position.\n+\t* ssa.c (rename_registers): Add missing cast of arg to bzero.\n+\t* tree.c (int_size_in_bytes): Check for too big to represent.\n+\t(bit_position, int_bit_position, host_integerp, tree_low_cst): New fns.\n+\t* tree.h (host_integerp, tree_low_cst, bit_position, int_bit_position):\n+\tNew declarations.\n+\t(min_precision): Delete from here.\n+\t* varasm.c (decode_addr_const): Use host_integerp, bit_position,\n+\tand int_bit_position.\n+\t* objc/objc-act.c (encode_method_prototype): Sizes are HOST_WIDE_INT.\n+\t(encode_method_def): Likewise.\n+\t(build_ivar_list_initializer): Use int_bit_position.\n+\t(generate_shared_structures): Convert size.\n+\t(encode_type, encode_complete_bitfield): Use integer_zerop.\n+\t(encode_bitfield): Use tree_low_cst and int_bit_position.\n+\t\n 2000-03-17  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.h (CPP_SPEC): Fix typo."}, {"sha": "599e11be1c157b58223ff18bd0ea648797dc289c", "filename": "gcc/c-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -129,7 +129,7 @@ static int undeclared_variable_notice;\n \tbuild_int_2 (pedantic | (warn_pointer_arith << 1), 0)\n #define RESTORE_WARN_FLAGS(tval) \\\n   do {                                     \\\n-    int val = TREE_INT_CST_LOW (tval);     \\\n+    int val = tree_low_cst (tval, 0);     \\\n     pedantic = val & 1;                    \\\n     warn_pointer_arith = (val >> 1) & 1;   \\\n   } while (0)"}, {"sha": "f1169ab412f3ace0ab934bc1c37922b6c8cca4a4", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -235,7 +235,7 @@ static int undeclared_variable_notice;\n \tbuild_int_2 (pedantic | (warn_pointer_arith << 1), 0)\n #define RESTORE_WARN_FLAGS(tval) \\\n   do {                                     \\\n-    int val = TREE_INT_CST_LOW (tval);     \\\n+    int val = tree_low_cst (tval, 0);     \\\n     pedantic = val & 1;                    \\\n     warn_pointer_arith = (val >> 1) & 1;   \\\n   } while (0)"}, {"sha": "ffe2aa82968dc1ec61dc2a814bfba506906b415c", "filename": "gcc/c-parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -210,7 +210,7 @@ static int undeclared_variable_notice;\n \tbuild_int_2 (pedantic | (warn_pointer_arith << 1), 0)\n #define RESTORE_WARN_FLAGS(tval) \\\n   do {                                     \\\n-    int val = TREE_INT_CST_LOW (tval);     \\\n+    int val = tree_low_cst (tval, 0);     \\\n     pedantic = val & 1;                    \\\n     warn_pointer_arith = (val >> 1) & 1;   \\\n   } while (0)"}, {"sha": "32e802e0f2e3217d9e57bfce80af42755d0dad77", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -170,6 +170,9 @@ extern void c_parse_init\t\t\tPARAMS ((void));\n /* in c-aux-info.c */\n extern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n \n+/* In c-common.c */\n+extern unsigned int min_precision\t\tPARAMS ((tree, int));\n+\n /* in c-convert.c */\n extern tree convert                             PARAMS ((tree, tree));\n "}, {"sha": "d1d16bdddfe75b0c64c67202dfb14db19e1c1fb9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 102, "deletions": 158, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -2373,8 +2373,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  enum tree_code xresultcode = resultcode;\n \t  tree val \n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n+\n \t  if (val != 0)\n \t    return val;\n+\n \t  op0 = xop0, op1 = xop1;\n \t  converted = 1;\n \t  resultcode = xresultcode;\n@@ -2384,7 +2386,6 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t    {\n \t      int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n \t      int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n-\n \t      int unsignedp0, unsignedp1;\n \t      tree primop0 = get_narrower (op0, &unsignedp0);\n \t      tree primop1 = get_narrower (op1, &unsignedp1);\n@@ -2395,11 +2396,12 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      STRIP_TYPE_NOPS (xop1);\n \n \t      /* Give warnings for comparisons between signed and unsigned\n-\t\t quantities that may fail.  */\n-\t      /* Do the checking based on the original operand trees, so that\n-\t\t casts will be considered, but default promotions won't be.  */\n+\t\t quantities that may fail. \n \n-\t      /* Do not warn if the comparison is being done in a signed type,\n+\t\t Do the checking based on the original operand trees, so that\n+\t\t casts will be considered, but default promotions won't be.\n+\n+\t\t Do not warn if the comparison is being done in a signed type,\n \t\t since the signed type will only be chosen if it can represent\n \t\t all the values of the unsigned type.  */\n \t      if (! TREE_UNSIGNED (result_type))\n@@ -2410,6 +2412,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      else\n \t\t{\n \t\t  tree sop, uop;\n+\n \t\t  if (op0_signed)\n \t\t    sop = xop0, uop = xop1;\n \t\t  else\n@@ -2458,24 +2461,23 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\t    primop1 = get_narrower (TREE_OPERAND (primop1, 0),\n \t\t\t\t\t    &unsignedp1);\n \t      \n-\t\t  if (TREE_CODE (primop0) == INTEGER_CST\n-\t\t      || TREE_CODE (primop1) == INTEGER_CST)\n+\t\t  if (host_integerp (primop0, 0) || host_integerp (primop1, 0))\n \t\t    {\n \t\t      tree primop;\n \t\t      HOST_WIDE_INT constant, mask;\n \t\t      int unsignedp, bits;\n \n-\t\t      if (TREE_CODE (primop0) == INTEGER_CST)\n+\t\t      if (host_integerp (primop0, 0))\n \t\t\t{\n \t\t\t  primop = primop1;\n \t\t\t  unsignedp = unsignedp1;\n-\t\t\t  constant = TREE_INT_CST_LOW (primop0);\n+\t\t\t  constant = tree_low_cst (primop0, 0);\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  primop = primop0;\n \t\t\t  unsignedp = unsignedp0;\n-\t\t\t  constant = TREE_INT_CST_LOW (primop1);\n+\t\t\t  constant = tree_low_cst (primop1, 0);\n \t\t\t}\n \n \t\t      bits = TYPE_PRECISION (TREE_TYPE (primop));\n@@ -3018,10 +3020,10 @@ build_unary_op (code, xarg, noconvert)\n \n \t    addr = convert (argtype, addr);\n \n-\t    if (! integer_zerop (DECL_FIELD_BITPOS (field)))\n+\t    if (! integer_zerop (bit_position (field)))\n \t      {\n \t\ttree offset\n-\t\t  = size_binop (EASY_DIV_EXPR, DECL_FIELD_BITPOS (field),\n+\t\t  = size_binop (EASY_DIV_EXPR, bit_position (field),\n \t\t\t\tbitsize_int (BITS_PER_UNIT));\n \t\tint flag = TREE_CONSTANT (addr);\n \n@@ -4723,8 +4725,7 @@ static tree constructor_type;\n static tree constructor_fields;\n \n /* For an ARRAY_TYPE, this is the specified index\n-   at which to store the next element we get.\n-   This is a special INTEGER_CST node that we modify in place.  */\n+   at which to store the next element we get.  */\n static tree constructor_index;\n \n /* For an ARRAY_TYPE, this is the end index of the range\n@@ -4739,13 +4740,11 @@ static tree constructor_max_index;\n static tree constructor_unfilled_fields;\n \n /* For an ARRAY_TYPE, this is the index of the first element\n-   not yet written out.\n-   This is a special INTEGER_CST node that we modify in place.  */\n+   not yet written out.  */\n static tree constructor_unfilled_index;\n \n /* In a RECORD_TYPE, the byte index of the next consecutive field.\n-   This is so we can generate gaps between fields, when appropriate.\n-   This is a special INTEGER_CST node that we modify in place.  */\n+   This is so we can generate gaps between fields, when appropriate.  */\n static tree constructor_bit_index;\n \n /* If we are saving up the elements rather than allocating them,\n@@ -5028,8 +5027,9 @@ really_start_incremental_init (type)\n       while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n \t     && DECL_NAME (constructor_fields) == 0)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n+\n       constructor_unfilled_fields = constructor_fields;\n-      constructor_bit_index = copy_node (size_zero_node);\n+      constructor_bit_index = bitsize_int (0);\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5039,14 +5039,13 @@ really_start_incremental_init (type)\n \t  constructor_max_index\n \t    = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n \t  constructor_index\n-\t    = copy_node (convert (bitsizetype,\n-\t\t\t\t  TYPE_MIN_VALUE\n-\t\t\t\t  (TYPE_DOMAIN (constructor_type))));\n+\t    = convert (bitsizetype,\n+\t\t       TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n \t}\n       else\n-\tconstructor_index = copy_node (bitsize_int (0));\n+\tconstructor_index = bitsize_int (0);\n \n-      constructor_unfilled_index = copy_node (constructor_index);\n+      constructor_unfilled_index = constructor_index;\n     }\n   else\n     {\n@@ -5101,20 +5100,16 @@ push_init_level (implicit)\n     {\n       /* Advance to offset of this element.  */\n       if (! tree_int_cst_equal (constructor_bit_index,\n-\t\t\t\tDECL_FIELD_BITPOS (constructor_fields)))\n-\t{\n-\t  /* By using unsigned arithmetic, the result will be correct even\n-\t     in case of overflows, if BITS_PER_UNIT is a power of two.  */\n-\t  unsigned next = (TREE_INT_CST_LOW\n-\t\t\t   (DECL_FIELD_BITPOS (constructor_fields))\n-\t\t\t   / (unsigned)BITS_PER_UNIT);\n-\t  unsigned here = (TREE_INT_CST_LOW (constructor_bit_index)\n-\t\t\t   / (unsigned)BITS_PER_UNIT);\n-\n-\t  assemble_zeros ((next - here)\n-\t\t\t  * (unsigned)BITS_PER_UNIT\n-\t\t\t  / (unsigned)BITS_PER_UNIT);\n-\t}\n+\t\t\t\tbit_position (constructor_fields)))\n+\tassemble_zeros\n+\t  (tree_low_cst\n+\t   (size_binop (TRUNC_DIV_EXPR,\n+\t\t\tsize_binop (MINUS_EXPR,\n+\t\t\t\t    bit_position (constructor_fields),\n+\t\t\t\t    constructor_bit_index),\n+\t\t\tbitsize_int (BITS_PER_UNIT)),\n+\t    1));\n+\n       /* Indicate that we have now filled the structure up to the current\n \t field.  */\n       constructor_unfilled_fields = constructor_fields;\n@@ -5170,7 +5165,7 @@ push_init_level (implicit)\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n       constructor_type = TREE_TYPE (constructor_type);\n-      push_array_bounds (TREE_INT_CST_LOW (constructor_index));\n+      push_array_bounds (tree_low_cst (constructor_index, 0));\n       constructor_depth++;\n       if (! tree_int_cst_equal (constructor_index, constructor_unfilled_index)\n \t  || constructor_range_end != 0)\n@@ -5202,8 +5197,9 @@ push_init_level (implicit)\n       while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n \t     && DECL_NAME (constructor_fields) == 0)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n+\n       constructor_unfilled_fields = constructor_fields;\n-      constructor_bit_index = copy_node (size_zero_node);\n+      constructor_bit_index = bitsize_int (0);\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5213,14 +5209,14 @@ push_init_level (implicit)\n \t  constructor_max_index\n \t    = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n \t  constructor_index\n-\t    = copy_node (convert (bitsizetype, \n+\t    = convert (bitsizetype, \n \t\t\t\t  TYPE_MIN_VALUE\n-\t\t\t\t  (TYPE_DOMAIN (constructor_type))));\n+\t\t\t\t  (TYPE_DOMAIN (constructor_type)));\n \t}\n       else\n \tconstructor_index = bitsize_int (0);\n \n-      constructor_unfilled_index = copy_node (constructor_index);\n+      constructor_unfilled_index = constructor_index;\n     }\n   else\n     {\n@@ -5282,7 +5278,7 @@ pop_init_level (implicit)\n      int implicit;\n {\n   struct constructor_stack *p;\n-  int size = 0;\n+  HOST_WIDE_INT size = 0;\n   tree constructor = 0;\n \n   if (implicit == 0)\n@@ -5402,7 +5398,7 @@ pop_init_level (implicit)\n \t/* Find the offset of the end of that field.  */\n \tfilled = size_binop (CEIL_DIV_EXPR,\n \t\t\t     constructor_bit_index,\n-\t\t\t     size_int (BITS_PER_UNIT));\n+\t\t\t     bitsize_int (BITS_PER_UNIT));\n \n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n@@ -5422,10 +5418,12 @@ pop_init_level (implicit)\n \t\t in the array, because we start counting at zero.  Therefore,\n \t\t warn only if the value is less than zero.  */\n \t      if (pedantic\n-\t\t  && (tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)))\n+\t\t  && (tree_int_cst_sgn\n+\t\t      (TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)))\n \t\t      < 0))\n \t\terror_with_decl (constructor_decl,\n \t\t\t\t \"zero or negative array size `%s'\");\n+\n \t      layout_type (constructor_type);\n \t      size = int_size_in_bytes (constructor_type);\n \t    }\n@@ -5440,7 +5438,7 @@ pop_init_level (implicit)\n \tfilled = 0;\n \n       if (filled != 0)\n-\tassemble_zeros (size - TREE_INT_CST_LOW (filled));\n+\tassemble_zeros (size - tree_low_cst (filled, 1));\n     }\n \n \t  \n@@ -5486,14 +5484,15 @@ set_init_index (first, last)\n \t  || TREE_CODE (first) == NON_LVALUE_EXPR)\n \t && (TYPE_MODE (TREE_TYPE (first))\n \t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (first, 0)))))\n-    (first) = TREE_OPERAND (first, 0);\n+    first = TREE_OPERAND (first, 0);\n+\n   if (last)\n     while ((TREE_CODE (last) == NOP_EXPR\n \t    || TREE_CODE (last) == CONVERT_EXPR\n \t    || TREE_CODE (last) == NON_LVALUE_EXPR)\n \t   && (TYPE_MODE (TREE_TYPE (last))\n \t       == TYPE_MODE (TREE_TYPE (TREE_OPERAND (last, 0)))))\n-      (last) = TREE_OPERAND (last, 0);\n+      last = TREE_OPERAND (last, 0);\n \n   if (TREE_CODE (first) != INTEGER_CST)\n     error_init (\"nonconstant array index in initializer\");\n@@ -5505,16 +5504,16 @@ set_init_index (first, last)\n     error_init (\"duplicate array index in initializer\");\n   else\n     {\n-      TREE_INT_CST_LOW (constructor_index) = TREE_INT_CST_LOW (first);\n-      TREE_INT_CST_HIGH (constructor_index) = TREE_INT_CST_HIGH (first);\n+      constructor_index = convert (bitsizetype, first);\n \n       if (last != 0 && tree_int_cst_lt (last, first))\n \terror_init (\"empty index range in initializer\");\n       else\n \t{\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C forbids specifying element to initialize\");\n-\t  constructor_range_end = last;\n+\n+\t  constructor_range_end = last ? convert (bitsizetype, last) : 0;\n \t}\n     }\n }\n@@ -5587,8 +5586,8 @@ add_pending_init (purpose, value)\n       while (*q != NULL)\n \t{\n \t  p = *q;\n-\t  if (tree_int_cst_lt (DECL_FIELD_BITPOS (purpose),\n-\t\t\t       DECL_FIELD_BITPOS (p->purpose)))\n+\t  if (tree_int_cst_lt (bit_position (purpose),\n+\t\t\t       bit_position (p->purpose)))\n \t    q = &p->left;\n \t  else if (p->purpose != purpose)\n \t    q = &p->right;\n@@ -5789,8 +5788,8 @@ pending_init_member (field)\n \t{\n \t  if (field == p->purpose)\n \t    return 1;\n-\t  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (field),\n-\t\t\t\t    DECL_FIELD_BITPOS (p->purpose)))\n+\t  else if (tree_int_cst_lt (bit_position (field),\n+\t\t\t\t    bit_position (p->purpose)))\n \t    p = p->left;\n \t  else\n \t    p = p->right;\n@@ -5870,12 +5869,10 @@ output_init_element (value, type, field, pending)\n   /* If this element doesn't come next in sequence,\n      put it on constructor_pending_elts.  */\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE\n-      && !tree_int_cst_equal (field, constructor_unfilled_index))\n+      && ! tree_int_cst_equal (field, constructor_unfilled_index))\n     {\n       if (! duplicate)\n-\t/* The copy_node is needed in case field is actually\n-\t   constructor_index, which is modified in place.  */\n-\tadd_pending_init (copy_node (field),\n+\tadd_pending_init (field,\n \t\t\t  digest_init (type, value, require_constant_value, \n \t\t\t\t       require_constant_elements));\n     }\n@@ -5911,27 +5908,18 @@ output_init_element (value, type, field, pending)\n \t    {\n \t      /* Structure elements may require alignment.\n \t\t Do this, if necessary.  */\n-\t      if (TREE_CODE (constructor_type) == RECORD_TYPE)\n-\t\t{\n-\t\t  /* Advance to offset of this element.  */\n-\t\t  if (! tree_int_cst_equal (constructor_bit_index,\n-\t\t\t\t\t    DECL_FIELD_BITPOS (field)))\n-\t\t    {\n-\t\t      /* By using unsigned arithmetic, the result will be\n-\t\t\t correct even in case of overflows, if BITS_PER_UNIT\n-\t\t\t is a power of two.  */\n-\t\t      unsigned next = (TREE_INT_CST_LOW\n-\t\t\t\t       (DECL_FIELD_BITPOS (field))\n-\t\t\t\t       / (unsigned)BITS_PER_UNIT);\n-\t\t      unsigned here = (TREE_INT_CST_LOW\n-\t\t\t\t       (constructor_bit_index)\n-\t\t\t\t       / (unsigned)BITS_PER_UNIT);\n-\n-\t\t      assemble_zeros ((next - here)\n-\t\t\t\t      * (unsigned)BITS_PER_UNIT\n-\t\t\t\t      / (unsigned)BITS_PER_UNIT);\n-\t\t    }\n-\t\t}\n+\t      if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t\t  && ! tree_int_cst_equal (constructor_bit_index,\n+\t\t\t\t\t   bit_position (field)))\n+\t\t/* Advance to offset of this element.  */\n+\t\tassemble_zeros\n+\t\t  (tree_low_cst\n+\t\t   (size_binop (TRUNC_DIV_EXPR,\n+\t\t\t\tsize_binop (MINUS_EXPR, bit_position (field),\n+\t\t\t\t\t    constructor_bit_index),\n+\t\t\t\tbitsize_int (BITS_PER_UNIT)),\n+\t\t    0));\n+\n \t      output_constant (digest_init (type, value,\n \t\t\t\t\t    require_constant_value,\n \t\t\t\t\t    require_constant_elements),\n@@ -5941,33 +5929,22 @@ output_init_element (value, type, field, pending)\n \t\t keep track of end position of last field.  */\n \t      if (TREE_CODE (constructor_type) == RECORD_TYPE\n \t\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n-\t\t{\n-\t\t  tree temp = size_binop (PLUS_EXPR, DECL_FIELD_BITPOS (field),\n-\t\t\t\t\t  DECL_SIZE (field));\n-\n-\t\t  TREE_INT_CST_LOW (constructor_bit_index)\n-\t\t    = TREE_INT_CST_LOW (temp);\n-\t\t  TREE_INT_CST_HIGH (constructor_bit_index)\n-\t\t    = TREE_INT_CST_HIGH (temp);\n-\t\t}\n+\t\tconstructor_bit_index\n+\t\t  = size_binop (PLUS_EXPR, bit_position (field),\n+\t\t\t\tDECL_SIZE (field));\n \t    }\n \t}\n \n       /* Advance the variable that indicates sequential elements output.  */\n       if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\t{\n-\t  tree tem = size_binop (PLUS_EXPR, constructor_unfilled_index,\n-\t\t\t\t bitsize_int (1));\n-\n-\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n-\t    = TREE_INT_CST_LOW (tem);\n-\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n-\t    = TREE_INT_CST_HIGH (tem);\n-\t}\n+\tconstructor_unfilled_index\n+\t  = size_binop (PLUS_EXPR, constructor_unfilled_index,\n+\t\t\tbitsize_int (1));\n       else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n \t{\n-\t  constructor_unfilled_fields =\n-\t    TREE_CHAIN (constructor_unfilled_fields);\n+\t  constructor_unfilled_fields\n+\t    = TREE_CHAIN (constructor_unfilled_fields);\n+\n \t  /* Skip any nameless bit fields.  */\n \t  while (constructor_unfilled_fields != 0\n \t\t && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n@@ -6067,8 +6044,8 @@ output_pending_init_elements (all)\n \t\t\t\t   constructor_unfilled_fields,\n \t\t\t\t   0);\n \t    }\n-\t  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (constructor_unfilled_fields),\n-\t\t\t\t    DECL_FIELD_BITPOS (elt->purpose)))\n+\t  else if (tree_int_cst_lt (bit_position (constructor_unfilled_fields),\n+\t\t\t\t    bit_position (elt->purpose)))\n \t    {\n \t      /* Advance to the next smaller node.  */\n \t      if (elt->left)\n@@ -6094,8 +6071,9 @@ output_pending_init_elements (all)\n \t\t    elt = elt->parent;\n \t\t  elt = elt->parent;\n \t\t  if (elt\n-\t\t      && tree_int_cst_lt (DECL_FIELD_BITPOS (constructor_unfilled_fields),\n-\t\t\t\t\t  DECL_FIELD_BITPOS (elt->purpose)))\n+\t\t      && (tree_int_cst_lt\n+\t\t\t  (bit_position (constructor_unfilled_fields),\n+\t\t\t   bit_position (elt->purpose))))\n \t\t    {\n \t\t      next = elt->purpose;\n \t\t      break;\n@@ -6131,20 +6109,17 @@ output_pending_init_elements (all)\n \t    /* Find the offset of the end of that field.  */\n \t    filled = size_binop (CEIL_DIV_EXPR,\n \t\t\t\t size_binop (PLUS_EXPR,\n-\t\t\t\t\t     DECL_FIELD_BITPOS (tail),\n+\t\t\t\t\t     bit_position (tail),\n \t\t\t\t\t     DECL_SIZE (tail)),\n \t\t\t\t bitsize_int (BITS_PER_UNIT));\n \t  else\n \t    filled = bitsize_int (0);\n \n \t  nextpos_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t     DECL_FIELD_BITPOS (next),\n+\t\t\t\t     bit_position (next),\n \t\t\t\t     bitsize_int (BITS_PER_UNIT));\n \n-\t  TREE_INT_CST_HIGH (constructor_bit_index)\n-\t    = TREE_INT_CST_HIGH (DECL_FIELD_BITPOS (next));\n-\t  TREE_INT_CST_LOW (constructor_bit_index)\n-\t    = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (next));\n+\t  constructor_bit_index = bit_position (next);\n \t  constructor_unfilled_fields = next;\n \t}\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n@@ -6158,20 +6133,13 @@ output_pending_init_elements (all)\n \t    = size_binop (MULT_EXPR, next,\n \t\t\t  convert (bitsizetype, TYPE_SIZE_UNIT\n \t\t\t\t   (TREE_TYPE (constructor_type))));\n-\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n-\t    = TREE_INT_CST_LOW (next);\n-\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n-\t    = TREE_INT_CST_HIGH (next);\n+\t  constructor_unfilled_index = next;\n \t}\n       else\n \tfilled = 0;\n \n       if (filled)\n-\t{\n-\t  int nextpos = TREE_INT_CST_LOW (nextpos_tree);\n-\n-\t  assemble_zeros (nextpos - TREE_INT_CST_LOW (filled));\n-\t}\n+\tassemble_zeros (tree_low_cst (size_diffop (nextpos_tree, filled), 1));\n     }\n   else\n     {\n@@ -6182,12 +6150,7 @@ output_pending_init_elements (all)\n \t  || TREE_CODE (constructor_type) == UNION_TYPE)\n \tconstructor_unfilled_fields = next;\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\t{\n-\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n-\t    = TREE_INT_CST_LOW (next);\n-\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n-\t    = TREE_INT_CST_HIGH (next);\n-\t}\n+\tconstructor_unfilled_index = next;\n     }\n \n   /* ELT now points to the node in the pending tree with the next\n@@ -6305,14 +6268,10 @@ process_init_element (value)\n \t       directly output as a constructor.  */\n \t    {\n \t      /* For a record, keep track of end position of last field.  */\n-\t      tree temp = size_binop (PLUS_EXPR,\n-\t\t\t\t      DECL_FIELD_BITPOS (constructor_fields),\n-\t\t\t\t      DECL_SIZE (constructor_fields));\n-\n-\t      TREE_INT_CST_LOW (constructor_bit_index)\n-\t\t= TREE_INT_CST_LOW (temp);\n-\t      TREE_INT_CST_HIGH (constructor_bit_index)\n-\t\t= TREE_INT_CST_HIGH (temp);\n+\t      constructor_bit_index\n+\t\t= size_binop (PLUS_EXPR,\n+\t\t\t      bit_position (constructor_fields),\n+\t\t\t      DECL_SIZE (constructor_fields));\n \n \t      constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n \t      /* Skip any nameless bit fields.  */\n@@ -6375,11 +6334,7 @@ process_init_element (value)\n \t    /* Do the bookkeeping for an element that was\n \t       directly output as a constructor.  */\n \t    {\n-\t      TREE_INT_CST_LOW (constructor_bit_index)\n-\t\t= TREE_INT_CST_LOW (DECL_SIZE (constructor_fields));\n-\t      TREE_INT_CST_HIGH (constructor_bit_index)\n-\t\t= TREE_INT_CST_HIGH (DECL_SIZE (constructor_fields));\n-\n+\t      constructor_bit_index = DECL_SIZE (constructor_fields);\n \t      constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n \t    }\n \n@@ -6424,10 +6379,7 @@ process_init_element (value)\n \t\t\t\t      constructor_range_end))\n \t\t{\n \t\t  pedwarn_init (\"excess elements in array initializer\");\n-\t\t  TREE_INT_CST_HIGH (constructor_range_end)\n-\t\t    = TREE_INT_CST_HIGH (constructor_max_index);\n-\t\t  TREE_INT_CST_LOW (constructor_range_end)\n-\t\t    = TREE_INT_CST_LOW (constructor_max_index);\n+\t\t  constructor_range_end = constructor_max_index;\n \t\t}\n \n \t      value = save_expr (value);\n@@ -6438,29 +6390,21 @@ process_init_element (value)\n \t     If there is a range, repeat it till we advance past the range.  */\n \t  do\n \t    {\n-\t      tree tem;\n-\n \t      if (value)\n \t\t{\n-\t\t  push_array_bounds (TREE_INT_CST_LOW (constructor_index));\n+\t\t  push_array_bounds (tree_low_cst (constructor_index, 0));\n \t\t  output_init_element (value, elttype, constructor_index, 1);\n \t\t  RESTORE_SPELLING_DEPTH (constructor_depth);\n \t\t}\n \n-\t      tem = size_binop (PLUS_EXPR, constructor_index, bitsize_int (1));\n-\t      TREE_INT_CST_LOW (constructor_index) = TREE_INT_CST_LOW (tem);\n-\t      TREE_INT_CST_HIGH (constructor_index) = TREE_INT_CST_HIGH (tem);\n+\t      constructor_index\n+\t\t= size_binop (PLUS_EXPR, constructor_index, bitsize_int (1));\n \n-\t      if (!value)\n+\t      if (! value)\n \t\t/* If we are doing the bookkeeping for an element that was\n-\t\t   directly output as a constructor,\n-\t\t   we must update constructor_unfilled_index.  */\n-\t\t{\n-\t\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n-\t\t    = TREE_INT_CST_LOW (constructor_index);\n-\t\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n-\t\t    = TREE_INT_CST_HIGH (constructor_index);\n-\t\t}\n+\t\t   directly output as a constructor, we must update\n+\t\t   constructor_unfilled_index.  */\n+\t\tconstructor_unfilled_index = constructor_index;\n \t    }\n \t  while (! (constructor_range_end == 0\n \t\t    || tree_int_cst_lt (constructor_range_end,"}, {"sha": "9336309aa666e86aca1fa778b99de0721ea4a5d3", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -1,3 +1,19 @@\n+Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* typeck.c (min_precision): New function.\n+\t(build_chill_slice): Use host_integerp and tree_low_cst.\n+\t(expand_constant_to_buffer): Likewise and also int_bit_position.\n+\tLO is unsigned HOST_WIDE_INT\n+\t(build_chill_array_ref_1): Make `i' be HOST_WIDE_INT; use tree_low_cst.\n+\t(extract_constant_from_buffer): Sizes are now HOST_WIDE_INT.\n+\tUse host_integerp and tree_low_cst.\n+\t(build_chill_bin_type): Use host_integerp and tree_low_cst.\n+\t(layout_chill_range_type): Use tree_int_cst_sgn, compare_tree_int,\n+\ttree_low_cst, and min_precision.\n+\t(apply_chill_array_layout): Cleanups for types of variables\n+\tand use tree_int_cst_sgn, compare_tree_int, and tree_low_cst.\n+\t(apply_chill_field_layout): Likewise.\n+\n 2000-03-07  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* grant.c (globalize_decl): Constify a char*."}, {"sha": "9126ede3e3a7985aeb75a1d03128a2c6694e12ae", "filename": "gcc/ch/typeck.c", "status": "modified", "additions": 153, "deletions": 106, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -46,6 +46,7 @@ static tree extract_constant_from_buffer PARAMS ((tree, const unsigned char *, i\n static int expand_constant_to_buffer PARAMS ((tree, unsigned char *, int));\n static tree build_empty_string PARAMS ((tree));\n static tree make_chill_pointer_type PARAMS ((tree, enum tree_code));\n+static unsigned int min_precision PARAMS ((tree, int));\n static tree make_chill_range_type PARAMS ((tree, tree, tree));\n static void apply_chill_array_layout PARAMS ((tree));\n static int field_decl_cmp PARAMS ((tree *, tree*));\n@@ -243,13 +244,15 @@ build_chill_slice (array, min_value, length)\n \n       SET_CH_NOVELTY (slice_type, CH_NOVELTY (array_type));\n \n-      if (TREE_CONSTANT (array) && TREE_CODE (min_value) == INTEGER_CST\n-\t  && TREE_CODE (length) == INTEGER_CST)\n+      if (TREE_CONSTANT (array) && host_integerp (min_value, 0)\n+\t  && host_integerp (length, 0))\n \t{\n-\t  int type_size = int_size_in_bytes (array_type);\n-\t  unsigned char *buffer = (unsigned char*) alloca (type_size);\n-\t  int delta = int_size_in_bytes (element_type)\n-\t    * (TREE_INT_CST_LOW (min_value) - TREE_INT_CST_LOW (domain_min));\n+\t  unsigned HOST_WIDE_INT type_size = int_size_in_bytes (array_type);\n+\t  unsigned char *buffer = (unsigned char *) alloca (type_size);\n+\t  int delta = (int_size_in_bytes (element_type)\n+\t\t       * (tree_low_cst (min_value, 0)\n+\t\t\t  - tree_low_cst (domain_min, 0)));\n+\n \t  bzero (buffer, type_size);\n \t  if (expand_constant_to_buffer (array, buffer, type_size))\n \t    {\n@@ -626,13 +629,14 @@ build_chill_array_ref_1 (array, idx)\n       else if (TREE_CODE (array) == STRING_CST\n \t       && CH_CHARS_TYPE_P (TREE_TYPE (array)))\n \t{\n-\t  HOST_WIDE_INT i = TREE_INT_CST_LOW (idx);\n+\t  HOST_WIDE_INT i = tree_low_cst (idx, 0);\n+\n \t  if (i >= 0 && i < TREE_STRING_LENGTH (array))\n-\t    {\n-\t      char ch = TREE_STRING_POINTER (array) [i];\n-\t      return convert_to_class (class,\n-\t\t\t\t       build_int_2 ((unsigned char)ch, 0));\n-\t    }\n+\t    return\n+\t      convert_to_class\n+\t\t(class,\n+\t\t build_int_2\n+\t\t ((unsigned char) TREE_STRING_POINTER (array) [i], 0));\n \t}\n     }\n \n@@ -731,16 +735,18 @@ expand_constant_to_buffer (value, buffer, buf_size)\n     {\n     case INTEGER_CST:\n       {\n-\tHOST_WIDE_INT lo = TREE_INT_CST_LOW (value);\n+\tunsigned HOST_WIDE_INT lo = TREE_INT_CST_LOW (value);\n \tHOST_WIDE_INT hi = TREE_INT_CST_HIGH (value);\n \tfor (i = 0; i < size; i++)\n \t  {\n \t    /* Doesn't work if host and target BITS_PER_UNIT differ. */\n \t    unsigned char byte = lo & ((1 << BITS_PER_UNIT) - 1);\n+\n \t    if (BYTES_BIG_ENDIAN)\n \t      buffer[size - i - 1] = byte;\n \t    else\n \t      buffer[i] = byte;\n+\n \t    rshift_double (lo, hi, BITS_PER_UNIT, BITS_PER_UNIT * size,\n \t\t\t   &lo, &hi, 0);\n \t  }\n@@ -770,10 +776,10 @@ expand_constant_to_buffer (value, buffer, buf_size)\n \t      tree min_val = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n \t      if (min_val)\n \t\t{\n-\t\t  if (TREE_CODE (min_val) != INTEGER_CST)\n+\t\t  if (! host_integerp (min_val, 0))\n \t\t    return 0;\n \t\t  else\n-\t\t    min_index = TREE_INT_CST_LOW (min_val);\n+\t\t    min_index = tree_low_cst (min_val, 0);\n \t\t}\n \t    }\n \n@@ -784,14 +790,15 @@ expand_constant_to_buffer (value, buffer, buf_size)\n \t      HOST_WIDE_INT offset;\n \t      HOST_WIDE_INT last_index;\n \t      tree purpose = TREE_PURPOSE (list);\n+\n \t      if (purpose)\n \t\t{\n-\t\t  if (TREE_CODE (purpose) == INTEGER_CST)\n-\t\t    last_index = next_index = TREE_INT_CST_LOW (purpose);\n+\t\t  if (host_integerp (purpose, 0))\n+\t\t    last_index = next_index = tree_low_cst (purpose, 0);\n \t\t  else if (TREE_CODE (purpose) == RANGE_EXPR)\n \t\t    {\n-\t\t      next_index = TREE_INT_CST_LOW (TREE_OPERAND(purpose, 0));\n-\t\t      last_index = TREE_INT_CST_LOW (TREE_OPERAND(purpose, 1));\n+\t\t      next_index = tree_low_cst (TREE_OPERAND (purpose, 0), 0);\n+\t\t      last_index = tree_low_cst (TREE_OPERAND (purpose, 1), 0);\n \t\t    }\n \t\t  else\n \t\t    return 0;\n@@ -816,12 +823,14 @@ expand_constant_to_buffer (value, buffer, buf_size)\n \t    {\n \t      tree field = TREE_PURPOSE (list);\n \t      HOST_WIDE_INT offset;\n+\n \t      if (field == NULL_TREE || TREE_CODE (field) != FIELD_DECL)\n \t\treturn 0;\n+\n \t      if (DECL_BIT_FIELD (field))\n \t\treturn 0;\n-\t      offset = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n-\t\t/ BITS_PER_UNIT;\n+\n+\t      offset = int_bit_position (field) / BITS_PER_UNIT;\n \t      if (!expand_constant_to_buffer (TREE_VALUE (list),\n \t\t\t\t\t      buffer + offset,\n \t\t\t\t\t      buf_size - offset))\n@@ -854,10 +863,12 @@ extract_constant_from_buffer (type, buffer, buf_size)\n      int buf_size;\n {\n   tree value;\n-  int size = int_size_in_bytes (type);\n-  int i;\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+  HOST_WIDE_INT i;\n+\n   if (size < 0 || size > buf_size)\n     return 0;\n+\n   switch (TREE_CODE (type))\n     {\n     case INTEGER_TYPE:\n@@ -902,16 +913,18 @@ extract_constant_from_buffer (type, buffer, buf_size)\n \tvalue = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n \tif (value)\n \t  {\n-\t    if (TREE_CODE (value) != INTEGER_CST)\n+\t    if (! host_integerp (value, 0))\n \t      return 0;\n \t    else\n-\t      min_index = TREE_INT_CST_LOW (value);\n+\t      min_index = tree_low_cst (value, 0);\n \t  }\n+\n \tvalue = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\tif (value == NULL_TREE || TREE_CODE (value) != INTEGER_CST)\n+\tif (value == NULL_TREE || ! host_integerp (value, 0))\n \t  return 0;\n \telse\n-\t  max_index = TREE_INT_CST_LOW (value);\n+\t  max_index = tree_low_cst (value, 0);\n+\n \tfor (cur_index = max_index; cur_index >= min_index; cur_index--)\n \t  {\n \t    HOST_WIDE_INT offset = (cur_index - min_index) * element_size;\n@@ -933,8 +946,8 @@ extract_constant_from_buffer (type, buffer, buf_size)\n \ttree field = TYPE_FIELDS (type);\n \tfor (; field != NULL_TREE; field = TREE_CHAIN (field))\n \t  {\n-\t    HOST_WIDE_INT offset\n-\t      = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)) / BITS_PER_UNIT;\n+\t    HOST_WIDE_INT offset = int_bit_position (field) / BITS_PER_UNIT;\n+\n \t    if (DECL_BIT_FIELD (field))\n \t      return 0;\n \t    value = extract_constant_from_buffer (TREE_TYPE (field),\n@@ -953,7 +966,7 @@ extract_constant_from_buffer (type, buffer, buf_size)\n     case UNION_TYPE:\n       {\n \ttree longest_variant = NULL_TREE;\n-\tint longest_size = 0;\n+\tunsigned HOST_WIDE_INT longest_size = 0;\n \ttree field = TYPE_FIELDS (type);\n \t\n \t/* This is a kludge.  We assume that converting the data to te\n@@ -966,44 +979,55 @@ extract_constant_from_buffer (type, buffer, buf_size)\n \n \tfor (; field != NULL_TREE; field = TREE_CHAIN (field))\n \t  {\n-\t    int size = TREE_INT_CST_LOW (size_in_bytes (TREE_TYPE (field)));\n+\t    unsigned HOST_WIDE_INT size\n+\t      = int_size_in_bytes (TREE_TYPE (field));\n \t    \n \t    if (size > longest_size)\n \t      {\n \t\tlongest_size = size;\n \t\tlongest_variant = field;\n \t      }\n \t  }\n+\n \tif (longest_variant == NULL_TREE)\n \t  return NULL_TREE;\n-\treturn extract_constant_from_buffer (TREE_TYPE (longest_variant), buffer, buf_size);\n+\n+\treturn\n+\t  extract_constant_from_buffer (TREE_TYPE (longest_variant),\n+\t\t\t\t\tbuffer, buf_size);\n       }\n \n     case SET_TYPE:\n       {\n \ttree list = NULL_TREE;\n \tint i;\n \tHOST_WIDE_INT min_index, max_index;\n+\n \tif (TYPE_DOMAIN (type) == 0)\n \t  return 0;\n+\n \tvalue = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n \tif (value == NULL_TREE)\n \t  min_index = 0;\n-\telse if (TREE_CODE (value) != INTEGER_CST)\n+\n+\telse if (! host_integerp (value, 0))\n \t  return 0;\n \telse\n-\t  min_index = TREE_INT_CST_LOW (value);\n+\t  min_index = tree_low_cst (value, 0);\n+\n \tvalue = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n \tif (value == NULL_TREE)\n \t  max_index = 0;\n-\telse if (TREE_CODE (value) != INTEGER_CST)\n+\telse if (! host_integerp (value, 0))\n \t  return 0;\n \telse\n-\t  max_index = TREE_INT_CST_LOW (value);\n+\t  max_index = tree_low_cst (value, 0);\n+\n \tfor (i = max_index + 1 - min_index; --i >= 0; )\n \t  {\n-\t    unsigned char byte = (unsigned char)buffer[i / BITS_PER_UNIT];\n-\t    unsigned bit_pos = (unsigned)i % (unsigned)BITS_PER_UNIT;\n+\t    unsigned char byte = (unsigned char) buffer[i / BITS_PER_UNIT];\n+\t    unsigned bit_pos = (unsigned) i % (unsigned) BITS_PER_UNIT;\n+\n \t    if (BYTES_BIG_ENDIAN\n \t\t? (byte & (1 << (BITS_PER_UNIT - 1 - bit_pos)))\n \t\t: (byte & (1 << bit_pos)))\n@@ -1241,14 +1265,16 @@ build_chill_bin_type (size)\n      tree size;\n {\n #if 0\n-  int isize;\n+  HOST_WIDE_INT isize;\n \n-  if (TREE_CODE (size) != INTEGER_CST\n-      || (isize = TREE_INT_CST_LOW (size), isize <= 0))\n+  if (! host_integerp (size, 1))\n     {\n       error (\"operand to bin must be a non-negative integer literal\");\n       return error_mark_node;\n     }\n+\n+  isize = tree_low_cst (size, 1);\n+\n   if (isize <= TYPE_PRECISION (unsigned_char_type_node))\n     return unsigned_char_type_node;\n   if (isize <= TYPE_PRECISION (short_unsigned_type_node))\n@@ -2500,6 +2526,36 @@ make_chill_range_type (type, lowval, highval)\n   return itype;\n }\n \n+\f\n+/* Return the minimum number of bits needed to represent VALUE in a\n+   signed or unsigned type, UNSIGNEDP says which.  */\n+\n+static unsigned int\n+min_precision (value, unsignedp)\n+     tree value;\n+     int unsignedp;\n+{\n+  int log;\n+\n+  /* If the value is negative, compute its negative minus 1.  The latter\n+     adjustment is because the absolute value of the largest negative value\n+     is one larger than the largest positive value.  This is equivalent to\n+     a bit-wise negation, so use that operation instead.  */\n+\n+  if (tree_int_cst_sgn (value) < 0)\n+    value = fold (build1 (BIT_NOT_EXPR, TREE_TYPE (value), value));\n+\n+  /* Return the number of bits needed, taking into account the fact\n+     that we need one more bit for a signed than unsigned type.  */\n+\n+  if (integer_zerop (value))\n+    log = 0;\n+  else\n+    log = tree_floor_log2 (value);\n+\n+  return log + 1 + ! unsignedp;\n+}\n+\n tree\n layout_chill_range_type (rangetype, must_be_const)\n      tree rangetype;\n@@ -2518,30 +2574,31 @@ layout_chill_range_type (rangetype, must_be_const)\n     {\n       int binsize;\n       \n-      /* make a range out of it */\n+      /* Make a range out of it */\n       if (TREE_CODE (highval) != INTEGER_CST)\n \t{\n \t  error (\"non-constant expression for BIN\");\n \t  return error_mark_node;\n \t}\n-      binsize = TREE_INT_CST_LOW (highval);\n-      if (binsize < 0)\n+      else if (tree_int_cst_sgn (highval) < 0)\n \t{\n \t  error (\"expression for BIN must not be negative\");\n \t  return error_mark_node;\n \t}\n-      if (binsize > 32)\n+      else if (compare_tree_int (highval, 32) > 0)\n \t{\n \t  error (\"cannot process BIN (>32)\");\n \t  return error_mark_node;\n \t}\n+\n+      binsize = tree_low_cst (highval, 1);\n       type = ridpointers [(int) RID_RANGE];\n       lowval = integer_zero_node;\n       highval = build_int_2 ((1 << binsize) - 1, 0);\n     }\n  \n-  if (TREE_CODE (lowval) == ERROR_MARK ||\n-      TREE_CODE (highval) == ERROR_MARK)\n+  if (TREE_CODE (lowval) == ERROR_MARK\n+      || TREE_CODE (highval) == ERROR_MARK)\n     return error_mark_node;\n \n   if (!CH_COMPATIBLE_CLASSES (lowval, highval))\n@@ -2578,37 +2635,14 @@ layout_chill_range_type (rangetype, must_be_const)\n \t  && TREE_CODE (lowval) == INTEGER_CST\n \t  && TREE_CODE (highval) == INTEGER_CST)\n \t{\n-\t  /* The logic of this code has been copied from finish_enum\n-\t     in c-decl.c.  FIXME duplication! */\n-\t  int precision = 0;\n-\t  HOST_WIDE_INT maxvalue = TREE_INT_CST_LOW (highval);\n-\t  HOST_WIDE_INT minvalue = TREE_INT_CST_LOW (lowval);\n-\t  if (TREE_INT_CST_HIGH (lowval) >= 0\n-\t      ? tree_int_cst_lt (TYPE_MAX_VALUE (unsigned_type_node), highval)\n-\t      : (tree_int_cst_lt (lowval, TYPE_MIN_VALUE (integer_type_node))\n-\t\t || tree_int_cst_lt (TYPE_MAX_VALUE (integer_type_node), highval)))\n-\t    precision = TYPE_PRECISION (long_long_integer_type_node);\n-\t  else\n-\t    {\n-\t      if (maxvalue > 0)\n-\t\tprecision = floor_log2 (maxvalue) + 1;\n-\t      if (minvalue < 0)\n-\t\t{\n-\t\t  /* Compute number of bits to represent magnitude of a\n-\t\t     negative value.  Add one to MINVALUE since range of\n-\t\t     negative numbers includes the power of two.  */\n-\t\t  int negprecision = floor_log2 (-minvalue - 1) + 1;\n-\t\t  if (negprecision > precision)\n-\t\t    precision = negprecision;\n-\t\t  precision += 1;\t/* room for sign bit */\n-\t\t}\n+\t  int unsignedp = tree_int_cst_sgn (lowval) >= 0;\n+\t  unsigned int precision = MAX (min_precision (highval, unsignedp),\n+\t\t\t\t\tmin_precision (lowval, unsignedp));\n \n-\t      if (!precision)\n-\t\tprecision = 1;\n-\t    }\n-\t  type = type_for_size (precision, minvalue >= 0);\n+\t  type = type_for_size (precision, unsignedp);\n \n \t}\n+\n       TREE_TYPE (rangetype) = type;\n     }\n   else\n@@ -2736,7 +2770,9 @@ apply_chill_array_layout (array_type)\n      tree array_type;\n {\n   tree layout, temp, what, element_type;\n-  int stepsize=0, word, start_bit=0, length, natural_length;\n+  HOST_WIDE_INT stepsize = 0;\n+  HOST_WIDE_INT word, start_bit = 0, length;\n+  HOST_WIDE_INT natural_length;\n   int stepsize_specified;\n   int start_bit_error = 0;\n   int length_error = 0;\n@@ -2757,8 +2793,10 @@ apply_chill_array_layout (array_type)\n       && get_type_precision (TYPE_MIN_VALUE (element_type),\n \t\t\t     TYPE_MAX_VALUE (element_type)) == 1)\n     natural_length = 1;\n+  else if (host_integerp (TYPE_SIZE (element_type), 1))\n+    natural_length = tree_low_cst (TYPE_SIZE (element_type), 1);\n   else\n-    natural_length = TREE_INT_CST_LOW (TYPE_SIZE (element_type));\n+    natural_length = -1;\n \n   if (layout == integer_one_node) /* PACK */\n     {\n@@ -2774,55 +2812,58 @@ apply_chill_array_layout (array_type)\n   temp = TREE_VALUE (layout);\n   if (TREE_VALUE (temp) != NULL_TREE)\n     {\n-      if (TREE_CODE (TREE_VALUE (temp)) != INTEGER_CST)\n+      if (! host_integerp (TREE_VALUE (temp), 0))\n \terror (\"Stepsize in STEP must be an integer constant\");\n       else\n \t{\n-\t  stepsize = TREE_INT_CST_LOW (TREE_VALUE (temp));\n-\t  if (stepsize <= 0)\n+\t  if (tree_int_cst_sgn (TREE_VALUE (temp)) <= 0)\n \t    error (\"Stepsize in STEP must be > 0\");\n \t  else\n \t    stepsize_specified = 1;\n \n+\t  stepsize = tree_low_cst (TREE_VALUE (temp), 1);\n \t  if (stepsize != natural_length)\n \t    sorry (\"Stepsize in STEP must be the natural width of the array element mode\");\n \t}\n     }\n \n   temp = TREE_PURPOSE (temp);\n-  if (TREE_CODE (TREE_PURPOSE (temp)) != INTEGER_CST)\n+  if (! host_integerp (TREE_PURPOSE (temp), 0))\n     error (\"Starting word in POS must be an integer constant\");\n   else\n     {\n-      word = TREE_INT_CST_LOW (TREE_PURPOSE (temp));\n-      if (word < 0)\n+      if (tree_int_cst_sgn (TREE_PURPOSE (temp)) < 0)\n \terror (\"Starting word in POS must be >= 0\");\n-      if (word != 0)\n+      if (! integer_zerop (TREE_PURPOSE (temp)))\n \tsorry (\"Starting word in POS within STEP must be 0\");\n+\n+      word = tree_low_cst (TREE_PURPOSE (temp), 0);\n     }\n \n   length = natural_length;\n   temp = TREE_VALUE (temp);\n   if (temp != NULL_TREE)\n     {\n       int wordsize = TYPE_PRECISION (chill_integer_type_node);\n-      if (TREE_CODE (TREE_PURPOSE (temp)) != INTEGER_CST)\n+      if (! host_integerp (TREE_PURPOSE (temp), 0))\n \t{\n \t  error (\"Starting bit in POS must be an integer constant\");\n \t  start_bit_error = 1;\n \t}\n       else\n \t{\n-\t  start_bit = TREE_INT_CST_LOW (TREE_PURPOSE (temp));\n-\t  if (start_bit != 0)\n+\t  if (! integer_zerop (TREE_PURPOSE (temp)))\n \t    sorry (\"Starting bit in POS within STEP must be 0\");\n-\t  if (start_bit < 0)\n+\n+\t  if (tree_int_cst_sgn (TREE_PURPOSE (temp)) < 0)\n \t    {\n \t      error (\"Starting bit in POS must be >= 0\");\n \t      start_bit = 0;\n \t      start_bit_error = 1;\n \t    }\n-\t  else if (start_bit >= wordsize)\n+\t  \n+\t  start_bit = tree_low_cst (TREE_PURPOSE (temp), 0);\n+\t  if (start_bit >= wordsize)\n \t    {\n \t      error (\"Starting bit in POS must be < the width of a word\");\n \t      start_bit = 0;\n@@ -2836,28 +2877,29 @@ apply_chill_array_layout (array_type)\n \t  what = TREE_PURPOSE (temp);\n \t  if (what == integer_zero_node)\n \t    {\n-\t      if (TREE_CODE (TREE_VALUE (temp)) != INTEGER_CST)\n+\t      if (! host_integerp (TREE_VALUE (temp), 0))\n \t\t{\n \t\t  error (\"Length in POS must be an integer constant\");\n \t\t  length_error = 1;\n \t\t}\n \t      else\n \t\t{\n-\t\t  length = TREE_INT_CST_LOW (TREE_VALUE (temp));\n+\t\t  length = tree_low_cst (TREE_VALUE (temp), 0);\n \t\t  if (length <= 0)\n \t\t    error (\"Length in POS must be > 0\");\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      if (TREE_CODE (TREE_VALUE (temp)) != INTEGER_CST)\n+\t      if (! host_integerp (TREE_VALUE (temp), 0))\n \t\t{\n \t\t  error (\"End bit in POS must be an integer constant\");\n \t\t  length_error = 1;\n \t\t}\n \t      else\n \t\t{\n-\t\t  int end_bit = TREE_INT_CST_LOW (TREE_VALUE (temp));\n+\t\t  HOST_WIDE_INT end_bit = tree_low_cst (TREE_VALUE (temp), 0);\n+\n \t\t  if (end_bit < start_bit)\n \t\t    {\n \t\t      error (\"End bit in POS must be >= the start bit\");\n@@ -2876,10 +2918,9 @@ apply_chill_array_layout (array_type)\n \t\t    length = end_bit - start_bit + 1;\n \t\t}\n \t    }\n+\n \t  if (! length_error && length != natural_length)\n-\t    {\n-\t      sorry (\"The length specified on POS within STEP must be the natural length of the array element type\");\n-\t    }\n+\t    sorry (\"The length specified on POS within STEP must be the natural length of the array element type\");\n \t}\n     }\n \n@@ -3053,8 +3094,10 @@ apply_chill_field_layout (decl, next_struct_offset)\n   if (is_discrete)\n     natural_length\n       = get_type_precision (TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type));\n+  else if (host_integerp (TYPE_SIZE (type), 1))\n+    natural_length = tree_low_cst (TYPE_SIZE (type), 1);\n   else\n-    natural_length = TREE_INT_CST_LOW (TYPE_SIZE (type));\n+    natural_length = -1;\n \n   if (layout == integer_zero_node) /* NOPACK */\n     {\n@@ -3082,20 +3125,21 @@ apply_chill_field_layout (decl, next_struct_offset)\n      natural width of the underlying type. */\n   temp = TREE_PURPOSE (layout);\n \n-  if (TREE_CODE (TREE_PURPOSE (temp)) != INTEGER_CST)\n+  if (! host_integerp (TREE_PURPOSE (temp), 0))\n     {\n       error (\"Starting word in POS must be an integer constant\");\n       pos_error = 1;\n     }\n   else\n     {\n-      word = TREE_INT_CST_LOW (TREE_PURPOSE (temp));\n       if (tree_int_cst_sgn (TREE_PURPOSE (temp)) < 0)\n \t{\n \t  error (\"Starting word in POS must be >= 0\");\n \t  word = 0;\n \t  pos_error = 1;\n \t}\n+      else\n+\tword = tree_low_cst (TREE_PURPOSE (temp), 0);\n     }\n \n   wordsize = TYPE_PRECISION (chill_integer_type_node);\n@@ -3105,22 +3149,23 @@ apply_chill_field_layout (decl, next_struct_offset)\n   temp = TREE_VALUE (temp);\n   if (temp != NULL_TREE)\n     {\n-      if (TREE_CODE (TREE_PURPOSE (temp)) != INTEGER_CST)\n+      if (! host_integerp (TREE_PURPOSE (temp), 0))\n \t{\n \t  error (\"Starting bit in POS must be an integer constant\");\n \t  start_bit = *next_struct_offset - offset;\n \t  pos_error = 1;\n \t}\n       else\n \t{\n-\t  start_bit = TREE_INT_CST_LOW (TREE_PURPOSE (temp));\n \t  if (tree_int_cst_sgn (TREE_PURPOSE (temp)) < 0)\n \t    {\n \t      error (\"Starting bit in POS must be >= 0\");\n \t      start_bit = *next_struct_offset - offset;\n \t      pos_error = 1;\n \t    }\n-\t  else if (start_bit >= wordsize)\n+\n+\t  start_bit = tree_low_cst (TREE_PURPOSE (temp), 0);\n+\t  if (start_bit >= wordsize)\n \t    {\n \t      error (\"Starting bit in POS must be < the width of a word\");\n \t      start_bit = *next_struct_offset - offset;\n@@ -3134,32 +3179,34 @@ apply_chill_field_layout (decl, next_struct_offset)\n \t  what = TREE_PURPOSE (temp);\n \t  if (what == integer_zero_node)\n \t    {\n-\t      if (TREE_CODE (TREE_VALUE (temp)) != INTEGER_CST)\n+\t      if (! host_integerp (TREE_VALUE (temp), 0))\n \t\t{\n \t\t  error (\"Length in POS must be an integer constant\");\n \t\t  pos_error = 1;\n \t\t}\n \t      else\n \t\t{\n-\t\t  length = TREE_INT_CST_LOW (TREE_VALUE (temp));\n \t\t  if (tree_int_cst_sgn (TREE_VALUE (temp)) < 0)\n \t\t    {\n \t\t      error (\"Length in POS must be > 0\");\n \t\t      length = natural_length;\n \t\t      pos_error = 1;\n \t\t    }\n+\t\t  else\n+\t\t    length = tree_low_cst (TREE_VALUE (temp), 0);\n+\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      if (TREE_CODE (TREE_VALUE (temp)) != INTEGER_CST)\n+\t      if (! host_integerp (TREE_VALUE (temp), 0))\n \t\t{\n \t\t  error (\"End bit in POS must be an integer constant\");\n \t\t  pos_error = 1;\n \t\t}\n \t      else\n \t\t{\n-\t\t  HOST_WIDE_INT end_bit = TREE_INT_CST_LOW (TREE_VALUE (temp));\n+\t\t  HOST_WIDE_INT end_bit = tree_low_cst (TREE_VALUE (temp), 0);\n \n \t\t  if (end_bit < start_bit)\n \t\t    {"}, {"sha": "45453b52e4836b021c190eb378f9a3f15251e856", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -1,3 +1,28 @@\n+Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* class.c (build_vbase_path): Use integer_zerop.\n+\t(build_vtable_entry): Use tree_low_cst.\n+\t(get_vfield_offset): Use bit_position.\n+\t(dfs_modify_vtables): New variable vindex_val; `i' is HOST_WIDE_INT.\n+\tUse tree_low_cst.\n+\t(check_bitfield_decl): Set DECL_SIZE using convert.\n+\t(build_base_field): Set DECL_SIZE and DECL_SIZE_UNIT using size_binop.\n+\t(layout_virtual_bases): DSIZE is unsigned HOST_WIDE_INT.\n+\tUse tree_low_cst.\n+\t(finish_struct_1): Use bit_position.\n+\t(dump_class_hierarchy): Use tree_low_cst.\n+\t* cp-tree.h (min_precision): Add declaration.\n+\t* decl.c (xref_tag, xref_basetypes): Use tree_low_cst.\n+\t* error.c (dump_type_suffix): Use host_integerp and tree_low_cst.\n+\t(dump_expr): Use integer_zerop, host_integerp, and tree_low_cst.\n+\t* expr.c (cplus_expand_constant): Use bit_position.\n+\t* init.c (build_vec_init): Use host_integerp and tree_low_cst.\n+\t* rtti.c (get_base_offset): Use bit_position.\n+\t* typeck.c (build_binary_op): Use integer_zerop, compare_tree_int,\n+\thost_integerp, and tree_low_cst.\n+\t(pointer_int_sum): Use integer_zerop.\n+\t(build_component_addr): Use bit_position.\n+\t\n 2000-03-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* typeck.c (require_complete_type): Don't assume size_zero_node."}, {"sha": "2540f274869ed2588e5a50993b363e951176c786", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -635,7 +635,7 @@ build_vbase_path (code, type, expr, path, nonnull)\n   else\n     offset = BINFO_OFFSET (last);\n \n-  if (TREE_INT_CST_LOW (offset))\n+  if (! integer_zerop (offset))\n     {\n       /* Bash types to make the backend happy.  */\n       offset = cp_convert (type, offset);\n@@ -691,8 +691,8 @@ build_vtable_entry (delta, vcall_index, entry)\n       HOST_WIDE_INT idelta;\n       HOST_WIDE_INT ivindex;\n \n-      idelta = TREE_INT_CST_LOW (delta);\n-      ivindex = TREE_INT_CST_LOW (vcall_index);\n+      idelta = tree_low_cst (delta, 0);\n+      ivindex = tree_low_cst (vcall_index, 0);\n       if ((idelta || ivindex) \n \t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (entry, 0)))\n \t{\n@@ -908,7 +908,7 @@ get_vfield_offset (binfo)\n {\n   tree tmp\n     = size_binop (FLOOR_DIV_EXPR,\n-\t\t  DECL_FIELD_BITPOS (TYPE_VFIELD (BINFO_TYPE (binfo))),\n+\t\t  bit_position (TYPE_VFIELD (BINFO_TYPE (binfo))),\n \t\t  bitsize_int (BITS_PER_UNIT));\n \n   return size_binop (PLUS_EXPR, convert (sizetype, tmp),\n@@ -3111,7 +3111,8 @@ dfs_modify_vtables (binfo, data)\n \t  tree overrider;\n \t  tree vindex;\n \t  tree delta;\n-\t  unsigned HOST_WIDE_INT i;\n+\t  HOST_WIDE_INT vindex_val, i;\n+\n \n \t  /* Find the function which originally caused this vtable\n \t     entry to be present.  */\n@@ -3121,7 +3122,8 @@ dfs_modify_vtables (binfo, data)\n \t  fn = skip_rtti_stuff (TYPE_BINFO (BINFO_TYPE (b)),\n \t\t\t\tBINFO_TYPE (b),\n \t\t\t\t&i);\n-\t  while (i < TREE_INT_CST_LOW (vindex))\n+\t  vindex_val = tree_low_cst (vindex, 0);\n+\t  while (i < vindex_val)\n \t    {\n \t      fn = TREE_CHAIN (fn);\n \t      ++i;\n@@ -3685,7 +3687,7 @@ check_bitfield_decl (field)\n       if (DECL_INITIAL (field))\n \t{\n \t  DECL_INITIAL (field) = NULL_TREE;\n-\t  DECL_SIZE (field) = bitsize_int (TREE_INT_CST_LOW (w));\n+\t  DECL_SIZE (field) = convert (bitsizetype, w);\n \t  DECL_BIT_FIELD (field) = 1;\n \n \t  if (integer_zerop (w))\n@@ -4268,12 +4270,10 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n \t here.  */\n       *base_align = MAX (*base_align, DECL_ALIGN (decl));\n       DECL_SIZE (decl)\n-\t= size_int (MAX ((HOST_WIDE_INT) TREE_INT_CST_LOW (DECL_SIZE (decl)),\n-\t\t\t (int) (*base_align)));\n+\t= size_binop (MAX_EXPR, DECL_SIZE (decl), bitsize_int (*base_align));\n       DECL_SIZE_UNIT (decl)\n-\t= size_int (MAX (((HOST_WIDE_INT) TREE_INT_CST_LOW\n-\t\t\t  (DECL_SIZE_UNIT (decl))),\n-\t\t\t (int) *base_align / BITS_PER_UNIT));\n+\t= size_binop (MAX_EXPR, DECL_SIZE_UNIT (decl),\n+\t\t      size_int (*base_align / BITS_PER_UNIT));\n     }\n \n   if (!integer_zerop (DECL_SIZE (decl)))\n@@ -4768,10 +4768,11 @@ layout_virtual_bases (t)\n      tree t;\n {\n   tree vbase;\n-  int dsize;\n+  unsigned HOST_WIDE_INT dsize;\n \n   /* DSIZE is the size of the class without the virtual bases.  */\n-  dsize = TREE_INT_CST_LOW (TYPE_SIZE (t));\n+  dsize = tree_low_cst (TYPE_SIZE (t), 1);\n+\n   /* Make every class have alignment of at least one.  */\n   TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), BITS_PER_UNIT);\n \n@@ -4800,7 +4801,7 @@ layout_virtual_bases (t)\n \t/* Every virtual baseclass takes a least a UNIT, so that we can\n \t   take it's address and get something different for each base.  */\n \tdsize += MAX (BITS_PER_UNIT,\n-\t\t      TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n+\t\t      tree_low_cst (CLASSTYPE_SIZE (basetype), 0));\n       }\n \n   /* Make sure that all of the CLASSTYPE_VBASECLASSES have their\n@@ -5038,7 +5039,7 @@ layout_class_type (t, empty_p, has_virtual_p,\n    For C++, we must handle the building of derived classes.\n    Also, C++ allows static class members.  The way that this is\n    handled is to keep the field name where it is (as the DECL_NAME\n-   of the field), and place the overloaded decl in the DECL_FIELD_BITPOS\n+   of the field), and place the overloaded decl in the bit position\n    of the field.  layout_record and layout_union will know about this.\n \n    More C++ hair: inline functions have text in their\n@@ -5124,7 +5125,7 @@ finish_struct_1 (t)\n \n       DECL_FIELD_CONTEXT (vfield) = t;\n       DECL_FIELD_BITPOS (vfield)\n-\t= size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));\n+\t= size_binop (PLUS_EXPR, offset, bit_position (vfield));\n       TYPE_VFIELD (t) = vfield;\n     }\n \n@@ -6538,7 +6539,7 @@ dump_class_hierarchy (binfo, indent)\n \t   (unsigned long) binfo,\n \t   type_as_string (binfo, TS_PLAIN));\n   fprintf (stderr, HOST_WIDE_INT_PRINT_DEC,\n-\t   TREE_INT_CST_LOW (BINFO_OFFSET (binfo)));\n+\t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n   fprintf (stderr, \" %s\\n\",\n \t   BINFO_PRIMARY_MARKED_P (binfo) ? \"primary\" : \"\");\n "}, {"sha": "fd87926fd03f057522940c630089c70ea562380b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -3116,6 +3116,7 @@ extern tree convert_and_check\t\t\tPARAMS ((tree, tree));\n extern void overflow_warning\t\t\tPARAMS ((tree));\n extern void unsigned_conversion_warning\t\tPARAMS ((tree, tree));\n extern void c_apply_type_quals_to_decl          PARAMS ((int, tree));\n+extern unsigned int min_precision\t\tPARAMS ((tree, int));\n \n /* Read the rest of the current #-directive line.  */\n #if USE_CPPLIB"}, {"sha": "5a4a5121c7889d320ff6783acace57bbeea8c45e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -12350,7 +12350,7 @@ xref_tag (code_type_node, name, globalize)\n       code_type_node = TREE_VALUE (code_type_node);\n     }\n \n-  tag_code = (enum tag_types) TREE_INT_CST_LOW (code_type_node);\n+  tag_code = (enum tag_types) tree_low_cst (code_type_node, 1);\n   switch (tag_code)\n     {\n     case record_type:\n@@ -12578,7 +12578,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n   tree base;\n \n   int i, len;\n-  enum tag_types tag_code = (enum tag_types) TREE_INT_CST_LOW (code_type_node);\n+  enum tag_types tag_code = (enum tag_types) tree_low_cst (code_type_node, 1);\n \n   if (tag_code == union_type)\n     {"}, {"sha": "e5a087221b33387b2b307966ff88afffb63ab295", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -721,8 +721,8 @@ dump_type_suffix (t, flags)\n       OB_PUTC ('[');\n       if (TYPE_DOMAIN (t))\n \t{\n-\t  if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == INTEGER_CST)\n-\t    OB_PUTI (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) + 1);\n+\t  if (host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0))\n+\t    OB_PUTI (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0) + 1);\n \t  else if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (t))) == MINUS_EXPR)\n \t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0),\n \t               flags & ~TS_EXPR_PARENS);\n@@ -1477,17 +1477,15 @@ dump_expr (t, flags)\n \t  }\n \telse if (type == boolean_type_node)\n \t  {\n-\t    if (t == boolean_false_node\n-\t\t|| (TREE_INT_CST_LOW (t) == 0\n-\t\t    && TREE_INT_CST_HIGH (t) == 0))\n+\t    if (t == boolean_false_node || integer_zerop (t))\n \t      OB_PUTS (\"false\");\n \t    else if (t == boolean_true_node)\n \t      OB_PUTS (\"true\");\n \t  }\n \telse if (type == char_type_node)\n \t  {\n \t    OB_PUTC ('\\'');\n-\t    dump_char (TREE_INT_CST_LOW (t));\n+\t    dump_char (tree_low_cst (t, 0));\n \t    OB_PUTC ('\\'');\n \t  }\n \telse if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (t)\n@@ -1851,8 +1849,7 @@ dump_expr (t, flags)\n \t      OB_PUTS (\") 0)\");\n \t      break;\n \t    }\n-\t  else if (TREE_CODE (idx) == INTEGER_CST\n-\t\t   && TREE_INT_CST_HIGH (idx) == 0)\n+\t  else if (host_integerp (idx, 0))\n \t    {\n \t      tree virtuals;\n \t      unsigned HOST_WIDE_INT n;\n@@ -1861,7 +1858,7 @@ dump_expr (t, flags)\n \t      t = TYPE_METHOD_BASETYPE (t);\n \t      virtuals = TYPE_BINFO_VIRTUALS (TYPE_MAIN_VARIANT (t));\n \t      \n-\t      n = TREE_INT_CST_LOW (idx);\n+\t      n = tree_low_cst (idx, 0);\n \n \t      /* Map vtable index back one, to allow for the null pointer to\n \t\t member.  */"}, {"sha": "e97a65d55e8f3e121b89a1798d204606a395b7c3", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -62,7 +62,7 @@ cplus_expand_constant (cst)\n \t    /* Find the offset for the field.  */\n \t    offset = convert (sizetype,\n \t\t\t      size_binop (EASY_DIV_EXPR,\n-\t\t\t\t\t  DECL_FIELD_BITPOS (member),\n+\t\t\t\t\t  bit_position (member),\n \t\t\t\t\t  bitsize_int (BITS_PER_UNIT)));\n \n \t    /* We offset all pointer to data members by 1 so that we"}, {"sha": "960f46b0ac3def934ed90b3a5345dbb172a0a7e4", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -2872,9 +2872,9 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \n   if (from_array\n       || (TYPE_NEEDS_CONSTRUCTING (type)\n-\t  && ! (TREE_CODE (maxindex) == INTEGER_CST\n+\t  && ! (host_integerp (maxindex, 0)\n \t\t&& (num_initialized_elts\n-\t\t    == (HOST_WIDE_INT) TREE_INT_CST_LOW (maxindex) + 1))))\n+\t\t    == tree_low_cst (maxindex, 0) + 1))))\n     {\n       /* If the ITERATOR is equal to -1, then we don't have to loop;\n \t we've already initialized all the elements.  */"}, {"sha": "f06174c4ded5336fd59f4e66289581b7f333693f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -524,8 +524,7 @@ get_base_offset (binfo, parent)\n     \n       FORMAT_VBASE_NAME (name, t);\n       field = lookup_field (parent, get_identifier (name), 0, 0);\n-      offset = size_binop (FLOOR_DIV_EXPR, \n-    \t\t           DECL_FIELD_BITPOS (field), \n+      offset = size_binop (FLOOR_DIV_EXPR, bit_position (field), \n     \t\t           bitsize_int (BITS_PER_UNIT));\n       offset = convert (sizetype, offset);\n     }"}, {"sha": "a92c1febfcf78c6122c93c89e3131bdd6b9f7343", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -3512,11 +3512,9 @@ build_binary_op (code, orig_op0, orig_op1)\n \t\twarning (\"right shift count is negative\");\n \t      else\n \t\t{\n-\t\t  if (TREE_INT_CST_LOW (op1) | TREE_INT_CST_HIGH (op1))\n+\t\t  if (! integer_zerop (op1))\n \t\t    short_shift = 1;\n-\t\t  if (TREE_INT_CST_HIGH (op1) != 0\n-\t\t      || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n-\t\t\t  >= TYPE_PRECISION (type0)))\n+\t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\t    warning (\"right shift count >= width of type\");\n \t\t}\n \t    }\n@@ -3537,9 +3535,7 @@ build_binary_op (code, orig_op0, orig_op1)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n \t\twarning (\"left shift count is negative\");\n-\t      else if (TREE_INT_CST_HIGH (op1) != 0\n-\t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n-\t\t\t   >= TYPE_PRECISION (type0)))\n+\t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\twarning (\"left shift count >= width of type\");\n \t    }\n \t  /* Convert the shift-count to an integer, regardless of\n@@ -3561,9 +3557,7 @@ build_binary_op (code, orig_op0, orig_op1)\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n \t\twarning (\"%s rotate count is negative\",\n \t\t\t (code == LROTATE_EXPR) ? \"left\" : \"right\");\n-\t      else if (TREE_INT_CST_HIGH (op1) != 0\n-\t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n-\t\t\t   >= TYPE_PRECISION (type0)))\n+\t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\twarning (\"%s rotate count >= width of type\",\n \t\t\t (code == LROTATE_EXPR) ? \"left\" : \"right\");\n \t    }\n@@ -3894,8 +3888,7 @@ build_binary_op (code, orig_op0, orig_op1)\n \t  if (TYPE_PRECISION (TREE_TYPE (arg0)) < TYPE_PRECISION (result_type)\n \t      /* We can shorten only if the shift count is less than the\n \t\t number of bits in the smaller type size.  */\n-\t      && TREE_INT_CST_HIGH (op1) == 0\n-\t      && TYPE_PRECISION (TREE_TYPE (arg0)) > TREE_INT_CST_LOW (op1)\n+\t      && compare_tree_int (op1, TYPE_PRECISION (TREE_TYPE (arg0))) < 0\n \t      /* If arg is sign-extended and then unsigned-shifted,\n \t\t we can simulate this with a signed shift in arg's type\n \t\t only if the extended result is at least twice as wide\n@@ -4009,25 +4002,24 @@ build_binary_op (code, orig_op0, orig_op1)\n \t      if (TREE_CODE (primop1) == BIT_NOT_EXPR)\n \t\tprimop1 = get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);\n \t      \n-\t      if (TREE_CODE (primop0) == INTEGER_CST\n-\t\t  || TREE_CODE (primop1) == INTEGER_CST)\n+\t      if (host_integerp (primop0, 0) || host_integerp (primop1, 0))\n \t\t{\n \t\t  tree primop;\n \t\t  HOST_WIDE_INT constant, mask;\n \t\t  int unsignedp;\n-\t\t  unsigned bits;\n+\t\t  unsigned int bits;\n \n-\t\t  if (TREE_CODE (primop0) == INTEGER_CST)\n+\t\t  if (host_integerp (primop0, 0))\n \t\t    {\n \t\t      primop = primop1;\n \t\t      unsignedp = unsignedp1;\n-\t\t      constant = TREE_INT_CST_LOW (primop0);\n+\t\t      constant = tree_low_cst (primop0, 0);\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      primop = primop0;\n \t\t      unsignedp = unsignedp0;\n-\t\t      constant = TREE_INT_CST_LOW (primop1);\n+\t\t      constant = tree_low_cst (primop1, 0);\n \t\t    }\n \n \t\t  bits = TYPE_PRECISION (TREE_TYPE (primop));\n@@ -4157,9 +4149,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n \n   /* Needed to make OOPS V2R3 work.  */\n   intop = folded;\n-  if (TREE_CODE (intop) == INTEGER_CST\n-      && TREE_INT_CST_LOW (intop) == 0\n-      && TREE_INT_CST_HIGH (intop) == 0)\n+  if (integer_zerop (intop))\n     return ptrop;\n \n   /* If what we are about to multiply by the size of the elements\n@@ -4295,11 +4285,12 @@ build_component_addr (arg, argtype)\n     /* This conversion is harmless.  */\n     rval = convert_force (argtype, rval, 0);\n \n-  if (! integer_zerop (DECL_FIELD_BITPOS (field)))\n+  if (! integer_zerop (bit_position (field)))\n     {\n-      tree offset = size_binop (EASY_DIV_EXPR, DECL_FIELD_BITPOS (field),\n+      tree offset = size_binop (EASY_DIV_EXPR, bit_position (field),\n \t\t\t\tbitsize_int (BITS_PER_UNIT));\n       int flag = TREE_CONSTANT (rval);\n+\n       offset = convert (sizetype, offset);\n       rval = fold (build (PLUS_EXPR, argtype,\n \t\t\t  rval, cp_convert (argtype, offset)));"}, {"sha": "2d43dbb8e6d5db21a762507ecd69aa8175d73759", "filename": "gcc/dbxout.c", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -623,29 +623,28 @@ dbxout_type_fields (type)\n      tree type;\n {\n   tree tem;\n+\n   /* Output the name, type, position (in bits), size (in bits) of each\n-     field.  */\n+     field that we can support.  */\n   for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n     {\n       /* Omit here local type decls until we know how to support them.  */\n-      if (TREE_CODE (tem) == TYPE_DECL)\n-\tcontinue;\n-      /* Omit fields whose position or size are variable.  */\n-      else if (TREE_CODE (tem) == FIELD_DECL\n-\t       && (TREE_CODE (DECL_FIELD_BITPOS (tem)) != INTEGER_CST\n-\t\t   || TREE_CODE (DECL_SIZE (tem)) != INTEGER_CST))\n-\tcontinue;\n-      /* Omit here the nameless fields that are used to skip bits.  */\n-      else if (DECL_IGNORED_P (tem))\n+      if (TREE_CODE (tem) == TYPE_DECL\n+\t  /* Omit fields whose position or size are variable or too large to\n+\t     represent.  */\n+\t  || (TREE_CODE (tem) == FIELD_DECL\n+\t      && (! host_integerp (bit_position (tem), 0)\n+\t\t  || ! host_integerp (DECL_SIZE (tem), 1)))\n+\t  /* Omit here the nameless fields that are used to skip bits.  */\n+\t   || DECL_IGNORED_P (tem))\n \tcontinue;\n+\n       else if (TREE_CODE (tem) != CONST_DECL)\n \t{\n \t  /* Continue the line if necessary,\n \t     but not before the first field.  */\n \t  if (tem != TYPE_FIELDS (type))\n-\t    {\n-\t      CONTIN;\n-\t    }\n+\t    CONTIN;\n \n \t  if (use_gnu_debug_info_extensions\n \t      && flag_minimal_debug\n@@ -661,7 +660,7 @@ dbxout_type_fields (type)\n \t      dbxout_type (TREE_TYPE (tem), 0, 0);\n \t      fputc (',', asmfile);\n \t      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t       TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)));\n+\t\t       int_bit_position (tem));\n \t      fputc (';', asmfile);\n \t      continue;\n \t    }\n@@ -691,8 +690,7 @@ dbxout_type_fields (type)\n \n \t  dbxout_type ((TREE_CODE (tem) == FIELD_DECL\n \t\t\t&& DECL_BIT_FIELD_TYPE (tem))\n-\t\t       ? DECL_BIT_FIELD_TYPE (tem)\n-\t\t       : TREE_TYPE (tem), 0, 0);\n+\t\t       ? DECL_BIT_FIELD_TYPE (tem) : TREE_TYPE (tem), 0, 0);\n \n \t  if (TREE_CODE (tem) == VAR_DECL)\n \t    {\n@@ -705,22 +703,20 @@ dbxout_type_fields (type)\n \t\t  CHARS (strlen (name));\n \t\t}\n \t      else\n-\t\t{\n-\t\t  /* If TEM is non-static, GDB won't understand it.  */\n-\t\t  fprintf (asmfile, \",0,0;\");\n-\t\t}\n+\t\t/* If TEM is non-static, GDB won't understand it.  */\n+\t\tfprintf (asmfile, \",0,0;\");\n \t    }\n-\t  else if (TREE_CODE (DECL_FIELD_BITPOS (tem)) == INTEGER_CST)\n+\t  else\n \t    {\n \t      fputc (',', asmfile);\n \t      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t       TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)));\n+\t\t       int_bit_position (tem));\n \t      fputc (',', asmfile);\n \t      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t       TREE_INT_CST_LOW (DECL_SIZE (tem)));\n+\t\t       tree_low_cst (DECL_SIZE (tem), 1));\n \t      fputc (';', asmfile);\n+\t      CHARS (23);\n \t    }\n-\t  CHARS (23);\n \t}\n     }\n }\n@@ -758,13 +754,15 @@ dbxout_type_method_1 (decl, debug_name)\n     }\n \n   fprintf (asmfile, \":%s;%c%c%c\", debug_name,\n-\t   TREE_PRIVATE (decl) ? '0' : TREE_PROTECTED (decl) ? '1' : '2', c1, c2);\n+\t   TREE_PRIVATE (decl) ? '0'\n+\t   : TREE_PROTECTED (decl) ? '1' : '2', c1, c2);\n   CHARS (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl)) + 6\n \t - (debug_name - IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))));\n-  if (DECL_VINDEX (decl))\n+\n+  if (DECL_VINDEX (decl) && host_integerp (DECL_VINDEX (decl), 0))\n     {\n       fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t       TREE_INT_CST_LOW (DECL_VINDEX (decl)));\n+\t       tree_low_cst (DECL_VINDEX (decl), 0));\n       fputc (';', asmfile);\n       dbxout_type (DECL_CONTEXT (decl), 0, 0);\n       fprintf (asmfile, \";\");\n@@ -959,20 +957,23 @@ dbxout_range_type (type)\n       else\n \tdbxout_type_index (integer_type_node);\n     }\n-  if (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n+\n+  if (TYPE_MIN_VALUE (type) != 0\n+      && host_integerp (TYPE_MIN_VALUE (type), 0))\n     {\n       fputc (';', asmfile);\n       fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t       TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)));\n+\t       tree_low_cst (TYPE_MIN_VALUE (type), 0));\n     }\n   else\n     fprintf (asmfile, \";0\");\n-  if (TYPE_MAX_VALUE (type) \n-      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST)\n+\n+  if (TYPE_MAX_VALUE (type) != 0\n+      && host_integerp (TYPE_MAX_VALUE (type), 0))\n     {\n       fputc (';', asmfile);\n       fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t       TREE_INT_CST_LOW (TYPE_MAX_VALUE (type)));\n+\t       tree_low_cst (TYPE_MAX_VALUE (type), 0));\n       fputc (';', asmfile);\n     }\n   else\n@@ -1407,17 +1408,15 @@ dbxout_type (type, full, show_arg_types)\n \tfor (i = 0; i < n_baseclasses; i++)\n \t  {\n \t    tree child = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), i);\n+\n \t    if (use_gnu_debug_info_extensions)\n \t      {\n \t\thave_used_extensions = 1;\n-\t\tputc (TREE_VIA_VIRTUAL (child) ? '1'\n-\t\t      : '0',\n-\t\t      asmfile);\n-\t\tputc (TREE_VIA_PUBLIC (child) ? '2'\n-\t\t      : '0',\n-\t\t      asmfile);\n+\t\tputc (TREE_VIA_VIRTUAL (child) ? '1' : '0', asmfile);\n+\t\tputc (TREE_VIA_PUBLIC (child) ? '2' : '0', asmfile);\n \t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t TREE_INT_CST_LOW (BINFO_OFFSET (child)) * BITS_PER_UNIT);\n+\t\t\t (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t  * BITS_PER_UNIT));\n \t\tfputc (',', asmfile);\n \t\tCHARS (15);\n \t\tdbxout_type (BINFO_TYPE (child), 0, 0);\n@@ -1432,10 +1431,13 @@ dbxout_type (type, full, show_arg_types)\n \t\tdbxout_type (BINFO_TYPE (child), full, 0);\n \t\tfputc (',', asmfile);\n \t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t TREE_INT_CST_LOW (BINFO_OFFSET (child)) * BITS_PER_UNIT);\n+\t\t\t tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t * BITS_PER_UNIT);\n \t\tfputc (',', asmfile);\n \t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t TREE_INT_CST_LOW (DECL_SIZE (TYPE_NAME (BINFO_TYPE (child)))) * BITS_PER_UNIT);\n+\t\t\t (tree_low_cst (DECL_SIZE (TYPE_NAME\n+\t\t\t\t\t\t  (BINFO_TYPE (child))), 0)\n+\t\t\t  * BITS_PER_UNIT));\n \t\tfputc (';', asmfile);\n \t\tCHARS (20);\n \t      }\n@@ -1451,6 +1453,7 @@ dbxout_type (type, full, show_arg_types)\n \t  have_used_extensions = 1;\n \t  dbxout_type_methods (type);\n \t}\n+\n       putc (';', asmfile);\n \n       if (use_gnu_debug_info_extensions && TREE_CODE (type) == RECORD_TYPE\n@@ -1615,7 +1618,7 @@ print_int_cst_octal (c)\n   unsigned HOST_WIDE_INT high = TREE_INT_CST_HIGH (c);\n   unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (c);\n   int excess = (3 - (HOST_BITS_PER_WIDE_INT % 3));\n-  int width = TYPE_PRECISION (TREE_TYPE (c));\n+  unsigned int width = TYPE_PRECISION (TREE_TYPE (c));\n \n   /* GDB wants constants with no extra leading \"1\" bits, so\n      we need to remove any sign-extension that might be\n@@ -1928,6 +1931,7 @@ dbxout_symbol (decl, local)\n \t and not written in memory, inform the debugger.  */\n       if (TREE_STATIC (decl) && TREE_READONLY (decl)\n \t  && DECL_INITIAL (decl) != 0\n+\t  && host_integerp (DECL_INITIAL (decl), 0)\n \t  && ! TREE_ASM_WRITTEN (decl)\n \t  && (DECL_FIELD_CONTEXT (decl) == NULL_TREE\n \t      || TREE_CODE (DECL_FIELD_CONTEXT (decl)) == BLOCK))\n@@ -1936,10 +1940,11 @@ dbxout_symbol (decl, local)\n \t    {\n \t      /* The sun4 assembler does not grok this.  */\n \t      const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+\n \t      if (TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n \t\t{\n-\t\t  HOST_WIDE_INT ival = TREE_INT_CST_LOW (DECL_INITIAL (decl));\n+\t\t  HOST_WIDE_INT ival = tree_low_cst (DECL_INITIAL (decl), 0);\n #ifdef DBX_OUTPUT_CONSTANT_SYMBOL\n \t\t  DBX_OUTPUT_CONSTANT_SYMBOL (asmfile, name, ival);\n #else"}, {"sha": "9fedb94f6636c4837599ce93cd8af4e323b6f6fe", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -2470,11 +2470,11 @@ static int is_based_loc\t\t\tPARAMS ((rtx));\n static dw_loc_descr_ref mem_loc_descriptor PARAMS ((rtx, enum machine_mode mode));\n static dw_loc_descr_ref concat_loc_descriptor PARAMS ((rtx, rtx));\n static dw_loc_descr_ref loc_descriptor\tPARAMS ((rtx));\n-static unsigned ceiling\t\t\tPARAMS ((unsigned, unsigned));\n+static HOST_WIDE_INT ceiling\t\tPARAMS ((HOST_WIDE_INT, unsigned int));\n static tree field_type\t\t\tPARAMS ((tree));\n-static unsigned simple_type_align_in_bits PARAMS ((tree));\n-static unsigned simple_type_size_in_bits PARAMS ((tree));\n-static unsigned field_byte_offset\tPARAMS ((tree));\n+static unsigned int simple_type_align_in_bits PARAMS ((tree));\n+static unsigned HOST_WIDE_INT simple_type_size_in_bits PARAMS ((tree));\n+static HOST_WIDE_INT field_byte_offset\tPARAMS ((tree));\n static void add_AT_location_description\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute, rtx));\n static void add_data_member_location_attribute PARAMS ((dw_die_ref, tree));\n@@ -6471,13 +6471,13 @@ loc_descriptor (rtl)\n   return loc_result;\n }\n \n-/* Given an unsigned value, round it up to the lowest multiple of `boundary'\n+/* Given a value, round it up to the lowest multiple of `boundary'\n    which is not less than the value itself.  */\n \n-static inline unsigned\n+static inline HOST_WIDE_INT\n ceiling (value, boundary)\n-     register unsigned value;\n-     register unsigned boundary;\n+     HOST_WIDE_INT value;\n+     unsigned int boundary;\n {\n   return (((value + boundary - 1) / boundary) * boundary);\n }\n@@ -6521,7 +6521,7 @@ simple_type_align_in_bits (type)\n    else return BITS_PER_WORD if the type actually turns out to be an\n    ERROR_MARK node.  */\n \n-static inline unsigned\n+static inline unsigned HOST_WIDE_INT\n simple_type_size_in_bits (type)\n      register tree type;\n {\n@@ -6531,10 +6531,10 @@ simple_type_size_in_bits (type)\n     {\n       register tree type_size_tree = TYPE_SIZE (type);\n \n-      if (TREE_CODE (type_size_tree) != INTEGER_CST)\n+      if (! host_integerp (type_size_tree, 1))\n \treturn TYPE_ALIGN (type);\n \n-      return (unsigned) TREE_INT_CST_LOW (type_size_tree);\n+      return tree_low_cst (type_size_tree, 1);\n     }\n }\n \n@@ -6545,22 +6545,21 @@ simple_type_size_in_bits (type)\n    be a pointer to an ERROR_MARK node, or because the offset is actually\n    variable.  (We can't handle the latter case just yet).  */\n \n-static unsigned\n+static HOST_WIDE_INT\n field_byte_offset (decl)\n      register tree decl;\n {\n-  register unsigned type_align_in_bytes;\n-  register unsigned type_align_in_bits;\n-  register unsigned type_size_in_bits;\n-  register unsigned object_offset_in_align_units;\n-  register unsigned object_offset_in_bits;\n-  register unsigned object_offset_in_bytes;\n-  register tree type;\n-  register tree bitpos_tree;\n-  register tree field_size_tree;\n-  register unsigned bitpos_int;\n-  register unsigned deepest_bitpos;\n-  register unsigned field_size_in_bits;\n+  unsigned int type_align_in_bytes;\n+  unsigned int type_align_in_bits;\n+  unsigned HOST_WIDE_INT type_size_in_bits;\n+  HOST_WIDE_INT object_offset_in_align_units;\n+  HOST_WIDE_INT object_offset_in_bits;\n+  HOST_WIDE_INT object_offset_in_bytes;\n+  tree type;\n+  tree field_size_tree;\n+  HOST_WIDE_INT bitpos_int;\n+  HOST_WIDE_INT deepest_bitpos;\n+  unsigned HOST_WIDE_INT field_size_in_bits;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n@@ -6569,29 +6568,28 @@ field_byte_offset (decl)\n     abort ();\n \n   type = field_type (decl);\n-\n-  bitpos_tree = DECL_FIELD_BITPOS (decl);\n   field_size_tree = DECL_SIZE (decl);\n \n   /* If there was an error, the size could be zero.  */\n   if (! field_size_tree)\n     {\n       if (errorcount)\n \treturn 0;\n+\n       abort ();\n     }\n \n   /* We cannot yet cope with fields whose positions are variable, so \n      for now, when we see such things, we simply return 0.  Someday, we may\n      be able to handle such cases, but it will be damn difficult.  */\n-  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n+  if (! host_integerp (bit_position (decl), 0))\n     return 0;\n \n-  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n+  bitpos_int = int_bit_position (decl);\n \n     /* If we don't know the size of the field, pretend it's a full word.  */\n-  if (TREE_CODE (field_size_tree) == INTEGER_CST)\n-    field_size_in_bits = (unsigned) TREE_INT_CST_LOW (field_size_tree);\n+  if (host_integerp (field_size_tree, 1))\n+    field_size_in_bits = tree_low_cst (field_size_tree, 1);\n   else\n     field_size_in_bits = BITS_PER_WORD;\n \n@@ -6727,7 +6725,7 @@ add_data_member_location_attribute (die, decl)\n   register enum dwarf_location_atom op;\n \n   if (TREE_CODE (decl) == TREE_VEC)\n-    offset = TREE_INT_CST_LOW (BINFO_OFFSET (decl));\n+    offset = tree_low_cst (BINFO_OFFSET (decl), 0);\n   else\n     offset = field_byte_offset (decl);\n \n@@ -7063,8 +7061,6 @@ add_bound_info (subrange_die, bound_attr, bound)\n      register enum dwarf_attribute bound_attr;\n      register tree bound;\n {\n-  register unsigned bound_value = 0;\n-\n   /* If this is an Ada unconstrained array type, then don't emit any debug\n      info because the array bounds are unknown.  They are parameterized when\n      the type is instantiated.  */\n@@ -7078,13 +7074,14 @@ add_bound_info (subrange_die, bound_attr, bound)\n \n     /* All fixed-bounds are represented by INTEGER_CST nodes.        */\n     case INTEGER_CST:\n-      bound_value = TREE_INT_CST_LOW (bound);\n-      if (bound_attr == DW_AT_lower_bound\n-\t  && ((is_c_family () && bound_value == 0)\n-\t      || (is_fortran () && bound_value == 1)))\n-\t/* use the default */;\n+      if (! host_integerp (bound, 0)\n+\t  || (bound_attr == DW_AT_lower_bound\n+\t      && ((is_c_family () && integer_zerop (bound))\n+\t\t  || (is_fortran () && integer_onep (bound)))))\n+\t/* use the default */\n+\t;\n       else\n-\tadd_AT_unsigned (subrange_die, bound_attr, bound_value);\n+\tadd_AT_unsigned (subrange_die, bound_attr, tree_low_cst (bound, 0));\n       break;\n \n     case CONVERT_EXPR:\n@@ -7297,13 +7294,12 @@ add_bit_offset_attribute (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  register unsigned object_offset_in_bytes = field_byte_offset (decl);\n-  register tree type = DECL_BIT_FIELD_TYPE (decl);\n-  register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n-  register unsigned bitpos_int;\n-  register unsigned highest_order_object_bit_offset;\n-  register unsigned highest_order_field_bit_offset;\n-  register unsigned bit_offset;\n+  HOST_WIDE_INT object_offset_in_bytes = field_byte_offset (decl);\n+  tree type = DECL_BIT_FIELD_TYPE (decl);\n+  HOST_WIDE_INT bitpos_int;\n+  HOST_WIDE_INT highest_order_object_bit_offset;\n+  HOST_WIDE_INT highest_order_field_bit_offset;\n+  HOST_WIDE_INT unsigned bit_offset;\n \n   /* Must be a field and a bit field.  */\n   if (!type\n@@ -7312,11 +7308,12 @@ add_bit_offset_attribute (die, decl)\n \n   /* We can't yet handle bit-fields whose offsets are variable, so if we\n      encounter such things, just return without generating any attribute\n-     whatsoever.  */\n-  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n+     whatsoever.  Likewise for variable or too large size.  */\n+  if (! host_integerp (bit_position (decl), 0)\n+      || ! host_integerp (DECL_SIZE (decl), 1))\n     return;\n \n-  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n+  bitpos_int = int_bit_position (decl);\n \n   /* Note that the bit offset is always the distance (in bits) from the\n      highest-order bit of the \"containing object\" to the highest-order bit of \n@@ -7328,9 +7325,7 @@ add_bit_offset_attribute (die, decl)\n \n   if (! BYTES_BIG_ENDIAN)\n     {\n-      highest_order_field_bit_offset\n-\t+= (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n-\n+      highest_order_field_bit_offset += tree_low_cst (DECL_SIZE (decl), 0);\n       highest_order_object_bit_offset += simple_type_size_in_bits (type);\n     }\n \n@@ -7354,8 +7349,9 @@ add_bit_size_attribute (die, decl)\n   if (TREE_CODE (decl) != FIELD_DECL\n       || ! DECL_BIT_FIELD_TYPE (decl))\n     abort ();\n-  add_AT_unsigned (die, DW_AT_bit_size,\n-\t\t   (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl)));\n+\n+  if (host_integerp (DECL_SIZE (decl), 1))\n+    add_AT_unsigned (die, DW_AT_bit_size, tree_low_cst (DECL_SIZE (decl), 1));\n }\n \n /* If the compiled language is ANSI C, then add a 'prototyped'\n@@ -7420,10 +7416,12 @@ add_pure_or_virtual_attribute (die, func_decl)\n   if (DECL_VINDEX (func_decl))\n     {\n       add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n-      add_AT_loc (die, DW_AT_vtable_elem_location,\n-\t\t  new_loc_descr (DW_OP_constu,\n-\t\t\t\t TREE_INT_CST_LOW (DECL_VINDEX (func_decl)),\n-\t\t\t\t 0));\n+\n+      if (host_integerp (DECL_VINDEX (func_decl), 0))\n+\tadd_AT_loc (die, DW_AT_vtable_elem_location,\n+\t\t    new_loc_descr (DW_OP_constu,\n+\t\t\t\t   tree_low_cst (DECL_VINDEX (func_decl), 0),\n+\t\t\t\t   0));\n \n       /* GNU extension: Record what type this method came from originally.  */\n       if (debug_info_level > DINFO_LEVEL_TERSE)\n@@ -7914,8 +7912,10 @@ gen_enumeration_type_die (type, context_die)\n \n \t  add_name_attribute (enum_die,\n \t\t\t      IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n-\t  add_AT_unsigned (enum_die, DW_AT_const_value,\n-\t\t\t   (unsigned) TREE_INT_CST_LOW (TREE_VALUE (link)));\n+\n+\t  if (host_integerp (TREE_VALUE (link), 0))\n+\t    add_AT_unsigned (enum_die, DW_AT_const_value,\n+\t\t\t     tree_low_cst (TREE_VALUE (link), 0));\n \t}\n     }\n   else"}, {"sha": "eab7bf54fc989f5e15e542e23330e634cae84791", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 59, "deletions": 60, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -331,11 +331,11 @@ static void output_mem_loc_descriptor\tPARAMS ((rtx));\n static void output_loc_descriptor\tPARAMS ((rtx));\n static void output_bound_representation\tPARAMS ((tree, unsigned, int));\n static void output_enumeral_list\tPARAMS ((tree));\n-static inline unsigned ceiling\t\tPARAMS ((unsigned, unsigned));\n+static inline HOST_WIDE_INT ceiling\tPARAMS ((HOST_WIDE_INT, unsigned int));\n static inline tree field_type\t\tPARAMS ((tree));\n-static inline unsigned simple_type_align_in_bits PARAMS ((tree));\n-static inline unsigned simple_type_size_in_bits  PARAMS ((tree));\n-static unsigned field_byte_offset\tPARAMS ((tree));\n+static inline unsigned int simple_type_align_in_bits PARAMS ((tree));\n+static inline unsigned HOST_WIDE_INT simple_type_size_in_bits  PARAMS ((tree));\n+static HOST_WIDE_INT field_byte_offset\tPARAMS ((tree));\n static inline void sibling_attribute\tPARAMS ((void));\n static void location_attribute\t\tPARAMS ((rtx));\n static void data_member_location_attribute PARAMS ((tree));\n@@ -1806,8 +1806,8 @@ output_bound_representation (bound, dim_num, u_or_l)\n       /* All fixed-bounds are represented by INTEGER_CST nodes.\t */\n \n     case INTEGER_CST:\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t      (unsigned) TREE_INT_CST_LOW (bound));\n+      if (host_integerp (bound, 0))\n+\tASM_OUTPUT_DWARF_DATA4 (asm_out_file, tree_low_cst (bound, 0));\n       break;\n \n     default:\n@@ -1881,8 +1881,11 @@ output_enumeral_list (link)\n   if (link)\n     {\n       output_enumeral_list (TREE_CHAIN (link));\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t      (unsigned) TREE_INT_CST_LOW (TREE_VALUE (link)));\n+\n+      if (host_integerp (TREE_VALUE (link), 0))\n+\tASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n+\t\t\t\ttree_low_cst (TREE_VALUE (link), 0));\n+\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file,\n \t\t\t       IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n     }\n@@ -1891,10 +1894,10 @@ output_enumeral_list (link)\n /* Given an unsigned value, round it up to the lowest multiple of `boundary'\n    which is not less than the value itself.  */\n \n-static inline unsigned\n+static inline HOST_WIDE_INT\n ceiling (value, boundary)\n-     register unsigned value;\n-     register unsigned boundary;\n+     register HOST_WIDE_INT value;\n+     register unsigned int boundary;\n {\n   return (((value + boundary - 1) / boundary) * boundary);\n }\n@@ -1922,7 +1925,7 @@ field_type (decl)\n    node, return the alignment in bits for the type, or else return\n    BITS_PER_WORD if the node actually turns out to be an ERROR_MARK node.  */\n \n-static inline unsigned\n+static inline unsigned int\n simple_type_align_in_bits (type)\n      register tree type;\n {\n@@ -1935,7 +1938,7 @@ simple_type_align_in_bits (type)\n    constant, or else return BITS_PER_WORD if the type actually turns out\n    to be an ERROR_MARK node.  */\n \n-static inline unsigned\n+static inline unsigned HOST_WIDE_INT\n simple_type_size_in_bits (type)\n      register tree type;\n {\n@@ -1945,10 +1948,10 @@ simple_type_size_in_bits (type)\n     {\n       register tree type_size_tree = TYPE_SIZE (type);\n \n-      if (TREE_CODE (type_size_tree) != INTEGER_CST)\n+      if (! host_integerp (type_size_tree, 1))\n \treturn TYPE_ALIGN (type);\n \n-      return (unsigned) TREE_INT_CST_LOW (type_size_tree);\n+      return tree_low_cst (type_size_tree, 1);\n     }\n }\n \n@@ -1959,22 +1962,21 @@ simple_type_size_in_bits (type)\n    pointer to an ERROR_MARK node, or because the offset is actually variable.\n    (We can't handle the latter case just yet.)  */\n \n-static unsigned\n+static HOST_WIDE_INT\n field_byte_offset (decl)\n      register tree decl;\n {\n-  register unsigned type_align_in_bytes;\n-  register unsigned type_align_in_bits;\n-  register unsigned type_size_in_bits;\n-  register unsigned object_offset_in_align_units;\n-  register unsigned object_offset_in_bits;\n-  register unsigned object_offset_in_bytes;\n-  register tree type;\n-  register tree bitpos_tree;\n-  register tree field_size_tree;\n-  register unsigned bitpos_int;\n-  register unsigned deepest_bitpos;\n-  register unsigned field_size_in_bits;\n+  unsigned int type_align_in_bytes;\n+  unsigned int type_align_in_bits;\n+  unsigned HOST_WIDE_INT type_size_in_bits;\n+  HOST_WIDE_INT object_offset_in_align_units;\n+  HOST_WIDE_INT object_offset_in_bits;\n+  HOST_WIDE_INT object_offset_in_bytes;\n+  tree type;\n+  tree field_size_tree;\n+  HOST_WIDE_INT bitpos_int;\n+  HOST_WIDE_INT deepest_bitpos;\n+  unsigned HOST_WIDE_INT field_size_in_bits;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n@@ -1983,33 +1985,29 @@ field_byte_offset (decl)\n     abort ();\n \n   type = field_type (decl);\n-\n-  bitpos_tree = DECL_FIELD_BITPOS (decl);\n   field_size_tree = DECL_SIZE (decl);\n \n   /* If there was an error, the size could be zero.  */\n   if (! field_size_tree)\n     {\n       if (errorcount)\n \treturn 0;\n+\n       abort ();\n     }\n     \n-\n   /* We cannot yet cope with fields whose positions or sizes are variable,\n      so for now, when we see such things, we simply return 0.  Someday,\n      we may be able to handle such cases, but it will be damn difficult.  */\n \n-  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n+  if (! host_integerp (bit_position (decl), 0)\n+      || ! host_integerp (field_size_tree, 1))\n     return 0;\n-  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n \n-  if (TREE_CODE (field_size_tree) != INTEGER_CST)\n-    return 0;\n-  field_size_in_bits = (unsigned) TREE_INT_CST_LOW (field_size_tree);\n+  bitpos_int = int_bit_position (decl);\n+  field_size_in_bits = tree_low_cst (field_size_tree, 1);\n \n   type_size_in_bits = simple_type_size_in_bits (type);\n-\n   type_align_in_bits = simple_type_align_in_bits (type);\n   type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;\n \n@@ -2058,8 +2056,7 @@ field_byte_offset (decl)\n \n      The value we deduce is then used (by the callers of this routine) to\n      generate AT_location and AT_bit_offset attributes for fields (both\n-     bit-fields and, in the case of AT_location, regular fields as well).\n-  */\n+     bit-fields and, in the case of AT_location, regular fields as well). */\n \n   /* Figure out the bit-distance from the start of the structure to the\n      \"deepest\" bit of the bit-field.  */\n@@ -2201,7 +2198,7 @@ data_member_location_attribute (t)\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n   if (TREE_CODE (t) == TREE_VEC)\n-    object_offset_in_bytes = TREE_INT_CST_LOW (BINFO_OFFSET (t));\n+    object_offset_in_bytes = tree_low_cst (BINFO_OFFSET (t), 0);\n   else\n     object_offset_in_bytes = field_byte_offset (t);\n \n@@ -2258,8 +2255,8 @@ const_value_attribute (rtl)\n \t   simplicity we always just output CONST_DOUBLEs using 8 bytes.  */\n \n \tASM_OUTPUT_DWARF_DATA8 (asm_out_file,\n-\t\t\t\t(unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (rtl),\n-\t\t\t\t(unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (rtl));\n+\t\t\t\t(unsigned int) CONST_DOUBLE_HIGH (rtl),\n+\t\t\t\t(unsigned int) CONST_DOUBLE_LOW (rtl));\n \tbreak;\n \n       case CONST_STRING:\n@@ -2715,26 +2712,27 @@ static inline void\n bit_offset_attribute (decl)\n     register tree decl;\n {\n-  register unsigned object_offset_in_bytes = field_byte_offset (decl);\n-  register tree type = DECL_BIT_FIELD_TYPE (decl);\n-  register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n-  register unsigned bitpos_int;\n-  register unsigned highest_order_object_bit_offset;\n-  register unsigned highest_order_field_bit_offset;\n-  register unsigned bit_offset;\n+  HOST_WIDE_INT object_offset_in_bytes = field_byte_offset (decl);\n+  tree type = DECL_BIT_FIELD_TYPE (decl);\n+  HOST_WIDE_INT bitpos_int;\n+  HOST_WIDE_INT highest_order_object_bit_offset;\n+  HOST_WIDE_INT highest_order_field_bit_offset;\n+  HOST_WIDE_INT bit_offset;\n \n   /* Must be a bit field.  */\n   if (!type\n       || TREE_CODE (decl) != FIELD_DECL)\n     abort ();\n \n-  /* We can't yet handle bit-fields whose offsets are variable, so if we\n-     encounter such things, just return without generating any attribute\n-     whatsoever.  */\n+  /* We can't yet handle bit-fields whose offsets or sizes are variable, so\n+     if we encounter such things, just return without generating any\n+     attribute whatsoever.  */\n \n-  if (TREE_CODE (bitpos_tree) != INTEGER_CST)\n+  if (! host_integerp (bit_position (decl), 0)\n+      || ! host_integerp (DECL_SIZE (decl), 1))\n     return;\n-  bitpos_int = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n+\n+  bitpos_int = int_bit_position (decl);\n \n   /* Note that the bit offset is always the distance (in bits) from the\n      highest-order bit of the \"containing object\" to the highest-order\n@@ -2747,9 +2745,7 @@ bit_offset_attribute (decl)\n \n   if (! BYTES_BIG_ENDIAN)\n     {\n-      highest_order_field_bit_offset\n-\t+= (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n-\n+      highest_order_field_bit_offset += tree_low_cst (DECL_SIZE (decl), 1);\n       highest_order_object_bit_offset += simple_type_size_in_bits (type);\n     }\n \n@@ -2774,9 +2770,12 @@ bit_size_attribute (decl)\n       || ! DECL_BIT_FIELD_TYPE (decl))\n     abort ();\n \n-  ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_bit_size);\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t  (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl)));\n+  if (host_integerp (DECL_SIZE (decl), 1))\n+    {\n+      ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_bit_size);\n+      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n+\t\t\t      tree_low_cst (DECL_SIZE (decl), 1));\n+    }\n }\n \n /* The following routine outputs the `element_list' attribute for enumeration"}, {"sha": "4e09199beddaf8267d25f84b87e362e956b47533", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -6530,7 +6530,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t\tif (TREE_CODE (init) == CONSTRUCTOR)\n \t\t  {\n-\t\t    tree elem = CONSTRUCTOR_ELTS (init);\n+\t\t    tree elem;\n \n \t\t    for (elem = CONSTRUCTOR_ELTS (init);\n \t\t\t (elem"}, {"sha": "d581da2adad1b55b8a6e1e0e1056beccd14cec9c", "filename": "gcc/genoutput.c", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -103,8 +103,8 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-static int n_occurrences PARAMS ((int, const char *));\n-static void strip_whitespace PARAMS ((char *));\n+static int n_occurrences\t\tPARAMS ((int, const char *));\n+static const char *strip_whitespace\tPARAMS ((const char *));\n \n /* insns in the machine description are assigned sequential code numbers\n    that are used by insn-recog.c (produced by genrecog) to communicate\n@@ -438,13 +438,9 @@ scan_operands (d, part, this_address_p, this_strict_low)\n       d->operand[opno].mode = GET_MODE (part);\n       d->operand[opno].strict_low = this_strict_low;\n       d->operand[opno].predicate = XSTR (part, 1);\n-      d->operand[opno].constraint = XSTR (part, 2);\n-      if (XSTR (part, 2) != NULL && *XSTR (part, 2) != 0)\n-\t{\n-\t  strip_whitespace (XSTR (part, 2));\n-\t  d->operand[opno].n_alternatives\n-\t    = n_occurrences (',', XSTR (part, 2)) + 1;\n-\t}\n+      d->operand[opno].constraint = strip_whitespace (XSTR (part, 2));\n+      d->operand[opno].n_alternatives\n+\t= n_occurrences (',', d->operand[opno].constraint) + 1;\n       d->operand[opno].address_p = this_address_p;\n       d->operand[opno].eliminable = 1;\n       return;\n@@ -466,13 +462,9 @@ scan_operands (d, part, this_address_p, this_strict_low)\n       d->operand[opno].mode = GET_MODE (part);\n       d->operand[opno].strict_low = 0;\n       d->operand[opno].predicate = \"scratch_operand\";\n-      d->operand[opno].constraint = XSTR (part, 1);\n-      if (XSTR (part, 1) != NULL && *XSTR (part, 1) != 0)\n-\t{\n-\t  strip_whitespace (XSTR (part, 1));\n-\t  d->operand[opno].n_alternatives\n-\t    = n_occurrences (',', XSTR (part, 1)) + 1;\n-\t}\n+      d->operand[opno].constraint = strip_whitespace (XSTR (part, 1));\n+      d->operand[opno].n_alternatives\n+\t= n_occurrences (',', d->operand[opno].constraint) + 1;\n       d->operand[opno].address_p = 0;\n       d->operand[opno].eliminable = 0;\n       return;\n@@ -965,28 +957,43 @@ main (argc, argv)\n \t? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n }\n \n+/* Return the number of occurrences of character C in string S or\n+   -1 if S is the null string.  */\n+\n static int\n n_occurrences (c, s)\n      int c;\n      const char *s;\n {\n   int n = 0;\n+\n+  if (s == 0 || *s == '\\0')\n+    return -1;\n+\n   while (*s)\n     n += (*s++ == c);\n+\n   return n;\n }\n \n-/* Remove whitespace in `s' by moving up characters until the end.  */\n-static void\n+/* Remove whitespace in `s' by moving up characters until the end.\n+   Return a new string.  */\n+\n+static const char *\n strip_whitespace (s)\n-     char *s;\n+     const char *s;\n {\n-  char *p = s;\n-  int ch;\n+  char *p, *q;\n+  char ch;\n+\n+  if (s == 0)\n+    return 0;\n \n+  p = q = xmalloc (strlen (s) + 1);\n   while ((ch = *s++) != '\\0')\n     if (! ISSPACE (ch))\n       *p++ = ch;\n \n   *p = '\\0';\n+  return q;\n }"}, {"sha": "5d58d88b68b1b94075f877d70941acdc009b2c1c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -1,3 +1,13 @@\n+Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* class.c (make_field_value): Properly handle sizes.\n+\t(get_dispatch_vector): Use tree_low_cst and host_integerp.\n+\t(layout_class_method): Count using trees.\n+\t* decl.c (push_promoted_type): Set TYPE_{MIN,MAX}_VALUE with copy_node.\n+\t* expr.c (java_array_data_offset): Use int_bit_position.\n+\t(build_newarray, build_anewarray): Use host_integerp and tree_low_cst.\n+\t(build_invokevirtual): Use tree_low_cst and do computations with trees.\n+\t\n 2000-03-16  Tom Tromey  <tromey@cygnus.com>\n \n \t* lang.c (flag_hash_synchronization): New global."}, {"sha": "1332639290e6ddaf845da14420051c43c6f748ce", "filename": "gcc/java/class.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -1073,9 +1073,10 @@ make_field_value (fdecl)\n   tree fdecl;\n {\n   tree finit, info;\n-  int bsize, flags;\n+  int flags;\n   tree type = TREE_TYPE (fdecl);\n   int resolved = is_compiled_class (type);\n+\n   START_RECORD_CONSTRUCTOR (finit, field_type_node);\n   PUSH_FIELD_VALUE (finit, \"name\", build_utf8_ref (DECL_NAME (fdecl)));\n   if (resolved)\n@@ -1091,24 +1092,24 @@ make_field_value (fdecl)\n   flags = get_access_flags_from_decl (fdecl);\n   if (! resolved)\n     flags |= 0x8000 /* FIELD_UNRESOLVED_FLAG */;\n+\n   PUSH_FIELD_VALUE (finit, \"accflags\", build_int_2 (flags, 0));\n-  bsize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (fdecl))) / BITS_PER_UNIT;\n-  PUSH_FIELD_VALUE (finit, \"bsize\", build_int_2 (bsize, 0));\n+  PUSH_FIELD_VALUE (finit, \"bsize\", TYPE_SIZE_UNIT (TREE_TYPE (fdecl)));\n   if (FIELD_STATIC (fdecl))\n     {\n-      tree cfield = TREE_CHAIN (TYPE_FIELDS(field_info_union_node));\n+      tree cfield = TREE_CHAIN (TYPE_FIELDS (field_info_union_node));\n       tree faddr = build_address_of (build_static_field_ref (fdecl));\n+\n       info = build (CONSTRUCTOR, field_info_union_node, NULL_TREE,\n \t\t    build_tree_list (cfield, faddr));\n     }\n   else\n-    {\n-      int boffset\n-\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (fdecl)) / BITS_PER_UNIT;\n-      info = build (CONSTRUCTOR, field_info_union_node, NULL_TREE,\n-\t\t    build_tree_list (TYPE_FIELDS(field_info_union_node),\n-\t\t\t\t     build_int_2 (boffset, 0)));\n-    }\n+    info = build (CONSTRUCTOR, field_info_union_node, NULL_TREE,\n+\t\t  build_tree_list (TYPE_FIELDS (field_info_union_node),\n+\t\t\t\t   build_int_2 ((int_bit_position (fdecl)\n+\t\t\t\t\t\t / BITS_PER_UNIT),\n+\t\t\t\t\t\t0)));\n+\n   PUSH_FIELD_VALUE (finit, \"info\", info);\n \n   FINISH_RECORD_CONSTRUCTOR (finit);\n@@ -1152,29 +1153,28 @@ get_dispatch_vector (type)\n   tree vtable = TYPE_VTABLE (type);\n   if (vtable == NULL)\n     {\n-      int i;\n+      HOST_WIDE_INT i;\n       tree method;\n       tree super = CLASSTYPE_SUPER (type);\n-      int nvirtuals = TREE_INT_CST_LOW (TYPE_NVIRTUALS (type));\n+      HOST_WIDE_INT nvirtuals = tree_low_cst (TYPE_NVIRTUALS (type), 0);\n       vtable = make_tree_vec (nvirtuals);\n       TYPE_VTABLE (type) = vtable;\n       if (super != NULL_TREE)\n \t{\n \t  tree super_vtable = get_dispatch_vector (super);\n-\t  for ( i = TREE_INT_CST_LOW (TYPE_NVIRTUALS (super));  --i >= 0; )\n+\n+\t  for (i = tree_low_cst (TYPE_NVIRTUALS (super), 0); --i >= 0; )\n \t    TREE_VEC_ELT (vtable, i) = TREE_VEC_ELT (super_vtable, i);\n \t}\n+\n       for (method = TYPE_METHODS (type);  method != NULL_TREE;\n \t   method = TREE_CHAIN (method))\n-\t{\n-\t  if (DECL_VINDEX (method) != NULL_TREE\n-\t      && TREE_CODE (DECL_VINDEX (method)) == INTEGER_CST)\n-\t    {\n-\t      TREE_VEC_ELT (vtable, TREE_INT_CST_LOW (DECL_VINDEX (method)))\n-\t\t= method;\n-\t    }\n-\t}\n+\tif (DECL_VINDEX (method) != NULL_TREE\n+\t    && host_integerp (DECL_VINDEX (method), 0))\n+\t  TREE_VEC_ELT (vtable, tree_low_cst (DECL_VINDEX (method), 0))\n+\t    = method;\n     }\n+\n   return vtable;\n }\n \n@@ -1966,9 +1966,11 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n \t       && dtable_count)\n \t{\n \t  DECL_VINDEX (method_decl) = dtable_count;\n-\t  dtable_count = build_int_2 (1+TREE_INT_CST_LOW (dtable_count), 0);\n+\t  dtable_count = fold (build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t      dtable_count, integer_one_node));\n \t}\n     }\n+\n   return dtable_count;\n }\n "}, {"sha": "f5cd80ef76f2efbe603e8d9e211f5ce557b9f31c", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -401,11 +401,9 @@ push_promoted_type (name, actual_type)\n   tree in_min = TYPE_MIN_VALUE (actual_type);\n   tree in_max = TYPE_MAX_VALUE (actual_type);\n #endif\n-  TYPE_MIN_VALUE (type) = build_int_2 (TREE_INT_CST_LOW (in_min),\n-\t\t\t\t       TREE_INT_CST_HIGH (in_min));\n+  TYPE_MIN_VALUE (type) = copy_node (in_min);\n   TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n-  TYPE_MAX_VALUE (type) = build_int_2 (TREE_INT_CST_LOW (in_max),\n-\t\t\t\t       TREE_INT_CST_HIGH (in_max));\n+  TYPE_MAX_VALUE (type) = copy_node (in_max);\n   TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n   TYPE_PRECISION (type) = TYPE_PRECISION (int_type_node);\n   layout_type (type);"}, {"sha": "dc568578cc09e7fe59cc932d0ed8422ba2c86835", "filename": "gcc/java/expr.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -693,8 +693,7 @@ java_array_data_offset (array)\n   if (data_fld == NULL_TREE)\n     return size_in_bytes (array_type);\n   else\n-    return build_int_2 (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (data_fld))\n-\t\t\t/ BITS_PER_UNIT, 0);\n+    return build_int_2 (int_bit_position (data_fld) / BITS_PER_UNIT, 0);\n }\n \n /* Implement array indexing (either as l-value or r-value).\n@@ -788,8 +787,8 @@ build_newarray (atype_value, length)\n {\n   tree type\n     = build_java_array_type (decode_newarray_type (atype_value),\n-\t\t\t     TREE_CODE (length) == INTEGER_CST\n-\t\t\t     ? (HOST_WIDE_INT) TREE_INT_CST_LOW (length) : -1);\n+\t\t\t     host_integerp (length, 0) == INTEGER_CST\n+\t\t\t     ? tree_low_cst (length, 0) : -1);\n \n   return build (CALL_EXPR, promote_type (type),\n \t\tbuild_address_of (soft_newarray_node),\n@@ -809,8 +808,8 @@ build_anewarray (class_type, length)\n {\n   tree type\n     = build_java_array_type (class_type,\n-\t\t\t     TREE_CODE (length) == INTEGER_CST\n-\t\t\t     ? (HOST_WIDE_INT) TREE_INT_CST_LOW (length) : -1);\n+\t\t\t     host_integerp (length, 0)\n+\t\t\t     ? tree_low_cst (length, 0) : -1);\n \n   return build (CALL_EXPR, promote_type (type),\n \t\tbuild_address_of (soft_anewarray_node),\n@@ -1646,14 +1645,15 @@ build_invokevirtual (dtable, method)\n   tree func;\n   tree nativecode_ptr_ptr_type_node\n     = build_pointer_type (nativecode_ptr_type_node);\n-  int method_index = TREE_INT_CST_LOW (DECL_VINDEX (method));\n+  tree method_index = convert (sizetype, DECL_VINDEX (method));\n+\n   /* Add one to skip \"class\" field of dtable, and one to skip unused\n      vtable entry (for C++ compatibility). */\n-  method_index += 2;\n-  method_index\n-    *= int_size_in_bytes (nativecode_ptr_ptr_type_node);\n-  func = fold (build (PLUS_EXPR, nativecode_ptr_ptr_type_node,\n-\t\t      dtable, build_int_2 (method_index, 0)));\n+  method_index = size_binop (PLUS_EXPR, method_index, size_int (2));\n+  method_index = size_binop (MULT_EXPR, method_index,\n+\t\t\t     TYPE_SIZE_UNIT (nativecode_ptr_ptr_type_node));\n+  func = fold (build (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n+\t\t      convert (nativecode_ptr_ptr_type_node, method_index)));\n   func = build1 (INDIRECT_REF, nativecode_ptr_type_node, func);\n \n   return func;"}, {"sha": "7c363e302bd41ccf61a5fe382eb9aa69f8be642b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -2819,7 +2819,7 @@ encode_method_prototype (method_decl, func_decl)\n   tree parms;\n   int stack_size, i;\n   tree user_args;\n-  int max_parm_end = 0;\n+  HOST_WIDE_INT max_parm_end = 0;\n   char buf[40];\n   tree result;\n \n@@ -2835,9 +2835,8 @@ encode_method_prototype (method_decl, func_decl)\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n        parms = TREE_CHAIN (parms))\n     {\n-      int parm_end = (forwarding_offset (parms)\n-\t\t      + (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (parms)))\n-\t\t\t / BITS_PER_UNIT));\n+      HOST_WIDE_INT parm_end = (forwarding_offset (parms)\n+\t\t\t\t+ int_size_in_bytes (parms));\n \n       if (!offset_is_register && max_parm_end < parm_end)\n \tmax_parm_end = parm_end;\n@@ -3822,9 +3821,7 @@ build_ivar_list_initializer (type, field_decl)\n       ivar\n \t= tree_cons\n \t  (NULL_TREE,\n-\t   build_int_2 ((TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field_decl))\n-\t\t\t / BITS_PER_UNIT),\n-\t\t\t0),\n+\t   build_int_2 ((int_bit_position (field_decl) / BITS_PER_UNIT), 0),\n \t   ivar);\n \n       initlist = tree_cons (NULL_TREE, \n@@ -4489,9 +4486,7 @@ generate_shared_structures ()\n     = build_shared_structure_initializer\n       (TREE_TYPE (decl),\n        root_expr, super_expr, name_expr,\n-       build_int_2 ((TREE_INT_CST_LOW (TYPE_SIZE (objc_class_template))\n-\t\t    / BITS_PER_UNIT),\n-\t\t    0),\n+       convert (integer_type_node, TYPE_SIZE_UNIT (objc_class_template)),\n        2 /*CLS_META*/,\n        UOBJC_CLASS_METHODS_decl,\n        UOBJC_CLASS_VARIABLES_decl,\n@@ -4509,11 +4504,9 @@ generate_shared_structures ()\n       (TREE_TYPE (decl),\n        build_unary_op (ADDR_EXPR, UOBJC_METACLASS_decl, 0),\n        super_expr, name_expr,\n-       build_int_2\n-       ((TREE_INT_CST_LOW\n-\t (TYPE_SIZE (CLASS_STATIC_TEMPLATE (implementation_template)))\n-\t / BITS_PER_UNIT),\n-\t0),\n+       convert (integer_type_node,\n+\t\tTYPE_SIZE_UNIT (CLASS_STATIC_TEMPLATE\n+\t\t\t\t(implementation_template))),\n        1 /*CLS_FACTORY*/,\n        UOBJC_INSTANCE_METHODS_decl,\n        UOBJC_INSTANCE_VARIABLES_decl,\n@@ -6726,8 +6719,7 @@ encode_type (type, curtype, format)\n \n   if (code == INTEGER_TYPE)\n     {\n-      if (TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) == 0\n-\t  && TREE_INT_CST_HIGH (TYPE_MIN_VALUE (type)) == 0)\n+      if (integer_zerop (TYPE_MIN_VALUE (type)))\n \t{\n \t  /* Unsigned integer types.  */\n \n@@ -6802,8 +6794,7 @@ encode_complete_bitfield (int position, tree type, int size)\n \n   if (code == INTEGER_TYPE)\n     {\n-      if (TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) == 0\n-\t  && TREE_INT_CST_HIGH (TYPE_MIN_VALUE (type)) == 0)\n+      if (integer_zerop (TYPE_MIN_VALUE (type)))\n \t{\n \t  /* Unsigned integer types.  */\n \n@@ -6865,16 +6856,16 @@ encode_field_decl (field_decl, curtype, format)\n   if (flag_next_runtime)\n     {\n       if (DECL_BIT_FIELD (field_decl))\n-\tencode_bitfield (TREE_INT_CST_LOW (DECL_SIZE (field_decl)));\n+\tencode_bitfield (tree_low_cst (DECL_SIZE (field_decl), 1));\n       else\n \tencode_type (TREE_TYPE (field_decl), curtype, format);\n     }\n   else\n     {\n       if (DECL_BIT_FIELD (field_decl))\n-\tencode_complete_bitfield (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field_decl)),\n+\tencode_complete_bitfield (int_bit_position (field_decl),\n \t\t\t\t  DECL_BIT_FIELD_TYPE (field_decl),\n-\t\t\t\t  TREE_INT_CST_LOW (DECL_SIZE (field_decl)));\n+\t\t\t\t  tree_low_cst (DECL_SIZE (field_decl), 1));\n       else\n \tencode_type (TREE_TYPE (field_decl), curtype, format);\n     }\n@@ -7294,7 +7285,7 @@ encode_method_def (func_decl)\n {\n   tree parms;\n   int stack_size;\n-  int max_parm_end = 0;\n+  HOST_WIDE_INT max_parm_end = 0;\n   char buffer[40];\n   tree result;\n \n@@ -7307,11 +7298,10 @@ encode_method_def (func_decl)\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n        parms = TREE_CHAIN (parms))\n     {\n-      int parm_end = (forwarding_offset (parms)\n-\t\t      + (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (parms)))\n-\t\t\t / BITS_PER_UNIT));\n+      HOST_WIDE_INT parm_end = (forwarding_offset (parms)\n+\t\t\t\t+ int_size_in_bytes (TREE_TYPE (parms)));\n \n-      if (!offset_is_register && parm_end > max_parm_end)\n+      if (! offset_is_register && parm_end > max_parm_end)\n \tmax_parm_end = parm_end;\n     }\n "}, {"sha": "e34d7b28341ad68be7cab0a43b1792ff1f1fd431", "filename": "gcc/objc/objc-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -130,7 +130,7 @@ static int undeclared_variable_notice;\n \tbuild_int_2 (pedantic | (warn_pointer_arith << 1), 0)\n #define RESTORE_WARN_FLAGS(tval) \\\n   do {                                     \\\n-    int val = TREE_INT_CST_LOW (tval);     \\\n+    int val = tree_low_cst (tval, 0);     \\\n     pedantic = val & 1;                    \\\n     warn_pointer_arith = (val >> 1) & 1;   \\\n   } while (0)"}, {"sha": "e475096492c36d175de772116ecf2fcf65986565", "filename": "gcc/objc/objc-parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -222,7 +222,7 @@ static int undeclared_variable_notice;\n \tbuild_int_2 (pedantic | (warn_pointer_arith << 1), 0)\n #define RESTORE_WARN_FLAGS(tval) \\\n   do {                                     \\\n-    int val = TREE_INT_CST_LOW (tval);     \\\n+    int val = tree_low_cst (tval, 0);     \\\n     pedantic = val & 1;                    \\\n     warn_pointer_arith = (val >> 1) & 1;   \\\n   } while (0)"}, {"sha": "dfe84c8a5de4144b1ec27647c1c5af5025c9d5fb", "filename": "gcc/sdbout.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -607,12 +607,14 @@ plain_type_1 (type, level)\n \tif (sdb_n_dims < SDB_MAX_DIM)\n \t  sdb_dims[sdb_n_dims++]\n \t    = (TYPE_DOMAIN (type)\n-\t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n-\t       && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INTEGER_CST\n-\t       && TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) == INTEGER_CST\n-\t       ? (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t\t  - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1)\n+\t       && TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != 0\n+\t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != 0\n+\t       && host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0)\n+\t       && host_integerp (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0)\n+\t       ? (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0)\n+\t\t  - tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0) + 1)\n \t       : 0);\n+\n \treturn PUSH_DERIVED_LEVEL (DT_ARY, m);\n       }\n \n@@ -1089,8 +1091,8 @@ sdbout_field_types (type)\n        below.  */\n     if (TREE_CODE (tail) == FIELD_DECL\n \t&& DECL_NAME (tail) != 0\n-\t&& TREE_CODE (DECL_SIZE (tail)) == INTEGER_CST\n-\t&& TREE_CODE (DECL_FIELD_BITPOS (tail)) == INTEGER_CST)\n+\t&& ! host_integerp (DECL_SIZE (tail), 1)\n+\t&& ! host_integerp (bit_position (tail), 0))\n       {\n \tif (POINTER_TYPE_P (TREE_TYPE (tail)))\n \t  sdbout_one_type (TREE_TYPE (TREE_TYPE (tail)));\n@@ -1239,7 +1241,7 @@ sdbout_one_type (type)\n \n \t\tCONTIN;\n \t\tPUT_SDB_DEF (IDENTIFIER_POINTER (child_type_name));\n-\t\tPUT_SDB_INT_VAL (TREE_INT_CST_LOW (BINFO_OFFSET (child)));\n+\t\tPUT_SDB_INT_VAL (tree_low_cst (BINFO_OFFSET (child), 0));\n \t\tPUT_SDB_SCL (member_scl);\n \t\tsdbout_type (BINFO_TYPE (child));\n \t\tPUT_SDB_ENDEF;\n@@ -1250,13 +1252,14 @@ sdbout_one_type (type)\n \n \tif (TREE_CODE (type) == ENUMERAL_TYPE)\n \t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n-\t    {\n-\t      PUT_SDB_DEF (IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n-\t      PUT_SDB_INT_VAL (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n-\t      PUT_SDB_SCL (C_MOE);\n-\t      PUT_SDB_TYPE (T_MOE);\n-\t      PUT_SDB_ENDEF;\n-\t    }\n+\t    if (host_integerp (TREE_VALUE (tem), 0))\n+\t      {\n+\t\tPUT_SDB_DEF (IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n+\t\tPUT_SDB_INT_VAL (tree_low_cst (TREE_VALUE (tem), 0));\n+\t\tPUT_SDB_SCL (C_MOE);\n+\t\tPUT_SDB_TYPE (T_MOE);\n+\t\tPUT_SDB_ENDEF;\n+\t      }\n \n \telse\t\t\t/* record or union type */\n \t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n@@ -1268,8 +1271,8 @@ sdbout_one_type (type)\n \t       Also omit non FIELD_DECL nodes that GNU C++ may put here.  */\n \t    if (TREE_CODE (tem) == FIELD_DECL\n \t\t&& DECL_NAME (tem) != 0\n-\t\t&& TREE_CODE (DECL_SIZE (tem)) == INTEGER_CST\n-\t\t&& TREE_CODE (DECL_FIELD_BITPOS (tem)) == INTEGER_CST)\n+\t\t&& host_integerp (DECL_SIZE (tem), 1)\n+\t\t&& host_integerp (bit_position (tem), 0))\n \t      {\n \t\tchar *name;\n \n@@ -1278,15 +1281,14 @@ sdbout_one_type (type)\n \t\tPUT_SDB_DEF (name);\n \t\tif (DECL_BIT_FIELD_TYPE (tem))\n \t\t  {\n-\t\t    PUT_SDB_INT_VAL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)));\n+\t\t    PUT_SDB_INT_VAL (int_bit_position (tem));\n \t\t    PUT_SDB_SCL (C_FIELD);\n \t\t    sdbout_type (DECL_BIT_FIELD_TYPE (tem));\n-\t\t    PUT_SDB_SIZE (TREE_INT_CST_LOW (DECL_SIZE (tem)));\n+\t\t    PUT_SDB_SIZE (tree_low_cst (DECL_SIZE (tem), 1));\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    PUT_SDB_INT_VAL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem))\n-\t\t\t\t     / BITS_PER_UNIT);\n+\t\t    PUT_SDB_INT_VAL (int_bit_position (tem) / BITS_PER_UNIT);\n \t\t    PUT_SDB_SCL (member_scl);\n \t\t    sdbout_type (TREE_TYPE (tem));\n \t\t  }"}, {"sha": "8a36bbd9226c1d93400a0082c0f33f1a32aabcc6", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -764,7 +764,7 @@ rename_registers (nregs, idom)\n   VARRAY_RTX_INIT (ssa_rename_from, nregs * 3, \"ssa_rename_from\");\n \n   ssa_rename_to = (rtx *) alloca (nregs * sizeof(rtx));\n-  bzero (ssa_rename_to, nregs * sizeof(rtx));\n+  bzero ((char *) ssa_rename_to, nregs * sizeof(rtx));\n \n   rename_block (0, idom);\n "}, {"sha": "72d85ee0ba96137362748b2b6374ce060a356b0e", "filename": "gcc/tree.c", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -2301,13 +2301,36 @@ int_size_in_bytes (type)\n   if (t == 0\n       || TREE_CODE (t) != INTEGER_CST\n       || TREE_OVERFLOW (t)\n-      || TREE_INT_CST_HIGH (t) != 0)\n+      || TREE_INT_CST_HIGH (t) != 0\n+      /* If the result would appear negative, it's too big to represent.  */\n+      || (HOST_WIDE_INT) TREE_INT_CST_LOW (t) < 0)\n     return -1;\n \n   return TREE_INT_CST_LOW (t);\n }\n+\f\n+/* Return the bit position of FIELD, in bits from the start of the record.\n+   This is a tree of type bitsizetype.  */\n+\n+tree\n+bit_position (field)\n+     tree field;\n+{\n+  return DECL_FIELD_BITPOS (field);\n+}\n+\n+/* Likewise, but return as an integer.  Abort if it cannot be represented\n+   in that way (since it could be a signed value, we don't have the option\n+   of returning -1 like int_size_in_byte can.  */\n \n-/* Return the strictest alignment, in bits, that  T is known to have.  */\n+HOST_WIDE_INT\n+int_bit_position (field)\n+     tree field;\n+{\n+  return tree_low_cst (bit_position (field), 0);\n+}\n+\f\n+/* Return the strictest alignment, in bits, that T is known to have.  */\n \n unsigned int\n expr_align (t)\n@@ -4107,6 +4130,37 @@ tree_int_cst_lt (t1, t2)\n   return INT_CST_LT_UNSIGNED (t1, t2);\n }\n \n+/* Return 1 if T is an INTEGER_CST that can be represented in a single\n+   HOST_WIDE_INT value.  If POS is nonzero, the result must be positive.  */\n+\n+int\n+host_integerp (t, pos)\n+     tree t;\n+     int pos;\n+{\n+  return (TREE_CODE (t) == INTEGER_CST\n+\t  && ! TREE_OVERFLOW (t)\n+\t  && ((TREE_INT_CST_HIGH (t) == 0\n+\t       && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) >= 0)\n+\t      || (! pos && TREE_INT_CST_HIGH (t) == -1\n+\t\t  && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) < 0)));\n+}\n+\n+/* Return the HOST_WIDE_INT least significant bits of T if it is an\n+   INTEGER_CST and there is no overflow.  POS is nonzero if the result must\n+   be positive.  Abort if we cannot satisfy the above conditions.  */\n+\n+HOST_WIDE_INT\n+tree_low_cst (t, pos)\n+     tree t;\n+     int pos;\n+{\n+  if (host_integerp (t, pos))\n+    return TREE_INT_CST_LOW (t);\n+  else\n+    abort ();\n+}  \n+\n /* Return the most significant bit of the integer constant T.  */\n \n int"}, {"sha": "c8cfdf900b21ea0f80c6b9d12e28ffa84fd76640", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -1703,6 +1703,8 @@ extern int attribute_list_equal\t\tPARAMS ((tree, tree));\n extern int attribute_list_contained\tPARAMS ((tree, tree));\n extern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\n extern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\n+extern int host_integerp\t\tPARAMS ((tree, int));\n+extern HOST_WIDE_INT tree_low_cst\tPARAMS ((tree, int));\n extern int tree_int_cst_msb\t\tPARAMS ((tree));\n extern int tree_int_cst_sgn\t\tPARAMS ((tree));\n extern int index_type_equal\t\tPARAMS ((tree, tree));\n@@ -1850,6 +1852,8 @@ extern tree convert\t\t\tPARAMS ((tree, tree));\n extern unsigned int expr_align\t\tPARAMS ((tree));\n extern tree size_in_bytes\t\tPARAMS ((tree));\n extern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\n+extern tree bit_position\t\tPARAMS ((tree));\n+extern HOST_WIDE_INT int_bit_position\tPARAMS ((tree));\n \n /* Define data structures, macros, and functions for handling sizes\n    and the various types used to represent sizes.  */\n@@ -2554,7 +2558,6 @@ extern void print_lang_statistics\tPARAMS ((void));\n \n /* In c-common.c */\n extern tree truthvalue_conversion\tPARAMS ((tree));\n-extern unsigned int min_precision\tPARAMS ((tree, int));\n extern void split_specs_attrs\t\tPARAMS ((tree, tree *, tree *));\n \n /* In c-decl.c */"}, {"sha": "f144293a4b0bde21a8849a5e28f18be579266e04", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665f250366b2cd1528c32b0d7d2fea6aae006e85/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=665f250366b2cd1528c32b0d7d2fea6aae006e85", "patch": "@@ -2281,10 +2281,12 @@ decode_addr_const (exp, value)\n   while (1)\n     {\n       if (TREE_CODE (target) == COMPONENT_REF\n-\t  && (TREE_CODE (DECL_FIELD_BITPOS (TREE_OPERAND (target, 1)))\n-\t      == INTEGER_CST))\n+\t  && host_integerp (bit_position (TREE_OPERAND (target, 1)), 0))\n+\n \t{\n-\t  offset += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (TREE_OPERAND (target, 1))) / BITS_PER_UNIT;\n+\t  offset\n+\t    += int_bit_position (TREE_OPERAND (target, 1)) / BITS_PER_UNIT;\n+\n \t  target = TREE_OPERAND (target, 0);\n \t}\n       else if (TREE_CODE (target) == ARRAY_REF)"}]}