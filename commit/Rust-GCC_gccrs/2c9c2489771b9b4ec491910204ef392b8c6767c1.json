{"sha": "2c9c2489771b9b4ec491910204ef392b8c6767c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5YzI0ODk3NzFiOWI0ZWM0OTE5MTAyMDRlZjM5MmI4YzY3NjdjMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-26T18:26:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-26T18:26:41Z"}, "message": "Initial revision\n\nFrom-SVN: r8342", "tree": {"sha": "7d71223190a50413ab7d6ecaae5c71af2d3e0e42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d71223190a50413ab7d6ecaae5c71af2d3e0e42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c9c2489771b9b4ec491910204ef392b8c6767c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9c2489771b9b4ec491910204ef392b8c6767c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9c2489771b9b4ec491910204ef392b8c6767c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9c2489771b9b4ec491910204ef392b8c6767c1/comments", "author": null, "committer": null, "parents": [{"sha": "601727c5e57d4e7056cadfc21d20cf280a32de6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601727c5e57d4e7056cadfc21d20cf280a32de6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601727c5e57d4e7056cadfc21d20cf280a32de6c"}], "stats": {"total": 4770, "additions": 4770, "deletions": 0}, "files": [{"sha": "0d7da7e4507c996fc75a1fc89685bfae9d76b6c7", "filename": "gcc/config/pdp11/pdp11.c", "status": "added", "additions": 1416, "deletions": 0, "changes": 1416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=2c9c2489771b9b4ec491910204ef392b8c6767c1", "patch": "@@ -0,0 +1,1416 @@\n+/* Subroutines for gcc2 for pdp11.\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef FILE\n+#include <stdio.h>\n+#endif\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+/*\n+#define FPU_REG_P(X)\t((X)>=8 && (X)<14)\n+#define CPU_REG_P(X)\t((X)>=0 && (X)<8)\n+*/\n+\n+/* this is the current value returned by the macro FIRST_PARM_OFFSET \n+   defined in tm.h */\n+int current_first_parm_offset;\n+\n+/* This is where the condition code register lives.  */\n+/* rtx cc0_reg_rtx; - no longer needed? */\n+\n+static rtx find_addr_reg (); \n+\n+/* Nonzero if OP is a valid second operand for an arithmetic insn.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) || GET_CODE (op) == CONST_INT);\n+}\n+\n+int\n+const_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT);\n+}\n+\n+int \n+immediate15_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+    return (GET_CODE (op) == CONST_INT && ((INTVAL (op) & 0x8000) == 0x0000));\n+}\n+\n+int\n+expand_shift_operand (op, mode)\n+  rtx op;\n+  enum machine_mode mode;\n+{\n+    return (GET_CODE (op) == CONST_INT \n+\t    && abs (INTVAL(op)) > 1 \n+\t    && abs (INTVAL(op)) <= 4);\n+}\n+\n+/*\n+   stream is a stdio stream to output the code to.\n+   size is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  \n+*/\n+\n+void \n+output_function_prologue(stream, size)\n+  FILE *stream;\n+  int size;\n+{\t\t\t\t\t\t\t       \n+    extern char call_used_regs[];\t\t\t\t\t\n+    extern int frame_pointer_needed;\t\t\t\t\n+\n+    int fsize = ((size) + 1) & ~1;      \t\t\t\t\n+    int regno, nregs, i;\t\t\t\t\t\t\n+    int offset = 0;\n+\n+    int via_ac = -1;\n+    \n+    fprintf (stream, \"\\n\\t;\t/* function prologue %s*/\\n\", current_function_name);\t\t\n+\n+    /* if we are outputting code for main, \n+       the switch FPU to right mode if TARGET_FPU */\n+    if ( (strcmp (\"main\", current_function_name) == 0)\n+\t && TARGET_FPU)\n+    {\n+\tfprintf(stream, \"\\t;/* switch cpu to double float, single integer */\\n\");\n+\tfprintf(stream, \"\\tsetd\\n\");\n+\tfprintf(stream, \"\\tseti\\n\\n\");\n+    }\n+    \n+    if (frame_pointer_needed) \t\t\t\t\t\n+    {\t\t\t\t\t\t\t\t\n+\tfprintf(stream, \"\\tmov fp, -(sp)\\n\");\t\t\t\n+\tfprintf(stream, \"\\tmov sp, fp\\n\");\t\t\t\t\n+    }\t\t\t\t\t\t\t\t\n+    else \t\t\t\t\t\t\t\t\n+    {\t\t\t\t\t\t\t\t\n+\t/* DON'T SAVE FP */\n+    }\t\t\t\t\t\t\t\t\n+\n+    /* make frame */\n+    if (fsize)\t\t\t\t\t\t\t\n+\tfprintf (stream, \"\\tsub $%d, sp\\n\", fsize);\t\t\t\n+\n+    /* save CPU registers  */\n+    for (regno = 0; regno < 8; regno++)\t\t\t\t\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\n+\t    if (! ((regno == FRAME_POINTER_REGNUM)\t\t\t\n+\t\t   && frame_pointer_needed))\t\t\t\t\n+\t\tfprintf (stream, \"\\tmov %s, -(sp)\\n\", reg_names[regno]);\t\n+    /* fpu regs saving */\n+    \n+    /* via_ac specifies the ac to use for saving ac4, ac5 */\n+    via_ac = -1;\n+    \n+    for (regno = 8; regno < FIRST_PSEUDO_REGISTER ; regno++) \n+    {\n+\t/* ac0 - ac3 */\t\t\t\t\t\t\n+\tif (LOAD_FPU_REG_P(regno)\n+\t    && regs_ever_live[regno] \n+\t    && ! call_used_regs[regno])\n+\t{\n+\t    fprintf (stream, \"\\tfstd %s, -(sp)\\n\", reg_names[regno]);\n+\t    via_ac = regno;\n+\t}\n+\t\n+\t/* maybe make ac4, ac5 call used regs?? */\n+\t/* ac4 - ac5 */\n+\tif (NO_LOAD_FPU_REG_P(regno)\n+\t    && regs_ever_live[regno]\n+\t    && ! call_used_regs[regno])\n+\t{\n+\t    if (via_ac == -1)\n+\t\tabort();\n+\t    \n+\t    fprintf (stream, \"\\tfldd %s, %s\\n\", reg_names[regno], reg_names[via_ac]);\n+\t    fprintf (stream, \"\\tfstd %s, -(sp)\\n\", reg_names[via_ac]);\n+\t}\n+    }\n+\n+    fprintf (stream, \"\\t;/* end of prologue */\\n\\n\");\t\t\n+}\n+\n+/*\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+/* maybe we can make leaf functions faster by switching to the\n+   second register file - this way we don't have to save regs!\n+   leaf functions are ~ 50% of all functions (dynamically!) \n+\n+   set/clear bit 11 (dec. 2048) to status word for switching - \n+   but how can we do this? pdp11/45 says bit may only be set (p.24) \n+   switching to kernel is probably more expensive, so we'll leave it \n+   like this \n+\n+   maybe as option if you want to generate code for kernel mode? */\n+\n+\n+void \n+output_function_epilogue(stream, size)\n+  FILE *stream;\n+  int size;\n+{\t\t\t\t\t\t\t\t\n+    extern char call_used_regs[];\t\t\t\t\t\n+    extern int may_call_alloca;\n+\n+    int fsize = ((size) + 1) & ~1;      \t\t\t\t\n+    int nregs, regno, i, j, k, adjust_fp;\t\t\t\t\n+\n+    int via_ac;\n+    \n+    fprintf (stream, \"\\n\\t;\t/*function epilogue */\\n\");\t\t\n+\n+    if (frame_pointer_needed)\t\t\t\t\t\n+    {\t\t\t\t\t\t\t\t\n+\t/* hope this is safe - m68k does it also .... */\t\t\n+\tregs_ever_live[FRAME_POINTER_REGNUM] = 0;\t\t\t\n+\t\t\t\t\t\t\t\t\n+\tfor (i =7, j = 0 ; i >= 0 ; i--)\t\t\t\t\n+\t    if (regs_ever_live[i] && ! call_used_regs[i])\t\t\n+\t\tj++;\n+\t\n+\t/* remember # of pushed bytes for CPU regs */\n+\tk = 2*j;\n+\t\n+\tfor (i =7 ; i >= 0 ; i--)\t\t\t\t\t\n+\t    if (regs_ever_live[i] && ! call_used_regs[i])\t\t\n+\t\tfprintf(stream, \"\\tmov %d(fp), %s\\n\",-fsize-2*j--, reg_names[i]);\n+\n+\t/* get ACs */\t\t\t\t\t\t\n+\tvia_ac = FIRST_PSEUDO_REGISTER -1;\n+\t\n+\tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n+\t    if (regs_ever_live[i] && ! call_used_regs[i])\n+\t    {\n+\t\tvia_ac = i;\n+\t\tk += 8;\n+\t    }\n+\t\n+\tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n+\t{\n+\t    if (LOAD_FPU_REG_P(i)\n+\t\t&& regs_ever_live[i]\n+\t\t&& ! call_used_regs[i])\n+\t    {\n+\t\tfprintf(stream, \"\\tfldd %d(fp), %s\\n\", -fsize-k, reg_names[i]);\n+\t\tk -= 8;\n+\t    }\n+\t    \n+\t    if (NO_LOAD_FPU_REG_P(i)\n+\t\t&& regs_ever_live[i]\n+\t\t&& ! call_used_regs[i])\n+\t    {\n+\t\tif (! LOAD_FPU_REG_P(via_ac))\n+\t\t    abort();\n+\t\t    \n+\t\tfprintf(stream, \"\\tfldd %d(fp), %s\\n\", -fsize-k, reg_names[via_ac]);\n+\t\tfprintf(stream, \"\\tfstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n+\t\tk -= 8;\n+\t    }\n+\t}\n+\t\n+\tfprintf(stream, \"\\tmov fp, sp\\n\");\t\t\t\t\n+\tfprintf (stream, \"\\tmov (sp)+, fp\\n\");     \t\t\t\n+    }\t\t\t\t\t\t\t\t\n+    else\t\t\t\t\t\t\t\t\n+    {\t\t   \n+\tvia_ac = FIRST_PSEUDO_REGISTER -1;\n+\t\n+\t/* get ACs */\n+\tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n+\t    if (regs_ever_live[i] && call_used_regs[i])\n+\t\tvia_ac = i;\n+\t\n+\tfor (i = FIRST_PSEUDO_REGISTER; i > 7; i--)\n+\t{\n+\t    if (LOAD_FPU_REG_P(i)\n+\t\t&& regs_ever_live[i]\n+\t\t&& ! call_used_regs[i])\n+\t      fprintf(stream, \"\\tfldd (sp)+, %s\\n\", reg_names[i]);\n+\t    \n+\t    if (NO_LOAD_FPU_REG_P(i)\n+\t\t&& regs_ever_live[i]\n+\t\t&& ! call_used_regs[i])\n+\t    {\n+\t\tif (! LOAD_FPU_REG_P(via_ac))\n+\t\t    abort();\n+\t\t    \n+\t\tfprintf(stream, \"\\tfldd (sp)+, %s\\n\", reg_names[via_ac]);\n+\t\tfprintf(stream, \"\\tfstd %s, %s\\n\", reg_names[via_ac], reg_names[i]);\n+\t    }\n+\t}\n+\n+\tfor (i=7; i >= 0; i--)\t\t\t\t\t\n+\t    if (regs_ever_live[i] && !call_used_regs[i])\t\t\n+\t\tfprintf(stream, \"\\tmov (sp)+, %s\\n\", reg_names[i]);\t\n+\t\t\t\t\t\t\t\t\n+\tif (fsize)\t\t\t\t\t\t\n+\t    fprintf((stream), \"\\tadd $%d, sp\\n\", fsize);      \t\t\n+    }\t\t\t\n+\t\t\t\t\t\n+    fprintf (stream, \"\\trts pc\\n\");\t\t\t\t\t\n+    fprintf (stream, \"\\t;/* end of epilogue*/\\n\\n\\n\");\t\t\n+}\n+\t\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (operands[1] != const0_rtx)\n+    return \"mov %1,%0\";\n+\n+  return \"clr %0\";\n+}\n+\n+\f\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    optype0 = POPOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = PUSHOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+#if 0\n+\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n+#endif\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = PUSHOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If one operand is decrementing and one is incrementing\n+     decrement the former register explicitly\n+     and change that operand into ordinary indexing.  */\n+\n+  if (optype0 == PUSHOP && optype1 == POPOP)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"sub $4,%0\", operands);\n+      operands[0] = gen_rtx (MEM, SImode, operands[0]);\n+      optype0 = OFFSOP;\n+    }\n+  if (optype0 == POPOP && optype1 == PUSHOP)\n+    {\n+      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"sub $4,%1\", operands);\n+      operands[1] = gen_rtx (MEM, SImode, operands[1]);\n+      optype1 = OFFSOP;\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, HImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 2);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, HImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 2);\n+  else if (optype1 == CNSTOP)\n+    {\n+\tif (CONSTANT_P (operands[1]))\n+\t{\n+\t    /* now the mess begins, high word is in lower word??? \n+\n+\t       that's what ashc makes me think, but I don't remember :-( */\n+\t    latehalf[1] = gen_rtx(CONST_INT, VOIDmode, \n+\t\t\t\t  INTVAL(operands[1])>>16);\n+\t    operands[1] = gen_rtx(CONST_INT, VOIDmode,\n+\t\t\t\t  INTVAL(operands[1])&0xff);\n+\t}\n+      else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t    /* immediate 32 bit values not allowed */\n+\t    abort();\n+\t}\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If insn is effectively movd N(sp),-(sp) then we will do the\n+     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n+     for the low word as well, to compensate for the first decrement of sp.  */\n+  if (optype0 == PUSHOP\n+      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    operands[1] = latehalf[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  /* Likewise,  the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add $2,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add $2,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"sub $2,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"sub $2,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add $2,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add $2,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"sub $2,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"sub $2,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+/* Output assembler code to perform a quadword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_quad (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  output_asm_insn(\";; movdi/df: %1 -> %0\", operands);\n+  \n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    optype0 = POPOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = PUSHOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1])\n+\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = PUSHOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+  \n+  /* check if we move a CPU reg to an FPU reg, or vice versa! */\n+  if (optype0 == REGOP && optype1 == REGOP)\n+      /* bogus - 64 bit cannot reside in CPU! */\n+      if (CPU_REG_P(REGNO(operands[0]))\n+\t  || CPU_REG_P (REGNO(operands[1])))\n+\t  abort();\n+  \n+  if (optype0 == REGOP || optype1 == REGOP)\n+  {\n+      /* check for use of clrd???? \n+         if you ever allow ac4 and ac5 (now we require secondary load) \n+\t you must check whether \n+\t you want to load into them or store from them - \n+\t then dump ac0 into $help$ movce ac4/5 to ac0, do the \n+\t store from ac0, and restore ac0 - if you can find \n+\t an unused ac[0-3], use that and you save a store and a load!*/\n+\n+      if (FPU_REG_P(REGNO(operands[0])))\n+      {\n+\t  if (GET_CODE(operands[1]) == CONST_DOUBLE)\n+\t  {\n+\t      union { double d; int i[2]; } u;\n+\t      u.i[0] = CONST_DOUBLE_LOW (operands[1]); \n+\t      u.i[1] = CONST_DOUBLE_HIGH (operands[1]); \n+\t      \n+\t      if (u.d == 0.0)\n+\t\t  return \"clrd %0\";\n+\t  }\n+\t      \n+\t  return \"ldd %1, %0\";\n+      }\n+      \n+      if (FPU_REG_P(REGNO(operands[1])))\n+\t  return \"std %1, %0\";\n+  }\n+      \n+  /* If one operand is decrementing and one is incrementing\n+     decrement the former register explicitly\n+     and change that operand into ordinary indexing.  */\n+\n+  if (optype0 == PUSHOP && optype1 == POPOP)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"sub $8,%0\", operands);\n+      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      optype0 = OFFSOP;\n+    }\n+  if (optype0 == POPOP && optype1 == PUSHOP)\n+    {\n+      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"sub $8,%1\", operands);\n+      operands[1] = gen_rtx (MEM, SImode, operands[1]);\n+      optype1 = OFFSOP;\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 2);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 2);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t    /* floats only. not yet supported!\n+\n+\t     -- compute it into PDP float format, - internally,\n+\t     just use IEEE and ignore possible problems ;-)\n+\n+\t     we might get away with it !!!! */\n+\n+\t    abort();\n+\t    \n+#ifndef HOST_WORDS_BIG_ENDIAN\n+\t  latehalf[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_LOW (operands[1]));\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_HIGH (operands[1]));\n+#else /* HOST_WORDS_BIG_ENDIAN */\n+\t  latehalf[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_HIGH (operands[1]));\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_LOW (operands[1]));\n+#endif /* HOST_WORDS_BIG_ENDIAN */\n+\t}\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If insn is effectively movd N(sp),-(sp) then we will do the\n+     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n+     for the low word as well, to compensate for the first decrement of sp.  */\n+  if (optype0 == PUSHOP\n+      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    operands[1] = latehalf[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  /* Likewise,  the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add $4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add $4,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn(output_move_double(latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"sub $4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"sub $4,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return output_move_double (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (output_move_double (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add $4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add $4,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (output_move_double (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"sub $4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"sub $4,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  return 0;\n+}\n+\f\n+/* Output an ascii string.  */\n+output_ascii (file, p, size)\n+     FILE *file;\n+     char *p;\n+     int size;\n+{\n+  int i;\n+\n+  fprintf (file, \"\\t.byte \\\"\");\n+\n+  for (i = 0; i < size; i++)\n+    {\n+      register int c = p[i];\n+      if (c == '\\\"' || c == '\\\\')\n+\tputc ('\\\\', file);\n+      if (c >= ' ' && c < 0177)\n+\tputc (c, file);\n+      else\n+\t{\n+\t  fprintf (file, \"\\\\%03o\", c);\n+\t  /* After an octal-escape, if a digit follows,\n+\t     terminate one string constant and start another.\n+\t     The Vax assembler fails to stop reading the escape\n+\t     after three digits, so this is the only way we\n+\t     can get it to parse the data properly.  */\n+\t  if (i < size - 1 && p[i + 1] >= '0' && p[i + 1] <= '9')\n+\t    fprintf (file, \"\\\"\\n\\tstring \\\"\");\n+\t}\n+    }\n+  fprintf (file, \"\\\"\\n\");\n+}\n+\n+\n+/* --- stole from out-vax, needs changes */\n+\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  register rtx reg1, reg2, breg, ireg;\n+  rtx offset;\n+\n+ retry:\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case MEM:\n+      fprintf (file, \"@\");\n+      addr = XEXP (addr, 0);\n+      goto retry;\n+\n+    case REG:\n+      fprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_INC:\n+      fprintf (file, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case PLUS:\n+      reg1 = 0;\treg2 = 0;\n+      ireg = 0;\tbreg = 0;\n+      offset = 0;\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n+\t  || GET_CODE (XEXP (addr, 0)) == MEM)\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n+\t       || GET_CODE (XEXP (addr, 1)) == MEM)\n+\t{\n+\t  offset = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) != PLUS)\n+\t;\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\n+\t{\n+\t  if (reg1 == 0)\n+\t    reg1 = addr;\n+\t  else\n+\t    reg2 = addr;\n+\t  addr = 0;\n+\t}\n+      if (offset != 0)\n+\t{\n+\t  if (addr != 0) abort ();\n+\t  addr = offset;\n+\t}\n+      if (reg1 != 0 && GET_CODE (reg1) == MULT)\n+\t{\n+\t  breg = reg2;\n+\t  ireg = reg1;\n+\t}\n+      else if (reg2 != 0 && GET_CODE (reg2) == MULT)\n+\t{\n+\t  breg = reg1;\n+\t  ireg = reg2;\n+\t}\n+      else if (reg2 != 0 || GET_CODE (addr) == MEM)\n+\t{\n+\t  breg = reg2;\n+\t  ireg = reg1;\n+\t}\n+      else\n+\t{\n+\t  breg = reg1;\n+\t  ireg = reg2;\n+\t}\n+      if (addr != 0)\n+\toutput_address (addr);\n+      if (breg != 0)\n+\t{\n+\t  if (GET_CODE (breg) != REG)\n+\t    abort ();\n+\t  fprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n+\t}\n+      if (ireg != 0)\n+\t{\n+\t  if (GET_CODE (ireg) == MULT)\n+\t    ireg = XEXP (ireg, 0);\n+\t  if (GET_CODE (ireg) != REG)\n+\t    abort ();\n+\t  abort();\n+\t  fprintf (file, \"[%s]\", reg_names[REGNO (ireg)]);\n+\t}\n+      break;\n+\n+    default:\n+      output_addr_const (file, addr);\n+    }\n+}\n+\n+/* register move costs, indexed by regs */\n+\n+static int move_costs[N_REG_CLASSES][N_REG_CLASSES] = \n+{\n+             /* NO  MUL  GEN  LFPU  NLFPU FPU ALL */\n+\n+/* NO */     {  0,   0,   0,    0,    0,    0,   0},\n+/* MUL */    {  0,   2,   2,   10,   22,   22,  22},\n+/* GEN */    {  0,   2,   2,   10,   22,   22,  22},\n+/* LFPU */   {  0,  10,  10,    2,    2,    2,  10},\n+/* NLFPU */  {  0,  22,  22,    2,    2,    2,  22},\n+/* FPU */    {  0,  22,  22,    2,    2,    2,  22},\n+/* ALL */    {  0,  22,  22,   10,   22,   22,  22}\n+}  ;\n+\n+\n+/* -- note that some moves are tremendously expensive, \n+   because they require lots of tricks? do we have to \n+   charge the costs incurred by secondary reload class \n+   -- as we do here with 22 -- or not ? */\n+\n+int \n+register_move_cost(c1, c2)\n+  enum reg_class c1, c2;\n+{\n+    return move_costs[(int)c1][(int)c2];\n+}\n+\n+char *\n+output_jump(pos, neg, length)\n+  int length;\n+  char *pos, *neg;\n+{\n+    static int x = 0;\n+    \n+    static char buf[1000];\n+\n+#if 0\n+/* currently we don't need this, because the tstdf and cmpdf \n+   copy the condition code immediately, and other float operations are not \n+   yet recognized as changing the FCC - if so, then the length-cost of all\n+   jump insns increases by one, because we have to potentially copy the \n+   FCC! */\n+    if (cc_status.flags & CC_IN_FPU)\n+\toutput_asm_insn(\"cfcc\", NULL);\n+#endif\n+\t\n+    switch (length)\n+    {\n+      case 1:\n+\t\n+\tstrcpy(buf, pos);\n+\tstrcat(buf, \" %l0\");\n+\t\n+\treturn buf;\n+\t\n+      case 3:\n+\t\n+\tsprintf(buf, \"%s JMP_%d\\n\\tjmp %%l0\\nJMP_%d:\", neg, x, x);\n+\t\n+\tx++;\n+\t\n+\treturn buf;\n+\t\n+      default:\n+\t\n+\tabort();\n+    }\n+    \n+}\n+\n+void\n+notice_update_cc_on_set(exp, insn)\n+  rtx exp;\n+  rtx insn;\n+{\n+    if (GET_CODE (SET_DEST (exp)) == CC0)\n+    { \n+\tcc_status.flags = 0;\t\t\t\t\t\n+\tcc_status.value1 = SET_DEST (exp);\t\t\t\n+\tcc_status.value2 = SET_SRC (exp);\t\t\t\n+\n+/*\n+\tif (GET_MODE(SET_SRC(exp)) == DFmode)\n+\t    cc_status.flags |= CC_IN_FPU;\n+*/\t\n+    }\t\t\t\t\t\t\t\n+    else if ((GET_CODE (SET_DEST (exp)) == REG\t\t\n+\t      || GET_CODE (SET_DEST (exp)) == MEM)\t\t\n+\t     && GET_CODE (SET_SRC (exp)) != PC\t\t\n+\t     && (GET_MODE (SET_DEST(exp)) == HImode\t\t\n+\t\t || GET_MODE (SET_DEST(exp)) == QImode)\t\n+\t\t&& (GET_CODE (SET_SRC(exp)) == PLUS\t\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == MINUS\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == AND\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == IOR\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == XOR\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == NOT\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == NEG\t\n+\t\t\t|| GET_CODE (SET_SRC(exp)) == REG\t\n+\t\t    || GET_CODE (SET_SRC(exp)) == MEM))\t\n+    { \n+\tcc_status.flags = 0;\t\t\t\t\t\n+\tcc_status.value1 = SET_SRC (exp);   \t\t\t\n+\tcc_status.value2 = SET_DEST (exp);\t\t\t\n+\t\n+\tif (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\n+\t    && cc_status.value2\t\t\t\t\t\n+\t    && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n+    \t    cc_status.value2 = 0;\t\t\t\t\t\n+\tif (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\n+\t    && cc_status.value2\t\t\t\t\t\n+\t    && GET_CODE (cc_status.value2) == MEM)\t\t\t\n+\t    cc_status.value2 = 0; \t\t\t\t\t\n+    }\t\t\t\t\t\t\t\n+    else if (GET_CODE (SET_SRC (exp)) == CALL)\t\t\n+    { \n+\tCC_STATUS_INIT; \n+    }\n+    else if (GET_CODE (SET_DEST (exp)) == REG)       \t\t\n+\t/* what's this ? */\t\t\t\t\t\n+    { \n+\tif ((cc_status.value1\t\t\t\t\t\n+\t     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1)))\n+\t    cc_status.value1 = 0;\t\t\t\t\n+\tif ((cc_status.value2\t\t\t\t\t\n+\t     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2)))\n+\t    cc_status.value2 = 0;\t\t\t\t\n+    }\t\t\t\t\t\t\t\n+    else if (SET_DEST(exp) == pc_rtx)\n+    { \n+\t/* jump */\n+    }\n+    else /* if (GET_CODE (SET_DEST (exp)) == MEM)\t*/\t\n+    {  \n+\t/* the last else is a bit paranoic, but since nearly all instructions \n+\t   play with condition codes, it's reasonable! */\n+\n+\tCC_STATUS_INIT; /* paranoia*/ \n+    }\t\t        \n+}\n+\n+\n+int simple_memory_operand(op, mode)\n+  rtx op;\n+  enum machine_mode mode;\n+{\n+    rtx addr, plus0, plus1;\n+    int offset = 0;\n+\n+    /* Eliminate non-memory operations */\n+    if (GET_CODE (op) != MEM)\n+\treturn FALSE;\n+\n+#if 0\n+    /* dword operations really put out 2 instructions, so eliminate them.  */\n+    if (GET_MODE_SIZE (GET_MODE (op)) > (HAVE_64BIT_P () ? 8 : 4))\n+\treturn FALSE;\n+#endif\n+\n+    /* Decode the address now.  */\n+\n+  indirection:\n+    \n+    addr = XEXP (op, 0);\n+\n+    switch (GET_CODE (addr))\n+    {\n+      case REG:\n+\t/* (R0) - no extra cost */\n+\treturn 1;\n+\t\n+      case PRE_DEC:\n+      case POST_INC:\n+\t/* -(R0), (R0)+ - cheap! */\n+\treturn 0;\n+\t\n+      case MEM:\n+\t/* cheap - is encoded in addressing mode info! \n+\n+\t   -- except for @(R0), which has to be @0(R0) !!! */\n+\n+\tif (GET_CODE (XEXP (addr, 0)) == REG)\n+\t    return 0;\n+\t\n+\top=addr;\n+\tgoto indirection;\n+\t\n+      case CONST_INT:\n+      case LABEL_REF:\t       \n+      case CONST:\n+      case SYMBOL_REF:\n+\t/* @#address - extra cost */\n+\treturn 0;\n+\n+      case PLUS:\n+\t/* X(R0) - extra cost */\n+\treturn 0;\n+    }\n+    \n+    return FALSE;\n+}\n+\n+\n+/*\n+ * output a block move:\n+ *\n+ * operands[0]\t... to\n+ * operands[1]  ... from\n+ * operands[2]  ... length\n+ * operands[3]  ... alignment\n+ * operands[4]  ... scratch register\n+ */\n+\n+ \n+char *\n+output_block_move(operands)\n+  rtx *operands;\n+{\n+    static int count = 0;\n+    char buf[200];\n+    \n+    if (GET_CODE(operands[2]) == CONST_INT\n+\t&& TARGET_TIME)\n+    {\n+\tif (INTVAL(operands[2]) < 16\n+\t    && INTVAL(operands[3]) == 1)\n+\t{\n+\t    register int i;\n+\t    \n+\t    for (i = 1; i <= INTVAL(operands[2]); i++)\n+\t\toutput_asm_insn(\"movb (%1)+, (%0)+\", operands);\n+\n+\t    return \"\";\n+\t}\n+\telse if (INTVAL(operands[2]) < 32)\n+\t{\n+\t    register int i;\n+\t    \n+\t    for (i = 1; i <= INTVAL(operands[2])/2; i++)\n+\t\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\t    \n+\t    /* may I assume that moved quantity is \n+\t       multiple of alignment ???\n+\n+\t       I HOPE SO !\n+\t    */\n+\n+\t    return \"\";\n+\t}\n+\t\n+\n+\t/* can do other clever things, maybe... */\n+    }\n+\n+    if (CONSTANT_P(operands[2]) )\n+    {\n+\t/* just move count to scratch */\n+\toutput_asm_insn(\"mov %2, %4\", operands);\n+    }\n+    else\n+    {\n+\t/* just clobber the register */\n+\toperands[4] = operands[2];\n+    }\n+    \n+\n+    /* switch over alignment */\n+    switch (INTVAL(operands[3]))\n+    {\n+      case 1:\n+\t\n+\t/* \n+\t  x:\n+\t  movb (%1)+, (%0)+\n+\t  \n+\t  if (TARGET_45)\n+\t     sob %4,x\n+\t  else\n+\t     dec %4\n+\t     bgt x\n+\n+\t*/\n+\n+\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n+\toutput_asm_insn(buf, NULL);\n+\t\n+\toutput_asm_insn(\"movb (%1)+, (%0)+\", operands);\n+\t\n+\tif (TARGET_45)\n+\t{\n+\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n+\t    output_asm_insn(buf, operands);\n+\t}\n+\telse\n+\t{\n+\t    output_asm_insn(\"dec %4\", operands);\n+\t    \n+\t    sprintf(buf, \"bgt movestrhi%d\", count);\n+\t    output_asm_insn(buf, NULL);\n+\t}\n+\t\n+\tcount ++;\n+\tbreak;\n+\t\n+      case 2:\n+\t\n+\t/* \n+\t   asr %4\n+\n+\t   x:\n+\n+\t   mov (%1)+, (%0)+\n+\n+\t   if (TARGET_45)\n+\t     sob %4, x\n+\t   else\n+\t     dec %4\n+\t     bgt x\n+\t*/\n+\n+      generate_compact_code:\n+\n+\toutput_asm_insn(\"asr %4\", operands);\n+\n+\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n+\toutput_asm_insn(buf, NULL);\n+\t\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\t\n+\tif (TARGET_45)\n+\t{\n+\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n+\t    output_asm_insn(buf, operands);\n+\t}\n+\telse\n+\t{\n+\t    output_asm_insn(\"dec %4\", operands);\n+\t    \n+\t    sprintf(buf, \"bgt movestrhi%d\", count);\n+\t    output_asm_insn(buf, NULL);\n+\t}\n+\t\n+\tcount ++;\n+\tbreak;\n+\n+      case 4:\n+\t\n+\t/*\n+\n+\t   asr %4\n+\t   asr %4\n+\n+\t   x:\n+\n+\t   mov (%1)+, (%0)+\n+\t   mov (%1)+, (%0)+\n+\n+\t   if (TARGET_45)\n+\t     sob %4, x\n+\t   else\n+\t     dec %4\n+\t     bgt x\n+\t*/\n+\n+\tif (TARGET_SPACE)\n+\t    goto generate_compact_code;\n+\t\n+\toutput_asm_insn(\"asr %4\", operands);\n+\toutput_asm_insn(\"asr %4\", operands);\n+\n+\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n+\toutput_asm_insn(buf, NULL);\n+\t\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\t\n+\tif (TARGET_45)\n+\t{\n+\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n+\t    output_asm_insn(buf, operands);\n+\t}\n+\telse\n+\t{\n+\t    output_asm_insn(\"dec %4\", operands);\n+\t    \n+\t    sprintf(buf, \"bgt movestrhi%d\", count);\n+\t    output_asm_insn(buf, NULL);\n+\t}\n+\t\n+\tcount ++;\n+\tbreak;\n+       \n+      default:\n+\t\n+\t/*\n+\t   \n+\t   asr %4\n+\t   asr %4\n+\t   asr %4\n+\n+\t   x:\n+\n+\t   mov (%1)+, (%0)+\n+\t   mov (%1)+, (%0)+\n+\t   mov (%1)+, (%0)+\n+\t   mov (%1)+, (%0)+\n+\t   \n+\t   if (TARGET_45)\n+\t     sob %4, x\n+\t   else\n+\t     dec %4\n+\t     bgt x\n+\t*/\n+\n+\n+\tif (TARGET_SPACE)\n+\t    goto generate_compact_code;\n+\t\n+\toutput_asm_insn(\"asr %4\", operands);\n+\toutput_asm_insn(\"asr %4\", operands);\n+\toutput_asm_insn(\"asr %4\", operands);\n+\n+\tsprintf(buf, \"\\nmovestrhi%d:\", count);\n+\toutput_asm_insn(buf, NULL);\n+\t\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn(\"mov (%1)+, (%0)+\", operands);\n+\t\n+\tif (TARGET_45)\n+\t{\n+\t    sprintf(buf, \"sob %%4, movestrhi%d\", count);\n+\t    output_asm_insn(buf, operands);\n+\t}\n+\telse\n+\t{\n+\t    output_asm_insn(\"dec %4\", operands);\n+\t    \n+\t    sprintf(buf, \"bgt movestrhi%d\", count);\n+\t    output_asm_insn(buf, NULL);\n+\t}\n+\t\n+\tcount ++;\n+\tbreak;\n+\t\n+\t;\n+\t\n+    }\n+    \n+    return \"\";\n+}\n+\n+/* for future use */\n+int\n+comparison_operator_index(op)\n+  rtx op;\n+{\n+    switch (GET_CODE(op))\n+    {\n+      case NE:\n+\treturn 0;\n+\t\n+      case EQ:\n+\treturn 1;\n+\t\n+      case GE:\n+\treturn 2;\n+\t\n+      case GT:\n+\treturn 3;\n+\t\n+      case LE:\n+\treturn 4;\n+\t\n+      case LT:\n+\treturn 5;\n+\t\n+      case GEU:\n+\treturn 6;\n+\t\n+      case GTU:\n+\treturn 7;\n+\n+      case LEU:\n+\treturn 8;\n+\t\n+      case LTU:\n+\treturn 9;\n+\t\n+      default:\n+\treturn -1;\n+    }\n+}    \n+\t\n+/* tests whether the rtx is a comparison operator */\n+int\n+comp_operator (op, mode)\n+  rtx op;\n+  enum machine_mode mode;\n+{\n+    return comparison_operator_index(op) >= 0;\n+}\n+\n+    \n+int\n+legitimate_address_p (mode, address)\n+  enum machine_mode mode;\n+  rtx address;\n+{\n+/* #define REG_OK_STRICT */\n+    GO_IF_LEGITIMATE_ADDRESS(mode, address, win);\n+    \n+    return 0;\n+    \n+  win:\n+    return 1;\n+\n+/* #undef REG_OK_STRICT */\n+}"}, {"sha": "4ae42034c4559b0ced0e90df50c838a0fbde0f9b", "filename": "gcc/config/pdp11/pdp11.h", "status": "added", "additions": 1367, "deletions": 0, "changes": 1367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=2c9c2489771b9b4ec491910204ef392b8c6767c1", "patch": "@@ -0,0 +1,1367 @@\n+/* Definitions of target machine for GNU compiler, for the pdp-11\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* declarations */\n+char *output_jump();\n+char *output_move_double();\n+char *output_move_quad();\n+char *output_block_move();\n+\n+/* check whther load_fpu_reg or not */\n+#define LOAD_FPU_REG_P(x) ((x)>=8 && (x)<=11)\n+#define NO_LOAD_FPU_REG_P(x) ((x)==12 || (x)==13)\n+#define FPU_REG_P(x)\t(LOAD_FPU_REG_P(x) || NO_LOAD_FPU_REG_P(x))\n+#define CPU_REG_P(x)\t((x)<8)\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dpdp11\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (pdp11)\");\n+\n+\n+/* Generate DBX debugging information.  */\n+\n+/* #define DBX_DEBUGGING_INFO */\n+\n+/* Run-time compilation parameters selecting different hardware subsets.\n+*/\n+\n+extern int target_flags;\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+{   { \"fpu\", 1},\t\t\\\n+    { \"soft-float\", -1},       \t\\\n+/* return float result in ac0 */\\\n+    { \"ac0\", 2},\t\t\\\n+    { \"no-ac0\", -2},\t\t\\\n+/* is 11/40 */\t\t\t\\\n+    { \"40\", 4},\t\t\t\\\n+    { \"no-40\", -4},\t\t\\\n+/* is 11/45 */\t\t\t\\\n+    { \"45\", 8},\t\t\t\\\n+    { \"no-45\", -8},\t\t\\\n+/* is 11/10 */\t\t\t\\\n+    { \"10\", -12},\t\t\\\n+/* use movstrhi for bcopy */\t\\\n+    { \"bcopy\", 16},\t\t\\\n+    { \"bcopy-builtin\", -16},\t\\\n+/* use 32 bit for int */\t\\\n+    { \"int32\", 32},\t\t\\\n+    { \"no-int16\", 32},\t\t\\\n+    { \"int16\", -32},\t\t\\\n+    { \"no-int32\", -32},\t\t\\\n+/* use 32 bit for float */\t\\\n+    { \"float32\", 64},\t\t\\\n+    { \"no-float64\", 64},\t\\\n+    { \"float64\", -64},\t\t\\\n+    { \"no-float32\", -64},\t\\\n+/* allow abshi pattern? - can trigger \"optimizations\" which make code SLOW! */\\\n+    { \"abshi\", 128},\t\t\\\n+    { \"no-abshi\", -128},\t\\\n+/* is branching expensive - on a PDP, it's actually really cheap */ \\\n+/* this is just to play aroound and check what code gcc generates */ \\\n+    { \"branch-expensive\", 256}, \\\n+    { \"branch-cheap\", -256},\t\\\n+/* optimize for space instead of time - just in a couple of places */ \\\n+    { \"space\", 512 },\t\t\\\n+    { \"time\", -512 },\t\t\\\n+/* default */\t\t\t\\\n+    { \"\", TARGET_DEFAULT}\t\\\n+}\n+\n+#define TARGET_DEFAULT (1 | 8 | 128)\n+\n+#define TARGET_FPU \t\t(target_flags & 1)\n+#define TARGET_SOFT_FLOAT \t(!TARGET_FPU)\n+\n+#define TARGET_AC0\t\t((target_flags & 2) && TARGET_FPU)\n+#define TARGET_NO_AC0\t\t(! TARGET_AC0)\n+\n+#define TARGET_45\t\t(target_flags & 8)\n+#define TARGET_40_PLUS\t\t((target_flags & 4) || (target_flags))\n+#define TARGET_10\t\t(! TARGET_40_PLUS)\n+\n+#define TARGET_BCOPY_BUILTIN\t(! (target_flags & 16))\n+\n+#define TARGET_INT16\t\t(! TARGET_INT32)\n+#define TARGET_INT32\t\t(target_flags & 32)\n+\n+#define TARGET_FLOAT32\t\t(target_flags & 64)\n+#define TARGET_FLOAT64\t\t(! TARGET_FLOAT32)\n+\n+#define TARGET_ABSHI_BUILTIN\t(target_flags & 128)\n+\n+#define TARGET_BRANCH_EXPENSIVE\t(target_flags & 256)\n+#define TARGET_BRANCH_CHEAP \t(!TARGET_BRANCH_EXPENSIVE)\n+\n+#define TARGET_SPACE \t\t(target_flags & 512)\n+#define TARGET_TIME\t\t(! TARGET_SPACE)\n+\f\n+\n+/* TYPE SIZES */\n+#define CHAR_TYPE_SIZE\t\t8\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t(TARGET_INT16 ? 16 : 32)\n+#define LONG_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64     \n+\n+/* if we set FLOAT_TYPE_SIZE to 32, we could have the benefit \n+   of saving core for huge arrays - the definitions are \n+   already in md - but floats can never reside in \n+   an FPU register - we keep the FPU in double float mode \n+   all the time !! */\n+#define FLOAT_TYPE_SIZE\t\t(TARGET_FLOAT32 ? 32 : 64)\n+#define DOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* machine types from ansi */\n+#define SIZE_TYPE \"unsigned int\" \t/* definition of size_t */\n+\n+/* is used in cexp.y - we don't have target_flags there, \n+   so just give default definition \n+\n+   hope it does not come back to haunt us! */\n+#define WCHAR_TYPE \"int\" \t\t/* or long int???? */\n+#define WCHAR_TYPE_SIZE 16\n+\n+#define PTRDIFF_TYPE \"int\"\n+\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is numbered.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+/*  This is a machine with 16-bit registers */\n+#define BITS_PER_WORD 16\n+\n+/* Width of a word, in units (bytes). \n+\n+   UNITS OR BYTES - seems like units */\n+#define UNITS_PER_WORD 2\n+\n+/* Maximum sized of reasonable data type \n+   DImode or Dfmode ...*/\n+#define MAX_FIXED_MODE_SIZE 64\t\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 16\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY 16\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 16\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 16\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 16\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   we have 8 integer registers, plus 6 float \n+   (don't use scratch float !) */\n+\n+#define FIRST_PSEUDO_REGISTER 14\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On the pdp, these are:\n+   Reg 7\t= pc;\n+   reg 6\t= sp;\n+   reg 5\t= fp;  not necessarily! \n+*/\n+\n+/* don't let them touch fp regs for the time being !*/\n+\n+#define FIXED_REGISTERS  \\\n+{0, 0, 0, 0, 0, 0, 1, 1, \\\n+ 0, 0, 0, 0, 0, 0     }\n+\n+\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+/* don't know about fp */\n+#define CALL_USED_REGISTERS  \\\n+{1, 1, 0, 0, 0, 0, 1, 1, \\\n+ 0, 0, 0, 0, 0, 0 }\n+\n+\n+/* Make sure everything's fine if we *don't* have an FPU.\n+   This assumes that putting a register in fixed_regs will keep the\n+   compiler's mitts completely off it.  We don't bother to zero it out\n+   of register classes.  \n+*/\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{ \t\t\t\t\t\t\\\n+  int i; \t\t\t\t\t\\\n+  HARD_REG_SET x; \t\t\t\t\\\n+  if (!TARGET_FPU)\t\t\t\t\\\n+    { \t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPU_REGS]); \\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    } \t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+  if (TARGET_AC0)\t\t\t\t\\\n+      call_used_regs[8] = 1;\t\t\t\\\n+}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+*/\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+((REGNO < 8)?\t\t\t\t\t\t\t\t\\\n+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\t\\\n+    :1)\n+    \n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the pdp, the cpu registers can hold any mode - check alignment\n+\n+   FPU can only hold DF - simplifies life!\n+*/\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+((REGNO < 8)?\t\t\t\t\t\t\\\n+  ((GET_MODE_BITSIZE(MODE) <= 16) \t\t\t\\\n+   || (GET_MODE_BITSIZE(MODE) == 32 && !(REGNO & 1)))\t\\\n+  :(MODE) == DFmode)\n+    \n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 0\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* the pdp11 pc overloaded on a register that the compiler knows about.  */\n+#define PC_REGNUM  7\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 6\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 5\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.\n+  */\n+\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 5\n+\n+/* Register in which static-chain is passed to a function.  */\n+/* ??? - i don't want to give up a reg for this! */\n+#define STATIC_CHAIN_REGNUM 4\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  \n+   let's make it an invisible first argument!!! */\n+\n+#define STRUCT_VALUE 0\n+\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The pdp has a couple of classes:\n+\n+MUL_REGS are used for odd numbered regs, to use in 16 bit multiplication\n+         (even numbered do 32 bit multiply)\n+LMUL_REGS long multiply registers (even numbered regs )\n+\t  (don't need them, all 32 bit regs are even numbered!)\n+GENERAL_REGS is all cpu\n+LOAD_FPU_REGS is the first four cpu regs, they are easier to load\n+NO_LOAD_FPU_REGS is ac4 and ac5, currently - difficult to load them\n+FPU_REGS is all fpu regs \n+*/\n+\n+enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REGS, FPU_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* have to allow this till cmpsi/tstsi are fixed in a better way !! */\n+#define SMALL_REGISTER_CLASSES \n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS,\n+   don't give it a different class number; just make it an alias.  */\n+\n+/* #define GENERAL_REGS ALL_REGS */\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES {\"NO_REGS\", \"MUL_REGS\", \"GENERAL_REGS\", \"LOAD_FPU_REGS\", \"NO_LOAD_FPU_REGS\", \"FPU_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x00aa, 0x00ff, 0x0f00, 0x3000, 0x3f00, 0x3fff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \t\t\\\n+((REGNO)>=8?((REGNO)<=11?LOAD_FPU_REGS:NO_LOAD_FPU_REGS):((REGNO&1)?MUL_REGS:GENERAL_REGS))\n+\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\\\n+((C) == 'f' ? FPU_REGS :\t\t\t\\\n+  ((C) == 'd' ? MUL_REGS : \t\t\t\\\n+   ((C) == 'a' ? LOAD_FPU_REGS : NO_REGS)))\n+    \n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   I\t\tbits 31-16 0000\n+   J\t\tbits 15-00 0000\n+   K\t\tcompletely random 32 bit\n+   L,M,N\t-1,1,0 respectively\n+   O \t\twhere doing shifts in sequence is faster than \n+                one big shift \n+*/\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? ((VALUE) & 0xffff0000) == 0\t\t\\\n+   : (C) == 'J' ? ((VALUE) & 0x0000ffff) == 0  \t       \t\\\n+   : (C) == 'K' ? (((VALUE) & 0xffff0000) != 0\t\t\\\n+\t\t   && ((VALUE) & 0x0000ffff) != 0)\t\\\n+   : (C) == 'L' ? ((VALUE) == 1)\t\t\t\\\n+   : (C) == 'M' ? ((VALUE) == -1)\t\t\t\\\n+   : (C) == 'N' ? ((VALUE) == 0)\t\t\t\\\n+   : (C) == 'O' ? (abs(VALUE) >1 && abs(VALUE) <= 4)\t\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' && XINT (VALUE, 0) == 0 && XINT (VALUE, 1) == 0)\n+\n+\n+/* Letters in the range `Q' through `U' may be defined in a\n+   machine-dependent fashion to stand for arbitrary operand types. \n+   The machine description macro `EXTRA_CONSTRAINT' is passed the\n+   operand as its first argument and the constraint letter as its\n+   second operand.\n+\n+   `Q'\tis for memory refereces using take more than 1 instruction.\n+   `R'\tis for memory refereces which take 1 word for the instruction.  */\n+\n+#define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n+  ((GET_CODE (OP) != MEM) ? 0\t\t\t\t\t\t\\\n+   : !legitimate_address_p (GET_MODE (OP), XEXP (OP, 0)) ? 0\t\t\\\n+   : ((CODE) == 'Q')\t  ? !simple_memory_operand (OP, GET_MODE (OP))\t\\\n+   : ((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  \n+\n+loading is easier into LOAD_FPU_REGS than FPU_REGS! */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \t\\\n+(((CLASS) != FPU_REGS)?(CLASS):LOAD_FPU_REGS)\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,x)\t\\\n+(((CLASS) == NO_LOAD_FPU_REGS && !(REG_P(x) && LOAD_FPU_REG_P(REGNO(x))))?LOAD_FPU_REGS:NO_REGS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+((CLASS == GENERAL_REGS || CLASS == MUL_REGS)?\t\t\t\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD):\t\\\n+  1\t\t\t\t\t\t\t\t\t\\\n+)\n+\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.\n+*/\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the pdp11, the stack is on an even boundary */\n+#define PUSH_ROUNDING(BYTES) ((BYTES + 1) & ~1)\n+\n+/* current_first_parm_offset stores the # of registers pushed on the \n+   stack */\n+extern int current_first_parm_offset;\n+\n+/* Offset of first parameter from the argument pointer register value.  \n+   For the pdp11, this is non-zero to account for the return address.\n+\t1 - return address\n+\t2 - frame pointer (always saved, even when not used!!!!)\n+\t\t-- chnage some day !!!:q!\n+\n+*/\n+#define FIRST_PARM_OFFSET(FNDECL) 4\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define BASE_RETURN_VALUE_REG(MODE) \\\n+ ((MODE) == DFmode ? 8 : 0) \n+\n+/* On the pdp11 the value is found in R0 (or ac0??? \n+not without FPU!!!! ) */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))\n+\n+/* and the called function leaves it in the first register.\n+   Difference only on machines with register windows.  */\n+\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG(TYPE_MODE(VALTYPE)))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, BASE_RETURN_VALUE_REG(MODE))\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+   On the pdp, the first \"output\" reg is the only register thus used. \n+\n+maybe ac0 ? - as option someday! */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) (((N) == 0) || (TARGET_AC0 && (N) == 8))\n+\n+/* should probably return DImode and DFmode in memory,lest\n+   we fill up all regs!\n+\n+ have to, else we crash - exceptio: maybe return result in \n+ ac0 if DFmode and FPU present - compatibility problem with\n+ libraries for non-floating point ...\n+*/\n+\n+#define RETURN_IN_MEMORY(TYPE)\t\\\n+  (TYPE_MODE(TYPE) == DImode || (TYPE_MODE(TYPE) == DFmode && ! TARGET_AC0))\n+\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   - not used on pdp */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+*/\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   ...., the offset normally starts at 0, but starts at 1 word\n+   when the function gets a structure-value-address as an\n+   invisible first argument.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  \n+\n+*/\n+\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE))\t\t\\\n+\t    : (int_size_in_bytes (TYPE))))\t\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)  0\n+\n+/* Define where a function finds its arguments.\n+   This would be different from FUNCTION_ARG if we had register windows.  */\n+/*\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+  FUNCTION_ARG (CUM, MODE, TYPE, NAMED)\n+*/\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* This macro generates the assembly code for function entry. */\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+    output_function_prologue(FILE, SIZE);\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   abort ();\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+extern int may_call_alloca;\n+extern int current_function_pretend_args_size;\n+\n+#define EXIT_IGNORE_STACK\t1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+*/\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+    output_function_epilogue(FILE, SIZE);\n+  \n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  int offset, regno;\t\t      \t\t\t\t\\\n+  offset = get_frame_size();\t\t\t\t\t\\\n+  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      offset += 2;\t\t\t\t\t\t\\\n+  for (regno = 8; regno < 14; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      offset += 8;\t\t\t\t\t\t\\\n+  /* offset -= 2;   no fp on stack frame */\t\t\t\\\n+  (DEPTH_VAR) = offset;\t\t\t\t\t\t\\\n+}   \n+    \n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT\n+/* #define HAVE_POST_DECREMENT */\n+\n+#define HAVE_PRE_DECREMENT\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+  ((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+  ((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+*/\n+\n+\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) (1)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) (1)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (1)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+*/\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR) \\\n+{\t\t\t\t\t\t      \\\n+    rtx xfoob;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept (R0) */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (operand) == REG\t\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P(operand))\t\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept @#address */\t\t\t\t\t\t\\\n+    if (CONSTANT_ADDRESS_P (operand))\t\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    /* accept X(R0) */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (operand) == PLUS       \t\t\t\t\\\n+\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P (XEXP (operand, 0))\t\t\t\\\n+\t&& CONSTANT_ADDRESS_P (XEXP (operand, 1)))\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    /* accept -(R0) */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (operand) == PRE_DEC\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept (R0)+ */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (operand) == POST_INC\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    /* handle another level of indirection ! */\t\t\t\t\\\n+    if (GET_CODE(operand) != MEM)\t\t\t\t\t\\\n+      goto fail;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    xfoob = XEXP (operand, 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* (MEM:xx (MEM:xx ())) is not valid for SI, DI and currently */    \\\n+    /* also forbidden for float, because we have to handle this */  \t\\\n+    /* in output_move_double and/or output_move_quad() - we could */   \t\\\n+    /* do it, but currently it's not worth it!!! */\t\t\t\\\n+    /* now that DFmode cannot go into CPU register file, */\t\t\\\n+    /* maybe I should allow float ... */\t\t\t\t\\\n+    /*  but then I have to handle memory-to-memory moves in movdf ?? */ \\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE_BITSIZE(mode) > 16)\t\t\t\t\t\\\n+      goto fail;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept @(R0) - which is @0(R0) */\t\t\t\t\\\n+    if (GET_CODE (xfoob) == REG\t\t\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P(xfoob))\t\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept @address */\t\t\t\t\t\t\\\n+    if (CONSTANT_ADDRESS_P (xfoob))\t\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    /* accept @X(R0) */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (xfoob) == PLUS       \t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0))\t\t\t\t\\\n+\t&& CONSTANT_ADDRESS_P (XEXP (xfoob, 1)))\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept @-(R0) */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (xfoob) == PRE_DEC\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0)))\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* accept @(R0)+ */\t\t\t\t\t\t\t\\\n+    if (GET_CODE (xfoob) == POST_INC\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n+\t&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0)))\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* anything else is illegal */\t\t\t\t\t\\\n+  fail: ;\t\t\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t{}\n+\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the the pdp this is for predec/postinc */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n+     goto LABEL; \t\t\t\t\t\t\t\\\n+ }\n+\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE HImode\n+\n+/* Define this if a raw index is all that is needed for a\n+   `tablejump' insn.  */\n+#define CASE_TAKES_INDEX_RAW\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  \n+*/\n+\n+#define MOVE_MAX 2\n+\n+/* Zero extension is faster if the target is known to be zero */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by byte is slow and undesirable. -\n+*/\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   CCFPmode is used for FPU, but should we use a separate reg? */\n+#define EXTRA_CC_MODES CCFPmode\n+\n+/* the name for the mode above */\n+#define EXTRA_CC_NAMES \"CCFPmode\"\n+\n+/* Give a comparison code (EQ, NE etc) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  For floating-point, CCFPmode\n+   should be used. */\n+\n+#define SELECT_CC_MODE(OP,X,Y)\t\\\n+(GET_MODE_CLASS(GET_MODE(X)) == MODE_FLOAT? CCFPmode : CCmode)\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+/* #define STORE_FLAG_VALUE 1 */\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode HImode\n+\n+/* A function address in a call instruction\n+   is a word address (for indexing purposes)\n+   so give the MEM rtx a word's mode.  */\n+#define FUNCTION_MODE HImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+/* #define NO_FUNCTION_CSE */\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch. \n+\n+   -1, 0, 1 are cheaper for add, sub ... \n+*/\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL(RTX) == 0\t\t\t\t\t\\\n+\t|| INTVAL(RTX) == -1\t\t\t\t\t\\\n+\t|| INTVAL(RTX) == 1)\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    /* twice as expensive as REG */\t\t\t\t\\\n+    return 2;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    /* twice (or 4 times) as expensive as 16 bit */\t\t\\\n+    return 4;\n+\f\n+/* cost of moving one register class to another */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) register_move_cost(CLASS1, CLASS2)\n+\n+/* Tell emit-rtl.c how to initialize special values on a per-function base.  */\n+extern int optimize;\n+extern struct rtx_def *cc0_reg_rtx;\n+\n+#define CC_STATUS_MDEP rtx\n+\n+#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+#define CC_IN_FPU 04000 \n+\n+/* Do UPDATE_CC if EXP is a set, used in\n+   NOTICE_UPDATE_CC \n+\n+   floats only do compare correctly, else nullify ...\n+\n+   get cc0 out soon ...\n+*/\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{ if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      notice_update_cc_on_set(EXP, INSN);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n+\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      notice_update_cc_on_set(XVECEXP (EXP, 0, 0), INSN);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (EXP) == CALL)\t\t\t\t\\\n+    { /* all bets are off */ CC_STATUS_INIT; }\t\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n+    printf (\"here!\\n\", cc_status.value2 = 0);\t\t\t\\\n+}\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#if 0\n+#define ASM_FILE_START(FILE) \\\n+(\t\t\t\t\t\t\t\t\\\n+fprintf (FILE, \"\\t.data\\n\"),\t\t\t\t\t\\\n+fprintf (FILE, \"$help$: . = .+8 ; space for tmp moves!\\n\")\t\\\n+/* do we need reg def's R0 = %0 etc ??? */\t\t\t\\\n+)\n+#else\n+#define ASM_FILE_START(FILE)\t(0)\n+#endif\n+\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\\n\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\\n\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"fp\", \"sp\", \"pc\",     \\\n+ \"ac0\", \"ac1\", \"ac2\", \"ac3\", \"ac4\", \"ac5\" }\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.globl \", FILE); assemble_name (FILE, NAME); fputs(\"\\n\", FILE); } while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s_%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s_%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tdouble %.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tfloat %.12e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `short' and `char' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \" /*short*/\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \" /* char */\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.-\n+\n+   do we really NEED it ? let's output it with a comment and grep the \n+   assembly source ;-)\n+*/\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n+  output_ascii (FILE, P, SIZE)\n+\n+#define ASM_OUTPUT_ADDR_VEC_PROLOGUE(FILE, MODE, LEN)\t\\\n+  fprintf (FILE, \"\\t/* HELP! */\\n\");\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word L_%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (the pdp does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\tERROR @L%d-@L%d ! error should not be used\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes. \n+\n+   who needs this????\n+*/\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", 1<<(LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.=.+ %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fprintf ((FILE), \".globl \"),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \"\\n\"),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \": .=.+ %d\\n\", (ROUNDED))\t\t\\\n+)\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( assemble_name ((FILE), (NAME)),\t\t\t\t\\\n+  fprintf ((FILE), \":\\t.=.+ %d\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+*/\n+\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '#') fprintf (FILE, \"#\");\t\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != SImode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"#%.20e\", u.d); }\t\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+ print_operand_address (FILE, ADDR)\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\\\n+(\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tmov %s, -(sp)\\n\", reg_names[REGNO])\t\\\n+)\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)                 \t\t\\\n+(                                                       \t\\\n+  fprintf (FILE, \"\\tmov (sp)+, %s\\n\", reg_names[REGNO])     \t\\\n+)\n+\n+\n+#define ASM_IDENTIFY_GCC(FILE)\t\t\t\\\n+    fprintf(FILE, \"gcc_compiled:\\n\")\n+\n+#define ASM_OUTPUT_DOUBLE_INT(a,b)\tfprintf(a,\"%d\", b)\n+\n+/* trampoline - how should i do it in separate i+d ? */\n+#define TRAMPOLINE_SIZE 0\n+\n+#define INITIALIZE_TRAMPOLINE(x,y,z)\t\\\n+{\t\t\t\t\t\\\n+abort();\t\t\t\t\\\n+}\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\\\n+{\t\t\t\t\t\\\n+abort();\t\t\t\t\\\n+}\n+\n+/* Some machines may desire to change what optimizations are\n+   performed for various optimization levels.   This macro, if\n+   defined, is executed once just after the optimization level is\n+   determined and before the remainder of the command options have\n+   been parsed.  Values set in this macro are used as the default\n+   values for the other command line options.\n+\n+   LEVEL is the optimization level specified; 2 if -O2 is\n+   specified, 1 if -O is specified, and 0 if neither is specified.  */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (LEVEL >= 3)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      flag_inline_functions\t\t= 1;\t\t\t\t\\\n+      flag_omit_frame_pointer\t\t= 1;\t\t\t\t\\\n+      /* flag_unroll_loops\t\t\t= 1; */\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+\n+   we don't say how expensive SImode is - pretty expensive!!!\n+\n+   there is something wrong in MULT because MULT is not \n+   as cheap as total = 2 even if we can shift!\n+\n+   if TARGET_SPACE make mult etc cheap, but not 1, so when \n+   in doubt the faster insn is chosen.\n+*/\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE) \\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    if (TARGET_SPACE)\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS(2);\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS (11);\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\t\\\n+    if (TARGET_SPACE)\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS(2);\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS (25);\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\t\\\n+    if (TARGET_SPACE)\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS(2);\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS (26);\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case ABS:\t\t\t\t\t\t\t\t\\\n+    /* equivalent to length, so same for TARGET_SPACE */\t\t\\\n+    total = COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n+    /* only used for: qi->hi */\t\t\t\t\t\t\\\n+    total = COSTS_N_INSNS(1);\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n+    if (GET_MODE(X) == HImode)\t\t\t\t\t\t\\\n+      \ttotal = COSTS_N_INSNS(1);\t\t\t\t\t\\\n+    else if (GET_MODE(X) == SImode)\t\t\t\t\t\\\n+\ttotal = COSTS_N_INSNS(6);\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+\tabort();\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  /* case LSHIFT: */\t\t       \t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\t\\\n+    if (TARGET_SPACE)\t\t\t\t\t\t\t\\\n+      total = COSTS_N_INSNS(1);\t\t\t\t\t\t\\\n+    else if (GET_MODE(X) ==  QImode)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE(XEXP (X,1)) != CONST_INT)\t\t\t\t\\\n+   \t  abort();\t\t\t\t\t\t\t\\\n+\ttotal = COSTS_N_INSNS(INTVAL(XEXP (X,1)));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    else if (GET_MODE(X) == HImode)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE(XEXP (X,1)) == CONST_INT)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (abs (INTVAL (XEXP (X, 1))) == 1)\t\t\t\t\\\n+          total = COSTS_N_INSNS(1);\t\t\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+\t  total = COSTS_N_INSNS(2.5 + 0.5 *INTVAL(XEXP(X,1)));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+      else /* worst case */\t\t\t\t\t\t\\\n+        total = COSTS_N_INSNS (10);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    else if (GET_MODE(X) == SImode)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE(XEXP (X,1)) == CONST_INT)\t\t\t\t\\\n+\t  total = COSTS_N_INSNS(2.5 + 0.5 *INTVAL(XEXP(X,1)));\t\t\\\n+      else /* worst case */\t\t\t\t\t\t\\\n+        total = COSTS_N_INSNS(18);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    break;\n+\n+\n+/* there is no point in avoiding branches on a pdp, \n+   since branches are really cheap - I just want to find out\n+   how much difference the BRANCH_COST macro makes in code */\n+#define BRANCH_COST (TARGET_BRANCH_CHEAP ? 0 : 1)\n+\n+\n+#define COMPARE_FLAG_MODE HImode\n+"}, {"sha": "f1fc810b76190d2b168acec537e66b9a783a266d", "filename": "gcc/config/pdp11/pdp11.md", "status": "added", "additions": 1958, "deletions": 0, "changes": 1958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=2c9c2489771b9b4ec491910204ef392b8c6767c1", "patch": "@@ -0,0 +1,1958 @@\n+;;- Machine description for the pdp11 for GNU C compiler\n+;; Copyright (C) 1994 Free Software Foundation, Inc.\n+;; Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 1, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;; HI is 16 bit\n+;; QI is 8 bit \n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;;- Operand classes for the register allocator:\n+\f\n+;; Compare instructions.\n+\n+;; currently we only support df floats, which saves us quite some\n+;; hassle switching the FP mode! \n+;; we assume that CPU is always in long float mode, and \n+;; 16 bit integer mode - currently, the prologue for main does this,\n+;; but maybe we should just set up a NEW crt0 properly, \n+;; -- and what about signal handling code?\n+;; (we don't even let sf floats in the register file, so\n+;; we only should have to worry about truncating and widening \n+;; when going to memory)\n+\n+;; abort() call by g++ - must define libfunc for cmp_optab\n+;; and ucmp_optab for mode SImode, because we don't have that!!!\n+;; - yet since no libfunc is there, we abort ()\n+\n+;; The only thing that remains to be done then is output \n+;; the floats in a way the assembler can handle it (and \n+;; if you're really into it, use a PDP11 float emulation\n+;; libary to do floating point constant folding - but \n+;; I guess you'll get reasonable results even when not\n+;; doing this)\n+;; the last thing to do is fix the UPDATE_CC macro to check\n+;; for floating point condition codes, and set cc_status\n+;; properly, also setting the CC_IN_FCCR flag. \n+\n+;; define attributes\n+;; currently type is only fpu or arith or unknown, maybe branch later ?\n+;; default is arith\n+(define_attr \"type\" \"unknown,arith,fp\" (const_string \"arith\"))\n+\n+;; length default is 1 word each\n+(define_attr \"length\" \"\" (const_int 1))\n+\n+;; a users asm staement \n+(define_asm_attributes\n+  [(set_attr \"type\" \"unknown\")\n+; all bets are off how long it is - make it 256, forces long jumps \n+; whenever jumping around it !!!\n+   (set_attr \"length\" \"256\")])\n+\n+;; define function units\n+\n+;; arithmetic - values here immediately when next insn issued\n+;; or does it mean the number of cycles after this insn was issued?\n+;; how do I say that fpu insns use cpu also? (pre-interaction phase)\n+\n+;(define_function_unit \"cpu\" 1 1 (eq_attr \"type\" \"arith\") 0 0)\n+;(define_function_unit \"fpu\" 1 1 (eq_attr \"type\" \"fp\") 0 0)\n+\n+;; compare\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"general_operand\" \"fR,Q,F\")\n+\t\t (match_operand:DF 1 \"register_operand\" \"a,a,a\")))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FPU;\n+  return \\\"cmpd %0, %1\\;cfcc\\\";\n+}\"\n+  [(set_attr \"length\" \"2,3,6\")])\n+\n+;; a bit of brain damage, maybe inline later - \n+;; problem is - gcc seems to NEED SImode because \n+;; of the cmp weirdness - maybe change gcc to handle this?\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:SI 0)\n+\t(match_operand:SI 0 \"general_operand\" \"g\"))\n+   (set (reg:SI 2)\n+\t(match_operand:SI 1 \"general_operand\" \"g\"))\n+   (parallel [(set (cc0)\n+\t\t   (compare (reg:SI 0)\n+\t\t\t    (reg:SI 2)))\n+\t      (clobber (reg:SI 0))])]\n+  \"0\" ;; disable for test\n+  \"\")\n+\n+;; check for next insn for branch code - does this still\n+;; work in gcc 2.* ?\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (reg:SI 0)\n+\t\t (reg:SI 2)))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx br_insn = NEXT_INSN (insn);\n+  RTX_CODE br_code;\n+\n+  if (GET_CODE (br_insn) != JUMP_INSN)\n+    abort();\n+  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n+  \n+  switch(br_code)\n+  {\n+    case GEU:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+      \n+      return \\\"jsr pc, ___ucmpsi\\;cmp $1,r0\\\";\n+\n+    case GE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case EQ:\n+    case NE:\n+\n+      return \\\"jsr pc, ___cmpsi\\;tst r0\\\";\n+\n+    default:\n+\n+      abort();\n+  }\n+}\"\n+  [(set_attr \"length\" \"4\")])\n+\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"general_operand\" \"rR,rR,Qi,Qi\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+  \"\"\n+  \"cmp %0,%1\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"general_operand\" \"rR,rR,Qi,Qi\")\n+\t\t (match_operand:QI 1 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+  \"\"\n+  \"cmpb %0,%1\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\t\t\t   \n+\n+;; We have to have this because cse can optimize the previous pattern\n+;; into this one.\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"general_operand\" \"fR,Q\"))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FPU;\n+  return \\\"tstd %0\\;cfcc\\\";\n+}\"\n+  [(set_attr \"length\" \"2,3\")])\n+\n+\n+(define_expand \"tstsi\"\n+  [(set (reg:SI 0)\n+\t(match_operand:SI 0 \"general_operand\" \"g\"))\n+   (parallel [(set (cc0)\n+\t\t   (reg:SI 0))\n+\t      (clobber (reg:SI 0))])]\n+  \"0\" ;; disable for test\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(reg:SI 0))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  \"jsr pc, ___tstsi\\;tst r0\"\n+  [(set_attr \"length\" \"3\")])\n+\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"general_operand\" \"rR,Q\"))]\n+  \"\"\n+  \"tst %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"general_operand\" \"rR,Q\"))]\n+  \"\"\n+  \"tstb %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; sob instruction - we need an assembler which can make this instruction\n+;; valid under _all_ circumstances!\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (plus:HI (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t      (const_int -1))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"TARGET_40_PLUS\"\n+  \"*\n+{\n+ static int labelcount = 0;\n+ static char buf[1000];\n+\n+ if (get_attr_length (insn) == 1)\n+    return \\\"sob %0, %l1\\\";\n+\n+ /* emulate sob */\n+ output_asm_insn (\\\"dec %0\\\", operands);\n+ \n+ sprintf (buf, \\\"bge LONG_SOB%d\\\", labelcount);\n+ output_asm_insn (buf, NULL);\n+\n+ output_asm_insn (\\\"jmp %l1\\\", operands);\n+ \n+ sprintf (buf, \\\"LONG_SOB%d:\\\", labelcount++);\n+ output_asm_insn (buf, NULL);\n+\n+ return \\\"\\\";\n+}\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t       (pc))\n+\t\t\t\t\t\t(const_int -256))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t       (pc))\n+\t\t\t\t\t\t(const_int 0)))\n+\t\t\t\t      (const_int 4)\n+\t\t\t\t      (const_int 1)))])\n+\n+;; These control RTL generation for conditional jump insns\n+;; and match them for register allocation.\n+\n+;; problem with too short jump distance! we need an assembler which can \n+;; make this legal for all jump distances!\n+;; e.g. gas!\n+\n+;; these must be changed to check for CC_IN_FCCR if float is to be \n+;; enabled\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"beq\\\", \\\"bne\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"bne\\\", \\\"beq\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"bgt\\\", \\\"ble\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"bhi\\\", \\\"blos\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"blt\\\", \\\"bge\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"blo\\\", \\\"bhos\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"bge\\\", \\\"blt\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"bhis\\\", \\\"blo\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"ble\\\", \\\"bgt\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_jump(\\\"blos\\\", \\\"bhi\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+\f\n+;; These match inverted jump insns for register allocation.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"bne\\\", \\\"beq\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"beq\\\", \\\"bne\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"ble\\\", \\\"bgt\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"blos\\\", \\\"bhi\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"bge\\\", \\\"blt\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"bhos\\\", \\\"blo\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"  \n+  \"* return output_jump(\\\"blt\\\", \\\"bge\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"blo\\\", \\\"bhos\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"bgt\\\", \\\"ble\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_jump(\\\"bhi\\\", \\\"blos\\\", get_attr_length(insn));\"\n+  [(set (attr \"length\") (if_then_else (ior (le (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int -128))\n+\t\t\t\t\t   (ge (minus (match_dup 0)\n+\t\t\t\t\t\t      (pc))\n+\t\t\t\t\t       (const_int 128)))\n+\t\t\t\t      (const_int 3)\n+\t\t\t\t      (const_int 1)))])\n+\f\n+;; Move instructions\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(match_operand:DI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"* return output_move_quad (operands);\"\n+;; what's the mose expensive code - say twice movsi = 16\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,rm,m\")\n+\t(match_operand:SI 1 \"general_operand\" \"rN,IJ,K,m,r\"))]\n+  \"\"\n+  \"* return output_move_double (operands);\"\n+;; what's the most expensive code ? - I think 8!\n+;; we could split it up and make several sub-cases...\n+  [(set_attr \"length\" \"2,3,4,8,8\")])\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(match_operand:HI 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clr %0\\\";\n+\n+  return \\\"mov %1, %0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(match_operand:QI 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clrb %0\\\";\n+\n+  return \\\"movb %1, %0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+;; do we have to supply all these moves? e.g. to \n+;; NO_LOAD_FPU_REGs ? \n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f,R,f,Q,f,m\")\n+        (match_operand:DF 1 \"general_operand\" \"fR,f,Q,f,F,m\"))]\n+  \"\"\n+  \"* return output_move_quad (operands);\"\n+;; just a guess..\n+  [(set_attr \"length\" \"1,1,2,2,5,16\")])\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,r,g\")\n+        (match_operand:SF 1 \"general_operand\" \"r,rmF,g\"))]\n+  \"TARGET_FPU\"\n+  \"* return output_move_double (operands);\"\n+  [(set_attr \"length\" \"8,8,8\")])\n+\n+;; maybe fiddle a bit with move_ratio, then \n+;; let contraints only accept a register ...\n+\n+(define_expand \"movstrhi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"=g,g\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"g,g\")))\n+\t      (use (match_operand:HI 2 \"arith_operand\" \"n,&mr\"))\n+\t      (use (match_operand:HI 3 \"immediate_operand\" \"i,i\"))\n+\t      (clobber (match_scratch:HI 4 \"=&r,X\"))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))\n+\t      (clobber (match_dup 2))])]\n+  \"(TARGET_BCOPY_BUILTIN)\"\n+  \"\n+{\n+  operands[0] = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+  operands[2] = force_not_mem (operands[2]);\n+}\")\n+\n+\n+(define_insn \"\" ; \"movstrhi\"\n+  [(set (mem:BLK (match_operand:HI 0 \"general_operand\" \"=r,r\"))\n+\t(mem:BLK (match_operand:HI 1 \"general_operand\" \"r,r\")))\n+   (use (match_operand:HI 2 \"arith_operand\" \"n,&r\"))\n+   (use (match_operand:HI 3 \"immediate_operand\" \"i,i\"))\n+   (clobber (match_scratch:HI 4 \"=&r,X\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))\n+   (clobber (match_dup 2))]\n+  \"(TARGET_BCOPY_BUILTIN)\"\n+  \"* return output_block_move (operands);\"\n+;;; just a guess\n+  [(set_attr \"length\" \"40\")])\n+   \n+\n+\f\n+;;- truncation instructions\n+\n+(define_insn  \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=R,Q\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"a,a\")))]\n+  \"TARGET_FPU\"\n+  \"stcdf %1, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_expand \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(subreg:HI \n+\t  (match_operand:SI 1 \"general_operand\" \"or\")\n+          0))]\n+  \"\"\n+  \"\")\n+\n+\f\n+;;- zero extension instructions\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"bic $(256*255), %0\"\n+  [(set_attr \"length\" \"2\")])\n+\t\t\t \n+(define_expand \"zero_extendhisi2\"\n+  [(set (subreg:HI \n+          (match_dup 0)\n+          1)\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (set (subreg:HI \n+          (match_operand:SI 0 \"register_operand\" \"=r\")\n+          0)\n+        (const_int 0))]\n+  \"\"\n+  \"/* operands[1] = make_safe_from (operands[1], operands[0]); */\")\n+\n+\f\n+;;- sign extension instructions\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(float_extend:SF (match_operand:SF 1 \"memory_operand\" \"R,Q\")))]\n+  \"TARGET_FPU\"\n+  \"ldcfd %1, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; does movb sign extend in register-to-register move?\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"rR,Q\")))]\n+  \"\"\n+  \"movb %1, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_operand\" \"rR,Q\")))]\n+  \"TARGET_40_PLUS\"\n+  \"*\n+{\n+  rtx latehalf[2];\n+\n+  /* make register pair available */\n+  latehalf[0] = operands[0];\n+  operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+    \n+  output_asm_insn(\\\"movb %1, %0\\\", operands);\n+  output_asm_insn(\\\"sxt %0\\\", latehalf);\n+    \n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"2,3\")])\n+\n+;; maybe we have to use define_expand to say that we have the instruction,\n+;; unconditionally, and then match dependent on CPU type:\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\")\n+  \n+(define_insn \"\" ; \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=o,<,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g,g,g\")))]\n+  \"TARGET_40_PLUS\"\n+  \"*\n+{\n+  rtx latehalf[2];\n+\n+  /* we don't want to mess with auto increment */\n+  \n+  switch(which_alternative)\n+  {\n+    case 0:\n+\n+      latehalf[0] = operands[0];\n+      operands[0] = adj_offsettable_operand(operands[0], 2);\n+  \n+      output_asm_insn(\\\"mov %1, %0\\\", operands);\n+      output_asm_insn(\\\"sxt %0\\\", latehalf);\n+\n+      return \\\"\\\";\n+\n+    case 1:\n+\n+      /* - auto-decrement - right direction ;-) */\n+      output_asm_insn(\\\"mov %1, %0\\\", operands);\n+      output_asm_insn(\\\"sxt %0\\\", operands);\n+\n+      return \\\"\\\";\n+\n+    case 2:\n+\n+      /* make register pair available */\n+      latehalf[0] = operands[0];\n+      operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+\n+      output_asm_insn(\\\"mov %1, %0\\\", operands);\n+      output_asm_insn(\\\"sxt %0\\\", latehalf);\n+\n+      return \\\"\\\";\n+\n+    default:\n+\n+      abort();\n+  }\n+}\"\n+  [(set_attr \"length\" \"5,3,3\")])\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"(! TARGET_40_PLUS)\"\n+  \"*\n+{\n+  static count = 0;\n+  char buf[100];\n+  rtx lateoperands[2];\n+\n+  lateoperands[0] = operands[0];\n+  operands[0] = gen_rtx(REG, HImode, REGNO (operands[0])+1);\n+\n+  output_asm_insn(\\\"tst %0\\\", operands);\n+  sprintf(buf, \\\"bge extendhisi%d\\\", count);\n+  output_asm_insn(buf, NULL);\n+  output_asm_insn(\\\"mov -1, %0\\\", lateoperands);\n+  sprintf(buf, \\\"bne extendhisi%d\\\", count+1);\n+  output_asm_insn(buf, NULL);\n+  sprintf(buf, \\\"\\\\nextendhisi%d:\\\", count);\n+  output_asm_insn(buf, NULL);\n+  output_asm_insn(\\\"clr %0\\\", lateoperands);\n+  sprintf(buf, \\\"\\\\nextendhisi%d:\\\", count+1);\n+  output_asm_insn(buf, NULL);\n+\n+  count += 2;\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"6\")])\n+\n+;; make float to int and vice versa \n+;; using the cc_status.flag field we coulf probably cut down\n+;; on seti and setl\n+;; assume that we are normally in double and integer mode -\n+;; what do pdp library routines do to fpu mode ?\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(float:DF (match_operand:SI 1 \"memory_operand\" \"R,Q\")))]\n+  \"TARGET_FPU\"\n+  \"setl\\;ldcld %1, %0\\;seti\"\n+  [(set_attr \"length\" \"3,4\")])\n+\n+(define_insn \"floathidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(float:DF (match_operand:HI 1 \"general_operand\" \"rR,Qi\")))]\n+  \"TARGET_FPU\"\n+  \"ldcid %1, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\t\n+;; cut float to int\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=R,Q\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"a,a\"))))]\n+  \"TARGET_FPU\"\n+  \"setl\\;stcdl %1, %0\\;seti\"\n+  [(set_attr \"length\" \"3,4\")])\n+\n+(define_insn \"fix_truncdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"register_operand\" \"a,a\"))))]\n+  \"TARGET_FPU\"\n+  \"stcdi %1, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+\f\n+;;- arithmetic instructions\n+;;- add instructions\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0,0,0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"fR,Q,F\")))]\n+  \"TARGET_FPU\"\n+  \"addd %2, %0\"\n+  [(set_attr \"length\" \"1,2,5\")])\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,o,o,r,r,r,o,o,o\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0,0,0,0,0,0,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"r,o,r,o,I,J,K,I,J,K\")))]\n+  \"\"\n+  \"*\n+{ /* Here we trust that operands don't overlap \n+\n+     or is lateoperands the low word?? - looks like it! */\n+\n+  unsigned int i;\n+  rtx lateoperands[3];\n+  \n+  lateoperands[0] = operands[0];\n+\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+  else\n+    operands[0] = adj_offsettable_operand (operands[0], 2);\n+  \n+  if (! CONSTANT_P(operands[2]))\n+  {\n+    lateoperands[2] = operands[2];\n+\n+    if (REG_P (operands[2]))\n+      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+    else\n+      operands[2] = adj_offsettable_operand(operands[2], 2);\n+\n+    output_asm_insn (\\\"add %2, %0\\\", operands);\n+    output_asm_insn (\\\"adc %0\\\", lateoperands);\n+    output_asm_insn (\\\"add %2, %0\\\", lateoperands);\n+    return \\\"\\\";\n+  }\n+\n+  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);\n+  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);\n+  \n+  if (INTVAL(operands[2]))\n+  { \n+    output_asm_insn (\\\"add %2, %0\\\", operands);\n+    output_asm_insn (\\\"adc %0\\\", lateoperands);\n+  }\n+\n+  if (INTVAL(lateoperands[2]))\n+    output_asm_insn (\\\"add %2, %0\\\", lateoperands);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"3,5,6,8,3,1,5,5,3,8\")])\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rRLM,Qi,rRLM,Qi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    if (INTVAL(operands[2]) == 1)\n+      return \\\"inc %0\\\";\n+    else if (INTVAL(operands[2]) == -1)\n+      return \\\"dec %0\\\";\n+\n+  return \\\"add %2, %0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"rRLM,Qi,rRLM,Qi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    if (INTVAL(operands[2]) == 1)\n+      return \\\"incb %0\\\";\n+    else if (INTVAL(operands[2]) == -1)\n+      return \\\"decb %0\\\";\n+\n+  return \\\"addb %2, %0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+\f\n+;;- subtract instructions\n+;; we don't have to care for constant second \n+;; args, since they are cononical plus:xx now!\n+;; also for minus:DF ??\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"fR,Q\")))]\n+  \"TARGET_FPU\"\n+  \"subd %2, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,o,o\")\n+        (minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n+                  (match_operand:SI 2 \"general_operand\" \"r,o,r,o\")))]\n+  \"\"\n+  \"*\n+{ /* Here we trust that operands don't overlap \n+\n+     or is lateoperands the low word?? - looks like it! */\n+\n+  unsigned int i;\n+  rtx lateoperands[3];\n+  \n+  lateoperands[0] = operands[0];\n+\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+  else\n+    operands[0] = adj_offsettable_operand (operands[0], 2);\n+  \n+  lateoperands[2] = operands[2];\n+\n+  if (REG_P (operands[2]))\n+    operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+  else\n+    operands[2] = adj_offsettable_operand(operands[2], 2);\n+\n+  output_asm_insn (\\\"sub %2, %0\\\", operands);\n+  output_asm_insn (\\\"sbc %0\\\", lateoperands);\n+  output_asm_insn (\\\"sub %2, %0\\\", lateoperands);\n+  return \\\"\\\";\n+}\"\n+;; offsetable memory addresses always are expensive!!!\n+  [(set_attr \"length\" \"3,5,6,8\")])\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    abort();\n+\n+  return \\\"sub %2, %0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    abort();\n+\n+  return \\\"subb %2, %0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+;;;;- and instructions\n+;; Bit-and on the pdp (like on the vax) is done with a clear-bits insn.\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(not:SI (match_operand:SI 2 \"general_operand\" \"g\"))))]\n+  \"\"\n+  \"\n+{\n+  extern rtx expand_unop ();\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[2]));\n+  else\n+    operands[2] = expand_unop (SImode, one_cmpl_optab, operands[2], 0, 1);\n+}\")\n+\n+(define_expand \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(not:HI (match_operand:HI 2 \"general_operand\" \"g\"))))]\n+  \"\"\n+  \"\n+{\n+  extern rtx expand_unop ();\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[2]));\n+  else\n+    operands[2] = expand_unop (HImode, one_cmpl_optab, operands[2], 0, 1);\n+}\")\n+\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t(not:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n+  \"\"\n+  \"\n+{\n+  extern rtx expand_unop ();\n+  rtx op = operands[2];\n+  if (GET_CODE (op) == CONST_INT)\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t   ((1 << 8) - 1) & ~INTVAL (op));\n+  else\n+    operands[2] = expand_unop (QImode, one_cmpl_optab, op, 0, 1);\n+}\")\n+\n+(define_insn \"andcbsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,o,o,r,r,r,o,o,o\")\n+        (and:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0,0,0,0,0,0,0\")\n+                (not:SI (match_operand:SI 2 \"general_operand\" \"r,o,r,o,I,J,K,I,J,K\"))))]\n+  \"\"\n+  \"*\n+{ /* Here we trust that operands don't overlap \n+\n+     or is lateoperands the low word?? - looks like it! */\n+\n+  unsigned int i;\n+  rtx lateoperands[3];\n+  \n+  lateoperands[0] = operands[0];\n+\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+  else\n+    operands[0] = adj_offsettable_operand (operands[0], 2);\n+  \n+  if (! CONSTANT_P(operands[2]))\n+  {\n+    lateoperands[2] = operands[2];\n+\n+    if (REG_P (operands[2]))\n+      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+    else\n+      operands[2] = adj_offsettable_operand(operands[2], 2);\n+\n+    output_asm_insn (\\\"bic %2, %0\\\", operands);\n+    output_asm_insn (\\\"bic %2, %0\\\", lateoperands);\n+    return \\\"\\\";\n+  }\n+\n+  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);\n+  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);\n+  \n+  /* these have different lengths, so we should have \n+     different constraints! */\n+  if (INTVAL(operands[2]))\n+    output_asm_insn (\\\"bic %2, %0\\\", operands);\n+\n+  if (INTVAL(lateoperands[2]))\n+    output_asm_insn (\\\"bic %2, %0\\\", lateoperands);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"2,4,4,6,2,2,4,3,3,6\")])\n+\n+(define_insn \"andcbhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t(not:HI (match_operand:HI 2 \"general_operand\" \"rR,Qi,rR,Qi\"))))]\n+  \"\"\n+  \"bic %2, %0\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+(define_insn \"andcbqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t(not:QI (match_operand:QI 2 \"general_operand\" \"rR,Qi,rR,Qi\"))))]\n+  \"\"\n+  \"bicb %2, %0\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+;;- Bit set (inclusive or) instructions\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,o,o,r,r,r,o,o,o\")\n+        (ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0,0,0,0,0,0,0\")\n+                  (match_operand:SI 2 \"general_operand\" \"r,o,r,o,I,J,K,I,J,K\")))]\n+  \"\"\n+  \"*\n+{ /* Here we trust that operands don't overlap \n+\n+     or is lateoperands the low word?? - looks like it! */\n+\n+  unsigned int i;\n+  rtx lateoperands[3];\n+  \n+  lateoperands[0] = operands[0];\n+\n+  if (REG_P (operands[0]))\n+    operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+  else\n+    operands[0] = adj_offsettable_operand (operands[0], 2);\n+  \n+  if (! CONSTANT_P(operands[2]))\n+  {\n+    lateoperands[2] = operands[2];\n+\n+    if (REG_P (operands[2]))\n+      operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+    else\n+      operands[2] = adj_offsettable_operand(operands[2], 2);\n+\n+    output_asm_insn (\\\"bis %2, %0\\\", operands);\n+    output_asm_insn (\\\"bis %2, %0\\\", lateoperands);\n+    return \\\"\\\";\n+  }\n+\n+  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);\n+  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);\n+  \n+  /* these have different lengths, so we should have \n+     different constraints! */\n+  if (INTVAL(operands[2]))\n+    output_asm_insn (\\\"bis %2, %0\\\", operands);\n+\n+  if (INTVAL(lateoperands[2]))\n+    output_asm_insn (\\\"bis %2, %0\\\", lateoperands);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"2,4,4,6,2,2,4,3,3,6\")])\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+  \"\"\n+  \"bis %2, %0\"\n+  [(set_attr \"length\" \"1,2,2,3\")])\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+  \"\"\n+  \"bisb %2, %0\")\n+\n+;;- xor instructions\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n+                  (match_operand:SI 2 \"arith_operand\" \"r,I,J,K\")))]\n+  \"TARGET_40_PLUS\"\n+  \"*\n+{ /* Here we trust that operands don't overlap */\n+\n+  unsigned int i;\n+  rtx lateoperands[3];\n+\n+  lateoperands[0] = operands[0];\n+  operands[0] = gen_rtx(REG, HImode, REGNO(operands[0]) + 1);\n+\n+  if (REG_P(operands[2]))\n+  {\n+    lateoperands[2] = operands[2];\n+    operands[2] = gen_rtx(REG, HImode, REGNO(operands[2]) + 1);\n+    \n+    output_asm_insn (\\\"xor %2, %0\\\", operands);\n+    output_asm_insn (\\\"xor %2, %0\\\", lateoperands);\n+\n+    return \\\"\\\";\n+  }\n+\n+  lateoperands[2] = gen_rtx(CONST_INT, VOIDmode, (INTVAL(operands[2]) >> 16) & 0xffff);\n+  operands[2] = gen_rtx(CONST_INT, VOIDmode, INTVAL(operands[2]) & 0xffff);\n+  \n+  if (INTVAL(operands[2]))\n+    output_asm_insn (\\\"xor %2, %0\\\", operands);\n+\n+  if (INTVAL(lateoperands[2]))\n+    output_asm_insn (\\\"xor %2, %0\\\", lateoperands);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"2,1,1,2\")])\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"register_operand\" \"r,r\")))]\n+  \"TARGET_40_PLUS\"\n+  \"xor %2, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;;- one complement instructions\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+        (not:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"com %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,Q\")\n+        (not:QI (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"comb %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;;- arithmetic shift instructions\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n+  \"TARGET_45\"\n+  \"ashc %2,%0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; Arithmetic right shift on the pdp works by negating the shift count.\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = negate_rtx (HImode, operands[2]);\n+}\")\n+\n+;; define asl aslb asr asrb - ashc missing!\n+\n+;; asl \n+(define_insn \"\" \n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"asl %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; and another possibility for asr is << -1\n+;; might cause problems since -1 can also be encoded as 65535!\n+;; not in gcc2 ??? \n+\n+;; asr\n+(define_insn \"\" \n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n+\t\t   (const_int -1)))]\n+  \"\"\n+  \"asr %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; shift is by arbitrary count is expensive, \n+;; shift by one cheap - so let's do that, if\n+;; space doesn't matter\n+(define_insn \"\" \n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"expand_shift_operand\" \"O\")))]\n+  \"TARGET_TIME\"\n+  \"*\n+{\n+  register int i;\n+\n+  for (i = 1; i <= abs(INTVAL(operands[2])); i++)\n+    if (INTVAL(operands[2]) < 0)\n+      output_asm_insn(\\\"asr %0\\\", operands);\n+    else\n+      output_asm_insn(\\\"asl %0\\\", operands);\n+      \n+  return \\\"\\\";\n+}\"\n+;; longest is 4\n+  [(set (attr \"length\") (const_int 4))])\n+\n+;; aslb\n+(define_insn \"\" \n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,o\")\n+\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n+\t\t   (match_operand:HI 2 \"const_immediate_operand\" \"n,n\")))]\n+  \"\"\n+  \"*\n+{ /* allowing predec or post_inc is possible, but hairy! */\n+  int i, cnt;\n+\n+  cnt = INTVAL(operands[2]) & 0x0007;\n+\n+  for (i=0 ; i < cnt ; i++)\n+       output_asm_insn(\\\"aslb %0\\\", operands);\n+\n+  return \\\"\\\";\n+}\"\n+;; set attribute length ( match_dup 2 & 7 ) *(1 or 2) !!!\n+  [(set_attr_alternative \"length\" \n+                         [(const_int 7)\n+                          (const_int 14)])])\n+\n+;;; asr \n+;(define_insn \"\" \n+;  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+;\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n+;\t\t     (const_int 1)))]\n+;  \"\"\n+;  \"asr %0\"\n+;  [(set_attr \"length\" \"1,2\")])\n+\n+;; asrb\n+(define_insn \"\" \n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,o\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n+\t\t     (match_operand:HI 2 \"const_immediate_operand\" \"n,n\")))]\n+  \"\"\n+  \"*\n+{ /* allowing predec or post_inc is possible, but hairy! */\n+  int i, cnt;\n+\n+  cnt = INTVAL(operands[2]) & 0x0007;\n+\n+  for (i=0 ; i < cnt ; i++)\n+       output_asm_insn(\\\"asrb %0\\\", operands);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr_alternative \"length\" \n+                         [(const_int 7)\n+                          (const_int 14)])])\n+\n+;; the following is illegal - too complex!!! - just say 14 !!!\n+;  [(set (attr \"length\") (plus (and (match_dup 2)\n+;                                   (const_int 7))\n+;                              (and (match_dup 2)\n+;                                   (const_int 7))))])\n+\n+\n+\n+;; can we get +-1 in the next pattern? should \n+;; have been caught by previous patterns!\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE(operands[2]) == CONST_INT)\n+    if (INTVAL(operands[2]) == 1)\n+      return \\\"asl %0\\\";\n+    else if (INTVAL(operands[2]) == -1)\n+      return \\\"asr %0\\\";\n+\n+  return \\\"ash %2,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; Arithmetic right shift on the pdp works by negating the shift count.\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = negate_rtx (HImode, operands[2]);\n+}\")\n+\n+;;;;- logical shift instructions\n+;;(define_insn \"lshrsi3\"\n+;;  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+;;\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+;;\t\t     (match_operand:HI 2 \"arith_operand\" \"rI\")))]\n+;;  \"\"\n+;;  \"srl %0,%2\")\n+\n+;; absolute \n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fR,Q\")\n+\t(abs:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))]\n+  \"TARGET_FPU\"\n+  \"absd %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"abshi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,o\")\n+\t(abs:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n+  \"TARGET_ABSHI_BUILTIN\"\n+  \"*\n+{\n+  static count = 0;\n+  char buf[200];\n+\t\n+  output_asm_insn(\\\"tst %0\\\", operands);\n+  sprintf(buf, \\\"bge abshi%d\\\", count);\n+  output_asm_insn(buf, NULL);\n+  output_asm_insn(\\\"neg %0\\\", operands);\n+  sprintf(buf, \\\"\\\\nabshi%d:\\\", count++);\n+  output_asm_insn(buf, NULL);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"3,5\")])\n+\n+\n+;; define expand abshi - is much better !!! - but\n+;; will it be optimized into an abshi2 ?\n+;; it will leave better code, because the tsthi might be \n+;; optimized away!!\n+; -- just a thought - don't have time to check \n+;\n+;(define_expand \"abshi2\"\n+;  [(match_operand:HI 0 \"general_operand\" \"\")\n+;   (match_operand:HI 1 \"general_operand\" \"\")]\n+;  \"\"\n+;  \"\n+;{\n+;  rtx label = gen_label_rtx ();\n+;\n+;  /* do I need this? */\n+;  do_pending_stack_adjust ();\n+;\n+;  emit_move_insn (operands[0], operands[1]);\n+;\n+;  emit_insn (gen_tsthi (operands[0]));\n+;  emit_insn (gen_bge (label1));\n+;\n+;  emit_insn (gen_neghi(operands[0], operands[0])\n+;  \n+;  emit_barrier ();\n+;\n+;  emit_label (label);\n+;\n+;  /* allow REG_NOTES to be set on last insn (labels don't have enough\n+;     fields, and can't be used for REG_NOTES anyway).  */\n+;  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+;  DONE;\n+;}\")\n+\n+;; negate insns\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fR,Q\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"0,0\")))]\n+  \"TARGET_FPU\"\n+  \"negd %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rR,Q\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"neg %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rR,Q\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"negb %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+\n+;; Unconditional and other jump instructions\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp %l0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+    (label_ref (match_operand 0 \"\" \"\")))\n+   (clobber (const_int 1))]\n+  \"\"\n+  \"jmp %l0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:HI 0 \"general_operand\" \"rR,Q\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; indirect jump - let's be conservative!\n+;; allow only register_operand, even though we could also \n+;; allow labels etc.\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp (%0)\")\n+\n+;;- jump to subroutine\n+\n+(define_insn \"call\"\n+  [(call (match_operand:HI 0 \"general_operand\" \"R,Q\")\n+\t (match_operand:HI 1 \"general_operand\" \"g,g\"))\n+;;   (use (reg:HI 0)) what was that ???\n+  ]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"jsr pc, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;;- jump to subroutine\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:HI 1 \"general_operand\" \"R,Q\")\n+\t      (match_operand:HI 2 \"general_operand\" \"g,g\")))\n+;;   (use (reg:HI 0)) - what was that ????\n+  ]\n+  ;;- Don't use operand 2 for most machines.\n+  \"\"\n+  \"jsr pc, %1\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;;- nop instruction\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\f\n+\n+;;- multiply \n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0,0,0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"fR,Q,F\")))]\n+  \"TARGET_FPU\"\n+  \"muld %2, %0\"\n+  [(set_attr \"length\" \"1,2,5\")])\n+\n+;; 16 bit result multiply:\n+;; currently we multiply only into odd registers, so we don't use two \n+;; registers - but this is a bit inefficient at times. If we define \n+;; a register class for each register, then we can specify properly \n+;; which register need which scratch register ....\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d\") ; multiply regs\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n+  \"TARGET_45\"\n+  \"mul %2, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; 32 bit result\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\") ; even numbered!\n+\t(mult:SI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n+  \"TARGET_45\"\n+  \"mul %2, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;;- divide\n+;; how can I use the remainder ? - \n+;; modsidi and move upper register to lower ????\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"0,0,0\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"fR,Q,F\")))]\n+  \"TARGET_FPU\"\n+  \"divd %2, %0\"\n+  [(set_attr \"length\" \"1,2,5\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0,0\")\n+\t  (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"rR,Q\")))))]\n+  \"TARGET_45\"\n+  \"div %2,%0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; - problem matching the (sign_extend:SI (const_int ...))\n+; used without -O \n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (sign_extend:SI (match_operand 2 \"immediate_operand\" \"n\")))))]\n+  \"TARGET_45\"\n+  \"div %2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+; used with -O\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (match_operand:SI 2 \"immediate_operand\" \"i\"))))]\n+  \"TARGET_45\"\n+  \"div %2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_expand \"divhi3\"\n+  [(set (match_dup 3)\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))\n+   (set (match_operand:HI 0 \"general_operand\" \"g\")\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_dup 3)\n+\t  (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"g\")))))]\n+  \"TARGET_45\"\n+  \"operands[3] = gen_reg_rtx (SImode);\")\n+\n+(define_expand \"udivqi\"\n+  [(set (subreg:HI (match_dup 3) 1)\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"g\")))\n+   (set (subreg:HI (match_dup 3) 0)\n+\t(const_int 0))\n+   (set (match_dup 4)\n+\t(sign_extend:HI (match_operand:QI 2 \"general_operand\" \"g\")))\n+   (set (match_dup 5)\n+\t(and:HI (match_dup 4)\n+\t\t(const_int 255)))\n+   (set (match_dup 6)\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_dup 3)\n+\t  (sign_extend:SI (match_dup 5)))))\n+   (set (match_operand:QI 0 \"general_operand\" \"g\")\n+\t(truncate:QI (match_dup 6)))]\n+  \"TARGET_45\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (SImode);\n+  operands[4] = gen_reg_rtx (HImode);\n+  operands[5] = gen_reg_rtx (HImode);\n+  operands[6] = gen_reg_rtx (HImode);\n+}\")\n+   \n+;; we must restrict it to divide by 15-bit constant...\n+(define_expand \"udivhi3\"\n+  [(set (subreg:HI (match_dup 3) 1)\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))\n+   (set (subreg:HI (match_dup 3) 0)\n+\t(const_int 0))\n+   (set (match_operand:HI 0 \"general_operand\" \"g\")\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_dup 3)\n+\t  (sign_extend:SI (match_operand:HI 2 \"immediate15_operand\" \"n\")))))]\n+  \"TARGET_45\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (SImode);\n+  \n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || ((INTVAL (operands[2]) & 0x8000) != 0x0000))\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r,r\") 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0,0\")\n+\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rR,Q\")))))]\n+  \"TARGET_45\"\n+  \"div %2,%0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; (sign_extend:SI (const_int ))\n+; w/o -O\n+(define_insn \"\"\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (sign_extend:SI (match_operand 2 \"immediate_operand\" \"i\")))))]\n+  \"TARGET_45\"\n+  \"div %2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+; w/ -O\n+(define_insn \"\"\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (match_operand:SI 2 \"immediate_operand\" \"i\"))))]\n+  \"TARGET_45\"\n+  \"div %2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_expand \"modhi3\"\n+  [(set (match_dup 3)\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))\n+   (set (subreg:HI (match_dup 3) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 3)\n+\t  (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"g\")))))\n+   (set (match_operand:HI 0 \"general_operand\" \"g\")\n+\t(subreg:HI (match_dup 3) 1))]\n+  \"TARGET_45\"\n+  \"operands[3] = gen_reg_rtx (SImode);\")\n+\n+;; we must restrict it to mod by 15 bit constant\n+(define_expand \"umodhi3\"\n+  [(set (subreg:HI (match_dup 3) 0)\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))\n+   (set (subreg:HI (match_dup 3) 1)\n+\t(const_int 0))\n+   (set (subreg:HI (match_dup 3) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 3)\n+\t  (sign_extend:SI (match_operand:HI 2 \"immediate15_operand\" \"n\")))))\n+   (set (match_operand:HI 0 \"general_operand\" \"g\")\n+\t(subreg:HI (match_dup 3) 1))]\n+  \"TARGET_45\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (SImode);\n+  \n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || ((INTVAL (operands[2]) & 0x8000) != 0x0000))\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r,r\") 0)\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0,0\")\n+\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rR,Q\")))))\n+   (set (subreg:HI (match_dup 0) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 1)\n+\t  (sign_extend:SI (match_dup 2)))))]\n+  \"TARGET_45\"\n+  \"div %2, %0\"\n+  [(set_attr \"length\" \"1,2\")])\n+\n+;; (sign_extend:SI (const_int))\n+; w/o -O \n+(define_insn \"\"\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 0)\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (sign_extend:SI (match_operand 2 \"immediate_operand\" \"i\")))))\n+   (set (subreg:HI (match_dup 0) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 1)\n+\t  (sign_extend:SI (match_dup 2)))))]\n+  \"TARGET_45\"\n+  \"div %2, %0\"\n+  [(set_attr \"length\" \"2\")])\n+; w/ -O\n+(define_insn \"\"\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 0)\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (match_operand:SI 2 \"immediate_operand\" \"i\"))))\n+   (set (subreg:HI (match_dup 0) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 1)\n+\t  (match_dup 2))))]\n+  \"TARGET_45\"\n+  \"div %2, %0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_expand \"divmodhi4\"\n+  [(set (match_dup 4)\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))\n+   (set (subreg:HI (match_dup 4) 0)\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_dup 4)\n+\t  (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"g\")))))\n+   (set (subreg:HI (match_dup 4) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 4)\n+\t  (sign_extend:SI (match_dup 2)))))\n+   (set (match_operand:HI 0 \"general_operand\" \"g\")\n+\t(subreg:HI (match_dup 4) 0))\n+   (set (match_operand:HI 3 \"general_operand\" \"g\")\n+\t(subreg:HI (match_dup 4) 1))]\n+  \"TARGET_45\"\n+  \"operands[4] = gen_reg_rtx(SImode);\")\n+\n+(define_expand \"udivmodhi4\"\n+  [(set (subreg:HI (match_dup 3) 1)\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))\n+   (set (subreg:HI (match_dup 3) 0)\n+\t(const_int 0))\n+   (set (subreg:HI (match_dup 4) 0)\n+\t(truncate:HI \n+\t (div:SI\n+\t  (match_dup 4)\n+\t  (sign_extend:SI (match_operand:HI 2 \"immediate15_operand\" \"n\")))))\n+   (set (subreg:HI (match_dup 4) 1)\n+\t(truncate:HI \n+\t (mod:SI\n+\t  (match_dup 4)\n+\t  (sign_extend:SI (match_dup 2)))))\n+   (set (match_operand:HI 0 \"general_operand\" \"g\")\n+\t(subreg:HI (match_dup 4) 0))\n+   (set (match_operand:HI 3 \"general_operand\" \"g\")\n+\t(subreg:HI (match_dup 4) 1))]\n+  \"TARGET_45\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (SImode);\n+  \n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || ((INTVAL (operands[2]) & 0x8000) != 0x0000))\n+    FAIL;\n+}\")\n+\n+;; truncate used in div/mod patterns\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r\")\n+\t(truncate:QI (match_operand:HI 1 \"general_operand\" \"0,r\")))]\n+  \"TARGET_45\"\n+  \"@\n+   ; nop\n+   movb %1, %0\"\n+  [(set_attr \"length\" \"0,1\")])\n+   \n+;; is rotate doing the right thing to be included here ????"}, {"sha": "7cf7c77d865fb10d3a37c78bcd02c57baaf939e0", "filename": "gcc/config/pdp11/xm-pdp11.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fxm-pdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9c2489771b9b4ec491910204ef392b8c6767c1/gcc%2Fconfig%2Fpdp11%2Fxm-pdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fxm-pdp11.h?ref=2c9c2489771b9b4ec491910204ef392b8c6767c1", "patch": "@@ -0,0 +1,29 @@\n+/* Configuration for GNU C-compiler for pdp-11 family.\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n+\n+ This file is part of GNU CC.\n+\n+ GNU CC is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 1, or (at your option)\n+ any later version.\n+\n+ GNU CC is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU CC; see the file COPYING.  If not, write to\n+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+*/\n+\n+/* ???? */\n+/* xm is if you want to run gcc here ??? */\n+/* too big !!! */\n+\n+#error YOU LOSE! Gcc cannot run on a pdp-11 due to size problems!\n+\n+"}]}