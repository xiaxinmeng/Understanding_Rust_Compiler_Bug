{"sha": "7d651220a36ec97dfbff7e6bd23fe6147956f078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q2NTEyMjBhMzZlYzk3ZGZiZmY3ZTZiZDIzZmU2MTQ3OTU2ZjA3OA==", "commit": {"author": {"name": "Dalibor Topic", "email": "robilad@kaffe.org", "date": "2005-02-20T21:18:30Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-02-20T21:18:30Z"}, "message": "RE.java, [...]: Made 'inner' classes real public static inner classes...\n\n2005-02-20  Dalibor Topic  <robilad@kaffe.org>\n\n\t* libraries/javalib/gnu/regexp/RE.java,\n\tlibraries/javalib/java/io/ObjectInputStream.java,\n\tlibraries/javalib/java/security/AllPermission.java,\n\tlibraries/javalib/java/security/BasicPermission.java,\n\tlibraries/javalib/java/security/Permissions.java,\n\tlibraries/javalib/java/text/MessageFormat.java:\n\tMade 'inner' classes real public static inner classes,\n\tand made them final where possible, or removed them\n\twhere unused.\n\nFrom-SVN: r95310", "tree": {"sha": "60fdf53adbc4000a2ef51e30a5f32ac9d42b11bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60fdf53adbc4000a2ef51e30a5f32ac9d42b11bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d651220a36ec97dfbff7e6bd23fe6147956f078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d651220a36ec97dfbff7e6bd23fe6147956f078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d651220a36ec97dfbff7e6bd23fe6147956f078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d651220a36ec97dfbff7e6bd23fe6147956f078/comments", "author": null, "committer": null, "parents": [{"sha": "237eaf79a5cb53340d8451e3379d6c483ec4f1aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/237eaf79a5cb53340d8451e3379d6c483ec4f1aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/237eaf79a5cb53340d8451e3379d6c483ec4f1aa"}], "stats": {"total": 689, "additions": 351, "deletions": 338}, "files": [{"sha": "81df0f1f0f7a956cc9722cd225cc4e8bfc59b625", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -1,3 +1,15 @@\n+2005-02-20  Dalibor Topic  <robilad@kaffe.org>\n+\n+\t* libraries/javalib/gnu/regexp/RE.java,\n+\tlibraries/javalib/java/io/ObjectInputStream.java,\n+\tlibraries/javalib/java/security/AllPermission.java,\n+\tlibraries/javalib/java/security/BasicPermission.java,\n+\tlibraries/javalib/java/security/Permissions.java,\n+\tlibraries/javalib/java/text/MessageFormat.java:\n+\tMade 'inner' classes real public static inner classes,\n+\tand made them final where possible, or removed them\n+\twhere unused.\n+\n 2005-02-20  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/text/FormatCharacterIterator.java:"}, {"sha": "a01de58f1bb9f59956ecdec909e3c7b2421637b7", "filename": "libjava/gnu/regexp/RE.java", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fgnu%2Fregexp%2FRE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fgnu%2Fregexp%2FRE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRE.java?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -43,15 +43,6 @@\n import java.util.ResourceBundle;\n import java.util.Vector;\n \n-class IntPair implements Serializable {\n-  public int first, second;\n-}\n-\n-class CharUnit implements Serializable {\n-  public char ch;\n-  public boolean bk;\n-}\n-\n /**\n  * RE provides the user interface for compiling and matching regular\n  * expressions.\n@@ -119,6 +110,16 @@ class CharUnit implements Serializable {\n  */\n \n public class RE extends REToken {\n+\n+  private static final class IntPair implements Serializable {\n+    public int first, second;\n+  }\n+\n+  private static final class CharUnit implements Serializable {\n+    public char ch;\n+    public boolean bk;\n+  }\n+\n   // This String will be returned by getVersion()\n   private static final String VERSION = \"1.1.5-dev\";\n "}, {"sha": "6f4faf89a6a78257427acfec380928fccba76b01", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -1809,7 +1809,6 @@ private void invokeValidators() throws InvalidObjectException\n    * @param sm SecurityManager instance which should be called.\n    * @return The current class loader in the calling stack.\n    */\n-\n   private static native ClassLoader currentClassLoader (SecurityManager sm);\n   \n   private native ClassLoader getCallersClassLoader();\n@@ -1879,7 +1878,7 @@ private native Object allocateObject (Class clazz)\n   private int depth = 0;\n \n   private void dumpElement (String msg)\n-  {\t\n+  {\n     System.out.print(msg);\n   }\n   \n@@ -1898,24 +1897,24 @@ private void dumpElementln (String msg)\n \tSystem.loadLibrary (\"javaio\");\n       }\n   }\n-}\n-\n-\n-// used to keep a prioritized list of object validators\n-class ValidatorAndPriority implements Comparable\n-{\n-  int priority;\n-  ObjectInputValidation validator;\n-\n-  ValidatorAndPriority (ObjectInputValidation validator, int priority)\n-  {\n-    this.priority = priority;\n-    this.validator = validator;\n-  }\n \n-  public int compareTo (Object o)\n+  // used to keep a prioritized list of object validators\n+  private static final class ValidatorAndPriority implements Comparable\n   {\n-    ValidatorAndPriority vap = (ValidatorAndPriority)o;\n-    return this.priority - vap.priority;\n+    int priority;\n+    ObjectInputValidation validator;\n+\n+    ValidatorAndPriority (ObjectInputValidation validator, int priority)\n+    {\n+      this.priority = priority;\n+      this.validator = validator;\n+    }\n+\n+    public int compareTo (Object o)\n+    {\n+      ValidatorAndPriority vap = (ValidatorAndPriority)o;\n+      return this.priority - vap.priority;\n+    }\n   }\n }\n+"}, {"sha": "e7f316917c2c8e91f5a94de171fc7bc6f472f610", "filename": "libjava/java/security/AllPermission.java", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fsecurity%2FAllPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fsecurity%2FAllPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAllPermission.java?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -1,5 +1,5 @@\n /* AllPermission.java -- Permission to do anything\n-   Copyright (C) 1998, 2001, 2002, 2004  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2001, 2002, 2004, 2005  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -135,64 +135,64 @@ public PermissionCollection newPermissionCollection()\n   {\n     return new AllPermissionCollection();\n   }\n-} // class AllPermission\n-\n-/**\n- * Implements AllPermission.newPermissionCollection, and obeys serialization\n- * of JDK.\n- *\n- * @author Eric Blake <ebb9@email.byu.edu>\n- */\n-final class AllPermissionCollection extends PermissionCollection\n-{\n-  /**\n-   * Compatible with JDK 1.1+.\n-   */\n-  private static final long serialVersionUID = -4023755556366636806L;\n-\n-  /**\n-   * Whether an AllPermission has been added to the collection.\n-   *\n-   * @serial if all permission is in the collection yet\n-   */\n-  private boolean all_allowed;\n-\n-  /**\n-   * Add an AllPermission.\n-   *\n-   * @param perm the permission to add\n-   * @throws IllegalArgumentException if perm is not an AllPermission\n-   * @throws SecurityException if the collection is read-only\n-   */\n-  public void add(Permission perm)\n-  {\n-    if (isReadOnly())\n-      throw new SecurityException();\n-    if (! (perm instanceof AllPermission))\n-      throw new IllegalArgumentException();\n-    all_allowed = true;\n-  }\n-\n-  /**\n-   * Returns true if this collection implies a permission.\n-   *\n-   * @param perm the permission to check\n-   * @return true if this collection contains an AllPermission\n-   */\n-  public boolean implies(Permission perm)\n-  {\n-    return all_allowed;\n-  }\n \n   /**\n-   * Returns an enumeration of the elements in the collection.\n+   * Implements AllPermission.newPermissionCollection, and obeys serialization\n+   * of JDK.\n    *\n-   * @return the elements in the collection\n+   * @author Eric Blake (ebb9@email.byu.edu)\n    */\n-  public Enumeration elements()\n+  private static final class AllPermissionCollection extends PermissionCollection\n   {\n-    return all_allowed\n-      ? Collections.enumeration(Collections.singleton(new AllPermission()))\n-      : EmptyEnumeration.getInstance();\n-  }\n-} // class AllPermissionCollection\n+    /**\n+     * Compatible with JDK 1.1+.\n+     */\n+    private static final long serialVersionUID = -4023755556366636806L;\n+\n+    /**\n+     * Whether an AllPermission has been added to the collection.\n+     *\n+     * @serial if all permission is in the collection yet\n+     */\n+    private boolean all_allowed;\n+\n+    /**\n+     * Add an AllPermission.\n+     *\n+     * @param perm the permission to add\n+     * @throws IllegalArgumentException if perm is not an AllPermission\n+     * @throws SecurityException if the collection is read-only\n+     */\n+    public void add(Permission perm)\n+    {\n+      if (isReadOnly())\n+        throw new SecurityException();\n+      if (! (perm instanceof AllPermission))\n+        throw new IllegalArgumentException();\n+      all_allowed = true;\n+    }\n+\n+    /**\n+     * Returns true if this collection implies a permission.\n+     *\n+     * @param perm the permission to check\n+     * @return true if this collection contains an AllPermission\n+     */\n+    public boolean implies(Permission perm)\n+    {\n+      return all_allowed;\n+    }\n+\n+    /**\n+     * Returns an enumeration of the elements in the collection.\n+     *\n+     * @return the elements in the collection\n+     */\n+    public Enumeration elements()\n+    {\n+      return all_allowed\n+        ? Collections.enumeration(Collections.singleton(new AllPermission()))\n+        : EmptyEnumeration.getInstance();\n+    }\n+  } // class AllPermissionCollection\n+} // class AllPermission"}, {"sha": "741f2b02464937ab222ee3328c448954cd6b4e2f", "filename": "libjava/java/security/BasicPermission.java", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fsecurity%2FBasicPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fsecurity%2FBasicPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FBasicPermission.java?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -72,8 +72,9 @@\n  * @since 1.1\n  * @status updated to 1.4\n  */\n-public abstract class BasicPermission extends Permission\n+public abstract class BasicPermission extends java.security.Permission\n   implements Serializable\n+  // FIXME extends with fully qualified classname as workaround for gcj 3.3.\n {\n   /**\n    * Compatible with JDK 1.1+.\n@@ -197,111 +198,111 @@ public PermissionCollection newPermissionCollection()\n   {\n     return new BasicPermissionCollection(getClass());\n   }\n-} // class BasicPermission\n \n-/**\n- * Implements AllPermission.newPermissionCollection, and obeys serialization\n- * of JDK.\n- *\n- * @author Eric Blake <ebb9@email.byu.edu>\n- */\n-final class BasicPermissionCollection extends PermissionCollection\n-{\n   /**\n-   * Compatible with JDK 1.1+.\n-   */\n-  private static final long serialVersionUID = 739301742472979399L;\n-\n-  /**\n-   * The permissions in the collection.\n+   * Implements AllPermission.newPermissionCollection, and obeys serialization\n+   * of JDK.\n    *\n-   * @serial a hash mapping name to permissions, all of type permClass\n+   * @author Eric Blake (ebb9@email.byu.edu)\n    */\n-  private final Hashtable permissions = new Hashtable();\n+  private static final class BasicPermissionCollection extends PermissionCollection\n+  {\n+    /**\n+     * Compatible with JDK 1.1+.\n+     */\n+    private static final long serialVersionUID = 739301742472979399L;\n \n-  /**\n-   * If \"*\" is in the collection.\n-   *\n-   * @serial true if a permission named \"*\" is in the collection\n-   */\n-  private boolean all_allowed;\n+    /**\n+     * The permissions in the collection.\n+     *\n+     * @serial a hash mapping name to permissions, all of type permClass\n+     */\n+    private final Hashtable permissions = new Hashtable();\n \n-  /**\n-   * The runtime class which all entries in the table must belong to.\n-   *\n-   * @serial the limiting subclass of this collection\n-   */\n-  private final Class permClass;\n+    /**\n+     * If \"*\" is in the collection.\n+     *\n+     * @serial true if a permission named \"*\" is in the collection\n+     */\n+    private boolean all_allowed;\n \n-  /**\n-   * Construct a collection over the given runtime class.\n-   *\n-   * @param c the class\n-   */\n-  BasicPermissionCollection(Class c)\n-  {\n-    permClass = c;\n-  }\n+    /**\n+     * The runtime class which all entries in the table must belong to.\n+     *\n+     * @serial the limiting subclass of this collection\n+     */\n+    private final Class permClass;\n \n-  /**\n-   * Add a Permission. It must be of the same type as the permission which\n-   * created this collection.\n-   *\n-   * @param perm the permission to add\n-   * @throws IllegalArgumentException if perm is not the correct type\n-   * @throws SecurityException if the collection is read-only\n-   */\n-  public void add(Permission perm)\n-  {\n-    if (isReadOnly())\n-      throw new SecurityException(\"readonly\");\n-    if (! permClass.isInstance(perm))\n-      throw new IllegalArgumentException(\"Expecting instance of \" + permClass);\n-    BasicPermission bp = (BasicPermission) perm;\n-    String name = bp.getName();\n-    if (name.equals(\"*\"))\n-      all_allowed = true;\n-    permissions.put(name, bp);\n-  }\n+    /**\n+     * Construct a collection over the given runtime class.\n+     *\n+     * @param c the class\n+     */\n+    BasicPermissionCollection(Class c)\n+    {\n+      permClass = c;\n+    }\n \n-  /**\n-   * Returns true if this collection implies the given permission.\n-   *\n-   * @param permission the permission to check\n-   * @return true if it is implied by this\n-   */\n-  public boolean implies(Permission permission)\n-  {\n-    if (! permClass.isInstance(permission))\n-      return false;\n-    if (all_allowed)\n-      return true;\n-    BasicPermission toImply = (BasicPermission) permission;\n-    String name = toImply.getName();\n-    if (name.equals(\"*\"))\n-      return false;\n-    int prefixLength = name.length();\n-    if (name.endsWith(\"*\"))\n-      prefixLength -= 2;\n+    /**\n+     * Add a Permission. It must be of the same type as the permission which\n+     * created this collection.\n+     *\n+     * @param perm the permission to add\n+     * @throws IllegalArgumentException if perm is not the correct type\n+     * @throws SecurityException if the collection is read-only\n+     */\n+    public void add(Permission perm)\n+    {\n+      if (isReadOnly())\n+        throw new SecurityException(\"readonly\");\n+      if (! permClass.isInstance(perm))\n+        throw new IllegalArgumentException(\"Expecting instance of \" + permClass);\n+      BasicPermission bp = (BasicPermission) perm;\n+      String name = bp.getName();\n+      if (name.equals(\"*\"))\n+        all_allowed = true;\n+      permissions.put(name, bp);\n+    }\n \n-    while (true)\n-      {\n-        if (permissions.get(name) != null)\n-          return true;\n-        prefixLength = name.lastIndexOf('.', prefixLength);\n-        if (prefixLength < 0)\n-          return false;\n-        name = name.substring(0, prefixLength + 1) + '*';\n-      }\n-  }\n+    /**\n+     * Returns true if this collection implies the given permission.\n+     *\n+     * @param permission the permission to check\n+     * @return true if it is implied by this\n+     */\n+    public boolean implies(Permission permission)\n+    {\n+      if (! permClass.isInstance(permission))\n+        return false;\n+      if (all_allowed)\n+        return true;\n+      BasicPermission toImply = (BasicPermission) permission;\n+      String name = toImply.getName();\n+      if (name.equals(\"*\"))\n+        return false;\n+      int prefixLength = name.length();\n+      if (name.endsWith(\"*\"))\n+        prefixLength -= 2;\n \n-  /**\n-   * Enumerate over the collection.\n-   *\n-   * @return an enumeration of the collection contents\n-   */\n-  public Enumeration elements()\n-  {\n-    return permissions.elements();\n-  }\n-} // class BasicPermissionCollection\n+      while (true)\n+        {\n+          if (permissions.get(name) != null)\n+            return true;\n+          prefixLength = name.lastIndexOf('.', prefixLength);\n+          if (prefixLength < 0)\n+            return false;\n+          name = name.substring(0, prefixLength + 1) + '*';\n+        }\n+    }\n+\n+    /**\n+     * Enumerate over the collection.\n+     *\n+     * @return an enumeration of the collection contents\n+     */\n+    public Enumeration elements()\n+    {\n+      return permissions.elements();\n+    }\n+  } // class BasicPermissionCollection\n+} // class BasicPermission"}, {"sha": "b603dedcf8666f8a7948866bbe1eb6c11422ea8b", "filename": "libjava/java/security/Permissions.java", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fsecurity%2FPermissions.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Fsecurity%2FPermissions.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FPermissions.java?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -188,67 +188,67 @@ public Object nextElement()\n       }\n     };\n   }\n-} // class Permissions\n-\n-/**\n- * Implements the permission collection for all permissions without one of\n- * their own, and obeys serialization of JDK.\n- *\n- * @author Eric Blake <ebb9@email.byu.edu>\n- */\n-class PermissionsHash extends PermissionCollection\n-{\n-  /**\n-   * Compatible with JDK 1.1+.\n-   */\n-  private static final long serialVersionUID = -8491988220802933440L;\n \n   /**\n-   * Hashtable where we store permissions.\n+   * Implements the permission collection for all permissions without one of\n+   * their own, and obeys serialization of JDK.\n    *\n-   * @serial the stored permissions, both as key and value\n+   * @author Eric Blake (ebb9@email.byu.edu)\n    */\n-  private final Hashtable perms = new Hashtable();\n-\n-  /**\n-   * Add a permission. We don't need to check for read-only, as this\n-   * collection is never exposed outside of Permissions, which has already\n-   * done that check.\n-   *\n-   * @param perm the permission to add\n-   */\n-  public void add(Permission perm)\n+  private static final class PermissionsHash extends PermissionCollection\n   {\n-    perms.put(perm, perm);\n-  }\n-\n-  /**\n-   * Returns true if perm is in the collection.\n-   *\n-   * @param perm the permission to check\n-   * @return true if it is implied\n-   */\n-  // FIXME: Should this method be synchronized?\n-  public boolean implies(Permission perm)\n-  {\n-    Enumeration elements = elements();\n-\n-    while (elements.hasMoreElements())\n-      {\n-\tPermission p = (Permission)elements.nextElement();\n-\tif (p.implies(perm))\n-\t  return true;\n-      }\n-    return false;\n-  }\n-\n-  /**\n-   * Return the elements.\n-   *\n-   * @return the elements\n-   */\n-  public Enumeration elements()\n-  {\n-    return perms.elements();\n-  }\n+    /**\n+     * Compatible with JDK 1.1+.\n+     */\n+    private static final long serialVersionUID = -8491988220802933440L;\n+\n+    /**\n+     * Hashtable where we store permissions.\n+     *\n+     * @serial the stored permissions, both as key and value\n+     */\n+    private final Hashtable perms = new Hashtable();\n+\n+    /**\n+     * Add a permission. We don't need to check for read-only, as this\n+     * collection is never exposed outside of Permissions, which has already\n+     * done that check.\n+     *\n+     * @param perm the permission to add\n+     */\n+    public void add(Permission perm)\n+    {\n+      perms.put(perm, perm);\n+    }\n+\n+    /**\n+     * Returns true if perm is in the collection.\n+     *\n+     * @param perm the permission to check\n+     * @return true if it is implied\n+     */\n+    // FIXME: Should this method be synchronized?\n+    public boolean implies(Permission perm)\n+    {\n+      Enumeration elements = elements();\n+      \n+      while (elements.hasMoreElements())\n+\t{\n+\t  Permission p = (Permission)elements.nextElement();\n+\t  if (p.implies(perm))\n+\t    return true;\n+\t}\n+      return false;\n+    }\n+\n+    /**\n+     * Return the elements.\n+     *\n+     * @return the elements\n+     */\n+    public Enumeration elements()\n+    {\n+      return perms.elements();\n+    }\n+  } // class PermissionsHash\n } // class Permissions"}, {"sha": "6c1b0508bdaa98948f52322c94e962933d15d1e1", "filename": "libjava/java/text/MessageFormat.java", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Ftext%2FMessageFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d651220a36ec97dfbff7e6bd23fe6147956f078/libjava%2Fjava%2Ftext%2FMessageFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FMessageFormat.java?ref=7d651220a36ec97dfbff7e6bd23fe6147956f078", "patch": "@@ -46,107 +46,107 @@\n import java.util.Locale;\n import java.util.Vector;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @author Jorge Aliss <jaliss@hotmail.com>\n- * @date March 3, 1999\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 from http://www.javasoft.com.\n- * Status:  Believed complete and correct to 1.2, except serialization.\n- *          and parsing.\n- */\n-final class MessageFormatElement\n+public class MessageFormat extends Format\n {\n-  // Argument number.\n-  int argNumber;\n-  // Formatter to be used.  This is the format set by setFormat.\n-  Format setFormat;\n-  // Formatter to be used based on the type.\n-  Format format;\n-\n-  // Argument will be checked to make sure it is an instance of this\n-  // class.\n-  Class formatClass;\n-\n-  // Formatter type.\n-  String type;\n-  // Formatter style.\n-  String style;\n-\n-  // Text to follow this element.\n-  String trailer;\n-\n-  // Recompute the locale-based formatter.\n-  void setLocale (Locale loc)\n+  /**\n+   * @author Tom Tromey (tromey@cygnus.com)\n+   * @author Jorge Aliss (jaliss@hotmail.com)\n+   * @date March 3, 1999\n+   */\n+  /* Written using \"Java Class Libraries\", 2nd edition, plus online\n+   * API docs for JDK 1.2 from http://www.javasoft.com.\n+   * Status:  Believed complete and correct to 1.2, except serialization.\n+   *          and parsing.\n+   */\n+  private static final class MessageFormatElement\n   {\n-    if (type == null)\n-      ;\n-    else if (type.equals(\"number\"))\n-      {\n-\tformatClass = java.lang.Number.class;\n-\n-\tif (style == null)\n-\t  format = NumberFormat.getInstance(loc);\n-\telse if (style.equals(\"currency\"))\n-\t  format = NumberFormat.getCurrencyInstance(loc);\n-\telse if (style.equals(\"percent\"))\n-\t  format = NumberFormat.getPercentInstance(loc);\n-\telse if (style.equals(\"integer\"))\n-\t  {\n-\t    NumberFormat nf = NumberFormat.getNumberInstance(loc);\n-\t    nf.setMaximumFractionDigits(0);\n-\t    nf.setGroupingUsed(false);\n-\t    format = nf;\n-\t  }\n-\telse\n-\t  {\n-\t    format = NumberFormat.getNumberInstance(loc);\n-\t    DecimalFormat df = (DecimalFormat) format;\n-\t    df.applyPattern(style);\n-\t  }\n-      }\n-    else if (type.equals(\"time\") || type.equals(\"date\"))\n-      {\n-\tformatClass = java.util.Date.class;\n-\n-\tint val = DateFormat.DEFAULT;\n-\tif (style == null)\n-\t  ;\n-\telse if (style.equals(\"short\"))\n-\t  val = DateFormat.SHORT;\n-\telse if (style.equals(\"medium\"))\n-\t  val = DateFormat.MEDIUM;\n-\telse if (style.equals(\"long\"))\n-\t  val = DateFormat.LONG;\n-\telse if (style.equals(\"full\"))\n-\t  val = DateFormat.FULL;\n-\n-\tif (type.equals(\"time\"))\n-\t  format = DateFormat.getTimeInstance(val, loc);\n-\telse\n-\t  format = DateFormat.getDateInstance(val, loc);\n-\n-\tif (style != null && val == DateFormat.DEFAULT)\n-\t  {\n-\t    SimpleDateFormat sdf = (SimpleDateFormat) format;\n-\t    sdf.applyPattern(style);\n-\t  }\n-      }\n-    else if (type.equals(\"choice\"))\n-      {\n-\tformatClass = java.lang.Number.class;\n-\n-\tif (style == null)\n-\t  throw new\n-\t    IllegalArgumentException (\"style required for choice format\");\n-\tformat = new ChoiceFormat (style);\n-      }\n+    // Argument number.\n+    int argNumber;\n+    // Formatter to be used.  This is the format set by setFormat.\n+    Format setFormat;\n+    // Formatter to be used based on the type.\n+    Format format;\n+\n+    // Argument will be checked to make sure it is an instance of this\n+    // class.\n+    Class formatClass;\n+\n+    // Formatter type.\n+    String type;\n+    // Formatter style.\n+    String style;\n+\n+    // Text to follow this element.\n+    String trailer;\n+\n+    // Recompute the locale-based formatter.\n+    void setLocale (Locale loc)\n+    {\n+      if (type == null)\n+        ;\n+      else if (type.equals(\"number\"))\n+        {\n+\t  formatClass = java.lang.Number.class;\n+\n+\t  if (style == null)\n+\t    format = NumberFormat.getInstance(loc);\n+\t  else if (style.equals(\"currency\"))\n+\t    format = NumberFormat.getCurrencyInstance(loc);\n+\t  else if (style.equals(\"percent\"))\n+\t    format = NumberFormat.getPercentInstance(loc);\n+\t  else if (style.equals(\"integer\"))\n+\t    {\n+\t      NumberFormat nf = NumberFormat.getNumberInstance(loc);\n+\t      nf.setMaximumFractionDigits(0);\n+\t      nf.setGroupingUsed(false);\n+\t      format = nf;\n+\t    }\n+\t  else\n+\t    {\n+\t      format = NumberFormat.getNumberInstance(loc);\n+\t      DecimalFormat df = (DecimalFormat) format;\n+\t      df.applyPattern(style);\n+\t    }\n+        }\n+      else if (type.equals(\"time\") || type.equals(\"date\"))\n+        {\n+\t  formatClass = java.util.Date.class;\n+\n+\t  int val = DateFormat.DEFAULT;\n+\t  if (style == null)\n+\t    ;\n+\t  else if (style.equals(\"short\"))\n+\t    val = DateFormat.SHORT;\n+\t  else if (style.equals(\"medium\"))\n+\t    val = DateFormat.MEDIUM;\n+\t  else if (style.equals(\"long\"))\n+\t    val = DateFormat.LONG;\n+\t  else if (style.equals(\"full\"))\n+\t    val = DateFormat.FULL;\n+\n+\t  if (type.equals(\"time\"))\n+\t    format = DateFormat.getTimeInstance(val, loc);\n+\t  else\n+\t    format = DateFormat.getDateInstance(val, loc);\n+\n+\t  if (style != null && val == DateFormat.DEFAULT)\n+\t    {\n+\t      SimpleDateFormat sdf = (SimpleDateFormat) format;\n+\t      sdf.applyPattern(style);\n+\t    }\n+        }\n+      else if (type.equals(\"choice\"))\n+        {\n+\t  formatClass = java.lang.Number.class;\n+\n+\t  if (style == null)\n+\t    throw new\n+\t      IllegalArgumentException (\"style required for choice format\");\n+\t  format = new ChoiceFormat (style);\n+        }\n+    }\n   }\n-}\n \n-public class MessageFormat extends Format\n-{\n   private static final long serialVersionUID = 6479157306784022952L;\n \n   public static class Field extends Format.Field"}]}