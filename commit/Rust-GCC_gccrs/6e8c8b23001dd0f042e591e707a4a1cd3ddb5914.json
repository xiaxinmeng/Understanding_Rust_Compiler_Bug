{"sha": "6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU4YzhiMjMwMDFkZDBmMDQyZTU5MWU3MDdhNGExY2QzZGRiNTkxNA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-05-31T12:17:06Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-05-31T12:17:06Z"}, "message": "Revert \"Fix PR debug/49047\"\n\nThis reverts commit ce20032a8ad4d9d4fa37192e2ecc73cb257094e8.\n\nFrom-SVN: r174473", "tree": {"sha": "71092f075f47e927d4c48dd0afb5918e087b8d10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71092f075f47e927d4c48dd0afb5918e087b8d10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/comments", "author": null, "committer": null, "parents": [{"sha": "874e7c171cd2af43b4dc9dddae981120e1b29e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874e7c171cd2af43b4dc9dddae981120e1b29e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874e7c171cd2af43b4dc9dddae981120e1b29e33"}], "stats": {"total": 186, "additions": 118, "deletions": 68}, "files": [{"sha": "192845576e84d2001c76c9a9816663654fac2355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -1,9 +1,3 @@\n-2011-05-31  Dodji Seketeli  <dodji@redhat.com>\n-\n-\tPR debug/49047\n-\t* dwarf2out.c (gen_subprogram_die): Emit linkage name attribute\n-\tfor concrete functions containing the code of cloned functions.\n-\n 2011-05-31  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-forwprop.c (forward_propagate_into_comparison): Rename"}, {"sha": "7ec1e931eed523dab0a53318d167b810a4ce83de", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -19636,12 +19636,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n       add_abstract_origin_attribute (subr_die, origin);\n-      /*  This is where the actual code for a cloned function is.\n-\t  Let's emit linkage name attribute for it.  This helps\n-\t  debuggers to e.g, set breakpoints into\n-\t  constructors/destructors when the user asks \"break\n-\t  K::K\".  */\n-      add_linkage_name (subr_die, decl);\n     }\n   else if (old_die)\n     {"}, {"sha": "3f7b52abf1899674dcea286fd8bf86ab3d0cdd3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -1,8 +1,3 @@\n-2011-05-31  Dodji Seketeli  <dodji@redhat.com>\n-\n-\tPR debug/49047\n-\t* g++.dg/debug/dwarf2/cdtor-1.C: New test.\n-\n 2011-05-31  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR testsuite/49239"}, {"sha": "6d39e54ae08aa6b5a15c63dfa6ec60a675397fa1", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/cdtor-1.C", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874e7c171cd2af43b4dc9dddae981120e1b29e33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fcdtor-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874e7c171cd2af43b4dc9dddae981120e1b29e33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fcdtor-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fcdtor-1.C?ref=874e7c171cd2af43b4dc9dddae981120e1b29e33", "patch": "@@ -1,17 +0,0 @@\n-// origin PR debug/49047\n-// { dg-options \"-g -dA\" }\n-// { dg-do compile }\n-\n-struct K\n-{\n-  K () { }\n-  ~K () { }\n-};\n-\n-int\n-main()\n-{\n-    K k;\n-}\n-\n-// { dg-final {scan-assembler-times \"\\[^\\n\\r\\]*DW_AT_MIPS_linkage_name:\" 2 } }"}, {"sha": "c0b2fa7c323649f7d53523026136d649395971fb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -1,14 +1,3 @@\n-2011-05-31  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\tPR libgcj/49193\n-\t* configure.host (sysdeps_dir): Set to i386 for x86_64.\n-\n-\t* sysdep/i386/locks.h (compare_and_swap): Call\n-\t__sync_bool_compare_and_swap.\n-\t(release_set): Call write_barrier ().\n-\n-\t* sysdep/x86-64/locks.h: Removed.\n-\n 2011-04-24  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* README: Refer to our generic bug reporting page."}, {"sha": "5b8847803b33b696cd04a7907e3a743aa257cfae", "filename": "libjava/configure.host", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -132,7 +132,7 @@ case \"${host}\" in\n \tslow_pthread_self=yes\n \t;;\n   x86_64-*)\n-\tsysdeps_dir=i386\n+\tsysdeps_dir=x86-64\n \t# For 64-bit we always use SSE registers for arithmetic,\n \t# which doesn't have the extra precision problems of the fpu.\n \t# But be careful about 32-bit multilibs.\n@@ -279,7 +279,7 @@ EOF\n         slow_pthread_self=\n         ;;\n   i[34567]86-*-solaris2.1[0-9]* )\n-\tsysdeps_dir=i386\n+\tsysdeps_dir=x86-64\n \tDIVIDESPEC=-f%{m32:no-}%{!m32:%{!m64:no-}}%{m64:}use-divide-subroutine\n \t;;\n   mips-sgi-irix6* )"}, {"sha": "9d130b0f515446c27d83c8673f02499ac4cf7d3b", "filename": "libjava/sysdep/i386/locks.h", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2Fsysdep%2Fi386%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2Fsysdep%2Fi386%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Flocks.h?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -1,6 +1,6 @@\n /* locks.h - Thread synchronization primitives. X86/x86-64 implementation.\n \n-   Copyright (C) 2002, 2011  Free Software Foundation\n+   Copyright (C) 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -23,25 +23,19 @@ compare_and_swap(volatile obj_addr_t *addr,\n \t\t obj_addr_t old,\n \t\t obj_addr_t new_val)\n {\n-  return __sync_bool_compare_and_swap (addr, old, new_val);\n-}\n-\n-// Ensure that subsequent instructions do not execute on stale\n-// data that was loaded from memory before the barrier.\n-// On X86/x86-64, the hardware ensures that reads are properly ordered.\n-inline static void\n-read_barrier()\n-{\n-}\n-\n-// Ensure that prior stores to memory are completed with respect to other\n-// processors.\n-inline static void\n-write_barrier()\n-{\n-  /* x86-64/X86 does not reorder writes. We just need to ensure that\n-     gcc also doesn't.  */\n-  __asm__ __volatile__(\" \" : : : \"memory\");\n+  char result;\n+#ifdef __x86_64__\n+  __asm__ __volatile__(\"lock; cmpxchgq %2, %0; setz %1\"\n+\t      : \"=m\"(*(addr)), \"=q\"(result)\n+\t      : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n+\t      : \"memory\");\n+#else\n+  __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n+\t\t       : \"=m\"(*addr), \"=q\"(result)\n+\t\t       : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n+\t\t       : \"memory\");\n+#endif\n+  return (bool) result;\n }\n \n // Set *addr to new_val with release semantics, i.e. making sure\n@@ -52,7 +46,7 @@ write_barrier()\n inline static void\n release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n {\n-  write_barrier ();\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n   *(addr) = new_val;\n }\n \n@@ -66,4 +60,22 @@ compare_and_swap_release(volatile obj_addr_t *addr,\n {\n   return compare_and_swap(addr, old, new_val);\n }\n+\n+// Ensure that subsequent instructions do not execute on stale\n+// data that was loaded from memory before the barrier.\n+// On X86/x86-64, the hardware ensures that reads are properly ordered.\n+inline static void\n+read_barrier()\n+{\n+}\n+\n+// Ensure that prior stores to memory are completed with respect to other\n+// processors.\n+inline static void\n+write_barrier()\n+{\n+  /* x86-64/X86 does not reorder writes. We just need to ensure that\n+     gcc also doesn't.  */\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n+}\n #endif"}, {"sha": "fdc0a3efb82594162c633d3fb316f12588a03036", "filename": "libjava/sysdep/x86-64/locks.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2Fsysdep%2Fx86-64%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c8b23001dd0f042e591e707a4a1cd3ddb5914/libjava%2Fsysdep%2Fx86-64%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fx86-64%2Flocks.h?ref=6e8c8b23001dd0f042e591e707a4a1cd3ddb5914", "patch": "@@ -0,0 +1,83 @@\n+/* locks.h - Thread synchronization primitives. X86/x86-64 implementation.\n+\n+   Copyright (C) 2002  Free Software Foundation\n+\n+   Contributed by Bo Thorsen <bo@suse.de>.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_LOCKS_H__\n+#define __SYSDEP_LOCKS_H__\n+\n+typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n+\t\t\t\t/* address.\t\t\t\t*/\n+\n+// Atomically replace *addr by new_val if it was initially equal to old.\n+// Return true if the comparison succeeded.\n+// Assumed to have acquire semantics, i.e. later memory operations\n+// cannot execute before the compare_and_swap finishes.\n+inline static bool\n+compare_and_swap(volatile obj_addr_t *addr,\n+\t\t obj_addr_t old,\n+\t\t obj_addr_t new_val)\n+{\n+  char result;\n+#ifdef __x86_64__\n+  __asm__ __volatile__(\"lock; cmpxchgq %2, %0; setz %1\"\n+\t      : \"=m\"(*(addr)), \"=q\"(result)\n+\t      : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n+\t      : \"memory\");\n+#else\n+  __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n+\t\t       : \"=m\"(*addr), \"=q\"(result)\n+\t\t       : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n+\t\t       : \"memory\");\n+#endif\n+  return (bool) result;\n+}\n+\n+// Set *addr to new_val with release semantics, i.e. making sure\n+// that prior loads and stores complete before this\n+// assignment.\n+// On X86/x86-64, the hardware shouldn't reorder reads and writes,\n+// so we just have to convince gcc not to do it either.\n+inline static void\n+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n+{\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n+  *(addr) = new_val;\n+}\n+\n+// Compare_and_swap with release semantics instead of acquire semantics.\n+// On many architecture, the operation makes both guarantees, so the\n+// implementation can be the same.\n+inline static bool\n+compare_and_swap_release(volatile obj_addr_t *addr,\n+\t\t\t obj_addr_t old,\n+\t\t\t obj_addr_t new_val)\n+{\n+  return compare_and_swap(addr, old, new_val);\n+}\n+\n+// Ensure that subsequent instructions do not execute on stale\n+// data that was loaded from memory before the barrier.\n+// On X86/x86-64, the hardware ensures that reads are properly ordered.\n+inline static void\n+read_barrier()\n+{\n+}\n+\n+// Ensure that prior stores to memory are completed with respect to other\n+// processors.\n+inline static void\n+write_barrier()\n+{\n+  /* x86-64/X86 does not reorder writes. We just need to ensure that\n+     gcc also doesn't.  */\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n+}\n+#endif"}]}