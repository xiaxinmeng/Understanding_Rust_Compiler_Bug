{"sha": "fe9821b88c042f37973f4ab2866a52dcb676446c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5ODIxYjg4YzA0MmYzNzk3M2Y0YWIyODY2YTUyZGNiNjc2NDQ2Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-05-01T11:18:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-05-01T11:18:01Z"}, "message": "tree.h (maybe_fold_offset_to_component_ref): Remove.\n\n\n\t* tree.h (maybe_fold_offset_to_component_ref): Remove.\n\t(maybe_fold_offset_to_reference): Declare.\n\t* fold-const.c (fold_unary): Do not fold\n\t(type *)&A into &A->field_of_type_and_offset_0\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): When base type\n\tsize is unknown, give up.\n\t(maybe_fold_offset_to_component_ref): Ignore firelds with unknown\n\toffsets.\n\t(maybe_fold_offset_to_reference): New.\n\t(maybe_fold_stmt_indirect): Use it.\n\t(fold_stmt_r): Fold (type *)&A+offset into A->field_if_type_and_offset.\n\t* gimplify.c (gimplify_conversion): Canonicalize conversions to\n\tfield references.\n\t(gimplify_expr): Likewise for plus_expr.\n\nFrom-SVN: r124323", "tree": {"sha": "bd72595e8b02806708c943137cbe687e4482667d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd72595e8b02806708c943137cbe687e4482667d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe9821b88c042f37973f4ab2866a52dcb676446c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9821b88c042f37973f4ab2866a52dcb676446c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9821b88c042f37973f4ab2866a52dcb676446c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9821b88c042f37973f4ab2866a52dcb676446c/comments", "author": null, "committer": null, "parents": [{"sha": "8b11009bad1b794283984fc806198e3cf29dbed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b11009bad1b794283984fc806198e3cf29dbed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b11009bad1b794283984fc806198e3cf29dbed3"}], "stats": {"total": 165, "additions": 135, "deletions": 30}, "files": [{"sha": "88d090a6ec8ab33f3fb045aba7e7ee1eeb71821b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe9821b88c042f37973f4ab2866a52dcb676446c", "patch": "@@ -1,3 +1,20 @@\n+2007-05-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.h (maybe_fold_offset_to_component_ref): Remove.\n+\t(maybe_fold_offset_to_reference): Declare.\n+\t* fold-const.c (fold_unary): Do not fold\n+\t(type *)&A into &A->field_of_type_and_offset_0\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): When base type\n+\tsize is unknown, give up.\n+\t(maybe_fold_offset_to_component_ref): Ignore firelds with unknown\n+\toffsets.\n+\t(maybe_fold_offset_to_reference): New.\n+\t(maybe_fold_stmt_indirect): Use it.\n+\t(fold_stmt_r): Fold (type *)&A+offset into A->field_if_type_and_offset.\n+\t* gimplify.c (gimplify_conversion): Canonicalize conversions to\n+\tfield references.\n+\t(gimplify_expr): Likewise for plus_expr.\n+\n 2007-05-01  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Use"}, {"sha": "6311be7e0848e72fcd6e1a440ff5d8cbf5889271", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fe9821b88c042f37973f4ab2866a52dcb676446c", "patch": "@@ -7748,13 +7748,6 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t    return fold_convert (type, build_fold_addr_expr (base));\n         }\n \n-      /* Convert (type *)&A into &A->field_of_type_and_offset_0.  */\n-      if (TREE_CODE (op0) == ADDR_EXPR && POINTER_TYPE_P (type)\n-\t  && (tem = maybe_fold_offset_to_component_ref\n-\t\t      (TREE_TYPE (TREE_OPERAND (op0, 0)), TREE_OPERAND (op0, 0),\n-\t\t       integer_zero_node, TREE_TYPE (type), false)))\n-        return build_fold_addr_expr_with_type (tem, type);\n-\n       if ((TREE_CODE (op0) == MODIFY_EXPR\n \t   || TREE_CODE (op0) == GIMPLE_MODIFY_STMT)\n \t  && TREE_CONSTANT (GENERIC_TREE_OPERAND (op0, 1))"}, {"sha": "805c3020272323babd0b1086afb6b1553fef28e2", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=fe9821b88c042f37973f4ab2866a52dcb676446c", "patch": "@@ -1617,6 +1617,7 @@ canonicalize_addr_expr (tree *expr_p)\n static enum gimplify_status\n gimplify_conversion (tree *expr_p)\n {\n+  tree tem;\n   gcc_assert (TREE_CODE (*expr_p) == NOP_EXPR\n \t      || TREE_CODE (*expr_p) == CONVERT_EXPR);\n   \n@@ -1627,6 +1628,17 @@ gimplify_conversion (tree *expr_p)\n   if (tree_ssa_useless_type_conversion (*expr_p))\n     *expr_p = TREE_OPERAND (*expr_p, 0);\n \n+  /* Attempt to avoid NOP_EXPR by producing reference to a subtype.\n+     For example this fold (subclass *)&A into &A->subclass avoiding\n+     a need for statement.  */\n+  if (TREE_CODE (*expr_p) == NOP_EXPR\n+      && POINTER_TYPE_P (TREE_TYPE (*expr_p))\n+      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n+      && (tem = maybe_fold_offset_to_reference\n+\t\t  (TREE_OPERAND (*expr_p, 0),\n+\t\t   integer_zero_node, TREE_TYPE (TREE_TYPE (*expr_p)))))\n+    *expr_p = build_fold_addr_expr_with_type (tem, TREE_TYPE (*expr_p));\n+\n   /* If we still have a conversion at the toplevel,\n      then canonicalize some constructs.  */\n   if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n@@ -5857,6 +5869,21 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n+\tcase PLUS_EXPR:\n+          /* Convert ((type *)A)+offset into &A->field_of_type_and_offset.\n+\t     The second is gimple immediate saving a need for extra statement.\n+\t   */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (*expr_p))\n+\t      && TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n+\t      && (tmp = maybe_fold_offset_to_reference\n+\t\t\t (TREE_OPERAND (*expr_p, 0), TREE_OPERAND (*expr_p, 1),\n+\t\t   \t  TREE_TYPE (TREE_TYPE (*expr_p)))))\n+\t     {\n+               *expr_p = build_fold_addr_expr_with_type (tmp,\n+\t\t\t\t\t\t\t TREE_TYPE (*expr_p));\n+\t\tbreak;\n+\t     }\n+          /* FALLTHRU */\n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {"}, {"sha": "6c9475540fefd6f27aa1e342e26121710a204cef", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 90, "deletions": 21, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=fe9821b88c042f37973f4ab2866a52dcb676446c", "patch": "@@ -1587,6 +1587,8 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n      Otherwise, compute the offset as an index by using a division.  If the\n      division isn't exact, then don't do anything.  */\n   elt_size = TYPE_SIZE_UNIT (elt_type);\n+  if (!elt_size)\n+    return NULL;\n   if (integer_zerop (offset))\n     {\n       if (TREE_CODE (elt_size) != INTEGER_CST)\n@@ -1647,12 +1649,11 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n }\n \n \n-/* A subroutine of fold_stmt_r.  Attempts to fold *(S+O) to S.X.\n+/* Attempt to fold *(S+O) to S.X.\n    BASE is a record type.  OFFSET is a byte displacement.  ORIG_TYPE\n    is the desired result type.  */\n-/* ??? This doesn't handle class inheritance.  */\n \n-tree\n+static tree\n maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \t\t\t\t    tree orig_type, bool base_is_ptr)\n {\n@@ -1679,6 +1680,8 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n       if (DECL_BIT_FIELD (f))\n \tcontinue;\n \n+      if (!DECL_FIELD_OFFSET (f))\n+\tcontinue;\n       field_offset = byte_position (f);\n       if (TREE_CODE (field_offset) != INTEGER_CST)\n \tcontinue;\n@@ -1766,6 +1769,69 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \t\t\t\t\t     orig_type, false);\n }\n \n+/* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE->field_of_orig_type\n+   or BASE[index] or by combination of those. \n+\n+   Before attempting the conversion strip off existing ADDR_EXPRs and\n+   handled component refs.  */\n+\n+tree\n+maybe_fold_offset_to_reference (tree base, tree offset, tree orig_type)\n+{\n+  tree ret;\n+  tree type;\n+  bool base_is_ptr = true;\n+\n+  STRIP_NOPS (base);\n+  if (TREE_CODE (base) == ADDR_EXPR)\n+    {\n+      base_is_ptr = false;\n+\n+      base = TREE_OPERAND (base, 0);\n+\n+      /* Handle case where existing COMPONENT_REF pick e.g. wrong field of union,\n+\t so it needs to be removed and new COMPONENT_REF constructed.\n+\t The wrong COMPONENT_REF are often constructed by folding the\n+\t (type *)&object within the expression (type *)&object+offset  */\n+      if (handled_component_p (base) && 0)\n+\t{\n+          HOST_WIDE_INT sub_offset, size, maxsize;\n+\t  tree newbase;\n+\t  newbase = get_ref_base_and_extent (base, &sub_offset,\n+\t\t\t\t\t     &size, &maxsize);\n+\t  gcc_assert (newbase);\n+\t  gcc_assert (!(sub_offset & (BITS_PER_UNIT - 1)));\n+\t  if (size == maxsize)\n+\t    {\n+\t      base = newbase;\n+\t      if (sub_offset)\n+\t\toffset = int_const_binop (PLUS_EXPR, offset,\n+\t\t\t\t\t  build_int_cst (TREE_TYPE (offset),\n+\t\t\t\t\t  sub_offset / BITS_PER_UNIT), 1);\n+\t    }\n+\t}\n+      if (lang_hooks.types_compatible_p (orig_type, TREE_TYPE (base))\n+\t  && integer_zerop (offset))\n+\treturn base;\n+      type = TREE_TYPE (base);\n+    }\n+  else\n+    {\n+      base_is_ptr = true;\n+      if (!POINTER_TYPE_P (TREE_TYPE (base)))\n+\treturn NULL_TREE;\n+      type = TREE_TYPE (TREE_TYPE (base));\n+    }\n+  ret = maybe_fold_offset_to_component_ref (type, base, offset,\n+\t\t\t\t\t    orig_type, base_is_ptr);\n+  if (!ret)\n+    {\n+      if (base_is_ptr)\n+\tbase = build1 (INDIRECT_REF, type, base);\n+      ret = maybe_fold_offset_to_array_ref (base, offset, orig_type);\n+    }\n+  return ret;\n+}\n \n /* A subroutine of fold_stmt_r.  Attempt to simplify *(BASE+OFFSET).\n    Return the simplified expression, or NULL if nothing could be done.  */\n@@ -1802,6 +1868,8 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n \n   if (TREE_CODE (base) == ADDR_EXPR)\n     {\n+      tree base_addr = base;\n+\n       /* Strip the ADDR_EXPR.  */\n       base = TREE_OPERAND (base, 0);\n \n@@ -1810,24 +1878,11 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n \t  && ccp_decl_initial_min_invariant (DECL_INITIAL (base)))\n \treturn DECL_INITIAL (base);\n \n-      /* Try folding *(&B+O) to B[X].  */\n-      t = maybe_fold_offset_to_array_ref (base, offset, TREE_TYPE (expr));\n-      if (t)\n-\treturn t;\n-\n       /* Try folding *(&B+O) to B.X.  */\n-      t = maybe_fold_offset_to_component_ref (TREE_TYPE (base), base, offset,\n-\t\t\t\t\t      TREE_TYPE (expr), false);\n+      t = maybe_fold_offset_to_reference (base_addr, offset,\n+\t\t\t\t\t  TREE_TYPE (expr));\n       if (t)\n \treturn t;\n-\n-      /* Fold *&B to B.  We can only do this if EXPR is the same type\n-\t as BASE.  We can't do this if EXPR is the element type of an array\n-\t and BASE is the array.  */\n-      if (integer_zerop (offset)\n-\t  && lang_hooks.types_compatible_p (TREE_TYPE (base),\n-\t\t\t\t\t    TREE_TYPE (expr)))\n-\treturn base;\n     }\n   else\n     {\n@@ -1856,9 +1911,8 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n       /* Try folding *(B+O) to B->X.  Still an improvement.  */\n       if (POINTER_TYPE_P (TREE_TYPE (base)))\n \t{\n-          t = maybe_fold_offset_to_component_ref (TREE_TYPE (TREE_TYPE (base)),\n-\t\t\t\t\t\t  base, offset,\n-\t\t\t\t\t\t  TREE_TYPE (expr), true);\n+          t = maybe_fold_offset_to_reference (base, offset,\n+\t\t\t\t              TREE_TYPE (expr));\n \t  if (t)\n \t    return t;\n \t}\n@@ -2020,6 +2074,21 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n \t\t\t\t    integer_zero_node);\n       break;\n \n+    case NOP_EXPR:\n+      t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n+      if (t)\n+\treturn t;\n+      *walk_subtrees = 0;\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (expr))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\t  && (t = maybe_fold_offset_to_reference\n+\t\t      (TREE_OPERAND (expr, 0),\n+\t\t       integer_zero_node,\n+\t\t       TREE_TYPE (TREE_TYPE (expr)))))\n+        t = build_fold_addr_expr_with_type (t, TREE_TYPE (expr));\n+      break;\n+\n       /* ??? Could handle more ARRAY_REFs here, as a variant of INDIRECT_REF.\n \t We'd only want to bother decomposing an existing ARRAY_REF if\n \t the base array is found to have another offset contained within."}, {"sha": "3059d40280436924a7472a244753c44f2877e3cf", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9821b88c042f37973f4ab2866a52dcb676446c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fe9821b88c042f37973f4ab2866a52dcb676446c", "patch": "@@ -4422,8 +4422,7 @@ extern void fold_defer_overflow_warnings (void);\n extern void fold_undefer_overflow_warnings (bool, tree, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n-extern tree maybe_fold_offset_to_component_ref (tree, tree, tree,\n-\t\t\t\t                tree, bool);\n+extern tree maybe_fold_offset_to_reference (tree, tree, tree);\n \n extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t   int, bool);"}]}