{"sha": "dea61d92828ce08a91a19523d3cc2eaf29b76acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVhNjFkOTI4MjhjZTA4YTkxYTE5NTIzZDNjYzJlYWYyOWI3NmFjZg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2008-02-28T12:37:24Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-02-28T12:37:24Z"}, "message": "invoke.texi: Document -ftree-loop-distribution.\n\n\t* doc/invoke.texi: Document -ftree-loop-distribution.\n\t* tree-loop-distribution.c: New.\n\t* tree-pass.h (pass_loop_distribution): New.\n\t* graphds.h (struct graph): Add htab_t indices.\n\t* timevar.def (TV_TREE_LOOP_DISTRIBUTION): New.\n\t* tree-vectorizer.c (rename_variables_in_loop): Extern.\n\t(slpeel_tree_duplicate_loop_to_edge_cfg): Init PENDING_STMT to NULL.\n\t* tree-vectorizer.h (tree_duplicate_loop_on_edge): Declared.\n\t* tree-data-ref.c (debug_data_dependence_relations): New.\n\t(dump_data_dependence_relation): Also print data references.\n\t(free_data_ref): Extern.\n\t(same_access_functions): Moved...\n\t(find_vertex_for_stmt): Renamed rdg_vertex_for_stmt.\n\t(dump_rdg_vertex, debug_rdg_vertex, dump_rdg_component,\n\tdebug_rdg_component, dump_rdg, debug_rdg, dot_rdg_1, dot_rdg,\n\tstruct rdg_vertex_info, rdg_vertex_for_stmt): New.\n\t(create_rdg_edge_for_ddr, create_rdg_vertices): Cleaned up.\n\t(stmts_from_loop): Skip LABEL_EXPR.\n\t(hash_stmt_vertex_info, eq_stmt_vertex_info, hash_stmt_vertex_del): New.\n\t(build_rdg): Initialize rdg->indices htab.\n\t(free_rdg, stores_from_loop, ref_base_address,\n\trdg_defs_used_in_other_loops_p, have_similar_memory_accesses,\n\thave_similar_memory_accesses_1, ref_base_address_1,\n\tremove_similar_memory_refs): New.\n\t* tree-data-ref.h: Depend on tree-chrec.h.\n\t(debug_data_dependence_relations, free_data_ref): Declared.\n\t(same_access_functions): ... here.\n\t(ddr_is_anti_dependent, ddrs_have_anti_deps, ddr_dependence_level): New.\n\t(struct rdg_vertex): Add has_mem_write and has_mem_reads.\n\t(RDGV_HAS_MEM_WRITE, RDGV_HAS_MEM_READS, RDG_STMT,\n\tRDG_MEM_WRITE_STMT, RDG_MEM_READS_STMT): New.\n\t(dump_rdg_vertex, debug_rdg_vertex, dump_rdg_component,\n\tdebug_rdg_component, dump_rdg, debug_rdg, dot_rdg,\n\trdg_vertex_for_stmt): Declared.\n\t(struct rdg_edge): Add level.\n\t(RDGE_LEVEL): New.\n\t(free_rdg, stores_from_loop, remove_similar_memory_refs,\n\trdg_defs_used_in_other_loops_p, have_similar_memory_accesses): Declared.\n\t(rdg_has_similar_memory_accesses): New.\n\t* tree-vect-analyze.c: Remove unused static decls.\n\t* lambda.h (dependence_level): New.\n\t* common.opt (ftree-loop-distribution): New.\n\t* tree-flow.h (mark_virtual_ops_in_bb, \n\tslpeel_tree_duplicate_loop_to_edge_cfg,\n\trename_variables_in_loop): Declared.\n\t* Makefile.in (TREE_DATA_REF_H): Depend on tree-chrec.h.\n\t(OBJS-common): Add tree-loop-distribution.o.\n\t(tree-loop-distribution.o): New rule.\n\t* tree-cfg.c (mark_virtual_ops_in_bb): New.\n\t(mark_virtual_ops_in_region): Use mark_virtual_ops_in_bb.\n\t* passes.c (init_optimization_passes): Schedule pass_loop_distribution.\n\n\t* testsuite/gcc.dg/tree-ssa/ldist-{1..12}.c: New.\n\nFrom-SVN: r132745", "tree": {"sha": "9b84bf0f68098103bdd76fd0c6c2fa17afc3dd07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b84bf0f68098103bdd76fd0c6c2fa17afc3dd07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dea61d92828ce08a91a19523d3cc2eaf29b76acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea61d92828ce08a91a19523d3cc2eaf29b76acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea61d92828ce08a91a19523d3cc2eaf29b76acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea61d92828ce08a91a19523d3cc2eaf29b76acf/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde75838e94cc9b22bc6210802b1849b2ae3f3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dde75838e94cc9b22bc6210802b1849b2ae3f3cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dde75838e94cc9b22bc6210802b1849b2ae3f3cf"}], "stats": {"total": 2431, "additions": 2326, "deletions": 105}, "files": [{"sha": "13854195354d8672c141bae510d9dfa0624d9058", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -1,3 +1,57 @@\n+2008-02-28  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* doc/invoke.texi: Document -ftree-loop-distribution.\n+\t* tree-loop-distribution.c: New.\n+\t* tree-pass.h (pass_loop_distribution): New.\n+\t* graphds.h (struct graph): Add htab_t indices.\n+\t* timevar.def (TV_TREE_LOOP_DISTRIBUTION): New.\n+\t* tree-vectorizer.c (rename_variables_in_loop): Extern.\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): Init PENDING_STMT to NULL.\n+\t* tree-vectorizer.h (tree_duplicate_loop_on_edge): Declared.\n+\t* tree-data-ref.c (debug_data_dependence_relations): New.\n+\t(dump_data_dependence_relation): Also print data references.\n+\t(free_data_ref): Extern.\n+\t(same_access_functions): Moved...\n+\t(find_vertex_for_stmt): Renamed rdg_vertex_for_stmt.\n+\t(dump_rdg_vertex, debug_rdg_vertex, dump_rdg_component,\n+\tdebug_rdg_component, dump_rdg, debug_rdg, dot_rdg_1, dot_rdg,\n+\tstruct rdg_vertex_info, rdg_vertex_for_stmt): New.\n+\t(create_rdg_edge_for_ddr, create_rdg_vertices): Cleaned up.\n+\t(stmts_from_loop): Skip LABEL_EXPR.\n+\t(hash_stmt_vertex_info, eq_stmt_vertex_info, hash_stmt_vertex_del): New.\n+\t(build_rdg): Initialize rdg->indices htab.\n+\t(free_rdg, stores_from_loop, ref_base_address,\n+\trdg_defs_used_in_other_loops_p, have_similar_memory_accesses,\n+\thave_similar_memory_accesses_1, ref_base_address_1,\n+\tremove_similar_memory_refs): New.\n+\t* tree-data-ref.h: Depend on tree-chrec.h.\n+\t(debug_data_dependence_relations, free_data_ref): Declared.\n+\t(same_access_functions): ... here.\n+\t(ddr_is_anti_dependent, ddrs_have_anti_deps, ddr_dependence_level): New.\n+\t(struct rdg_vertex): Add has_mem_write and has_mem_reads.\n+\t(RDGV_HAS_MEM_WRITE, RDGV_HAS_MEM_READS, RDG_STMT,\n+\tRDG_MEM_WRITE_STMT, RDG_MEM_READS_STMT): New.\n+\t(dump_rdg_vertex, debug_rdg_vertex, dump_rdg_component,\n+\tdebug_rdg_component, dump_rdg, debug_rdg, dot_rdg,\n+\trdg_vertex_for_stmt): Declared.\n+\t(struct rdg_edge): Add level.\n+\t(RDGE_LEVEL): New.\n+\t(free_rdg, stores_from_loop, remove_similar_memory_refs,\n+\trdg_defs_used_in_other_loops_p, have_similar_memory_accesses): Declared.\n+\t(rdg_has_similar_memory_accesses): New.\n+\t* tree-vect-analyze.c: Remove unused static decls.\n+\t* lambda.h (dependence_level): New.\n+\t* common.opt (ftree-loop-distribution): New.\n+\t* tree-flow.h (mark_virtual_ops_in_bb, \n+\tslpeel_tree_duplicate_loop_to_edge_cfg,\n+\trename_variables_in_loop): Declared.\n+\t* Makefile.in (TREE_DATA_REF_H): Depend on tree-chrec.h.\n+\t(OBJS-common): Add tree-loop-distribution.o.\n+\t(tree-loop-distribution.o): New rule.\n+\t* tree-cfg.c (mark_virtual_ops_in_bb): New.\n+\t(mark_virtual_ops_in_region): Use mark_virtual_ops_in_bb.\n+\t* passes.c (init_optimization_passes): Schedule pass_loop_distribution.\n+\n 2008-02-28  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR target/33963"}, {"sha": "5878d1411ccbde96b538f527a55d9ac285f17a34", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -838,7 +838,7 @@ DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H) options.h\n C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h $(TREE_H) vec.h $(GGC_H)\n-TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h graphds.h\n+TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h graphds.h tree-chrec.h\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n TREE_INLINE_H = tree-inline.h $(VARRAY_H) pointer-set.h\n REAL_H = real.h $(MACHMODE_H)\n@@ -1156,6 +1156,7 @@ OBJS-common = \\\n \ttree-if-conv.o \\\n \ttree-into-ssa.o \\\n \ttree-iterator.o \\\n+\ttree-loop-distribution.o \\\n \ttree-loop-linear.o \\\n \ttree-nested.o \\\n \ttree-nrv.o \\\n@@ -2283,6 +2284,11 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) $(LAMBDA_H) \\\n    $(TARGET_H) tree-chrec.h $(OBSTACK_H)\n+tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n+   tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) \\\n+   $(TARGET_H) tree-chrec.h tree-vectorizer.h\n tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_FLOW_H) $(TREE_H) $(RTL_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(GGC_H) \\\n    $(DIAGNOSTIC_H) tree-pass.h $(SCEV_H) langhooks.h gt-tree-parloops.h \\"}, {"sha": "74b3255afc78eaa9dea770b0ca4e95d445e277c1", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -1098,6 +1098,10 @@ ftree-fre\n Common Report Var(flag_tree_fre) Optimization\n Enable Full Redundancy Elimination (FRE) on trees\n \n+ftree-loop-distribution\n+Common Report Var(flag_tree_loop_distribution)\n+Enable loop distribution on trees\n+\n ftree-loop-im\n Common Report Var(flag_tree_loop_im) Init(1) Optimization\n Enable loop invariant motion on trees"}, {"sha": "dbd66eab30c6a671f3c9c44e64df38f4b4469ba4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -354,6 +354,7 @@ Objective-C and Objective-C++ Dialects}.\n -fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer -ftree-ccp @gol\n -ftree-ch -ftree-copy-prop -ftree-copyrename -ftree-dce @gol\n -ftree-dominator-opts -ftree-dse -ftree-fre -ftree-loop-im @gol\n+-ftree-loop-distribution @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-reassoc -ftree-salias @gol\n -ftree-sink -ftree-sra -ftree-store-ccp -ftree-ter @gol\n@@ -5928,6 +5929,11 @@ performance and allow further loop optimizations to take place.\n Compare the results of several data dependence analyzers.  This option\n is used for debugging the data dependence analyzers.\n \n+@item -ftree-loop-distribution\n+Perform loop distribution.  This flag can improve cache performance on\n+big loop bodies and allow further loop optimizations, like\n+parallelization or vectorization, to take place.\n+\n @item -ftree-loop-im\n @opindex ftree-loop-im\n Perform loop invariant motion on trees.  This pass moves only invariants that"}, {"sha": "83cf90c2e314514dbf30cbdc93dca09bd7af3f72", "filename": "gcc/graphds.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fgraphds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fgraphds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.h?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -47,6 +47,7 @@ struct graph\n   int n_vertices;\t/* Number of vertices.  */\n   struct vertex *vertices;\n \t\t\t/* The vertices.  */\n+  htab_t indices;\t/* Fast lookup for indices.  */\n };\n \n struct graph *new_graph (int);"}, {"sha": "641b3bcaa051c2d1a2b47a414436582b5067c1cb", "filename": "gcc/lambda.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -469,5 +469,22 @@ build_linear_expr (tree type, lambda_vector coefs, VEC (tree, heap) *ivs)\n   return expr;\n }\n \n+/* Returns the dependence level for a vector DIST of size LENGTH.\n+   LEVEL = 0 means a lexicographic dependence, i.e. a dependence due\n+   to the sequence of statements, not carried by any loop.  */\n+\n+\n+static inline unsigned\n+dependence_level (lambda_vector dist_vect, int length)\n+{\n+  int i;\n+\n+  for (i = 0; i < length; i++)\n+    if (dist_vect[i] != 0)\n+      return i + 1;\n+\n+  return 0;\n+}\n+\n #endif /* LAMBDA_H  */\n "}, {"sha": "bec473a06702cb51539b481adfd694a6fe66254b", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -625,6 +625,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_empty_loop);\n \t  NEXT_PASS (pass_record_bounds);\n \t  NEXT_PASS (pass_check_data_deps);\n+\t  NEXT_PASS (pass_loop_distribution);\n \t  NEXT_PASS (pass_linear_transform);\n \t  NEXT_PASS (pass_iv_canon);\n \t  NEXT_PASS (pass_if_conversion);"}, {"sha": "882de9891605817e7d6e59f4a39447833da83863", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -1,3 +1,20 @@\n+2008-02-28  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* testsuite/gcc.dg/tree-ssa/ldist-1.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-1a.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-2.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-3.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-4.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-5.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-6.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-7.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-8.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-9.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-10.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-11.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/ldist-12.c: New.\n+\t* testsuite/gfortran.dg/ldist-1.f90: New.\n+\n 2008-02-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/pr34351.c: Compile for x86 targets only.  Use %ebx register."}, {"sha": "43c1046652558ca5bb256e2905a0117bf566309b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-1.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+void foo (int * __restrict__ ia,\n+\t  int * __restrict__ ib,\n+\t  int * __restrict__ oxa,\n+\t  int * __restrict__ oxb,\n+\t  int * __restrict__ oya,\n+\t  int * __restrict__ oyb)\n+{\n+  int i;\n+  long int mya[52];\n+  long int myb[52];\n+\n+  for (i=0; i < 52; i++)\n+    {\n+      mya[i] = ia[i] * oxa[i] + ib[i] * oxb[i];\n+      myb[i] = -ia[i] * oxb[i] + ib[i] * oxa[i];\n+      oya[i] = mya[i] >> 10;\n+      oyb[i] = myb[i] >> 10;\n+    }\n+\n+  /* This loop was distributed, but it is not anymore due to the cost\n+     model changes: the result of a distribution would look like this:\n+\n+     |  for (i=0; i < 52; i++)\n+     |    oya[i] = ia[i] * oxa[i] + ib[i] * oxb[i] >> 10;\n+     |\n+     |  for (i=0; i < 52; i++)\n+     |    oyb[i] = -ia[i] * oxb[i] + ib[i] * oxa[i] >> 10;\n+\n+     and in this the array IA is read in both tasks.  For maximizing\n+     the cache reuse, ldist does not distributes this loop anymore.\n+  */\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "0790c18a9dae211269ee9096460d9b08f4e921af", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-10.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-10.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  int a[1000], b[1000], c[1000];\n+\n+  for (i = 1; i < 1000; i ++)\n+    {\n+      a[i] = c[i]; /* S1 */\n+      b[i] = a[i-1]+1; /* S2 */\n+    }\n+  /* Dependences:\n+     S1->S2 (flow, level 1)\n+\n+     One partition as A is used in both S1 and S2.\n+  */\n+\n+  return a[1000-2] + b[1000-1] + c[1000-2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "88651e7b72dc699b8b027a49b076019d5cf19eff", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-11.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-11.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+void foo (int * __restrict__ ia,\n+\t  int * __restrict__ ib,\n+\t  int * __restrict__ oxa,\n+\t  int * __restrict__ oxb,\n+\t  int * __restrict__ oya,\n+\t  int * __restrict__ oyb)\n+{\n+  int i;\n+  long int mya[52];\n+  long int myb[52];\n+\n+  for (i=0; i < 52; i++)\n+    {\n+      mya[i] = ia[i] * oxa[i] + ib[i] * oxb[i];\n+      myb[i] = -ia[i] * oxb[i] + ib[i] * oxa[i];\n+      oya[i] = 0;\n+      oyb[i] = myb[i] >> 10;\n+    }\n+\n+  /* This loop should be distributed, and the result should look like\n+     this:\n+     |  memset (oya, 0, 208);\n+     |  for (i=0; i < 52; i++)\n+     |    oyb[i] = -ia[i] * oxb[i] + ib[i] * oxa[i] >> 10;\n+  */\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 1 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated memset zero\" 1 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "1e555fe26ad9053ef3a3ed3814f44582d5076dbe", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-12.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-12.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int foo (int * __restrict__ ia,\n+\t int * __restrict__ ib,\n+\t int * __restrict__ oxa,\n+\t int * __restrict__ oxb)\n+{\n+  int i;\n+  int oya[52], oyb[52];\n+\n+  for (i=0; i < 52; i++)\n+    {\n+      oya[i] = (ia[i] * oxa[i]) >> 10;\n+      oyb[i] = (ib[i] * oxb[i]) >> 10;\n+    }\n+\n+  return oya[22] + oyb[21];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 1 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "623aacfdbf5e0dfa83edc797de4dfb4caada651c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-1a.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-1a.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int foo (int * __restrict__ ia,\n+\t int * __restrict__ ib,\n+\t int * __restrict__ oxa,\n+\t int * __restrict__ oxb)\n+{\n+  int i;\n+  int oya[52], oyb[52];\n+\n+  for (i=0; i < 52; i++)\n+    {\n+      oya[i] = (ia[i] * oxa[i] + ib[i] * oxb[i]) >> 10;\n+      oyb[i] = (-ia[i] * oxb[i] + ib[i] * oxa[i]) >> 10;\n+    }\n+\n+  return oya[22] + oyb[21];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "de98ccc4c30b424a4b5cdf57bf7b574407040159", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-2.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+void foo (int * __restrict__ a,\n+\t  int * __restrict__ b,\n+\t  int * __restrict__ c)\n+{\n+  int i;\n+\n+  for (i=1; i < 10; i++)\n+    {\n+      a[i] += c[i];\n+      b[i] = a[i - 1] + 1;\n+    }\n+\n+  /* This loop is not distributed because the cost of spliting it:\n+\n+     |  for (i=1; i < N; i++)\n+     |    a[i] += c[i];\n+     |\n+     |  for (i=1; i < N; i++)\n+     |    b[i] = a[i - 1] + 1;\n+\n+     is higher due to data in array A that is written and then read in\n+     another task.  The cost model should forbid the transformation in\n+     this case.\n+  */\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "524fb4542b8501d5730316d6d1cb9d47a4981b73", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-3.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  int a[10000], b[10000], c[10000], d[10000];\n+\t\n+  a[0] = k; a[3] = k*2;\n+  c[1] = k+1;\n+  for (i = 2; i < (10000-1); i ++)\n+    {\n+      a[i] = k * i; /* S1 */\n+      b[i] = a[i-2] + k; /* S2 */\n+      c[i] = b[i] + a[i+1]; /* S3 */\n+      d[i] = c[i-1] + k + i; /* S4 */\n+    }\n+  /*\n+    Dependences:\n+    S1 -> S2 (flow, level 1)\n+    S1 -> S3 (anti, level 1)\n+    S2 -> S3 (flow, level 0)\n+    S3 -> S4 (flow, level 1)\n+\n+    There are three partitions: {S1, S3}, {S2} and {S4}.\n+\n+    The cost model should fuse together all the partitions, as they\n+    are reusing the same data, ending on a single partition.\n+  */\n+  return a[10000-2] + b[10000-1] + c[10000-2] + d[10000-2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 3 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "c9b1293f0f29d1a006fc61802e4ba50492ae9610", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  unsigned int j;\n+  int a[100], b[100][100];\n+\n+  a[0] = k;\n+  for (i = 1; i < 100; i ++)\n+    {\n+      for (j = 0; j < 100; j++)\n+\t{\n+\t  a[j] = k * i;\n+\t  b[i][j] = a[j-1] + k;\n+\t}\n+    }\n+\n+  return b[100-1][0];\n+}\n+\n+/* We used to distribute also innermost loops, but these could produce\n+   too much code in the outer loop, degrading performance of scalar\n+   code.  So this test is XFAILed because the cost model of the stand\n+   alone distribution pass has evolved.  */\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "af74557024e98c8c65e33c4f3b09929e3062ebc8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-5.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-5.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  unsigned int j;\n+  int a[100][100], b[100][100], c[100][100], d[100][100];\n+\n+  a[0][0] = k;\n+  for (i = 1; i < 100; i ++)\n+    for (j = 1; j < (100-1); j++) \n+      {   \n+        a[i][j] = k * i; /* S1 */\n+        b[i][j] = a[i][j-1] + k; /* S2 */\n+        c[i][j] = b[i][j] + a[i][j+1]; /* S3 */\n+        d[i][j] = c[i][j] + k + i; /* S4 */\n+      }\n+  /* Dependences:\n+     S1->S2 (flow, level 2)\n+     S1->S3 (anti, level 2)\n+     S2->S3 (flow, level 0)\n+     S3->S4 (flow, level 0)\n+  */\n+  \n+  return a[100-1][100-1] + b[100-1][100-1] + c[100-1][100-1] + d[100-1][100-1];\n+}\n+\n+/* FIXME: This is XFAILed because of a data dependence analysis\n+   problem: the dependence test fails with a \"don't know\" relation.  */\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 1 \"ldist\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "7a38c86832b0f90f933e8ca6dd57ef9af89ff0a3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-6.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-6.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  int a[1000], b[1000], c[1000], d[1000];\n+\n+  for (i = 2; i < (1000-1); i ++) {\n+    a[i] = k * i; /* S1 */\n+    b[i] = a[i-2] + k; /* S2 */\n+    c[i] = b[i-1] + a[i+1]; /* S3 */\n+    d[i] = c[i-1] + k + i; /* S4 */\n+  }\n+  /* Dependences:\n+     S1->S2 (flow, level 1)\n+     S2->S3 (flow, level 1)\n+     S3->S1 (anti, level 1)\n+     S3->S4 (flow, level 1)\n+\n+    There are two partitions: {S1, S2, S3} and {S4}.\n+\n+    {S1, S2, S3} have to be in the same partition because:\n+    - S1 (i) has to be executed before S2 (i+2), as S1 produces a[i] that is then consumed 2 iterations later by S2.\n+    - S2 (i) has to be executed before S3 (i+1), as S2 produces b[i] that is then consumed one iteration later by S3,\n+    - S3 (i) has to be executed before S1 (i+1), as a[i+1] has to execute before the update to a[i],\n+\n+    {S4} is the consumer partition: it consumes the values from array \"c\" produced in S3.\n+\n+    The cost model should fuse all the tasks together as the cost of\n+    fetching data from caches is too high.\n+  */\n+\n+  return a[1000-2] + b[1000-1] + c[1000-2] + d[1000-2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "124fcdedd03b7a84b802a680c3fb397ff156657b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-7.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-7.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i, z;\n+  int a[1000], b[1000], c[1000], d[1000];\n+\n+  for (i = 2; i < (1000-1); i ++) {\n+    z = a[i+1]; /* S1 */\n+    a[i] = k * i; /* S2 */\n+    b[i] = a[i-2] + k; /* S3 */\n+    c[i] = b[i-1] + z; /* S4 */\n+    d[i] = c[i-1] + b[i+1] + k + i; /* S5 */\n+  }\n+  /* Dependences:\n+     S1->S2 (anti, level 1)\n+     S1->S4 (flow, level 1, scalar)\n+     S2->S3 (flow, level 1)\n+     S3->S4 (flow, level 1)\n+     S4->S5 (flow, level 1)\n+     S5->S3 (anti, level 1)\n+\n+     There is a single partition: {S1, S2, S3, S4, S5}, because of the\n+     scalar dependence z between the two partitions {S1, S2} and {S3, S4, S5}.\n+  */\n+\n+  return a[1000-2] + b[1000-1] + c[1000-2] + d[1000-2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "4a8e0660061ada7b82482c81624c8ae981fa79ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-8.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-8.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  int a[1000], b[1000], c[1000], d[1000];\n+\n+  for (i = 2; i < (1000-1); i ++)\n+    {\n+      a[i] = k * i; /* S1 */\n+      b[i] = a[i+1] + k; /* S2 */\n+      c[i] = a[i-1] + b[i-1] + d[i-1]; /* S3 */\n+      d[i] = a[i-1] + b[i+1] + k + i; /* S4 */\n+    }\n+  /* Dependences:\n+     S1->S2 (anti, level 1)\n+     S1->S3 (flow, level 1)\n+     S1->S4 (flow, level 1)\n+     S2->S3 (flow, level 1)\n+     S2->S4 (anti, level 1)\n+     S4->S3 (flow, level 1)\n+\n+     Two partitions: {S1, S2, S4} produce information that is consumed in {S3}.\n+\n+     So that means that the current cost model will also fuse these\n+     two partitions into a single one for avoiding cache misses.\n+  */\n+\n+  return a[1000-2] + b[1000-1] + c[1000-2] + d[1000-2];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "ee8d023dee304915207bbb19815c178d4b973d67", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-9.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-9.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" } */\n+\n+int loop1 (int k)\n+{\n+  unsigned int i;\n+  int a[1000], b[1000];\n+\n+  for (i = 1; i < (1000-1); i ++) {\n+    a[i] = a[i+1] + a[i-1]; /* S1 */\n+    b[i] = a[i-1] + k; /* S2 */\n+  }\n+  /*\n+    Dependences:\n+    S1->S2 (flow, level 1)\n+    S1->S1 (anti, level 1)\n+    S1->S1 (flow, level 1)\n+\n+    One partition, because of the cost of cache misses.\n+  */\n+\n+  return a[1000-2] + b[1000-1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "dd1f02a176b14731d661a4f94d2b6521eff267c7", "filename": "gcc/testsuite/gfortran.dg/ldist-1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fldist-1.f90?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }     \n+! { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-all\" }\n+\n+Subroutine PADEC(DKS,DKDS,HVAR,WM,WG,FN,NS,AN,BN,CN,IT)\n+  IMPLICIT REAL*8 (A-H, O-Z)\n+  DIMENSION DKS(*),DKDS(*),HVAR(*)\n+  COMPLEX*16 WM(*),WG(*),FN(*),AN(*),BN(*),CN(*)\n+  COMPLEX*16 H2,CONST\n+  COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP\n+  Parameter (F1 = .8333333333333333D0, F2 = .0833333333333333D0)\n+\n+  SS=DT/(2.0D0)\n+\n+  do J=2,NS\n+     BS=SS*DKS(J)*HVAR(J)*HVAR(J)\n+     AN(J)=F1+2.*BS\n+     BN(J)=F2-BS\n+     CN(J)=F2-BS\n+     H2=WM(J+1)\n+\n+     if(J.EQ.NS) then\n+        CONST=CN(J)*H2\n+     else\n+        CONST=(0.D0,0.D0)\n+     endif\n+     FN(J)=(BS+F2)*(H2)+(F1-2.D0*BS)-CONST\n+  end do\n+\n+  return\n+end Subroutine PADEC\n+\n+! { dg-final { scan-tree-dump-times \"distributed: split to 4 loops\" 1 \"ldist\" } }\n+! { dg-final { cleanup-tree-dump \"ldist\" } }"}, {"sha": "1091724540cce361c8ee9a1dc68fa81252291662", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -123,6 +123,7 @@ DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, \"tree parallelize loops\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n+DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, \"tree loop distribution\")\n DEFTIMEVAR (TV_CHECK_DATA_DEPS       , \"tree check data dependences\")\n DEFTIMEVAR (TV_TREE_PREFETCH\t     , \"tree prefetching\")\n DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")"}, {"sha": "844e7c14a0e797853cbf73e1cb00d9544da95b59", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -5646,22 +5646,30 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n /* Marks virtual operands of all statements in basic blocks BBS for\n    renaming.  */\n \n-static void\n-mark_virtual_ops_in_region (VEC (basic_block,heap) *bbs)\n+void\n+mark_virtual_ops_in_bb (basic_block bb)\n {\n   tree phi;\n   block_stmt_iterator bsi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    mark_virtual_ops_for_renaming (phi);\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    mark_virtual_ops_for_renaming (bsi_stmt (bsi));\n+}\n+\n+/* Marks virtual operands of all statements in basic blocks BBS for\n+   renaming.  */\n+\n+static void\n+mark_virtual_ops_in_region (VEC (basic_block,heap) *bbs)\n+{\n   basic_block bb;\n   unsigned i;\n \n   for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n-    {\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tmark_virtual_ops_for_renaming (phi);\n-\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tmark_virtual_ops_for_renaming (bsi_stmt (bsi));\n-    }\n+    mark_virtual_ops_in_bb (bb);\n }\n \n /* Move basic block BB from function CFUN to function DEST_FN.  The"}, {"sha": "70266034aab51ff6990ee13ee5b07494efb7ed5c", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 484, "deletions": 54, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -88,7 +88,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"timevar.h\"\n #include \"cfgloop.h\"\n-#include \"tree-chrec.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n@@ -157,6 +156,14 @@ dump_data_references (FILE *file, VEC (data_reference_p, heap) *datarefs)\n     dump_data_reference (file, dr);\n }\n \n+/* Dump to STDERR all the dependence relations from DDRS.  */ \n+\n+void \n+debug_data_dependence_relations (VEC (ddr_p, heap) *ddrs)\n+{\n+  dump_data_dependence_relations (stderr, ddrs);\n+}\n+\n /* Dump into FILE all the dependence relations from DDRS.  */ \n \n void \n@@ -354,6 +361,10 @@ dump_data_dependence_relation (FILE *outf,\n   dra = DDR_A (ddr);\n   drb = DDR_B (ddr);\n   fprintf (outf, \"(Data Dep: \\n\");\n+\n+  dump_data_reference (outf, dra);\n+  dump_data_reference (outf, drb);\n+\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     fprintf (outf, \"    (don't know)\\n\");\n   \n@@ -808,7 +819,7 @@ dr_address_invariant_p (struct data_reference *dr)\n \n /* Frees data reference DR.  */\n \n-static void\n+void\n free_data_ref (data_reference_p dr)\n {\n   BITMAP_FREE (DR_VOPS (dr));\n@@ -2787,22 +2798,6 @@ build_classic_dist_vector_1 (struct data_dependence_relation *ddr,\n   return true;\n }\n \n-/* Return true when the DDR contains two data references that have the\n-   same access functions.  */\n-\n-static bool\n-same_access_functions (const struct data_dependence_relation *ddr)\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n-    if (!eq_evolutions_p (DR_ACCESS_FN (DDR_A (ddr), i),\n-\t\t\t  DR_ACCESS_FN (DDR_B (ddr), i)))\n-      return false;\n-\n-  return true;\n-}\n-\n /* Return true when the DDR contains only constant access functions.  */\n \n static bool\n@@ -4371,48 +4366,219 @@ free_data_refs (VEC (data_reference_p, heap) *datarefs)\n \n \f\n \n-/* Returns the index of STMT in RDG.  */\n+/* Dump vertex I in RDG to FILE.  */\n \n-static int\n-find_vertex_for_stmt (const struct graph *rdg, const_tree stmt)\n+void\n+dump_rdg_vertex (FILE *file, struct graph *rdg, int i)\n+{\n+  struct vertex *v = &(rdg->vertices[i]);\n+  struct graph_edge *e;\n+\n+  fprintf (file, \"(vertex %d: (%s%s) (in:\", i, \n+\t   RDG_MEM_WRITE_STMT (rdg, i) ? \"w\" : \"\",\n+\t   RDG_MEM_READS_STMT (rdg, i) ? \"r\" : \"\");\n+\n+  if (v->pred)\n+    for (e = v->pred; e; e = e->pred_next)\n+      fprintf (file, \" %d\", e->src);\n+\n+  fprintf (file, \") (out:\");\n+\n+  if (v->succ)\n+    for (e = v->succ; e; e = e->succ_next)\n+      fprintf (file, \" %d\", e->dest);\n+\n+  fprintf (file, \") \\n\");\n+  print_generic_stmt (file, RDGV_STMT (v), TDF_VOPS|TDF_MEMSYMS);\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Call dump_rdg_vertex on stderr.  */\n+\n+void\n+debug_rdg_vertex (struct graph *rdg, int i)\n+{\n+  dump_rdg_vertex (stderr, rdg, i);\n+}\n+\n+/* Dump component C of RDG to FILE.  If DUMPED is non-null, set the\n+   dumped vertices to that bitmap.  */\n+\n+void dump_rdg_component (FILE *file, struct graph *rdg, int c, bitmap dumped)\n+{\n+  int i;\n+\n+  fprintf (file, \"(%d\\n\", c);\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    if (rdg->vertices[i].component == c)\n+      {\n+\tif (dumped)\n+\t  bitmap_set_bit (dumped, i);\n+\n+\tdump_rdg_vertex (file, rdg, i);\n+      }\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Call dump_rdg_vertex on stderr.  */\n+\n+void\n+debug_rdg_component (struct graph *rdg, int c)\n+{\n+  dump_rdg_component (stderr, rdg, c, NULL);\n+}\n+\n+/* Dump the reduced dependence graph RDG to FILE.  */\n+\n+void\n+dump_rdg (FILE *file, struct graph *rdg)\n {\n   int i;\n+  bitmap dumped = BITMAP_ALLOC (NULL);\n+\n+  fprintf (file, \"(rdg\\n\");\n \n   for (i = 0; i < rdg->n_vertices; i++)\n-    if (RDGV_STMT (&(rdg->vertices[i])) == stmt)\n-      return i;\n+    if (!bitmap_bit_p (dumped, i))\n+      dump_rdg_component (file, rdg, rdg->vertices[i].component, dumped);\n \n-  gcc_unreachable ();\n-  return 0;\n+  fprintf (file, \")\\n\");\n+  BITMAP_FREE (dumped);\n }\n \n-/* Creates an edge in RDG for each distance vector from DDR.  */\n+/* Call dump_rdg on stderr.  */\n+\n+void\n+debug_rdg (struct graph *rdg)\n+{\n+  dump_rdg (stderr, rdg);\n+}\n \n static void\n-create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n+dot_rdg_1 (FILE *file, struct graph *rdg)\n {\n-  int va, vb;\n-  data_reference_p dra;\n-  data_reference_p drb;\n-  struct graph_edge *e;\n+  int i;\n+\n+  fprintf (file, \"digraph RDG {\\n\");\n \n-  if (DDR_REVERSED_P (ddr))\n+  for (i = 0; i < rdg->n_vertices; i++)\n     {\n-      dra = DDR_B (ddr);\n-      drb = DDR_A (ddr);\n+      struct vertex *v = &(rdg->vertices[i]);\n+      struct graph_edge *e;\n+\n+      /* Highlight reads from memory.  */\n+      if (RDG_MEM_READS_STMT (rdg, i))\n+\tfprintf (file, \"%d [style=filled, fillcolor=green]\\n\", i);\n+\n+      /* Highlight stores to memory.  */\n+      if (RDG_MEM_WRITE_STMT (rdg, i))\n+\tfprintf (file, \"%d [style=filled, fillcolor=red]\\n\", i);\n+\n+      if (v->succ)\n+\tfor (e = v->succ; e; e = e->succ_next)\n+\t  switch (RDGE_TYPE (e))\n+\t    {\n+\t    case input_dd:\n+\t      fprintf (file, \"%d -> %d [label=input] \\n\", i, e->dest);\n+\t      break;\n+\n+\t    case output_dd:\n+\t      fprintf (file, \"%d -> %d [label=output] \\n\", i, e->dest);\n+\t      break;\n+\n+\t    case flow_dd:\n+\t      /* These are the most common dependences: don't print these. */\n+\t      fprintf (file, \"%d -> %d \\n\", i, e->dest);\n+\t      break;\n+\n+\t    case anti_dd:\n+\t      fprintf (file, \"%d -> %d [label=anti] \\n\", i, e->dest);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n     }\n-  else\n+\n+  fprintf (file, \"}\\n\\n\");\n+}\n+\n+/* Display SCOP using dotty.  */\n+\n+void\n+dot_rdg (struct graph *rdg)\n+{\n+  FILE *file = fopen (\"/tmp/rdg.dot\", \"w\");\n+  gcc_assert (file != NULL);\n+\n+  dot_rdg_1 (file, rdg);\n+  fclose (file);\n+\n+  system (\"dotty /tmp/rdg.dot\");\n+}\n+\n+\n+/* This structure is used for recording the mapping statement index in\n+   the RDG.  */\n+\n+struct rdg_vertex_info GTY(())\n+{\n+  tree stmt;\n+  int index;\n+};\n+\n+/* Returns the index of STMT in RDG.  */\n+\n+int\n+rdg_vertex_for_stmt (struct graph *rdg, tree stmt)\n+{\n+  struct rdg_vertex_info rvi, *slot;\n+\n+  rvi.stmt = stmt;\n+  slot = (struct rdg_vertex_info *) htab_find (rdg->indices, &rvi);\n+\n+  if (!slot)\n+    return -1;\n+\n+  return slot->index;\n+}\n+\n+/* Creates an edge in RDG for each distance vector from DDR.  The\n+   order that we keep track of in the RDG is the order in which\n+   statements have to be executed.  */\n+\n+static void\n+create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n+{\n+  struct graph_edge *e;\n+  int va, vb;\n+  data_reference_p dra = DDR_A (ddr);\n+  data_reference_p drb = DDR_B (ddr);\n+  unsigned level = ddr_dependence_level (ddr);\n+\n+  /* For non scalar dependences, when the dependence is REVERSED,\n+     statement B has to be executed before statement A.  */\n+  if (level > 0\n+      && !DDR_REVERSED_P (ddr))\n     {\n-      dra = DDR_A (ddr);\n-      drb = DDR_B (ddr);\n+      data_reference_p tmp = dra;\n+      dra = drb;\n+      drb = tmp;\n     }\n \n-  va = find_vertex_for_stmt (rdg, DR_STMT (dra));\n-  vb = find_vertex_for_stmt (rdg, DR_STMT (drb));\n+  va = rdg_vertex_for_stmt (rdg, DR_STMT (dra));\n+  vb = rdg_vertex_for_stmt (rdg, DR_STMT (drb));\n+\n+  if (va < 0 || vb < 0)\n+    return;\n \n   e = add_edge (rdg, va, vb);\n   e->data = XNEW (struct rdg_edge);\n \n+  RDGE_LEVEL (e) = level;\n+\n   /* Determines the type of the data dependence.  */\n   if (DR_IS_READ (dra) && DR_IS_READ (drb))\n     RDGE_TYPE (e) = input_dd;\n@@ -4435,9 +4601,13 @@ create_rdg_edges_for_scalar (struct graph *rdg, tree def, int idef)\n            \n   FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, def)\n     {\n-      int use = find_vertex_for_stmt (rdg, USE_STMT (imm_use_p));\n-      struct graph_edge *e = add_edge (rdg, idef, use);\n+      struct graph_edge *e;\n+      int use = rdg_vertex_for_stmt (rdg, USE_STMT (imm_use_p));\n \n+      if (use < 0)\n+\tcontinue;\n+\n+      e = add_edge (rdg, idef, use);\n       e->data = XNEW (struct rdg_edge);\n       RDGE_TYPE (e) = flow_dd;\n     }\n@@ -4458,8 +4628,8 @@ create_rdg_edges (struct graph *rdg, VEC (ddr_p, heap) *ddrs)\n       create_rdg_edge_for_ddr (rdg, ddr);\n \n   for (i = 0; i < rdg->n_vertices; i++)\n-    FOR_EACH_PHI_OR_STMT_DEF (def_p, RDGV_STMT (&(rdg->vertices[i])),\n-\t\t\t      iter, SSA_OP_ALL_DEFS)\n+    FOR_EACH_PHI_OR_STMT_DEF (def_p, RDG_STMT (rdg, i),\n+\t\t\t      iter, SSA_OP_DEF)\n       create_rdg_edges_for_scalar (rdg, DEF_FROM_PTR (def_p), i);\n }\n \n@@ -4468,19 +4638,50 @@ create_rdg_edges (struct graph *rdg, VEC (ddr_p, heap) *ddrs)\n static void\n create_rdg_vertices (struct graph *rdg, VEC (tree, heap) *stmts)\n {\n-  int i;\n-  tree s;\n+  int i, j;\n+  tree stmt;\n \n-  for (i = 0; VEC_iterate (tree, stmts, i, s); i++)\n+  for (i = 0; VEC_iterate (tree, stmts, i, stmt); i++)\n     {\n+      VEC (data_ref_loc, heap) *references;\n+      data_ref_loc *ref;\n       struct vertex *v = &(rdg->vertices[i]);\n+      struct rdg_vertex_info *rvi = XNEW (struct rdg_vertex_info);\n+      struct rdg_vertex_info **slot;\n+\n+      rvi->stmt = stmt;\n+      rvi->index = i;\n+      slot = (struct rdg_vertex_info **) htab_find_slot (rdg->indices, rvi, INSERT);\n+\n+      if (!*slot)\n+\t*slot = rvi;\n+      else\n+\tfree (rvi);\n \n       v->data = XNEW (struct rdg_vertex);\n-      RDGV_STMT (v) = s;\n+      RDG_STMT (rdg, i) = stmt;\n+\n+      RDG_MEM_WRITE_STMT (rdg, i) = false;\n+      RDG_MEM_READS_STMT (rdg, i) = false;\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\tcontinue;\n+\n+      get_references_in_stmt (stmt, &references);\n+      for (j = 0; VEC_iterate (data_ref_loc, references, j, ref); j++)\n+\tif (!ref->is_read)\n+\t  RDG_MEM_WRITE_STMT (rdg, i) = true;\n+\telse\n+\t  RDG_MEM_READS_STMT (rdg, i) = true;\n+\n+      VEC_free (data_ref_loc, heap, references);\n     }\n }\n \n-/* Initialize STMTS with all the statements and PHI nodes of LOOP.  */\n+/* Initialize STMTS with all the statements of LOOP.  When\n+   INCLUDE_PHIS is true, include also the PHI nodes.  The order in\n+   which we discover statements is important as\n+   generate_loops_for_partition is using the same traversal for\n+   identifying statements. */\n \n static void\n stmts_from_loop (struct loop *loop, VEC (tree, heap) **stmts)\n@@ -4490,15 +4691,16 @@ stmts_from_loop (struct loop *loop, VEC (tree, heap) **stmts)\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      tree phi;\n+      tree phi, stmt;\n       basic_block bb = bbs[i];\n       block_stmt_iterator bsi;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \tVEC_safe_push (tree, heap, *stmts, phi);\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tVEC_safe_push (tree, heap, *stmts, bsi_stmt (bsi));\n+\tif (TREE_CODE (stmt = bsi_stmt (bsi)) != LABEL_EXPR)\n+\t  VEC_safe_push (tree, heap, *stmts, stmt);\n     }\n \n   free (bbs);\n@@ -4519,8 +4721,39 @@ known_dependences_p (VEC (ddr_p, heap) *dependence_relations)\n   return true;\n }\n \n-/* Build a Reduced Dependence Graph with one vertex per statement of the\n-   loop nest and one edge per data dependence or scalar dependence.  */\n+/* Computes a hash function for element ELT.  */\n+\n+static hashval_t\n+hash_stmt_vertex_info (const void *elt)\n+{\n+  struct rdg_vertex_info *rvi = (struct rdg_vertex_info *) elt;\n+  tree stmt = rvi->stmt;\n+\n+  return htab_hash_pointer (stmt);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+static int\n+eq_stmt_vertex_info (const void *e1, const void *e2)\n+{\n+  const struct rdg_vertex_info *elt1 = (const struct rdg_vertex_info *) e1;\n+  const struct rdg_vertex_info *elt2 = (const struct rdg_vertex_info *) e2;\n+\n+  return elt1->stmt == elt2->stmt;\n+}\n+\n+/* Free the element E.  */\n+\n+static void\n+hash_stmt_vertex_del (void *e)\n+{\n+  free (e);\n+}\n+\n+/* Build the Reduced Dependence Graph (RDG) with one vertex per\n+   statement of the loop nest, and one edge per data dependence or\n+   scalar dependence.  */\n \n struct graph *\n build_rdg (struct loop *loop)\n@@ -4529,20 +4762,23 @@ build_rdg (struct loop *loop)\n   struct graph *rdg = NULL;\n   VEC (ddr_p, heap) *dependence_relations;\n   VEC (data_reference_p, heap) *datarefs;\n-  VEC (tree, heap) *stmts = VEC_alloc (tree, heap, 10);\n+  VEC (tree, heap) *stmts = VEC_alloc (tree, heap, nb_data_refs);\n   \n   dependence_relations = VEC_alloc (ddr_p, heap, nb_data_refs * nb_data_refs) ;\n   datarefs = VEC_alloc (data_reference_p, heap, nb_data_refs);\n   compute_data_dependences_for_loop (loop, \n                                      false,\n                                      &datarefs,\n                                      &dependence_relations);\n-  \n+\n   if (!known_dependences_p (dependence_relations))\n     goto end_rdg;\n \n   stmts_from_loop (loop, &stmts);\n   rdg = new_graph (VEC_length (tree, stmts));\n+\n+  rdg->indices = htab_create (nb_data_refs, hash_stmt_vertex_info,\n+\t\t\t      eq_stmt_vertex_info, hash_stmt_vertex_del);\n   create_rdg_vertices (rdg, stmts);\n   create_rdg_edges (rdg, dependence_relations);\n \n@@ -4553,3 +4789,197 @@ build_rdg (struct loop *loop)\n \n   return rdg;\n }\n+\n+/* Free the reduced dependence graph RDG.  */\n+\n+void\n+free_rdg (struct graph *rdg)\n+{\n+  int i;\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    free (rdg->vertices[i].data);\n+\n+  htab_delete (rdg->indices);\n+  free_graph (rdg);\n+}\n+\n+/* Initialize STMTS with all the statements of LOOP that contain a\n+   store to memory.  */\n+\n+void\n+stores_from_loop (struct loop *loop, VEC (tree, heap) **stmts)\n+{\n+  unsigned int i;\n+  basic_block *bbs = get_loop_body_in_dom_order (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      block_stmt_iterator bsi;\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tif (!ZERO_SSA_OPERANDS (bsi_stmt (bsi), SSA_OP_VDEF))\n+\t  VEC_safe_push (tree, heap, *stmts, bsi_stmt (bsi));\n+    }\n+\n+  free (bbs);\n+}\n+\n+/* For a data reference REF, return the declaration of its base\n+   address or NULL_TREE if the base is not determined.  */\n+\n+static inline tree\n+ref_base_address (tree stmt, data_ref_loc *ref)\n+{\n+  tree base = NULL_TREE;\n+  tree base_address;\n+  struct data_reference *dr = XCNEW (struct data_reference);\n+\n+  DR_STMT (dr) = stmt;\n+  DR_REF (dr) = *ref->pos;\n+  dr_analyze_innermost (dr);\n+  base_address = DR_BASE_ADDRESS (dr);\n+\n+  if (!base_address)\n+    goto end;\n+\n+  switch (TREE_CODE (base_address))\n+    {\n+    case ADDR_EXPR:\n+      base = TREE_OPERAND (base_address, 0);\n+      break;\n+\n+    default:\n+      base = base_address;\n+      break;\n+    }\n+\n+ end:\n+  free_data_ref (dr);\n+  return base;\n+}\n+\n+/* Determines whether the statement from vertex V of the RDG has a\n+   definition used outside the loop that contains this statement.  */\n+\n+bool\n+rdg_defs_used_in_other_loops_p (struct graph *rdg, int v)\n+{\n+  tree stmt = RDG_STMT (rdg, v);\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  use_operand_p imm_use_p;\n+  imm_use_iterator iterator;\n+  ssa_op_iter it;\n+  def_operand_p def_p;\n+\n+  if (!loop)\n+    return true;\n+\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, it, SSA_OP_DEF)\n+    {\n+      FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, DEF_FROM_PTR (def_p))\n+\t{\n+\t  if (loop_containing_stmt (USE_STMT (imm_use_p)) != loop)\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Determines whether statements S1 and S2 access to similar memory\n+   locations.  Two memory accesses are considered similar when they\n+   have the same base address declaration, i.e. when their\n+   ref_base_address is the same.  */\n+\n+bool\n+have_similar_memory_accesses (tree s1, tree s2)\n+{\n+  bool res = false;\n+  unsigned i, j;\n+  VEC (data_ref_loc, heap) *refs1, *refs2;\n+  data_ref_loc *ref1, *ref2;\n+\n+  get_references_in_stmt (s1, &refs1);\n+  get_references_in_stmt (s2, &refs2);\n+\n+  for (i = 0; VEC_iterate (data_ref_loc, refs1, i, ref1); i++)\n+    {\n+      tree base1 = ref_base_address (s1, ref1);\n+\n+      if (base1)\n+\tfor (j = 0; VEC_iterate (data_ref_loc, refs2, j, ref2); j++)\n+\t  if (base1 == ref_base_address (s2, ref2))\n+\t    {\n+\t      res = true;\n+\t      goto end;\n+\t    }\n+    }\n+\n+ end:\n+  VEC_free (data_ref_loc, heap, refs1);\n+  VEC_free (data_ref_loc, heap, refs2);\n+  return res;\n+}\n+\n+/* Helper function for the hashtab.  */\n+\n+static int\n+have_similar_memory_accesses_1 (const void *s1, const void *s2)\n+{\n+  return have_similar_memory_accesses ((tree) s1, (tree) s2);\n+}\n+\n+/* Helper function for the hashtab.  */\n+\n+static hashval_t\n+ref_base_address_1 (const void *s)\n+{\n+  tree stmt = (tree) s;\n+  unsigned i;\n+  VEC (data_ref_loc, heap) *refs;\n+  data_ref_loc *ref;\n+  hashval_t res = 0;\n+\n+  get_references_in_stmt (stmt, &refs);\n+\n+  for (i = 0; VEC_iterate (data_ref_loc, refs, i, ref); i++)\n+    if (!ref->is_read)\n+      {\n+\tres = htab_hash_pointer (ref_base_address (stmt, ref));\n+\tbreak;\n+      }\n+\n+  VEC_free (data_ref_loc, heap, refs);\n+  return res;\n+}\n+\n+/* Try to remove duplicated write data references from STMTS.  */\n+\n+void\n+remove_similar_memory_refs (VEC (tree, heap) **stmts)\n+{\n+  unsigned i;\n+  tree stmt;\n+  htab_t seen = htab_create (VEC_length (tree, *stmts), ref_base_address_1,\n+\t\t\t     have_similar_memory_accesses_1, NULL);\n+\n+  for (i = 0; VEC_iterate (tree, *stmts, i, stmt); )\n+    {\n+      void **slot;\n+\n+      slot = htab_find_slot (seen, stmt, INSERT);\n+\n+      if (*slot)\n+\tVEC_ordered_remove (tree, *stmts, i);\n+      else\n+\t{\n+\t  *slot = (void *) stmt;\n+\t  i++;\n+\t}\n+    }\n+\n+  htab_delete (seen);\n+}\n+"}, {"sha": "b24fd63095f37d6d37ded6f85f0b4dc1100753cb", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphds.h\"\n #include \"lambda.h\"\n #include \"omega.h\"\n+#include \"tree-chrec.h\"\n \n /*\n   innermost_loop_behavior describes the evolution of the address of the memory\n@@ -38,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n                        Example 1                      Example 2\n       data-ref         a[j].b[i][j]                   *(p + x + 16B + 4B * j)\n       \n+\n   innermost_loop_behavior\n       base_address     &a                             p\n       offset           i * D_i\t\t\t      x\n@@ -319,26 +321,107 @@ extern void debug_data_dependence_relation (struct data_dependence_relation *);\n extern void dump_data_dependence_relation (FILE *, \n \t\t\t\t\t   struct data_dependence_relation *);\n extern void dump_data_dependence_relations (FILE *, VEC (ddr_p, heap) *);\n+extern void debug_data_dependence_relations (VEC (ddr_p, heap) *);\n extern void dump_data_dependence_direction (FILE *, \n \t\t\t\t\t    enum data_dependence_direction);\n extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (VEC (ddr_p, heap) *);\n+extern void free_data_ref (data_reference_p);\n extern void free_data_refs (VEC (data_reference_p, heap) *);\n struct data_reference *create_data_ref (struct loop *, tree, tree, bool);\n bool find_loop_nest (struct loop *, VEC (loop_p, heap) **);\n void compute_all_dependences (VEC (data_reference_p, heap) *,\n \t\t\t      VEC (ddr_p, heap) **, VEC (loop_p, heap) *, bool);\n \n+/* Return true when the DDR contains two data references that have the\n+   same access functions.  */\n+\n+static inline bool\n+same_access_functions (const struct data_dependence_relation *ddr)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+    if (!eq_evolutions_p (DR_ACCESS_FN (DDR_A (ddr), i),\n+\t\t\t  DR_ACCESS_FN (DDR_B (ddr), i)))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true when DDR is an anti-dependence relation.  */\n+\n+static inline bool\n+ddr_is_anti_dependent (ddr_p ddr)\n+{\n+  return (DDR_ARE_DEPENDENT (ddr) == NULL_TREE\n+\t  && DR_IS_READ (DDR_A (ddr))\n+\t  && !DR_IS_READ (DDR_B (ddr))\n+\t  && !same_access_functions (ddr));\n+}\n+\n+/* Return true when DEPENDENCE_RELATIONS contains an anti-dependence.  */\n+\n+static inline bool\n+ddrs_have_anti_deps (VEC (ddr_p, heap) *dependence_relations)\n+{\n+  unsigned i;\n+  ddr_p ddr;\n+\n+  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+    if (ddr_is_anti_dependent (ddr))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return the dependence level for the DDR relation.  */\n+\n+static inline unsigned\n+ddr_dependence_level (ddr_p ddr)\n+{\n+  unsigned vector;\n+  unsigned level = 0;\n+\n+  if (DDR_DIST_VECTS (ddr))\n+    level = dependence_level (DDR_DIST_VECT (ddr, 0), DDR_NB_LOOPS (ddr));\n+\n+  for (vector = 1; vector < DDR_NUM_DIST_VECTS (ddr); vector++)\n+    level = MIN (level, dependence_level (DDR_DIST_VECT (ddr, vector),\n+\t\t\t\t\t  DDR_NB_LOOPS (ddr)));\n+  return level;\n+}\n+\n \f\n \n-/* A RDG vertex representing a statement.  */\n+/* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n typedef struct rdg_vertex\n {\n   /* The statement represented by this vertex.  */\n   tree stmt;\n+\n+  /* True when the statement contains a write to memory.  */\n+  bool has_mem_write;\n+\n+  /* True when the statement contains a read from memory.  */\n+  bool has_mem_reads;\n } *rdg_vertex_p;\n \n-#define RDGV_STMT(V)       ((struct rdg_vertex *) ((V)->data))->stmt\n+#define RDGV_STMT(V)     ((struct rdg_vertex *) ((V)->data))->stmt\n+#define RDGV_HAS_MEM_WRITE(V) ((struct rdg_vertex *) ((V)->data))->has_mem_write\n+#define RDGV_HAS_MEM_READS(V) ((struct rdg_vertex *) ((V)->data))->has_mem_reads\n+#define RDG_STMT(RDG, I) RDGV_STMT (&(RDG->vertices[I]))\n+#define RDG_MEM_WRITE_STMT(RDG, I) RDGV_HAS_MEM_WRITE (&(RDG->vertices[I]))\n+#define RDG_MEM_READS_STMT(RDG, I) RDGV_HAS_MEM_READS (&(RDG->vertices[I]))\n+\n+void dump_rdg_vertex (FILE *, struct graph *, int);\n+void debug_rdg_vertex (struct graph *, int);\n+void dump_rdg_component (FILE *, struct graph *, int, bitmap);\n+void debug_rdg_component (struct graph *, int);\n+void dump_rdg (FILE *, struct graph *);\n+void debug_rdg (struct graph *);\n+void dot_rdg (struct graph *);\n+int rdg_vertex_for_stmt (struct graph *, tree);\n \n /* Data dependence type.  */\n \n@@ -363,11 +446,17 @@ typedef struct rdg_edge\n {\n   /* Type of the dependence.  */\n   enum rdg_dep_type type;\n+\n+  /* Levels of the dependence: the depth of the loops that\n+    carry the dependence.  */\n+  unsigned level;\n } *rdg_edge_p;\n \n #define RDGE_TYPE(E)        ((struct rdg_edge *) ((E)->data))->type\n+#define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n \n struct graph *build_rdg (struct loop *);\n+void free_rdg (struct graph *);\n \n /* Return the index of the variable VAR in the LOOP_NEST array.  */\n \n@@ -385,6 +474,21 @@ index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n   return var_index;\n }\n \n+void stores_from_loop (struct loop *, VEC (tree, heap) **);\n+void remove_similar_memory_refs (VEC (tree, heap) **);\n+bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n+bool have_similar_memory_accesses (tree, tree);\n+\n+/* Determines whether RDG vertices V1 and V2 access to similar memory\n+   locations, in which case they have to be in the same partition.  */\n+\n+static inline bool\n+rdg_has_similar_memory_accesses (struct graph *rdg, int v1, int v2)\n+{\n+  return have_similar_memory_accesses (RDG_STMT (rdg, v1),\n+\t\t\t\t       RDG_STMT (rdg, v2));\n+}\n+\n /* In lambda-code.c  */\n bool lambda_transform_legal_p (lambda_trans_matrix, int, VEC (ddr_p, heap) *);\n "}, {"sha": "555d3a32a57698c20a07a63474f26ce7ae72114f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -792,6 +792,7 @@ extern void end_recording_case_labels (void);\n extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n \t\t\t\t           basic_block);\n void remove_edge_and_dominated_blocks (edge);\n+void mark_virtual_ops_in_bb (basic_block);\n \n /* In tree-cfgcleanup.c  */\n extern bitmap cfgcleanup_altered_bbs;\n@@ -1022,6 +1023,8 @@ bool tree_duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t unsigned int, sbitmap,\n \t\t\t\t\t edge, VEC (edge, heap) **,\n \t\t\t\t\t int);\n+struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n+void rename_variables_in_loop (struct loop *);\n struct loop *tree_ssa_loop_version (struct loop *, tree,\n \t\t\t\t    basic_block *);\n tree expand_simple_operations (tree);"}, {"sha": "2d4a5d69373fa38824c8338344696b22bb87f2d5", "filename": "gcc/tree-loop-distribution.c", "status": "added", "additions": 1173, "deletions": 0, "changes": 1173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -0,0 +1,1173 @@\n+/* Loop distribution.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Georges-Andre Silber <Georges-Andre.Silber@ensmp.fr>\n+   and Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This pass performs loop distribution: for example, the loop\n+\n+   |DO I = 2, N\n+   |    A(I) = B(I) + C\n+   |    D(I) = A(I-1)*E\n+   |ENDDO\n+\n+   is transformed to \n+\n+   |DOALL I = 2, N\n+   |   A(I) = B(I) + C\n+   |ENDDO\n+   |\n+   |DOALL I = 2, N\n+   |   D(I) = A(I-1)*E\n+   |ENDDO\n+\n+   This pass uses an RDG, Reduced Dependence Graph built on top of the\n+   data dependence relations.  The RDG is then topologically sorted to\n+   obtain a map of information producers/consumers based on which it\n+   generates the new loops.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"lambda.h\"\n+#include \"langhooks.h\"\n+#include \"tree-vectorizer.h\"\n+\n+/* If bit I is not set, it means that this node represents an\n+   operation that has already been performed, and that should not be\n+   performed again.  This is the subgraph of remaining important\n+   computations that is passed to the DFS algorithm for avoiding to\n+   include several times the same stores in different loops.  */\n+static bitmap remaining_stmts;\n+\n+/* A node of the RDG is marked in this bitmap when it has as a\n+   predecessor a node that writes to memory.  */\n+static bitmap upstream_mem_writes;\n+\n+/* Update the PHI nodes of NEW_LOOP.  NEW_LOOP is a duplicate of\n+   ORIG_LOOP.  */\n+\n+static void\n+update_phis_for_loop_copy (struct loop *orig_loop, struct loop *new_loop)\n+{\n+  tree new_ssa_name;\n+  tree phi_new, phi_orig;\n+  edge orig_loop_latch = loop_latch_edge (orig_loop);\n+  edge orig_entry_e = loop_preheader_edge (orig_loop);\n+  edge new_loop_entry_e = loop_preheader_edge (new_loop);\n+\n+  /* Scan the phis in the headers of the old and new loops\n+     (they are organized in exactly the same order).  */\n+\n+  for (phi_new = phi_nodes (new_loop->header),\n+       phi_orig = phi_nodes (orig_loop->header);\n+       phi_new && phi_orig;\n+       phi_new = PHI_CHAIN (phi_new), phi_orig = PHI_CHAIN (phi_orig))\n+    {\n+      /* Add the first phi argument for the phi in NEW_LOOP (the one\n+\t associated with the entry of NEW_LOOP)  */\n+      tree def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_entry_e);\n+      add_phi_arg (phi_new, def, new_loop_entry_e);\n+\n+      /* Add the second phi argument for the phi in NEW_LOOP (the one\n+\t associated with the latch of NEW_LOOP)  */\n+      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_loop_latch);\n+\n+      if (TREE_CODE (def) == SSA_NAME)\n+\t{\n+\t  new_ssa_name = get_current_def (def);\n+\n+\t  if (!new_ssa_name)\n+\t    /* This only happens if there are no definitions inside the\n+\t       loop.  Use the phi_result in this case.  */\n+\t    new_ssa_name = PHI_RESULT (phi_new);\n+\t}\n+      else\n+\t/* Could be an integer.  */\n+\tnew_ssa_name = def;\n+\n+      add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop));\n+    }\n+}\n+\n+/* Return a copy of LOOP placed before LOOP.  */\n+\n+static struct loop *\n+copy_loop_before (struct loop *loop)\n+{\n+  struct loop *res;\n+  edge preheader = loop_preheader_edge (loop);\n+\n+  if (!single_exit (loop))\n+    return NULL;\n+\n+  initialize_original_copy_tables ();\n+  res = slpeel_tree_duplicate_loop_to_edge_cfg (loop, preheader);\n+  free_original_copy_tables ();\n+\n+  if (!res)\n+    return NULL;\n+\n+  update_phis_for_loop_copy (loop, res);\n+  rename_variables_in_loop (res);\n+\n+  return res;\n+}\n+\n+/* Creates an empty basic block after LOOP.  */\n+\n+static void\n+create_bb_after_loop (struct loop *loop)\n+{\n+  edge exit = single_exit (loop);\n+\n+  if (!exit)\n+    return;\n+\n+  split_edge (exit);\n+}\n+\n+/* Generate code for PARTITION from the code in LOOP.  The loop is\n+   copied when COPY_P is true.  All the statements not flagged in the\n+   PARTITION bitmap are removed from the loop or from its copy.  The\n+   statements are indexed in sequence inside a basic block, and the\n+   basic blocks of a loop are taken in dom order.  Returns true when\n+   the code gen succeeded. */\n+\n+static bool\n+generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n+{\n+  unsigned i, x;\n+  block_stmt_iterator bsi;\n+  basic_block *bbs;\n+\n+  if (copy_p)\n+    {\n+      loop = copy_loop_before (loop);\n+      create_preheader (loop, CP_SIMPLE_PREHEADERS);\n+      create_bb_after_loop (loop);\n+    }\n+\n+  if (loop == NULL)\n+    return false;\n+\n+  /* Remove stmts not in the PARTITION bitmap.  The order in which we\n+     visit the phi nodes and the statements is exactly as in\n+     stmts_from_loop.  */\n+  bbs = get_loop_body_in_dom_order (loop);\n+\n+  for (x = 0, i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      tree phi, prev = NULL_TREE, next;\n+\n+      for (phi = phi_nodes (bb); phi;)\n+\tif (!bitmap_bit_p (partition, x++))\n+\t  {\n+\t    next = PHI_CHAIN (phi);\n+\t    remove_phi_node (phi, prev, true);\n+\t    phi = next;\n+\t  }\n+\telse\n+\t  {\n+\t    prev = phi;\n+\t    phi = PHI_CHAIN (phi);\n+\t  }\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi);)\n+\tif (TREE_CODE (bsi_stmt (bsi)) != LABEL_EXPR\n+\t    && !bitmap_bit_p (partition, x++))\n+\t  bsi_remove (&bsi, false);\n+\telse\n+\t  bsi_next (&bsi);\n+\n+\tmark_virtual_ops_in_bb (bb);\n+    }\n+\n+  free (bbs);\n+  return true;\n+}\n+\n+/* Generate a call to memset.  Return true when the operation succeeded.  */\n+\n+static bool\n+generate_memset_zero (tree stmt, tree op0, tree nb_iter,\n+\t\t      block_stmt_iterator bsi)\n+{\n+  tree s, t, stmts, nb_bytes, addr_base;\n+  bool res = false;\n+  tree stmt_list = NULL_TREE;\n+  tree args [3];\n+  tree fn_call, mem, fndecl, fntype, fn;\n+  tree_stmt_iterator i;\n+  ssa_op_iter iter;\n+  struct data_reference *dr = XCNEW (struct data_reference);\n+\n+  nb_bytes = fold_build2 (MULT_EXPR, TREE_TYPE (nb_iter),\n+\t\t\t  nb_iter, TYPE_SIZE_UNIT (TREE_TYPE (op0)));\n+  nb_bytes = force_gimple_operand (nb_bytes, &stmts, true, NULL);\n+  append_to_statement_list_force (stmts, &stmt_list);\n+\n+  DR_STMT (dr) = stmt;\n+  DR_REF (dr) = op0;\n+  dr_analyze_innermost (dr);\n+\n+  /* Test for a positive stride, iterating over every element.  */\n+  if (integer_zerop (fold_build2 (MINUS_EXPR, integer_type_node, DR_STEP (dr),\n+\t\t\t\t  TYPE_SIZE_UNIT (TREE_TYPE (op0)))))\n+    addr_base = fold_build2 (PLUS_EXPR, TREE_TYPE (DR_BASE_ADDRESS (dr)),\n+\t\t\t     DR_BASE_ADDRESS (dr), \n+\t\t\t     size_binop (PLUS_EXPR,\n+\t\t\t\t\t DR_OFFSET (dr), DR_INIT (dr)));\n+\n+  /* Test for a negative stride, iterating over every element.  */\n+  else if (integer_zerop (fold_build2 (PLUS_EXPR, integer_type_node,\n+\t\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (op0)),\n+\t\t\t\t       DR_STEP (dr))))\n+    {\n+      addr_base = size_binop (PLUS_EXPR, DR_OFFSET (dr), DR_INIT (dr));\n+      addr_base = fold_build2 (MINUS_EXPR, sizetype, addr_base, nb_bytes);\n+      addr_base = force_gimple_operand (addr_base, &stmts, true, NULL);\n+      append_to_statement_list_force (stmts, &stmt_list);\n+\n+      addr_base = fold_build2 (POINTER_PLUS_EXPR,\n+\t\t\t       TREE_TYPE (DR_BASE_ADDRESS (dr)),\n+\t\t\t       DR_BASE_ADDRESS (dr), addr_base);\n+    }\n+  else\n+    goto end;\n+\n+  mem = force_gimple_operand (addr_base, &stmts, true, NULL);\n+  append_to_statement_list_force (stmts, &stmt_list);\n+\n+\n+  fndecl = implicit_built_in_decls [BUILT_IN_MEMSET];\n+  fntype = TREE_TYPE (fndecl);\n+  fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n+\n+  args[0] = mem;\n+  args[1] = integer_zero_node;\n+  args[2] = nb_bytes;\n+\n+  fn_call = build_call_array (fntype, fn, 3, args);\n+  append_to_statement_list_force (fn_call, &stmt_list);\n+\n+  for (i = tsi_start (stmt_list); !tsi_end_p (i); tsi_next (&i))\n+    {\n+      s = tsi_stmt (i);\n+      update_stmt_if_modified (s);\n+\n+      FOR_EACH_SSA_TREE_OPERAND (t, s, iter, SSA_OP_VIRTUAL_DEFS)\n+\t{\n+\t  if (TREE_CODE (t) == SSA_NAME)\n+\t    t = SSA_NAME_VAR (t);\n+\t  mark_sym_for_renaming (t);\n+\t}\n+    }\n+\n+  /* Mark also the uses of the VDEFS of STMT to be renamed.  */\n+  FOR_EACH_SSA_TREE_OPERAND (t, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+    {\n+      if (TREE_CODE (t) == SSA_NAME)\n+\t{\n+\t  imm_use_iterator imm_iter;\n+\n+\t  FOR_EACH_IMM_USE_STMT (s, imm_iter, t)\n+\t    update_stmt (s);\n+\n+\t  t = SSA_NAME_VAR (t);\n+\t}\n+      mark_sym_for_renaming (t);\n+    }\n+\n+  bsi_insert_after (&bsi, stmt_list, BSI_CONTINUE_LINKING);\n+  res = true;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"generated memset zero\\n\");\n+\n+ end:\n+  free_data_ref (dr);\n+  return res;\n+}\n+\n+/* Tries to generate a builtin function for the instructions of LOOP\n+   pointed to by the bits set in PARTITION.  Returns true when the\n+   operation succeeded.  */\n+\n+static bool\n+generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n+{\n+  bool res = false;\n+  unsigned i, x = 0;\n+  basic_block *bbs;\n+  tree write = NULL_TREE;\n+  tree op0, op1;\n+  block_stmt_iterator bsi;\n+  tree nb_iter = number_of_exit_cond_executions (loop);\n+\n+  if (!nb_iter || nb_iter == chrec_dont_know)\n+    return false;\n+\n+  bbs = get_loop_body_in_dom_order (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      tree phi;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\tx++;\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\n+\t  if (bitmap_bit_p (partition, x++)\n+\t      && TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t      && !is_gimple_reg (GIMPLE_STMT_OPERAND (stmt, 0)))\n+\t    {\n+\t      /* Don't generate the builtins when there are more than\n+\t\t one memory write.  */\n+\t      if (write != NULL)\n+\t\tgoto end;\n+\n+\t      write = stmt;\n+\t    }\n+\t}\n+    }\n+\n+  if (!write)\n+    goto end;\n+\n+  op0 = GIMPLE_STMT_OPERAND (write, 0);\n+  op1 = GIMPLE_STMT_OPERAND (write, 1);\n+\n+  if (!(TREE_CODE (op0) == ARRAY_REF\n+\t|| TREE_CODE (op0) == INDIRECT_REF))\n+    goto end;\n+\n+  /* The new statements will be placed before LOOP.  */\n+  bsi = bsi_last (loop_preheader_edge (loop)->src);\n+\n+  if (integer_zerop (op1) || real_zerop (op1))\n+    res = generate_memset_zero (write, op0, nb_iter, bsi);\n+\n+  /* If this is the last partition for which we generate code, we have\n+     to destroy the loop.  */\n+  if (res && !copy_p)\n+    {\n+      unsigned nbbs = loop->num_nodes;\n+      basic_block src = loop_preheader_edge (loop)->src;\n+      basic_block dest = single_exit (loop)->dest;\n+      make_edge (src, dest, EDGE_FALLTHRU);\n+      set_immediate_dominator (CDI_DOMINATORS, dest, src);\n+      cancel_loop_tree (loop);\n+\n+      for (i = 0; i < nbbs; i++)\n+\tdelete_basic_block (bbs[i]);\n+    }\n+\n+ end:\n+  free (bbs);\n+  return res;\n+}\n+\n+/* Generates code for PARTITION.  For simple loops, this function can\n+   generate a built-in.  */\n+\n+static bool\n+generate_code_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n+{\n+  if (generate_builtin (loop, partition, copy_p))\n+    return true;\n+\n+  return generate_loops_for_partition (loop, partition, copy_p);\n+}\n+\n+\n+/* Returns true if the node V of RDG cannot be recomputed.  */\n+\n+static bool\n+rdg_cannot_recompute_vertex_p (struct graph *rdg, int v)\n+{\n+  if (RDG_MEM_WRITE_STMT (rdg, v))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Returns true when the vertex V has already been generated in the\n+   current partition (V is in PROCESSED), or when V belongs to another\n+   partition and cannot be recomputed (V is not in REMAINING_STMTS).  */\n+\n+static inline bool\n+already_processed_vertex_p (bitmap processed, int v)\n+{\n+  return (bitmap_bit_p (processed, v)\n+\t  || !bitmap_bit_p (remaining_stmts, v));\n+}\n+\n+/* Returns NULL when there is no anti-dependence among the successors\n+   of vertex V, otherwise returns the edge with the anti-dep.  */\n+\n+static struct graph_edge *\n+has_anti_dependence (struct vertex *v)\n+{\n+  struct graph_edge *e;\n+\n+  if (v->succ)\n+    for (e = v->succ; e; e = e->succ_next)\n+      if (RDGE_TYPE (e) == anti_dd)\n+\treturn e;\n+\n+  return NULL;\n+}\n+\n+/* Returns true when V has an anti-dependence edge among its successors.  */\n+\n+static bool\n+predecessor_has_mem_write (struct graph *rdg, struct vertex *v)\n+{\n+  struct graph_edge *e;\n+\n+  if (v->pred)\n+    for (e = v->pred; e; e = e->pred_next)\n+      if (bitmap_bit_p (upstream_mem_writes, e->src)\n+\t  /* Don't consider flow channels: a write to memory followed\n+\t     by a read from memory.  These channels allow the split of\n+\t     the RDG in different partitions.  */\n+\t  && !RDG_MEM_WRITE_STMT (rdg, e->src))\n+\treturn true;\n+\n+  return false;\n+}\n+\n+/* Initializes the upstream_mem_writes bitmap following the\n+   information from RDG.  */\n+\n+static void\n+mark_nodes_having_upstream_mem_writes (struct graph *rdg)\n+{\n+  int v, x;\n+  bitmap seen = BITMAP_ALLOC (NULL);\n+\n+  for (v = rdg->n_vertices - 1; v >= 0; v--)\n+    if (!bitmap_bit_p (seen, v))\n+      {\n+\tunsigned i;\n+\tVEC (int, heap) *nodes = VEC_alloc (int, heap, 3);\n+\tbool has_upstream_mem_write_p = false;\n+\n+\tgraphds_dfs (rdg, &v, 1, &nodes, false, NULL);\n+\n+\tfor (i = 0; VEC_iterate (int, nodes, i, x); i++)\n+\t  {\n+\t    if (bitmap_bit_p (seen, x))\n+\t      continue;\n+\n+\t    bitmap_set_bit (seen, x);\n+\n+\t    if (RDG_MEM_WRITE_STMT (rdg, x)\n+\t\t|| predecessor_has_mem_write (rdg, &(rdg->vertices[x]))\n+\t\t/* In anti dependences the read should occur before\n+\t\t   the write, this is why both the read and the write\n+\t\t   should be placed in the same partition.  */\n+\t\t|| has_anti_dependence (&(rdg->vertices[x])))\n+\t      {\n+\t\thas_upstream_mem_write_p = true;\n+\t\tbitmap_set_bit (upstream_mem_writes, x);\n+\t      }\n+\t  }\n+\n+\tVEC_free (int, heap, nodes);\n+      }\n+}\n+\n+/* Returns true when vertex u has a memory write node as a predecessor\n+   in RDG.  */\n+\n+static bool\n+has_upstream_mem_writes (int u)\n+{\n+  return bitmap_bit_p (upstream_mem_writes, u);\n+}\n+\n+static void rdg_flag_vertex_and_dependent (struct graph *, int, bitmap, bitmap,\n+\t\t\t\t\t   bitmap, bool *);\n+\n+/* Flag all the uses of U.  */\n+\n+static void\n+rdg_flag_all_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,\n+\t\t   bitmap processed, bool *part_has_writes)\n+{\n+  struct graph_edge *e;\n+\n+  for (e = rdg->vertices[u].succ; e; e = e->succ_next)\n+    if (!bitmap_bit_p (processed, e->dest))\n+      {\n+\trdg_flag_vertex_and_dependent (rdg, e->dest, partition, loops,\n+\t\t\t\t       processed, part_has_writes);\n+\trdg_flag_all_uses (rdg, e->dest, partition, loops, processed,\n+\t\t\t   part_has_writes);\n+      }\n+}\n+\n+/* Flag the uses of U stopping following the information from\n+   upstream_mem_writes.  */\n+\n+static void\n+rdg_flag_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,\n+\t       bitmap processed, bool *part_has_writes)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  struct vertex *x = &(rdg->vertices[u]);\n+  tree stmt = RDGV_STMT (x);\n+  struct graph_edge *anti_dep = has_anti_dependence (x);\n+\n+  /* Keep in the same partition the destination of an antidependence,\n+     because this is a store to the exact same location.  Putting this\n+     in another partition is bad for cache locality.  */\n+  if (anti_dep)\n+    {\n+      int v = anti_dep->dest;\n+\n+      if (!already_processed_vertex_p (processed, v))\n+\trdg_flag_vertex_and_dependent (rdg, v, partition, loops,\n+\t\t\t\t       processed, part_has_writes);\n+    }\n+\n+  if (TREE_CODE (stmt) != PHI_NODE)\n+    {\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_VIRTUAL_USES)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\n+\t  if (TREE_CODE (use) == SSA_NAME)\n+\t    {\n+\t      tree def_stmt = SSA_NAME_DEF_STMT (use);\n+\t      int v = rdg_vertex_for_stmt (rdg, def_stmt);\n+\n+\t      if (v >= 0\n+\t\t  && !already_processed_vertex_p (processed, v))\n+\t\trdg_flag_vertex_and_dependent (rdg, v, partition, loops,\n+\t\t\t\t\t       processed, part_has_writes);\n+\t    }\n+\t}\n+    }\n+\n+  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+      && has_upstream_mem_writes (u))\n+    {\n+      tree op0 = GIMPLE_STMT_OPERAND (stmt, 0);\n+\n+      /* Scalar channels don't have enough space for transmitting data\n+\t between tasks, unless we add more storage by privatizing.  */\n+      if (is_gimple_reg (op0))\n+\t{\n+\t  use_operand_p use_p;\n+\t  imm_use_iterator iter;\n+\n+\t  FOR_EACH_IMM_USE_FAST (use_p, iter, op0)\n+\t    {\n+\t      int v = rdg_vertex_for_stmt (rdg, USE_STMT (use_p));\n+\n+\t      if (!already_processed_vertex_p (processed, v))\n+\t\trdg_flag_vertex_and_dependent (rdg, v, partition, loops,\n+\t\t\t\t\t       processed, part_has_writes);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Flag V from RDG as part of PARTITION, and also flag its loop number\n+   in LOOPS.  */\n+\n+static void\n+rdg_flag_vertex (struct graph *rdg, int v, bitmap partition, bitmap loops,\n+\t\t bool *part_has_writes)\n+{\n+  struct loop *loop;\n+\n+  if (bitmap_bit_p (partition, v))\n+    return;\n+\n+  loop = loop_containing_stmt (RDG_STMT (rdg, v));\n+  bitmap_set_bit (loops, loop->num);\n+  bitmap_set_bit (partition, v);\n+\n+  if (rdg_cannot_recompute_vertex_p (rdg, v))\n+    {\n+      *part_has_writes = true;\n+      bitmap_clear_bit (remaining_stmts, v);\n+    }\n+}\n+\n+/* Flag in the bitmap PARTITION the vertex V and all its predecessors.\n+   Alse flag their loop number in LOOPS.  */\n+\n+static void\n+rdg_flag_vertex_and_dependent (struct graph *rdg, int v, bitmap partition,\n+\t\t\t       bitmap loops, bitmap processed,\n+\t\t\t       bool *part_has_writes)\n+{\n+  unsigned i;\n+  VEC (int, heap) *nodes = VEC_alloc (int, heap, 3);\n+  int x;\n+\n+  bitmap_set_bit (processed, v);\n+  rdg_flag_uses (rdg, v, partition, loops, processed, part_has_writes);\n+  graphds_dfs (rdg, &v, 1, &nodes, false, remaining_stmts);\n+  rdg_flag_vertex (rdg, v, partition, loops, part_has_writes);\n+\n+  for (i = 0; VEC_iterate (int, nodes, i, x); i++)\n+    if (!already_processed_vertex_p (processed, x))\n+      rdg_flag_vertex_and_dependent (rdg, x, partition, loops, processed,\n+\t\t\t\t     part_has_writes);\n+\n+  VEC_free (int, heap, nodes);\n+}\n+\n+/* Initialize CONDS with all the condition statements from the basic\n+   blocks of LOOP.  */\n+\n+static void\n+collect_condition_stmts (struct loop *loop, VEC (tree, heap) **conds)\n+{\n+  unsigned i;\n+  edge e;\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+\n+  for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n+    {\n+      tree cond = last_stmt (e->src);\n+\n+      if (cond)\n+\tVEC_safe_push (tree, heap, *conds, cond);\n+    }\n+\n+  VEC_free (edge, heap, exits);\n+}\n+\n+/* Add to PARTITION all the exit condition statements for LOOPS\n+   together with all their dependent statements determined from\n+   RDG.  */\n+\n+static void\n+rdg_flag_loop_exits (struct graph *rdg, bitmap loops, bitmap partition,\n+\t\t     bitmap processed, bool *part_has_writes)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+  VEC (tree, heap) *conds = VEC_alloc (tree, heap, 3);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (loops, 0, i, bi)\n+    collect_condition_stmts (get_loop (i), &conds);\n+\n+  while (!VEC_empty (tree, conds))\n+    {\n+      tree cond = VEC_pop (tree, conds);\n+      int v = rdg_vertex_for_stmt (rdg, cond);\n+      bitmap new_loops = BITMAP_ALLOC (NULL);\n+\n+      if (!already_processed_vertex_p (processed, v))\n+\trdg_flag_vertex_and_dependent (rdg, v, partition, new_loops, processed,\n+\t\t\t\t       part_has_writes);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (new_loops, 0, i, bi)\n+\tif (!bitmap_bit_p (loops, i))\n+\t  {\n+\t    bitmap_set_bit (loops, i);\n+\t    collect_condition_stmts (get_loop (i), &conds);\n+\t  }\n+\n+      BITMAP_FREE (new_loops);\n+    }\n+}\n+\n+/* Strongly connected components of the reduced data dependence graph.  */\n+\n+typedef struct rdg_component\n+{\n+  int num;\n+  VEC (int, heap) *vertices;\n+} *rdgc;\n+\n+DEF_VEC_P (rdgc);\n+DEF_VEC_ALLOC_P (rdgc, heap);\n+\n+/* Flag all the nodes of RDG containing memory accesses that could\n+   potentially belong to arrays already accessed in the current\n+   PARTITION.  */\n+\n+static void\n+rdg_flag_similar_memory_accesses (struct graph *rdg, bitmap partition,\n+\t\t\t\t  bitmap loops, bitmap processed,\n+\t\t\t\t  VEC (int, heap) **other_stores)\n+{\n+  bool foo;\n+  unsigned i, n;\n+  int j, k, kk;\n+  bitmap_iterator ii;\n+  struct graph_edge *e;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, ii)\n+    if (RDG_MEM_WRITE_STMT (rdg, i)\n+\t|| RDG_MEM_READS_STMT (rdg, i))\n+      {\n+\tfor (j = 0; j < rdg->n_vertices; j++)\n+\t  if (!bitmap_bit_p (processed, j)\n+\t      && (RDG_MEM_WRITE_STMT (rdg, j)\n+\t\t  || RDG_MEM_READS_STMT (rdg, j))\n+\t      && rdg_has_similar_memory_accesses (rdg, i, j))\n+\t    {\n+\t      /* Flag first the node J itself, and all the nodes that\n+\t\t are needed to compute J.  */\n+\t      rdg_flag_vertex_and_dependent (rdg, j, partition, loops,\n+\t\t\t\t\t     processed, &foo);\n+\n+\t      /* When J is a read, we want to coalesce in the same\n+\t\t PARTITION all the nodes that are using J: this is\n+\t\t needed for better cache locality.  */\n+\t      rdg_flag_all_uses (rdg, j, partition, loops, processed, &foo);\n+\n+\t      /* Remove from OTHER_STORES the vertex that we flagged.  */\n+\t      if (RDG_MEM_WRITE_STMT (rdg, j))\n+\t\tfor (k = 0; VEC_iterate (int, *other_stores, k, kk); k++)\n+\t\t  if (kk == j)\n+\t\t    {\n+\t\t      VEC_unordered_remove (int, *other_stores, k);\n+\t\t      break;\n+\t\t    }\n+\t    }\n+\n+\t/* If the node I has two uses, then keep these together in the\n+\t   same PARTITION.  */\n+\tfor (n = 0, e = rdg->vertices[i].succ; e; e = e->succ_next, n++);\n+\n+\tif (n > 1)\n+\t  rdg_flag_all_uses (rdg, i, partition, loops, processed, &foo);\n+      }\n+}\n+\n+/* Returns a bitmap in which all the statements needed for computing\n+   the strongly connected component C of the RDG are flagged, also\n+   including the loop exit conditions.  */\n+\n+static bitmap\n+build_rdg_partition_for_component (struct graph *rdg, rdgc c,\n+\t\t\t\t   bool *part_has_writes,\n+\t\t\t\t   VEC (int, heap) **other_stores)\n+{\n+  int i, v;\n+  bitmap partition = BITMAP_ALLOC (NULL);\n+  bitmap loops = BITMAP_ALLOC (NULL);\n+  bitmap processed = BITMAP_ALLOC (NULL);\n+\n+  for (i = 0; VEC_iterate (int, c->vertices, i, v); i++)\n+    if (!already_processed_vertex_p (processed, v))\n+      rdg_flag_vertex_and_dependent (rdg, v, partition, loops, processed,\n+\t\t\t\t     part_has_writes);\n+\n+  /* Also iterate on the array of stores not in the starting vertices,\n+     and determine those vertices that have some memory affinity with\n+     the current nodes in the component: these are stores to the same\n+     arrays, i.e. we're taking care of cache locality.  */\n+  rdg_flag_similar_memory_accesses (rdg, partition, loops, processed,\n+\t\t\t\t    other_stores);\n+\n+  rdg_flag_loop_exits (rdg, loops, partition, processed, part_has_writes);\n+\n+  BITMAP_FREE (processed);\n+  BITMAP_FREE (loops);\n+  return partition;\n+}\n+\n+/* Free memory for COMPONENTS.  */\n+\n+static void\n+free_rdg_components (VEC (rdgc, heap) *components)\n+{\n+  int i;\n+  rdgc x;\n+\n+  for (i = 0; VEC_iterate (rdgc, components, i, x); i++)\n+    {\n+      VEC_free (int, heap, x->vertices);\n+      free (x);\n+    }\n+}\n+\n+/* Build the COMPONENTS vector with the strongly connected components\n+   of RDG in which the STARTING_VERTICES occur.  */\n+\n+static void\n+rdg_build_components (struct graph *rdg, VEC (int, heap) *starting_vertices, \n+\t\t      VEC (rdgc, heap) **components)\n+{\n+  int i, v;\n+  bitmap saved_components = BITMAP_ALLOC (NULL);\n+  int n_components = graphds_scc (rdg, NULL);\n+  VEC (int, heap) **all_components = XNEWVEC (VEC (int, heap) *, n_components);\n+\n+  for (i = 0; i < n_components; i++)\n+    all_components[i] = VEC_alloc (int, heap, 3);\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    VEC_safe_push (int, heap, all_components[rdg->vertices[i].component], i);\n+\n+  for (i = 0; VEC_iterate (int, starting_vertices, i, v); i++)\n+    {\n+      int c = rdg->vertices[v].component;\n+\n+      if (!bitmap_bit_p (saved_components, c))\n+\t{\n+\t  rdgc x = XCNEW (struct rdg_component);\n+\t  x->num = c;\n+\t  x->vertices = all_components[c];\n+\n+\t  VEC_safe_push (rdgc, heap, *components, x);\n+\t  bitmap_set_bit (saved_components, c);\n+\t}\n+    }\n+\n+  for (i = 0; i < n_components; i++)\n+    if (!bitmap_bit_p (saved_components, i))\n+      VEC_free (int, heap, all_components[i]);\n+\n+  free (all_components);\n+  BITMAP_FREE (saved_components);\n+}\n+\n+DEF_VEC_P (bitmap);\n+DEF_VEC_ALLOC_P (bitmap, heap);\n+\n+/* Aggregate several components into a useful partition that is\n+   registered in the PARTITIONS vector.  Partitions will be\n+   distributed in different loops.  */\n+\n+static void\n+rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n+\t\t      VEC (int, heap) **other_stores,\n+\t\t      VEC (bitmap, heap) **partitions, bitmap processed)\n+{\n+  int i;\n+  rdgc x;\n+  bitmap partition = BITMAP_ALLOC (NULL);\n+\n+  for (i = 0; VEC_iterate (rdgc, components, i, x); i++)\n+    {\n+      bitmap np;\n+      bool part_has_writes = false;\n+      int v = VEC_index (int, x->vertices, 0);\n+\t\n+      if (bitmap_bit_p (processed, v))\n+\tcontinue;\n+  \n+      np = build_rdg_partition_for_component (rdg, x, &part_has_writes,\n+\t\t\t\t\t      other_stores);\n+      bitmap_ior_into (partition, np);\n+      bitmap_ior_into (processed, np);\n+      BITMAP_FREE (np);\n+\n+      if (part_has_writes)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"ldist useful partition:\\n\");\n+\t      dump_bitmap (dump_file, partition);\n+\t    }\n+\n+\t  VEC_safe_push (bitmap, heap, *partitions, partition);\n+\t  partition = BITMAP_ALLOC (NULL);\n+\t}\n+    }\n+\n+  /* Add the nodes from the RDG that were not marked as processed, and\n+     that are used outside the current loop.  These are scalar\n+     computations that are not yet part of previous partitions.  */\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    if (!bitmap_bit_p (processed, i)\n+\t&& rdg_defs_used_in_other_loops_p (rdg, i))\n+      VEC_safe_push (int, heap, *other_stores, i);\n+\n+  /* If there are still statements left in the OTHER_STORES array,\n+     create other components and partitions with these stores and\n+     their dependences.  */\n+  if (VEC_length (int, *other_stores) > 0)\n+    {\n+      VEC (rdgc, heap) *comps = VEC_alloc (rdgc, heap, 3);\n+      VEC (int, heap) *foo = VEC_alloc (int, heap, 3);\n+\n+      rdg_build_components (rdg, *other_stores, &comps);\n+      rdg_build_partitions (rdg, comps, &foo, partitions, processed);\n+\n+      VEC_free (int, heap, foo);\n+      free_rdg_components (comps);\n+    }\n+\n+  /* If there is something left in the last partition, save it.  */\n+  if (bitmap_count_bits (partition) > 0)\n+    VEC_safe_push (bitmap, heap, *partitions, partition);\n+  else\n+    BITMAP_FREE (partition);\n+}\n+\n+/* Dump to FILE the PARTITIONS.  */\n+\n+static void\n+dump_rdg_partitions (FILE *file, VEC (bitmap, heap) *partitions)\n+{\n+  int i;\n+  bitmap partition;\n+\n+  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+    debug_bitmap_file (file, partition);\n+}\n+\n+/* Debug PARTITIONS.  */\n+extern void debug_rdg_partitions (VEC (bitmap, heap) *);\n+\n+void\n+debug_rdg_partitions (VEC (bitmap, heap) *partitions)\n+{\n+  dump_rdg_partitions (stderr, partitions);\n+}\n+\n+/* Generate code from STARTING_VERTICES in RDG.  Returns the number of\n+   distributed loops.  */\n+\n+static int\n+ldist_gen (struct loop *loop, struct graph *rdg,\n+\t   VEC (int, heap) *starting_vertices)\n+{\n+  int i, nbp;\n+  VEC (rdgc, heap) *components = VEC_alloc (rdgc, heap, 3);\n+  VEC (bitmap, heap) *partitions = VEC_alloc (bitmap, heap, 3);\n+  VEC (int, heap) *other_stores = VEC_alloc (int, heap, 3);\n+  bitmap partition, processed = BITMAP_ALLOC (NULL);\n+\n+  remaining_stmts = BITMAP_ALLOC (NULL);\n+  upstream_mem_writes = BITMAP_ALLOC (NULL);\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    {\n+      bitmap_set_bit (remaining_stmts, i);\n+\n+      /* Save in OTHER_STORES all the memory writes that are not in\n+\t STARTING_VERTICES.  */\n+      if (RDG_MEM_WRITE_STMT (rdg, i))\n+\t{\n+\t  int v;\n+\t  unsigned j;\n+\t  bool found = false;\n+\n+\t  for (j = 0; VEC_iterate (int, starting_vertices, j, v); j++)\n+\t    if (i == v)\n+\t      {\n+\t\tfound = true;\n+\t\tbreak;\n+\t      }\n+\n+\t  if (!found)\n+\t    VEC_safe_push (int, heap, other_stores, i);\n+\t}\n+    }\n+\n+  mark_nodes_having_upstream_mem_writes (rdg);\n+  rdg_build_components (rdg, starting_vertices, &components);\n+  rdg_build_partitions (rdg, components, &other_stores, &partitions,\n+\t\t\tprocessed);\n+  BITMAP_FREE (processed);\n+  nbp = VEC_length (bitmap, partitions);\n+\n+  if (nbp <= 1)\n+    goto ldist_done;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_rdg_partitions (dump_file, partitions);\n+\n+  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+    if (!generate_code_for_partition (loop, partition, i < nbp - 1))\n+      goto ldist_done;\n+\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+  update_ssa (TODO_update_ssa_only_virtuals | TODO_update_ssa);\n+\n+ ldist_done:\n+\n+  BITMAP_FREE (remaining_stmts);\n+  BITMAP_FREE (upstream_mem_writes);\n+\n+  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+    BITMAP_FREE (partition);\n+\n+  VEC_free (int, heap, other_stores);\n+  VEC_free (bitmap, heap, partitions);\n+  free_rdg_components (components);\n+  return nbp;\n+}\n+\n+/* Distributes the code from LOOP in such a way that producer\n+   statements are placed before consumer statements.  When STMTS is\n+   NULL, performs the maximal distribution, if STMTS is not NULL,\n+   tries to separate only these statements from the LOOP's body.\n+   Returns the number of distributed loops.  */\n+\n+static int\n+distribute_loop (struct loop *loop, VEC (tree, heap) *stmts)\n+{\n+  bool res = false;\n+  struct graph *rdg;\n+  tree s;\n+  unsigned i;\n+  VEC (int, heap) *vertices;\n+\n+  if (loop->num_nodes > 2)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"FIXME: Loop %d not distributed: it has more than two basic blocks.\\n\",\n+\t\t loop->num);\n+\n+      return res;\n+    }\n+\n+  rdg = build_rdg (loop);\n+\n+  if (!rdg)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"FIXME: Loop %d not distributed: failed to build the RDG.\\n\",\n+\t\t loop->num);\n+\n+      return res;\n+    }\n+\n+  vertices = VEC_alloc (int, heap, 3);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_rdg (dump_file, rdg);\n+\n+  for (i = 0; VEC_iterate (tree, stmts, i, s); i++)\n+    {\n+      int v = rdg_vertex_for_stmt (rdg, s);\n+\n+      if (v >= 0)\n+\t{\n+\t  VEC_safe_push (int, heap, vertices, v);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"ldist asked to generate code for vertex %d\\n\", v);\n+\t}\n+    }\n+\n+  res = ldist_gen (loop, rdg, vertices);\n+  VEC_free (int, heap, vertices);\n+  free_rdg (rdg);\n+\n+  return res;\n+}\n+\n+/* Distribute all loops in the current function.  */\n+\n+static unsigned int\n+tree_loop_distribution (void)\n+{\n+  struct loop *loop;\n+  loop_iterator li;\n+  int nb_generated_loops = 0;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      VEC (tree, heap) *work_list = VEC_alloc (tree, heap, 3);\n+\n+      /* With the following working list, we're asking distribute_loop\n+\t to separate the stores of the loop: when dependences allow,\n+\t it will end on having one store per loop.  */\n+      stores_from_loop (loop, &work_list);\n+\n+      /* A simple heuristic for cache locality is to not split stores\n+\t to the same array.  Without this call, an unrolled loop would\n+\t be split into as many loops as unroll factor, each loop\n+\t storing in the same array.  */\n+      remove_similar_memory_refs (&work_list);\n+\n+      nb_generated_loops = distribute_loop (loop, work_list);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  if (nb_generated_loops > 1)\n+\t    fprintf (dump_file, \"Loop %d distributed: split to %d loops.\\n\",\n+\t\t     loop->num, nb_generated_loops);\n+\t  else\n+\t    fprintf (dump_file, \"Loop %d is the same.\\n\", loop->num);\n+\t}\n+\n+      verify_loop_structure ();\n+\n+      VEC_free (tree, heap, work_list);\n+    }\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_tree_loop_distribution (void)\n+{\n+  return flag_tree_loop_distribution != 0;\n+}\n+\n+struct tree_opt_pass pass_loop_distribution =\n+{\n+  \"ldist\",\t\t\t/* name */\n+  gate_tree_loop_distribution,  /* gate */\n+  tree_loop_distribution,       /* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_LOOP_DISTRIBUTION,    /* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_loops,            /* todo_flags_finish */\n+  0                             /* letter */  \n+};"}, {"sha": "55aa5fcf77f2b1572f568247aa075330852caaa5", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -265,6 +265,7 @@ extern struct tree_opt_pass pass_scev_cprop;\n extern struct tree_opt_pass pass_empty_loop;\n extern struct tree_opt_pass pass_record_bounds;\n extern struct tree_opt_pass pass_if_conversion;\n+extern struct tree_opt_pass pass_loop_distribution;\n extern struct tree_opt_pass pass_vectorize;\n extern struct tree_opt_pass pass_complete_unroll;\n extern struct tree_opt_pass pass_parallelize_loops;"}, {"sha": "9f9ea823f20dbba5fcc03fbdf835c67ffc91cec1", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -41,28 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"recog.h\"\n \n-/* Main analysis functions.  */\n-static bool vect_analyze_data_refs (loop_vec_info);\n-static bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n-static void vect_analyze_scalar_cycles (loop_vec_info);\n-static bool vect_analyze_data_ref_accesses (loop_vec_info);\n-static bool vect_analyze_data_ref_dependences (loop_vec_info);\n-static bool vect_analyze_data_refs_alignment (loop_vec_info);\n-static bool vect_compute_data_refs_alignment (loop_vec_info);\n-static bool vect_enhance_data_refs_alignment (loop_vec_info);\n-static bool vect_analyze_operations (loop_vec_info);\n-static bool vect_determine_vectorization_factor (loop_vec_info);\n-\n-/* Utility functions for the analyses.  */\n-static bool exist_non_indexing_operands_for_use_p (tree, tree);\n-static tree vect_get_loop_niters (struct loop *, tree *);\n-static bool vect_analyze_data_ref_dependence\n-  (struct data_dependence_relation *, loop_vec_info);\n-static bool vect_compute_data_ref_alignment (struct data_reference *); \n-static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n-static void vect_update_misalignment_for_peel\n-  (struct data_reference *, struct data_reference *, int npeel);\n \n /* Function vect_determine_vectorization_factor\n "}, {"sha": "f657eeaa198a8cc55c3b20ea4506dcf2fd120df9", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -146,25 +146,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n \n-/*************************************************************************\n-  Simple Loop Peeling Utilities\n- *************************************************************************/\n-static void slpeel_update_phis_for_duplicate_loop \n-  (struct loop *, struct loop *, bool after);\n-static void slpeel_update_phi_nodes_for_guard1 \n-  (edge, struct loop *, bool, basic_block *, bitmap *); \n-static void slpeel_update_phi_nodes_for_guard2 \n-  (edge, struct loop *, bool, basic_block *);\n-static edge slpeel_add_loop_guard (basic_block, tree, basic_block, basic_block);\n-\n-static void rename_use_op (use_operand_p);\n-static void rename_variables_in_bb (basic_block);\n-static void rename_variables_in_loop (struct loop *);\n-\n /*************************************************************************\n   General Vectorization Utilities\n  *************************************************************************/\n-static void vect_set_dump_settings (void);\n \n /* vect_dump will be set to stderr or dump_file if exist.  */\n FILE *vect_dump;\n@@ -241,7 +225,7 @@ rename_variables_in_bb (basic_block bb)\n \n /* Renames variables in new generated LOOP.  */\n \n-static void\n+void\n rename_variables_in_loop (struct loop *loop)\n {\n   unsigned i;\n@@ -806,7 +790,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n /* Given LOOP this function generates a new copy of it and puts it \n    on E which is either the entry or exit of LOOP.  */\n \n-static struct loop *\n+struct loop *\n slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n {\n   struct loop *new_loop;\n@@ -871,6 +855,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n   if (at_exit) /* Add the loop copy at exit.  */\n     {\n       redirect_edge_and_branch_force (e, new_loop->header);\n+      PENDING_STMT (e) = NULL;\n       set_immediate_dominator (CDI_DOMINATORS, new_loop->header, e->src);\n       if (was_imm_dom)\n \tset_immediate_dominator (CDI_DOMINATORS, exit_dest, new_loop->header);\n@@ -888,6 +873,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n \tnew_exit_e = EDGE_SUCC (new_loop->header, 1); \n \n       redirect_edge_and_branch_force (new_exit_e, loop->header);\n+      PENDING_STMT (new_exit_e) = NULL;\n       set_immediate_dominator (CDI_DOMINATORS, loop->header,\n \t\t\t       new_exit_e->src);\n \n@@ -901,6 +887,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n \t}    \n \n       redirect_edge_and_branch_force (entry_e, new_loop->header);\n+      PENDING_STMT (entry_e) = NULL;\n       set_immediate_dominator (CDI_DOMINATORS, new_loop->header, preheader);\n     }\n "}, {"sha": "7b2be7457b65b5ad260d6cbd2dc1c11a37cca21f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea61d92828ce08a91a19523d3cc2eaf29b76acf/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=dea61d92828ce08a91a19523d3cc2eaf29b76acf", "patch": "@@ -630,6 +630,7 @@ extern struct loop *slpeel_tree_peel_loop_to_edge\n   (struct loop *, edge, tree, tree, bool, unsigned int, bool);\n extern void set_prologue_iterations (basic_block, tree,\n \t\t\t\t     struct loop *, unsigned int);\n+struct loop *tree_duplicate_loop_on_edge (struct loop *, edge);\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n #ifdef ENABLE_CHECKING"}]}