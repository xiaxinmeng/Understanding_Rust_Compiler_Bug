{"sha": "cf2b99ceb738610a60aa3d1c6d6a4518d2827b75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyYjk5Y2ViNzM4NjEwYTYwYWEzZDFjNmQ2YTQ1MThkMjgyN2I3NQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2009-12-06T12:03:51Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-12-06T12:03:51Z"}, "message": "i386-md (g): Add HImode and QImode.\n\n\t* config/i386/i386-md (g): Add HImode and QImode.\n\t(general_szext_operand): New mode attribute.\n\t(*test<mode>_1): Macroize insn from *test{qi,hi,si}_1 using\n\tSWI124 mode iterator.\n\t(and<mode>3): Macroize expander from and{qi,hi,si,di}3 using\n\tSWIM mode iterator.\n\t(*and<mode>_2): Macroize insn from *and{qi,hi,si}_2 using\n\tSWI124 mode iterator.\n\t(ior<mode>3): Macroize expander from ior{qi,hi,si,di}3 using\n\tSWIM mode iterator.\n\t(*ior<mode>_1): Macroize insn from *ior{hi,si,di}_1 using\n\tSWI248 mode iterator.\n\t(*ior<mode>_2): Macroize insn from *ior{qi,hi,si,di}_2 using\n\tSWI mode iterator.\n\t(*ior<mode>_3): Macroize insn from *ior{qi,hi,si,di}_3 using\n\tSWI mode iterator.\n\t(xor<mode>3): Macroize expander from xor{qi,hi,si,di}3 using\n\tSWIM mode iterator.\n\t(*xor<mode>_1): Macroize insn from *xor{hi,si,di}_1 using\n\tSWI248 mode iterator.\n\t(*xor<mode>_2): Macroize insn from *xor{qi,hi,si,di}_2 using\n\tSWI mode iterator.\n\t(*xor<mode>_3): Macroize insn from *xor{qi,hi,si,di}_3 using\n\tSWI mode iterator.\n\nFrom-SVN: r155021", "tree": {"sha": "9f0ff38e49a94bc97d6f019b0c01a8ee77641873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0ff38e49a94bc97d6f019b0c01a8ee77641873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23569a76fdded343d65c628c23282e584c6a608f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23569a76fdded343d65c628c23282e584c6a608f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23569a76fdded343d65c628c23282e584c6a608f"}], "stats": {"total": 994, "additions": 365, "deletions": 629}, "files": [{"sha": "c7a81fe9b5b7b2517a1037168665bdbc73a07f5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf2b99ceb738610a60aa3d1c6d6a4518d2827b75", "patch": "@@ -1,3 +1,30 @@\n+2009-12-06  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-md (g): Add HImode and QImode.\n+\t(general_szext_operand): New mode attribute.\n+\t(*test<mode>_1): Macroize insn from *test{qi,hi,si}_1 using\n+\tSWI124 mode iterator.\n+\t(and<mode>3): Macroize expander from and{qi,hi,si,di}3 using\n+\tSWIM mode iterator.\n+\t(*and<mode>_2): Macroize insn from *and{qi,hi,si}_2 using\n+\tSWI124 mode iterator.\n+\t(ior<mode>3): Macroize expander from ior{qi,hi,si,di}3 using\n+\tSWIM mode iterator.\n+\t(*ior<mode>_1): Macroize insn from *ior{hi,si,di}_1 using\n+\tSWI248 mode iterator.\n+\t(*ior<mode>_2): Macroize insn from *ior{qi,hi,si,di}_2 using\n+\tSWI mode iterator.\n+\t(*ior<mode>_3): Macroize insn from *ior{qi,hi,si,di}_3 using\n+\tSWI mode iterator.\n+\t(xor<mode>3): Macroize expander from xor{qi,hi,si,di}3 using\n+\tSWIM mode iterator.\n+\t(*xor<mode>_1): Macroize insn from *xor{hi,si,di}_1 using\n+\tSWI248 mode iterator.\n+\t(*xor<mode>_2): Macroize insn from *xor{qi,hi,si,di}_2 using\n+\tSWI mode iterator.\n+\t(*xor<mode>_3): Macroize insn from *xor{qi,hi,si,di}_3 using\n+\tSWI mode iterator.\n+\n 2009-12-05  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* config/i386/i386.c (TARGET_DEFAULT_TARGET_FLAGS): Add"}, {"sha": "9fd9f9aaf5d6c25387ac81a37300e244fb7d3c30", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 338, "deletions": 629, "changes": 967, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b99ceb738610a60aa3d1c6d6a4518d2827b75/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cf2b99ceb738610a60aa3d1c6d6a4518d2827b75", "patch": "@@ -788,7 +788,7 @@\n (define_mode_attr i [(QI \"n\") (HI \"n\") (SI \"i\") (DI \"e\")])\n \n ;; General operand constraint for word modes.\n-(define_mode_attr g [(SI \"g\") (DI \"rme\")])\n+(define_mode_attr g [(QI \"qmn\") (HI \"rmn\") (SI \"g\") (DI \"rme\")])\n \n ;; Immediate operand constraint for double integer modes.\n (define_mode_attr di [(SI \"iF\") (DI \"e\")])\n@@ -801,6 +801,13 @@\n \t (DI \"x86_64_general_operand\")\n \t (TI \"x86_64_general_operand\")])\n \n+;; General sign/zero extend operand predicate for integer modes.\n+(define_mode_attr general_szext_operand\n+\t[(QI \"general_operand\")\n+\t (HI \"general_operand\")\n+\t (SI \"general_operand\")\n+\t (DI \"x86_64_szext_general_operand\")])\n+\n ;; SSE and x87 SFmode and DFmode floating point modes\n (define_mode_iterator MODEF [SF DF])\n \n@@ -8110,39 +8117,6 @@\n ;; On Pentium, \"test imm, reg\" is pairable only with eax, ax, and al.\n ;; Note that this excludes ah.\n \n-(define_insn \"*testdi_1_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and:DI (match_operand:DI 0 \"nonimmediate_operand\" \"%!*a,r,!*a,r,rm\")\n-\t\t  (match_operand:DI 1 \"x86_64_szext_general_operand\" \"Z,Z,e,e,re\"))\n-\t  (const_int 0)))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"@\n-   test{l}\\t{%k1, %k0|%k0, %k1}\n-   test{l}\\t{%k1, %k0|%k0, %k1}\n-   test{q}\\t{%1, %0|%0, %1}\n-   test{q}\\t{%1, %0|%0, %1}\n-   test{q}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"test\")\n-   (set_attr \"modrm\" \"0,1,0,1,1\")\n-   (set_attr \"mode\" \"SI,SI,DI,DI,DI\")\n-   (set_attr \"pent_pair\" \"uv,np,uv,np,uv\")])\n-\n-(define_insn \"testsi_1\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"%!*a,r,rm\")\n-\t\t  (match_operand:SI 1 \"general_operand\" \"i,i,ri\"))\n-\t  (const_int 0)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"test{l}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"test\")\n-   (set_attr \"modrm\" \"0,1,1\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"pent_pair\" \"uv,np,uv\")])\n-\n (define_expand \"testsi_ccno_1\"\n   [(set (reg:CCNO FLAGS_REG)\n \t(compare:CCNO\n@@ -8152,19 +8126,6 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*testhi_1\"\n-  [(set (reg FLAGS_REG)\n-        (compare (and:HI (match_operand:HI 0 \"nonimmediate_operand\" \"%!*a,r,rm\")\n-\t\t\t (match_operand:HI 1 \"general_operand\" \"n,n,rn\"))\n-\t\t (const_int 0)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"test{w}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"test\")\n-   (set_attr \"modrm\" \"0,1,1\")\n-   (set_attr \"mode\" \"HI\")\n-   (set_attr \"pent_pair\" \"uv,np,uv\")])\n-\n (define_expand \"testqi_ccz_1\"\n   [(set (reg:CCZ FLAGS_REG)\n         (compare:CCZ (and:QI (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n@@ -8173,6 +8134,25 @@\n   \"\"\n   \"\")\n \n+(define_insn \"*testdi_1\"\n+  [(set (reg FLAGS_REG)\n+\t(compare\n+\t (and:DI\n+\t  (match_operand:DI 0 \"nonimmediate_operand\" \"%!*a,r,!*a,r,rm\")\n+\t  (match_operand:DI 1 \"x86_64_szext_general_operand\" \"Z,Z,e,e,re\"))\n+\t (const_int 0)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"@\n+   test{l}\\t{%k1, %k0|%k0, %k1}\n+   test{l}\\t{%k1, %k0|%k0, %k1}\n+   test{q}\\t{%1, %0|%0, %1}\n+   test{q}\\t{%1, %0|%0, %1}\n+   test{q}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"test\")\n+   (set_attr \"modrm\" \"0,1,0,1,1\")\n+   (set_attr \"mode\" \"SI,SI,DI,DI,DI\")])\n+\n (define_insn \"*testqi_1_maybe_si\"\n   [(set (reg FLAGS_REG)\n         (compare\n@@ -8198,19 +8178,19 @@\n    (set_attr \"mode\" \"QI,QI,QI,SI\")\n    (set_attr \"pent_pair\" \"uv,np,uv,np\")])\n \n-(define_insn \"*testqi_1\"\n+(define_insn \"*test<mode>_1\"\n   [(set (reg FLAGS_REG)\n-        (compare\n-\t  (and:QI\n-\t    (match_operand:QI 0 \"nonimmediate_operand\" \"%!*a,q,qm\")\n-\t    (match_operand:QI 1 \"general_operand\" \"n,n,qn\"))\n-\t  (const_int 0)))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && ix86_match_ccmode (insn, CCNOmode)\"\n-  \"test{b}\\t{%1, %0|%0, %1}\"\n+\t(compare\n+\t (and:SWI124\n+\t  (match_operand:SWI124 0 \"nonimmediate_operand\" \"%!*a,<r>,<r>m\")\n+\t  (match_operand:SWI124 1 \"general_operand\" \"<i>,<i>,<r><i>\"))\n+\t (const_int 0)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"test{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"test\")\n    (set_attr \"modrm\" \"0,1,1\")\n-   (set_attr \"mode\" \"QI\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"pent_pair\" \"uv,np,uv\")])\n \n (define_expand \"testqi_ext_ccno_0\"\n@@ -8244,7 +8224,7 @@\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"pent_pair\" \"np\")])\n \n-(define_insn \"*testqi_ext_1\"\n+(define_insn \"*testqi_ext_1_rex64\"\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (and:SI\n@@ -8253,15 +8233,14 @@\n \t      (const_int 8)\n \t      (const_int 8))\n \t    (zero_extend:SI\n-\t      (match_operand:QI 1 \"general_operand\" \"Qm\")))\n+\t      (match_operand:QI 1 \"register_operand\" \"Q\")))\n \t  (const_int 0)))]\n-  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n   \"test{b}\\t{%1, %h0|%h0, %1}\"\n   [(set_attr \"type\" \"test\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*testqi_ext_1_rex64\"\n+(define_insn \"*testqi_ext_1\"\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (and:SI\n@@ -8270,9 +8249,9 @@\n \t      (const_int 8)\n \t      (const_int 8))\n \t    (zero_extend:SI\n-\t      (match_operand:QI 1 \"register_operand\" \"Q\")))\n+\t      (match_operand:QI 1 \"general_operand\" \"Qm\")))\n \t  (const_int 0)))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n   \"test{b}\\t{%1, %h0|%h0, %1}\"\n   [(set_attr \"type\" \"test\")\n    (set_attr \"mode\" \"QI\")])\n@@ -8295,24 +8274,6 @@\n   [(set_attr \"type\" \"test\")\n    (set_attr \"mode\" \"QI\")])\n \n-;; Combine likes to form bit extractions for some tests.  Humor it.\n-(define_insn \"*testqi_ext_3\"\n-  [(set (reg FLAGS_REG)\n-        (compare (zero_extract:SI\n-\t\t   (match_operand 0 \"nonimmediate_operand\" \"rm\")\n-\t\t   (match_operand:SI 1 \"const_int_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (const_int 0)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && INTVAL (operands[1]) > 0\n-   && INTVAL (operands[2]) >= 0\n-   && INTVAL (operands[1]) + INTVAL (operands[2]) <= 32\n-   && (GET_MODE (operands[0]) == SImode\n-       || (TARGET_64BIT && GET_MODE (operands[0]) == DImode)\n-       || GET_MODE (operands[0]) == HImode\n-       || GET_MODE (operands[0]) == QImode)\"\n-  \"#\")\n-\n (define_insn \"*testqi_ext_3_rex64\"\n   [(set (reg FLAGS_REG)\n         (compare (zero_extract:DI\n@@ -8334,6 +8295,24 @@\n        || GET_MODE (operands[0]) == QImode)\"\n   \"#\")\n \n+;; Combine likes to form bit extractions for some tests.  Humor it.\n+(define_insn \"*testqi_ext_3\"\n+  [(set (reg FLAGS_REG)\n+        (compare (zero_extract:SI\n+\t\t   (match_operand 0 \"nonimmediate_operand\" \"rm\")\n+\t\t   (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t (const_int 0)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && INTVAL (operands[1]) > 0\n+   && INTVAL (operands[2]) >= 0\n+   && INTVAL (operands[1]) + INTVAL (operands[2]) <= 32\n+   && (GET_MODE (operands[0]) == SImode\n+       || (TARGET_64BIT && GET_MODE (operands[0]) == DImode)\n+       || GET_MODE (operands[0]) == HImode\n+       || GET_MODE (operands[0]) == QImode)\"\n+  \"#\")\n+\n (define_split\n   [(set (match_operand 0 \"flags_reg_operand\" \"\")\n         (match_operator 1 \"compare_operator\"\n@@ -8433,22 +8412,22 @@\n   \"operands[2] = gen_lowpart (QImode, operands[2]);\n    operands[3] = gen_lowpart (QImode, operands[3]);\")\n \n-\n ;; %%% This used to optimize known byte-wide and operations to memory,\n ;; and sometimes to QImode registers.  If this is considered useful,\n ;; it should be done with splitters.\n \n-(define_expand \"anddi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:DI 2 \"x86_64_szext_general_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (AND, DImode, operands); DONE;\")\n+(define_expand \"and<mode>3\"\n+  [(set (match_operand:SWIM 0 \"nonimmediate_operand\" \"\")\n+\t(and:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:SWIM 2 \"<general_szext_operand>\" \"\")))]\n+  \"\"\n+  \"ix86_expand_binary_operator (AND, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*anddi_1_rex64\"\n+(define_insn \"*anddi_1\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n-\t(and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,qm\")\n-\t\t(match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm,L\")))\n+\t(and:DI\n+\t (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,qm\")\n+\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm,L\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (AND, DImode, operands)\"\n {\n@@ -8493,29 +8472,6 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"SI,DI,DI,SI\")])\n \n-(define_insn \"*anddi_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (and:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,rem,re\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,rm\")\n-\t(and:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (AND, DImode, operands)\"\n-  \"@\n-   and{l}\\t{%k2, %k0|%k0, %k2}\n-   and{q}\\t{%2, %0|%0, %2}\n-   and{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI,DI,DI\")])\n-\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (AND, SImode, operands); DONE;\")\n-\n (define_insn \"*andsi_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n \t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n@@ -8561,43 +8517,6 @@\n    (set_attr \"length_immediate\" \"*,*,0\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(and (match_dup 0)\n-\t     (const_int -65536)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"optimize_function_for_size_p (cfun) || (TARGET_FAST_PREFIX && !TARGET_PARTIAL_REG_STALL)\"\n-  [(set (strict_low_part (match_dup 1)) (const_int 0))]\n-  \"operands[1] = gen_lowpart (HImode, operands[0]);\")\n-\n-(define_split\n-  [(set (match_operand 0 \"ext_register_operand\" \"\")\n-\t(and (match_dup 0)\n-\t     (const_int -256)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_REG_STALL) && reload_completed\"\n-  [(set (strict_low_part (match_dup 1)) (const_int 0))]\n-  \"operands[1] = gen_lowpart (QImode, operands[0]);\")\n-\n-(define_split\n-  [(set (match_operand 0 \"ext_register_operand\" \"\")\n-\t(and (match_dup 0)\n-\t     (const_int -65281)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_REG_STALL) && reload_completed\"\n-  [(parallel [(set (zero_extract:SI (match_dup 0)\n-\t\t\t\t    (const_int 8)\n-\t\t\t\t    (const_int 8))\n-\t\t   (xor:SI\n-\t\t     (zero_extract:SI (match_dup 0)\n-\t\t\t\t      (const_int 8)\n-\t\t\t\t      (const_int 8))\n-\t\t     (zero_extract:SI (match_dup 0)\n-\t\t\t\t      (const_int 8)\n-\t\t\t\t      (const_int 8))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\")\n-\n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n (define_insn \"*andsi_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8610,40 +8529,6 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*andsi_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g,ri\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(and:SI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (AND, SImode, operands)\"\n-  \"and{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; See comment for addsi_1_zext why we do use nonimmediate_operand\n-(define_insn \"*andsi_2_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (AND, SImode, operands)\"\n-  \"and{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"andhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (AND, HImode, operands); DONE;\")\n-\n (define_insn \"*andhi_1\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,r\")\n \t(and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,qm\")\n@@ -8674,26 +8559,6 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"HI,HI,SI\")])\n \n-(define_insn \"*andhi_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"rmn,rn\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(and:HI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (AND, HImode, operands)\"\n-  \"and{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"andqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (AND, QImode, operands); DONE;\")\n-\n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*andqi_1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r\")\n@@ -8713,17 +8578,75 @@\n \t(and:QI (match_dup 0)\n \t\t(match_operand:QI 1 \"general_operand\" \"qn,qmn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"and{b}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(and (match_dup 0)\n+\t     (const_int -65536)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(TARGET_FAST_PREFIX && !TARGET_PARTIAL_REG_STALL)\n+    || optimize_function_for_size_p (cfun)\"\n+  [(set (strict_low_part (match_dup 1)) (const_int 0))]\n+  \"operands[1] = gen_lowpart (HImode, operands[0]);\")\n+\n+(define_split\n+  [(set (match_operand 0 \"ext_register_operand\" \"\")\n+\t(and (match_dup 0)\n+\t     (const_int -256)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   && reload_completed\"\n+  [(set (strict_low_part (match_dup 1)) (const_int 0))]\n+  \"operands[1] = gen_lowpart (QImode, operands[0]);\")\n+\n+(define_split\n+  [(set (match_operand 0 \"ext_register_operand\" \"\")\n+\t(and (match_dup 0)\n+\t     (const_int -65281)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   && reload_completed\"\n+  [(parallel [(set (zero_extract:SI (match_dup 0)\n+\t\t\t\t    (const_int 8)\n+\t\t\t\t    (const_int 8))\n+\t\t   (xor:SI\n+\t\t     (zero_extract:SI (match_dup 0)\n+\t\t\t\t      (const_int 8)\n+\t\t\t\t      (const_int 8))\n+\t\t     (zero_extract:SI (match_dup 0)\n+\t\t\t\t      (const_int 8)\n+\t\t\t\t      (const_int 8))))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\")\n+\n+(define_insn \"*anddi_2\"\n+  [(set (reg FLAGS_REG)\n+\t(compare\n+\t (and:DI\n+\t  (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t  (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,rem,re\"))\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,rm\")\n+\t(and:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (AND, DImode, operands)\"\n+  \"@\n+   and{l}\\t{%k2, %k0|%k0, %k2}\n+   and{q}\\t{%2, %0|%0, %2}\n+   and{q}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI,DI,DI\")])\n+\n (define_insn \"*andqi_2_maybe_si\"\n   [(set (reg FLAGS_REG)\n \t(compare (and:QI\n-\t\t      (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t      (match_operand:QI 2 \"general_operand\" \"qmn,qn,n\"))\n+\t\t  (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"qmn,qn,n\"))\n \t\t (const_int 0)))\n    (set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,qm,*r\")\n \t(and:QI (match_dup 1) (match_dup 2)))]\n@@ -8743,29 +8666,44 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI,QI,SI\")])\n \n-(define_insn \"*andqi_2\"\n+(define_insn \"*and<mode>_2\"\n   [(set (reg FLAGS_REG)\n-\t(compare (and:QI\n-\t\t   (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"qmn,qn\"))\n+\t(compare (and:SWI124\n+\t\t  (match_operand:SWI124 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t  (match_operand:SWI124 2 \"general_operand\" \"<g>,<r><i>\"))\n \t\t (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,qm\")\n-\t(and:QI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:SWI124 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n+\t(and:SWI124 (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (AND, QImode, operands)\"\n-  \"and{b}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (AND, <MODE>mode, operands)\"\n+  \"and{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*andqi_2_slp\"\n+;; See comment for addsi_1_zext why we do use nonimmediate_operand\n+(define_insn \"*andsi_2_zext\"\n+  [(set (reg FLAGS_REG)\n+\t(compare (and:SI\n+\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t\t (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (AND, SImode, operands)\"\n+  \"and{l}\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*andqi_2_slp\"\n   [(set (reg FLAGS_REG)\n \t(compare (and:QI\n \t\t   (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n \t\t   (match_operand:QI 1 \"nonimmediate_operand\" \"qmn,qn\"))\n \t\t (const_int 0)))\n    (set (strict_low_part (match_dup 0))\n \t(and:QI (match_dup 0) (match_dup 1)))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && ix86_match_ccmode (insn, CCNOmode)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"and{b}\\t{%1, %0|%0, %1}\"\n@@ -8775,7 +8713,6 @@\n ;; ??? A bug in recog prevents it from recognizing a const_int as an\n ;; operand to zero_extend in andqi_ext_1.  It was checking explicitly\n ;; for a QImode operand, which of course failed.\n-\n (define_insn \"andqi_ext_0\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n@@ -8796,7 +8733,6 @@\n \n ;; Generated by peephole translating test to and.  This shows up\n ;; often in fp comparisons.\n-\n (define_insn \"*andqi_ext_0_cc\"\n   [(set (reg FLAGS_REG)\n \t(compare\n@@ -8823,7 +8759,7 @@\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*andqi_ext_1\"\n+(define_insn \"*andqi_ext_1_rex64\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n@@ -8833,15 +8769,15 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n+\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\"\n+  \"TARGET_64BIT\"\n   \"and{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*andqi_ext_1_rex64\"\n+(define_insn \"*andqi_ext_1\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n@@ -8851,9 +8787,9 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n+\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n+  \"!TARGET_64BIT\"\n   \"and{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n@@ -8929,68 +8865,36 @@\n ;; %%% This used to optimize known byte-wide and operations to memory.\n ;; If this is considered useful, it should be done with splitters.\n \n-(define_expand \"iordi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (IOR, DImode, operands); DONE;\")\n+(define_expand \"ior<mode>3\"\n+  [(set (match_operand:SWIM 0 \"nonimmediate_operand\" \"\")\n+\t(ior:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:SWIM 2 \"<general_operand>\" \"\")))]\n+  \"\"\n+  \"ix86_expand_binary_operator (IOR, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*iordi_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"re,rme\")))\n+(define_insn \"*ior<mode>_1\"\n+  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(ior:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t    (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && ix86_binary_operator_ok (IOR, DImode, operands)\"\n-  \"or{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*iordi_2_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem,re\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(ior:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, DImode, operands)\"\n-  \"or{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*iordi_3_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (ior:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem\"))\n-\t\t (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, DImode, operands)\"\n-  \"or{q}\\t{%2, %0|%0, %2}\"\n+  \"ix86_binary_operator_ok (IOR, <MODE>mode, operands)\"\n+  \"or{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-\n-(define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (IOR, SImode, operands); DONE;\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*iorsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"ri,g\")))\n+;; %%% Potential partial reg stall on alternative 2.  What to do?\n+(define_insn \"*iorqi_1\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n+\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (IOR, SImode, operands)\"\n-  \"or{l}\\t{%2, %0|%0, %2}\"\n+  \"ix86_binary_operator_ok (IOR, QImode, operands)\"\n+  \"@\n+   or{b}\\t{%2, %0|%0, %2}\n+   or{b}\\t{%2, %0|%0, %2}\n+   or{l}\\t{%k2, %k0|%k0, %k2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"QI,QI,SI\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n (define_insn \"*iorsi_1_zext\"\n@@ -9009,23 +8913,35 @@\n \t(ior:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n \t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\" \"Z\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (IOR, SImode, operands)\"\n   \"or{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*iorsi_2\"\n+(define_insn \"*iorqi_1_slp\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+q,m\"))\n+\t(ior:QI (match_dup 0)\n+\t\t(match_operand:QI 1 \"general_operand\" \"qmn,qn\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"or{b}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*ior<mode>_2\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g,ri\"))\n+\t(compare (ior:SWI\n+\t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>,<r><i>\"))\n \t\t (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(ior:SI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n+\t(ior:SWI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, SImode, operands)\"\n-  \"or{l}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (IOR, <MODE>mode, operands)\"\n+  \"or{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n ;; ??? Special case for immediate operand is missing - it is tricky.\n@@ -9044,8 +8960,9 @@\n \n (define_insn \"*iorsi_2_zext_imm\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand 2 \"x86_64_zext_immediate_operand\" \"Z\"))\n+\t(compare (ior:SI\n+\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"x86_64_zext_immediate_operand\" \"Z\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ior:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n@@ -9055,130 +8972,32 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*iorsi_3\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t\t (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"or{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"iorhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (IOR, HImode, operands); DONE;\")\n-\n-(define_insn \"*iorhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,m\")\n-\t(ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmn,rn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (IOR, HImode, operands)\"\n-  \"or{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*iorhi_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"rmn,rn\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(ior:HI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, HImode, operands)\"\n-  \"or{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*iorhi_3\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"rmn\"))\n-\t\t (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"or{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"iorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (IOR, QImode, operands); DONE;\")\n-\n-;; %%% Potential partial reg stall on alternative 2.  What to do?\n-(define_insn \"*iorqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n-\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (IOR, QImode, operands)\"\n-  \"@\n-   or{b}\\t{%2, %0|%0, %2}\n-   or{b}\\t{%2, %0|%0, %2}\n-   or{l}\\t{%k2, %k0|%k0, %k2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI,QI,SI\")])\n-\n-(define_insn \"*iorqi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+q,m\"))\n-\t(ior:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"qmn,qn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"or{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*iorqi_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:QI 2 \"general_operand\" \"qmn,qn\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,qm\")\n-\t(ior:QI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, QImode, operands)\"\n-  \"or{b}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI\")])\n-\n (define_insn \"*iorqi_2_slp\"\n   [(set (reg FLAGS_REG)\n \t(compare (ior:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"qmn,qn\"))\n \t\t (const_int 0)))\n    (set (strict_low_part (match_dup 0))\n \t(ior:QI (match_dup 0) (match_dup 1)))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && ix86_match_ccmode (insn, CCNOmode)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"or{b}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*iorqi_3\"\n+(define_insn \"*ior<mode>_3\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:QI 2 \"general_operand\" \"qmn\"))\n+\t(compare (ior:SWI\n+\t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>\"))\n \t\t (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n+   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"or{b}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (IOR, <MODE>mode, operands)\"\n+  \"or{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*iorqi_ext_0\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n@@ -9191,14 +9010,14 @@\n \t    (const_int 8))\n \t  (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n   \"or{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*iorqi_ext_1\"\n+(define_insn \"*iorqi_ext_1_rex64\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n@@ -9208,16 +9027,16 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n+\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\n+  \"TARGET_64BIT\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n   \"or{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*iorqi_ext_1_rex64\"\n+(define_insn \"*iorqi_ext_1\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n@@ -9227,9 +9046,9 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n+\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n+  \"!TARGET_64BIT\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n   \"or{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n@@ -9248,7 +9067,7 @@\n \t  \t\t   (const_int 8)\n \t\t\t   (const_int 8))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n   \"ior{b}\\t{%h2, %h0|%h0, %h2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n@@ -9299,67 +9118,36 @@\n ;; %%% This used to optimize known byte-wide and operations to memory.\n ;; If this is considered useful, it should be done with splitters.\n \n-(define_expand \"xordi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (XOR, DImode, operands); DONE;\")\n+(define_expand \"xor<mode>3\"\n+  [(set (match_operand:SWIM 0 \"nonimmediate_operand\" \"\")\n+\t(xor:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\" \"\")\n+\t\t  (match_operand:SWIM 2 \"<general_operand>\" \"\")))]\n+  \"\"\n+  \"ix86_expand_binary_operator (XOR, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*xordi_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")))\n+(define_insn \"*xor<mode>_1\"\n+  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(xor:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t    (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && ix86_binary_operator_ok (XOR, DImode, operands)\"\n-  \"xor{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*xordi_2_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem,re\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(xor:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, DImode, operands)\"\n-  \"xor{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*xordi_3_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"rem\"))\n-\t\t (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, DImode, operands)\"\n-  \"xor{q}\\t{%2, %0|%0, %2}\"\n+  \"ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n+  \"xor{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"xorsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (XOR, SImode, operands); DONE;\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*xorsi_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"ri,rm\")))\n+;; %%% Potential partial reg stall on alternative 2.  What to do?\n+(define_insn \"*xorqi_1\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n+\t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (XOR, SImode, operands)\"\n-  \"xor{l}\\t{%2, %0|%0, %2}\"\n+  \"ix86_binary_operator_ok (XOR, QImode, operands)\"\n+  \"@\n+   xor{b}\\t{%2, %0|%0, %2}\n+   xor{b}\\t{%2, %0|%0, %2}\n+   xor{l}\\t{%k2, %k0|%k0, %k2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"QI,QI,SI\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n ;; Add speccase for immediates\n@@ -9384,18 +9172,30 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*xorsi_2\"\n+(define_insn \"*xorqi_1_slp\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n+\t(xor:QI (match_dup 0)\n+\t\t(match_operand:QI 1 \"general_operand\" \"qn,qmn\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"xor{b}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*xor<mode>_2\"\n   [(set (reg FLAGS_REG)\n-\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g,ri\"))\n+\t(compare (xor:SWI\n+\t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>,<r><i>\"))\n \t\t (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(xor:SI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n+\t(xor:SWI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, SImode, operands)\"\n-  \"xor{l}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n+  \"xor{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n ;; ??? Special case for immediate operand is missing - it is tricky.\n@@ -9425,91 +9225,32 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*xorsi_3\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t\t (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"xor{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"xorhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (XOR, HImode, operands); DONE;\")\n-\n-(define_insn \"*xorhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,m\")\n-\t(xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmn,rn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (XOR, HImode, operands)\"\n-  \"xor{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*xorhi_2\"\n+(define_insn \"*xorqi_2_slp\"\n   [(set (reg FLAGS_REG)\n-\t(compare (xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"rmn,rn\"))\n+\t(compare (xor:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n+\t\t\t (match_operand:QI 1 \"general_operand\" \"qmn,qn\"))\n \t\t (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(xor:HI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, HImode, operands)\"\n-  \"xor{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n+   (set (strict_low_part (match_dup 0))\n+\t(xor:QI (match_dup 0) (match_dup 1)))]\n+  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n+   && ix86_match_ccmode (insn, CCNOmode)\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  \"xor{b}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*xorhi_3\"\n+(define_insn \"*xor<mode>_3\"\n   [(set (reg FLAGS_REG)\n-\t(compare (xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"rmn\"))\n+\t(compare (xor:SWI\n+\t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>\"))\n \t\t (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n+   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"xor{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"xorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (XOR, QImode, operands); DONE;\")\n-\n-;; %%% Potential partial reg stall on alternative 2.  What to do?\n-(define_insn \"*xorqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n-\t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (XOR, QImode, operands)\"\n-  \"@\n-   xor{b}\\t{%2, %0|%0, %2}\n-   xor{b}\\t{%2, %0|%0, %2}\n-   xor{l}\\t{%k2, %k0|%k0, %k2}\"\n+   && ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n+  \"xor{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI,QI,SI\")])\n-\n-(define_insn \"*xorqi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n-\t(xor:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"qn,qmn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"xor{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*xorqi_ext_0\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n@@ -9522,14 +9263,14 @@\n \t    (const_int 8))\n \t  (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n   \"xor{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*xorqi_ext_1\"\n+(define_insn \"*xorqi_ext_1_rex64\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n@@ -9539,16 +9280,16 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n+\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\n+  \"TARGET_64BIT\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n   \"xor{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*xorqi_ext_1_rex64\"\n+(define_insn \"*xorqi_ext_1\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n@@ -9558,9 +9299,9 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n+\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n+  \"!TARGET_64BIT\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n   \"xor{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n@@ -9579,117 +9320,85 @@\n \t  \t\t   (const_int 8)\n \t\t\t   (const_int 8))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n   \"xor{b}\\t{%h2, %h0|%h0, %h2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*xorqi_cc_1\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"qmn,qn\"))\n-\t  (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,qm\")\n-\t(xor:QI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, QImode, operands)\"\n-  \"xor{b}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xorqi_2_slp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n-\t\t\t (match_operand:QI 1 \"general_operand\" \"qmn,qn\"))\n-\t\t (const_int 0)))\n-   (set (strict_low_part (match_dup 0))\n-\t(xor:QI (match_dup 0) (match_dup 1)))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"xor{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xorqi_cc_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"qmn\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"xor{b}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI\")])\n+(define_expand \"xorqi_cc_ext_1\"\n+  [(parallel [\n+     (set (reg:CCNO FLAGS_REG)\n+\t  (compare:CCNO\n+\t    (xor:SI\n+\t      (zero_extract:SI\n+\t\t(match_operand 1 \"ext_register_operand\" \"\")\n+\t\t(const_int 8)\n+\t\t(const_int 8))\n+\t      (match_operand:QI 2 \"general_operand\" \"\"))\n+\t    (const_int 0)))\n+     (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"\")\n+\t\t\t   (const_int 8)\n+\t\t\t   (const_int 8))\n+\t  (xor:SI\n+\t    (zero_extract:SI\n+\t     (match_dup 1)\n+\t     (const_int 8)\n+\t     (const_int 8))\n+\t    (match_dup 2)))])]\n+  \"\"\n+  \"\")\n \n-(define_insn \"*xorqi_cc_ext_1\"\n+(define_insn \"*xorqi_cc_ext_1_rex64\"\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (xor:SI\n \t    (zero_extract:SI\n \t      (match_operand 1 \"ext_register_operand\" \"0\")\n \t      (const_int 8)\n \t      (const_int 8))\n-\t    (match_operand:QI 2 \"general_operand\" \"qmn\"))\n+\t    (match_operand:QI 2 \"nonmemory_operand\" \"Qn\"))\n \t  (const_int 0)))\n-   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(xor:SI\n-\t  (zero_extract:SI (match_dup 1) (const_int 8) (const_int 8))\n+\t  (zero_extract:SI\n+\t   (match_dup 1)\n+\t   (const_int 8)\n+\t   (const_int 8))\n \t  (match_dup 2)))]\n-  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n   \"xor{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*xorqi_cc_ext_1_rex64\"\n+(define_insn \"*xorqi_cc_ext_1\"\n   [(set (reg FLAGS_REG)\n \t(compare\n \t  (xor:SI\n \t    (zero_extract:SI\n \t      (match_operand 1 \"ext_register_operand\" \"0\")\n \t      (const_int 8)\n \t      (const_int 8))\n-\t    (match_operand:QI 2 \"nonmemory_operand\" \"Qn\"))\n+\t    (match_operand:QI 2 \"general_operand\" \"qmn\"))\n \t  (const_int 0)))\n-   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n+   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(xor:SI\n-\t  (zero_extract:SI (match_dup 1) (const_int 8) (const_int 8))\n+\t  (zero_extract:SI\n+\t   (match_dup 1)\n+\t   (const_int 8)\n+\t   (const_int 8))\n \t  (match_dup 2)))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n   \"xor{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_expand \"xorqi_cc_ext_1\"\n-  [(parallel [\n-     (set (reg:CCNO FLAGS_REG)\n-\t  (compare:CCNO\n-\t    (xor:SI\n-\t      (zero_extract:SI\n-\t\t(match_operand 1 \"ext_register_operand\" \"\")\n-\t\t(const_int 8)\n-\t\t(const_int 8))\n-\t      (match_operand:QI 2 \"general_operand\" \"\"))\n-\t    (const_int 0)))\n-     (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"\")\n-\t\t\t   (const_int 8)\n-\t\t\t   (const_int 8))\n-\t  (xor:SI\n-\t    (zero_extract:SI (match_dup 1) (const_int 8) (const_int 8))\n-\t    (match_dup 2)))])]\n-  \"\"\n-  \"\")\n-\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(xor (match_operand 1 \"register_operand\" \"\")"}]}