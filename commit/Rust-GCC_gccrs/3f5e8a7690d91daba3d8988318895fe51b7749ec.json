{"sha": "3f5e8a7690d91daba3d8988318895fe51b7749ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1ZThhNzY5MGQ5MWRhYmEzZDg5ODgzMTg4OTVmZTUxYjc3NDllYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-03T13:36:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-03T13:36:13Z"}, "message": "Use innermost_loop_behavior for outer loop vectorisation\n\nThis patch replaces the individual stmt_vinfo dr_* fields with\nan innermost_loop_behavior, so that the changes in later patches\nget picked up automatically.  It also adds a helper function for\ngetting the behavior of a data reference wrt the vectorised loop.\n\n2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vectorizer.h (_stmt_vec_info): Replace individual dr_*\n\tfields with dr_wrt_vec_loop.\n\t(STMT_VINFO_DR_BASE_ADDRESS, STMT_VINFO_DR_INIT, STMT_VINFO_DR_OFFSET)\n\t(STMT_VINFO_DR_STEP, STMT_VINFO_DR_ALIGNED_TO): Update accordingly.\n\t(STMT_VINFO_DR_WRT_VEC_LOOP): New macro.\n\t(vect_dr_behavior): New function.\n\t(vect_create_addr_base_for_vector_ref): Remove loop parameter.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Use\n\tvect_dr_behavior.  Use a step_preserves_misalignment_p boolean to\n\ttrack whether the step preserves the misalignment.\n\t(vect_create_addr_base_for_vector_ref): Remove loop parameter.\n\tUse vect_dr_behavior.\n\t(vect_setup_realignment): Update call accordingly.\n\t(vect_create_data_ref_ptr): Likewise.  Use vect_dr_behavior.\n\t* tree-vect-loop-manip.c (vect_gen_prolog_loop_niters): Update\n\tcall to vect_create_addr_base_for_vector_ref.\n\t(vect_create_cond_for_align_checks): Likewise.\n\t* tree-vect-patterns.c (vect_recog_bool_pattern): Copy\n\tSTMT_VINFO_DR_WRT_VEC_LOOP as a block.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\t* tree-vect-stmts.c (compare_step_with_zero): Use vect_dr_behavior.\n\t(new_stmt_vec_info): Remove redundant zeroing.\n\nFrom-SVN: r249911", "tree": {"sha": "72acbcd4a626f9138dea9686c90e6c41182d293b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72acbcd4a626f9138dea9686c90e6c41182d293b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f5e8a7690d91daba3d8988318895fe51b7749ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5e8a7690d91daba3d8988318895fe51b7749ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5e8a7690d91daba3d8988318895fe51b7749ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5e8a7690d91daba3d8988318895fe51b7749ec/comments", "author": null, "committer": null, "parents": [{"sha": "63d03dcecdafe34715282a5155cfc2162375feca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d03dcecdafe34715282a5155cfc2162375feca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d03dcecdafe34715282a5155cfc2162375feca"}], "stats": {"total": 215, "additions": 100, "deletions": 115}, "files": [{"sha": "a0db67d6890818fa4897cfe022ccfb394942b4c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f5e8a7690d91daba3d8988318895fe51b7749ec", "patch": "@@ -1,3 +1,28 @@\n+2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info): Replace individual dr_*\n+\tfields with dr_wrt_vec_loop.\n+\t(STMT_VINFO_DR_BASE_ADDRESS, STMT_VINFO_DR_INIT, STMT_VINFO_DR_OFFSET)\n+\t(STMT_VINFO_DR_STEP, STMT_VINFO_DR_ALIGNED_TO): Update accordingly.\n+\t(STMT_VINFO_DR_WRT_VEC_LOOP): New macro.\n+\t(vect_dr_behavior): New function.\n+\t(vect_create_addr_base_for_vector_ref): Remove loop parameter.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Use\n+\tvect_dr_behavior.  Use a step_preserves_misalignment_p boolean to\n+\ttrack whether the step preserves the misalignment.\n+\t(vect_create_addr_base_for_vector_ref): Remove loop parameter.\n+\tUse vect_dr_behavior.\n+\t(vect_setup_realignment): Update call accordingly.\n+\t(vect_create_data_ref_ptr): Likewise.  Use vect_dr_behavior.\n+\t* tree-vect-loop-manip.c (vect_gen_prolog_loop_niters): Update\n+\tcall to vect_create_addr_base_for_vector_ref.\n+\t(vect_create_cond_for_align_checks): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_bool_pattern): Copy\n+\tSTMT_VINFO_DR_WRT_VEC_LOOP as a block.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\t* tree-vect-stmts.c (compare_step_with_zero): Use vect_dr_behavior.\n+\t(new_stmt_vec_info): Remove redundant zeroing.\n+\n 2017-07-02  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* common/config/arm/arm-common.c (arm_be8_option): New function."}, {"sha": "3b4d570cc6abc20caf22f1952328f2d605681cb8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 42, "deletions": 70, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=3f5e8a7690d91daba3d8988318895fe51b7749ec", "patch": "@@ -666,11 +666,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n   tree ref = DR_REF (dr);\n-  tree vectype;\n-  tree base, base_addr;\n-  tree misalign = NULL_TREE;\n-  tree aligned_to;\n-  tree step;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree base;\n   unsigned HOST_WIDE_INT alignment;\n \n   if (dump_enabled_p ())\n@@ -683,38 +680,37 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   /* Initialize misalignment to unknown.  */\n   SET_DR_MISALIGNMENT (dr, DR_MISALIGNMENT_UNKNOWN);\n \n-  if (tree_fits_shwi_p (DR_STEP (dr)))\n-    misalign = DR_INIT (dr);\n-  aligned_to = DR_ALIGNED_TO (dr);\n-  base_addr = DR_BASE_ADDRESS (dr);\n-  vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  innermost_loop_behavior *drb = vect_dr_behavior (dr);\n+  bool step_preserves_misalignment_p;\n+\n+  /* No step for BB vectorization.  */\n+  if (!loop)\n+    {\n+      gcc_assert (integer_zerop (drb->step));\n+      step_preserves_misalignment_p = true;\n+    }\n \n   /* In case the dataref is in an inner-loop of the loop that is being\n      vectorized (LOOP), we use the base and misalignment information\n      relative to the outer-loop (LOOP).  This is ok only if the misalignment\n      stays the same throughout the execution of the inner-loop, which is why\n      we have to check that the stride of the dataref in the inner-loop evenly\n      divides by the vector size.  */\n-  if (loop && nested_in_vect_loop_p (loop, stmt))\n+  else if (nested_in_vect_loop_p (loop, stmt))\n     {\n       tree step = DR_STEP (dr);\n+      step_preserves_misalignment_p\n+\t= (tree_fits_shwi_p (step)\n+\t   && tree_to_shwi (step) % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0);\n \n-      if (tree_fits_shwi_p (step)\n-\t  && tree_to_shwi (step) % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0)\n-        {\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"inner step divides the vector-size.\\n\");\n-\t  misalign = STMT_VINFO_DR_INIT (stmt_info);\n-\t  aligned_to = STMT_VINFO_DR_ALIGNED_TO (stmt_info);\n-\t  base_addr = STMT_VINFO_DR_BASE_ADDRESS (stmt_info);\n-        }\n-      else\n+      if (dump_enabled_p ())\n \t{\n-\t  if (dump_enabled_p ())\n+\t  if (step_preserves_misalignment_p)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"inner step divides the vector-size.\\n\");\n+\t  else\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                     \"inner step doesn't divide the vector-size.\\n\");\n-\t  misalign = NULL_TREE;\n+\t\t\t     \"inner step doesn't divide the vector-size.\\n\");\n \t}\n     }\n \n@@ -725,18 +721,17 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   else\n     {\n       tree step = DR_STEP (dr);\n-      unsigned vf = loop ? LOOP_VINFO_VECT_FACTOR (loop_vinfo) : 1;\n+      unsigned vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      step_preserves_misalignment_p\n+\t= (tree_fits_shwi_p (step)\n+\t   && ((tree_to_shwi (step) * vf)\n+\t       % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0));\n \n-      if (tree_fits_shwi_p (step)\n-\t  && ((tree_to_shwi (step) * vf)\n-\t      % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                     \"step doesn't divide the vector-size.\\n\");\n-\t  misalign = NULL_TREE;\n-\t}\n+      if (!step_preserves_misalignment_p && dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"step doesn't divide the vector-size.\\n\");\n     }\n+  tree base_addr = drb->base_address;\n \n   /* To look at alignment of the base we have to preserve an inner MEM_REF\n      as that carries alignment information of the actual access.  */\n@@ -777,8 +772,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   alignment = TYPE_ALIGN_UNIT (vectype);\n \n-  if ((compare_tree_int (aligned_to, alignment) < 0)\n-      || !misalign)\n+  if ((compare_tree_int (drb->aligned_to, alignment) < 0)\n+      || !step_preserves_misalignment_p)\n     {\n       if (dump_enabled_p ())\n \t{\n@@ -835,19 +830,16 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       DR_VECT_AUX (dr)->base_element_aligned = true;\n     }\n \n-  if (loop && nested_in_vect_loop_p (loop, stmt))\n-    step = STMT_VINFO_DR_STEP (stmt_info);\n-  else\n-    step = DR_STEP (dr);\n   /* If this is a backward running DR then first access in the larger\n      vectype actually is N-1 elements before the address in the DR.\n      Adjust misalign accordingly.  */\n-  if (tree_int_cst_sgn (step) < 0)\n+  tree misalign = drb->init;\n+  if (tree_int_cst_sgn (drb->step) < 0)\n     {\n       tree offset = ssize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n       /* DR_STEP(dr) is the same as -TYPE_SIZE of the scalar type,\n \t otherwise we wouldn't be here.  */\n-      offset = fold_build2 (MULT_EXPR, ssizetype, offset, step);\n+      offset = fold_build2 (MULT_EXPR, ssizetype, offset, drb->step);\n       /* PLUS because STEP was negative.  */\n       misalign = size_binop (PLUS_EXPR, misalign, offset);\n     }\n@@ -3973,38 +3965,22 @@ tree\n vect_create_addr_base_for_vector_ref (gimple *stmt,\n \t\t\t\t      gimple_seq *new_stmt_list,\n \t\t\t\t      tree offset,\n-\t\t\t\t      struct loop *loop,\n \t\t\t\t      tree byte_offset)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree data_ref_base;\n   const char *base_name;\n   tree addr_base;\n   tree dest;\n   gimple_seq seq = NULL;\n-  tree base_offset;\n-  tree init;\n   tree vect_ptr_type;\n   tree step = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  innermost_loop_behavior *drb = vect_dr_behavior (dr);\n \n-  if (loop_vinfo && loop && loop != (gimple_bb (stmt))->loop_father)\n-    {\n-      struct loop *outer_loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\n-      gcc_assert (nested_in_vect_loop_p (outer_loop, stmt));\n-\n-      data_ref_base = unshare_expr (STMT_VINFO_DR_BASE_ADDRESS (stmt_info));\n-      base_offset = unshare_expr (STMT_VINFO_DR_OFFSET (stmt_info));\n-      init = unshare_expr (STMT_VINFO_DR_INIT (stmt_info));\n-    }\n-  else\n-    {\n-      data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n-      base_offset = unshare_expr (DR_OFFSET (dr));\n-      init = unshare_expr (DR_INIT (dr));\n-    }\n+  tree data_ref_base = unshare_expr (drb->base_address);\n+  tree base_offset = unshare_expr (drb->offset);\n+  tree init = unshare_expr (drb->init);\n \n   if (loop_vinfo)\n     base_name = get_name (data_ref_base);\n@@ -4169,11 +4145,7 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \n   /* Check the step (evolution) of the load in LOOP, and record\n      whether it's invariant.  */\n-  if (nested_in_vect_loop)\n-    step = STMT_VINFO_DR_STEP (stmt_info);\n-  else\n-    step = DR_STEP (STMT_VINFO_DATA_REF (stmt_info));\n-\n+  step = vect_dr_behavior (dr)->step;\n   if (integer_zerop (step))\n     *inv_p = true;\n   else\n@@ -4271,7 +4243,7 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n   /* Create: (&(base[init_val+offset]+byte_offset) in the loop preheader.  */\n \n   new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list,\n-\t\t\t\t\t\t   offset, loop, byte_offset);\n+\t\t\t\t\t\t   offset, byte_offset);\n   if (new_stmt_list)\n     {\n       if (pe)\n@@ -4985,7 +4957,7 @@ vect_setup_realignment (gimple *stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  /* Generate the INIT_ADDR computation outside LOOP.  */\n \t  init_addr = vect_create_addr_base_for_vector_ref (stmt, &stmts,\n-\t\t\t\t\t\t\tNULL_TREE, loop);\n+\t\t\t\t\t\t\t    NULL_TREE);\n           if (loop)\n             {\n    \t      pe = loop_preheader_edge (loop);"}, {"sha": "aa52c50f531dc68046a0849abfc8865cc664cd01", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=3f5e8a7690d91daba3d8988318895fe51b7749ec", "patch": "@@ -949,7 +949,6 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n \t\t\t     basic_block bb, int *bound)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree var;\n   tree niters_type = TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo));\n   gimple_seq stmts = NULL, new_stmts = NULL;\n@@ -977,7 +976,7 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n       tree offset = negative\n \t  ? size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1) : size_zero_node;\n       tree start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n-\t\t\t\t\t\t&stmts, offset, loop);\n+\t\t\t\t\t\t\t      &stmts, offset);\n       tree type = unsigned_type_for (TREE_TYPE (start_addr));\n       tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);\n       HOST_WIDE_INT elem_size =\n@@ -1975,7 +1974,6 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n                                    tree *cond_expr,\n \t\t\t\t   gimple_seq *cond_expr_stmt_list)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   vec<gimple *> may_misalign_stmts\n     = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n   gimple *ref_stmt;\n@@ -2016,7 +2014,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n       /* create: addr_tmp = (int)(address_of_first_vector) */\n       addr_base =\n \tvect_create_addr_base_for_vector_ref (ref_stmt, &new_stmt_list,\n-\t\t\t\t\t      offset, loop);\n+\t\t\t\t\t      offset);\n       if (new_stmt_list != NULL)\n \tgimple_seq_add_seq (cond_expr_stmt_list, new_stmt_list);\n "}, {"sha": "17d10835038f31b9bef8fafd98074789baaa1554", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=3f5e8a7690d91daba3d8988318895fe51b7749ec", "patch": "@@ -3789,14 +3789,8 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n       STMT_VINFO_DATA_REF (pattern_stmt_info)\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n-      STMT_VINFO_DR_BASE_ADDRESS (pattern_stmt_info)\n-\t= STMT_VINFO_DR_BASE_ADDRESS (stmt_vinfo);\n-      STMT_VINFO_DR_INIT (pattern_stmt_info) = STMT_VINFO_DR_INIT (stmt_vinfo);\n-      STMT_VINFO_DR_OFFSET (pattern_stmt_info)\n-\t= STMT_VINFO_DR_OFFSET (stmt_vinfo);\n-      STMT_VINFO_DR_STEP (pattern_stmt_info) = STMT_VINFO_DR_STEP (stmt_vinfo);\n-      STMT_VINFO_DR_ALIGNED_TO (pattern_stmt_info)\n-\t= STMT_VINFO_DR_ALIGNED_TO (stmt_vinfo);\n+      STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n+\t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n       DR_STMT (STMT_VINFO_DATA_REF (stmt_vinfo)) = pattern_stmt;\n       *type_out = vectype;\n       *type_in = vectype;\n@@ -3930,14 +3924,8 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n       STMT_VINFO_DATA_REF (pattern_stmt_info)\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n-      STMT_VINFO_DR_BASE_ADDRESS (pattern_stmt_info)\n-\t= STMT_VINFO_DR_BASE_ADDRESS (stmt_vinfo);\n-      STMT_VINFO_DR_INIT (pattern_stmt_info) = STMT_VINFO_DR_INIT (stmt_vinfo);\n-      STMT_VINFO_DR_OFFSET (pattern_stmt_info)\n-\t= STMT_VINFO_DR_OFFSET (stmt_vinfo);\n-      STMT_VINFO_DR_STEP (pattern_stmt_info) = STMT_VINFO_DR_STEP (stmt_vinfo);\n-      STMT_VINFO_DR_ALIGNED_TO (pattern_stmt_info)\n-\t= STMT_VINFO_DR_ALIGNED_TO (stmt_vinfo);\n+      STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n+\t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n       DR_STMT (STMT_VINFO_DATA_REF (stmt_vinfo)) = pattern_stmt;\n \n       *type_out = vectype1;"}, {"sha": "1067421d57593751de49ee52a9f8962595005925", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=3f5e8a7690d91daba3d8988318895fe51b7749ec", "patch": "@@ -1692,13 +1692,9 @@ static int\n compare_step_with_zero (gimple *stmt)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  tree step;\n-  if (loop_vinfo && nested_in_vect_loop_p (LOOP_VINFO_LOOP (loop_vinfo), stmt))\n-    step = STMT_VINFO_DR_STEP (stmt_info);\n-  else\n-    step = DR_STEP (STMT_VINFO_DATA_REF (stmt_info));\n-  return tree_int_cst_compare (step, size_zero_node);\n+  data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  return tree_int_cst_compare (vect_dr_behavior (dr)->step,\n+\t\t\t       size_zero_node);\n }\n \n /* If the target supports a permute mask that reverses the elements in\n@@ -8845,12 +8841,6 @@ new_stmt_vec_info (gimple *stmt, vec_info *vinfo)\n   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n   STMT_VINFO_VEC_CONST_COND_REDUC_CODE (res) = ERROR_MARK;\n \n-  STMT_VINFO_DR_BASE_ADDRESS (res) = NULL;\n-  STMT_VINFO_DR_OFFSET (res) = NULL;\n-  STMT_VINFO_DR_INIT (res) = NULL;\n-  STMT_VINFO_DR_STEP (res) = NULL;\n-  STMT_VINFO_DR_ALIGNED_TO (res) = NULL;\n-\n   if (gimple_code (stmt) == GIMPLE_PHI\n       && is_loop_header_bb_p (gimple_bb (stmt)))\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;"}, {"sha": "4a1e302fe36230ca7579acf3a89c1cfcda437306", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5e8a7690d91daba3d8988318895fe51b7749ec/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=3f5e8a7690d91daba3d8988318895fe51b7749ec", "patch": "@@ -554,11 +554,7 @@ typedef struct _stmt_vec_info {\n \n   /* Information about the data-ref relative to this loop\n      nest (the loop that is being considered for vectorization).  */\n-  tree dr_base_address;\n-  tree dr_init;\n-  tree dr_offset;\n-  tree dr_step;\n-  tree dr_aligned_to;\n+  innermost_loop_behavior dr_wrt_vec_loop;\n \n   /* For loop PHI nodes, the base and evolution part of it.  This makes sure\n      this information is still available in vect_update_ivs_after_vectorizer\n@@ -708,11 +704,12 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_VEC_REDUCTION_TYPE(S)   (S)->v_reduc_type\n #define STMT_VINFO_VEC_CONST_COND_REDUC_CODE(S) (S)->const_cond_reduc_code\n \n-#define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address\n-#define STMT_VINFO_DR_INIT(S)              (S)->dr_init\n-#define STMT_VINFO_DR_OFFSET(S)            (S)->dr_offset\n-#define STMT_VINFO_DR_STEP(S)              (S)->dr_step\n-#define STMT_VINFO_DR_ALIGNED_TO(S)        (S)->dr_aligned_to\n+#define STMT_VINFO_DR_WRT_VEC_LOOP(S)      (S)->dr_wrt_vec_loop\n+#define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_wrt_vec_loop.base_address\n+#define STMT_VINFO_DR_INIT(S)              (S)->dr_wrt_vec_loop.init\n+#define STMT_VINFO_DR_OFFSET(S)            (S)->dr_wrt_vec_loop.offset\n+#define STMT_VINFO_DR_STEP(S)              (S)->dr_wrt_vec_loop.step\n+#define STMT_VINFO_DR_ALIGNED_TO(S)        (S)->dr_wrt_vec_loop.aligned_to\n \n #define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n@@ -1014,6 +1011,22 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n   return (DR_MISALIGNMENT (data_ref_info) != DR_MISALIGNMENT_UNKNOWN);\n }\n \n+/* Return the behavior of DR with respect to the vectorization context\n+   (which for outer loop vectorization might not be the behavior recorded\n+   in DR itself).  */\n+\n+static inline innermost_loop_behavior *\n+vect_dr_behavior (data_reference *dr)\n+{\n+  gimple *stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  if (loop_vinfo == NULL\n+      || !nested_in_vect_loop_p (LOOP_VINFO_LOOP (loop_vinfo), stmt))\n+    return &DR_INNERMOST (dr);\n+  else\n+    return &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info);\n+}\n \n /* Return true if the vect cost model is unlimited.  */\n static inline bool\n@@ -1144,8 +1157,7 @@ extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n extern tree vect_get_new_ssa_name (tree, enum vect_var_kind,\n \t\t\t\t   const char * = NULL);\n extern tree vect_create_addr_base_for_vector_ref (gimple *, gimple_seq *,\n-\t\t\t\t\t\t  tree, struct loop *,\n-\t\t\t\t\t\t  tree = NULL_TREE);\n+\t\t\t\t\t\t  tree, tree = NULL_TREE);\n \n /* In tree-vect-loop.c.  */\n /* FORNOW: Used in tree-parloops.c.  */"}]}