{"sha": "82e31c8973eb1a752c2ffd01005efe291d35cee3", "node_id": "C_kwDOANBUbNoAKDgyZTMxYzg5NzNlYjFhNzUyYzJmZmQwMTAwNWVmZTI5MWQzNWNlZTM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-02-03T23:54:23Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-02-03T23:54:23Z"}, "message": "c++: dependence of member noexcept-spec [PR104079]\n\nHere a stale TYPE_DEPENDENT_P/_P_VALID value for f's function type\nafter replacing the type's DEFERRED_NOEXCEPT with the parsed dependent\nnoexcept-spec causes us to try to instantiate g's noexcept-spec ahead\nof time (since it in turn appears non-dependent), leading to an ICE.\n\nThis patch fixes this by clearing TYPE_DEPENDENT_P_VALID in\nfixup_deferred_exception_variants appropriately (as in\nbuild_cp_fntype_variant).\n\nThat turns out to fix the testcase for C++17 but not for C++11/14,\nbecause it's not until C++17 that a noexcept-spec is part of (and\ntherefore affects dependence of) the function type.  Since dependence of\nNOEXCEPT_EXPR is defined in terms of instantiation dependence, the most\nappropriate fix for earlier dialects seems to be to make instantiation\ndependence consider dependence of a noexcept-spec.\n\n\tPR c++/104079\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (value_dependent_noexcept_spec_p): New predicate split\n\tout from ...\n\t(dependent_type_p_r): ... here.\n\t(instantiation_dependent_r): Use value_dependent_noexcept_spec_p\n\tto consider dependence of a noexcept-spec before C++17.\n\t* tree.cc (fixup_deferred_exception_variants): Clear\n\tTYPE_DEPENDENT_P_VALID.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/noexcept74.C: New test.\n\t* g++.dg/cpp0x/noexcept74a.C: New test.", "tree": {"sha": "f7539fe6e73b907c3edab5be373b8424bb597d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7539fe6e73b907c3edab5be373b8424bb597d1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82e31c8973eb1a752c2ffd01005efe291d35cee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e31c8973eb1a752c2ffd01005efe291d35cee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82e31c8973eb1a752c2ffd01005efe291d35cee3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e31c8973eb1a752c2ffd01005efe291d35cee3/comments", "author": null, "committer": null, "parents": [{"sha": "3ef328c293a336df0aead2d72c0c5ed9781a9861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef328c293a336df0aead2d72c0c5ed9781a9861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef328c293a336df0aead2d72c0c5ed9781a9861"}], "stats": {"total": 69, "additions": 59, "deletions": 10}, "files": [{"sha": "60641d89c193407473cd00240e8382c87e58ae8e", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=82e31c8973eb1a752c2ffd01005efe291d35cee3", "patch": "@@ -27003,6 +27003,24 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n   return true;\n }\n \n+/* Returns true iff the noexcept-specifier for TYPE is value-dependent.  */\n+\n+static bool\n+value_dependent_noexcept_spec_p (tree type)\n+{\n+  if (tree spec = TYPE_RAISES_EXCEPTIONS (type))\n+    if (tree noex = TREE_PURPOSE (spec))\n+      /* Treat DEFERRED_NOEXCEPT as non-dependent, since it doesn't\n+\t affect overload resolution and treating it as dependent breaks\n+\t things.  Same for an unparsed noexcept expression.  */\n+      if (TREE_CODE (noex) != DEFERRED_NOEXCEPT\n+\t  && TREE_CODE (noex) != DEFERRED_PARSE\n+\t  && value_dependent_expression_p (noex))\n+\treturn true;\n+\n+  return false;\n+}\n+\n /* Returns TRUE if TYPE is dependent, in the sense of [temp.dep.type].\n    Assumes that TYPE really is a type, and not the ERROR_MARK_NODE.*/\n \n@@ -27055,17 +27073,10 @@ dependent_type_p_r (tree type)\n \t   arg_type = TREE_CHAIN (arg_type))\n \tif (dependent_type_p (TREE_VALUE (arg_type)))\n \t  return true;\n-      if (cxx_dialect >= cxx17)\n+      if (cxx_dialect >= cxx17\n+\t  && value_dependent_noexcept_spec_p (type))\n \t/* A value-dependent noexcept-specifier makes the type dependent.  */\n-\tif (tree spec = TYPE_RAISES_EXCEPTIONS (type))\n-\t  if (tree noex = TREE_PURPOSE (spec))\n-\t    /* Treat DEFERRED_NOEXCEPT as non-dependent, since it doesn't\n-\t       affect overload resolution and treating it as dependent breaks\n-\t       things.  Same for an unparsed noexcept expression.  */\n-\t    if (TREE_CODE (noex) != DEFERRED_NOEXCEPT\n-\t\t&& TREE_CODE (noex) != DEFERRED_PARSE\n-\t\t&& value_dependent_expression_p (noex))\n-\t      return true;\n+\treturn true;\n       return false;\n     }\n   /* -- an array type constructed from any dependent type or whose\n@@ -27874,6 +27885,17 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n \treturn *tp;\n       break;\n \n+    case TEMPLATE_DECL:\n+    case FUNCTION_DECL:\n+      /* Before C++17, a noexcept-specifier isn't part of the function type\n+\t so it doesn't affect type dependence, but we still want to consider it\n+\t for instantiation dependence.  */\n+      if (cxx_dialect < cxx17\n+\t  && DECL_DECLARES_FUNCTION_P (*tp)\n+\t  && value_dependent_noexcept_spec_p (TREE_TYPE (*tp)))\n+\treturn *tp;\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "2d8f2c551c0d0da4f5560b9ac3e3e2c8f882756b", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=82e31c8973eb1a752c2ffd01005efe291d35cee3", "patch": "@@ -2839,6 +2839,10 @@ fixup_deferred_exception_variants (tree type, tree raises)\n \t  }\n \telse\n \t  TYPE_RAISES_EXCEPTIONS (variant) = raises;\n+\n+\tif (!TYPE_DEPENDENT_P (variant))\n+\t  /* We no longer know that it's not type-dependent.  */\n+\t  TYPE_DEPENDENT_P_VALID (variant) = false;\n       }\n }\n "}, {"sha": "c439c9dc88ca5c08b641aa9cb274f491e7a15d01", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept74.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept74.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept74.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept74.C?ref=82e31c8973eb1a752c2ffd01005efe291d35cee3", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/104079\n+// { dg-do compile { target c++11 } }\n+\n+template<bool B>\n+struct AT {\n+  static void f() noexcept(B);\n+\n+  void g() noexcept(noexcept(f())) {\n+    static_assert(noexcept(f()), \"\");\n+  }\n+};"}, {"sha": "008654d44eafb7e3d3edbf7da5f655057aa9a286", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept74a.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept74a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e31c8973eb1a752c2ffd01005efe291d35cee3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept74a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept74a.C?ref=82e31c8973eb1a752c2ffd01005efe291d35cee3", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/104079\n+// { dg-do compile { target c++11 } }\n+// A variant of noexcept74.C where f is a function template.\n+\n+template<bool B>\n+struct AT {\n+  template<class...> static void f() noexcept(B);\n+\n+  void g() noexcept(noexcept(f())) {\n+    static_assert(noexcept(f()), \"\");\n+  }\n+};"}]}