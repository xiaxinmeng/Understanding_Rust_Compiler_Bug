{"sha": "2282d28d488248a113c9f172f8f0f0bca73419c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI4MmQyOGQ0ODgyNDhhMTEzYzlmMTcyZjhmMGYwYmNhNzM0MTljNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-02T20:01:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-02T20:01:38Z"}, "message": "re PR c++/7188 (Segfault with template class and recursive (incorrect) initalizer list.)\n\n\tPR c++/7188.\n\t* cp-tree.def (CTOR_INITIALIZER): Use one slot, not two.\n\t* cp-tree.h (emit_base_init): Rename to ....\n\t(emit_mem_initializers): ... this.\n\t(expand_member_init): Change prototype.\n\t* init.c (perform_member_init): Compute explicit, rather than\n\trequiring it as a parameter.\n\t(sort_member_init): Rename to ...\n\t(sort_mem_initializers): ... this.  Process bases and data members\n\ttogether.\n\t(sort_base_init): Remove.\n\t(emit_base_init): Rename to ...\n\t(emit_mem_initializers): ... this.\n\t(expand_aggr_vbase_init_1): Remove.\n\t(construct_virtual_bases): Rename to ...\n\t(construct_virtual_base): ... this.\n\t(expand_member_init): Rework handling of base initializers.\n\t* method.c (do_build_copy_constructor): Use\n\tfinish_mem_initializers.\n\t* parse.y (member_init): Adjust calls to expand_member_init.\n\t* pt.c (tsubst_expr): Simplify CTOR_INITIALIZER case.\n\t(tsubst_initializer_list): Use expand_member_init.\n\t* semantics.c (finish_mem_intiailizers): Simplify.\n\n\tPR c++/7188.\n\t* g++.dg/template/meminit1.C: New test.\n\t* g++.dg/warn/Wreorder-1.C: Likewise.\n\t* g++.old-deja/g++.mike/warn3.C: Tweak.\n\t* lib/prune.exp: Ingore \"in copy constructor\".\n\nFrom-SVN: r57748", "tree": {"sha": "245a8ba4ee36bea837735b3570838103f4f7e63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/245a8ba4ee36bea837735b3570838103f4f7e63f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2282d28d488248a113c9f172f8f0f0bca73419c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2282d28d488248a113c9f172f8f0f0bca73419c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2282d28d488248a113c9f172f8f0f0bca73419c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2282d28d488248a113c9f172f8f0f0bca73419c7/comments", "author": null, "committer": null, "parents": [{"sha": "854ef3909dcc16b363d5300d096823fa4c6afdc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/854ef3909dcc16b363d5300d096823fa4c6afdc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/854ef3909dcc16b363d5300d096823fa4c6afdc5"}], "stats": {"total": 866, "additions": 359, "deletions": 507}, "files": [{"sha": "7eb00b0e3350c2cd67ee4c329574ba3c10f17122", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -1,3 +1,29 @@\n+2002-10-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/7188.\n+\t* cp-tree.def (CTOR_INITIALIZER): Use one slot, not two.\n+\t* cp-tree.h (emit_base_init): Rename to ....\n+\t(emit_mem_initializers): ... this.\n+\t(expand_member_init): Change prototype.\n+\t* init.c (perform_member_init): Compute explicit, rather than\n+\trequiring it as a parameter.\n+\t(sort_member_init): Rename to ...\n+\t(sort_mem_initializers): ... this.  Process bases and data members\n+\ttogether.\n+\t(sort_base_init): Remove.\n+\t(emit_base_init): Rename to ...\n+\t(emit_mem_initializers): ... this.\n+\t(expand_aggr_vbase_init_1): Remove.\n+\t(construct_virtual_bases): Rename to ...\n+\t(construct_virtual_base): ... this.\n+\t(expand_member_init): Rework handling of base initializers.\n+\t* method.c (do_build_copy_constructor): Use\n+\tfinish_mem_initializers.\n+\t* parse.y (member_init): Adjust calls to expand_member_init.\n+\t* pt.c (tsubst_expr): Simplify CTOR_INITIALIZER case.\n+\t(tsubst_initializer_list): Use expand_member_init.\n+\t* semantics.c (finish_mem_intiailizers): Simplify.\n+\t\n 2002-10-02  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/6627"}, {"sha": "1aae797a4c23bfe8bfab4de439b1e733c216a073", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -251,7 +251,7 @@ DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", 'e', 3)\n \n /* CTOR_INITIALIZER is a placeholder in template code for a call to\n    setup_vtbl_pointer (and appears in all functions, not just ctors).  */\n-DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n+DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 1)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)\n DEFTREECODE (EH_SPEC_BLOCK, \"eh_spec_block\", 'e', 2)"}, {"sha": "5701a505f5d418100e6eb8369268cfc38f30b1a8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -3845,8 +3845,8 @@ extern void add_friend                          PARAMS ((tree, tree));\n extern tree do_friend\t\t\t\tPARAMS ((tree, tree, tree, tree, tree, enum overload_flags, tree, int));\n \n /* in init.c */\n-extern void emit_base_init\t\t\tPARAMS ((tree, tree));\n-extern tree expand_member_init\t\t\tPARAMS ((tree, tree, tree));\n+extern tree expand_member_init\t\t\t(tree, tree);\n+extern void emit_mem_initializers\t\t(tree);\n extern tree build_aggr_init\t\t\tPARAMS ((tree, tree, int));\n extern tree build_init\t\t\t\tPARAMS ((tree, tree, int));\n extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));"}, {"sha": "156822f40bfdf2872133441dd0e9b49239cce023", "filename": "gcc/cp/init.c", "status": "modified", "additions": 255, "deletions": 404, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -34,17 +34,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"ggc.h\"\n \n-static void expand_aggr_vbase_init_1 PARAMS ((tree, tree, tree, tree));\n-static void construct_virtual_bases PARAMS ((tree, tree, tree, tree, tree));\n+static void construct_virtual_base (tree, tree);\n static void expand_aggr_init_1 PARAMS ((tree, tree, tree, tree, int));\n static void expand_default_init PARAMS ((tree, tree, tree, tree, int));\n static tree build_vec_delete_1 PARAMS ((tree, tree, tree, special_function_kind, int));\n-static void perform_member_init PARAMS ((tree, tree, int));\n-static void sort_base_init PARAMS ((tree, tree, tree *, tree *));\n+static void perform_member_init (tree, tree);\n static tree build_builtin_delete_call PARAMS ((tree));\n static int member_init_ok_or_else PARAMS ((tree, tree, tree));\n static void expand_virtual_init PARAMS ((tree, tree));\n-static tree sort_member_init PARAMS ((tree, tree));\n+static tree sort_mem_initializers (tree, tree);\n static tree initializing_context PARAMS ((tree));\n static void expand_cleanup_for_base PARAMS ((tree, tree));\n static tree get_temp_regvar PARAMS ((tree, tree));\n@@ -303,16 +301,30 @@ build_default_init (type)\n   return build_zero_init (type, /*static_storage_p=*/false);\n }\n \n-/* Subroutine of emit_base_init.  */\n+/* Initialize MEMBER, a FIELD_DECL, with INIT, a TREE_LIST of\n+   arguments.  If TREE_LIST is void_type_node, an empty initializer\n+   list was given; if NULL_TREE no initializer was given.  */\n \n static void\n-perform_member_init (member, init, explicit)\n-     tree member, init;\n-     int explicit;\n+perform_member_init (tree member, tree init)\n {\n   tree decl;\n   tree type = TREE_TYPE (member);\n+  bool explicit;\n \n+  explicit = (init != NULL_TREE);\n+\n+  /* Effective C++ rule 12 requires that all data members be\n+     initialized.  */\n+  if (warn_ecpp && !explicit && TREE_CODE (type) != ARRAY_TYPE)\n+    warning (\"`%D' should be initialized in the member initialization \"\n+\t     \"list\", \n+\t     member);\n+\n+  if (init == void_type_node)\n+    init = NULL_TREE;\n+\n+  /* Get an lvalue for the data member.  */\n   decl = build_class_member_access_expr (current_class_ref, member,\n \t\t\t\t\t /*access_path=*/NULL_TREE,\n \t\t\t\t\t /*preserve_reference=*/true);\n@@ -333,11 +345,6 @@ perform_member_init (member, init, explicit)\n   else if (TYPE_NEEDS_CONSTRUCTING (type)\n \t   || (init && TYPE_HAS_CONSTRUCTOR (type)))\n     {\n-      /* Since `init' is already a TREE_LIST on the member_init_list,\n-\t only build it into one if we aren't already a list.  */\n-      if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n-\tinit = build_tree_list (NULL_TREE, init);\n-\n       if (explicit\n \t  && TREE_CODE (type) == ARRAY_TYPE\n \t  && init != NULL_TREE\n@@ -443,79 +450,107 @@ build_field_list (t, list, uses_unions_p)\n   return list;\n }\n \n-/* The MEMBER_INIT_LIST is a TREE_LIST.  The TREE_PURPOSE of each list\n-   gives a FIELD_DECL in T that needs initialization.  The TREE_VALUE\n-   gives the initializer, or list of initializer arguments.  Sort the\n-   MEMBER_INIT_LIST, returning a version that contains the same\n-   information but in the order that the fields should actually be\n-   initialized.  Perform error-checking in the process.  */\n+/* The MEM_INITS are a TREE_LIST.  The TREE_PURPOSE of each list gives\n+   a FIELD_DECL or BINFO in T that needs initialization.  The\n+   TREE_VALUE gives the initializer, or list of initializer arguments.\n+\n+   Return a TREE_LIST containing all of the initializations required\n+   for T, in the order in which they should be performed.  The output\n+   list has the same format as the input.  */\n \n static tree\n-sort_member_init (t, member_init_list)\n-     tree t;\n-     tree member_init_list;\n+sort_mem_initializers (tree t, tree mem_inits)\n {\n-  tree init_list;\n-  tree last_field;\n   tree init;\n+  tree base;\n+  tree sorted_inits;\n+  tree next_subobject;\n+  int i;\n   int uses_unions_p;\n \n-  /* Build up a list of the various fields, in sorted order.  */\n-  init_list = nreverse (build_field_list (t, NULL_TREE, &uses_unions_p));\n-\n-  /* Go through the explicit initializers, adding them to the\n-     INIT_LIST.  */\n-  last_field = init_list;\n-  for (init = member_init_list; init; init = TREE_CHAIN (init))\n-    {\n-      tree f;\n-      tree initialized_field;\n-\n-      initialized_field = TREE_PURPOSE (init);\n-      my_friendly_assert (TREE_CODE (initialized_field) == FIELD_DECL,\n-\t\t\t  20000516);\n-\n-      /* If the explicit initializers are in sorted order, then the\n-\t INITIALIZED_FIELD will be for a field following the\n-\t LAST_FIELD.  */\n-      for (f = last_field; f; f = TREE_CHAIN (f))\n-\tif (TREE_PURPOSE (f) == initialized_field)\n+  /* Build up a list of initializations.  The TREE_PURPOSE of entry\n+     will be the subobject (a FIELD_DECL or BINFO) to initialize.  The\n+     TREE_VALUE will be the constructor arguments, or NULL if no\n+     explicit initialization was provided.  */\n+  sorted_inits = NULL_TREE;\n+  /* Process the virtual bases.  */\n+  for (base = CLASSTYPE_VBASECLASSES (t); base; base = TREE_CHAIN (base))\n+    sorted_inits = tree_cons (TREE_VALUE (base), NULL_TREE, sorted_inits);\n+  /* Process the direct bases.  */\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+    {\n+      base = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+      if (!TREE_VIA_VIRTUAL (base))\n+\tsorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n+    }\n+  /* Process the non-static data members.  */\n+  sorted_inits = build_field_list (t, sorted_inits, &uses_unions_p);\n+  /* Reverse the entire list of initializations, so that they are in\n+     the order that they will actually be performed.  */\n+  sorted_inits = nreverse (sorted_inits);\n+\n+  /* If the user presented the initializers in an order different from\n+     that in which they will actually occur, we issue a warning.  Keep\n+     track of the next subobject which can be explicitly initialized\n+     without issuing a warning.  */\n+  next_subobject = sorted_inits;\n+\n+  /* Go through the explicit initializers, filling in TREE_PURPOSE in\n+     the SORTED_INITS.  */\n+  for (init = mem_inits; init; init = TREE_CHAIN (init))\n+    {\n+      tree subobject;\n+      tree subobject_init;\n+\n+      subobject = TREE_PURPOSE (init);\n+\n+      /* If the explicit initializers are in sorted order, then\n+\t SUBOBJECT will be NEXT_SUBOBJECT, or something following \n+\t it.  */\n+      for (subobject_init = next_subobject; \n+\t   subobject_init; \n+\t   subobject_init = TREE_CHAIN (subobject_init))\n+\tif (TREE_PURPOSE (subobject_init) == subobject)\n \t  break;\n \n-      /* Give a warning, if appropriate.  */\n-      if (warn_reorder && !f)\n+      /* Issue a warning if the explicit initializer order does not\n+\t match that which will actually occur.  */\n+      if (warn_reorder && !subobject_init)\n \t{\n-\t  cp_warning_at (\"member initializers for `%#D'\", \n-\t\t\t TREE_PURPOSE (last_field));\n-\t  cp_warning_at (\"  and `%#D'\", initialized_field);\n-\t  warning (\"  will be re-ordered to match declaration order\");\n+\t  if (TREE_CODE (TREE_PURPOSE (next_subobject)) == FIELD_DECL)\n+\t    cp_warning_at (\"`%D' will be initialized after\",\n+\t\t\t   TREE_PURPOSE (next_subobject));\n+\t  else\n+\t    warning (\"base `%T' will be initialized after\",\n+\t\t     TREE_PURPOSE (next_subobject));\n+\t  if (TREE_CODE (subobject) == FIELD_DECL)\n+\t    cp_warning_at (\"  `%#D'\", subobject);\n+\t  else\n+\t    warning (\"  base `%T'\", subobject);\n \t}\n \n-      /* Look again, from the beginning of the list.  We must find the\n-\t field on this loop.  */\n-      if (!f)\n+      /* Look again, from the beginning of the list.  */\n+      if (!subobject_init)\n \t{\n-\t  f = init_list;\n-\t  while (TREE_PURPOSE (f) != initialized_field)\n-\t    f = TREE_CHAIN (f);\n+\t  subobject_init = sorted_inits;\n+\t  while (TREE_PURPOSE (subobject_init) != subobject)\n+\t    subobject_init = TREE_CHAIN (subobject_init);\n \t}\n-\n-      /* If there was already an explicit initializer for this field,\n-\t issue an error.  */\n-      if (TREE_TYPE (f))\n-\terror (\"multiple initializations given for member `%D'\",\n-\t\t  initialized_field);\n-      else\n+\t\n+      /* It is invalid to initialize the same subobject more than\n+\t once.  */\n+      if (TREE_VALUE (subobject_init))\n \t{\n-\t  /* Mark the field as explicitly initialized.  */\n-\t  TREE_TYPE (f) = error_mark_node;\n-\t  /* And insert the initializer.  */\n-\t  TREE_VALUE (f) = TREE_VALUE (init);\n+\t  if (TREE_CODE (subobject) == FIELD_DECL)\n+\t    error (\"multiple initializations given for `%D'\", subobject);\n+\t  else\n+\t    error (\"multiple initializations given for base `%T'\", \n+\t\t   subobject);\n \t}\n \n-      /* Remember the location of the last explicitly initialized\n-\t field.  */\n-      last_field = f;\n+      /* Record the initialization.  */\n+      TREE_VALUE (subobject_init) = TREE_VALUE (init);\n+      next_subobject = subobject_init;\n     }\n \n   /* [class.base.init]\n@@ -525,15 +560,16 @@ sort_member_init (t, member_init_list)\n      anonymous unions), the ctor-initializer is ill-formed.  */\n   if (uses_unions_p)\n     {\n-      last_field = NULL_TREE;\n-      for (init = init_list; init; init = TREE_CHAIN (init))\n+      tree last_field = NULL_TREE;\n+      for (init = sorted_inits; init; init = TREE_CHAIN (init))\n \t{\n \t  tree field;\n \t  tree field_type;\n \t  int done;\n \n-\t  /* Skip uninitialized members.  */\n-\t  if (!TREE_TYPE (init))\n+\t  /* Skip uninitialized members and base classes.  */\n+\t  if (!TREE_VALUE (init) \n+\t      || TREE_CODE (TREE_PURPOSE (init)) != FIELD_DECL)\n \t    continue;\n \t  /* See if this field is a member of a union, or a member of a\n \t     structure contained in a union, etc.  */\n@@ -600,231 +636,73 @@ sort_member_init (t, member_init_list)\n \t}\n     }\n \n-  return init_list;\n+  return sorted_inits;\n }\n \n-/* Like sort_member_init, but used for initializers of base classes.\n-   *RBASE_PTR is filled in with the initializers for non-virtual bases;\n-   vbase_ptr gets the virtual bases.  */\n-\n-static void\n-sort_base_init (t, base_init_list, rbase_ptr, vbase_ptr)\n-     tree t;\n-     tree base_init_list;\n-     tree *rbase_ptr, *vbase_ptr;\n-{\n-  tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n-  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  int i;\n-  tree x;\n-  tree last;\n-\n-  /* For warn_reorder.  */\n-  int last_pos = 0;\n-  tree last_base = NULL_TREE;\n-\n-  tree rbases = NULL_TREE;\n-  tree vbases = NULL_TREE;\n-\n-  /* First walk through and splice out vbase and invalid initializers.\n-     Also replace types with binfos.  */\n-\n-  last = tree_cons (NULL_TREE, NULL_TREE, base_init_list);\n-  for (x = TREE_CHAIN (last); x; x = TREE_CHAIN (x))\n-    {\n-      tree basetype = TREE_PURPOSE (x);\n-      tree binfo = (TREE_CODE (basetype) == TREE_VEC\n-\t\t    ? basetype : binfo_or_else (basetype, t));\n-      \n-      if (binfo == NULL_TREE)\n-\t/* BASETYPE might be an inaccessible direct base (because it\n-\t   is also an indirect base).  */\n-\tcontinue;\n-\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\t{\n-\t  /* Virtual base classes are special cases.  Their\n-\t     initializers are recorded with this constructor, and they\n-\t     are used when this constructor is the top-level\n-\t     constructor called.  */\n-\t  tree v = binfo_for_vbase (BINFO_TYPE (binfo), t);\n-\t  vbases = tree_cons (v, TREE_VALUE (x), vbases);\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, it must be an immediate base class.  */\n-\t  my_friendly_assert\n-\t    (same_type_p (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo)),\n-\t\t\t  t), 20011113);\n-\n-\t  TREE_PURPOSE (x) = binfo;\n-\t  TREE_CHAIN (last) = x;\n-\t  last = x;\n-\t}\n-    }\n-  TREE_CHAIN (last) = NULL_TREE;\n-\n-  /* Now walk through our regular bases and make sure they're initialized.  */\n-\n-  for (i = 0; i < n_baseclasses; ++i)\n-    {\n-      /* The base for which we're currently initializing.  */\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      /* The initializer for BASE_BINFO.  */\n-      tree init;\n-      int pos;\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tcontinue;\n-\n-      /* We haven't found the BASE_BINFO yet.  */\n-      init = NULL_TREE;\n-      /* Loop through all the explicitly initialized bases, looking\n-\t for an appropriate initializer.  */\n-      for (x = base_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n-\t{\n-\t  tree binfo = TREE_PURPOSE (x);\n-\n-\t  if (binfo == base_binfo && !init)\n-\t    {\n-\t      if (warn_reorder)\n-\t\t{\n-\t\t  if (pos < last_pos)\n-\t\t    {\n-\t\t      cp_warning_at (\"base initializers for `%#T'\", last_base);\n-\t\t      cp_warning_at (\"  and `%#T'\", BINFO_TYPE (binfo));\n-\t\t      warning (\"  will be re-ordered to match inheritance order\");\n-\t\t    }\n-\t\t  last_pos = pos;\n-\t\t  last_base = BINFO_TYPE (binfo);\n-\t\t}\n-\n-\t      /* Make sure we won't try to work on this init again.  */\n-\t      TREE_PURPOSE (x) = NULL_TREE;\n-\t      init = build_tree_list (binfo, TREE_VALUE (x));\n-\t    }\n-\t  else if (binfo == base_binfo)\n-\t    {\n-\t      error (\"base class `%T' already initialized\", \n-\t\t\tBINFO_TYPE (binfo));\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* If we didn't find BASE_BINFO in the list, create a dummy entry\n-\t so the two lists (RBASES and the list of bases) will be\n-\t symmetrical.  */\n-      if (!init)\n-\tinit = build_tree_list (NULL_TREE, NULL_TREE);\n-      rbases = chainon (rbases, init);\n-    }\n-\n-  *rbase_ptr = rbases;\n-  *vbase_ptr = vbases;\n-}\n-\n-/* Perform whatever initializations have yet to be done on the base\n-   class, and non-static data members, of the CURRENT_CLASS_TYPE.\n-   These actions are given by the BASE_INIT_LIST and MEM_INIT_LIST,\n-   respectively.\n-\n-   If there is a need for a call to a constructor, we must surround\n-   that call with a pushlevel/poplevel pair, since we are technically\n-   at the PARM level of scope.  */\n+/* Initialize all bases and members of CURRENT_CLASS_TYPE.  MEM_INITS\n+   is a TREE_LIST giving the explicit mem-initializer-list for the\n+   constructor.  The TREE_PURPOSE of each entry is a subobject (a\n+   FIELD_DECL or a BINFO) of the CURRENT_CLASS_TYPE.  The TREE_VALUE\n+   is a TREE_LIST giving the arguments to the constructor or\n+   void_type_node for an empty list of arguments.  */\n \n void\n-emit_base_init (mem_init_list, base_init_list)\n-     tree mem_init_list;\n-     tree base_init_list;\n+emit_mem_initializers (tree mem_inits)\n {\n-  tree member;\n-  tree rbase_init_list, vbase_init_list;\n-  tree t = current_class_type;\n-  tree t_binfo = TYPE_BINFO (t);\n-  tree binfos = BINFO_BASETYPES (t_binfo);\n-  int i;\n-  int n_baseclasses = BINFO_N_BASETYPES (t_binfo);\n-\n-  mem_init_list = sort_member_init (t, mem_init_list);\n-  sort_base_init (t, base_init_list, &rbase_init_list, &vbase_init_list);\n-\n-  /* First, initialize the virtual base classes, if we are\n-     constructing the most-derived object.  */\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    {\n-      tree first_arg = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n-      construct_virtual_bases (t, current_class_ref, current_class_ptr,\n-\t\t\t       vbase_init_list, first_arg);\n-    }\n-\n-  /* Now, perform initialization of non-virtual base classes.  */\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree init = void_list_node;\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tcontinue;\n-\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo,\n-\t\t\t  999);\n-\n-      if (TREE_PURPOSE (rbase_init_list))\n-\tinit = TREE_VALUE (rbase_init_list);\n-      else if (TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (base_binfo)))\n-\t{\n-\t  init = NULL_TREE;\n-\t  if (extra_warnings \n-\t      && DECL_COPY_CONSTRUCTOR_P (current_function_decl))\n-\t    warning (\"base class `%#T' should be explicitly initialized in the copy constructor\",\n-\t\t\tBINFO_TYPE (base_binfo));\n-\t}\n-\n-      if (init != void_list_node)\n+  /* Sort the mem-initializers into the order in which the\n+     initializations should be performed.  */\n+  mem_inits = sort_mem_initializers (current_class_type, mem_inits);\n+\n+  /* Initialize base classes.  */\n+  while (mem_inits \n+\t && TREE_CODE (TREE_PURPOSE (mem_inits)) != FIELD_DECL)\n+    {\n+      tree subobject = TREE_PURPOSE (mem_inits);\n+      tree arguments = TREE_VALUE (mem_inits);\n+\n+      /* If these initializations are taking place in a copy\n+\t constructor, the base class should probably be explicitly\n+\t initialized.  */\n+      if (extra_warnings && !arguments \n+\t  && DECL_COPY_CONSTRUCTOR_P (current_function_decl)\n+\t  && TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (subobject)))\n+\twarning (\"base class `%#T' should be explicitly initialized in the \"\n+\t\t \"copy constructor\",\n+\t\t BINFO_TYPE (subobject));\n+\n+      /* If an explicit -- but empty -- initializer list was present,\n+\t treat it just like default initialization at this point.  */\n+      if (arguments == void_type_node)\n+\targuments = NULL_TREE;\n+\n+      /* Initialize the base.  */\n+      if (TREE_VIA_VIRTUAL (subobject))\n+\tconstruct_virtual_base (subobject, arguments);\n+      else\n \t{\n-\t  member = build_base_path (PLUS_EXPR, current_class_ptr,\n-\t\t\t\t    base_binfo, 1);\n-\t  expand_aggr_init_1 (base_binfo, NULL_TREE,\n-\t\t\t      build_indirect_ref (member, NULL), init,\n+\t  tree base_addr;\n+\t  \n+\t  base_addr = build_base_path (PLUS_EXPR, current_class_ptr,\n+\t\t\t\t       subobject, 1);\n+\t  expand_aggr_init_1 (subobject, NULL_TREE,\n+\t\t\t      build_indirect_ref (base_addr, NULL), \n+\t\t\t      arguments,\n \t\t\t      LOOKUP_NORMAL);\n+\t  expand_cleanup_for_base (subobject, NULL_TREE);\n \t}\n \n-      expand_cleanup_for_base (base_binfo, NULL_TREE);\n-      rbase_init_list = TREE_CHAIN (rbase_init_list);\n+      mem_inits = TREE_CHAIN (mem_inits);\n     }\n \n-  /* Initialize the vtable pointers for the class.  */\n+  /* Initialize the vptrs.  */\n   initialize_vtbl_ptrs (current_class_ptr);\n \n-  while (mem_init_list)\n+  /* Initialize the data members.  */\n+  while (mem_inits)\n     {\n-      tree init;\n-      tree member;\n-      int from_init_list;\n-\n-      member = TREE_PURPOSE (mem_init_list);\n-\n-      /* See if we had a user-specified member initialization.  */\n-      if (TREE_TYPE (mem_init_list))\n-\t{\n-\t  init = TREE_VALUE (mem_init_list);\n-\t  from_init_list = 1;\n-\t}\n-      else\n-\t{\n-\t  init = DECL_INITIAL (member);\n-\t  from_init_list = 0;\n-\n-\t  /* Effective C++ rule 12.  */\n-\t  if (warn_ecpp && init == NULL_TREE\n-\t      && !DECL_ARTIFICIAL (member)\n-\t      && TREE_CODE (TREE_TYPE (member)) != ARRAY_TYPE)\n-\t    warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n-\t}\n-\n-      perform_member_init (member, init, from_init_list);\n-      mem_init_list = TREE_CHAIN (mem_init_list);\n+      perform_member_init (TREE_PURPOSE (mem_inits),\n+\t\t\t   TREE_VALUE (mem_inits));\n+      mem_inits = TREE_CHAIN (mem_inits);\n     }\n }\n \n@@ -948,89 +826,57 @@ expand_cleanup_for_base (binfo, flag)\n   finish_eh_cleanup (expr);\n }\n \n-/* Subroutine of `expand_aggr_vbase_init'.\n-   BINFO is the binfo of the type that is being initialized.\n-   INIT_LIST is the list of initializers for the virtual baseclass.  */\n+/* Construct the virtual base-class VBASE passing the ARGUMENTS to its\n+   constructor.  */\n \n static void\n-expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n-     tree binfo, exp, addr, init_list;\n+construct_virtual_base (tree vbase, tree arguments)\n {\n-  tree init = purpose_member (binfo, init_list);\n-  tree ref = build_indirect_ref (addr, NULL);\n-\n-  if (init)\n-    init = TREE_VALUE (init);\n-  /* Call constructors, but don't set up vtables.  */\n-  expand_aggr_init_1 (binfo, exp, ref, init, LOOKUP_COMPLAIN);\n-}\n-\n-/* Construct the virtual base-classes of THIS_REF (whose address is\n-   THIS_PTR).  The object has the indicated TYPE.  The construction\n-   actually takes place only if FLAG is nonzero.  INIT_LIST is list\n-   of initializations for constructors to perform.  */\n-\n-static void\n-construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n-     tree type;\n-     tree this_ref;\n-     tree this_ptr;\n-     tree init_list;\n-     tree flag;\n-{\n-  tree vbases;\n-\n-  /* If there are no virtual baseclasses, we shouldn't even be here.  */\n-  my_friendly_assert (TYPE_USES_VIRTUAL_BASECLASSES (type), 19990621);\n-\n-  /* Now, run through the baseclasses, initializing each.  */ \n-  for (vbases = CLASSTYPE_VBASECLASSES (type); vbases;\n-       vbases = TREE_CHAIN (vbases))\n-    {\n-      tree inner_if_stmt;\n-      tree compound_stmt;\n-      tree exp;\n-      tree vbase;\n-\n-      /* If there are virtual base classes with destructors, we need to\n-\t emit cleanups to destroy them if an exception is thrown during\n-\t the construction process.  These exception regions (i.e., the\n-\t period during which the cleanups must occur) begin from the time\n-\t the construction is complete to the end of the function.  If we\n-\t create a conditional block in which to initialize the\n-\t base-classes, then the cleanup region for the virtual base begins\n-\t inside a block, and ends outside of that block.  This situation\n-\t confuses the sjlj exception-handling code.  Therefore, we do not\n-\t create a single conditional block, but one for each\n-\t initialization.  (That way the cleanup regions always begin\n-\t in the outer block.)  We trust the back-end to figure out\n-\t that the FLAG will not change across initializations, and\n-\t avoid doing multiple tests.  */\n-      inner_if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (flag, inner_if_stmt);\n-      compound_stmt = begin_compound_stmt (/*has_no_scope=*/1);\n-\n-      /* Compute the location of the virtual base.  If we're\n-\t constructing virtual bases, then we must be the most derived\n-\t class.  Therefore, we don't have to look up the virtual base;\n-\t we already know where it is.  */\n-      vbase = TREE_VALUE (vbases);\n-      exp = build (PLUS_EXPR,\n-\t\t   TREE_TYPE (this_ptr),\n-\t\t   this_ptr,\n-\t\t   fold (build1 (NOP_EXPR, TREE_TYPE (this_ptr),\n-\t\t\t\t BINFO_OFFSET (vbase))));\n-      exp = build1 (NOP_EXPR, \n-\t\t    build_pointer_type (BINFO_TYPE (vbase)), \n-\t\t    exp);\n-\n-      expand_aggr_vbase_init_1 (vbase, this_ref, exp, init_list);\n-      finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n-      finish_then_clause (inner_if_stmt);\n-      finish_if_stmt ();\n-      \n-      expand_cleanup_for_base (vbase, flag);\n-    }\n+  tree inner_if_stmt;\n+  tree compound_stmt;\n+  tree exp;\n+  tree flag;  \n+\n+  /* If there are virtual base classes with destructors, we need to\n+     emit cleanups to destroy them if an exception is thrown during\n+     the construction process.  These exception regions (i.e., the\n+     period during which the cleanups must occur) begin from the time\n+     the construction is complete to the end of the function.  If we\n+     create a conditional block in which to initialize the\n+     base-classes, then the cleanup region for the virtual base begins\n+     inside a block, and ends outside of that block.  This situation\n+     confuses the sjlj exception-handling code.  Therefore, we do not\n+     create a single conditional block, but one for each\n+     initialization.  (That way the cleanup regions always begin\n+     in the outer block.)  We trust the back-end to figure out\n+     that the FLAG will not change across initializations, and\n+     avoid doing multiple tests.  */\n+  flag = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n+  inner_if_stmt = begin_if_stmt ();\n+  finish_if_stmt_cond (flag, inner_if_stmt);\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/1);\n+\n+  /* Compute the location of the virtual base.  If we're\n+     constructing virtual bases, then we must be the most derived\n+     class.  Therefore, we don't have to look up the virtual base;\n+     we already know where it is.  */\n+  exp = build (PLUS_EXPR,\n+\t       TREE_TYPE (current_class_ptr),\n+\t       current_class_ptr,\n+\t       fold (build1 (NOP_EXPR, TREE_TYPE (current_class_ptr),\n+\t\t\t     BINFO_OFFSET (vbase))));\n+  exp = build1 (NOP_EXPR, \n+\t\tbuild_pointer_type (BINFO_TYPE (vbase)), \n+\t\texp);\n+  exp = build1 (INDIRECT_REF, BINFO_TYPE (vbase), exp);\n+\n+  expand_aggr_init_1 (vbase, current_class_ref, exp,\n+\t\t      arguments, LOOKUP_COMPLAIN);\n+  finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n+  finish_then_clause (inner_if_stmt);\n+  finish_if_stmt ();\n+\n+  expand_cleanup_for_base (vbase, flag);\n }\n \n /* Find the context in which this FIELD can be initialized.  */\n@@ -1079,46 +925,41 @@ member_init_ok_or_else (field, type, member_name)\n   return 1;\n }\n \n-/* EXP is an expression of aggregate type. NAME is an IDENTIFIER_NODE\n-   which names a field, or it is a _TYPE node or TYPE_DECL which names\n-   a base for that type.  INIT is a parameter list for that field's or\n-   base's constructor.  Check the validity of NAME, and return a\n-   TREE_LIST of the base _TYPE or FIELD_DECL and the INIT. EXP is used\n-   only to get its type.  If NAME is invalid, return NULL_TREE and\n-   issue a diagnostic.\n+/* NAME is a FIELD_DECL, an IDENTIFIER_NODE which names a field, or it\n+   is a _TYPE node or TYPE_DECL which names a base for that type.\n+   INIT is a parameter list for that field's or base's constructor.\n+   Check the validity of NAME, and return a TREE_LIST of the base\n+   _TYPE or FIELD_DECL and the INIT.  If NAME is invalid, return\n+   NULL_TREE and issue a diagnostic.\n \n    An old style unnamed direct single base construction is permitted,\n    where NAME is NULL.  */\n \n tree\n-expand_member_init (exp, name, init)\n-     tree exp, name, init;\n+expand_member_init (tree name, tree init)\n {\n-  tree basetype = NULL_TREE, field;\n-  tree type;\n+  tree basetype;\n+  tree field;\n \n-  if (exp == NULL_TREE)\n+  if (!current_class_ref)\n     return NULL_TREE;\n \n-  type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n-  my_friendly_assert (IS_AGGR_TYPE (type), 20011113);\n-\n   if (!name)\n     {\n       /* This is an obsolete unnamed base class initializer.  The\n \t parser will already have warned about its use.  */\n-      switch (CLASSTYPE_N_BASECLASSES (type))\n+      switch (CLASSTYPE_N_BASECLASSES (current_class_type))\n \t{\n \tcase 0:\n \t  error (\"unnamed initializer for `%T', which has no base classes\",\n-\t\t    type);\n+\t\t current_class_type);\n \t  return NULL_TREE;\n \tcase 1:\n-\t  basetype = TYPE_BINFO_BASETYPE (type, 0);\n+\t  basetype = TYPE_BINFO_BASETYPE (current_class_type, 0);\n \t  break;\n \tdefault:\n \t  error (\"unnamed initializer for `%T', which uses multiple inheritance\",\n-\t\t    type);\n+\t\t current_class_type);\n \t  return NULL_TREE;\n       }\n     }\n@@ -1129,44 +970,54 @@ expand_member_init (exp, name, init)\n     }\n   else if (TREE_CODE (name) == TYPE_DECL)\n     basetype = TYPE_MAIN_VARIANT (TREE_TYPE (name));\n+  else\n+    basetype = NULL_TREE;\n \n   my_friendly_assert (init != NULL_TREE, 0);\n \n-  if (init == void_type_node)\n-    init = NULL_TREE;\n-\n   if (basetype)\n     {\n+      tree binfo;\n+\n       if (current_template_parms)\n-\t;\n-      else if (vec_binfo_member (basetype, TYPE_BINFO_BASETYPES (type)))\n-\t/* A direct base.  */;\n-      else if (binfo_for_vbase (basetype, type))\n-\t/* A virtual base.  */;\n-      else\n+\treturn build_tree_list (basetype, init);\n+\n+      binfo = lookup_base (current_class_type, basetype, \n+\t\t\t   ba_ignore, NULL);\n+      if (binfo)\n+\t{\n+\t  if (TREE_VIA_VIRTUAL (binfo))\n+\t    binfo = binfo_for_vbase (basetype, current_class_type);\n+\t  else if (BINFO_INHERITANCE_CHAIN (binfo) \n+\t\t   != TYPE_BINFO (current_class_type))\n+\t    binfo = NULL_TREE;\n+\t}\n+      if (!binfo)\n \t{\n-\t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n+\t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n \t    error (\"type `%D' is not a direct or virtual base of `%T'\",\n-\t\t      name, type);\n+\t\t   name, current_class_type);\n \t  else\n \t    error (\"type `%D' is not a direct base of `%T'\",\n-\t\t      name, type);\n+\t\t   name, current_class_type);\n \t  return NULL_TREE;\n \t}\n \n-      init = build_tree_list (basetype, init);\n+      if (binfo)\n+\treturn build_tree_list (binfo, init);\n     }\n   else\n     {\n-      field = lookup_field (type, name, 1, 0);\n-\n-      if (! member_init_ok_or_else (field, type, name))\n-\treturn NULL_TREE;\n+      if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\tfield = lookup_field (current_class_type, name, 1, 0);\n+      else\n+\tfield = name;\n \n-      init = build_tree_list (field, init);\n+      if (member_init_ok_or_else (field, current_class_type, name))\n+\treturn build_tree_list (field, init);\n     }\n \n-  return init;\n+  return NULL_TREE;\n }\n \n /* This is like `expand_member_init', only it stores one aggregate"}, {"sha": "065818132e9d0fa61ada2b2e9fd1c9ca7694f97e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -536,7 +536,6 @@ do_build_copy_constructor (fndecl)\n       int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n       tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n       tree member_init_list = NULL_TREE;\n-      tree base_init_list = NULL_TREE;\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n \n@@ -550,10 +549,12 @@ do_build_copy_constructor (fndecl)\n \t{\n \t  tree binfo = TREE_VALUE (t);\n \t  \n-\t  base_init_list = tree_cons (binfo,\n-\t\t\t\t      build_base_path (PLUS_EXPR, parm,\n-\t\t\t\t\t\t       binfo, 1),\n-\t\t\t\t      base_init_list);\n+\t  member_init_list \n+\t    = tree_cons (binfo,\n+\t\t\t build_tree_list (NULL_TREE,\n+\t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n+\t\t\t\t\t\t\t   binfo, 1)),\n+\t\t\t member_init_list);\n \t}\n \n       for (i = 0; i < n_bases; ++i)\n@@ -562,10 +563,12 @@ do_build_copy_constructor (fndecl)\n \t  if (TREE_VIA_VIRTUAL (binfo))\n \t    continue; \n \n-\t  base_init_list = tree_cons (binfo,\n-\t\t\t\t      build_base_path (PLUS_EXPR, parm,\n-\t\t\t\t\t\t       binfo, 1),\n-\t\t\t\t      base_init_list);\n+\t  member_init_list \n+\t    = tree_cons (binfo,\n+\t\t\t build_tree_list (NULL_TREE,\n+\t\t\t\t\t  build_base_path (PLUS_EXPR, parm,\n+\t\t\t\t\t\t\t   binfo, 1)),\n+\t\t\t member_init_list);\n \t}\n \n       for (; fields; fields = TREE_CHAIN (fields))\n@@ -609,9 +612,7 @@ do_build_copy_constructor (fndecl)\n \t  member_init_list\n \t    = tree_cons (field, init, member_init_list);\n \t}\n-      member_init_list = nreverse (member_init_list);\n-      base_init_list = nreverse (base_init_list);\n-      emit_base_init (member_init_list, base_init_list);\n+      finish_mem_initializers (member_init_list);\n     }\n }\n "}, {"sha": "b404e6a2fdaa3a89301588fd9bc735adb8ba80fa", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -981,31 +981,27 @@ member_init:\n \t\t{\n \t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n-\t\t  $$ = expand_member_init (current_class_ref, NULL_TREE, $2);\n+\t\t  $$ = expand_member_init (NULL_TREE, $2);\n \t\t}\n \t| LEFT_RIGHT\n \t\t{\n \t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n-\t\t  $$ = expand_member_init (current_class_ref,\n-\t\t\t\t\t   NULL_TREE,\n+\t\t  $$ = expand_member_init (NULL_TREE,\n \t\t\t\t\t   void_type_node);\n \t\t}\n \t| notype_identifier '(' nonnull_exprlist ')'\n-\t\t{ $$ = expand_member_init (current_class_ref, $1, $3); }\n+\t\t{ $$ = expand_member_init ($1, $3); }\n \t| notype_identifier LEFT_RIGHT\n-\t\t{ $$ = expand_member_init (current_class_ref, $1,\n-\t\t\t\t\t   void_type_node); }\n+\t\t{ $$ = expand_member_init ($1, void_type_node); }\n \t| nonnested_type '(' nonnull_exprlist ')'\n-\t\t{ $$ = expand_member_init (current_class_ref, $1, $3); }\n+\t\t{ $$ = expand_member_init ($1, $3); }\n \t| nonnested_type LEFT_RIGHT\n-\t\t{ $$ = expand_member_init (current_class_ref, $1,\n-\t\t\t\t\t   void_type_node); }\n+\t\t{ $$ = expand_member_init ($1, void_type_node); }\n \t| typename_sub '(' nonnull_exprlist ')'\n-\t\t{ $$ = expand_member_init (current_class_ref, $1, $3); }\n+\t\t{ $$ = expand_member_init ($1, $3); }\n \t| typename_sub LEFT_RIGHT\n-\t\t{ $$ = expand_member_init (current_class_ref, $1,\n-\t\t\t\t\t   void_type_node); }\n+\t\t{ $$ = expand_member_init ($1, void_type_node); }\n         | error\n                 { $$ = NULL_TREE; }\n \t;"}, {"sha": "6d8ec065a9e517b2fcf6bcedaeb1b785cd76147e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -7369,18 +7369,10 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case CTOR_INITIALIZER:\n-      {\n-\ttree member_init_list;\n-\ttree base_init_list;\n-\n-\tprep_stmt (t);\n-\tmember_init_list\n-\t  = tsubst_initializer_list (TREE_OPERAND (t, 0), args);\n-\tbase_init_list\n-\t  = tsubst_initializer_list (TREE_OPERAND (t, 1), args);\n-\temit_base_init (member_init_list, base_init_list);\n-\tbreak;\n-      }\n+      prep_stmt (t);\n+      finish_mem_initializers (tsubst_initializer_list \n+\t\t\t       (TREE_OPERAND (t, 0), args));\n+      break;\n \n     case RETURN_STMT:\n       prep_stmt (t);\n@@ -10293,8 +10285,7 @@ static tree\n tsubst_initializer_list (t, argvec)\n      tree t, argvec;\n {\n-  tree first = NULL_TREE;\n-  tree *p = &first;\n+  tree inits = NULL_TREE;\n \n   for (; t; t = TREE_CHAIN (t))\n     {\n@@ -10312,13 +10303,17 @@ tsubst_initializer_list (t, argvec)\n       else if (TREE_CODE (init) == TREE_LIST)\n \tfor (val = init; val; val = TREE_CHAIN (val))\n \t  TREE_VALUE (val) = convert_from_reference (TREE_VALUE (val));\n-      else\n+      else if (init != void_type_node)\n \tinit = convert_from_reference (init);\n \n-      *p = build_tree_list (decl, init);\n-      p = &TREE_CHAIN (*p);\n+      init = expand_member_init (decl, init);\n+      if (init)\n+\t{\n+\t  TREE_CHAIN (init) = inits;\n+\t  inits = init;\n+\t}\n     }\n-  return first;\n+  return inits;\n }\n \n /* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */"}, {"sha": "27fa97a4332f31f2b1244831f8ba2e14083f0c29", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 55, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -1094,67 +1094,21 @@ begin_mem_initializers ()\n     error (\"only constructors take base initializers\");\n }\n \n-/* The INIT_LIST is a list of mem-initializers, in the order they were\n-   written by the user.  The TREE_VALUE of each node is a list of\n-   initializers for a particular subobject.  The TREE_PURPOSE is a\n-   FIELD_DECL is the initializer is for a non-static data member, and\n-   a class type if the initializer is for a base class.  */\n+/* The MEM_INITS is a list of mem-initializers, in reverse of the\n+   order they were written by the user.  Each node is as for\n+   emit_mem_initializers.  */\n \n void\n-finish_mem_initializers (init_list)\n-     tree init_list;\n+finish_mem_initializers (tree mem_inits)\n {\n-  tree member_init_list;\n-  tree base_init_list;\n-  tree last_base_warned_about;\n-  tree next; \n-  tree init;\n-\n-  member_init_list = NULL_TREE;\n-  base_init_list = NULL_TREE;\n-  last_base_warned_about = NULL_TREE;\n-\n-  for (init = init_list; init; init = next)\n-    {\n-      next = TREE_CHAIN (init);\n-      if (TREE_CODE (TREE_PURPOSE (init)) == FIELD_DECL)\n-\t{\n-\t  TREE_CHAIN (init) = member_init_list;\n-\t  member_init_list = init;\n-\n-\t  /* We're running through the initializers from right to left\n-\t     as we process them here.  So, if we see a data member\n-\t     initializer after we see a base initializer, that\n-\t     actually means that the base initializer preceded the\n-\t     data member initializer.  */\n-\t  if (warn_reorder && last_base_warned_about != base_init_list)\n-\t    {\n-\t      tree base;\n-\n-\t      for (base = base_init_list; \n-\t\t   base != last_base_warned_about; \n-\t\t   base = TREE_CHAIN (base))\n-\t\t{\n-\t\t  warning (\"base initializer for `%T'\",\n-\t\t\t      TREE_PURPOSE (base));\n-\t\t  warning (\"   will be re-ordered to precede member initializations\");\n-\t\t}\n-\n-\t      last_base_warned_about = base_init_list;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  TREE_CHAIN (init) = base_init_list;\n-\t  base_init_list = init;\n-\t}\n-    }\n+  /* Reorder the MEM_INITS so that they are in the order they appeared\n+     in the source program.  */\n+  mem_inits = nreverse (mem_inits);\n \n   if (processing_template_decl)\n-    add_stmt (build_min_nt (CTOR_INITIALIZER,\n-\t\t\t    member_init_list, base_init_list));\n+    add_stmt (build_min_nt (CTOR_INITIALIZER, mem_inits));\n   else\n-    emit_base_init (member_init_list, base_init_list);\n+    emit_mem_initializers (mem_inits);\n }\n \n /* Returns the stack of SCOPE_STMTs for the current function.  */"}, {"sha": "412533c7d300f20a1b477e20ddfe3d67c83fa813", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -1,3 +1,11 @@\n+2002-10-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/7188.\n+\t* g++.dg/template/meminit1.C: New test.\n+\t* g++.dg/warn/Wreorder-1.C: Likewise.\n+\t* g++.old-deja/g++.mike/warn3.C: Tweak.\n+\t* lib/prune.exp: Ingore \"in copy constructor\".\n+\n 2002-10-02  Andreas Jaeger  <aj@suse.de>\n \n \t* gcc.dg/20020919-1.c, gcc.dg/inline-2.c, gcc.dg/980211-1.c,"}, {"sha": "90b0d7d853943f193abc2431f3ce6bfeab3ba868", "filename": "gcc/testsuite/g++.dg/template/meminit1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmeminit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmeminit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmeminit1.C?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -0,0 +1,7 @@\n+template <class T >\n+struct S\n+{\n+  S() : S() {} // { dg-error \"base\" }\n+};\n+\n+S<int> s; // { dg-error \"instantiated\" }"}, {"sha": "bd8113a2a47c0afeaae770756bae59937fc9bebf", "filename": "gcc/testsuite/g++.dg/warn/Wreorder-1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreorder-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreorder-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreorder-1.C?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"-Wreorder -W\" }\n+\n+struct S {\n+  S ();\n+};\n+\n+struct T {\n+  T ();\n+};\n+\n+struct U : virtual public S, virtual public T {\n+  U () : T (), S () {}     // { dg-warning \"\" }\n+  U (const U&) : S () {}   // { dg-warning \"copy\" }\n+};"}, {"sha": "d5ed38371d7ede8f07d4f3a52b4340b084bfa2bc", "filename": "gcc/testsuite/g++.old-deja/g++.mike/warn3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fwarn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fwarn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fwarn3.C?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -7,6 +7,6 @@ public:\n };\n \n class D : public B {\n-  int member;\n+  int member;\t\t                // WARNING - reordered\n   D() : member(0), B(member) { }\t// WARNING - reordered\n };"}, {"sha": "5a3609493c8c123d3261c12a943dc81c76ce4129", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282d28d488248a113c9f172f8f0f0bca73419c7/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=2282d28d488248a113c9f172f8f0f0bca73419c7", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 1999, 2000, 2002 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -19,7 +19,7 @@\n proc prune_gcc_output { text } {\n     #send_user \"Before:$text\\n\"\n \n-    regsub -all \"(^|\\n)\\[^\\n\\]*: In (function|member|method|constructor|instantiation|program|subroutine|block-data) \\[^\\n\\]*\" $text \"\" text\n+    regsub -all \"(^|\\n)\\[^\\n\\]*: In (function|member|method|(copy )?constructor|instantiation|program|subroutine|block-data) \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*: At (top level|global scope):\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)collect2: ld returned \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)Please submit.*instructions\\[^\\n\\]*\" $text \"\" text"}]}