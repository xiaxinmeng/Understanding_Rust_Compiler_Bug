{"sha": "c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0MzJlNzYwMzlkMmM0ZmI3YTAwZjBmYmQyNjFlZWMyMjM4ZDQyYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-10-31T11:58:53Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-10-31T11:58:53Z"}, "message": "GCOV: std::vector refactoring.\n\n2017-10-31  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (struct source_info): Remove typedef.\n\t(source_info::source_info): Add proper ctor.\n\t(accumulate_line_counts): Use struct, not it's typedef.\n\t(output_gcov_file): Likewise.\n\t(output_lines): Likewise.\n\t(main): Do not allocate an array.\n\t(output_intermediate_file): Use size of vector container.\n\t(process_file): Resize the vector.\n\t(generate_results): Do not preallocate, use newly added vector\n\tlines.\n\t(release_structures): Do not release sources.\n\t(find_source): Use vector methods.\n\t(add_line_counts): Do not use typedef.\n\nFrom-SVN: r254260", "tree": {"sha": "acaed900ec6dda1fa1e1f45383ce9f9414b64fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acaed900ec6dda1fa1e1f45383ce9f9414b64fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7432e76039d2c4fb7a00f0fbd261eec2238d42b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cdb07de7c67cf0d04607ee8e85a659d8bf7594f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb07de7c67cf0d04607ee8e85a659d8bf7594f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb07de7c67cf0d04607ee8e85a659d8bf7594f6"}], "stats": {"total": 105, "additions": 55, "deletions": 50}, "files": [{"sha": "8f1eded8401b0dc3ac004647524f6bc7d899e29d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7432e76039d2c4fb7a00f0fbd261eec2238d42b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7432e76039d2c4fb7a00f0fbd261eec2238d42b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "patch": "@@ -1,3 +1,19 @@\n+2017-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (struct source_info): Remove typedef.\n+\t(source_info::source_info): Add proper ctor.\n+\t(accumulate_line_counts): Use struct, not it's typedef.\n+\t(output_gcov_file): Likewise.\n+\t(output_lines): Likewise.\n+\t(main): Do not allocate an array.\n+\t(output_intermediate_file): Use size of vector container.\n+\t(process_file): Resize the vector.\n+\t(generate_results): Do not preallocate, use newly added vector\n+\tlines.\n+\t(release_structures): Do not release sources.\n+\t(find_source): Use vector methods.\n+\t(add_line_counts): Do not use typedef.\n+\n 2017-10-31  Martin Liska  <mliska@suse.cz>\n \n \t* doc/gcov.texi: Document that."}, {"sha": "f920061593b05b377c031731c4cc582496a06596", "filename": "gcc/gcov.c", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7432e76039d2c4fb7a00f0fbd261eec2238d42b/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7432e76039d2c4fb7a00f0fbd261eec2238d42b/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "patch": "@@ -272,22 +272,29 @@ line_t::has_block (block_t *needle)\n /* Describes a file mentioned in the block graph.  Contains an array\n    of line info.  */\n \n-typedef struct source_info\n+struct source_info\n {\n+  /* Default constructor.  */\n+  source_info ();\n+\n   /* Canonical name of source file.  */\n   char *name;\n   time_t file_time;\n \n-  /* Array of line information.  */\n-  line_t *lines;\n-  unsigned num_lines;\n+  /* Vector of line information.  */\n+  vector<line_t> lines;\n \n   coverage_t coverage;\n \n   /* Functions in this source file.  These are in ascending line\n      number order.  */\n   function_t *functions;\n-} source_t;\n+};\n+\n+source_info::source_info (): name (NULL), file_time (), lines (),\n+  coverage (), functions (NULL)\n+{\n+}\n \n typedef struct name_map\n {\n@@ -300,9 +307,8 @@ typedef struct name_map\n static function_t *functions;\n static function_t **fn_end = &functions;\n \n-static source_t *sources;   /* Array of source files  */\n-static unsigned n_sources;  /* Number of sources */\n-static unsigned a_sources;  /* Allocated sources */\n+/* Vector of source files.  */\n+static vector<source_info> sources;\n \n static name_map_t *names;   /* Mapping of file names to sources */\n static unsigned n_names;    /* Number of names */\n@@ -444,10 +450,10 @@ static void add_line_counts (coverage_t *, function_t *);\n static void executed_summary (unsigned, unsigned);\n static void function_summary (const coverage_t *, const char *);\n static const char *format_gcov (gcov_type, gcov_type, int);\n-static void accumulate_line_counts (source_t *);\n-static void output_gcov_file (const char *, source_t *);\n+static void accumulate_line_counts (source_info *);\n+static void output_gcov_file (const char *, source_info *);\n static int output_branch_count (FILE *, int, const arc_t *);\n-static void output_lines (FILE *, const source_t *);\n+static void output_lines (FILE *, const source_info *);\n static char *make_gcov_file_name (const char *, const char *);\n static char *mangle_name (const char *, char *);\n static void release_structures (void);\n@@ -664,8 +670,6 @@ main (int argc, char **argv)\n \n   a_names = 10;\n   names = XNEWVEC (name_map_t, a_names);\n-  a_sources = 10;\n-  sources = XNEWVEC (source_t, a_sources);\n \n   argno = process_args (argc, argv);\n   if (optind == argc)\n@@ -859,7 +863,7 @@ included. Instead the intermediate format here outputs only a single\n file 'foo.cc.gcov' similar to the above example. */\n \n static void\n-output_intermediate_file (FILE *gcov_file, source_t *src)\n+output_intermediate_file (FILE *gcov_file, source_info *src)\n {\n   unsigned line_num;    /* current line number.  */\n   const line_t *line;   /* current line info ptr.  */\n@@ -876,7 +880,7 @@ output_intermediate_file (FILE *gcov_file, source_t *src)\n     }\n \n   for (line_num = 1, line = &src->lines[line_num];\n-       line_num < src->num_lines;\n+       line_num < src->lines.size ();\n        line_num++, line++)\n     {\n       arc_t *arc;\n@@ -958,8 +962,8 @@ process_file (const char *file_name)\n \t\t    {\n \t\t      unsigned last_line\n \t\t\t= block->locations[i].lines.back () + 1;\n-\t\t      if (last_line > sources[s].num_lines)\n-\t\t\tsources[s].num_lines = last_line;\n+\t\t      if (last_line > sources[s].lines.size ())\n+\t\t\tsources[s].lines.resize (last_line);\n \t\t    }\n \t\t}\n \t    }\n@@ -978,7 +982,7 @@ process_file (const char *file_name)\n }\n \n static void\n-output_gcov_file (const char *file_name, source_t *src)\n+output_gcov_file (const char *file_name, source_info *src)\n {\n   char *gcov_file_name = make_gcov_file_name (file_name, src->coverage.name);\n \n@@ -1011,14 +1015,8 @@ output_gcov_file (const char *file_name, source_t *src)\n static void\n generate_results (const char *file_name)\n {\n-  unsigned ix;\n-  source_t *src;\n   function_t *fn;\n \n-  for (ix = n_sources, src = sources; ix--; src++)\n-    if (src->num_lines)\n-      src->lines = XCNEWVEC (line_t, src->num_lines);\n-\n   for (fn = functions; fn; fn = fn->next)\n     {\n       coverage_t coverage;\n@@ -1043,8 +1041,10 @@ generate_results (const char *file_name)\n \tfile_name = canonicalize_name (file_name);\n     }\n \n-  for (ix = n_sources, src = sources; ix--; src++)\n+  for (vector<source_info>::iterator it = sources.begin ();\n+       it != sources.end (); it++)\n     {\n+      source_info *src = &(*it);\n       if (flag_relative_only)\n \t{\n \t  /* Ignore this source, if it is an absolute path (after\n@@ -1082,10 +1082,6 @@ release_structures (void)\n   unsigned ix;\n   function_t *fn;\n \n-  for (ix = n_sources; ix--;)\n-    free (sources[ix].lines);\n-  free (sources);\n-\n   for (ix = n_names; ix--;)\n     free (names[ix].name);\n   free (names);\n@@ -1230,25 +1226,15 @@ find_source (const char *file_name)\n   if (!name_map)\n     {\n       /* Not found with canonical name, create a new source.  */\n-      source_t *src;\n-\n-      if (n_sources == a_sources)\n-\t{\n-\t  a_sources *= 2;\n-\t  src = XNEWVEC (source_t, a_sources);\n-\t  memcpy (src, sources, n_sources * sizeof (*sources));\n-\t  free (sources);\n-\t  sources = src;\n-\t}\n-\n-      idx = n_sources;\n+      source_info *src;\n \n+      idx = sources.size ();\n       name_map = &names[n_names++];\n       name_map->name = canon;\n       name_map->src = idx;\n \n-      src = &sources[n_sources++];\n-      memset (src, 0, sizeof (*src));\n+      sources.push_back (source_info ());\n+      src = &sources.back ();\n       src->name = canon;\n       src->coverage.name = src->name;\n       if (source_length\n@@ -2254,7 +2240,7 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \tfn->blocks_executed++;\n       for (unsigned i = 0; i < block->locations.size (); i++)\n \t{\n-\t  const source_t *src = &sources[block->locations[i].source_file_idx];\n+\t  source_info *src = &sources[block->locations[i].source_file_idx];\n \n \t  vector<unsigned> &lines = block->locations[i].lines;\n \t  for (unsigned j = 0; j < lines.size (); j++)\n@@ -2310,11 +2296,10 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n /* Accumulate the line counts of a file.  */\n \n static void\n-accumulate_line_counts (source_t *src)\n+accumulate_line_counts (source_info *src)\n {\n-  line_t *line;\n   function_t *fn, *fn_p, *fn_n;\n-  unsigned ix;\n+  unsigned ix = 0;\n \n   /* Reverse the function order.  */\n   for (fn = src->functions, fn_p = NULL; fn; fn_p = fn, fn = fn_n)\n@@ -2324,8 +2309,10 @@ accumulate_line_counts (source_t *src)\n     }\n   src->functions = fn_p;\n \n-  for (ix = src->num_lines, line = src->lines; ix--; line++)\n+  for (vector<line_t>::reverse_iterator it = src->lines.rbegin ();\n+       it != src->lines.rend (); it++)\n     {\n+      line_t *line = &(*it);\n       if (line->blocks)\n \t{\n \t  /* The user expects the line count to be the number of times\n@@ -2378,6 +2365,8 @@ accumulate_line_counts (source_t *src)\n \t  if (line->count)\n \t    src->coverage.lines_executed++;\n \t}\n+\n+      ix++;\n     }\n }\n \n@@ -2539,7 +2528,7 @@ output_line_beginning (FILE *f, bool exists, bool unexceptional,\n    information.  */\n \n static void\n-output_lines (FILE *gcov_file, const source_t *src)\n+output_lines (FILE *gcov_file, const source_info *src)\n {\n #define  DEFAULT_LINE_START \"        -:    0:\"\n \n@@ -2572,7 +2561,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n     fn = src->functions;\n \n   for (line_num = 1, line = &src->lines[line_num];\n-       line_num < src->num_lines; line_num++, line++)\n+       line_num < src->lines.size (); line_num++, line++)\n     {\n       for (; fn && fn->line == line_num; fn = fn->next_file_fn)\n \t{"}]}