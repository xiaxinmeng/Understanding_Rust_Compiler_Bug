{"sha": "879c27e3a3fd424e17690514bd52a7ebc0c1976f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc5YzI3ZTNhM2ZkNDI0ZTE3NjkwNTE0YmQ1MmE3ZWJjMGMxOTc2Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-01-19T13:27:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-01-19T13:27:11Z"}, "message": "re PR tree-optimization/69336 (Constant value not detected)\n\n2016-01-19  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/69336\n\t* tree-ssa-scopedtables.c (avail_expr_hash): Handle all\n\thandled components with get_ref_base_and_extent.\n\t(equal_mem_array_ref_p): Adjust.\n\n\t* g++.dg/tree-ssa/pr69336.C: New testcase.\n\nFrom-SVN: r232559", "tree": {"sha": "a5f8aac4273d3bb4f73465df51cb734ce2eb1b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f8aac4273d3bb4f73465df51cb734ce2eb1b85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/879c27e3a3fd424e17690514bd52a7ebc0c1976f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/879c27e3a3fd424e17690514bd52a7ebc0c1976f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/879c27e3a3fd424e17690514bd52a7ebc0c1976f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/879c27e3a3fd424e17690514bd52a7ebc0c1976f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "015337d35b4b3d5688162d24866b58a16a152f56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015337d35b4b3d5688162d24866b58a16a152f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015337d35b4b3d5688162d24866b58a16a152f56"}], "stats": {"total": 104, "additions": 101, "deletions": 3}, "files": [{"sha": "a4a90470e53e6b0c9efc8059f32b9523fc78cac5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=879c27e3a3fd424e17690514bd52a7ebc0c1976f", "patch": "@@ -1,3 +1,10 @@\n+2016-01-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/69336\n+\t* tree-ssa-scopedtables.c (avail_expr_hash): Handle all\n+\thandled components with get_ref_base_and_extent.\n+\t(equal_mem_array_ref_p): Adjust.\n+\n 2016-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/65779"}, {"sha": "9f486780fac8898d2bf2f53078941be10080d6d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=879c27e3a3fd424e17690514bd52a7ebc0c1976f", "patch": "@@ -1,3 +1,8 @@\n+2016-01-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/69336\n+\t* g++.dg/tree-ssa/pr69336.C: New testcase.\n+\n 2016-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/65779"}, {"sha": "67f87cfbe2f594740f6676fb5b54e50d261c170a", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr69336.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr69336.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr69336.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr69336.C?ref=879c27e3a3fd424e17690514bd52a7ebc0c1976f", "patch": "@@ -0,0 +1,86 @@\n+// { dg-do compile }\n+// { dg-options \"-O3 -fdump-tree-optimized -std=c++14\" }\n+\n+#include <array>\n+#include <utility>\n+\n+\n+template<class Key, class T, size_t N> struct static_map\n+{\n+  using key_type = Key;\n+  using mapped_type = T;\n+  using value_type = std::pair<const key_type, mapped_type>;\n+private:\n+  using _value_type = std::pair<size_t, value_type>;\n+  _value_type _values[N];\n+  static constexpr _value_type _new_value_type(const std::pair<Key, T> &v)\n+  {\n+    return std::make_pair(0, std::make_pair(v.first, v.second));\n+  }\n+public:\n+  template<class... U> constexpr static_map(U &&...il) : _values{ _new_value_type(il)... } { }\n+  constexpr mapped_type &operator[](const key_type &k) { return at(k); }\n+  constexpr const mapped_type &operator[](const key_type &k) const { return at(k); }\n+  constexpr mapped_type &at(const key_type &k)\n+  {\n+    for (size_t n = 0; n < N; n++)\n+      if (_values[n].second.first == k)\n+        return _values[n].second.second;\n+    throw std::out_of_range(\"Key not found\");\n+  }\n+  constexpr const mapped_type &at(const key_type &k) const\n+  {\n+    for (size_t n = 0; n < N; n++)\n+      if (_values[n].second.first == k)\n+        return _values[n].second.second;\n+    throw std::out_of_range(\"Key not found\");\n+  }\n+};\n+namespace detail\n+{\n+  template<class Key, class T, size_t N, size_t... I> constexpr static_map<Key, T, N> static_map_from_array(const std::pair<Key, T>(&il)[N], std::index_sequence<I...>)\n+  {\n+    return static_map<Key, T, N>(il[I]...);\n+  }\n+}\n+template<class Key, class T, size_t N> constexpr static_map<Key, T, N> make_static_map(const std::pair<Key, T> (&il)[N])\n+{\n+  return detail::static_map_from_array<Key, T, N>(il, std::make_index_sequence<N>());\n+}\n+\n+/* Two phase construction, required because heterogeneous braced init\n+in C++ 14 has a big limitation: template<class... Args> auto make(Args &&...)\n+will accept make({ 5, \"apple\" }) as make(int, const char *) but\n+make({ 5, \"apple\" }, { 8, \"pear\" }) will fail to deduce Args as a\n+heterogeneous initializer_list is not permitted. This forces something\n+like make(make_pair{ 5, \"apple\" }, make_pair{ 8, \"pear\" }, ...) which\n+is less succinct than using a constexpr C array for the nested braced init.\n+*/\n+constexpr std::pair<const int, const char *> map_data[] = {\n+  { 5, \"apple\" },\n+  { 8, \"pear\" },\n+  { 0, \"banana\" }\n+};\n+\n+template<size_t N> constexpr int cstrcmp(const char *a, const char *b)\n+{\n+  for (size_t n = 0; n < N; n++)\n+  {\n+    if (a[n] < b[n]) return -1;\n+    if (a[n] > b[n]) return 1;\n+  }\n+  return 0;\n+}\n+\n+int main(void)\n+{\n+  constexpr auto cmap = make_static_map(map_data);\n+  // No abort() appears in assembler, so this was executed constexpr\n+  if(!cmap[8]) abort();\n+  // This however does cause code implementing a lookup to be generated,\n+  // so this was NOT executed constexpr\n+  //const char *foo=cmap[5];\n+  return 0;\n+}\n+\n+// { dg-final { scan-tree-dump-not \"cmap\" \"optimized\" } }"}, {"sha": "613f50b58530b248f1f7162a1aebc60a2b80441e", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879c27e3a3fd424e17690514bd52a7ebc0c1976f/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=879c27e3a3fd424e17690514bd52a7ebc0c1976f", "patch": "@@ -214,7 +214,7 @@ avail_expr_hash (class expr_hash_elt *p)\n     {\n       /* T could potentially be a switch index or a goto dest.  */\n       tree t = expr->ops.single.rhs;\n-      if (TREE_CODE (t) == MEM_REF || TREE_CODE (t) == ARRAY_REF)\n+      if (TREE_CODE (t) == MEM_REF || handled_component_p (t))\n \t{\n \t  /* Make equivalent statements of both these kinds hash together.\n \t     Dealing with both MEM_REF and ARRAY_REF allows us not to care\n@@ -252,9 +252,9 @@ avail_expr_hash (class expr_hash_elt *p)\n static bool\n equal_mem_array_ref_p (tree t0, tree t1)\n {\n-  if (TREE_CODE (t0) != MEM_REF && TREE_CODE (t0) != ARRAY_REF)\n+  if (TREE_CODE (t0) != MEM_REF && ! handled_component_p (t0))\n     return false;\n-  if (TREE_CODE (t1) != MEM_REF && TREE_CODE (t1) != ARRAY_REF)\n+  if (TREE_CODE (t1) != MEM_REF && ! handled_component_p (t1))\n     return false;\n \n   if (!types_compatible_p (TREE_TYPE (t0), TREE_TYPE (t1)))"}]}