{"sha": "58926110dc3efed307b3a9e06fb51fef5e6d4304", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg5MjYxMTBkYzNlZmVkMzA3YjNhOWUwNmZiNTFmZWY1ZTZkNDMwNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-11-10T18:18:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-11-10T18:18:51Z"}, "message": "re PR c++/34158 (Template delete doesn't call if exception thrown in constructor)\n\n\tPR c++/34158\n\tPR c++/36406\n\t* call.c (non_placement_deallocation_fn_p): Split out...\n\t(build_op_delete_call): ...from here.  Use instantiate_type\n\tfor placement delete.  Simplify logic.\n\t* pt.c (primary_template_instantiation_p): Non-static.\n\t* cp-tree.h: Declare it.\n\nFrom-SVN: r154072", "tree": {"sha": "3f394cf2fa59e3d724a47295615ec350d68884f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f394cf2fa59e3d724a47295615ec350d68884f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58926110dc3efed307b3a9e06fb51fef5e6d4304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58926110dc3efed307b3a9e06fb51fef5e6d4304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58926110dc3efed307b3a9e06fb51fef5e6d4304", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58926110dc3efed307b3a9e06fb51fef5e6d4304/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f743a562d0b9ae481124b63d62afa9c72715a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f743a562d0b9ae481124b63d62afa9c72715a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f743a562d0b9ae481124b63d62afa9c72715a45"}], "stats": {"total": 193, "additions": 127, "deletions": 66}, "files": [{"sha": "6087ed7f90c69ea2536a08bd73b4dbba1d6970e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=58926110dc3efed307b3a9e06fb51fef5e6d4304", "patch": "@@ -1,5 +1,13 @@\n 2009-11-09  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/34158\n+\tPR c++/36406\n+\t* call.c (non_placement_deallocation_fn_p): Split out...\n+\t(build_op_delete_call): ...from here.  Use instantiate_type\n+\tfor placement delete.  Simplify logic.\n+\t* pt.c (primary_template_instantiation_p): Non-static.\n+\t* cp-tree.h: Declare it.\n+\n \tPR c++/41972\n \t* parser.c (cp_parser_template_argument): Accept SCOPE_REF around\n \tVAR_DECL."}, {"sha": "1cd3fc2e0e69a778c43219fcf8e47017096d30de", "filename": "gcc/cp/call.c", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=58926110dc3efed307b3a9e06fb51fef5e6d4304", "patch": "@@ -4503,6 +4503,33 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   return NULL_TREE;\n }\n \n+/* Returns true iff T, an element of an OVERLOAD chain, is a usual\n+   deallocation function (3.7.4.2 [basic.stc.dynamic.deallocation]).  */\n+\n+static bool\n+non_placement_deallocation_fn_p (tree t)\n+{\n+  /* A template instance is never a usual deallocation function,\n+     regardless of its signature.  */\n+  if (TREE_CODE (t) == TEMPLATE_DECL\n+      || primary_template_instantiation_p (t))\n+    return false;\n+\n+  /* If a class T has a member deallocation function named operator delete\n+     with exactly one parameter, then that function is a usual\n+     (non-placement) deallocation function. If class T does not declare\n+     such an operator delete but does declare a member deallocation\n+     function named operator delete with exactly two parameters, the second\n+     of which has type std::size_t (18.2), then this function is a usual\n+     deallocation function.  */\n+  t = FUNCTION_ARG_CHAIN (t);\n+  if (t == void_list_node\n+      || (t && same_type_p (TREE_VALUE (t), size_type_node)\n+\t  && TREE_CHAIN (t) == void_list_node))\n+    return true;\n+  return false;\n+}\n+\n /* Build a call to operator delete.  This has to be handled very specially,\n    because the restrictions on what signatures match are different from all\n    other call instances.  For a normal delete, only a delete taking (void *)\n@@ -4528,8 +4555,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t\t      tree alloc_fn)\n {\n   tree fn = NULL_TREE;\n-  tree fns, fnname, argtypes, type;\n-  int pass;\n+  tree fns, fnname, type, t;\n \n   if (addr == error_mark_node)\n     return error_mark_node;\n@@ -4564,78 +4590,68 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   if (placement)\n     {\n-      /* Get the parameter types for the allocation function that is\n-\t being called.  */\n-      gcc_assert (alloc_fn != NULL_TREE);\n-      argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (alloc_fn)));\n-    }\n-  else\n-    {\n-      /* First try it without the size argument.  */\n-      argtypes = void_list_node;\n-    }\n+      /* \"A declaration of a placement deallocation function matches the\n+\t declaration of a placement allocation function if it has the same\n+\t number of parameters and, after parameter transformations (8.3.5),\n+\t all parameter types except the first are identical.\"\n \n-  /* We make two tries at finding a matching `operator delete'.  On\n-     the first pass, we look for a one-operator (or placement)\n-     operator delete.  If we're not doing placement delete, then on\n-     the second pass we look for a two-argument delete.  */\n-  for (pass = 0; pass < (placement ? 1 : 2); ++pass)\n-    {\n-      /* Go through the `operator delete' functions looking for one\n-\t with a matching type.  */\n-      for (fn = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;\n-\t   fn;\n-\t   fn = OVL_NEXT (fn))\n-\t{\n-\t  tree t;\n+\t So we build up the function type we want and ask instantiate_type\n+\t to get it for us.  */\n+      t = FUNCTION_ARG_CHAIN (alloc_fn);\n+      t = tree_cons (NULL_TREE, ptr_type_node, t);\n+      t = build_function_type (void_type_node, t);\n \n-\t  /* The first argument must be \"void *\".  */\n-\t  t = TYPE_ARG_TYPES (TREE_TYPE (OVL_CURRENT (fn)));\n-\t  if (!same_type_p (TREE_VALUE (t), ptr_type_node))\n-\t    continue;\n-\t  t = TREE_CHAIN (t);\n-\t  /* On the first pass, check the rest of the arguments.  */\n-\t  if (pass == 0)\n-\t    {\n-\t      tree a = argtypes;\n-\t      while (a && t)\n-\t\t{\n-\t\t  if (!same_type_p (TREE_VALUE (a), TREE_VALUE (t)))\n-\t\t    break;\n-\t\t  a = TREE_CHAIN (a);\n-\t\t  t = TREE_CHAIN (t);\n-\t\t}\n-\t      if (!a && !t)\n-\t\tbreak;\n-\t    }\n-\t  /* On the second pass, look for a function with exactly two\n-\t     arguments: \"void *\" and \"size_t\".  */\n-\t  else if (pass == 1\n-\t\t   /* For \"operator delete(void *, ...)\" there will be\n-\t\t      no second argument, but we will not get an exact\n-\t\t      match above.  */\n-\t\t   && t\n-\t\t   && same_type_p (TREE_VALUE (t), size_type_node)\n-\t\t   && TREE_CHAIN (t) == void_list_node)\n-\t    break;\n-\t}\n+      fn = instantiate_type (t, fns, tf_none);\n+      if (fn == error_mark_node)\n+\treturn NULL_TREE;\n \n-      /* If we found a match, we're done.  */\n-      if (fn)\n-\tbreak;\n+      if (BASELINK_P (fn))\n+\tfn = BASELINK_FUNCTIONS (fn);\n+\n+      /* \"If the lookup finds the two-parameter form of a usual deallocation\n+\t function (3.7.4.2) and that function, considered as a placement\n+\t deallocation function, would have been selected as a match for the\n+\t allocation function, the program is ill-formed.\"  */\n+      if (non_placement_deallocation_fn_p (fn))\n+\terror (\"non-placement deallocation function %qD selected for \"\n+\t       \"placement delete\", fn);\n     }\n+  else\n+    /* \"Any non-placement deallocation function matches a non-placement\n+       allocation function. If the lookup finds a single matching\n+       deallocation function, that function will be called; otherwise, no\n+       deallocation function will be called.\"  */\n+    for (t = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;\n+\t t; t = OVL_NEXT (t))\n+      {\n+\ttree elt = OVL_CURRENT (t);\n+\tif (non_placement_deallocation_fn_p (elt))\n+\t  {\n+\t    fn = elt;\n+\t    /* \"If a class T has a member deallocation function named\n+\t       operator delete with exactly one parameter, then that\n+\t       function is a usual (non-placement) deallocation\n+\t       function. If class T does not declare such an operator\n+\t       delete but does declare a member deallocation function named\n+\t       operator delete with exactly two parameters, the second of\n+\t       which has type std::size_t (18.2), then this function is a\n+\t       usual deallocation function.\"\n+\n+\t       So (void*) beats (void*, size_t).  */\n+\t    if (FUNCTION_ARG_CHAIN (fn) == void_list_node)\n+\t      break;\n+\t  }\n+      }\n \n   /* If we have a matching function, call it.  */\n   if (fn)\n     {\n-      /* Make sure we have the actual function, and not an\n-\t OVERLOAD.  */\n-      fn = OVL_CURRENT (fn);\n+      gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n \n       /* If the FN is a member function, make sure that it is\n \t accessible.  */\n-      if (DECL_CLASS_SCOPE_P (fn))\n-\tperform_or_defer_access_check (TYPE_BINFO (type), fn, fn);\n+      if (BASELINK_P (fns))\n+\tperform_or_defer_access_check (BASELINK_BINFO (fns), fn, fn);\n \n       /* Core issue 901: It's ok to new a type with deleted delete.  */\n       if (DECL_DELETED_FN (fn) && alloc_fn)\n@@ -4659,7 +4675,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t  tree ret;\n \t  VEC(tree,gc) *args = VEC_alloc (tree, gc, 2);\n \t  VEC_quick_push (tree, args, addr);\n-\t  if (pass != 0)\n+\t  if (FUNCTION_ARG_CHAIN (fn) != void_list_node)\n \t    VEC_quick_push (tree, args, size);\n \t  ret = cp_build_function_call_vec (fn, &args, tf_warning_or_error);\n \t  VEC_free (tree, gc, args);"}, {"sha": "ca52bdf7597cc9e3d3892853873fa67defc95f33", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=58926110dc3efed307b3a9e06fb51fef5e6d4304", "patch": "@@ -4853,6 +4853,7 @@ extern struct tinst_level *outermost_tinst_level(void);\n extern bool parameter_of_template_p\t\t(tree, tree);\n extern void init_template_processing\t\t(void);\n bool template_template_parameter_p\t\t(const_tree);\n+extern bool primary_template_instantiation_p    (const_tree);\n extern tree get_primary_template_innermost_parameters\t(const_tree);\n extern tree get_template_innermost_arguments\t(const_tree);\n extern tree get_template_argument_pack_elems\t(const_tree);"}, {"sha": "0e688bf406a632b36b7d5c188784d561cd7d1015", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=58926110dc3efed307b3a9e06fb51fef5e6d4304", "patch": "@@ -191,7 +191,6 @@ static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n static void append_type_to_template_for_access_check_1 (tree, tree, tree);\n static hashval_t iterative_hash_template_arg (tree arg, hashval_t val);\n-static bool primary_template_instantiation_p (const_tree);\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n \n@@ -2739,7 +2738,7 @@ make_ith_pack_parameter_name (tree name, int i)\n /* Return true if T is a primary function\n    or class template instantiation.  */\n \n-static bool\n+bool\n primary_template_instantiation_p (const_tree t)\n {\n   if (!t)"}, {"sha": "ae1202fcbe8d2daf92d4b35311b451ff2c021a8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58926110dc3efed307b3a9e06fb51fef5e6d4304", "patch": "@@ -1,3 +1,8 @@\n+2009-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/34158\n+\t* g++.dg/init/placement4.C: New.\n+\n 2009-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/vect/vect-multitypes-5.c: XFAIL on SPARC 32-bit."}, {"sha": "9c61eca2b04619b785e154b128beeae9d7602263", "filename": "gcc/testsuite/g++.dg/init/placement4.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fplacement4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58926110dc3efed307b3a9e06fb51fef5e6d4304/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fplacement4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fplacement4.C?ref=58926110dc3efed307b3a9e06fb51fef5e6d4304", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/34158\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" void* malloc (size_t);\n+extern \"C\" void free (void *);\n+\n+template <class T> class undef;\n+\n+struct A {\n+  A() { throw 1; }\n+};\n+\n+template<typename T> class Pool { };\n+\n+void *operator new(size_t size,Pool<int>& pool)\n+{\n+  return malloc(size);\n+}\n+\n+template<typename T>\n+void operator delete(void *p,Pool<T>& pool)\n+{\n+  undef<T> t;\t\t\t// { dg-error \"incomplete\" }\n+  free(p);\n+}\n+\n+int main ()\n+{\n+  Pool<int> pool;\n+  new (pool) A();\t\t// { dg-message \"instantiated\" }\n+  return 0;\n+}"}]}