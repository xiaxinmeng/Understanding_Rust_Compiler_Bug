{"sha": "30196a76d1266055da06c42a6679c5487cde4676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAxOTZhNzZkMTI2NjA1NWRhMDZjNDJhNjY3OWM1NDg3Y2RlNDY3Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-09-09T09:35:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T09:35:11Z"}, "message": "nlists.ads, nlists.adb (In_Same_List): New function.\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* nlists.ads, nlists.adb (In_Same_List): New function.\n\tUse Node_Or_Entity_Id where appropriate.\n\t* par-labl.adb, sem_ch6.adb, sem_type.adb: Use In_Same_List.\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* restrict.ads, restrict.adb (Check_Wide_Character_Restriction): New\n\tprocedure.\n\t* sem_ch3.adb: Use Check_Wide_Character_Restriction\n\t(Enumeration_Type_Declaration): Check violation of No_Wide_Characters\n\t* sem_ch8.adb (Find_Direct_Name): Check violation of No_Wide_Characters\n\t(Find_Expanded_Name): Check violation of No_Wide_Characters\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch5.adb: Minor reformatting.\n\nFrom-SVN: r164056", "tree": {"sha": "8078d5b31e183495eefbdb243bfb11688a5b1435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8078d5b31e183495eefbdb243bfb11688a5b1435"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30196a76d1266055da06c42a6679c5487cde4676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30196a76d1266055da06c42a6679c5487cde4676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30196a76d1266055da06c42a6679c5487cde4676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30196a76d1266055da06c42a6679c5487cde4676/comments", "author": null, "committer": null, "parents": [{"sha": "d151d6a357e5336c4a3dd16c440b1d54eaab3639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d151d6a357e5336c4a3dd16c440b1d54eaab3639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d151d6a357e5336c4a3dd16c440b1d54eaab3639"}], "stats": {"total": 519, "additions": 317, "deletions": 202}, "files": [{"sha": "c0c3e104c3171f9d01344f72ce870825ac6c98d7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -1,3 +1,22 @@\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* nlists.ads, nlists.adb (In_Same_List): New function.\n+\tUse Node_Or_Entity_Id where appropriate.\n+\t* par-labl.adb, sem_ch6.adb, sem_type.adb: Use In_Same_List.\n+\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* restrict.ads, restrict.adb (Check_Wide_Character_Restriction): New\n+\tprocedure.\n+\t* sem_ch3.adb: Use Check_Wide_Character_Restriction\n+\t(Enumeration_Type_Declaration): Check violation of No_Wide_Characters\n+\t* sem_ch8.adb (Find_Direct_Name): Check violation of No_Wide_Characters\n+\t(Find_Expanded_Name): Check violation of No_Wide_Characters\n+\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch5.adb: Minor reformatting.\n+\n 2010-09-09  Robert Dewar  <dewar@adacore.com>\n \n \t* prj-env.adb: Minor code reorganization."}, {"sha": "453e665ecccd5609114551dbc7e0e18707234942", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 136, "deletions": 107, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,10 +52,10 @@ package body Nlists is\n    --  three fields:\n \n    type List_Header is record\n-      First : Node_Id;\n+      First : Node_Or_Entity_Id;\n       --  Pointer to first node in list. Empty if list is empty\n \n-      Last  : Node_Id;\n+      Last : Node_Or_Entity_Id;\n       --  Pointer to last node in list. Empty if list is empty\n \n       Parent : Node_Id;\n@@ -85,16 +85,16 @@ package body Nlists is\n    --  list and Prev_Node is Empty at the start of a list.\n \n    package Next_Node is new Table.Table (\n-      Table_Component_Type => Node_Id,\n-      Table_Index_Type     => Node_Id'Base,\n+      Table_Component_Type => Node_Or_Entity_Id,\n+      Table_Index_Type     => Node_Or_Entity_Id'Base,\n       Table_Low_Bound      => First_Node_Id,\n       Table_Initial        => Alloc.Orig_Nodes_Initial,\n       Table_Increment      => Alloc.Orig_Nodes_Increment,\n       Table_Name           => \"Next_Node\");\n \n    package Prev_Node is new Table.Table (\n-      Table_Component_Type => Node_Id,\n-      Table_Index_Type     => Node_Id'Base,\n+      Table_Component_Type => Node_Or_Entity_Id,\n+      Table_Index_Type     => Node_Or_Entity_Id'Base,\n       Table_Low_Bound      => First_Node_Id,\n       Table_Initial        => Alloc.Orig_Nodes_Initial,\n       Table_Increment      => Alloc.Orig_Nodes_Increment,\n@@ -104,32 +104,32 @@ package body Nlists is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Set_First (List : List_Id; To : Node_Id);\n+   procedure Set_First (List : List_Id; To : Node_Or_Entity_Id);\n    pragma Inline (Set_First);\n    --  Sets First field of list header List to reference To\n \n-   procedure Set_Last (List : List_Id; To : Node_Id);\n+   procedure Set_Last (List : List_Id; To : Node_Or_Entity_Id);\n    pragma Inline (Set_Last);\n    --  Sets Last field of list header List to reference To\n \n-   procedure Set_List_Link (Node : Node_Id; To : List_Id);\n+   procedure Set_List_Link (Node : Node_Or_Entity_Id; To : List_Id);\n    pragma Inline (Set_List_Link);\n    --  Sets list link of Node to list header To\n \n-   procedure Set_Next (Node : Node_Id; To : Node_Id);\n+   procedure Set_Next (Node : Node_Or_Entity_Id; To : Node_Or_Entity_Id);\n    pragma Inline (Set_Next);\n    --  Sets the Next_Node pointer for Node to reference To\n \n-   procedure Set_Prev (Node : Node_Id; To : Node_Id);\n+   procedure Set_Prev (Node : Node_Or_Entity_Id; To : Node_Or_Entity_Id);\n    pragma Inline (Set_Prev);\n    --  Sets the Prev_Node pointer for Node to reference To\n \n    --------------------------\n    -- Allocate_List_Tables --\n    --------------------------\n \n-   procedure Allocate_List_Tables (N : Node_Id) is\n-      Old_Last : constant Node_Id'Base := Next_Node.Last;\n+   procedure Allocate_List_Tables (N : Node_Or_Entity_Id) is\n+      Old_Last : constant Node_Or_Entity_Id'Base := Next_Node.Last;\n \n    begin\n       pragma Assert (N >= Old_Last);\n@@ -149,8 +149,8 @@ package body Nlists is\n    -- Append --\n    ------------\n \n-   procedure Append (Node : Node_Id; To : List_Id) is\n-      L : constant Node_Id := Last (To);\n+   procedure Append (Node : Node_Or_Entity_Id; To : List_Id) is\n+      L : constant Node_Or_Entity_Id := Last (To);\n \n       procedure Append_Debug;\n       pragma Inline (Append_Debug);\n@@ -230,9 +230,9 @@ package body Nlists is\n \n       else\n          declare\n-            L : constant Node_Id := Last (To);\n-            F : constant Node_Id := First (List);\n-            N : Node_Id;\n+            L : constant Node_Or_Entity_Id := Last (To);\n+            F : constant Node_Or_Entity_Id := First (List);\n+            N : Node_Or_Entity_Id;\n \n          begin\n             pragma Debug (Append_List_Debug);\n@@ -272,7 +272,7 @@ package body Nlists is\n    -- Append_To --\n    ---------------\n \n-   procedure Append_To (To : List_Id; Node : Node_Id) is\n+   procedure Append_To (To : List_Id; Node : Node_Or_Entity_Id) is\n    begin\n       Append (Node, To);\n    end Append_To;\n@@ -281,7 +281,7 @@ package body Nlists is\n    -- First --\n    -----------\n \n-   function First (List : List_Id) return Node_Id is\n+   function First (List : List_Id) return Node_Or_Entity_Id is\n    begin\n       if List = No_List then\n          return Empty;\n@@ -295,8 +295,8 @@ package body Nlists is\n    -- First_Non_Pragma --\n    ----------------------\n \n-   function First_Non_Pragma (List : List_Id) return Node_Id is\n-      N : constant Node_Id := First (List);\n+   function First_Non_Pragma (List : List_Id) return Node_Or_Entity_Id is\n+      N : constant Node_Or_Entity_Id := First (List);\n    begin\n       if Nkind (N) /= N_Pragma\n            and then\n@@ -329,11 +329,22 @@ package body Nlists is\n    end Initialize;\n \n    ------------------\n-   -- Insert_After --\n+   -- In_Same_List --\n    ------------------\n \n-   procedure Insert_After (After : Node_Id; Node : Node_Id) is\n+   function In_Same_List (N1, N2 : Node_Or_Entity_Id) return Boolean is\n+   begin\n+      return List_Containing (N1) = List_Containing (N2);\n+   end In_Same_List;\n \n+   ------------------\n+   -- Insert_After --\n+   ------------------\n+\n+   procedure Insert_After\n+     (After : Node_Or_Entity_Id;\n+      Node  : Node_Or_Entity_Id)\n+   is\n       procedure Insert_After_Debug;\n       pragma Inline (Insert_After_Debug);\n       --  Output debug information if Debug_Flag_N set\n@@ -366,8 +377,8 @@ package body Nlists is\n       pragma Debug (Insert_After_Debug);\n \n       declare\n-         Before : constant Node_Id := Next (After);\n-         LC     : constant List_Id := List_Containing (After);\n+         Before : constant Node_Or_Entity_Id := Next (After);\n+         LC     : constant List_Id           := List_Containing (After);\n \n       begin\n          if Present (Before) then\n@@ -390,8 +401,10 @@ package body Nlists is\n    -- Insert_Before --\n    -------------------\n \n-   procedure Insert_Before (Before : Node_Id; Node : Node_Id) is\n-\n+   procedure Insert_Before\n+     (Before : Node_Or_Entity_Id;\n+      Node   : Node_Or_Entity_Id)\n+   is\n       procedure Insert_Before_Debug;\n       pragma Inline (Insert_Before_Debug);\n       --  Output debug information if Debug_Flag_N set\n@@ -424,8 +437,8 @@ package body Nlists is\n       pragma Debug (Insert_Before_Debug);\n \n       declare\n-         After : constant Node_Id := Prev (Before);\n-         LC    : constant List_Id := List_Containing (Before);\n+         After : constant Node_Or_Entity_Id := Prev (Before);\n+         LC    : constant List_Id           := List_Containing (Before);\n \n       begin\n          if Present (After) then\n@@ -448,7 +461,7 @@ package body Nlists is\n    -- Insert_List_After --\n    -----------------------\n \n-   procedure Insert_List_After (After : Node_Id; List : List_Id) is\n+   procedure Insert_List_After (After : Node_Or_Entity_Id; List : List_Id) is\n \n       procedure Insert_List_After_Debug;\n       pragma Inline (Insert_List_After_Debug);\n@@ -479,11 +492,11 @@ package body Nlists is\n \n       else\n          declare\n-            Before : constant Node_Id := Next (After);\n-            LC     : constant List_Id := List_Containing (After);\n-            F      : constant Node_Id := First (List);\n-            L      : constant Node_Id := Last (List);\n-            N      : Node_Id;\n+            Before : constant Node_Or_Entity_Id := Next (After);\n+            LC     : constant List_Id           := List_Containing (After);\n+            F      : constant Node_Or_Entity_Id := First (List);\n+            L      : constant Node_Or_Entity_Id := Last (List);\n+            N      : Node_Or_Entity_Id;\n \n          begin\n             pragma Debug (Insert_List_After_Debug);\n@@ -515,7 +528,7 @@ package body Nlists is\n    -- Insert_List_Before --\n    ------------------------\n \n-   procedure Insert_List_Before (Before : Node_Id; List : List_Id) is\n+   procedure Insert_List_Before (Before : Node_Or_Entity_Id; List : List_Id) is\n \n       procedure Insert_List_Before_Debug;\n       pragma Inline (Insert_List_Before_Debug);\n@@ -546,11 +559,11 @@ package body Nlists is\n \n       else\n          declare\n-            After : constant Node_Id := Prev (Before);\n-            LC    : constant List_Id := List_Containing (Before);\n-            F     : constant Node_Id := First (List);\n-            L     : constant Node_Id := Last (List);\n-            N     : Node_Id;\n+            After : constant Node_Or_Entity_Id := Prev (Before);\n+            LC    : constant List_Id           := List_Containing (Before);\n+            F     : constant Node_Or_Entity_Id := First (List);\n+            L     : constant Node_Or_Entity_Id := Last (List);\n+            N     : Node_Or_Entity_Id;\n \n          begin\n             pragma Debug (Insert_List_Before_Debug);\n@@ -591,7 +604,7 @@ package body Nlists is\n    -- Is_List_Member --\n    --------------------\n \n-   function Is_List_Member (Node : Node_Id) return Boolean is\n+   function Is_List_Member (Node : Node_Or_Entity_Id) return Boolean is\n    begin\n       return Nodes.Table (Node).In_List;\n    end Is_List_Member;\n@@ -609,7 +622,7 @@ package body Nlists is\n    -- Last --\n    ----------\n \n-   function Last (List : List_Id) return Node_Id is\n+   function Last (List : List_Id) return Node_Or_Entity_Id is\n    begin\n       pragma Assert (List <= Lists.Last);\n       return Lists.Table (List).Last;\n@@ -628,8 +641,8 @@ package body Nlists is\n    -- Last_Non_Pragma --\n    ---------------------\n \n-   function Last_Non_Pragma (List : List_Id) return Node_Id is\n-      N : constant Node_Id := Last (List);\n+   function Last_Non_Pragma (List : List_Id) return Node_Or_Entity_Id is\n+      N : constant Node_Or_Entity_Id := Last (List);\n    begin\n       if Nkind (N) /= N_Pragma then\n          return N;\n@@ -642,7 +655,7 @@ package body Nlists is\n    -- List_Containing --\n    ---------------------\n \n-   function List_Containing (Node : Node_Id) return List_Id is\n+   function List_Containing (Node : Node_Or_Entity_Id) return List_Id is\n    begin\n       pragma Assert (Is_List_Member (Node));\n       return List_Id (Nodes.Table (Node).Link);\n@@ -654,7 +667,7 @@ package body Nlists is\n \n    function List_Length (List : List_Id) return Nat is\n       Result : Nat;\n-      Node   : Node_Id;\n+      Node   : Node_Or_Entity_Id;\n \n    begin\n       Result := 0;\n@@ -698,7 +711,7 @@ package body Nlists is\n \n    function New_Copy_List (List : List_Id) return List_Id is\n       NL : List_Id;\n-      E  : Node_Id;\n+      E  : Node_Or_Entity_Id;\n \n    begin\n       if List = No_List then\n@@ -723,7 +736,7 @@ package body Nlists is\n \n    function New_Copy_List_Original (List : List_Id) return List_Id is\n       NL : List_Id;\n-      E  : Node_Id;\n+      E  : Node_Or_Entity_Id;\n \n    begin\n       if List = No_List then\n@@ -790,7 +803,7 @@ package body Nlists is\n    --  list directly, rather than first building an empty list and then doing\n    --  the insertion, which results in some unnecessary work.\n \n-   function New_List (Node : Node_Id) return List_Id is\n+   function New_List (Node : Node_Or_Entity_Id) return List_Id is\n \n       procedure New_List_Debug;\n       pragma Inline (New_List_Debug);\n@@ -838,22 +851,34 @@ package body Nlists is\n       end if;\n    end New_List;\n \n-   function New_List (Node1, Node2 : Node_Id) return List_Id is\n+   function New_List\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id) return List_Id\n+   is\n       L : constant List_Id := New_List (Node1);\n    begin\n       Append (Node2, L);\n       return L;\n    end New_List;\n \n-   function New_List (Node1, Node2, Node3 : Node_Id) return List_Id is\n+   function New_List\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id) return List_Id\n+   is\n       L : constant List_Id := New_List (Node1);\n    begin\n       Append (Node2, L);\n       Append (Node3, L);\n       return L;\n    end New_List;\n \n-   function New_List (Node1, Node2, Node3, Node4 : Node_Id) return List_Id is\n+   function New_List\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id;\n+      Node4 : Node_Or_Entity_Id) return List_Id\n+   is\n       L : constant List_Id := New_List (Node1);\n    begin\n       Append (Node2, L);\n@@ -863,11 +888,11 @@ package body Nlists is\n    end New_List;\n \n    function New_List\n-     (Node1 : Node_Id;\n-      Node2 : Node_Id;\n-      Node3 : Node_Id;\n-      Node4 : Node_Id;\n-      Node5 : Node_Id) return List_Id\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id;\n+      Node4 : Node_Or_Entity_Id;\n+      Node5 : Node_Or_Entity_Id) return List_Id\n    is\n       L : constant List_Id := New_List (Node1);\n    begin\n@@ -879,12 +904,12 @@ package body Nlists is\n    end New_List;\n \n    function New_List\n-     (Node1 : Node_Id;\n-      Node2 : Node_Id;\n-      Node3 : Node_Id;\n-      Node4 : Node_Id;\n-      Node5 : Node_Id;\n-      Node6 : Node_Id) return List_Id\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id;\n+      Node4 : Node_Or_Entity_Id;\n+      Node5 : Node_Or_Entity_Id;\n+      Node6 : Node_Or_Entity_Id) return List_Id\n    is\n       L : constant List_Id := New_List (Node1);\n    begin\n@@ -900,13 +925,13 @@ package body Nlists is\n    -- Next --\n    ----------\n \n-   function Next (Node : Node_Id) return Node_Id is\n+   function Next (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id is\n    begin\n       pragma Assert (Is_List_Member (Node));\n       return Next_Node.Table (Node);\n    end Next;\n \n-   procedure Next (Node : in out Node_Id) is\n+   procedure Next (Node : in out Node_Or_Entity_Id) is\n    begin\n       Node := Next (Node);\n    end Next;\n@@ -924,22 +949,22 @@ package body Nlists is\n    -- Next_Non_Pragma --\n    ---------------------\n \n-   function Next_Non_Pragma (Node : Node_Id) return Node_Id is\n-      N : Node_Id;\n+   function Next_Non_Pragma\n+     (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id\n+   is\n+      N : Node_Or_Entity_Id;\n \n    begin\n       N := Node;\n       loop\n          N := Next (N);\n-         exit when Nkind (N) /= N_Pragma\n-                     and then\n-                   Nkind (N) /= N_Null_Statement;\n+         exit when not Nkind_In (N, N_Pragma, N_Null_Statement);\n       end loop;\n \n       return N;\n    end Next_Non_Pragma;\n \n-   procedure Next_Non_Pragma (Node : in out Node_Id) is\n+   procedure Next_Non_Pragma (Node : in out Node_Or_Entity_Id) is\n    begin\n       Node := Next_Non_Pragma (Node);\n    end Next_Non_Pragma;\n@@ -966,10 +991,10 @@ package body Nlists is\n    -- p --\n    -------\n \n-   function p (U : Union_Id) return Node_Id is\n+   function p (U : Union_Id) return Node_Or_Entity_Id is\n    begin\n       if U in Node_Range then\n-         return Parent (Node_Id (U));\n+         return Parent (Node_Or_Entity_Id (U));\n       elsif U in List_Range then\n          return Parent (List_Id (U));\n       else\n@@ -981,7 +1006,7 @@ package body Nlists is\n    -- Parent --\n    ------------\n \n-   function Parent (List : List_Id) return Node_Id is\n+   function Parent (List : List_Id) return Node_Or_Entity_Id is\n    begin\n       pragma Assert (List <= Lists.Last);\n       return Lists.Table (List).Parent;\n@@ -991,8 +1016,8 @@ package body Nlists is\n    -- Pick --\n    ----------\n \n-   function Pick (List : List_Id; Index : Pos) return Node_Id is\n-      Elmt : Node_Id;\n+   function Pick (List : List_Id; Index : Pos) return Node_Or_Entity_Id is\n+      Elmt : Node_Or_Entity_Id;\n \n    begin\n       Elmt := First (List);\n@@ -1007,8 +1032,8 @@ package body Nlists is\n    -- Prepend --\n    -------------\n \n-   procedure Prepend (Node : Node_Id; To : List_Id) is\n-      F : constant Node_Id := First (To);\n+   procedure Prepend (Node : Node_Or_Entity_Id; To : List_Id) is\n+      F : constant Node_Or_Entity_Id := First (To);\n \n       procedure Prepend_Debug;\n       pragma Inline (Prepend_Debug);\n@@ -1088,9 +1113,9 @@ package body Nlists is\n \n       else\n          declare\n-            F : constant Node_Id := First (To);\n-            L : constant Node_Id := Last (List);\n-            N : Node_Id;\n+            F : constant Node_Or_Entity_Id := First (To);\n+            L : constant Node_Or_Entity_Id := Last (List);\n+            N : Node_Or_Entity_Id;\n \n          begin\n             pragma Debug (Prepend_List_Debug);\n@@ -1130,7 +1155,7 @@ package body Nlists is\n    -- Prepend_To --\n    ----------------\n \n-   procedure Prepend_To (To : List_Id; Node : Node_Id) is\n+   procedure Prepend_To (To : List_Id; Node : Node_Or_Entity_Id) is\n    begin\n       Prepend (Node, To);\n    end Prepend_To;\n@@ -1148,13 +1173,13 @@ package body Nlists is\n    -- Prev --\n    ----------\n \n-   function Prev (Node : Node_Id) return Node_Id is\n+   function Prev (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id is\n    begin\n       pragma Assert (Is_List_Member (Node));\n       return Prev_Node.Table (Node);\n    end Prev;\n \n-   procedure Prev (Node : in out Node_Id) is\n+   procedure Prev (Node : in out Node_Or_Entity_Id) is\n    begin\n       Node := Prev (Node);\n    end Prev;\n@@ -1172,8 +1197,10 @@ package body Nlists is\n    -- Prev_Non_Pragma --\n    ---------------------\n \n-   function Prev_Non_Pragma (Node : Node_Id) return Node_Id is\n-      N : Node_Id;\n+   function Prev_Non_Pragma\n+     (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id\n+   is\n+      N : Node_Or_Entity_Id;\n \n    begin\n       N := Node;\n@@ -1185,7 +1212,7 @@ package body Nlists is\n       return N;\n    end Prev_Non_Pragma;\n \n-   procedure Prev_Non_Pragma (Node : in out Node_Id) is\n+   procedure Prev_Non_Pragma (Node : in out Node_Or_Entity_Id) is\n    begin\n       Node := Prev_Non_Pragma (Node);\n    end Prev_Non_Pragma;\n@@ -1194,10 +1221,10 @@ package body Nlists is\n    -- Remove --\n    ------------\n \n-   procedure Remove (Node : Node_Id) is\n-      Lst : constant List_Id := List_Containing (Node);\n-      Prv : constant Node_Id := Prev (Node);\n-      Nxt : constant Node_Id := Next (Node);\n+   procedure Remove (Node : Node_Or_Entity_Id) is\n+      Lst : constant List_Id           := List_Containing (Node);\n+      Prv : constant Node_Or_Entity_Id := Prev (Node);\n+      Nxt : constant Node_Or_Entity_Id := Next (Node);\n \n       procedure Remove_Debug;\n       pragma Inline (Remove_Debug);\n@@ -1241,8 +1268,8 @@ package body Nlists is\n    -- Remove_Head --\n    -----------------\n \n-   function Remove_Head (List : List_Id) return Node_Id is\n-      Frst : constant Node_Id := First (List);\n+   function Remove_Head (List : List_Id) return Node_Or_Entity_Id is\n+      Frst : constant Node_Or_Entity_Id := First (List);\n \n       procedure Remove_Head_Debug;\n       pragma Inline (Remove_Head_Debug);\n@@ -1271,7 +1298,7 @@ package body Nlists is\n \n       else\n          declare\n-            Nxt : constant Node_Id := Next (Frst);\n+            Nxt : constant Node_Or_Entity_Id := Next (Frst);\n \n          begin\n             Set_First (List, Nxt);\n@@ -1293,8 +1320,10 @@ package body Nlists is\n    -- Remove_Next --\n    -----------------\n \n-   function Remove_Next (Node : Node_Id) return Node_Id is\n-      Nxt : constant Node_Id := Next (Node);\n+   function Remove_Next\n+     (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id\n+   is\n+      Nxt : constant Node_Or_Entity_Id := Next (Node);\n \n       procedure Remove_Next_Debug;\n       pragma Inline (Remove_Next_Debug);\n@@ -1318,8 +1347,8 @@ package body Nlists is\n    begin\n       if Present (Nxt) then\n          declare\n-            Nxt2 : constant Node_Id := Next (Nxt);\n-            LC   : constant List_Id := List_Containing (Node);\n+            Nxt2 : constant Node_Or_Entity_Id := Next (Nxt);\n+            LC   : constant List_Id           := List_Containing (Node);\n \n          begin\n             pragma Debug (Remove_Next_Debug);\n@@ -1343,7 +1372,7 @@ package body Nlists is\n    -- Set_First --\n    ---------------\n \n-   procedure Set_First (List : List_Id; To : Node_Id) is\n+   procedure Set_First (List : List_Id; To : Node_Or_Entity_Id) is\n    begin\n       Lists.Table (List).First := To;\n    end Set_First;\n@@ -1352,7 +1381,7 @@ package body Nlists is\n    -- Set_Last --\n    --------------\n \n-   procedure Set_Last (List : List_Id; To : Node_Id) is\n+   procedure Set_Last (List : List_Id; To : Node_Or_Entity_Id) is\n    begin\n       Lists.Table (List).Last := To;\n    end Set_Last;\n@@ -1361,7 +1390,7 @@ package body Nlists is\n    -- Set_List_Link --\n    -------------------\n \n-   procedure Set_List_Link (Node : Node_Id; To : List_Id) is\n+   procedure Set_List_Link (Node : Node_Or_Entity_Id; To : List_Id) is\n    begin\n       Nodes.Table (Node).Link := Union_Id (To);\n    end Set_List_Link;\n@@ -1370,7 +1399,7 @@ package body Nlists is\n    -- Set_Next --\n    --------------\n \n-   procedure Set_Next (Node : Node_Id; To : Node_Id) is\n+   procedure Set_Next (Node : Node_Or_Entity_Id; To : Node_Or_Entity_Id) is\n    begin\n       Next_Node.Table (Node) := To;\n    end Set_Next;\n@@ -1379,7 +1408,7 @@ package body Nlists is\n    -- Set_Parent --\n    ----------------\n \n-   procedure Set_Parent (List : List_Id; Node : Node_Id) is\n+   procedure Set_Parent (List : List_Id; Node : Node_Or_Entity_Id) is\n    begin\n       pragma Assert (List <= Lists.Last);\n       Lists.Table (List).Parent := Node;\n@@ -1389,7 +1418,7 @@ package body Nlists is\n    -- Set_Prev --\n    --------------\n \n-   procedure Set_Prev (Node : Node_Id; To : Node_Id) is\n+   procedure Set_Prev (Node : Node_Or_Entity_Id; To : Node_Or_Entity_Id) is\n    begin\n       Prev_Node.Table (Node) := To;\n    end Set_Prev;"}, {"sha": "10c04ed902117693f94235cdda2934d1765fe091", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 80, "deletions": 49, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,6 +49,10 @@ package Nlists is\n    --  Note: node lists can contain either nodes or entities (extended nodes)\n    --  or a mixture of nodes and extended nodes.\n \n+   function In_Same_List (N1, N2 : Node_Or_Entity_Id) return Boolean;\n+   pragma Inline (In_Same_List);\n+   --  Equivalent to List_Containing (N1) = List_Containing (N2)\n+\n    function Last_List_Id return List_Id;\n    pragma Inline (Last_List_Id);\n    --  Returns Id of last allocated list header\n@@ -70,33 +74,42 @@ package Nlists is\n    --  Used in contexts where an empty list (as opposed to an initially empty\n    --  list to be filled in) is required.\n \n-   function New_List (Node : Node_Id) return List_Id;\n+   function New_List\n+     (Node : Node_Or_Entity_Id) return List_Id;\n    --  Build a new list initially containing the given node\n \n-   function New_List (Node1, Node2 : Node_Id) return List_Id;\n+   function New_List\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id) return List_Id;\n    --  Build a new list initially containing the two given nodes\n \n-   function New_List (Node1, Node2, Node3 : Node_Id) return List_Id;\n+   function New_List\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id) return List_Id;\n    --  Build a new list initially containing the three given nodes\n \n-   function New_List (Node1, Node2, Node3, Node4 : Node_Id) return List_Id;\n-   --  Build a new list initially containing the four given nodes\n+   function New_List\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id;\n+      Node4 : Node_Or_Entity_Id) return List_Id;\n \n    function New_List\n-     (Node1 : Node_Id;\n-      Node2 : Node_Id;\n-      Node3 : Node_Id;\n-      Node4 : Node_Id;\n-      Node5 : Node_Id) return List_Id;\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id;\n+      Node4 : Node_Or_Entity_Id;\n+      Node5 : Node_Or_Entity_Id) return List_Id;\n    --  Build a new list initially containing the five given nodes\n \n    function New_List\n-     (Node1 : Node_Id;\n-      Node2 : Node_Id;\n-      Node3 : Node_Id;\n-      Node4 : Node_Id;\n-      Node5 : Node_Id;\n-      Node6 : Node_Id) return List_Id;\n+     (Node1 : Node_Or_Entity_Id;\n+      Node2 : Node_Or_Entity_Id;\n+      Node3 : Node_Or_Entity_Id;\n+      Node4 : Node_Or_Entity_Id;\n+      Node5 : Node_Or_Entity_Id;\n+      Node6 : Node_Or_Entity_Id) return List_Id;\n    --  Build a new list initially containing the six given nodes\n \n    function New_Copy_List (List : List_Id) return List_Id;\n@@ -108,12 +121,12 @@ package Nlists is\n    function New_Copy_List_Original (List : List_Id) return List_Id;\n    --  Same as New_Copy_List but copies only nodes coming from source\n \n-   function First (List : List_Id) return Node_Id;\n+   function First (List : List_Id) return Node_Or_Entity_Id;\n    pragma Inline (First);\n    --  Obtains the first element of the given node list or, if the node list\n    --  has no items or is equal to No_List, then Empty is returned.\n \n-   function First_Non_Pragma (List : List_Id) return Node_Id;\n+   function First_Non_Pragma (List : List_Id) return Node_Or_Entity_Id;\n    --  Used when dealing with a list that can contain pragmas to skip past\n    --  any initial pragmas and return the first element that is not a pragma.\n    --  If the list is empty, or if it contains only pragmas, then Empty is\n@@ -122,14 +135,14 @@ package Nlists is\n    --  This function also skips N_Null nodes which can result from rewriting\n    --  unrecognized or incorrect pragmas.\n \n-   function Last (List : List_Id) return Node_Id;\n+   function Last (List : List_Id) return Node_Or_Entity_Id;\n    pragma Inline (Last);\n    --  Obtains the last element of the given node list or, if the node list\n    --  has no items, then Empty is returned. It is an error to call Last with\n    --  a Node_Id or No_List. (No_List is not considered to be the same as an\n    --  empty node list).\n \n-   function Last_Non_Pragma (List : List_Id) return Node_Id;\n+   function Last_Non_Pragma (List : List_Id) return Node_Or_Entity_Id;\n    --  Obtains the last element of a given node list that is not a pragma.\n    --  If the list is empty, or if it contains only pragmas, then Empty is\n    --  returned. It is an error to call Last_Non_Pragma with a Node_Id or\n@@ -141,42 +154,44 @@ package Nlists is\n    --  this function with No_List (No_List is not considered to be the same\n    --  as an empty list).\n \n-   function Next (Node : Node_Id) return Node_Id;\n+   function Next (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n    pragma Inline (Next);\n    --  This function returns the next node on a node list, or Empty if Node is\n    --  the last element of the node list. The argument must be a member of a\n    --  node list.\n \n-   procedure Next (Node : in out Node_Id);\n+   procedure Next (Node : in out Node_Or_Entity_Id);\n    pragma Inline (Next);\n    --  Equivalent to Node := Next (Node);\n \n-   function Next_Non_Pragma (Node : Node_Id) return Node_Id;\n+   function Next_Non_Pragma\n+     (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n    --  This function returns the next node on a node list, skipping past any\n    --  pragmas, or Empty if there is no non-pragma entry left. The argument\n    --  must be a member of a node list. This function also skips N_Null nodes\n    --  which can result from rewriting unrecognized or incorrect pragmas.\n \n-   procedure Next_Non_Pragma (Node : in out Node_Id);\n+   procedure Next_Non_Pragma (Node : in out Node_Or_Entity_Id);\n    pragma Inline (Next_Non_Pragma);\n    --  Equivalent to Node := Next_Non_Pragma (Node);\n \n-   function Prev (Node : Node_Id) return Node_Id;\n+   function Prev (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n    pragma Inline (Prev);\n    --  This function returns the previous node on a node list, or Empty\n    --  if Node is the first element of the node list. The argument must be\n    --  a member of a node list. Note: the implementation does maintain back\n    --  pointers, so this function executes quickly in constant time.\n \n-   function Pick (List : List_Id; Index : Pos) return Node_Id;\n+   function Pick (List : List_Id; Index : Pos) return Node_Or_Entity_Id;\n    --  Given a list, picks out the Index'th entry (1 = first entry). The\n    --  caller must ensure that Index is in range.\n \n-   procedure Prev (Node : in out Node_Id);\n+   procedure Prev (Node : in out Node_Or_Entity_Id);\n    pragma Inline (Prev);\n    --  Equivalent to Node := Prev (Node);\n \n-   function Prev_Non_Pragma (Node : Node_Id) return Node_Id;\n+   function Prev_Non_Pragma\n+     (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n    pragma Inline (Prev_Non_Pragma);\n    --  This function returns the previous node on a node list, skipping any\n    --  pragmas. If Node is the first element of the list, or if the only\n@@ -185,7 +200,7 @@ package Nlists is\n    --  does maintain back pointers, so this function executes quickly in\n    --  constant time.\n \n-   procedure Prev_Non_Pragma (Node : in out Node_Id);\n+   procedure Prev_Non_Pragma (Node : in out Node_Or_Entity_Id);\n    pragma Inline (Prev_Non_Pragma);\n    --  Equivalent to Node := Prev_Non_Pragma (Node);\n \n@@ -199,23 +214,23 @@ package Nlists is\n    --  This function determines if a given list id references a node list that\n    --  contains at least one item. No_List as an argument returns False.\n \n-   function Is_List_Member (Node : Node_Id) return Boolean;\n+   function Is_List_Member (Node : Node_Or_Entity_Id) return Boolean;\n    pragma Inline (Is_List_Member);\n    --  This function determines if a given node is a member of a node list.\n    --  It is an error for Node to be Empty, or to be a node list.\n \n-   function List_Containing (Node : Node_Id) return List_Id;\n+   function List_Containing (Node : Node_Or_Entity_Id) return List_Id;\n    pragma Inline (List_Containing);\n    --  This function provides a pointer to the node list containing Node.\n    --  Node must be a member of a node list.\n \n-   procedure Append (Node : Node_Id; To : List_Id);\n+   procedure Append (Node : Node_Or_Entity_Id; To : List_Id);\n    --  Appends Node at the end of node list To. Node must be a non-empty node\n    --  that is not already a member of a node list, and To must be a\n    --  node list. An attempt to append an error node is ignored without\n    --  complaint and the list is unchanged.\n \n-   procedure Append_To (To : List_Id; Node : Node_Id);\n+   procedure Append_To (To : List_Id; Node : Node_Or_Entity_Id);\n    pragma Inline (Append_To);\n    --  Like Append, but arguments are the other way round\n \n@@ -227,56 +242,72 @@ package Nlists is\n    pragma Inline (Append_List_To);\n    --  Like Append_List, but arguments are the other way round\n \n-   procedure Insert_After (After : Node_Id; Node : Node_Id);\n+   procedure Insert_After\n+     (After : Node_Or_Entity_Id;\n+      Node  : Node_Or_Entity_Id);\n    --  Insert Node, which must be a non-empty node that is not already a\n    --  member of a node list, immediately past node After, which must be a\n    --  node that is currently a member of a node list. An attempt to insert\n    --  an error node is ignored without complaint (and the list is unchanged).\n \n-   procedure Insert_List_After (After : Node_Id; List : List_Id);\n+   procedure Insert_List_After\n+     (After : Node_Or_Entity_Id;\n+      List  : List_Id);\n    --  Inserts the entire contents of node list List immediately after node\n    --  After, which must be a member of a node list. On return, the node list\n    --  List is reset to be the empty node list.\n \n-   procedure Insert_Before (Before : Node_Id; Node : Node_Id);\n+   procedure Insert_Before\n+     (Before : Node_Or_Entity_Id;\n+      Node   : Node_Or_Entity_Id);\n    --  Insert Node, which must be a non-empty node that is not already a\n    --  member of a node list, immediately before Before, which must be a node\n    --  that is currently a member of a node list. An attempt to insert an\n    --  error node is ignored without complaint (and the list is unchanged).\n \n-   procedure Insert_List_Before (Before : Node_Id; List : List_Id);\n+   procedure Insert_List_Before\n+     (Before : Node_Or_Entity_Id;\n+      List   : List_Id);\n    --  Inserts the entire contents of node list List immediately before node\n    --  Before, which must be a member of a node list. On return, the node list\n    --  List is reset to be the empty node list.\n \n-   procedure Prepend (Node : Node_Id; To : List_Id);\n+   procedure Prepend\n+     (Node : Node_Or_Entity_Id;\n+      To   : List_Id);\n    --  Prepends Node at the start of node list To. Node must be a non-empty\n    --  node that is not already a member of a node list, and To must be a\n    --  node list. An attempt to prepend an error node is ignored without\n    --  complaint and the list is unchanged.\n \n-   procedure Prepend_To (To : List_Id; Node : Node_Id);\n+   procedure Prepend_To\n+     (To   : List_Id;\n+      Node : Node_Or_Entity_Id);\n    pragma Inline (Prepend_To);\n    --  Like Prepend, but arguments are the other way round\n \n-   procedure Prepend_List (List : List_Id; To : List_Id);\n+   procedure Prepend_List\n+     (List : List_Id;\n+      To   : List_Id);\n    --  Prepends node list List to the start of node list To. On return,\n    --  List is reset to be empty.\n \n-   procedure Prepend_List_To (To : List_Id; List : List_Id);\n+   procedure Prepend_List_To\n+     (To   : List_Id;\n+      List : List_Id);\n    pragma Inline (Prepend_List_To);\n    --  Like Prepend_List, but arguments are the other way round\n \n-   procedure Remove (Node : Node_Id);\n+   procedure Remove (Node : Node_Or_Entity_Id);\n    --  Removes Node, which must be a node that is a member of a node list,\n    --  from this node list. The contents of Node are not otherwise affected.\n \n-   function Remove_Head (List : List_Id) return Node_Id;\n+   function Remove_Head (List : List_Id) return Node_Or_Entity_Id;\n    --  Removes the head element of a node list, and returns the node (whose\n    --  contents are not otherwise affected) as the result. If the node list\n    --  is empty, then Empty is returned.\n \n-   function Remove_Next (Node : Node_Id) return Node_Id;\n+   function Remove_Next (Node : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n    --  Removes the item immediately following the given node, and returns it\n    --  as the result. If Node is the last element of the list, then Empty is\n    --  returned. Node must be a member of a list. Unlike Remove, Remove_Next\n@@ -302,13 +333,13 @@ package Nlists is\n    --  Writes out internal tables to current tree file using the relevant\n    --  Table.Tree_Write routines.\n \n-   function Parent (List : List_Id) return Node_Id;\n+   function Parent (List : List_Id) return Node_Or_Entity_Id;\n    pragma Inline (Parent);\n    --  Node lists may have a parent in the same way as a node. The function\n    --  accesses the Parent value, which is either Empty when a list header\n    --  is first created, or the value that has been set by Set_Parent.\n \n-   procedure Set_Parent (List : List_Id; Node : Node_Id);\n+   procedure Set_Parent (List : List_Id; Node : Node_Or_Entity_Id);\n    pragma Inline (Set_Parent);\n    --  Sets the parent field of the given list to reference the given node\n \n@@ -322,7 +353,7 @@ package Nlists is\n    --  Tests given Id for inequality with No_List. This allows notations like\n    --  \"if Present (Statements)\" as opposed to \"if Statements /= No_List\".\n \n-   procedure Allocate_List_Tables (N : Node_Id);\n+   procedure Allocate_List_Tables (N : Node_Or_Entity_Id);\n    --  Called when nodes table is expanded to include node N. This call\n    --  makes sure that list structures internal to Nlists are adjusted\n    --  appropriately to reflect this increase in the size of the nodes table.\n@@ -332,7 +363,7 @@ package Nlists is\n    --  These functions return the addresses of the Next_Node and Prev_Node\n    --  tables (used in Back_End for Gigi).\n \n-   function p (U : Union_Id) return Node_Id;\n+   function p (U : Union_Id) return Node_Or_Entity_Id;\n    --  This function is intended for use from the debugger, it determines\n    --  whether U is a Node_Id or List_Id, and calls the appropriate Parent\n    --  function and returns the parent Node in either case. This is shorter"}, {"sha": "d9d64d7f542c5a310a58a93ac7b0f978ecdb11f6", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -334,10 +334,10 @@ package body Ch5 is\n                when Tok_Exception =>\n                   Test_Statement_Required;\n \n-                  --  If Extm not set and the exception is not to the left\n-                  --  of the expected column of the end for this sequence, then\n-                  --  we assume it belongs to the current sequence, even though\n-                  --  it is not permitted.\n+                  --  If Extm not set and the exception is not to the left of\n+                  --  the expected column of the end for this sequence, then we\n+                  --  assume it belongs to the current sequence, even though it\n+                  --  is not permitted.\n \n                   if not SS_Flags.Extm and then\n                      Start_Column >= Scope.Table (Scope.Last).Ecol\n@@ -350,16 +350,16 @@ package body Ch5 is\n \n                   --  Always return, in the case where we scanned out handlers\n                   --  that we did not expect, Parse_Exception_Handlers returned\n-                  --  with Token being either end or EOF, so we are OK\n+                  --  with Token being either end or EOF, so we are OK.\n \n                   exit;\n \n                --  Case of OR\n \n                when Tok_Or =>\n \n-                  --  Terminate if Ortm set or if the or is to the left\n-                  --  of the expected column of the end for this sequence\n+                  --  Terminate if Ortm set or if the or is to the left of the\n+                  --  expected column of the end for this sequence.\n \n                   if SS_Flags.Ortm\n                      or else Start_Column < Scope.Table (Scope.Last).Ecol\n@@ -385,9 +385,9 @@ package body Ch5 is\n \n                   exit when SS_Flags.Tatm and then Token = Tok_Abort;\n \n-                  --  Otherwise we treat THEN as some kind of mess where we\n-                  --  did not see the associated IF, but we pick up assuming\n-                  --  it had been there!\n+                  --  Otherwise we treat THEN as some kind of mess where we did\n+                  --  not see the associated IF, but we pick up assuming it had\n+                  --  been there!\n \n                   Restore_Scan_State (Scan_State); -- to THEN\n                   Append_To (Statement_List, P_If_Statement);\n@@ -397,8 +397,8 @@ package body Ch5 is\n \n                when Tok_When | Tok_Others =>\n \n-                  --  Terminate if Whtm set or if the WHEN is to the left\n-                  --  of the expected column of the end for this sequence\n+                  --  Terminate if Whtm set or if the WHEN is to the left of\n+                  --  the expected column of the end for this sequence.\n \n                   if SS_Flags.Whtm\n                      or else Start_Column < Scope.Table (Scope.Last).Ecol"}, {"sha": "8520292ecd2612744d71998b6c3c756b7fd5796b", "filename": "gcc/ada/par-labl.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fpar-labl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fpar-labl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-labl.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -378,12 +378,10 @@ procedure Labl is\n \n                   --  If the label and the goto are both in the same statement\n                   --  list, then we've found a loop. Note that labels and goto\n-                  --  statements are always part of some list, so\n-                  --  List_Containing always makes sense.\n+                  --  statements are always part of some list, so In_Same_List\n+                  --  always makes sense.\n \n-                  if List_Containing (Node (N)) =\n-                     List_Containing (Node (S1))\n-                  then\n+                  if In_Same_List (Node (N), Node (S1)) then\n                      Source := S1;\n                      Found  := True;\n "}, {"sha": "229369edc1c9e400c4d038b60ec5a603b2be2a30", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n+with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Debug;    use Debug;\n with Fname;    use Fname;\n@@ -396,6 +397,29 @@ package body Restrict is\n       end loop;\n    end Check_Restriction_No_Dependence;\n \n+   --------------------------------------\n+   -- Check_Wide_Character_Restriction --\n+   --------------------------------------\n+\n+   procedure Check_Wide_Character_Restriction (E : Entity_Id; N : Node_Id) is\n+   begin\n+      if Restriction_Active (No_Wide_Characters)\n+        and then Comes_From_Source (N)\n+      then\n+         declare\n+            T : constant Entity_Id := Root_Type (E);\n+         begin\n+            if T = Standard_Wide_Character      or else\n+               T = Standard_Wide_String         or else\n+               T = Standard_Wide_Wide_Character or else\n+               T = Standard_Wide_Wide_String\n+            then\n+               Check_Restriction (No_Wide_Characters, N);\n+            end if;\n+         end;\n+      end if;\n+   end Check_Wide_Character_Restriction;\n+\n    ----------------------------------------\n    -- Cunit_Boolean_Restrictions_Restore --\n    ----------------------------------------"}, {"sha": "ecac63cff7d7461e487dc093c14d2df743709019", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -239,6 +239,12 @@ package Restrict is\n    --  mechanism (e.g. a special pragma) to handle this case, but there are\n    --  only six cases, and it is not worth the effort to do something general.\n \n+   procedure Check_Wide_Character_Restriction (E : Entity_Id; N : Node_Id);\n+   --  This procedure checks if the No_Wide_Character restriction is active,\n+   --  and if so, if N Comes_From_Source, and the root type of E is one of\n+   --  [Wide_]Wide_Character or [Wide_]Wide_String, then the restriction\n+   --  violation is recorded, and an appropriate message given.\n+\n    function Cunit_Boolean_Restrictions_Save\n      return Save_Cunit_Boolean_Restrictions;\n    --  This function saves the compilation unit restriction settings, and"}, {"sha": "0e9329c9185cf40660212fc4cafcfd4e3241c8cc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -2960,13 +2960,7 @@ package body Sem_Ch3 is\n \n       --  Check No_Wide_Characters restriction\n \n-      if T = Standard_Wide_Character\n-        or else T = Standard_Wide_Wide_Character\n-        or else Root_Type (T) = Standard_Wide_String\n-        or else Root_Type (T) = Standard_Wide_Wide_String\n-      then\n-         Check_Restriction (No_Wide_Characters, Object_Definition (N));\n-      end if;\n+      Check_Wide_Character_Restriction (T, Object_Definition (N));\n \n       --  Indicate this is not set in source. Certainly true for constants,\n       --  and true for variables so far (will be reset for a variable if and\n@@ -13677,8 +13671,20 @@ package body Sem_Ch3 is\n          Generate_Definition (L);\n          Set_Convention (L, Convention_Intrinsic);\n \n+         --  Case of character literal\n+\n          if Nkind (L) = N_Defining_Character_Literal then\n             Set_Is_Character_Type (T, True);\n+\n+            --  Check violation of No_Wide_Characters\n+\n+            if Restriction_Active (No_Wide_Characters) then\n+               Get_Name_String (Chars (L));\n+\n+               if Name_Len >= 3 and then Name_Buffer (1 .. 2) = \"QW\" then\n+                  Check_Restriction (No_Wide_Characters, L);\n+               end if;\n+            end if;\n          end if;\n \n          Ev := Ev + 1;\n@@ -14211,13 +14217,7 @@ package body Sem_Ch3 is\n \n       --  Check No_Wide_Characters restriction\n \n-      if Typ = Standard_Wide_Character\n-        or else Typ = Standard_Wide_Wide_Character\n-        or else Typ = Standard_Wide_String\n-        or else Typ = Standard_Wide_Wide_String\n-      then\n-         Check_Restriction (No_Wide_Characters, S);\n-      end if;\n+      Check_Wide_Character_Restriction (Typ, S);\n \n       return Typ;\n    end Find_Type_Of_Subtype_Indic;"}, {"sha": "baf53983e21d6a80af9b7cdc57865aaf7c745bd4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -1638,9 +1638,7 @@ package body Sem_Ch6 is\n \n          if Present (Prag) then\n             if Present (Spec_Id) then\n-               if List_Containing (N) =\n-                 List_Containing (Unit_Declaration_Node (Spec_Id))\n-               then\n+               if In_Same_List (N, Unit_Declaration_Node (Spec_Id)) then\n                   Analyze (Prag);\n                end if;\n \n@@ -1649,10 +1647,12 @@ package body Sem_Ch6 is\n \n                declare\n                   Subp : constant Entity_Id :=\n-                    Make_Defining_Identifier (Loc, Chars (Body_Id));\n+                           Make_Defining_Identifier (Loc, Chars (Body_Id));\n                   Decl : constant Node_Id :=\n-                    Make_Subprogram_Declaration (Loc,\n-                      Specification =>  New_Copy_Tree (Specification (N)));\n+                           Make_Subprogram_Declaration (Loc,\n+                             Specification =>\n+                               New_Copy_Tree (Specification (N)));\n+\n                begin\n                   Set_Defining_Unit_Name (Specification (Decl), Subp);\n \n@@ -7993,9 +7993,7 @@ package body Sem_Ch6 is\n                        (\"equality operator must be declared \"\n                          & \"before type& is frozen\", S, Typ);\n \n-                  elsif List_Containing (Parent (Typ))\n-                          /=\n-                        List_Containing (Decl)\n+                  elsif not In_Same_List (Parent (Typ), Decl)\n                     and then not Is_Limited_Type (Typ)\n                   then\n                      Error_Msg_N"}, {"sha": "ef72d3f8489c281f68adc16ae8de389edd9aa541", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -454,8 +454,9 @@ package body Sem_Ch8 is\n    --  private with on E.\n \n    procedure Find_Expanded_Name (N : Node_Id);\n-   --  Selected component is known to be expanded name. Verify legality of\n-   --  selector given the scope denoted by prefix.\n+   --  The input is a selected component is known to be expanded name. Verify\n+   --  legality of selector given the scope denoted by prefix, and change node\n+   --  N into a expanded name with a properly set Entity field.\n \n    function Find_Renamed_Entity\n      (N         : Node_Id;\n@@ -4411,6 +4412,10 @@ package body Sem_Ch8 is\n \n       <<Found>> begin\n \n+         --  Check violation of No_Wide_Characters restriction\n+\n+         Check_Wide_Character_Restriction (E, N);\n+\n          --  When distribution features are available (Get_PCS_Name /=\n          --  Name_No_DSA), a remote access-to-subprogram type is converted\n          --  into a record type holding whatever information is needed to\n@@ -4960,6 +4965,10 @@ package body Sem_Ch8 is\n          Set_Etype (N, Get_Full_View (Etype (Id)));\n       end if;\n \n+      --  Check for violation of No_Wide_Characters\n+\n+      Check_Wide_Character_Restriction (Id, N);\n+\n       --  If the Ekind of the entity is Void, it means that all homonyms are\n       --  hidden from all visibility (RM 8.3(5,14-20)).\n \n@@ -7330,8 +7339,8 @@ package body Sem_Ch8 is\n               and then Scope (Id) /= Scope (Prev)\n               and then Used_As_Generic_Actual (Scope (Prev))\n               and then Used_As_Generic_Actual (Scope (Id))\n-              and then List_Containing (Current_Use_Clause (Scope (Prev))) /=\n-                       List_Containing (Current_Use_Clause (Scope (Id)))\n+              and then not In_Same_List (Current_Use_Clause (Scope (Prev)),\n+                                         Current_Use_Clause (Scope (Id)))\n             then\n                Set_Is_Potentially_Use_Visible (Prev, False);\n                Append_Elmt (Prev, Hidden_By_Use_Clause (N));"}, {"sha": "12d1327b3c20ab15f02b5eaa4f33ec2f782eba02", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30196a76d1266055da06c42a6679c5487cde4676/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=30196a76d1266055da06c42a6679c5487cde4676", "patch": "@@ -1866,6 +1866,7 @@ package body Sem_Type is\n             then\n                declare\n                   Opnd : Node_Id;\n+\n                begin\n                   if Nkind (N) = N_Function_Call then\n                      Opnd := First_Actual (N);\n@@ -1875,8 +1876,8 @@ package body Sem_Type is\n \n                   if Ekind (Etype (Opnd)) = E_Anonymous_Access_Type\n                     and then\n-                      List_Containing (Parent (Designated_Type (Etype (Opnd))))\n-                        = List_Containing (Unit_Declaration_Node (User_Subp))\n+                      In_Same_List (Parent (Designated_Type (Etype (Opnd))),\n+                                    Unit_Declaration_Node (User_Subp))\n                   then\n                      if It2.Nam = Predef_Subp then\n                         return It1;"}]}