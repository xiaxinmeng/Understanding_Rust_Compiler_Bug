{"sha": "8110ee3b6349ae4b1a369996a25161dc6a0f067e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODExMGVlM2I2MzQ5YWU0YjFhMzY5OTk2YTI1MTYxZGM2YTBmMDY3ZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-10-22T09:19:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T09:19:51Z"}, "message": "checks.adb (Apply_Predicate_Check): Remove attempt at optimization when subtype is the same...\n\n2010-10-22  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Predicate_Check): Remove attempt at optimization\n\twhen subtype is the same, caused legitimate checks to be missed.\n\t* exp_ch13.adb (Build_Predicate_Function): Use Nearest_Ancestor to get\n\tinheritance from right entity.\n\t* freeze.adb (Freeze_Entity): Use Nearest_Ancestor to freeze in the\n\tderived type case if the ancestor type has predicates.\n\t* sem_aux.ads, sem_aux.adb (Nearest_Ancestor): New function.\n\t* sem_prag.adb (Check_Enabled): Minor code reorganization.\n\nFrom-SVN: r165807", "tree": {"sha": "fb2dd57e04140daa06885584791bb5dbdce45d10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb2dd57e04140daa06885584791bb5dbdce45d10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8110ee3b6349ae4b1a369996a25161dc6a0f067e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8110ee3b6349ae4b1a369996a25161dc6a0f067e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8110ee3b6349ae4b1a369996a25161dc6a0f067e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8110ee3b6349ae4b1a369996a25161dc6a0f067e/comments", "author": null, "committer": null, "parents": [{"sha": "ca8e13e8554d22976e5afa8a73aab6531976486a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8e13e8554d22976e5afa8a73aab6531976486a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8e13e8554d22976e5afa8a73aab6531976486a"}], "stats": {"total": 150, "additions": 117, "deletions": 33}, "files": [{"sha": "ff1fba1b558d872e15f59c81a17aff36aa4936f8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -1,3 +1,14 @@\n+2010-10-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Predicate_Check): Remove attempt at optimization\n+\twhen subtype is the same, caused legitimate checks to be missed.\n+\t* exp_ch13.adb (Build_Predicate_Function): Use Nearest_Ancestor to get\n+\tinheritance from right entity.\n+\t* freeze.adb (Freeze_Entity): Use Nearest_Ancestor to freeze in the\n+\tderived type case if the ancestor type has predicates.\n+\t* sem_aux.ads, sem_aux.adb (Nearest_Ancestor): New function.\n+\t* sem_prag.adb (Check_Enabled): Minor code reorganization.\n+\n 2010-10-22  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/utils.c, gcc-interface/gigi.h: Minor reformatting."}, {"sha": "17b9fcb9eb3f61b699598ae9f615b4f1dce99c4a", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -1759,9 +1759,7 @@ package body Checks is\n \n    procedure Apply_Predicate_Check (N : Node_Id; Typ : Entity_Id) is\n    begin\n-      if Etype (N) /= Typ\n-        and then Present (Predicate_Function (Typ))\n-      then\n+      if Present (Predicate_Function (Typ)) then\n          Insert_Action (N,\n            Make_Predicate_Check (Typ, Duplicate_Subexpr (N)));\n       end if;"}, {"sha": "4580ec2d0df8fc154dd1f45ce0f93c632dfcdc4e", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -152,7 +152,7 @@ package body Exp_Ch13 is\n             if Opt.List_Inherited_Aspects then\n                Error_Msg_Sloc := Sloc (Predicate_Function (T));\n                Error_Msg_Node_2 := T;\n-               Error_Msg_N (\"?info: & inherits predicate from & at #\", Typ);\n+               Error_Msg_N (\"?info: & inherits predicate from & #\", Typ);\n             end if;\n          end if;\n       end Add_Call;\n@@ -272,21 +272,13 @@ package body Exp_Ch13 is\n \n       Add_Predicates;\n \n-      --  Deal with ancestor subtype and parent type\n+      --  Add predicates for ancestor if present\n \n       declare\n-         Atyp : constant Entity_Id := Ancestor_Subtype (Typ);\n-\n+         Atyp : constant Entity_Id := Nearest_Ancestor (Typ);\n       begin\n-         --  If ancestor subtype present, add its predicates\n-\n          if Present (Atyp) then\n             Add_Call (Atyp);\n-\n-         --  Else if this is derived, add predicates of parent type\n-\n-         elsif Is_Derived_Type (Typ) then\n-            Add_Call (Etype (Base_Type (Typ)));\n          end if;\n       end;\n "}, {"sha": "e9c715ef2b14fa813d6b0a62743ea836f578c460", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -3096,18 +3096,31 @@ package body Freeze is\n             end if;\n \n             --  If ancestor subtype present, freeze that first. Note that this\n-            --  will also get the base type frozen.\n+            --  will also get the base type frozen. Need RM reference ???\n \n             Atype := Ancestor_Subtype (E);\n \n             if Present (Atype) then\n                Freeze_And_Append (Atype, N, Result);\n \n-            --  Otherwise freeze the base type of the entity before freezing\n-            --  the entity itself (RM 13.14(15)).\n+            --  No ancestor subtype present\n \n-            elsif E /= Base_Type (E) then\n-               Freeze_And_Append (Base_Type (E), N, Result);\n+            else\n+               --  See if we have a nearest ancestor that has a predicate.\n+               --  That catches the case of derived type with a predicate.\n+               --  Need RM reference here ???\n+\n+               Atype := Nearest_Ancestor (E);\n+\n+               if Present (Atype) and then Has_Predicates (Atype) then\n+                  Freeze_And_Append (Atype, N, Result);\n+               end if;\n+\n+               --  Freeze base type before freezing the entity (RM 13.14(15))\n+\n+               if E /= Base_Type (E) then\n+                  Freeze_And_Append (Base_Type (E), N, Result);\n+               end if;\n             end if;\n \n          --  For a derived type, freeze its parent type first (RM 13.14(15))"}, {"sha": "ee23d17c5295b29654d2050e54b94577f7cac756", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -749,6 +749,46 @@ package body Sem_Aux is\n       end if;\n    end Is_Limited_Type;\n \n+   ----------------------\n+   -- Nearest_Ancestor --\n+   ----------------------\n+\n+   function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id is\n+         D : constant Node_Id := Declaration_Node (Typ);\n+\n+   begin\n+      --  If we have a subtype declaration, get the ancestor subtype\n+\n+      if Nkind (D) = N_Subtype_Declaration then\n+         if Nkind (Subtype_Indication (D)) = N_Subtype_Indication then\n+            return Entity (Subtype_Mark (Subtype_Indication (D)));\n+         else\n+            return Entity (Subtype_Indication (D));\n+         end if;\n+\n+      --  If derived type declaration, find who we are derived from\n+\n+      elsif Nkind (D) = N_Full_Type_Declaration\n+        and then Nkind (Type_Definition (D)) = N_Derived_Type_Definition\n+      then\n+         declare\n+            DTD : constant Entity_Id := Type_Definition (D);\n+            SI  : constant Entity_Id := Subtype_Indication (DTD);\n+         begin\n+            if Is_Entity_Name (SI) then\n+               return Entity (SI);\n+            else\n+               return Entity (Subtype_Mark (SI));\n+            end if;\n+         end;\n+\n+      --  Otherwise, nothing useful to return, return Empty\n+\n+      else\n+         return Empty;\n+      end if;\n+   end Nearest_Ancestor;\n+\n    ---------------------------\n    -- Nearest_Dynamic_Scope --\n    ---------------------------"}, {"sha": "8ef11ec8a7ad45434fcc883a80d19041797fe2bf", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -181,6 +181,24 @@ package Sem_Aux is\n    --  composite containing a limited component, or a subtype of any of\n    --  these types).\n \n+   function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id;\n+   --  Given a subtype Typ, this function finds out the nearest ancestor from\n+   --  which constraints and predicates are inherited. There is no simple link\n+   --  for doing this, consider:\n+   --\n+   --     subtype R is Integer range 1 .. 10;\n+   --     type T is new R;\n+   --\n+   --  In this case the nearest ancestor is R, but the Etype of T'Base will\n+   --  point to R'Base, so we have to go rummaging in the declarations to get\n+   --  this information. It is used for making sure we freeze this before we\n+   --  freeze Typ, and also for retrieving inherited predicate information.\n+   --  For the case of base types or first subtypes, there is no useful entity\n+   --  to return, so Empty is returned.\n+   --\n+   --  Note: this is similar to Ancestor_Subtype except that it also deals\n+   --  with the case of derived types.\n+\n    function Nearest_Dynamic_Scope (Ent : Entity_Id) return Entity_Id;\n    --  This is similar to Enclosing_Dynamic_Scope except that if Ent is itself\n    --  a dynamic scope, then it is returned. Otherwise the result is the same"}, {"sha": "78bebfc7e9230b4272f56b9e1c3d9e1d17e8fbef", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8110ee3b6349ae4b1a369996a25161dc6a0f067e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8110ee3b6349ae4b1a369996a25161dc6a0f067e", "patch": "@@ -13696,27 +13696,39 @@ package body Sem_Prag is\n       PP : Node_Id;\n \n    begin\n+      --  Loop through entries in check policy list\n+\n       PP := Opt.Check_Policy_List;\n       loop\n+         --  If there are no specific entries that matched, then we let the\n+         --  setting of assertions govern. Note that this provides the needed\n+         --  compatibility with the RM for the cases of assertion, invariant,\n+         --  precondition, predicate, and postcondition.\n+\n          if No (PP) then\n             return Assertions_Enabled;\n \n-         elsif\n-           Nam = Chars (Expression (First (Pragma_Argument_Associations (PP))))\n-         then\n-            case\n-              Chars (Expression (Last (Pragma_Argument_Associations (PP))))\n-            is\n-            when Name_On | Name_Check =>\n-               return True;\n-            when Name_Off | Name_Ignore =>\n-               return False;\n-            when others =>\n-               raise Program_Error;\n-            end case;\n+         --  Here we have an entry see if it matches\n \n          else\n-            PP := Next_Pragma (PP);\n+            declare\n+               PPA : constant List_Id := Pragma_Argument_Associations (PP);\n+\n+            begin\n+               if Nam = Chars (Get_Pragma_Arg (First (PPA))) then\n+                  case (Chars (Get_Pragma_Arg (Last (PPA)))) is\n+                     when Name_On | Name_Check =>\n+                        return True;\n+                     when Name_Off | Name_Ignore =>\n+                        return False;\n+                     when others =>\n+                        raise Program_Error;\n+                  end case;\n+\n+               else\n+                  PP := Next_Pragma (PP);\n+               end if;\n+            end;\n          end if;\n       end loop;\n    end Check_Enabled;"}]}