{"sha": "bb033fd8060e36e8bafdebec388e5fa91d073d61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIwMzNmZDgwNjBlMzZlOGJhZmRlYmVjMzg4ZTVmYTkxZDA3M2Q2MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-20T18:43:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-20T18:43:30Z"}, "message": "predict.c (return_prediction): New function.\n\n\t* predict.c (return_prediction): New function.\n\t(apply_return_prediction): Likewise.\n\t(tree_bb_level_predictions): Likewise.\n\t(tree_estimate_probability): Add noreturn exit edges; call\n\tbb_level_predictions; fix logic of return heuristics.\n\t(predict_paths_leading_to):  Rescuesce from old CVS version of\n\tprocess_note_prediction function.\n\t* predict.def (PRED_TREE_EARLY_RETURN): New predictor.\n\nFrom-SVN: r87768", "tree": {"sha": "adf52de249bf13af0d4b65ddb438bf8e22d50b62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf52de249bf13af0d4b65ddb438bf8e22d50b62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb033fd8060e36e8bafdebec388e5fa91d073d61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb033fd8060e36e8bafdebec388e5fa91d073d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb033fd8060e36e8bafdebec388e5fa91d073d61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb033fd8060e36e8bafdebec388e5fa91d073d61/comments", "author": null, "committer": null, "parents": [{"sha": "348f5701fc7bfeeaf8f6ccb2b7894b0b41feae4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348f5701fc7bfeeaf8f6ccb2b7894b0b41feae4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348f5701fc7bfeeaf8f6ccb2b7894b0b41feae4f"}], "stats": {"total": 245, "additions": 234, "deletions": 11}, "files": [{"sha": "1f0ddd6c6a306bc6e6f43448df62d664fc48995c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb033fd8060e36e8bafdebec388e5fa91d073d61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb033fd8060e36e8bafdebec388e5fa91d073d61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb033fd8060e36e8bafdebec388e5fa91d073d61", "patch": "@@ -1,3 +1,14 @@\n+2004-09-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (return_prediction): New function.\n+\t(apply_return_prediction): Likewise.\n+\t(tree_bb_level_predictions): Likewise.\n+\t(tree_estimate_probability): Add noreturn exit edges; call\n+\tbb_level_predictions; fix logic of return heuristics.\n+\t(predict_paths_leading_to):  Rescuesce from old CVS version of\n+\tprocess_note_prediction function.\n+\t* predict.def (PRED_TREE_EARLY_RETURN): New predictor.\n+\n 2004-09-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.c (s390_frame_info): Added alignment statement for"}, {"sha": "7eaee34d2eb209faa9b862a0de40742da8f056d0", "filename": "gcc/predict.c", "status": "modified", "additions": 222, "deletions": 11, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb033fd8060e36e8bafdebec388e5fa91d073d61/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb033fd8060e36e8bafdebec388e5fa91d073d61/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=bb033fd8060e36e8bafdebec388e5fa91d073d61", "patch": "@@ -77,6 +77,7 @@ static void estimate_loops_at_level (struct loop *loop);\n static void propagate_freq (struct loop *);\n static void estimate_bb_frequencies (struct loops *);\n static int counts_to_freqs (void);\n+static void predict_paths_leading_to (basic_block, int *, enum br_predictor, enum prediction);\n static bool last_basic_block_p (basic_block);\n static void compute_function_frequency (void);\n static void choose_function_section (void);\n@@ -1119,6 +1120,152 @@ tree_predict_by_opcode (basic_block bb)\n       }\n }\n \n+/* Try to guess whether the value of return means error code.  */\n+static enum br_predictor\n+return_prediction (tree val, enum prediction *prediction)\n+{\n+  /* VOID.  */\n+  if (!val)\n+    return PRED_NO_PREDICTION;\n+  /* Different heuristics for pointers and scalars.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (val)))\n+    {\n+      /* NULL is usually not returned.  */\n+      if (integer_zerop (val))\n+\t{\n+\t  *prediction = NOT_TAKEN;\n+\t  return PRED_NULL_RETURN;\n+\t}\n+    }\n+  else if (INTEGRAL_TYPE_P (TREE_TYPE (val)))\n+    {\n+      /* Negative return values are often used to indicate\n+         errors.  */\n+      if (TREE_CODE (val) == INTEGER_CST\n+\t  && tree_int_cst_sgn (val) < 0)\n+\t{\n+\t  *prediction = NOT_TAKEN;\n+\t  return PRED_NEGATIVE_RETURN;\n+\t}\n+      /* Constant return values seems to be commonly taken.\n+         Zero/one often represent booleans so exclude them from the\n+\t heuristics.  */\n+      if (TREE_CONSTANT (val)\n+\t  && (!integer_zerop (val) && !integer_onep (val)))\n+\t{\n+\t  *prediction = TAKEN;\n+\t  return PRED_NEGATIVE_RETURN;\n+\t}\n+    }\n+  return PRED_NO_PREDICTION;\n+}\n+\n+/* Find the basic block with return expression and look up for possible\n+   return value trying to apply RETURN_PREDICTION heuristics.  */\n+static void\n+apply_return_prediction (int *heads)\n+{\n+  tree return_stmt;\n+  tree return_val;\n+  edge e;\n+  tree phi;\n+  int phi_num_args, i;\n+  enum br_predictor pred;\n+  enum prediction direction;\n+\n+  for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+    {\n+      return_stmt = last_stmt (e->src);\n+      if (TREE_CODE (return_stmt) == RETURN_EXPR)\n+\tbreak;\n+    }\n+  if (!e)\n+    return;\n+  return_val = TREE_OPERAND (return_stmt, 0);\n+  if (!return_val)\n+    return;\n+  if (TREE_CODE (return_val) == MODIFY_EXPR)\n+    return_val = TREE_OPERAND (return_val, 1);\n+  if (TREE_CODE (return_val) != SSA_NAME\n+      || !SSA_NAME_DEF_STMT (return_val)\n+      || TREE_CODE (SSA_NAME_DEF_STMT (return_val)) != PHI_NODE)\n+    return;\n+  phi = SSA_NAME_DEF_STMT (return_val);\n+  while (phi)\n+    {\n+      tree next = PHI_CHAIN (phi);\n+      if (PHI_RESULT (phi) == return_val)\n+\tbreak;\n+      phi = next;\n+    }\n+  if (!phi)\n+    return;\n+  phi_num_args = PHI_NUM_ARGS (phi);\n+  pred = return_prediction (PHI_ARG_DEF (phi, 0), &direction);\n+\n+  /* Avoid the degenerate case where all return values form the function\n+     belongs to same category (ie they are all positive constants)\n+     so we can hardly say something about them.  */\n+  for (i = 1; i < phi_num_args; i++)\n+    if (pred != return_prediction (PHI_ARG_DEF (phi, i), &direction))\n+      break;\n+  if (i != phi_num_args)\n+    for (i = 0; i < phi_num_args; i++)\n+      {\n+\tpred = return_prediction (PHI_ARG_DEF (phi, i), &direction);\n+\tif (pred != PRED_NO_PREDICTION)\n+\t  predict_paths_leading_to (PHI_ARG_EDGE (phi, i)->src, heads, pred,\n+\t\t\t\t    direction);\n+      }\n+}\n+\n+/* Look for basic block that contains unlikely to happen events\n+   (such as noreturn calls) and mark all paths leading to execution\n+   of this basic blocks as unlikely.  */\n+\n+static void\n+tree_bb_level_predictions (void)\n+{\n+  basic_block bb;\n+  int *heads;\n+\n+  heads = xmalloc (sizeof (int) * last_basic_block);\n+  memset (heads, -1, sizeof (int) * last_basic_block);\n+  heads[ENTRY_BLOCK_PTR->next_bb->index] = last_basic_block;\n+\n+  apply_return_prediction (heads);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi = bsi_last (bb);\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  switch (TREE_CODE (stmt))\n+\t    {\n+\t      case MODIFY_EXPR:\n+\t\tif (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n+\t\t  {\n+\t\t    stmt = TREE_OPERAND (stmt, 1);\n+\t\t    goto call_expr;\n+\t\t  }\n+\t\tbreak;\n+\t      case CALL_EXPR:\n+call_expr:;\n+\t\tif (call_expr_flags (stmt) & ECF_NORETURN)\n+\t\t  predict_paths_leading_to (bb, heads, PRED_NORETURN,\n+\t\t      \t\t\t    NOT_TAKEN);\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+\n+  free (heads);\n+}\n+\n /* Predict branch probabilities and estimate profile of the tree CFG.  */\n static void\n tree_estimate_probability (void)\n@@ -1130,10 +1277,13 @@ tree_estimate_probability (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     flow_loops_dump (&loops_info, dump_file, NULL, 0);\n \n+  add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n+  tree_bb_level_predictions ();\n+\n   predict_loops (&loops_info, false);\n \n   FOR_EACH_BB (bb)\n@@ -1143,18 +1293,23 @@ tree_estimate_probability (void)\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  /* Predict early returns to be probable, as we've already taken\n-\t     care for error returns and other are often used for fast paths\n-\t     trought function.  */\n-\t  if ((e->dest == EXIT_BLOCK_PTR\n-\t       || (e->dest->succ && !e->dest->succ->succ_next\n-\t\t   && e->dest->succ->dest == EXIT_BLOCK_PTR))\n-\t       && !predicted_by_p (bb, PRED_NULL_RETURN)\n-\t       && !predicted_by_p (bb, PRED_CONST_RETURN)\n-\t       && !predicted_by_p (bb, PRED_NEGATIVE_RETURN)\n-\t       && !last_basic_block_p (e->dest))\n-\t    predict_edge_def (e, PRED_EARLY_RETURN, TAKEN);\n+\t     care for error returns and other cases are often used for\n+\t     fast paths trought function.  */\n+\t  if (e->dest == EXIT_BLOCK_PTR\n+\t      && TREE_CODE (last_stmt (bb)) == RETURN_EXPR\n+\t      && bb->pred && bb->pred->pred_next)\n+\t    {\n+\t      edge e1;\n+\n+\t      for (e1 = bb->pred; e1; e1 = e1->pred_next)\n+\t      \tif (!predicted_by_p (e1->src, PRED_NULL_RETURN)\n+\t\t    && !predicted_by_p (e1->src, PRED_CONST_RETURN)\n+\t\t    && !predicted_by_p (e1->src, PRED_NEGATIVE_RETURN)\n+\t\t    && !last_basic_block_p (e1->src))\n+\t\t  predict_edge_def (e1, PRED_TREE_EARLY_RETURN, NOT_TAKEN);\n+\t    }\n \n-\t  /* Look for block we are guarding (i.e. we dominate it,\n+\t  /* Look for block we are guarding (ie we dominate it,\n \t     but it doesn't postdominate us).  */\n \t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n \t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n@@ -1287,6 +1442,62 @@ last_basic_block_p (basic_block bb)\n \t      && bb->succ && !bb->succ->succ_next\n \t      && bb->succ->dest->next_bb == EXIT_BLOCK_PTR));\n }\n+\n+/* Sets branch probabilities according to PREDiction and\n+   FLAGS. HEADS[bb->index] should be index of basic block in that we\n+   need to alter branch predictions (i.e. the first of our dominators\n+   such that we do not post-dominate it) (but we fill this information\n+   on demand, so -1 may be there in case this was not needed yet).  */\n+\n+static void\n+predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n+\t\t\t  enum prediction taken)\n+{\n+  edge e;\n+  int y;\n+\n+  if (heads[bb->index] < 0)\n+    {\n+      /* This is first time we need this field in heads array; so\n+         find first dominator that we do not post-dominate (we are\n+         using already known members of heads array).  */\n+      basic_block ai = bb;\n+      basic_block next_ai = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      int head;\n+\n+      while (heads[next_ai->index] < 0)\n+\t{\n+\t  if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n+\t    break;\n+\t  heads[next_ai->index] = ai->index;\n+\t  ai = next_ai;\n+\t  next_ai = get_immediate_dominator (CDI_DOMINATORS, next_ai);\n+\t}\n+      if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n+\thead = next_ai->index;\n+      else\n+\thead = heads[next_ai->index];\n+      while (next_ai != bb)\n+\t{\n+\t  next_ai = ai;\n+\t  if (heads[ai->index] == ENTRY_BLOCK)\n+\t    ai = ENTRY_BLOCK_PTR;\n+\t  else\n+\t    ai = BASIC_BLOCK (heads[ai->index]);\n+\t  heads[next_ai->index] = head;\n+\t}\n+    }\n+  y = heads[bb->index];\n+\n+  /* Now find the edge that leads to our branch and aply the prediction.  */\n+\n+  if (y == last_basic_block)\n+    return;\n+  for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n+    if (e->dest->index >= 0\n+\t&& dominated_by_p (CDI_POST_DOMINATORS, e->dest, bb))\n+      predict_edge_def (e, pred, taken);\n+}\n \f\n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */"}, {"sha": "f469b34c4f86ba65b30f979828d250c07b53bf08", "filename": "gcc/predict.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb033fd8060e36e8bafdebec388e5fa91d073d61/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb033fd8060e36e8bafdebec388e5fa91d073d61/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=bb033fd8060e36e8bafdebec388e5fa91d073d61", "patch": "@@ -104,6 +104,7 @@ DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (70), 0)\n \n /* Branch causing function to terminate is probably not taken.  */\n DEF_PREDICTOR (PRED_EARLY_RETURN, \"early return\", HITRATE (67), 0)\n+DEF_PREDICTOR (PRED_TREE_EARLY_RETURN, \"early return (on trees)\", HITRATE (67), 0)\n \n /* Branch containing goto is probably not taken.  */\n DEF_PREDICTOR (PRED_GOTO, \"goto\", HITRATE (70), 0)"}]}