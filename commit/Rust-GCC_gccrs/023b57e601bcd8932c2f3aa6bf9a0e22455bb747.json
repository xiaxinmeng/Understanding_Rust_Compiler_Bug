{"sha": "023b57e601bcd8932c2f3aa6bf9a0e22455bb747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIzYjU3ZTYwMWJjZDg5MzJjMmYzYWE2YmY5YTBlMjI0NTViYjc0Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-01T20:29:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-01T20:29:40Z"}, "message": "(expand_fixup): Create a BLOCK node (via pushlevel/poplevel) to represent an...\n\n(expand_fixup):  Create a BLOCK node (via pushlevel/poplevel)\nto represent an artificial scope containing all of the fixup code.\nAlso emit NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END for that block.\n(fixup_gotos):  Declaration of NEWBLOCK deleted.\nCall `set_block' to use the BLOCK made in expand_fixup.\nDeleted code to insert NEWBLOCK into block hierarchy.\n\nFrom-SVN: r2014", "tree": {"sha": "1ef81df79195e4e12ec5ad4656f309cf109da5b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ef81df79195e4e12ec5ad4656f309cf109da5b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/023b57e601bcd8932c2f3aa6bf9a0e22455bb747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/023b57e601bcd8932c2f3aa6bf9a0e22455bb747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/023b57e601bcd8932c2f3aa6bf9a0e22455bb747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/023b57e601bcd8932c2f3aa6bf9a0e22455bb747/comments", "author": null, "committer": null, "parents": [{"sha": "498ee10c6a1a15f8b06cafa63ef925b6f81e12c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ee10c6a1a15f8b06cafa63ef925b6f81e12c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ee10c6a1a15f8b06cafa63ef925b6f81e12c3"}], "stats": {"total": 43, "additions": 33, "deletions": 10}, "files": [{"sha": "911cb75e0267215cb09f42c56bc71f46f0bf7e93", "filename": "gcc/stmt.c", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/023b57e601bcd8932c2f3aa6bf9a0e22455bb747/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/023b57e601bcd8932c2f3aa6bf9a0e22455bb747/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=023b57e601bcd8932c2f3aa6bf9a0e22455bb747", "patch": "@@ -742,8 +742,11 @@ expand_goto_internal (body, label, last_insn)\n    If LAST_INSN is nonzero, we pretend that the jump appears\n    after insn LAST_INSN instead of at the current point in the insn stream.\n \n-   The fixup will be used later to insert insns at this point\n-   to restore the stack level as appropriate for the target label.\n+   The fixup will be used later to insert insns just before the goto.\n+   Those insns will restore the stack level as appropriate for the\n+   target label, and will (in the case of C++) also invoke any object\n+   destructors which have to be invoked when we exit the scopes which\n+   are exited by the goto.\n \n    Value is nonzero if a fixup is made.  */\n \n@@ -820,10 +823,30 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t someone does it!  */\n       if (last_insn == 0)\n \tdo_pending_stack_adjust ();\n-      fixup->before_jump = last_insn ? last_insn : get_last_insn ();\n       fixup->target = tree_label;\n       fixup->target_rtl = rtl_label;\n-      fixup->context = current_block ();\n+\n+      /* Create a BLOCK node and a corresponding matched set of\n+\t NOTE_INSN_BEGIN_BLOCK and NOTE_INSN_END_BLOCK notes at\n+\t this point.  The notes will encapsulate any and all fixup\n+\t code which we might later insert at this point in the insn\n+\t stream.  Also, the BLOCK node will be the parent (i.e. the\n+\t `SUPERBLOCK') of any other BLOCK nodes which we might create\n+\t later on when we are expanding the fixup code.  */\n+\n+      {\n+        register rtx original_before_jump\n+          = last_insn ? last_insn : get_last_insn ();\n+\n+        start_sequence ();\n+        pushlevel (0);\n+        fixup->before_jump = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+        last_block_end_note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+        fixup->context = poplevel (1, 0, 0);  /* Create the BLOCK node now! */\n+        end_sequence ();\n+        emit_insns_after (fixup->before_jump, original_before_jump);\n+      }\n+\n       fixup->block_start_count = block_start_count;\n       fixup->stack_level = 0;\n       fixup->cleanup_list_list\n@@ -885,7 +908,6 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n       else if (PREV_INSN (f->target_rtl) != 0)\n \t{\n \t  register rtx cleanup_insns;\n-\t  tree newblock;\n \n \t  /* Get the first non-label after the label\n \t     this goto jumps to.  If that's before this scope begins,\n@@ -921,7 +943,12 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \n \t  start_sequence ();\n \n+\t  /* Temporarily restore the lexical context where we will\n+\t     logically be inserting the fixup code.  We do this for the\n+\t     sake of getting the debugging information right.  */\n+\n \t  pushlevel (0);\n+\t  set_block (f->context);\n \n \t  /* Expand the cleanups for blocks this jump exits.  */\n \t  if (f->cleanup_list_list)\n@@ -955,15 +982,11 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t     destructed are still \"in scope\".  */\n \n \t  cleanup_insns = get_insns ();\n-\t  newblock = poplevel (1, 0, 0);\n+\t  poplevel (1, 0, 0);\n \n \t  end_sequence ();\n \t  emit_insns_after (cleanup_insns, f->before_jump);\n \n-\t  /* Put the new block into its proper context.  */\n-\t  BLOCK_SUBBLOCKS (f->context) \n-\t    = chainon (BLOCK_SUBBLOCKS (f->context), newblock);\n-\t  BLOCK_SUPERCONTEXT (newblock) = f->context;\n \n \t  f->before_jump = 0;\n \t}"}]}