{"sha": "9932d281eb4d2accb93069667addc2172c9b3129", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkzMmQyODFlYjRkMmFjY2I5MzA2OTY2N2FkZGMyMTcyYzliMzEyOQ==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-04-15T12:22:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-15T12:22:03Z"}, "message": "errfn.c: Rework to avoid problems when HOST_WIDE_INT is longer than a pointer.\n\n        * errfn.c: Rework to avoid problems when HOST_WIDE_INT is longer\n        than a pointer.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r19226", "tree": {"sha": "381bb5c0ebe1ad1d8ab54ef2938d7b262eaac580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381bb5c0ebe1ad1d8ab54ef2938d7b262eaac580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9932d281eb4d2accb93069667addc2172c9b3129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9932d281eb4d2accb93069667addc2172c9b3129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9932d281eb4d2accb93069667addc2172c9b3129", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9932d281eb4d2accb93069667addc2172c9b3129/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2872409d73c41967affd9d30d37d1d5f20a0bbbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2872409d73c41967affd9d30d37d1d5f20a0bbbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2872409d73c41967affd9d30d37d1d5f20a0bbbb"}], "stats": {"total": 262, "additions": 155, "deletions": 107}, "files": [{"sha": "dde9817261f865a0b8ebedcf0e55b2f47254d565", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9932d281eb4d2accb93069667addc2172c9b3129/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9932d281eb4d2accb93069667addc2172c9b3129/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9932d281eb4d2accb93069667addc2172c9b3129", "patch": "@@ -1,3 +1,9 @@\n+Wed Apr 15 13:20:06 1998  John Carr  <jfc@mit.edu>\n+\t\t\t  Jeff Law   <law@cygnus.com>\n+\n+\t* errfn.c: Rework to avoid problems when HOST_WIDE_INT is longer\n+\tthan a pointer.\n+\n Fri Apr 10 12:16:49 1998  Benjamin Kosnik  <bkoz@loony.cygnus.com>\n \n \t* decl.c (duplicate_decls): Don't warn for redundant decls if"}, {"sha": "0bb67a34e4522cd28de5aeaf93e624b63f25be9b", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 149, "deletions": 107, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9932d281eb4d2accb93069667addc2172c9b3129/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9932d281eb4d2accb93069667addc2172c9b3129/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=9932d281eb4d2accb93069667addc2172c9b3129", "patch": "@@ -22,13 +22,18 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#ifdef __STDC__\n+#include <stdarg.h>\n+#else\n+#include <varargs.h>\n+#endif\n \n /* cp_printer is the type of a function which converts an argument into\n    a string for digestion by printf.  The cp_printer function should deal\n    with all memory management; the functions in this file will not free\n    the char*s returned.  See error.c for an example use of this code.  */\n \n-typedef char* cp_printer PROTO((HOST_WIDE_INT, int));\n+typedef char* cp_printer PROTO((tree, int));\n extern cp_printer * cp_printers[256];\n \n /* Whether or not we should try to be quiet for errors and warnings; this is\n@@ -43,184 +48,221 @@ extern int   cp_line_of PROTO((tree));\n \n #define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n \n-#define NARGS 5\n-#define arglist a1, a2, a3, a4, a5\n-#define arglist_dcl HOST_WIDE_INT a1, a2, a3, a4, a5;\n-#define ARGSINIT \\\n-  args[0] = a1; args[1] = a2; args[2] = a3; args[3] = a4; args[4] = a5;\n-#define ARGSLIST args[0], args[1], args[2], args[3], args[4]\n+/* This function supports only `%s', `%d', and the C++ print codes.  */\n \n+#ifdef __STDC__\n static void\n-cp_thing (errfn, atarg1, format, arglist)\n+cp_thing (errorfn *errfn, int atarg1, const char *format, va_list ap)\n+#else\n+static void\n+cp_thing (errfn, atarg1, format, ap)\n      errorfn *errfn;\n      int atarg1;\n-     char *format;\n-     arglist_dcl\n+     const char *format;\n+     va_list ap;\n+#endif\n {\n-  char *fmt;\n-  char *f;\n-  char *ap;\n-  int arg;\n-  HOST_WIDE_INT atarg = atarg1 ? a1 : 0;\n-  HOST_WIDE_INT args[NARGS];\n-  ARGSINIT\n-\n-  fmt = STRDUP(format);\n-  \n-  for (f = fmt, arg = 0; *f; ++f)\n+  static char *buf;\n+  static long buflen;\n+  int nargs = 0;\n+  long len;\n+  long offset;\n+  const char *f;\n+  tree atarg = 0;\n+\n+  len = strlen (format) + 1;\n+  if (len > buflen)\n+    {\n+      buflen = len;\n+      buf = xmalloc (buflen);\n+    }\n+  offset = 0;\n+\n+  for (f = format; *f; ++f)\n     {\n       cp_printer * function;\n       int alternate;\n       int maybe_here;\n       \n       /* ignore text */\n-      if (*f != '%') continue;\n+      if (*f != '%')\n+\t{\n+\t  buf[offset++] = *f;\n+\t  continue;\n+\t}\n \n       ++f;\n \n       alternate = 0;\n       maybe_here = 0;\n \n-      /* ignore most flags */\n-      while (*f == ' ' || *f == '-' || *f == '+' || *f == '#')\n+      /* Check for '+' and '#' (in that order). */\n+      if (*f == '+')\n \t{\n-\t  if (*f == '+')\n-\t    maybe_here = 1;\n-\t  else if (*f == '#')\n-\t    alternate = 1;\n+\t  maybe_here = 1;\n \t  ++f;\n \t}\n-\n-      /* ignore field width */\n-      if (*f == '*')\n+      if (*f == '#')\n \t{\n+\t  alternate = 1;\n \t  ++f;\n-\t  ++arg;\n \t}\n-      else\n-\twhile (isdigit (*f))\n-\t  ++f;\n \n-      /* ignore precision */\n-      if (*f == '.')\n-\t{\n-\t  ++f;\n-\t  if (*f == '*')\n-\t    {\n-\t      ++f;\n-\t      ++arg;\n-\t    }\n-\t  else\n-\t    while (isdigit (*f))\n-\t      ++f;\n-\t}\n-\n-      /* ignore \"long\" */\n-      if (*f == 'l')\n-\t++f;\n+      /* no field width or precision */\n \n       function = cp_printers[(int)*f];\n \n-      if (function)\n+      if (function || *f == 's')\n \t{\n \t  char *p;\n+\t  int plen;\n \n-\t  if (arg >= NARGS) abort ();\n-\t  \n-\t  if (maybe_here && atarg1)\n-\t    atarg = args[arg];\n+\t  if (*f == 's')\n+\t    {\n+\t      p = va_arg (ap, char *);\n+\t      nargs++;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree t = va_arg (ap, tree);\n+\t      nargs++;\n \n-\t  /* Must use a temporary to avoid calling *function twice */\n-\t  p = (*function) (args[arg], alternate);\n-\t  args[arg] = (HOST_WIDE_INT) STRDUP(p);\n-\t  *f = 's';\n-\t}\n+\t      /* This indicates that ATARG comes from a different\n+\t\t location than normal.  */\n+\t      if (maybe_here && atarg1)\n+\t\tatarg = t;\n \n-      ++arg;\t\t\t/* Assume valid format string */\n+\t      /* If atarg1 is set and this is the first argument, then\n+\t\t set ATARG appropriately.  */\n+\t      if (atarg1 && nargs == 1)\n+\t\tatarg = t;\n \n+\t      p = (*function) (t, alternate);\n+\t    }\n+\n+\t  plen = strlen (p);\n+\t  len += plen;\n+\t  if (len > buflen)\n+\t    {\n+\t      buflen = len;\n+\t      buf = xrealloc (buf, len);\n+\t    }\n+\t  strcpy (buf + offset, p);\n+\t  offset += plen;\n+\t}\n+      else\n+\t{\n+\t  if (*f != 'd')\n+\t    abort ();\n+\t  len += HOST_BITS_PER_INT / 2;\n+\t  if (len > buflen)\n+\t    {\n+\t      buflen = len;\n+\t      buf = xmalloc (len);\n+\t    }\n+\t  sprintf (buf + offset, \"%d\", va_arg (ap, int));\n+\t  nargs++;\n+\t  offset += strlen (buf + offset);\n+\t  /* With an ANSI C library one could write\n+\t     out += sprintf (...); */\n+\t}\n     }\n+  buf[offset] = '\\0';\n+\n+  /* If ATARG1 is set, but we haven't extracted any arguments, then\n+     extract one tree argument for ATARG.  */  \n+  if (nargs == 0 && atarg1)\n+    atarg = va_arg (ap, tree);\n \n   if (atarg)\n     {\n-      char *file = cp_file_of ((tree) atarg);\n-      int   line = cp_line_of ((tree) atarg);\n-      (*errfn) (file, line, fmt, ARGSLIST);\n+      char *file = cp_file_of (atarg);\n+      int   line = cp_line_of (atarg);\n+      (*errfn) (file, line, buf);\n     }\n   else\n-    (*errfn) (fmt, ARGSLIST);\n+    (*errfn) (buf);\n \n }\n \n-void\n-cp_error (format, arglist)\n-     char *format;\n-     arglist_dcl\n+#ifdef __STDC__\n+#define DECLARE(name) void name (const char *format, ...)\n+#define INIT va_start (ap, format)\n+#else\n+#define DECLARE(name) void name (format, va_alist) char *format; va_dcl\n+#define INIT va_start (ap)\n+#endif\n+\n+DECLARE (cp_error)\n {\n   extern errorfn error;\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing (error, 0, format, arglist);\n+    cp_thing (error, 0, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_warning (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_warning)\n {\n   extern errorfn warning;\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing (warning, 0, format, arglist);\n+    cp_thing (warning, 0, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_pedwarn (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_pedwarn)\n {\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing ((errorfn *) pedwarn, 0, format, arglist);\n+    cp_thing ((errorfn *) pedwarn, 0, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_compiler_error (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_compiler_error)\n {\n   extern errorfn compiler_error;\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing (compiler_error, 0, format, arglist);\n+    cp_thing (compiler_error, 0, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_sprintf (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_sprintf)\n {\n-  cp_thing ((errorfn *) sprintf, 0, format, arglist);\n+  va_list ap;\n+  INIT;\n+  cp_thing ((errorfn *) sprintf, 0, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_error_at (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_error_at)\n {\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing ((errorfn *) error_with_file_and_line, 1, format, arglist);\n+    cp_thing ((errorfn *) error_with_file_and_line, 1, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_warning_at (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_warning_at)\n {\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing ((errorfn *) warning_with_file_and_line, 1, format, arglist);\n+    cp_thing ((errorfn *) warning_with_file_and_line, 1, format, ap);\n+  va_end (ap);\n }\n \n-void\n-cp_pedwarn_at (format, arglist)\n-     char *format;\n-     arglist_dcl\n+DECLARE (cp_pedwarn_at)\n {\n+  va_list ap;\n+  INIT;\n   if (! cp_silent)\n-    cp_thing ((errorfn *) pedwarn_with_file_and_line, 1, format, arglist);\n+    cp_thing ((errorfn *) pedwarn_with_file_and_line, 1, format, ap);\n+  va_end (ap);\n }"}]}