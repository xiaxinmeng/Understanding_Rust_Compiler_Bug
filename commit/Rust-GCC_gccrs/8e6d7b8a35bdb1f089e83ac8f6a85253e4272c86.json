{"sha": "8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU2ZDdiOGEzNWJkYjFmMDg5ZTgzYWM4ZjZhODUyNTNlNDI3MmM4Ng==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-04-15T20:06:17Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-04-15T20:06:17Z"}, "message": "re PR libfortran/18495 ([4.0 only] Intrinisc function SPREAD is broken)\n\n2005-04-15  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/18495\n        * intrinsics/spread_generic.c (spread):  Remove const from\n        return array descriptor.\n        New variables: rrank (rank of return array),  rs (for\n        calculating the size of the return array), srank (rank\n        of the source array).\n        Generate runtime error if the dim= argument is larger than\n        the rank of the return array.\n        Generate runtime error if the needed rank of the return\n        array is larger than 7.\n        If ret->data is null, populate the return array descriptor\n        and initialize the variables for the actual operation.\n        Otherwise, set ret->dim[0].stride to one if it is zero.\n        Change second, independent use of variable dim to srank.\n\n2005-04-15  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/18495\n        * gfortran.fortran-torture/execute/intrinsic_spread.f90:\n        Test callee-allocated version of return array with a write\n        statement.\n        Test spread with a temporary with another write statement.\n\nFrom-SVN: r98208", "tree": {"sha": "292cf804ca180a2bbd8b572c18603d0233efe047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/292cf804ca180a2bbd8b572c18603d0233efe047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/comments", "author": null, "committer": null, "parents": [{"sha": "35205e8f059ddcbf7a5ce1865901a56d1771b923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35205e8f059ddcbf7a5ce1865901a56d1771b923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35205e8f059ddcbf7a5ce1865901a56d1771b923"}], "stats": {"total": 130, "additions": 107, "deletions": 23}, "files": [{"sha": "594aae10f555d501de8eb505a359cde110486722", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "patch": "@@ -1,3 +1,11 @@\n+2005-04-15  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/18495\n+\t* gfortran.fortran-torture/execute/intrinsic_spread.f90:\n+\tTest callee-allocated version of return array with a write\n+\tstatement.\n+\tTest spread with a temporary with another write statement.\n+\n 2005-04-15  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR tree-optimization/21031"}, {"sha": "2308a1d64aa96a767698c518bf02ea48ca0384ac", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_spread.f90", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_spread.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_spread.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_spread.f90?ref=8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "patch": "@@ -1,10 +1,17 @@\n program foo\n    integer, dimension (2, 3) :: a\n    integer, dimension (2, 2, 3) :: b\n+   character (len=80) line1, line2, line3\n \n    a = reshape ((/1, 2, 3, 4, 5, 6/), (/2, 3/))\n    b = spread (a, 1, 2)\n    if (any (b .ne. reshape ((/1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6/), &\n                             (/2, 2, 3/)))) &\n       call abort\n+   write(line1, 9000) b\n+   write(line2, 9000) spread (a, 1, 2)\n+   if (line1 /= line2) call abort\n+   write(line3, 9000) spread (a, 1, 2) + 0\n+   if (line1 /= line2) call abort\n+9000 format(12I3)\n end program"}, {"sha": "9fc0b63b51a1acf497bcc141fa25f7f294c8c76a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "patch": "@@ -1,3 +1,20 @@\n+2005-04-15  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/18495\n+\t* intrinsics/spread_generic.c (spread):  Remove const from\n+\treturn array descriptor.\n+\tNew variables: rrank (rank of return array),  rs (for\n+\tcalculating the size of the return array), srank (rank\n+\tof the source array).\n+\tGenerate runtime error if the dim= argument is larger than\n+\tthe rank of the return array.\n+\tGenerate runtime error if the needed rank of the return\n+\tarray is larger than 7.\n+\tIf ret->data is null, populate the return array descriptor\n+\tand initialize the variables for the actual operation.\n+\tOtherwise, set ret->dim[0].stride to one if it is zero.\n+\tChange second, independent use of variable dim to srank.\n+\n 2005-04-12  Mike Stump  <mrs@apple.com>\n \n \t* configure: Regenerate."}, {"sha": "7dcabf63bcbef905ebcebde201812f07e04e64b6", "filename": "libgfortran/intrinsics/spread_generic.c", "status": "modified", "additions": 75, "deletions": 23, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/libgfortran%2Fintrinsics%2Fspread_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86/libgfortran%2Fintrinsics%2Fspread_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fspread_generic.c?ref=8e6d7b8a35bdb1f089e83ac8f6a85253e4272c86", "patch": "@@ -34,23 +34,26 @@ Boston, MA 02111-1307, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n-extern void spread (const gfc_array_char *, const gfc_array_char *,\n+extern void spread (gfc_array_char *, const gfc_array_char *,\n \t\t    const index_type *, const index_type *);\n export_proto(spread);\n \n void\n-spread (const gfc_array_char *ret, const gfc_array_char *source,\n+spread (gfc_array_char *ret, const gfc_array_char *source,\n \tconst index_type *along, const index_type *pncopies)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS - 1];\n   index_type rstride0;\n   index_type rdelta;\n+  index_type rrank;\n+  index_type rs;\n   char *rptr;\n   char *dest;\n   /* s.* indicates the source array.  */\n   index_type sstride[GFC_MAX_DIMENSIONS - 1];\n   index_type sstride0;\n+  index_type srank;\n   const char *sptr;\n \n   index_type count[GFC_MAX_DIMENSIONS - 1];\n@@ -60,34 +63,83 @@ spread (const gfc_array_char *ret, const gfc_array_char *source,\n   index_type size;\n   index_type ncopies;\n \n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (*along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = *pncopies;\n+\n   size = GFC_DESCRIPTOR_SIZE (source);\n-  dim = 0;\n-  for (n = 0; n < GFC_DESCRIPTOR_RANK (ret); n++)\n+  if (ret->data == NULL)\n     {\n-      if (n == *along - 1)\n-        {\n-          rdelta = ret->dim[n].stride * size;\n-        }\n-      else\n-        {\n-          count[dim] = 0;\n-          extent[dim] = source->dim[dim].ubound + 1 - source->dim[dim].lbound;\n-          sstride[dim] = source->dim[dim].stride * size;\n-          rstride[dim] = ret->dim[n].stride * size;\n-          dim++;\n-        }\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == *along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs * size;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride * size;\n+\t      rstride[dim] = rs * size;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->base = 0;\n+      ret->data = internal_malloc_size (rs * size);\n     }\n-  dim = GFC_DESCRIPTOR_RANK (source);\n-  if (sstride[0] == 0)\n-    sstride[0] = size;\n-  if (rstride[0] == 0)\n-    rstride[0] = size;\n+  else\n+    {\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n \n+      if (ret->dim[0].stride == 0)\n+\tret->dim[0].stride = 1;\n+\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  if (n == *along - 1)\n+\t    {\n+\t      rdelta = ret->dim[n].stride * size;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride * size;\n+\t      rstride[dim] = ret->dim[n].stride * size;\n+\t      dim++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = size;\n+    }\n   sstride0 = sstride[0];\n   rstride0 = rstride[0];\n   rptr = ret->data;\n   sptr = source->data;\n-  ncopies = *pncopies;\n \n   while (sptr)\n     {\n@@ -113,7 +165,7 @@ spread (const gfc_array_char *ret, const gfc_array_char *source,\n           sptr -= sstride[n] * extent[n];\n           rptr -= rstride[n] * extent[n];\n           n++;\n-          if (n >= dim)\n+          if (n >= srank)\n             {\n               /* Break out of the loop.  */\n               sptr = NULL;"}]}