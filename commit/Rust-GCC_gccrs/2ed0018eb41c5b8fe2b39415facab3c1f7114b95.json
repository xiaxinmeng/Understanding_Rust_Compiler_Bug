{"sha": "2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkMDAxOGViNDFjNWI4ZmUyYjM5NDE1ZmFjYWIzYzFmNzExNGI5NQ==", "commit": {"author": {"name": "Thomas Fitzsimmons", "email": "fitzsim@redhat.com", "date": "2005-05-06T23:06:18Z"}, "committer": {"name": "Thomas Fitzsimmons", "email": "fitzsim@gcc.gnu.org", "date": "2005-05-06T23:06:18Z"}, "message": "Makefile.am (gtk_awt_peer_sources): Add GtkVolatileImage.java.\n\n2005-05-06  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* Makefile.am (gtk_awt_peer_sources): Add GtkVolatileImage.java.\n\t* Makefile.in: Regenerate.\n\t* gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java\n\t(createCompatibleVolatileImage(int,int)): Implement.\n\t(createCompatibleVolatileImage(int,int,ImageCapabilities)):\n\tLikewise.\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java (backBuffer, caps):\n\tNew fields.\n\t(createVolatileImage): Implement.\n\t(createBuffers): Likewise.\n\t(getBackBuffer): Likewise.\n\t(flip): Likewise.\n\t(destroyBuffers): Likewise.\n\t* gnu/java/awt/peer/gtk/GtkVolatileImage.java: New file.\n\t* java/awt/Canvas.java (CanvasBltBufferStrategy): New class.\n\t(CanvasFlipBufferStrategy): Likewise.\n\t(createBufferStrategy(int)): New method.\n\t(createBufferStrategy(int,BufferCapabilities)): Likewise.\n\t* java/awt/Component.java (BltBufferStrategy): Implement and\n\tdocument class.\n\t(FlipBufferStrategy): Likewise.\n\t* java/awt/Window.java (WindowBltBufferStrategy): New class.\n\t(WindowFlipBufferStrategy): Likewise.\n\t(createBufferStrategy(int)): New method.\n\t(createBufferStrategy(int,BufferCapabilities)): Likewise.\n\t(getBufferStrategy): Likewise.\n\t* java/awt/BufferCapabilities.java (BufferCapabilities): Rename\n\tfront to frontCaps and back to backCaps.\n\nFrom-SVN: r99336", "tree": {"sha": "81ea3a47bbb3d6ce4bcf710fb8c56e517fc413aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81ea3a47bbb3d6ce4bcf710fb8c56e517fc413aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/comments", "author": null, "committer": null, "parents": [{"sha": "91a01f21abfe192fd660da55be548f52008e3f51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a01f21abfe192fd660da55be548f52008e3f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a01f21abfe192fd660da55be548f52008e3f51"}], "stats": {"total": 1037, "additions": 965, "deletions": 72}, "files": [{"sha": "90a70486847680a3220dbf2cdefb26c277c2efd2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -1,3 +1,34 @@\n+2005-05-06  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* Makefile.am (gtk_awt_peer_sources): Add GtkVolatileImage.java.\n+\t* Makefile.in: Regenerate.\n+\t* gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java\n+\t(createCompatibleVolatileImage(int,int)): Implement.\n+\t(createCompatibleVolatileImage(int,int,ImageCapabilities)):\n+\tLikewise.\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java (backBuffer, caps):\n+\tNew fields.\n+\t(createVolatileImage): Implement.\n+\t(createBuffers): Likewise.\n+\t(getBackBuffer): Likewise.\n+\t(flip): Likewise.\n+\t(destroyBuffers): Likewise.\n+\t* gnu/java/awt/peer/gtk/GtkVolatileImage.java: New file.\n+\t* java/awt/Canvas.java (CanvasBltBufferStrategy): New class.\n+\t(CanvasFlipBufferStrategy): Likewise.\n+\t(createBufferStrategy(int)): New method.\n+\t(createBufferStrategy(int,BufferCapabilities)): Likewise.\n+\t* java/awt/Component.java (BltBufferStrategy): Implement and\n+\tdocument class.\n+\t(FlipBufferStrategy): Likewise.\n+\t* java/awt/Window.java (WindowBltBufferStrategy): New class.\n+\t(WindowFlipBufferStrategy): Likewise.\n+\t(createBufferStrategy(int)): New method.\n+\t(createBufferStrategy(int,BufferCapabilities)): Likewise.\n+\t(getBufferStrategy): Likewise.\n+\t* java/awt/BufferCapabilities.java (BufferCapabilities): Rename\n+\tfront to frontCaps and back to backCaps.\n+\n 2005-05-06  Michael Koch  <konqueror@gmx.de>\n \n \t* java/awt/BufferCapabilities.java"}, {"sha": "a369fafefc01dcac45cbd8fb539e5bb76ff58cf6", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -387,6 +387,7 @@ gnu/java/awt/peer/gtk/GtkTextAreaPeer.java \\\n gnu/java/awt/peer/gtk/GtkTextComponentPeer.java\t\\\n gnu/java/awt/peer/gtk/GtkTextFieldPeer.java \\\n gnu/java/awt/peer/gtk/GtkToolkit.java \\\n+gnu/java/awt/peer/gtk/GtkVolatileImage.java \\\n gnu/java/awt/peer/gtk/GtkWindowPeer.java \\\n gnu/java/awt/peer/gtk/GThreadMutex.java \\\n gnu/java/awt/peer/gtk/GThreadNativeMethodRunner.java"}, {"sha": "387fdb45546b57e33c5cad7d91b89c9f0453d7ac", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -4783,6 +4783,7 @@ gnu/java/awt/peer/gtk/GtkTextAreaPeer.java \\\n gnu/java/awt/peer/gtk/GtkTextComponentPeer.java\t\\\n gnu/java/awt/peer/gtk/GtkTextFieldPeer.java \\\n gnu/java/awt/peer/gtk/GtkToolkit.java \\\n+gnu/java/awt/peer/gtk/GtkVolatileImage.java \\\n gnu/java/awt/peer/gtk/GtkWindowPeer.java \\\n gnu/java/awt/peer/gtk/GThreadMutex.java \\\n gnu/java/awt/peer/gtk/GThreadNativeMethodRunner.java"}, {"sha": "94e1b0f0110ea39bf7de4ae81b00d0338a9566ce", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsConfiguration.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -86,14 +86,14 @@ public BufferedImage createCompatibleImage(int w, int h,\n \n   public VolatileImage createCompatibleVolatileImage(int w, int h)\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+    return new GtkVolatileImage(w, h);\n   }\n \n   public VolatileImage createCompatibleVolatileImage(int w, int h,\n                                                      ImageCapabilities caps)\n     throws java.awt.AWTException\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+    return new GtkVolatileImage(w, h, caps);\n   }\n \n   public ColorModel getColorModel()"}, {"sha": "e3e7afb199e314337bc1c6dfa7c70c934724911f", "filename": "libjava/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -39,6 +39,7 @@\n package gnu.java.awt.peer.gtk;\n \n import java.awt.AWTEvent;\n+import java.awt.AWTException;\n import java.awt.BufferCapabilities;\n import java.awt.Color;\n import java.awt.Component;\n@@ -71,6 +72,9 @@\n public class GtkComponentPeer extends GtkGenericPeer\n   implements ComponentPeer\n {\n+  VolatileImage backBuffer;\n+  BufferCapabilities caps;\n+\n   Component awtComponent;\n \n   Insets insets;\n@@ -596,35 +600,63 @@ public void updateCursorImmediately ()\n     \n   }\n \n-  public VolatileImage createVolatileImage (int width, int height)\n-  {\n-    return null;\n-  }\n-\n   public boolean handlesWheelScrolling ()\n   {\n     return false;\n   }\n \n-  public void createBuffers (int x, BufferCapabilities capabilities)\n-    throws java.awt.AWTException\n+  // Convenience method to create a new volatile image on the screen\n+  // on which this component is displayed.\n+  public VolatileImage createVolatileImage (int width, int height)\n+  {\n+    return new GtkVolatileImage (width, height);\n+  }\n \n+  // Creates buffers used in a buffering strategy.\n+  public void createBuffers (int numBuffers, BufferCapabilities caps)\n+    throws AWTException\n   {\n-    \n+    // numBuffers == 2 implies double-buffering, meaning one back\n+    // buffer and one front buffer.\n+    if (numBuffers == 2)\n+      backBuffer = new GtkVolatileImage(awtComponent.getWidth(),\n+\t\t\t\t\tawtComponent.getHeight(),\n+\t\t\t\t\tcaps.getBackBufferCapabilities());\n+    else\n+      throw new AWTException(\"GtkComponentPeer.createBuffers:\"\n+\t\t\t     + \" multi-buffering not supported\");\n+    this.caps = caps;\n   }\n \n+  // Return the back buffer.\n   public Image getBackBuffer ()\n   {\n-    return null;\n+    return backBuffer;\n   }\n \n+  // FIXME: flip should be implemented as a fast native operation\n   public void flip (BufferCapabilities.FlipContents contents)\n   {\n-    \n+    getGraphics().drawImage(backBuffer,\n+\t\t\t    awtComponent.getWidth(),\n+\t\t\t    awtComponent.getHeight(),\n+\t\t\t    null);\n+\n+    // create new back buffer and clear it to the background color.\n+    if (contents == BufferCapabilities.FlipContents.BACKGROUND)\n+\t{\n+\t  backBuffer = createVolatileImage(awtComponent.getWidth(),\n+\t\t\t\t\t   awtComponent.getHeight());\n+\t  backBuffer.getGraphics().clearRect(0, 0,\n+\t\t\t\t\t     awtComponent.getWidth(),\n+\t\t\t\t\t     awtComponent.getHeight());\n+\t}\n+    // FIXME: support BufferCapabilities.FlipContents.PRIOR\n   }\n \n+  // Release the resources allocated to back buffers.\n   public void destroyBuffers ()\n   {\n-    \n+    backBuffer.flush();\n   }\n }"}, {"sha": "3ac3b31aec576a630b27901a8e76c27ec69ceb43", "filename": "libjava/gnu/java/awt/peer/gtk/GtkVolatileImage.java", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkVolatileImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkVolatileImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkVolatileImage.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -0,0 +1,114 @@\n+/* GtkVolatileImage.java -- a hardware-accelerated image buffer\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.ImageCapabilities;\n+import java.awt.image.VolatileImage;\n+\n+public class GtkVolatileImage extends VolatileImage\n+{\n+  private int width;\n+  private int height;\n+  private ImageCapabilities caps;\n+\n+  public GtkVolatileImage(int width, int height)\n+  {\n+    this(width, height, null);\n+  }\n+\n+  public GtkVolatileImage(int width, int height, ImageCapabilities caps)\n+  {\n+    this.width = width;\n+    this.height = height;\n+    this.caps = caps;\n+  }\n+\n+  // FIXME: should return a buffered image snapshot of the accelerated\n+  // visual\n+  public BufferedImage getSnapshot()\n+  {\n+    return null;\n+  }\n+\n+  public int getWidth()\n+  {\n+    return width;\n+  }\n+\n+  public int getHeight()\n+  {\n+    return height;\n+  }\n+\n+  // FIXME: should return a graphics wrapper around this image's\n+  // visual\n+  public Graphics2D createGraphics()\n+  {\n+    return null;\n+  }\n+\n+  public int validate(GraphicsConfiguration gc)\n+  {\n+    return VolatileImage.IMAGE_OK;\n+  }\n+\n+  public boolean contentsLost()\n+  {\n+    return false;\n+  }\n+\n+  public ImageCapabilities getCapabilities()\n+  {\n+    return caps;\n+  }\n+\n+  public synchronized Object getProperty (String name, ImageObserver observer)\n+  {\n+    return null;\n+  }\n+\n+  public synchronized int getWidth (ImageObserver observer)\n+  {\n+    return width;\n+  }\n+  \n+  public synchronized int getHeight (ImageObserver observer)\n+  {\n+    return height;\n+  }\n+}"}, {"sha": "35888b2ddb71b0f62f979398aec0848af1954b64", "filename": "libjava/java/awt/BufferCapabilities.java", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FBufferCapabilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FBufferCapabilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FBufferCapabilities.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -132,22 +132,22 @@ private FlipContents(int value)\n   /**\n    * Creates a buffer capabilities object.\n    *\n-   * @param front front buffer capabilities descriptor\n-   * @param back back buffer capabilities descriptor\n+   * @param frontCaps front buffer capabilities descriptor\n+   * @param backCaps back buffer capabilities descriptor\n    * @param flip the results of a flip operation or null if\n    * flipping is not supported\n    *\n-   * @exception IllegalArgumentException if front or back is\n+   * @exception IllegalArgumentException if frontCaps or backCaps is\n    * null\n    */\n-  public BufferCapabilities(ImageCapabilities front,\n-\t\t\t    ImageCapabilities back,\n+  public BufferCapabilities(ImageCapabilities frontCaps,\n+\t\t\t    ImageCapabilities backCaps,\n                             FlipContents flip)\n   {\n-    if (front ==  null || back == null)\n+    if (frontCaps ==  null || backCaps == null)\n       throw new IllegalArgumentException();\n-    this.front = front;\n-    this.back = back;\n+    this.front = frontCaps;\n+    this.back = backCaps;\n     this.flip = flip;\n   }\n "}, {"sha": "9a6311922250faae4b27d60c6a9ea9dc08e40c31", "filename": "libjava/java/awt/Canvas.java", "status": "modified", "additions": 151, "deletions": 1, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FCanvas.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FCanvas.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FCanvas.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -178,6 +178,157 @@ public AccessibleContext getAccessibleContext()\n     return accessibleContext;\n   }\n \n+  /**\n+   * A BltBufferStrategy for canvases.\n+   */\n+  private class CanvasBltBufferStrategy extends BltBufferStrategy\n+  {\n+    /**\n+     * Creates a block transfer strategy for this canvas.\n+     *\n+     * @param numBuffers the number of buffers in this strategy\n+     * @param accelerated true if the buffer should be accelerated,\n+     * false otherwise\n+     */\n+    CanvasBltBufferStrategy(int numBuffers, boolean accelerated)\n+    {\n+      super(numBuffers,\n+\t    new BufferCapabilities(new ImageCapabilities(accelerated),\n+\t\t\t\t   new ImageCapabilities(accelerated),\n+\t\t\t\t   BufferCapabilities.FlipContents.COPIED));\n+    }\n+  }\n+\n+  /**\n+   * A FlipBufferStrategy for canvases.\n+   */\n+  private class CanvasFlipBufferStrategy extends FlipBufferStrategy\n+  {\n+    /**\n+     * Creates a flip buffer strategy for this canvas.\n+     *\n+     * @param numBuffers the number of buffers in this strategy\n+     *\n+     * @throws AWTException if the requested number of buffers is not\n+     * supported\n+     */\n+    CanvasFlipBufferStrategy(int numBuffers)\n+      throws AWTException\n+    {\n+      super(numBuffers,\n+\t    new BufferCapabilities(new ImageCapabilities(true),\n+\t\t\t\t   new ImageCapabilities(true),\n+\t\t\t\t   BufferCapabilities.FlipContents.COPIED));\n+    }\n+  }\n+\n+  /**\n+   * Creates a buffering strategy that manages how this canvas is\n+   * repainted.  This method attempts to create the optimum strategy\n+   * based on the desired number of buffers.  Hardware or software\n+   * acceleration may be used.\n+   *\n+   * createBufferStrategy attempts different levels of optimization,\n+   * but guarantees that some strategy with the requested number of\n+   * buffers will be created even if it is not optimal.  First it\n+   * attempts to create a page flipping strategy, then an accelerated\n+   * blitting strategy, then an unaccelerated blitting strategy.\n+   *\n+   * Calling this method causes any existing buffer strategy to be\n+   * destroyed.\n+   *\n+   * @param numBuffers the number of buffers in this strategy\n+   *\n+   * @throws IllegalArgumentException if requested number of buffers\n+   * is less than one\n+   * @throws IllegalStateException if this canvas is not displayable\n+   *\n+   * @since 1.4\n+   */\n+  public void createBufferStrategy(int numBuffers)\n+  {\n+    if (numBuffers < 1)\n+      throw new IllegalArgumentException(\"Canvas.createBufferStrategy: number\"\n+\t\t\t\t\t + \" of buffers is less than one\");\n+\n+    if (!isDisplayable())\n+      throw new IllegalStateException(\"Canvas.createBufferStrategy: canvas is\"\n+\t\t\t\t      + \" not displayable\");\n+\n+    // try a flipping strategy\n+    try\n+      {\n+\tbufferStrategy = new CanvasFlipBufferStrategy(numBuffers);\n+\treturn;\n+      }\n+    catch (AWTException e)\n+      {\n+      }\n+\n+    // try an accelerated blitting strategy\n+    try\n+      {\n+\tbufferStrategy = new CanvasBltBufferStrategy(numBuffers, true);\n+      }\n+    catch (AWTException e)\n+      {\n+      }\n+\n+    // fall back to an unaccelerated blitting strategy\n+    try\n+      {\n+\tbufferStrategy = new CanvasBltBufferStrategy(numBuffers, false);\n+      }\n+    catch (AWTException e)\n+      {\n+      }\n+  }\n+\n+  /**\n+   * Creates a buffering strategy that manages how this canvas is\n+   * repainted.  This method attempts to create a strategy based on\n+   * the specified capabilities and throws an exception if the\n+   * requested strategy is not supported.\n+   *\n+   * Calling this method causes any existing buffer strategy to be\n+   * destroyed.\n+   *\n+   * @param numBuffers the number of buffers in this strategy\n+   * @param caps the requested buffering capabilities\n+   *\n+   * @throws AWTException if the requested capabilities are not\n+   * supported\n+   * @throws IllegalArgumentException if requested number of buffers\n+   * is less than one or if caps is null\n+   *\n+   * @since 1.4\n+   */\n+  public void createBufferStrategy(int numBuffers,\n+\t\t\t\t   BufferCapabilities caps)\n+  {\n+    if (numBuffers < 1)\n+      throw new IllegalArgumentException(\"Canvas.createBufferStrategy: number\"\n+\t\t\t\t\t + \" of buffers is less than one\");\n+\n+    if (caps == null)\n+      throw new IllegalArgumentException(\"Canvas.createBufferStrategy:\"\n+\t\t\t\t\t + \" capabilities object is null\");\n+\n+    // a flipping strategy was requested\n+    if (caps.isPageFlipping())\n+      {\n+\ttry\n+\t  {\n+\t    bufferStrategy = new CanvasFlipBufferStrategy(numBuffers);\n+\t  }\n+\tcatch (AWTException e)\n+\t  {\n+\t  }\n+      }\n+    else\n+      bufferStrategy = new CanvasBltBufferStrategy(numBuffers, true);\n+  }\n+\n   /**\n    * Returns the buffer strategy used by the canvas.\n    *\n@@ -211,5 +362,4 @@ public void update(Graphics graphics)\n     /* Call the paint method */\n     paint(graphics);\n   }\n-\n }"}, {"sha": "8b174fbe29cd70da4d1b68e159f59ce2f295ffa4", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 387, "deletions": 33, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -5574,78 +5574,432 @@ public void focusLost(FocusEvent e)\n   } // class AccessibleAWTComponent\n \n   /**\n-   * This class provides support for blitting offscreen surfaces.\n+   * This class provides support for blitting offscreen surfaces to a\n+   * component.\n+   *\n+   * @see BufferStrategy\n    *\n-   * @author Eric Blake (ebb9@email.byu.edu)\n    * @since 1.4\n-   * @XXX Shell class, to allow compilation. This needs documentation and\n-   * correct implementation.\n    */\n   protected class BltBufferStrategy extends BufferStrategy\n   {\n+    /**\n+     * The capabilities of the image buffer.\n+     */\n     protected BufferCapabilities caps;\n+\n+    /**\n+     * The back buffers used in this strategy.\n+     */\n     protected VolatileImage[] backBuffers;\n+\n+    /**\n+     * Whether or not the image buffer resources are allocated and\n+     * ready to be drawn into.\n+     */\n     protected boolean validatedContents;\n+\n+    /**\n+     * The width of the back buffers.\n+     */\n     protected int width;\n+\n+    /**\n+     * The height of the back buffers.\n+     */\n     protected int height;\n-    protected BltBufferStrategy(int num, BufferCapabilities caps)\n+\n+    /**\n+     * The front buffer.\n+     */\n+    private VolatileImage frontBuffer;\n+\n+    /**\n+     * Creates a blitting buffer strategy.\n+     *\n+     * @param numBuffers the number of buffers, including the front\n+     * buffer\n+     * @param caps the capabilities of this strategy\n+     */\n+    protected BltBufferStrategy(int numBuffers, BufferCapabilities caps)\n     {\n       this.caps = caps;\n-      createBackBuffers(num);\n+      createBackBuffers(numBuffers - 1);\n+      width = getWidth();\n+      height = getHeight();\n     }\n-    protected void createBackBuffers(int num)\n+\n+    /**\n+     * Initializes the backBuffers field with an array of numBuffers\n+     * VolatileImages.\n+     *\n+     * @param numBuffers the number of backbuffers to create\n+     */\n+    protected void createBackBuffers(int numBuffers)\n     {\n-      backBuffers = new VolatileImage[num];\n+      GraphicsConfiguration c =\n+\tGraphicsEnvironment.getLocalGraphicsEnvironment()\n+\t.getDefaultScreenDevice().getDefaultConfiguration();\n+\n+      backBuffers = new VolatileImage[numBuffers];\n+\n+      for (int i = 0; i < numBuffers; i++)\n+\tbackBuffers[i] = c.createCompatibleVolatileImage(width, height);\n     }\n+\n+    /**\n+     * Retrieves the capabilities of this buffer strategy.\n+     *\n+     * @return the capabilities of this buffer strategy\n+     */\n     public BufferCapabilities getCapabilities()\n     {\n       return caps;\n     }\n-    public Graphics getDrawGraphics() { return null; }\n-    public void show() {}\n-    protected void revalidate() {}\n-    public boolean contentsLost() { return false; }\n-    public boolean contentsRestored() { return false; }\n-  } // class BltBufferStrategy\n+\n+    /**\n+     * Retrieves a graphics object that can be used to draw into this\n+     * strategy's image buffer.\n+     *\n+     * @return a graphics object\n+     */\n+    public Graphics getDrawGraphics()\n+    {\n+      // Return the backmost buffer's graphics.\n+      return backBuffers[0].getGraphics();\n+    }\n+\n+    /**\n+     * Bring the contents of the back buffer to the front buffer.\n+     */\n+    public void show()\n+    {\n+      GraphicsConfiguration c =\n+\tGraphicsEnvironment.getLocalGraphicsEnvironment()\n+\t.getDefaultScreenDevice().getDefaultConfiguration();\n+\n+      // draw the front buffer.\n+      getGraphics().drawImage(backBuffers[backBuffers.length - 1],\n+\t\t\t      width, height, null);\n+\n+      BufferCapabilities.FlipContents f = getCapabilities().getFlipContents();\n+\n+      // blit the back buffers.\n+      for (int i = backBuffers.length - 1; i > 0 ; i--)\n+\tbackBuffers[i] = backBuffers[i - 1];\n+\n+      // create new backmost buffer.\n+      if (f == BufferCapabilities.FlipContents.UNDEFINED)\n+\tbackBuffers[0] = c.createCompatibleVolatileImage(width, height);\n+\n+      // create new backmost buffer and clear it to the background\n+      // color.\n+      if (f == BufferCapabilities.FlipContents.BACKGROUND)\n+\t{\n+\t  backBuffers[0] = c.createCompatibleVolatileImage(width, height);\n+\t  backBuffers[0].getGraphics().clearRect(0, 0, width, height);\n+\t}\n+\n+      // FIXME: set the backmost buffer to the prior contents of the\n+      // front buffer.  How do we retrieve the contents of the front\n+      // buffer?\n+      //\n+      //      if (f == BufferCapabilities.FlipContents.PRIOR)\n+\n+      // set the backmost buffer to a copy of the new front buffer.\n+      if (f == BufferCapabilities.FlipContents.COPIED)\n+\tbackBuffers[0] = backBuffers[backBuffers.length - 1];\n+    }\n+\n+    /**\n+     * Re-create the image buffer resources if they've been lost.\n+     */\n+    protected void revalidate()\n+    {\n+      GraphicsConfiguration c =\n+\tGraphicsEnvironment.getLocalGraphicsEnvironment()\n+\t.getDefaultScreenDevice().getDefaultConfiguration();\n+\n+      for (int i = 0; i < backBuffers.length; i++)\n+\t{\n+\t  int result = backBuffers[i].validate(c);\n+\t  if (result == VolatileImage.IMAGE_INCOMPATIBLE)\n+\t    backBuffers[i] = c.createCompatibleVolatileImage(width, height);\n+\t}\n+      validatedContents = true;\n+    }\n+\n+    /**\n+     * Returns whether or not the image buffer resources have been\n+     * lost.\n+     *\n+     * @return true if the resources have been lost, false otherwise\n+     */\n+    public boolean contentsLost()\n+    {\n+      for (int i = 0; i < backBuffers.length; i++)\n+\t{\n+\t  if (backBuffers[i].contentsLost())\n+\t    {\n+\t      validatedContents = false;\n+\t      return true;\n+\t    }\n+\t}\n+      // we know that the buffer resources are valid now because we\n+      // just checked them\n+      validatedContents = true;\n+      return false;\n+    }\n+\n+    /**\n+     * Returns whether or not the image buffer resources have been\n+     * restored.\n+     *\n+     * @return true if the resources have been restored, false\n+     * otherwise\n+     */\n+    public boolean contentsRestored()\n+    {\n+      GraphicsConfiguration c =\n+\tGraphicsEnvironment.getLocalGraphicsEnvironment()\n+\t.getDefaultScreenDevice().getDefaultConfiguration();\n+\n+      boolean imageRestored = false;\n+\n+      for (int i = 0; i < backBuffers.length; i++)\n+\t{\n+\t  int result = backBuffers[i].validate(c);\n+\t  if (result == VolatileImage.IMAGE_RESTORED)\n+\t    imageRestored = true;\n+\t  else if (result == VolatileImage.IMAGE_INCOMPATIBLE)\n+\t    return false;\n+\t}\n+      // we know that the buffer resources are valid now because we\n+      // just checked them\n+      validatedContents = true;\n+      return imageRestored;\n+    }\n+  }\n \n   /**\n-   * This class provides support for flipping component buffers. It is only\n-   * designed for use by Canvas and Window.\n+   * This class provides support for flipping component buffers. It\n+   * can only be used on Canvases and Windows.\n    *\n-   * @author Eric Blake (ebb9@email.byu.edu)\n    * @since 1.4\n-   * @XXX Shell class, to allow compilation. This needs documentation and\n-   * correct implementation.\n    */\n   protected class FlipBufferStrategy extends BufferStrategy\n   {\n+    /**\n+     * The number of buffers.\n+     */\n     protected int numBuffers;\n+\n+    /**\n+     * The capabilities of this buffering strategy.\n+     */\n     protected BufferCapabilities caps;\n+\n+    /**\n+     * An Image reference to the drawing buffer.\n+     */\n     protected Image drawBuffer;\n+\n+    /**\n+     * A VolatileImage reference to the drawing buffer.\n+     */\n     protected VolatileImage drawVBuffer;\n+\n+    /**\n+     * Whether or not the image buffer resources are allocated and\n+     * ready to be drawn into.\n+     */\n     protected boolean validatedContents;\n-    protected FlipBufferStrategy(int num, BufferCapabilities caps)\n+\n+    /**\n+     * The width of the back buffer.\n+     */\n+    private int width;\n+\n+    /**\n+     * The height of the back buffer.\n+     */\n+    private int height;\n+\n+    /**\n+     * Creates a flipping buffer strategy.  The only supported\n+     * strategy for FlipBufferStrategy itself is a double-buffer page\n+     * flipping strategy.  It forms the basis for more complex derived\n+     * strategies.\n+     *\n+     * @param numBuffers the number of buffers\n+     * @param caps the capabilities of this buffering strategy\n+     *\n+     * @throws AWTException if the requested\n+     * number-of-buffers/capabilities combination is not supported\n+     */\n+    protected FlipBufferStrategy(int numBuffers, BufferCapabilities caps)\n       throws AWTException\n     {\n       this.caps = caps;\n-      createBuffers(num, caps);\n+      width = getWidth();\n+      height = getHeight();\n+\n+      if (numBuffers > 1)\n+\tcreateBuffers(numBuffers, caps);\n+      else\n+\t{\n+\t  drawVBuffer = peer.createVolatileImage(width, height);\n+\t  drawBuffer = drawVBuffer;\n+\t}\n     }\n-    protected void createBuffers(int num, BufferCapabilities caps)\n-      throws AWTException {}\n+\n+    /**\n+     * Creates a multi-buffer flipping strategy.  The number of\n+     * buffers must be greater than one and the buffer capabilities\n+     * must specify page flipping.\n+     *\n+     * @param numBuffers the number of flipping buffers; must be\n+     * greater than one\n+     * @param caps the buffering capabilities; caps.isPageFlipping()\n+     * must return true\n+     *\n+     * @throws IllegalArgumentException if numBuffers is not greater\n+     * than one or if the page flipping capability is not requested\n+     *\n+     * @throws AWTException if the requested flipping strategy is not\n+     * supported\n+     */\n+    protected void createBuffers(int numBuffers, BufferCapabilities caps)\n+      throws AWTException\n+    {\n+      if (numBuffers <= 1)\n+\tthrow new IllegalArgumentException(\"FlipBufferStrategy.createBuffers:\"\n+\t\t\t\t\t   + \" numBuffers must be greater than\"\n+\t\t\t\t\t   + \" one.\");\n+\n+      if (!caps.isPageFlipping())\n+\tthrow new IllegalArgumentException(\"FlipBufferStrategy.createBuffers:\"\n+\t\t\t\t\t   + \" flipping must be a specified\"\n+\t\t\t\t\t   + \" capability.\");\n+\n+      peer.createBuffers(numBuffers, caps);\n+    }\n+\n+    /**\n+     * Return a direct reference to the back buffer image.\n+     *\n+     * @return a direct reference to the back buffer image.\n+     */\n     protected Image getBackBuffer()\n     {\n-      return drawBuffer;\n+      return peer.getBackBuffer();\n     }\n-    protected void flip(BufferCapabilities.FlipContents flipAction) {}\n-    protected void destroyBuffers() {}\n+\n+    /**\n+     * Perform a flip operation to transfer the contents of the back\n+     * buffer to the front buffer.\n+     */\n+    protected void flip(BufferCapabilities.FlipContents flipAction)\n+    {\n+      peer.flip(flipAction);\n+    }\n+\n+    /**\n+     * Release the back buffer's resources.\n+     */\n+    protected void destroyBuffers()\n+    {\n+      peer.destroyBuffers();\n+    }\n+\n+    /**\n+     * Retrieves the capabilities of this buffer strategy.\n+     *\n+     * @return the capabilities of this buffer strategy\n+     */\n     public BufferCapabilities getCapabilities()\n     {\n       return caps;\n     }\n-    public Graphics getDrawGraphics() { return null; }\n-    protected void revalidate() {}\n-    public boolean contentsLost() { return false; }\n-    public boolean contentsRestored() { return false; }\n-    public void show() {}\n-  } // class FlipBufferStrategy\n-} // class Component\n+\n+    /**\n+     * Retrieves a graphics object that can be used to draw into this\n+     * strategy's image buffer.\n+     *\n+     * @return a graphics object\n+     */\n+    public Graphics getDrawGraphics()\n+    {\n+      return drawVBuffer.getGraphics();\n+    }\n+\n+    /**\n+     * Re-create the image buffer resources if they've been lost.\n+     */\n+    protected void revalidate()\n+    {\n+      GraphicsConfiguration c =\n+\tGraphicsEnvironment.getLocalGraphicsEnvironment()\n+\t.getDefaultScreenDevice().getDefaultConfiguration();\n+\n+      if (drawVBuffer.validate(c) == VolatileImage.IMAGE_INCOMPATIBLE)\n+\tdrawVBuffer = peer.createVolatileImage(width, height);\n+      validatedContents = true;\n+    }\n+\n+    /**\n+     * Returns whether or not the image buffer resources have been\n+     * lost.\n+     *\n+     * @return true if the resources have been lost, false otherwise\n+     */\n+    public boolean contentsLost()\n+    {\n+      if (drawVBuffer.contentsLost())\n+\t{\n+\t  validatedContents = false;\n+\t  return true;\n+\t}\n+      // we know that the buffer resources are valid now because we\n+      // just checked them\n+      validatedContents = true;\n+      return false;\n+    }\n+\n+    /**\n+     * Returns whether or not the image buffer resources have been\n+     * restored.\n+     *\n+     * @return true if the resources have been restored, false\n+     * otherwise\n+     */\n+    public boolean contentsRestored()\n+    {\n+      GraphicsConfiguration c =\n+\tGraphicsEnvironment.getLocalGraphicsEnvironment()\n+\t.getDefaultScreenDevice().getDefaultConfiguration();\n+\n+      int result = drawVBuffer.validate(c);\n+\n+      boolean imageRestored = false;\n+\n+      if (result == VolatileImage.IMAGE_RESTORED)\n+\timageRestored = true;\n+      else if (result == VolatileImage.IMAGE_INCOMPATIBLE)\n+\treturn false;\n+\n+      // we know that the buffer resources are valid now because we\n+      // just checked them\n+      validatedContents = true;\n+      return imageRestored;\n+    }\n+\n+    /**\n+     * Bring the contents of the back buffer to the front buffer.\n+     */\n+    public void show()\n+    {\n+      flip(caps.getFlipContents());\n+    }\n+  }\n+}"}, {"sha": "051749267ee8be3083b639cc7920ec3f8727a598", "filename": "libjava/java/awt/Window.java", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FWindow.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -45,6 +45,7 @@\n import java.awt.event.WindowFocusListener;\n import java.awt.event.WindowListener;\n import java.awt.event.WindowStateListener;\n+import java.awt.image.BufferStrategy;\n import java.awt.peer.WindowPeer;\n import java.lang.ref.Reference;\n import java.lang.ref.WeakReference;\n@@ -796,6 +797,168 @@ public void setLocationRelativeTo (Component c)\n     // FIXME: handle case where component is non-null.\n   }\n \n+  /**\n+   * A BltBufferStrategy for windows.\n+   */\n+  private class WindowBltBufferStrategy extends BltBufferStrategy\n+  {\n+    /**\n+     * Creates a block transfer strategy for this window.\n+     *\n+     * @param numBuffers the number of buffers in this strategy\n+     * @param accelerated true if the buffer should be accelerated,\n+     * false otherwise\n+     */\n+    WindowBltBufferStrategy(int numBuffers, boolean accelerated)\n+    {\n+      super(numBuffers,\n+\t    new BufferCapabilities(new ImageCapabilities(accelerated),\n+\t\t\t\t   new ImageCapabilities(accelerated),\n+\t\t\t\t   BufferCapabilities.FlipContents.COPIED));\n+    }\n+  }\n+\n+  /**\n+   * A FlipBufferStrategy for windows.\n+   */\n+  private class WindowFlipBufferStrategy extends FlipBufferStrategy\n+  {\n+    /**\n+     * Creates a flip buffer strategy for this window.\n+     *\n+     * @param numBuffers the number of buffers in this strategy\n+     *\n+     * @throws AWTException if the requested number of buffers is not\n+     * supported\n+     */\n+    WindowFlipBufferStrategy(int numBuffers)\n+      throws AWTException\n+    {\n+      super(numBuffers,\n+\t    new BufferCapabilities(new ImageCapabilities(true),\n+\t\t\t\t   new ImageCapabilities(true),\n+\t\t\t\t   BufferCapabilities.FlipContents.COPIED));\n+    }\n+  }\n+\n+  /**\n+   * Creates a buffering strategy that manages how this window is\n+   * repainted.  This method attempts to create the optimum strategy\n+   * based on the desired number of buffers.  Hardware or software\n+   * acceleration may be used.\n+   *\n+   * createBufferStrategy attempts different levels of optimization,\n+   * but guarantees that some strategy with the requested number of\n+   * buffers will be created even if it is not optimal.  First it\n+   * attempts to create a page flipping strategy, then an accelerated\n+   * blitting strategy, then an unaccelerated blitting strategy.\n+   *\n+   * Calling this method causes any existing buffer strategy to be\n+   * destroyed.\n+   *\n+   * @param numBuffers the number of buffers in this strategy\n+   *\n+   * @throws IllegalArgumentException if requested number of buffers\n+   * is less than one\n+   * @throws IllegalStateException if this window is not displayable\n+   *\n+   * @since 1.4\n+   */\n+  public void createBufferStrategy(int numBuffers)\n+  {\n+    if (numBuffers < 1)\n+      throw new IllegalArgumentException(\"Window.createBufferStrategy: number\"\n+\t\t\t\t\t + \" of buffers is less than one\");\n+\n+    if (!isDisplayable())\n+      throw new IllegalStateException(\"Window.createBufferStrategy: window is\"\n+\t\t\t\t      + \" not displayable\");\n+\n+    // try a flipping strategy\n+    try\n+      {\n+\tbufferStrategy = new WindowFlipBufferStrategy(numBuffers);\n+\treturn;\n+      }\n+    catch (AWTException e)\n+      {\n+      }\n+\n+    // try an accelerated blitting strategy\n+    try\n+      {\n+\tbufferStrategy = new WindowBltBufferStrategy(numBuffers, true);\n+      }\n+    catch (AWTException e)\n+      {\n+      }\n+\n+    // fall back to an unaccelerated blitting strategy\n+    try\n+      {\n+\tbufferStrategy = new WindowBltBufferStrategy(numBuffers, false);\n+      }\n+    catch (AWTException e)\n+      {\n+      }\n+  }\n+\n+  /**\n+   * Creates a buffering strategy that manages how this window is\n+   * repainted.  This method attempts to create a strategy based on\n+   * the specified capabilities and throws an exception if the\n+   * requested strategy is not supported.\n+   *\n+   * Calling this method causes any existing buffer strategy to be\n+   * destroyed.\n+   *\n+   * @param numBuffers the number of buffers in this strategy\n+   * @param caps the requested buffering capabilities\n+   *\n+   * @throws AWTException if the requested capabilities are not\n+   * supported\n+   * @throws IllegalArgumentException if requested number of buffers\n+   * is less than one or if caps is null\n+   *\n+   * @since 1.4\n+   */\n+  public void createBufferStrategy(int numBuffers,\n+\t\t\t\t   BufferCapabilities caps)\n+  {\n+    if (numBuffers < 1)\n+      throw new IllegalArgumentException(\"Window.createBufferStrategy: number\"\n+\t\t\t\t\t + \" of buffers is less than one\");\n+\n+    if (caps == null)\n+      throw new IllegalArgumentException(\"Window.createBufferStrategy:\"\n+\t\t\t\t\t + \" capabilities object is null\");\n+\n+    // a flipping strategy was requested\n+    if (caps.isPageFlipping())\n+      {\n+\ttry\n+\t  {\n+\t    bufferStrategy = new WindowFlipBufferStrategy(numBuffers);\n+\t  }\n+\tcatch (AWTException e)\n+\t  {\n+\t  }\n+      }\n+    else\n+      bufferStrategy = new WindowBltBufferStrategy(numBuffers, true);\n+  }\n+\n+  /**\n+   * Returns the buffer strategy used by the window.\n+   *\n+   * @return the buffer strategy.\n+   * @since 1.4\n+   */\n+  public BufferStrategy getBufferStrategy()\n+  {\n+    return bufferStrategy;\n+  }\n+\n   /**\n    * @since 1.2\n    *"}, {"sha": "3a92cdf2a08f5b8aa4a872cd213569e568d19859", "filename": "libjava/java/awt/image/BufferStrategy.java", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2Fimage%2FBufferStrategy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2Fimage%2FBufferStrategy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FBufferStrategy.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -96,23 +96,22 @@ public BufferStrategy()\n \n   /**\n    * Returns whether or not the buffer's resources have been reclaimed\n-   * by the native graphics system since the last call to\n-   * getDrawGraphics.  If the buffer resources have been lost then\n-   * you'll need to obtain new resources before drawing again.  For\n-   * details, see the documentation for VolatileImage.\n+   * by the native graphics system.  If the buffer resources have been\n+   * lost then you'll need to obtain new resources before drawing\n+   * again.  For details, see the documentation for VolatileImage.\n    *\n-   * @return true if the contents were lost since the last call to\n-   * getDrawGraphics, false otherwise\n+   * @return true if the contents were lost, false otherwise\n    */\n   public abstract boolean contentsLost();\n \n   /**\n    * Returns whether or not the buffer's resources were re-created and\n-   * cleared to the default background color since the last call to\n-   * getDrawGraphics.  If the buffer's resources have recently been\n-   * re-created and initialized then the buffer's image may need to be\n-   * re-rendered.  For details, see the documentation for\n-   * VolatileImage.\n+   * cleared to the default background color.  If the buffer's\n+   * resources have recently been re-created and initialized then the\n+   * buffer's image may need to be re-rendered.  For details, see the\n+   * documentation for VolatileImage.\n+   *\n+   * @return true if the contents were restored, false otherwise\n    */\n   public abstract boolean contentsRestored();\n "}, {"sha": "a615e41f34f22dd87e5992594927c23481897b80", "filename": "libjava/java/awt/image/VolatileImage.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2Fimage%2FVolatileImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2Fimage%2FVolatileImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FVolatileImage.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -79,8 +79,7 @@ public abstract class VolatileImage extends Image\n    * One of validate's possible return values.  Indicates that the\n    * image buffer has been restored, meaning that it is valid and\n    * ready-to-use but that its previous contents have been lost.  This\n-   * return value implies IMAGE_OK but that the image needs to be\n-   * re-rendered.\n+   * return value implies that the image needs to be re-rendered.\n    */\n   public static final int IMAGE_RESTORED = 1;\n \n@@ -212,7 +211,7 @@ public Graphics getGraphics()\n    *   <li><code>IMAGE_OK</code> if the image did not need to be\n    *   validated and didn't need to be restored</li>\n    *   <li><code>IMAGE_RESTORED</code> if the image may need to be\n-   *   re-rendered.  This return value implies IMAGE_OK.</li>\n+   *   re-rendered.</li>\n    *   <li><code>IMAGE_INCOMPATIBLE</code> if this image's\n    *   requirements are not fulfilled by the graphics configuration\n    *   parameter.  This implies that you need to create a new"}, {"sha": "95c7832fd779e46a8442654b3e0a2030dbbbab92", "filename": "libjava/java/awt/peer/ComponentPeer.java", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed0018eb41c5b8fe2b39415facab3c1f7114b95/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fpeer%2FComponentPeer.java?ref=2ed0018eb41c5b8fe2b39415facab3c1f7114b95", "patch": "@@ -128,11 +128,60 @@ boolean prepareImage(Image img, int width, int height,\n   boolean canDetermineObscurity();\n   void coalescePaintEvent(PaintEvent e);\n   void updateCursorImmediately();\n-  VolatileImage createVolatileImage(int width, int height);\n   boolean handlesWheelScrolling();\n-  void createBuffers(int x, BufferCapabilities capabilities) throws AWTException;\n+\n+  /**\n+   * A convenience method that creates a volatile image.  The volatile\n+   * image is created on the screen device on which this component is\n+   * displayed, in the device's current graphics configuration.\n+   *\n+   * @param width width of the image\n+   * @param height height of the image\n+   *\n+   * @see VolatileImage\n+   *\n+   * @since 1.2\n+   */\n+  VolatileImage createVolatileImage(int width, int height);\n+\n+  /**\n+   * Create a number of image buffers that implement a buffering\n+   * strategy according to the given capabilities.\n+   *\n+   * @param numBuffers the number of buffers\n+   * @param caps the buffering capabilities\n+   *\n+   * @throws AWTException if the specified buffering strategy is not\n+   * implemented\n+   *\n+   * @since 1.2\n+   */\n+  void createBuffers(int numBuffers, BufferCapabilities caps)\n+    throws AWTException;\n+\n+  /**\n+   * Return the back buffer of this component.\n+   *\n+   * @return the back buffer of this component.\n+   *\n+   * @since 1.2\n+   */\n   Image getBackBuffer();\n+\n+  /**\n+   * Perform a page flip, leaving the contents of the back buffer in\n+   * the specified state.\n+   *\n+   * @param contents the state in which to leave the back buffer\n+   *\n+   * @since 1.2\n+   */\n   void flip(BufferCapabilities.FlipContents contents);\n+\n+  /**\n+   * Destroy the resources created by createBuffers.\n+   *\n+   * @since 1.2\n+   */\n   void destroyBuffers();\n-  \n }"}]}