{"sha": "4304ccfd019194af658e777c9d5d2a3dbebbc825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMwNGNjZmQwMTkxOTRhZjY1OGU3NzdjOWQ1ZDJhM2RiZWJiYzgyNQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-05-02T23:23:45Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-05-02T23:23:45Z"}, "message": "machmode.h (mode_complex): Add support to give the complex mode for a given mode.\n\n[gcc]\n2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* machmode.h (mode_complex): Add support to give the complex mode\n\tfor a given mode.\n\t(GET_MODE_COMPLEX_MODE): Likewise.\n\t* stor-layout.c (layout_type): For COMPLEX_TYPE, use the mode\n\tstored by build_complex_type and gfc_build_complex_type instead of\n\ttrying to figure out the appropriate mode based on the size. Raise\n\tan assertion error, if the type was not set.\n\t* genmodes.c (struct mode_data): Add field for the complex type of\n\tthe given type.\n\t(blank_mode): Likewise.\n\t(make_complex_modes): Remember the complex mode created in the\n\tbase type.\n\t(emit_mode_complex): Write out the mode_complex array to map a\n\ttype mode to the complex version.\n\t(emit_insn_modes_c): Likewise.\n\t* tree.c (build_complex_type): Set the complex type to use before\n\tcalling layout_type.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Add\n\tsupport for __float128 complex datatypes.\n\t(rs6000_hard_regno_mode_ok): Likewise.\n\t(rs6000_setup_reg_addr_masks): Likewise.\n\t(rs6000_complex_function_value): Likewise.\n\t* config/rs6000/rs6000.h (FLOAT128_IEEE_P): Likewise.\n\t__float128 and __ibm128 complex.\n\t(FLOAT128_IBM_P): Likewise.\n\t(ALTIVEC_ARG_MAX_RETURN): Likewise.\n\t* doc/extend.texi (Additional Floating Types): Document that\n\t-mfloat128 must be used to enable __float128.  Document complex\n\t__float128 and __ibm128 support.\n\n[gcc/fortran]\n2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* trans-types.c (gfc_build_complex_type):\n\n[gcc/testsuite]\n2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/float128-complex-1.c: New tests for complex\n\t__float128.\n\t* gcc.target/powerpc/float128-complex-2.c: Likewise.\n\nFrom-SVN: r235794", "tree": {"sha": "7e53a4f7ecf1db3452d71051ae33009438550f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e53a4f7ecf1db3452d71051ae33009438550f2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4304ccfd019194af658e777c9d5d2a3dbebbc825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4304ccfd019194af658e777c9d5d2a3dbebbc825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4304ccfd019194af658e777c9d5d2a3dbebbc825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4304ccfd019194af658e777c9d5d2a3dbebbc825/comments", "author": null, "committer": null, "parents": [{"sha": "fd39794afaedab9f102cede19852ec74e8a1ee17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd39794afaedab9f102cede19852ec74e8a1ee17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd39794afaedab9f102cede19852ec74e8a1ee17"}], "stats": {"total": 509, "additions": 480, "deletions": 29}, "files": [{"sha": "6f1663ffe673abec90978c585084da8117e63e19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -1,3 +1,35 @@\n+2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* machmode.h (mode_complex): Add support to give the complex mode\n+\tfor a given mode.\n+\t(GET_MODE_COMPLEX_MODE): Likewise.\n+\t* stor-layout.c (layout_type): For COMPLEX_TYPE, use the mode\n+\tstored by build_complex_type and gfc_build_complex_type instead of\n+\ttrying to figure out the appropriate mode based on the size. Raise\n+\tan assertion error, if the type was not set.\n+\t* genmodes.c (struct mode_data): Add field for the complex type of\n+\tthe given type.\n+\t(blank_mode): Likewise.\n+\t(make_complex_modes): Remember the complex mode created in the\n+\tbase type.\n+\t(emit_mode_complex): Write out the mode_complex array to map a\n+\ttype mode to the complex version.\n+\t(emit_insn_modes_c): Likewise.\n+\t* tree.c (build_complex_type): Set the complex type to use before\n+\tcalling layout_type.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Add\n+\tsupport for __float128 complex datatypes.\n+\t(rs6000_hard_regno_mode_ok): Likewise.\n+\t(rs6000_setup_reg_addr_masks): Likewise.\n+\t(rs6000_complex_function_value): Likewise.\n+\t* config/rs6000/rs6000.h (FLOAT128_IEEE_P): Likewise.\n+\t__float128 and __ibm128 complex.\n+\t(FLOAT128_IBM_P): Likewise.\n+\t(ALTIVEC_ARG_MAX_RETURN): Likewise.\n+\t* doc/extend.texi (Additional Floating Types): Document that\n+\t-mfloat128 must be used to enable __float128.  Document complex\n+\t__float128 and __ibm128 support.\n+\n 2016-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/49244"}, {"sha": "839ff5b71e69eed3a307c164228cb7df8a5af577", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -1866,7 +1866,7 @@ rs6000_hard_regno_nregs_internal (int regno, machine_mode mode)\n      128-bit floating point that can go in vector registers, which has VSX\n      memory addressing.  */\n   if (FP_REGNO_P (regno))\n-    reg_size = (VECTOR_MEM_VSX_P (mode)\n+    reg_size = (VECTOR_MEM_VSX_P (mode) || FLOAT128_VECTOR_P (mode)\n \t\t? UNITS_PER_VSX_WORD\n \t\t: UNITS_PER_FP_WORD);\n \n@@ -1898,6 +1898,9 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n {\n   int last_regno = regno + rs6000_hard_regno_nregs[mode][regno] - 1;\n \n+  if (COMPLEX_MODE_P (mode))\n+    mode = GET_MODE_INNER (mode);\n+\n   /* PTImode can only go in GPRs.  Quad word memory operations require even/odd\n      register combinations, and use PTImode where we need to deal with quad\n      word memory operations.  Don't allow quad words in the argument or frame\n@@ -2699,8 +2702,17 @@ rs6000_setup_reg_addr_masks (void)\n \n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n     {\n-      machine_mode m2 = (machine_mode)m;\n-      unsigned short msize = GET_MODE_SIZE (m2);\n+      machine_mode m2 = (machine_mode) m;\n+      bool complex_p = false;\n+      size_t msize;\n+\n+      if (COMPLEX_MODE_P (m2))\n+\t{\n+\t  complex_p = true;\n+\t  m2 = GET_MODE_INNER (m2);\n+\t}\n+\n+      msize = GET_MODE_SIZE (m2);\n \n       /* SDmode is special in that we want to access it only via REG+REG\n \t addressing on power7 and above, since we want to use the LFIWZX and\n@@ -2722,7 +2734,7 @@ rs6000_setup_reg_addr_masks (void)\n \t      /* Indicate if the mode takes more than 1 physical register.  If\n \t\t it takes a single register, indicate it can do REG+REG\n \t\t addressing.  */\n-\t      if (nregs > 1 || m == BLKmode)\n+\t      if (nregs > 1 || m == BLKmode || complex_p)\n \t\taddr_mask |= RELOAD_REG_MULTIPLE;\n \t      else\n \t\taddr_mask |= RELOAD_REG_INDEXED;\n@@ -2738,7 +2750,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\t  && msize <= 8\n \t\t  && !VECTOR_MODE_P (m2)\n \t\t  && !FLOAT128_VECTOR_P (m2)\n-\t\t  && !COMPLEX_MODE_P (m2)\n+\t\t  && !complex_p\n \t\t  && (m2 != DFmode || !TARGET_UPPER_REGS_DF)\n \t\t  && (m2 != SFmode || !TARGET_UPPER_REGS_SF)\n \t\t  && !(TARGET_E500_DOUBLE && msize == 8))\n@@ -18202,25 +18214,33 @@ rs6000_secondary_reload_memory (rtx addr,\n     addr_mask = (reg_addr[mode].addr_mask[RELOAD_REG_VMX]\n \t\t & ~RELOAD_REG_AND_M16);\n \n-  else\n+  /* If the register allocator hasn't made up its mind yet on the register\n+     class to use, settle on defaults to use.  */\n+  else if (rclass == NO_REGS)\n     {\n-      if (TARGET_DEBUG_ADDR)\n-\tfprintf (stderr,\n-\t\t \"rs6000_secondary_reload_memory: mode = %s, class = %s, \"\n-\t\t \"class is not GPR, FPR, VMX\\n\",\n-\t\t GET_MODE_NAME (mode), reg_class_names[rclass]);\n+      addr_mask = (reg_addr[mode].addr_mask[RELOAD_REG_ANY]\n+\t\t   & ~RELOAD_REG_AND_M16);\n \n-      return -1;\n+      if ((addr_mask & RELOAD_REG_MULTIPLE) != 0)\n+\taddr_mask &= ~(RELOAD_REG_INDEXED\n+\t\t       | RELOAD_REG_PRE_INCDEC\n+\t\t       | RELOAD_REG_PRE_MODIFY);\n     }\n \n+  else\n+    addr_mask = 0;\n+\n   /* If the register isn't valid in this register class, just return now.  */\n   if ((addr_mask & RELOAD_REG_VALID) == 0)\n     {\n       if (TARGET_DEBUG_ADDR)\n-\tfprintf (stderr,\n-\t\t \"rs6000_secondary_reload_memory: mode = %s, class = %s, \"\n-\t\t \"not valid in class\\n\",\n-\t\t GET_MODE_NAME (mode), reg_class_names[rclass]);\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"rs6000_secondary_reload_memory: mode = %s, class = %s, \"\n+\t\t   \"not valid in class\\n\",\n+\t\t   GET_MODE_NAME (mode), reg_class_names[rclass]);\n+\t  debug_rtx (addr);\n+\t}\n \n       return -1;\n     }\n@@ -18849,6 +18869,9 @@ rs6000_secondary_reload (bool in_p,\n \tfprintf (stderr, \", reload func = %s, extra cost = %d\",\n \t\t insn_data[sri->icode].name, sri->extra_cost);\n \n+      else if (sri->extra_cost > 0)\n+\tfprintf (stderr, \", extra cost = %d\", sri->extra_cost);\n+\n       fputs (\"\\n\", stderr);\n       debug_rtx (x);\n     }\n@@ -19242,6 +19265,16 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n   machine_mode mode = GET_MODE (x);\n   bool is_constant = CONSTANT_P (x);\n \n+  /* If a mode can't go in FPR/ALTIVEC/VSX registers, don't return a preferred\n+     reload class for it.  */\n+  if ((rclass == ALTIVEC_REGS || rclass == VSX_REGS)\n+      && (reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_VALID) == 0)\n+    return NO_REGS;\n+\n+  if ((rclass == FLOAT_REGS || rclass == VSX_REGS)\n+      && (reg_addr[mode].addr_mask[RELOAD_REG_FPR] & RELOAD_REG_VALID) == 0)\n+    return NO_REGS;\n+\n   /* For VSX, see if we should prefer FLOAT_REGS or ALTIVEC_REGS.  Do not allow\n      the reloading of address expressions using PLUS into floating point\n      registers.  */\n@@ -19291,6 +19324,25 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n       return NO_REGS;\n     }\n \n+  /* If we haven't picked a register class, and the type is a vector or\n+     floating point type, prefer to use the VSX, FPR, or Altivec register\n+     classes.  */\n+  if (rclass == NO_REGS)\n+    {\n+      if (TARGET_VSX && VECTOR_MEM_VSX_OR_P8_VECTOR_P (mode))\n+\treturn VSX_REGS;\n+\n+      if (TARGET_ALTIVEC && VECTOR_MEM_ALTIVEC_P (mode))\n+\treturn ALTIVEC_REGS;\n+\n+      if (DECIMAL_FLOAT_MODE_P (mode))\n+\treturn TARGET_DFP ? FLOAT_REGS : NO_REGS;\n+\n+      if (TARGET_FPRS && TARGET_HARD_FLOAT && FLOAT_MODE_P (mode)\n+\t  && (reg_addr[mode].addr_mask[RELOAD_REG_FPR] & RELOAD_REG_VALID) == 0)\n+\treturn FLOAT_REGS;\n+    }\n+\n   if (GET_MODE_CLASS (mode) == MODE_INT && rclass == NON_SPECIAL_REGS)\n     return GENERAL_REGS;\n \n@@ -34066,8 +34118,14 @@ rs6000_complex_function_value (machine_mode mode)\n   machine_mode inner = GET_MODE_INNER (mode);\n   unsigned int inner_bytes = GET_MODE_UNIT_SIZE (mode);\n \n-  if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  if (TARGET_FLOAT128\n+      && (mode == KCmode\n+\t  || (mode == TCmode && TARGET_IEEEQUAD)))\n+    regno = ALTIVEC_ARG_RETURN;\n+\n+  else if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n+\n   else\n     {\n       regno = GP_ARG_RETURN;"}, {"sha": "12fa7275cdca7400e125a939157115f7df3aab10", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -418,12 +418,12 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    Similarly IFmode is the IBM long double format even if the default is IEEE\n    128-bit.  */\n #define FLOAT128_IEEE_P(MODE)\t\t\t\t\t\t\\\n-  (((MODE) == TFmode && TARGET_IEEEQUAD)\t\t\t\t\\\n-   || ((MODE) == KFmode))\n+  ((TARGET_IEEEQUAD && ((MODE) == TFmode || (MODE) == TCmode))\t\t\\\n+   || ((MODE) == KFmode) || ((MODE) == KCmode))\n \n #define FLOAT128_IBM_P(MODE)\t\t\t\t\t\t\\\n-  (((MODE) == TFmode && !TARGET_IEEEQUAD)\t\t\t\t\\\n-   || ((MODE) == IFmode))\n+  ((!TARGET_IEEEQUAD && ((MODE) == TFmode || (MODE) == TCmode))\t\t\\\n+   || ((MODE) == IFmode) || ((MODE) == ICmode))\n \n /* Helper macros to say whether a 128-bit floating point type can go in a\n    single vector register, or whether it needs paired scalar values.  */\n@@ -1775,7 +1775,9 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define ALTIVEC_ARG_RETURN (FIRST_ALTIVEC_REGNO + 2)\n #define FP_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? FP_ARG_RETURN\t\\\n \t\t\t   : (FP_ARG_RETURN + AGGR_ARG_NUM_REG - 1))\n-#define ALTIVEC_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? ALTIVEC_ARG_RETURN \\\n+#define ALTIVEC_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2\t\t\\\n+\t\t\t\t? (ALTIVEC_ARG_RETURN\t\t\t\\\n+\t\t\t\t   + (TARGET_FLOAT128 ? 1 : 0))\t\t\\\n \t\t\t        : (ALTIVEC_ARG_RETURN + AGGR_ARG_NUM_REG - 1))\n \n /* Flags for the call/call_value rtl operations set up by function_arg */"}, {"sha": "daf1297350d89d87890dde1a05ed9a17a83559d9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -962,8 +962,13 @@ complex @code{__float128} type.  When these problems are fixed, you\n would use the following syntax to declare @code{_Complex128} to be a\n complex @code{__float128} type:\n \n+On the PowerPC Linux VSX targets, you can declare complex types using\n+the corresponding internal complex type, @code{KCmode} for\n+@code{__float128} type and @code{ICmode} for @code{__ibm128} type:\n+\n @smallexample\n-typedef _Complex float __attribute__((mode(KC))) _Complex128;\n+typedef _Complex float __attribute__((mode(KC))) _Complex_float128;\n+typedef _Complex float __attribute__((mode(IC))) _Complex_ibm128;\n @end smallexample\n \n Not all targets support additional floating-point types."}, {"sha": "e1958be6b1433218b14ef29e034a168c027b1057", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -1,3 +1,7 @@\n+2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* trans-types.c (gfc_build_complex_type):\n+\n 2016-05-02  Richard Biener  <rguenther@suse.de>\n \n \t* trans-array.c (gfc_trans_create_temp_array): Properly"}, {"sha": "e6c5b8e8e912a7cb9dd700cc3a9fd7f4ab2bb325", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -828,6 +828,7 @@ gfc_build_complex_type (tree scalar_type)\n \n   new_type = make_node (COMPLEX_TYPE);\n   TREE_TYPE (new_type) = scalar_type;\n+  SET_TYPE_MODE (new_type, GET_MODE_COMPLEX_MODE (TYPE_MODE (scalar_type)));\n   layout_type (new_type);\n   return new_type;\n }"}, {"sha": "788031b7fff961503a1d0f051a3f4ff8c61d0565", "filename": "gcc/genmodes.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -66,6 +66,7 @@ struct mode_data\n \t\t\t\t   this mode as a component.  */\n   struct mode_data *next_cont;  /* Next mode in that list.  */\n \n+  struct mode_data *complex;\t/* complex type with mode as component.  */\n   const char *file;\t\t/* file and line of definition, */\n   unsigned int line;\t\t/* for error reporting */\n   unsigned int counter;\t\t/* Rank ordering of modes */\n@@ -83,7 +84,7 @@ static struct mode_data *void_mode;\n static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1U, -1U, -1U, -1U,\n-  0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0,\n   \"<unknown>\", 0, 0, 0, 0, false, 0\n };\n \n@@ -472,6 +473,7 @@ make_complex_modes (enum mode_class cl,\n \n       c = new_mode (cclass, buf, file, line);\n       c->component = m;\n+      m->complex = c;\n     }\n }\n \n@@ -1380,6 +1382,22 @@ emit_mode_wider (void)\n   print_closer ();\n }\n \n+static void\n+emit_mode_complex (void)\n+{\n+  int c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_complex\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%smode\",\n+\t\t   m->complex ? m->complex->name : void_mode->name,\n+\t\t   m->name);\n+\n+  print_closer ();\n+}\n+\n static void\n emit_mode_mask (void)\n {\n@@ -1745,6 +1763,7 @@ emit_insn_modes_c (void)\n   emit_mode_size ();\n   emit_mode_nunits ();\n   emit_mode_wider ();\n+  emit_mode_complex ();\n   emit_mode_mask ();\n   emit_mode_inner ();\n   emit_mode_unit_size ();"}, {"sha": "3dcadd862f2216e57b7eea81dba715ca70bb912a", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -269,6 +269,10 @@ extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n #define GET_MODE_2XWIDER_MODE(MODE) ((machine_mode) mode_2xwider[MODE])\n \n+/* Get the complex mode from the component mode.  */\n+extern const unsigned char mode_complex[NUM_MACHINE_MODES];\n+#define GET_MODE_COMPLEX_MODE(MODE) ((machine_mode) mode_complex[MODE])\n+\n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  */"}, {"sha": "bf8a978c06247ab176f805965b127e78a6d6c03f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -2146,11 +2146,13 @@ layout_type (tree type)\n \n     case COMPLEX_TYPE:\n       TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n-      SET_TYPE_MODE (type,\n-\t\t     mode_for_size (2 * TYPE_PRECISION (TREE_TYPE (type)),\n-\t\t\t\t    (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE\n-\t\t\t\t     ? MODE_COMPLEX_FLOAT : MODE_COMPLEX_INT),\n-\t\t\t\t     0));\n+\n+      /* build_complex_type and fortran's gfc_build_complex_type have set the\n+\t expected mode to allow having multiple complex types for multiple\n+\t floating point types that have the same size such as the PowerPC with\n+\t __ibm128 and __float128.  */\n+      gcc_assert (TYPE_MODE (type) != VOIDmode);\n+\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;"}, {"sha": "0f91bdf762893067524efbb4487d904a378990a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -1,3 +1,9 @@\n+2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-complex-1.c: New tests for complex\n+\t__float128.\n+\t* gcc.target/powerpc/float128-complex-2.c: Likewise.\n+\n 2016-05-02  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR testsuite/70520"}, {"sha": "4e3b3253cafaaa709b73286a8d2b2ec5222c64de", "filename": "gcc/testsuite/gcc.target/powerpc/float128-complex-1.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-1.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -0,0 +1,157 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_float128_sw_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-O2 -mcpu=power7 -mfloat128\" } */\n+\n+#ifndef NO_FLOAT\n+typedef _Complex float\tfloat_complex;\n+extern float_complex cfloat1 (void);\n+extern float_complex cfloat2 (void);\n+\n+#define FLOAT_ARG(NAME, OP)\tARG_OP(float, float_complex, NAME, OP)\n+#define FLOAT_PTR(NAME, OP)\tPTR_OP(float, float_complex, NAME, OP)\n+#define FLOAT_CALL()\t\tCALL_OP(float, float_complex, cfloat1, cfloat2)\n+\n+#else\n+#define FLOAT_ARG(NAME, OP)\n+#define FLOAT_PTR(NAME, OP)\n+#define FLOAT_CALL()\n+#endif\n+\n+#ifndef NO_DOUBLE\n+typedef _Complex double\tdouble_complex;\n+extern double_complex cdouble1 (void);\n+extern double_complex cdouble2 (void);\n+\n+#define DOUBLE_ARG(NAME, OP)\tARG_OP(double, double_complex, NAME, OP)\n+#define DOUBLE_PTR(NAME, OP)\tPTR_OP(double, double_complex, NAME, OP)\n+#define DOUBLE_CALL()\t\tCALL_OP(double, double_complex, cdouble1, cdouble2)\n+\n+#else\n+#define DOUBLE_ARG(NAME, OP)\n+#define DOUBLE_PTR(NAME, OP)\n+#define DOUBLE_CALL()\n+#endif\n+\n+#ifndef NO_FLOAT128\n+#ifdef __VSX__\n+typedef _Complex float __attribute__((mode(KC)))\tfloat128_complex;\n+#else\n+typedef _Complex float __attribute__((mode(TC)))\tfloat128_complex;\n+#endif\n+\n+extern float128_complex cfloat128_1 (void);\n+extern float128_complex cfloat128_2 (void);\n+\n+#define FLOAT128_ARG(NAME, OP)\tARG_OP(float128, float128_complex, NAME, OP)\n+#define FLOAT128_PTR(NAME, OP)\tPTR_OP(float128, float128_complex, NAME, OP)\n+#define FLOAT128_CALL()\t\tCALL_OP(float128, float128_complex, cfloat128_1, cfloat128_2)\n+\n+#else\n+#define FLOAT128_ARG(NAME, OP)\n+#define FLOAT128_PTR(NAME, OP)\n+#define FLOAT128_CALL()\n+#endif\n+\n+#ifndef NO_LDOUBLE\n+typedef _Complex long double ldouble_complex;\n+extern ldouble_complex cldouble1 (void);\n+extern ldouble_complex cldouble2 (void);\n+\n+#define LDOUBLE_ARG(NAME, OP)\tARG_OP(ldouble, ldouble_complex, NAME, OP)\n+#define LDOUBLE_PTR(NAME, OP)\tPTR_OP(ldouble, ldouble_complex, NAME, OP)\n+#define LDOUBLE_CALL()\t\tCALL_OP(ldouble, ldouble_complex, cldouble1, cldouble2)\n+\n+#else\n+#define LDOUBLE_ARG(NAME, OP)\n+#define LDOUBLE_PTR(NAME, OP)\n+#define LDOUBLE_CALL()\n+#endif\n+\n+\n+#define ARG_OP(SUFFIX, TYPE, NAME, OP)\t\t\t\t\t\\\n+TYPE arg_ ## NAME ## _ ## SUFFIX (TYPE a, TYPE b)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  return a OP b;\t\t\t\t\t\t\t\\\n+}\n+\n+#define PTR_OP(SUFFIX, TYPE, NAME, OP)\t\t\t\t\t\\\n+void ptr_ ## NAME ## _ ## SUFFIX (TYPE *p, TYPE *a, TYPE *b)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  *p = *a OP *b;\t\t\t\t\t\t\t\\\n+}\n+\n+#define CALL_OP(SUFFIX, TYPE, FUNC1, FUNC2)\t\t\t\t\\\n+TYPE call_ ## SUFFIX (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  TYPE value1 = FUNC1 ();\t\t\t\t\t\t\\\n+  TYPE value2 = FUNC2 ();\t\t\t\t\t\t\\\n+  return value1 + value2;\t\t\t\t\t\t\\\n+}\n+\n+#ifndef NO_ARG\n+#ifndef NO_ADD\n+FLOAT_ARG    (add, +)\n+DOUBLE_ARG   (add, +)\n+FLOAT128_ARG (add, +)\n+LDOUBLE_ARG  (add, +)\n+#endif\n+\n+#ifndef NO_SUB\n+FLOAT_ARG    (sub, -)\n+DOUBLE_ARG   (sub, -)\n+FLOAT128_ARG (sub, -)\n+LDOUBLE_ARG  (sub, -)\n+#endif\n+\n+#ifndef NO_MUL\n+FLOAT_ARG    (mul, *)\n+DOUBLE_ARG   (mul, *)\n+FLOAT128_ARG (mul, *)\n+LDOUBLE_ARG  (mul, *)\n+#endif\n+\n+#ifndef NO_DIV\n+FLOAT_ARG    (div, /)\n+DOUBLE_ARG   (div, /)\n+FLOAT128_ARG (div, /)\n+LDOUBLE_ARG  (div, /)\n+#endif\n+#endif\n+\n+#ifndef NO_PTR\n+#ifndef NO_ADD\n+FLOAT_PTR    (add, +)\n+DOUBLE_PTR   (add, +)\n+FLOAT128_PTR (add, +)\n+LDOUBLE_PTR  (add, +)\n+#endif\n+\n+#ifndef NO_SUB\n+FLOAT_PTR    (sub, -)\n+DOUBLE_PTR   (sub, -)\n+FLOAT128_PTR (sub, -)\n+LDOUBLE_PTR  (sub, -)\n+#endif\n+\n+#ifndef NO_MUL\n+FLOAT_PTR    (mul, *)\n+DOUBLE_PTR   (mul, *)\n+FLOAT128_PTR (mul, *)\n+LDOUBLE_PTR  (mul, *)\n+#endif\n+\n+#ifndef NO_DIV\n+FLOAT_PTR    (div, /)\n+DOUBLE_PTR   (div, /)\n+FLOAT128_PTR (div, /)\n+LDOUBLE_PTR  (div, /)\n+#endif\n+#endif\n+\n+#ifndef NO_CALL\n+FLOAT_CALL    ()\n+DOUBLE_CALL   ()\n+FLOAT128_CALL ()\n+LDOUBLE_CALL  ()\n+#endif"}, {"sha": "06dd8e2f01b2e06121f2df08d419b502272530d8", "filename": "gcc/testsuite/gcc.target/powerpc/float128-complex-2.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-2.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -0,0 +1,160 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_float128_hw_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-O2 -mcpu=power9 -mfloat128 -mfloat128-hardware\" } */\n+\n+#ifndef NO_FLOAT\n+typedef _Complex float\tfloat_complex;\n+extern float_complex cfloat1 (void);\n+extern float_complex cfloat2 (void);\n+\n+#define FLOAT_ARG(NAME, OP)\tARG_OP(float, float_complex, NAME, OP)\n+#define FLOAT_PTR(NAME, OP)\tPTR_OP(float, float_complex, NAME, OP)\n+#define FLOAT_CALL()\t\tCALL_OP(float, float_complex, cfloat1, cfloat2)\n+\n+#else\n+#define FLOAT_ARG(NAME, OP)\n+#define FLOAT_PTR(NAME, OP)\n+#define FLOAT_CALL()\n+#endif\n+\n+#ifndef NO_DOUBLE\n+typedef _Complex double\tdouble_complex;\n+extern double_complex cdouble1 (void);\n+extern double_complex cdouble2 (void);\n+\n+#define DOUBLE_ARG(NAME, OP)\tARG_OP(double, double_complex, NAME, OP)\n+#define DOUBLE_PTR(NAME, OP)\tPTR_OP(double, double_complex, NAME, OP)\n+#define DOUBLE_CALL()\t\tCALL_OP(double, double_complex, cdouble1, cdouble2)\n+\n+#else\n+#define DOUBLE_ARG(NAME, OP)\n+#define DOUBLE_PTR(NAME, OP)\n+#define DOUBLE_CALL()\n+#endif\n+\n+#ifndef NO_FLOAT128\n+#ifdef __VSX__\n+typedef _Complex float __attribute__((mode(KC)))\tfloat128_complex;\n+#else\n+typedef _Complex float __attribute__((mode(TC)))\tfloat128_complex;\n+#endif\n+\n+extern float128_complex cfloat128_1 (void);\n+extern float128_complex cfloat128_2 (void);\n+\n+#define FLOAT128_ARG(NAME, OP)\tARG_OP(float128, float128_complex, NAME, OP)\n+#define FLOAT128_PTR(NAME, OP)\tPTR_OP(float128, float128_complex, NAME, OP)\n+#define FLOAT128_CALL()\t\tCALL_OP(float128, float128_complex, cfloat128_1, cfloat128_2)\n+\n+#else\n+#define FLOAT128_ARG(NAME, OP)\n+#define FLOAT128_PTR(NAME, OP)\n+#define FLOAT128_CALL()\n+#endif\n+\n+#ifndef NO_LDOUBLE\n+typedef _Complex long double ldouble_complex;\n+extern ldouble_complex cldouble1 (void);\n+extern ldouble_complex cldouble2 (void);\n+\n+#define LDOUBLE_ARG(NAME, OP)\tARG_OP(ldouble, ldouble_complex, NAME, OP)\n+#define LDOUBLE_PTR(NAME, OP)\tPTR_OP(ldouble, ldouble_complex, NAME, OP)\n+#define LDOUBLE_CALL()\t\tCALL_OP(ldouble, ldouble_complex, cldouble1, cldouble2)\n+\n+#else\n+#define LDOUBLE_ARG(NAME, OP)\n+#define LDOUBLE_PTR(NAME, OP)\n+#define LDOUBLE_CALL()\n+#endif\n+\n+\n+#define ARG_OP(SUFFIX, TYPE, NAME, OP)\t\t\t\t\t\\\n+TYPE arg_ ## NAME ## _ ## SUFFIX (TYPE a, TYPE b)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  return a OP b;\t\t\t\t\t\t\t\\\n+}\n+\n+#define PTR_OP(SUFFIX, TYPE, NAME, OP)\t\t\t\t\t\\\n+void ptr_ ## NAME ## _ ## SUFFIX (TYPE *p, TYPE *a, TYPE *b)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  *p = *a OP *b;\t\t\t\t\t\t\t\\\n+}\n+\n+#define CALL_OP(SUFFIX, TYPE, FUNC1, FUNC2)\t\t\t\t\\\n+TYPE call_ ## SUFFIX (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  TYPE value1 = FUNC1 ();\t\t\t\t\t\t\\\n+  TYPE value2 = FUNC2 ();\t\t\t\t\t\t\\\n+  return value1 + value2;\t\t\t\t\t\t\\\n+}\n+\n+#ifndef NO_ARG\n+#ifndef NO_ADD\n+FLOAT_ARG    (add, +)\n+DOUBLE_ARG   (add, +)\n+FLOAT128_ARG (add, +)\n+LDOUBLE_ARG  (add, +)\n+#endif\n+\n+#ifndef NO_SUB\n+FLOAT_ARG    (sub, -)\n+DOUBLE_ARG   (sub, -)\n+FLOAT128_ARG (sub, -)\n+LDOUBLE_ARG  (sub, -)\n+#endif\n+\n+#ifndef NO_MUL\n+FLOAT_ARG    (mul, *)\n+DOUBLE_ARG   (mul, *)\n+FLOAT128_ARG (mul, *)\n+LDOUBLE_ARG  (mul, *)\n+#endif\n+\n+#ifndef NO_DIV\n+FLOAT_ARG    (div, /)\n+DOUBLE_ARG   (div, /)\n+FLOAT128_ARG (div, /)\n+LDOUBLE_ARG  (div, /)\n+#endif\n+#endif\n+\n+#ifndef NO_PTR\n+#ifndef NO_ADD\n+FLOAT_PTR    (add, +)\n+DOUBLE_PTR   (add, +)\n+FLOAT128_PTR (add, +)\n+LDOUBLE_PTR  (add, +)\n+#endif\n+\n+#ifndef NO_SUB\n+FLOAT_PTR    (sub, -)\n+DOUBLE_PTR   (sub, -)\n+FLOAT128_PTR (sub, -)\n+LDOUBLE_PTR  (sub, -)\n+#endif\n+\n+#ifndef NO_MUL\n+FLOAT_PTR    (mul, *)\n+DOUBLE_PTR   (mul, *)\n+FLOAT128_PTR (mul, *)\n+LDOUBLE_PTR  (mul, *)\n+#endif\n+\n+#ifndef NO_DIV\n+FLOAT_PTR    (div, /)\n+DOUBLE_PTR   (div, /)\n+FLOAT128_PTR (div, /)\n+LDOUBLE_PTR  (div, /)\n+#endif\n+#endif\n+\n+#ifndef NO_CALL\n+FLOAT_CALL    ()\n+DOUBLE_CALL   ()\n+FLOAT128_CALL ()\n+LDOUBLE_CALL  ()\n+#endif\n+\n+/* { dg-final { scan-assembler \"xsaddqp\"  } } */\n+/* { dg-final { scan-assembler \"xssubqp\"  } } */"}, {"sha": "ebec112d4b1560372179f10357ad7e8b2dd1be07", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4304ccfd019194af658e777c9d5d2a3dbebbc825/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4304ccfd019194af658e777c9d5d2a3dbebbc825", "patch": "@@ -8774,6 +8774,7 @@ build_complex_type (tree component_type)\n   t = make_node (COMPLEX_TYPE);\n \n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (component_type);\n+  SET_TYPE_MODE (t, GET_MODE_COMPLEX_MODE (TYPE_MODE (component_type)));\n \n   /* If we already have such a type, use the old one.  */\n   hstate.add_object (TYPE_HASH (component_type));"}]}