{"sha": "0c4ec427e072c10777f4b26a6d05e0916df69fac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM0ZWM0MjdlMDcyYzEwNzc3ZjRiMjZhNmQwNWUwOTE2ZGY2OWZhYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2014-10-16T16:19:48Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2014-10-16T16:19:48Z"}, "message": "aarch64.c (aarch64_legitimize_address): New function.\n\n\t* config/aarch64/aarch64.c (aarch64_legitimize_address): New function.\n\t(TARGET_LEGITIMIZE_ADDRESS): Redefine.\n\nFrom-SVN: r216336", "tree": {"sha": "ef99a386d0abccee6cf183db8d2e225fff4fd56e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef99a386d0abccee6cf183db8d2e225fff4fd56e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c4ec427e072c10777f4b26a6d05e0916df69fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c4ec427e072c10777f4b26a6d05e0916df69fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c4ec427e072c10777f4b26a6d05e0916df69fac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c4ec427e072c10777f4b26a6d05e0916df69fac/comments", "author": null, "committer": null, "parents": [{"sha": "29fe1a72cb716f18d179e732cc28108eb2e29fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29fe1a72cb716f18d179e732cc28108eb2e29fec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29fe1a72cb716f18d179e732cc28108eb2e29fec"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "70ef40f2f3523e81e7705d4550cfc9aa8b4c9793", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c4ec427e072c10777f4b26a6d05e0916df69fac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c4ec427e072c10777f4b26a6d05e0916df69fac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c4ec427e072c10777f4b26a6d05e0916df69fac", "patch": "@@ -1,3 +1,8 @@\n+2014-10-16  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_legitimize_address): New function.\n+\t(TARGET_LEGITIMIZE_ADDRESS): Redefine.\n+\n 2014-10-16  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh-protos.h (fldi_ok): Remove."}, {"sha": "92c78543846e3b98fcf626f042d0e4bf72dfd6c4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c4ec427e072c10777f4b26a6d05e0916df69fac/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c4ec427e072c10777f4b26a6d05e0916df69fac/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0c4ec427e072c10777f4b26a6d05e0916df69fac", "patch": "@@ -4167,6 +4167,47 @@ aarch64_regno_regclass (unsigned regno)\n   return NO_REGS;\n }\n \n+static rtx\n+aarch64_legitimize_address (rtx x, rtx /* orig_x  */, enum machine_mode mode)\n+{\n+  /* Try to split X+CONST into Y=X+(CONST & ~mask), Y+(CONST&mask),\n+     where mask is selected by alignment and size of the offset.\n+     We try to pick as large a range for the offset as possible to\n+     maximize the chance of a CSE.  However, for aligned addresses\n+     we limit the range to 4k so that structures with different sized\n+     elements are likely to use the same base.  */\n+\n+  if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n+    {\n+      HOST_WIDE_INT offset = INTVAL (XEXP (x, 1));\n+      HOST_WIDE_INT base_offset;\n+\n+      /* Does it look like we'll need a load/store-pair operation?  */\n+      if (GET_MODE_SIZE (mode) > 16\n+\t  || mode == TImode)\n+\tbase_offset = ((offset + 64 * GET_MODE_SIZE (mode))\n+\t\t       & ~((128 * GET_MODE_SIZE (mode)) - 1));\n+      /* For offsets aren't a multiple of the access size, the limit is\n+\t -256...255.  */\n+      else if (offset & (GET_MODE_SIZE (mode) - 1))\n+\tbase_offset = (offset + 0x100) & ~0x1ff;\n+      else\n+\tbase_offset = offset & ~0xfff;\n+\n+      if (base_offset == 0)\n+\treturn x;\n+\n+      offset -= base_offset;\n+      rtx base_reg = gen_reg_rtx (Pmode);\n+      rtx val = force_operand (plus_constant (Pmode, XEXP (x, 0), base_offset),\n+\t\t\t   NULL_RTX);\n+      emit_move_insn (base_reg, val);\n+      x = plus_constant (Pmode, base_reg, offset);\n+    }\n+\n+  return x;\n+}\n+\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and return the new rtx.  */\n \n@@ -10165,6 +10206,9 @@ aarch64_asan_shadow_offset (void)\n #undef TARGET_ASAN_SHADOW_OFFSET\n #define TARGET_ASAN_SHADOW_OFFSET aarch64_asan_shadow_offset\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS aarch64_legitimize_address\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-aarch64.h\""}]}