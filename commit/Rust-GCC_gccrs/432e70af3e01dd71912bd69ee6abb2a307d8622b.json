{"sha": "432e70af3e01dd71912bd69ee6abb2a307d8622b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyZTcwYWYzZTAxZGQ3MTkxMmJkNjllZTZhYmIyYTMwN2Q4NjIyYg==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-06-03T03:46:32Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-06-03T03:46:32Z"}, "message": "[NDS32] Implement peephole2 patterns for tuning code size.\n\ngcc/\n\t* config/nds32/nds32-peephole2.md: Add new patterns for code size.\n\nFrom-SVN: r261124", "tree": {"sha": "c7f7e4eb76c8d124b16297b7655d1aaf35415588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7f7e4eb76c8d124b16297b7655d1aaf35415588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/432e70af3e01dd71912bd69ee6abb2a307d8622b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432e70af3e01dd71912bd69ee6abb2a307d8622b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432e70af3e01dd71912bd69ee6abb2a307d8622b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432e70af3e01dd71912bd69ee6abb2a307d8622b/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37d8f61108e97d88d1422dd1e0efabef833b0f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d8f61108e97d88d1422dd1e0efabef833b0f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37d8f61108e97d88d1422dd1e0efabef833b0f26"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "0dc3091bf1c66c15d6b1a0983418b553fa91d049", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432e70af3e01dd71912bd69ee6abb2a307d8622b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432e70af3e01dd71912bd69ee6abb2a307d8622b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=432e70af3e01dd71912bd69ee6abb2a307d8622b", "patch": "@@ -1,3 +1,7 @@\n+2018-06-03  Kito Cheng  <kito.cheng@gmail.com>\n+\n+\t* config/nds32/nds32-peephole2.md: Add new patterns for code size.\n+\n 2018-06-03  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32-opts.h (nds32_arch_type): Add ARCH_V3J."}, {"sha": "033f62bae5ad85461deb74a2887182b00d0f828c", "filename": "gcc/config/nds32/nds32-peephole2.md", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432e70af3e01dd71912bd69ee6abb2a307d8622b/gcc%2Fconfig%2Fnds32%2Fnds32-peephole2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432e70af3e01dd71912bd69ee6abb2a307d8622b/gcc%2Fconfig%2Fnds32%2Fnds32-peephole2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-peephole2.md?ref=432e70af3e01dd71912bd69ee6abb2a307d8622b", "patch": "@@ -22,3 +22,139 @@\n ;; Use define_peephole2 to handle possible target-specific optimization.\n \n ;; ------------------------------------------------------------------------\n+;; Try to utilize 16-bit instruction by swap operand if possible.\n+;; ------------------------------------------------------------------------\n+\n+;; Try to make add as add45.\n+(define_peephole2\n+  [(set (match_operand:QIHISI 0 \"register_operand\"              \"\")\n+\t(plus:QIHISI (match_operand:QIHISI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QIHISI 2 \"register_operand\" \"\")))]\n+  \"reload_completed\n+   && TARGET_16_BIT\n+   && REGNO (operands[0]) == REGNO (operands[2])\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && TEST_HARD_REG_BIT (reg_class_contents[MIDDLE_REGS], REGNO (operands[0]))\"\n+  [(set (match_dup 0) (plus:QIHISI (match_dup 2) (match_dup 1)))])\n+\n+;; Try to make xor/ior/and/mult as xor33/ior33/and33/mult33.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\"    \"\")\n+\t(match_operator:SI 1 \"nds32_have_33_inst_operator\"\n+\t  [(match_operand:SI 2 \"register_operand\" \"\")\n+\t   (match_operand:SI 3 \"register_operand\" \"\")]))]\n+  \"reload_completed\n+   && TARGET_16_BIT\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && REGNO (operands[0]) != REGNO (operands[2])\n+   && TEST_HARD_REG_BIT (reg_class_contents[LOW_REGS], REGNO (operands[0]))\n+   && TEST_HARD_REG_BIT (reg_class_contents[LOW_REGS], REGNO (operands[2]))\"\n+  [(set (match_dup 0) (match_op_dup 1 [(match_dup 3) (match_dup 2)]))])\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"TARGET_16_BIT\n+   && !TARGET_ISA_V2\n+   && NDS32_IS_GPR_REGNUM (REGNO (operands[0]))\n+   && NDS32_IS_GPR_REGNUM (REGNO (operands[1]))\n+   && ((REGNO (operands[0]) & 0x1) == 0)\n+   && ((REGNO (operands[1]) & 0x1) == 0)\n+   && (REGNO (operands[0]) + 1) == REGNO (operands[2])\n+   && (REGNO (operands[1]) + 1) == REGNO (operands[3])\"\n+  \"movd44\\t%0, %1\"\n+  [(set_attr \"type\"   \"alu\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Merge two fcpyss to fcpysd.\n+(define_peephole2\n+  [(set (match_operand:SF 0 \"float_even_register_operand\" \"\")\n+\t(match_operand:SF 1 \"float_even_register_operand\" \"\"))\n+   (set (match_operand:SF 2 \"float_odd_register_operand\"  \"\")\n+\t(match_operand:SF 3 \"float_odd_register_operand\"  \"\"))]\n+  \"(TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+   && REGNO (operands[0]) == REGNO (operands[2]) - 1\n+   && REGNO (operands[1]) == REGNO (operands[3]) - 1\"\n+  [(set (match_dup 4) (match_dup 5))]\n+  {\n+    operands[4] = gen_rtx_REG (DFmode, REGNO (operands[0]));\n+    operands[5] = gen_rtx_REG (DFmode, REGNO (operands[1]));\n+  })\n+\n+(define_peephole2\n+  [(set (match_operand:SF 0 \"float_odd_register_operand\"  \"\")\n+\t(match_operand:SF 1 \"float_odd_register_operand\"  \"\"))\n+   (set (match_operand:SF 2 \"float_even_register_operand\" \"\")\n+\t(match_operand:SF 3 \"float_even_register_operand\" \"\"))]\n+  \"(TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+   && REGNO (operands[2]) == REGNO (operands[0]) - 1\n+   && REGNO (operands[3]) == REGNO (operands[1]) - 1\"\n+  [(set (match_dup 4) (match_dup 5))]\n+  {\n+    operands[4] = gen_rtx_REG (DFmode, REGNO (operands[2]));\n+    operands[5] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n+  })\n+\n+;; ------------------------------------------------------------------------\n+;; GCC will prefer [u]divmodsi3 rather than [u]divsi3 even remainder is\n+;; unused, so we use split to drop mod operation for lower register pressure.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\")\n+\t\t(match_operand:SI 2 \"register_operand\")))\n+   (set (match_operand:SI 3 \"register_operand\")\n+\t(mod:SI (match_dup 1) (match_dup 2)))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[3])) != NULL\n+   && can_create_pseudo_p ()\"\n+  [(set (match_dup 0)\n+\t(div:SI (match_dup 1)\n+\t\t(match_dup 2)))])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\")\n+\t\t (match_operand:SI 2 \"register_operand\")))\n+   (set (match_operand:SI 3 \"register_operand\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[3])) != NULL\n+   && can_create_pseudo_p ()\"\n+  [(set (match_dup 0)\n+\t(udiv:SI (match_dup 1)\n+\t\t (match_dup 2)))])\n+\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\"))))]\n+  \"NDS32_EXT_DSP_P ()\n+   && peep2_regno_dead_p (1, WORDS_BIG_ENDIAN ? REGNO (operands[0]) + 1 : REGNO (operands[0]))\"\n+  [(const_int 1)]\n+{\n+  rtx highpart = nds32_di_high_part_subreg (operands[0]);\n+  emit_insn (gen_smulsi3_highpart (highpart, operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"nds32_general_register_operand\" \"\")\n+\t(match_operand:DI 1 \"nds32_general_register_operand\" \"\"))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[0])) != NULL\n+   || find_regno_note (insn, REG_UNUSED, REGNO (operands[0]) + 1) != NULL\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  rtx dead_note = find_regno_note (curr_insn, REG_UNUSED, REGNO (operands[0]));\n+  HOST_WIDE_INT offset;\n+  if (dead_note == NULL_RTX)\n+    offset = 0;\n+  else\n+    offset = 4;\n+  operands[0] = simplify_gen_subreg (\n+\t\t  SImode, operands[0],\n+\t\t  DImode, offset);\n+  operands[1] = simplify_gen_subreg (\n+\t\t  SImode, operands[1],\n+\t\t  DImode, offset);\n+})"}]}