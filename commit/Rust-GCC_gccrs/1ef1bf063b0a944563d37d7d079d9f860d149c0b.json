{"sha": "1ef1bf063b0a944563d37d7d079d9f860d149c0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmMWJmMDYzYjBhOTQ0NTYzZDM3ZDdkMDc5ZDlmODYwZDE0OWMwYg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1999-08-10T16:19:16Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-08-10T16:19:16Z"}, "message": "except.h (eh_nesting_info): Add new structure defintion.\n\n\nTue Aug 10 10:47:42 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n\n\t* except.h (eh_nesting_info): Add new structure defintion.\n\t(init_eh_nesting_info, free_eh_nesting_info): Add function prototypes.\n\t(reachable_handlers, update_rethrow_references): Add function\n\tprototypes.\n\t* rtl.h (struct rtvec_def): Update comments.  REG_EH_RETHROW takes\n\ta rethrow symbol instead of an integer exception region number.\n\t* flow.c (Make_edges): Use new exception nesting routines to determine\n\twhich handlers are reachable from a CALL or asynchronous insn.\n\tDont add an edge for calls with a REG_EH_REGION of -1 to non-local\n\tgoto receivers.\n\t(delete_eh_regions): Update rethrow labels, and don't delete\n\tregions which are the target of a rethrow.\n\t* except.c (struct func_eh_entry): Add rethrow_ref field, now we can\n\tavoid overloading the SYMBOL_REF_USED flag.\n\t(rethrow_symbol_map): Use new rethrow_ref field.\n\t(rethrow_used): Use new rethrow_ref field.\n\t(expand_rethrow): REG_EH_RETHROW now has a SYMBOL_REF instead\n\tof an integer.  Fix formatting.\n\t(output_exception_table_entry): Use new rethrow_ref field.\n\t(can_throw): Check for EH_REGION_NOTE before deciding\n\twhether a CALL can throw or not.\n\t(scan_region): Call rethrow_used() instead of accessing data structure.\n\t(update_rethrow_references): New function to make sure only regions\n\twhich are still targets of a rethrow are flagged as such.\n\t(process_nestinfo): New static function to initialize a handler\n\tlist for a specific region.\n\t(init_eh_nesting_info): New function to allocate and initialize\n\tthe list of all EH handlers reachable from all regions.\n\t(reachable_handlers): New function to retrieve the list of handlers\n\treachable from a specific region and insn.\n\t(free_eh_nesting_info): New function to dispose of a list of\n\treachable handlers.\n\nFrom-SVN: r28647", "tree": {"sha": "2b4a46a35a3de3f7ea944875d45ee6b88e31d370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4a46a35a3de3f7ea944875d45ee6b88e31d370"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ef1bf063b0a944563d37d7d079d9f860d149c0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef1bf063b0a944563d37d7d079d9f860d149c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef1bf063b0a944563d37d7d079d9f860d149c0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef1bf063b0a944563d37d7d079d9f860d149c0b/comments", "author": null, "committer": null, "parents": [{"sha": "a8688bd6e92665a50b78fb7b5331c879f1f99801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8688bd6e92665a50b78fb7b5331c879f1f99801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8688bd6e92665a50b78fb7b5331c879f1f99801"}], "stats": {"total": 494, "additions": 429, "deletions": 65}, "files": [{"sha": "040946176038e922b58b2bbbf0b692cda04b7df6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ef1bf063b0a944563d37d7d079d9f860d149c0b", "patch": "@@ -1,3 +1,38 @@\n+Tue Aug 10 10:47:42 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* except.h (eh_nesting_info): Add new structure defintion.\n+\t(init_eh_nesting_info, free_eh_nesting_info): Add function prototypes.\n+\t(reachable_handlers, update_rethrow_references): Add function \n+\tprototypes.\n+\t* rtl.h (struct rtvec_def): Update comments.  REG_EH_RETHROW takes\n+\ta rethrow symbol instead of an integer exception region number.\n+\t* flow.c (Make_edges): Use new exception nesting routines to determine \n+\twhich handlers are reachable from a CALL or asynchronous insn.\n+\tDont add an edge for calls with a REG_EH_REGION of -1 to non-local\n+\tgoto receivers.\n+\t(delete_eh_regions): Update rethrow labels, and don't delete \n+\tregions which are the target of a rethrow.\n+\t* except.c (struct func_eh_entry): Add rethrow_ref field, now we can\n+\tavoid overloading the SYMBOL_REF_USED flag.\n+\t(rethrow_symbol_map): Use new rethrow_ref field.\n+\t(rethrow_used): Use new rethrow_ref field.\n+\t(expand_rethrow): REG_EH_RETHROW now has a SYMBOL_REF instead \n+\tof an integer.  Fix formatting.\n+\t(output_exception_table_entry): Use new rethrow_ref field.\n+\t(can_throw): Check for EH_REGION_NOTE before deciding\n+\twhether a CALL can throw or not.\n+\t(scan_region): Call rethrow_used() instead of accessing data structure.\n+\t(update_rethrow_references): New function to make sure only regions\n+\twhich are still targets of a rethrow are flagged as such.\n+\t(process_nestinfo): New static function to initialize a handler \n+\tlist for a specific region.\n+\t(init_eh_nesting_info): New function to allocate and initialize\n+\tthe list of all EH handlers reachable from all regions.\n+\t(reachable_handlers): New function to retrieve the list of handlers\n+\treachable from a specific region and insn.\n+\t(free_eh_nesting_info): New function to dispose of a list of\n+\treachable handlers.\n+\n Tue Aug 10 10:39:31 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* flow.c (split_edge): Set JUMP_LABEL field."}, {"sha": "952021bbdcc6ba270b85ecad86cf64e2039e2d8f", "filename": "gcc/except.c", "status": "modified", "additions": 319, "deletions": 21, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1ef1bf063b0a944563d37d7d079d9f860d149c0b", "patch": "@@ -677,8 +677,9 @@ receive_exception_label (handler_label)\n \n struct func_eh_entry \n {\n-  int range_number;   /* EH region number from EH NOTE insn's */\n-  rtx rethrow_label;  /* Label for rethrow */\n+  int range_number;   /* EH region number from EH NOTE insn's.  */\n+  rtx rethrow_label;  /* Label for rethrow.  */\n+  int rethrow_ref;    /* Is rethrow referenced?  */\n   struct handler_info *handlers;\n };\n \n@@ -981,7 +982,7 @@ rethrow_symbol_map (sym, map)\n           {\n             x = duplicate_eh_handlers (CODE_LABEL_NUMBER (l1), y, map);\n             /* Since we're mapping it, it must be used. */\n-            SYMBOL_REF_USED (function_eh_regions[x].rethrow_label) = 1;\n+            function_eh_regions[x].rethrow_ref = 1;\n           }\n         return function_eh_regions[x].rethrow_label;\n       }\n@@ -994,8 +995,8 @@ rethrow_used (region)\n {\n   if (flag_new_exceptions)\n     {\n-      rtx lab = function_eh_regions[find_func_region (region)].rethrow_label;\n-      return (SYMBOL_REF_USED (lab));\n+      int ret = function_eh_regions[find_func_region (region)].rethrow_ref;\n+      return ret;\n     }\n   return 0;\n }\n@@ -1900,23 +1901,24 @@ expand_rethrow (label)\n   else\n     if (flag_new_exceptions)\n       {\n-        rtx insn, val;\n-        if (label == NULL_RTX)\n-          label = last_rethrow_symbol;\n-        emit_library_call (rethrow_libfunc, 0, VOIDmode, 1, label, Pmode);\n-        SYMBOL_REF_USED (label) = 1;\n+\trtx insn, val;\n+\tint region;\n+\tif (label == NULL_RTX)\n+\t  label = last_rethrow_symbol;\n+\temit_library_call (rethrow_libfunc, 0, VOIDmode, 1, label, Pmode);\n+\tregion = find_func_region (eh_region_from_symbol (label));\n+\tfunction_eh_regions[region].rethrow_ref = 1;\n \n \t/* Search backwards for the actual call insn.  */\n-        insn = get_last_insn ();\n+\tinsn = get_last_insn ();\n \twhile (GET_CODE (insn) != CALL_INSN)\n \t  insn = PREV_INSN (insn);\n \tdelete_insns_since (insn);\n-\t\n-        /* Mark the label/symbol on the call. */\n-        val = GEN_INT (eh_region_from_symbol (label));\n-        REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EH_RETHROW, val,\n+\n+\t/* Mark the label/symbol on the call. */\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EH_RETHROW, label,\n \t\t\t\t\t      REG_NOTES (insn));\n-        emit_barrier ();\n+\temit_barrier ();\n       }\n     else\n       emit_jump (label);\n@@ -2062,7 +2064,7 @@ output_exception_table_entry (file, n)\n   if (rethrow != NULL_RTX && !flag_new_exceptions)\n       rethrow = NULL_RTX;\n   if (rethrow != NULL_RTX && handler == NULL)\n-    if (! SYMBOL_REF_USED (rethrow))\n+    if (! function_eh_regions[index].rethrow_ref)\n       rethrow = NULL_RTX;\n \n \n@@ -2373,9 +2375,14 @@ static int\n can_throw (insn)\n      rtx insn;\n {\n-  /* Calls can always potentially throw exceptions.  */\n+  /* Calls can always potentially throw exceptions, unless they have\n+     a REG_EH_REGION note with a value of 0 or less.  */\n   if (GET_CODE (insn) == CALL_INSN)\n-    return 1;\n+    {\n+      rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+      if (!note || XINT (XEXP (note, 0), 0) > 0)\n+\treturn 1;\n+    }\n \n   if (asynchronous_exceptions)\n     {\n@@ -2416,9 +2423,8 @@ scan_region (insn, n, delete_outer)\n   /* Assume we can delete the region.  */\n   int delete = 1;\n \n-  int r = find_func_region (n);\n   /* Can't delete something which is rethrown to. */\n-  if (SYMBOL_REF_USED((function_eh_regions[r].rethrow_label)))\n+  if (rethrow_used (n))\n     delete = 0;\n \n   if (insn == NULL_RTX\n@@ -2533,6 +2539,53 @@ exception_optimize ()\n \t}\n     }\n }\n+\n+/* This function determines whether any of the exception regions in the\n+   current function are targets of a rethrow or not, and set the \n+   reference flag according.  */\n+void\n+update_rethrow_references ()\n+{\n+  rtx insn;\n+  int x, region;\n+  int *saw_region, *saw_rethrow;\n+\n+  if (!flag_new_exceptions)\n+    return;\n+\n+  saw_region = (int *) alloca (current_func_eh_entry * sizeof (int));\n+  saw_rethrow = (int *) alloca (current_func_eh_entry * sizeof (int));\n+  bzero ((char *) saw_region, (current_func_eh_entry * sizeof (int)));\n+  bzero ((char *) saw_rethrow, (current_func_eh_entry * sizeof (int)));\n+\n+  /* Determine what regions exist, and whether there are any rethrows\n+     to those regions or not.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == CALL_INSN)\n+      {\n+\trtx note = find_reg_note (insn, REG_EH_RETHROW, NULL_RTX);\n+\tif (note)\n+\t  {\n+            region = eh_region_from_symbol (XEXP (note, 0));\n+\t    region = find_func_region  (region);\n+\t    saw_rethrow[region] = 1;\n+\t  }\n+      }\n+    else\n+      if (GET_CODE (insn) == NOTE)\n+        {\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t    {\n+\t      region = find_func_region (NOTE_BLOCK_NUMBER (insn));\n+\t      saw_region[region] = 1;\n+\t    }\n+\t}\n+\n+  /* For any regions we did see, set the referenced flag.  */\n+  for (x = 0; x < current_func_eh_entry; x++)\n+    if (saw_region[x])\n+      function_eh_regions[x].rethrow_ref = saw_rethrow[x];\n+}\n \f\n /* Various hooks for the DWARF 2 __throw routine.  */\n \n@@ -2853,4 +2906,249 @@ in_same_eh_region (insn1, insn2)\n   ret = (insn_eh_region[uid1] == insn_eh_region[uid2]);\n   return ret;\n }\n+\f\n+\n+/* This function will initialize the handler list for a specified block.\n+   It may recursively call itself if the outer block hasn't been processed\n+   yet.  At some point in the future we can trim out handlers which we\n+   know cannot be called. (ie, if a block has an INT type handler,\n+   control will never be passed to an outer INT type handler).  */\n+static void \n+process_nestinfo (block, info, nested_eh_region)\n+     int block;\n+     eh_nesting_info *info;\n+     int *nested_eh_region;\n+{\n+  handler_info *ptr, *last_ptr = NULL;\n+  int x, y, count = 0;\n+  int extra = 0;\n+  handler_info **extra_handlers;\n+  int index = info->region_index[block];\n+\n+  /* If we've already processed this block, simply return. */\n+  if (info->num_handlers[index] > 0)\n+    return;\n+\n+  for (ptr = get_first_handler (block); ptr; last_ptr = ptr, ptr = ptr->next)\n+    count++;\n+\n+ /* pick up any information from the next outer region.  It will already\n+    contain a summary of itself and all outer regions to it.  */\n+\n+  if (nested_eh_region [block] != 0) \n+    {\n+      int nested_index = info->region_index[nested_eh_region[block]];\n+      process_nestinfo (nested_eh_region[block], info, nested_eh_region);\n+      extra = info->num_handlers[nested_index];\n+      extra_handlers = info->handlers[nested_index];\n+      info->outer_index[index] = nested_index;\n+    }\n+\n+  /* If the last handler is either a CATCH_ALL or a cleanup, then we\n+     won't use the outer ones since we know control will not go past the\n+     catch-all or cleanup.  */\n+\n+  if (last_ptr != NULL && (last_ptr->type_info == NULL \n+  \t\t\t   || last_ptr->type_info == CATCH_ALL_TYPE))\n+    extra = 0;\n+\n+  info->num_handlers[index] = count + extra;\n+  info->handlers[index] = (handler_info **) malloc ((count + extra) \n+  \t\t\t\t\t\t    * sizeof (handler_info **));\n+\n+  /* First put all our handlers into the list.  */\n+  ptr = get_first_handler (block);\n+  for (x = 0; x < count; x++)\n+    {\n+      info->handlers[index][x] = ptr;\n+      ptr = ptr->next;\n+    }\n+\n+  /* Now add all the outer region handlers, if they aren't they same as \n+     one of the types in the current block.  We won't worry about\n+     derived types yet, we'll just look for the exact type.  */\n+  for (y =0, x = 0; x < extra ; x++)\n+    {\n+      int i, ok;\n+      ok = 1;\n+      /* Check to see if we have a type duplication.  */\n+      for (i = 0; i < count; i++)\n+        if (info->handlers[index][i]->type_info == extra_handlers[x]->type_info)\n+\t  {\n+\t    ok = 0;\n+\t    /* Record one less handler.  */\n+\t    (info->num_handlers[index])--;\n+\t    break;\n+\t  }\n+      if (ok)\n+        {\n+\t  info->handlers[index][y + count] = extra_handlers[x];\n+\t  y++;\n+\t}\n+    }\n+}\n+\n+/* This function will allocate and initialize an eh_nesting_info structure. \n+   It returns a pointer to the completed data structure.  If there are\n+   no exception regions, a NULL value is returned.  */\n+eh_nesting_info *\n+init_eh_nesting_info ()\n+{\n+  int *nested_eh_region;\n+  int region_count = 0;\n+  rtx eh_note = NULL_RTX;\n+  eh_nesting_info *info;\n+  rtx insn;\n+  int x;\n+\n+  info = (eh_nesting_info *) malloc (sizeof (eh_nesting_info));\n+  info->region_index = (int *) malloc ((max_label_num () + 1) * sizeof (int));\n+  bzero ((char *) info->region_index, (max_label_num () + 1) * sizeof (int));\n+\n+  nested_eh_region = (int *) alloca ((max_label_num () + 1) * sizeof (int));\n+  bzero ((char *) nested_eh_region, (max_label_num () + 1) * sizeof (int));\n \n+  /* Create the nested_eh_region list.  If indexed with a block number, it \n+     returns the block number of the next outermost region, if any. \n+     We can count the number of regions and initialize the region_index\n+     vector at the same time.  */\n+  for (insn = get_insns(); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+          if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+            {\n+\t      int block = NOTE_BLOCK_NUMBER (insn);\n+\t      region_count++;\n+\t      info->region_index[block] = region_count;\n+              if (eh_note)\n+                nested_eh_region [block] =\n+                                     NOTE_BLOCK_NUMBER (XEXP (eh_note, 0));\n+              else\n+                nested_eh_region [block] = 0;\n+              eh_note = gen_rtx_EXPR_LIST (VOIDmode, insn, eh_note);\n+            }\n+          else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n+            eh_note = XEXP (eh_note, 1);\n+        }\n+    }\n+  \n+  /* If there are no regions, wrap it up now.  */\n+  if (region_count == 0)\n+    {\n+      free (info->region_index);\n+      free (info);\n+      return NULL;\n+    }\n+\n+  region_count++;\n+  info->handlers = (handler_info ***) malloc (region_count \n+\t\t\t\t\t      * sizeof (handler_info ***));\n+  info->num_handlers = (int *) malloc (region_count * sizeof (int));\n+  info->outer_index = (int *) malloc (region_count * sizeof (int));\n+\n+  bzero ((char *) info->handlers, region_count * sizeof (rtx *));\n+  bzero ((char *) info->num_handlers, region_count * sizeof (int));\n+  bzero ((char *) info->outer_index, region_count * sizeof (int));\n+\n+ /* Now initialize the handler lists for all exception blocks.  */\n+  for (x = 0; x <= max_label_num (); x++)\n+    {\n+      if (info->region_index[x] != 0)\n+\tprocess_nestinfo (x, info, nested_eh_region);\n+    }\n+  info->region_count = region_count;\n+  return info;\n+}\n+\n+\n+/* This function is used to retreive the vector of handlers which \n+   can be reached by a given insn in a given exception region.\n+   BLOCK is the exception block the insn is in.\n+   INFO is the eh_nesting_info structure.\n+   INSN is the (optional) insn within the block.  If insn is not NULL_RTX,\n+   it may contain reg notes which modify its throwing behavior, and\n+   these will be obeyed.  If NULL_RTX is passed, then we simply return the\n+   handlers for block.\n+   HANDLERS is the address of a pointer to a vector of handler_info pointers.\n+   Upon return, this will have the handlers which can be reached by block.\n+   This function returns the number of elements in the handlers vector.  */\n+int \n+reachable_handlers (block, info, insn, handlers)\n+     int block;\n+     eh_nesting_info *info;\n+     rtx insn ;\n+     handler_info ***handlers;\n+{\n+  int index = 0;\n+  *handlers = NULL;\n+\n+  if (info == NULL)\n+    return 0;\n+  if (block > 0)\n+    index = info->region_index[block];\n+\n+  if (insn && GET_CODE (insn) == CALL_INSN)\n+    {\n+      /* RETHROWs specify a region number from which we are going to rethrow.\n+\t This means we wont pass control to handlers in the specified\n+\t region, but rather any region OUTSIDE the specified region.\n+\t We accomplish this by setting block to the outer_index of the\n+\t specified region.  */\n+      rtx note = find_reg_note (insn, REG_EH_RETHROW, NULL_RTX);\n+      if (note)\n+\t{\n+          index = eh_region_from_symbol (XEXP (note, 0));\n+\t  index = info->region_index[index];\n+\t  if (index)\n+\t    index = info->outer_index[index];\n+\t}\n+      else\n+        {\n+\t  /* If there is no rethrow, we look for a REG_EH_REGION, and\n+\t     we'll throw from that block.  A value of 0 or less\n+\t     indicates that this insn cannot throw.  */\n+\t  note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\t  if (note)\n+\t    {\n+\t      int b = XINT (XEXP (note, 0), 0);\n+\t      if (b <= 0)\n+\t        index = 0;\n+\t      else\n+\t\tindex = info->region_index[b];\n+\t    }\n+\t}\n+    }\n+  /* If we reach this point, and index is 0, there is no throw.  */\n+  if (index == 0)\n+    return 0;\n+  \n+  *handlers = info->handlers[index];\n+  return info->num_handlers[index];\n+}\n+\n+\n+/* This function will free all memory associated with the eh_nesting info.  */\n+\n+void \n+free_eh_nesting_info (info)\n+     eh_nesting_info *info;\n+{\n+  int x;\n+  if (info != NULL)\n+    {\n+      if (info->region_index)\n+        free (info->region_index);\n+      if (info->num_handlers)\n+        free (info->num_handlers);\n+      if (info->outer_index)\n+        free (info->outer_index);\n+      if (info->handlers)\n+        {\n+\t  for (x = 0; x < info->region_count; x++)\n+\t    if (info->handlers[x])\n+\t      free (info->handlers[x]);\n+\t  free (info->handlers);\n+\t}\n+    }\n+}"}, {"sha": "73bbe4dc8d7303a6e0aeaf71ff58e00d97acd6b9", "filename": "gcc/except.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=1ef1bf063b0a944563d37d7d079d9f860d149c0b", "patch": "@@ -266,6 +266,11 @@ rtx rethrow_symbol_map                          PROTO((rtx, rtx (*)(rtx)));\n \n int rethrow_used                                PROTO((int));\n \n+/* Update the rethrow references to reflect rethrows which have been\n+   optimized away.  */\n+\n+void update_rethrow_references\t\t\tPROTO((void));\n+\n /* Return the region number a this is the rethrow label for. */\n \n int eh_region_from_symbol                       PROTO((rtx));\n@@ -278,6 +283,46 @@ struct handler_info *get_first_handler          PROTO((int));\n \n int find_all_handler_type_matches               PROTO((void ***));\n \n+/* The eh_nesting_info structure is used to find a list of valid handlers\n+   for any arbitrary exception region.  When init_eh_nesting_info is called,\n+   the information is all pre-calculated and entered in this structure.\n+   REGION_INDEX is a vector over all possible region numbers.  Since the\n+   number of regions is typically much smaller than the range of block\n+   numbers, this is a sparse vector and the other data structures are \n+   represented as dense vectors.  Indexed with an exception region number, this\n+   returns the index to use in the other data structures to retreive the\n+   correct information.\n+   HANDLERS is an array of vectors which point to handler_info structures.\n+   when indexed, it gives the list of all possible handlers which can \n+   be reached by a throw from this exception region.\n+   NUM_HANDLERS is the equivilent array indicating how many handler\n+   pointers there are in the HANDLERS vector.\n+   OUTER_INDEX indicates which index represents the information for the\n+   outer block.  0 indicates there is no outer context.\n+   REGION_COUNT is the number of regions.  */\n+\n+typedef struct eh_nesting \n+{\n+  int *region_index;\n+  handler_info ***handlers;\n+  int *num_handlers;\n+  int *outer_index;\n+  int region_count;\n+} eh_nesting_info;\n+\n+/* Initialize the eh_nesting_info structure.  */\n+\n+eh_nesting_info *init_eh_nesting_info \t\tPROTO((void));\n+\n+/* Get a list of handlers reachable from a an exception region/insn.  */\n+\n+int reachable_handlers \t\t\tPROTO((int, eh_nesting_info *, rtx, \n+\t\t\t\t\t       handler_info ***handlers));\n+\n+/* Free the eh_nesting_info structure.  */\n+\n+void free_eh_nesting_info \t\t\tPROTO((eh_nesting_info *));\n+\n extern void init_eh\t\t\t\tPROTO((void));\n \n /* Initialization for the per-function EH data.  */"}, {"sha": "ccec7929d359bf640a0d3b63d253e20901786577", "filename": "gcc/flow.c", "status": "modified", "additions": 24, "deletions": 38, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=1ef1bf063b0a944563d37d7d079d9f860d149c0b", "patch": "@@ -867,6 +867,7 @@ make_edges (label_value_list, bb_eh_end)\n      rtx *bb_eh_end;\n {\n   int i;\n+  eh_nesting_info *eh_nest_info = init_eh_nesting_info ();\n \n   /* Assume no computed jump; revise as we create edges.  */\n   current_function_has_computed_jump = 0;\n@@ -976,41 +977,19 @@ make_edges (label_value_list, bb_eh_end)\n       if (code == CALL_INSN || asynchronous_exceptions)\n \t{\n \t  int is_call = (code == CALL_INSN ? EDGE_ABNORMAL_CALL : 0);\n-\t  handler_info *ptr;\n+\t  handler_info **handler_list;\n+\t  int eh_region = -1;\n+\t  int num;\n \n-\t  /* Use REG_EH_RETHROW and REG_EH_REGION if available.  */\n-\t  /* ??? REG_EH_REGION is not generated presently.  Is it\n-\t     inteded that there be multiple notes for the regions?\n-\t     or is my eh_list collection redundant with handler linking?  */\n+\t  if (eh_list)\n+\t    eh_region = NOTE_BLOCK_NUMBER (XEXP (eh_list, 0));\n \n-\t  x = find_reg_note (insn, REG_EH_RETHROW, 0);\n-\t  if (!x)\n-\t    x = find_reg_note (insn, REG_EH_REGION, 0);\n-\t  if (x)\n+\t  num = reachable_handlers (eh_region, eh_nest_info,\n+\t\t\t\t    insn, &handler_list);\n+\t  for ( ; num > 0; num--)\n \t    {\n-\t      if (XINT (XEXP (x, 0), 0) > 0)\n-\t\t{\n-\t\t  ptr = get_first_handler (XINT (XEXP (x, 0), 0));\n-\t\t  while (ptr)\n-\t\t    {\n-\t\t      make_label_edge (bb, ptr->handler_label,\n-\t\t\t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n-\t\t      ptr = ptr->next;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      for (x = eh_list; x; x = XEXP (x, 1))\n-\t\t{\n-\t\t  ptr = get_first_handler (NOTE_BLOCK_NUMBER (XEXP (x, 0)));\n-\t\t  while (ptr)\n-\t\t    {\n-\t\t      make_label_edge (bb, ptr->handler_label,\n-\t\t\t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n-\t\t      ptr = ptr->next;\n-\t\t    }\n-\t\t}\n+\t      make_label_edge (bb, handler_list[num - 1]->handler_label,\n+\t\t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n \t    }\n \n \t  if (code == CALL_INSN && nonlocal_goto_handler_labels)\n@@ -1022,10 +1001,13 @@ make_edges (label_value_list, bb_eh_end)\n \t\t gotos do not have their addresses taken, then only calls to\n \t\t those functions or to other nested functions that use them\n \t\t could possibly do nonlocal gotos.  */\n-\n-\t      for (x = nonlocal_goto_handler_labels; x ; x = XEXP (x, 1))\n-\t        make_label_edge (bb, XEXP (x, 0),\n-\t\t\t         EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+\t      /* We do know that a REG_EH_REGION note with a value less\n+\t\t than 0 is guaranteed not to perform a non-local goto.  */\n+\t      rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\t      if (!note || XINT (XEXP (note, 0), 0) >=  0)\n+\t\tfor (x = nonlocal_goto_handler_labels; x ; x = XEXP (x, 1))\n+\t\t  make_label_edge (bb, XEXP (x, 0),\n+\t\t\t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n \t    }\n \t}\n \n@@ -1050,6 +1032,7 @@ make_edges (label_value_list, bb_eh_end)\n \t    make_edge (bb, BASIC_BLOCK (i + 1), EDGE_FALLTHRU);\n \t}\n     }\n+  free_eh_nesting_info (eh_nest_info);\n }\n \n /* Create an edge between two basic blocks.  FLAGS are auxiliary information\n@@ -1615,15 +1598,18 @@ delete_eh_regions ()\n {\n   rtx insn;\n \n+  update_rethrow_references ();\n+\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE)\n       {\n \tif ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n \t    (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n \t  {\n \t    int num = CODE_LABEL_NUMBER (insn);\n-\t    /* A NULL handler indicates a region is no longer needed */\n-\t    if (get_first_handler (num) == NULL)\n+\t    /* A NULL handler indicates a region is no longer needed,\n+\t       as long as it isn't the target of a rethrow.  */\n+\t    if (get_first_handler (num) == NULL && ! rethrow_used (num))\n \t      {\n \t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\tNOTE_SOURCE_FILE (insn) = 0;"}, {"sha": "705da5e2cdd8f5d929712a45226620dc008137c2", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef1bf063b0a944563d37d7d079d9f860d149c0b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1ef1bf063b0a944563d37d7d079d9f860d149c0b", "patch": "@@ -344,13 +344,13 @@ typedef struct rtvec_def{\n    rtx is used instead of intuition.  */\n /*   REG_EH_REGION is used to indicate what exception region an INSN\n    belongs in.  This can be used to indicate what region a call may throw\n-   to.  A REGION of 0 indicates that a call cannot throw at all.\n-   A REGION  of -1 indicates that it cannot throw, nor will it execute\n+   to. a REGION of 0 indicates that a call cannot throw at all.\n+   a REGION  of -1 indicates that it cannot throw, nor will it execute\n    a non-local goto.\n-     REG_EH_RETHROW is used to indicate what that a call is actually a\n-   call to rethrow, and specifies which region the rethrow is targetting.\n-   This provides a way to generate the non standard flow edges required \n-   for a rethrow.  */\n+     REG_EH_RETHROW is used to indicate that a call is actually a\n+   call to rethrow, and specifies the rethrow symbol for the region \n+   the rethrow is targetting.  This provides a way to generate the \n+   non standard flow edges required for a rethrow. */\n    \n \n #define REG_NOTES(INSN)\t((INSN)->fld[6].rtx)"}]}