{"sha": "0eed45bbe286757689d39d5f345842b67c023ce4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVlZDQ1YmJlMjg2NzU3Njg5ZDM5ZDVmMzQ1ODQyYjY3YzAyM2NlNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T09:53:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T09:53:24Z"}, "message": "[multiple changes]\n\n2010-06-23  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch11.adb (Expand_Local_Exception_Handlers): Propagate the end\n\tlabel to the new sequence of statements.  Set the sloc of the raise\n\tstatement onto the new goto statements.\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* a-stuten.ads, a-stuten.adb: New files.\n\t* impunit.adb: Add engtry for Ada.Strings.UTF_Encoding (a-stuten.ads)\n\t* Makefile.rtl: Add entry for a-stuten (Ada.Strings.UTF_Encoding)\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Add documentation of -gnat12 switch\n\tAdd documentation of -gnatX switch.\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.ads: Include the current Ada_Version in the info for pending\n\tinstance bodies, so that declaration and body are compiled with the\n\tsame Ada_Version.\n\t* inline.adb: Move with_clause for Opt to spec.\n\t* sem_ch12.adb (Analyze_Package_Instantiation,\n\tAnalyze_Subprogram_Instantiation): Save current Ada_Version in\n\tPending_Instantiation information.\n\t(Instantiate_Package_Body, Instantiate_Subprogram_Body,\n\tInline_Package_Body): Use the Ada_Version present in the body\n\tinformation.\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* usage.adb: Add documentation for -gnat12 switch.\n\t* errout.ads: Add VMS alias entry for -gnat12 switch\n\t* gnat_rm.texi: Add documentation for pragma Ada_12 and Ada_2012\n\tAdd documentation for pragma Extensions_Allowed.\n\t* opt.ads: Add entry for Ada 2012 mode.\n\t* sem_ch4.adb, par-ch3.adb, par-ch4.adb: Use new Ada 2012 mode for 2012\n\tfeatures.\n\t* sem_prag.adb, par-prag.adb: Add processing for pragma Ada_12 and\n\tAda_2012.\n\t* sem_ch13.adb: Add handling for Ada 2012 mode.\n\t* snames.ads-tmpl: Add entries for pragma Ada_2012 and Ada_12.\n\t* switch-c.adb: Add handling for -gnat12 switch.\n\tImplement -gnat2005 and -gnat2012.\n\t* usage.adb: Add documentation for -gnat12 switch.\n\t* vms_data.ads: Add /12 switch for Ada 2012 mode.\n\nFrom-SVN: r161268", "tree": {"sha": "682a591ce203dec73771dbec80125a9be4066201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/682a591ce203dec73771dbec80125a9be4066201"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eed45bbe286757689d39d5f345842b67c023ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eed45bbe286757689d39d5f345842b67c023ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eed45bbe286757689d39d5f345842b67c023ce4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eed45bbe286757689d39d5f345842b67c023ce4/comments", "author": null, "committer": null, "parents": [{"sha": "6b8cdb0ac2a57a4d025254e4e7e9cbb54fc72862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8cdb0ac2a57a4d025254e4e7e9cbb54fc72862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8cdb0ac2a57a4d025254e4e7e9cbb54fc72862"}], "stats": {"total": 1636, "additions": 1541, "deletions": 95}, "files": [{"sha": "6874fe56679432871a6b91ee86a4ebedf95489d2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -1,3 +1,51 @@\n+2010-06-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch11.adb (Expand_Local_Exception_Handlers): Propagate the end\n+\tlabel to the new sequence of statements.  Set the sloc of the raise\n+\tstatement onto the new goto statements.\n+\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-stuten.ads, a-stuten.adb: New files.\n+\t* impunit.adb: Add engtry for Ada.Strings.UTF_Encoding (a-stuten.ads)\n+\t* Makefile.rtl: Add entry for a-stuten (Ada.Strings.UTF_Encoding)\n+\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Add documentation of -gnat12 switch\n+\tAdd documentation of -gnatX switch.\n+\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* inline.ads: Include the current Ada_Version in the info for pending\n+\tinstance bodies, so that declaration and body are compiled with the\n+\tsame Ada_Version.\n+\t* inline.adb: Move with_clause for Opt to spec.\n+\t* sem_ch12.adb (Analyze_Package_Instantiation,\n+\tAnalyze_Subprogram_Instantiation): Save current Ada_Version in\n+\tPending_Instantiation information.\n+\t(Instantiate_Package_Body, Instantiate_Subprogram_Body,\n+\tInline_Package_Body): Use the Ada_Version present in the body\n+\tinformation.\n+\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* usage.adb: Add documentation for -gnat12 switch.\n+\t* errout.ads: Add VMS alias entry for -gnat12 switch\n+\t* gnat_rm.texi: Add documentation for pragma Ada_12 and Ada_2012\n+\tAdd documentation for pragma Extensions_Allowed.\n+\t* opt.ads: Add entry for Ada 2012 mode.\n+\t* sem_ch4.adb, par-ch3.adb, par-ch4.adb: Use new Ada 2012 mode for 2012\n+\tfeatures.\n+\t* sem_prag.adb, par-prag.adb: Add processing for pragma Ada_12 and\n+\tAda_2012.\n+\t* sem_ch13.adb: Add handling for Ada 2012 mode.\n+\t* snames.ads-tmpl: Add entries for pragma Ada_2012 and Ada_12.\n+\t* switch-c.adb: Add handling for -gnat12 switch.\n+\tImplement -gnat2005 and -gnat2012.\n+\t* usage.adb: Add documentation for -gnat12 switch.\n+\t* vms_data.ads: Add /12 switch for Ada 2012 mode.\n+\n 2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Allocator): Fix potential crash when using"}, {"sha": "236ddde0967d959dff43201e70dd2680a49c0ec8", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -211,6 +211,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ststio$(objext) \\\n   a-stunau$(objext) \\\n   a-stunha$(objext) \\\n+  a-stuten$(objext) \\\n   a-stwibo$(objext) \\\n   a-stwifi$(objext) \\\n   a-stwiha$(objext) \\"}, {"sha": "7571bda08337d54c171076f138311778b6758781", "filename": "gcc/ada/a-stuten.adb", "status": "added", "additions": 1032, "deletions": 0, "changes": 1032, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fa-stuten.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fa-stuten.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stuten.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -0,0 +1,1032 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . S T R I N G S . U T F _ E N C O D I N G             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+-------------------------------------------------------------------------------\n+with Interfaces; use Interfaces;\n+with Unchecked_Conversion;\n+\n+package body Ada.Strings.UTF_Encoding is\n+\n+   function To_Unsigned_8 is new\n+     Unchecked_Conversion (Character, Unsigned_8);\n+\n+   function To_Unsigned_16 is new\n+     Unchecked_Conversion (Wide_Character, Unsigned_16);\n+\n+   function To_Unsigned_32 is new\n+     Unchecked_Conversion (Wide_Wide_Character, Unsigned_32);\n+\n+   --  Local subprograms\n+\n+   procedure Raise_Encoding_Error;\n+   --  Called if an invalid input encoding sequence is found by Decode\n+\n+   function Decode_UTF_8 (Item : String) return Wide_String;\n+   --  Equivalent to Decode (Item, UTF_8), but smaller and faster\n+\n+   function Decode_UTF_8 (Item : String) return Wide_Wide_String;\n+   --  Equivalent to Decode (Item, UTF_8), but smaller and faster\n+\n+   function Encode_UTF_8 (Item : Wide_String) return String;\n+   --  Equivalent to Encode (Item, UTF_8) but smaller and faster\n+\n+   function Encode_UTF_8 (Item : Wide_Wide_String) return String;\n+   --  Equivalent to Encode (Item, UTF_8) but smaller and faster\n+\n+   function Decode_UTF_16 (Item : Wide_String) return Wide_String;\n+   --  Equivalent to Decode (Item, UTF_16)\n+\n+   function Decode_UTF_16 (Item : Wide_String) return Wide_Wide_String;\n+   --  Equivalent to Decode (Item, UTF_16)\n+\n+   function Encode_UTF_16 (Item : Wide_String) return Wide_String;\n+   --  Equivalent to Encode (Item, UTF_16)\n+\n+   function Encode_UTF_16 (Item : Wide_Wide_String) return Wide_String;\n+   --  Equivalent to Encode (Item, UTF_16)\n+\n+   ------------\n+   -- Decode --\n+   ------------\n+\n+   --  String input with Wide_String output (short encodings)\n+\n+   function Decode\n+     (Item   : String;\n+      Scheme : Short_Encoding := UTF_8) return Wide_String\n+   is\n+   begin\n+      --  UTF-8 encoding case\n+\n+      if Scheme = UTF_8 then\n+         return Decode_UTF_8 (Item);\n+\n+      --  Case of UTF_16LE or UTF_16BE\n+\n+      else\n+         UTF16_XE : declare\n+            Input_UTF16 : Wide_String (1 .. Item'Length / 2);\n+            --  UTF_16 input string\n+\n+            Iptr : Natural;\n+            --  Pointer to next location to store in Input_UTF16\n+\n+            Ptr : Natural;\n+            --  Input string pointer\n+\n+            H, L : Natural range 0 .. 1;\n+            --  Offset for high and low order bytes\n+\n+         begin\n+            --  In both cases, the input string must be even in length, since\n+            --  we have two input characters for each input code in UTF_16.\n+\n+            if Item'Length mod 2 /= 0 then\n+               Raise_Encoding_Error;\n+            end if;\n+\n+            --  We first assemble the UTF_16 string from the input. Set offsets\n+            --  for the two bytes. For UTF_16LE we have low order/high order.\n+            --  For UTF_16BE we have high order/low order.\n+\n+            if Scheme = UTF_16LE then\n+               L := 0;\n+               H := 1;\n+            else\n+               L := 1;\n+               H := 0;\n+            end if;\n+\n+            --  Loop to convert input to UTF_16 form\n+\n+            Iptr := 1;\n+            Ptr := Item'First;\n+            while Ptr < Item'Last loop\n+               Input_UTF16 (Iptr) :=\n+                 Wide_Character'Val\n+                   (Unsigned_16 (To_Unsigned_8 (Item (Ptr + L)))\n+                     or\n+                    Shift_Left\n+                      (Unsigned_16 (To_Unsigned_8 (Item (Ptr + H))), 8));\n+               Iptr := Iptr + 1;\n+               Ptr := Ptr + 2;\n+            end loop;\n+\n+            --  Result is obtained by converting this UTF_16 input. Note that\n+            --  we rely on this nested call to Decode to skip any BOM present.\n+\n+            return Decode (Input_UTF16);\n+         end UTF16_XE;\n+      end if;\n+   end Decode;\n+\n+   --  String input with Wide_Wide_String output (short encodings)\n+\n+   function Decode\n+     (Item   : String;\n+      Scheme : Short_Encoding := UTF_8) return Wide_Wide_String\n+   is\n+   begin\n+      --  UTF-8 encoding case\n+\n+      if Scheme = UTF_8 then\n+         return Decode_UTF_8 (Item);\n+\n+      --  Case of UTF_16LE or UTF_16BE\n+\n+      else\n+         UTF16_XE : declare\n+            Input_UTF16 : Wide_String (1 .. Item'Length / 2);\n+            --  UTF_16 input string\n+\n+            Iptr : Natural;\n+            --  Pointer to next location to store in Input_UTF16\n+\n+            Ptr : Natural;\n+            --  Input string pointer\n+\n+            H, L : Integer range 0 .. 1;\n+            --  Offset for high and low order bytes\n+\n+         begin\n+            --  In both cases, the input string must be even in length, since\n+            --  we have two input characters for each input code in UTF_16.\n+\n+            if Item'Length mod 2 /= 0 then\n+               Raise_Encoding_Error;\n+            end if;\n+\n+            --  We first assemble the UTF_16 string from the input. Set offsets\n+            --  for the two bytes. For UTF_16LE we have low order/high order.\n+            --  For UTF_16BE we have high order/low order.\n+\n+            if Scheme = UTF_16LE then\n+               L := 0;\n+               H := 1;\n+            else\n+               L := 1;\n+               H := 0;\n+            end if;\n+\n+            --  Loop to convert input to UTF_16 form\n+\n+            Ptr := Item'First;\n+            Iptr := 1;\n+            while Ptr < Item'Last loop\n+               Input_UTF16 (Iptr) :=\n+                 Wide_Character'Val\n+                   (Unsigned_16 (To_Unsigned_8 (Item (Ptr + L)))\n+                      or\n+                    Shift_Left\n+                      (Unsigned_16 (To_Unsigned_8 (Item (Ptr + H))), 8));\n+               Iptr := Iptr + 1;\n+               Ptr := Ptr + 2;\n+            end loop;\n+\n+            --  Result is obtained by converting this UTF_16 input. Note that\n+            --  we rely on this nested call to Decode to skip any BOM present.\n+\n+            return Decode_UTF_16 (Input_UTF16);\n+         end UTF16_XE;\n+      end if;\n+   end Decode;\n+\n+   --  Wide_String input with Wide_Wide_String output (long encodings)\n+\n+   function Decode\n+     (Item   : Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_String\n+   is\n+      pragma Unreferenced (Scheme);\n+   begin\n+      return Decode_UTF_16 (Item);\n+   end Decode;\n+\n+   --  Wide_String input with Wide_Wide_String output (long encodings)\n+\n+   function Decode\n+     (Item   : Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_Wide_String\n+   is\n+      pragma Unreferenced (Scheme);\n+   begin\n+      return Decode_UTF_16 (Item);\n+   end Decode;\n+\n+   -------------------\n+   -- Decode_UTF_16 --\n+   -------------------\n+\n+   --  Version returning Wide_String result\n+\n+   function Decode_UTF_16 (Item : Wide_String) return Wide_String is\n+      Result : Wide_String (1 .. Item'Length);\n+      --  Result is same length as input (possibly minus 1 if BOM present)\n+\n+      Len : Natural := 0;\n+      --  Length of result\n+\n+      Cod : Unsigned_16;\n+      J   : Positive;\n+\n+   begin\n+      --  Skip UTF-16 BOM at start\n+\n+      J := Item'First;\n+\n+      if J <= Item'Last and then Item (J) = BOM_16 (1) then\n+         J := J + 1;\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while J <= Item'Last loop\n+         Cod := To_Unsigned_16 (Item (J));\n+\n+         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFF#\n+         --  represent their own value.\n+\n+         if Cod <= 16#D7FF# or else Cod >= 16#E000# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (Cod);\n+\n+         --  Codes in the range 16#D800#..16#DBFF# represent the first of the\n+         --  two surrogates used to encode the range 16#01_000#..16#10_FFFF\".\n+         --  Such codes are out of range for 16-bit output.\n+\n+         --  The remaining case of input in the range 16#DC00#..16#DFFF# must\n+         --  never occur, since it means we have a second surrogate character\n+         --  with no corresponding first surrogate.\n+\n+         --  Thus all remaining codes are invalid\n+\n+         else\n+            Raise_Encoding_Error;\n+         end if;\n+\n+         J := J + 1;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode_UTF_16;\n+\n+   --  Version returning Wide_Wide_String result\n+\n+   function Decode_UTF_16 (Item : Wide_String) return Wide_Wide_String is\n+      Result : Wide_Wide_String (1 .. Item'Length);\n+      --  Result cannot be longer than the input string\n+\n+      Len : Natural := 0;\n+      --  Length of result\n+\n+      Cod  : Unsigned_16;\n+      J    : Positive;\n+      Rcod : Unsigned_32;\n+\n+   begin\n+      --  Skip UTF-16 BOM at start\n+\n+      J := Item'First;\n+\n+      if J <= Item'Last and then Item (J) = BOM_16 (1) then\n+         J := J + 1;\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while J <= Item'Last loop\n+         Cod := To_Unsigned_16 (Item (J));\n+\n+         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFF#\n+         --  represent their own value.\n+\n+         if Cod <= 16#D7FF# or else Cod >= 16#E000# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Wide_Character'Val (Cod);\n+\n+         --  Codes in the range 16#D800#..16#DBFF# represent the first of the\n+         --  two surrogates used to encode the range 16#01_000#..16#10_FFFF\".\n+\n+         elsif Cod <= 16#DBFF# then\n+            Rcod := (Unsigned_32 (Cod) - 16#D800#) * 2 ** 10;\n+\n+            --  Error if at end of string\n+\n+            if J = Item'Last then\n+               Raise_Encoding_Error;\n+\n+            --  Otherwise next character must be valid low order surrogate\n+\n+            else\n+               J := J + 1;\n+               Cod := To_Unsigned_16 (Item (J));\n+\n+               if Cod < 16#DC00# or else Cod > 16#DFFF# then\n+                  Raise_Encoding_Error;\n+\n+               else\n+                  Rcod := Rcod + (Unsigned_32 (Cod) mod 2 ** 10) + 16#01_0000#;\n+                  Len := Len + 1;\n+                  Result (Len) := Wide_Wide_Character'Val (Rcod);\n+               end if;\n+            end if;\n+\n+         --  If input is in the range 16#DC00#..16#DFFF#, we have a second\n+         --  surrogate character with no corresponding first surrogate.\n+\n+         else\n+            Raise_Encoding_Error;\n+         end if;\n+\n+         J := J + 1;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode_UTF_16;\n+\n+   ------------------\n+   -- Decode_UTF_8 --\n+   ------------------\n+\n+   --  Version returning Wide_String result\n+\n+   function Decode_UTF_8 (Item : String) return Wide_String is\n+      Result : Wide_String (1 .. Item'Length);\n+      --  Result string (worst case is same length as input)\n+\n+      Len : Natural := 0;\n+      --  Length of result stored so far\n+\n+      Ptr : Natural;\n+      --  Input string pointer\n+\n+      C : Unsigned_8;\n+      R : Unsigned_16;\n+\n+      procedure Get_Continuation;\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n+      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n+      --  return Ptr is incremented. Raises exceptioon if continuation\n+      --  byte does not exist or is invalid.\n+\n+      ----------------------\n+      -- Get_Continuation --\n+      ----------------------\n+\n+      procedure Get_Continuation is\n+      begin\n+         if Ptr > Item'Last then\n+            Raise_Encoding_Error;\n+\n+         else\n+            C := To_Unsigned_8 (Item (Ptr));\n+            Ptr := Ptr + 1;\n+\n+            if C < 2#10_000000# or else C > 2#10_111111# then\n+               Raise_Encoding_Error;\n+\n+            else\n+               R := Shift_Left (R, 6) or\n+                      Unsigned_16 (C and 2#00_111111#);\n+            end if;\n+         end if;\n+      end Get_Continuation;\n+\n+   --  Start of processing for Decode_UTF_8\n+\n+   begin\n+      Ptr := Item'First;\n+\n+      --  Skip BOM at start\n+\n+      if Ptr + 2 <= Item'Last\n+        and then Item (Ptr .. Ptr + 2) = BOM_8\n+      then\n+         Ptr := Ptr + 3;\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while Ptr <= Item'Last loop\n+         C := To_Unsigned_8 (Item (Ptr));\n+         Ptr := Ptr + 1;\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            R := Unsigned_16 (C);\n+\n+         --  No initial code can be of the form 10xxxxxx. Such codes are used\n+         --  only for continuations.\n+\n+         elsif C <= 2#10_111111# then\n+            Raise_Encoding_Error;\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 2#110_11111# then\n+            R := Unsigned_16 (C and 2#000_11111#);\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 2#1110_1111# then\n+            R := Unsigned_16 (C and 2#0000_1111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n+         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+\n+         --  Such codes are out of range for Wide_String output\n+\n+         else\n+            Raise_Encoding_Error;\n+         end if;\n+\n+         Len := Len + 1;\n+         Result (Len) := Wide_Character'Val (R);\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode_UTF_8;\n+\n+   --  Version returning Wide_Wide_String result\n+\n+   function Decode_UTF_8 (Item : String) return Wide_Wide_String is\n+      Result : Wide_Wide_String (1 .. Item'Length);\n+      --  Result string (worst case is same length as input)\n+\n+      Len : Natural := 0;\n+      --  Length of result stored so far\n+\n+      Ptr : Natural;\n+      --  Input string pointer\n+\n+      C : Unsigned_8;\n+      R : Unsigned_32;\n+\n+      procedure Get_Continuation;\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n+      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n+      --  return Ptr is incremented. Raises exceptioon if continuation\n+      --  byte does not exist or is invalid.\n+\n+      ----------------------\n+      -- Get_Continuation --\n+      ----------------------\n+\n+      procedure Get_Continuation is\n+      begin\n+         if Ptr > Item'Last then\n+            raise Encoding_Error with\n+              \"incomplete UTF-8 encoding sequence\";\n+\n+         else\n+            C := To_Unsigned_8 (Item (Ptr));\n+            Ptr := Ptr + 1;\n+\n+            if C < 2#10_000000# or else C > 2#10_111111# then\n+               Raise_Encoding_Error;\n+\n+            else\n+               R := Shift_Left (R, 6) or\n+                 Unsigned_32 (C and 2#00_111111#);\n+            end if;\n+         end if;\n+      end Get_Continuation;\n+\n+   --  Start of processing for UTF8_Decode\n+\n+   begin\n+      Ptr := Item'First;\n+\n+      --  Skip BOM at start\n+\n+      if Ptr + 2 <= Item'Last\n+        and then Item (Ptr .. Ptr + 2) = BOM_8\n+      then\n+         Ptr := Ptr + 3;\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while Ptr <= Item'Last loop\n+         C := To_Unsigned_8 (Item (Ptr));\n+         Ptr := Ptr + 1;\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            R := Unsigned_32 (C);\n+\n+         --  No initial code can be of the form 10xxxxxx. Such codes are used\n+         --  only for continuations.\n+\n+         elsif C <= 2#10_111111# then\n+            Raise_Encoding_Error;\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 2#110_11111# then\n+            R := Unsigned_32 (C and 2#000_11111#);\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 2#1110_1111# then\n+            R := Unsigned_32 (C and 2#0000_1111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n+         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 2#11110_111# then\n+            R := Unsigned_32 (C and 2#00000_111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+            Get_Continuation;\n+\n+         --  Any other code is an error\n+\n+         else\n+            Raise_Encoding_Error;\n+         end if;\n+\n+         Len := Len + 1;\n+         Result (Len) := Wide_Wide_Character'Val (R);\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode_UTF_8;\n+\n+   ------------\n+   -- Encode --\n+   ------------\n+\n+   --  Version with Wide_String input returning encoded String\n+\n+   function Encode\n+     (Item   : Wide_String;\n+      Scheme : Short_Encoding := UTF_8) return String\n+   is\n+   begin\n+      --  Case of UTF_8\n+\n+      if Scheme = UTF_8 then\n+         return Encode_UTF_8 (Item);\n+\n+      --  Case of UTF_16LE or UTF_16BE\n+\n+      else\n+         UTF16XE_Encode : declare\n+            UTF16_Str : constant Wide_String := Encode_UTF_16 (Item);\n+            Result    : String (1 .. 2 * UTF16_Str'Last);\n+\n+            H, L : Integer range -1 .. 0;\n+            --  Offset for high and low order bytes\n+\n+            C : Unsigned_16;\n+            --  One UTF_16 output value\n+\n+         begin\n+            --  Set proper byte offsets\n+\n+            --  Set the byte order for the two bytes of each UTF_16 input code.\n+            --  For UTF_16LE we have low order/high order. For UTF_16BE we have\n+            --  high order/low order.\n+\n+            if Scheme = UTF_16LE then\n+               L := -1;\n+               H := 0;\n+            else\n+               L := 0;\n+               H := -1;\n+            end if;\n+\n+            --  Now copy the UTF_16 string to the result string\n+\n+            pragma Warnings (Off);\n+            for J in 1 .. UTF16_Str'Last loop\n+               C := To_Unsigned_16 (UTF16_Str (J));\n+               Result (2 * J + L) := Character'Val (C and 16#FF#);\n+               Result (2 * J + H) := Character'Val (Shift_Right (C, 8));\n+            end loop;\n+\n+            return Result;\n+         end UTF16XE_Encode;\n+      end if;\n+   end Encode;\n+\n+   --  Version with Wide_Wide_String input returning String\n+\n+   function Encode\n+     (Item   : Wide_Wide_String;\n+      Scheme : Short_Encoding := UTF_8) return String\n+   is\n+   begin\n+      --  Case of UTF_8\n+\n+      if Scheme = UTF_8 then\n+         return Encode_UTF_8 (Item);\n+\n+      --  Case of UTF_16LE or UTF_16BE\n+\n+      else\n+         UTF16XE_Encode : declare\n+            UTF16_Str : constant Wide_String := Encode (Item, UTF_16);\n+            Result    : String (1 .. 2 * UTF16_Str'Last);\n+\n+            H, L : Integer range -1 .. 0;\n+            --  Offset for high and low order bytes\n+\n+            C : Unsigned_16;\n+            --  One UTF_16 output value\n+\n+         begin\n+            --  Set proper byte offsets\n+\n+            --  Set the byte order for the two bytes of each UTF_16 input code.\n+            --  For UTF_16LE we have low order/high order. For UTF_16BE we have\n+            --  high order/low order.\n+\n+            if Scheme = UTF_16LE then\n+               L := -1;\n+               H := 0;\n+            else\n+               L := 0;\n+               H := -1;\n+            end if;\n+\n+            --  Now copy the UTF_16 string to the result string\n+\n+            for J in 1 .. UTF16_Str'Last loop\n+               C := To_Unsigned_16 (UTF16_Str (J));\n+               Result (2 * J + L) := Character'Val (C and 16#FF#);\n+               Result (2 * J + H) := Character'Val (Shift_Right (C, 8));\n+            end loop;\n+\n+            return Result;\n+         end UTF16XE_Encode;\n+      end if;\n+   end Encode;\n+\n+   --  Wide_String input returning encoded Wide_String (long encodings)\n+\n+   function Encode\n+     (Item   : Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_String\n+   is\n+      pragma Unreferenced (Scheme);\n+   begin\n+      return Encode_UTF_16 (Item);\n+   end Encode;\n+\n+   --  Wide_Wide_String input returning Wide_String (long encodings)\n+\n+   function Encode\n+     (Item   : Wide_Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_String\n+   is\n+      pragma Unreferenced (Scheme);\n+   begin\n+      return Encode_UTF_16 (Item);\n+   end Encode;\n+\n+   -------------------\n+   -- Encode_UTF_16 --\n+   -------------------\n+\n+   --  Wide_String input with UTF-16 encoded Wide_String output\n+\n+   function Encode_UTF_16 (Item : Wide_String) return Wide_String is\n+      Result : Wide_String (1 .. Item'Length);\n+      --  Output is same length as input (we do not add a BOM!)\n+\n+      Len : Integer := 0;\n+      --  Length of output string\n+\n+      Cod : Unsigned_16;\n+\n+   begin\n+      --  Loop through input characters encoding them\n+\n+      for J in Item'Range loop\n+         Cod := To_Unsigned_16 (Item (J));\n+\n+         --  Codes in the range 16#0000#..16#D7FF# are output unchanged\n+\n+         if Cod <= 16#D7FF# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (Cod);\n+\n+         --  Codes in tne range 16#D800#..16#DFFF# should never appear in the\n+         --  input, since no valid Unicode characters are in this range (which\n+         --  would conflict with the UTF-16 surrogate encodings).\n+\n+         elsif Cod <= 16#DFFF# then\n+            raise Constraint_Error with\n+              \"Wide_Character in range 16#D800# .. 16#DFFF#\";\n+\n+         --  Codes in the range 16#E000#..16#FFFF# are output unchanged\n+\n+         else\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (Cod);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Encode_UTF_16;\n+\n+   --  Wide_Wide_String input with UTF-16 encoded Wide_String output\n+\n+   function Encode_UTF_16 (Item : Wide_Wide_String) return Wide_String is\n+      Result : Wide_String (1 .. 2 * Item'Length);\n+      --  Worst case is each input character generates two output characters\n+\n+      Len : Integer := 0;\n+      --  Length of output string\n+\n+      Cod : Unsigned_32;\n+\n+   begin\n+      --  Loop through input characters encoding them\n+\n+      for J in Item'Range loop\n+         Cod := To_Unsigned_32 (Item (J));\n+\n+         --  Codes in the range 16#00_0000#..16#00_D7FF# are output unchanged\n+\n+         if Cod <= 16#00_D7FF# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (Cod);\n+\n+         --  Codes in tne range 16#00_D800#..16#00_DFFF# should never appear\n+         --  in the input, since no valid Unicode characters are in this range\n+         --  (which would conflict with the UTF-16 surrogate encodings).\n+\n+         elsif Cod <= 16#00_DFFF# then\n+            raise Constraint_Error with\n+              \"Wide_Wide_Character in range 16#00_D800# .. 16#00_DFFF#\";\n+\n+         --  Codes in the range 16#00_E000#..16#00_FFFF# are output unchanged\n+\n+         elsif Cod <= 16#00_FFFF# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (Cod);\n+\n+         --  Codes in the range 16#01_0000#..16#10_FFFF# are output using two\n+         --  surrogate characters. First 16#1_0000# is subtracted from the code\n+         --  point to give a 20-bit value. This is then split into two separate\n+         --  10-bit values each of which is represented as a surrogate with the\n+         --  most significant half placed in the first surrogate. To allow safe\n+         --  use of simple word-oriented string processing, separate ranges of\n+         --  values are used for the two surrogates: 16#D800#-16#DBFF# for the\n+         --  first, most significant surrogate and 16#DC00#-16#DFFF# for the\n+         --  second, least significant surrogate.\n+\n+         elsif Cod <= 16#10_FFFF# then\n+            Cod := Cod - 16#1_0000#;\n+\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (16#D800# + Cod / 2 ** 10);\n+\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (16#DC00# + Cod mod 2 ** 10);\n+\n+         --  Codes larger than 16#10_FFFF# are invalid\n+\n+         else\n+            raise Constraint_Error with\n+              \"Wide_Wide_Character exceeds maximum value of 16#10_FFFF#\";\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Encode_UTF_16;\n+\n+   ------------------\n+   -- Encode_UTF_8 --\n+   ------------------\n+\n+   --  Wide_String input with UTF_8 encoded String output\n+\n+   function Encode_UTF_8 (Item : Wide_String) return String is\n+      Result : String (1 .. 3 * Item'Length);\n+      --  Worst case is three bytes per input byte\n+\n+      N : Natural := 0;\n+      --  Number of output codes stored in Result\n+\n+      C : Unsigned_16;\n+      --  Single input character\n+\n+      procedure Store (C : Unsigned_16);\n+      pragma Inline (Store);\n+      --  Store one output code, C is in the range 0 .. 255\n+\n+      -----------\n+      -- Store --\n+      -----------\n+\n+      procedure Store (C : Unsigned_16) is\n+      begin\n+         N := N + 1;\n+         Result (N) := Character'Val (C);\n+      end Store;\n+\n+   --  Start of processing for UTF8_Encode\n+\n+   begin\n+      --  Loop through characters of input\n+\n+      for J in Item'Range loop\n+         C := To_Unsigned_16 (Item (J));\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            Store (C);\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 16#7FF# then\n+            Store (2#110_00000# or Shift_Right (C, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         else\n+            Store (2#1110_0000# or Shift_Right (C, 12));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000#, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. N);\n+   end Encode_UTF_8;\n+\n+   --  Wide_Wide_String input with UTF_8 encoded String output\n+\n+   function Encode_UTF_8 (Item : Wide_Wide_String) return String is\n+      Result : String (1 .. 4 * Item'Length);\n+      --  Worst case is four bytes per input byte\n+\n+      N  : Natural := 0;\n+      --  Number of output codes stored in Result\n+\n+      C : Unsigned_32;\n+      --  Single input character\n+\n+      procedure Store (C : Unsigned_32);\n+      pragma Inline (Store);\n+      --  Store one output code (input is in range 0 .. 255)\n+\n+      -----------\n+      -- Store --\n+      -----------\n+\n+      procedure Store (C : Unsigned_32) is\n+      begin\n+         N := N + 1;\n+         Result (N) := Character'Val (C);\n+      end Store;\n+\n+   --  Start of processing for UTF8_Encode\n+\n+   begin\n+      --  Loop through characters of input\n+\n+      for J in Item'Range loop\n+         C := To_Unsigned_32 (Item (J));\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            Store (C);\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 16#7FF# then\n+            Store (2#110_00000# or Shift_Right (C, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 16#FFFF# then\n+            Store (2#1110_0000# or Shift_Right (C, 12));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000#, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n+         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 16#10_FFFF# then\n+            Store (2#11110_000# or Shift_Right (C, 18));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000_000000#, 12));\n+            Store (2#10_000000#\n+                   or Shift_Right (C and 2#111111_000000#, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes higher than 16#10_FFFF# should not appear\n+\n+         else\n+            raise Constraint_Error with\n+              \"out of range invalid value in Encode input\";\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. N);\n+   end Encode_UTF_8;\n+\n+   --------------\n+   -- Encoding --\n+   --------------\n+\n+   --  Version taking String input\n+\n+   function Encoding (Item : String) return Encoding_Scheme is\n+   begin\n+      if Item'Length >= 2 then\n+         if Item (Item'First .. Item'First + 1) = BOM_16BE then\n+            return UTF_16BE;\n+\n+         elsif Item (Item'First .. Item'First + 1) = BOM_16LE then\n+            return UTF_16LE;\n+\n+         elsif Item'Length >= 3\n+           and then Item (Item'First .. Item'First + 2) = BOM_8\n+         then\n+            return UTF_8;\n+         end if;\n+      end if;\n+\n+      return UTF_None;\n+   end Encoding;\n+\n+   --  Version taking Wide_String input\n+\n+   function Encoding (Item : Wide_String) return Encoding_Scheme is\n+   begin\n+      if Item'Length >= 1\n+        and then Item (Item'First .. Item'First) = BOM_16\n+      then\n+         return UTF_16;\n+      else\n+         return UTF_None;\n+      end if;\n+   end Encoding;\n+\n+   ------------------------\n+   -- Raise_Encoding_Error --\n+   ------------------------\n+\n+   procedure Raise_Encoding_Error is\n+   begin\n+      raise Encoding_Error with \"invalid input encoding sequence\";\n+   end Raise_Encoding_Error;\n+\n+end Ada.Strings.UTF_Encoding;"}, {"sha": "33b5aec88d143c8e05c3c36d1310fee9b8dcba3a", "filename": "gcc/ada/a-stuten.ads", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fa-stuten.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fa-stuten.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stuten.ads?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . S T R I N G S . U T F _ E N C O D I N G             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Ada 2012 package defined in AI05-0137-1. It is used for\n+--  encoding strings using UTF encodings (UTF-8, UTF-16LE, UTF-16BE, UTF-16).\n+\n+--  Compared with version 05 of the AI, we have added routines for UTF-16\n+--  encoding and decoding of wide strings, which seems missing from the AI,\n+--  added comments, and reordered the declarations.\n+\n+--  Note: although this is an Ada 2012 package, the earlier versions of the\n+--  language permit the addition of new grandchildren of Ada, so we are able\n+--  to add this package unconditionally for use in Ada 2005 mode. We cannot\n+--  allow it in earlier versions, since it requires Wide_Wide_Character/String.\n+\n+package Ada.Strings.UTF_Encoding is\n+   pragma Pure (UTF_Encoding);\n+\n+   type Encoding_Scheme is (UTF_None, UTF_8, UTF_16BE, UTF_16LE, UTF_16);\n+\n+   subtype Short_Encoding is Encoding_Scheme range UTF_8 .. UTF_16LE;\n+   subtype Long_Encoding  is Encoding_Scheme range UTF_16 .. UTF_16;\n+\n+   --  The BOM (BYTE_ORDER_MARK) values defined here are used at the start of\n+   --  a string to indicate the encoding. The convention in this package is\n+   --  that decoding routines ignore a BOM, and output of encoding routines\n+   --  does not include a BOM. If you want to include a BOM in the output,\n+   --  you simply concatenate the appropriate value at the start of the string.\n+\n+   BOM_8    : constant String :=\n+                Character'Val (16#EF#) &\n+                Character'Val (16#BB#) &\n+                Character'Val (16#BF#);\n+\n+   BOM_16BE : constant String :=\n+                Character'Val (16#FE#) &\n+                Character'Val (16#FF#);\n+\n+   BOM_16LE : constant String :=\n+                Character'Val (16#FF#) &\n+                Character'Val (16#FE#);\n+\n+   BOM_16   : constant Wide_String :=\n+                (1 => Wide_Character'Val (16#FEFF#));\n+\n+   --  The encoding routines take a wide string or wide wide string as input\n+   --  and encode the result using the specified UTF encoding method. For\n+   --  UTF-16, the output is returned as a Wide_String, this is not a normal\n+   --  Wide_String, since the codes in it may represent UTF-16 surrogate\n+   --  characters used to encode large values. Similarly for UTF-8, UTF-16LE,\n+   --  and UTF-16BE, the output is returned in a String, and again this String\n+   --  is not a standard format string, since it may include UTF-8 surrogates.\n+   --  As previously noted, the returned value does NOT start with a BOM.\n+\n+   --  Note: invalid codes in calls to one of the Encode routines represent\n+   --  invalid values in the sense that they are not defined. For example, the\n+   --  code 16#DC03# is not a valid wide character value. Such values result\n+   --  in undefined behavior. For GNAT, Constraint_Error is raised with an\n+   --  appropriate exception message.\n+\n+   function Encode\n+     (Item   : Wide_String;\n+      Scheme : Short_Encoding := UTF_8) return String;\n+   function Encode\n+     (Item   : Wide_Wide_String;\n+      Scheme : Short_Encoding := UTF_8) return String;\n+\n+   function Encode\n+     (Item   : Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_String;\n+   function Encode\n+     (Item   : Wide_Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_String;\n+\n+   --  The decoding routines take a String or Wide_String input which is an\n+   --  encoded string using the specified encoding. The output is a normal\n+   --  Ada Wide_String or Wide_Wide_String value representing the decoded\n+   --  values. Note that a BOM in the input matching the encoding is skipped.\n+\n+   Encoding_Error : exception;\n+   --  Exception raised if an invalid encoding sequence is encountered by\n+   --  one of the Decode routines.\n+\n+   function Decode\n+     (Item   : String;\n+      Scheme : Short_Encoding := UTF_8) return Wide_String;\n+   function Decode\n+     (Item   : String;\n+      Scheme : Short_Encoding := UTF_8) return Wide_Wide_String;\n+\n+   function Decode\n+     (Item   : Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_String;\n+   function Decode\n+     (Item   : Wide_String;\n+      Scheme : Long_Encoding := UTF_16) return Wide_Wide_String;\n+\n+   --  The Encoding functions inspect an encoded string or wide_string and\n+   --  determine if a BOM is present. If so, the appropriate Encoding_Scheme\n+   --  is returned. If not, then UTF_None is returned.\n+\n+   function Encoding (Item : String)      return Encoding_Scheme;\n+   function Encoding (Item : Wide_String) return Encoding_Scheme;\n+\n+end Ada.Strings.UTF_Encoding;"}, {"sha": "8251126f3410b39deb5884c32abfd4b7bde8c89c", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -376,21 +376,26 @@ package Errout is\n    Gname5 : aliased constant String := \"gnat05\";\n    Vname5 : aliased constant String := \"05\";\n \n+   Gname6 : aliased constant String := \"gnat12\";\n+   Vname6 : aliased constant String := \"12\";\n+\n    type Cstring_Ptr is access constant String;\n \n    Gnames : array (Nat range <>) of Cstring_Ptr :=\n               (Gname1'Access,\n                Gname2'Access,\n                Gname3'Access,\n                Gname4'Access,\n-               Gname5'Access);\n+               Gname5'Access,\n+               Gname6'Access);\n \n    Vnames : array (Nat range <>) of Cstring_Ptr :=\n               (Vname1'Access,\n                Vname2'Access,\n                Vname3'Access,\n                Vname4'Access,\n-               Vname5'Access);\n+               Vname5'Access,\n+               Vname6'Access);\n \n    -----------------------------------------------------\n    -- Global Values Used for Error Message Insertions --"}, {"sha": "111bc182fe7cf0b023df529ce1d7e63848b49c2a", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -666,7 +666,8 @@ package body Exp_Ch11 is\n \n             Rewrite (HSS,\n               Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => New_List (Blk_Stm)));\n+                Statements => New_List (Blk_Stm),\n+                End_Label  => Relocate_Node (End_Label (HSS))));\n \n             --  Set block statement as analyzed, we don't want to actually call\n             --  Analyze on this block, it would cause a recursion in exception\n@@ -741,13 +742,12 @@ package body Exp_Ch11 is\n                         Relmt := First_Elmt (Local_Raise_Statements (Handler));\n                         while Present (Relmt) loop\n                            declare\n-                              Raise_S : constant Node_Id := Node (Relmt);\n-\n+                              Raise_S : constant Node_Id    := Node (Relmt);\n+                              RLoc    : constant Source_Ptr := Sloc (Raise_S);\n                               Name_L1 : constant Node_Id :=\n                                           New_Occurrence_Of (L1_Dent, Loc);\n-\n                               Goto_L1 : constant Node_Id :=\n-                                          Make_Goto_Statement (Loc,\n+                                          Make_Goto_Statement (RLoc,\n                                             Name => Name_L1);\n \n                            begin"}, {"sha": "9bf7a47453f7a5a138c7ebec34d0a68ad787efaf", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -4035,31 +4035,32 @@ ada/sem_util.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/casing.ads ada/casing.adb ada/checks.ads ada/csets.ads \\\n    ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads ada/elists.adb \\\n    ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/eval_fat.ads \\\n-   ada/exp_ch11.ads ada/exp_disp.ads ada/exp_tss.ads ada/exp_util.ads \\\n-   ada/fname.ads ada/freeze.ads ada/get_targ.ads ada/gnat.ads \\\n-   ada/g-hesorg.ads ada/g-htable.ads ada/hostparm.ads ada/interfac.ads \\\n-   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-sort.adb \\\n-   ada/lib-xref.ads ada/namet.ads ada/namet.adb ada/nlists.ads \\\n-   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n-   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/scans.ads \\\n+   ada/exp_ch11.ads ada/exp_disp.ads ada/exp_dist.ads ada/exp_tss.ads \\\n+   ada/exp_util.ads ada/fname.ads ada/fname-uf.ads ada/freeze.ads \\\n+   ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads ada/g-htable.ads \\\n+   ada/hostparm.ads ada/interfac.ads ada/lib.ads ada/lib.adb \\\n+   ada/lib-list.adb ada/lib-load.ads ada/lib-sort.adb ada/lib-xref.ads \\\n+   ada/namet.ads ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads \\\n+   ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n+   ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb ada/scans.ads \\\n    ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads ada/sem_attr.ads \\\n-   ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch6.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_eval.ads ada/sem_eval.adb ada/sem_res.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/sinput.adb \\\n-   ada/snames.ads ada/stand.ads ada/stringt.ads ada/stringt.adb \\\n-   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n-   ada/system.ads ada/s-carun8.ads ada/s-crc32.ads ada/s-crc32.adb \\\n-   ada/s-exctab.ads ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-strhas.ads ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/types.adb ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n-   ada/widechar.ads \n+   ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch6.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_disp.ads ada/sem_dist.ads ada/sem_eval.ads \\\n+   ada/sem_eval.adb ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n+   ada/sinput.ads ada/sinput.adb ada/snames.ads ada/stand.ads \\\n+   ada/stringt.ads ada/stringt.adb ada/style.ads ada/styleg.ads \\\n+   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-carun8.ads \\\n+   ada/s-crc32.ads ada/s-crc32.adb ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-htable.adb ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-strhas.ads ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/ttypes.ads ada/types.ads ada/types.adb ada/uintp.ads ada/uintp.adb \\\n+   ada/uname.ads ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \\\n+   ada/urealp.adb ada/widechar.ads \n \n ada/sem_vfpt.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\"}, {"sha": "e4a39e1671b9a5b15f68f5fba9fcadc9b5e2f00f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -99,6 +99,8 @@ Implementation Defined Pragmas\n * Pragma Ada_95::\n * Pragma Ada_05::\n * Pragma Ada_2005::\n+* Pragma Ada_12::\n+* Pragma Ada_2012::\n * Pragma Annotate::\n * Pragma Assert::\n * Pragma Assume_No_Invalid_Values::\n@@ -132,6 +134,7 @@ Implementation Defined Pragmas\n * Pragma Export_Value::\n * Pragma Export_Valued_Procedure::\n * Pragma Extend_System::\n+* Pragma Extensions_Allowed::\n * Pragma External::\n * Pragma External_Name_Casing::\n * Pragma Fast_Math::\n@@ -712,6 +715,8 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Ada_95::\n * Pragma Ada_05::\n * Pragma Ada_2005::\n+* Pragma Ada_12::\n+* Pragma Ada_2012::\n * Pragma Annotate::\n * Pragma Assert::\n * Pragma Assume_No_Invalid_Values::\n@@ -745,6 +750,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Export_Value::\n * Pragma Export_Valued_Procedure::\n * Pragma Extend_System::\n+* Pragma Extensions_Allowed::\n * Pragma External::\n * Pragma External_Name_Casing::\n * Pragma Fast_Math::\n@@ -903,9 +909,7 @@ pragma Ada_05;\n @noindent\n A configuration pragma that establishes Ada 2005 mode for the unit to which\n it applies, regardless of the mode set by the command line switches.\n-This mode is set automatically for the @code{Ada} and @code{System}\n-packages and their children, so you need not specify it in these\n-contexts.  This pragma is useful when writing a reusable component that\n+This pragma is useful when writing a reusable component that\n itself uses Ada 2005 features, but which is intended to be usable from\n either Ada 83 or Ada 95 programs.\n \n@@ -922,6 +926,37 @@ pragma Ada_2005;\n This configuration pragma is a synonym for pragma Ada_05 and has the\n same syntax and effect.\n \n+@node Pragma Ada_12\n+@unnumberedsec Pragma Ada_12\n+@findex Ada_12\n+@noindent\n+Syntax:\n+@smallexample @c ada\n+pragma Ada_12;\n+@end smallexample\n+\n+@noindent\n+A configuration pragma that establishes Ada 2012 mode for the unit to which\n+it applies, regardless of the mode set by the command line switches.\n+This mode is set automatically for the @code{Ada} and @code{System}\n+packages and their children, so you need not specify it in these\n+contexts.  This pragma is useful when writing a reusable component that\n+itself uses Ada 2012 features, but which is intended to be usable from\n+Ada 83, Ada 95, or Ada 2005 programs.\n+\n+@node Pragma Ada_2012\n+@unnumberedsec Pragma Ada_2012\n+@findex Ada_2005\n+@noindent\n+Syntax:\n+@smallexample @c ada\n+pragma Ada_2012;\n+@end smallexample\n+\n+@noindent\n+This configuration pragma is a synonym for pragma Ada_12 and has the\n+same syntax and effect.\n+\n @node Pragma Annotate\n @unnumberedsec Pragma Annotate\n @findex Annotate\n@@ -2174,6 +2209,35 @@ it you will have to use the appropriate switch for compiling\n system units.  @xref{Top, @value{EDITION} User's Guide, About This\n Guide,, gnat_ugn, @value{EDITION} User's Guide}, for details.\n \n+@node Pragma Extensions_Allowed\n+@unnumberedsec Pragma Extensions_Allowed\n+@cindex Ada Extensions\n+@cindex GNAT Extensions\n+@findex Extensions_Allowed\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Extensions_Allowed (On | Off);\n+@end smallexample\n+\n+@noindent\n+This configuration pragma enables or disables the implementation\n+extension mode (the use of Off as a parameter cancels the effect\n+of the @option{-gnatX} command switch).\n+\n+In extension mode, the latest version of the Ada language is\n+implemented (currently Ada 2012), and in addition a small number\n+of GNAT specific extensions are recognized as follows:\n+\n+@table @asis\n+@item Constrained attribute for generic objects\n+The @code{Constrained} attribute is permitted for objects of\n+generic types. The result indicates if the corresponding actual\n+is constrained.\n+\n+@end table\n+\n @node Pragma External\n @unnumberedsec Pragma External\n @findex External\n@@ -8879,8 +8943,8 @@ The algorithm is the Mersenne Twister, as documented in the source file\n state.  See A.5.2(38).\n @end cartouche\n @noindent\n-The value returned by the Image function is the concatenation of \n-the fixed-width decimal representations of the 624 32-bit integers \n+The value returned by the Image function is the concatenation of\n+the fixed-width decimal representations of the 624 32-bit integers\n of the state vector.\n \n @sp 1"}, {"sha": "e18baef53d5090c68670f5b9674a2e72a5b9850b", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -4060,6 +4060,17 @@ Enforce Ada 95 restrictions.\n @cindex @option{-gnat05} (@command{gcc})\n Allow full Ada 2005 features.\n \n+@item -gnat2005\n+@cindex @option{-gnat2005} (@command{gcc})\n+Allow full Ada 2005 features (same as @option{-gnat05}\n+\n+@item -gnat12\n+@cindex @option{-gnat12} (@command{gcc})\n+\n+@item -gnat2012\n+@cindex @option{-gnat2012} (@command{gcc})\n+Allow full Ada 2012 features (same as @option{-gnat12}\n+\n @item -gnata\n @cindex @option{-gnata} (@command{gcc})\n Assertions enabled. @code{Pragma Assert} and @code{pragma Debug} to be\n@@ -4359,6 +4370,10 @@ Wide character encoding method\n @cindex @option{-gnatx} (@command{gcc})\n Suppress generation of cross-reference information.\n \n+@item -gnatX\n+@cindex @option{-gnatX} (@command{gcc})\n+Enable GNAT implementation extensions and latest Ada version.\n+\n @item ^-gnaty^/STYLE_CHECKS=(option,option@dots{})^\n @cindex @option{^-gnaty^/STYLE_CHECKS^} (@command{gcc})\n Enable built-in style checks (@pxref{Style Checking}).\n@@ -6900,27 +6915,60 @@ uses of the new Ada 2005 features will cause error\n messages or warnings.\n \n This switch also can be used to cancel the effect of a previous\n-@option{-gnat83} or @option{-gnat05} switch earlier in the command line.\n+@option{-gnat83}, @option{-gnat05/2005}, or @option{-gnat12/2012}\n+switch earlier in the command line.\n \n-@item -gnat05 (Ada 2005 mode)\n+@item -gnat05 or -gnat2005 (Ada 2005 mode)\n @cindex @option{-gnat05} (@command{gcc})\n+@cindex @option{-gnat2005} (@command{gcc})\n @cindex Ada 2005 mode\n \n @noindent\n This switch directs the compiler to implement the Ada 2005 version of the\n-language.\n+language, as documented in the official Ada standards document.\n Since Ada 2005 is almost completely upwards\n compatible with Ada 95 (and thus also with Ada 83), Ada 83 and Ada 95 programs\n may generally be compiled using this switch (see the description of the\n @option{-gnat83} and @option{-gnat95} switches for further\n information).\n \n+Note that even though Ada 2005 is the current official version of the\n+language, GNAT still compiles in Ada 95 mode by default, so if you are\n+using Ada 2005 features in your program, you must use this switch (or\n+the equivalent Ada_05 or Ada_2005 configuration pragmas).\n+\n+@item -gnat12 or -gnat2012 (Ada 2012 mode)\n+@cindex @option{-gnat12} (@command{gcc})\n+@cindex @option{-gnat2012} (@command{gcc})\n+@cindex Ada 2012 mode\n+\n+@noindent\n+This switch directs the compiler to implement the Ada 2012 version of the\n+language.\n+Since Ada 2012 is almost completely upwards\n+compatible with Ada 2005 (and thus also with Ada 83, and Ada 95),\n+Ada 83 and Ada 95 programs\n+may generally be compiled using this switch (see the description of the\n+@option{-gnat83}, @option{-gnat95}, and @option{-gnat05/2005} switches\n+for further information).\n+\n For information about the approved ``Ada Issues'' that have been incorporated\n-into Ada 2005, see @url{http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs}.\n-Included with GNAT releases is a file @file{features-ada0y} that describes\n-the set of implemented Ada 2005 features.\n-@end table\n+into Ada 2012, see @url{http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs}.\n+Included with GNAT releases is a file @file{features-ada12} that describes\n+the set of implemented Ada 2012 features.\n+\n+@item -gnatX (Enable GNAT Extensions)\n+@cindex @option{-gnatX} (@command{gcc})\n+@cindex Ada language extensions\n+@cindex GNAT extensions\n+\n+@noindent\n+This switch directs the compiler to implement the latest version of the\n+language (currently Ada 2012) and also to enable certain GNAT implementation\n+extensions that are not part of any Ada standard. For a full list of these\n+extensions, see the GNAT reference manual.\n \n+@end table\n \n @node Character Set Control\n @subsection Character Set Control\n@@ -11353,6 +11401,8 @@ recognized by GNAT:\n    Ada_95\n    Ada_05\n    Ada_2005\n+   Ada_12\n+   Ada_2012\n    Assertion_Policy\n    Assume_No_Invalid_Values\n    C_Pass_By_Copy\n@@ -11396,6 +11446,7 @@ recognized by GNAT:\n    Restrictions\n    Restrictions_Warnings\n    Reviewable\n+   Short_Circuit_And_Or\n    Source_File_Name\n    Source_File_Name_Project\n    Style_Checks\n@@ -20667,7 +20718,9 @@ Unlike HP Ada, the GNAT ``@code{EXPORT_}@i{subprogram}'' pragmas require\n a separate subprogram specification which must appear before the\n subprogram body.\n \n-GNAT also supplies a number of implementation-defined pragmas as follows:\n+GNAT also supplies a number of implementation-defined pragmas including the\n+following:\n+\n @itemize @bullet\n @item  @code{ABORT_DEFER}\n \n@@ -20677,6 +20730,12 @@ GNAT also supplies a number of implementation-defined pragmas as follows:\n \n @item  @code{ADA_05}\n \n+@item  @code{Ada_2005}\n+\n+@item  @code{Ada_12}\n+\n+@item  @code{Ada_2012}\n+\n @item  @code{ANNOTATE}\n \n @item  @code{ASSERT}\n@@ -20723,7 +20782,7 @@ GNAT also supplies a number of implementation-defined pragmas as follows:\n @end itemize\n \n @noindent\n-For full details on these GNAT implementation-defined pragmas,\n+For full details on these and other GNAT implementation-defined pragmas,\n see @ref{Implementation Defined Pragmas,,, gnat_rm, GNAT Reference\n Manual}.\n "}, {"sha": "cff6d67aa2e3f9447fa65785efe94fcb2bfc6a91", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -459,6 +459,11 @@ package body Impunit is\n      \"a-szuzti\",    -- Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO\n      \"a-zchuni\",    -- Ada.Wide_Wide_Characters.Unicode\n \n+      --  Note: strictly the next one should be an Ada 2012 unit, but it seems\n+      --  harmless (and useful) to make it available in Ada 2005 mode.\n+\n+     \"a-stuten\",    -- Ada.Strings.UTF_Encoding\n+\n    ---------------------------\n    -- GNAT Special IO Units --\n    ---------------------------"}, {"sha": "1379a9e82dd68594af4fb629acf0b667ef334cd9", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,7 +34,6 @@ with Fname.UF; use Fname.UF;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n-with Opt;      use Opt;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;"}, {"sha": "04cb3234400795184bd050dda881220c036c5664", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,6 +36,7 @@\n --  Frontend, and thus are not mutually recursive.\n \n with Alloc;\n+with Opt;   use Opt;\n with Sem;   use Sem;\n with Table;\n with Types; use Types;\n@@ -84,6 +85,10 @@ package Inline is\n       --  This means we have to capture this information from the current scope\n       --  at the point of instantiation.\n \n+      Version : Ada_Version_Type;\n+      --  The body must be compiled with the same language version as the\n+      --  spec. The version may be set by a configuration pragma in a separate\n+      --  file or in the current file, and may differ from body to body.\n    end record;\n \n    package Pending_Instantiations is new Table.Table ("}, {"sha": "54cec4932d6c3f6292ebc8895902489d96015574", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -64,17 +64,15 @@ package Opt is\n    --  GNATBIND, GNATLINK\n    --  Set True if binder file to be generated in Ada rather than C\n \n-   type Ada_Version_Type is (Ada_83, Ada_95, Ada_05);\n-   pragma Warnings (Off, Ada_Version_Type);\n+   type Ada_Version_Type is (Ada_83, Ada_95, Ada_05, Ada_12);\n    --  Versions of Ada for Ada_Version below. Note that these are ordered,\n    --  so that tests like Ada_Version >= Ada_95 are legitimate and useful.\n-   --  The Warnings_Off pragma stops warnings for Ada_Version >= Ada_05,\n-   --  which we want to allow, so that things work OK when Ada_15 is added!\n-   --  This warning is now removed, so this pragma can be removed some time???\n \n    Ada_Version_Default : constant Ada_Version_Type := Ada_05;\n+   pragma Warnings (Off, Ada_Version_Default);\n    --  GNAT\n-   --  Default Ada version if no switch given\n+   --  Default Ada version if no switch given. The Warnings off is to kill\n+   --  constant condition warnings.\n \n    Ada_Version : Ada_Version_Type := Ada_Version_Default;\n    --  GNAT\n@@ -91,7 +89,7 @@ package Opt is\n    --  the rare cases (notably for pragmas Preelaborate_05 and Pure_05)\n    --  where in the run-time we want the explicit version set.\n \n-   Ada_Version_Runtime : Ada_Version_Type := Ada_05;\n+   Ada_Version_Runtime : Ada_Version_Type := Ada_12;\n    --  GNAT\n    --  Ada version used to compile the runtime. Used to set Ada_Version (but\n    --  not Ada_Version_Explicit) when compiling predefined or internal units."}, {"sha": "d1bc039b9695e5ae7e8e03a04abae00658255de9", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -124,9 +124,8 @@ package body Ch3 is\n       elsif Nkind_In (N, N_In, N_Not_In)\n         and then Paren_Count (N) = 0\n       then\n-         Error_Msg_N (\"|this expression must be parenthesized!\", N);\n          Error_Msg_N\n-           (\"\\|since extensions (and set notation) are allowed\", N);\n+           (\"|this expression must be parenthesized in Ada 2012 mode!\", N);\n       end if;\n    end Check_Restricted_Expression;\n \n@@ -3663,10 +3662,10 @@ package body Ch3 is\n                --  Expression\n \n                else\n-                  --  If extensions are permitted then the expression must be a\n-                  --  simple expression. The resaon for this restriction (i.e.\n-                  --  going back to the Ada 83 rule) is to avoid ambiguities\n-                  --  when set membership operations are allowed, consider the\n+                  --  In Ada 2012 mode, the expression must be a simple\n+                  --  expression. The resaon for this restriction (i.e. going\n+                  --  back to the Ada 83 rule) is to avoid ambiguities when set\n+                  --  membership operations are allowed, consider the\n                   --  following:\n \n                   --     when A in 1 .. 10 | 12 =>\n@@ -3679,12 +3678,12 @@ package body Ch3 is\n                   --     when (A in 1 .. 10 | 12) =>\n                   --     when (A in 1 .. 10) | 12 =>\n \n-                  --  To solve this, if extensins are enabled, we disallow\n+                  --  To solve this, in Ada 2012 mode, we disallow\n                   --  the use of membership operations in expressions in\n                   --  choices. Technically in the grammar, the expression\n                   --  must match the grammar for restricted expression.\n \n-                  if Extensions_Allowed then\n+                  if Ada_Version >= Ada_12 then\n                      Check_Restricted_Expression (Expr_Node);\n \n                   --  In Ada 83 mode, the syntax required a simple expression"}, {"sha": "d90b413d9521cfd43f9c203224a61efd7c52c48c", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -2352,7 +2352,7 @@ package body Ch4 is\n                --  If this looks like a conditional expression, then treat it\n                --  that way with an error message.\n \n-               elsif Extensions_Allowed then\n+               elsif Ada_Version >= Ada_12 then\n                   Error_Msg_SC\n                     (\"conditional expression must be parenthesized\");\n                   return P_Conditional_Expression;\n@@ -2378,7 +2378,7 @@ package body Ch4 is\n                --  If this looks like a case expression, then treat it that way\n                --  with an error message.\n \n-               elsif Extensions_Allowed then\n+               elsif Ada_Version >= Ada_12 then\n                   Error_Msg_SC (\"case expression must be parenthesized\");\n                   return P_Case_Expression;\n \n@@ -2668,9 +2668,9 @@ package body Ch4 is\n       Save_State : Saved_Scan_State;\n \n    begin\n-      if not Extensions_Allowed then\n-         Error_Msg_SC (\"|case expression is an Ada extension\");\n-         Error_Msg_SC (\"\\|use -gnatX switch to compile this unit\");\n+      if Ada_Version < Ada_12 then\n+         Error_Msg_SC (\"|case expression is an Ada 2012 feature\");\n+         Error_Msg_SC (\"\\|use -gnat12 switch to compile this unit\");\n       end if;\n \n       Scan; -- past CASE\n@@ -2759,9 +2759,9 @@ package body Ch4 is\n    begin\n       Inside_Conditional_Expression := Inside_Conditional_Expression + 1;\n \n-      if Token = Tok_If and then not Extensions_Allowed then\n-         Error_Msg_SC (\"|conditional expression is an Ada extension\");\n-         Error_Msg_SC (\"\\|use -gnatX switch to compile this unit\");\n+      if Token = Tok_If and then Ada_Version < Ada_12 then\n+         Error_Msg_SC (\"|conditional expression is an Ada 2012 feature\");\n+         Error_Msg_SC (\"\\|use -gnat12 switch to compile this unit\");\n       end if;\n \n       Scan; -- past IF or ELSIF\n@@ -2836,15 +2836,15 @@ package body Ch4 is\n    procedure P_Membership_Test (N : Node_Id) is\n       Alt : constant Node_Id :=\n               P_Range_Or_Subtype_Mark\n-                (Allow_Simple_Expression => Extensions_Allowed);\n+                (Allow_Simple_Expression => (Ada_Version >= Ada_12));\n \n    begin\n       --  Set case\n \n       if Token = Tok_Vertical_Bar then\n-         if not Extensions_Allowed then\n-            Error_Msg_SC (\"set notation is a language extension\");\n-            Error_Msg_SC (\"\\|use -gnatX switch to compile this unit\");\n+         if Ada_Version < Ada_12 then\n+            Error_Msg_SC (\"set notation is an Ada 2012 feature\");\n+            Error_Msg_SC (\"\\|use -gnat12 switch to compile this unit\");\n          end if;\n \n          Set_Alternatives (N, New_List (Alt));"}, {"sha": "a421592ad84e4bf7f207a5898492f33cb5b3750a", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -306,7 +306,7 @@ begin\n       -- Ada_05/Ada_2005 --\n       ---------------------\n \n-      --  This pragma must be processed at parse time, since we want to set\n+      --  These pragmas must be processed at parse time, since we want to set\n       --  the Ada version properly at parse time to recognize the appropriate\n       --  Ada version syntax. However, it is only the zero argument form that\n       --  must be processed at parse time.\n@@ -317,6 +317,18 @@ begin\n             Ada_Version_Explicit := Ada_05;\n          end if;\n \n+      ---------------------\n+      -- Ada_12/Ada_2012 --\n+      ---------------------\n+\n+      --  These pragmas must be processed at parse time, since we want to set\n+      --  the Ada version properly at parse time to recognize the appropriate\n+      --  Ada version syntax.\n+\n+      when Pragma_Ada_12 | Pragma_Ada_2012 =>\n+         Ada_Version := Ada_12;\n+         Ada_Version_Explicit := Ada_12;\n+\n       -----------\n       -- Debug --\n       -----------\n@@ -374,8 +386,10 @@ begin\n \n          if Chars (Expression (Arg1)) = Name_On then\n             Extensions_Allowed := True;\n+            Ada_Version := Ada_12;\n          else\n             Extensions_Allowed := False;\n+            Ada_Version := Ada_Version_Explicit;\n          end if;\n \n       ----------------"}, {"sha": "a2009c2b66e7cffc03167230de0f2e420fedf6f0", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -3394,7 +3394,8 @@ package body Sem_Ch12 is\n                    Expander_Status          => Expander_Active,\n                    Current_Sem_Unit         => Current_Sem_Unit,\n                    Scope_Suppress           => Scope_Suppress,\n-                   Local_Suppress_Stack_Top => Local_Suppress_Stack_Top));\n+                   Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n+                   Version                  => Ada_Version));\n             end if;\n          end if;\n \n@@ -3701,7 +3702,8 @@ package body Sem_Ch12 is\n                Expander_Status          => Expander_Active,\n                Current_Sem_Unit         => Current_Sem_Unit,\n                Scope_Suppress           => Scope_Suppress,\n-               Local_Suppress_Stack_Top => Local_Suppress_Stack_Top)),\n+               Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n+               Version                  => Ada_Version)),\n             Inlined_Body => True);\n \n          Pop_Scope;\n@@ -3816,7 +3818,8 @@ package body Sem_Ch12 is\n                Expander_Status          => Expander_Active,\n                Current_Sem_Unit         => Current_Sem_Unit,\n                Scope_Suppress           => Scope_Suppress,\n-               Local_Suppress_Stack_Top => Local_Suppress_Stack_Top)),\n+               Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n+               Version                  => Ada_Version)),\n             Inlined_Body => True);\n       end if;\n    end Inline_Instance_Body;\n@@ -3855,7 +3858,8 @@ package body Sem_Ch12 is\n              Expander_Status          => Expander_Active,\n              Current_Sem_Unit         => Current_Sem_Unit,\n              Scope_Suppress           => Scope_Suppress,\n-             Local_Suppress_Stack_Top => Local_Suppress_Stack_Top));\n+             Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n+             Version                  => Ada_Version));\n          return True;\n       else\n          return False;\n@@ -8590,6 +8594,7 @@ package body Sem_Ch12 is\n \n       Local_Suppress_Stack_Top := Body_Info.Local_Suppress_Stack_Top;\n       Scope_Suppress           := Body_Info.Scope_Suppress;\n+      Opt.Ada_Version          := Body_Info.Version;\n \n       if No (Gen_Body_Id) then\n          Load_Parent_Of_Generic\n@@ -8853,6 +8858,7 @@ package body Sem_Ch12 is\n \n       Local_Suppress_Stack_Top := Body_Info.Local_Suppress_Stack_Top;\n       Scope_Suppress           := Body_Info.Scope_Suppress;\n+      Opt.Ada_Version          := Body_Info.Version;\n \n       if No (Gen_Body_Id) then\n \n@@ -10801,7 +10807,8 @@ package body Sem_Ch12 is\n                                 Get_Code_Unit (Sloc (Node (Decl))),\n                               Scope_Suppress           => Scope_Suppress,\n                               Local_Suppress_Stack_Top =>\n-                                Local_Suppress_Stack_Top);\n+                                Local_Suppress_Stack_Top,\n+                              Version                  => Ada_Version);\n \n                            --  Package instance\n \n@@ -10841,7 +10848,8 @@ package body Sem_Ch12 is\n                            Get_Code_Unit (Sloc (Inst_Node)),\n                          Scope_Suppress           => Scope_Suppress,\n                          Local_Suppress_Stack_Top =>\n-                           Local_Suppress_Stack_Top)),\n+                           Local_Suppress_Stack_Top,\n+                           Version                => Ada_Version)),\n                      Body_Optional => Body_Optional);\n                end;\n             end if;"}, {"sha": "86908077d306ae11de9c183c2418f8821a5dddd3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -315,7 +315,7 @@ package body Sem_Ch13 is\n          --  In AI-133. This involves gathering all components which start at\n          --  the same byte offset and processing them together\n \n-         when Ada_05 =>\n+         when Ada_05 .. Ada_Version_Type'Last =>\n             declare\n                Max_Machine_Scalar_Size : constant Uint :=\n                                            UI_From_Int"}, {"sha": "743d128e65d69340e6c4a29f63b4bd811984f4b9", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -2344,7 +2344,7 @@ package body Sem_Ch4 is\n       Analyze_Expression (L);\n \n       if No (R)\n-        and then Extensions_Allowed\n+        and then Ada_Version >= Ada_12\n       then\n          Analyze_Set_Membership;\n          return;"}, {"sha": "764d4f6a506936be32dc2331d0c833f8734bdad1", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -5257,8 +5257,9 @@ package body Sem_Prag is\n             --  said this was a configuration pragma, but we did not check and\n             --  are hesitant to add the check now.\n \n-            --  However, we really cannot tolerate mixing Ada 2005 with Ada 83\n-            --  or Ada 95, so we must check if we are in Ada 2005 mode.\n+            --  However, we really cannot tolerate mixing Ada 2005 or Ada 2012\n+            --  with Ada 83 or Ada 95, so we must check if we are in Ada 2005\n+            --  or Ada 2012 mode.\n \n             if Ada_Version >= Ada_05 then\n                Check_Valid_Configuration_Pragma;\n@@ -5347,6 +5348,33 @@ package body Sem_Prag is\n             end if;\n          end;\n \n+         ---------------------\n+         -- Ada_12/Ada_2012 --\n+         ---------------------\n+\n+         --  pragma Ada_12;\n+         --  pragma Ada_2012;\n+\n+         --  Note: these pragma also have some specific processing in Par.Prag\n+         --  because we want to set the Ada 2012 version mode during parsing.\n+\n+         when Pragma_Ada_12 | Pragma_Ada_2012 =>\n+            GNAT_Pragma;\n+            Check_Arg_Count (0);\n+\n+            --  For Ada_2012 we unconditionally enforce the documented\n+            --  configuration pragma placement, since we do not want to\n+            --  tolerate mixed modes in a unit involving Ada 2012. That would\n+            --  cause real difficulties for those cases where there are\n+            --  incompatibilities between Ada 95 and Ada 2005/Ada 2012.\n+\n+            Check_Valid_Configuration_Pragma;\n+\n+            --  Now set Ada 2012 mode\n+\n+            Ada_Version := Ada_12;\n+            Ada_Version_Explicit := Ada_12;\n+\n          ----------------------\n          -- All_Calls_Remote --\n          ----------------------\n@@ -7451,8 +7479,11 @@ package body Sem_Prag is\n \n             if Chars (Expression (Arg1)) = Name_On then\n                Extensions_Allowed := True;\n+               Ada_Version := Ada_Version_Type'Last;\n+\n             else\n                Extensions_Allowed := False;\n+               Ada_Version := Ada_Version_Explicit;\n             end if;\n \n          --------------\n@@ -10080,7 +10111,7 @@ package body Sem_Prag is\n \n             --  This is one of the few cases where we need to test the value of\n             --  Ada_Version_Explicit rather than Ada_Version (which is always\n-            --  set to Ada_05 in a predefined unit), we need to know the\n+            --  set to Ada_12 in a predefined unit), we need to know the\n             --  explicit version set to know if this pragma is active.\n \n             if Ada_Version_Explicit >= Ada_05 then\n@@ -10580,7 +10611,7 @@ package body Sem_Prag is\n \n             --  This is one of the few cases where we need to test the value of\n             --  Ada_Version_Explicit rather than Ada_Version (which is always\n-            --  set to Ada_05 in a predefined unit), we need to know the\n+            --  set to Ada_12 in a predefined unit), we need to know the\n             --  explicit version set to know if this pragma is active.\n \n             if Ada_Version_Explicit >= Ada_05 then\n@@ -12647,6 +12678,8 @@ package body Sem_Prag is\n       Pragma_Ada_95                        => -1,\n       Pragma_Ada_05                        => -1,\n       Pragma_Ada_2005                      => -1,\n+      Pragma_Ada_12                        => -1,\n+      Pragma_Ada_2012                      => -1,\n       Pragma_All_Calls_Remote              => -1,\n       Pragma_Annotate                      => -1,\n       Pragma_Assert                        => -1,"}, {"sha": "717003888900aecb100f8b4ae33cfddeceedd36b", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -34,7 +34,7 @@ with Namet; use Namet;\n package Snames is\n \n --  This package contains definitions of standard names (i.e. entries in the\n---  Names table) that are used throughout the GNAT compiler). It also contains\n+--  Names table) that are used throughout the GNAT compiler. It also contains\n --  the definitions of some enumeration types whose definitions are tied to\n --  the order of these preset names.\n \n@@ -334,6 +334,8 @@ package Snames is\n    Name_Ada_95                         : constant Name_Id := N + $; -- GNAT\n    Name_Ada_05                         : constant Name_Id := N + $; -- GNAT\n    Name_Ada_2005                       : constant Name_Id := N + $; -- GNAT\n+   Name_Ada_12                         : constant Name_Id := N + $; -- GNAT\n+   Name_Ada_2012                       : constant Name_Id := N + $; -- GNAT\n    Name_Assertion_Policy               : constant Name_Id := N + $; -- Ada 05\n    Name_Assume_No_Invalid_Values       : constant Name_Id := N + $; -- GNAT\n    Name_C_Pass_By_Copy                 : constant Name_Id := N + $; -- GNAT\n@@ -1416,6 +1418,8 @@ package Snames is\n       Pragma_Ada_95,\n       Pragma_Ada_05,\n       Pragma_Ada_2005,\n+      Pragma_Ada_12,\n+      Pragma_Ada_2012,\n       Pragma_Assertion_Policy,\n       Pragma_Assume_No_Invalid_Values,\n       Pragma_C_Pass_By_Copy,"}, {"sha": "ab213af14bb540b9ee18029cc0aa5181c22b91ea", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -532,11 +532,11 @@ package body Switch.C is\n                System_Extend_Unit := Empty;\n                Warning_Mode := Treat_As_Error;\n \n-               --  Set Ada 2005 mode explicitly. We don't want to rely on the\n+               --  Set Ada 2012 mode explicitly. We don't want to rely on the\n                --  implicit setting here, since for example, we want\n                --  Preelaborate_05 treated as Preelaborate\n \n-               Ada_Version := Ada_05;\n+               Ada_Version := Ada_12;\n                Ada_Version_Explicit := Ada_Version;\n \n                --  Set default warnings and style checks for -gnatg\n@@ -903,6 +903,8 @@ package body Switch.C is\n             when 'X' =>\n                Ptr := Ptr + 1;\n                Extensions_Allowed := True;\n+               Ada_Version := Ada_Version_Type'Last;\n+               Ada_Version_Explicit := Ada_Version_Type'Last;\n \n             --  Processing for y switch\n \n@@ -1048,6 +1050,42 @@ package body Switch.C is\n                   Ada_Version_Explicit := Ada_Version;\n                end if;\n \n+            --  Processing for 12 switch\n+\n+            when '1' =>\n+               if Ptr = Max then\n+                  Bad_Switch (\"-gnat1\");\n+               end if;\n+\n+               Ptr := Ptr + 1;\n+\n+               if Switch_Chars (Ptr) /= '2' then\n+                  Bad_Switch (\"-gnat1\" & Switch_Chars (Ptr .. Max));\n+               else\n+                  Ptr := Ptr + 1;\n+                  Ada_Version := Ada_12;\n+                  Ada_Version_Explicit := Ada_Version;\n+               end if;\n+\n+            --  Processing for 2005 and 2012 switches\n+\n+            when '2' =>\n+               if Ptr > Max - 3 then\n+                  Bad_Switch (\"-gnat\" & Switch_Chars (Ptr .. Max));\n+\n+               elsif Switch_Chars (Ptr .. Ptr + 3) = \"2005\" then\n+                  Ada_Version := Ada_05;\n+\n+               elsif Switch_Chars (Ptr .. Ptr + 3) = \"2012\" then\n+                  Ada_Version := Ada_12;\n+\n+               else\n+                  Bad_Switch (\"-gnat\" & Switch_Chars (Ptr .. Ptr + 3));\n+               end if;\n+\n+               Ada_Version_Explicit := Ada_Version;\n+               Ptr := Ptr + 4;\n+\n             --  Switch cancellation, currently only -gnat-p is allowed.\n             --  All we do here is the error checking, since the actual\n             --  processing for switch cancellation is done by calls to"}, {"sha": "2121b7f20e42892f47728937876c61674c5f51f0", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -595,7 +595,17 @@ begin\n    if Ada_Version_Default = Ada_05 then\n       Write_Line (\"Ada 2005 mode (default)\");\n    else\n-      Write_Line (\"Allow Ada 2005 extensions\");\n+      Write_Line (\"Enforce Ada 2005 restrictions\");\n+   end if;\n+\n+   --  Line for -gnat12 switch\n+\n+   Write_Switch_Char (\"12\");\n+\n+   if Ada_Version_Default = Ada_12 then\n+      Write_Line (\"Ada 2012 mode (default)\");\n+   else\n+      Write_Line (\"Allow Ada 2012 extensions\");\n    end if;\n \n    --  Line for -gnat-p switch"}, {"sha": "8454041abb11fc3fa7b942de6a021ac0bd65d76b", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eed45bbe286757689d39d5f345842b67c023ce4/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=0eed45bbe286757689d39d5f345842b67c023ce4", "patch": "@@ -1227,7 +1227,13 @@ package VMS_Data is\n                                              \"-gnat05\";\n    --        /05 (D)\n    --\n-   --   Allows GNAT to recognize all implemented proposed Ada 2005\n+   --   Allows GNAT to recognize the full range of Ada 2005 constructs.\n+\n+   S_GCC_Ada_12 : aliased constant S := \"/12 \"                             &\n+                                             \"-gnat12\";\n+   --        /05 (D)\n+   --\n+   --   Allows GNAT to recognize all implemented proposed Ada 2012\n    --   extensions. See features file for list of implemented features.\n \n    S_GCC_Add     : aliased constant S := \"/ADD_PROJECT_SEARCH_DIR=*\"       &"}]}