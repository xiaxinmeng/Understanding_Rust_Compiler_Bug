{"sha": "03b71406323ddc065b1d7837d8b43b17e4b048b5", "node_id": "C_kwDOANBUbNoAKDAzYjcxNDA2MzIzZGRjMDY1YjFkNzgzN2Q4YjQzYjE3ZTRiMDQ4YjU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-07T08:05:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-07T08:05:08Z"}, "message": "openmp: Add support for OpenMP 5.2 linear clause syntax for C/C++\n\nThe syntax for linear clause changed in 5.2, the original syntax\nwhich is still valid is:\nlinear (var1, var2)\nlinear (var3, var4 : step1)\nThe 4.5 syntax with modifiers like:\nlinear (val (var5, var6))\nlinear (val (var7, var8) : step2)\nis still supported in 5.2, but is deprecated there.\nInstead, one can use a new syntax:\nlinear (var9, var10 : val)\nlinear (var11, var12 : step (step3), val)\nAs val, ref, uval or step (someexpr) can be valid expressions (and especially\nin C++ can be const / constexpr / consteval), the spec says that\nwhen the whole step expression is val (or ref or uval) or step ( ... )\nthen it is the new modifier syntax, one can use + 0 or 0 + or 1 * or * 1\nor ()s to say it is the old step expression.\nAlso, 5.2 now allows val modifier to be specified even outside of declare simd\n(but not the other modifiers).  I've implemented this for the new modifier\nsyntax only, the old one keeps the old restriction (which is why\nOMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER flag has been introduced).\n\n2022-06-07  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree.h (OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER): Define.\n\t* tree-pretty-print.cc (dump_omp_clause) <case OMP_CLAUSE_LINEAR>:\n\tAdjust clause printing style depending on\n\tOMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER.\ngcc/c/\n\t* c-parser.cc (c_parser_omp_clause_linear): Parse OpenMP 5.2\n\tstyle linear clause modifiers.  Set\n\tOMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER flag on the clauses when\n\told style modifiers are used.\n\t* c-typeck.cc (c_finish_omp_clauses): Only reject linear clause\n\twith val modifier on simd or for if the old style modifiers are\n\tused.\ngcc/cp/\n\t* parser.cc (cp_parser_omp_clause_linear): Parse OpenMP 5.2\n\tstyle linear clause modifiers.  Set\n\tOMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER flag on the clauses when\n\told style modifiers are used.\n\t* semantics.cc (finish_omp_clauses): Only reject linear clause\n\twith val modifier on simd or for if the old style modifiers are\n\tused.\ngcc/fortran/\n\t* trans-openmp.cc (gfc_trans_omp_clauses): Set\n\tOMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER on OMP_CLAUSE_LINEAR\n\tclauses unconditionally for now.\ngcc/testsuite/\n\t* c-c++-common/gomp/linear-2.c: New test.\n\t* c-c++-common/gomp/linear-3.c: New test.\n\t* g++.dg/gomp/linear-3.C: New test.\n\t* g++.dg/gomp/linear-4.C: New test.\n\t* g++.dg/gomp/linear-5.C: New test.", "tree": {"sha": "5bcbe506924a87854f78855d460f540622c920b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bcbe506924a87854f78855d460f540622c920b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b71406323ddc065b1d7837d8b43b17e4b048b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b71406323ddc065b1d7837d8b43b17e4b048b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b71406323ddc065b1d7837d8b43b17e4b048b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b71406323ddc065b1d7837d8b43b17e4b048b5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb0776e104b5ca5a7bed9f333a9690174b4d00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb0776e104b5ca5a7bed9f333a9690174b4d00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb0776e104b5ca5a7bed9f333a9690174b4d00b"}], "stats": {"total": 489, "additions": 452, "deletions": 37}, "files": [{"sha": "1704a52be12949acf9ef74211f6f427ff44c789d", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 102, "deletions": 9, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -15668,14 +15668,25 @@ c_parser_omp_clause_allocate (c_parser *parser, tree list)\n \n    OpenMP 4.5:\n    linear ( modifier ( variable-list ) )\n-   linear ( modifier ( variable-list ) : expression ) */\n+   linear ( modifier ( variable-list ) : expression )\n+\n+   modifier:\n+     val\n+\n+   OpenMP 5.2:\n+   linear ( variable-list : modifiers-list )\n+\n+   modifiers:\n+     val\n+     step ( expression )  */\n \n static tree\n c_parser_omp_clause_linear (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree nl, c, step;\n   enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;\n+  bool old_linear_modifier = false;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -15691,6 +15702,7 @@ c_parser_omp_clause_linear (c_parser *parser, tree list)\n \tkind = OMP_CLAUSE_LINEAR_DEFAULT;\n       if (kind != OMP_CLAUSE_LINEAR_DEFAULT)\n \t{\n+\t  old_linear_modifier = true;\n \t  c_parser_consume_token (parser);\n \t  c_parser_consume_token (parser);\n \t}\n@@ -15706,15 +15718,95 @@ c_parser_omp_clause_linear (c_parser *parser, tree list)\n     {\n       c_parser_consume_token (parser);\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n-      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n-      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n-      step = expr.value;\n-      step = c_fully_fold (step, false, NULL);\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))\n+      bool has_modifiers = false;\n+      if (kind == OMP_CLAUSE_LINEAR_DEFAULT\n+\t  && c_parser_next_token_is (parser, CPP_NAME))\n+\t{\n+\t  c_token *tok = c_parser_peek_token (parser);\n+\t  const char *p = IDENTIFIER_POINTER (tok->value);\n+\t  unsigned int pos = 0;\n+\t  if (strcmp (\"val\", p) == 0)\n+\t    pos = 2;\n+\t  else if (strcmp (\"step\", p) == 0\n+\t\t   && c_parser_peek_2nd_token (parser)->type == CPP_OPEN_PAREN)\n+\t    {\n+\t      pos = 3;\n+\t      if (c_parser_check_balanced_raw_token_sequence (parser, &pos)\n+\t\t  && (c_parser_peek_nth_token_raw (parser, pos)->type\n+\t\t      == CPP_CLOSE_PAREN))\n+\t\t++pos;\n+\t      else\n+\t\tpos = 0;\n+\t    }\n+\t  if (pos)\n+\t    {\n+\t      tok = c_parser_peek_nth_token_raw (parser, pos);\n+\t      if (tok->type == CPP_COMMA || tok->type == CPP_CLOSE_PAREN)\n+\t\thas_modifiers = true;\n+\t    }\n+\t}\n+      if (has_modifiers)\n+\t{\n+\t  step = NULL_TREE;\n+\t  while (c_parser_next_token_is (parser, CPP_NAME))\n+\t    {\n+\t      c_token *tok = c_parser_peek_token (parser);\n+\t      const char *p = IDENTIFIER_POINTER (tok->value);\n+\t      if (strcmp (\"val\", p) == 0)\n+\t\t{\n+\t\t  if (kind != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t\t    error_at (tok->location, \"multiple linear modifiers\");\n+\t\t  kind = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t\t  c_parser_consume_token (parser);\n+\t\t}\n+\t      else if (strcmp (\"step\", p) == 0)\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  matching_parens parens2;\n+\t\t  if (parens2.require_open (parser))\n+\t\t    {\n+\t\t      if (step)\n+\t\t\terror_at (tok->location,\n+\t\t\t\t  \"multiple %<step%> modifiers\");\n+\t\t      expr_loc = c_parser_peek_token (parser)->location;\n+\t\t      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t\t      expr = convert_lvalue_to_rvalue (expr_loc, expr, false,\n+\t\t\t\t\t\t       true);\n+\t\t      step = c_fully_fold (expr.value, false, NULL);\n+\t\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))\n+\t\t\t{\n+\t\t\t  error_at (clause_loc, \"%<linear%> clause step \"\n+\t\t\t\t\t\t\"expression must be integral\");\n+\t\t\t  step = integer_one_node;\n+\t\t\t}\n+\t\t      parens2.skip_until_found_close (parser);\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  continue;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  if (!step)\n+\t    step = integer_one_node;\n+\t}\n+      else\n \t{\n-\t  error_at (clause_loc, \"%<linear%> clause step expression must \"\n-\t\t\t\t\"be integral\");\n-\t  step = integer_one_node;\n+\t  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+\t  step = c_fully_fold (expr.value, false, NULL);\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))\n+\t    {\n+\t      error_at (clause_loc, \"%<linear%> clause step expression must \"\n+\t\t\t\t    \"be integral\");\n+\t      step = integer_one_node;\n+\t    }\n \t}\n \n     }\n@@ -15725,6 +15817,7 @@ c_parser_omp_clause_linear (c_parser *parser, tree list)\n     {\n       OMP_CLAUSE_LINEAR_STEP (c) = step;\n       OMP_CLAUSE_LINEAR_KIND (c) = kind;\n+      OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (c) = old_linear_modifier;\n     }\n \n   parens.skip_until_found_close (parser);"}, {"sha": "fd0a7f81a7a92461f8939208e77d1d169e075d01", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -14478,11 +14478,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    need_implicitly_determined = true;\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (ort != C_ORT_OMP_DECLARE_SIMD\n-\t      && OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t      && OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_DEFAULT\n+\t      && OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (c))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"modifier should not be specified in %<linear%> \"\n-\t\t\t\"clause on %<simd%> or %<for%> constructs\");\n+\t\t\t\"clause on %<simd%> or %<for%> constructs when not \"\n+\t\t\t\"using OpenMP 5.2 modifiers\");\n \t      OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n \t    }\n \t  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))"}, {"sha": "da2f370cdca55ec7cf13a766681b4846eeed8143", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 123, "deletions": 5, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -38942,7 +38942,21 @@ cp_parser_omp_clause_lastprivate (cp_parser *parser, tree list)\n \n    OpenMP 4.5:\n    linear ( modifier ( variable-list ) )\n-   linear ( modifier ( variable-list ) : expression ) */\n+   linear ( modifier ( variable-list ) : expression )\n+\n+   modifier:\n+     val\n+     ref\n+     uval\n+\n+   OpenMP 5.2:\n+   linear ( variable-list : modifiers-list )\n+\n+   modifiers:\n+     val\n+     ref\n+     uval\n+     step ( expression )  */\n \n static tree\n cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n@@ -38951,6 +38965,7 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n   tree nlist, c, step = integer_one_node;\n   bool colon;\n   enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;\n+  bool old_linear_modifier = false;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -38968,7 +38983,10 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n       else if (strcmp (\"uval\", p) == 0)\n \tkind = OMP_CLAUSE_LINEAR_UVAL;\n       if (cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN))\n-\tcp_lexer_consume_token (parser->lexer);\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  old_linear_modifier = true;\n+\t}\n       else\n \tkind = OMP_CLAUSE_LINEAR_DEFAULT;\n     }\n@@ -38990,10 +39008,109 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n \n   if (colon)\n     {\n+      bool has_modifiers = false;\n+      if (kind == OMP_CLAUSE_LINEAR_DEFAULT\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t{\n+\t  tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t  const char *p = IDENTIFIER_POINTER (id);\n+\t  size_t pos = 0;\n+\t  if (strcmp (\"ref\", p) == 0\n+\t      || strcmp (\"val\", p) == 0\n+\t      || strcmp (\"uval\", p) == 0)\n+\t    pos = 2;\n+\t  else if (strcmp (\"step\", p) == 0\n+\t\t   && cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN))\n+\t    {\n+\t      pos = cp_parser_skip_balanced_tokens (parser, 2);\n+\t      if (pos == 2)\n+\t\tpos = 0;\n+\t    }\n+\t  if (pos != 0\n+\t      && (cp_lexer_nth_token_is (parser->lexer, pos, CPP_COMMA)\n+\t\t  || cp_lexer_nth_token_is (parser->lexer, pos,\n+\t\t\t\t\t    CPP_CLOSE_PAREN)))\n+\t    has_modifiers = true;\n+\t}\n+\n       step = NULL_TREE;\n-      if (declare_simd\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n-\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_CLOSE_PAREN))\n+      if (has_modifiers)\n+\t{\n+\t  while (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t    {\n+\t      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t      const char *p = IDENTIFIER_POINTER (id);\n+\t      enum omp_clause_linear_kind nkind = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t      if (strcmp (\"ref\", p) == 0)\n+\t\tnkind = OMP_CLAUSE_LINEAR_REF;\n+\t      else if (strcmp (\"val\", p) == 0)\n+\t\tnkind = OMP_CLAUSE_LINEAR_VAL;\n+\t      else if (strcmp (\"uval\", p) == 0)\n+\t\tnkind = OMP_CLAUSE_LINEAR_UVAL;\n+\t      if (nkind != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t\t{\n+\t\t  if (kind != OMP_CLAUSE_LINEAR_DEFAULT)\n+\t\t    error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t      \"multiple linear modifiers\");\n+\t\t  kind = nkind;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t      else if (strcmp (\"step\", p) == 0)\n+\t\t{\n+\t\t  location_t step_loc\n+\t\t    = cp_lexer_peek_token (parser->lexer)->location;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  matching_parens parens2;\n+\t\t  if (parens2.require_open (parser))\n+\t\t    {\n+\t\t      if (step)\n+\t\t\terror_at (step_loc, \"multiple %<step%> modifiers\");\n+\t\t      if (declare_simd\n+\t\t\t  && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t\t\t  && cp_lexer_nth_token_is (parser->lexer, 2,\n+\t\t\t\t\t\t    CPP_CLOSE_PAREN))\n+\t\t\t{\n+\t\t\t  cp_token *token\n+\t\t\t    = cp_lexer_peek_token (parser->lexer);\n+\t\t\t  location_t tok_loc = token->location;\n+\t\t\t  cp_parser_parse_tentatively (parser);\n+\t\t\t  step = cp_parser_id_expression (parser, false, true,\n+\t\t\t\t\t\t\t  NULL, false, false);\n+\t\t\t  if (step != error_mark_node)\n+\t\t\t    step = cp_parser_lookup_name_simple (parser, step,\n+\t\t\t\t\t\t\t\t tok_loc);\n+\t\t\t  if (step == error_mark_node)\n+\t\t\t    {\n+\t\t\t      step = NULL_TREE;\n+\t\t\t      cp_parser_abort_tentative_parse (parser);\n+\t\t\t    }\n+\t\t\t  else if (!cp_parser_parse_definitely (parser))\n+\t\t\t    step = NULL_TREE;\n+\t\t\t}\n+\t\t      if (!step)\n+\t\t\tstep = cp_parser_assignment_expression (parser);\n+\t\t      if (!parens2.require_close (parser))\n+\t\t\tcp_parser_skip_to_closing_parenthesis (parser, true,\n+\t\t\t\t\t\t\t       false, true);\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t\t{\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  continue;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  if (!step)\n+\t    step = integer_one_node;\n+\t}\n+      else if (declare_simd\n+\t       && cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+\t       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_CLOSE_PAREN))\n \t{\n \t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \t  cp_parser_parse_tentatively (parser);\n@@ -39028,6 +39145,7 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n     {\n       OMP_CLAUSE_LINEAR_STEP (c) = step;\n       OMP_CLAUSE_LINEAR_KIND (c) = kind;\n+      OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (c) = old_linear_modifier;\n     }\n \n   return nlist;"}, {"sha": "24cca99e9092993767d45ef1f910d0155bcb5feb", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -6827,10 +6827,22 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  if (ort != C_ORT_OMP_DECLARE_SIMD\n \t      && OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_DEFAULT)\n \t    {\n-\t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"modifier should not be specified in %<linear%> \"\n-\t\t\t\"clause on %<simd%> or %<for%> constructs\");\n-\t      OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t      if (OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (c))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"modifier should not be specified in %<linear%> \"\n+\t\t\t    \"clause on %<simd%> or %<for%> constructs when \"\n+\t\t\t    \"not using OpenMP 5.2 modifiers\");\n+\t\t  OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t\t}\n+\t      else if (OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_VAL)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"modifier other than %<val%> specified in \"\n+\t\t\t    \"%<linear%> clause on %<simd%> or %<for%> \"\n+\t\t\t    \"constructs when using OpenMP 5.2 modifiers\");\n+\t\t  OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n+\t\t}\n \t    }\n \t  if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t      && !type_dependent_expression_p (t))"}, {"sha": "c6a584d36f221cb2ad7de14f44868c2aad74392a", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -2769,6 +2769,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t    gcc_unreachable ();\n \t\t\t  }\n \t\t\tOMP_CLAUSE_LINEAR_KIND (node) = kind;\n+\t\t\tOMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (node) = 1;\n \t\t\tif (last_step_expr && last_step == NULL_TREE)\n \t\t\t  {\n \t\t\t    if (!declare_simd)"}, {"sha": "545b7e5f01d4565c8d945907c8e4db620e945ae8", "filename": "gcc/testsuite/c-c++-common/gomp/linear-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-2.c?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int i;\n+\n+#pragma omp declare simd linear (x : val, step (1)) linear (y : step (2))\n+int bar (int x, int y, int z);\n+#pragma omp declare simd linear (x : step (1), val)\n+int baz (int x, int y, int z);\n+#pragma omp declare simd linear (val (x) : val) uniform (val)\n+int qux (int x, int val);\n+#pragma omp declare simd linear (x : val, step (val)) uniform (val)\n+int corge (int x, int val);\n+#pragma omp declare simd linear (x : val)\n+int grault (int x);\n+int step (int);\n+\n+void\n+foo (int x, int y)\n+{\n+  int val = 1;\n+  #pragma omp simd linear (i: step (3))\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp simd linear (i: val, step (3))\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp simd linear (x: step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (x: step (y + 1), val)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for linear (x: step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for linear (x: val, step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (i: step (3))\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp parallel for simd linear (i: step (3), val)\n+  for (i = 0; i < 33; i += 3)\n+    ;\n+  #pragma omp parallel for simd linear (x: step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (x: val, step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (i: val + 0)\n+  for (i = 0; i < 10; i++)\n+    ;\n+  #pragma omp parallel for simd linear (i: step (1) * 1)\n+  for (i = 0; i < 10; i++)\n+    ;\n+}"}, {"sha": "32fa0bc7a92285bdf6527a16356b6ed2a133d847", "filename": "gcc/testsuite/c-c++-common/gomp/linear-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flinear-3.c?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int step (int);\n+int val;\n+#pragma omp declare simd linear (val (x) : step (1))\t/* { dg-error \"is neither constant nor a parameter\" } */\n+int bar (int x, int y, int z);\n+#pragma omp declare simd linear (val (x) : val)\t\t/* { dg-error \"is neither constant nor a parameter\" } */\n+int baz (int x, int y, int z);"}, {"sha": "0936cf89155a9800c8fd2e4953f4ad09280d3a55", "filename": "gcc/testsuite/g++.dg/gomp/linear-3.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-3.C?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fopenmp\" }\n+\n+int i;\n+\n+#pragma omp declare simd linear (x : ref, step (1)) linear (y : step (2), uval)\n+int bar (int &x, int &y, int z);\n+#pragma omp declare simd linear (x : step (1), uval)\n+int baz (int &x, int y, int z);\n+#pragma omp declare simd linear (ref (x) : ref) uniform (ref)\n+int qux (int &x, int ref);\n+#pragma omp declare simd linear (x : ref, step (ref)) uniform (ref)\n+int corge (int &x, int ref);\n+#pragma omp declare simd linear (x : ref)\n+int grault (int &x);\n+#pragma omp declare simd linear (x : uval)\n+int waldo (int &x);\n+constexpr int step (int x) { return x; }\n+\n+void\n+foo (int &x, int &y)\n+{\n+  #pragma omp simd linear (x: step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (x: val, step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for linear (x: step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for linear (x: step (y + 1), val)\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (x: step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (x: val, step (y + 1))\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (x: step (1) + 0)\n+  for (i = 0; i < 10; i++)\n+    x += step (1) + 0;\n+  {\n+    constexpr int ref = 1;\n+    constexpr int uval = 2;\n+    #pragma omp parallel for simd linear (x: ref + 0)\n+    for (i = 0; i < 10; i++)\n+      x += ref + 0;\n+    #pragma omp parallel for simd linear (x: uval * 1)\n+    for (i = 0; i < 10; i++)\n+      x += uval;\n+  }\n+}"}, {"sha": "a1b947289312011c11072b93310ac00f8ff49ec3", "filename": "gcc/testsuite/g++.dg/gomp/linear-4.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-4.C?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+int i;\n+\n+void\n+foo (int &x, int &y)\n+{\n+  #pragma omp simd linear (x: step (y + 1), ref)\t\t// { dg-error \"modifier other than 'val' specified in 'linear' clause\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp simd linear (x: uval, step (y + 1))\t\t// { dg-error \"modifier other than 'val' specified in 'linear' clause\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for linear (x: ref, step (y + 1))\t// { dg-error \"modifier other than 'val' specified in 'linear' clause\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for linear (x: step (y + 1), uval)\t// { dg-error \"modifier other than 'val' specified in 'linear' clause\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (x: step (y + 1), ref)\t// { dg-error \"modifier other than 'val' specified in 'linear' clause\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+  #pragma omp parallel for simd linear (x: uval, step (y + 1))\t// { dg-error \"modifier other than 'val' specified in 'linear' clause\" }\n+  for (i = 0; i < 10; i++)\n+    x += y + 1;\n+}"}, {"sha": "fbc193edeb6e21706027285736f5d430315fc977", "filename": "gcc/testsuite/g++.dg/gomp/linear-5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Flinear-5.C?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+constexpr int step (int x) { return x; }\n+constexpr int val = 1;\n+constexpr int ref = 2;\n+constexpr int uval = 3;\n+#pragma omp declare simd linear (val (x) : step (1)) linear (ref (y) : step (2)) linear (uval (z) : step (3))\n+int foo (int x, int &y, int &z);\n+#pragma omp declare simd linear (val (x) : val) linear (ref (y) : ref) linear (uval (z) : uval)\n+int bar (int x, int &y, int &z);\n+#pragma omp declare simd linear (val (x) : ref) linear (ref (y) : uval) linear (uval (z) : val)\n+int baz (int x, int &y, int &z);\n+#pragma omp declare simd linear (val (x) : uval) linear (ref (y) : val) linear (uval (z) : ref)\n+int qux (int x, int &y, int &z);"}, {"sha": "bfabe9e76279d7c3383b684ed61cc92228de4500", "filename": "gcc/tree-pretty-print.cc", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftree-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftree-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.cc?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -707,29 +707,50 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \n     case OMP_CLAUSE_LINEAR:\n       pp_string (pp, \"linear(\");\n-      switch (OMP_CLAUSE_LINEAR_KIND (clause))\n-\t{\n-\tcase OMP_CLAUSE_LINEAR_DEFAULT:\n-\t  break;\n-\tcase OMP_CLAUSE_LINEAR_REF:\n-\t  pp_string (pp, \"ref(\");\n-\t  break;\n-\tcase OMP_CLAUSE_LINEAR_VAL:\n-\t  pp_string (pp, \"val(\");\n-\t  break;\n-\tcase OMP_CLAUSE_LINEAR_UVAL:\n-\t  pp_string (pp, \"uval(\");\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      if (OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (clause))\n+\tswitch (OMP_CLAUSE_LINEAR_KIND (clause))\n+\t  {\n+\t  case OMP_CLAUSE_LINEAR_DEFAULT:\n+\t    break;\n+\t  case OMP_CLAUSE_LINEAR_REF:\n+\t    pp_string (pp, \"ref(\");\n+\t    break;\n+\t  case OMP_CLAUSE_LINEAR_VAL:\n+\t    pp_string (pp, \"val(\");\n+\t    break;\n+\t  case OMP_CLAUSE_LINEAR_UVAL:\n+\t    pp_string (pp, \"uval(\");\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n       dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n \t\t\t spc, flags, false);\n-      if (OMP_CLAUSE_LINEAR_KIND (clause) != OMP_CLAUSE_LINEAR_DEFAULT)\n+      if (OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (clause)\n+\t  && OMP_CLAUSE_LINEAR_KIND (clause) != OMP_CLAUSE_LINEAR_DEFAULT)\n \tpp_right_paren (pp);\n       pp_colon (pp);\n+      if (!OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (clause)\n+\t  && OMP_CLAUSE_LINEAR_KIND (clause) != OMP_CLAUSE_LINEAR_DEFAULT)\n+\tswitch (OMP_CLAUSE_LINEAR_KIND (clause))\n+\t  {\n+\t    case OMP_CLAUSE_LINEAR_REF:\n+\t      pp_string (pp, \"ref,step(\");\n+\t      break;\n+\t    case OMP_CLAUSE_LINEAR_VAL:\n+\t      pp_string (pp, \"val,step(\");\n+\t      break;\n+\t    case OMP_CLAUSE_LINEAR_UVAL:\n+\t      pp_string (pp, \"uval,step(\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t  }\n       dump_generic_node (pp, OMP_CLAUSE_LINEAR_STEP (clause),\n \t\t\t spc, flags, false);\n+      if (!OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER (clause)\n+\t  && OMP_CLAUSE_LINEAR_KIND (clause) != OMP_CLAUSE_LINEAR_DEFAULT)\n+\tpp_right_paren (pp);\n       pp_right_paren (pp);\n       break;\n "}, {"sha": "507ea252b958b9fb0a5d69c1ddd53edcd746112d", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b71406323ddc065b1d7837d8b43b17e4b048b5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=03b71406323ddc065b1d7837d8b43b17e4b048b5", "patch": "@@ -1841,6 +1841,11 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_LINEAR_VARIABLE_STRIDE(NODE) \\\n   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))\n \n+/* True for a LINEAR clause with old style modifier syntax\n+   linear(modifier(list)) or linear(modifier(list):step).  */\n+#define OMP_CLAUSE_LINEAR_OLD_LINEAR_MODIFIER(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->base.addressable_flag)\n+\n /* True if a LINEAR clause is for an array or allocatable variable that\n    needs special handling by the frontend.  */\n #define OMP_CLAUSE_LINEAR_ARRAY(NODE) \\"}]}