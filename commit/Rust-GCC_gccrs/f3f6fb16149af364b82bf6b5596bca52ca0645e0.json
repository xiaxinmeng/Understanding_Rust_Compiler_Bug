{"sha": "f3f6fb16149af364b82bf6b5596bca52ca0645e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNmNmZiMTYxNDlhZjM2NGI4MmJmNmI1NTk2YmNhNTJjYTA2NDVlMA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T15:39:02Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T15:39:02Z"}, "message": "expmed.c: Use rtx_insn and rtx_code_label\n\ngcc/\n\t* expmed.c (store_bit_field_using_insv): Strengthen local \"last\"\n\tfrom rtx to rtx_insn *.\n\t(store_bit_field_1): Likewise.\n\t(extract_bit_field_1): Likewise.\n\t(expand_mult_const): Likewise for local \"insns\".\n\t(expmed_mult_highpart): Strengthen local \"label\" from rtx to\n\trtx_code_label *.\n\t(expand_smod_pow2): Likewise.\n\t(expand_sdiv_pow2): Likewise.\n\t(expand_divmod): Strengthen locals \"last\", \"insn\" from rtx to\n\trtx_insn *.  Strengthen locals \"label\", \"label1\", \"label2\",\n\t\"label3\", \"label4\", \"label5\", \"lab\" from rtx to rtx_code_label *.\n\t(emit_cstore): Strengthen local \"last\" from rtx to rtx_insn *.\n\t(emit_store_flag): Likewise.\n\t(emit_store_flag_force): Strengthen local \"label\" from rtx to\n\trtx_code_label *.\n\t(do_cmp_and_jump): Likewise for param \"label\".\n\nFrom-SVN: r214323", "tree": {"sha": "9f5b793aed8fbeaa5957d1c03234c6b604984275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f5b793aed8fbeaa5957d1c03234c6b604984275"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3f6fb16149af364b82bf6b5596bca52ca0645e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f6fb16149af364b82bf6b5596bca52ca0645e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3f6fb16149af364b82bf6b5596bca52ca0645e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f6fb16149af364b82bf6b5596bca52ca0645e0/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "528a80c14ee077f5f801181a1732dc1c9fa1ffd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/528a80c14ee077f5f801181a1732dc1c9fa1ffd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/528a80c14ee077f5f801181a1732dc1c9fa1ffd2"}], "stats": {"total": 81, "additions": 54, "deletions": 27}, "files": [{"sha": "583fbb6fa34dd60b790cabd28a845d1b87994842", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f6fb16149af364b82bf6b5596bca52ca0645e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f6fb16149af364b82bf6b5596bca52ca0645e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3f6fb16149af364b82bf6b5596bca52ca0645e0", "patch": "@@ -1,3 +1,23 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* expmed.c (store_bit_field_using_insv): Strengthen local \"last\"\n+\tfrom rtx to rtx_insn *.\n+\t(store_bit_field_1): Likewise.\n+\t(extract_bit_field_1): Likewise.\n+\t(expand_mult_const): Likewise for local \"insns\".\n+\t(expmed_mult_highpart): Strengthen local \"label\" from rtx to\n+\trtx_code_label *.\n+\t(expand_smod_pow2): Likewise.\n+\t(expand_sdiv_pow2): Likewise.\n+\t(expand_divmod): Strengthen locals \"last\", \"insn\" from rtx to\n+\trtx_insn *.  Strengthen locals \"label\", \"label1\", \"label2\",\n+\t\"label3\", \"label4\", \"label5\", \"lab\" from rtx to rtx_code_label *.\n+\t(emit_cstore): Strengthen local \"last\" from rtx to rtx_insn *.\n+\t(emit_store_flag): Likewise.\n+\t(emit_store_flag_force): Strengthen local \"label\" from rtx to\n+\trtx_code_label *.\n+\t(do_cmp_and_jump): Likewise for param \"label\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* explow.c (force_reg): Strengthen local \"insn\" from rtx to"}, {"sha": "7b71616a2fa1c6a9488d5dec537344a37dbf4902", "filename": "gcc/expmed.c", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3f6fb16149af364b82bf6b5596bca52ca0645e0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3f6fb16149af364b82bf6b5596bca52ca0645e0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f3f6fb16149af364b82bf6b5596bca52ca0645e0", "patch": "@@ -65,7 +65,7 @@ static rtx extract_fixed_bit_field_1 (enum machine_mode, rtx,\n static rtx lshift_value (enum machine_mode, unsigned HOST_WIDE_INT, int);\n static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, int);\n-static void do_cmp_and_jump (rtx, rtx, enum rtx_code, enum machine_mode, rtx);\n+static void do_cmp_and_jump (rtx, rtx, enum rtx_code, enum machine_mode, rtx_code_label *);\n static rtx expand_smod_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n static rtx expand_sdiv_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n \n@@ -482,7 +482,7 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n   struct expand_operand ops[4];\n   rtx value1;\n   rtx xop0 = op0;\n-  rtx last = get_last_insn ();\n+  rtx_insn *last = get_last_insn ();\n   bool copy_back = false;\n \n   enum machine_mode op_mode = insv->field_mode;\n@@ -768,7 +768,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       unsigned int backwards = WORDS_BIG_ENDIAN && fieldmode != BLKmode;\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n-      rtx last;\n+      rtx_insn *last;\n \n       /* This is the mode we must force value to, so that there will be enough\n \t subwords to extract.  Note that fieldmode will often (always?) be\n@@ -874,7 +874,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  && store_bit_field_using_insv (&insv, op0, bitsize, bitnum, value))\n \treturn true;\n \n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n \n       /* Try loading part of OP0 into a register, inserting the bitfield\n \t into that, and then copying the result back to OP0.  */\n@@ -1553,7 +1553,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       unsigned int backwards = WORDS_BIG_ENDIAN;\n       unsigned int nwords = (bitsize + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n       unsigned int i;\n-      rtx last;\n+      rtx_insn *last;\n \n       if (target == 0 || !REG_P (target) || !valid_multiword_target_p (target))\n \ttarget = gen_reg_rtx (mode);\n@@ -1671,7 +1671,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    return result;\n \t}\n \n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n \n       /* Try loading part of OP0 into a register and extracting the\n \t bitfield from that.  */\n@@ -2906,7 +2906,8 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \t\t   enum mult_variant variant)\n {\n   HOST_WIDE_INT val_so_far;\n-  rtx insn, accum, tem;\n+  rtx_insn *insn;\n+  rtx accum, tem;\n   int opno;\n   enum machine_mode nmode;\n \n@@ -3503,7 +3504,8 @@ expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n       && (mul_cost (speed, wider_mode) + shift_cost (speed, mode, size-1)\n \t  < max_cost))\n     {\n-      rtx insns, wop0, wop1;\n+      rtx_insn *insns;\n+      rtx wop0, wop1;\n \n       /* We need to widen the operands, for example to ensure the\n \t constant multiplier is correctly sign or zero extended.\n@@ -3624,7 +3626,8 @@ expmed_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n static rtx\n expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n {\n-  rtx result, temp, shift, label;\n+  rtx result, temp, shift;\n+  rtx_code_label *label;\n   int logd;\n   int prec = GET_MODE_PRECISION (mode);\n \n@@ -3720,7 +3723,8 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n static rtx\n expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n {\n-  rtx temp, label;\n+  rtx temp;\n+  rtx_code_label *label;\n   int logd;\n \n   logd = floor_log2 (d);\n@@ -3753,7 +3757,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t\t\t\t     mode, temp, temp2, mode, 0);\n       if (temp2)\n \t{\n-\t  rtx seq = get_insns ();\n+\t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n \t  emit_insn (seq);\n \t  return expand_shift (RSHIFT_EXPR, mode, temp2, logd, NULL_RTX, 0);\n@@ -3835,9 +3839,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   enum machine_mode compute_mode;\n   rtx tquotient;\n   rtx quotient = 0, remainder = 0;\n-  rtx last;\n+  rtx_insn *last;\n   int size;\n-  rtx insn;\n+  rtx_insn *insn;\n   optab optab1, optab2;\n   int op1_is_constant, op1_is_pow2 = 0;\n   int max_cost, extra_cost;\n@@ -4455,7 +4459,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    /* This could be computed with a branch-less sequence.\n \t       Save that for later.  */\n \t    rtx tem;\n-\t    rtx label = gen_label_rtx ();\n+\t    rtx_code_label *label = gen_label_rtx ();\n \t    do_cmp_and_jump (remainder, const0_rtx, EQ, compute_mode, label);\n \t    tem = expand_binop (compute_mode, xor_optab, op0, op1,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n@@ -4469,7 +4473,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t/* No luck with division elimination or divmod.  Have to do it\n \t   by conditionally adjusting op0 *and* the result.  */\n \t{\n-\t  rtx label1, label2, label3, label4, label5;\n+\t  rtx_code_label *label1, *label2, *label3, *label4, *label5;\n \t  rtx adjusted_op0;\n \t  rtx tem;\n \n@@ -4530,7 +4534,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t      compute_mode, 1, 1);\n \t\tif (t3 == 0)\n \t\t  {\n-\t\t    rtx lab;\n+\t\t    rtx_code_label *lab;\n \t\t    lab = gen_label_rtx ();\n \t\t    do_cmp_and_jump (t2, const0_rtx, EQ, compute_mode, lab);\n \t\t    expand_inc (t1, const1_rtx);\n@@ -4570,7 +4574,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t      {\n \t\t/* This could be computed with a branch-less sequence.\n \t\t   Save that for later.  */\n-\t\trtx label = gen_label_rtx ();\n+\t\trtx_code_label *label = gen_label_rtx ();\n \t\tdo_cmp_and_jump (remainder, const0_rtx, EQ,\n \t\t\t\t compute_mode, label);\n \t\texpand_inc (quotient, const1_rtx);\n@@ -4582,7 +4586,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    /* No luck with division elimination or divmod.  Have to do it\n \t       by conditionally adjusting op0 *and* the result.  */\n \t    {\n-\t      rtx label1, label2;\n+\t      rtx_code_label *label1, *label2;\n \t      rtx adjusted_op0, tem;\n \n \t      quotient = gen_reg_rtx (compute_mode);\n@@ -4627,7 +4631,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t      compute_mode, 1, 1);\n \t\tif (t3 == 0)\n \t\t  {\n-\t\t    rtx lab;\n+\t\t    rtx_code_label *lab;\n \t\t    lab = gen_label_rtx ();\n \t\t    do_cmp_and_jump (t2, const0_rtx, EQ, compute_mode, lab);\n \t\t    expand_inc (t1, const1_rtx);\n@@ -4667,7 +4671,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t/* This could be computed with a branch-less sequence.\n \t\t   Save that for later.  */\n \t\trtx tem;\n-\t\trtx label = gen_label_rtx ();\n+\t\trtx_code_label *label = gen_label_rtx ();\n \t\tdo_cmp_and_jump (remainder, const0_rtx, EQ,\n \t\t\t\t compute_mode, label);\n \t\ttem = expand_binop (compute_mode, xor_optab, op0, op1,\n@@ -4682,7 +4686,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    /* No luck with division elimination or divmod.  Have to do it\n \t       by conditionally adjusting op0 *and* the result.  */\n \t    {\n-\t      rtx label1, label2, label3, label4, label5;\n+\t      rtx_code_label *label1, *label2, *label3, *label4, *label5;\n \t      rtx adjusted_op0;\n \t      rtx tem;\n \n@@ -4757,7 +4761,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \tif (unsignedp)\n \t  {\n \t    rtx tem;\n-\t    rtx label;\n+\t    rtx_code_label *label;\n \t    label = gen_label_rtx ();\n \t    quotient = gen_reg_rtx (compute_mode);\n \t    remainder = gen_reg_rtx (compute_mode);\n@@ -4780,7 +4784,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \telse\n \t  {\n \t    rtx abs_rem, abs_op1, tem, mask;\n-\t    rtx label;\n+\t    rtx_code_label *label;\n \t    label = gen_label_rtx ();\n \t    quotient = gen_reg_rtx (compute_mode);\n \t    remainder = gen_reg_rtx (compute_mode);\n@@ -5090,7 +5094,8 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n \t     enum machine_mode target_mode)\n {\n   struct expand_operand ops[4];\n-  rtx op0, last, comparison, subtarget;\n+  rtx op0, comparison, subtarget;\n+  rtx_insn *last;\n   enum machine_mode result_mode = targetm.cstore_mode (icode);\n \n   last = get_last_insn ();\n@@ -5394,7 +5399,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   enum machine_mode target_mode = target ? GET_MODE (target) : VOIDmode;\n   enum rtx_code rcode;\n   rtx subtarget;\n-  rtx tem, last, trueval;\n+  rtx tem, trueval;\n+  rtx_insn *last;\n \n   /* If we compare constants, we shouldn't use a store-flag operation,\n      but a constant load.  We can get there via the vanilla route that\n@@ -5722,7 +5728,8 @@ rtx\n emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t       enum machine_mode mode, int unsignedp, int normalizep)\n {\n-  rtx tem, label;\n+  rtx tem;\n+  rtx_code_label *label;\n   rtx trueval, falseval;\n \n   /* First see if emit_store_flag can do the job.  */\n@@ -5796,7 +5803,7 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n static void\n do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, enum machine_mode mode,\n-\t\t rtx label)\n+\t\t rtx_code_label *label)\n {\n   int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);\n   do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode,"}]}