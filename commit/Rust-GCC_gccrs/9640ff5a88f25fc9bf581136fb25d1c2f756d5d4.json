{"sha": "9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY0MGZmNWE4OGYyNWZjOWJmNTgxMTM2ZmIyNWQxYzJmNzU2ZDVkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-02-27T17:36:39Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-02-27T17:36:39Z"}, "message": "middle-end: Fix wrong code caused by disagreemed between FRE and access path oracle [PR 92152]\n\nFRE is checking stores for equivalence based on their address, value and\nbase+ref alias sets.  Because ref alias set is not always the alias set of\ninnermost type, but it may be one of refs in the access path (as decided by\ncomponent_uses_parent_alias_set_from) it means that we can not really rely on\nthe remaining part of access path to be meaningful in any way except for\noffset+size computation.\n\nThe patch makes alias (which is used by FRE to validate transform) and\ntree-ssa-alias to share same logic for ending the access path relevant for\nTBAA. tree-ssa-alias previously ended access paths on VIEW_CONVERT_EXPR and\nBIT_FIELD_REF so it is not hard to wire in common predicate.  However it led to\nadditional issues (I tried to read the code quite carefully for possible extra\nfun, so I hope I found it all):\n\n  1) alias_component_refs_walk compares base and reference sizes to see\n     if one access path may continue by another.  This check can be confused\n     by an union containing structure with zero sized array.  In this case we\n     no longer see the refernece to zero sized array and think that ref size\n     is 0.\n\n     In an access path there can be at most one (valid) trailing/zero sized\n     array access, so the sizes in the access path are decreasing with the\n     this exception. This is already handled by the logic, however the access\n     is not expected to happen past the end of TBAA segment.  I suppose this\n     was kind of latent problem before because one can think of access path\n     doing traling array past VIEW_CONVERT_EXPR, but since in C code we don't\n     VCE and in non-C we don't do trailing arrays, we did not hit the problem.\n\n     I fixed this by tracking if the trailing array references appearing after\n     the end of TBAA access path and mostly punt in the second case (because we\n     need to support kind of all type puning here). I do not think we can assume\n     much of sanity here, in particular, we no longer know there is only one\n     because FRE may mix things up.\n\n     An exception is the walk that looks for occurence of basetype of path1\n     within TBAA relevant part of path2.  Here we realy care about TBAA\n     relevant parts of paths and thus do not need to give up.\n\n     I broke out the logic into ends_tbaa_access_path_p to avoid duplication and\n     to let me stick some detailed comments. This became much more complex\n     than I originally imagined (still it is useful to make oracle both faster\n     and more precise).\n\n     Note that logic in aliasing_component_refs_walk is safe since it works\n     on TBAA relevant segments of paths only.\n  2) nonoverlapping_refs_since_match_p is using TBAA only in the corner case\n     that the paths got out of sync and re-synchronize of types of same size\n     are found.  I thus extended it to whole paths (not only TBAA relevant\n     parts) and track if the TBAA part can be used by counting of number of\n     TBAA relevant res on the stack.\n\n     I have noticed that in one case we call nonoverlapping_refs_since_match_p\n     before checking for view converting MEM_REFs and in others we check\n     after.  I think we want to just disable TBAA part if view convert\n     is in there but still disambiguate.  I will do this incrementaly.\n  3) nonoverlapping_component_refs_p uses TBAA so it needs to punt on\n     end of TBAA path. It deals with no sizes and thus there is not the issue\n     as in 1).\n\nI am also attaching one (most probably) valid C++ testcase (by Mark Williams)\nwhere we incorrectly disambiguated while the code is valid by the common\ninitial sequence rule.  This happens to be fixed by same patch. Here one access\ngoes through union and follows by access path trhough one filed, while other\naccess path start by different field of the union with common initial sequence.\nThis made aliasing_component_refs_p to not find the overlapping type (because\nthere is none) and disambiguate.  Now we cut the first access path by the union\nreference and this makes us to find the path continuation in\nalias_component_refs_walk.\n\nIf FRE is ever made more careful about access paths past the fist union\nreference (I think that would be good idea since unions are quite common in C++\nand we throw away quite useful info) then we will need to teach access path\noracle about the common initial sequence rule (which, as Mark pointed out, is\npart of both C and C++ standards).\n\nOnly argument that can possibly invalidate this testcase is that I do not see\nthat stadnard is clear about the situation where one access path contains the\nunion but other starts after the union.\n\nClearly if both start after the union reference we are right to disambiguate\n(since there is no union unvolved).  If both starts before union then there is\ncommon initial sequence and by standard it is defined. This case works on current\ntrunk because aliasing_component_refs_p resorts to base+offset after finding\nthe match. But even that is more or less an accident I would say.\n\nI had to xfail three testcases.  While alias-access-path ones are artificial\nand odd, 20030807-7 is derived from gcc and shows that we give up on\ndisambiguations of tree_node union, so this patch disables useful transform\nin real world code.\n\nI am still planning to collect some data on the effect of this change to TBAA,\nbut unless we want to reorganize FRE, I do not think there is better solution.\n\ngcc/ChangeLog:\n\n2020-02-26  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR middle-end/92152\n\t* alias.c (ends_tbaa_access_path_p): Break out from ...\n\t(component_uses_parent_alias_set_from): ... here.\n\t* alias.h (ends_tbaa_access_path_p): Declare.\n\t* tree-ssa-alias.c (access_path_may_continue_p): Break out from ...;\n\thandle trailing arrays past end of tbaa access path.\n\t(aliasing_component_refs_p): ... here; likewise.\n\t(nonoverlapping_refs_since_match_p): Track TBAA segment of the access\n\tpath; disambiguate also past end of it.\n\t(nonoverlapping_component_refs_p): Use only TBAA segment of the access\n\tpath.\n\ngcc/testsuite/ChangeLog:\n\n2020-02-26  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR middle-end/92152\n\t* gcc.dg/tree-ssa/alias-access-path-12.c: New testcase.\n\t* g++.dg/torture/pr92152.C: New testcase.\n\t* gcc.dg/torture/pr92152.c: New testcase.\n\t* gcc.dg/tree-ssa/20030807-7.c: xfail.\n\t* gcc.dg/tree-ssa/alias-access-path-4.c: xfail one case.\n\t* gcc.dg/tree-ssa/alias-access-path-5.c: xfail one case.", "tree": {"sha": "140756ce031d5cbf6b63c78520094cbed14078cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/140756ce031d5cbf6b63c78520094cbed14078cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/comments", "author": null, "committer": null, "parents": [{"sha": "17a13507d776059bd7022ea4ddf7d5b9fab5294b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a13507d776059bd7022ea4ddf7d5b9fab5294b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a13507d776059bd7022ea4ddf7d5b9fab5294b"}], "stats": {"total": 405, "additions": 317, "deletions": 88}, "files": [{"sha": "cc93163d3e6eabe4e6e7749f262da5c4583723e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -1,3 +1,17 @@\n+2020-02-27  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/92152\n+\t* alias.c (ends_tbaa_access_path_p): Break out from ...\n+\t(component_uses_parent_alias_set_from): ... here.\n+\t* alias.h (ends_tbaa_access_path_p): Declare.\n+\t* tree-ssa-alias.c (access_path_may_continue_p): Break out from ...;\n+\thandle trailing arrays past end of tbaa access path.\n+\t(aliasing_component_refs_p): ... here; likewise.\n+\t(nonoverlapping_refs_since_match_p): Track TBAA segment of the access\n+\tpath; disambiguate also past end of it.\n+\t(nonoverlapping_component_refs_p): Use only TBAA segment of the access\n+\tpath.\n+\n 2020-02-27  Mihail Ionescu  <mihail.ionescu@arm.com>\n \n \t* (__ARM_NUM_LANES, __arm_lane, __arm_lane_q): Move to the"}, {"sha": "fe75e22cdb5b03d1cd9f58ab1781953c81c39bce", "filename": "gcc/alias.c", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -587,6 +587,49 @@ objects_must_conflict_p (tree t1, tree t2)\n   return alias_sets_must_conflict_p (set1, set2);\n }\n \f\n+/* Return true if T is an end of the access path which can be used\n+   by type based alias oracle.  */\n+\n+bool\n+ends_tbaa_access_path_p (const_tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case COMPONENT_REF:\n+      if (DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1)))\n+\treturn true;\n+      /* Permit type-punning when accessing a union, provided the access\n+\t is directly through the union.  For example, this code does not\n+\t permit taking the address of a union member and then storing\n+\t through it.  Even the type-punning allowed here is a GCC\n+\t extension, albeit a common and useful one; the C standard says\n+\t that such accesses have implementation-defined behavior.  */\n+      else if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n+\treturn true;\n+      break;\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      if (TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0))))\n+\treturn true;\n+      break;\n+\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      break;\n+\n+    case BIT_FIELD_REF:\n+    case VIEW_CONVERT_EXPR:\n+      /* Bitfields and casts are never addressable.  */\n+      return true;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n /* Return the outermost parent of component present in the chain of\n    component references handled by get_inner_reference in T with the\n    following property:\n@@ -601,40 +644,8 @@ component_uses_parent_alias_set_from (const_tree t)\n \n   while (handled_component_p (t))\n     {\n-      switch (TREE_CODE (t))\n-\t{\n-\tcase COMPONENT_REF:\n-\t  if (DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1)))\n-\t    found = t;\n-\t  /* Permit type-punning when accessing a union, provided the access\n-\t     is directly through the union.  For example, this code does not\n-\t     permit taking the address of a union member and then storing\n-\t     through it.  Even the type-punning allowed here is a GCC\n-\t     extension, albeit a common and useful one; the C standard says\n-\t     that such accesses have implementation-defined behavior.  */\n-\t  else if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n-\t    found = t;\n-\t  break;\n-\n-\tcase ARRAY_REF:\n-\tcase ARRAY_RANGE_REF:\n-\t  if (TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0))))\n-\t    found = t;\n-\t  break;\n-\n-\tcase REALPART_EXPR:\n-\tcase IMAGPART_EXPR:\n-\t  break;\n-\n-\tcase BIT_FIELD_REF:\n-\tcase VIEW_CONVERT_EXPR:\n-\t  /* Bitfields and casts are never addressable.  */\n-\t  found = t;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      if (ends_tbaa_access_path_p (t))\n+\tfound = t;\n \n       t = TREE_OPERAND (t, 0);\n     }"}, {"sha": "781b040fec11cff58bb456b364805728c8699d3c", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -26,6 +26,7 @@ extern alias_set_type get_deref_alias_set (tree);\n extern alias_set_type get_varargs_alias_set (void);\n extern alias_set_type get_frame_alias_set (void);\n extern tree component_uses_parent_alias_set_from (const_tree);\n+extern bool ends_tbaa_access_path_p (const_tree);\n extern bool alias_set_subset_of (alias_set_type, alias_set_type);\n extern void record_alias_subset (alias_set_type, alias_set_type);\n extern void record_component_aliases (tree);"}, {"sha": "756273e57afcdbc806e42ca7dde972a66f686645", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -1,3 +1,13 @@\n+2020-02-27  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/92152\n+\t* gcc.dg/tree-ssa/alias-access-path-12.c: New testcase.\n+\t* g++.dg/torture/pr92152.C: New testcase.\n+\t* gcc.dg/torture/pr92152.c: New testcase.\n+\t* gcc.dg/tree-ssa/20030807-7.c: xfail.\n+\t* gcc.dg/tree-ssa/alias-access-path-4.c: xfail one case.\n+\t* gcc.dg/tree-ssa/alias-access-path-5.c: xfail one case.\n+\n 2020-02-27  Mihail Ionescu  <mihail.ionescu@arm.com>\n \n \t* gcc.target/arm/bf16_dup.c: New test."}, {"sha": "1aff9b735be36254434e7440906a42ba561bfa35", "filename": "gcc/testsuite/g++.dg/torture/pr92152.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr92152.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr92152.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr92152.C?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run } */\n+using size_t = unsigned long;\n+using uint64_t = unsigned long;\n+\n+namespace HPHP {\n+\n+inline void bitvec_set(uint64_t* bits, size_t index) {\n+  bits[index / 64] |= 1ull << (index % 64);\n+}\n+\n+namespace jit {\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct VregSet {\n+  struct Block;\n+\n+  VregSet() : blocks{} { blocks.data[1] = 1LL << 0x30; };\n+\n+  VregSet(const VregSet& o)\n+    : blocks{o.blocks}\n+  {\n+  }\n+\n+  bool any() const {\n+    if (!isExtended()) return blocks.any();\n+    return true;\n+  }\n+  void removePhys() {\n+    auto const b = !isExtended() ? &blocks : extended.blocks;\n+    b->data[0] = 0;\n+    b->data[1] = 0;\n+  }\n+  static constexpr size_t kBitsPerBlock = 256;\n+  bool isExtended() const {\n+    return extended.data[1] & (1ULL << (kExtendedBit % 64));\n+  }\n+\n+  static constexpr size_t kExtendedBit = 127;\n+\n+  struct Block {\n+    bool any() const {\n+      return data[0] | data[1];\n+    }\n+    uint64_t data[2];\n+  };\n+  struct Extended {\n+    uint64_t data[2];\n+    Block* blocks;\n+  };\n+\n+  union {\n+    Block blocks{};\n+    Extended extended;\n+  };\n+};\n+\n+//////////////////////////////////////////////////////////////////////\n+\n+\n+__attribute__((noinline))\n+bool test(VregSet&& c) {\n+  auto copy = c;\n+  copy.removePhys();\n+  return copy.any();\n+}\n+///////////////////////////////////////////////////////////////////////////////\n+}}\n+///////////////////////////////////////////////////////////////////////////////\n+\n+int main() {\n+  if (HPHP::jit::test(HPHP::jit::VregSet{}))\n+    __builtin_abort ();\n+  return 0;\n+} "}, {"sha": "a4f883956d4a39ac909c7ba483ce65f21ef51f3d", "filename": "gcc/testsuite/gcc.dg/torture/pr92152.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92152.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92152.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92152.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+union U\n+{\n+  long long i;\n+  long f;\n+} v;\n+ \t\n+long\n+foo (long *f)\n+{\n+  *f = 1;\n+  v.i = 0;\n+  v.f = 0;\n+  return *f;\n+}\n+ \t\n+int\n+main ()\n+{\n+  if (foo (&v.f) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "ca06f712890f85b6816b9dc7bc0a8ec50abf37e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-7.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -34,4 +34,4 @@ simplify_condition (cond_p)\n }\n \n /* There should be exactly one IF conditional.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp1\" { xfail *-*-* } } } */"}, {"sha": "738f45503a5cdda09e9ce63fe6595dbb554ef07b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-12.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-12.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-strict-aliasing -fdump-tree-optimized\" } */\n+\n+struct S\n+{\n+  int i;\n+  int j;\n+};\n+union U\n+{\n+  struct S a[10];\n+};\n+int\n+foo (union U *u, int n, int i, int j)\n+{\n+  u->a[i].i = 123;\n+  u->a[j].j = j;\n+  return u->a[i].i;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"} } */"}, {"sha": "2883fd37f3161854e2c336c9aaeb021e36cf75a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-4.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -20,5 +20,5 @@ test2 (struct b *bptr1, union c *cptr, int i, int j)\n   cptr->b.a[j].v1=1;\n   return bptr1->a[i].v1;\n }\n-/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"  { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-not \"return 124\" \"optimized\"} } */"}, {"sha": "c58d478e0eba17e05ed48c9326f35310eedcd209", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-5.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -21,5 +21,5 @@ test2 (struct b *bptr1, union c *cptr, int i, int j)\n   cptr->b.a[j].v1=1;\n   return bptr1->a[i].v1;\n }\n-/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"  { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-not \"return 124\" \"optimized\"} } */"}, {"sha": "2e8290f35d504d04fcc64e38ea4f76b37e455791", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 127, "deletions": 51, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9640ff5a88f25fc9bf581136fb25d1c2f756d5d4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=9640ff5a88f25fc9bf581136fb25d1c2f756d5d4", "patch": "@@ -995,6 +995,51 @@ aliasing_component_refs_walk (tree ref1, tree type1, tree base1,\n   return -1;\n }\n \n+/* Consider access path1 base1....ref1 and access path2 base2...ref2.\n+   Return true if they can be composed to single access path\n+   base1...ref1...base2...ref2.\n+\n+   REF_TYPE1 if type of REF1.  END_STRUCT_PAST_END1 is true if there is\n+   a trailing array access after REF1 in the non-TBAA part of the access.\n+   REF1_ALIAS_SET is the alias set of REF1.\n+\n+   BASE_TYPE2 is type of base2.  END_STRUCT_REF2 is non-NULL if there is\n+   a traling array access in the TBAA part of access path2.\n+   BASE2_ALIAS_SET is the alias set of base2.  */\n+\n+bool\n+access_path_may_continue_p (tree ref_type1, bool end_struct_past_end1,\n+\t\t\t    alias_set_type ref1_alias_set,\n+\t\t\t    tree base_type2, tree end_struct_ref2,\n+\t\t\t    alias_set_type base2_alias_set)\n+{\n+  /* Access path can not continue past types with no components.  */\n+  if (!type_has_components_p (ref_type1))\n+    return false;\n+\n+  /* If first access path ends by too small type to hold base of\n+     the second access path, typically paths can not continue.\n+\n+     Punt if end_struct_past_end1 is true.  We want to support arbitrary\n+     type puning past first COMPONENT_REF to union because redundant store\n+     elimination depends on this, see PR92152.  For this reason we can not\n+     check size of the reference because types may partially overlap.  */\n+  if (!end_struct_past_end1)\n+    {\n+      if (compare_type_sizes (ref_type1, base_type2) < 0)\n+\treturn false;\n+      /* If the path2 contains trailing array access we can strenghten the check\n+\t to verify that also the size of element of the trailing array fits.\n+\t In fact we could check for offset + type_size, but we do not track\n+\t offsets and this is quite side case.  */\n+      if (end_struct_ref2\n+\t  && compare_type_sizes (ref_type1, TREE_TYPE (end_struct_ref2)) < 0)\n+\treturn false;\n+    }\n+  return (base2_alias_set == ref1_alias_set\n+\t  || alias_set_subset_of (base2_alias_set, ref1_alias_set));\n+}\n+\n /* Determine if the two component references REF1 and REF2 which are\n    based on access types TYPE1 and TYPE2 and of which at least one is based\n    on an indirect reference may alias.  \n@@ -1021,8 +1066,30 @@ aliasing_component_refs_p (tree ref1,\n   tree type1, type2;\n   bool maybe_match = false;\n   tree end_struct_ref1 = NULL, end_struct_ref2 = NULL;\n+  bool end_struct_past_end1 = false;\n+  bool end_struct_past_end2 = false;\n+\n+  /* Choose bases and base types to search for.\n+     The access path is as follows:\n+       base....end_of_tbaa_ref...actual_ref\n+     At one place in the access path may be a reference to zero sized or\n+     trailing array.\n+\n+     We generally discard the segment after end_of_tbaa_ref however\n+     we need to be careful in case it contains zero sized or traling array.\n+     These may happen after refernce to union and in this case we need to\n+     not disambiguate type puning scenarios.\n+\n+     We set:\n+\tbase1 to point to base\n+\n+\tref1 to point to end_of_tbaa_ref\n \n-  /* Choose bases and base types to search for.  */\n+\tend_struct_ref1 to point the trailing reference (if it exists\n+ \tin range base....end_of_tbaa_ref\n+\n+\tend_struct_past_end1 is true if this traling refernece occurs in\n+\tend_of_tbaa_ref...actual_ref.  */\n   base1 = ref1;\n   while (handled_component_p (base1))\n     {\n@@ -1042,9 +1109,15 @@ aliasing_component_refs_p (tree ref1,\n \t  gcc_checking_assert (!end_struct_ref1);\n           end_struct_ref1 = base1;\n \t}\n-      if (TREE_CODE (base1) == VIEW_CONVERT_EXPR\n-\t  || TREE_CODE (base1) == BIT_FIELD_REF)\n-\tref1 = TREE_OPERAND (base1, 0);\n+      if (ends_tbaa_access_path_p (base1))\n+\t{\n+\t  ref1 = TREE_OPERAND (base1, 0);\n+\t  if (end_struct_ref1)\n+\t    {\n+\t      end_struct_past_end1 = true;\n+\t      end_struct_ref1 = NULL;\n+\t    }\n+\t}\n       base1 = TREE_OPERAND (base1, 0);\n     }\n   type1 = TREE_TYPE (base1);\n@@ -1056,9 +1129,15 @@ aliasing_component_refs_p (tree ref1,\n \t  gcc_checking_assert (!end_struct_ref2);\n \t  end_struct_ref2 = base2;\n \t}\n-      if (TREE_CODE (base2) == VIEW_CONVERT_EXPR\n-\t  || TREE_CODE (base2) == BIT_FIELD_REF)\n-\tref2 = TREE_OPERAND (base2, 0);\n+      if (ends_tbaa_access_path_p (base2))\n+\t{\n+\t  ref2 = TREE_OPERAND (base2, 0);\n+\t  if (end_struct_ref2)\n+\t    {\n+\t      end_struct_past_end2 = true;\n+\t      end_struct_ref2 = NULL;\n+\t    }\n+\t}\n       base2 = TREE_OPERAND (base2, 0);\n     }\n   type2 = TREE_TYPE (base2);\n@@ -1070,7 +1149,8 @@ aliasing_component_refs_p (tree ref1,\n \n   /* If type2 is big enough to contain type1 walk its access path.\n      We also need to care of arrays at the end of structs that may extend\n-     beyond the end of structure.  */\n+     beyond the end of structure.  If this occurs in the TBAA part of the\n+     access path, we need to consider the increased type as well.  */\n   if (cmp_outer >= 0\n       || (end_struct_ref2\n \t  && compare_type_sizes (TREE_TYPE (end_struct_ref2), type1) >= 0))\n@@ -1113,31 +1193,14 @@ aliasing_component_refs_p (tree ref1,\n       return false;\n     }\n \n-  /* If we have two type access paths B1.path1 and B2.path2 they may\n-     only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n-     But we can still have a path that goes B1.path1...B2.path2 with\n-     a part that we do not see.  So we can only disambiguate now\n-     if there is no B2 in the tail of path1 and no B1 on the\n-     tail of path2.  */\n-  if (compare_type_sizes (TREE_TYPE (ref2), type1) >= 0\n-      && (!end_struct_ref1\n-\t  || compare_type_sizes (TREE_TYPE (ref2),\n-\t\t \t\t TREE_TYPE (end_struct_ref1)) >= 0)\n-      && type_has_components_p (TREE_TYPE (ref2))\n-      && (base1_alias_set == ref2_alias_set\n-          || alias_set_subset_of (base1_alias_set, ref2_alias_set)))\n-    {\n-      ++alias_stats.aliasing_component_refs_p_may_alias;\n-      return true;\n-    }\n-  /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n-  if (compare_type_sizes (TREE_TYPE (ref1), type2) >= 0\n-      && (!end_struct_ref2\n-\t  || compare_type_sizes (TREE_TYPE (ref1),\n-\t\t \t\t TREE_TYPE (end_struct_ref2)) >= 0)\n-      && type_has_components_p (TREE_TYPE (ref1))\n-      && (base2_alias_set == ref1_alias_set\n-\t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n+  if (access_path_may_continue_p (TREE_TYPE (ref1), end_struct_past_end1,\n+\t\t\t\t  ref1_alias_set,\n+\t\t\t\t  type2, end_struct_ref2,\n+\t\t\t\t  base2_alias_set)\n+      || access_path_may_continue_p (TREE_TYPE (ref2), end_struct_past_end2,\n+\t\t\t\t     ref2_alias_set,\n+\t\t\t\t     type1, end_struct_ref1,\n+\t\t\t\t     base1_alias_set))\n     {\n       ++alias_stats.aliasing_component_refs_p_may_alias;\n       return true;\n@@ -1348,6 +1411,7 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t\t\t\t   tree match2, tree ref2,\n \t\t\t\t   bool partial_overlap)\n {\n+  int ntbaa1 = 0, ntbaa2 = 0;\n   /* Early return if there are no references to match, we do not need\n      to walk the access paths.\n \n@@ -1365,25 +1429,33 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n   /* Create the stack of handled components for REF1.  */\n   while (handled_component_p (ref1) && ref1 != match1)\n     {\n-      if (TREE_CODE (ref1) == VIEW_CONVERT_EXPR\n-\t  || TREE_CODE (ref1) == BIT_FIELD_REF)\n-\tcomponent_refs1.truncate (0);\n+      /* We use TBAA only to re-synchronize after mismatched refs.  So we\n+\t do not need to truncate access path after TBAA part ends.  */\n+      if (ends_tbaa_access_path_p (ref1))\n+\tntbaa1 = 0;\n       else\n-        component_refs1.safe_push (ref1);\n+\tntbaa1++;\n+      component_refs1.safe_push (ref1);\n       ref1 = TREE_OPERAND (ref1, 0);\n     }\n \n   /* Create the stack of handled components for REF2.  */\n   while (handled_component_p (ref2) && ref2 != match2)\n     {\n-      if (TREE_CODE (ref2) == VIEW_CONVERT_EXPR\n-\t  || TREE_CODE (ref2) == BIT_FIELD_REF)\n-\tcomponent_refs2.truncate (0);\n+      if (ends_tbaa_access_path_p (ref2))\n+\tntbaa2 = 0;\n       else\n-        component_refs2.safe_push (ref2);\n+\tntbaa2++;\n+      component_refs2.safe_push (ref2);\n       ref2 = TREE_OPERAND (ref2, 0);\n     }\n \n+  if (!flag_strict_aliasing)\n+    {\n+      ntbaa1 = 0;\n+      ntbaa2 = 0;\n+    }\n+\n   bool mem_ref1 = TREE_CODE (ref1) == MEM_REF && ref1 != match1;\n   bool mem_ref2 = TREE_CODE (ref2) == MEM_REF && ref2 != match2;\n \n@@ -1444,6 +1516,7 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t  for (; narray_refs1 > narray_refs2; narray_refs1--)\n \t    {\n \t      ref1 = component_refs1.pop ();\n+\t      ntbaa1--;\n \n \t      /* If index is non-zero we need to check whether the reference\n \t\t does not break the main invariant that bases are either\n@@ -1471,6 +1544,7 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t  for (; narray_refs2 > narray_refs1; narray_refs2--)\n \t    {\n \t      ref2 = component_refs2.pop ();\n+\t      ntbaa2--;\n \t      if (!operand_equal_p (TREE_OPERAND (ref2, 1),\n \t\t\t\t    cheap_array_ref_low_bound (ref2), 0))\n \t\treturn 0;\n@@ -1480,6 +1554,8 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t    {\n \t      int cmp = nonoverlapping_array_refs_p (component_refs1.pop (),\n \t\t\t\t\t\t     component_refs2.pop ());\n+\t      ntbaa1--;\n+\t      ntbaa2--;\n \t      if (cmp == 1 && !partial_overlap)\n \t\t{\n \t\t  ++alias_stats\n@@ -1494,7 +1570,7 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t\t     from type based alias analysis if we reach referneces to\n \t\t     same sizes.  We do not attempt to match array sizes, so\n \t\t     just finish array walking and look for component refs.  */\n-\t\t  if (!flag_strict_aliasing)\n+\t\t  if (ntbaa1 < 0 || ntbaa2 < 0)\n \t\t    {\n \t\t      ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n \t\t      return -1;\n@@ -1503,6 +1579,8 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t\t    {\n \t\t      component_refs1.pop ();\n \t\t      component_refs2.pop ();\n+\t\t      ntbaa1--;\n+\t\t      ntbaa2--;\n \t\t    }\n \t\t  break;\n \t\t}\n@@ -1520,10 +1598,11 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t      return 0;\n \t    }\n \t  ref1 = component_refs1.pop ();\n+\t  ntbaa1--;\n \t  if (TREE_CODE (ref1) != COMPONENT_REF)\n \t    {\n \t      seen_unmatched_ref_p = true;\n-\t      if (!flag_strict_aliasing)\n+\t      if (ntbaa1 < 0 || ntbaa2 < 0)\n \t\t{\n \t\t  ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n \t\t  return -1;\n@@ -1541,9 +1620,10 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \t      return 0;\n \t    }\n \t  ref2 = component_refs2.pop ();\n+\t  ntbaa2--;\n \t  if (TREE_CODE (ref2) != COMPONENT_REF)\n \t    {\n-\t      if (!flag_strict_aliasing)\n+\t      if (ntbaa1 < 0 || ntbaa2 < 0)\n \t\t{\n \t\t  ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n \t\t  return -1;\n@@ -1569,11 +1649,9 @@ nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n \n       partial_overlap = false;\n \n-      gcc_checking_assert (!seen_unmatched_ref_p || flag_strict_aliasing);\n-\n       /* If we skipped array refs on type of different sizes, we can\n \t no longer be sure that there are not partial overlaps.  */\n-      if (seen_unmatched_ref_p\n+      if (seen_unmatched_ref_p && ntbaa1 >= 0 && ntbaa2 >= 0\n \t  && !operand_equal_p (TYPE_SIZE (type1), TYPE_SIZE (type2), 0))\n \t{\n \t  ++alias_stats\n@@ -1663,8 +1741,7 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n \t  if (TREE_CODE (type) == RECORD_TYPE)\n \t    fieldsx.safe_push (field);\n \t}\n-      else if (TREE_CODE (x) == VIEW_CONVERT_EXPR\n-\t       || TREE_CODE (x) == BIT_FIELD_REF)\n+      else if (ends_tbaa_access_path_p (x))\n \tfieldsx.truncate (0);\n       x = TREE_OPERAND (x, 0);\n     }\n@@ -1680,8 +1757,7 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n \t  if (TREE_CODE (type) == RECORD_TYPE)\n \t    fieldsy.safe_push (TREE_OPERAND (y, 1));\n \t}\n-      else if (TREE_CODE (y) == VIEW_CONVERT_EXPR\n-\t       || TREE_CODE (y) == BIT_FIELD_REF)\n+      else if (ends_tbaa_access_path_p (y))\n \tfieldsy.truncate (0);\n       y = TREE_OPERAND (y, 0);\n     }"}]}