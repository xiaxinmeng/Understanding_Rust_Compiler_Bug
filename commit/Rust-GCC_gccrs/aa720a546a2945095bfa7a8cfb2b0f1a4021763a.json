{"sha": "aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE3MjBhNTQ2YTI5NDUwOTViZmE3YThjZmIyYjBmMWE0MDIxNzYzYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-05T10:09:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-05T10:09:56Z"}, "message": "[multiple changes]\n\n2004-05-05  Emmanuel Briot  <briot@act-europe.fr>\n\n\t* g-os_lib.ads (Invalid_Time): New constant\n\n\t* adaint.h, adaint.c (__gnat_file_time_name, __gnat_file_time_fd): Now\n\treturn OS_Time instead of time_t to match what is imported by Ada.\n\tNow return -1 if the file doesn't exist, instead of a random value\n\n2004-05-05  Robert Dewar  <dewar@gnat.com>\n\n\t* usage.adb: Add line for -gnatR?s switch\n\n\t* sem_ch13.adb, exp_ch2.adb: Minor reformatting\n\n\t* g-regpat.ads, g-regpat.adb: Add documentation on handling of Size\n\tand for Match (Data_First, Data_last)\n\n\t* lib-writ.adb (Write_With_Lines): Ensure that correct index number is\n\twritten when we are dealing with multi-unit files.\n\n2004-05-05  Jerome Guitton  <guitton@act-europe.fr>\n\n\t* Makefile.in: Remove unused targets and variables.\n\n2004-05-05  Vincent Celier  <celier@gnat.com>\n\n\t* switch-m.adb: New gnatmake switch -eI\n\n\t* vms_data.ads: Add VMS equivalents of new gnatclean swith -innn and\n\tof new gnatmake switch -eInnn.\n\n\t* makegpr.adb: Take into account new parameters Index and Src_Index in\n\tPrj.Util.\n\n\t* clean.adb: Implement support for multi-unit sources, including new\n\tswitch -i.\n\n\t* gnatcmd.adb (GNATCmd): Call Prj.Util.Value_Of with new parameter\n\tSrc_Index.\n\n\t* make.ads, make.adb (Insert_Q): New parameter Index, defaulted to 0\n\t(Extract_From_Q): New out parameter Index\n\t(Mark, Is_Marked): Subprograms moved to Makeutl\n\t(Switches_Of): New parameter Source_Index\n\t(Add_Switch): New parameter Index\n\t(Check): New parameter Source_Index\n\t(Collect_Arguments): New parameter Source_Index\n\t(Collect_Arguments_And_Compile): New parameter Source_Index\n\t(Compile): New parameter Source_Index\n\tPut subprograms in alphabetical order\n\tAdd support for multi-source sources, including in project files.\n\n\t* makeutl.ads, makeutl.adb (Unit_Index_Of): New function\n\t(Mark, Is_Marked, Delete_All_Marks): New subprograms, moved from\n\tMake.\n\n\t* makeusg.adb: New gnatmake switch -eInnn\n\n\t* mlib-prj.adb (Build_Library): Add new parameter Src_Index to call to\n\tPrj.Util.Value_Of.\n\n\t* opt.ads (Main_Index): New variable, defaulted to 0.\n\n\t* osint.ads, osinte.adb (Add_File): New parameter Index\n\t(Current_Source_Index): New function\n\n\t* prj.adb: Take into account new components Index and Src_Index\n\n\t* prj.ads (String_Element): New component Index\n\t(Variable_Value): New component Index\n\t(Array_Element): New component Src_Index\n\n\t* prj-attr.adb: Indicate that optional index may be specified for\n\tattributes Main, Executable, Spec, Body and some of Switches.\n\n\t* prj-attr.ads (Attribute_Kind): New values for optional indexes\n\t(Attribute_Record): New component Optional_Index\n\n\t* prj-com.ads (File_Name_Data): New component Index\n\n\t* prj-dect.adb (Parse_Attribute_Declaration): Process optional index\n\n\t* prj-env.adb (Put): Output optional index\n\n\t* prj-makr.adb: Put indexes for multi-unit sources in SFN pragmas and\n\tattributes Spec and Body.\n\n\t* prj-nmsc.adb: Process optional indexes\n\n\t* prj-pp.adb: Ouput \"at\" for optional indexes\n\n\t* prj-proc.adb: Take into account optional indexes\n\n\t* prj-strt.ads, prj-strt.adb (Terms): New Boolean parameter\n\tOptional_Index. For string literal,\n\tprocess optional index when Optional_Index is True.\n\t(Parse_Expresion): New Boolean parameter Optional_Index\n\n\t* prj-tree.ads, prj-tree.adb (Source_Index_Of): New function\n\t(Set_Source_Index_Of): New procedure\n\n\t* prj-util.adb (Executable_Of, Value_Of): Take into account optional\n\tindex.\n\n\t* prj-util.ads (Executable_Of): New parameter Index\n\t(Value_Of (Name_Id, Array_Element_Id) returning Variable_Value):\n\tNew parameter Src_Index, defaulted to 0.\n\n2004-05-05  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15257\n\t* sem_ch3.adb (Access_Definition): If this is an access parameter\n\twhose designated type is imported through a limited_with clause, do\n\tnot add the enclosing subprogram to the list of private dependents of\n\tthe type.\n\n2004-05-05  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15258\n\t* sem_ch6.adb (Base_Types_Match): True if one type is imported through\n\ta limited_with clause, and the other is its non-limited view.\n\n2004-05-05  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* cstand.adb (Create_Standard): Initialize Stand.Boolean_Literals.\n\n\t* exp_attr.adb, exp_ch5.adb, exp_ch9.adb, exp_disp.adb,\n\texp_fixd.adb, sem_attr.adb, sem_dist.adb, sem_util.adb: Use\n\tStand.Boolean_Literals to produce references to entities\n\tStandard_False and Standard_True from compile-time computed boolean\n\tvalues.\n\n\t* stand.ads (Boolean_Literals): New variable, provides the entity\n\tvalues for False and True, for use by the expander.\n\n2004-05-05  Doug Rupp  <rupp@gnat.com>\n\n\t* 5vinmaop.adb, 5[vx]system.ads: Add Short_Address subtype\n\t5vinmaop.adb: Unchecked convert Short_Address vice Address\n\n\t* adaint.c, raise.c: Caste CRTL function return value\n\tto avoid gcc error on 32/64 bit IVMS.\n\n\t* Makefile.in [VMS]: Use iar archiver if host = Alpha/VMS and\n\ttarget = IA64/VMS.\n\n\t* init.c[VMS]: Only call Alpha specific __gnat_error_prehandler IN_RTS.\n\n\t* 5qsystem.ads (Address): Declare as Long_Integer\n\t(Short_Address): Declare as 32 bit subtype of Address\n\tDeclare  abstract address operations to avoid gratuitous ambiguities.\n\n2004-05-05  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* gnat_rm.texi: Use the new restriction Simple_Barriers (AI-249)\n\tinstead of the old Boolean_Entry_Barriers.\n\tDitto for No_Task_Attributes_Package instead of No_Task_Attributes.\n\n2004-05-05  GNAT Script  <nobody@gnat.com>\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r81519", "tree": {"sha": "79664ddc9b0ba53bcbb38c74d0161e65912f0466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79664ddc9b0ba53bcbb38c74d0161e65912f0466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/comments", "author": null, "committer": null, "parents": [{"sha": "68ea5833ec6d11b69ca1dc822b7b6b946efadee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ea5833ec6d11b69ca1dc822b7b6b946efadee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ea5833ec6d11b69ca1dc822b7b6b946efadee1"}], "stats": {"total": 3543, "additions": 2105, "deletions": 1438}, "files": [{"sha": "cfbba6d5c53994702bc48eef0c89c08b9a9a7a82", "filename": "gcc/ada/5qsystem.ads", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5qsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5qsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qsystem.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -62,7 +62,10 @@ pragma Pure (System);\n \n    --  Storage-related Declarations\n \n-   type Address is private;\n+   type Address is new Long_Integer;\n+   subtype Short_Address is Address\n+     range -2 ** (32 - 1) .. +2 ** (32 - 1) - 1;\n+   for Short_Address'Object_Size use 32;\n    Null_Address : constant Address;\n \n    Storage_Unit : constant := 8;\n@@ -83,6 +86,18 @@ pragma Pure (System);\n    pragma Import (Intrinsic, \">=\");\n    pragma Import (Intrinsic, \"=\");\n \n+   --  Abstract declarations for arithmetic operations on type address.\n+   --  These declarations are needed when Address is non-private. They\n+   --  avoid excessive visibility of arithmetic operations on address\n+   --  which are typically available elsewhere (e.g. Storage_Elements)\n+   --  and which would cause excessive ambiguities in application code.\n+\n+   function \"+\"   (Left, Right : Address) return Address is abstract;\n+   function \"-\"   (Left, Right : Address) return Address is abstract;\n+   function \"/\"   (Left, Right : Address) return Address is abstract;\n+   function \"*\"   (Left, Right : Address) return Address is abstract;\n+   function \"mod\" (Left, Right : Address) return Address is abstract;\n+\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n@@ -101,7 +116,6 @@ pragma Pure (System);\n \n private\n \n-   type Address is mod Memory_Size;\n    Null_Address : constant Address := 0;\n \n    --------------------------------------"}, {"sha": "42207a1ce100289e4c5abb0ea0c3a3980bc5cb1b", "filename": "gcc/ada/5vinmaop.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5vinmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5vinmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vinmaop.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -114,7 +114,7 @@ package body System.Interrupt_Management.Operations is\n    --------------------\n \n    function To_unsigned_long is new\n-     Unchecked_Conversion (System.Address, unsigned_long);\n+     Unchecked_Conversion (System.Short_Address, unsigned_long);\n \n    function Interrupt_Wait (Mask : access Interrupt_Mask)\n      return Interrupt_ID"}, {"sha": "9bf3b5f2698659e859454f9dd34d1aefa916a1f9", "filename": "gcc/ada/5vsystem.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5vsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5vsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vsystem.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                       (OpenVMS DEC Threads Version)                      --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -63,6 +63,7 @@ pragma Pure (System);\n    --  Storage-related Declarations\n \n    type Address is private;\n+   subtype Short_Address is Address;\n    Null_Address : constant Address;\n \n    Storage_Unit : constant := 8;"}, {"sha": "a716fa1a708a1fd999e296eb2b380c279baba751", "filename": "gcc/ada/5xsystem.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5xsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2F5xsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5xsystem.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                   (OpenVMS GCC_ZCX DEC Threads Version)                  --\n --                                                                          --\n---          Copyright (C) 2002-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -63,6 +63,7 @@ pragma Pure (System);\n    --  Storage-related Declarations\n \n    type Address is private;\n+   subtype Short_Address is Address;\n    Null_Address : constant Address;\n \n    Storage_Unit : constant := 8;"}, {"sha": "19d4b15b1f7b884def6aace891889b438d4e9777", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -1,3 +1,165 @@\n+2004-05-05  Emmanuel Briot  <briot@act-europe.fr>\n+\n+\t* g-os_lib.ads (Invalid_Time): New constant\n+\n+\t* adaint.h, adaint.c (__gnat_file_time_name, __gnat_file_time_fd): Now\n+\treturn OS_Time instead of time_t to match what is imported by Ada.\n+\tNow return -1 if the file doesn't exist, instead of a random value\n+\n+2004-05-05  Robert Dewar  <dewar@gnat.com>\n+\n+\t* usage.adb: Add line for -gnatR?s switch\n+\n+\t* sem_ch13.adb, exp_ch2.adb: Minor reformatting\n+\n+\t* g-regpat.ads, g-regpat.adb: Add documentation on handling of Size\n+\tand for Match (Data_First, Data_last)\n+\n+\t* lib-writ.adb (Write_With_Lines): Ensure that correct index number is\n+\twritten when we are dealing with multi-unit files.\n+\n+2004-05-05  Jerome Guitton  <guitton@act-europe.fr>\n+\n+\t* Makefile.in: Remove unused targets and variables.\n+\n+2004-05-05  Vincent Celier  <celier@gnat.com>\n+\n+\t* switch-m.adb: New gnatmake switch -eI\n+\n+\t* vms_data.ads: Add VMS equivalents of new gnatclean swith -innn and\n+\tof new gnatmake switch -eInnn.\n+\n+\t* makegpr.adb: Take into account new parameters Index and Src_Index in\n+\tPrj.Util.\n+\n+\t* clean.adb: Implement support for multi-unit sources, including new\n+\tswitch -i.\n+\n+\t* gnatcmd.adb (GNATCmd): Call Prj.Util.Value_Of with new parameter\n+\tSrc_Index.\n+\n+\t* make.ads, make.adb (Insert_Q): New parameter Index, defaulted to 0\n+\t(Extract_From_Q): New out parameter Index\n+\t(Mark, Is_Marked): Subprograms moved to Makeutl\n+\t(Switches_Of): New parameter Source_Index\n+\t(Add_Switch): New parameter Index\n+\t(Check): New parameter Source_Index\n+\t(Collect_Arguments): New parameter Source_Index\n+\t(Collect_Arguments_And_Compile): New parameter Source_Index\n+\t(Compile): New parameter Source_Index\n+\tPut subprograms in alphabetical order\n+\tAdd support for multi-source sources, including in project files.\n+\n+\t* makeutl.ads, makeutl.adb (Unit_Index_Of): New function\n+\t(Mark, Is_Marked, Delete_All_Marks): New subprograms, moved from\n+\tMake.\n+\n+\t* makeusg.adb: New gnatmake switch -eInnn\n+\n+\t* mlib-prj.adb (Build_Library): Add new parameter Src_Index to call to\n+\tPrj.Util.Value_Of.\n+\n+\t* opt.ads (Main_Index): New variable, defaulted to 0.\n+\n+\t* osint.ads, osinte.adb (Add_File): New parameter Index\n+\t(Current_Source_Index): New function\n+\n+\t* prj.adb: Take into account new components Index and Src_Index\n+\n+\t* prj.ads (String_Element): New component Index\n+\t(Variable_Value): New component Index\n+\t(Array_Element): New component Src_Index\n+\n+\t* prj-attr.adb: Indicate that optional index may be specified for\n+\tattributes Main, Executable, Spec, Body and some of Switches.\n+\n+\t* prj-attr.ads (Attribute_Kind): New values for optional indexes\n+\t(Attribute_Record): New component Optional_Index\n+\n+\t* prj-com.ads (File_Name_Data): New component Index\n+\n+\t* prj-dect.adb (Parse_Attribute_Declaration): Process optional index\n+\n+\t* prj-env.adb (Put): Output optional index\n+\n+\t* prj-makr.adb: Put indexes for multi-unit sources in SFN pragmas and\n+\tattributes Spec and Body.\n+\n+\t* prj-nmsc.adb: Process optional indexes\n+\n+\t* prj-pp.adb: Ouput \"at\" for optional indexes\n+\n+\t* prj-proc.adb: Take into account optional indexes\n+\n+\t* prj-strt.ads, prj-strt.adb (Terms): New Boolean parameter\n+\tOptional_Index. For string literal,\n+\tprocess optional index when Optional_Index is True.\n+\t(Parse_Expresion): New Boolean parameter Optional_Index\n+\n+\t* prj-tree.ads, prj-tree.adb (Source_Index_Of): New function\n+\t(Set_Source_Index_Of): New procedure\n+\n+\t* prj-util.adb (Executable_Of, Value_Of): Take into account optional\n+\tindex.\n+\n+\t* prj-util.ads (Executable_Of): New parameter Index\n+\t(Value_Of (Name_Id, Array_Element_Id) returning Variable_Value):\n+\tNew parameter Src_Index, defaulted to 0.\n+\n+2004-05-05  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15257\n+\t* sem_ch3.adb (Access_Definition): If this is an access parameter\n+\twhose designated type is imported through a limited_with clause, do\n+\tnot add the enclosing subprogram to the list of private dependents of\n+\tthe type.\n+\n+2004-05-05  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15258\n+\t* sem_ch6.adb (Base_Types_Match): True if one type is imported through\n+\ta limited_with clause, and the other is its non-limited view.\n+\n+2004-05-05  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* cstand.adb (Create_Standard): Initialize Stand.Boolean_Literals.\n+\n+\t* exp_attr.adb, exp_ch5.adb, exp_ch9.adb, exp_disp.adb, \n+\texp_fixd.adb, sem_attr.adb, sem_dist.adb, sem_util.adb: Use\n+\tStand.Boolean_Literals to produce references to entities\n+\tStandard_False and Standard_True from compile-time computed boolean\n+\tvalues.\n+\n+\t* stand.ads (Boolean_Literals): New variable, provides the entity\n+\tvalues for False and True, for use by the expander.\n+\n+2004-05-05  Doug Rupp  <rupp@gnat.com>\n+\n+\t* 5vinmaop.adb, 5[vx]system.ads: Add Short_Address subtype\n+\t5vinmaop.adb: Unchecked convert Short_Address vice Address\n+\n+\t* adaint.c, raise.c: Caste CRTL function return value\n+\tto avoid gcc error on 32/64 bit IVMS.\n+\n+\t* Makefile.in [VMS]: Use iar archiver if host = Alpha/VMS and\n+\ttarget = IA64/VMS.\n+\n+\t* init.c[VMS]: Only call Alpha specific __gnat_error_prehandler IN_RTS.\n+\n+\t* 5qsystem.ads (Address): Declare as Long_Integer\n+\t(Short_Address): Declare as 32 bit subtype of Address\n+\tDeclare  abstract address operations to avoid gratuitous ambiguities.\n+\n+2004-05-05  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* gnat_rm.texi: Use the new restriction Simple_Barriers (AI-249)\n+\tinstead of the old Boolean_Entry_Barriers.\n+\tDitto for No_Task_Attributes_Package instead of No_Task_Attributes.\n+\n+2004-05-05  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n 2004-05-03  Arnaud Charlet  <charlet@act-europe.fr>\n \n \t* 50system.ads, 59system.ads, s-thread.ads: Removed, no longer used."}, {"sha": "5cf5d62d425ba30b212071f6502cf9107cc77ae8", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -2953,10 +2953,10 @@ ada/sem_ch13.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/s-imgenu.ads ada/s-memory.ads ada/s-rident.ads ada/s-secsta.ads \\\n    ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n    ada/s-stoele.adb ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/urealp.adb \n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \n \n ada/sem_ch2.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/atree.adb ada/casing.ads ada/debug.ads ada/einfo.ads ada/elists.ads \\\n@@ -3457,14 +3457,15 @@ ada/sem_util.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/csets.ads ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n    ada/elists.adb ada/err_vars.ads ada/errout.ads ada/erroutc.ads \\\n    ada/eval_fat.ads ada/exp_tss.ads ada/exp_util.ads ada/fname.ads \\\n-   ada/freeze.ads ada/get_targ.ads ada/gnat.ads ada/g-hesora.ads \\\n-   ada/g-htable.ads ada/g-os_lib.ads ada/g-string.ads ada/gnatvsn.ads \\\n-   ada/hostparm.ads ada/interfac.ads ada/lib.ads ada/lib.adb \\\n-   ada/lib-list.adb ada/lib-sort.adb ada/lib-xref.ads ada/namet.ads \\\n-   ada/namet.adb ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n-   ada/opt.ads ada/output.ads ada/restrict.ads ada/rident.ads \\\n-   ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_cat.ads ada/sem_ch8.ads ada/sem_eval.ads \\\n+   ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads ada/gnat.ads \\\n+   ada/g-hesora.ads ada/g-htable.ads ada/g-os_lib.ads ada/g-string.ads \\\n+   ada/gnatvsn.ads ada/hostparm.ads ada/interfac.ads ada/lib.ads \\\n+   ada/lib.adb ada/lib-list.adb ada/lib-load.ads ada/lib-sort.adb \\\n+   ada/lib-xref.ads ada/namet.ads ada/namet.adb ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb \\\n+   ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads \\\n+   ada/sem_cat.ads ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_eval.ads \\\n    ada/sem_eval.adb ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads \\\n    ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n    ada/sinput.ads ada/sinput.adb ada/snames.ads ada/stand.ads \\"}, {"sha": "f35622436fe002b2f40367958685920bafba9934", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 4, "deletions": 257, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -549,40 +549,6 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<5zml-tgt.adb\n \n-  EXTRA_HIE_NONE_TARGET_PAIRS= \\\n-  system.ads<50system.ads\n-\n-  EXTRA_RAVEN_SOURCES=i-vxwork.ads s-vxwork.ads\n-  EXTRA_RAVEN_OBJS=i-vxwork.o s-vxwork.o\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-  HIE_RAVEN_TARGET_PAIRS=\\\n-  $(HIE_NONE_TARGET_PAIRS) \\\n-  a-reatim.ads<1areatim.ads \\\n-  a-reatim.adb<1areatim.adb \\\n-  a-retide.adb<1aretide.adb \\\n-  a-interr.adb<1ainterr.adb \\\n-  s-interr.ads<1sinterr.ads \\\n-  s-interr.adb<1sinterr.adb \\\n-  s-taskin.ads<1staskin.ads \\\n-  s-taskin.adb<1staskin.adb \\\n-  s-taspri.ads<1staspri.ads \\\n-  s-tarest.adb<1starest.adb \\\n-  s-tposen.ads<1stposen.ads \\\n-  s-tposen.adb<1stposen.adb \\\n-  s-osinte.adb<1sosinte.adb \\\n-  s-taprop.ads<1staprop.ads \\\n-  s-taprop.adb<1staprop.adb \\\n-  s-taprob.ads<1staprob.ads \\\n-  s-taprob.adb<1staprob.adb \\\n-  a-sytaco.ads<1asytaco.ads \\\n-  a-sytaco.adb<1asytaco.adb \\\n-  a-intnam.ads<4zintnam.ads \\\n-  s-osinte.ads<5zosinte.ads \\\n-  s-parame.ads<5zparame.ads \\\n-  s-vxwork.ads<5pvxwork.ads \\\n-  a-taside.adb<1ataside.adb \\\n-\n   ifeq ($(strip $(filter-out yes,$(TRACE))),)\n     LIBGNAT_TARGET_PAIRS += \\\n     s-traces.adb<7straces.adb \\\n@@ -593,22 +559,6 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   endif\n endif\n \n-ifeq ($(strip $(filter-out powerpc% unknown elf,$(targ))),)\n-  EXTRA_HIE_NONE_TARGET_PAIRS= \\\n-  system.ads<59system.ads\n-\n-  LIBGNAT_TARGET_PAIRS = \\\n-  $(HIE_NONE_TARGET_PAIRS)\n-endif\n-\n-ifeq ($(strip $(filter-out sparc% unknown elf,$(targ))),)\n-  EXTRA_HIE_NONE_TARGET_PAIRS= \\\n-  system.ads<5rsystem.ads\n-\n-  LIBGNAT_TARGET_PAIRS = \\\n-  $(HIE_NONE_TARGET_PAIRS)\n-endif\n-\n ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-sytaco.ads<4zsytaco.ads \\\n@@ -1182,6 +1132,10 @@ ifeq ($(strip $(filter-out alpha% ia64 dec hp vms% openvms% alphavms%,$(host))),\n soext  = .exe\n hyphen = _\n \n+ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n+AR = iar\n+endif\n+\n .SUFFIXES: .sym\n \n .o.sym: \n@@ -1394,131 +1348,6 @@ include $(fsrcdir)/Makefile.rtl\n GNATRTL_OBJS = $(GNATRTL_NONTASKING_OBJS) $(GNATRTL_TASKING_OBJS) \\\n   g-trasym.o memtrack.o\n \n-# Files which are suitable in no run time/hi integrity mode\n-\n-COMPILABLE_HIE_SOURCES= \\\n- system.ads   \\\n- ada.ads      \\\n- gnat.ads     \\\n- g-souinf.ads \\\n- interfac.ads \\\n- i-c.ads      \\\n- s-stoele.ads \\\n- s-stoele.adb \\\n- s-maccod.ads \\\n- s-unstyp.ads \\\n- s-fatflt.ads \\\n- s-fatlfl.ads \\\n- s-fatllf.ads \\\n- s-fatsfl.ads \\\n- s-secsta.ads \\\n- s-secsta.adb \\\n- a-tags.ads   \\\n- a-tags.adb  \\\n- a-except.ads \\\n- a-except.adb $(EXTRA_HIE_SOURCES)\n-\n-NON_COMPILABLE_HIE_SOURCES= \\\n- a-unccon.ads \\\n- a-uncdea.ads \\\n- s-fatgen.adb \\\n- s-fatgen.ads \\\n- unchconv.ads \\\n- s-atacco.ads \\\n- s-atacco.adb \\\n- unchdeal.ads\n-\n-\n-HIE_SOURCES = $(NON_COMPILABLE_HIE_SOURCES) $(COMPILABLE_HIE_SOURCES)\n-\n-# Object to generate for the HI run time\n-\n-HIE_OBJS =  \\\n- system.o   \\\n- ada.o      \\\n- a-except.o \\\n- gnat.o     \\\n- g-souinf.o \\\n- interfac.o \\\n- i-c.o      \\\n- s-stoele.o \\\n- s-maccod.o \\\n- s-unstyp.o \\\n- s-fatflt.o \\\n- s-fatlfl.o \\\n- s-fatllf.o \\\n- s-fatsfl.o \\\n- s-secsta.o \\\n- a-tags.o $(EXTRA_HIE_OBJS)\n-\n-# Files which are needed in ravenscar mode\n-\n-COMPILABLE_RAVEN_SOURCES = \\\n-$(COMPILABLE_HIE_SOURCES) \\\n- s-parame.ads \\\n- s-parame.adb \\\n- s-purexc.ads \\\n- s-osinte.ads \\\n- s-osinte.adb \\\n- s-tasinf.ads \\\n- s-tasinf.adb \\\n- s-taspri.ads \\\n- s-taprop.ads \\\n- s-taprop.adb \\\n- s-taskin.ads \\\n- s-taskin.adb \\\n- s-interr.ads \\\n- s-interr.adb \\\n- a-interr.ads \\\n- a-interr.adb \\\n- a-intnam.ads \\\n- a-reatim.ads \\\n- a-reatim.adb \\\n- a-retide.ads \\\n- a-retide.adb \\\n- s-taprob.ads \\\n- s-taprob.adb \\\n- s-tposen.ads \\\n- s-tposen.adb \\\n- s-tasres.ads \\\n- s-tarest.ads \\\n- s-tarest.adb \\\n- a-sytaco.ads \\\n- a-sytaco.adb \\\n- a-taside.ads \\\n- a-taside.adb $(EXTRA_RAVEN_SOURCES)\n-\n-NON_COMPILABLE_RAVEN_SOURCES= $(NON_COMPILABLE_HIE_SOURCES)\n-\n-RAVEN_SOURCES = $(NON_COMPILABLE_RAVEN_SOURCES) $(COMPILABLE_RAVEN_SOURCES)\n-\n-# Objects to generate for the ravenscar run time\n-\n-RAVEN_LIBGNARL_OBJS = \\\n- s-parame.o  \\\n- s-purexc.o  \\\n- s-osinte.o  \\\n- s-tasinf.o  \\\n- s-taspri.o  \\\n- s-taprop.o  \\\n- s-taskin.o  \\\n- s-interr.o  \\\n- a-interr.o  \\\n- a-intnam.o  \\\n- a-reatim.o  \\\n- a-retide.o  \\\n- s-osinte.o  \\\n- s-taprob.o  \\\n- s-tposen.o  \\\n- s-tasres.o  \\\n- s-tarest.o  \\\n- a-sytaco.o \\\n- a-taside.o $(EXTRA_RAVEN_OBJS)\n-\n-RAVEN_OBJS = \\\n- $(HIE_OBJS) \\\n- $(RAVEN_LIBGNARL_OBJS)\n-\n # Default run time files\n \n ADA_INCLUDE_SRCS =\\\n@@ -1878,88 +1707,6 @@ gnatlib: ../stamp-gnatlib1 ../stamp-gnatlib2\n \t$(CHMOD) a-wx rts/*.ali\n \ttouch ../stamp-gnatlib\n \n-HIE_NONE_TARGET_PAIRS=\\\n- a-except.ads<1aexcept.ads \\\n- a-except.adb<1aexcept.adb \\\n- a-tags.ads<1atags.ads \\\n- a-tags.adb<1atags.adb \\\n- s-secsta.ads<1ssecsta.ads \\\n- s-secsta.adb<1ssecsta.adb \\\n- i-c.ads<1ic.ads $(EXTRA_HIE_NONE_TARGET_PAIRS)\n-\n-# This target needs RTS_NAME, RTS_SRCS, RTS_TARGET_PAIRS to be set properly\n-# it creates a rts with the proper structure and the right target \n-# dependant srcs\n-prepare-rts:\n-\t$(RMDIR) rts-$(RTS_NAME)\n-\t$(MKDIR) rts-$(RTS_NAME)\n-\t$(CHMOD) u+w rts-$(RTS_NAME)\n-\t$(MKDIR) rts-$(RTS_NAME)/adalib\n-\t$(MKDIR) rts-$(RTS_NAME)/adainclude\n-\t$(CHMOD) u+w rts-$(RTS_NAME)/*\n-# Generate the project file\n-\t$(ECHO) \"project $(RTS_NAME) is\" > rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"   for Source_Dirs use (\\\"adainclude\\\");\" \\\n-\t\t>> rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"   for Object_Dir use \\\"adalib\\\";\" \\\n-\t\t>> rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"   for Source_List_File use \" \\\n-\t\t>>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"      \\\"rts-$(RTS_NAME)_source_list.txt\\\";\" \\\n-\t\t>>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"   package Builder is\" >>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"     for Default_Switches (\\\"Ada\\\") use (\\\"-a\\\");\" \\\n-\t\t >>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"  end Builder;\" >>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"  package Compiler is\" >> rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"     for Default_Switches (\\\"Ada\\\") use (\\\"-nostdinc\\\");\" \\\n-\t\t >>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"  end Compiler;\" >>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\t$(ECHO) \"end $(RTS_NAME);\" >>rts-$(RTS_NAME)/$(RTS_NAME).gpr\n-\n-\t$(foreach f, $(COMPILABLE_SOURCES), \\\n-\t\t$(ECHO) $(f) >> \\\n-\t\t\trts-$(RTS_NAME)/rts-$(RTS_NAME)_source_list.txt ;) true\n-# Copy target independent sources\n-\t$(foreach f,$(RTS_SRCS), \\\n-\t  $(CP) $(fsrcpfx)$(f) rts-$(RTS_NAME)/adainclude/ ;) true\n-# Remove files to be replaced by target dependent sources\n-\t$(RM) $(foreach PAIR,$(RTS_TARGET_PAIRS), \\\n-\t         rts-$(RTS_NAME)/adainclude/$(word 1,$(subst <, ,$(PAIR))))\n-# Copy new target dependent sources\n-\t$(foreach PAIR,$(RTS_TARGET_PAIRS), \\\n-\t    $(CP) $(fsrcpfx)$(word 2,$(subst <, ,$(PAIR))) \\\n-\t            rts-$(RTS_NAME)/adainclude/$(word 1,$(subst <, ,$(PAIR)));)\n-\n-install-rts: force\n-\t$(CP) -r rts-$(RTS_NAME) $(DESTDIR)$(libsubdir)/\n-\n-rts-zfp: force\n-\t$(MAKE) $(FLAGS_TO_PASS) prepare-rts \\\n-\t   RTS_NAME=zfp RTS_SRCS=\"$(HIE_SOURCES)\" \\\n-\t   RTS_TARGET_PAIRS=\"$(HIE_NONE_TARGET_PAIRS)\" \\\n-\t   COMPILABLE_SOURCES=\"$(COMPILABLE_HIE_SOURCES)\" \n-\t$(GNATMAKE) -Prts-zfp/zfp.gpr --GCC=\"../../../xgcc -B../../../\"\n-\tcd rts-zfp/adalib/ ; $(AR) r libgnat.a *.o\n-\t$(RM) rts-zfp/adalib/*.o\n-\t$(CHMOD) a-wx rts-zfp/adalib/*.ali\n-\t$(CHMOD) a-wx rts-zfp/adalib/libgnat.a\n-\n-rts-ravenscar: force\n-\t$(MAKE)  $(FLAGS_TO_PASS) prepare-rts \\\n-\t   RTS_NAME=ravenscar RTS_SRCS=\"$(RAVEN_SOURCES)\" \\\n-\t   RTS_TARGET_PAIRS=\"$(HIE_RAVEN_TARGET_PAIRS)\" \\\n-\t   COMPILABLE_SOURCES=\"$(COMPILABLE_RAVEN_SOURCES)\" \n-\t$(GNATMAKE) -Prts-ravenscar/ravenscar.gpr \\\n-\t   --GCC=\"../../../xgcc -B../../../\"\n-\tcd rts-ravenscar/adalib ; \\\n-\t$(foreach FILE,$(RAVEN_LIBGNARL_OBJS), $(AR) r libgnarl.a $(FILE);) \\\n-\t$(foreach FILE,$(HIE_OBJS), $(AR) r libgnat.a $(FILE);)\n-\t$(RM) rts-ravenscar/adalib/*.o\n-\t$(CHMOD) a-wx rts-ravenscar/adalib/*.ali\n-\t$(CHMOD) a-wx rts-ravenscar/adalib/libgnat.a\n-\t$(CHMOD) a-wx rts-ravenscar/adalib/libgnarl.a\n-\n # Warning: this target assumes that LIBRARY_VERSION has been set correctly.\n gnatlib-shared-default:\n \t$(MAKE) $(FLAGS_TO_PASS) \\"}, {"sha": "7b8813ab6ee19d8c06088dc4a46405173cfa72c5", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -862,15 +862,15 @@ win32_filetime (HANDLE h)\n \n /* Return a GNAT time stamp given a file name.  */\n \n-time_t\n+OS_Time\n __gnat_file_time_name (char *name)\n {\n \n #if defined (__EMX__) || defined (MSDOS)\n   int fd = open (name, O_RDONLY | O_BINARY);\n   time_t ret = __gnat_file_time_fd (fd);\n   close (fd);\n-  return ret;\n+  return (OS_Time)ret;\n \n #elif defined (_WIN32)\n   time_t ret = 0;\n@@ -882,22 +882,25 @@ __gnat_file_time_name (char *name)\n       ret = win32_filetime (h);\n       CloseHandle (h);\n     }\n-  return ret;\n+  return (OS_Time) ret;\n #else\n   struct stat statbuf;\n-  (void) __gnat_stat (name, &statbuf);\n+  if (__gnat_stat (name, &statbuf) != 0) {\n+     return (OS_Time)-1;\n+  } else {\n #ifdef VMS\n-  /* VMS has file versioning.  */\n-  return statbuf.st_ctime;\n+     /* VMS has file versioning.  */\n+     return (OS_Time)statbuf.st_ctime;\n #else\n-  return statbuf.st_mtime;\n+     return (OS_Time)statbuf.st_mtime;\n #endif\n+  }\n #endif\n }\n \n /* Return a GNAT time stamp given a file descriptor.  */\n \n-time_t\n+OS_Time\n __gnat_file_time_fd (int fd)\n {\n   /* The following workaround code is due to the fact that under EMX and\n@@ -965,24 +968,26 @@ __gnat_file_time_fd (int fd)\n   tot_secs += file_hour * 3600;\n   tot_secs += file_min * 60;\n   tot_secs += file_tsec * 2;\n-  return tot_secs;\n+  return (OS_Time) tot_secs;\n \n #elif defined (_WIN32)\n   HANDLE h = (HANDLE) _get_osfhandle (fd);\n   time_t ret = win32_filetime (h);\n-  return ret;\n+  return (OS_Time) ret;\n \n #else\n   struct stat statbuf;\n \n-  (void) fstat (fd, &statbuf);\n-\n+  if (fstat (fd, &statbuf) != 0) {\n+     return (OS_Time) -1;\n+  } else {\n #ifdef VMS\n-  /* VMS has file versioning.  */\n-  return statbuf.st_ctime;\n+     /* VMS has file versioning.  */\n+     return (OS_Time) statbuf.st_ctime;\n #else\n-  return statbuf.st_mtime;\n+     return (OS_Time) statbuf.st_mtime;\n #endif\n+  }\n #endif\n }\n "}, {"sha": "c45a5332309bf66434bfac35f59f2f14b8102692", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -70,8 +70,11 @@ extern long   __gnat_named_file_length             (char *);\n extern void   __gnat_tmp_name\t\t\t   (char *);\n extern char  *__gnat_readdir                       (DIR *, char *);\n extern int    __gnat_readdir_is_thread_safe        (void);\n-extern time_t __gnat_file_time_name                (char *);\n-extern time_t __gnat_file_time_fd                  (int);\n+\n+extern OS_Time __gnat_file_time_name                (char *);\n+extern OS_Time __gnat_file_time_fd                  (int);\n+/* return -1 in case of error */\n+\n extern void   __gnat_set_file_time_name\t\t   (char *, time_t);\n extern void   __gnat_get_env_value_ptr             (char *, int *,\n \t\t\t\t\t\t    char **);"}, {"sha": "53f82d0d4166565e518e8e2bff855878e485f5bc", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 242, "deletions": 157, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -24,10 +24,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Command_Line; use Ada.Command_Line;\n+\n with ALI;      use ALI;\n with Csets;\n with Gnatvsn;\n with Hostparm;\n+with Makeutl;  use Makeutl;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -43,12 +46,10 @@ with System;\n with Table;\n with Types;    use Types;\n \n-with GNAT.Command_Line;         use GNAT.Command_Line;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.IO;                   use GNAT.IO;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n-\n package body Clean is\n \n    Initialized : Boolean := False;\n@@ -136,15 +137,13 @@ package body Clean is\n    procedure Init_Q;\n    --  Must be called to initialize the Q\n \n-   procedure Insert_Q\n-     (Source_File : File_Name_Type);\n-   --  If Source_File is not marked, inserts it at the end of Q and mark it\n+   procedure Insert_Q (Lib_File  : File_Name_Type);\n+   --  If Lib_File is not marked, inserts it at the end of Q and mark it\n \n    function Empty_Q return Boolean;\n    --  Returns True if Q is empty.\n \n-   procedure Extract_From_Q\n-     (Source_File : out File_Name_Type);\n+   procedure Extract_From_Q (Lib_File : out File_Name_Type);\n    --  Extracts the first element from the Q.\n \n    Q_Front : Natural;\n@@ -367,14 +366,14 @@ package body Clean is\n       Main_Source_File : File_Name_Type;\n       --  Current main source\n \n-      Source_File : File_Name_Type;\n-      --  Current source file\n+      Main_Lib_File : File_Name_Type;\n+      --  ALI file of the current main\n \n       Lib_File : File_Name_Type;\n-      --  Current library file\n+      --  Current ALI file\n \n       Full_Lib_File : File_Name_Type;\n-      --  Full name of the current library file\n+      --  Full name of the current ALI file\n \n       Text : Text_Buffer_Ptr;\n       The_ALI : ALI_Id;\n@@ -393,12 +392,13 @@ package body Clean is\n \n       for N_File in 1 .. Osint.Number_Of_Files loop\n          Main_Source_File := Next_Main_Source;\n-         Insert_Q (Main_Source_File);\n+         Main_Lib_File := Osint.Lib_File_Name\n+                             (Main_Source_File, Current_File_Index);\n+         Insert_Q (Main_Lib_File);\n \n          while not Empty_Q loop\n             Sources.Set_Last (0);\n-            Extract_From_Q (Source_File);\n-            Lib_File      := Osint.Lib_File_Name (Source_File);\n+            Extract_From_Q (Lib_File);\n             Full_Lib_File := Osint.Full_Lib_File_Name (Lib_File);\n \n             --  If we have an existing ALI file that is not read-only,\n@@ -428,7 +428,7 @@ package body Clean is\n                         for K in ALI.Units.Table (J).First_With ..\n                           ALI.Units.Table (J).Last_With\n                         loop\n-                           Insert_Q (Withs.Table (K).Sfile);\n+                           Insert_Q (Withs.Table (K).Afile);\n                         end loop;\n                      end loop;\n \n@@ -499,7 +499,7 @@ package body Clean is\n \n          if not Compile_Only then\n             declare\n-               Source : constant Name_Id := Strip_Suffix (Main_Source_File);\n+               Source : constant Name_Id := Strip_Suffix (Main_Lib_File);\n                Executable : constant String := Get_Name_String\n                                               (Executable_Name (Source));\n             begin\n@@ -529,7 +529,10 @@ package body Clean is\n       Data        : constant Project_Data := Projects.Table (Project);\n       U_Data      : Prj.Com.Unit_Data;\n       File_Name1  : Name_Id;\n+      Index1      : Int;\n       File_Name2  : Name_Id;\n+      Index2      : Int;\n+      Lib_File    : File_Name_Type;\n \n       use Prj.Com;\n \n@@ -583,26 +586,32 @@ package body Clean is\n                      (U_Data.File_Names (Specification).Project, Project)\n                then\n                   File_Name1 := U_Data.File_Names (Body_Part).Name;\n+                  Index1     := U_Data.File_Names (Body_Part).Index;\n                   File_Name2 := U_Data.File_Names (Specification).Name;\n+                  Index2     := U_Data.File_Names (Specification).Index;\n \n                   --  If there is no body file name, then there may be only a\n                   --  spec.\n \n                   if File_Name1 = No_Name then\n                      File_Name1 := File_Name2;\n+                     Index1     := Index2;\n                      File_Name2 := No_Name;\n+                     Index2     := 0;\n                   end if;\n                end if;\n \n                --  If there is either a spec or a body, look for files in the\n                --  object directory.\n \n                if File_Name1 /= No_Name then\n+                  Lib_File := Osint.Lib_File_Name (File_Name1, Index1);\n+\n                   declare\n-                     Asm : constant String := Assembly_File_Name (File_Name1);\n-                     ALI : constant String := ALI_File_Name      (File_Name1);\n-                     Obj : constant String := Object_File_Name   (File_Name1);\n-                     Adt : constant String := Tree_File_Name     (File_Name1);\n+                     Asm : constant String := Assembly_File_Name (Lib_File);\n+                     ALI : constant String := ALI_File_Name      (Lib_File);\n+                     Obj : constant String := Object_File_Name   (Lib_File);\n+                     Adt : constant String := Tree_File_Name     (Lib_File);\n                      Deb : constant String := Debug_File_Name    (File_Name1);\n                      Rep : constant String := Repinfo_File_Name  (File_Name1);\n                      Del : Boolean := True;\n@@ -776,7 +785,11 @@ package body Clean is\n                Main_Source_File := Next_Main_Source;\n \n                if not Compile_Only then\n-                  Executable := Executable_Of (Main_Project, Main_Source_File);\n+                  Executable :=\n+                    Executable_Of\n+                      (Main_Project,\n+                       Main_Source_File,\n+                       Current_File_Index);\n \n                   if Is_Regular_File (Get_Name_String (Executable)) then\n                      Delete (Exec_Dir, Get_Name_String (Executable));\n@@ -938,12 +951,12 @@ package body Clean is\n    -- Extract_From_Q --\n    --------------------\n \n-   procedure Extract_From_Q (Source_File : out File_Name_Type) is\n-      File : constant File_Name_Type := Q.Table (Q_Front);\n+   procedure Extract_From_Q (Lib_File : out File_Name_Type) is\n+      Lib : constant File_Name_Type := Q.Table (Q_Front);\n \n    begin\n-      Q_Front := Q_Front + 1;\n-      Source_File := File;\n+      Q_Front  := Q_Front + 1;\n+      Lib_File := Lib;\n    end Extract_From_Q;\n \n    ---------------\n@@ -1019,12 +1032,14 @@ package body Clean is\n       if Main_Project /= No_Project and then Osint.Number_Of_Files = 0 then\n          declare\n             Value : String_List_Id := Projects.Table (Main_Project).Mains;\n-\n+            Main  : String_Element;\n          begin\n             while Value /= Prj.Nil_String loop\n-               Get_Name_String (String_Elements.Table (Value).Value);\n-               Osint.Add_File (Name_Buffer (1 .. Name_Len));\n-               Value := String_Elements.Table (Value).Next;\n+               Main := String_Elements.Table (Value);\n+               Osint.Add_File\n+                 (File_Name => Get_Name_String (Main.Value),\n+                  Index     => Main.Index);\n+               Value := Main.Next;\n             end loop;\n          end;\n       end if;\n@@ -1152,19 +1167,17 @@ package body Clean is\n    -- Insert_Q --\n    --------------\n \n-   procedure Insert_Q (Source_File : File_Name_Type) is\n+   procedure Insert_Q (Lib_File : File_Name_Type) is\n    begin\n       --  Do not insert an empty name or an already marked source\n \n-      if Source_File /= No_Name\n-        and then Get_Name_Table_Byte (Source_File) = 0\n-      then\n-         Q.Table (Q.Last) := Source_File;\n+      if Lib_File /= No_Name and then not Is_Marked (Lib_File) then\n+         Q.Table (Q.Last) := Lib_File;\n          Q.Increment_Last;\n \n          --  Mark the source that has been just added to the Q\n \n-         Set_Name_Table_Byte (Source_File, 1);\n+         Mark (Lib_File);\n       end if;\n    end Insert_Q;\n \n@@ -1196,165 +1209,236 @@ package body Clean is\n    --------------------\n \n    procedure Parse_Cmd_Line is\n+      Source_Index : Int := 0;\n+      Index : Positive := 1;\n+      Last  : constant Natural := Argument_Count;\n    begin\n-      loop\n-         case\n-           GNAT.Command_Line.Getopt\n-             (\"aO: c D: F h I: I- n P: q r v vP0 vP1 vP2 X:\")\n-         is\n-            when ASCII.NUL =>\n-               exit;\n+      while Index <= Last loop\n+         declare\n+            Arg : constant String := Argument (Index);\n \n-            when 'a' =>\n-               Add_Lib_Search_Dir (GNAT.Command_Line.Parameter);\n+            procedure Bad_Argument;\n+            --  Signal bad argument\n \n-            when 'c'    =>\n-               Compile_Only := True;\n+            ------------------\n+            -- Bad_Argument --\n+            ------------------\n \n-            when 'D'    =>\n-               declare\n-                  Dir : constant String := GNAT.Command_Line.Parameter;\n+            procedure Bad_Argument is\n+            begin\n+               Fail (\"invalid argument \"\"\", Arg, \"\"\"\");\n+            end Bad_Argument;\n \n-               begin\n-                  if Object_Directory_Path /= null then\n-                     Fail (\"duplicate -D switch\");\n+         begin\n+            if Arg'Length /= 0 then\n+               if Arg (1) = '-' then\n+                  if Arg'Length = 1 then\n+                     Bad_Argument;\n+                  end if;\n \n-                  elsif Project_File_Name /= null then\n-                     Fail (\"-P and -D cannot be used simultaneously\");\n+                  case Arg (2) is\n+                     when 'a' =>\n+                        if Arg'Length < 4 or else Arg (3) /= 'O' then\n+                           Bad_Argument;\n+                        end if;\n \n-                  elsif not Is_Directory (Dir) then\n-                     Fail (Dir, \" is not a directory\");\n+                        Add_Lib_Search_Dir (Arg (3 .. Arg'Last));\n \n-                  else\n-                     Add_Lib_Search_Dir (Dir);\n-                  end if;\n-               end;\n+                     when 'c'    =>\n+                        Compile_Only := True;\n \n-            when 'F' =>\n-               Full_Path_Name_For_Brief_Errors := True;\n+                     when 'D'    =>\n+                        if Object_Directory_Path /= null then\n+                           Fail (\"duplicate -D switch\");\n \n-            when 'h' =>\n-               Usage;\n+                        elsif Project_File_Name /= null then\n+                           Fail (\"-P and -D cannot be used simultaneously\");\n+                        end if;\n \n-            when 'I' =>\n-               if Full_Switch = \"I-\" then\n-                  Opt.Look_In_Primary_Dir := False;\n+                        if Arg'Length > 2 then\n+                           declare\n+                              Dir : constant String := Arg (3 .. Arg'Last);\n+                           begin\n+                              if not Is_Directory (Dir) then\n+                                 Fail (Dir, \" is not a directory\");\n+                              else\n+                                 Add_Lib_Search_Dir (Dir);\n+                              end if;\n+                           end;\n \n-               else\n-                  Add_Lib_Search_Dir (GNAT.Command_Line.Parameter);\n-               end if;\n+                        else\n+                           if Index = Last then\n+                              Fail (\"no directory specified after -D\");\n+                           end if;\n \n-            when 'n' =>\n-               Do_Nothing := True;\n+                           Index := Index + 1;\n \n-            when 'P' =>\n-               if Project_File_Name /= null then\n-                  Fail (\"multiple -P switches\");\n+                           declare\n+                              Dir : constant String := Argument (Index);\n+                           begin\n+                              if not Is_Directory (Dir) then\n+                                 Fail (Dir, \" is not a directory\");\n+                              else\n+                                 Add_Lib_Search_Dir (Dir);\n+                              end if;\n+                           end;\n+                        end if;\n \n-               elsif Object_Directory_Path /= null then\n-                  Fail (\"-D and -P cannot be used simultaneously\");\n+                     when 'F' =>\n+                        Full_Path_Name_For_Brief_Errors := True;\n \n-               else\n-                  declare\n-                     Prj : constant String := GNAT.Command_Line.Parameter;\n-                  begin\n-                     if Prj'Length > 1 and then Prj (Prj'First) = '=' then\n-                        Project_File_Name :=\n-                          new String'(Prj (Prj'First + 1 ..  Prj'Last));\n+                     when 'h' =>\n+                        Usage;\n \n-                     else\n-                        Project_File_Name := new String'(Prj);\n-                     end if;\n-                  end;\n-               end if;\n+                     when 'i' =>\n+                        if Arg'Length = 2 then\n+                           Bad_Argument;\n+                        end if;\n \n-            when 'q' =>\n-               Quiet_Output := True;\n+                        Source_Index := 0;\n \n-            when 'r' =>\n-               All_Projects := True;\n+                        for J in 3 .. Arg'Last loop\n+                           if Arg (J) not in '0' .. '9' then\n+                              Bad_Argument;\n+                           end if;\n \n-            when 'v' =>\n-               if Full_Switch = \"v\" then\n-                  Verbose_Mode := True;\n+                           Source_Index :=\n+                             (20 * Source_Index) +\n+                             (Character'Pos (Arg (J)) - Character'Pos ('0'));\n+                        end loop;\n \n-               elsif Full_Switch = \"vP0\" then\n-                  Prj.Com.Current_Verbosity := Prj.Default;\n+                     when 'I' =>\n+                        if Arg = \"-I-\" then\n+                           Opt.Look_In_Primary_Dir := False;\n \n-               elsif Full_Switch = \"vP1\" then\n-                  Prj.Com.Current_Verbosity := Prj.Medium;\n+                        else\n+                           if Arg'Length = 2 then\n+                              Bad_Argument;\n+                           end if;\n \n-               else\n-                  Prj.Com.Current_Verbosity := Prj.High;\n-               end if;\n+                           Add_Lib_Search_Dir (Arg (3 .. Arg'Last));\n+                        end if;\n \n-            when 'X' =>\n-               declare\n-                  Ext_Asgn  : constant String := GNAT.Command_Line.Parameter;\n-                  Start     : Positive := Ext_Asgn'First;\n-                  Stop      : Natural  := Ext_Asgn'Last;\n-                  Equal_Pos : Natural;\n-                  OK        : Boolean  := True;\n+                     when 'n' =>\n+                        Do_Nothing := True;\n \n-               begin\n-                  if Ext_Asgn (Start) = '\"' then\n-                     if Ext_Asgn (Stop) = '\"' then\n-                        Start := Start + 1;\n-                        Stop  := Stop - 1;\n+                     when 'P' =>\n+                        if Project_File_Name /= null then\n+                           Fail (\"multiple -P switches\");\n \n-                     else\n-                        OK := False;\n-                     end if;\n-                  end if;\n+                        elsif Object_Directory_Path /= null then\n+                           Fail (\"-D and -P cannot be used simultaneously\");\n \n-                  Equal_Pos := Start;\n+                        end if;\n \n-                  while Equal_Pos <= Stop and then\n-                        Ext_Asgn (Equal_Pos) /= '='\n-                  loop\n-                     Equal_Pos := Equal_Pos + 1;\n-                  end loop;\n+                        if Arg'Length > 2 then\n+                           declare\n+                              Prj : constant String := Arg (3 .. Arg'Last);\n+                           begin\n+                              if Prj'Length > 1 and then\n+                                Prj (Prj'First) = '='\n+                              then\n+                                 Project_File_Name :=\n+                                   new String'\n+                                     (Prj (Prj'First + 1 ..  Prj'Last));\n+                              else\n+                                 Project_File_Name := new String'(Prj);\n+                              end if;\n+                           end;\n \n-                  if Equal_Pos = Start or else Equal_Pos > Stop then\n-                     OK := False;\n-                  end if;\n+                        else\n+                           if Index = Last then\n+                              Fail (\"no project specified after -P\");\n+                           end if;\n \n-                  if OK then\n-                     Prj.Ext.Add\n-                       (External_Name => Ext_Asgn (Start .. Equal_Pos - 1),\n-                        Value         => Ext_Asgn (Equal_Pos + 1 .. Stop));\n+                           Index := Index + 1;\n+                           Project_File_Name := new String'(Argument (Index));\n+                        end if;\n \n-                  else\n-                     Fail (\"illegal external assignment '\", Ext_Asgn, \"'\");\n-                  end if;\n-               end;\n+                     when 'q' =>\n+                        Quiet_Output := True;\n \n-            when others =>\n-               Fail (\"INTERNAL ERROR, please report\");\n-         end case;\n-      end loop;\n+                     when 'r' =>\n+                        All_Projects := True;\n \n-      --  Get the file names\n+                     when 'v' =>\n+                        if Arg = \"-v\" then\n+                           Verbose_Mode := True;\n \n-      loop\n-         declare\n-            S : constant String := GNAT.Command_Line.Get_Argument;\n+                        elsif Arg = \"-vP0\" then\n+                           Prj.Com.Current_Verbosity := Prj.Default;\n \n-         begin\n-            exit when S'Length = 0;\n+                        elsif Arg = \"-vP1\" then\n+                           Prj.Com.Current_Verbosity := Prj.Medium;\n \n-            Add_File (S);\n-         end;\n-      end loop;\n+                        elsif Arg = \"-vP2\" then\n+                           Prj.Com.Current_Verbosity := Prj.High;\n \n-   exception\n-      when GNAT.Command_Line.Invalid_Switch =>\n-         Usage;\n-         Fail (\"invalid switch : \"& GNAT.Command_Line.Full_Switch);\n+                        else\n+                           Bad_Argument;\n+                        end if;\n \n-      when GNAT.Command_Line.Invalid_Parameter =>\n-         Usage;\n-         Fail (\"parameter missing for : \" & GNAT.Command_Line.Full_Switch);\n+                     when 'X' =>\n+                        if Arg'Length = 2 then\n+                           Bad_Argument;\n+                        end if;\n+\n+                        declare\n+                           Ext_Asgn  : constant String := Arg (3 .. Arg'Last);\n+                           Start     : Positive := Ext_Asgn'First;\n+                           Stop      : Natural  := Ext_Asgn'Last;\n+                           Equal_Pos : Natural;\n+                           OK        : Boolean  := True;\n+\n+                        begin\n+                           if Ext_Asgn (Start) = '\"' then\n+                              if Ext_Asgn (Stop) = '\"' then\n+                                 Start := Start + 1;\n+                                 Stop  := Stop - 1;\n+\n+                              else\n+                                 OK := False;\n+                              end if;\n+                           end if;\n+\n+                           Equal_Pos := Start;\n+\n+                           while Equal_Pos <= Stop\n+                             and then Ext_Asgn (Equal_Pos) /= '='\n+                           loop\n+                              Equal_Pos := Equal_Pos + 1;\n+                           end loop;\n+\n+                           if Equal_Pos = Start or else Equal_Pos > Stop then\n+                              OK := False;\n+                           end if;\n+\n+                           if OK then\n+                              Prj.Ext.Add\n+                                (External_Name =>\n+                                   Ext_Asgn (Start .. Equal_Pos - 1),\n+                                 Value         =>\n+                                   Ext_Asgn (Equal_Pos + 1 .. Stop));\n+\n+                           else\n+                              Fail\n+                                (\"illegal external assignment '\",\n+                                 Ext_Asgn, \"'\");\n+                           end if;\n+                        end;\n+\n+                     when others =>\n+                        Bad_Argument;\n+                  end case;\n+\n+               else\n+                  Add_File (Arg, Source_Index);\n+               end if;\n+            end if;\n+         end;\n+\n+         Index := Index + 1;\n+      end loop;\n    end Parse_Cmd_Line;\n \n    -----------------------\n@@ -1398,7 +1482,7 @@ package body Clean is\n       if not Usage_Displayed then\n          Usage_Displayed := True;\n          Display_Copyright;\n-         Put_Line (\"Usage: gnatclean [switches] names\");\n+         Put_Line (\"Usage: gnatclean [switches] {[-innn] name}\");\n          New_Line;\n \n          Put_Line (\"  names is one or more file names from which \" &\n@@ -1411,6 +1495,7 @@ package body Clean is\n          Put_Line (\"  -F       Full project path name \" &\n                    \"in brief error messages\");\n          Put_Line (\"  -h       Display this message\");\n+         Put_Line (\"  -innn    Index of unit in source for following names\");\n          Put_Line (\"  -n       Nothing to do: only list files to delete\");\n          Put_Line (\"  -Pproj   Use GNAT Project File proj\");\n          Put_Line (\"  -q       Be quiet/terse\");"}, {"sha": "b7d1c90eb5c4b45eddda26eae3d082f227ad6c26", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -402,6 +402,11 @@ package body CStand is\n       Set_Etype (R_Node, Standard_Boolean);\n       Set_Parent (R_Node, Standard_Boolean);\n \n+      --  Record entity identifiers for boolean literals in the\n+      --  Boolean_Literals array, for easy reference during expansion.\n+\n+      Boolean_Literals := (False => Standard_False, True => Standard_True);\n+\n       --  Create type definition nodes for predefined integer types\n \n       Build_Signed_Integer_Type"}, {"sha": "edf358ef1b22c955049fc787c2b7a1fe2e737b01", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -1182,30 +1182,22 @@ package body Exp_Attr is\n                   Res := Is_Constrained (Etype (Ent));\n                end if;\n \n-               if Res then\n-                  Rewrite (N,\n-                    New_Reference_To (Standard_True, Loc));\n-               else\n-                  Rewrite (N,\n-                    New_Reference_To (Standard_False, Loc));\n-               end if;\n+               Rewrite (N,\n+                 New_Reference_To (Boolean_Literals (Res), Loc));\n             end;\n \n          --  Prefix is not an entity name. These are also cases where\n          --  we can always tell at compile time by looking at the form\n          --  and type of the prefix.\n \n          else\n-            if not Is_Variable (Pref)\n-              or else Nkind (Pref) = N_Explicit_Dereference\n-              or else Is_Constrained (Etype (Pref))\n-            then\n-               Rewrite (N,\n-                 New_Reference_To (Standard_True, Loc));\n-            else\n-               Rewrite (N,\n-                 New_Reference_To (Standard_False, Loc));\n-            end if;\n+            Rewrite (N,\n+              New_Reference_To (\n+                Boolean_Literals (\n+                  not Is_Variable (Pref)\n+                    or else Nkind (Pref) = N_Explicit_Dereference\n+                    or else Is_Constrained (Etype (Pref))),\n+                Loc));\n          end if;\n \n          Analyze_And_Resolve (N, Standard_Boolean);"}, {"sha": "7192cb9a33350455c003e41a8b77a1df32c5c14c", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -218,12 +218,13 @@ package body Exp_Ch2 is\n \n          and then Nkind (Parent (N)) /= N_Pragma_Argument_Association\n \n-         --  Same for Asm_Input and Asm_Output attribute references.\n+         --  Same for Asm_Input and Asm_Output attribute references\n \n          and then not (Nkind (Parent (N)) = N_Attribute_Reference\n-           and then (Attribute_Name (Parent (N)) = Name_Asm_Input\n-             or else Attribute_Name (Parent (N)) = Name_Asm_Output))\n-\n+                         and then\n+                           (Attribute_Name (Parent (N)) = Name_Asm_Input\n+                              or else\n+                            Attribute_Name (Parent (N)) = Name_Asm_Output))\n       then\n          --  Case of Current_Value is a compile time known value\n "}, {"sha": "4a08a28477bebdcdf54d8a09e0d3bc4744854ba9", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -702,13 +702,9 @@ package body Exp_Ch5 is\n                     Duplicate_Subexpr (Right_Lo, Name_Req => True),\n                     Duplicate_Subexpr (Right_Hi, Name_Req => True));\n \n-                  if Forwards_OK (N) then\n-                     Append_To (Actuals,\n-                       New_Occurrence_Of (Standard_False, Loc));\n-                  else\n-                     Append_To (Actuals,\n-                       New_Occurrence_Of (Standard_True, Loc));\n-                  end if;\n+                  Append_To (Actuals,\n+                    New_Occurrence_Of (\n+                      Boolean_Literals (not Forwards_OK (N)), Loc));\n \n                   Rewrite (N,\n                     Make_Procedure_Call_Statement (Loc,"}, {"sha": "d8c43df42ad0744e9239a8dd8d4af182f542a712", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -5735,19 +5735,16 @@ package body Exp_Ch9 is\n       RTS_Call   : Entity_Id;\n \n    begin\n-      if Abort_Present (N) then\n-         Abortable := New_Occurrence_Of (Standard_True, Loc);\n-      else\n-         Abortable := New_Occurrence_Of (Standard_False, Loc);\n-      end if;\n+      Abortable :=\n+        New_Occurrence_Of (Boolean_Literals (Abort_Present (N)), Loc);\n \n-      --  Set up the target object.\n+      --  Set up the target object\n \n       Extract_Entry (N, Concval, Ename, Index);\n       Conctyp := Etype (Concval);\n       New_Param := Concurrent_Ref (Concval);\n \n-      --  The target entry index and abortable flag are the same for all cases.\n+      --  The target entry index and abortable flag are the same for all cases\n \n       Params := New_List (\n         Entry_Index_Expression (Loc, Entity (Ename), Index, Conctyp),\n@@ -5804,7 +5801,7 @@ package body Exp_Ch9 is\n          end if;\n       end loop;\n \n-      --  Create the GNARLI call.\n+      --  Create the GNARLI call\n \n       Rcall := Make_Procedure_Call_Statement (Loc,\n         Name =>"}, {"sha": "fb8f6be31e01a7cea1a2181a9f76b97b7c410a6a", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -876,24 +876,22 @@ package body Exp_Disp is\n                Node2 => Position)));\n       end;\n \n-      --  Generate: Set_Remotely_Callable (DT_Ptr, status);\n-      --  where status is described in E.4 (18)\n+      --  Generate: Set_Remotely_Callable (DT_Ptr, Status);\n+      --  where Status is described in E.4 (18)\n \n       declare\n          Status : Entity_Id;\n \n       begin\n-         if Is_Pure (Typ)\n-           or else Is_Shared_Passive (Typ)\n-           or else\n-             ((Is_Remote_Types (Typ) or else Is_Remote_Call_Interface (Typ))\n-                 and then Original_View_In_Visible_Part (Typ))\n-           or else not Comes_From_Source (Typ)\n-         then\n-            Status := Standard_True;\n-         else\n-            Status := Standard_False;\n-         end if;\n+         Status :=\n+           Boolean_Literals\n+             (Is_Pure (Typ)\n+                or else Is_Shared_Passive (Typ)\n+                or else\n+                  ((Is_Remote_Types (Typ)\n+                      or else Is_Remote_Call_Interface (Typ))\n+                   and then Original_View_In_Visible_Part (Typ))\n+                or else not Comes_From_Source (Typ));\n \n          Append_To (Elab_Code,\n            Make_DT_Access_Action (Typ,"}, {"sha": "75357a2f3ab96951f0ddf1c9e79fc3b283a276e6", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -561,11 +561,7 @@ package body Exp_Fixd is\n       --  call the runtime routine to compute the quotient and remainder\n \n       else\n-         if Rounded_Result_Set (N) then\n-            Rnd := Standard_True;\n-         else\n-            Rnd := Standard_False;\n-         end if;\n+         Rnd := Boolean_Literals (Rounded_Result_Set (N));\n \n          Code := New_List (\n            Make_Object_Declaration (Loc,\n@@ -947,11 +943,7 @@ package body Exp_Fixd is\n       --  call the runtime routine to compute the quotient and remainder\n \n       else\n-         if Rounded_Result_Set (N) then\n-            Rnd := Standard_True;\n-         else\n-            Rnd := Standard_False;\n-         end if;\n+         Rnd := Boolean_Literals (Rounded_Result_Set (N));\n \n          Code := New_List (\n            Make_Object_Declaration (Loc,"}, {"sha": "a8968c25c6cc2ea616eed8554a607538bba19231", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -103,6 +103,7 @@ pragma Elaborate_Body (OS_Lib);\n    --  file (of course in Unix systems, this *is* in GMT form).\n \n    type OS_Time is private;\n+   Invalid_Time : constant OS_Time;\n \n    subtype Year_Type   is Integer range 1900 .. 2099;\n    subtype Month_Type  is Integer range    1 ..   12;\n@@ -368,9 +369,11 @@ pragma Elaborate_Body (OS_Lib);\n    function File_Time_Stamp (Name : String) return OS_Time;\n    --  Given the name of a file or directory, Name, obtains and returns the\n    --  time stamp. This function can be used for an unopened file.\n+   --  Returns Invalid_Time is Name doesn't correspond to an existing file.\n \n    function File_Time_Stamp (FD : File_Descriptor) return OS_Time;\n    --  Get time stamp of file from file descriptor FD\n+   --  Returns Invalid_Time is FD doesn't correspond to an existing file.\n \n    function Normalize_Pathname\n      (Name           : String;\n@@ -542,6 +545,7 @@ pragma Elaborate_Body (OS_Lib);\n       Success      : out Boolean);\n \n    function File_Time_Stamp (Name : C_File_Name) return OS_Time;\n+   --  Returns Invalid_Time is Name doesn't correspond to an existing file.\n \n    function Is_Regular_File (Name : C_File_Name) return Boolean;\n \n@@ -735,6 +739,9 @@ private\n    --  but this was not properly supported till GNAT 3.15a, so that would\n    --  cause bootstrap path problems. To be changed later ???\n \n+   Invalid_Time : constant OS_Time := -1;\n+   --  This value should match the return valud by __gnat_file_time_*\n+\n    pragma Inline (\"<\");\n    pragma Inline (\">\");\n    pragma Inline (\"<=\");"}, {"sha": "76fd6abd46d597d9052010b4a030f1e5da995924", "filename": "gcc/ada/g-regpat.adb", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fg-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fg-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --               Copyright (C) 1986 by University of Toronto.               --\n---           Copyright (C) 1996-2003 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1996-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3406,9 +3406,9 @@ package body GNAT.Regpat is\n      (Expression : String;\n       Data       : String;\n       Matches    : out Match_Array;\n-      Size       : Program_Size := 0;\n-      Data_First : Integer := -1;\n-      Data_Last  : Positive := Positive'Last)\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last)\n    is\n       PM            : Pattern_Matcher (Size);\n       Finalize_Size : Program_Size;\n@@ -3426,12 +3426,12 @@ package body GNAT.Regpat is\n    -- Match --\n    -----------\n \n-   function  Match\n+   function Match\n      (Expression : String;\n       Data       : String;\n-      Size       : Program_Size := 0;\n-      Data_First : Integer := -1;\n-      Data_Last  : Positive := Positive'Last) return Natural\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last) return Natural\n    is\n       PM         : Pattern_Matcher (Size);\n       Final_Size : Program_Size; -- unused\n@@ -3452,9 +3452,9 @@ package body GNAT.Regpat is\n    function  Match\n      (Expression : String;\n       Data       : String;\n-      Size       : Program_Size := 0;\n-      Data_First : Integer := -1;\n-      Data_Last  : Positive := Positive'Last) return Boolean\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last) return Boolean\n    is\n       Matches    : Match_Array (0 .. 0);\n       PM         : Pattern_Matcher (Size);"}, {"sha": "82bab7f5bdad0f85e2c48484024cf4213efe943b", "filename": "gcc/ada/g-regpat.ads", "status": "modified", "additions": 128, "deletions": 80, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fg-regpat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fg-regpat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                                                                          --\n --               Copyright (C) 1986 by University of Toronto.               --\n---           Copyright (C) 1996-2003 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1996-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -300,19 +300,32 @@ pragma Preelaborate (Regpat);\n    --  This is limited by the size of a Character, as found in the\n    --  byte-compiled version of regular expressions.\n \n-   Max_Program_Size : constant := 2**15 - 1;\n-   --  Maximum size that can be allocated for a program\n-\n    Max_Curly_Repeat : constant := 32767;\n    --  Maximum number of repetition for the curly operator.\n    --  The digits in the {n}, {n,} and {n,m } operators can not be higher\n    --  than this constant, since they have to fit on two characters in the\n    --  byte-compiled version of regular expressions.\n \n+   Max_Program_Size : constant := 2**15 - 1;\n+   --  Maximum size that can be allocated for a program\n+\n    type Program_Size is range 0 .. Max_Program_Size;\n    for Program_Size'Size use 16;\n    --  Number of bytes allocated for the byte-compiled version of a regular\n-   --  expression.\n+   --  expression. The size required depends on the complexity of the regular\n+   --  expression in a complex manner that is undocumented (other than in the\n+   --  body of the Compile procedure). Normally the size is automatically set\n+   --  and the programmer need not be concerned about it. There are two\n+   --  exceptions to this. First in the calls to Match, it is possible to\n+   --  specify a non-zero size that is known to be large enough. This can\n+   --  slightly increase the efficiency by avoiding a copy. Second, in the\n+   --  case of calling compile, it is possible using the procedural form\n+   --  of Compile to use a single Pattern_Matcher variable for several\n+   --  different expressions by setting its size sufficiently large.\n+\n+   Auto_Size : constant := 0;\n+   --  Used in calls to Match to indicate that the Size should be set to\n+   --  a value appropriate to the expression being used automatically.\n \n    type Regexp_Flags is mod 256;\n    for Regexp_Flags'Size use 8;\n@@ -368,9 +381,14 @@ pragma Preelaborate (Regpat);\n    --  matching a null string at position 1, which uses (1, 0)\n    --  and no match at all.\n \n-   ------------------------------\n-   -- Pattern_Matcher Creation --\n-   ------------------------------\n+   ---------------------------------\n+   -- Pattern_Matcher Compilation --\n+   ---------------------------------\n+\n+   --  The subprograms here are used to precompile regular expressions\n+   --  for use in subsequent Match calls. Precompilation improves\n+   --  efficiency if the same regular expression is to be used in\n+   --  more than one Match call.\n \n    type Pattern_Matcher (Size : Program_Size) is private;\n    --  Type used to represent a regular expression compiled into byte code\n@@ -381,26 +399,47 @@ pragma Preelaborate (Regpat);\n    function Compile\n      (Expression : String;\n       Flags      : Regexp_Flags := No_Flags) return Pattern_Matcher;\n-   --  Compile a regular expression into internal code.\n-   --  Raises Expression_Error if Expression is not a legal regular expression.\n-   --  The appropriate size is calculated automatically, but this means that\n-   --  the regular expression has to be compiled twice (the first time to\n-   --  calculate the size, the second time to actually generate the byte code).\n+   --  Compile a regular expression into internal code\n    --\n-   --  Flags is the default value to use to set properties for Expression (case\n-   --  sensitivity,...).\n+   --  Raises Expression_Error if Expression is not a legal regular expression\n+   --\n+   --  The appropriate size is calculated automatically to correspond to the\n+   --  provided expression. This is the normal default method of compilation.\n+   --  Note that it is generally not possible to assign the result of two\n+   --  different calls to this Compile function to the same Pattern_Matcher\n+   --  variable, since the sizes will differ.\n+   --\n+   --  Flags is the default value to use to set properties for Expression\n+   --  (e.g. case sensitivity,...).\n \n    procedure Compile\n      (Matcher         : out Pattern_Matcher;\n       Expression      : String;\n       Final_Code_Size : out Program_Size;\n       Flags           : Regexp_Flags := No_Flags);\n    --  Compile a regular expression into into internal code\n-   --  This procedure is significantly faster than the function\n-   --  Compile, as there is a known maximum size for the matcher.\n-   --  This function raises Storage_Error if Matcher is too small\n-   --  to hold the resulting code, or Expression_Error is Expression\n-   --  is not a legal regular expression.\n+\n+   --  This procedure is significantly faster than the Compile function\n+   --  since it avoids the extra step of precomputing the required size.\n+   --\n+   --  However, it requires the user to provide a Pattern_Matcher variable\n+   --  whose size is preset to a large enough value. One advantage of this\n+   --  approach, in addition to the improved efficiency, is that the same\n+   --  Pattern_Matcher variable can be used to hold the compiled code for\n+   --  several different regular expressions by setting a size that is\n+   --  large enough to accomodate all possibilities.\n+   --\n+   --  In this version of the procedure call, the actual required code\n+   --  size is returned. Also if Matcher.Size is zero on entry, then the\n+   --  resulting code is not stored. A call with Matcher.Size set to Auto_Size\n+   --  can thus be used to determine the space required for compiling the\n+   --  given regular expression.\n+   --\n+   --  This function raises Storage_Error if Matcher is too small to hold\n+   --  the resulting code (i.e. Matcher.Size has too small a value).\n+   --\n+   --  Expression_Error is raised if the string Expression does not contain\n+   --  a valid regular expression.\n    --\n    --  Flags is the default value to use to set properties for Expression (case\n    --  sensitivity,...).\n@@ -410,7 +449,7 @@ pragma Preelaborate (Regpat);\n       Expression : String;\n       Flags      : Regexp_Flags := No_Flags);\n    --  Same procedure as above, expect it does not return the final\n-   --  program size.\n+   --  program size, and Matcher.Size cannot be Auto_Size.\n \n    function Paren_Count (Regexp : Pattern_Matcher) return Match_Count;\n    pragma Inline (Paren_Count);\n@@ -442,92 +481,103 @@ pragma Preelaborate (Regpat);\n    -- Matching --\n    --------------\n \n-   procedure Match\n-     (Expression     : String;\n-      Data           : String;\n-      Matches        : out Match_Array;\n-      Size           : Program_Size := 0;\n-      Data_First     : Integer      := -1;\n-      Data_Last      : Positive     := Positive'Last);\n-   --  Match Expression against Data (Data_First .. Data_Last) and store\n-   --  result in Matches.\n-   --\n-   --  Data_First defaults to Data'First if unspecified (that is the\n-   --  dummy value of -1 is interpreted to mean Data'First).\n-   --\n-   --  Data_Last defaults to Data'Last if unspecified (that is the\n-   --  dummy value of Positive'Last is interpreted to mean Data'Last)\n-   --\n-   --  It is important that Data contains the whole string (or file) you\n-   --  want to matched against, even if you start in the middle, since\n-   --  otherwise regular expressions starting with \"^\" or ending with \"$\" will\n-   --  be improperly processed.\n+   --  The Match subprograms are given a regular expression in string\n+   --  form, and perform the corresponding match. The following parameters\n+   --  are present in all forms of the Match call.\n+\n+   --    Expression contains the regular expression to be matched as a string\n+\n+   --    Data contains the string to be matched\n+\n+   --    Data_First is the lower bound for the match, i.e. Data (Data_First)\n+   --    will be the first character to be examined. If Data_First is set to\n+   --    the special value of -1 (the default), then the first character to\n+   --    be examined is Data (Data_First). However, the regular expression\n+   --    character ^ (start of string) still refers to the first character\n+   --    of the full string (Data (Data'First)), which is why there is a\n+   --    separate mechanism for specifying Data_First.\n+\n+   --    Data_Last is the upper bound for the match, i.e. Data (Data_Last)\n+   --    will be the last character to be examined. If Data_Last is set to\n+   --    the special value of Positive'Last (the default), then the last\n+   --    character to be examined is Data (Data_Last). However, the regular\n+   --    expression character $ (end of string) still refers to the last\n+   --    character of the full string (Data (Data'Last)), which is why there\n+   --    is a separate mechanism for specifying Data_Last.\n+\n+   --    Note: the use of Data_First and Data_Last is not equivalent to\n+   --    simply passing a slice as Expression because of the handling of\n+   --    regular expression characters ^ and $.\n+\n+   --    Size is the size allocated for the compiled byte code. Normally\n+   --    this is defaulted to Auto_Size which means that the appropriate\n+   --    size is allocated automatically. It is possible to specify an\n+   --    explicit size, which must be sufficiently large. This slightly\n+   --    increases the efficiency by avoiding the extra step of computing\n+   --    the appropriate size.\n+\n+   --  The following exceptions can be raised in calls to Match\n    --\n-   --  Function raises Storage_Error if Size is too small for Expression,\n-   --  or Expression_Error if Expression is not a legal regular expression.\n-   --  If Size is 0, then the appropriate size is automatically calculated\n-   --  by this package, but this is slightly slower.\n+   --    Storage_Error is raised if a non-zero value is given for Size\n+   --    and it is too small to hold the compiled byte code.\n    --\n+   --    Expression_Error is raised if the given expression is not a legal\n+   --    regular expression.\n+\n+\n+   procedure Match\n+     (Expression : String;\n+      Data       : String;\n+      Matches    : out Match_Array;\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last);\n+   --  This version returns the result of the match stored in Match_Array.\n    --  At most Matches'Length parenthesis are returned.\n \n-   function  Match\n+   function Match\n      (Expression : String;\n       Data       : String;\n-      Size       : Program_Size := 0;\n-      Data_First : Integer  := -1;\n-      Data_Last  : Positive := Positive'Last) return Natural;\n-   --  Return the position where Data matches, or (Data'First - 1) if\n-   --  there is no match.\n-   --\n-   --  Function raises Storage_Error if Size is too small for Expression\n-   --  or Expression_Error if Expression is not a legal regular expression\n-   --\n-   --  If Size is 0, then the appropriate size is automatically calculated\n-   --  by this package, but this is slightly slower.\n-   --  See description of Data_First and Data_Last above.\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last) return Natural;\n+   --  This version returns the position where Data matches, or if there is\n+   --  no match, then the value Data'First - 1.\n \n    function Match\n      (Expression : String;\n       Data       : String;\n-      Size       : Program_Size := 0;\n-      Data_First : Integer  := -1;\n-      Data_Last  : Positive := Positive'Last) return Boolean;\n-   --  Return True if Data matches Expression. Match raises Storage_Error\n-   --  if Size is too small for Expression, or Expression_Error if Expression\n-   --  is not a legal regular expression.\n-   --\n-   --  If Size is 0, then the appropriate size is automatically calculated\n-   --  by this package, but this is slightly slower.\n-   --\n-   --  See description of Data_First and Data_Last above.\n+      Size       : Program_Size := Auto_Size;\n+      Data_First : Integer      := -1;\n+      Data_Last  : Positive     := Positive'Last) return Boolean;\n+   --  This version returns True if the match succeeds, False otherwise\n \n    ------------------------------------------------\n-   -- Matching a pre-compiled regular expression --\n+   -- Matching a Pre-Compiled Regular Expression --\n    ------------------------------------------------\n \n    --  The following functions are significantly faster if you need to reuse\n    --  the same regular expression multiple times, since you only have to\n-   --  compile it once.\n+   --  compile it once. For these functions you must first compile the\n+   --  expression with a call to Compile as previously described.\n+\n+   --  The parameters Data, Data_First and Data_Last are as described\n+   --  in the previous section.\n \n    function  Match\n      (Self       : Pattern_Matcher;\n       Data       : String;\n       Data_First : Integer  := -1;\n       Data_Last  : Positive := Positive'Last) return Natural;\n-   --  Match Data using the given pattern matcher.\n-   --  Return the position where Data matches, or (Data'First - 1) if there is\n-   --  no match.\n-   --\n-   --  See description of Data_First and Data_Last above.\n+   --  Match Data using the given pattern matcher. Returns the position\n+   --  where Data matches, or (Data'First - 1) if there is no match.\n \n    function  Match\n      (Self       : Pattern_Matcher;\n       Data       : String;\n       Data_First : Integer  := -1;\n       Data_Last  : Positive := Positive'Last) return Boolean;\n    --  Return True if Data matches using the given pattern matcher.\n-   --\n-   --  See description of Data_First and Data_Last above.\n \n    pragma Inline (Match);\n    --  All except the last one below\n@@ -542,8 +592,6 @@ pragma Preelaborate (Regpat);\n    --  The expression matches if Matches (0) /= No_Match.\n    --\n    --  At most Matches'Length parenthesis are returned.\n-   --\n-   --  See description of Data_First and Data_Last above.\n \n    -----------\n    -- Debug --"}, {"sha": "ec766614392239892627df8359639710c98f8511", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -2970,14 +2970,13 @@ There are no semantic dependencies on the package Ada.Calendar.\n @item No_Relative_Delay\n There are no delay_relative_statements.\n \n-@item No_Task_Attributes\n-There are no semantic dependencies on the Ada.Task_Attributes package and\n-there are no references to the attributes Callable and Terminated [RM 9.9].\n+@item No_Task_Attributes_Package\n+There are no semantic dependencies on the Ada.Task_Attributes package.\n \n-@item Boolean_Entry_Barriers\n-Entry barrier condition expressions shall be boolean\n-objects which are declared in the protected type\n-which contains the entry.\n+@item Simple_Barriers\n+Entry barrier condition expressions shall be either static\n+boolean expressions or boolean objects which are declared in\n+the protected type which contains the entry.\n \n @item Max_Asynchronous_Select_Nesting = 0\n [RM D.7] Specifies the maximum dynamic nesting level of asynchronous_selects.\n@@ -3023,7 +3022,7 @@ and whose most recent description is available at\n \n The above set is a superset of the restrictions provided by pragma\n @code{Restricted_Run_Time}, it includes five additional restrictions\n-(@code{Boolean_Entry_Barriers}, @code{No_Select_Statements},\n+(@code{Simple_Barriers}, @code{No_Select_Statements},\n @code{No_Calendar},\n @code{No_Relative_Delay} and @code{No_Task_Termination}).  This means\n that pragma @code{Ravenscar}, like the pragma @code{Restricted_Run_Time},\n@@ -3054,7 +3053,7 @@ A configuration pragma that establishes the following set of restrictions:\n @item No_Protected_Type_Allocators\n @item No_Local_Protected_Objects\n @item No_Requeue_Statements\n-@item No_Task_Attributes\n+@item No_Task_Attributes_Package\n @item Max_Asynchronous_Select_Nesting =  0\n @item Max_Task_Entries =  0\n @item Max_Protected_Entries = 1\n@@ -6847,13 +6846,14 @@ then all compilation units in the partition must obey the restriction.\n \n @table @code\n \n-@item Boolean_Entry_Barriers\n-@findex Boolean_Entry_Barriers\n+@item Simple_Barriers\n+@findex Simple_Barriers\n This restriction ensures at compile time that barriers in entry declarations\n-for protected types are restricted to references to simple boolean variables\n-defined in the private part of the protected type.  No other form of entry\n-barriers is permitted.  This is one of the restrictions of the Ravenscar\n-profile for limited tasking (see also pragma @code{Ravenscar}).\n+for protected types are restricted to either static boolean expressions or\n+references to simple boolean variables defined in the private part of the\n+protected type.  No other form of entry barriers is permitted.  This is one\n+of the restrictions of the Ravenscar profile for limited tasking (see also\n+pragma @code{Ravenscar}).\n \n @item Max_Entry_Queue_Depth => Expr\n @findex Max_Entry_Queue_Depth\n@@ -6990,8 +6990,8 @@ user-defined storage pool.\n This restriction ensures at compile time that there are no implicit or\n explicit dependencies on the package @code{Ada.Streams}.\n \n-@item No_Task_Attributes\n-@findex No_Task_Attributes\n+@item No_Task_Attributes_Package\n+@findex No_Task_Attributes_Package\n This restriction ensures at compile time that there are no implicit or\n explicit dependencies on the package @code{Ada.Task_Attributes}.\n "}, {"sha": "1747d25d3079ed9c585c296bb65bc0c536118f15", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -839,8 +839,9 @@ begin\n                          (Name => Name_Default_Switches,\n                           In_Arrays => Element.Decl.Arrays);\n                      The_Switches := Prj.Util.Value_Of\n-                       (Index => Name_Ada,\n-                        In_Array => Default_Switches_Array);\n+                       (Index     => Name_Ada,\n+                        Src_Index => 0,\n+                        In_Array  => Default_Switches_Array);\n                   end if;\n                end if;\n "}, {"sha": "e43821eab673a8ce3fbde4e0c9f4389de37bb84e", "filename": "gcc/ada/init.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -1281,11 +1281,14 @@ __gnat_initialize (void)\n \n #elif defined (VMS)\n \n+#ifdef IN_RTS\n+\n /* The prehandler actually gets control first on a condition. It swaps the\n    stack pointer and calls the handler (__gnat_error_handler). */\n extern long __gnat_error_prehandler (void);\n \n extern char *__gnat_error_prehandler_stack;   /* Alternate signal stack */\n+#endif\n \n /* Conditions that don't have an Ada exception counterpart must raise\n    Non_Ada_Error.  Since this is defined in s-auxdec, it should only be\n@@ -1474,6 +1477,7 @@ void\n __gnat_install_handler (void)\n {\n   long prvhnd;\n+#ifdef IN_RTS\n   char *c;\n \n   c = (char *) xmalloc (2049);\n@@ -1482,6 +1486,9 @@ __gnat_install_handler (void)\n \n   /* __gnat_error_prehandler is an assembly function.  */\n   SYS$SETEXV (1, __gnat_error_prehandler, 3, &prvhnd);\n+#else\n+  SYS$SETEXV (1, __gnat_error_handler, 3, &prvhnd);\n+#endif\n   __gnat_handler_installed = 1;\n }\n "}, {"sha": "1259bc890b7e52aa9f77edf3952e20847550bc41", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -600,6 +600,7 @@ package body Lib.Writ is\n          Pname      : constant Unit_Name_Type :=\n                         Get_Parent_Spec_Name (Unit_Name (Main_Unit));\n          Body_Fname : File_Name_Type;\n+         Body_Index : Nat;\n \n       begin\n          --  Loop to build the with table. A with on the main unit itself\n@@ -657,12 +658,18 @@ package body Lib.Writ is\n                       (Get_Body_Name (Uname),\n                        Subunit => False, May_Fail => True);\n \n+                  Body_Index :=\n+                    Get_Unit_Index\n+                      (Get_Body_Name (Uname));\n+\n                   if Body_Fname = No_File then\n                      Body_Fname := Get_File_Name (Uname, Subunit => False);\n+                     Body_Index := Get_Unit_Index (Uname);\n                   end if;\n \n                else\n                   Body_Fname := Get_File_Name (Uname, Subunit => False);\n+                  Body_Index := Get_Unit_Index (Uname);\n                end if;\n \n                --  A package is considered to have a body if it requires\n@@ -675,7 +682,7 @@ package body Lib.Writ is\n                   Write_Info_Name (Body_Fname);\n                   Write_Info_Tab (49);\n                   Write_Info_Name\n-                    (Lib_File_Name (Body_Fname, Munit_Index (Unum)));\n+                    (Lib_File_Name (Body_Fname, Body_Index));\n                else\n                   Write_Info_Name (Fname);\n                   Write_Info_Tab (49);"}, {"sha": "ee0926c54641c40c2ea8844e4ccaeb2b32cb86a8", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 374, "deletions": 312, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -124,16 +124,18 @@ package body Make is\n \n    procedure Insert_Q\n      (Source_File : File_Name_Type;\n-      Source_Unit : Unit_Name_Type := No_Name);\n-   --  Inserts Source_File at the end of Q. Provide Source_Unit when\n-   --  possible for external use (gnatdist).\n+      Source_Unit : Unit_Name_Type := No_Name;\n+      Index       : Int            := 0);\n+   --  Inserts Source_File at the end of Q. Provide Source_Unit when possible\n+   --  for external use (gnatdist). Provide index for multi-unit sources.\n \n    function Empty_Q return Boolean;\n    --  Returns True if Q is empty.\n \n    procedure Extract_From_Q\n-     (Source_File : out File_Name_Type;\n-      Source_Unit : out Unit_Name_Type);\n+     (Source_File  : out File_Name_Type;\n+      Source_Unit  : out Unit_Name_Type;\n+      Source_Index : out Int);\n    --  Extracts the first element from the Q.\n \n    procedure Insert_Project_Sources\n@@ -164,12 +166,14 @@ package body Make is\n    --  Used to detect multiple --RTS= switches\n \n    type Q_Record is record\n-      File : File_Name_Type;\n-      Unit : Unit_Name_Type;\n+      File  : File_Name_Type;\n+      Unit  : Unit_Name_Type;\n+      Index : Int;\n    end record;\n    --  File is the name of the file to compile. Unit is for gnatdist\n    --  use in order to easily get the unit name of a file to compile\n-   --  when its name is krunched or declared in gnat.adc.\n+   --  when its name is krunched or declared in gnat.adc. Index, when not 0,\n+   --  is the index of the unit in a multi-unit source.\n \n    package Q is new Table.Table (\n      Table_Component_Type => Q_Record,\n@@ -459,20 +463,6 @@ package body Make is\n    --  pragmas file to be specified for For_Project,\n    --  otherwise return an empty argument list.\n \n-   ----------------------\n-   -- Marking Routines --\n-   ----------------------\n-\n-   Marking_Label : Byte := 1;\n-   --  Value to mark the source files\n-\n-   procedure Mark (Source_File : File_Name_Type);\n-   --  Mark Source_File. Marking is used to signal that Source_File has\n-   --  already been inserted in the Q.\n-\n-   function Is_Marked (Source_File : File_Name_Type) return Boolean;\n-   --  Returns True if Source_File was previously marked.\n-\n    -------------------\n    -- Misc Routines --\n    -------------------\n@@ -574,6 +564,7 @@ package body Make is\n    function Switches_Of\n      (Source_File      : Name_Id;\n       Source_File_Name : String;\n+      Source_Index     : Int;\n       Naming           : Naming_Data;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value;\n@@ -656,6 +647,7 @@ package body Make is\n    procedure Add_Switches\n      (The_Package : Package_Id;\n       File_Name   : String;\n+      Index       : Int;\n       Program     : Make_Program_Type);\n    procedure Add_Switch\n      (S             : String_Access;\n@@ -676,13 +668,14 @@ package body Make is\n    --  added at the beginning of the command line.\n \n    procedure Check\n-     (Source_File : File_Name_Type;\n-      The_Args    : Argument_List;\n-      Lib_File    : File_Name_Type;\n-      Read_Only   : Boolean;\n-      ALI         : out ALI_Id;\n-      O_File      : out File_Name_Type;\n-      O_Stamp     : out Time_Stamp_Type);\n+     (Source_File  : File_Name_Type;\n+      Source_Index : Int;\n+      The_Args     : Argument_List;\n+      Lib_File     : File_Name_Type;\n+      Read_Only    : Boolean;\n+      ALI          : out ALI_Id;\n+      O_File       : out File_Name_Type;\n+      O_Stamp      : out Time_Stamp_Type);\n    --  Determines whether the library file Lib_File is up-to-date or not. The\n    --  full name (with path information) of the object file corresponding to\n    --  Lib_File is returned in O_File. Its time stamp is saved in O_Stamp.\n@@ -703,8 +696,9 @@ package body Make is\n    --  Otherwise O_File is No_File.\n \n    procedure Collect_Arguments\n-     (Source_File : File_Name_Type;\n-      Args        : Argument_List);\n+     (Source_File  : File_Name_Type;\n+      Source_Index : Int;\n+      Args         : Argument_List);\n    --  Collect all arguments for a source to be compiled, including those\n    --  that come from a project file.\n \n@@ -942,6 +936,7 @@ package body Make is\n    procedure Add_Switches\n      (The_Package : Package_Id;\n       File_Name   : String;\n+      Index       : Int;\n       Program     : Make_Program_Type)\n    is\n       Switches    : Variable_Value;\n@@ -956,6 +951,7 @@ package body Make is\n            Switches_Of\n            (Source_File      => Name_Find,\n             Source_File_Name => File_Name,\n+            Source_Index     => Index,\n             Naming           => Projects.Table (Main_Project).Naming,\n             In_Package       => The_Package,\n             Allow_ALI        =>\n@@ -1104,13 +1100,14 @@ package body Make is\n    -----------\n \n    procedure Check\n-     (Source_File : File_Name_Type;\n-      The_Args    : Argument_List;\n-      Lib_File    : File_Name_Type;\n-      Read_Only   : Boolean;\n-      ALI         : out ALI_Id;\n-      O_File      : out File_Name_Type;\n-      O_Stamp     : out Time_Stamp_Type)\n+     (Source_File  : File_Name_Type;\n+      Source_Index : Int;\n+      The_Args     : Argument_List;\n+      Lib_File     : File_Name_Type;\n+      Read_Only    : Boolean;\n+      ALI          : out ALI_Id;\n+      O_File       : out File_Name_Type;\n+      O_Stamp      : out Time_Stamp_Type)\n    is\n       function First_New_Spec (A : ALI_Id) return File_Name_Type;\n       --  Looks in the with table entries of A and returns the spec file name\n@@ -1342,7 +1339,7 @@ package body Make is\n \n             --  First, collect all the switches\n \n-            Collect_Arguments (Source_File, The_Args);\n+            Collect_Arguments (Source_File, Source_Index, The_Args);\n \n             Prev_Switch := Dummy_Switch;\n \n@@ -1705,8 +1702,9 @@ package body Make is\n    -----------------------\n \n    procedure Collect_Arguments\n-     (Source_File : File_Name_Type;\n-      Args        : Argument_List)\n+     (Source_File  : File_Name_Type;\n+      Source_Index : Int;\n+      Args         : Argument_List)\n    is\n    begin\n       Arguments_Collected := True;\n@@ -1787,6 +1785,7 @@ package body Make is\n                   Switches := Switches_Of\n                     (Source_File      => Source_File,\n                      Source_File_Name => Source_File_Name,\n+                     Source_Index     => Source_Index,\n                      Naming           => Data.Naming,\n                      In_Package       => Compiler_Package,\n                      Allow_ALI        => False);\n@@ -1885,6 +1884,7 @@ package body Make is\n       Most_Recent_Obj_Stamp : out Time_Stamp_Type;\n       Main_Unit             : out Boolean;\n       Compilation_Failures  : out Natural;\n+      Main_Index            : Int      := 0;\n       Check_Readonly_Files  : Boolean  := False;\n       Do_Not_Execute        : Boolean  := False;\n       Force_Compilations    : Boolean  := False;\n@@ -1893,15 +1893,6 @@ package body Make is\n       Initialize_ALI_Data   : Boolean  := True;\n       Max_Process           : Positive := 1)\n    is\n-      function Compile\n-        (S    : Name_Id;\n-         L    : Name_Id;\n-         Args : Argument_List) return Process_Id;\n-      --  Compiles S using Args. If S is a GNAT predefined source\n-      --  \"-gnatpg\" is added to Args. Non blocking call. L corresponds to the\n-      --  expected library file name. Process_Id of the process spawned to\n-      --  execute the compile.\n-\n       No_Mapping_File : constant Natural := 0;\n \n       type Compilation_Data is record\n@@ -1990,9 +1981,23 @@ package body Make is\n       --  resp. No_File, No_File and No_Name  if there were no compilations\n       --  to wait for.\n \n-      procedure Collect_Arguments_And_Compile (Source_File : File_Name_Type);\n+      function Bad_Compilation_Count return Natural;\n+      --  Returns the number of compilation failures.\n+\n+      procedure Collect_Arguments_And_Compile\n+        (Source_File : File_Name_Type; Source_Index : Int);\n       --  Collect arguments from project file (if any) and compile\n \n+      function Compile\n+        (S            : Name_Id;\n+         L            : Name_Id;\n+         Source_Index : Int;\n+         Args         : Argument_List) return Process_Id;\n+      --  Compiles S using Args. If S is a GNAT predefined source\n+      --  \"-gnatpg\" is added to Args. Non blocking call. L corresponds to the\n+      --  expected library file name. Process_Id of the process spawned to\n+      --  execute the compile.\n+\n       package Good_ALI is new Table.Table (\n         Table_Component_Type => ALI_Id,\n         Table_Index_Type     => Natural,\n@@ -2002,12 +2007,13 @@ package body Make is\n         Table_Name           => \"Make.Good_ALI\");\n       --  Contains the set of valid ALI files that have not yet been scanned.\n \n-      procedure Record_Good_ALI (A : ALI_Id);\n-      --  Records in the previous set the Id of an ALI file.\n-\n       function Good_ALI_Present return Boolean;\n       --  Returns True if any ALI file was recorded in the previous set.\n \n+      procedure Get_Mapping_File (Project : Project_Id);\n+      --  Get a mapping file name. If there is one to be reused, reuse it.\n+      --  Otherwise, create a new mapping file.\n+\n       function Get_Next_Good_ALI return ALI_Id;\n       --  Returns the next good ALI_Id record;\n \n@@ -2019,12 +2025,8 @@ package body Make is\n       --  If Found is False then the compilation of File failed because we\n       --  could not find it. Records also Unit when possible.\n \n-      function Bad_Compilation_Count return Natural;\n-      --  Returns the number of compilation failures.\n-\n-      procedure Get_Mapping_File (Project : Project_Id);\n-      --  Get a mapping file name. If there is one to be reused, reuse it.\n-      --  Otherwise, create a new mapping file.\n+      procedure Record_Good_ALI (A : ALI_Id);\n+      --  Records in the previous set the Id of an ALI file.\n \n       -----------------\n       -- Add_Process --\n@@ -2146,14 +2148,16 @@ package body Make is\n       -- Collect_Arguments_And_Compile --\n       -----------------------------------\n \n-      procedure Collect_Arguments_And_Compile (Source_File : File_Name_Type) is\n+      procedure Collect_Arguments_And_Compile\n+        (Source_File : File_Name_Type; Source_Index : Int)\n+      is\n       begin\n \n          --  If arguments have not yet been collected (in Check), collect them\n          --  now.\n \n          if not Arguments_Collected then\n-            Collect_Arguments (Source_File, Args);\n+            Collect_Arguments (Source_File, Source_Index, Args);\n          end if;\n \n          --  If we use mapping file (-P or -C switches), then get one\n@@ -2201,7 +2205,7 @@ package body Make is\n \n             Change_To_Object_Directory (Arguments_Project);\n \n-            Pid := Compile (Arguments_Path_Name, Lib_File,\n+            Pid := Compile (Arguments_Path_Name, Lib_File, Source_Index,\n                             Arguments (1 .. Last_Argument));\n \n          else\n@@ -2213,7 +2217,7 @@ package body Make is\n                Change_To_Object_Directory (Arguments_Project);\n             end if;\n \n-            Pid := Compile (Full_Source_File, Lib_File,\n+            Pid := Compile (Full_Source_File, Lib_File, Source_Index,\n                             Arguments (1 .. Last_Argument));\n          end if;\n       end Collect_Arguments_And_Compile;\n@@ -2223,9 +2227,10 @@ package body Make is\n       -------------\n \n       function Compile\n-        (S    : Name_Id;\n-         L    : Name_Id;\n-         Args : Argument_List) return Process_Id\n+        (S            : Name_Id;\n+         L            : Name_Id;\n+         Source_Index : Int;\n+         Args         : Argument_List) return Process_Id\n       is\n          Comp_Args : Argument_List (Args'First .. Args'Last + 8);\n          Comp_Next : Integer := Args'First;\n@@ -2337,7 +2342,20 @@ package body Make is\n             Comp_Args (Comp_Last) := Ada_Flag_2;\n          end if;\n \n-         if L /= Strip_Directory (L) or else Object_Directory_Path /= null then\n+         if Source_Index /= 0 then\n+            declare\n+               Num : constant String := Source_Index'Img;\n+            begin\n+               Comp_Last := Comp_Last + 1;\n+               Comp_Args (Comp_Last) :=\n+                 new String'(\"-gnateI\" & Num (Num'First + 1 .. Num'Last));\n+            end;\n+         end if;\n+\n+         if Source_Index /= 0 or else\n+           L /= Strip_Directory (L) or else\n+           Object_Directory_Path /= null\n+         then\n \n             --  Build -o argument.\n \n@@ -2501,9 +2519,9 @@ package body Make is\n       --  Only insert in the Q if it is not already done, to avoid simultaneous\n       --  compilations if -jnnn is used.\n \n-      if not Is_Marked (Main_Source) then\n-         Insert_Q (Main_Source);\n-         Mark (Main_Source);\n+      if not Is_Marked (Main_Source, Main_Index) then\n+         Insert_Q (Main_Source, Index => Main_Index);\n+         Mark (Main_Source, Main_Index);\n       end if;\n \n       First_Compiled_File   := No_File;\n@@ -2537,157 +2555,156 @@ package body Make is\n          --  up all the available processes.\n \n          if not Empty_Q and then Outstanding_Compiles < Max_Process then\n-            Extract_From_Q (Source_File, Source_Unit);\n-            Full_Source_File := Osint.Full_Source_Name (Source_File);\n-            Lib_File         := Osint.Lib_File_Name (Source_File);\n-            Full_Lib_File    := Osint.Full_Lib_File_Name (Lib_File);\n-\n-            --  If this source has already been compiled, the executable is\n-            --  obsolete.\n+            declare\n+               Source_Index : Int;\n+               --  Index of the current unit in the current source file\n \n-            if Is_In_Obsoleted (Source_File) then\n-               Executable_Obsolete := True;\n-            end if;\n+            begin\n+               Extract_From_Q (Source_File, Source_Unit, Source_Index);\n+               Full_Source_File := Osint.Full_Source_Name (Source_File);\n+               Lib_File         := Osint.Lib_File_Name\n+                 (Source_File, Source_Index);\n+               Full_Lib_File    := Osint.Full_Lib_File_Name (Lib_File);\n \n-            --  If the library file is an Ada library skip it\n+               --  If this source has already been compiled, the executable is\n+               --  obsolete.\n \n-            if Full_Lib_File /= No_File\n-              and then In_Ada_Lib_Dir (Full_Lib_File)\n-            then\n-               Verbose_Msg (Lib_File, \"is in an Ada library\", Prefix => \"  \");\n+               if Is_In_Obsoleted (Source_File) then\n+                  Executable_Obsolete := True;\n+               end if;\n \n-            --  If the library file is a read-only library skip it, but only\n-            --  if, when using project files, this library file is in the\n-            --  right object directory (a read-only ALI file in the object\n-            --  directory of a project being extended should not be skipped).\n+               --  If the library file is an Ada library skip it\n \n-            elsif Full_Lib_File /= No_File\n-              and then not Check_Readonly_Files\n-              and then Is_Readonly_Library (Full_Lib_File)\n-              and then Is_In_Object_Directory (Source_File, Full_Lib_File)\n-            then\n-               Verbose_Msg\n-                 (Lib_File, \"is a read-only library\", Prefix => \"  \");\n-\n-            --  The source file that we are checking cannot be located\n+               if Full_Lib_File /= No_File\n+                 and then In_Ada_Lib_Dir (Full_Lib_File)\n+               then\n+                  Verbose_Msg\n+                    (Lib_File, \"is in an Ada library\", Prefix => \"  \");\n+\n+                  --  If the library file is a read-only library skip it, but\n+                  --  only if, when using project files, this library file is\n+                  --  in the right object directory (a read-only ALI file\n+                  --  in the object directory of a project being extended\n+                  --  should not be skipped).\n+\n+               elsif Full_Lib_File /= No_File\n+                 and then not Check_Readonly_Files\n+                 and then Is_Readonly_Library (Full_Lib_File)\n+                 and then Is_In_Object_Directory (Source_File, Full_Lib_File)\n+               then\n+                  Verbose_Msg\n+                    (Lib_File, \"is a read-only library\", Prefix => \"  \");\n \n-            elsif Full_Source_File = No_File then\n-               Record_Failure (Source_File, Source_Unit, False);\n+                  --  The source file that we are checking cannot be located\n \n-            --  Source and library files can be located but are internal\n-            --  files\n+               elsif Full_Source_File = No_File then\n+                  Record_Failure (Source_File, Source_Unit, False);\n \n-            elsif not Check_Readonly_Files\n-              and then Full_Lib_File /= No_File\n-              and then Is_Internal_File_Name (Source_File)\n-            then\n+                  --  Source and library files can be located but are internal\n+                  --  files\n \n-               if Force_Compilations then\n-                  Fail\n-                    (\"not allowed to compile \"\"\" &\n-                     Get_Name_String (Source_File) &\n-                     \"\"\"; use -a switch, or compile file with \" &\n-                     \"\"\"-gnatg\"\" switch\");\n-               end if;\n+               elsif not Check_Readonly_Files\n+                 and then Full_Lib_File /= No_File\n+                 and then Is_Internal_File_Name (Source_File)\n+               then\n+                  if Force_Compilations then\n+                     Fail\n+                       (\"not allowed to compile \"\"\" &\n+                        Get_Name_String (Source_File) &\n+                        \"\"\"; use -a switch, or compile file with \" &\n+                        \"\"\"-gnatg\"\" switch\");\n+                  end if;\n \n-               Verbose_Msg\n-                 (Lib_File, \"is an internal library\", Prefix => \"  \");\n+                  Verbose_Msg\n+                    (Lib_File, \"is an internal library\", Prefix => \"  \");\n \n-            --  The source file that we are checking can be located\n+               --  The source file that we are checking can be located\n \n-            else\n-               Arguments_Collected := False;\n+               else\n+                  Arguments_Collected := False;\n \n-               --  Don't waste any time if we have to recompile anyway\n+                  --  Don't waste any time if we have to recompile anyway\n \n-               Obj_Stamp       := Empty_Time_Stamp;\n-               Need_To_Compile := Force_Compilations;\n+                  Obj_Stamp       := Empty_Time_Stamp;\n+                  Need_To_Compile := Force_Compilations;\n \n-               if not Force_Compilations then\n-                  Read_Only :=\n-                    Full_Lib_File /= No_File\n-                    and then not Check_Readonly_Files\n-                    and then Is_Readonly_Library (Full_Lib_File);\n-                  Check (Source_File, Args, Lib_File, Read_Only,\n-                         ALI, Obj_File, Obj_Stamp);\n-                  Need_To_Compile := (ALI = No_ALI_Id);\n-               end if;\n+                  if not Force_Compilations then\n+                     Read_Only :=\n+                       Full_Lib_File /= No_File\n+                       and then not Check_Readonly_Files\n+                       and then Is_Readonly_Library (Full_Lib_File);\n+                     Check (Source_File, Source_Index, Args, Lib_File,\n+                            Read_Only, ALI, Obj_File, Obj_Stamp);\n+                     Need_To_Compile := (ALI = No_ALI_Id);\n+                  end if;\n \n-               if not Need_To_Compile then\n+                  if not Need_To_Compile then\n \n-                  --  The ALI file is up-to-date. Record its Id.\n+                     --  The ALI file is up-to-date. Record its Id.\n \n-                  Record_Good_ALI (ALI);\n+                     Record_Good_ALI (ALI);\n \n-                  --  Record the time stamp of the most recent object file\n-                  --  as long as no (re)compilations are needed.\n+                     --  Record the time stamp of the most recent object file\n+                     --  as long as no (re)compilations are needed.\n \n-                  if First_Compiled_File = No_File\n-                    and then (Most_Recent_Obj_File = No_File\n-                              or else Obj_Stamp > Most_Recent_Obj_Stamp)\n-                  then\n-                     Most_Recent_Obj_File  := Obj_File;\n-                     Most_Recent_Obj_Stamp := Obj_Stamp;\n-                  end if;\n+                     if First_Compiled_File = No_File\n+                       and then (Most_Recent_Obj_File = No_File\n+                                   or else Obj_Stamp > Most_Recent_Obj_Stamp)\n+                     then\n+                        Most_Recent_Obj_File  := Obj_File;\n+                        Most_Recent_Obj_Stamp := Obj_Stamp;\n+                     end if;\n \n-               else\n-                  --  Is this the first file we have to compile?\n+                  else\n+                     --  Is this the first file we have to compile?\n \n-                  if First_Compiled_File = No_File then\n-                     First_Compiled_File  := Full_Source_File;\n-                     Most_Recent_Obj_File := No_File;\n+                     if First_Compiled_File = No_File then\n+                        First_Compiled_File  := Full_Source_File;\n+                        Most_Recent_Obj_File := No_File;\n \n-                     if Do_Not_Execute then\n-                        exit Make_Loop;\n+                        if Do_Not_Execute then\n+                           exit Make_Loop;\n+                        end if;\n                      end if;\n-                  end if;\n \n-                  if In_Place_Mode then\n+                     if In_Place_Mode then\n \n-                     --  If the library file was not found, then save the\n-                     --  library file near the source file.\n+                        --  If the library file was not found, then save the\n+                        --  library file near the source file.\n \n-                     if Full_Lib_File = No_File then\n-                        Get_Name_String (Full_Source_File);\n-\n-                        for J in reverse 1 .. Name_Len loop\n-                           if Name_Buffer (J) = '.' then\n-                              Name_Buffer (J + 1 .. J + 3) := \"ali\";\n-                              Name_Len := J + 3;\n-                              exit;\n-                           end if;\n-                        end loop;\n+                        if Full_Lib_File = No_File then\n+                           Lib_File := Osint.Lib_File_Name\n+                             (Full_Source_File, Source_Index);\n \n-                        Lib_File := Name_Find;\n+                           --  If the library file was found, then save the\n+                           --  library file in the same place.\n \n-                     --  If the library file was found, then save the\n-                     --  library file in the same place.\n+                        else\n+                           Lib_File := Full_Lib_File;\n+                        end if;\n \n-                     else\n-                        Lib_File := Full_Lib_File;\n                      end if;\n \n-                  end if;\n-\n-                  --  Start the compilation and record it. We can do this\n-                  --  because there is at least one free process.\n+                     --  Start the compilation and record it. We can do this\n+                     --  because there is at least one free process.\n \n-                  Collect_Arguments_And_Compile (Source_File);\n+                     Collect_Arguments_And_Compile (Source_File, Source_Index);\n \n-                  --  Make sure we could successfully start the compilation\n+                     --  Make sure we could successfully start the compilation\n \n-                  if Pid = Invalid_Pid then\n-                     Record_Failure (Full_Source_File, Source_Unit);\n-                  else\n-                     Add_Process\n-                       (Pid,\n-                        Full_Source_File,\n-                        Lib_File,\n-                        Source_Unit,\n-                        Mfile);\n+                     if Pid = Invalid_Pid then\n+                        Record_Failure (Full_Source_File, Source_Unit);\n+                     else\n+                        Add_Process\n+                          (Pid,\n+                           Full_Source_File,\n+                           Lib_File,\n+                           Source_Unit,\n+                           Mfile);\n+                     end if;\n                   end if;\n                end if;\n-            end if;\n+            end;\n          end if;\n \n          --  PHASE 2: Now check if we should wait for a compilation to\n@@ -2784,96 +2801,111 @@ package body Make is\n          while Good_ALI_Present loop\n             ALI := Get_Next_Good_ALI;\n \n-            --  If we are processing the library file corresponding to the\n-            --  main source file check if this source can be a main unit.\n+            declare\n+               Source_Index : Int := Unit_Index_Of (ALIs.Table (ALI).Afile);\n \n-            if ALIs.Table (ALI).Sfile = Main_Source then\n-               Main_Unit := ALIs.Table (ALI).Main_Program /= None;\n-            end if;\n+            begin\n+               --  If we are processing the library file corresponding to the\n+               --  main source file check if this source can be a main unit.\n \n-            --  The following adds the standard library (s-stalib) to the\n-            --  list of files to be handled by gnatmake: this file and any\n-            --  files it depends on are always included in every bind,\n-            --  even if they are not in the explicit dependency list.\n-            --  Of course, it is not added if Suppress_Standard_Library\n-            --  is True.\n+               if ALIs.Table (ALI).Sfile = Main_Source and then\n+                 Source_Index = Main_Index\n+               then\n+                  Main_Unit := ALIs.Table (ALI).Main_Program /= None;\n+               end if;\n \n-            --  However, to avoid annoying output about s-stalib.ali being\n-            --  read only, when \"-v\" is used, we add the standard library\n-            --  only when \"-a\" is used.\n+               --  The following adds the standard library (s-stalib) to the\n+               --  list of files to be handled by gnatmake: this file and any\n+               --  files it depends on are always included in every bind,\n+               --  even if they are not in the explicit dependency list.\n+               --  Of course, it is not added if Suppress_Standard_Library\n+               --  is True.\n \n-            if Need_To_Check_Standard_Library then\n-               Need_To_Check_Standard_Library := False;\n+               --  However, to avoid annoying output about s-stalib.ali being\n+               --  read only, when \"-v\" is used, we add the standard library\n+               --  only when \"-a\" is used.\n \n-               if not Targparm.Suppress_Standard_Library_On_Target then\n-                  declare\n-                     Sfile  : Name_Id;\n-                     Add_It : Boolean := True;\n+               if Need_To_Check_Standard_Library then\n+                  Need_To_Check_Standard_Library := False;\n \n-                  begin\n-                     Name_Len := Standard_Library_Package_Body_Name'Length;\n-                     Name_Buffer (1 .. Name_Len) :=\n-                       Standard_Library_Package_Body_Name;\n-                     Sfile := Name_Enter;\n+                  if not Targparm.Suppress_Standard_Library_On_Target then\n+                     declare\n+                        Sfile  : Name_Id;\n+                        Add_It : Boolean := True;\n \n-                     --  If we have a special runtime, we add the standard\n-                     --  library only if we can find it.\n+                     begin\n+                        Name_Len := Standard_Library_Package_Body_Name'Length;\n+                        Name_Buffer (1 .. Name_Len) :=\n+                          Standard_Library_Package_Body_Name;\n+                        Sfile := Name_Enter;\n \n-                     if RTS_Switch then\n-                        Add_It := Find_File (Sfile, Osint.Source) /= No_File;\n-                     end if;\n+                        --  If we have a special runtime, we add the standard\n+                        --  library only if we can find it.\n \n-                     if Add_It then\n-                        if Is_Marked (Sfile) then\n-                           if Is_In_Obsoleted (Sfile) then\n-                              Executable_Obsolete := True;\n-                           end if;\n+                        if RTS_Switch then\n+                           Add_It :=\n+                             Find_File (Sfile, Osint.Source) /= No_File;\n+                        end if;\n \n-                        else\n-                           Insert_Q (Sfile);\n-                           Mark (Sfile);\n+                        if Add_It then\n+                           if Is_Marked (Sfile) then\n+                              if Is_In_Obsoleted (Sfile) then\n+                                 Executable_Obsolete := True;\n+                              end if;\n+\n+                           else\n+                              Insert_Q (Sfile, Index => 0);\n+                              Mark (Sfile, Index => 0);\n+                           end if;\n                         end if;\n-                     end if;\n-                  end;\n+                     end;\n+                  end if;\n                end if;\n-            end if;\n \n-            --  Now insert in the Q the unmarked source files (i.e. those\n-            --  which have never been inserted in the Q and hence never\n-            --  considered). Only do that if Unique_Compile is False.\n+               --  Now insert in the Q the unmarked source files (i.e. those\n+               --  which have never been inserted in the Q and hence never\n+               --  considered). Only do that if Unique_Compile is False.\n \n-            if not Unique_Compile then\n-               for J in\n-                 ALIs.Table (ALI).First_Unit .. ALIs.Table (ALI).Last_Unit\n-               loop\n-                  for K in\n-                    Units.Table (J).First_With .. Units.Table (J).Last_With\n+               if not Unique_Compile then\n+                  for J in\n+                    ALIs.Table (ALI).First_Unit .. ALIs.Table (ALI).Last_Unit\n                   loop\n-                     Sfile := Withs.Table (K).Sfile;\n-                     Add_Dependency (ALIs.Table (ALI).Sfile, Sfile);\n+                     for K in\n+                       Units.Table (J).First_With .. Units.Table (J).Last_With\n+                     loop\n+                        Sfile := Withs.Table (K).Sfile;\n+                        Add_Dependency (ALIs.Table (ALI).Sfile, Sfile);\n \n-                     if Is_In_Obsoleted (Sfile) then\n-                        Executable_Obsolete := True;\n-                     end if;\n+                        if Is_In_Obsoleted (Sfile) then\n+                           Executable_Obsolete := True;\n+                        end if;\n+\n+                        if Sfile = No_File then\n+                           Debug_Msg\n+                             (\"Skipping generic:\", Withs.Table (K).Uname);\n \n-                     if Sfile = No_File then\n-                        Debug_Msg (\"Skipping generic:\", Withs.Table (K).Uname);\n+                        else\n+                           Source_Index :=\n+                             Unit_Index_Of (Withs.Table (K).Afile);\n \n-                     elsif Is_Marked (Sfile) then\n-                        Debug_Msg (\"Skipping marked file:\", Sfile);\n+                           if Is_Marked (Sfile, Source_Index) then\n+                              Debug_Msg (\"Skipping marked file:\", Sfile);\n \n-                     elsif not Check_Readonly_Files\n-                       and then Is_Internal_File_Name (Sfile)\n-                     then\n-                        Debug_Msg (\"Skipping internal file:\", Sfile);\n+                           elsif not Check_Readonly_Files\n+                             and then Is_Internal_File_Name (Sfile)\n+                           then\n+                              Debug_Msg (\"Skipping internal file:\", Sfile);\n \n-                     else\n-                        Insert_Q (Sfile, Withs.Table (K).Uname);\n-                        Mark (Sfile);\n-                     end if;\n+                           else\n+                              Insert_Q\n+                                (Sfile, Withs.Table (K).Uname, Source_Index);\n+                              Mark (Sfile, Source_Index);\n+                           end if;\n+                        end if;\n+                     end loop;\n                   end loop;\n-               end loop;\n-            end if;\n+               end if;\n+            end;\n          end loop;\n \n          if Display_Compilation_Progress then\n@@ -3266,35 +3298,34 @@ package body Make is\n    --------------------\n \n    procedure Extract_From_Q\n-     (Source_File : out File_Name_Type;\n-      Source_Unit : out Unit_Name_Type)\n+     (Source_File  : out File_Name_Type;\n+      Source_Unit  : out Unit_Name_Type;\n+      Source_Index : out Int)\n    is\n-      File : constant File_Name_Type := Q.Table (Q_Front).File;\n-      Unit : constant Unit_Name_Type := Q.Table (Q_Front).Unit;\n+      File  : constant File_Name_Type := Q.Table (Q_Front).File;\n+      Unit  : constant Unit_Name_Type := Q.Table (Q_Front).Unit;\n+      Index : constant Int            := Q.Table (Q_Front).Index;\n \n    begin\n       if Debug.Debug_Flag_Q then\n          Write_Str (\"   Q := Q - [ \");\n          Write_Name (File);\n+\n+         if Index /= 0 then\n+            Write_Str (\", \");\n+            Write_Int (Index);\n+         end if;\n+\n          Write_Str (\" ]\");\n          Write_Eol;\n       end if;\n \n       Q_Front := Q_Front + 1;\n-      Source_File := File;\n-      Source_Unit := Unit;\n+      Source_File  := File;\n+      Source_Unit  := Unit;\n+      Source_Index := Index;\n    end Extract_From_Q;\n \n-   -----------------\n-   -- Make_Failed --\n-   -----------------\n-\n-   procedure Make_Failed (S1 : String; S2 : String := \"\"; S3 : String := \"\") is\n-   begin\n-      Delete_All_Temp_Files;\n-      Osint.Fail (S1, S2, S3);\n-   end Make_Failed;\n-\n    --------------\n    -- Gnatmake --\n    --------------\n@@ -3326,7 +3357,12 @@ package body Make is\n       --  The current working directory, used to modify some relative path\n       --  switches on the command line when a project file is used.\n \n+      Current_Main_Index : Int := 0;\n+      --  If not zero, the index of the current main unit in its source file\n+\n       There_Are_Stand_Alone_Libraries : Boolean := False;\n+      --  Set to True when there are Stand-Alone Libraries, so that gnatbind\n+      --  is invoked with the -F switch to force checking of elaboration flags.\n \n    begin\n       Gnatmake_Called := True;\n@@ -3407,6 +3443,9 @@ package body Make is\n             end loop;\n          end if;\n \n+      elsif Main_Index /= 0 and then Osint.Number_Of_Files > 1 then\n+         Make_Failed (\"cannot specify several mains with a multi-unit index\");\n+\n       elsif Main_Project /= No_Project then\n \n          --  If the main project file is a library project file, main(s)\n@@ -3575,6 +3614,11 @@ package body Make is\n          --  the sources of the project file as mains.\n \n          else\n+            if Main_Index /= 0 then\n+               Make_Failed (\"cannot specify a multi-unit index but no main \" &\n+                            \"on the command line\");\n+            end if;\n+\n             declare\n                Value : String_List_Id := Projects.Table (Main_Project).Mains;\n \n@@ -3669,7 +3713,8 @@ package body Make is\n                            At_Least_One_Main := True;\n                            Osint.Add_File\n                              (Get_Name_String\n-                                (String_Elements.Table (Value).Value));\n+                                (String_Elements.Table (Value).Value),\n+                              Index => String_Elements.Table (Value).Index);\n                         end if;\n \n                         Value := String_Elements.Table (Value).Next;\n@@ -3743,6 +3788,10 @@ package body Make is\n \n       Main_Source_File := Next_Main_Source;\n \n+      if Current_File_Index /= No_Index then\n+         Main_Index := Current_File_Index;\n+      end if;\n+\n       Add_Switch (\"-I-\", Binder, And_Save => True);\n       Add_Switch (\"-I-\", Compiler, And_Save => True);\n \n@@ -3935,6 +3984,7 @@ package body Make is\n \n                   Add_Switches\n                     (File_Name   => Main_Unit_File_Name,\n+                     Index       => Main_Index,\n                      The_Package => Builder_Package,\n                      Program     => None);\n \n@@ -3949,6 +3999,7 @@ package body Make is\n                      Defaults : constant Variable_Value :=\n                        Prj.Util.Value_Of\n                          (Name                    => Name_Ada,\n+                          Index                   => 0,\n                           Attribute_Or_Array_Name => Name_Default_Switches,\n                           In_Package              => Builder_Package);\n \n@@ -3973,6 +4024,7 @@ package body Make is\n \n                         Add_Switches\n                           (File_Name   => \" \",\n+                           Index       => 0,\n                            The_Package => Builder_Package,\n                            Program     => None);\n \n@@ -4010,6 +4062,7 @@ package body Make is\n \n                Add_Switches\n                  (File_Name   => Main_Unit_File_Name,\n+                  Index       => Main_Index,\n                   The_Package => Binder_Package,\n                   Program     => Binder);\n             end if;\n@@ -4025,6 +4078,7 @@ package body Make is\n \n                Add_Switches\n                  (File_Name   => Main_Unit_File_Name,\n+                  Index       => Main_Index,\n                   The_Package => Linker_Package,\n                   Program     => Linker);\n             end if;\n@@ -4256,6 +4310,8 @@ package body Make is\n \n       Bad_Compilation.Init;\n \n+      Current_Main_Index := Main_Index;\n+\n       --  Here is where the make process is started\n \n       --  We do the same process for each main\n@@ -4312,7 +4368,7 @@ package body Make is\n                --  \"main.2.ada\", when the body termination is \".2.ada\".\n \n                Executable := Prj.Util.Executable_Of\n-                                        (Main_Project, Main_Source_File);\n+                               (Main_Project, Main_Source_File, Main_Index);\n             end if;\n          end if;\n \n@@ -4380,6 +4436,7 @@ package body Make is\n                   Most_Recent_Obj_File  => Youngest_Obj_File,\n                   Most_Recent_Obj_Stamp => Youngest_Obj_Stamp,\n                   Main_Unit             => Is_Main_Unit,\n+                  Main_Index            => Current_Main_Index,\n                   Compilation_Failures  => Compilation_Failures,\n                   Check_Readonly_Files  => Check_Readonly_Files,\n                   Do_Not_Execute        => Do_Not_Execute,\n@@ -4629,7 +4686,7 @@ package body Make is\n \n          begin\n             Src_File      := Strip_Directory (Main_Source_File);\n-            ALI_File      := Lib_File_Name (Src_File);\n+            ALI_File      := Lib_File_Name (Src_File, Current_Main_Index);\n             Main_ALI_File := Full_Lib_File_Name (ALI_File);\n \n             --  When In_Place_Mode, the library file can be located in the\n@@ -5164,6 +5221,10 @@ package body Make is\n          if N_File < Osint.Number_Of_Files then\n             Main_Source_File := Next_Main_Source;\n \n+            if Current_File_Index /= No_Index then\n+               Main_Index := Current_File_Index;\n+            end if;\n+\n             if Main_Project /= No_Project then\n \n                --  Find the file name of the main unit\n@@ -5249,6 +5310,7 @@ package body Make is\n \n                      Add_Switches\n                        (File_Name   => Main_Unit_File_Name,\n+                        Index       => Main_Index,\n                         The_Package => Binder_Package,\n                         Program     => Binder);\n                   end if;\n@@ -5265,6 +5327,7 @@ package body Make is\n \n                      Add_Switches\n                        (File_Name   => Main_Unit_File_Name,\n+                        Index       => Main_Index,\n                         The_Package => Linker_Package,\n                         Program     => Linker);\n                   end if;\n@@ -5317,17 +5380,10 @@ package body Make is\n             end if;\n          end if;\n \n-         --  Increase the marking label to be sure to check sources\n-         --  for all executables.\n+         --  Remove all marks to be sure to check sources for all executables,\n+         --  as the switches may be different and -s may be in use.\n \n-         Marking_Label := Marking_Label + 1;\n-\n-         --  Make sure it is not 0, which is the default value for\n-         --  a file that has never been marked.\n-\n-         if Marking_Label = 0 then\n-            Marking_Label := 1;\n-         end if;\n+         Delete_All_Marks;\n       end loop Multiple_Main_Loop;\n \n       if Failed_Links.Last > 0 then\n@@ -5657,9 +5713,6 @@ package body Make is\n \n       Project_Object_Directory := No_Project;\n \n-      --  Set the marking label to a value that is not zero\n-\n-      Marking_Label := 1;\n    end Initialize;\n \n    ----------------------------\n@@ -5828,18 +5881,27 @@ package body Make is\n \n    procedure Insert_Q\n      (Source_File : File_Name_Type;\n-      Source_Unit : Unit_Name_Type := No_Name)\n+      Source_Unit : Unit_Name_Type := No_Name;\n+      Index       : Int            := 0)\n    is\n    begin\n       if Debug.Debug_Flag_Q then\n          Write_Str (\"   Q := Q + [ \");\n          Write_Name (Source_File);\n+\n+         if Index /= 0 then\n+            Write_Str (\", \");\n+            Write_Int (Index);\n+         end if;\n+\n          Write_Str (\" ] \");\n          Write_Eol;\n       end if;\n \n-      Q.Table (Q.Last).File := Source_File;\n-      Q.Table (Q.Last).Unit := Source_Unit;\n+      Q.Table (Q.Last) :=\n+        (File  => Source_File,\n+         Unit  => Source_Unit,\n+         Index => Index);\n       Q.Increment_Last;\n    end Insert_Q;\n \n@@ -5963,15 +6025,6 @@ package body Make is\n       return True;\n    end Is_In_Object_Directory;\n \n-   ---------------\n-   -- Is_Marked --\n-   ---------------\n-\n-   function Is_Marked (Source_File : File_Name_Type) return Boolean is\n-   begin\n-      return Get_Name_Table_Byte (Source_File) = Marking_Label;\n-   end Is_Marked;\n-\n    ----------\n    -- Link --\n    ----------\n@@ -6085,14 +6138,15 @@ package body Make is\n       Set_Standard_Error;\n    end List_Depend;\n \n-   ----------\n-   -- Mark --\n-   ----------\n+   -----------------\n+   -- Make_Failed --\n+   -----------------\n \n-   procedure Mark (Source_File : File_Name_Type) is\n+   procedure Make_Failed (S1 : String; S2 : String := \"\"; S3 : String := \"\") is\n    begin\n-      Set_Name_Table_Byte (Source_File, Marking_Label);\n-   end Mark;\n+      Delete_All_Temp_Files;\n+      Osint.Fail (S1, S2, S3);\n+   end Make_Failed;\n \n    --------------------\n    -- Mark_Directory --\n@@ -6755,6 +6809,7 @@ package body Make is\n             --  or one character switches which are not in 'a' .. 'z'\n             --  (except 'C', 'F', 'M' and 'B') are passed to the compiler,\n             --  unless we are dealing with a debug switch (starts with 'd')\n+            --  or an extended gnatmake switch (starts with 'e').\n \n          elsif Argv (2) /= 'd'\n            and then Argv (2) /= 'e'\n@@ -6787,6 +6842,7 @@ package body Make is\n    function Switches_Of\n      (Source_File      : Name_Id;\n       Source_File_Name : String;\n+      Source_Index     : Int;\n       Naming           : Naming_Data;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value\n@@ -6808,8 +6864,9 @@ package body Make is\n    begin\n       Switches :=\n         Prj.Util.Value_Of\n-        (Index => Source_File,\n-         In_Array => Switches_Array);\n+          (Index     => Source_File,\n+           Src_Index => Source_Index,\n+           In_Array  => Switches_Array);\n \n       if Switches = Nil_Variable_Value then\n          declare\n@@ -6846,8 +6903,9 @@ package body Make is\n                Name_Buffer (1 .. Name_Len) := Name (1 .. Last);\n                Switches :=\n                  Prj.Util.Value_Of\n-                 (Index => Name_Find,\n-                  In_Array => Switches_Array);\n+                   (Index     => Name_Find,\n+                    Src_Index => 0,\n+                    In_Array  => Switches_Array);\n \n                if Switches = Nil_Variable_Value\n                  and then Allow_ALI\n@@ -6863,16 +6921,20 @@ package body Make is\n                   Name_Buffer (1 .. Name_Len) := Name (1 .. Name_Len);\n                   Switches :=\n                     Prj.Util.Value_Of\n-                       (Index => Name_Find,\n-                        In_Array => Switches_Array);\n+                      (Index     => Name_Find,\n+                       Src_Index => 0,\n+                       In_Array  => Switches_Array);\n                end if;\n             end if;\n          end;\n       end if;\n \n       if Switches = Nil_Variable_Value then\n-         Switches := Prj.Util.Value_Of\n-                                (Index => Name_Ada, In_Array => Defaults);\n+         Switches :=\n+           Prj.Util.Value_Of\n+             (Index     => Name_Ada,\n+              Src_Index => 0,\n+              In_Array  => Defaults);\n       end if;\n \n       return Switches;"}, {"sha": "9fcdf6d3842723b26e9ba3f45ddfdd96b520c5ff", "filename": "gcc/ada/make.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmake.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmake.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -112,6 +112,7 @@ package Make is\n       Most_Recent_Obj_Stamp : out Time_Stamp_Type;\n       Main_Unit             : out Boolean;\n       Compilation_Failures  : out Natural;\n+      Main_Index            : Int      := 0;\n       Check_Readonly_Files  : Boolean  := False;\n       Do_Not_Execute        : Boolean  := False;\n       Force_Compilations    : Boolean  := False;\n@@ -148,6 +149,10 @@ package Make is\n    --    Compilation_Failures is a count of compilation failures. This count\n    --    is used to extract compilation failure reports with Extract_Failure.\n    --\n+   --    Main_Index, when not zero, is the index of the main unit in source\n+   --    file Main_Source which is a multi-unit source.\n+   --    Zero indicates that Main_Source is a single unit source file.\n+   --\n    --    Check_Readonly_Files set it to True to compile source files\n    --    which library files are read-only. When compiling GNAT predefined\n    --    files the \"-gnatg\" flag is used."}, {"sha": "a881bc30d490362e26bf2d21c6f5571a1c013446", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 140, "deletions": 93, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -178,7 +178,6 @@ package body Makegpr is\n    Options : array (Programming_Language) of Comp_Opts.Instance;\n    --  Tables to store compiling options for the different compilers\n \n-\n    package Linker_Options is new Table.Table\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Integer,\n@@ -354,9 +353,9 @@ package body Makegpr is\n    --  or Linker (depending on Proc) of a specified project file.\n \n    procedure Build_Archive (Project : Project_Id; Unconditionally : Boolean);\n-   --  Build the archive for a specified project.\n-   --  If Unconditionally is False, first check if the archive is up to date,\n-   --  and build it only if it is not.\n+   --  Build the archive for a specified project. If Unconditionally is\n+   --  False, first check if the archive is up to date, and build it only\n+   --  if it is not.\n \n    procedure Check_Compilation_Needed\n      (Source          : Other_Source;\n@@ -369,7 +368,7 @@ package body Makegpr is\n \n    procedure Compile\n      (Source_Id    : Other_Source_Id;\n-      Data         : in Project_Data;\n+      Data         : Project_Data;\n       Local_Errors : in out Boolean);\n \n    procedure Compile_Individual_Sources;\n@@ -378,9 +377,8 @@ package body Makegpr is\n \n    procedure Compile_Link_With_Gnatmake (Mains_Specified : Boolean);\n    --  Compile/Link with gnatmake when there are Ada sources in the main\n-   --  project.\n-   --  Arguments may already contain options to be used by gnatmake.\n-   --  Used for both Ada mains and mains of other languages.\n+   --  project. Arguments may already contain options to be used by\n+   --  gnatmake. Used for both Ada mains and mains of other languages.\n    --  When Compile_Only is True, do not use the linking options\n \n    procedure Compile_Sources;\n@@ -390,7 +388,9 @@ package body Makegpr is\n    --  Output the Copyright notice\n \n    procedure Create_Archive_Dependency_File\n-     (Name : String; First_Source : Other_Source_Id);\n+     (Name         : String;\n+      First_Source : Other_Source_Id);\n+   --  ??? needs comment\n \n    procedure Display_Command (Name : String; Path : String_Access);\n    --  Display the command for a spawned process, if in Verbose_Mode or\n@@ -431,6 +431,7 @@ package body Makegpr is\n    --  Process one command line argument\n \n    function Strip_CR_LF (Text : String) return String;\n+   --  Needs comment ???\n \n    procedure Usage;\n    --  Display the usage\n@@ -467,6 +468,7 @@ package body Makegpr is\n             --  Nothing to do if the project has already been processed\n \n             if not Data.Seen then\n+\n                --  Mark the project as processed, to avoid processing it again\n \n                Projects.Table (Project).Seen := True;\n@@ -496,6 +498,7 @@ package body Makegpr is\n \n                if Data.Sources_Present then\n                   if Data.Library then\n+\n                      --  If it is a library project file, nothing to do if\n                      --  gnatmake will be invoked, because gnatmake will take\n                      --  care of it, even if the library is not an Ada library.\n@@ -633,16 +636,20 @@ package body Makegpr is\n       --  Nothing to do if no argument is specified or if argument is empty\n \n       if Arg /= null or else Arg'Length = 0 then\n+\n          --  Reallocate arrays if necessary\n \n          if Last_Argument = Arguments'Last then\n             declare\n                New_Arguments : constant Argument_List_Access :=\n-                 new Argument_List\n-                   (1 .. Last_Argument + Initial_Argument_Count);\n+                                 new Argument_List\n+                                   (1 .. Last_Argument +\n+                                           Initial_Argument_Count);\n+\n                New_Arguments_Displayed : constant Booleans :=\n-                 new Boolean_Array\n-                   (1 .. Last_Argument + Initial_Argument_Count);\n+                                           new Boolean_Array\n+                                             (1 .. Last_Argument +\n+                                                     Initial_Argument_Count);\n \n             begin\n                New_Arguments (Arguments'Range) := Arguments.all;\n@@ -672,6 +679,7 @@ package body Makegpr is\n \n    procedure Add_Argument (Arg : String; Display : Boolean) is\n       Argument : String_Access := null;\n+\n    begin\n       --  Nothing to do if argument is empty\n \n@@ -750,18 +758,21 @@ package body Makegpr is\n \n    procedure Add_Option (Arg : String) is\n       Option : constant String_Access := new String'(Arg);\n+\n    begin\n       case Current_Processor is\n          when None =>\n             null;\n \n          when Linker =>\n+\n             --  Add option to the linker table\n \n             Linker_Options.Increment_Last;\n             Linker_Options.Table (Linker_Options.Last) := Option;\n \n          when Compiler =>\n+\n             --  Add option to the compiler option table, depending on the\n             --  value of Current_Language.\n \n@@ -783,8 +794,9 @@ package body Makegpr is\n       if Last_Source = Source_Indexes'Last then\n          declare\n             New_Indexes : constant Source_Indexes_Ref :=\n-              new Source_Index_Array\n-                (1 .. Source_Indexes'Last + Initial_Source_Index_Count);\n+                            new Source_Index_Array\n+                              (1 .. Source_Indexes'Last +\n+                                      Initial_Source_Index_Count);\n          begin\n             New_Indexes (Source_Indexes'Range) := Source_Indexes.all;\n             Free (Source_Indexes);\n@@ -801,7 +813,8 @@ package body Makegpr is\n    ----------------------------\n \n    procedure Add_Search_Directories\n-     (Data : Project_Data; Language : Programming_Language)\n+     (Data     : Project_Data;\n+      Language : Programming_Language)\n    is\n    begin\n       --  If a GNU compiler is used, set the CPATH environment variable,\n@@ -858,15 +871,17 @@ package body Makegpr is\n       end case;\n \n       --  Get the Switches (\"file name\"), if they exist\n+\n       Switches_Array := Prj.Util.Value_Of\n         (Name      => Name_Switches,\n          In_Arrays =>\n            Packages.Table (Pkg).Decl.Arrays);\n \n       Switches :=\n         Prj.Util.Value_Of\n-          (Index => File_Name,\n-           In_Array => Switches_Array);\n+          (Index     => File_Name,\n+           Src_Index => 0,\n+           In_Array  => Switches_Array);\n \n       --  Otherwise, get the Default_Switches (\"language\"), if they exist\n \n@@ -875,8 +890,9 @@ package body Makegpr is\n            (Name      => Name_Default_Switches,\n             In_Arrays => Packages.Table (Pkg).Decl.Arrays);\n          Switches := Prj.Util.Value_Of\n-           (Index    => Lang_Name_Ids (Language),\n-            In_Array => Defaults);\n+           (Index     => Lang_Name_Ids (Language),\n+            Src_Index => 0,\n+            In_Array  => Defaults);\n       end if;\n \n       --  If there are switches, add them to Arguments\n@@ -923,6 +939,7 @@ package body Makegpr is\n       Time_Stamp  : Time_Stamp_Type;\n \n       Saved_Last_Argument : Natural;\n+\n    begin\n       --  First, make sure that the archive builder (ar) is on the path\n \n@@ -961,6 +978,8 @@ package body Makegpr is\n                Write_Line (\"      -> archive does not exist\");\n             end if;\n \n+         --  Archive does exist\n+\n          else\n             --  Check the archive dependency file\n \n@@ -1000,8 +1019,7 @@ package body Makegpr is\n                   Object_Name := Name_Find;\n                   Source_Id := No_Other_Source;\n \n-                  --  Check if this object file is for a source of this\n-                  --  project.\n+                  --  Check if this object file is for a source of this project\n \n                   for S in 1 .. Last_Source loop\n                      if (not Source_Indexes (S).Found) and then\n@@ -1088,6 +1106,7 @@ package body Makegpr is\n                Close (File);\n \n                if not Need_To_Rebuild then\n+\n                   --  Now, check if all object files of the project have been\n                   --  accounted for. If any of them is not in the dependency\n                   --  file, the archive needs to be rebuilt.\n@@ -1120,6 +1139,7 @@ package body Makegpr is\n       --  Build the archive if necessary\n \n       if Need_To_Rebuild then\n+\n          --  If an archive is built, then linking will need to occur\n          --  unconditionally.\n \n@@ -1131,10 +1151,12 @@ package body Makegpr is\n          --  in the library directory.\n \n          if Data.Library then\n+\n             --  If there are sources in Ada, then gnatmake will build the\n             --  library, so nothing to do.\n \n             if not Data.Languages (Lang_Ada) then\n+\n                --  Get all the object files of the project\n \n                Source_Id := Data.First_Other_Source;\n@@ -1174,13 +1196,11 @@ package body Makegpr is\n                end if;\n             end if;\n \n-            --  Create a fake empty archive, to be able to check its time stamp\n-            --  later.\n+            --  Create fake empty archive, so we can check its time stamp later\n \n             declare\n                Archive : Ada.Text_IO.File_Type;\n                use Ada.Text_IO;\n-\n             begin\n                Create (Archive, Out_File, Archive_Name);\n                Close (Archive);\n@@ -1239,6 +1259,7 @@ package body Makegpr is\n          end loop;\n \n          if Success then\n+\n             --  If the archive was built, run the archive indexer (ranlib),\n             --  if there is one.\n \n@@ -1251,6 +1272,7 @@ package body Makegpr is\n                Spawn (Archive_Indexer_Path.all, Arguments (1 .. 1), Success);\n \n                if not Success then\n+\n                   --  Running ranlib failed, delete the dependency file,\n                   --  if it exists.\n \n@@ -1309,7 +1331,9 @@ package body Makegpr is\n       --  object file.\n \n       Dep_File : Prj.Util.Text_File;\n-      Start, Finish : Natural;\n+      Start    : Natural;\n+      Finish   : Natural;\n+\n    begin\n       --  Assume the worst, so that statement \"return;\" may be used if there\n       --  is any problem.\n@@ -1378,8 +1402,7 @@ package body Makegpr is\n \n       Open (Dep_File, Dep_Name);\n \n-      --  If the dependency file cannot be open, we need to recompile the\n-      --  source.\n+      --  If dependency file cannot be open, we need to recompile the source\n \n       if not Is_Valid (Dep_File) then\n          if Verbose_Mode then\n@@ -1392,6 +1415,7 @@ package body Makegpr is\n \n       declare\n          End_Of_File_Reached : Boolean := False;\n+\n       begin\n          loop\n             if End_Of_File (Dep_File) then\n@@ -1445,8 +1469,10 @@ package body Makegpr is\n             declare\n                Line : constant String := Name_Buffer (1 .. Name_Len);\n                Last : constant Natural := Name_Len;\n+\n             begin\n                Name_Loop : loop\n+\n                   --  Find the beginning of the next source path name\n \n                   while Start < Last and then Line (Start) = ' ' loop\n@@ -1484,13 +1510,13 @@ package body Makegpr is\n \n                   declare\n                      Src_Name : constant String :=\n-                       Normalize_Pathname\n-                         (Name => Line (Start .. Finish),\n-                          Case_Sensitive => False);\n+                                  Normalize_Pathname\n+                                    (Name           => Line (Start .. Finish),\n+                                     Case_Sensitive => False);\n                      Src_TS   : Time_Stamp_Type;\n+\n                   begin\n-                     --  If it is the original source,\n-                     --  set Source_In_Dependencies.\n+                     --  If it is original source, set Source_In_Dependencies\n \n                      if Src_Name = Source_Path then\n                         Source_In_Dependencies := True;\n@@ -1599,6 +1625,7 @@ package body Makegpr is\n    is\n       Source  : Other_Source := Other_Sources.Table (Source_Id);\n       Success : Boolean;\n+\n    begin\n       --  If the compiler is not know yet, get its path name\n \n@@ -1668,6 +1695,7 @@ package body Makegpr is\n \n                   declare\n                      S : constant String := Strip_CR_LF (Expect_Out (FD));\n+\n                   begin\n                      --  Each line of the output is put in the dependency\n                      --  file, including errors. If there are errors, the\n@@ -1679,22 +1707,24 @@ package body Makegpr is\n                   end;\n                end loop;\n \n-               --  If we are here, it means we had a timeout.\n-               --  So, the dependency file may be incomplete: it is safer to\n+               --  If we are here, it means we had a timeout, so the\n+               --  dependency file may be incomplete. It is safer to\n                --  delete it, otherwise the dependencies may be wrong.\n \n                Close (FD, Status);\n                Close (Dep_File);\n                Delete_File (Get_Name_String (Source.Dep_Name), Success);\n \n             exception\n-               when Process_Died =>\n-                  --  This is the normal outcome. Just close the file.\n+            when Process_Died =>\n+\n+                  --  This is the normal outcome. Just close the file\n \n                   Close (FD, Status);\n                   Close (Dep_File);\n \n-               when others =>\n+            when others =>\n+\n                   --  Something wrong happened. It is safer to delete the\n                   --  dependency file, otherwise the dependencies may be wrong.\n \n@@ -1719,10 +1749,9 @@ package body Makegpr is\n \n       Last_Argument := 0;\n \n-      --  For GCC compilers, make sure the language is always\n-      --  specified to the GCC driver, in case the extension is\n-      --  not recognized by the GCC driver as a source of the\n-      --  language.\n+      --  For GCC compilers, make sure the language is always specified to\n+      --  to the GCC driver, in case the extension is not recognized by the\n+      --  GCC driver as a source of the language.\n \n       if Compiler_Is_Gcc (Source.Language) then\n          Add_Argument (Dash_x, Verbose_Mode);\n@@ -1731,13 +1760,14 @@ package body Makegpr is\n       end if;\n \n       --  Specify the source to be compiled\n+\n       Add_Argument (Dash_c, True);\n       Add_Argument (Get_Name_String (Source.Path_Name), True);\n \n-      --  If it is a non static library project, compile with the PIC option\n-      --  if there is one (when there is no PIC option, function\n-      --  MLib.Tgt.PIC_Option returns an empty string, and Add_Argument with\n-      --  an empty string has no effect).\n+      --  If non static library project, compile with the PIC option if there\n+      --  is one (when there is no PIC option, function MLib.Tgt.PIC_Option\n+      --  returns an empty string, and Add_Argument with an empty string has\n+      --  no effect).\n \n       if Data.Library and then Data.Library_Kind /= Static then\n          Add_Argument (PIC_Option, True);\n@@ -1790,6 +1820,7 @@ package body Makegpr is\n          Success);\n \n       if Success then\n+\n          --  Compilation was successful, update the time stamp\n          --  of the object file.\n \n@@ -1812,8 +1843,7 @@ package body Makegpr is\n                \" has not been modified\");\n \n          else\n-            --  Everything looks fine, update the Other_Sources\n-            --  table.\n+            --  Everything looks fine, update the Other_Sources table\n \n             Other_Sources.Table (Source_Id) := Source;\n          end if;\n@@ -1832,13 +1862,15 @@ package body Makegpr is\n    --------------------------------\n \n    procedure Compile_Individual_Sources is\n-      Data      : Project_Data := Projects.Table (Main_Project);\n-      Source_Id : Other_Source_Id;\n-      Source    : Other_Source;\n-      Source_Name : Name_Id;\n+      Data         : Project_Data := Projects.Table (Main_Project);\n+      Source_Id    : Other_Source_Id;\n+      Source       : Other_Source;\n+      Source_Name  : Name_Id;\n       Project_Name : String := Get_Name_String (Data.Name);\n       Dummy        : Boolean := False;\n+\n       Ada_Is_A_Language : constant Boolean := Data.Languages (Lang_Ada);\n+\n    begin\n       Ada_Mains.Init;\n \n@@ -1914,6 +1946,7 @@ package body Makegpr is\n       end if;\n \n       if Ada_Mains.Last > 0 then\n+\n          --  Invoke gnatmake for all sources that are not of a non Ada language\n \n          Last_Argument := 0;\n@@ -1933,8 +1966,9 @@ package body Makegpr is\n    --------------------------------\n \n    procedure Compile_Link_With_Gnatmake (Mains_Specified : Boolean) is\n-      Data : constant Project_Data := Projects.Table (Main_Project);\n+      Data    : constant Project_Data := Projects.Table (Main_Project);\n       Success : Boolean;\n+\n    begin\n       --  Array Arguments may already contain some arguments, so we don't\n       --  set Last_Argument to 0.\n@@ -2074,9 +2108,8 @@ package body Makegpr is\n       Source       : Other_Source;\n \n       Local_Errors : Boolean := False;\n-      --  Set to True when there is a compilation error.\n-      --  Used only when Keep_Going is True, to inhibit the building of the\n-      --  archive.\n+      --  Set to True when there is a compilation error. Used only when\n+      --  Keep_Going is True, to inhibit the building of the archive.\n \n       Need_To_Compile : Boolean;\n       --  Set to True when a source needs to be compiled/recompiled.\n@@ -2092,6 +2125,7 @@ package body Makegpr is\n          Data := Projects.Table (Project);\n \n          if not Data.Virtual then\n+\n             --  If the imported directory switches are unknown, compute them\n \n             if not Data.Include_Data_Set then\n@@ -2100,8 +2134,7 @@ package body Makegpr is\n                Projects.Table (Project) := Data;\n             end if;\n \n-            --  Nothing to do when there are no sources of language other than\n-            --  Ada.\n+            --  Nothing to do when no sources of language other than Ada\n \n             if Data.Sources_Present then\n                Need_To_Rebuild_Archive := Force_Compilations;\n@@ -2116,7 +2149,6 @@ package body Makegpr is\n \n                while Source_Id /= No_Other_Source loop\n                   Source := Other_Sources.Table (Source_Id);\n-\n                   Need_To_Compile := Force_Compilations;\n \n                   --  Check if compilation is needed\n@@ -2128,11 +2160,11 @@ package body Makegpr is\n                   --  Proceed, if compilation is needed\n \n                   if Need_To_Compile then\n+\n                      --  If a source is compiled/recompiled, of course the\n                      --  archive will need to be built/rebuilt.\n \n                      Need_To_Rebuild_Archive := True;\n-\n                      Compile (Source_Id, Data, Local_Errors);\n                   end if;\n \n@@ -2175,11 +2207,12 @@ package body Makegpr is\n    ------------------------------------\n \n    procedure Create_Archive_Dependency_File\n-     (Name : String; First_Source : Other_Source_Id)\n+     (Name         : String;\n+      First_Source : Other_Source_Id)\n    is\n       Source_Id : Other_Source_Id := First_Source;\n       Source    : Other_Source;\n-      Dep_File : Ada.Text_IO.File_Type;\n+      Dep_File  : Ada.Text_IO.File_Type;\n       use Ada.Text_IO;\n \n    begin\n@@ -2246,14 +2279,18 @@ package body Makegpr is\n       --  The id of the package IDE in the project file\n \n       Compiler : constant Variable_Value :=\n-        Value_Of (Lang_Name_Ids (For_Language), Name_Compiler_Command, Ide);\n-      --  The value of Compiler_Command (\"language\") in package IDE, if it is\n-      --  defined.\n+        Value_Of\n+          (Name                    => Lang_Name_Ids (For_Language),\n+           Index                   => 0,\n+           Attribute_Or_Array_Name => Name_Compiler_Command,\n+           In_Package              => Ide);\n+      --  The value of Compiler_Command (\"language\") in package IDE, if defined\n \n    begin\n       --  No need to do it again if the compiler is known for this language\n \n       if Compiler_Names (For_Language) = null then\n+\n          --  If compiler command is not defined for this language in package\n          --  IDE, use the default compiler for this language.\n \n@@ -2266,8 +2303,7 @@ package body Makegpr is\n               new String'(Get_Name_String (Compiler.Value));\n          end if;\n \n-         --  Check if compiler is a GCC compiler: its name end with \"gcc\" or\n-         --  \"g++\".\n+         --  Check we have a GCC compiler (name ends with \"gcc\" or \"g++\")\n \n          declare\n             Comp_Name : constant String := Compiler_Names (For_Language).all;\n@@ -2277,7 +2313,6 @@ package body Makegpr is\n                Last3 := Comp_Name (Comp_Name'Last - 2 .. Comp_Name'Last);\n                Compiler_Is_Gcc (For_Language) :=\n                  (Last3 = \"gcc\") or (Last3 = \"g++\");\n-\n             else\n                Compiler_Is_Gcc (For_Language) := False;\n             end if;\n@@ -2315,6 +2350,7 @@ package body Makegpr is\n       Data    : in out Project_Data)\n    is\n       Imported_Projects : Project_List := Data.Imported_Projects;\n+\n       Path_Length : Natural := 0;\n       Position    : Natural := 0;\n \n@@ -2380,8 +2416,9 @@ package body Makegpr is\n       ------------------------\n \n       procedure Recursive_Get_Dirs (Prj : Project_Id) is\n-         Data : Project_Data;\n+         Data     : Project_Data;\n          Imported : Project_List;\n+\n       begin\n          --  Nothing to do if project is undefined\n \n@@ -2391,6 +2428,7 @@ package body Makegpr is\n             --  Nothing to do if project has already been processed\n \n             if not Data.Seen then\n+\n                --  Mark the project as processed, to avoid multiple processing\n                --  of the same project.\n \n@@ -2427,8 +2465,7 @@ package body Makegpr is\n \n       Last_Argument := 0;\n \n-      --  Process this project individually, the project data are already\n-      --  known.\n+      --  Process this project individually, project data are already known\n \n       Projects.Table (Project).Seen := True;\n \n@@ -2518,7 +2555,6 @@ package body Makegpr is\n          end if;\n \n       else\n-\n          --  First compile sources and build archives, if necessary\n \n          Compile_Sources;\n@@ -2676,6 +2712,7 @@ package body Makegpr is\n \n                File : Ada.Text_IO.File_Type;\n                use Ada.Text_IO;\n+\n             begin\n                Create (File, Out_File, Cpp_Linker);\n \n@@ -2693,11 +2730,8 @@ package body Makegpr is\n          end if;\n       end Choose_C_Plus_Plus_Link_Process;\n \n-\n-\n    begin\n-      --  If no mains were specified, get the mains from attribute Main, if\n-      --  it exists.\n+      --  If no mains specified, get mains from attribute Main, if it exists\n \n       if not Mains_Specified then\n          declare\n@@ -2844,6 +2878,7 @@ package body Makegpr is\n                           (Executable_Of\n                              (Project  => Main_Project,\n                               Main     => Other_Mains.Table (Main).File_Name,\n+                              Index    => 0,\n                               Ada_Main => False)),\n                         True);\n                   end if;\n@@ -2959,24 +2994,30 @@ package body Makegpr is\n                         Executable_Name : constant String :=\n                           Get_Name_String\n                             (Executable_Of\n-                                 (Main_Project, Main_Id, Ada_Main => False));\n+                                 (Project  => Main_Project,\n+                                  Main     => Main_Id,\n+                                  Index    => 0,\n+                                  Ada_Main => False));\n                         --  File name of the executable\n \n                         Executable_Path : constant String :=\n-                          Get_Name_String (Data.Exec_Directory) &\n-                        Directory_Separator & Executable_Name;\n+                                            Get_Name_String\n+                                              (Data.Exec_Directory) &\n+                                            Directory_Separator &\n+                                            Executable_Name;\n                         --  Path name of the executable\n \n                         Exec_Time_Stamp : Time_Stamp_Type;\n-                     begin\n \n+                     begin\n                         --  Now, check if the executable is up to date.\n                         --  It is considered up to date if its time stamp is\n                         --  not earlier that the time stamp of any archive.\n                         --  Only do that if we don't know if we need to link.\n \n                         if not Need_To_Relink then\n-                           --  Get the time stamp of the excutable\n+\n+                           --  Get the time stamp of the executable\n \n                            Name_Len := 0;\n                            Add_Str_To_Name_Buffer (Executable_Path);\n@@ -3003,6 +3044,7 @@ package body Makegpr is\n \n                               declare\n                                  Prj_Data : Project_Data;\n+\n                               begin\n                                  for Prj in 1 .. Projects.Last loop\n                                     Prj_Data := Projects.Table (Prj);\n@@ -3052,7 +3094,6 @@ package body Makegpr is\n                               end;\n                            end if;\n \n-\n                            --  If Need_To_Relink is False, we are done\n \n                            if Verbose_Mode and (not Need_To_Relink) then\n@@ -3076,7 +3117,10 @@ package body Makegpr is\n                               Directory_Separator &\n                               Get_Name_String\n                                 (Executable_Of\n-                                   (Main_Project, Main_Id, Ada_Main => False)),\n+                                   (Project  => Main_Project,\n+                                    Main     => Main_Id,\n+                                    Index    => 0,\n+                                    Ada_Main => False)),\n                               True);\n \n                            --  Specify the object file of the main source\n@@ -3156,7 +3200,10 @@ package body Makegpr is\n                      Write_Str\n                        (Get_Name_String\n                           (Executable_Of\n-                             (Main_Project, Main_Id, Ada_Main => False)));\n+                             (Project  => Main_Project,\n+                              Main     => Main_Id,\n+                              Index    => 0,\n+                              Ada_Main => False)));\n                      Write_Line (\"\"\" up to date\");\n                   end;\n \n@@ -3173,10 +3220,12 @@ package body Makegpr is\n    ------------------\n \n    procedure Report_Error\n-     (S1 : String; S2 : String := \"\"; S3 : String := \"\")\n+     (S1 : String;\n+      S2 : String := \"\";\n+      S3 : String := \"\")\n    is\n    begin\n-      --  If keep_Going is True, output the error message, preceded by the\n+      --  If Keep_Going is True, output the error message, preceded by the\n       --  error header.\n \n       if Keep_Going then\n@@ -3231,7 +3280,6 @@ package body Makegpr is\n       if Project_File_Name_Expected then\n          if Arg (1) = '-' then\n             Osint.Fail (\"project file name missing after -P\");\n-\n          else\n             Project_File_Name_Expected := False;\n             Project_File_Name := new String'(Arg);\n@@ -3243,7 +3291,6 @@ package body Makegpr is\n       elsif Output_File_Name_Expected then\n          if Arg (1) = '-' then\n             Osint.Fail (\"output file name missing after -o\");\n-\n          else\n             Output_File_Name_Expected := False;\n             Output_File_Name := new String'(Arg);\n@@ -3255,10 +3302,11 @@ package body Makegpr is\n \n       elsif Arg'Length >= 6 and then\n          Arg (Arg'First .. Arg'First + 1) = \"-c\" and then\n-         Arg (Arg'Last - 3 .. Arg'Last) = \"args\"\n+      Arg (Arg'Last - 3 .. Arg'Last) = \"args\"\n+\n       then\n          declare\n-            OK : Boolean := False;\n+            OK          : Boolean := False;\n             Args_String : constant String :=\n                             Arg (Arg'First + 2 .. Arg'Last - 4);\n \n@@ -3287,9 +3335,8 @@ package body Makegpr is\n       elsif Arg = \"-gargs\" then\n          Current_Processor := None;\n \n-      --  A special test is needed for the -o switch within a -largs\n-      --  since that is another way to specify the name of the final\n-      --  executable.\n+      --  A special test is needed for the -o switch within a -largs since\n+      --  that is another way to specify the name of the final executable.\n \n       elsif Current_Processor = Linker and then Arg = \"-o\" then\n          Osint.Fail"}, {"sha": "268f75492eb898ae2e4f082e872b95ddb2f92eee", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -88,6 +88,11 @@ begin\n    Write_Str (\"  -D dir   Specify dir as the object directory\");\n    Write_Eol;\n \n+   --  Line for -eI\n+\n+   Write_Str (\"  -eI      Index of unit in multi-unit source file\");\n+   Write_Eol;\n+\n    --  Line for -eL\n \n    Write_Str (\"  -eL      Follow symbolic links when processing \" &"}, {"sha": "eb92cd76dafb3bbc9d640358bb593157c54c98a6", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -25,15 +25,40 @@\n ------------------------------------------------------------------------------\n \n with Namet;       use Namet;\n+with Osint;       use Osint;\n with Prj;         use Prj;\n with Prj.Ext;\n with Prj.Util;\n with Snames;      use Snames;\n with Table;\n with Types;       use Types;\n \n+with System.HTable;\n+\n package body Makeutl is\n \n+   type Mark_Key is record\n+      File  : File_Name_Type;\n+      Index : Int;\n+   end record;\n+   --  Identify either a mono-unit source (when Index = 0) or a specific unit\n+   --  in a multi-unit source.\n+\n+   Max_Mask_Num : constant := 2048;\n+\n+   subtype Mark_Num is Union_Id range 0 .. Max_Mask_Num - 1;\n+\n+   function Hash (Key : Mark_Key) return Mark_Num;\n+\n+   package Marks is new System.HTable.Simple_HTable\n+     (Header_Num => Mark_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Mark_Key,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  A hash table to keep tracks of the marked units.\n+\n    type Linker_Options_Data is record\n       Project : Project_Id;\n       Options : String_List_Id;\n@@ -83,6 +108,24 @@ package body Makeutl is\n       end if;\n    end Add_Linker_Option;\n \n+   ----------------------\n+   -- Delete_All_Marks --\n+   ----------------------\n+\n+   procedure Delete_All_Marks is\n+   begin\n+      Marks.Reset;\n+   end Delete_All_Marks;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Key : Mark_Key) return Mark_Num is\n+   begin\n+      return Union_Id (Key.File) mod Max_Mask_Num;\n+   end Hash;\n+\n    ----------------------------\n    -- Is_External_Assignment --\n    ----------------------------\n@@ -124,6 +167,19 @@ package body Makeutl is\n       end if;\n    end Is_External_Assignment;\n \n+   ---------------\n+   -- Is_Marked --\n+   ---------------\n+\n+   function Is_Marked\n+     (Source_File : File_Name_Type;\n+      Index       : Int := 0)\n+      return Boolean\n+   is\n+   begin\n+      return Marks.Get (K => (File => Source_File, Index => Index));\n+   end Is_Marked;\n+\n    -----------------------------\n    -- Linker_Options_Switches --\n    -----------------------------\n@@ -166,6 +222,7 @@ package body Makeutl is\n                   Options :=\n                     Prj.Util.Value_Of\n                       (Name => Name_Ada,\n+                       Index => 0,\n                        Attribute_Or_Array_Name => Name_Linker_Options,\n                        In_Package => Linker_Package);\n \n@@ -305,6 +362,15 @@ package body Makeutl is\n \n    end Mains;\n \n+   ----------\n+   -- Mark --\n+   ----------\n+\n+   procedure Mark (Source_File : File_Name_Type; Index : Int := 0) is\n+   begin\n+      Marks.Set (K => (File => Source_File, Index => Index), E => True);\n+   end Mark;\n+\n    ---------------------------\n    -- Test_If_Relative_Path --\n    ---------------------------\n@@ -384,4 +450,58 @@ package body Makeutl is\n       end if;\n    end Test_If_Relative_Path;\n \n+   -------------------\n+   -- Unit_Index_Of --\n+   -------------------\n+\n+   function Unit_Index_Of (ALI_File : File_Name_Type) return Int is\n+      Start  : Natural;\n+      Finish : Natural;\n+      Result : Int := 0;\n+   begin\n+      Get_Name_String (ALI_File);\n+\n+      --  First, find the last dot\n+\n+      Finish := Name_Len;\n+\n+      while Finish >= 1 and then Name_Buffer (Finish) /= '.' loop\n+         Finish := Finish - 1;\n+      end loop;\n+\n+      if Finish = 1 then\n+         return 0;\n+      end if;\n+\n+      --  Now check that the dot is preceded by digits\n+\n+      Start := Finish;\n+      Finish := Finish - 1;\n+\n+      while Start >= 1 and then Name_Buffer (Start - 1) in '0' .. '9' loop\n+         Start := Start - 1;\n+      end loop;\n+\n+      --  If there is no difits, or if the digits are not preceded by\n+      --  the character that precedes a unit index, this is not the ALI file\n+      --  of a unit in a multi-unit source.\n+\n+      if Start > Finish or else\n+        Start = 1 or else\n+        Name_Buffer (Start - 1) /= Multi_Unit_Index_Character\n+      then\n+         return 0;\n+      end if;\n+\n+      --  Build the index from the digit(s)\n+\n+      while Start <= Finish loop\n+         Result := (Result * 10) + Character'Pos (Name_Buffer (Start))\n+           - Character'Pos ('0');\n+         Start := Start + 1;\n+      end loop;\n+\n+      return Result;\n+   end Unit_Index_Of;\n+\n end Makeutl;"}, {"sha": "b5cfaf7be3d8827fbd369af7dd1c5f0b209cbf6e", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -27,13 +27,17 @@\n with GNAT.OS_Lib; use GNAT.OS_Lib;\n with Osint;\n with Prj;         use Prj;\n+with Types;       use Types;\n \n package Makeutl is\n \n    type Fail_Proc is access procedure\n      (S1 : String; S2 : String := \"\"; S3 : String := \"\");\n    Do_Fail : Fail_Proc := Osint.Fail'Access;\n \n+   function Unit_Index_Of (ALI_File : File_Name_Type) return Int;\n+   --  Find the index of a unit in a source file. Return zero if the file\n+   --  is not a multi-unit source file.\n \n    function Is_External_Assignment (Argv : String) return Boolean;\n    --  Verify that an external assignment switch is syntactically correct.\n@@ -85,4 +89,22 @@ package Makeutl is\n    --  For gnatbind switches, Including_L_Switch is False, because the\n    --  argument of the -L switch is not a path.\n \n+   ----------------------\n+   -- Marking Routines --\n+   ----------------------\n+\n+   procedure Mark (Source_File : File_Name_Type; Index : Int := 0);\n+   --  Mark a unit, identified by its source file and, when Index is not 0,\n+   --  the index of the unit in the source file. Marking is used to signal\n+   --  that the unit has already been inserted in the Q.\n+\n+   function Is_Marked\n+     (Source_File : File_Name_Type;\n+      Index       : Int := 0)\n+      return Boolean;\n+   --  Returns True if the unit was previously marked.\n+\n+   procedure Delete_All_Marks;\n+   --  Remove all file/index couples marked\n+\n end Makeutl;"}, {"sha": "b55d801388d3e212dd840e4a281f5ba966760a9a", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -815,7 +815,9 @@ package body MLib.Prj is\n                      if Defaults /= No_Array_Element then\n                         Switches :=\n                           Value_Of\n-                            (Index => Name_Ada, In_Array => Defaults);\n+                            (Index     => Name_Ada,\n+                             Src_Index => 0,\n+                             In_Array  => Defaults);\n \n                         if not Switches.Default then\n                            Switch := Switches.Values;"}, {"sha": "90babc28861ca170de703041d30b7e9cb40ea4cf", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -638,6 +638,11 @@ package Opt is\n    --  Set to True when either Compile_Only, Bind_Only or Link_Only is\n    --  set to True.\n \n+   Main_Index : Int := 0;\n+   --  GNATMAKE\n+   --  This is set to non-zero by gnatmake switch -eInnn to indicate that\n+   --  the main program is the nnn unit in a multi-unit source file.\n+\n    Mapping_File_Name : String_Ptr := null;\n    --  GNAT\n    --  File name of mapping between unit names, file names and path names."}, {"sha": "7ca5fca77e50df8e0f3fba31a8eb81e76fa50037", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -520,7 +520,7 @@ package body Osint is\n    -- Add_File --\n    --------------\n \n-   procedure Add_File (File_Name : String) is\n+   procedure Add_File (File_Name : String; Index : Int := No_Index) is\n    begin\n       Number_File_Names := Number_File_Names + 1;\n \n@@ -530,9 +530,12 @@ package body Osint is\n \n       if Number_File_Names > File_Names'Last then\n          File_Names := new File_Name_Array'(File_Names.all & File_Names.all);\n+         File_Indexes :=\n+           new File_Index_Array'(File_Indexes.all & File_Indexes.all);\n       end if;\n \n-      File_Names (Number_File_Names) := new String'(File_Name);\n+      File_Names   (Number_File_Names) := new String'(File_Name);\n+      File_Indexes (Number_File_Names) := Index;\n    end Add_File;\n \n    ------------------------\n@@ -670,6 +673,15 @@ package body Osint is\n       end if;\n    end Create_File_And_Check;\n \n+   ------------------------\n+   -- Current_File_Index --\n+   ------------------------\n+\n+   function Current_File_Index return Int is\n+   begin\n+      return File_Indexes (Current_File_Name_Index);\n+   end Current_File_Index;\n+\n    --------------------------------\n    -- Current_Library_File_Stamp --\n    --------------------------------"}, {"sha": "f6e69c74814678be8c26cd558199100f9a53cb42", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -92,7 +92,9 @@ package Osint is\n    function Number_Of_Files return Int;\n    --  gives the total number of filenames found on the command line.\n \n-   procedure Add_File (File_Name : String);\n+   No_Index : constant := -1;\n+\n+   procedure Add_File (File_Name : String; Index : Int := No_Index);\n    --  Called by the subprogram processing the command line for each\n    --  file name found.\n \n@@ -379,6 +381,9 @@ package Osint is\n    --  every single time the routines are called unless you have previously\n    --  called Source_File_Data (Cache => True). See below.\n \n+   function Current_File_Index return Int;\n+   --  Return the index in its source file of the current main unit\n+\n    function Matching_Full_Source_Name\n      (N : File_Name_Type;\n       T : Time_Stamp_Type) return File_Name_Type;\n@@ -573,6 +578,11 @@ private\n    --  extensible, because when using project files, there may be\n    --  more files than arguments on the command line.\n \n+   type File_Index_Array is array (Int range <>) of Int;\n+   type File_Index_Array_Ptr is access File_Index_Array;\n+   File_Indexes : File_Index_Array_Ptr :=\n+                    new File_Index_Array (1 .. Int (Argument_Count) + 2);\n+\n    Current_File_Name_Index : Int := 0;\n    --  The index in File_Names of the last file opened by Next_Main_Source\n    --  or Next_Main_Lib_File. The value 0 indicates that no files have been"}, {"sha": "a0588bcb4e146fb9c4ca07355dfd1c089810ac9d", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -39,14 +39,17 @@ package body Prj.Attr is\n \n    --  The first letter is one of\n    --    'S' for Single\n-   --    'L' for list\n+   --    's' for Single with optional index\n+   --    'L' for List\n+   --    'l' for List of strings with optional indexes\n \n    --  The second letter is one of\n    --    'V' for single variable\n    --    'A' for associative array\n    --    'a' for case insensitive associative array\n    --    'b' for associative array, case insensitive if file names are case\n    --        insensitive\n+   --    'c' same as 'b', with optional index\n \n    --  End is indicated by two consecutive '#'.\n \n@@ -72,7 +75,7 @@ package body Prj.Attr is\n      \"SVlibrary_symbol_file#\" &\n      \"SVlibrary_symbol_policy#\" &\n      \"SVlibrary_reference_symbol_file#\" &\n-     \"LVmain#\" &\n+     \"lVmain#\" &\n      \"LVlanguages#\" &\n      \"SVmain_language#\" &\n \n@@ -86,26 +89,26 @@ package body Prj.Attr is\n      \"SVseparate_suffix#\" &\n      \"SVcasing#\" &\n      \"SVdot_replacement#\" &\n-     \"SAspecification#\" &\n-     \"SAspec#\" &\n-     \"SAimplementation#\" &\n-     \"SAbody#\" &\n+     \"sAspecification#\" &\n+     \"sAspec#\" &\n+     \"sAimplementation#\" &\n+     \"sAbody#\" &\n      \"Laspecification_exceptions#\" &\n      \"Laimplementation_exceptions#\" &\n \n    --  package Compiler\n \n      \"Pcompiler#\" &\n      \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+     \"Lcswitches#\" &\n      \"SVlocal_configuration_pragmas#\" &\n \n    --  package Builder\n \n      \"Pbuilder#\" &\n      \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n-     \"Sbexecutable#\" &\n+     \"Lcswitches#\" &\n+     \"Scexecutable#\" &\n      \"SVexecutable_suffix#\" &\n      \"SVglobal_configuration_pragmas#\" &\n \n@@ -118,13 +121,13 @@ package body Prj.Attr is\n \n      \"Pbinder#\" &\n      \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+     \"Lcswitches#\" &\n \n    --  package Linker\n \n      \"Plinker#\" &\n      \"Ladefault_switches#\" &\n-     \"Lbswitches#\" &\n+     \"Lcswitches#\" &\n      \"LVlinker_options#\" &\n \n    --  package Cross_Reference\n@@ -184,6 +187,7 @@ package body Prj.Attr is\n       Current_Attribute : Attribute_Node_Id  := Empty_Attribute;\n       Is_An_Attribute   : Boolean            := False;\n       Kind_1            : Variable_Kind      := Undefined;\n+      Optional_Index    : Boolean            := False;\n       Kind_2            : Attribute_Kind     := Single;\n       Package_Name      : Name_Id            := No_Name;\n       Attribute_Name    : Name_Id            := No_Name;\n@@ -232,10 +236,20 @@ package body Prj.Attr is\n                Start := Finish + 1;\n \n             when 'S' =>\n-               Kind_1 := Single;\n+               Kind_1         := Single;\n+               Optional_Index := False;\n+\n+            when 's' =>\n+               Kind_1         := Single;\n+               Optional_Index := True;\n \n             when 'L' =>\n-               Kind_1 := List;\n+               Kind_1         := List;\n+               Optional_Index := False;\n+\n+            when 'l' =>\n+               Kind_1         := List;\n+               Optional_Index := True;\n \n             when others =>\n                raise Program_Error;\n@@ -263,6 +277,14 @@ package body Prj.Attr is\n                      Kind_2 := Case_Insensitive_Associative_Array;\n                   end if;\n \n+               when 'c' =>\n+                  if File_Names_Case_Sensitive then\n+                     Kind_2 := Optional_Index_Associative_Array;\n+                  else\n+                     Kind_2 :=\n+                       Optional_Index_Case_Insensitive_Associative_Array;\n+                  end if;\n+\n                when others =>\n                   raise Program_Error;\n             end case;\n@@ -279,6 +301,7 @@ package body Prj.Attr is\n               To_Lower (Initialization_Data (Start .. Finish - 1));\n             Attribute_Name := Name_Find;\n             Attributes.Increment_Last;\n+\n             if Current_Attribute = Empty_Attribute then\n                First_Attribute := Attributes.Last;\n \n@@ -306,10 +329,11 @@ package body Prj.Attr is\n \n             Current_Attribute := Attributes.Last;\n             Attributes.Table (Current_Attribute) :=\n-              (Name    => Attribute_Name,\n-               Kind_1  => Kind_1,\n-               Kind_2  => Kind_2,\n-               Next    => Empty_Attribute);\n+              (Name           => Attribute_Name,\n+               Kind_1         => Kind_1,\n+               Optional_Index => Optional_Index,\n+               Kind_2         => Kind_2,\n+               Next           => Empty_Attribute);\n             Start := Finish + 1;\n          end if;\n       end loop;"}, {"sha": "9ca7ded47c1d6de93025b80f223d73e390e95464", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2002 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,13 +53,16 @@ package Prj.Attr is\n    type Attribute_Kind is\n      (Single,\n       Associative_Array,\n-      Case_Insensitive_Associative_Array);\n+      Optional_Index_Associative_Array,\n+      Case_Insensitive_Associative_Array,\n+      Optional_Index_Case_Insensitive_Associative_Array);\n \n    type Attribute_Record is record\n-      Name     : Name_Id;\n-      Kind_1   : Variable_Kind;\n-      Kind_2   : Attribute_Kind;\n-      Next     : Attribute_Node_Id;\n+      Name           : Name_Id;\n+      Kind_1         : Variable_Kind;\n+      Optional_Index : Boolean;\n+      Kind_2         : Attribute_Kind;\n+      Next           : Attribute_Node_Id;\n    end record;\n \n    package Attributes is"}, {"sha": "e4e73d92209b4febda188cf8252ce4e5dcfafee0", "filename": "gcc/ada/prj-com.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-com.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-com.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-com.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -56,6 +56,7 @@ package Prj.Com is\n \n    type File_Name_Data is record\n       Name         : Name_Id := No_Name;\n+      Index        : Int     := 0;\n       Display_Name : Name_Id := No_Name;\n       Path         : Name_Id := No_Name;\n       Display_Path : Name_Id := No_Name;"}, {"sha": "89233fa90eb765f1a21f3e5f2c2bb7378c74be47", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2001-2003 Free Software Foundation, Inc          --\n+--           Copyright (C) 2001-2004 Free Software Foundation, Inc          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Scans;    use Scans;\n with Snames;\n with Types;    use Types;\n with Prj.Attr; use Prj.Attr;\n+with Uintp;    use Uintp;\n \n package body Prj.Dect is\n \n@@ -121,6 +122,7 @@ package body Prj.Dect is\n       Current_Attribute      : Attribute_Node_Id := First_Attribute;\n       Full_Associative_Array : Boolean           := False;\n       Attribute_Name         : Name_Id           := No_Name;\n+      Optional_Index         : Boolean           := False;\n \n    begin\n       Attribute := Default_Project_Node (Of_Kind => N_Attribute_Declaration);\n@@ -194,8 +196,9 @@ package body Prj.Dect is\n \n          --  Set, if appropriate the index case insensitivity flag\n \n-         elsif Attributes.Table (Current_Attribute).Kind_2 =\n-           Case_Insensitive_Associative_Array\n+         elsif Attributes.Table (Current_Attribute).Kind_2 in\n+           Case_Insensitive_Associative_Array ..\n+             Optional_Index_Case_Insensitive_Associative_Array\n          then\n             Set_Case_Insensitive (Attribute, To => True);\n          end if;\n@@ -245,6 +248,40 @@ package body Prj.Dect is\n          if Token = Tok_String_Literal then\n             Set_Associative_Array_Index_Of (Attribute, Token_Name);\n             Scan; --  past the literal string index\n+\n+            if Token = Tok_At then\n+               case Attributes.Table (Current_Attribute).Kind_2 is\n+                  when Optional_Index_Associative_Array |\n+                       Optional_Index_Case_Insensitive_Associative_Array =>\n+                     Scan;\n+                     Expect (Tok_Integer_Literal, \"integer literal\");\n+\n+                     if Token = Tok_Integer_Literal then\n+                        declare\n+                           Index : constant Int :=\n+                                     UI_To_Int (Int_Literal_Value);\n+                        begin\n+                           if Index = 0 then\n+                              Error_Msg (\"index cannot be zero\", Token_Ptr);\n+\n+                           else\n+                              --  Set the index\n+                              Set_Source_Index_Of (Attribute, To => Index);\n+                           end if;\n+                        end;\n+\n+                        Scan;\n+                     end if;\n+\n+                  when others =>\n+                     Error_Msg (\"index not allowed here\", Token_Ptr);\n+                     Scan;\n+\n+                     if Token = Tok_Integer_Literal then\n+                        Scan;\n+                     end if;\n+               end case;\n+            end if;\n          end if;\n \n          Expect (Tok_Right_Paren, \"`)`\");\n@@ -271,6 +308,7 @@ package body Prj.Dect is\n       if Current_Attribute /= Empty_Attribute then\n          Set_Expression_Kind_Of\n            (Attribute, To => Attributes.Table (Current_Attribute).Kind_1);\n+         Optional_Index := Attributes.Table (Current_Attribute).Optional_Index;\n       end if;\n \n       Expect (Tok_Use, \"USE\");\n@@ -439,7 +477,8 @@ package body Prj.Dect is\n                Parse_Expression\n                  (Expression      => Expression,\n                   Current_Project => Current_Project,\n-                  Current_Package => Current_Package);\n+                  Current_Package => Current_Package,\n+                  Optional_Index  => Optional_Index);\n                Set_Expression_Of (Attribute, To => Expression);\n \n                --  If the expression is legal, but not of the right kind\n@@ -1225,7 +1264,8 @@ package body Prj.Dect is\n       Parse_Expression\n         (Expression      => Expression,\n          Current_Project => Current_Project,\n-         Current_Package => Current_Package);\n+         Current_Package => Current_Package,\n+         Optional_Index  => False);\n       Set_Expression_Of (Variable, To => Expression);\n \n       if Expression /= Empty_Node then"}, {"sha": "b8e3fc7bf020518d01b6ef0bb0c987c976a6923d", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -584,7 +584,8 @@ package body Prj.Env is\n       procedure Put\n         (Unit_Name : Name_Id;\n          File_Name : Name_Id;\n-         Unit_Kind : Spec_Or_Body);\n+         Unit_Kind : Spec_Or_Body;\n+         Index     : Int);\n       --  Put an SFN pragma in the temporary file\n \n       procedure Put (File : File_Descriptor; S : String);\n@@ -742,7 +743,8 @@ package body Prj.Env is\n       procedure Put\n         (Unit_Name : Name_Id;\n          File_Name : Name_Id;\n-         Unit_Kind : Spec_Or_Body)\n+         Unit_Kind : Spec_Or_Body;\n+         Index     : Int)\n       is\n       begin\n          --  A temporary file needs to be open\n@@ -761,7 +763,14 @@ package body Prj.Env is\n          end if;\n \n          Put (File, Namet.Get_Name_String (File_Name));\n-         Put_Line (File, \"\"\");\");\n+         Put (File, \"\"\"\");\n+\n+         if Index /= 0 then\n+            Put (File, \", Index =>\");\n+            Put (File, Index'Img);\n+         end if;\n+\n+         Put_Line (File, \");\");\n       end Put;\n \n       procedure Put (File : File_Descriptor; S : String) is\n@@ -788,7 +797,7 @@ package body Prj.Env is\n          Last : Natural;\n \n       begin\n-         --  Add an ASCII.LF to the string. As this gnat.adc is supposed to\n+         --  Add an ASCII.LF to the string. As this config file is supposed to\n          --  be used only by the compiler, we don't care about the characters\n          --  for the end of line. In fact we could have put a space, but\n          --  it is more convenient to be able to read gnat.adc during\n@@ -831,13 +840,15 @@ package body Prj.Env is\n                if Unit.File_Names (Specification).Needs_Pragma then\n                   Put (Unit.Name,\n                        Unit.File_Names (Specification).Name,\n-                       Specification);\n+                       Specification,\n+                       Unit.File_Names (Specification).Index);\n                end if;\n \n                if Unit.File_Names (Body_Part).Needs_Pragma then\n                   Put (Unit.Name,\n                        Unit.File_Names (Body_Part).Name,\n-                       Body_Part);\n+                       Body_Part,\n+                       Unit.File_Names (Body_Part).Index);\n                end if;\n \n                Current_Unit := Current_Unit + 1;\n@@ -1269,7 +1280,6 @@ package body Prj.Env is\n                            Write_Line (\"   OK\");\n                         end if;\n \n-\n                         if Full_Path then\n                            return Get_Name_String\n                              (Unit.File_Names (Specification).Path);"}, {"sha": "b6b66dd51959b8809dd550646b6488b77fd2c030", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 115, "deletions": 96, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -136,9 +136,10 @@ package body Prj.Makr is\n       Args : Argument_List  (1 .. Preproc_Switches'Length + 6);\n \n       type SFN_Pragma is record\n-         Unit : Name_Id;\n-         File : Name_Id;\n-         Spec : Boolean;\n+         Unit  : Name_Id;\n+         File  : Name_Id;\n+         Index : Int := 0;\n+         Spec  : Boolean;\n       end record;\n \n       package SFN_Pragmas is new Table.Table\n@@ -254,7 +255,7 @@ package body Prj.Makr is\n                   then\n                      Output.Write_Str (\"   Checking \"\"\");\n                      Output.Write_Str (Str (1 .. Last));\n-                     Output.Write_Str (\"\"\": \");\n+                     Output.Write_Line (\"\"\": \");\n                   end if;\n \n                   --  If the file name matches one of the regular expressions,\n@@ -362,7 +363,7 @@ package body Prj.Makr is\n                            if End_Of_File (File) then\n                               if Opt.Verbose_Mode then\n                                  if not Success then\n-                                    Output.Write_Str (\"(process died) \");\n+                                    Output.Write_Str (\"      (process died) \");\n                                  end if;\n                               end if;\n \n@@ -383,10 +384,11 @@ package body Prj.Makr is\n                                           Name_Buffer (1 .. Name_Len) :=\n                                             Text_Line (6 .. J - 7);\n                                           SFN_Prag :=\n-                                            (Unit => Name_Find,\n-                                             File => File_Name_Id,\n-                                             Spec => Text_Line (J - 5 .. J) =\n-                                                       \"(spec)\");\n+                                            (Unit  => Name_Find,\n+                                             File  => File_Name_Id,\n+                                             Index => 0,\n+                                             Spec  => Text_Line (J - 5 .. J) =\n+                                                        \"(spec)\");\n \n                                           SFN_Pragmas.Increment_Last;\n                                           SFN_Pragmas.Table\n@@ -400,107 +402,116 @@ package body Prj.Makr is\n \n                            if Save_Last_Pragma_Index = SFN_Pragmas.Last then\n                               if Opt.Verbose_Mode then\n-                                 Output.Write_Line (\"not a unit\");\n-                              end if;\n-\n-                           elsif SFN_Pragmas.Last >\n-                             Save_Last_Pragma_Index + 1\n-                           then\n-                              SFN_Pragmas.Set_Last (Save_Last_Pragma_Index);\n-\n-                              if Opt.Verbose_Mode then\n-                                 Output.Write_Line\n-                                   (\"file contains multiple units\");\n+                                 Output.Write_Line (\"      not a unit\");\n                               end if;\n \n                            else\n-                              SFN_Prag := SFN_Pragmas.Table\n-                                (SFN_Pragmas.Last);\n-\n-                              if Opt.Verbose_Mode then\n-                                 if SFN_Prag.Spec then\n-                                    Output.Write_Str (\"spec of \");\n-\n-                                 else\n-                                    Output.Write_Str (\"body of \");\n-                                 end if;\n-\n-                                 Output.Write_Line\n-                                   (Get_Name_String (SFN_Prag.Unit));\n+                              if SFN_Pragmas.Last >\n+                                   Save_Last_Pragma_Index + 1\n+                              then\n+                                 for Index in Save_Last_Pragma_Index + 1 ..\n+                                                SFN_Pragmas.Last\n+                                 loop\n+                                    SFN_Pragmas.Table (Index).Index :=\n+                                      Int (Index - Save_Last_Pragma_Index);\n+                                 end loop;\n                               end if;\n \n-                              if Project_File then\n-\n-                                 --  Add the corresponding attribute in the\n-                                 --  Naming package of the naming project.\n-\n-                                 declare\n-                                    Decl_Item : constant Project_Node_Id :=\n-                                                  Default_Project_Node\n-                                                   (Of_Kind =>\n-                                                      N_Declarative_Item);\n-\n-                                    Attribute : constant Project_Node_Id :=\n-                                                  Default_Project_Node\n-                                                   (Of_Kind =>\n-                                                      N_Attribute_Declaration);\n-\n-                                    Expression : constant Project_Node_Id :=\n-                                                   Default_Project_Node\n-                                                    (Of_Kind => N_Expression,\n-                                                     And_Expr_Kind => Single);\n-\n-                                    Term : constant Project_Node_Id :=\n-                                             Default_Project_Node\n-                                               (Of_Kind => N_Term,\n-                                                And_Expr_Kind => Single);\n-\n-                                    Value : constant Project_Node_Id :=\n-                                              Default_Project_Node\n-                                                (Of_Kind => N_Literal_String,\n-                                                 And_Expr_Kind => Single);\n-\n-                                 begin\n-                                    Set_Next_Declarative_Item\n-                                      (Decl_Item,\n-                                       To => First_Declarative_Item_Of\n-                                         (Naming_Package));\n-                                    Set_First_Declarative_Item_Of\n-                                      (Naming_Package, To => Decl_Item);\n-                                    Set_Current_Item_Node\n-                                      (Decl_Item, To => Attribute);\n-\n-                                    --  Is it a spec or a body?\n+                              for Index in Save_Last_Pragma_Index + 1 ..\n+                                             SFN_Pragmas.Last\n+                              loop\n+                                 SFN_Prag := SFN_Pragmas.Table (Index);\n \n+                                 if Opt.Verbose_Mode then\n                                     if SFN_Prag.Spec then\n-                                       Set_Name_Of\n-                                         (Attribute, To => Name_Spec);\n+                                       Output.Write_Str (\"      spec of \");\n+\n                                     else\n-                                       Set_Name_Of\n-                                         (Attribute,\n-                                          To => Name_Body);\n+                                       Output.Write_Str (\"      body of \");\n                                     end if;\n \n-                                    --  Get the name of the unit\n+                                    Output.Write_Line\n+                                      (Get_Name_String (SFN_Prag.Unit));\n+                                 end if;\n+\n+                                 if Project_File then\n+\n+                                    --  Add the corresponding attribute in the\n+                                    --  Naming package of the naming project.\n+\n+                                    declare\n+                                       Decl_Item : constant Project_Node_Id :=\n+                                         Default_Project_Node\n+                                           (Of_Kind =>\n+                                                N_Declarative_Item);\n+\n+                                       Attribute : constant Project_Node_Id :=\n+                                         Default_Project_Node\n+                                           (Of_Kind =>\n+                                                N_Attribute_Declaration);\n+\n+                                       Expression : constant Project_Node_Id :=\n+                                         Default_Project_Node\n+                                           (Of_Kind => N_Expression,\n+                                            And_Expr_Kind => Single);\n+\n+                                       Term : constant Project_Node_Id :=\n+                                         Default_Project_Node\n+                                           (Of_Kind => N_Term,\n+                                            And_Expr_Kind => Single);\n+\n+                                       Value : constant Project_Node_Id :=\n+                                         Default_Project_Node\n+                                           (Of_Kind => N_Literal_String,\n+                                            And_Expr_Kind => Single);\n+\n+                                    begin\n+                                       Set_Next_Declarative_Item\n+                                         (Decl_Item,\n+                                          To => First_Declarative_Item_Of\n+                                            (Naming_Package));\n+                                       Set_First_Declarative_Item_Of\n+                                         (Naming_Package, To => Decl_Item);\n+                                       Set_Current_Item_Node\n+                                         (Decl_Item, To => Attribute);\n+\n+                                       --  Is it a spec or a body?\n+\n+                                       if SFN_Prag.Spec then\n+                                          Set_Name_Of\n+                                            (Attribute, To => Name_Spec);\n+                                       else\n+                                          Set_Name_Of\n+                                            (Attribute,\n+                                             To => Name_Body);\n+                                       end if;\n \n-                                    Get_Name_String (SFN_Prag.Unit);\n-                                    To_Lower (Name_Buffer (1 .. Name_Len));\n-                                    Set_Associative_Array_Index_Of\n-                                      (Attribute, To => Name_Find);\n+                                       --  Get the name of the unit\n \n-                                    Set_Expression_Of\n-                                      (Attribute, To => Expression);\n-                                    Set_First_Term\n-                                      (Expression, To => Term);\n-                                    Set_Current_Term (Term, To => Value);\n+                                       Get_Name_String (SFN_Prag.Unit);\n+                                       To_Lower (Name_Buffer (1 .. Name_Len));\n+                                       Set_Associative_Array_Index_Of\n+                                         (Attribute, To => Name_Find);\n \n-                                    --  And set the name of the file\n+                                       Set_Expression_Of\n+                                         (Attribute, To => Expression);\n+                                       Set_First_Term\n+                                         (Expression, To => Term);\n+                                       Set_Current_Term (Term, To => Value);\n \n-                                    Set_String_Value_Of\n-                                      (Value, To => File_Name_Id);\n-                                 end;\n+                                       --  And set the name of the file\n \n-                                 --  Add source file name to source list file\n+                                       Set_String_Value_Of\n+                                         (Value, To => File_Name_Id);\n+                                       Set_Source_Index_Of\n+                                         (Value, To => SFN_Prag.Index);\n+                                    end;\n+                                 end if;\n+                              end loop;\n+\n+                              if Project_File then\n+                                 --  Add source file name to source list\n+                                 --  file.\n \n                                  Last := Last + 1;\n                                  Str (Last) := ASCII.LF;\n@@ -1273,7 +1284,15 @@ package body Prj.Makr is\n \n                Write_A_String\n                  (Get_Name_String (SFN_Pragmas.Table (Index).File));\n-               Write_A_String (\"\"\");\");\n+\n+               Write_A_String (\"\"\"\");\n+\n+               if SFN_Pragmas.Table (Index).Index /= 0 then\n+                  Write_A_String (\", Index =>\");\n+                  Write_A_String (SFN_Pragmas.Table (Index).Index'Img);\n+               end if;\n+\n+               Write_A_String (\");\");\n                Write_Eol;\n             end loop;\n "}, {"sha": "f728d975d34ace6f29fde9a46dddde1d3f72aef9", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 251, "deletions": 185, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -38,6 +38,7 @@ with Prj.Err;\n with Prj.Util; use Prj.Util;\n with Sinput.P;\n with Snames;   use Snames;\n+with Table;    use Table;\n with Types;    use Types;\n \n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n@@ -97,27 +98,48 @@ package body Prj.Nmsc is\n    --  several times, and to avoid cycles that may be introduced by symbolic\n    --  links.\n \n+   type Ada_Naming_Exception_Id is new Nat;\n+   No_Ada_Naming_Exception : constant Ada_Naming_Exception_Id := 0;\n+\n    type Unit_Info is record\n       Kind : Spec_Or_Body;\n       Unit : Name_Id;\n+      Next : Ada_Naming_Exception_Id := No_Ada_Naming_Exception;\n    end record;\n-   No_Unit : constant Unit_Info := (Specification, No_Name);\n+   --  No_Unit : constant Unit_Info :=\n+   --              (Specification, No_Name, No_Ada_Naming_Exception);\n+\n+   package Ada_Naming_Exception_Table is new Table.Table\n+     (Table_Component_Type => Unit_Info,\n+      Table_Index_Type     => Ada_Naming_Exception_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 20,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Nmsc.Ada_Naming_Exception_Table\");\n \n    package Ada_Naming_Exceptions is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n-      Element    => Unit_Info,\n-      No_Element => No_Unit,\n+      Element    => Ada_Naming_Exception_Id,\n+      No_Element => No_Ada_Naming_Exception,\n       Key        => Name_Id,\n       Hash       => Hash,\n       Equal      => \"=\");\n-   --  A hash table to store naming exceptions for Ada\n+   --  A hash table to store naming exceptions for Ada. For each file name\n+   --  there is one or several unit in table Ada_Naming_Exception_Table.\n \n    function Hash (Unit : Unit_Info) return Header_Num;\n \n+   type Name_And_Index is record\n+      Name  : Name_Id := No_Name;\n+      Index : Int     := 0;\n+   end record;\n+   No_Name_And_Index : constant Name_And_Index :=\n+                         (Name => No_Name, Index => 0);\n+\n    package Reverse_Ada_Naming_Exceptions is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n-      Element    => Name_Id,\n-      No_Element => No_Name,\n+      Element    => Name_And_Index,\n+      No_Element => No_Name_And_Index,\n       Key        => Unit_Info,\n       Hash       => Hash,\n       Equal      => \"=\");\n@@ -198,12 +220,15 @@ package body Prj.Nmsc is\n    procedure Get_Unit\n      (Canonical_File_Name : Name_Id;\n       Naming              : Naming_Data;\n+      Exception_Id        : out Ada_Naming_Exception_Id;\n       Unit_Name           : out Name_Id;\n       Unit_Kind           : out Spec_Or_Body;\n       Needs_Pragma        : out Boolean);\n    --  Find out, from a file name, the unit name, the unit kind and if a\n    --  specific SFN pragma is needed. If the file name corresponds to no\n-   --  unit, then Unit_Name will be No_Name.\n+   --  unit, then Unit_Name will be No_Name. If the file is a multi-unit source\n+   --  or an exception to the naming scheme, then Exception_Id is set to\n+   --  the unit or units that the source contains.\n \n    function Is_Illegal_Suffix\n      (Suffix                          : String;\n@@ -362,7 +387,7 @@ package body Prj.Nmsc is\n                         Write_Line (Get_Name_String (Name));\n                      end if;\n \n-                     --  Register the source if it is an Ada compilation unit..\n+                     --  Register the source if it is an Ada compilation unit.\n \n                      Record_Ada_Source\n                        (File_Name       => Name,\n@@ -574,7 +599,6 @@ package body Prj.Nmsc is\n                              (Name_Locally_Removed_Files,\n                               Data.Decl.Attributes);\n \n-\n             begin\n                pragma Assert\n                  (Sources.Kind = List,\n@@ -896,6 +920,7 @@ package body Prj.Nmsc is\n                         String_Elements.Increment_Last;\n                         String_Elements.Table (String_Elements.Last) :=\n                           (Value    => ALI_Name_Id,\n+                           Index    => 0,\n                            Display_Value => ALI_Name_Id,\n                            Location => String_Elements.Table\n                                                          (Interfaces).Location,\n@@ -2099,8 +2124,9 @@ package body Prj.Nmsc is\n          declare\n             Ada_Spec_Suffix : constant Variable_Value :=\n                                 Prj.Util.Value_Of\n-                                 (Index => Name_Ada,\n-                                  In_Array => Data.Naming.Spec_Suffix);\n+                                  (Index     => Name_Ada,\n+                                   Src_Index => 0,\n+                                   In_Array  => Data.Naming.Spec_Suffix);\n \n          begin\n             if Ada_Spec_Suffix.Kind = Single\n@@ -2128,8 +2154,9 @@ package body Prj.Nmsc is\n          declare\n             Ada_Body_Suffix : constant Variable_Value :=\n               Prj.Util.Value_Of\n-              (Index => Name_Ada,\n-               In_Array => Data.Naming.Body_Suffix);\n+                (Index     => Name_Ada,\n+                 Src_Index => 0,\n+                 In_Array  => Data.Naming.Body_Suffix);\n \n          begin\n             if Ada_Body_Suffix.Kind = Single\n@@ -2491,6 +2518,7 @@ package body Prj.Nmsc is\n \n    procedure Free_Ada_Naming_Exceptions is\n    begin\n+      Ada_Naming_Exception_Table.Set_Last (0);\n       Ada_Naming_Exceptions.Reset;\n       Reverse_Ada_Naming_Exceptions.Reset;\n    end Free_Ada_Naming_Exceptions;\n@@ -2591,57 +2619,42 @@ package body Prj.Nmsc is\n    procedure Get_Unit\n      (Canonical_File_Name : Name_Id;\n       Naming              : Naming_Data;\n+      Exception_Id        : out Ada_Naming_Exception_Id;\n       Unit_Name           : out Name_Id;\n       Unit_Kind           : out Spec_Or_Body;\n       Needs_Pragma        : out Boolean)\n    is\n-      function Check_Exception (Canonical : Name_Id) return Boolean;\n-      pragma Inline (Check_Exception);\n-      --  Check if Canonical is one of the exceptions in List.\n-      --  Returns True if Get_Unit should exit\n-\n-      ---------------------\n-      -- Check_Exception --\n-      ---------------------\n+      Info_Id  : Ada_Naming_Exception_Id\n+        := Ada_Naming_Exceptions.Get (Canonical_File_Name);\n+      VMS_Name : Name_Id;\n \n-      function Check_Exception (Canonical : Name_Id) return Boolean is\n-         Info     : Unit_Info := Ada_Naming_Exceptions.Get (Canonical);\n-         VMS_Name : Name_Id;\n-\n-      begin\n-         if Info = No_Unit then\n-            if Hostparm.OpenVMS then\n-               VMS_Name := Canonical;\n-               Get_Name_String (VMS_Name);\n-\n-               if Name_Buffer (Name_Len) = '.' then\n-                  Name_Len := Name_Len - 1;\n-                  VMS_Name := Name_Find;\n-               end if;\n-\n-               Info := Ada_Naming_Exceptions.Get (VMS_Name);\n+   begin\n+      if Info_Id = No_Ada_Naming_Exception then\n+         if Hostparm.OpenVMS then\n+            VMS_Name := Canonical_File_Name;\n+            Get_Name_String (VMS_Name);\n+\n+            if Name_Buffer (Name_Len) = '.' then\n+               Name_Len := Name_Len - 1;\n+               VMS_Name := Name_Find;\n             end if;\n \n-            if Info = No_Unit then\n-               return False;\n-            end if;\n+            Info_Id := Ada_Naming_Exceptions.Get (VMS_Name);\n          end if;\n \n-         Unit_Kind := Info.Kind;\n-         Unit_Name := Info.Unit;\n-         Needs_Pragma := True;\n-         return True;\n-      end Check_Exception;\n-\n-   --  Start of processing for Get_Unit\n-\n-   begin\n-      Needs_Pragma := False;\n+      end if;\n \n-      if Check_Exception (Canonical_File_Name) then\n+      if Info_Id /= No_Ada_Naming_Exception then\n+         Exception_Id := Info_Id;\n+         Unit_Name := No_Name;\n+         Unit_Kind := Specification;\n+         Needs_Pragma := True;\n          return;\n       end if;\n \n+      Needs_Pragma := False;\n+      Exception_Id := No_Ada_Naming_Exception;\n+\n       Get_Name_String (Canonical_File_Name);\n \n       declare\n@@ -3004,7 +3017,8 @@ package body Prj.Nmsc is\n                   Display_Value => Non_Canonical_Path,\n                   Location => No_Location,\n                   Flag     => False,\n-                  Next     => Nil_String);\n+                  Next     => Nil_String,\n+                  Index    => 0);\n \n                --  Case of first source directory\n \n@@ -3380,7 +3394,8 @@ package body Prj.Nmsc is\n                Display_Value => Data.Display_Directory,\n                Location => No_Location,\n                Flag     => False,\n-               Next     => Nil_String);\n+               Next     => Nil_String,\n+               Index    => 0);\n \n             if Current_Verbosity = High then\n                Write_Line (\"Single source directory:\");\n@@ -3747,10 +3762,11 @@ package body Prj.Nmsc is\n                      if Suffix2 = No_Array_Element then\n                         Array_Elements.Increment_Last;\n                         Array_Elements.Table (Array_Elements.Last) :=\n-                          (Index => Element.Index,\n+                          (Index     => Element.Index,\n+                           Src_Index => Element.Src_Index,\n                            Index_Case_Sensitive => False,\n-                           Value => Element.Value,\n-                           Next  => Spec_Suffixs);\n+                           Value     => Element.Value,\n+                           Next      => Spec_Suffixs);\n                         Spec_Suffixs := Array_Elements.Last;\n                      end if;\n \n@@ -3823,6 +3839,7 @@ package body Prj.Nmsc is\n                         Array_Elements.Increment_Last;\n                         Array_Elements.Table (Array_Elements.Last) :=\n                           (Index => Element.Index,\n+                           Src_Index => Element.Src_Index,\n                            Index_Case_Sensitive => False,\n                            Value => Element.Value,\n                            Next  => Impl_Suffixs);\n@@ -4091,8 +4108,9 @@ package body Prj.Nmsc is\n                declare\n                   Naming_Exceptions : constant Variable_Value :=\n                     Value_Of\n-                      (Index => Lang_Name_Ids (Lang),\n-                       In_Array => Data.Naming.Implementation_Exceptions);\n+                      (Index     => Lang_Name_Ids (Lang),\n+                       Src_Index => 0,\n+                       In_Array  => Data.Naming.Implementation_Exceptions);\n                   Element_Id : String_List_Id;\n                   Element    : String_Element;\n                   File_Id : Name_Id;\n@@ -4325,19 +4343,27 @@ package body Prj.Nmsc is\n       Current : Array_Element_Id := List;\n       Element : Array_Element;\n \n+      Unit : Unit_Info;\n+\n    begin\n       --  Traverse the list\n \n       while Current /= No_Array_Element loop\n          Element := Array_Elements.Table (Current);\n \n          if Element.Index /= No_Name then\n-            Ada_Naming_Exceptions.Set\n-              (Element.Value.Value,\n-               (Kind => Kind, Unit => Element.Index));\n+            Unit :=\n+              (Kind => Kind,\n+               Unit => Element.Index,\n+               Next => No_Ada_Naming_Exception);\n             Reverse_Ada_Naming_Exceptions.Set\n-              ((Kind => Kind, Unit => Element.Index),\n-               Element.Value.Value);\n+              (Unit, (Element.Value.Value, Element.Value.Index));\n+            Unit.Next := Ada_Naming_Exceptions.Get (Element.Value.Value);\n+            Ada_Naming_Exception_Table.Increment_Last;\n+            Ada_Naming_Exception_Table.Table\n+              (Ada_Naming_Exception_Table.Last) := Unit;\n+            Ada_Naming_Exceptions.Set\n+              (Element.Value.Value, Ada_Naming_Exception_Table.Last);\n          end if;\n \n          Current := Element.Next;\n@@ -4382,16 +4408,22 @@ package body Prj.Nmsc is\n    is\n       Canonical_File_Name : Name_Id;\n       Canonical_Path_Name : Name_Id;\n+      Exception_Id : Ada_Naming_Exception_Id;\n       Unit_Name    : Name_Id;\n       Unit_Kind    : Spec_Or_Body;\n+      Unit_Index   : Int := 0;\n+      Info         : Unit_Info;\n+      Name_Index   : Name_And_Index;\n       Needs_Pragma : Boolean;\n \n       The_Location    : Source_Ptr     := Location;\n       Previous_Source : constant String_List_Id := Current_Source;\n-      Except_Name     : Name_Id        := No_Name;\n+      Except_Name     : Name_And_Index := No_Name_And_Index;\n \n       Unit_Prj : Unit_Project;\n \n+      File_Name_Recorded : Boolean := False;\n+\n    begin\n       Get_Name_String (File_Name);\n       Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n@@ -4415,31 +4447,36 @@ package body Prj.Nmsc is\n       Get_Unit\n         (Canonical_File_Name => Canonical_File_Name,\n          Naming              => Data.Naming,\n+         Exception_Id        => Exception_Id,\n          Unit_Name           => Unit_Name,\n          Unit_Kind           => Unit_Kind,\n          Needs_Pragma        => Needs_Pragma);\n \n-      if Unit_Name = No_Name then\n+      if Exception_Id = No_Ada_Naming_Exception and then\n+        Unit_Name = No_Name\n+      then\n          if Current_Verbosity = High then\n             Write_Str  (\"   \"\"\");\n             Write_Str  (Get_Name_String (Canonical_File_Name));\n             Write_Line (\"\"\" is not a valid source file name (ignored).\");\n          end if;\n \n       else\n+\n          --  Check to see if the source has been hidden by an exception,\n          --  but only if it is not an exception.\n \n          if not Needs_Pragma then\n             Except_Name :=\n-              Reverse_Ada_Naming_Exceptions.Get ((Unit_Kind, Unit_Name));\n+              Reverse_Ada_Naming_Exceptions.Get\n+                ((Unit_Kind, Unit_Name, No_Ada_Naming_Exception));\n \n-            if Except_Name /= No_Name then\n+            if Except_Name /= No_Name_And_Index then\n                if Current_Verbosity = High then\n                   Write_Str  (\"   \"\"\");\n                   Write_Str  (Get_Name_String (Canonical_File_Name));\n                   Write_Str  (\"\"\" contains a unit that is found in \"\"\");\n-                  Write_Str  (Get_Name_String (Except_Name));\n+                  Write_Str  (Get_Name_String (Except_Name.Name));\n                   Write_Line (\"\"\" (ignored).\");\n                end if;\n \n@@ -4451,145 +4488,173 @@ package body Prj.Nmsc is\n             end if;\n          end if;\n \n-         --  Put the file name in the list of sources of the project\n+         loop\n+            if Exception_Id /= No_Ada_Naming_Exception then\n+               Info := Ada_Naming_Exception_Table.Table (Exception_Id);\n+               Exception_Id := Info.Next;\n+               Info.Next := No_Ada_Naming_Exception;\n+               Name_Index := Reverse_Ada_Naming_Exceptions.Get (Info);\n \n-         String_Elements.Increment_Last;\n-         String_Elements.Table (String_Elements.Last) :=\n-           (Value         => Canonical_File_Name,\n-            Display_Value => File_Name,\n-            Location      => No_Location,\n-            Flag          => False,\n-            Next          => Nil_String);\n+               Unit_Name  := Info.Unit;\n+               Unit_Index := Name_Index.Index;\n+               Unit_Kind  := Info.Kind;\n+            end if;\n+            --  Put the file name in the list of sources of the project\n \n-         if Current_Source = Nil_String then\n-            Data.Sources := String_Elements.Last;\n+            if not File_Name_Recorded then\n+               String_Elements.Increment_Last;\n+               String_Elements.Table (String_Elements.Last) :=\n+                 (Value         => Canonical_File_Name,\n+                  Display_Value => File_Name,\n+                  Location      => No_Location,\n+                  Flag          => False,\n+                  Next          => Nil_String,\n+                  Index         => Unit_Index);\n+            end if;\n \n-         else\n-            String_Elements.Table (Current_Source).Next :=\n-              String_Elements.Last;\n-         end if;\n+            if Current_Source = Nil_String then\n+               Data.Sources := String_Elements.Last;\n \n-         Current_Source := String_Elements.Last;\n+            else\n+               String_Elements.Table (Current_Source).Next :=\n+                 String_Elements.Last;\n+            end if;\n \n-         --  Put the unit in unit list\n+            Current_Source := String_Elements.Last;\n \n-         declare\n-            The_Unit      : Unit_Id := Units_Htable.Get (Unit_Name);\n-            The_Unit_Data : Unit_Data;\n+            --  Put the unit in unit list\n \n-         begin\n-            if Current_Verbosity = High then\n-               Write_Str  (\"Putting \");\n-               Write_Str  (Get_Name_String (Unit_Name));\n-               Write_Line (\" in the unit list.\");\n-            end if;\n+            declare\n+               The_Unit      : Unit_Id := Units_Htable.Get (Unit_Name);\n+               The_Unit_Data : Unit_Data;\n \n-            --  The unit is already in the list, but may be it is\n-            --  only the other unit kind (spec or body), or what is\n-            --  in the unit list is a unit of a project we are extending.\n+            begin\n+               if Current_Verbosity = High then\n+                  Write_Str  (\"Putting \");\n+                  Write_Str  (Get_Name_String (Unit_Name));\n+                  Write_Line (\" in the unit list.\");\n+               end if;\n \n-            if The_Unit /= Prj.Com.No_Unit then\n-               The_Unit_Data := Units.Table (The_Unit);\n+               --  The unit is already in the list, but may be it is\n+               --  only the other unit kind (spec or body), or what is\n+               --  in the unit list is a unit of a project we are extending.\n \n-               if The_Unit_Data.File_Names (Unit_Kind).Name = No_Name\n-                 or else Project_Extends\n-                           (Data.Extends,\n-                            The_Unit_Data.File_Names (Unit_Kind).Project)\n-               then\n-                  if The_Unit_Data.File_Names (Unit_Kind).Path = Slash then\n-                     Remove_Forbidden_File_Name\n-                       (The_Unit_Data.File_Names (Unit_Kind).Name);\n-                  end if;\n+               if The_Unit /= Prj.Com.No_Unit then\n+                  The_Unit_Data := Units.Table (The_Unit);\n \n-                  --  Record the file name in the hash table Files_Htable\n-\n-                  Unit_Prj := (Unit => The_Unit, Project => Project);\n-                  Files_Htable.Set (Canonical_File_Name, Unit_Prj);\n-\n-                  The_Unit_Data.File_Names (Unit_Kind) :=\n-                    (Name         => Canonical_File_Name,\n-                     Display_Name => File_Name,\n-                     Path         => Canonical_Path_Name,\n-                     Display_Path => Path_Name,\n-                     Project      => Project,\n-                     Needs_Pragma => Needs_Pragma);\n-                  Units.Table (The_Unit) := The_Unit_Data;\n-                  Source_Recorded := True;\n-\n-               elsif The_Unit_Data.File_Names (Unit_Kind).Project = Project\n-                 and then (Data.Known_Order_Of_Source_Dirs or else\n-                           The_Unit_Data.File_Names (Unit_Kind).Path =\n-                                                          Canonical_Path_Name)\n-               then\n-                  if Previous_Source = Nil_String then\n-                     Data.Sources := Nil_String;\n-                  else\n-                     String_Elements.Table (Previous_Source).Next :=\n-                       Nil_String;\n-                     String_Elements.Decrement_Last;\n-                  end if;\n+                  if The_Unit_Data.File_Names (Unit_Kind).Name = No_Name\n+                    or else Project_Extends\n+                      (Data.Extends,\n+                       The_Unit_Data.File_Names (Unit_Kind).Project)\n+                  then\n+                     if The_Unit_Data.File_Names (Unit_Kind).Path = Slash then\n+                        Remove_Forbidden_File_Name\n+                          (The_Unit_Data.File_Names (Unit_Kind).Name);\n+                     end if;\n \n-                  Current_Source := Previous_Source;\n+                     --  Record the file name in the hash table Files_Htable\n+\n+                     Unit_Prj := (Unit => The_Unit, Project => Project);\n+                     Files_Htable.Set (Canonical_File_Name, Unit_Prj);\n+\n+                     The_Unit_Data.File_Names (Unit_Kind) :=\n+                       (Name         => Canonical_File_Name,\n+                        Index        => Unit_Index,\n+                        Display_Name => File_Name,\n+                        Path         => Canonical_Path_Name,\n+                        Display_Path => Path_Name,\n+                        Project      => Project,\n+                        Needs_Pragma => Needs_Pragma);\n+                     Units.Table (The_Unit) := The_Unit_Data;\n+                     Source_Recorded := True;\n+\n+                  elsif The_Unit_Data.File_Names (Unit_Kind).Project = Project\n+                    and then (Data.Known_Order_Of_Source_Dirs or else\n+                              The_Unit_Data.File_Names (Unit_Kind).Path =\n+                                Canonical_Path_Name)\n+                  then\n+                     if Previous_Source = Nil_String then\n+                        Data.Sources := Nil_String;\n+                     else\n+                        String_Elements.Table (Previous_Source).Next :=\n+                          Nil_String;\n+                        String_Elements.Decrement_Last;\n+                     end if;\n \n-               else\n-                  --  It is an error to have two units with the same name\n-                  --  and the same kind (spec or body).\n+                     Current_Source := Previous_Source;\n \n-                  if The_Location = No_Location then\n-                     The_Location := Projects.Table (Project).Location;\n-                  end if;\n+                  else\n+                     --  It is an error to have two units with the same name\n+                     --  and the same kind (spec or body).\n \n-                  Err_Vars.Error_Msg_Name_1 := Unit_Name;\n-                  Error_Msg (Project, \"duplicate source {\", The_Location);\n+                     if The_Location = No_Location then\n+                        The_Location := Projects.Table (Project).Location;\n+                     end if;\n \n-                  Err_Vars.Error_Msg_Name_1 :=\n-                    Projects.Table\n-                      (The_Unit_Data.File_Names (Unit_Kind).Project).Name;\n-                  Err_Vars.Error_Msg_Name_2 :=\n-                    The_Unit_Data.File_Names (Unit_Kind).Path;\n-                  Error_Msg (Project, \"\\   project file {, {\", The_Location);\n+                     Err_Vars.Error_Msg_Name_1 := Unit_Name;\n+                     Error_Msg (Project, \"duplicate source {\", The_Location);\n \n-                  Err_Vars.Error_Msg_Name_1 := Projects.Table (Project).Name;\n-                  Err_Vars.Error_Msg_Name_2 := Canonical_Path_Name;\n-                  Error_Msg (Project, \"\\   project file {, {\", The_Location);\n+                     Err_Vars.Error_Msg_Name_1 :=\n+                       Projects.Table\n+                         (The_Unit_Data.File_Names (Unit_Kind).Project).Name;\n+                     Err_Vars.Error_Msg_Name_2 :=\n+                       The_Unit_Data.File_Names (Unit_Kind).Path;\n+                     Error_Msg\n+                       (Project, \"\\   project file {, {\", The_Location);\n \n-               end if;\n+                     Err_Vars.Error_Msg_Name_1 :=\n+                       Projects.Table (Project).Name;\n+                     Err_Vars.Error_Msg_Name_2 := Canonical_Path_Name;\n+                     Error_Msg\n+                       (Project, \"\\   project file {, {\", The_Location);\n \n-            --  It is a new unit, create a new record\n+                  end if;\n \n-            else\n-               --  First, check if there is no other unit with this file name\n-               --  in another project. If it is, report an error.\n+                  --  It is a new unit, create a new record\n \n-               Unit_Prj := Files_Htable.Get (Canonical_File_Name);\n+               else\n+                  --  First, check if there is no other unit with this file\n+                  --  name in another project. If it is, report an error.\n+                  --  Of course, we do that only for the first unit in the\n+                  --  source file.\n \n-               if Unit_Prj /= No_Unit_Project then\n-                  Error_Msg_Name_1 := File_Name;\n-                  Error_Msg_Name_2 := Projects.Table (Unit_Prj.Project).Name;\n-                  Error_Msg\n-                    (Project,\n-                     \"{ is already a source of project {\",\n-                     Location);\n+                  Unit_Prj := Files_Htable.Get (Canonical_File_Name);\n \n-               else\n-                  Units.Increment_Last;\n-                  The_Unit := Units.Last;\n-                  Units_Htable.Set (Unit_Name, The_Unit);\n-                  Unit_Prj := (Unit => The_Unit, Project => Project);\n-                  Files_Htable.Set (Canonical_File_Name, Unit_Prj);\n-                  The_Unit_Data.Name := Unit_Name;\n-                  The_Unit_Data.File_Names (Unit_Kind) :=\n-                    (Name         => Canonical_File_Name,\n-                     Display_Name => File_Name,\n-                     Path         => Canonical_Path_Name,\n-                     Display_Path => Path_Name,\n-                     Project      => Project,\n-                     Needs_Pragma => Needs_Pragma);\n-                  Units.Table (The_Unit) := The_Unit_Data;\n-                  Source_Recorded := True;\n+                  if not File_Name_Recorded and then\n+                    Unit_Prj /= No_Unit_Project\n+                  then\n+                     Error_Msg_Name_1 := File_Name;\n+                     Error_Msg_Name_2 :=\n+                       Projects.Table (Unit_Prj.Project).Name;\n+                     Error_Msg\n+                       (Project,\n+                        \"{ is already a source of project {\",\n+                        Location);\n+\n+                  else\n+                     Units.Increment_Last;\n+                     The_Unit := Units.Last;\n+                     Units_Htable.Set (Unit_Name, The_Unit);\n+                     Unit_Prj := (Unit => The_Unit, Project => Project);\n+                     Files_Htable.Set (Canonical_File_Name, Unit_Prj);\n+                     The_Unit_Data.Name := Unit_Name;\n+                     The_Unit_Data.File_Names (Unit_Kind) :=\n+                       (Name         => Canonical_File_Name,\n+                        Index        => Unit_Index,\n+                        Display_Name => File_Name,\n+                        Path         => Canonical_Path_Name,\n+                        Display_Path => Path_Name,\n+                        Project      => Project,\n+                        Needs_Pragma => Needs_Pragma);\n+                     Units.Table (The_Unit) := The_Unit_Data;\n+                     Source_Recorded := True;\n+                  end if;\n                end if;\n-            end if;\n-         end;\n+            end;\n+\n+            exit when Exception_Id = No_Ada_Naming_Exception;\n+            File_Name_Recorded := True;\n+         end loop;\n       end if;\n    end Record_Ada_Source;\n \n@@ -4797,8 +4862,9 @@ package body Prj.Nmsc is\n    is\n       Suffix : constant Variable_Value :=\n         Value_Of\n-          (Index => Lang_Name_Ids (Language),\n-           In_Array => Naming.Body_Suffix);\n+          (Index     => Lang_Name_Ids (Language),\n+           Src_Index => 0,\n+           In_Array  => Naming.Body_Suffix);\n    begin\n       --  If no suffix for this language is found in package Naming, use the\n       --  default."}, {"sha": "f9cceb5bc52f7d6f216ed4fbe71ebabd3723705b", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -454,6 +454,11 @@ package body Prj.PP is\n                   pragma Debug (Indicate_Tested (N_Literal_String));\n                   Output_String (String_Value_Of (Node));\n \n+                  if Source_Index_Of (Node) /= 0 then\n+                     Write_String (\" at \");\n+                     Write_String (Source_Index_Of (Node)'Img);\n+                  end if;\n+\n                when N_Attribute_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Declaration));\n                   Print (First_Comment_Before (Node), Indent);\n@@ -464,6 +469,12 @@ package body Prj.PP is\n                   if Associative_Array_Index_Of (Node) /= No_Name then\n                      Write_String (\" (\");\n                      Output_String (Associative_Array_Index_Of (Node));\n+\n+                     if Source_Index_Of (Node) /= 0 then\n+                        Write_String (\" at \");\n+                        Write_String (Source_Index_Of (Node)'Img);\n+                     end if;\n+\n                      Write_String (\")\");\n                   end if;\n "}, {"sha": "439645e4bb7f78b774e3863741bcfaadafd12b95", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -182,7 +182,8 @@ package body Prj.Proc is\n                         Kind     => Single,\n                         Location => No_Location,\n                         Default  => True,\n-                        Value    => Empty_String);\n+                        Value    => Empty_String,\n+                        Index    => 0);\n \n                   --  List attributes have a default value of nil list\n \n@@ -275,6 +276,7 @@ package body Prj.Proc is\n \n                   when Single =>\n                      Add (Result.Value, String_Value_Of (The_Current_Term));\n+                     Result.Index := Source_Index_Of (The_Current_Term);\n \n                   when List =>\n \n@@ -295,6 +297,7 @@ package body Prj.Proc is\n                      Last := String_Elements.Last;\n                      String_Elements.Table (Last) :=\n                        (Value    => String_Value_Of (The_Current_Term),\n+                        Index    => Source_Index_Of (The_Current_Term),\n                         Display_Value => No_Name,\n                         Location => Location_Of (The_Current_Term),\n                         Flag     => False,\n@@ -342,7 +345,8 @@ package body Prj.Proc is\n                         Display_Value => No_Name,\n                         Location => Value.Location,\n                         Flag     => False,\n-                        Next     => Nil_String);\n+                        Next     => Nil_String,\n+                        Index    => Value.Index);\n \n                      loop\n                         --  Add the other element of the literal string list\n@@ -370,7 +374,8 @@ package body Prj.Proc is\n                            Display_Value => No_Name,\n                            Location => Value.Location,\n                            Flag     => False,\n-                           Next     => Nil_String);\n+                           Next     => Nil_String,\n+                           Index    => Value.Index);\n                      end loop;\n \n                   end if;\n@@ -560,7 +565,8 @@ package body Prj.Proc is\n                                  Kind     => Single,\n                                  Location => No_Location,\n                                  Default  => True,\n-                                 Value    => Empty_String);\n+                                 Value    => Empty_String,\n+                                 Index    => 0);\n                            end if;\n                         end if;\n                      end;\n@@ -623,7 +629,8 @@ package body Prj.Proc is\n                                  Display_Value => No_Name,\n                                  Location => Location_Of (The_Current_Term),\n                                  Flag     => False,\n-                                 Next     => Nil_String);\n+                                 Next     => Nil_String,\n+                                 Index    => 0);\n \n                            when List =>\n \n@@ -653,7 +660,8 @@ package body Prj.Proc is\n                                        Location => Location_Of\n                                                           (The_Current_Term),\n                                        Flag     => False,\n-                                       Next     => Nil_String);\n+                                       Next     => Nil_String,\n+                                       Index    => 0);\n                                     The_List :=\n                                       String_Elements.Table (The_List).Next;\n                                  end loop;\n@@ -725,7 +733,8 @@ package body Prj.Proc is\n                            Display_Value => No_Name,\n                            Location => Location_Of (The_Current_Term),\n                            Flag     => False,\n-                           Next     => Nil_String);\n+                           Next     => Nil_String,\n+                           Index    => 0);\n \n                   end case;\n                end;\n@@ -1582,6 +1591,7 @@ package body Prj.Proc is\n \n                               Array_Elements.Table (The_Array_Element) :=\n                                 (Index  => Index_Name,\n+                                 Src_Index => Source_Index_Of (Current_Item),\n                                  Index_Case_Sensitive =>\n                                  not Case_Insensitive (Current_Item),\n                                  Value  => New_Value,"}, {"sha": "8dade50791560b096489e1c56a93e17dff63f099", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Scans;     use Scans;\n with Snames;\n with Table;\n with Types;     use Types;\n+with Uintp;     use Uintp;\n \n package body Prj.Strt is\n \n@@ -115,7 +116,8 @@ package body Prj.Strt is\n      (Term            : out Project_Node_Id;\n       Expr_Kind       : in out Variable_Kind;\n       Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id);\n+      Current_Package : Project_Node_Id;\n+      Optional_Index  : Boolean);\n    --  Recursive procedure to parse one term or several terms concatenated\n    --  using \"&\".\n \n@@ -454,7 +456,8 @@ package body Prj.Strt is\n    procedure Parse_Expression\n      (Expression      : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id)\n+      Current_Package : Project_Node_Id;\n+      Optional_Index  : Boolean)\n    is\n       First_Term      : Project_Node_Id := Empty_Node;\n       Expression_Kind : Variable_Kind := Undefined;\n@@ -470,7 +473,8 @@ package body Prj.Strt is\n       Terms (Term            => First_Term,\n              Expr_Kind       => Expression_Kind,\n              Current_Project => Current_Project,\n-             Current_Package => Current_Package);\n+             Current_Package => Current_Package,\n+             Optional_Index  => Optional_Index);\n \n       --  Set the first term and the expression kind\n \n@@ -1077,7 +1081,8 @@ package body Prj.Strt is\n      (Term            : out Project_Node_Id;\n       Expr_Kind       : in out Variable_Kind;\n       Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id)\n+      Current_Package : Project_Node_Id;\n+      Optional_Index  : Boolean)\n    is\n       Next_Term          : Project_Node_Id := Empty_Node;\n       Term_Id            : Project_Node_Id := Empty_Node;\n@@ -1143,7 +1148,8 @@ package body Prj.Strt is\n                   Current_Location := Token_Ptr;\n                   Parse_Expression (Expression      => Next_Expression,\n                                     Current_Project => Current_Project,\n-                                    Current_Package => Current_Package);\n+                                    Current_Package => Current_Package,\n+                                    Optional_Index  => Optional_Index);\n \n                   --  The expression kind is String list, report an error\n \n@@ -1199,6 +1205,37 @@ package body Prj.Strt is\n \n             Scan;\n \n+            if Token = Tok_At then\n+               if not Optional_Index then\n+                  Error_Msg (\"index not allowed here\", Token_Ptr);\n+                  Scan;\n+\n+                  if Token = Tok_Integer_Literal then\n+                     Scan;\n+                  end if;\n+\n+               else\n+                  Scan;\n+                  Expect (Tok_Integer_Literal, \"integer literal\");\n+\n+                  if Token = Tok_Integer_Literal then\n+                     declare\n+                        Index : constant Int := UI_To_Int (Int_Literal_Value);\n+                     begin\n+                        if Index = 0 then\n+                           Error_Msg (\"index cannot be zero\", Token_Ptr);\n+\n+                        else\n+                           --  Set the index\n+                           Set_Source_Index_Of (Term_Id, To => Index);\n+                        end if;\n+                     end;\n+\n+                     Scan;\n+                  end if;\n+               end if;\n+            end if;\n+\n          when Tok_Identifier =>\n             Current_Location := Token_Ptr;\n \n@@ -1292,7 +1329,8 @@ package body Prj.Strt is\n          Terms (Term            => Next_Term,\n                 Expr_Kind       => Expr_Kind,\n                 Current_Project => Current_Project,\n-                Current_Package => Current_Package);\n+                Current_Package => Current_Package,\n+                Optional_Index  => Optional_Index);\n \n          --  And link the next term to this term\n "}, {"sha": "633b022e8f5907a4f85c3288e22bbdaef6513d25", "filename": "gcc/ada/prj-strt.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-strt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-strt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -70,7 +70,8 @@ private package Prj.Strt is\n    procedure Parse_Expression\n      (Expression      : out Project_Node_Id;\n       Current_Project : Project_Node_Id;\n-      Current_Package : Project_Node_Id);\n+      Current_Package : Project_Node_Id;\n+      Optional_Index  : Boolean);\n    --  Parse a simple string expression or a string list expression.\n    --  Current_Project is the node of the project file being parsed.\n    --  Current_Package is the node of the package being parsed,"}, {"sha": "993d1ecf451be357b51d903012332c98dd399db6", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -111,6 +111,7 @@ package body Prj.Tree is\n             Packages         => Empty_Node,\n             Pkg_Id           => Empty_Package,\n             Name             => No_Name,\n+            Src_Index        => 0,\n             Path_Name        => No_Name,\n             Value            => No_Name,\n             Field1           => Empty_Node,\n@@ -157,6 +158,7 @@ package body Prj.Tree is\n                Packages         => Empty_Node,\n                Pkg_Id           => Empty_Package,\n                Name             => No_Name,\n+               Src_Index        => 0,\n                Path_Name        => No_Name,\n                Value            => Comments.Table (J).Value,\n                Field1           => Empty_Node,\n@@ -204,7 +206,6 @@ package body Prj.Tree is\n       Comments.Set_Last (0);\n    end Add_Comments;\n \n-\n    --------------------------------\n    -- Associative_Array_Index_Of --\n    --------------------------------\n@@ -310,6 +311,7 @@ package body Prj.Tree is\n          Packages         => Empty_Node,\n          Pkg_Id           => Empty_Package,\n          Name             => No_Name,\n+         Src_Index        => 0,\n          Path_Name        => No_Name,\n          Value            => No_Name,\n          Field1           => Empty_Node,\n@@ -379,6 +381,7 @@ package body Prj.Tree is\n          Packages         => Empty_Node,\n          Pkg_Id           => Empty_Package,\n          Name             => No_Name,\n+         Src_Index        => 0,\n          Path_Name        => No_Name,\n          Value            => No_Name,\n          Field1           => Empty_Node,\n@@ -411,6 +414,7 @@ package body Prj.Tree is\n                Packages         => Empty_Node,\n                Pkg_Id           => Empty_Package,\n                Name             => No_Name,\n+               Src_Index        => 0,\n                Path_Name        => No_Name,\n                Value            => No_Name,\n                Field1           => Empty_Node,\n@@ -441,6 +445,7 @@ package body Prj.Tree is\n                   Packages         => Empty_Node,\n                   Pkg_Id           => Empty_Package,\n                   Name             => No_Name,\n+                  Src_Index        => 0,\n                   Path_Name        => No_Name,\n                   Value            => Comments.Table (J).Value,\n                   Field1           => Empty_Node,\n@@ -2323,6 +2328,24 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Field1 := To;\n    end Set_Project_Of_Renamed_Package_Of;\n \n+   -------------------------\n+   -- Set_Source_Index_Of --\n+   -------------------------\n+\n+   procedure Set_Source_Index_Of\n+     (Node : Project_Node_Id;\n+      To   : Int)\n+   is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+           (Project_Nodes.Table (Node).Kind = N_Literal_String\n+            or else\n+            Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n+      Project_Nodes.Table (Node).Src_Index := To;\n+   end Set_Source_Index_Of;\n+\n    ------------------------\n    -- Set_String_Type_Of --\n    ------------------------\n@@ -2368,6 +2391,21 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Value := To;\n    end Set_String_Value_Of;\n \n+   ---------------------\n+   -- Source_Index_Of --\n+   ---------------------\n+\n+   function Source_Index_Of (Node : Project_Node_Id) return Int is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+           (Project_Nodes.Table (Node).Kind = N_Literal_String\n+            or else\n+            Project_Nodes.Table (Node).Kind = N_Attribute_Declaration));\n+      return Project_Nodes.Table (Node).Src_Index;\n+   end Source_Index_Of;\n+\n    --------------------\n    -- String_Type_Of --\n    --------------------\n@@ -2450,5 +2488,4 @@ package body Prj.Tree is\n       return Unkept_Comments;\n    end There_Are_Unkept_Comments;\n \n-\n end Prj.Tree;"}, {"sha": "c376d3beee262db18e724a9b5e70d958781507ff", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -269,6 +269,10 @@ package Prj.Tree is\n    pragma Inline (String_Value_Of);\n    --  Only valid for N_With_Clause, N_Literal_String nodes or N_Comment\n \n+   function Source_Index_Of (Node : Project_Node_Id) return Int;\n+   pragma Inline (Source_Index_Of);\n+   --  Only valid for N_Literal_String and N_Attribute_Declaration nodes\n+\n    function First_With_Clause_Of\n      (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_With_Clause_Of);\n@@ -694,6 +698,11 @@ package Prj.Tree is\n       To   : Project_Node_Id);\n    pragma Inline (Set_Package_Node_Of);\n \n+   procedure Set_Source_Index_Of\n+     (Node : Project_Node_Id;\n+      To   : Int);\n+   pragma Inline (Set_Source_Index_Of);\n+\n    procedure Set_String_Type_Of\n      (Node : Project_Node_Id;\n       To   : Project_Node_Id);\n@@ -773,6 +782,10 @@ package Prj.Tree is\n          Name : Name_Id := No_Name;\n          --  See below for what Project_Node_Kind it is used\n \n+         Src_Index : Int := 0;\n+         --  Index of a unit in a multi-unit source.\n+         --  Onli for some N_Attribute_Declaration and N_Literal_String.\n+\n          Path_Name : Name_Id := No_Name;\n          --  See below for what Project_Node_Kind it is used\n "}, {"sha": "9de974760ddc002887ce30c35bfad24c9d7121ae", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -76,6 +76,7 @@ package body Prj.Util is\n    function Executable_Of\n      (Project  : Project_Id;\n       Main     : Name_Id;\n+      Index    : Int;\n       Ada_Main : Boolean := True) return Name_Id\n    is\n       pragma Assert (Project /= No_Project);\n@@ -91,12 +92,14 @@ package body Prj.Util is\n       Executable : Variable_Value :=\n                      Prj.Util.Value_Of\n                        (Name                    => Main,\n+                        Index                   => Index,\n                         Attribute_Or_Array_Name => Name_Executable,\n                         In_Package              => Builder_Package);\n \n       Executable_Suffix : constant Variable_Value :=\n                             Prj.Util.Value_Of\n                               (Name                    => Main,\n+                               Index                   => 0,\n                                Attribute_Or_Array_Name =>\n                                  Name_Executable_Suffix,\n                                In_Package              => Builder_Package);\n@@ -158,6 +161,7 @@ package body Prj.Util is\n                   Executable :=\n                     Prj.Util.Value_Of\n                       (Name                    => Name_Find,\n+                       Index                   => 0,\n                        Attribute_Or_Array_Name => Name_Executable,\n                        In_Package              => Builder_Package);\n                end if;\n@@ -395,8 +399,8 @@ package body Prj.Util is\n    end Value_Of;\n \n    function Value_Of\n-     (Index    : Name_Id;\n-      In_Array : Array_Element_Id) return Name_Id\n+     (Index     : Name_Id;\n+      In_Array  : Array_Element_Id) return Name_Id\n    is\n       Current    : Array_Element_Id := In_Array;\n       Element    : Array_Element;\n@@ -431,8 +435,9 @@ package body Prj.Util is\n    end Value_Of;\n \n    function Value_Of\n-     (Index    : Name_Id;\n-      In_Array : Array_Element_Id) return Variable_Value\n+     (Index     : Name_Id;\n+      Src_Index : Int := 0;\n+      In_Array  : Array_Element_Id) return Variable_Value\n    is\n       Current : Array_Element_Id := In_Array;\n       Element : Array_Element;\n@@ -454,7 +459,9 @@ package body Prj.Util is\n       while Current /= No_Array_Element loop\n          Element := Array_Elements.Table (Current);\n \n-         if Real_Index = Element.Index then\n+         if Real_Index = Element.Index and then\n+           Src_Index = Element.Src_Index\n+         then\n             return Element.Value;\n          else\n             Current := Element.Next;\n@@ -466,6 +473,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Name                    : Name_Id;\n+      Index                   : Int := 0;\n       Attribute_Or_Array_Name : Name_Id;\n       In_Package              : Package_Id) return Variable_Value\n    is\n@@ -483,8 +491,9 @@ package body Prj.Util is\n               In_Arrays => Packages.Table (In_Package).Decl.Arrays);\n          The_Attribute :=\n            Value_Of\n-             (Index    => Name,\n-              In_Array => The_Array);\n+             (Index     => Name,\n+              Src_Index => Index,\n+              In_Array  => The_Array);\n \n          --  If there is no array element, look for a variable\n "}, {"sha": "7373a640d595cdc59867b0bca13bd3bc3e4c09e0", "filename": "gcc/ada/prj-util.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -35,6 +35,7 @@ package Prj.Util is\n    function Executable_Of\n      (Project  : Project_Id;\n       Main     : Name_Id;\n+      Index    : Int;\n       Ada_Main : Boolean := True) return Name_Id;\n    --  Return the value of the attribute Builder'Executable for file Main in\n    --  the project Project, if it exists. If there is no attribute Executable\n@@ -59,8 +60,9 @@ package Prj.Util is\n    --  associative array.\n \n    function Value_Of\n-     (Index    : Name_Id;\n-      In_Array : Array_Element_Id) return Variable_Value;\n+     (Index     : Name_Id;\n+      Src_Index : Int := 0;\n+      In_Array  : Array_Element_Id) return Variable_Value;\n    --  Get a string array component (single String or String list).\n    --  Returns Nil_Variable_Value if there is no component Index\n    --  or if In_Array is null.\n@@ -72,6 +74,7 @@ package Prj.Util is\n \n    function Value_Of\n      (Name                    : Name_Id;\n+      Index                   : Int := 0;\n       Attribute_Or_Array_Name : Name_Id;\n       In_Package              : Package_Id) return Variable_Value;\n    --  In a specific package,"}, {"sha": "55523435f4f16fe1cad4480d16633d2996529ae3", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -34,6 +34,7 @@ with Prj.Env;\n with Prj.Err;  use Prj.Err;\n with Scans;    use Scans;\n with Snames;   use Snames;\n+with Uintp;    use Uintp;\n \n with GNAT.OS_Lib; use GNAT.OS_Lib;\n \n@@ -240,6 +241,7 @@ package body Prj is\n    begin\n       if not Initialized then\n          Initialized := True;\n+         Uintp.Initialize;\n          Name_Len := 0;\n          The_Empty_String := Name_Find;\n          Empty_Name := The_Empty_String;\n@@ -321,13 +323,15 @@ package body Prj is\n \n       if not Found then\n          Element :=\n-           (Index => Lang,\n+           (Index     => Lang,\n+            Src_Index => 0,\n             Index_Case_Sensitive => False,\n             Value => (Project  => No_Project,\n                       Kind     => Single,\n                       Location => No_Location,\n                       Default  => False,\n-                      Value    => Default_Spec_Suffix),\n+                      Value    => Default_Spec_Suffix,\n+                      Index    => 0),\n             Next  => Std_Naming_Data.Spec_Suffix);\n          Array_Elements.Increment_Last;\n          Array_Elements.Table (Array_Elements.Last) := Element;\n@@ -357,13 +361,15 @@ package body Prj is\n \n       if not Found then\n          Element :=\n-           (Index => Lang,\n+           (Index     => Lang,\n+            Src_Index => 0,\n             Index_Case_Sensitive => False,\n             Value => (Project  => No_Project,\n                       Kind     => Single,\n                       Location => No_Location,\n                       Default  => False,\n-                      Value    => Default_Body_Suffix),\n+                      Value    => Default_Body_Suffix,\n+                      Index    => 0),\n             Next  => Std_Naming_Data.Body_Suffix);\n          Array_Elements.Increment_Last;\n          Array_Elements.Table (Array_Elements.Last) := Element;"}, {"sha": "9d82b5ff841a23bfad916e56ba00f064caa8e437", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -197,6 +197,7 @@ package Prj is\n    Nil_String : constant String_List_Id := 0;\n    type String_Element is record\n       Value    : Name_Id        := No_Name;\n+      Index    : Int            := 0;\n       Display_Value : Name_Id   := No_Name;\n       Location : Source_Ptr     := No_Location;\n       Flag     : Boolean        := False;\n@@ -233,6 +234,7 @@ package Prj is\n             Values : String_List_Id := Nil_String;\n          when Single =>\n             Value : Name_Id := No_Name;\n+            Index : Int     := 0;\n       end case;\n    end record;\n    --  Values for variables and array elements.\n@@ -267,6 +269,7 @@ package Prj is\n    No_Array_Element : constant Array_Element_Id := 0;\n    type Array_Element is record\n       Index                : Name_Id;\n+      Src_Index            : Int := 0;\n       Index_Case_Sensitive : Boolean := True;\n       Value                : Variable_Value;\n       Next                 : Array_Element_Id := No_Array_Element;"}, {"sha": "2d7c61a057d48c7afd0ac451eff61dba72d6e49a", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -152,7 +152,7 @@ db_accepted_codes (void)\n \n   if (accepted_codes == -1)\n     {\n-      char * db_env = getenv (\"EH_DEBUG\");\n+      char * db_env = (char *) getenv (\"EH_DEBUG\");\n \n       accepted_codes = db_env ? (atoi (db_env) | DB_ERR) : 0;\n       /* Arranged for ERR stuff to always be visible when the variable"}, {"sha": "afe954e71acfbe1b0bc34b204c24608fc4b8f993", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -4820,19 +4820,9 @@ package body Sem_Attr is\n       --------------\n \n       when Attribute_Definite =>\n-         declare\n-            Result : Node_Id;\n-\n-         begin\n-            if Is_Indefinite_Subtype (P_Entity) then\n-               Result := New_Occurrence_Of (Standard_False, Loc);\n-            else\n-               Result := New_Occurrence_Of (Standard_True, Loc);\n-            end if;\n-\n-            Rewrite (N, Result);\n-            Analyze_And_Resolve (N, Standard_Boolean);\n-         end;\n+         Rewrite (N, New_Occurrence_Of (\n+           Boolean_Literals (not Is_Indefinite_Subtype (P_Entity)), Loc));\n+         Analyze_And_Resolve (N, Standard_Boolean);\n \n       ------------\n       -- Denorm --\n@@ -4961,19 +4951,9 @@ package body Sem_Attr is\n       -----------------------\n \n       when Attribute_Has_Discriminants =>\n-         declare\n-            Result : Node_Id;\n-\n-         begin\n-            if Has_Discriminants (P_Entity) then\n-               Result := New_Occurrence_Of (Standard_True, Loc);\n-            else\n-               Result := New_Occurrence_Of (Standard_False, Loc);\n-            end if;\n-\n-            Rewrite (N, Result);\n-            Analyze_And_Resolve (N, Standard_Boolean);\n-         end;\n+         Rewrite (N, New_Occurrence_Of (\n+           Boolean_Literals (Has_Discriminants (P_Entity)), Loc));\n+         Analyze_And_Resolve (N, Standard_Boolean);\n \n       --------------\n       -- Identity --\n@@ -5962,13 +5942,10 @@ package body Sem_Attr is\n          Typ : constant Entity_Id := Underlying_Type (P_Type);\n \n       begin\n-         if Is_Array_Type (P_Type)\n-           and then not Is_Constrained (Typ)\n-         then\n-            Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n-         else\n-            Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n-         end if;\n+         Rewrite (N, New_Occurrence_Of (\n+           Boolean_Literals (\n+             Is_Array_Type (P_Type)\n+              and then not Is_Constrained (Typ)), Loc));\n \n          --  Analyze and resolve as boolean, note that this attribute is\n          --  a static attribute in GNAT."}, {"sha": "69e324b0a7f5584eeca8c8a8be53bf11fe3ee732", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -1399,6 +1399,10 @@ package body Sem_Ch13 is\n             --  Return true if the entity is a procedure with an\n             --  appropriate profile for the write attribute.\n \n+            ----------------------\n+            -- Has_Good_Profile --\n+            ----------------------\n+\n             function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n                F     : Entity_Id;\n                Ok    : Boolean := False;"}, {"sha": "a800768af5b0f0b0381af02616c50403a39bb672", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -734,9 +734,12 @@ package body Sem_Ch3 is\n       --  discriminant, in a private or a full type declaration. In\n       --  the case of a subprogram, If the designated type is incomplete,\n       --  the operation will be a primitive operation of the full type, to\n-      --  be updated subsequently.\n+      --  be updated subsequently. If the type is imported through a limited\n+      --  with clause, it is not a primitive operation of the type (which\n+      --  is declared elsewhere in some other scope).\n \n       if Ekind (Desig_Type) = E_Incomplete_Type\n+        and then not From_With_Type (Desig_Type)\n         and then Is_Overloadable (Current_Scope)\n       then\n          Append_Elmt (Current_Scope, Private_Dependents (Desig_Type));\n@@ -9988,7 +9991,7 @@ package body Sem_Ch3 is\n              Defining_Identifier => T,\n              Subtype_Indication  => Relocate_Node (Obj_Def)));\n \n-         --  This subtype may need freezing and it will not be done\n+         --  This subtype may need freezing, and this will not be done\n          --  automatically if the object declaration is not in a\n          --  declarative part. Since this is an object declaration, the\n          --  type cannot always be frozen here. Deferred constants do not\n@@ -10125,7 +10128,7 @@ package body Sem_Ch3 is\n       elsif Can_Derive_From (Standard_Long_Long_Float) then\n          Base_Typ := Standard_Long_Long_Float;\n \n-      --  If we can't derive from any existing type, use long long float\n+      --  If we can't derive from any existing type, use long_long_float\n       --  and give appropriate message explaining the problem.\n \n       else"}, {"sha": "3d4f02eef6ff691cc82d4ebca60aca278d735977", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -88,6 +88,8 @@ package body Sem_Ch6 is\n    --  subsequenty used for inline expansions at call sites. If subprogram can\n    --  be inlined (depending on size and nature of local declarations) this\n    --  function returns true. Otherwise subprogram body is treated normally.\n+   --  If proper warnings are enabled and the subprogram contains a construct\n+   --  that cannot be inlined, the offending construct is flagged accordingly.\n \n    type Conformance_Type is\n      (Type_Conformant, Mode_Conformant, Subtype_Conformant, Fully_Conformant);\n@@ -2986,6 +2988,17 @@ package body Sem_Ch6 is\n               or else not Is_Generic_Actual_Type (T2)\n               or else Scope (T1) /= Scope (T2);\n \n+         --  In some cases a type imported through a limited_with clause,\n+         --  and its non-limited view are both visible, for example in an\n+         --  anonymous access_to_classwide type in a formal. Both entities\n+         --  designate the same type.\n+\n+         elsif From_With_Type (T1)\n+           and then Ekind (T1) = E_Incomplete_Type\n+           and then T2 = Non_Limited_View (T1)\n+         then\n+            return True;\n+\n          else\n             return False;\n          end if;"}, {"sha": "c48361092fe49c2d563c50ef84f92760e7b29ff9", "filename": "gcc/ada/sem_dist.adb", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -332,19 +332,12 @@ package body Sem_Dist is\n       RS_Pkg_Specif := Parent (Remote_Subp_Decl);\n       RS_Pkg_E := Defining_Entity (RS_Pkg_Specif);\n \n-      if Ekind (Remote_Subp) = E_Procedure\n-        and then Is_Asynchronous (Remote_Subp)\n-      then\n-         Async_E := Standard_True;\n-      else\n-         Async_E := Standard_False;\n-      end if;\n+      Async_E :=\n+        Boolean_Literals (Ekind (Remote_Subp) = E_Procedure\n+                            and then Is_Asynchronous (Remote_Subp));\n \n-      if Has_All_Calls_Remote (RS_Pkg_E) then\n-         All_Calls_Remote_E := Standard_True;\n-      else\n-         All_Calls_Remote_E := Standard_False;\n-      end if;\n+      All_Calls_Remote_E :=\n+        Boolean_Literals (Has_All_Calls_Remote (RS_Pkg_E));\n \n       Local_Addr :=\n         Make_Attribute_Reference (Loc,"}, {"sha": "db85ab27c958e674e032c3709d9bad9bfcc72cd0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -5588,11 +5588,8 @@ package body Sem_Util is\n \n    function Rep_To_Pos_Flag (E : Entity_Id; Loc : Source_Ptr) return Node_Id is\n    begin\n-      if Range_Checks_Suppressed (E) then\n-         return New_Occurrence_Of (Standard_False, Loc);\n-      else\n-         return New_Occurrence_Of (Standard_True, Loc);\n-      end if;\n+      return New_Occurrence_Of\n+               (Boolean_Literals (not Range_Checks_Suppressed (E)), Loc);\n    end Rep_To_Pos_Flag;\n \n    --------------------"}, {"sha": "0970a06a6eedd572a0bc341834695cd235b3918f", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -310,6 +310,9 @@ package Stand is\n    --  Highest List_Id value used by Standard (including those used by\n    --  normal list headers, element list headers, and list elements)\n \n+   Boolean_Literals : array (Boolean) of Entity_Id;\n+   --  Entities for the two boolean literals, used by the expander\n+\n    -------------------------------------\n    -- Semantic Phase Special Entities --\n    -------------------------------------"}, {"sha": "67cee51013997f117a8253f97a3f0afa45cc01f7", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -562,6 +562,12 @@ package body Switch.M is\n \n             case Switch_Chars (Ptr) is\n \n+               --  processing for eI switch\n+\n+               when 'I' =>\n+                  Ptr := Ptr + 1;\n+                  Scan_Pos (Switch_Chars, Max, Ptr, Main_Index);\n+\n                --  processing for eL switch\n \n                when 'L' =>"}, {"sha": "b5903da01900213a82a821b1ede8cdaeefb6481c", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -269,10 +269,12 @@ begin\n    Write_Switch_Char (\"Q\");\n    Write_Line (\"Don't quit, write ali/tree file even if compile errors\");\n \n-   --  Line for -gnatR switch\n+   --  Lines for -gnatR switch\n \n    Write_Switch_Char (\"R?\");\n-   Write_Line (\"List rep inf (?=0/1/2/3 for none/types/all/variable)\");\n+   Write_Line (\"List rep info (?=0/1/2/3 for none/types/all/variable)\");\n+   Write_Switch_Char (\"R?s\");\n+   Write_Line (\"List rep info to file.rep instead of standard output\");\n \n    --  Lines for -gnats switch\n "}, {"sha": "256d8a64a515e54f2246b08d552f841202725d19", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa720a546a2945095bfa7a8cfb2b0f1a4021763a/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=aa720a546a2945095bfa7a8cfb2b0f1a4021763a", "patch": "@@ -191,7 +191,6 @@ package VMS_Data is\n    -- Switches for GNAT BIND --\n    ----------------------------\n \n-\n    S_Bind_Bind    : aliased constant S := \"/BIND_FILE=\"                    &\n                                             \"ADA \"                         &\n                                                \"-A \"                       &\n@@ -490,7 +489,6 @@ package VMS_Data is\n                                             \"!-b,!-v\";\n    --  NODOC (see /REPORT_ERRORS)\n \n-\n    S_Bind_Restr   : aliased constant S := \"/RESTRICTION_LIST \"             &\n                                             \"-r\";\n    --        /NORESTRICTION_LIST (D)\n@@ -814,6 +812,13 @@ package VMS_Data is\n    --\n    --   Output a message explaining the usage of gnatclean.\n \n+   S_Clean_Index   : aliased constant S := \"/SOURCE_INDEX=#\"               &\n+                                             \"-i#\";\n+   --        /SOURCE_INDEX=nnn\n+   --\n+   --   Specifies the index of the units in the source file\n+   --   By default, source files are mono-unit and there is no index\n+\n    S_Clean_Mess    : aliased constant S := \"/MESSAGES_PROJECT_FILE=\"       &\n                                             \"DEFAULT \"                     &\n                                                \"-vP0 \"                     &\n@@ -833,7 +838,6 @@ package VMS_Data is\n    --      HIGH        A great number of messages are output, most of them not\n    --                  being useful for the user.\n \n-\n    S_Clean_Object  : aliased constant S := \"/OBJECT_SEARCH=*\"              &\n                                             \"-aO*\";\n    --        /OBJECT_SEARCH=(directory,...)\n@@ -892,6 +896,7 @@ package VMS_Data is\n       S_Clean_Ext    'Access,\n       S_Clean_Full   'Access,\n       S_Clean_Help   'Access,\n+      S_Clean_Index  'Access,\n       S_Clean_Mess   'Access,\n       S_Clean_Object 'Access,\n       S_Clean_Project'Access,\n@@ -3738,6 +3743,15 @@ package VMS_Data is\n    --   are found on the Ada object path, the new object and ALI files are\n    --   created in the directory containing the source being compiled.\n \n+   S_Make_Index   : aliased constant S := \"/SOURCE_INDEX=#\"               &\n+                                             \"-eI#\";\n+   --        /SOURCE_INDEX=nnn\n+   --\n+   --   Specifies the index of the units in the source file\n+   --   By default, source files are mono-unit and there is no index\n+   --   When /SOURCE_INDEX=nnn is specified, only one main may be specified\n+   --   on the command line.\n+\n    S_Make_Library : aliased constant S := \"/LIBRARY_SEARCH=*\"              &\n                                             \"-L*\";\n    --        /LIBRARY_SEARCH=(directory[,...])\n@@ -3965,6 +3979,7 @@ package VMS_Data is\n       S_Make_Force   'Access,\n       S_Make_Full    'Access,\n       S_Make_Inplace 'Access,\n+      S_Make_Index   'Access,\n       S_Make_Library 'Access,\n       S_Make_Link    'Access,\n       S_Make_Make    'Access,"}]}