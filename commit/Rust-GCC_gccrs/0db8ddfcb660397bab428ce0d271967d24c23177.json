{"sha": "0db8ddfcb660397bab428ce0d271967d24c23177", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRiOGRkZmNiNjYwMzk3YmFiNDI4Y2UwZDI3MTk2N2QyNGMyMzE3Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-08-22T15:13:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-08-22T15:13:09Z"}, "message": "re PR tree-optimization/81741 (Misoptimisation : replacing a constant field read access by a function call)\n\n\tPR tree-optimization/81741\n\tPR tree-optimization/71947\n\t* tree-ssa-dom.c: Include tree-inline.h.\n\t(record_temporary_equivalences): Only record SSA_NAME = SSA_NAME\n\tequivalences if one is more expensive to compute than the other.\n\t* tree-ssa-scopedtables.h (class const_or_copies): Make\n\trecord_const_or_copy_raw method private.\n\t(class avail_exprs_stack): New method simplify_binary_operation.\n\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr): Call\n\tavail_exprs_stack::simplify_binary_operation as needed.\n\t(avail_exprs_stack::simplify_binary_operation): New function.\n\n\tPR tree-optimization/81741\n\tPR tree-optimization/71947\n\t* gcc.dg/tree-ssa/pr81741.c: New test.\n\t* gcc.dg/tree-ssa/pr71947-7.c: New test.\n\t* gcc.dg/tree-ssa/pr71947-8.c: New test.\n\t* gcc.dg/tree-ssa/pr71947-9.c: New test.\n\t* gcc.dg/tree-ssa/pr71941-1.c: Tweak expected output.\n\t* gcc.dg/tree-ssa/pr71941-2.c: Tweak expected output.\n\t* gcc.dg/tree-ssa/pr71941-3.c: Tweak expected output.\n\t* gcc.dg/tree-ssa/20030922-2.c: xfail.\n\nFrom-SVN: r251279", "tree": {"sha": "4004740d0a74395c77ee7b55de8e23b4d1a201a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4004740d0a74395c77ee7b55de8e23b4d1a201a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0db8ddfcb660397bab428ce0d271967d24c23177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0db8ddfcb660397bab428ce0d271967d24c23177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0db8ddfcb660397bab428ce0d271967d24c23177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0db8ddfcb660397bab428ce0d271967d24c23177/comments", "author": null, "committer": null, "parents": [{"sha": "d4c550fd0ecb17d577353074c58283e942d1f870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c550fd0ecb17d577353074c58283e942d1f870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4c550fd0ecb17d577353074c58283e942d1f870"}], "stats": {"total": 254, "additions": 238, "deletions": 16}, "files": [{"sha": "9b941af74c69efbb362b1fa3defc6cef3f5f6c61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -1,3 +1,17 @@\n+2017-08-22  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/81741\n+\tPR tree-optimization/71947\n+\t* tree-ssa-dom.c: Include tree-inline.h.\n+\t(record_temporary_equivalences): Only record SSA_NAME = SSA_NAME\n+\tequivalences if one is more expensive to compute than the other.\n+\t* tree-ssa-scopedtables.h (class const_or_copies): Make\n+\trecord_const_or_copy_raw method private.\n+\t(class avail_exprs_stack): New method simplify_binary_operation.\n+\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr): Call\n+\tavail_exprs_stack::simplify_binary_operation as needed.\n+\t(avail_exprs_stack::simplify_binary_operation): New function.\n+\n 2017-08-22  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* config.gcc (powerpc-*-rtems*): Add rs6000/linux64.opt."}, {"sha": "531d0f95ae78a757472e8d852c0ee7ce1f036a4a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -1,3 +1,16 @@\n+2017-08-22  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/81741\n+\tPR tree-optimization/71947\n+\t* gcc.dg/tree-ssa/pr81741.c: New test.\n+\t* gcc.dg/tree-ssa/pr71947-7.c: New test.\n+\t* gcc.dg/tree-ssa/pr71947-8.c: New test.\n+\t* gcc.dg/tree-ssa/pr71947-9.c: New test.\n+\t* gcc.dg/tree-ssa/pr71941-1.c: Tweak expected output.\n+\t* gcc.dg/tree-ssa/pr71941-2.c: Tweak expected output.\n+\t* gcc.dg/tree-ssa/pr71941-3.c: Tweak expected output.\n+\t* gcc.dg/tree-ssa/20030922-2.c: xfail.\n+\n 2017-08-22  Yvan Roux  <yvan.roux@linaro.org>\n \n         PR c++/80287"}, {"sha": "172f203cf8e4da0959b990e4d94c95a302ad53d7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030922-2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -20,4 +20,6 @@ rgn_rank (rtx insn1, rtx insn2)\n }\n \n /* There should be two IF conditionals.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 2 \"dom2\" } } */\n+/* We no longer record the conditional equivalence by design, thus we\n+   are unable to simplify the 3rd conditional at compile time.  */\n+/* { dg-final { scan-tree-dump-times \"if \" 2 \"dom2\" { xfail *-*-* } } } */"}, {"sha": "ac8271cc574c28001bdb77ad56ac6ea22d64e36d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr71947-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-1.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -14,6 +14,6 @@ int f(int x, int y)\n    return ret;\n }\n \n-/* { dg-final { scan-tree-dump \"Folded to: ret_\\[0-9\\]+ = 0;\"  \"dom2\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced redundant expr \\[^\\r\\n\\]* with .0.\"  \"dom2\" } } */\n \n "}, {"sha": "b2c09cbb02119efb4d1dc49ee747cae9c8944fd4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr71947-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-2.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -13,4 +13,4 @@ int f(int x, int y)\n   return ret;\n }\n \n-/* { dg-final { scan-tree-dump \"Folded to: ret_\\[0-9\\]+ = 0;\"  \"dom2\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced redundant expr \\[^\\r\\n\\]* with .0.\"  \"dom2\" } } */"}, {"sha": "2316f7e1c0494df4b8907a8b706df912f3336d2e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr71947-3.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-3.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -9,4 +9,5 @@ int f(int x, int y)\n   return ret;\n }\n \n-/* { dg-final { scan-tree-dump \"Folded to: ret_\\[0-9\\]+ = 0;\"  \"dom2\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced redundant expr \\[^\\r\\n\\]* with .0.\"  \"dom2\" } } */\n+"}, {"sha": "b44c064aa2392aed208d4c02e9129ff240f27a03", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr71947-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-7.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-vrp -fdump-tree-dom-details\" } */\n+\n+\n+int f(int x, int y)\n+{\n+  int ret;\n+  if (x == y)\n+    ret = x % y;\n+  else\n+    ret = 1;\n+\n+  return ret;\n+}\n+/* { dg-final { scan-tree-dump \"Replaced redundant expr \\[^\\r\\n\\]* with .0.\"  \"dom2\" } } */\n+\n+"}, {"sha": "26e5abbdc293fa7115d34f11eb4e003f029cac3b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr71947-8.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-8.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-vrp -fdump-tree-dom-details\" } */\n+\n+\n+int f(int x, int y)\n+{\n+  int ret;\n+  if (x == y)\n+    ret = x / y;\n+  else\n+    ret = 0;\n+\n+  return ret;\n+}\n+/* { dg-final { scan-tree-dump \"Replaced redundant expr \\[^\\r\\n\\]* with .1.\"  \"dom2\" } } */\n+\n+"}, {"sha": "22b68d5ede064dc2efb52ee033c4b31bbb2ac369", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr71947-9.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr71947-9.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-vrp -fdump-tree-dom-details\" } */\n+\n+\n+int f(int x, int y)\n+{\n+  int ret;\n+  if (x == y)\n+    ret = x & y;\n+  else\n+    ret = 0;\n+\n+  return ret;\n+}\n+/* { dg-final { scan-tree-dump \"Replaced redundant expr \\[^\\r\\n\\]* with .\\(x|y\\).\"  \"dom2\" } } */\n+\n+"}, {"sha": "a162c3cf58ffb708032e7a5ed4942ebb70802960", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81741.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81741.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81741.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81741.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -w -fdump-tree-dom2-details\" } */\n+\n+#include <string.h>\n+\n+typedef struct string_s {\n+  unsigned long size, alloc;\n+  char *ptr;\n+} string_t[1];\n+\n+# define M_ASSUME(x)                                    \\\n+  (! __builtin_constant_p (!!(x) || !(x)) || (x) ?      \\\n+   (void) 0 : __builtin_unreachable())\n+\n+int f(string_t s)\n+{\n+  M_ASSUME(strlen(s->ptr) == s->size);\n+  return s->size;\n+}\n+\n+/* { dg-final { scan-assembler-not \"strlen\" } } */\n+"}, {"sha": "407a4ef97d2591287cf8f04a1f4b6ad773de4794", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"gimple-fold.h\"\n #include \"tree-eh.h\"\n+#include \"tree-inline.h\"\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n #include \"tree-into-ssa.h\"\n@@ -776,16 +777,27 @@ record_temporary_equivalences (edge e,\n \n       /* Record the simple NAME = VALUE equivalence.  */\n       tree rhs = edge_info->rhs;\n-      record_equality (lhs, rhs, const_and_copies);\n \n-      /* We already recorded that LHS = RHS, with canonicalization,\n-\t value chain following, etc.\n+      /* If this is a SSA_NAME = SSA_NAME equivalence and one operand is\n+\t cheaper to compute than the other, then set up the equivalence\n+\t such that we replace the expensive one with the cheap one.\n \n-\t We also want to record RHS = LHS, but without any canonicalization\n-\t or value chain following.  */\n-      if (TREE_CODE (rhs) == SSA_NAME)\n-\tconst_and_copies->record_const_or_copy_raw (rhs, lhs,\n-\t\t\t\t\t\t    SSA_NAME_VALUE (rhs));\n+\t If they are the same cost to compute, then do not record anything.  */\n+      if (TREE_CODE (lhs) == SSA_NAME && TREE_CODE (rhs) == SSA_NAME)\n+\t{\n+\t  gimple *rhs_def = SSA_NAME_DEF_STMT (rhs);\n+\t  int rhs_cost = estimate_num_insns (rhs_def, &eni_size_weights);\n+\n+\t  gimple *lhs_def = SSA_NAME_DEF_STMT (lhs);\n+\t  int lhs_cost = estimate_num_insns (lhs_def, &eni_size_weights);\n+\n+\t  if (rhs_cost > lhs_cost)\n+\t    record_equality (rhs, lhs, const_and_copies);\n+\t  else if (rhs_cost < lhs_cost)\n+\t    record_equality (lhs, rhs, const_and_copies);\n+\t}\n+      else\n+\trecord_equality (lhs, rhs, const_and_copies);\n \n       /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was\n \t set via a widening type conversion, then we may be able to record"}, {"sha": "6e1fd582814ac0d65c50819f681cb2920879befd", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -116,6 +116,102 @@ vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n   return NULL;\n }\n \n+/* We looked for STMT in the hash table, but did not find it.\n+\n+   If STMT is an assignment from a binary operator, we may know something\n+   about the operands relationship to each other which would allow\n+   us to derive a constant value for the RHS of STMT.  */\n+\n+tree\n+avail_exprs_stack::simplify_binary_operation (gimple *stmt,\n+\t\t\t\t\t      class expr_hash_elt element)\n+{\n+  if (is_gimple_assign (stmt))\n+    {\n+      struct hashable_expr *expr = element.expr ();\n+      if (expr->kind == EXPR_BINARY)\n+\t{\n+\t  enum tree_code code = expr->ops.binary.op;\n+\n+\t  switch (code)\n+\t    {\n+\t    /* For these cases, if we know the operands\n+\t       are equal, then we know the result.  */\n+\t    case MIN_EXPR:\n+\t    case MAX_EXPR:\n+\t    case BIT_IOR_EXPR:\n+\t    case BIT_AND_EXPR:\n+\t    case BIT_XOR_EXPR:\n+\t    case MINUS_EXPR:\n+\t    case TRUNC_DIV_EXPR:\n+\t    case CEIL_DIV_EXPR:\n+\t    case FLOOR_DIV_EXPR:\n+\t    case ROUND_DIV_EXPR:\n+\t    case EXACT_DIV_EXPR:\n+\t    case TRUNC_MOD_EXPR:\n+\t    case CEIL_MOD_EXPR:\n+\t    case FLOOR_MOD_EXPR:\n+\t    case ROUND_MOD_EXPR:\n+\t      {\n+\t\t/* Build a simple equality expr and query the hash table\n+\t\t   for it.  */\n+\t\tstruct hashable_expr expr;\n+\t\texpr.type = boolean_type_node;\n+\t\texpr.kind = EXPR_BINARY;\n+\t\texpr.ops.binary.op = EQ_EXPR;\n+\t\texpr.ops.binary.opnd0 = gimple_assign_rhs1 (stmt);\n+\t\texpr.ops.binary.opnd1 = gimple_assign_rhs2 (stmt);\n+\t\tclass expr_hash_elt element2 (&expr, NULL_TREE);\n+\t\texpr_hash_elt **slot\n+\t\t  = m_avail_exprs->find_slot (&element2, NO_INSERT);\n+\t\ttree result_type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\n+\t\t/* If the query was successful and returned a nonzero\n+\t\t   result, then we know that the operands of the binary\n+\t\t   expression are the same.  In many cases this allows\n+\t\t   us to compute a constant result of the expression\n+\t\t   at compile time, even if we do not know the exact\n+\t\t   values of the operands.  */\n+\t\tif (slot && *slot && integer_onep ((*slot)->lhs ()))\n+\t\t  {\n+\t\t    switch (code)\n+\t\t      {\n+\t\t      case MIN_EXPR:\n+\t\t      case MAX_EXPR:\n+\t\t      case BIT_IOR_EXPR:\n+\t\t      case BIT_AND_EXPR:\n+\t\t\treturn gimple_assign_rhs1 (stmt);\n+\n+\t\t      case BIT_XOR_EXPR:\n+\t\t      case MINUS_EXPR:\n+\t\t      case TRUNC_MOD_EXPR:\n+\t\t      case CEIL_MOD_EXPR:\n+\t\t      case FLOOR_MOD_EXPR:\n+\t\t      case ROUND_MOD_EXPR:\n+\t\t\treturn build_zero_cst (result_type);\n+\n+\t\t      case TRUNC_DIV_EXPR:\n+\t\t      case CEIL_DIV_EXPR:\n+\t\t      case FLOOR_DIV_EXPR:\n+\t\t      case ROUND_DIV_EXPR:\n+\t\t      case EXACT_DIV_EXPR:\n+\t\t\treturn build_one_cst (result_type);\n+\n+\t\t      default:\n+\t\t\tgcc_unreachable ();\n+\t\t      }\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\n+\t      default:\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Search for an existing instance of STMT in the AVAIL_EXPRS_STACK table.\n    If found, return its LHS. Otherwise insert STMT in the table and\n    return NULL_TREE.\n@@ -160,6 +256,12 @@ avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n     }\n   else if (*slot == NULL)\n     {\n+      /* If we did not find the expression in the hash table, we may still\n+\t be able to produce a result for some expressions.  */\n+      tree alt = avail_exprs_stack::simplify_binary_operation (stmt, element);\n+      if (alt)\n+\treturn alt;\n+\n       class expr_hash_elt *element2 = new expr_hash_elt (element);\n       *slot = element2;\n "}, {"sha": "e3d7bff6913380b495d6d75a794c4d415c7529dc", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db8ddfcb660397bab428ce0d271967d24c23177/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=0db8ddfcb660397bab428ce0d271967d24c23177", "patch": "@@ -156,6 +156,11 @@ class avail_exprs_stack\n   vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > m_stack;\n   hash_table<expr_elt_hasher> *m_avail_exprs;\n \n+  /* For some assignments where the RHS is a binary operator, if we know\n+     a equality relationship between the operands, we may be able to compute\n+     a result, even if we don't know the exact value of the operands.  */\n+  tree simplify_binary_operation (gimple *, class expr_hash_elt);\n+\n   /* We do not allow copying this object or initializing one\n      from another.  */\n   avail_exprs_stack& operator= (const avail_exprs_stack&);\n@@ -185,17 +190,17 @@ class const_and_copies\n      may follow the value chain for the RHS.  */\n   void record_const_or_copy (tree, tree);\n \n-  /* Record a single const/copy pair that can be unwound.  This version\n-     does not follow the value chain for the RHS.  */\n-  void record_const_or_copy_raw (tree, tree, tree);\n-\n   /* Special entry point when we want to provide an explicit previous\n      value for the first argument.  Try to get rid of this in the future. \n \n      This version may also follow the value chain for the RHS.  */\n   void record_const_or_copy (tree, tree, tree);\n \n  private:\n+  /* Record a single const/copy pair that can be unwound.  This version\n+     does not follow the value chain for the RHS.  */\n+  void record_const_or_copy_raw (tree, tree, tree);\n+\n   vec<tree> m_stack;\n   const_and_copies& operator= (const const_and_copies&);\n   const_and_copies (class const_and_copies &);"}]}