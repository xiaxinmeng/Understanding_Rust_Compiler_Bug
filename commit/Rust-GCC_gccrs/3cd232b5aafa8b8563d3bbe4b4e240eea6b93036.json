{"sha": "3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NkMjMyYjVhYWZhOGI4NTYzZDNiYmU0YjRlMjQwZWVhNmI5MzAzNg==", "commit": {"author": {"name": "Nguyen Duy Dat", "email": "dat.nguyen.yn@rvc.renesas.com", "date": "2013-01-09T15:07:08Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2013-01-09T15:07:08Z"}, "message": "v850.md (cbranchsf4): New pattern.\n\n\t* config/v850/v850.md (cbranchsf4): New pattern.\n\t(cstoresf4): New pattern.\n\t(cbranchdf4): New pattern.\n\t(cstoredf4): New pattern.\n\t(movsicc): Disallow floating point comparisons.\n\t(cmpsf_le_insn): Fix order of operators.\n\t(cmpsf_lt_insn): Likewise.\n\t(cmpsf_eq_insn): Likewise.\n\t(cmpdf_le_insn): Likewise.\n\t(cmpdf_lt_insn): Likewise.\n\t(cmpdf_eq_insn): Likewise.\n\t(cmpsf_ge_insn): Use LE comparison.\n\t(cmpdf_ge_insn): Likewise.\n\t(cmpsf_gt_insn): Use LT comparison.\n\t(cmpdf_gt_insn): Likewise.\n\t(cmpsf_ne_insn): Delete pattern.\n\t(cmpdf_ne_insn): Delete pattern.\n\t* config/v850/v850.c (v850_gen_float_compare): Use\n\tgen_cmpdf_eq_insn for NE comparison.\n\t(v850_float_z_comparison_operator)\n\t(v850_float_nz_comparison_operator): Move from here ...\n\t* config/v850/predicates.md: ... to here.  Move GT and GE\n\tcomparisons into v850_float_z_comparison_operator.\n\t* config/v850/v850-protos.h (v850_float_z_comparison_operator):\n\tDelete prototype.\n\t(v850_float_nz_comparison_operator): Likewise.\n\nFrom-SVN: r195053", "tree": {"sha": "0dbf0b610c223b5dc4566dfded8f297f4a38346e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dbf0b610c223b5dc4566dfded8f297f4a38346e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/comments", "author": null, "committer": null, "parents": [{"sha": "458752def198a1a663152609b4027fe08224b6f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458752def198a1a663152609b4027fe08224b6f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/458752def198a1a663152609b4027fe08224b6f8"}], "stats": {"total": 336, "additions": 233, "deletions": 103}, "files": [{"sha": "d76456fc6cec27001586d99146dcad7aaa293ebe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "patch": "@@ -1,3 +1,33 @@\n+2013-01-09  Nguyen Duy Dat\n+\t    Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/v850/v850.md (cbranchsf4): New pattern.\n+\t(cstoresf4): New pattern.\n+\t(cbranchdf4): New pattern.\n+\t(cstoredf4): New pattern.\n+\t(movsicc): Disallow floating point comparisons.\n+\t(cmpsf_le_insn): Fix order of operators.\n+\t(cmpsf_lt_insn): Likewise.\n+\t(cmpsf_eq_insn): Likewise.\n+\t(cmpdf_le_insn): Likewise.\n+\t(cmpdf_lt_insn): Likewise.\n+\t(cmpdf_eq_insn): Likewise.\n+\t(cmpsf_ge_insn): Use LE comparison.\n+\t(cmpdf_ge_insn): Likewise.\n+\t(cmpsf_gt_insn): Use LT comparison.\n+\t(cmpdf_gt_insn): Likewise.\n+\t(cmpsf_ne_insn): Delete pattern.\n+\t(cmpdf_ne_insn): Delete pattern.\n+\t* config/v850/v850.c (v850_gen_float_compare): Use\n+\tgen_cmpdf_eq_insn for NE comparison.\n+\t(v850_float_z_comparison_operator)\n+\t(v850_float_nz_comparison_operator): Move from here ...\n+\t* config/v850/predicates.md: ... to here.  Move GT and GE\n+\tcomparisons into v850_float_z_comparison_operator.\n+\t* config/v850/v850-protos.h (v850_float_z_comparison_operator):\n+\tDelete prototype.\n+\t(v850_float_nz_comparison_operator): Likewise.\n+\n 2013-01-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/pa/pa.c (pa_emit_move_sequence): Replace calls to gen_insv"}, {"sha": "6b1335efda91f82a75d8f8a93f7a1f09eb7f3fbc", "filename": "gcc/config/v850/predicates.md", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fpredicates.md?ref=3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "patch": "@@ -497,3 +497,68 @@\n \n   return op == CONST0_RTX(mode);\n })\n+\n+;; Return true if the floating point comparison operation\n+;; given produces a canonical answer.\n+(define_predicate \"v850_float_z_comparison_operator\"\n+  (match_code \"lt,le,eq,gt,ge\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != RTX_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n+    return 0;\n+\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n+\n+  if ((GET_CODE (XEXP (op, 0)) != REG\n+       || REGNO (XEXP (op, 0)) != CC_REGNUM)\n+      || XEXP (op, 1) != const0_rtx)\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_LTmode)\n+    return code == LT;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_LEmode)\n+    return code == LE;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_EQmode)\n+    return code == EQ;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_GTmode)\n+    return code == GT;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_GEmode)\n+    return code == GE;\n+\n+  /* Note we do not accept CC_FPU_NEmode here.  See\n+     v850_float_nz_comparison for the reason why.  */\n+  return 0;\n+})\n+\n+;; Return true if the floating point comparison operation\n+;; given produces an inverted answer.\n+(define_predicate \"v850_float_nz_comparison_operator\"\n+  (match_code \"ne\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  /* The V850E2V3 does not have a floating point NZ comparison operator.\n+     Instead it is implemented as an EQ comparison and this function ensures\n+     that the branch_nz_normal and set_nz_insn patterns are used to examine\n+     (and invert) the result of the floating point comparison.  */\n+\n+  if (GET_RTX_CLASS (code) != RTX_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n+    return 0;\n+\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n+\n+  if ((GET_CODE (XEXP (op, 0)) != REG\n+       || REGNO (XEXP (op, 0)) != CC_REGNUM)\n+      || XEXP (op, 1) != const0_rtx)\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_NEmode)\n+    return code == NE;\n+\n+  return 0;\n+})"}, {"sha": "0fa982e0978497530d85d1e7fd617a0ea99519c0", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "patch": "@@ -40,8 +40,6 @@ extern char * construct_restore_jr          (rtx);\n extern char * construct_dispose_instruction (rtx);\n extern char * construct_prepare_instruction (rtx);\n extern int    ep_memory_operand             (rtx, enum machine_mode, int);\n-extern int    v850_float_z_comparison_operator (rtx, enum machine_mode);\n-extern int    v850_float_nz_comparison_operator (rtx, enum machine_mode);\n extern rtx    v850_gen_compare              (enum rtx_code, enum machine_mode,\n \t\t\t\t\t     rtx, rtx);\n extern enum machine_mode  v850_gen_float_compare (enum rtx_code,"}, {"sha": "fb855cf5ed2e3f4b02c10944e1acc9ecbebd27ea", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 14, "deletions": 69, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "patch": "@@ -898,61 +898,6 @@ output_move_single (rtx * operands)\n   return \"\";\n }\n \n-/* Generate comparison code.  */\n-int\n-v850_float_z_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (GET_RTX_CLASS (code) != RTX_COMPARE\n-      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n-    return 0;\n-\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  if ((GET_CODE (XEXP (op, 0)) != REG\n-       || REGNO (XEXP (op, 0)) != CC_REGNUM)\n-      || XEXP (op, 1) != const0_rtx)\n-    return 0;\n-\n-  if (GET_MODE (XEXP (op, 0)) == CC_FPU_LTmode)\n-    return code == LT;\n-  if (GET_MODE (XEXP (op, 0)) == CC_FPU_LEmode)\n-    return code == LE;\n-  if (GET_MODE (XEXP (op, 0)) == CC_FPU_EQmode)\n-    return code == EQ;\n-\n-  return 0;\n-}\n-\n-int\n-v850_float_nz_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (GET_RTX_CLASS (code) != RTX_COMPARE\n-      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n-    return 0;\n-\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  if ((GET_CODE (XEXP (op, 0)) != REG\n-       || REGNO (XEXP (op, 0)) != CC_REGNUM)\n-      || XEXP (op, 1) != const0_rtx)\n-    return 0;\n-\n-  if (GET_MODE (XEXP (op, 0)) == CC_FPU_GTmode)\n-    return code == GT;\n-  if (GET_MODE (XEXP (op, 0)) == CC_FPU_GEmode)\n-    return code == GE;\n-  if (GET_MODE (XEXP (op, 0)) == CC_FPU_NEmode)\n-    return code == NE;\n-\n-  return code == GT || code == GE || code == NE;\n-}\n-\n enum machine_mode\n v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1 ATTRIBUTE_UNUSED)\n {\n@@ -973,7 +918,7 @@ v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1 ATTRIBUTE_UNUSED)\n \tcase NE:\n \t  return CC_FPU_NEmode;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return CCmode;\n@@ -982,7 +927,7 @@ v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1 ATTRIBUTE_UNUSED)\n enum machine_mode\n v850_gen_float_compare (enum rtx_code cond, enum machine_mode mode ATTRIBUTE_UNUSED, rtx op0, rtx op1)\n {\n-  if (GET_MODE(op0) == DFmode)\n+  if (GET_MODE (op0) == DFmode)\n     {\n       switch (cond)\n \t{\n@@ -998,17 +943,18 @@ v850_gen_float_compare (enum rtx_code cond, enum machine_mode mode ATTRIBUTE_UNU\n \tcase GT:\n \t  emit_insn (gen_cmpdf_gt_insn (op0, op1));\n \t  break;\n+\tcase NE:\n+\t  /* Note: There is no NE comparison operator. So we\n+\t     perform an EQ comparison and invert the branch.\n+\t     See v850_float_nz_comparison for how this is done.  */\n \tcase EQ:\n \t  emit_insn (gen_cmpdf_eq_insn (op0, op1));\n \t  break;\n-\tcase NE:\n-\t  emit_insn (gen_cmpdf_ne_insn (op0, op1));\n-\t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n-  else if (GET_MODE(v850_compare_op0) == SFmode)\n+  else if (GET_MODE (v850_compare_op0) == SFmode)\n     {\n       switch (cond)\n \t{\n@@ -1024,20 +970,19 @@ v850_gen_float_compare (enum rtx_code cond, enum machine_mode mode ATTRIBUTE_UNU\n \tcase GT:\n \t  emit_insn (gen_cmpsf_gt_insn(op0, op1));\n \t  break;\n+\tcase NE:\n+\t  /* Note: There is no NE comparison operator. So we\n+\t     perform an EQ comparison and invert the branch.\n+\t     See v850_float_nz_comparison for how this is done.  */\n \tcase EQ:\n \t  emit_insn (gen_cmpsf_eq_insn(op0, op1));\n \t  break;\n-\tcase NE:\n-\t  emit_insn (gen_cmpsf_ne_insn(op0, op1));\n-\t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n-    {\n-      abort ();\n-    }\n+    gcc_unreachable ();\n \n   return v850_select_cc_mode (cond, op0, op1);\n }"}, {"sha": "c05dee7aafd61858e27cb380d51c5237dd0f050c", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 124, "deletions": 32, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "patch": "@@ -405,6 +405,114 @@\n   [(set_attr \"length\" \"2,2\")\n    (set_attr \"cc\" \"compare\")])\n \n+(define_expand \"cbranchsf4\"\n+  [(set (pc)\n+       (if_then_else (match_operator     0 \"ordered_comparison_operator\"\n+                      [(match_operand:SF 1 \"register_operand\")\n+                       (match_operand:SF 2 \"register_operand\")])\n+                     (label_ref (match_operand 3 \"\"))\n+                     (pc)))\n+  (clobber (cc0))]\n+  \"TARGET_V850E2V3\"\n+{\n+  v850_compare_op0 = operands[1];\n+  v850_compare_op1 = operands[2];\n+\n+  enum rtx_code cond = GET_CODE(operands[0]);\n+  enum machine_mode mode;\n+  rtx fcc_reg;\n+  rtx cc_reg;\n+  rtx tmp;\n+\n+  if (GET_MODE_CLASS (GET_MODE (v850_compare_op0)) != MODE_FLOAT)\n+    FAIL;\n+\n+  mode = v850_gen_float_compare (cond, VOIDmode, v850_compare_op0, v850_compare_op1);\n+  fcc_reg = gen_rtx_REG (mode, FCC_REGNUM);\n+  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+  emit_insn(gen_rtx_SET (mode, cc_reg, fcc_reg));\n+  tmp = gen_rtx_fmt_ee (cond, mode, cc_reg, const0_rtx);\n+  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+                              gen_rtx_LABEL_REF (VOIDmode, operands[3]), pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n+  DONE;\n+})\n+\n+(define_insn \"cstoresf4\"\n+  [(set (match_operand:SI   0 \"register_operand\" \"=r\")\n+        (match_operator:SI  1 \"ordered_comparison_operator\"\n+         [(match_operand:SF 2 \"register_operand\" \"r\")\n+          (match_operand:SF 3 \"register_operand\" \"r\")]))]\n+  \"TARGET_V850E2V3\"\n+{\n+  if (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GE)\n+    return \"cmpf.s %c1, %z2, %z3 ; trfsr ; setf nz, %0\";\n+  if (GET_CODE (operands[1]) == LT || GET_CODE (operands[1]) == LE)\n+    return \"cmpf.s %c1, %z2, %z3 ; trfsr ; setf z, %0\";\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \"cmpf.s eq, %z2, %z3 ; trfsr ; setf z, %0\";\n+  if (GET_CODE (operands[1]) == NE)\n+    return \"cmpf.s neq, %z2, %z3 ; trfsr ; setf nz, %0\";\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"fpu\")]\n+)\n+\n+(define_expand \"cbranchdf4\"\n+  [(set (pc)\n+       (if_then_else (match_operator     0 \"ordered_comparison_operator\"\n+                      [(match_operand:DF 1 \"even_reg_operand\")\n+                       (match_operand:DF 2 \"even_reg_operand\")])\n+                     (label_ref (match_operand 3 \"\"))\n+                     (pc)))\n+  (clobber (cc0))]\n+  \"TARGET_V850E2V3\"\n+{\n+  v850_compare_op0 = operands[1];\n+  v850_compare_op1 = operands[2];\n+\n+  enum rtx_code cond = GET_CODE(operands[0]);\n+  enum machine_mode mode;\n+  rtx fcc_reg;\n+  rtx cc_reg;\n+  rtx tmp;\n+\n+  if (GET_MODE_CLASS (GET_MODE (v850_compare_op0)) != MODE_FLOAT)\n+    FAIL;\n+\n+  mode = v850_gen_float_compare (cond, VOIDmode, v850_compare_op0, v850_compare_op1);\n+  fcc_reg = gen_rtx_REG (mode, FCC_REGNUM);\n+  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+  emit_insn(gen_rtx_SET (mode, cc_reg, fcc_reg));\n+  tmp = gen_rtx_fmt_ee (cond, mode, cc_reg, const0_rtx);\n+  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+                              gen_rtx_LABEL_REF (VOIDmode, operands[3]), pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n+  DONE;\n+})\n+\n+(define_insn \"cstoredf4\"\n+  [(set (match_operand:SI   0 \"register_operand\" \"=r\")\n+        (match_operator:SI  1 \"ordered_comparison_operator\"\n+         [(match_operand:DF 2 \"even_reg_operand\"  \"r\")\n+          (match_operand:DF 3 \"even_reg_operand\" \"r\")]))]\n+  \"TARGET_V850E2V3\"\n+{\n+  if (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GE)\n+    return \"cmpf.d %c1, %z2, %z3 ; trfsr ; setf nz, %0\";\n+  if (GET_CODE (operands[1]) == LT || GET_CODE (operands[1]) == LE)\n+    return \"cmpf.d %c1, %z2, %z3 ; trfsr ; setf z, %0\";\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \"cmpf.d eq, %z2, %z3 ; trfsr ; setf z ,%0\";\n+  if (GET_CODE (operands[1]) == NE)\n+    return \"cmpf.d neq, %z2, %z3 ; trfsr ; setf nz, %0\";\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"fpu\")]\n+)\n+\n (define_expand \"cmpsf\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare (match_operand:SF 0 \"register_operand\" \"r\")\n@@ -940,6 +1048,11 @@\n \t (match_operand:SI 3 \"reg_or_const_operand\" \"rI\")))]\n   \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   {\n+    /* Make sure that we have an integer comparison...  */\n+    if (GET_MODE (XEXP (operands[1], 0)) != CCmode\n+        && GET_MODE (XEXP (operands[1], 0)) != SImode)\n+      FAIL;\n+\n     if ((GET_CODE (operands[2]) == CONST_INT\n \t&& GET_CODE (operands[3]) == CONST_INT))\n       {\n@@ -2210,7 +2323,7 @@\n         (compare:CC_FPU_LE (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.s le,%z1,%z0\"\n+  \"cmpf.s le, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2220,7 +2333,7 @@\n         (compare:CC_FPU_LT (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.s lt,%z1,%z0\"\n+  \"cmpf.s lt, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2230,7 +2343,7 @@\n         (compare:CC_FPU_GE (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.s ge,%z1,%z0\"\n+  \"cmpf.s le, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2240,7 +2353,7 @@\n         (compare:CC_FPU_GT (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.s gt,%z1,%z0\"\n+  \"cmpf.s lt, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2250,17 +2363,7 @@\n         (compare:CC_FPU_EQ (match_operand:SF 0 \"register_operand\" \"r\")\n \t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.s eq,%z1,%z0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")\n-   (set_attr \"type\" \"fpu\")])\n-\n-(define_insn \"cmpsf_ne_insn\"\n-  [(set (reg:CC_FPU_NE FCC_REGNUM)\n-        (compare:CC_FPU_NE (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n-  \"cmpf.s neq,%z1,%z0\"\n+  \"cmpf.s eq, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2272,7 +2375,7 @@\n         (compare:CC_FPU_LE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.d le,%z1,%z0\"\n+  \"cmpf.d le, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2282,7 +2385,7 @@\n         (compare:CC_FPU_LT (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.d lt,%z1,%z0\"\n+  \"cmpf.d lt, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2292,17 +2395,17 @@\n         (compare:CC_FPU_GE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.d ge,%z1,%z0\"\n+  \"cmpf.d le, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n \n (define_insn \"cmpdf_gt_insn\"\n   [(set (reg:CC_FPU_GT FCC_REGNUM)\n         (compare:CC_FPU_GT (match_operand:DF 0 \"even_reg_operand\" \"r\")\n-\t\t      (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+\t\t           (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.d gt,%z1,%z0\"\n+  \"cmpf.d lt, %z1, %z0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n@@ -2312,22 +2415,11 @@\n         (compare:CC_FPU_EQ (match_operand:DF 0 \"even_reg_operand\" \"r\")\n \t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n   \"TARGET_USE_FPU\"\n-  \"cmpf.d eq,%z1,%z0\"\n+  \"cmpf.d eq, %z0, %z1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n    (set_attr \"type\" \"fpu\")])\n \n-(define_insn \"cmpdf_ne_insn\"\n-  [(set (reg:CC_FPU_NE FCC_REGNUM)\n-        (compare:CC_FPU_NE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n-\t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n-  \"TARGET_USE_FPU\"\n-  \"cmpf.d neq,%z1,%z0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"none_0hit\")\n-   (set_attr \"type\" \"fpu\")])\n-\n-\n ;;\n ;; Transfer a v850e2v3 fcc to the Z bit of CC0 (this is necessary to do a\n ;; conditional branch based on a floating-point compare)"}]}