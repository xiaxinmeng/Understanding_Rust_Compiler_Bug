{"sha": "ed69105c95c1940e31459755fe931acde845deeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ2OTEwNWM5NWMxOTQwZTMxNDU5NzU1ZmU5MzFhY2RlODQ1ZGVlYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-02-09T18:17:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-02-09T18:17:09Z"}, "message": "constraints.md (Ym): New constraint.\n\n        * config/i386/constraints.md (Ym): New constraint.\n        * config/i386/i386.md (movsi_1): Change Y2 to Yi constraints.\n        (movdi_1_rex64): Split sse and xmm general register moves from\n        memory move alternatives.  Use conditional register constraints.\n        (movsf_1, movdf_integer): Likewise.\n        (zero_extendsidi2_32, zero_extendsidi2_rex64): Likewise.\n        (movdf_integer_rex64): New.\n        (pushsf_rex64): Fix output constraints.\n        * config/i386/sse.md (sse2_loadld): Split rm alternative, use Yi.\n        (sse2_stored): Likewise.\n        (sse2_storeq_rex64): New.\n        * config/i386/i386.c (x86_inter_unit_moves): Enable for not\n        amd and not generic.\n        (ix86_secondary_memory_needed): Don't bypass TARGET_INTER_UNIT_MOVES\n        for optimize_size.  Remove SF/DFmode hack.\n\nFrom-SVN: r121767", "tree": {"sha": "aeccd61acc2216e7bb90aae7a64a206821b76d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeccd61acc2216e7bb90aae7a64a206821b76d0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed69105c95c1940e31459755fe931acde845deeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed69105c95c1940e31459755fe931acde845deeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed69105c95c1940e31459755fe931acde845deeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed69105c95c1940e31459755fe931acde845deeb/comments", "author": null, "committer": null, "parents": [{"sha": "8413669bde530c1ea19e990945f3fd11f6226f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8413669bde530c1ea19e990945f3fd11f6226f63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8413669bde530c1ea19e990945f3fd11f6226f63"}], "stats": {"total": 274, "additions": 215, "deletions": 59}, "files": [{"sha": "52ed599bc1de256874859cbc405b9bcc4a6f7cd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed69105c95c1940e31459755fe931acde845deeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed69105c95c1940e31459755fe931acde845deeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed69105c95c1940e31459755fe931acde845deeb", "patch": "@@ -1,3 +1,21 @@\n+2007-02-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/constraints.md (Ym): New constraint.\n+\t* config/i386/i386.md (movsi_1): Change Y2 to Yi constraints.\n+\t(movdi_1_rex64): Split sse and xmm general register moves from\n+\tmemory move alternatives.  Use conditional register constraints.\n+\t(movsf_1, movdf_integer): Likewise.\n+\t(zero_extendsidi2_32, zero_extendsidi2_rex64): Likewise.\n+\t(movdf_integer_rex64): New.\n+\t(pushsf_rex64): Fix output constraints.\n+\t* config/i386/sse.md (sse2_loadld): Split rm alternative, use Yi.\n+\t(sse2_stored): Likewise.\n+\t(sse2_storeq_rex64): New.\n+\t* config/i386/i386.c (x86_inter_unit_moves): Enable for not\n+\tamd and not generic.\n+\t(ix86_secondary_memory_needed): Don't bypass TARGET_INTER_UNIT_MOVES\n+\tfor optimize_size.  Remove SF/DFmode hack.\n+\n 2007-02-09  Dwarakanath Rajagopal <dwarak.rajagopal@amd.com>\n \n         * config/i386/driver-i386.c: Turn on -mtune=native for AMDFAM10."}, {"sha": "8f3e3cef06693d89ea6c8ec730fccd8f0c47c43a", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=ed69105c95c1940e31459755fe931acde845deeb", "patch": "@@ -86,6 +86,7 @@\n ;; We use the Y prefix to denote any number of conditional register sets:\n ;;  2\tSSE2 enabled\n ;;  i\tSSE2 inter-unit moves enabled\n+;;  m\tMMX inter-unit moves enabled\n \n (define_register_constraint \"Y2\" \"TARGET_SSE2 ? SSE_REGS : NO_REGS\"\n  \"@internal Any SSE register, when SSE2 is enabled.\")\n@@ -94,6 +95,10 @@\n  \"TARGET_SSE2 && TARGET_INTER_UNIT_MOVES ? SSE_REGS : NO_REGS\"\n  \"@internal Any SSE register, when SSE2 and inter-unit moves are enabled.\")\n \n+(define_register_constraint \"Ym\"\n+ \"TARGET_MMX && TARGET_INTER_UNIT_MOVES ? MMX_REGS : NO_REGS\"\n+ \"@internal Any MMX register, when inter-unit moves are enabled.\")\n+\n ;; Integer constant constraints.\n (define_constraint \"I\"\n   \"Integer constant in the range 0 @dots{} 31, for 32-bit shifts.\""}, {"sha": "e5ff76e2d2242c8cf944937be199bcfeef34da5a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ed69105c95c1940e31459755fe931acde845deeb", "patch": "@@ -1161,9 +1161,7 @@ const int x86_sse_load0_by_pxor = m_PPRO | m_PENT4 | m_NOCONA;\n const int x86_use_ffreep = m_ATHLON_K8_AMDFAM10;\n const int x86_use_incdec = ~(m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC);\n \n-/* ??? Allowing interunit moves makes it all too easy for the compiler to put\n-   integer data in xmm registers.  Which results in pretty abysmal code.  */\n-const int x86_inter_unit_moves = 0 /* ~(m_ATHLON_K8) */;\n+const int x86_inter_unit_moves = ~(m_ATHLON_K8_AMDFAM10 | m_GENERIC);\n \n const int x86_ext_80387_constants = m_K6_GEODE | m_ATHLON_K8 | m_PENT4\n                                     | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n@@ -18301,18 +18299,12 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n \n       /* If the target says that inter-unit moves are more expensive\n \t than moving through memory, then don't generate them.  */\n-      if (!TARGET_INTER_UNIT_MOVES && !optimize_size)\n+      if (!TARGET_INTER_UNIT_MOVES)\n \treturn true;\n \n       /* Between SSE and general, we have moves no larger than word size.  */\n       if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \treturn true;\n-\n-      /* ??? For the cost of one register reformat penalty, we could use\n-\t the same instructions to move SFmode and DFmode data, but the\n-\t relevant move patterns don't support those alternatives.  */\n-      if (mode == SFmode || mode == DFmode)\n-\treturn true;\n     }\n \n   return false;"}, {"sha": "4f194d4b2169920368c6fc22e53474d9490283e0", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 175, "deletions": 39, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ed69105c95c1940e31459755fe931acde845deeb", "patch": "@@ -1187,9 +1187,9 @@\n \n (define_insn \"*movsi_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\"=r  ,m  ,*y,*y,?rm,?*y,*x,*x,?r ,m ,?*Y2,*x\")\n+\t\t\t\"=r  ,m  ,*y,*y,?rm,?*y,*x,*x,?r ,m ,?*Yi,*x\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"rinm,rin,C ,*y,*y ,rm ,C ,*x,*Y2,*x,r   ,m \"))]\n+\t\t\t\"rinm,rin,C ,*y,*y ,rm ,C ,*x,*Yi,*x,r   ,m \"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2022,35 +2022,41 @@\n \n (define_insn \"*movdi_1_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\"=r,r  ,r,m ,!m,*y,*y,?rm,?*y,*x,*x,?rm,?*x,?*x,?*y\")\n+\t  \"=r,r  ,r,m ,!m,*y,*y,?r ,m ,?*Ym,*y,*x,*x,?r ,m,?*Yi,*x,?*x,?*Ym\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\"Z ,rem,i,re,n ,C ,*y,*y ,rm ,C ,*x,*x ,rm ,*y ,*x\"))]\n+\t  \"Z ,rem,i,re,n ,C ,*y,*Ym,*y,r   ,m ,C ,*x,*Yi,*x,r  ,m ,*Ym,*x\"))]\n   \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_SSECVT:\n-      if (which_alternative == 13)\n+      if (SSE_REG_P (operands[0]))\n \treturn \"movq2dq\\t{%1, %0|%0, %1}\";\n       else\n \treturn \"movdq2q\\t{%1, %0|%0, %1}\";\n+\n     case TYPE_SSEMOV:\n       if (get_attr_mode (insn) == MODE_TI)\n-\t  return \"movdqa\\t{%1, %0|%0, %1}\";\n+\treturn \"movdqa\\t{%1, %0|%0, %1}\";\n       /* FALLTHRU */\n+\n     case TYPE_MMXMOV:\n-      /* Moves from and into integer register is done using movd opcode with\n- \t REX prefix.  */\n+      /* Moves from and into integer register is done using movd\n+\t opcode with REX prefix.  */\n       if (GENERAL_REG_P (operands[0]) || GENERAL_REG_P (operands[1]))\n-\t  return \"movd\\t{%1, %0|%0, %1}\";\n+\treturn \"movd\\t{%1, %0|%0, %1}\";\n       return \"movq\\t{%1, %0|%0, %1}\";\n+\n     case TYPE_SSELOG1:\n     case TYPE_MMXADD:\n       return \"pxor\\t%0, %0\";\n+\n     case TYPE_MULTI:\n       return \"#\";\n+\n     case TYPE_LEA:\n       return \"lea{q}\\t{%a1, %0|%0, %a1}\";\n+\n     default:\n       gcc_assert (!flag_pic || LEGITIMATE_PIC_OPERAND_P (operands[1]));\n       if (get_attr_mode (insn) == MODE_SI)\n@@ -2064,23 +2070,23 @@\n   [(set (attr \"type\")\n      (cond [(eq_attr \"alternative\" \"5\")\n \t      (const_string \"mmxadd\")\n-\t    (eq_attr \"alternative\" \"6,7,8\")\n+\t    (eq_attr \"alternative\" \"6,7,8,9,10\")\n \t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"9\")\n+\t    (eq_attr \"alternative\" \"11\")\n \t      (const_string \"sselog1\")\n-\t    (eq_attr \"alternative\" \"10,11,12\")\n+\t    (eq_attr \"alternative\" \"12,13,14,15,16\")\n \t      (const_string \"ssemov\")\n-\t    (eq_attr \"alternative\" \"13,14\")\n+\t    (eq_attr \"alternative\" \"17,18\")\n \t      (const_string \"ssecvt\")\n \t    (eq_attr \"alternative\" \"4\")\n \t      (const_string \"multi\")\n  \t    (match_operand:DI 1 \"pic_32bit_operand\" \"\")\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,DI,TI,TI,DI,DI,DI,DI\")])\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,DI,DI,DI,TI,TI,DI,DI,DI,DI,DI,DI\")])\n \n ;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -2280,7 +2286,7 @@\n    (set_attr \"mode\" \"SF,SI,SF\")])\n \n (define_insn \"*pushsf_rex64\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=X,X,X\")\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n \t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f,rF,x\"))]\n   \"TARGET_64BIT\"\n {\n@@ -2320,9 +2326,9 @@\n \n (define_insn \"*movsf_1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\"\n-\t  \"=f,m   ,f,r  ,m    ,x,x,x ,m   ,!*y,!rm,!*y\")\n+\t  \"=f,m,f,r  ,m ,x,x,x ,m,*y,m ,*y,Yi,r ,*Ym,r  \")\n \t(match_operand:SF 1 \"general_operand\"\n-\t  \"fm,f,G   ,rmF,Fr,C   ,x   ,xm,x,rm ,*y ,*y\"))]\n+\t  \"fm,f,G,rmF,Fr,C,x,xm,x,m ,*y,*y,r ,Yi,r  ,*Ym\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n@@ -2358,12 +2364,11 @@\n \treturn \"movaps\\t{%1, %0|%0, %1}\";\n       else\n \treturn \"movss\\t{%1, %0|%0, %1}\";\n-    case 7:\n-    case 8:\n+    case 7: case 8:\n       return \"movss\\t{%1, %0|%0, %1}\";\n \n-    case 9:\n-    case 10:\n+    case 9: case 10:\n+    case 12: case 13: case 14: case 15:\n       return \"movd\\t{%1, %0|%0, %1}\";\n \n     case 11:\n@@ -2373,7 +2378,7 @@\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sselog1,ssemov,ssemov,ssemov,mmxmov,mmxmov,mmxmov\")\n+  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sselog1,ssemov,ssemov,ssemov,mmxmov,mmxmov,mmxmov,ssemov,ssemov,mmxmov,mmxmov\")\n    (set (attr \"mode\")\n         (cond [(eq_attr \"alternative\" \"3,4,9,10\")\n \t\t (const_string \"SI\")\n@@ -2609,13 +2614,139 @@\n \t      ]\n \t      (const_string \"DF\")))])\n \n+(define_insn \"*movdf_integer_rex64\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n+\t\t\"=f,m,f,r  ,m ,Y2*x,Y2*x,Y2*x,m   ,Yi,r \")\n+\t(match_operand:DF 1 \"general_operand\"\n+\t\t\"fm,f,G,rmF,Fr,C   ,Y2*x,m   ,Y2*x,r ,Yi\"))]\n+  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && (reload_in_progress || reload_completed\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n+       || (!(TARGET_SSE2 && TARGET_SSE_MATH) && optimize_size\n+\t   && standard_80387_constant_p (operands[1]))\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], DFmode))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return output_387_reg_move (insn, operands);\n+\n+    case 1:\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \"fstp%z0\\t%y0\";\n+      else\n+        return \"fst%z0\\t%y0\";\n+\n+    case 2:\n+      return standard_80387_constant_opcode (operands[1]);\n+\n+    case 3:\n+    case 4:\n+      return \"#\";\n+\n+    case 5:\n+      switch (get_attr_mode (insn))\n+\t{\n+\tcase MODE_V4SF:\n+\t  return \"xorps\\t%0, %0\";\n+\tcase MODE_V2DF:\n+\t  return \"xorpd\\t%0, %0\";\n+\tcase MODE_TI:\n+\t  return \"pxor\\t%0, %0\";\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    case 6:\n+    case 7:\n+    case 8:\n+      switch (get_attr_mode (insn))\n+\t{\n+\tcase MODE_V4SF:\n+\t  return \"movaps\\t{%1, %0|%0, %1}\";\n+\tcase MODE_V2DF:\n+\t  return \"movapd\\t{%1, %0|%0, %1}\";\n+\tcase MODE_TI:\n+\t  return \"movdqa\\t{%1, %0|%0, %1}\";\n+\tcase MODE_DI:\n+\t  return \"movq\\t{%1, %0|%0, %1}\";\n+\tcase MODE_DF:\n+\t  return \"movsd\\t{%1, %0|%0, %1}\";\n+\tcase MODE_V1DF:\n+\t  return \"movlpd\\t{%1, %0|%0, %1}\";\n+\tcase MODE_V2SF:\n+\t  return \"movlps\\t{%1, %0|%0, %1}\";\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+    case 9:\n+    case 10:\n+      return \"movd\\t{%1, %0|%0, %1}\";\n+\n+    default:\n+      gcc_unreachable();\n+    }\n+}\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov,ssemov,ssemov\")\n+   (set (attr \"mode\")\n+        (cond [(eq_attr \"alternative\" \"0,1,2\")\n+\t\t (const_string \"DF\")\n+\t       (eq_attr \"alternative\" \"3,4,9,10\")\n+\t\t (const_string \"DI\")\n+\n+\t       /* For SSE1, we have many fewer alternatives.  */\n+\t       (eq (symbol_ref \"TARGET_SSE2\") (const_int 0))\n+\t\t (cond [(eq_attr \"alternative\" \"5,6\")\n+\t\t\t  (const_string \"V4SF\")\n+\t\t       ]\n+\t\t   (const_string \"V2SF\"))\n+\n+\t       /* xorps is one byte shorter.  */\n+\t       (eq_attr \"alternative\" \"5\")\n+\t\t (cond [(ne (symbol_ref \"optimize_size\")\n+\t\t\t    (const_int 0))\n+\t\t\t  (const_string \"V4SF\")\n+\t\t\t(ne (symbol_ref \"TARGET_SSE_LOAD0_BY_PXOR\")\n+\t\t\t    (const_int 0))\n+\t\t\t  (const_string \"TI\")\n+\t\t       ]\n+\t\t       (const_string \"V2DF\"))\n+\n+\t       /* For architectures resolving dependencies on\n+\t\t  whole SSE registers use APD move to break dependency\n+\t\t  chains, otherwise use short move to avoid extra work.\n+\n+\t\t  movaps encodes one byte shorter.  */\n+\t       (eq_attr \"alternative\" \"6\")\n+\t\t (cond\n+\t\t   [(ne (symbol_ref \"optimize_size\")\n+\t\t        (const_int 0))\n+\t\t      (const_string \"V4SF\")\n+\t\t    (ne (symbol_ref \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n+\t\t        (const_int 0))\n+\t\t      (const_string \"V2DF\")\n+\t\t   ]\n+\t\t   (const_string \"DF\"))\n+\t       /* For architectures resolving dependencies on register\n+\t\t  parts we may avoid extra work to zero out upper part\n+\t\t  of register.  */\n+\t       (eq_attr \"alternative\" \"7\")\n+\t\t (if_then_else\n+\t\t   (ne (symbol_ref \"TARGET_SSE_SPLIT_REGS\")\n+\t\t       (const_int 0))\n+\t\t   (const_string \"V1DF\")\n+\t\t   (const_string \"DF\"))\n+\t      ]\n+\t      (const_string \"DF\")))])\n+\n (define_insn \"*movdf_integer\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n \t\t\"=f,m,f,r  ,o ,Y2*x,Y2*x,Y2*x,m   \")\n \t(match_operand:DF 1 \"general_operand\"\n \t\t\"fm,f,G,roF,Fr,C   ,Y2*x,m   ,Y2*x\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && ((!optimize_size && TARGET_INTEGER_DFMODE_MOVES) || TARGET_64BIT)\n+   && !optimize_size && TARGET_INTEGER_DFMODE_MOVES\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || (!(TARGET_SSE2 && TARGET_SSE_MATH) && optimize_size\n@@ -3261,40 +3392,45 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n      (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n   \"\"\n-  \"if (!TARGET_64BIT)\n-     {\n-       emit_insn (gen_zero_extendsidi2_32 (operands[0], operands[1]));\n-       DONE;\n-     }\n-  \")\n+{\n+  if (!TARGET_64BIT)\n+    {\n+      emit_insn (gen_zero_extendsidi2_32 (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n \n (define_insn \"zero_extendsidi2_32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o,?*y,?*Y2\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?o,?*Ym,*y,?*Yi,*Y2\")\n \t(zero_extend:DI\n-\t (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r,rm,rm\")))\n+\t (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r ,r   ,m ,r   ,m\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT\"\n   \"@\n    #\n    #\n    #\n    movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\n    movd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"mode\" \"SI,SI,SI,DI,TI\")\n-   (set_attr \"type\" \"multi,multi,multi,mmxmov,ssemov\")])\n+  [(set_attr \"mode\" \"SI,SI,SI,DI,DI,TI,TI\")\n+   (set_attr \"type\" \"multi,multi,multi,mmxmov,mmxmov,ssemov,ssemov\")])\n \n (define_insn \"zero_extendsidi2_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,?*y,?*Y2\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,?*Ym,*y,?*Yi,*Y2\")\n      (zero_extend:DI\n-       (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,rm,rm\")))]\n+       (match_operand:SI 1 \"nonimmediate_operand\"  \"rm,0,r   ,m ,r   ,m\")))]\n   \"TARGET_64BIT\"\n   \"@\n    mov\\t{%k1, %k0|%k0, %k1}\n    #\n    movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\n    movd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imovx,imov,mmxmov,ssemov\")\n-   (set_attr \"mode\" \"SI,DI,SI,SI\")])\n+  [(set_attr \"type\" \"imovx,imov,mmxmov,mmxmov,ssemov,ssemov\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,TI,TI\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"memory_operand\" \"\")"}, {"sha": "ed1de1946f4183f256839b540940685a6f63cd4e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed69105c95c1940e31459755fe931acde845deeb/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ed69105c95c1940e31459755fe931acde845deeb", "patch": "@@ -3961,26 +3961,25 @@\n   \"operands[2] = CONST0_RTX (V4SImode);\")\n \n (define_insn \"sse2_loadld\"\n-  [(set (match_operand:V4SI 0 \"register_operand\"       \"=Y2,x,x\")\n+  [(set (match_operand:V4SI 0 \"register_operand\"       \"=Y2,Yi,x,x\")\n \t(vec_merge:V4SI\n \t  (vec_duplicate:V4SI\n-\t    (match_operand:SI 2 \"nonimmediate_operand\" \"mr ,m,x\"))\n-\t  (match_operand:V4SI 1 \"reg_or_0_operand\"     \" C ,C,0\")\n+\t    (match_operand:SI 2 \"nonimmediate_operand\" \"m  ,r ,m,x\"))\n+\t  (match_operand:V4SI 1 \"reg_or_0_operand\"     \"C  ,C ,C,0\")\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n   \"@\n+   movd\\t{%2, %0|%0, %2}\n    movd\\t{%2, %0|%0, %2}\n    movss\\t{%2, %0|%0, %2}\n    movss\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"mode\" \"TI,V4SF,SF\")])\n+   (set_attr \"mode\" \"TI,TI,V4SF,SF\")])\n \n-;; ??? The hardware supports more, but TARGET_INTER_UNIT_MOVES must\n-;; be taken into account, and movdi isn't fully populated even without.\n (define_insn_and_split \"sse2_stored\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mx\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=mx,r\")\n \t(vec_select:SI\n-\t  (match_operand:V4SI 1 \"register_operand\" \"x\")\n+\t  (match_operand:V4SI 1 \"register_operand\" \"x,Yi\")\n \t  (parallel [(const_int 0)])))]\n   \"TARGET_SSE\"\n   \"#\"\n@@ -3998,8 +3997,14 @@\n   \"TARGET_SSE\"\n   \"\")\n \n-;; ??? The hardware supports more, but TARGET_INTER_UNIT_MOVES must\n-;; be taken into account, and movdi isn't fully populated even without.\n+(define_insn \"*sse2_storeq_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=mx,r\")\n+\t(vec_select:DI\n+\t  (match_operand:V2DI 1 \"register_operand\" \"x,Yi\")\n+\t  (parallel [(const_int 0)])))]\n+  \"TARGET_64BIT && TARGET_SSE\"\n+  \"#\")\n+\n (define_insn \"*sse2_storeq\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=mx\")\n \t(vec_select:DI"}]}