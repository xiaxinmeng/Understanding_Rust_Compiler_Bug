{"sha": "6eb791fc977474c35eed05b27836328e110460ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmViNzkxZmM5Nzc0NzRjMzVlZWQwNWIyNzgzNjMyOGUxMTA0NjBhZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-20T10:21:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-20T10:21:40Z"}, "message": "i386.md (indirect_jump): Allow Pmode operand.\n\n\n\t* i386.md (indirect_jump): Allow Pmode operand.\n\t(tablejump): LIkewise; perform expansion to 64bit mode.\n\t* i386.c (symbolic_operand): Allow 64bit PIC references.\n\t(pic_symbolic_operand): Likewise.\n\t(ix86_find_base_term): Strip the 64bit PIC references.\n\t(legitimate_pic_address_disp_p): Handle 64bit PIC.\n\t(legitimize_pic_address): Likewise.\n\t(i386_simplify_dwarf_addr): Strip down the 64bit PIC references.\n\t* i386.h (CASE_VECTOR_MODE): Set to SImode for 64bit PIC compilation.\n\nFrom-SVN: r45705", "tree": {"sha": "171c0dd8ab08b64284d3fef0e676571a789213be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/171c0dd8ab08b64284d3fef0e676571a789213be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eb791fc977474c35eed05b27836328e110460ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb791fc977474c35eed05b27836328e110460ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eb791fc977474c35eed05b27836328e110460ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb791fc977474c35eed05b27836328e110460ad/comments", "author": null, "committer": null, "parents": [{"sha": "5b66fcf9a9448d80ca43d721eaaad0c8b3ace0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b66fcf9a9448d80ca43d721eaaad0c8b3ace0f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b66fcf9a9448d80ca43d721eaaad0c8b3ace0f4"}], "stats": {"total": 139, "additions": 120, "deletions": 19}, "files": [{"sha": "6f039c6fd8e7ed026e580543fff0d064693d3703", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb791fc977474c35eed05b27836328e110460ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb791fc977474c35eed05b27836328e110460ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6eb791fc977474c35eed05b27836328e110460ad", "patch": "@@ -1,3 +1,15 @@\n+Thu Sep 20 12:19:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (indirect_jump): Allow Pmode operand.\n+\t(tablejump): LIkewise; perform expansion to 64bit mode.\n+\t* i386.c (symbolic_operand): Allow 64bit PIC references.\n+\t(pic_symbolic_operand): Likewise.\n+\t(ix86_find_base_term): Strip the 64bit PIC references.\n+\t(legitimate_pic_address_disp_p): Handle 64bit PIC.\n+\t(legitimize_pic_address): Likewise.\n+\t(i386_simplify_dwarf_addr): Strip down the 64bit PIC references.\n+\t* i386.h (CASE_VECTOR_MODE): Set to SImode for 64bit PIC compilation.\n+\n 2001-09-19  Alan Modra  <amodra@bigpond.net.au>\n \t    David Edelsohn  <edelsohn@gnu.org>\n "}, {"sha": "c89a0ab591d730dc13c07e6e2e993eda6f353eb5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 94, "deletions": 12, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb791fc977474c35eed05b27836328e110460ad/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb791fc977474c35eed05b27836328e110460ad/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6eb791fc977474c35eed05b27836328e110460ad", "patch": "@@ -1495,8 +1495,9 @@ symbolic_operand (op, mode)\n       if (GET_CODE (op) == SYMBOL_REF\n \t  || GET_CODE (op) == LABEL_REF\n \t  || (GET_CODE (op) == UNSPEC\n-\t      && XINT (op, 1) >= 6\n-\t      && XINT (op, 1) <= 7))\n+\t      && (XINT (op, 1) == 6\n+\t\t  || XINT (op, 1) == 7\n+\t\t  || XINT (op, 1) == 15)))\n \treturn 1;\n       if (GET_CODE (op) != PLUS\n \t  || GET_CODE (XEXP (op, 1)) != CONST_INT)\n@@ -1529,9 +1530,16 @@ pic_symbolic_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  if (GET_CODE (op) == CONST)\n+  if (GET_CODE (op) != CONST)\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (TARGET_64BIT)\n+    {\n+      if (GET_CODE (XEXP (op, 0)) == UNSPEC)\n+\treturn 1;\n+    }\n+  else \n     {\n-      op = XEXP (op, 0);\n       if (GET_CODE (op) == UNSPEC)\n \treturn 1;\n       if (GET_CODE (op) != PLUS\n@@ -3220,6 +3228,29 @@ ix86_find_base_term (x)\n {\n   rtx term;\n \n+  if (TARGET_64BIT)\n+    {\n+      if (GET_CODE (x) != CONST)\n+\treturn x;\n+      term = XEXP (x, 0);\n+      if (GET_CODE (term) == PLUS\n+\t  && (GET_CODE (XEXP (term, 1)) == CONST_INT\n+\t      || GET_CODE (XEXP (term, 1)) == CONST_DOUBLE))\n+\tterm = XEXP (term, 0);\n+      if (GET_CODE (term) != UNSPEC\n+\t  || XVECLEN (term, 0) != 1\n+\t  || XINT (term, 1) !=  15)\n+\treturn x;\n+\n+      term = XVECEXP (term, 0, 0);\n+\n+      if (GET_CODE (term) != SYMBOL_REF\n+\t  && GET_CODE (term) != LABEL_REF)\n+\treturn x;\n+\n+      return term;\n+    }\n+\n   if (GET_CODE (x) != PLUS\n       || XEXP (x, 0) != pic_offset_table_rtx\n       || GET_CODE (XEXP (x, 1)) != CONST)\n@@ -3251,10 +3282,42 @@ int\n legitimate_pic_address_disp_p (disp)\n      register rtx disp;\n {\n+  /* In 64bit mode we can allow direct addresses of symbols and labels\n+     when they are not dynamic symbols.  */\n+  if (TARGET_64BIT)\n+    {\n+      rtx x = disp;\n+      if (GET_CODE (disp) == CONST)\n+\tx = XEXP (disp, 0);\n+      /* ??? Handle PIC code models */\n+      if (GET_CODE (x) == PLUS\n+\t  && (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t      && ix86_cmodel == CM_SMALL_PIC\n+\t      && INTVAL (XEXP (x, 1)) < 1024*1024*1024\n+\t      && INTVAL (XEXP (x, 1)) > -1024*1024*1024))\n+\tx = XEXP (x, 0);\n+      if (local_symbolic_operand (x, Pmode))\n+\treturn 1;\n+    }\n   if (GET_CODE (disp) != CONST)\n     return 0;\n   disp = XEXP (disp, 0);\n \n+  if (TARGET_64BIT)\n+    {\n+      /* We are unsafe to allow PLUS expressions.  This limit allowed distance\n+         of GOT tables.  We should not need these anyway.  */\n+      if (GET_CODE (disp) != UNSPEC\n+\t  || XVECLEN (disp, 0) != 1\n+\t  || XINT (disp, 1) != 15)\n+\treturn 0;\n+\n+      if (GET_CODE (XVECEXP (disp, 0, 0)) != SYMBOL_REF\n+\t  && GET_CODE (XVECEXP (disp, 0, 0)) != LABEL_REF)\n+\treturn 0;\n+      return 1;\n+    }\n+\n   if (GET_CODE (disp) == PLUS)\n     {\n       if (GET_CODE (XEXP (disp, 1)) != CONST_INT)\n@@ -3576,16 +3639,23 @@ legitimize_pic_address (orig, reg)\n \t  if (local_symbolic_operand (op0, Pmode)\n \t      && GET_CODE (op1) == CONST_INT)\n \t    {\n-\t      current_function_uses_pic_offset_table = 1;\n-\t      new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), 7);\n-\t      new = gen_rtx_PLUS (Pmode, new, op1);\n-\t      new = gen_rtx_CONST (Pmode, new);\n-\t      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+\t      if (!TARGET_64BIT)\n+\t\t{\n+\t\t  current_function_uses_pic_offset_table = 1;\n+\t\t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), 7);\n+\t\t  new = gen_rtx_PLUS (Pmode, new, op1);\n+\t\t  new = gen_rtx_CONST (Pmode, new);\n+\t\t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \n-\t      if (reg != 0)\n+\t\t  if (reg != 0)\n+\t\t    {\n+\t\t      emit_move_insn (reg, new);\n+\t\t      new = reg;\n+\t\t    }\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  emit_move_insn (reg, new);\n-\t\t  new = reg;\n+\t\t  /* ??? We need to limit offsets here.  */\n \t\t}\n \t    }\n \t  else\n@@ -3900,6 +3970,9 @@ output_pic_addr_const (file, x, code)\n \tcase 8:\n \t  fputs (\"@PLT\", file);\n \t  break;\n+\tcase 15:\n+\t  fputs (\"@GOTPCREL(%RIP)\", file);\n+\t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand\");\n \t  break;\n@@ -3937,6 +4010,15 @@ i386_simplify_dwarf_addr (orig_x)\n {\n   rtx x = orig_x;\n \n+  if (TARGET_64BIT)\n+    {\n+      if (GET_CODE (x) != CONST\n+\t  || GET_CODE (XEXP (x, 0)) != UNSPEC\n+\t  || XINT (XEXP (x, 0), 1) != 15)\n+\treturn orig_x;\n+      return XVECEXP (XEXP (x, 0), 0, 0);\n+    }\n+\n   if (GET_CODE (x) != PLUS\n       || GET_CODE (XEXP (x, 0)) != REG\n       || GET_CODE (XEXP (x, 1)) != CONST)"}, {"sha": "86e83dfbbab780460f08e69c4857725144a20e4d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb791fc977474c35eed05b27836328e110460ad/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb791fc977474c35eed05b27836328e110460ad/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6eb791fc977474c35eed05b27836328e110460ad", "patch": "@@ -2244,7 +2244,7 @@ while (0)\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE Pmode\n+#define CASE_VECTOR_MODE (!TARGET_64BIT || flag_pic ? SImode : DImode)\n \n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the"}, {"sha": "ef5d0fc86de988dd24f74625be4822f4202bd7cd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb791fc977474c35eed05b27836328e110460ad/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb791fc977474c35eed05b27836328e110460ad/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6eb791fc977474c35eed05b27836328e110460ad", "patch": "@@ -12948,25 +12948,32 @@\n   [(set_attr \"type\" \"ibr\")])\n \n (define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+  [(set (pc) (match_operand:P 0 \"nonimmediate_operand\" \"rm\"))]\n   \"\"\n   \"jmp\\t%A0\"\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \n (define_expand \"tablejump\"\n-  [(parallel [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))\n+  [(parallel [(set (pc) (match_operand 0 \"nonimmediate_operand\" \"rm\"))\n \t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n   \"\"\n {\n   /* In PIC mode, the table entries are stored GOT-relative.  Convert\n      the relative address to an absolute address.  */\n   if (flag_pic)\n     {\n-      operands[0] = expand_simple_binop (Pmode, MINUS, pic_offset_table_rtx,\n-\t\t\t\t\t operands[0], NULL_RTX, 1,\n-\t\t\t\t\t OPTAB_DIRECT);\n-      current_function_uses_pic_offset_table = 1;\n+      if (TARGET_64BIT)\n+\toperands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n+\t\t\t\t\t   operands[1], NULL_RTX, 0,\n+\t\t\t\t\t   OPTAB_DIRECT);\n+      else\n+\t{\n+\t  operands[0] = expand_simple_binop (Pmode, MINUS, pic_offset_table_rtx,\n+\t\t\t\t\t     operands[0], NULL_RTX, 1,\n+\t\t\t\t\t     OPTAB_DIRECT);\n+\t  current_function_uses_pic_offset_table = 1;\n+\t}\n     }\n })\n "}]}