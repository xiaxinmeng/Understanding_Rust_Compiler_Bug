{"sha": "042259f23ad6239cd33fc4989f4d0d1dc9d45e76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQyMjU5ZjIzYWQ2MjM5Y2QzM2ZjNDk4OWY0ZDBkMWRjOWQ0NWU3Ng==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-02-19T22:27:14Z"}, "committer": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-02-19T22:27:14Z"}, "message": "remove operand_subword from easy_fp_const\nsupport DImode const in TOC\n\nFrom-SVN: r11309", "tree": {"sha": "bc39536ded1571bb7eab7d1c11210016097c14f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc39536ded1571bb7eab7d1c11210016097c14f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/042259f23ad6239cd33fc4989f4d0d1dc9d45e76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/042259f23ad6239cd33fc4989f4d0d1dc9d45e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/042259f23ad6239cd33fc4989f4d0d1dc9d45e76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/042259f23ad6239cd33fc4989f4d0d1dc9d45e76/comments", "author": null, "committer": null, "parents": [{"sha": "5854b0d02003df0d7efe67def8bd8ca7abbfabf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5854b0d02003df0d7efe67def8bd8ca7abbfabf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5854b0d02003df0d7efe67def8bd8ca7abbfabf6"}], "stats": {"total": 89, "additions": 65, "deletions": 24}, "files": [{"sha": "b611ee1288aa8da625832ddab3f99d69bfb2d2ca", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 65, "deletions": 24, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/042259f23ad6239cd33fc4989f4d0d1dc9d45e76/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/042259f23ad6239cd33fc4989f4d0d1dc9d45e76/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=042259f23ad6239cd33fc4989f4d0d1dc9d45e76", "patch": "@@ -533,8 +533,6 @@ easy_fp_constant (op, mode)\n      register rtx op;\n      register enum machine_mode mode;\n {\n-  rtx low, high;\n-\n   if (GET_CODE (op) != CONST_DOUBLE\n       || GET_MODE (op) != mode\n       || GET_MODE_CLASS (mode) != MODE_FLOAT)\n@@ -544,14 +542,27 @@ easy_fp_constant (op, mode)\n   if (TARGET_SOFT_FLOAT)\n     return 1;\n \n-  high = operand_subword (op, 0, 0, mode);\n-  low = operand_subword (op, 1, 0, mode);\n+  if (mode == DFmode)\n+    {\n+      long k[2];\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n \n-  if (high == 0 || ! input_operand (high, word_mode))\n-    return 0;\n+      return (((unsigned) (k[0] + 0x8000) < 0x10000 || (k[0] & 0xffff) == 0)\n+\t      && ((unsigned) (k[1] + 0x8000) < 0x10000 || (k[1] & 0xffff) == 0));\n+    }\n+  else\n+    {\n+      long l;\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \n-  return (mode == SFmode\n-\t  || (low != 0 && input_operand (low, word_mode)));\n+      return ((unsigned) (l + 0x8000) < 0x10000 || (l & 0xffff) == 0);\n+    }\n }\n \n /* Return 1 if the operand is in volatile memory.  Note that during the\n@@ -843,9 +854,7 @@ input_operand (op, mode)\n       && small_data_operand (op, Pmode))\n     return 1;\n \n-  /* Otherwise, we will be doing this SET with an add, so anything valid\n-     for an add will be valid.  */\n-  return add_operand (op, mode);\n+  return 0;\n }\n \n /* Return 1 for an operand in small memory on V.4/eabi */\n@@ -3603,34 +3612,66 @@ output_toc (file, x, labelno)\n   /* Handle FP constants specially.  Note that if we have a minimal\n      TOC, things we put here aren't actually in the TOC, so we can allow\n      FP constants.  */\n-  if (GET_CODE (x) == CONST_DOUBLE\n-      && GET_MODE (x) == DFmode\n+  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode\n       && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC))\n     {\n-      REAL_VALUE_TYPE r;\n-      long l[2];\n+      REAL_VALUE_TYPE rv;\n+      long k[2];\n \n-      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n       if (TARGET_MINIMAL_TOC)\n-\tfprintf (file, \"\\t.long %ld\\n\\t.long %ld\\n\", l[0], l[1]);\n+\tfprintf (file, \"\\t.long %ld\\n\\t.long %ld\\n\", k[0], k[1]);\n       else\n \tfprintf (file, \"\\t.tc FD_%lx_%lx[TC],%ld,%ld\\n\",\n-\t\t l[0], l[1], l[0], l[1]);\n+\t\t k[0], k[1], k[0], k[1]);\n       return;\n     }\n   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode\n \t   && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC))\n     {\n-      rtx val = operand_subword (x, 0, 0, SFmode);\n+      REAL_VALUE_TYPE rv;\n+      long l;\n \n-      if (val == 0 || GET_CODE (val) != CONST_INT)\n-\tabort ();\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\n+      if (TARGET_MINIMAL_TOC)\n+\tfprintf (file, \"\\t.long %d\\n\", l);\n+      else\n+\tfprintf (file, \"\\t.tc FS_%x[TC],%d\\n\", l, l);\n+      return;\n+    }\n+  else if (GET_MODE (x) == DImode\n+\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+\t   && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC))\n+    {\n+      HOST_WIDE_INT low;\n+      HOST_WIDE_INT high;\n+\n+      if (GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  low = CONST_DOUBLE_LOW (x);\n+\t  high = CONST_DOUBLE_HIGH (x);\n+\t}\n+      else\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t{\n+\t  low = INTVAL (x);\n+\t  high = (low < 0) ? ~0 : 0;\n+\t}\n+#else\n+\t{\n+          low = INTVAL (x) & 0xffffffff;\n+          high = (HOST_WIDE_INT) INTVAL (x) >> 32;\n+\t}\n+#endif\n \n       if (TARGET_MINIMAL_TOC)\n-\tfprintf (file, \"\\t.long %d\\n\", INTVAL (val));\n+\tfprintf (file, \"\\t.long %ld\\n\\t.long %ld\\n\", high, low);\n       else\n-\tfprintf (file, \"\\t.tc FS_%x[TC],%d\\n\", INTVAL (val), INTVAL (val));\n+\tfprintf (file, \"\\t.tc ID_%lx_%lx[TC],%ld,%ld\\n\",\n+\t\t high, low, high, low);\n       return;\n     }\n "}]}