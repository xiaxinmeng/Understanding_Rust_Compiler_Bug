{"sha": "90b4a764701e87a51dcb2a04d932f1454d24b157", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBiNGE3NjQ3MDFlODdhNTFkY2IyYTA0ZDkzMmYxNDU0ZDI0YjE1Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T22:42:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T22:42:24Z"}, "message": "(struct bb): Add flags field.\n\n(HAVE_POPEN): Test new define.\n(struct __bb, struct bb_{edge,func}): New structs.\n(__bb_init_{prg,file},__bb_{init,exit}_trace_func,__bb_trace_ret,\n(__bb_trace_func{,_ret},gopen,gclose): New functions.\n\nFrom-SVN: r10850", "tree": {"sha": "b3ab13e64f87799a65aaa393b3c0de60e91de742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3ab13e64f87799a65aaa393b3c0de60e91de742"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90b4a764701e87a51dcb2a04d932f1454d24b157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b4a764701e87a51dcb2a04d932f1454d24b157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90b4a764701e87a51dcb2a04d932f1454d24b157", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b4a764701e87a51dcb2a04d932f1454d24b157/comments", "author": null, "committer": null, "parents": [{"sha": "47431dff3ce4a3fca820512de9de65eb4bab7782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47431dff3ce4a3fca820512de9de65eb4bab7782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47431dff3ce4a3fca820512de9de65eb4bab7782"}], "stats": {"total": 734, "additions": 732, "deletions": 2}, "files": [{"sha": "b7458ef52a536691965e63ea66f083ca8ced022e", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 732, "deletions": 2, "changes": 734, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b4a764701e87a51dcb2a04d932f1454d24b157/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b4a764701e87a51dcb2a04d932f1454d24b157/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=90b4a764701e87a51dcb2a04d932f1454d24b157", "patch": "@@ -1450,6 +1450,7 @@ struct bb\n   const char **functions;\n   const long *line_nums;\n   const char **filenames;\n+  char *flags;\n };\n \n #ifdef BLOCK_PROFILER_CODE\n@@ -1513,11 +1514,11 @@ __bb_exit_func (void)\n \n       /* This is somewhat type incorrect, but it avoids worrying about\n \t exactly where time.h is included from.  It should be ok unless\n-\t a void * differs from other pointer formats, or if sizeof(long)\n+\t a void * differs from other pointer formats, or if sizeof (long)\n \t is < sizeof (time_t).  It would be nice if we could assume the\n \t use of rationale standards here.  */\n \n-      time((void *) &time_value);\n+      time ((void *) &time_value);\n       fprintf (file, \"Basic block profiling finished on %s\\n\", ctime ((void *) &time_value));\n \n       /* We check the length field explicitly in order to allow compatibility\n@@ -1632,6 +1633,735 @@ __bb_init_func (struct bb *blocks)\n   bb_head = blocks;\n }\n \n+#ifndef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\n+#endif\n+#ifndef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\n+#endif\n+\n+#include <string.h>\n+\n+/* Number of buckets in hashtable of basic block addresses. */\n+\n+#define BB_BUCKETS 311\n+\n+/* Maximum length of string in file bb.in. */\n+\n+#define BBINBUFSIZE 500\n+\n+/* BBINBUFSIZE-1 with double quotes. We could use #BBINBUFSIZE or\n+   \"BBINBUFSIZE\" but want to avoid trouble with preprocessors. */\n+\n+#define BBINBUFSIZESTR \"499\"\n+\n+struct bb_edge\n+{\n+  struct bb_edge *next;\n+  unsigned long src_addr;\n+  unsigned long dst_addr;\n+  unsigned long count;\n+};\n+\n+enum bb_func_mode\n+{\n+  TRACE_KEEP = 0, TRACE_ON = 1, TRACE_OFF = 2\n+};\n+\n+struct bb_func\n+{\n+  struct bb_func *next;\n+  char *funcname;\n+  char *filename;\n+  enum bb_func_mode mode;\n+};\n+\n+/* This is the connection to the outside world.\n+   The BLOCK_PROFILER macro must set __bb.blocks\n+   and __bb.blockno. */\n+\n+struct {\n+  unsigned long blockno;\n+  struct bb *blocks;\n+} __bb;\n+\n+/* Vars to store addrs of source and destination basic blocks \n+   of a jump. */\n+\n+static unsigned long bb_src = 0;\n+static unsigned long bb_dst = 0;\n+\n+static FILE *bb_tracefile = (FILE*)0;\n+static struct bb_edge **bb_hashbuckets = (struct bb_edge**)0;\n+static struct bb_func *bb_func_head = (struct bb_func*)0;\n+static unsigned long bb_callcount = 0;\n+static int bb_mode = 0;\n+\n+static unsigned long *bb_stack = (unsigned long *)0;\n+static size_t bb_stacksize = 0;\n+\n+static int reported = 0;\n+\n+/* Trace modes:\n+Always             :   Print execution frequencies of basic blocks\n+                       to file bb.out.\n+bb_mode & 1 != 0   :   Dump trace of basic blocks to file bbtrace[.gz]\n+bb_mode & 2 != 0   :   Print jump frequencies to file bb.out.\n+bb_mode & 4 != 0   :   Cut call instructions from basic block flow.\n+bb_mode & 8 != 0   :   Insert return instructions in basic block flow.\n+*/\n+\n+#ifdef HAVE_POPEN\n+\n+/*#include <sys/types.h>*/\n+#include <sys/stat.h>\n+/*#include <malloc.h>*/\n+\n+/* Commands executed by gopen. */\n+\n+#define GOPENDECOMPRESS \"gzip -cd \"\n+#define GOPENCOMPRESS \"gzip -c >\"\n+\n+/* Like fopen but pipes through gzip.  mode may only be \"r\" or \"w\".\n+   If it does not compile, simply replace gopen by fopen and delete\n+   '.gz' from any first parameter to gopen. */\n+\n+static FILE *\n+gopen (fn, mode)\n+     char *fn;\n+     char *mode;\n+{\n+  int use_gzip;\n+  char *p;\n+\n+  if (mode[1])\n+    return (FILE*)0;\n+\n+  if (mode[0] != 'r' && mode[0] != 'w') \n+    return (FILE*)0;\n+\n+  p = fn + strlen (fn)-1;\n+  use_gzip = ((p[-1] == '.' && (p[0] == 'Z' || p[0] == 'z')) ||\n+              (p[-2] == '.' && p[-1] == 'g' && p[0] == 'z'));\n+\n+  if (use_gzip)\n+    {\n+      if (mode[0]=='r')\n+        {\n+          FILE *f;\n+          char *s = (char*) malloc (sizeof (char) * strlen (fn)\n+                                    + sizeof (GOPENDECOMPRESS));\n+          strcpy (s, GOPENDECOMPRESS);\n+          strcpy (s + (sizeof (GOPENDECOMPRESS)-1), fn);\n+          f = popen (s, mode);\n+          free (s);\n+          return f;\n+        }\n+\n+      else\n+        {\n+          FILE *f;\n+          char *s = (char*) malloc (sizeof (char) * strlen (fn)\n+                                    + sizeof (GOPENCOMPRESS));\n+          strcpy (s, GOPENCOMPRESS);\n+          strcpy (s + (sizeof (GOPENCOMPRESS)-1), fn);\n+          if (!(f = popen (s, mode)))\n+            f = fopen (s, mode);\n+          free (s);\n+          return f;\n+        }\n+    }\n+\n+  else\n+    return fopen (fn, mode);\n+}\n+\n+static int\n+gclose (f)\n+     FILE *f;\n+{\n+  struct stat buf;\n+\n+  if (f != NULL)\n+    {\n+      if (!fstat (fileno (f), &buf) && S_ISFIFO (buf.st_mode))\n+        return pclose (f);\n+\n+      return fclose (f);\n+    }\n+  return 0;\n+}\n+\n+#endif /* HAVE_POPEN */\n+\n+/* Called once per program. */\n+\n+static void\n+__bb_exit_trace_func ()\n+{\n+  FILE *file = fopen (\"bb.out\", \"a\");\n+  struct bb_func *f;\n+  struct bb_edge *e;\n+  struct bb *b;\n+        \n+  if (!file)\n+    perror (\"bb.out\");\n+\n+  if (bb_mode & 1)\n+    {\n+      if (!bb_tracefile)\n+        perror (\"bbtrace\");\n+      else\n+#ifdef HAVE_POPEN\n+        gclose (bb_tracefile);\n+#else\n+        fclose (bb_tracefile);\n+#endif /* HAVE_POPEN */\n+    }\n+\n+  /* Check functions in `bb.in'. */\n+\n+  if (file)\n+    {\n+      long time_value;\n+      const struct bb_func *p;\n+      int printed_something = 0;\n+      struct bb *ptr;\n+      long blk;\n+\n+      /* This is somewhat type incorrect. */\n+      time ((void *) &time_value);\n+\n+      for (p = bb_func_head; p != (struct bb_func *)0; p = p->next)\n+        {\n+          for (ptr = bb_head; ptr != (struct bb *)0; ptr = ptr->next)\n+            {\n+              if (!ptr->filename || p->filename != (char *)0 && strcmp (p->filename, ptr->filename))\n+                continue;\n+              for (blk = 0; blk < ptr->ncounts; blk++)\n+                {\n+                  if (!strcmp (p->funcname, ptr->functions[blk]))\n+                    goto found;\n+                }\n+            }\n+  \n+          if (!printed_something)\n+            {\n+              fprintf (file, \"Functions in `bb.in' not executed during basic block profiling on %s\\n\", ctime ((void *) &time_value));\n+              printed_something = 1;\n+            }\n+\n+          fprintf (file, \"\\tFunction %s\", p->funcname);\n+          if (p->filename)\n+              fprintf (file, \" of file %s\", p->filename);\n+          fprintf (file, \"\\n\" );\n+  \n+found:        ;\n+        }\n+\n+      if (printed_something)\n+       fprintf (file, \"\\n\");\n+\n+    }\n+\n+  if (bb_mode & 2)\n+    {\n+      if (!bb_hashbuckets)\n+        {\n+          if (!reported)\n+            {\n+              fprintf (stderr, \"Profiler: out of memory\\n\");\n+              reported = 1;\n+            }\n+          return;\n+        }\n+    \n+      else if (file)\n+        {\n+          long time_value;\n+          int i;\n+          unsigned long addr_max = 0;\n+          unsigned long cnt_max  = 0;\n+          int cnt_len;\n+          int addr_len;\n+    \n+          /* This is somewhat type incorrect, but it avoids worrying about\n+             exactly where time.h is included from.  It should be ok unless\n+             a void * differs from other pointer formats, or if sizeof (long)\n+             is < sizeof (time_t).  It would be nice if we could assume the\n+             use of rationale standards here.  */\n+    \n+          time ((void *) &time_value);\n+          fprintf (file, \"Basic block jump tracing\");\n+\n+          switch (bb_mode & 12)\n+            {\n+              case 0:\n+                fprintf (file, \" (with call)\");\n+              break;\n+\n+              case 4:\n+\t\t/* Print nothing. */\n+              break;\n+\n+              case 8:\n+                fprintf (file, \" (with call & ret)\");\n+              break;\n+\n+              case 12:\n+                fprintf (file, \" (with ret)\");\n+              break;\n+            }\n+\n+          fprintf (file, \" finished on %s\\n\", ctime ((void *) &time_value));\n+    \n+          for (i = 0; i < BB_BUCKETS; i++)\n+            {\n+               struct bb_edge *bucket = bb_hashbuckets[i];\n+               for ( ; bucket; bucket = bucket->next )\n+                 {\n+                   if (addr_max < bucket->src_addr) \n+                     addr_max = bucket->src_addr;\n+                   if (addr_max < bucket->dst_addr) \n+                     addr_max = bucket->dst_addr;\n+                   if (cnt_max < bucket->count) \n+                     cnt_max = bucket->count;\n+                 }\n+            }\n+          addr_len = num_digits (addr_max, 16);\n+          cnt_len  = num_digits (cnt_max, 10);\n+    \n+          for ( i = 0; i < BB_BUCKETS; i++)\n+            {\n+               struct bb_edge *bucket = bb_hashbuckets[i];\n+               for ( ; bucket; bucket = bucket->next )\n+                 {\n+                   fprintf (file, \"Jump from block 0x%.*lx to \"\n+                                  \"block 0x%.*lx executed %*d time(s)\\n\", \n+                            addr_len, bucket->src_addr, \n+                            addr_len, bucket->dst_addr, \n+                            cnt_len, bucket->count);\n+                 }\n+            }\n+  \n+          fprintf (file, \"\\n\");\n+\n+        }\n+    }\n+\n+   if (file)\n+     fclose (file);\n+\n+   /* Free allocated memory. */\n+\n+   f = bb_func_head;\n+   while (f)\n+     {\n+       struct bb_func *old = f;\n+\n+       f = f->next;\n+       if (old->funcname) free (old->funcname);\n+       if (old->filename) free (old->filename);\n+       free (old);\n+     }\n+\n+   if (bb_stack)\n+     free (bb_stack);\n+\n+   if (bb_hashbuckets)\n+     {\n+       int i;\n+\n+       for (i = 0; i < BB_BUCKETS; i++)\n+         {\n+           struct bb_edge *old, *bucket = bb_hashbuckets[i];\n+\n+           while (bucket)\n+             {\n+               old = bucket;\n+               bucket = bucket->next;\n+               free (old);\n+             }\n+         }\n+       free (bb_hashbuckets);\n+     }\n+\n+   for (b = bb_head; b; b = b->next)\n+     if (b->flags) free (b->flags);\n+}\n+\n+/* Called once per program. */\n+\n+static void\n+__bb_init_prg ()\n+{\n+\n+  FILE *file;\n+  char buf[BBINBUFSIZE];\n+  const char *p;\n+  const char *pos;\n+  enum bb_func_mode m;\n+\n+#ifdef ON_EXIT\n+  /* Initialize destructor.  */\n+  ON_EXIT (__bb_exit_func, 0);\n+#endif\n+\n+  if (!(file = fopen (\"bb.in\", \"r\")))\n+    return;\n+\n+  while(fscanf (file, \" %\" BBINBUFSIZESTR \"s \", buf) != EOF)\n+    {\n+      p = buf;\n+      if (*p == '-') \n+        { \n+          m = TRACE_OFF; \n+          p++; \n+        }\n+      else \n+        { \n+          m = TRACE_ON; \n+        }\n+      if (!strcmp (p, \"__bb_trace__\"))\n+        bb_mode |= 1;\n+      else if (!strcmp (p, \"__bb_jumps__\"))\n+        bb_mode |= 2;\n+      else if (!strcmp (p, \"__bb_hidecall__\"))\n+        bb_mode |= 4;\n+      else if (!strcmp (p, \"__bb_showret__\"))\n+        bb_mode |= 8;\n+      else \n+        {\n+          struct bb_func *f = (struct bb_func*) malloc (sizeof (struct bb_func));\n+          if (f)\n+            {\n+              unsigned long l;\n+              f->next = bb_func_head;\n+              if (pos = strchr (p, ':'))\n+                {\n+                  if (!(f->funcname = (char*) malloc (strlen (pos+1)+1)))\n+                    continue;\n+                  strcpy (f->funcname, pos+1);\n+                  l = pos-p;\n+                  if ((f->filename = (char*) malloc (l+1)))\n+                    {\n+                      strncpy (f->filename, p, l);\n+                      f->filename[l] = '\\0';\n+                    }\n+                  else\n+                    f->filename = (char*)0;\n+                }\n+              else\n+                {\n+                  if (!(f->funcname = (char*) malloc (strlen (p)+1)))\n+                    continue;\n+                  strcpy (f->funcname, p);\n+                  f->filename = (char*)0;\n+                }\n+              f->mode = m;\n+              bb_func_head = f;\n+\t    }\n+         }\n+    }\n+  fclose (file);\n+\n+#ifdef HAVE_POPEN \n+\n+  if (bb_mode & 1)\n+      bb_tracefile = gopen (\"bbtrace.gz\", \"w\");\n+\n+#else\n+\n+  if (bb_mode & 1)\n+      bb_tracefile = fopen (\"bbtrace\", \"w\");\n+\n+#endif /* HAVE_POPEN */\n+\n+  if (bb_mode & 2)\n+    {\n+      bb_hashbuckets = (struct bb_edge **) \n+                   malloc (BB_BUCKETS * sizeof (struct bb_edge *));\n+      if (bb_hashbuckets)\n+        bzero (bb_hashbuckets, BB_BUCKETS);\n+    }\n+\n+  if (bb_mode & 12)\n+    {\n+      bb_stacksize = 10;\n+      bb_stack = (unsigned long *) malloc (bb_stacksize * sizeof (*bb_stack));\n+    }\n+\n+#ifdef ON_EXIT\n+      /* Initialize destructor.  */\n+      ON_EXIT (__bb_exit_trace_func, 0);\n+#endif\n+\n+}\n+\n+/* Called upon entering a basic block. */\n+\n+void\n+__bb_trace_func ()\n+{\n+  struct bb_edge *bucket;\n+\n+  MACHINE_STATE_SAVE(\"1\")\n+\n+  if (!bb_callcount || (__bb.blocks->flags && (__bb.blocks->flags[__bb.blockno] & TRACE_OFF)))\n+    goto skip;\n+\n+  bb_dst = __bb.blocks->addresses[__bb.blockno];\n+  __bb.blocks->counts[__bb.blockno]++;\n+\n+  if (bb_tracefile)\n+    {\n+      fwrite (&bb_dst, sizeof (unsigned long), 1, bb_tracefile);\n+    }\n+\n+  if (bb_hashbuckets)\n+    {\n+      struct bb_edge **startbucket, **oldnext;\n+\n+      oldnext = startbucket =\n+          & bb_hashbuckets[ (((int)bb_src*8)^(int)bb_dst) % BB_BUCKETS ];\n+      bucket = *startbucket;\n+\n+      for (bucket = *startbucket; bucket; \n+           oldnext = &(bucket->next), bucket = *oldnext)\n+        {\n+          if ( bucket->src_addr == bb_src &&\n+               bucket->dst_addr == bb_dst )\n+            {\n+              bucket->count++;\n+              *oldnext = bucket->next;\n+              bucket->next = *startbucket;\n+              *startbucket = bucket;\n+              goto ret;\n+            }\n+        }\n+\n+      bucket = (struct bb_edge *) malloc (sizeof (struct bb_edge));\n+\n+      if (!bucket)\n+        {\n+          if (!reported)\n+            {\n+              fprintf (stderr, \"Profiler: out of memory\\n\");\n+              reported = 1;\n+            }\n+        }\n+\n+      else\n+        {\n+          bucket->src_addr = bb_src;\n+          bucket->dst_addr = bb_dst;\n+          bucket->next = *startbucket;\n+          *startbucket = bucket;\n+          bucket->count = 1;\n+        }\n+    }\n+\n+ret:\n+  bb_src = bb_dst;\n+\n+skip:\n+  ;\n+\n+  MACHINE_STATE_RESTORE(\"1\")\n+\n+}\n+\n+/* Called when returning from a function and `__bb_showret__' is set. */\n+\n+static void\n+__bb_trace_func_ret ()\n+{\n+  struct bb_edge *bucket;\n+\n+  if (!bb_callcount || (__bb.blocks->flags && (__bb.blocks->flags[__bb.blockno] & TRACE_OFF)))\n+    goto skip;\n+\n+  if (bb_hashbuckets)\n+    {\n+      struct bb_edge **startbucket, **oldnext;\n+\n+      oldnext = startbucket =\n+          & bb_hashbuckets[ (((int)bb_dst*8)^(int)bb_src) % BB_BUCKETS ];\n+      bucket = *startbucket;\n+\n+      for (bucket = *startbucket; bucket; \n+           oldnext = &(bucket->next), bucket = *oldnext)\n+        {\n+          if ( bucket->src_addr == bb_dst &&\n+               bucket->dst_addr == bb_src )\n+            {\n+              bucket->count++;\n+              *oldnext = bucket->next;\n+              bucket->next = *startbucket;\n+              *startbucket = bucket;\n+              goto ret;\n+            }\n+        }\n+\n+      bucket = (struct bb_edge *) malloc (sizeof (struct bb_edge));\n+\n+      if (!bucket)\n+        {\n+          if (!reported)\n+            {\n+              fprintf (stderr, \"Profiler: out of memory\\n\");\n+              reported = 1;\n+            }\n+        }\n+\n+      else\n+        {\n+          bucket->src_addr = bb_dst;\n+          bucket->dst_addr = bb_src;\n+          bucket->next = *startbucket;\n+          *startbucket = bucket;\n+          bucket->count = 1;\n+        }\n+    }\n+\n+ret:\n+  bb_dst = bb_src;\n+\n+skip:\n+  ;\n+\n+}\n+\n+/* Called upon entering the first function of a file. */\n+\n+static void\n+__bb_init_file (blocks)\n+     struct bb *blocks;\n+{\n+\n+  const struct bb_func *p;\n+  long blk, ncounts = blocks->ncounts;\n+  const char **functions = blocks->functions;\n+\n+  /* Set up linked list.  */\n+  blocks->zero_word = 1;\n+  blocks->next = bb_head;\n+  bb_head = blocks;\n+\n+  blocks->flags = 0;\n+  if (!bb_func_head ||\n+      !(blocks->flags = (char*) malloc (sizeof (char) * blocks->ncounts)))\n+    return;\n+\n+  for (blk = 0; blk < ncounts; blk++)\n+    blocks->flags[blk] = 0;\n+\n+  for (blk = 0; blk < ncounts; blk++)\n+    {\n+      for (p = bb_func_head; p; p = p->next)\n+        {\n+          if (!strcmp (p->funcname, functions[blk]) &&\n+              (!p->filename || !strcmp (p->filename, blocks->filename)))\n+            {\n+              blocks->flags[blk] |= p->mode;\n+            }\n+        }\n+    }\n+\n+}\n+\n+/* Called when exiting from a function. */\n+\n+void\n+__bb_trace_ret ()\n+{\n+\n+  MACHINE_STATE_SAVE(\"2\")\n+\n+  if (bb_callcount)\n+    {\n+      if ((bb_mode & 12) && bb_stacksize > bb_callcount)\n+        {\n+          bb_src = bb_stack[bb_callcount];\n+          if (bb_mode & 8)\n+            __bb_trace_func_ret ();\n+        }\n+\n+      bb_callcount -= 1;\n+    }\n+\n+  MACHINE_STATE_RESTORE(\"2\")\n+\n+}\n+\n+/* Called when entering a function. */\n+\n+void\n+__bb_init_trace_func (blocks, blockno)\n+     struct bb *blocks;\n+     unsigned long blockno;\n+{\n+  static int trace_init = 0;\n+\n+  MACHINE_STATE_SAVE(\"3\")\n+\n+  if (!blocks->zero_word)\n+    { \n+      if (!trace_init)\n+        { \n+          trace_init = 1;\n+          __bb_init_prg ();\n+        }\n+      __bb_init_file (blocks);\n+    }\n+\n+  if (bb_callcount)\n+    {\n+\n+      bb_callcount += 1;\n+\n+      if (bb_mode & 12)\n+        {\n+          if (bb_callcount >= bb_stacksize)\n+            {\n+              size_t newsize = bb_callcount + 100;\n+\n+              bb_stack = (unsigned long *) realloc (bb_stack, newsize);\n+              if (! bb_stack)\n+                {\n+                  if (!reported)\n+                    {\n+                      fprintf (stderr, \"Profiler: out of memory\\n\");\n+                      reported = 1;\n+                    }\n+                  bb_stacksize = 0;\n+                  goto stack_overflow;\n+                }\n+\t      bb_stacksize = newsize;\n+            }\n+          bb_stack[bb_callcount] = bb_src;\n+\n+          if (bb_mode & 4)\n+            bb_src = 0;\n+\n+        }\n+\n+stack_overflow:;\n+\n+    }\n+\n+  else if (blocks->flags && (blocks->flags[blockno] & TRACE_ON))\n+    {\n+      bb_callcount = 1;\n+      bb_src = 0;\n+\n+      if (bb_stack)\n+          bb_stack[bb_callcount] = bb_src;\n+    }\n+\n+  MACHINE_STATE_RESTORE(\"3\")\n+}\n+\n #endif /* not inhibit_libc */\n #endif /* not BLOCK_PROFILER_CODE */\n #endif /* L_bb */"}]}