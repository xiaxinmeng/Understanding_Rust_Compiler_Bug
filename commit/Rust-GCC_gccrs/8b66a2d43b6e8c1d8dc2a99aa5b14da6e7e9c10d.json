{"sha": "8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2NmEyZDQzYjZlOGMxZDhkYzJhOTlhYTViMTRkYTZlN2U5YzEwZA==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2015-04-20T10:29:26Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2015-04-20T10:29:26Z"}, "message": "[AArch64] PR/64134: Make aarch64_expand_vector_init use 'ins' more often\n\ngcc/:\n\n\tPR target/64134\n\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Load constant\n\tand overwrite variable parts if <= 1/2 the elements are variable.\n\ngcc/testsuite/:\n\n\tPR target/64134\n\t* gcc.target/aarch64/vec_init_1.c: New test.\n\nFrom-SVN: r222229", "tree": {"sha": "ffff27274e6de597063d1d74b2c879849900f328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffff27274e6de597063d1d74b2c879849900f328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/comments", "author": null, "committer": null, "parents": [{"sha": "86f25864e73c151632e43818ce3f405efce3be34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86f25864e73c151632e43818ce3f405efce3be34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86f25864e73c151632e43818ce3f405efce3be34"}], "stats": {"total": 118, "additions": 92, "deletions": 26}, "files": [{"sha": "3628a438b0fa8b6a113bc1eb96d027e7e3905e13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "patch": "@@ -1,3 +1,9 @@\n+2015-04-20  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR target/64134\n+\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Load constant\n+\tand overwrite variable parts if <= 1/2 the elements are variable.\n+\n 2015-04-19  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/65805"}, {"sha": "767b986e907fbede46b117a271d179b58406afca", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "patch": "@@ -8769,22 +8769,19 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n   machine_mode mode = GET_MODE (target);\n   machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n-  int n_var = 0, one_var = -1;\n+  int n_var = 0;\n+  rtx any_const = NULL_RTX;\n   bool all_same = true;\n-  rtx x, mem;\n-  int i;\n \n-  x = XVECEXP (vals, 0, 0);\n-  if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))\n-    n_var = 1, one_var = 0;\n-  \n-  for (i = 1; i < n_elts; ++i)\n+  for (int i = 0; i < n_elts; ++i)\n     {\n-      x = XVECEXP (vals, 0, i);\n+      rtx x = XVECEXP (vals, 0, i);\n       if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))\n-\t++n_var, one_var = i;\n+\t++n_var;\n+      else\n+\tany_const = x;\n \n-      if (!rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n \tall_same = false;\n     }\n \n@@ -8801,36 +8798,60 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n   /* Splat a single non-constant element if we can.  */\n   if (all_same)\n     {\n-      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));\n+      rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));\n       aarch64_emit_move (target, gen_rtx_VEC_DUPLICATE (mode, x));\n       return;\n     }\n \n-  /* One field is non-constant.  Load constant then overwrite varying\n-     field.  This is more efficient than using the stack.  */\n-  if (n_var == 1)\n+  /* Half the fields (or less) are non-constant.  Load constant then overwrite\n+     varying fields.  Hope that this is more efficient than using the stack.  */\n+  if (n_var <= n_elts/2)\n     {\n       rtx copy = copy_rtx (vals);\n-      rtx index = GEN_INT (one_var);\n-      enum insn_code icode;\n \n-      /* Load constant part of vector, substitute neighboring value for\n-\t varying element.  */\n-      XVECEXP (copy, 0, one_var) = XVECEXP (vals, 0, one_var ^ 1);\n+      /* Load constant part of vector.  We really don't care what goes into the\n+\t parts we will overwrite, but we're more likely to be able to load the\n+\t constant efficiently if it has fewer, larger, repeating parts\n+\t (see aarch64_simd_valid_immediate).  */\n+      for (int i = 0; i < n_elts; i++)\n+\t{\n+\t  rtx x = XVECEXP (vals, 0, i);\n+\t  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n+\t    continue;\n+\t  rtx subst = any_const;\n+\t  for (int bit = n_elts / 2; bit > 0; bit /= 2)\n+\t    {\n+\t      /* Look in the copied vector, as more elements are const.  */\n+\t      rtx test = XVECEXP (copy, 0, i ^ bit);\n+\t      if (CONST_INT_P (test) || CONST_DOUBLE_P (test))\n+\t\t{\n+\t\t  subst = test;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  XVECEXP (copy, 0, i) = subst;\n+\t}\n       aarch64_expand_vector_init (target, copy);\n \n-      /* Insert variable.  */\n-      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, one_var));\n-      icode = optab_handler (vec_set_optab, mode);\n+      /* Insert variables.  */\n+      enum insn_code icode = optab_handler (vec_set_optab, mode);\n       gcc_assert (icode != CODE_FOR_nothing);\n-      emit_insn (GEN_FCN (icode) (target, x, index));\n+\n+      for (int i = 0; i < n_elts; i++)\n+\t{\n+\t  rtx x = XVECEXP (vals, 0, i);\n+\t  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n+\t    continue;\n+\t  x = copy_to_mode_reg (inner_mode, x);\n+\t  emit_insn (GEN_FCN (icode) (target, x, GEN_INT (i)));\n+\t}\n       return;\n     }\n \n   /* Construct the vector in memory one field at a time\n      and load the whole vector.  */\n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n-  for (i = 0; i < n_elts; i++)\n+  rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n+  for (int i = 0; i < n_elts; i++)\n     emit_move_insn (adjust_address_nv (mem, inner_mode,\n \t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n \t\t    XVECEXP (vals, 0, i));"}, {"sha": "248ffc866e1c8e4d8329904073c1a6fbaa0f15dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "patch": "@@ -1,3 +1,8 @@\n+2015-04-20  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR target/64134\n+\t* gcc.target/aarch64/vec_init_1.c: New test.\n+\n 2015-04-20  Yvan Roux  <yvan.roux@linaro.org>\n \n \t* gcc.target/arm/pr65729.c: Restrict to hard float ABI compliant"}, {"sha": "64eaff2dadab9de94e5c80174b24e9b216478a54", "filename": "gcc/testsuite/gcc.target/aarch64/vec_init_1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec_init_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec_init_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec_init_1.c?ref=8b66a2d43b6e8c1d8dc2a99aa5b14da6e7e9c10d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fomit-frame-pointer --save-temps -fno-inline\" } */\n+\n+extern void abort (void);\n+\n+typedef float float16x4_t __attribute__ ((vector_size ((16))));\n+\n+float a;\n+float b;\n+\n+float16x4_t\n+make_vector ()\n+{\n+  return (float16x4_t) { 0, 0, a, b };\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  a = 4.0;\n+  b = 3.0;\n+  float16x4_t vec = make_vector ();\n+  if (vec[0] != 0 || vec[1] != 0 || vec[2] != a || vec[3] != b)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"ins\\\\t\" 2 } } */\n+/* What we want to check, is that make_vector does not stp the whole vector\n+   to the stack.  Unfortunately here we scan the body of main() too, which may\n+   be a bit fragile - the test is currently passing only because of the option\n+   -fomit-frame-pointer which avoids use of stp in the prologue to main().  */\n+/* { dg-final { scan-assembler-not \"stp\\\\t\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}]}