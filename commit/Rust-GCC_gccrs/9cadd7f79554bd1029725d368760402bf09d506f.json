{"sha": "9cadd7f79554bd1029725d368760402bf09d506f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhZGQ3Zjc5NTU0YmQxMDI5NzI1ZDM2ODc2MDQwMmJmMDlkNTA2Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-02-19T11:55:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-02-19T11:55:29Z"}, "message": "re PR tree-optimization/34989 (ICE in get_addr_dereference_operands, at tree-ssa-operands.c:1698 with IMA)\n\n2008-02-19  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/34989\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Re-structure.\n\tAllow propagation to INDIRECT_REF if we can simplify only.\n\n\t* gcc.dg/pr34989-1.c: New testcase.\n\t* gcc.dg/pr34989-2.c: Likewise.\n\nFrom-SVN: r132429", "tree": {"sha": "6b712c11a70be977e4056a2a38cbc54c408e270a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b712c11a70be977e4056a2a38cbc54c408e270a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cadd7f79554bd1029725d368760402bf09d506f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cadd7f79554bd1029725d368760402bf09d506f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cadd7f79554bd1029725d368760402bf09d506f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cadd7f79554bd1029725d368760402bf09d506f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ffc301737217b196beaccb2a970e179fa716e5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffc301737217b196beaccb2a970e179fa716e5bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffc301737217b196beaccb2a970e179fa716e5bb"}], "stats": {"total": 155, "additions": 100, "deletions": 55}, "files": [{"sha": "9c8586ead3c9bc443bcc27eecae7985011bd0471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cadd7f79554bd1029725d368760402bf09d506f", "patch": "@@ -1,3 +1,9 @@\n+2008-02-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34989\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Re-structure.\n+\tAllow propagation to INDIRECT_REF if we can simplify only.\n+\n 2008-02-19  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* c-common.c (warn_for_collisions_1): Use appropriate option when"}, {"sha": "48c47b2e0725aded1b34b9d7c0c4a5956849fb69", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9cadd7f79554bd1029725d368760402bf09d506f", "patch": "@@ -1,3 +1,9 @@\n+2008-02-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34989\n+\t* gcc.dg/pr34989-1.c: New testcase.\n+\t* gcc.dg/pr34989-2.c: Likewise.\n+\n 2008-02-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/35028"}, {"sha": "88e8d64c64e4ea0477ea40f6a46ffb75b988f0b8", "filename": "gcc/testsuite/gcc.dg/pr34989-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34989-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34989-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34989-1.c?ref=9cadd7f79554bd1029725d368760402bf09d506f", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"--combine -O2\" } */\n+/* { dg-additional-sources \"pr34989-2.c\" } */\n+\n+extern struct globals *const ptr_to_globals;\n+struct globals { };\n+int syslogd_main(int argc, char **argv)\n+{\n+ (*(struct globals**)&ptr_to_globals) = 0;\n+}"}, {"sha": "c2c719dc0a7092860463b5f79d466a0a931a7c48", "filename": "gcc/testsuite/gcc.dg/pr34989-2.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34989-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34989-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34989-2.c?ref=9cadd7f79554bd1029725d368760402bf09d506f", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do compile } */\n+\n+extern struct globals *const ptr_to_globals;"}, {"sha": "1b901f1b2678d0806e0eb7a03b4b8ec62b4a63ff", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 75, "deletions": 55, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cadd7f79554bd1029725d368760402bf09d506f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=9cadd7f79554bd1029725d368760402bf09d506f", "patch": "@@ -546,68 +546,99 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n \t\t\t       bool single_use_p)\n {\n   tree lhs, rhs, array_ref;\n+  tree *rhsp, *lhsp;\n \n-  /* Strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS. \n-     ADDR_EXPR will not appear on the LHS.  */\n-  lhs = GIMPLE_STMT_OPERAND (use_stmt, 0);\n-  while (handled_component_p (lhs))\n-    lhs = TREE_OPERAND (lhs, 0);\n+  gcc_assert (TREE_CODE (def_rhs) == ADDR_EXPR);\n \n+  lhs = GIMPLE_STMT_OPERAND (use_stmt, 0);\n   rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n \n-  /* Now see if the LHS node is an INDIRECT_REF using NAME.  If so, \n-     propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n-  if (TREE_CODE (lhs) == INDIRECT_REF && TREE_OPERAND (lhs, 0) == name)\n-    {\n-      /* This should always succeed in creating gimple, so there is\n-\t no need to save enough state to undo this propagation.  */\n-      TREE_OPERAND (lhs, 0) = unshare_expr (def_rhs);\n-      fold_stmt_inplace (use_stmt);\n-      tidy_after_forward_propagate_addr (use_stmt);\n-\n-      /* Continue propagating into the RHS.  */\n-    }\n-\n   /* Trivial cases.  The use statement could be a trivial copy or a\n      useless conversion.  Recurse to the uses of the lhs as copyprop does\n-     not copy through differen variant pointers and FRE does not catch\n+     not copy through different variant pointers and FRE does not catch\n      all useless conversions.  Treat the case of a single-use name and\n      a conversion to def_rhs type separate, though.  */\n-  else if (TREE_CODE (lhs) == SSA_NAME\n-\t   && (TREE_CODE (rhs) == NOP_EXPR\n-\t       || TREE_CODE (rhs) == CONVERT_EXPR)\n-\t   && TREE_TYPE (rhs) == TREE_TYPE (def_rhs)\n-\t   && single_use_p)\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && (rhs == name\n+\t  || TREE_CODE (rhs) == NOP_EXPR\n+\t  || TREE_CODE (rhs) == CONVERT_EXPR)\n+      && useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (def_rhs)))\n     {\n+      /* Only recurse if we don't deal with a single use.  */\n+      if (!single_use_p)\n+\treturn forward_propagate_addr_expr (lhs, def_rhs);\n+\n       GIMPLE_STMT_OPERAND (use_stmt, 1) = unshare_expr (def_rhs);\n       return true;\n     }\n-  else if ((TREE_CODE (lhs) == SSA_NAME\n-      \t    && rhs == name)\n-\t   || ((TREE_CODE (rhs) == NOP_EXPR\n-\t\t|| TREE_CODE (rhs) == CONVERT_EXPR)\n-\t       && useless_type_conversion_p (TREE_TYPE (rhs),\n-\t\t\t\t\t    TREE_TYPE (def_rhs))))\n-    return forward_propagate_addr_expr (lhs, def_rhs);\n+\n+  /* Now strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS. \n+     ADDR_EXPR will not appear on the LHS.  */\n+  lhsp = &GIMPLE_STMT_OPERAND (use_stmt, 0);\n+  while (handled_component_p (*lhsp))\n+    lhsp = &TREE_OPERAND (*lhsp, 0);\n+  lhs = *lhsp;\n+\n+  /* Now see if the LHS node is an INDIRECT_REF using NAME.  If so, \n+     propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n+  if (TREE_CODE (lhs) == INDIRECT_REF\n+      && TREE_OPERAND (lhs, 0) == name\n+      /* This will not allow stripping const qualification from\n+\t pointers which we want to allow specifically here to clean up\n+\t the IL for initialization of constant objects.   */\n+      && (useless_type_conversion_p (TREE_TYPE (TREE_OPERAND (lhs, 0)),\n+\t\t\t\t     TREE_TYPE (def_rhs))\n+\t  /* So explicitly check for this here.  */\n+\t  || (TYPE_QUALS (TREE_TYPE (TREE_TYPE (TREE_OPERAND (lhs, 0))))\n+\t      ^ TYPE_QUALS (TREE_TYPE (TREE_TYPE (def_rhs)))) == TYPE_QUAL_CONST)\n+      /* ???  This looks redundant, but is required for bogus types\n+\t that can sometimes occur.  */\n+      && useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t    TREE_TYPE (TREE_OPERAND (def_rhs, 0))))\n+    {\n+      *lhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));\n+      fold_stmt_inplace (use_stmt);\n+      tidy_after_forward_propagate_addr (use_stmt);\n+\n+      /* Continue propagating into the RHS if this was not the only use.  */\n+      if (single_use_p)\n+\treturn true;\n+    }\n \n   /* Strip away any outer COMPONENT_REF, ARRAY_REF or ADDR_EXPR\n      nodes from the RHS.  */\n-  while (handled_component_p (rhs)\n-\t || TREE_CODE (rhs) == ADDR_EXPR)\n-    rhs = TREE_OPERAND (rhs, 0);\n+  rhsp = &GIMPLE_STMT_OPERAND (use_stmt, 1);\n+  while (handled_component_p (*rhsp)\n+\t || TREE_CODE (*rhsp) == ADDR_EXPR)\n+    rhsp = &TREE_OPERAND (*rhsp, 0);\n+  rhs = *rhsp;\n \n   /* Now see if the RHS node is an INDIRECT_REF using NAME.  If so, \n      propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n-  if (TREE_CODE (rhs) == INDIRECT_REF && TREE_OPERAND (rhs, 0) == name)\n+  if (TREE_CODE (rhs) == INDIRECT_REF\n+      && TREE_OPERAND (rhs, 0) == name\n+      /* ???  This doesn't allow stripping const qualification to\n+\t streamline the IL for reads from non-constant objects.  */\n+      && (useless_type_conversion_p (TREE_TYPE (TREE_OPERAND (rhs, 0)),\n+\t\t\t\t     TREE_TYPE (def_rhs))\n+\t  /* So explicitly check for this here.  */\n+\t  || (TYPE_QUALS (TREE_TYPE (TREE_TYPE (TREE_OPERAND (rhs, 0))))\n+\t      ^ TYPE_QUALS (TREE_TYPE (TREE_TYPE (def_rhs)))) == TYPE_QUAL_CONST)\n+      && useless_type_conversion_p (TREE_TYPE (rhs),\n+\t\t\t\t    TREE_TYPE (TREE_OPERAND (def_rhs, 0))))\n     {\n-      /* This should always succeed in creating gimple, so there is\n-         no need to save enough state to undo this propagation.  */\n-      TREE_OPERAND (rhs, 0) = unshare_expr (def_rhs);\n+      *rhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));\n       fold_stmt_inplace (use_stmt);\n       tidy_after_forward_propagate_addr (use_stmt);\n       return true;\n     }\n \n+  /* If the use of the ADDR_EXPR is not a POINTER_PLUS_EXPR, there\n+     is nothing to do. */\n+  if (TREE_CODE (rhs) != POINTER_PLUS_EXPR\n+      || TREE_OPERAND (rhs, 0) != name)\n+    return false;\n+\n   /* The remaining cases are all for turning pointer arithmetic into\n      array indexing.  They only apply when we have the address of\n      element zero in an array.  If that is not the case then there\n@@ -618,15 +649,9 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n       || !integer_zerop (TREE_OPERAND (array_ref, 1)))\n     return false;\n \n-  /* If the use of the ADDR_EXPR is not a POINTER_PLUS_EXPR, there\n-     is nothing to do. */\n-  if (TREE_CODE (rhs) != POINTER_PLUS_EXPR)\n-    return false;\n-\n   /* Try to optimize &x[0] p+ C where C is a multiple of the size\n      of the elements in X into &x[C/element size].  */\n-  if (TREE_OPERAND (rhs, 0) == name\n-      && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n+  if (TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n     {\n       tree orig = unshare_expr (rhs);\n       TREE_OPERAND (rhs, 0) = unshare_expr (def_rhs);\n@@ -651,8 +676,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n      converting a multiplication of an index by the size of the\n      array elements, then the result is converted into the proper\n      type for the arithmetic.  */\n-  if (TREE_OPERAND (rhs, 0) == name\n-      && TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME\n+  if (TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME\n       /* Avoid problems with IVopts creating PLUS_EXPRs with a\n \t different type than their operands.  */\n       && useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (name)))\n@@ -956,18 +980,14 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t\t}\n \n \t      if (TREE_CODE (rhs) == ADDR_EXPR\n-\t\t  /* We can also disregard changes in const qualifiers for\n-\t\t     the dereferenced value.  */\n+\t\t  /* Handle pointer conversions on invariant addresses\n+\t\t     as well, as this is valid gimple.  */\n \t\t  || ((TREE_CODE (rhs) == NOP_EXPR\n \t\t       || TREE_CODE (rhs) == CONVERT_EXPR)\n \t\t      && TREE_CODE (TREE_OPERAND (rhs, 0)) == ADDR_EXPR\n-\t\t      && POINTER_TYPE_P (TREE_TYPE (rhs))\n-\t\t      /* But do not propagate changes in volatileness.  */\n-\t\t      && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (rhs)))\n-\t\t\t  == TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (rhs, 0)))))\n-\t\t      && types_compatible_p (TREE_TYPE (TREE_TYPE (TREE_OPERAND (rhs, 0))),\n-\t\t\t\t\t     TREE_TYPE (TREE_TYPE (rhs)))))\n+\t\t      && POINTER_TYPE_P (TREE_TYPE (rhs))))\n \t\t{\n+\t\t  STRIP_NOPS (rhs);\n \t\t  if (!stmt_references_abnormal_ssa_name (stmt)\n \t\t      && forward_propagate_addr_expr (lhs, rhs))\n \t\t    {"}]}