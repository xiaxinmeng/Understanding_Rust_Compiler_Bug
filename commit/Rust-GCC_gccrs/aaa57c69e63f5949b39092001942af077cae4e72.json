{"sha": "aaa57c69e63f5949b39092001942af077cae4e72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFhNTdjNjllNjNmNTk0OWIzOTA5MjAwMTk0MmFmMDc3Y2FlNGU3Mg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-11-25T16:47:16Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-11-25T16:47:16Z"}, "message": "re PR target/53976 ([SH] Unnecessary clrt/sett after bt/bf)\n\n\tPR target/53976\n\tPR target/59243\n\t* config/sh/sh_optimize_sett_clrt.cc (struct ccreg_value): Update\n\tcomments.\n\t(sh_optimize_sett_clrt::find_last_ccreg_values): Check stack of\n\tpreviously visited basic blocks before recursing instead of only one\n\tbasic block.\n\nFrom-SVN: r205358", "tree": {"sha": "9c05f7288ce2ceb19d9e321c464f80815d13311c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c05f7288ce2ceb19d9e321c464f80815d13311c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaa57c69e63f5949b39092001942af077cae4e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa57c69e63f5949b39092001942af077cae4e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa57c69e63f5949b39092001942af077cae4e72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa57c69e63f5949b39092001942af077cae4e72/comments", "author": null, "committer": null, "parents": [{"sha": "1b7b698a06eca550af2782e64556dbf425089281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b7b698a06eca550af2782e64556dbf425089281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b7b698a06eca550af2782e64556dbf425089281"}], "stats": {"total": 88, "additions": 59, "deletions": 29}, "files": [{"sha": "d12270da1736733a1a056cd176256c6e960a70fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa57c69e63f5949b39092001942af077cae4e72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa57c69e63f5949b39092001942af077cae4e72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aaa57c69e63f5949b39092001942af077cae4e72", "patch": "@@ -1,3 +1,13 @@\n+2013-11-25  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53976\n+\tPR target/59243\n+\t* config/sh/sh_optimize_sett_clrt.cc (struct ccreg_value): Update\n+\tcomments.\n+\t(sh_optimize_sett_clrt::find_last_ccreg_values): Check stack of\n+\tpreviously visited basic blocks before recursing instead of only one\n+\tbasic block.\n+\n 2013-11-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (cortexa53_tuning): New struct."}, {"sha": "fc58bf9efdf7a3b9fc263fd8f18dc19e02727e21", "filename": "gcc/config/sh/sh_optimize_sett_clrt.cc", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaa57c69e63f5949b39092001942af077cae4e72/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaa57c69e63f5949b39092001942af077cae4e72/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc?ref=aaa57c69e63f5949b39092001942af077cae4e72", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n \n #include <vector>\n+#include <algorithm>\n \n /*\n This pass tries to eliminate unnecessary sett or clrt instructions in cases\n@@ -87,16 +88,15 @@ class sh_optimize_sett_clrt : public rtl_opt_pass\n   struct ccreg_value\n   {\n     // The insn at which the ccreg value was determined.\n+    // Might be NULL_RTX if e.g. an unknown value is recorded for an\n+    // empty basic block.\n     rtx insn;\n \n     // The basic block where the insn was discovered.\n-    // Notice that the CFG might be invalid at late RTL stages and\n-    // BLOCK_FOR_INSN might return null.  Thus the basic block are recorded\n-    // here while traversing them.\n     basic_block bb;\n \n-    // The value of ccreg.  If NULL_RTX, the value is not known, e.g. if the\n-    // ccreg is clobbered.\n+    // The value of ccreg.  If NULL_RTX, the exact value is not known, but\n+    // the ccreg is changed in some way (e.g. clobbered).\n     rtx value;\n   };\n \n@@ -113,7 +113,7 @@ class sh_optimize_sett_clrt : public rtl_opt_pass\n   // start insn.\n   void find_last_ccreg_values (rtx start_insn, basic_block bb,\n \t\t\t       std::vector<ccreg_value>& values_out,\n-\t\t\t       basic_block prev_visited_bb = NULL) const;\n+\t\t\t       std::vector<basic_block>& prev_visited_bb) const;\n \n   // Given a cbranch insn, its basic block and another basic block, determine\n   // the value to which the ccreg will be set after jumping/falling through to\n@@ -199,6 +199,10 @@ sh_optimize_sett_clrt::execute (void)\n   std::vector<ccreg_value> ccreg_values;\n   ccreg_values.reserve (32);\n \n+  // Something for recording visited basic blocks to avoid infinite recursion.\n+  std::vector<basic_block> visited_bbs;\n+  visited_bbs.reserve (32);\n+\n   // Look for insns that set the ccreg to a constant value and see if it can\n   // be optimized.\n   basic_block bb;\n@@ -221,7 +225,9 @@ sh_optimize_sett_clrt::execute (void)\n \t    log_msg (\"\\n\");\n \n \t    ccreg_values.clear ();\n-\t    find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values);\n+\t    visited_bbs.clear ();\n+\t    find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values,\n+\t\t\t\t    visited_bbs);\n \n \t    log_msg (\"number of ccreg values collected: %u\\n\",\n \t\t     (unsigned int)ccreg_values.size ());\n@@ -307,12 +313,16 @@ void\n sh_optimize_sett_clrt\n ::find_last_ccreg_values (rtx start_insn, basic_block bb,\n \t\t\t  std::vector<ccreg_value>& values_out,\n-\t\t\t  basic_block prev_visited_bb) const\n+\t\t\t  std::vector<basic_block>& prev_visited_bb) const\n {\n-  if (start_insn == NULL_RTX)\n-    return;\n-\n-  log_msg (\"looking for ccreg values in [bb %d]\\n\", bb->index);\n+  // FIXME: For larger CFGs this will unnecessarily re-visit basic blocks.\n+  // Once a basic block has been visited, the result should be stored in\n+  // some container so that it can be looked up quickly eliminating the\n+  // re-visits.\n+  log_msg (\"looking for ccreg values in [bb %d] \", bb->index);\n+  if (!prev_visited_bb.empty ())\n+    log_msg (\"(prev visited [bb %d])\", prev_visited_bb.back ()->index);\n+  log_msg (\"\\n\");\n \n   for (rtx i = start_insn; i != NULL_RTX && i != PREV_INSN (BB_HEAD (bb));\n        i = PREV_INSN (i))\n@@ -341,7 +351,7 @@ ::find_last_ccreg_values (rtx start_insn, basic_block bb,\n \t  return;\n \t}\n \n-      if (any_condjump_p (i) && onlyjump_p (i) && prev_visited_bb != NULL)\n+      if (any_condjump_p (i) && onlyjump_p (i) && !prev_visited_bb.empty ())\n \t{\n \t  // For a conditional branch the ccreg value will be a known constant\n \t  // of either 0 or STORE_FLAG_VALUE after branching/falling through\n@@ -353,10 +363,11 @@ ::find_last_ccreg_values (rtx start_insn, basic_block bb,\n \t  ccreg_value v;\n \t  v.insn = i;\n \t  v.bb = bb;\n-\t  v.value = GEN_INT (sh_cbranch_ccreg_value (i, bb, prev_visited_bb));\n+\t  v.value = GEN_INT (sh_cbranch_ccreg_value (i, bb,\n+\t\t\t\t\t\t     prev_visited_bb.back ()));\n \n \t  log_msg (\"    branches to [bb %d] with ccreg value \",\n-\t\t   prev_visited_bb->index);\n+\t\t   prev_visited_bb.back ()->index);\n \t  log_rtx (v.value);\n \t  log_msg (\"\\n\");\n \n@@ -370,26 +381,35 @@ ::find_last_ccreg_values (rtx start_insn, basic_block bb,\n   // In this case, check the predecessor basic blocks.\n   unsigned int pred_bb_count = 0;\n \n-  // If the current basic block is the same as the previous one, it's a loop.\n-  // Don't try to recurse again, as this will result in an infinite loop.\n-  if (bb != prev_visited_bb)\n-    for (edge_iterator ei = ei_start (bb->preds); !ei_end_p (ei); ei_next (&ei))\n-      {\n-\tbasic_block pred_bb = ei_edge (ei)->src;\n-\tif (pred_bb->index == ENTRY_BLOCK)\n-\t  continue;\n+  // If the current basic block is not in the stack of previously visited\n+  // basic blocks yet, we can recursively check the predecessor basic blocks.\n+  // Otherwise we have a loop in the CFG and recursing again will result in\n+  // an infinite loop.\n+  if (std::find (prev_visited_bb.rbegin (), prev_visited_bb.rend (), bb)\n+      == prev_visited_bb.rend ())\n+    {\n+      prev_visited_bb.push_back (bb);\n \n-\tpred_bb_count += 1;\n-\tfind_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out, bb);\n-      }\n+      for (edge_iterator ei = ei_start (bb->preds); !ei_end_p (ei);\n+\t   ei_next (&ei))\n+\t{\n+\t  basic_block pred_bb = ei_edge (ei)->src;\n+\t  pred_bb_count += 1;\n+\t  find_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out,\n+\t\t\t\t  prev_visited_bb);\n+\t}\n+\n+      prev_visited_bb.pop_back ();\n+    }\n+  else\n+    log_msg (\"loop detected for [bb %d]\\n\", bb->index);\n \n   log_msg (\"[bb %d] pred_bb_count = %u\\n\", bb->index, pred_bb_count);\n \n-  // If here, we've walked up all the predecessor basic blocks without finding\n-  // anything setcc related.  Add an entry for the last insn of the current\n-  // basic block with the ccreg value being set to unknown (NULL_RTX).\n   if (pred_bb_count == 0)\n   {\n+    // If we haven't checked a single predecessor basic block, the current\n+    // basic block is probably a leaf block and we don't know the ccreg value.\n     log_msg (\"unknown ccreg value for [bb %d]\\n\", bb->index);\n \n     ccreg_value v;"}]}