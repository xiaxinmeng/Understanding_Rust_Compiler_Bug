{"sha": "4e62aca0e0520e4ed2532f2d8153581190621c1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2MmFjYTBlMDUyMGU0ZWQyNTMyZjJkODE1MzU4MTE5MDYyMWMxYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-07T12:46:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-07T13:04:14Z"}, "message": "c++: block-scope externs get an alias [PR95677,PR31775,PR95677]\n\nThis patch improves block-scope extern handling by always injecting a\nhidden copy into the enclosing namespace (or using a match already\nthere).  This hidden copy will be revealed if the user explicitly\ndeclares it later.  We can get from the DECL_LOCAL_DECL_P local extern\nto the alias via DECL_LOCAL_DECL_ALIAS.  This fixes several bugs and\nremoves the kludgy per-function extern_decl_map.  We only do this\npushing for non-dependent local externs -- dependent ones will be\npushed during instantiation.\n\nUser code that expected to be able to handle incompatible local\nexterns in different block-scopes will no longer work.  That code is\nill-formed.  (always was, despite what 31775 claimed).  I had to\nadjust a number of testcases that fell into this.\n\nI tried using DECL_VALUE_EXPR, but that didn't work out.  Due to\nconstexpr requirements we have to do the replacement very late (it\nhappens in the gimplifier).   Consider:\n\nextern int l[]; // #1\nconstexpr bool foo ()\n{\n   extern int l[3]; // this does not complete the type of decl #1\n   constexpr int *p = &l[2]; // ok\n   return !p;\n}\n\nThis requirement, coupled with our use of the common folding machinery\nmakes pr97306 hard to fix, as we end up with an expression containing\nthe two different decls for 'l', and only the c++ FE knows how to\nreconcile those.  I punted on this.\n\n\tgcc/cp/\n\t* cp-tree.h (struct language_function): Delete extern_decl_map.\n\t(DECL_LOCAL_DECL_ALIAS): New.\n\t* name-lookup.h (is_local_extern): Delete.\n\t* name-lookup.c (set_local_extern_decl_linkage): Replace with ...\n\t(push_local_extern_decl): ... this new function.\n\t(do_pushdecl): Call new function after pushing new decl.  Unhide\n\thidden non-functions.\n\t(is_local_extern): Delete.\n\t* decl.c (layout_var_decl): Do not allow VLA local externs.\n\t* decl2.c (mark_used): Also mark DECL_LOCAL_DECL_ALIAS. Drop old\n\tlocal-extern treatment.\n\t* parser.c (cp_parser_oacc_declare): Deal with local extern aliases.\n\t* pt.c (tsubst_expr): Adjust local extern instantiation.\n\t* cp-gimplify.c (cp_genericize_r): Remap DECL_LOCAL_DECLs.\n\tgcc/testsuite/\n\t* g++.dg/cpp0x/lambda/lambda-sfinae1.C: Avoid ill-formed local extern\n\t* g++.dg/init/pr42844.C: Add expected error.\n\t* g++.dg/lookup/extern-redecl1.C: Likewise.\n\t* g++.dg/lookup/koenig15.C: Avoid ill-formed.\n\t* g++.dg/lto/pr95677.C: New.\n\t* g++.dg/other/nested-extern-1.C: Correct expected behabviour.\n\t* g++.dg/other/nested-extern-2.C: Likewise.\n\t* g++.dg/other/nested-extern.cc: Split ...\n\t* g++.dg/other/nested-extern-1.cc: ... here ...\n\t* g++.dg/other/nested-extern-2.cc: ... here.\n\t* g++.dg/template/scope5.C: Avoid ill-formed\n\t* g++.old-deja/g++.law/missed-error2.C: Allow extension.\n\t* g++.old-deja/g++.pt/crash3.C: Add expected error.", "tree": {"sha": "b7dc85222f79352e26770977dfcc28a0f5b4bf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7dc85222f79352e26770977dfcc28a0f5b4bf55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e62aca0e0520e4ed2532f2d8153581190621c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e62aca0e0520e4ed2532f2d8153581190621c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e62aca0e0520e4ed2532f2d8153581190621c1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e62aca0e0520e4ed2532f2d8153581190621c1a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e089e43365f7f2a90979e2316aea25d44823f5a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e089e43365f7f2a90979e2316aea25d44823f5a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e089e43365f7f2a90979e2316aea25d44823f5a3"}], "stats": {"total": 384, "additions": 206, "deletions": 178}, "files": [{"sha": "44c9d249b151c69c917c01f8db762e019160769d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -980,21 +980,17 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   /* Map block scope extern declarations to visible declarations with the\n      same name and type in outer scopes if any.  */\n-  if (cp_function_chain->extern_decl_map\n-      && VAR_OR_FUNCTION_DECL_P (stmt)\n-      && DECL_EXTERNAL (stmt))\n-    {\n-      struct cxx_int_tree_map *h, in;\n-      in.uid = DECL_UID (stmt);\n-      h = cp_function_chain->extern_decl_map->find_with_hash (&in, in.uid);\n-      if (h)\n-\t{\n-\t  *stmt_p = h->to;\n-\t  TREE_USED (h->to) |= TREE_USED (stmt);\n-\t  *walk_subtrees = 0;\n-\t  return NULL;\n-\t}\n-    }\n+  if (VAR_OR_FUNCTION_DECL_P (stmt) && DECL_LOCAL_DECL_P (stmt))\n+    if (tree alias = DECL_LOCAL_DECL_ALIAS (stmt))\n+      {\n+\tif (alias != error_mark_node)\n+\t  {\n+\t    *stmt_p = alias;\n+\t    TREE_USED (alias) |= TREE_USED (stmt);\n+\t  }\n+\t*walk_subtrees = 0;\n+\treturn NULL;\n+      }\n \n   if (TREE_CODE (stmt) == INTEGER_CST\n       && TYPE_REF_P (TREE_TYPE (stmt))"}, {"sha": "467256117ec1ddf0eb8470471bae64a6413d564b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -1926,7 +1926,6 @@ struct GTY(()) language_function {\n   /* Tracking possibly infinite loops.  This is a vec<tree> only because\n      vec<bool> doesn't work with gtype.  */\n   vec<tree, va_gc> *infinite_loops;\n-  hash_table<cxx_int_tree_map_hasher> *extern_decl_map;\n };\n \n /* The current C++-specific per-function global variables.  */\n@@ -2697,6 +2696,7 @@ struct GTY(()) lang_decl_min {\n      In a lambda-capture proxy VAR_DECL, this is DECL_CAPTURED_VARIABLE.\n      In a function-scope TREE_STATIC VAR_DECL or IMPLICIT_TYPEDEF_P TYPE_DECL,\n      this is DECL_DISCRIMINATOR.\n+     In a DECL_LOCAL_DECL_P decl, this is the namespace decl it aliases.\n      Otherwise, in a class-scope DECL, this is DECL_ACCESS.   */\n   tree access;\n };\n@@ -4023,6 +4023,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_LOCAL_DECL_P(NODE) \\\n   DECL_LANG_FLAG_0 (VAR_OR_FUNCTION_DECL_CHECK (NODE))\n \n+/* The namespace-scope decl a DECL_LOCAL_DECL_P aliases.  */\n+#define DECL_LOCAL_DECL_ALIAS(NODE)\t\t\t\\\n+  DECL_ACCESS ((gcc_checking_assert (DECL_LOCAL_DECL_P (NODE)), NODE))\n+\n /* Nonzero if NODE is the target for genericization of 'return' stmts\n    in constructors/destructors of targetm.cxx.cdtor_returns_this targets.  */\n #define LABEL_DECL_CDTOR(NODE) \\"}, {"sha": "0fe74b2e851db202b0b6341381eb7d8383dfef10", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -5830,7 +5830,8 @@ layout_var_decl (tree decl)\n       && DECL_SIZE (decl) != NULL_TREE\n       && ! TREE_CONSTANT (DECL_SIZE (decl)))\n     {\n-      if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n+      if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST\n+\t  && !DECL_LOCAL_DECL_P (decl))\n \tconstant_expression_warning (DECL_SIZE (decl));\n       else\n \t{"}, {"sha": "db3035dfba5f759522bbb7fe91741d94bb9079b7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -5567,6 +5567,22 @@ mark_used (tree decl, tsubst_flags_t complain)\n       return false;\n     }\n \n+  if (VAR_OR_FUNCTION_DECL_P (decl) && DECL_LOCAL_DECL_P (decl))\n+    {\n+      if (!DECL_LANG_SPECIFIC (decl))\n+\t/* An unresolved dependent local extern.  */\n+\treturn true;\n+\n+      DECL_ODR_USED (decl) = 1;\n+      auto alias = DECL_LOCAL_DECL_ALIAS (decl);\n+      if (!alias || alias == error_mark_node)\n+\treturn true;\n+\n+      /* Process the underlying decl.  */\n+      decl = alias;\n+      TREE_USED (decl) = true;\n+    }\n+\n   cp_warn_deprecated_use (decl, complain);\n \n   /* We can only check DECL_ODR_USED on variables or functions with\n@@ -5650,14 +5666,7 @@ mark_used (tree decl, tsubst_flags_t complain)\n       && !DECL_ARTIFICIAL (decl)\n       && !decl_defined_p (decl)\n       && no_linkage_check (TREE_TYPE (decl), /*relaxed_p=*/false))\n-    {\n-      if (is_local_extern (decl))\n-\t/* There's no way to define a local extern, and adding it to\n-\t   the vector interferes with GC, so give an error now.  */\n-\tno_linkage_error (decl);\n-      else\n-\tvec_safe_push (no_linkage_decls, decl);\n-    }\n+    vec_safe_push (no_linkage_decls, decl);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DECLARED_INLINE_P (decl)"}, {"sha": "e3f3712b1f0631ebf5128bfeab8e0e77c2f31301", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 73, "deletions": 113, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static cxx_binding *cxx_binding_make (tree value, tree type);\n static cp_binding_level *innermost_nonclass_level (void);\n+static tree do_pushdecl_with_scope (tree x, cp_binding_level *, bool hiding);\n static void set_identifier_type_value_with_scope (tree id, tree decl,\n \t\t\t\t\t\t  cp_binding_level *b);\n static name_hint maybe_suggest_missing_std_header (location_t location,\n@@ -2921,108 +2922,66 @@ set_decl_context_in_fn (tree ctx, tree decl)\n     DECL_CONTEXT (decl) = ctx;\n }\n \n-/* DECL is a local-scope decl with linkage.  SHADOWED is true if the\n-   name is already bound at the current level.\n-\n-   [basic.link] If there is a visible declaration of an entity with\n-   linkage having the same name and type, ignoring entities declared\n-   outside the innermost enclosing namespace scope, the block scope\n-   declaration declares that same entity and receives the linkage of\n-   the previous declaration.\n-\n-   Also, make sure that this decl matches any existing external decl\n-   in the enclosing namespace.  */\n+/* DECL is a local extern decl.  Find or create the namespace-scope\n+   decl that it aliases.  Also, determines the linkage of DECL.  */\n \n static void\n-set_local_extern_decl_linkage (tree decl, bool shadowed)\n+push_local_extern_decl_alias (tree decl)\n {\n-  tree ns_value = decl; /* Unique marker.  */\n-\n-  if (!shadowed)\n-    {\n-      tree loc_value = innermost_non_namespace_value (DECL_NAME (decl));\n-      if (!loc_value)\n-\t{\n-\t  ns_value\n-\t    = find_namespace_value (current_namespace, DECL_NAME (decl));\n-\t  loc_value = ns_value;\n-\t}\n-      if (loc_value == error_mark_node\n-\t  /* An ambiguous lookup.  */\n-\t  || (loc_value && TREE_CODE (loc_value) == TREE_LIST))\n-\tloc_value = NULL_TREE;\n-\n-      for (ovl_iterator iter (loc_value); iter; ++iter)\n-\tif (!iter.hidden_p ()\n-\t    && (TREE_STATIC (*iter) || DECL_EXTERNAL (*iter))\n-\t    && decls_match (*iter, decl))\n-\t  {\n-\t    /* The standard only says that the local extern inherits\n-\t       linkage from the previous decl; in particular, default\n-\t       args are not shared.  Add the decl into a hash table to\n-\t       make sure only the previous decl in this case is seen\n-\t       by the middle end.  */\n-\t    struct cxx_int_tree_map *h;\n-\n-\t    /* We inherit the outer decl's linkage.  But we're a\n-\t       different decl.  */\n-\t    TREE_PUBLIC (decl) = TREE_PUBLIC (*iter);\n-\n-\t    if (cp_function_chain->extern_decl_map == NULL)\n-\t      cp_function_chain->extern_decl_map\n-\t\t= hash_table<cxx_int_tree_map_hasher>::create_ggc (20);\n-\n-\t    h = ggc_alloc<cxx_int_tree_map> ();\n-\t    h->uid = DECL_UID (decl);\n-\t    h->to = *iter;\n-\t    cxx_int_tree_map **loc = cp_function_chain->extern_decl_map\n-\t      ->find_slot (h, INSERT);\n-\t    *loc = h;\n-\t    break;\n-\t  }\n-    }\n+  if (dependent_type_p (TREE_TYPE (decl)))\n+    return;\n+  /* EH specs were not part of the function type prior to c++17, but\n+     we still can't go pushing dependent eh specs into the namespace.  */\n+  if (cxx_dialect < cxx17\n+      && TREE_CODE (decl) == FUNCTION_DECL\n+      && (value_dependent_expression_p\n+\t  (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)))))\n+    return;\n \n-  if (TREE_PUBLIC (decl))\n-    {\n-      /* DECL is externally visible.  Make sure it matches a matching\n-\t decl in the namespace scope.  We only really need to check\n-\t this when inserting the decl, not when we find an existing\n-\t match in the current scope.  However, in practice we're\n-\t going to be inserting a new decl in the majority of cases --\n-\t who writes multiple extern decls for the same thing in the\n-\t same local scope?  Doing it here often avoids a duplicate\n-\t namespace lookup.  */\n+  gcc_checking_assert (!DECL_LANG_SPECIFIC (decl)\n+\t\t       || !DECL_TEMPLATE_INFO (decl));\n+  if (DECL_LANG_SPECIFIC (decl) && DECL_LOCAL_DECL_ALIAS (decl))\n+    /* We're instantiating a non-dependent local decl, it already\n+       knows the alias.  */\n+    return;\n \n-      /* Avoid repeating a lookup.  */\n-      if (ns_value == decl)\n-\tns_value = find_namespace_value (current_namespace, DECL_NAME (decl));\n+  tree alias = NULL_TREE;\n \n-      if (ns_value == error_mark_node\n-\t  || (ns_value && TREE_CODE (ns_value) == TREE_LIST))\n-\tns_value = NULL_TREE;\n+  if (DECL_SIZE (decl) && !TREE_CONSTANT (DECL_SIZE (decl)))\n+    /* Do not let a VLA creep into a namespace.  Diagnostic will be\n+       emitted in layout_var_decl later.  */\n+    alias = error_mark_node;\n+  else\n+    {\n+      /* First look for a decl that matches.  */\n+      tree ns = CP_DECL_CONTEXT (decl);\n+      tree binding = find_namespace_value (ns, DECL_NAME (decl));\n \n-      for (ovl_iterator iter (ns_value); iter; ++iter)\n-\t{\n-\t  tree other = *iter;\n-\n-\t  if (!(TREE_PUBLIC (other) || DECL_EXTERNAL (other)))\n-\t    ; /* Not externally visible.   */\n-\t  else if (DECL_EXTERN_C_P (decl) && DECL_EXTERN_C_P (other))\n-\t    ; /* Both are extern \"C\", we'll check via that mechanism.  */\n-\t  else if (TREE_CODE (other) != TREE_CODE (decl)\n-\t\t   || ((VAR_P (decl) || matching_fn_p (other, decl))\n-\t\t       && !comptypes (TREE_TYPE (decl), TREE_TYPE (other),\n-\t\t\t\t      COMPARE_REDECLARATION)))\n+      if (binding && TREE_CODE (binding) != TREE_LIST)\n+\tfor (ovl_iterator iter (binding); iter; ++iter)\n+\t  if (decls_match (*iter, decl))\n \t    {\n-\t      auto_diagnostic_group d;\n-\t      if (permerror (DECL_SOURCE_LOCATION (decl),\n-\t\t\t     \"local external declaration %q#D\", decl))\n-\t\tinform (DECL_SOURCE_LOCATION (other),\n-\t\t\t\"does not match previous declaration %q#D\", other);\n+\t      alias = *iter;\n \t      break;\n \t    }\n+\n+      if (!alias)\n+\t{\n+\t  /* No existing namespace-scope decl.  Make one.  */\n+\t  alias = copy_decl (decl);\n+\n+\t  /* This is the real thing.  */\n+\t  DECL_LOCAL_DECL_P (alias) = false;\n+\n+\t  /* Expected default linkage is from the namespace.  */\n+\t  TREE_PUBLIC (alias) = TREE_PUBLIC (ns);\n+\t  alias = do_pushdecl_with_scope (alias, NAMESPACE_LEVEL (ns),\n+\t\t\t\t\t  /* hiding= */true);\n \t}\n     }\n+\n+  retrofit_lang_decl (decl);\n+  DECL_LOCAL_DECL_ALIAS (decl) = alias;\n }\n \n /* Record DECL as belonging to the current lexical scope.  Check for\n@@ -3080,10 +3039,6 @@ do_pushdecl (tree decl, bool hiding)\n \t    old = binding->value;\n \t}\n \n-      if (current_function_decl && VAR_OR_FUNCTION_DECL_P (decl)\n-\t  && DECL_EXTERNAL (decl))\n-\tset_local_extern_decl_linkage (decl, old != NULL_TREE);\n-\n       if (old == error_mark_node)\n \told = NULL_TREE;\n \n@@ -3115,6 +3070,16 @@ do_pushdecl (tree decl, bool hiding)\n \t\t  /* We need to check and register the decl now.  */\n \t\t  check_extern_c_conflict (match);\n \t      }\n+\t    else if (slot && !hiding\n+\t\t     && STAT_HACK_P (*slot) && STAT_DECL_HIDDEN_P (*slot))\n+\t      {\n+\t\t/* Unhide the non-function.  */\n+\t\tgcc_checking_assert (old == match);\n+\t\tif (!STAT_TYPE (*slot))\n+\t\t  *slot = match;\n+\t\telse\n+\t\t  STAT_DECL (*slot) = match;\n+\t      }\n \t    return match;\n \t  }\n \n@@ -3190,12 +3155,21 @@ do_pushdecl (tree decl, bool hiding)\n \t  if (!instantiating_current_function_p ())\n \t    record_locally_defined_typedef (decl);\n \t}\n-      else if (VAR_P (decl))\n-\tmaybe_register_incomplete_var (decl);\n+      else\n+\t{\n+\t  if (VAR_P (decl) && !DECL_LOCAL_DECL_P (decl))\n+\t    maybe_register_incomplete_var (decl);\n+\n+\t  if (VAR_OR_FUNCTION_DECL_P (decl))\n+\t    {\n+\t      if (DECL_LOCAL_DECL_P (decl)\n+\t\t  && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n+\t\tpush_local_extern_decl_alias (decl);\n \n-      if ((VAR_P (decl) || TREE_CODE (decl) == FUNCTION_DECL)\n-\t  && DECL_EXTERN_C_P (decl))\n-\tcheck_extern_c_conflict (decl);\n+\t      if (DECL_EXTERN_C_P (decl))\n+\t\tcheck_extern_c_conflict (decl);\n+\t    }\n+\t}\n     }\n   else\n     add_decl_to_level (level, decl);\n@@ -6871,20 +6845,6 @@ lookup_elaborated_type (tree name, TAG_how how)\n   return ret;\n }\n \n-/* Returns true iff DECL is a block-scope extern declaration of a function\n-   or variable.  We will already have determined validity of the decl\n-   when pushing it.  So we do not have to redo that lookup.  */\n-\n-bool\n-is_local_extern (tree decl)\n-{\n-  if ((TREE_CODE (decl) == FUNCTION_DECL\n-       || TREE_CODE (decl) == VAR_DECL))\n-    return DECL_LOCAL_DECL_P (decl);\n-\n-  return false;\n-}\n-\n /* The type TYPE is being declared.  If it is a class template, or a\n    specialization of a class template, do any processing required and\n    perform error-checking.  If IS_FRIEND is nonzero, this TYPE is"}, {"sha": "d63ff108df513ec9a6f68391097d7747ef231e85", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -342,7 +342,6 @@ extern tree lookup_qualified_name (tree scope, tree name,\n extern tree lookup_qualified_name (tree scope, const char *name,\n \t\t\t\t   LOOK_want = LOOK_want::NORMAL,\n \t\t\t\t   bool = true);\n-extern bool is_local_extern (tree);\n extern bool pushdecl_class_level (tree);\n extern tree pushdecl_namespace_level (tree, bool hiding = false);\n extern bool push_class_level_binding (tree, tree);"}, {"sha": "7a61abfa7038e3689884ec7d00e8fb2571ad1a13", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -41176,6 +41176,10 @@ cp_parser_oacc_declare (cp_parser *parser, cp_token *pragma_tok)\n \t}\n \n       if (!found_in_scope)\n+\t/* This seems to ignore the existence of cleanup scopes?\n+\t   What is the meaning for local extern decls?  The local\n+\t   extern is in this scope, but it is referring to a decl that\n+\t   is namespace scope.  */\n \tfor (tree d = current_binding_level->names; d; d = TREE_CHAIN (d))\n \t  if (d == decl)\n \t    {\n@@ -41205,6 +41209,16 @@ cp_parser_oacc_declare (cp_parser *parser, cp_token *pragma_tok)\n \t{\n \t  tree id;\n \n+\t  if (DECL_LOCAL_DECL_P (decl))\n+\t    /* We need to mark the aliased decl, as that is the entity\n+\t       that is being referred to.  This won't work for\n+\t       dependent variables, but it didn't work for them before\n+\t       DECL_LOCAL_DECL_P was a thing either.  But then\n+\t       dependent local extern variable decls are as rare as\n+\t       hen's teeth.  */\n+\t    if (auto alias = DECL_LOCAL_DECL_ALIAS (decl))\n+\t      decl = alias;\n+\n \t  if (OMP_CLAUSE_MAP_KIND (t) == GOMP_MAP_LINK)\n \t    id = get_identifier (\"omp declare target link\");\n \t  else"}, {"sha": "3755aab092d4f2ba925521b7e5310e88d41bb509", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -18104,13 +18104,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t  }\n \t\telse if (DECL_IMPLICIT_TYPEDEF_P (t))\n \t\t  /* We already did a pushtag.  */;\n-\t\telse if (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t\t && DECL_LOCAL_DECL_P (decl)\n-\t\t\t && DECL_OMP_DECLARE_REDUCTION_P (decl))\n+\t\telse if (VAR_OR_FUNCTION_DECL_P (decl)\n+\t\t\t && DECL_LOCAL_DECL_P (decl))\n \t\t  {\n-\t\t    DECL_CONTEXT (decl) = current_function_decl;\n-\t\t    pushdecl (decl);\n-\t\t    if (cp_check_omp_declare_reduction (decl))\n+\t\t    if (TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n+\t\t      DECL_CONTEXT (decl) = NULL_TREE;\n+\t\t    decl = pushdecl (decl);\n+\t\t    if (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t\t&& DECL_OMP_DECLARE_REDUCTION_P (decl)\n+\t\t\t&& cp_check_omp_declare_reduction (decl))\n \t\t      instantiate_body (pattern_decl, args, decl, true);\n \t\t  }\n \t\telse"}, {"sha": "a9acc20e87f540e73d97670d788bfe20fddb8101", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-sfinae1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-sfinae1.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -9,7 +9,7 @@ struct AddRvalueReferenceImpl { typedef T type; };\n template <typename T>\n struct AddRvalueReferenceImpl<T, typename BoolSink<false &&\n       [] {\t\t\t// { dg-error \"lambda\" \"\" { target c++17_down } }\n-         extern T &&tref;\n+\textern void tref(T&&);\n       }>::type> {\n    typedef T &&type;\n };"}, {"sha": "d616f45c0a914e66d90ad5cc93538fb5a039c0cd", "filename": "gcc/testsuite/g++.dg/init/pr42844.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr42844.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr42844.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpr42844.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -49,7 +49,7 @@ template <class T>\n void g ()\n {\n   T const t; // { dg-error \"uninitialized 'const\" }\n-  extern T const text;\n+  extern T const text; // { dg-error \"conflicting declaration\" }\n }\n \n template void g<H> ();"}, {"sha": "f3e9b695f3b5aa68d65522455c09dc984bee0ab6", "filename": "gcc/testsuite/g++.dg/lookup/extern-redecl1.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fextern-redecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fextern-redecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fextern-redecl1.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -1,18 +1,18 @@\n extern int X; // { dg-message \"previous declaration\" }\n-extern int Y (int);  // { dg-message \"previous declaration\" }\n+extern int Y (int);  // { dg-message \"old declaration\" }\n extern int Y (float);\n \n-static int Z (int s)\n+static int Z (int s) // { dg-message \"old declaration\" }\n {\n   return s;\n }\n \n void Foo ()\n {\n-  extern char X; // { dg-error \"local external declaration\" }\n-  extern char Y (int); // { dg-error \"local external declaration\" }\n+  extern char X; // { dg-error \"conflicting declaration\" }\n+  extern char Y (int); // { dg-error \"ambiguating new declaration\" }\n   extern int Y (float);\n   extern void Y (double);\n-  extern char Z (int);\n+  extern char Z (int); // { dg-error \"ambiguating new declaration\" }\n }\n "}, {"sha": "6bf916a752d69e4a41e8ab4878eeca76859678eb", "filename": "gcc/testsuite/g++.dg/lookup/koenig15.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig15.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -4,10 +4,12 @@\n namespace N {\n   struct S { };\n   void f(S);\n+  void g(S);\n }\n \n namespace M {\n   void f(int);\n+  void g(int);\n }\n \n void\n@@ -40,6 +42,6 @@ void\n fn3 ()\n {\n   N::S s;\n-  extern void (*f)(char);\n-  f (s); // { dg-error \"cannot convert\" }\n+  extern void (*g)(char);\n+  g (s); // { dg-error \"cannot convert\" }\n }"}, {"sha": "520ef04e61c897b592a791a67ab4c19aa4b0af22", "filename": "gcc/testsuite/g++.dg/lto/pr95677.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr95677.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr95677.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr95677.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/95677\n+\n+// { dg-do link }\n+// { dg-require-effective-target lto }\n+// { dg-options \"-flto\" }\n+\n+\n+\n+namespace {\n+  void foo() {\n+    extern int xx; // injects a *static*\n+    xx = 0;\n+  }\n+  int xx = 1;\n+}\n+\n+int main() {\n+  xx = 2;\n+}"}, {"sha": "6c879e5de413ea8151b5d0610591dbeb382aef2d", "filename": "gcc/testsuite/g++.dg/other/nested-extern-1.C", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-1.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -1,17 +1,21 @@\n /* { dg-do run } */\n-// { dg-additional-sources \"nested-extern.cc\" }\n+// { dg-additional-options \"-fpermissive\" }\n+// { dg-additional-sources \"nested-extern-1.cc\" }\n /* PR 31775 */\n-extern \"C\" void abort();\n+extern int *p_otheri;\n extern int *p;\n int main()\n { \n-  extern int i;\n+  extern int i; // { dg-message \"previous declaration\" }\n   i = 1;\n   *p = 2;\n-  if (i == 2)\n-    abort ();\n+  if (i != 2)\n+    return 1;\n+  if (p_otheri != p)\n+    return 2;\n   return 0;\n }\n \n-static int i;\n+// This is extern because of the injection above.\n+static int i; // { dg-warning \".extern. and later .static\" }\n int *p = &i;"}, {"sha": "7d7007200051cd604ee53acef956ec9e5ff4cd50", "filename": "gcc/testsuite/g++.dg/other/nested-extern-1.cc", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-1.cc?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -0,0 +1,3 @@\n+extern int i;\n+\n+int *p_otheri = &i;"}, {"sha": "acd78ff406421bf844de8574806edf1ba02e0063", "filename": "gcc/testsuite/g++.dg/other/nested-extern-2.C", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-2.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -1,18 +1,27 @@\n /* { dg-do run } */\n-// { dg-additional-sources \"nested-extern.cc\" }\n /* PR 31775 */\n-extern \"C\" void abort();\n-static int i;\n-int *p = &i;\n+// { dg-additional-sources \"nested-extern-2.cc\" }\n+extern int *p_otheri;\n+static int i; // #1\n+int *p_si = &i;\n int main()\n { \n   int i;\n-  { \n+  int *p_ai = &i;\n+  {\n+    // This is an alias of #1, not a different object\n     extern int i;\n-    i = 1;\n-    *p = 2;\n-    if (i == 2)\n-      abort ();\n+    int *p_ei = &i;\n+\n+    *p_si = 1;\n+    *p_ai = 2;\n+    *p_ei = 3;\n+    if (*p_si != 3)\n+      return 1;\n+    if (*p_ai != 2)\n+      return 2;\n+    if (*p_otheri != 17)\n+      return 3;\n   }\n   return 0;\n }"}, {"sha": "da43380f382901aa0949681527ae3f02c84fdde4", "filename": "gcc/testsuite/g++.dg/other/nested-extern-2.cc", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern-2.cc?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -0,0 +1,3 @@\n+int i = 17; // never touched\n+\n+int *p_otheri = &i;"}, {"sha": "048f715b4656f388eaeddede94b3808a59a3a95e", "filename": "gcc/testsuite/g++.dg/other/nested-extern.cc", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e089e43365f7f2a90979e2316aea25d44823f5a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e089e43365f7f2a90979e2316aea25d44823f5a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fnested-extern.cc?ref=e089e43365f7f2a90979e2316aea25d44823f5a3", "patch": "@@ -1 +0,0 @@\n-int i;"}, {"sha": "cf23a0837bd230fe13d876a2a13c7425e6e8ce29", "filename": "gcc/testsuite/g++.dg/template/scope5.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fscope5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fscope5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fscope5.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -57,10 +57,12 @@ enum { a = b::e<0>::f };\n template <typename> class au;\n template <typename av> struct ac : ao<av> { typedef c::e<am::an> aq; };\n template <typename aw, typename i, typename ax> void ay(aw, i, ax) {\n-  au<c::e<ap<typename ak<i>::o>::f> > az();\n+  // Not sure if this has been creduced from an initialization of a\n+  // variable to a block-scope extern function decl\n+  au<c::e<ap<typename ak<i>::o>::f> > az2();\n }\n void v() {\n   ad a;\n-  void az();\n-  ay(az, a, v);\n+  void az1();\n+  ay(az1, a, v);\n }"}, {"sha": "7ae494b75da09ea9ada970845388db36971ef334", "filename": "gcc/testsuite/g++.old-deja/g++.law/missed-error2.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fmissed-error2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fmissed-error2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fmissed-error2.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -1,4 +1,5 @@\n // { dg-do assemble  }\n+// { dg-additional-options -fpermissive }\n // GROUPS passed missed-error\n // missed-error file\n // From: ndc!don@csvax.cs.caltech.edu (Don Erway)\n@@ -20,14 +21,14 @@ inline double max(double a, double b) {return a > b ? a : b;}; // { dg-message \"\n  // { dg-error \"extra ';'\" \"extra ;\" { target c++98_only } .-1 }\n \n int main() {\n+  // we treat this as-if extern\n    static void foo(int i, int j, double x, double y) ;// { dg-error \"\" } .*\n \n    foo(4, -37, 14.39, 14.38);\n }\n \n-// 971006 we no longer give an error for this since we emit a hard error\n-// about the declaration above\n-static void foo(int i, int j, double x, double y) { \n+static void foo(int i, int j, double x, double y) // { dg-warning \".extern.\" }\n+{ \n \n    std::cout << \"Max(int): \" << max(i,j) << \" Max(double): \" <<\n max(x,y) << '\\n';"}, {"sha": "52701b776ef484c85f2a0a4ffa6273b20c12ff92", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash3.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e62aca0e0520e4ed2532f2d8153581190621c1a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash3.C?ref=4e62aca0e0520e4ed2532f2d8153581190621c1a", "patch": "@@ -5,12 +5,13 @@ class CVector {\n public:\n     CVector<int> f() const\n     {\n-       CVector<int> v();\n+      // local-extern :)\n+      CVector<int> v(); // { dg-message \"old declaration\" }\n        return v;\t\t// { dg-error \"convert\" }\n     }\n     CVector<long> g() const\n     {\n-       CVector<long> v();\n+      CVector<long> v(); // { dg-error \"ambiguating new\" }\n        return v;\t\t// { dg-error \"convert\" }\n     }\n };"}]}