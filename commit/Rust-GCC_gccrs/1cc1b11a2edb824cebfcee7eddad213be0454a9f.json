{"sha": "1cc1b11a2edb824cebfcee7eddad213be0454a9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNjMWIxMWEyZWRiODI0Y2ViZmNlZTdlZGRhZDIxM2JlMDQ1NGE5Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T19:35:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T19:35:40Z"}, "message": "(fold): Handle complex constants as \"winning\".\n\nHandle REALPART_EXPR and IMAGPART_EXPR.\n\nFrom-SVN: r3637", "tree": {"sha": "79c15ba6e9da2a5a6c004248494ac406dcaec94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79c15ba6e9da2a5a6c004248494ac406dcaec94c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cc1b11a2edb824cebfcee7eddad213be0454a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cc1b11a2edb824cebfcee7eddad213be0454a9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cc1b11a2edb824cebfcee7eddad213be0454a9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cc1b11a2edb824cebfcee7eddad213be0454a9f/comments", "author": null, "committer": null, "parents": [{"sha": "8365d59ba28e2e6987de4e68519b6508becde81e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8365d59ba28e2e6987de4e68519b6508becde81e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8365d59ba28e2e6987de4e68519b6508becde81e"}], "stats": {"total": 64, "additions": 60, "deletions": 4}, "files": [{"sha": "9e2fb8237751309b50d221172d195583ad389490", "filename": "gcc/fold-const.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc1b11a2edb824cebfcee7eddad213be0454a9f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc1b11a2edb824cebfcee7eddad213be0454a9f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1cc1b11a2edb824cebfcee7eddad213be0454a9f", "patch": "@@ -2994,16 +2994,23 @@ fold (expr)\n   kind = TREE_CODE_CLASS (code);\n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n     {\n+      tree subop;\n+\n       /* Special case for conversion ops that can have fixed point args.  */\n       arg0 = TREE_OPERAND (t, 0);\n \n       /* Don't use STRIP_NOPS, because signedness of argument type matters.  */\n       if (arg0 != 0)\n \tSTRIP_TYPE_NOPS (arg0);\n \n-      if (arg0 != 0 && TREE_CODE (arg0) != INTEGER_CST\n+      if (arg0 != 0 && TREE_CODE (arg0) == COMPLEX_CST)\n+\tsubop = TREE_REALPART (arg0);\n+      else\n+\tsubop = arg0;\n+\n+      if (subop != 0 && TREE_CODE (subop) != INTEGER_CST\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-\t  && TREE_CODE (arg0) != REAL_CST\n+\t  && TREE_CODE (subop) != REAL_CST\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \t  )\n \t/* Note that TREE_CONSTANT isn't enough:\n@@ -3019,16 +3026,22 @@ fold (expr)\n       for (i = 0; i < len; i++)\n \t{\n \t  tree op = TREE_OPERAND (t, i);\n+\t  tree subop;\n \n \t  if (op == 0)\n \t    continue;\t\t/* Valid for CALL_EXPR, at least.  */\n \n \t  /* Strip any conversions that don't change the mode.  */\n \t  STRIP_NOPS (op);\n \t  \n-\t  if (TREE_CODE (op) != INTEGER_CST\n+\t  if (TREE_CODE (op) == COMPLEX_CST)\n+\t    subop = TREE_REALPART (op);\n+\t  else\n+\t    subop = op;\n+\n+\t  if (TREE_CODE (subop) != INTEGER_CST\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-\t      && TREE_CODE (op) != REAL_CST\n+\t      && TREE_CODE (subop) != REAL_CST\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \t      )\n \t    /* Note that TREE_CONSTANT isn't enough:\n@@ -4384,6 +4397,49 @@ fold (expr)\n \treturn non_lvalue (arg1);\n       return arg1;\n \n+    case COMPLEX_EXPR:\n+      if (wins)\n+\treturn build_complex (arg0, arg1);\n+      return t;\n+\n+    case REALPART_EXPR:\n+      if (TREE_CODE (type) != COMPLEX_TYPE)\n+\treturn t;\n+      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n+\treturn omit_one_operand (type, TREE_OPERAND (arg0, 0),\n+\t\t\t\t TREE_OPERAND (arg0, 1));\n+      else if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn TREE_REALPART (arg0);\n+      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+\treturn build_binary_op (TREE_CODE (arg0), type,\n+\t\t\t\tbuild_unary_op (REALPART_EXPR,\n+\t\t\t\t\t\tTREE_OPERAND (arg0, 0),\n+\t\t\t\t\t\t1),\n+\t\t\t\tbuild_unary_op (REALPART_EXPR,\n+\t\t\t\t\t\tTREE_OPERAND (arg0, 1),\n+\t\t\t\t\t\t1),\n+\t\t\t\t0);\n+      return t;\n+\n+    case IMAGPART_EXPR:\n+      if (TREE_CODE (type) != COMPLEX_TYPE)\n+\treturn convert (type, integer_zero_node);\n+      else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n+\treturn omit_one_operand (type, TREE_OPERAND (arg0, 1),\n+\t\t\t\t TREE_OPERAND (arg0, 0));\n+      else if (TREE_CODE (arg0) == COMPLEX_CST)\n+\treturn TREE_IMAGPART (arg0);\n+      else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n+\treturn build_binary_op (TREE_CODE (arg0), type,\n+\t\t\t\tbuild_unary_op (IMAGPART_EXPR,\n+\t\t\t\t\t\tTREE_OPERAND (arg0, 0),\n+\t\t\t\t\t\t1),\n+\t\t\t\tbuild_unary_op (IMAGPART_EXPR,\n+\t\t\t\t\t\tTREE_OPERAND (arg0, 1),\n+\t\t\t\t\t\t1),\n+\t\t\t\t0);\n+      return t;\n+\n     default:\n       return t;\n     } /* switch (code) */"}]}