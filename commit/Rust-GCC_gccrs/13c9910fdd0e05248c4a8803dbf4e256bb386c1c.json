{"sha": "13c9910fdd0e05248c4a8803dbf4e256bb386c1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNjOTkxMGZkZDBlMDUyNDhjNGE4ODAzZGJmNGUyNTZiYjM4NmMxYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-21T03:51:25Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-21T03:51:25Z"}, "message": "(find_comparison_args): New args PMODE1, PMODE2.\n\n(fold_rtx, record_jump_equiv): Use them to get modes of comparison.\n(fold_rtx): Associate MINUS with nested PLUS.\n\nFrom-SVN: r2197", "tree": {"sha": "873b2a5486024a6101b945590933bf18f10da584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/873b2a5486024a6101b945590933bf18f10da584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13c9910fdd0e05248c4a8803dbf4e256bb386c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c9910fdd0e05248c4a8803dbf4e256bb386c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c9910fdd0e05248c4a8803dbf4e256bb386c1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c9910fdd0e05248c4a8803dbf4e256bb386c1c/comments", "author": null, "committer": null, "parents": [{"sha": "e64ff1039c30a38b6e88e0399f64b7a8fc359e46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e64ff1039c30a38b6e88e0399f64b7a8fc359e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e64ff1039c30a38b6e88e0399f64b7a8fc359e46"}], "stats": {"total": 51, "additions": 29, "deletions": 22}, "files": [{"sha": "b5a6edc57321c0ef29e810343452cc95aaaeca2e", "filename": "gcc/cse.c", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c9910fdd0e05248c4a8803dbf4e256bb386c1c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c9910fdd0e05248c4a8803dbf4e256bb386c1c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=13c9910fdd0e05248c4a8803dbf4e256bb386c1c", "patch": "@@ -2629,9 +2629,10 @@ find_best_addr (insn, loc)\n    A or the code corresponding to the inverse of the comparison.  */\n \n static enum rtx_code\n-find_comparison_args (code, parg1, parg2)\n+find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n      enum rtx_code code;\n      rtx *parg1, *parg2;\n+     enum machine_mode *pmode1, *pmode2;\n {\n   rtx arg1, arg2;\n \n@@ -2770,7 +2771,9 @@ find_comparison_args (code, parg1, parg2)\n \tcode = reverse_condition (code);\n     }\n \n-  /* Return our results.  */\n+  /* Return our results.  Return the modes from before fold_rtx\n+     because fold_rtx might produce const_int, and then it's too late.  */\n+  *pmode1 = GET_MODE (arg1), *pmode2 = GET_MODE (arg2);\n   *parg1 = fold_rtx (arg1, 0), *parg2 = fold_rtx (arg2, 0);\n \n   return code;\n@@ -4549,7 +4552,7 @@ fold_rtx (x, insn)\n       if (new)\n \treturn fold_rtx (copy_rtx (XEXP (new, 0)), insn);\n       break;\n-      \n+\n     case MEM:\n       /* If we are not actually processing an insn, don't try to find the\n \t best address.  Not only don't we care, but we could modify the\n@@ -4848,6 +4851,7 @@ fold_rtx (x, insn)\n \t{\n \t  struct table_elt *p0, *p1;\n \t  rtx true = const_true_rtx, false = const0_rtx;\n+\t  enum machine_mode mode_arg1;\n \n #ifdef FLOAT_STORE_FLAG_VALUE\n \t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -4857,23 +4861,14 @@ fold_rtx (x, insn)\n \t    }\n #endif\n \n-\t  code = find_comparison_args (code, &folded_arg0, &folded_arg1);\n+\t  code = find_comparison_args (code, &folded_arg0, &folded_arg1,\n+\t\t\t\t       &mode_arg0, &mode_arg1);\n \t  const_arg0 = equiv_constant (folded_arg0);\n \t  const_arg1 = equiv_constant (folded_arg1);\n \n-\t  /* Get a mode from the values actually being compared, or from the\n-\t     old value of MODE_ARG0 if both are constants.  If the resulting\n-\t     mode is VOIDmode or a MODE_CC mode, we don't know what kinds\n-\t     of things are being compared, so we can't do anything with this\n-\t     comparison.  */\n-\n-\t  if (GET_MODE (folded_arg0) != VOIDmode\n-\t      && GET_MODE_CLASS (GET_MODE (folded_arg0)) != MODE_CC)\n-\t    mode_arg0 = GET_MODE (folded_arg0);\n-\n-\t  else if (GET_MODE (folded_arg1) != VOIDmode\n-\t\t   && GET_MODE_CLASS (GET_MODE (folded_arg1)) != MODE_CC)\n-\t    mode_arg0 = GET_MODE (folded_arg1);\n+\t  /* If the mode is VOIDmode or a MODE_CC mode, we don't know\n+\t     what kinds of things are being compared, so we can't do\n+\t     anything with this comparison.  */\n \n \t  if (mode_arg0 == VOIDmode || GET_MODE_CLASS (mode_arg0) == MODE_CC)\n \t    break;\n@@ -5020,10 +5015,21 @@ fold_rtx (x, insn)\n \t\t  && XEXP (XEXP (y, 1), 0) == XEXP (const_arg1, 0))\n \t\treturn XEXP (y, 0);\n \t    }\n+\t  goto from_plus;\n+\n+\tcase MINUS:\n+\t  /* If we have (MINUS Y C), see if Y is known to be (PLUS Z C2).\n+\t     If so, produce (PLUS Z C2-C).  */\n+\t  if (const_arg1 != 0 && GET_CODE (const_arg1) == CONST_INT)\n+\t    {\n+\t      rtx y = lookup_as_function (XEXP (x, 0), PLUS);\n+\t      if (y && GET_CODE (XEXP (y, 1)) == CONST_INT)\n+\t\treturn fold_rtx (plus_constant (y, -INTVAL (const_arg1)));\n+\t    }\n \n \t  /* ... fall through ... */\n \n-\tcase MINUS:\n+\tfrom_plus:\n \tcase SMIN:    case SMAX:      case UMIN:    case UMAX:\n \tcase IOR:     case AND:       case XOR:\n \tcase MULT:    case DIV:       case UDIV:\n@@ -5241,7 +5247,7 @@ record_jump_equiv (insn, taken)\n {\n   int cond_known_true;\n   rtx op0, op1;\n-  enum machine_mode mode;\n+  enum machine_mode mode, mode0, mode1;\n   int reversed_nonequality = 0;\n   enum rtx_code code;\n \n@@ -5262,16 +5268,17 @@ record_jump_equiv (insn, taken)\n   op0 = fold_rtx (XEXP (XEXP (SET_SRC (PATTERN (insn)), 0), 0), insn);\n   op1 = fold_rtx (XEXP (XEXP (SET_SRC (PATTERN (insn)), 0), 1), insn);\n \n-  code = find_comparison_args (code, &op0, &op1);\n+  code = find_comparison_args (code, &op0, &op1, &mode0, &mode1);\n   if (! cond_known_true)\n     {\n       reversed_nonequality = (code != EQ && code != NE);\n       code = reverse_condition (code);\n     }\n \n   /* The mode is the mode of the non-constant.  */\n-  mode = GET_MODE (op0);\n-  if (mode == VOIDmode) mode = GET_MODE (op1);\n+  mode = mode0;\n+  if (mode1 != VOIDmode)\n+    mode = mode1;\n \n   record_jump_cond (code, mode, op0, op1, reversed_nonequality);\n }"}]}