{"sha": "18c8152070f9939739b297a4f133db1ca2387b6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjODE1MjA3MGY5OTM5NzM5YjI5N2E0ZjEzM2RiMWNhMjM4N2I2ZA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-07-29T23:36:53Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-07-29T23:36:53Z"}, "message": "c-common.c (allow_pch): Remove.\n\n2003-07-29  Geoffrey Keating  <geoffk@apple.com>\n\n\t* c-common.c (allow_pch): Remove.\n\t* c-common.h (allow_pch): Remove.\n\t(c_common_no_more_pch): Declare.\n\t* c-lex.c (c_lex): Call c_common_no_more_pch when appropriate.\n\t* c-pch.c: Include hosthooks.h.\n\t(c_common_valid_pch): Don't check allow_pch.\n\t(c_common_read_pch): Clear valid_pch to prevent reading PCH files.\n\t(c_common_no_more_pch): New.\n\t* ggc-common.c: Include hosthooks.h.\n\t(gt_pch_save): Call gt_pch_get_address.\n\t(gt_pch_restore): Call gt_pch_use_address.\n\t* hooks.c (hook_voidp_size_t_null): New.\n\t(hook_bool_voidp_size_t_false): New.\n\t* hooks.h (hook_voidp_size_t_null): New.\n\t(hook_bool_voidp_size_t_false): New.\n\t* hosthooks-def.h (HOST_HOOKS_GT_PCH_GET_ADDRESS): New.\n\t(HOST_HOOKS_GT_PCH_USE_ADDRESS): New.\n\t(HOST_HOOKS_INITIALIZER): Add HOST_HOOKS_GT_PCH_GET_ADDRESS,\n\tHOST_HOOKS_GT_PCH_USE_ADDRESS.\n\t* hosthooks.h (struct host_hooks): Add gt_pch_get_address,\n\tgt_pch_use_address.\n\t* doc/hostconfig.texi (Host Common): Document\n\tHOST_HOOKS_GT_PCH_GET_ADDRESS, HOST_HOOKS_GT_PCH_USE_ADDRESS.\n\t* Makefile.in (c-pch.o): Depend on hosthooks.h.\n\t(ggc-common.o): Likewise.\n\n\t* config/rs6000/host-darwin.c (HOST_HOOKS_GT_PCH_GET_ADDRESS): Define.\n\t(HOST_HOOKS_GT_PCH_USE_ADDRESS): Define.\n\t(pch_address_space): New.\n\t(darwin_rs6000_gt_pch_get_address): New.\n\t(darwin_rs6000_gt_pch_use_address): New.\n\nIndex: cp/ChangeLog\n2003-07-29  Geoffrey Keating  <geoffk@apple.com>\n\n\t* parser.c (cp_lexer_new_main): Use c_common_no_more_pch instead\n\tof setting valid_pch by hand.\n\nFrom-SVN: r69944", "tree": {"sha": "a81081c458d46be162c522a5f484e4265c5c1d47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a81081c458d46be162c522a5f484e4265c5c1d47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18c8152070f9939739b297a4f133db1ca2387b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c8152070f9939739b297a4f133db1ca2387b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c8152070f9939739b297a4f133db1ca2387b6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c8152070f9939739b297a4f133db1ca2387b6d/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f9b40094d6e960d965e632f6537bf6eaa980ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9b40094d6e960d965e632f6537bf6eaa980ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9b40094d6e960d965e632f6537bf6eaa980ab5"}], "stats": {"total": 315, "additions": 253, "deletions": 62}, "files": [{"sha": "b4327db660b41665b3371ea7f960d22be3d15cf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -1,3 +1,37 @@\n+2003-07-29  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* c-common.c (allow_pch): Remove.\n+\t* c-common.h (allow_pch): Remove.\n+\t(c_common_no_more_pch): Declare.\n+\t* c-lex.c (c_lex): Call c_common_no_more_pch when appropriate.\n+\t* c-pch.c: Include hosthooks.h.\n+\t(c_common_valid_pch): Don't check allow_pch.\n+\t(c_common_read_pch): Clear valid_pch to prevent reading PCH files.\n+\t(c_common_no_more_pch): New.\n+\t* ggc-common.c: Include hosthooks.h.\n+\t(gt_pch_save): Call gt_pch_get_address.\n+\t(gt_pch_restore): Call gt_pch_use_address.\n+\t* hooks.c (hook_voidp_size_t_null): New.\n+\t(hook_bool_voidp_size_t_false): New.\n+\t* hooks.h (hook_voidp_size_t_null): New.\n+\t(hook_bool_voidp_size_t_false): New.\n+\t* hosthooks-def.h (HOST_HOOKS_GT_PCH_GET_ADDRESS): New.\n+\t(HOST_HOOKS_GT_PCH_USE_ADDRESS): New.\n+\t(HOST_HOOKS_INITIALIZER): Add HOST_HOOKS_GT_PCH_GET_ADDRESS,\n+\tHOST_HOOKS_GT_PCH_USE_ADDRESS.\n+\t* hosthooks.h (struct host_hooks): Add gt_pch_get_address,\n+\tgt_pch_use_address.\n+\t* doc/hostconfig.texi (Host Common): Document\n+\tHOST_HOOKS_GT_PCH_GET_ADDRESS, HOST_HOOKS_GT_PCH_USE_ADDRESS.\n+\t* Makefile.in (c-pch.o): Depend on hosthooks.h.\n+\t(ggc-common.o): Likewise.\n+\n+\t* config/rs6000/host-darwin.c (HOST_HOOKS_GT_PCH_GET_ADDRESS): Define.\n+\t(HOST_HOOKS_GT_PCH_USE_ADDRESS): Define.\n+\t(pch_address_space): New.\n+\t(darwin_rs6000_gt_pch_get_address): New.\n+\t(darwin_rs6000_gt_pch_use_address): New.\n+\n 2003-07-29  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* Makefile.in (LIBCPP_DEPS): Add HASHTAB_H."}, {"sha": "aaf42fcd81685998d3f3a51efef4a16f12e2fde8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -1351,8 +1351,8 @@ c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(C_TREE_H) tree-dump.h\n \n c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \\\n-\t$(C_COMMON_H) output.h toplev.h c-pragma.h $(GGC_H) debug.h langhooks.h \\\n-\tflags.h\n+\t$(C_COMMON_H) output.h toplev.h c-pragma.h $(GGC_H) debug.h \\\n+\tlanghooks.h flags.h hosthooks.h\n \n # Language-independent files.\n \n@@ -1433,7 +1433,7 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h\n \tssa.h cselib.h insn-addr.h\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n-\t$(HASHTAB_H) toplev.h $(PARAMS_H)\n+\t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n \n ggc-simple.o: ggc-simple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n \tflags.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)"}, {"sha": "95494a966c90aa148db6c3bb837f59dea3a25641", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -187,10 +187,6 @@ tree c_global_trees[CTI_MAX];\n    langhook should take care of initialization of this array.  */\n \n bool statement_code_p[MAX_TREE_CODES];\n-\n-/* Nonzero if we can read a PCH file now.  */\n-\n-int allow_pch = 1;\n \f\n /* Switches common to the C front ends.  */\n "}, {"sha": "8e54b49e300622bf9d48cfce9ef1f4b50c4913d0", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -363,10 +363,6 @@ struct c_lang_decl GTY(()) {\n      heuristics regarding optimization.  */\n #define DECL_ESTIMATED_INSNS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n-\n-/* Nonzero if we can read a PCH file now.  */\n-\n-extern int allow_pch;\n \f\n /* Switches common to the C front ends.  */\n \n@@ -1314,6 +1310,7 @@ extern int c_common_valid_pch (cpp_reader *pfile, const char *name, int fd);\n extern void c_common_read_pch (cpp_reader *pfile, const char *name, int fd,\n \t\t\t       const char *orig);\n extern void c_common_write_pch (void);\n+extern void c_common_no_more_pch (void);\n extern void builtin_define_with_value (const char *, const char *, int);\n extern void c_stddef_cpp_builtins (void);\n extern void fe_file_change (const struct line_map *);"}, {"sha": "28f2e8d5c271b88e633fe685aa8910fb7cdf1d03", "filename": "gcc/c-lex.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -320,6 +320,7 @@ c_lex (tree *value)\n {\n   const cpp_token *tok;\n   location_t atloc;\n+  static bool no_more_pch;\n \n  retry:\n   tok = get_nonpadding_token ();\n@@ -421,6 +422,12 @@ c_lex (tree *value)\n       break;\n     }\n \n+  if (! no_more_pch)\n+    {\n+      no_more_pch = true;\n+      c_common_no_more_pch ();\n+    }\n+\n   return tok->type;\n }\n "}, {"sha": "23ab0f8454ada90f9e0824a87cc07c72a9ea482b", "filename": "gcc/c-pch.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-pragma.h\"\n #include \"ggc.h\"\n #include \"langhooks.h\"\n+#include \"hosthooks.h\"\n \n struct c_pch_validity\n {\n@@ -164,9 +165,6 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n   const char *pch_ident;\n   struct c_pch_validity v;\n \n-  if (! allow_pch)\n-    return 2;\n-\n   /* Perform a quick test of whether this is a valid\n      precompiled header for the current language.  */\n \n@@ -244,7 +242,7 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n       return;\n     }\n \n-  allow_pch = 0;\n+  cpp_get_callbacks (parse_in)->valid_pch = NULL;\n \n   if (fread (&h, sizeof (h), 1, f) != 1)\n     {\n@@ -274,3 +272,15 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n \n   fclose (f);\n }\n+\n+/* Indicate that no more PCH files should be read.  */\n+\n+void\n+c_common_no_more_pch (void)\n+{\n+  if (cpp_get_callbacks (parse_in)->valid_pch)\n+    {\n+      cpp_get_callbacks (parse_in)->valid_pch = NULL;\n+      host_hooks.gt_pch_use_address (NULL, 0);\n+    }\n+}"}, {"sha": "7e8055690e42dc5eb50b3fc06cf545fa41b230d4", "filename": "gcc/config/rs6000/host-darwin.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -23,6 +23,7 @@\n #include \"coretypes.h\"\n #include <signal.h>\n #include <sys/ucontext.h>\n+#include <sys/mman.h>\n #include \"hosthooks.h\"\n #include \"hosthooks-def.h\"\n #include \"toplev.h\"\n@@ -135,5 +136,54 @@ darwin_rs6000_extra_signals (void)\n   if (sigaction (SIGSEGV, &sact, 0) < 0) \n     fatal_error (\"While setting up signal handler: %m\");\n }\n+\f\n+static void * darwin_rs6000_gt_pch_get_address (size_t);\n+static bool darwin_rs6000_gt_pch_use_address (void *, size_t);\n+\n+#undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n+#define HOST_HOOKS_GT_PCH_GET_ADDRESS darwin_rs6000_gt_pch_get_address\n+#undef HOST_HOOKS_GT_PCH_USE_ADDRESS\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS darwin_rs6000_gt_pch_use_address\n+\n+\n+/* Yes, this is really supposed to work.  */\n+static char pch_address_space[1024*1024*1024] __attribute__((aligned (4096)));\n+\n+/* Return the address of the PCH address space, if the PCH will fit in it.  */\n+\n+static void *\n+darwin_rs6000_gt_pch_get_address (size_t sz)\n+{\n+  if (sz <= sizeof (pch_address_space))\n+    return pch_address_space;\n+  else\n+    return NULL;\n+}\n+\n+/* Check ADDR and SZ for validity, and deallocate (using munmap) that part of\n+   pch_address_space beyond SZ.  */\n+\n+static bool\n+darwin_rs6000_gt_pch_use_address (void *addr, size_t sz)\n+{\n+  const size_t pagesize = getpagesize();\n+  bool result;\n+\n+  if ((size_t)pch_address_space % pagesize != 0\n+      || sizeof (pch_address_space) % pagesize != 0)\n+    abort ();\n+  \n+  result = (addr == pch_address_space && sz <= sizeof (pch_address_space));\n+  if (! result)\n+    sz = 0;\n+\n+  /* Round the size to a whole page size.  Normally this is a no-op.  */\n+  sz = (sz + pagesize - 1) / pagesize * pagesize;\n+\n+  if (munmap (pch_address_space + sz, sizeof (pch_address_space) - sz) != 0)\n+    fatal_error (\"couldn't unmap pch_address_space: %m\\n\");\n+\n+  return result;\n+}\n \n const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;"}, {"sha": "309c3f4f6cf57291c85dd65fd7be2384619b571c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -1,3 +1,8 @@\n+2003-07-29  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* parser.c (cp_lexer_new_main): Use c_common_no_more_pch instead\n+\tof setting valid_pch by hand.\n+\n 2003-07-29  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* decl.c (finish_enum): Initialize underlying_type."}, {"sha": "64d260d5b27017e810d1cb1027b7bf8ea590aac6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -302,7 +302,7 @@ cp_lexer_new_main (void)\n      which is a GC collection point.  So we have to grab the first\n      token before allocating any memory.  */\n   cp_lexer_get_preprocessor_token (NULL, &first_token);\n-  cpp_get_callbacks (parse_in)->valid_pch = NULL;\n+  c_common_no_more_pch ();\n \n   /* Allocate the memory.  */\n   lexer = ggc_alloc_cleared (sizeof (cp_lexer));"}, {"sha": "5c38313efd21e4cf2420862f33f3d68c67d6ef0f", "filename": "gcc/doc/hostconfig.texi", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fdoc%2Fhostconfig.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fdoc%2Fhostconfig.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fhostconfig.texi?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -42,6 +42,39 @@ This host hook is used to set up handling for extra signals.  The most\n common thing to do in this hook is to detect stack overflow.\n @end deftypefn\n \n+@deftypefn {Host Hook} void * HOST_HOOKS_GT_PCH_GET_ADDRESS (size_t @var{size})\n+This host hook returns the address of some space in which a PCH may be\n+loaded with @samp{HOST_HOOKS_PCH_LOAD_PCH}.  The space will need to\n+have @var{size} bytes.  If insufficient space is available,\n+@samp{NULL} may be returned; the PCH machinery will try to find a\n+suitable address using a heuristic.\n+\n+The memory does not have to be available now.  In fact, usually\n+@samp{HOST_HOOKS_PCH_LOAD_PCH} will already have been called.  The memory\n+need only be available in future invocations of GCC.\n+@end deftypefn\n+\n+@deftypefn {Host Hook} bool HOST_HOOKS_GT_PCH_USE_ADDRESS (size_t @var{size}, void * @var{address})\n+This host hook is called when a PCH file is about to be loaded.  If\n+@var{address} is the address that would have been returned by\n+@samp{HOST_HOOKS_PCH_MEMORY_ADDRESS}, and @var{size} is smaller than\n+the maximum than @samp{HOST_HOOKS_PCH_MEMORY_ADDRESS} would have\n+accepted, return true, otherwise return false.\n+\n+In addition, free any address space reserved that isn't needed to hold\n+@var{size} bytes (whether or not true is returned).  The PCH machinery will\n+use @samp{mmap} with @samp{MAP_FIXED} to load the PCH if @samp{HAVE_MMAP_FILE},\n+or will use @samp{fread} otherwise.\n+\n+If no PCH will be loaded, this hook may be called with @var{size}\n+zero, in which case all reserved address space should be freed.\n+\n+Do not try to handle values of @var{address} that could not have been\n+returned by this executable; just return false.  Such values usually\n+indicate an out-of-date PCH file (built by some other GCC executable),\n+and such a PCH file won't work.\n+@end deftypefn\n+\n @node Filesystem\n @section Host Filesystem\n @cindex configuration file"}, {"sha": "284811878dee05af123f3eaa0aedd325ca9e8997", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 80, "deletions": 45, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -29,6 +29,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"params.h\"\n+#include \"hosthooks.h\"\n \n #ifdef HAVE_SYS_RESOURCE_H\n # include <sys/resource.h>\n@@ -450,19 +451,24 @@ gt_pch_save (FILE *f)\n \n   mmi.size = ggc_pch_total_size (state.d);\n \n-  /* Try to arrange things so that no relocation is necessary,\n-     but don't try very hard.  On most platforms, this will always work,\n-     and on the rest it's a lot of work to do better.  */\n+  /* Try to arrange things so that no relocation is necessary, but\n+     don't try very hard.  On most platforms, this will always work,\n+     and on the rest it's a lot of work to do better.  \n+     (The extra work goes in HOST_HOOKS_GT_PCH_GET_ADDRESS and\n+     HOST_HOOKS_GT_PCH_USE_ADDRESS.)  */\n+  mmi.preferred_base = host_hooks.gt_pch_get_address (mmi.size);\n+      \n #if HAVE_MMAP_FILE\n-  mmi.preferred_base = mmap (NULL, mmi.size,\n-\t\t\t     PROT_READ | PROT_WRITE, MAP_PRIVATE,\n-\t\t\t     fileno (state.f), 0);\n-  if (mmi.preferred_base == (void *) MAP_FAILED)\n-    mmi.preferred_base = NULL;\n-  else\n-    munmap (mmi.preferred_base, mmi.size);\n-#else /* HAVE_MMAP_FILE */\n-  mmi.preferred_base = NULL;\n+  if (mmi.preferred_base == NULL)\n+    {\n+      mmi.preferred_base = mmap (NULL, mmi.size,\n+\t\t\t\t PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t\t\t\t fileno (state.f), 0);\n+      if (mmi.preferred_base == (void *) MAP_FAILED)\n+\tmmi.preferred_base = NULL;\n+      else\n+\tmunmap (mmi.preferred_base, mmi.size);\n+    }\n #endif /* HAVE_MMAP_FILE */\n \n   ggc_pch_this_base (state.d, mmi.preferred_base);\n@@ -539,6 +545,7 @@ gt_pch_restore (FILE *f)\n   size_t i;\n   struct mmap_info mmi;\n   void *addr;\n+  bool needs_read;\n \n   /* Delete any deletable objects.  This makes ggc_pch_read much\n      faster, as it can be sure that no GCable objects remain other\n@@ -571,47 +578,75 @@ gt_pch_restore (FILE *f)\n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n     fatal_error (\"can't read PCH file: %m\");\n \n+  if (host_hooks.gt_pch_use_address (mmi.preferred_base, mmi.size))\n+    {\n #if HAVE_MMAP_FILE\n-  addr = mmap (mmi.preferred_base, mmi.size,\n-\t       PROT_READ | PROT_WRITE, MAP_PRIVATE,\n-\t       fileno (f), mmi.offset);\n+      void *mmap_result;\n \n-#if HAVE_MINCORE\n-  if (addr != mmi.preferred_base)\n-    {\n-      size_t page_size = getpagesize();\n-      char one_byte;\n-\n-      if (addr != (void *) MAP_FAILED)\n-\tmunmap (addr, mmi.size);\n-\n-      /* We really want to be mapped at mmi.preferred_base\n-\t so we're going to resort to MAP_FIXED.  But before,\n-\t make sure that we can do so without destroying a\n-\t previously mapped area, by looping over all pages\n-\t that would be affected by the fixed mapping.  */\n-      errno = 0;\n-\n-      for (i = 0; i < mmi.size; i+= page_size)\n-\tif (mincore ((char *)mmi.preferred_base + i, page_size, (void *)&one_byte) == -1\n-\t    && errno == ENOMEM)\n-\t  continue; /* The page is not mapped.  */\n-\telse\n-\t  break;\n-\n-      if (i >= mmi.size)\n-\taddr = mmap (mmi.preferred_base, mmi.size, \n-\t\t     PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n-\t\t     fileno (f), mmi.offset);\n+      mmap_result = mmap (mmi.preferred_base, mmi.size,\n+\t\t\t  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n+\t\t\t  fileno (f), mmi.offset);\n+\n+      /* The file might not be mmap-able.  */\n+      needs_read = mmap_result == MAP_FAILED;\n+\n+      /* Sanity check for broken MAP_FIXED.  */\n+      if (! needs_read && mmap_result != mmi.preferred_base)\n+\tabort ();\n+#else\n+      needs_read = true;\n+#endif\n+      addr = mmi.preferred_base;\n     }\n+  else\n+    {\n+#if HAVE_MMAP_FILE\n+      addr = mmap (mmi.preferred_base, mmi.size,\n+\t\t   PROT_READ | PROT_WRITE, MAP_PRIVATE,\n+\t\t   fileno (f), mmi.offset);\n+      \n+#if HAVE_MINCORE\n+      if (addr != mmi.preferred_base)\n+\t{\n+\t  size_t page_size = getpagesize();\n+\t  char one_byte;\n+\t  \n+\t  if (addr != (void *) MAP_FAILED)\n+\t    munmap (addr, mmi.size);\n+\t  \n+\t  /* We really want to be mapped at mmi.preferred_base\n+\t     so we're going to resort to MAP_FIXED.  But before,\n+\t     make sure that we can do so without destroying a\n+\t     previously mapped area, by looping over all pages\n+\t     that would be affected by the fixed mapping.  */\n+\t  errno = 0;\n+\t  \n+\t  for (i = 0; i < mmi.size; i+= page_size)\n+\t    if (mincore ((char *)mmi.preferred_base + i, page_size, \n+\t\t\t (void *)&one_byte) == -1\n+\t\t&& errno == ENOMEM)\n+\t      continue; /* The page is not mapped.  */\n+\t    else\n+\t      break;\n+\t  \n+\t  if (i >= mmi.size)\n+\t    addr = mmap (mmi.preferred_base, mmi.size, \n+\t\t\t PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n+\t\t\t fileno (f), mmi.offset);\n+\t}\n #endif /* HAVE_MINCORE */\n+      \n+      needs_read = addr == (void *) MAP_FAILED;\n \n #else /* HAVE_MMAP_FILE */\n-  addr = MAP_FAILED;\n+      needs_read = true;\n #endif /* HAVE_MMAP_FILE */\n-  if (addr == (void *) MAP_FAILED)\n+      if (needs_read)\n+\taddr = xmalloc (mmi.size);\n+    }\n+\n+  if (needs_read)\n     {\n-      addr = xmalloc (mmi.size);\n       if (fseek (f, mmi.offset, SEEK_SET) != 0\n \t  || fread (&mmi, mmi.size, 1, f) != 1)\n \tfatal_error (\"can't read PCH file: %m\");"}, {"sha": "966945d90665a3762c1f8c5913d45b76e270d919", "filename": "gcc/hooks.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -192,3 +192,18 @@ hook_rtx_rtx_null (rtx x ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n+\n+/* Generic hook that takes a size_t and returns NULL.  */\n+void *\n+hook_voidp_size_t_null (size_t a ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n+/* Generic hook that takes a size_t and a pointer and returns false.  */\n+bool\n+hook_bool_voidp_size_t_false (void * a ATTRIBUTE_UNUSED,\n+\t\t\t      size_t b ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}"}, {"sha": "a3465f122d0dedb3d9e8596a2c00833354a6930e", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -55,5 +55,7 @@ bool hook_bool_tree_tree_false (tree, tree);\n \n rtx hook_rtx_rtx_identity (rtx);\n rtx hook_rtx_rtx_null (rtx);\n+void * hook_voidp_size_t_null (size_t);\n+bool hook_bool_voidp_size_t_false (void *, size_t);\n \n #endif"}, {"sha": "b1a41e7298892f75473684003942cd7563be40ab", "filename": "gcc/hosthooks-def.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhosthooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhosthooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks-def.h?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -24,10 +24,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"hooks.h\"\n \n #define HOST_HOOKS_EXTRA_SIGNALS hook_void_void\n+#define HOST_HOOKS_GT_PCH_GET_ADDRESS hook_voidp_size_t_null\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS hook_bool_voidp_size_t_false\n \n /* The structure is defined in hosthooks.h.  */\n #define HOST_HOOKS_INITIALIZER {\t\t\\\n-  HOST_HOOKS_EXTRA_SIGNALS\t\t\t\\\n+  HOST_HOOKS_EXTRA_SIGNALS,\t\t\t\\\n+  HOST_HOOKS_GT_PCH_GET_ADDRESS,\t\t\\\n+  HOST_HOOKS_GT_PCH_USE_ADDRESS\t\t\t\\\n }\n \n #endif /* GCC_HOST_HOOKS_DEF_H */"}, {"sha": "bbc28f69d4db4749ef4921ef10f025ed1582fd47", "filename": "gcc/hosthooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhosthooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c8152070f9939739b297a4f133db1ca2387b6d/gcc%2Fhosthooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks.h?ref=18c8152070f9939739b297a4f133db1ca2387b6d", "patch": "@@ -25,6 +25,9 @@ struct host_hooks\n {\n   void (*extra_signals) (void);\n \n+  void * (*gt_pch_get_address) (size_t);\n+  bool (*gt_pch_use_address) (void *, size_t);\n+\n   /* Whenever you add entries here, make sure you adjust hosthooks-def.h.  */\n };\n "}]}