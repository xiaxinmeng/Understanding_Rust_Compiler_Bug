{"sha": "d3797078d460e46342460aa13e202819404212a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM3OTcwNzhkNDYwZTQ2MzQyNDYwYWExM2UyMDI4MTk0MDQyMTJhMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-18T19:56:02Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-18T19:56:02Z"}, "message": "entered into RCS\n\nFrom-SVN: r782", "tree": {"sha": "2099bac32bbd37bd2d707d230ec81648bc82868c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2099bac32bbd37bd2d707d230ec81648bc82868c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3797078d460e46342460aa13e202819404212a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3797078d460e46342460aa13e202819404212a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3797078d460e46342460aa13e202819404212a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3797078d460e46342460aa13e202819404212a0/comments", "author": null, "committer": null, "parents": [{"sha": "e1fde2b5bcb969337221f881ebde8f9f61fcb0af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fde2b5bcb969337221f881ebde8f9f61fcb0af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1fde2b5bcb969337221f881ebde8f9f61fcb0af"}], "stats": {"total": 300, "additions": 300, "deletions": 0}, "files": [{"sha": "90bd94b8ede16122ec07e8cac253bb2ed582be4e", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3797078d460e46342460aa13e202819404212a0/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3797078d460e46342460aa13e202819404212a0/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=d3797078d460e46342460aa13e202819404212a0", "patch": "@@ -276,3 +276,303 @@ rev_cond_name (op)\n       abort ();\n     }\n }\n+\n+int\n+vax_float_literal(c)\n+    register rtx c;\n+{\n+  register enum machine_mode mode;\n+  int i;\n+  union {double d; int i[2];} val;\n+\n+  if (GET_CODE (c) != CONST_DOUBLE)\n+    return 0;\n+\n+  mode = GET_MODE (c);\n+\n+  if (c == const_tiny_rtx[(int) mode][0]\n+      || c == const_tiny_rtx[(int) mode][1]\n+      || c == const_tiny_rtx[(int) mode][2])\n+    return 1;\n+\n+#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n+\n+  val.i[0] = CONST_DOUBLE_LOW (c);\n+  val.i[1] = CONST_DOUBLE_HIGH (c);\n+\n+  for (i = 0; i < 7; i ++)\n+    if (val.d == 1 << i || val.d == 1 / (1 << i))\n+      return 1;\n+#endif\n+  return 0;\n+}\n+\n+\n+/* Return the cost in cycles of a memory address, relative to register\n+   indirect.\n+\n+   Each of the following adds the indicated number of cycles:\n+\n+   1 - symbolic address\n+   1 - pre-decrement\n+   1 - indexing and/or offset(register)\n+   2 - indirect */\n+\n+\n+int vax_address_cost(addr)\n+    register rtx addr;\n+{\n+  int reg = 0, indexed = 0, indir = 0, offset = 0, predec = 0;\n+  rtx plus_op0 = 0, plus_op1 = 0;\n+ restart:\n+  switch (GET_CODE (addr))\n+    {\n+    case PRE_DEC:\n+      predec = 1;\n+    case REG:\n+    case SUBREG:\n+    case POST_INC:\n+      reg = 1;\n+      break;\n+    case MULT:\n+      indexed = 1;\t/* 2 on VAX 2 */\n+      break;\n+    case CONST_INT:\n+      /* byte offsets cost nothing (on a VAX 2, they cost 1 cycle) */\n+      if (offset == 0)\n+\toffset = (unsigned)(INTVAL(addr)+128) > 256;\n+      break;\n+    case CONST:\n+    case SYMBOL_REF:\n+      offset = 1;\t/* 2 on VAX 2 */\n+      break;\n+    case LABEL_REF:\t/* this is probably a byte offset from the pc */\n+      if (offset == 0)\n+\toffset = 1;\n+      break;\n+    case PLUS:\n+      if (plus_op0)\n+\tplus_op1 = XEXP (addr, 0);\n+      else\n+\tplus_op0 = XEXP (addr, 0);\n+      addr = XEXP (addr, 1);\n+      goto restart;\n+    case MEM:\n+      indir = 2;\t/* 3 on VAX 2 */\n+      addr = XEXP (addr, 0);\n+      goto restart;\n+    }\n+\n+  /* Up to 3 things can be added in an address.  They are stored in\n+     plus_op0, plus_op1, and addr.  */\n+\n+  if (plus_op0)\n+    {\n+      addr = plus_op0;\n+      plus_op0 = 0;\n+      goto restart;\n+    }\n+  if (plus_op1)\n+    {\n+      addr = plus_op1;\n+      plus_op1 = 0;\n+      goto restart;\n+    }\n+  /* Indexing and register+offset can both be used (except on a VAX 2)\n+     without increasing execution time over either one alone. */\n+  if (reg && indexed && offset)\n+    return reg + indir + offset + predec;\n+  return reg + indexed + indir + offset + predec;\n+}\n+\n+\n+/* Cost of an expression on a VAX.  This version has costs tuned for the\n+   CVAX chip (found in the VAX 3 series) with comments for variations on\n+   other models.  */\n+\n+int\n+vax_rtx_cost (x)\n+    register rtx x;\n+{\n+  register enum rtx_code code = GET_CODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n+  register int c;\n+  int i = 0;\t\t\t\t/* may be modified in switch */\n+  char *fmt = GET_RTX_FORMAT (code);\t/* may be modified in switch */\n+\n+  switch (code)\n+    {\n+    case POST_INC:\n+      return 2;\n+    case PRE_DEC:\n+      return 3;\n+    case MULT:\n+      switch (mode)\n+\t{\n+\tcase DFmode:\n+\t  c = 16;\t\t/* 4 on VAX 9000 */\n+\t  break;\n+\tcase SFmode:\n+\t  c = 9;\t\t/* 4 on VAX 9000, 12 on VAX 2 */\n+\t  break;\n+\tcase DImode:\n+\t  c = 16;\t\t/* 6 on VAX 9000, 28 on VAX 2 */\n+\t  break;\n+\tcase SImode:\n+\tcase HImode:\n+\tcase QImode:\n+\t  c = 10;\t\t/* 3-4 on VAX 9000, 20-28 on VAX 2 */\n+\t  break;\n+\t}\n+      break;\n+    case UDIV:\n+      c = 17;\n+      break;\n+    case DIV:\n+      if (mode == DImode)\n+\tc = 30;\t/* highly variable */\n+      else if (mode == DFmode)\n+\t/* divide takes 28 cycles if the result is not zero, 13 otherwise */\n+\tc = 24;\n+      else\n+\tc = 11;\t\t\t/* 25 on VAX 2 */\n+      break;\n+    case MOD:\n+      c = 23;\n+      break;\n+    case UMOD:\n+      c = 29;\n+      break;\n+    case FLOAT:\n+      c = 6 + (mode == DFmode) + (GET_MODE (XEXP (x, 0)) != SImode);\n+      /* 4 on VAX 9000 */\n+      break;\n+    case FIX:\n+      c = 7;\t\t\t/* 17 on VAX 2 */\n+      break;\n+    case LSHIFT:\n+    case ASHIFT:\n+    case LSHIFTRT:\n+    case ASHIFTRT:\n+      if (mode == DImode)\n+\tc = 12;\n+      else\n+\tc = 10;\t\t\t/* 6 on VAX 9000 */\n+      break;\n+    case ROTATE:\n+    case ROTATERT:\n+      c = 6;\t\t\t/* 5 on VAX 2, 4 on VAX 9000 */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\tfmt = \"e\";\t/* all constant rotate counts are short */\n+      break;\n+    case PLUS:\n+      /* Check for small negative integer operand: subl2 can be used with\n+\t a short positive constant instead.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\tif ((unsigned)(INTVAL (XEXP (x, 1)) + 63) < 127)\n+\t  fmt = \"e\";\n+    case MINUS:\n+      c = (mode == DFmode) ? 13 : 8;\t/* 6/8 on VAX 9000, 16/15 on VAX 2 */\n+    case IOR:\n+    case XOR:\n+      c = 3;\n+      break;\n+    case AND:\n+      /* AND is special because the first operand is complemented. */\n+      c = 3;\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  if ((unsigned)~INTVAL (XEXP (x, 0)) > 63)\n+\t    c = 4;\n+\t  fmt = \"e\";\n+\t  i = 1;\n+\t}\n+      break;\n+    case NEG:\n+      if (mode == DFmode)\n+\treturn 9;\n+      else if (mode == SFmode)\n+\treturn 6;\n+      else if (mode == DImode)\n+\treturn 4;\n+    case NOT:\n+      return 2;\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      c = 15;\n+      break;\n+    case MEM:\n+      if (mode == DImode || mode == DFmode)\n+\tc = 5;\t\t\t\t/* 7 on VAX 2 */\n+      else\n+\tc = 3;\t\t\t\t/* 4 on VAX 2 */\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) == REG || GET_CODE (x) == POST_INC)\n+\treturn c;\n+      return c + vax_address_cost (x);\n+    default:\n+      c = 3;\n+      break;\n+    }\n+\n+\n+  /* Now look inside the expression.  Operands which are not registers or\n+     short constants add to the cost.\n+\n+     FMT and I may have been adjusted in the switch above for instructions\n+     which require special handling */\n+\n+  while (*fmt++ == 'e')\n+    {\n+      register rtx op = XEXP (x, i++);\n+      code = GET_CODE (op);\n+\n+      /* A NOT is likely to be found as the first operand of an AND\n+\t (in which case the relevant cost is of the operand inside\n+\t the not) and not likely to be found anywhere else.  */\n+      if (code == NOT)\n+\top = XEXP (op, 0), code = GET_CODE (op);\n+\n+      switch (code)\n+\t{\n+\tcase CONST_INT:\n+\t  if ((unsigned)INTVAL (op) > 63 && GET_MODE (x) != QImode)\n+\t    c += 1;\t\t/* 2 on VAX 2 */\n+\t  break;\n+\tcase CONST:\n+\tcase LABEL_REF:\n+\tcase SYMBOL_REF:\n+\t  c += 1;\t\t/* 2 on VAX 2 */\n+\t  break;\n+\tcase CONST_DOUBLE:\n+\t  if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT)\n+\t    {\n+\t      /* Registers are faster than floating point constants -- even\n+\t\t those constants which can be encoded in a single byte.  */\n+\t      if (vax_float_literal (op))\n+\t\tc++;\n+\t      else\n+\t\tc += (GET_MODE (x) == DFmode) ? 3 : 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (CONST_DOUBLE_HIGH (op) != 0\n+\t\t  || (unsigned)CONST_DOUBLE_LOW (op) > 63)\n+\t\tc += 2;\n+\t    }\n+\t  break;\n+\tcase MEM:\n+\t  c += 1;\t\t/* 2 on VAX 2 */\n+\t  if (GET_CODE (XEXP (op, 0)) != REG)\n+\t    c += vax_address_cost (XEXP (op, 0));\n+\t  break;\n+\tcase REG:\n+\tcase SUBREG:\n+\t  break;\n+\tdefault:\n+\t  c += 1;\n+\t  break;\n+\t}\n+    }\n+  return c;\n+}"}]}