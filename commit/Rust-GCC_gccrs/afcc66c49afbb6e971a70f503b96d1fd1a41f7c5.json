{"sha": "afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZjYzY2YzQ5YWZiYjZlOTcxYTcwZjUwM2I5NmQxZmQxYTQxZjdjNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T19:03:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T19:03:06Z"}, "message": "Makefile.in (target-globals.o): Depend on $(IRA_INT_H).\n\ngcc/\n\t* Makefile.in (target-globals.o): Depend on $(IRA_INT_H).\n\t* ira-int.h (ira_max_nregs, ira_important_class_nums): Delete.\n\t(target_ira_int): New structure.\n\t(default_target_ira_int): Declare.\n\t(this_target_ira_int): Declare as a variable or define as a macro.\n\t(ira_reg_mode_hard_regset, ira_register_move_cost)\n\t(ira_may_move_in_cost, ira_may_move_out_cost, ira_class_subset_p)\n\t(ira_non_ordered_class_hard_regs, ira_class_hard_reg_index)\n\t(prohibited_class_mode_regs, ira_important_classes_num)\n\t(ira_important_classes, ira_reg_class_intersect)\n\t(ira_reg_classes_intersect_p, ira_reg_class_super_classes)\n\t(ira_reg_class_union): Redefine as macros.\n\t* ira.h (target_ira): New structure.\n\t(default_target_ira): Declare.\n\t(this_target_ira): Declare as a variable or define as a macro.\n\t(ira_available_class_regs, ira_hard_regno_cover_class)\n\t(ira_reg_class_cover_size, ira_reg_class_cover, ira_class_translate)\n\t(ira_reg_class_nregs, ira_memory_move_cost, ira_class_hard_regs)\n\t(ira_class_hard_regs_num): Redefine as macros.\n\t* ira.c (default_target_ira, default_target_ira_int): New variables.\n\t(this_target_ira, this_target_ira_int): New conditional variables.\n\t(ira_reg_mode_hard_regset, ira_memory_move_cost)\n\t(ira_register_move_cost, ira_may_move_in_cost, ira_may_move_out_cost)\n\t(ira_class_subset_p): Delete.\n\t(no_unit_alloc_regs): Redefine as a macro.\n\t(ira_class_hard_regs, ira_non_ordered_class_hard_regs)\n\t(ira_class_hard_regs_num, ira_class_hard_reg_index)\n\t(ira_available_class_regs): Delete.\n\t(alloc_reg_class_subclasses): Redefine as a macro.\n\t(ira_reg_class_cover_size, ira_reg_class_cover)\n\t(ira_important_classes_num, ira_important_classes)\n\t(ira_important_class_nums, ira_class_translate): Delete.\n\t(cover_class_order): Document the variable's lifetime.\n\t(reorder_important_classes): Don't set ira_important_class_nums.\n\t(ira_reg_class_intersect, ira_reg_classes_intersect_p)\n\t(ira_reg_class_super_classes, ira_reg_class_union)\n\t(ira_hard_regno_cover_class, ira_reg_class_nregs, ira_max_nregs):\n\tDelete.\n\t(setup_reg_class_nregs): Don't set ira_max_regs.\n\t(prohibited_class_mode_regs): Delete.\n\t* target-globals.h (this_target_ira, this_target_ira_int): Declare.\n\t(target_globals): Add ira and ira_int fields.\n\t(restore_target_globals): Copy the ira field to this_target_ira\n\tand the ira_int field to this_target_ira_int.\n\t* target-globals.c: Include ira-int.h.\n\t(default_target_globals): Initialize the ira and ira_int fields.\n\t(save_target_globals): Likewise.\n\nFrom-SVN: r162102", "tree": {"sha": "9434cb86560bce7c7cc8fe82277a1394b43bf551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9434cb86560bce7c7cc8fe82277a1394b43bf551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4391924a335032f89f99247f2dad59c4b47b7a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4391924a335032f89f99247f2dad59c4b47b7a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4391924a335032f89f99247f2dad59c4b47b7a7a"}], "stats": {"total": 553, "additions": 276, "deletions": 277}, "files": [{"sha": "71ed99b1dce1ecc1a121d7ead3f5c64216b51580", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -1,3 +1,53 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (target-globals.o): Depend on $(IRA_INT_H).\n+\t* ira-int.h (ira_max_nregs, ira_important_class_nums): Delete.\n+\t(target_ira_int): New structure.\n+\t(default_target_ira_int): Declare.\n+\t(this_target_ira_int): Declare as a variable or define as a macro.\n+\t(ira_reg_mode_hard_regset, ira_register_move_cost)\n+\t(ira_may_move_in_cost, ira_may_move_out_cost, ira_class_subset_p)\n+\t(ira_non_ordered_class_hard_regs, ira_class_hard_reg_index)\n+\t(prohibited_class_mode_regs, ira_important_classes_num)\n+\t(ira_important_classes, ira_reg_class_intersect)\n+\t(ira_reg_classes_intersect_p, ira_reg_class_super_classes)\n+\t(ira_reg_class_union): Redefine as macros.\n+\t* ira.h (target_ira): New structure.\n+\t(default_target_ira): Declare.\n+\t(this_target_ira): Declare as a variable or define as a macro.\n+\t(ira_available_class_regs, ira_hard_regno_cover_class)\n+\t(ira_reg_class_cover_size, ira_reg_class_cover, ira_class_translate)\n+\t(ira_reg_class_nregs, ira_memory_move_cost, ira_class_hard_regs)\n+\t(ira_class_hard_regs_num): Redefine as macros.\n+\t* ira.c (default_target_ira, default_target_ira_int): New variables.\n+\t(this_target_ira, this_target_ira_int): New conditional variables.\n+\t(ira_reg_mode_hard_regset, ira_memory_move_cost)\n+\t(ira_register_move_cost, ira_may_move_in_cost, ira_may_move_out_cost)\n+\t(ira_class_subset_p): Delete.\n+\t(no_unit_alloc_regs): Redefine as a macro.\n+\t(ira_class_hard_regs, ira_non_ordered_class_hard_regs)\n+\t(ira_class_hard_regs_num, ira_class_hard_reg_index)\n+\t(ira_available_class_regs): Delete.\n+\t(alloc_reg_class_subclasses): Redefine as a macro.\n+\t(ira_reg_class_cover_size, ira_reg_class_cover)\n+\t(ira_important_classes_num, ira_important_classes)\n+\t(ira_important_class_nums, ira_class_translate): Delete.\n+\t(cover_class_order): Document the variable's lifetime.\n+\t(reorder_important_classes): Don't set ira_important_class_nums.\n+\t(ira_reg_class_intersect, ira_reg_classes_intersect_p)\n+\t(ira_reg_class_super_classes, ira_reg_class_union)\n+\t(ira_hard_regno_cover_class, ira_reg_class_nregs, ira_max_nregs):\n+\tDelete.\n+\t(setup_reg_class_nregs): Don't set ira_max_regs.\n+\t(prohibited_class_mode_regs): Delete.\n+\t* target-globals.h (this_target_ira, this_target_ira_int): Declare.\n+\t(target_globals): Add ira and ira_int fields.\n+\t(restore_target_globals): Copy the ira field to this_target_ira\n+\tand the ira_int field to this_target_ira_int.\n+\t* target-globals.c: Include ira-int.h.\n+\t(default_target_globals): Initialize the ira and ira_int fields.\n+\t(save_target_globals): Likewise.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in (target-globals.o): Depend on $(CFGLOOP_H)."}, {"sha": "e6a172d894356b0e31ed11af3350661b0dfa64d1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -3483,7 +3483,7 @@ lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) $(TOPLEV_H) target-globals.h \\\n    $(FLAGS_H) $(REGS_H) $(RTL_H) reload.h expmed.h $(EXPR_H) $(OPTABS_H) \\\n-   $(LIBFUNCS_H) $(CFGLOOP_H)\n+   $(LIBFUNCS_H) $(CFGLOOP_H) $(IRA_INT_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\"}, {"sha": "8c5377065a6e0a30842e03d3fcf416611cfa0429", "filename": "gcc/ira-int.h", "status": "modified", "additions": 127, "deletions": 88, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -564,9 +564,6 @@ extern int ira_overall_cost;\n extern int ira_reg_cost, ira_mem_cost;\n extern int ira_load_cost, ira_store_cost, ira_shuffle_cost;\n extern int ira_move_loops_num, ira_additional_jumps_num;\n-\n-/* Maximal value of element of array ira_reg_class_nregs.  */\n-extern int ira_max_nregs;\n \f\n /* This page contains a bitset implementation called 'min/max sets' used to\n    record conflicts in IRA.\n@@ -717,98 +714,140 @@ minmax_set_iter_next (minmax_set_iterator *i)\n        minmax_set_iter_cond (&(ITER), &(N));\t\t\t\\\n        minmax_set_iter_next (&(ITER)))\n \f\n-/* ira.c: */\n+struct target_ira_int {\n+  /* Hard registers that can not be used for the register allocator for\n+     all functions of the current compilation unit.  */\n+  HARD_REG_SET x_no_unit_alloc_regs;\n+\n+  /* Map: hard regs X modes -> set of hard registers for storing value\n+     of given mode starting with given hard register.  */\n+  HARD_REG_SET (x_ira_reg_mode_hard_regset\n+\t\t[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES]);\n+\n+  /* Array based on TARGET_REGISTER_MOVE_COST.  Don't use\n+     ira_register_move_cost directly.  Use function of\n+     ira_get_may_move_cost instead.  */\n+  move_table *x_ira_register_move_cost[MAX_MACHINE_MODE];\n+\n+  /* Similar to may_move_in_cost but it is calculated in IRA instead of\n+     regclass.  Another difference we take only available hard registers\n+     into account to figure out that one register class is a subset of\n+     the another one.  Don't use it directly.  Use function of\n+     ira_get_may_move_cost instead.  */\n+  move_table *x_ira_may_move_in_cost[MAX_MACHINE_MODE];\n+\n+  /* Similar to may_move_out_cost but it is calculated in IRA instead of\n+     regclass.  Another difference we take only available hard registers\n+     into account to figure out that one register class is a subset of\n+     the another one.  Don't use it directly.  Use function of\n+     ira_get_may_move_cost instead.  */\n+  move_table *x_ira_may_move_out_cost[MAX_MACHINE_MODE];\n+\n+  /* Register class subset relation: TRUE if the first class is a subset\n+     of the second one considering only hard registers available for the\n+     allocation.  */\n+  int x_ira_class_subset_p[N_REG_CLASSES][N_REG_CLASSES];\n+\n+  /* Array of the number of hard registers of given class which are\n+     available for allocation.  The order is defined by the the hard\n+     register numbers.  */\n+  short x_ira_non_ordered_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n+\n+  /* Index (in ira_class_hard_regs; for given register class and hard\n+     register (in general case a hard register can belong to several\n+     register classes;.  The index is negative for hard registers\n+     unavailable for the allocation.  */\n+  short x_ira_class_hard_reg_index[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n+\n+  /* Array whose values are hard regset of hard registers available for\n+     the allocation of given register class whose HARD_REGNO_MODE_OK\n+     values for given mode are zero.  */\n+  HARD_REG_SET x_prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n+\n+  /* The value is number of elements in the subsequent array.  */\n+  int x_ira_important_classes_num;\n+\n+  /* The array containing non-empty classes (including non-empty cover\n+     classes; which are subclasses of cover classes.  Such classes is\n+     important for calculation of the hard register usage costs.  */\n+  enum reg_class x_ira_important_classes[N_REG_CLASSES];\n+\n+  /* The biggest important class inside of intersection of the two\n+     classes (that is calculated taking only hard registers available\n+     for allocation into account;.  If the both classes contain no hard\n+     registers available for allocation, the value is calculated with\n+     taking all hard-registers including fixed ones into account.  */\n+  enum reg_class x_ira_reg_class_intersect[N_REG_CLASSES][N_REG_CLASSES];\n+\n+  /* True if the two classes (that is calculated taking only hard\n+     registers available for allocation into account; are\n+     intersected.  */\n+  bool x_ira_reg_classes_intersect_p[N_REG_CLASSES][N_REG_CLASSES];\n+\n+  /* Classes with end marker LIM_REG_CLASSES which are intersected with\n+     given class (the first index;.  That includes given class itself.\n+     This is calculated taking only hard registers available for\n+     allocation into account.  */\n+  enum reg_class x_ira_reg_class_super_classes[N_REG_CLASSES][N_REG_CLASSES];\n+\n+  /* The biggest important class inside of union of the two classes\n+     (that is calculated taking only hard registers available for\n+     allocation into account;.  If the both classes contain no hard\n+     registers available for allocation, the value is calculated with\n+     taking all hard-registers including fixed ones into account.  In\n+     other words, the value is the corresponding reg_class_subunion\n+     value.  */\n+  enum reg_class x_ira_reg_class_union[N_REG_CLASSES][N_REG_CLASSES];\n+\n+  /* For each reg class, table listing all the classes contained in it\n+     (excluding the class itself.  Non-allocatable registers are\n+     excluded from the consideration;.  */\n+  enum reg_class x_alloc_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n+};\n+\n+extern struct target_ira_int default_target_ira_int;\n+#if SWITCHABLE_TARGET\n+extern struct target_ira_int *this_target_ira_int;\n+#else\n+#define this_target_ira_int (&default_target_ira_int)\n+#endif\n \n-/* Map: hard regs X modes -> set of hard registers for storing value\n-   of given mode starting with given hard register.  */\n-extern HARD_REG_SET ira_reg_mode_hard_regset\n-                    [FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n-\n-/* Array based on TARGET_REGISTER_MOVE_COST.  Don't use\n-   ira_register_move_cost directly.  Use function of\n-   ira_get_may_move_cost instead.  */\n-extern move_table *ira_register_move_cost[MAX_MACHINE_MODE];\n-\n-/* Similar to may_move_in_cost but it is calculated in IRA instead of\n-   regclass.  Another difference we take only available hard registers\n-   into account to figure out that one register class is a subset of\n-   the another one.  Don't use it directly.  Use function of\n-   ira_get_may_move_cost instead.  */\n-extern move_table *ira_may_move_in_cost[MAX_MACHINE_MODE];\n-\n-/* Similar to may_move_out_cost but it is calculated in IRA instead of\n-   regclass.  Another difference we take only available hard registers\n-   into account to figure out that one register class is a subset of\n-   the another one.  Don't use it directly.  Use function of\n-   ira_get_may_move_cost instead.  */\n-extern move_table *ira_may_move_out_cost[MAX_MACHINE_MODE];\n-\n-/* Register class subset relation: TRUE if the first class is a subset\n-   of the second one considering only hard registers available for the\n-   allocation.  */\n-extern int ira_class_subset_p[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* Array of the number of hard registers of given class which are\n-   available for allocation.  The order is defined by the the hard\n-   register numbers.  */\n-extern short ira_non_ordered_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n-\n-/* Index (in ira_class_hard_regs) for given register class and hard\n-   register (in general case a hard register can belong to several\n-   register classes).  The index is negative for hard registers\n-   unavailable for the allocation. */\n-extern short ira_class_hard_reg_index[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n-\n-/* Array whose values are hard regset of hard registers available for\n-   the allocation of given register class whose HARD_REGNO_MODE_OK\n-   values for given mode are zero.  */\n-extern HARD_REG_SET prohibited_class_mode_regs\n-                    [N_REG_CLASSES][NUM_MACHINE_MODES];\n+#define ira_reg_mode_hard_regset \\\n+  (this_target_ira_int->x_ira_reg_mode_hard_regset)\n+#define ira_register_move_cost \\\n+  (this_target_ira_int->x_ira_register_move_cost)\n+#define ira_may_move_in_cost \\\n+  (this_target_ira_int->x_ira_may_move_in_cost)\n+#define ira_may_move_out_cost \\\n+  (this_target_ira_int->x_ira_may_move_out_cost)\n+#define ira_class_subset_p \\\n+  (this_target_ira_int->x_ira_class_subset_p)\n+#define ira_non_ordered_class_hard_regs \\\n+  (this_target_ira_int->x_ira_non_ordered_class_hard_regs)\n+#define ira_class_hard_reg_index \\\n+  (this_target_ira_int->x_ira_class_hard_reg_index)\n+#define prohibited_class_mode_regs \\\n+  (this_target_ira_int->x_prohibited_class_mode_regs)\n+#define ira_important_classes_num \\\n+  (this_target_ira_int->x_ira_important_classes_num)\n+#define ira_important_classes \\\n+  (this_target_ira_int->x_ira_important_classes)\n+#define ira_reg_class_intersect \\\n+  (this_target_ira_int->x_ira_reg_class_intersect)\n+#define ira_reg_classes_intersect_p \\\n+  (this_target_ira_int->x_ira_reg_classes_intersect_p)\n+#define ira_reg_class_super_classes \\\n+  (this_target_ira_int->x_ira_reg_class_super_classes)\n+#define ira_reg_class_union \\\n+  (this_target_ira_int->x_ira_reg_class_union)\n+\f\n+/* ira.c: */\n \n /* Array whose values are hard regset of hard registers for which\n    move of the hard register in given mode into itself is\n    prohibited.  */\n extern HARD_REG_SET ira_prohibited_mode_move_regs[NUM_MACHINE_MODES];\n \n-/* The value is number of elements in the subsequent array.  */\n-extern int ira_important_classes_num;\n-\n-/* The array containing non-empty classes (including non-empty cover\n-   classes) which are subclasses of cover classes.  Such classes is\n-   important for calculation of the hard register usage costs.  */\n-extern enum reg_class ira_important_classes[N_REG_CLASSES];\n-\n-/* The array containing indexes of important classes in the previous\n-   array.  The array elements are defined only for important\n-   classes.  */\n-extern int ira_important_class_nums[N_REG_CLASSES];\n-\n-/* The biggest important class inside of intersection of the two\n-   classes (that is calculated taking only hard registers available\n-   for allocation into account).  If the both classes contain no hard\n-   registers available for allocation, the value is calculated with\n-   taking all hard-registers including fixed ones into account.  */\n-extern enum reg_class ira_reg_class_intersect[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* True if the two classes (that is calculated taking only hard\n-   registers available for allocation into account) are\n-   intersected.  */\n-extern bool ira_reg_classes_intersect_p[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* Classes with end marker LIM_REG_CLASSES which are intersected with\n-   given class (the first index).  That includes given class itself.\n-   This is calculated taking only hard registers available for\n-   allocation into account.  */\n-extern enum reg_class ira_reg_class_super_classes[N_REG_CLASSES][N_REG_CLASSES];\n-/* The biggest important class inside of union of the two classes\n-   (that is calculated taking only hard registers available for\n-   allocation into account).  If the both classes contain no hard\n-   registers available for allocation, the value is calculated with\n-   taking all hard-registers including fixed ones into account.  In\n-   other words, the value is the corresponding reg_class_subunion\n-   value.  */\n-extern enum reg_class ira_reg_class_union[N_REG_CLASSES][N_REG_CLASSES];\n-\n extern void *ira_allocate (size_t);\n extern void *ira_reallocate (void *, size_t);\n extern void ira_free (void *addr);"}, {"sha": "59744d3d19b0f546f5ab640f8d4fd6b9d9c6e584", "filename": "gcc/ira.c", "status": "modified", "additions": 17, "deletions": 146, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -325,6 +325,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira-int.h\"\n \n \n+struct target_ira default_target_ira;\n+struct target_ira_int default_target_ira_int;\n+#if SWITCHABLE_TARGET\n+struct target_ira *this_target_ira = &default_target_ira;\n+struct target_ira_int *this_target_ira_int = &default_target_ira_int;\n+#endif\n+\n /* A modified value of flag `-fira-verbose' used internally.  */\n int internal_flag_ira_verbose;\n \n@@ -351,33 +358,6 @@ int ira_move_loops_num, ira_additional_jumps_num;\n \n HARD_REG_SET eliminable_regset;\n \n-/* Map: hard regs X modes -> set of hard registers for storing value\n-   of given mode starting with given hard register.  */\n-HARD_REG_SET ira_reg_mode_hard_regset[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n-\n-/* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n-short int ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n-\n-/* Array based on TARGET_REGISTER_MOVE_COST.  */\n-move_table *ira_register_move_cost[MAX_MACHINE_MODE];\n-\n-/* Similar to may_move_in_cost but it is calculated in IRA instead of\n-   regclass.  Another difference is that we take only available hard\n-   registers into account to figure out that one register class is a\n-   subset of the another one.  */\n-move_table *ira_may_move_in_cost[MAX_MACHINE_MODE];\n-\n-/* Similar to may_move_out_cost but it is calculated in IRA instead of\n-   regclass.  Another difference is that we take only available hard\n-   registers into account to figure out that one register class is a\n-   subset of the another one.  */\n-move_table *ira_may_move_out_cost[MAX_MACHINE_MODE];\n-\n-/* Register class subset relation: TRUE if the first class is a subset\n-   of the second one considering only hard registers available for the\n-   allocation.  */\n-int ira_class_subset_p[N_REG_CLASSES][N_REG_CLASSES];\n-\n /* Temporary hard reg set used for a different calculation.  */\n static HARD_REG_SET temp_hard_regset;\n \n@@ -401,30 +381,8 @@ setup_reg_mode_hard_regset (void)\n }\n \n \f\n-\n-/* Hard registers that can not be used for the register allocator for\n-   all functions of the current compilation unit.  */\n-static HARD_REG_SET no_unit_alloc_regs;\n-\n-/* Array of the number of hard registers of given class which are\n-   available for allocation.  The order is defined by the\n-   allocation order.  */\n-short ira_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n-\n-/* Array of the number of hard registers of given class which are\n-   available for allocation.  The order is defined by the\n-   the hard register numbers.  */\n-short ira_non_ordered_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n-\n-/* The number of elements of the above array for given register\n-   class.  */\n-int ira_class_hard_regs_num[N_REG_CLASSES];\n-\n-/* Index (in ira_class_hard_regs) for given register class and hard\n-   register (in general case a hard register can belong to several\n-   register classes).  The index is negative for hard registers\n-   unavailable for the allocation. */\n-short ira_class_hard_reg_index[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n+#define no_unit_alloc_regs \\\n+  (this_target_ira_int->x_no_unit_alloc_regs)\n \n /* The function sets up the three arrays declared above.  */\n static void\n@@ -470,10 +428,6 @@ setup_class_hard_regs (void)\n     }\n }\n \n-/* Number of given class hard registers available for the register\n-   allocation for given classes.  */\n-int ira_available_class_regs[N_REG_CLASSES];\n-\n /* Set up IRA_AVAILABLE_CLASS_REGS.  */\n static void\n setup_available_class_regs (void)\n@@ -666,11 +620,8 @@ ira_debug_disposition (void)\n }\n \n \f\n-\n-/* For each reg class, table listing all the classes contained in it\n-   (excluding the class itself.  Non-allocatable registers are\n-   excluded from the consideration).  */\n-static enum reg_class alloc_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n+#define alloc_reg_class_subclasses \\\n+  (this_target_ira_int->x_alloc_reg_class_subclasses)\n \n /* Initialize the table of subclasses of each reg class.  */\n static void\n@@ -711,29 +662,6 @@ setup_reg_subclasses (void)\n \n \f\n \n-/* Number of cover classes.  Cover classes is non-intersected register\n-   classes containing all hard-registers available for the\n-   allocation.  */\n-int ira_reg_class_cover_size;\n-\n-/* The array containing cover classes (see also comments for macro\n-   IRA_COVER_CLASSES).  Only first IRA_REG_CLASS_COVER_SIZE elements are\n-   used for this.  */\n-enum reg_class ira_reg_class_cover[N_REG_CLASSES];\n-\n-/* The number of elements in the subsequent array.  */\n-int ira_important_classes_num;\n-\n-/* The array containing non-empty classes (including non-empty cover\n-   classes) which are subclasses of cover classes.  Such classes is\n-   important for calculation of the hard register usage costs.  */\n-enum reg_class ira_important_classes[N_REG_CLASSES];\n-\n-/* The array containing indexes of important classes in the previous\n-   array.  The array elements are defined only for important\n-   classes.  */\n-int ira_important_class_nums[N_REG_CLASSES];\n-\n /* Set the four global variables defined above.  */\n static void\n setup_cover_and_important_classes (void)\n@@ -838,11 +766,6 @@ setup_cover_and_important_classes (void)\n       = ira_reg_class_cover[j];\n }\n \n-/* Map of all register classes to corresponding cover class containing\n-   the given class.  If given class is not a subset of a cover class,\n-   we translate it into the cheapest cover class.  */\n-enum reg_class ira_class_translate[N_REG_CLASSES];\n-\n /* Set up array IRA_CLASS_TRANSLATE.  */\n static void\n setup_class_translate (void)\n@@ -931,7 +854,8 @@ setup_class_translate (void)\n }\n \n /* Order numbers of cover classes in original target cover class\n-   array, -1 for non-cover classes.  */\n+   array, -1 for non-cover classes.  This is only live during\n+   reorder_important_classes.  */\n static int cover_class_order[N_REG_CLASSES];\n \n /* The function used to sort the important classes.  */\n@@ -951,7 +875,7 @@ comp_reg_classes_func (const void *v1p, const void *v2p)\n }\n \n /* Reorder important classes according to the order of their cover\n-   classes.  Set up array ira_important_class_nums too.  */\n+   classes.  */\n static void\n reorder_important_classes (void)\n {\n@@ -963,37 +887,7 @@ reorder_important_classes (void)\n     cover_class_order[ira_reg_class_cover[i]] = i;\n   qsort (ira_important_classes, ira_important_classes_num,\n \t sizeof (enum reg_class), comp_reg_classes_func);\n-  for (i = 0; i < ira_important_classes_num; i++)\n-    ira_important_class_nums[ira_important_classes[i]] = i;\n-}\n-\n-/* The biggest important reg_class inside of intersection of the two\n-   reg_classes (that is calculated taking only hard registers\n-   available for allocation into account).  If the both reg_classes\n-   contain no hard registers available for allocation, the value is\n-   calculated by taking all hard-registers including fixed ones into\n-   account.  */\n-enum reg_class ira_reg_class_intersect[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* True if the two classes (that is calculated taking only hard\n-   registers available for allocation into account) are\n-   intersected.  */\n-bool ira_reg_classes_intersect_p[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* Important classes with end marker LIM_REG_CLASSES which are\n-   supersets with given important class (the first index).  That\n-   includes given class itself.  This is calculated taking only hard\n-   registers available for allocation into account.  */\n-enum reg_class ira_reg_class_super_classes[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* The biggest important reg_class inside of union of the two\n-   reg_classes (that is calculated taking only hard registers\n-   available for allocation into account).  If the both reg_classes\n-   contain no hard registers available for allocation, the value is\n-   calculated by taking all hard-registers including fixed ones into\n-   account.  In other words, the value is the corresponding\n-   reg_class_subunion value.  */\n-enum reg_class ira_reg_class_union[N_REG_CLASSES][N_REG_CLASSES];\n+}\n \n /* Set up the above reg class relations.  */\n static void\n@@ -1137,11 +1031,6 @@ find_reg_class_closure (void)\n \n \f\n \n-/* Map: hard register number -> cover class it belongs to.  If the\n-   corresponding class is NO_REGS, the hard register is not available\n-   for allocation.  */\n-enum reg_class ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n-\n /* Set up the array above.  */\n static void\n setup_hard_regno_cover_class (void)\n@@ -1167,38 +1056,20 @@ setup_hard_regno_cover_class (void)\n \n \f\n \n-/* Map: register class x machine mode -> number of hard registers of\n-   given class needed to store value of given mode.  If the number is\n-   different, the size will be negative.  */\n-int ira_reg_class_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n-\n-/* Maximal value of the previous array elements.  */\n-int ira_max_nregs;\n-\n /* Form IRA_REG_CLASS_NREGS map.  */\n static void\n setup_reg_class_nregs (void)\n {\n   int cl, m;\n \n-  ira_max_nregs = -1;\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     for (m = 0; m < MAX_MACHINE_MODE; m++)\n-      {\n-\tira_reg_class_nregs[cl][m] = CLASS_MAX_NREGS ((enum reg_class) cl,\n-\t\t\t\t\t\t      (enum machine_mode) m);\n-\tif (ira_max_nregs < ira_reg_class_nregs[cl][m])\n-\t  ira_max_nregs = ira_reg_class_nregs[cl][m];\n-      }\n+      ira_reg_class_nregs[cl][m] = CLASS_MAX_NREGS ((enum reg_class) cl,\n+\t\t\t\t\t\t    (enum machine_mode) m);\n }\n \n \f\n \n-/* Array whose values are hard regset of hard registers available for\n-   the allocation of given register class whose HARD_REGNO_MODE_OK\n-   values for given mode are zero.  */\n-HARD_REG_SET prohibited_class_mode_regs[N_REG_CLASSES][NUM_MACHINE_MODES];\n-\n /* Set up PROHIBITED_CLASS_MODE_REGS.  */\n static void\n setup_prohibited_class_mode_regs (void)"}, {"sha": "46ea89e4bae1f301f261a0c81a7a8f89167b7abc", "filename": "gcc/ira.h", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -20,36 +20,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Number of given class hard registers available for the register\n-   allocation for given classes.  */\n-extern int ira_available_class_regs[N_REG_CLASSES];\n-\n-/* Map: hard register number -> cover class it belongs to.  If the\n-   corresponding class is NO_REGS, the hard register is not available\n-   for allocation.  */\n-extern enum reg_class ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n-\n-/* Number of cover classes.  Cover classes is non-intersected register\n-   classes containing all hard-registers available for the\n-   allocation.  */\n-extern int ira_reg_class_cover_size;\n-\n-/* The array containing cover classes (see also comments for macro\n-   IRA_COVER_CLASSES).  Only first IRA_REG_CLASS_COVER_SIZE elements are\n-   used for this.  */\n-extern enum reg_class ira_reg_class_cover[N_REG_CLASSES];\n-\n-/* Map of all register classes to corresponding cover class containing\n-   the given class.  If given class is not a subset of a cover class,\n-   we translate it into the cheapest cover class.  */\n-extern enum reg_class ira_class_translate[N_REG_CLASSES];\n-\n-/* Map: register class x machine mode -> number of hard registers of\n-   given class needed to store value of given mode.  If the number for\n-   some hard-registers of the register class is different, the size\n-   will be negative.  */\n-extern int ira_reg_class_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n-\n /* Function specific hard registers can not be used for the register\n    allocation.  */\n extern HARD_REG_SET ira_no_alloc_regs;\n@@ -58,17 +28,75 @@ extern HARD_REG_SET ira_no_alloc_regs;\n    mode or when the conflict table is too big.  */\n extern bool ira_conflicts_p;\n \n-/* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n-extern short ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n-\n-/* Array of number of hard registers of given class which are\n-   available for the allocation.  The order is defined by the\n-   allocation order.  */\n-extern short ira_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n-\n-/* The number of elements of the above array for given register\n-   class.  */\n-extern int ira_class_hard_regs_num[N_REG_CLASSES];\n+struct target_ira {\n+  /* Number of given class hard registers available for the register\n+     allocation for given classes.  */\n+  int x_ira_available_class_regs[N_REG_CLASSES];\n+\n+  /* Map: hard register number -> cover class it belongs to.  If the\n+     corresponding class is NO_REGS, the hard register is not available\n+     for allocation.  */\n+  enum reg_class x_ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n+\n+  /* Number of cover classes.  Cover classes is non-intersected register\n+     classes containing all hard-registers available for the\n+     allocation.  */\n+  int x_ira_reg_class_cover_size;\n+\n+  /* The array containing cover classes (see also comments for macro\n+     IRA_COVER_CLASSES;.  Only first IRA_REG_CLASS_COVER_SIZE elements are\n+     used for this.  */\n+  enum reg_class x_ira_reg_class_cover[N_REG_CLASSES];\n+\n+  /* Map of all register classes to corresponding cover class containing\n+     the given class.  If given class is not a subset of a cover class,\n+     we translate it into the cheapest cover class.  */\n+  enum reg_class x_ira_class_translate[N_REG_CLASSES];\n+\n+  /* Map: register class x machine mode -> number of hard registers of\n+     given class needed to store value of given mode.  If the number for\n+     some hard-registers of the register class is different, the size\n+     will be negative.  */\n+  int x_ira_reg_class_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n+\n+  /* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n+  short x_ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n+\n+  /* Array of number of hard registers of given class which are\n+     available for the allocation.  The order is defined by the\n+     allocation order.  */\n+  short x_ira_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n+\n+  /* The number of elements of the above array for given register\n+     class.  */\n+  int x_ira_class_hard_regs_num[N_REG_CLASSES];\n+};\n+\n+extern struct target_ira default_target_ira;\n+#if SWITCHABLE_TARGET\n+extern struct target_ira *this_target_ira;\n+#else\n+#define this_target_ira (&default_target_ira)\n+#endif\n+\n+#define ira_available_class_regs \\\n+  (this_target_ira->x_ira_available_class_regs)\n+#define ira_hard_regno_cover_class \\\n+  (this_target_ira->x_ira_hard_regno_cover_class)\n+#define ira_reg_class_cover_size \\\n+  (this_target_ira->x_ira_reg_class_cover_size)\n+#define ira_reg_class_cover \\\n+  (this_target_ira->x_ira_reg_class_cover)\n+#define ira_class_translate \\\n+  (this_target_ira->x_ira_class_translate)\n+#define ira_reg_class_nregs \\\n+  (this_target_ira->x_ira_reg_class_nregs)\n+#define ira_memory_move_cost \\\n+  (this_target_ira->x_ira_memory_move_cost)\n+#define ira_class_hard_regs \\\n+  (this_target_ira->x_ira_class_hard_regs)\n+#define ira_class_hard_regs_num \\\n+  (this_target_ira->x_ira_class_hard_regs_num)\n \n extern void ira_init_once (void);\n extern void ira_init (void);"}, {"sha": "9d3d6666fff749a6e106c515ffba9b285ae5515f", "filename": "gcc/target-globals.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"libfuncs.h\"\n #include \"cfgloop.h\"\n+#include \"ira-int.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n@@ -47,7 +48,9 @@ struct target_globals default_target_globals = {\n   &default_target_expmed,\n   &default_target_optabs,\n   &default_target_libfuncs,\n-  &default_target_cfgloop\n+  &default_target_cfgloop,\n+  &default_target_ira,\n+  &default_target_ira_int\n };\n \n struct target_globals *\n@@ -65,6 +68,8 @@ save_target_globals (void)\n   g->optabs = XCNEW (struct target_optabs);\n   g->libfuncs = ggc_alloc_cleared_target_libfuncs ();\n   g->cfgloop = XCNEW (struct target_cfgloop);\n+  g->ira = XCNEW (struct target_ira);\n+  g->ira_int = XCNEW (struct target_ira_int);\n   restore_target_globals (g);\n   target_reinit ();\n   return g;"}, {"sha": "b1458cc42a08b0bcbf98a995dcf170df2605b106", "filename": "gcc/target-globals.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afcc66c49afbb6e971a70f503b96d1fd1a41f7c5/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=afcc66c49afbb6e971a70f503b96d1fd1a41f7c5", "patch": "@@ -30,6 +30,8 @@ extern struct target_expmed *this_target_expmed;\n extern struct target_optabs *this_target_optabs;\n extern struct target_libfuncs *this_target_libfuncs;\n extern struct target_cfgloop *this_target_cfgloop;\n+extern struct target_ira *this_target_ira;\n+extern struct target_ira_int *this_target_ira_int;\n \n struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n@@ -41,6 +43,8 @@ struct GTY(()) target_globals {\n   struct target_optabs *GTY((skip)) optabs;\n   struct target_libfuncs *libfuncs;\n   struct target_cfgloop *GTY((skip)) cfgloop;\n+  struct target_ira *GTY((skip)) ira;\n+  struct target_ira_int *GTY((skip)) ira_int;\n };\n \n extern struct target_globals default_target_globals;\n@@ -59,6 +63,8 @@ restore_target_globals (struct target_globals *g)\n   this_target_optabs = g->optabs;\n   this_target_libfuncs = g->libfuncs;\n   this_target_cfgloop = g->cfgloop;\n+  this_target_ira = g->ira;\n+  this_target_ira_int = g->ira_int;\n }\n #endif\n "}]}