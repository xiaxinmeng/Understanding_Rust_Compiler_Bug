{"sha": "35b1567d9e376f670019b87ca5423052b6bbde07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViMTU2N2Q5ZTM3NmY2NzAwMTliODdjYTU0MjMwNTJiNmJiZGUwNw==", "commit": {"author": {"name": "Ben Chelf", "email": "chelf@gcc.gnu.org", "date": "2000-06-19T18:40:24Z"}, "committer": {"name": "Ben Chelf", "email": "chelf@gcc.gnu.org", "date": "2000-06-19T18:40:24Z"}, "message": "c-common.h (IF_COND): Added documentation.\n\n\t* c-common.h (IF_COND): Added documentation.\n\t(THEN_CLAUSE): Likewise.\n\t(ELSE_CLAUSE): Likewise.\n\t(WHILE_COND): Likewise.\n\t(WHILE_BODY): Likewise.\n\t(DO_COND): Likewise.\n\t(DO_BODY): Likewise.\n\t(RETURN_EXPR): Likewise.\n\t(EXPR_STMT_EXPR): Likewise.\n\t(FOR_INIT_STMT): Likewise.\n\t(FOR_COND): Likewise.\n\t(FOR_EXPR): Likewise.\n\t(FOR_BODY): Likewise.\n\t(SWITCH_COND): Likewise.\n\t(SWITCH_BODY): Likewise.\n\t(CASE_LOW): Likewise.\n\t(CASE_HIGH): Likewise.\n\t(GOTO_DESTINATION): Likewise.\n\t(COMPOUND_BODY): Likewise.\n\t(ASM_CV_QUAL): Likewise.\n\t(ASM_STRING): Likewise.\n\t(ASM_OUTPUTS): Likewise.\n\t(ASM_INPUTS): Likewise.\n\t(ASM_CLOBBERS): Likewise.\n\t(DECL_STMT_DECL): Likewise.\n\t(STMT_EXPR_STMT): Likewise.\n\t(LABEL_STMT_LABEL): Likewise.\n\n\t* c-common.def: Added documenetion for SRCLOC, EXPR_STMT,\n\tCOMPOUND_STMT, DECL_STMT, IF_STMT, FOR_STMT, WHILE_STMT, DO_STMT,\n\tRETURN_STMT, BREAK_STMT, CONTINUE_STMT, SWITCH_STMT, GOTO_STMT,\n\tLABEL_STMT, ASM_STMT, SCOPE_STMT, CASE_LABEL, STMT_EXPR.\n\n\t* cp/cp-tree.h (genrtl_try_block): Declare function.\n\t(genrtl_handler): Likewise.\n\t(genrtl_catch_block): Likewise.\n\t(genrtl_ctor_stmt): Likewise.\n\t(genrtl_subobject): Likewise.\n\t(genrtl_decl_cleanup): Likewise.\n\t(genrtl_do_poplevel): Likewise.\n\t(genrtl_do_pushlevel): Likewise.\n\t(genrtl_clear_out_block): Likewise.\n\t(genrtl_goto_stmt): Likewise.\n\t(genrtl_expr_stmt): Likewise.\n\t(genrtl_decl_stmt): Likewise.\n\t(genrtl_if_stmt): Likewise.\n\t(genrtl_while_stmt): Likewise.\n\t(genrtl_do_stmt): Likewise.\n\t(genrtl_return_stmt): Likewise.\n\t(genrtl_for_stmt): Likewise.\n\t(genrtl_break_stmt): Likewise.\n\t(genrtl_continue_stmt): Likewise.\n\t(genrtl_scope_stmt): Likewise.\n\t(genrtl_switch_stmt): Likewise.\n\t(genrtl_case_label): Likewise.\n\t(genrtl_begin_compound_stmt): Likewise.\n\t(genrtl_finish_compound_stmt): Likewise.\n\t(genrtl_compound_stmt): Likewise.\n\t(genrtl_asm_stmt): Likewise.\n\t(genrtl_named_return_value): Likewise.\n\t(genrtl_begin_stmt_expr): Likewise.\n\t(genrtl_finish_stmt_expr): Likewise.\n\t(finish_for_stmt): Removed first argument.\n\t(finish_switch_stmt): Likewise.\n\n\t* cp/semantics.c (genrtl_try_block): Define function.\n\t(genrtl_handler): Likewise.\n\t(genrtl_catch_block): Likewise.\n\t(genrtl_ctor_stmt): Likewise.\n\t(genrtl_subobject): Likewise.\n\t(genrtl_decl_cleanup): Likewise.\n\t(genrtl_do_poplevel): Likewise.\n\t(genrtl_do_pushlevel): Likewise.\n\t(genrtl_clear_out_block): Likewise.\n\t(genrtl_goto_stmt): Likewise.\n\t(genrtl_expr_stmt): Likewise.\n\t(genrtl_decl_stmt): Likewise.\n\t(genrtl_if_stmt): Likewise.\n\t(genrtl_while_stmt): Likewise.\n\t(genrtl_do_stmt): Likewise.\n\t(genrtl_return_stmt): Likewise.\n\t(genrtl_for_stmt): Likewise.\n\t(genrtl_break_stmt): Likewise.\n\t(genrtl_continue_stmt): Likewise.\n\t(genrtl_scope_stmt): Likewise.\n\t(genrtl_switch_stmt): Likewise.\n\t(genrtl_case_label): Likewise.\n\t(genrtl_begin_compound_stmt): Likewise.\n\t(genrtl_finish_compound_stmt): Likewise.\n\t(genrtl_compound_stmt): Likewise.\n\t(genrtl_asm_stmt): Likewise.\n\t(genrtl_named_return_value): Likewise.\n\t(genrtl_begin_stmt_expr): Likewise.\n\t(genrtl_finish_stmt_expr): Likewise.\n\t(finish_for_stmt): Removed first argument and generate rtl\n\tspecific code.\n\t(finish_switch_stmt): Likewise.\n\t(do_poplevel): Removed generate rtl specific code.\n\t(do_pushlevel): Likewise.\n\t(add_tree): Likewise.\n\t(finish_goto_stmt): Likewise.\n\t(finish_expr_stmt): Likewise.\n\t(begin_if_stmt): Likewise.\n\t(finish_if_stmt_cond): Likewise.\n\t(finish_then_clause): Likewise.\n\t(begin_else_clause): Likewise.\n\t(finish_else_clause): Likewise.\n\t(finish_if_stmt): Likewise.\n\t(clear_out_block): Likewise.\n\t(begin_while_stmt): Likewise.\n\t(finish_while_stmt_cond): Likewise.\n\t(finish_while_stmt): Likewise.\n\t(begin_do_stmt): Likewise.\n\t(finish_do_body): Likewise.\n\t(finish_do_stmt): Likewise.\n\t(finish_return_stmt): Likewise.\n\t(begin_for_stmt): Likewise.\n\t(finish_for_init_stmt): Likewise.\n\t(finish_for_cond): Likewise.\n\t(finish_for_expr): Likewise.\n\t(finish_break_stmt): Likewise.\n\t(finish_continue_stmt): Likewise.\n\t(begin_switch_stmt): Likewise.\n\t(finish_switch_cond): Likewise.\n\t(finish_case_label): Likewise.\n\t(begin_try_block): Likewise.\n\t(begin_function_try_block): Likewise.\n\t(finish_try_block): Likewise.\n\t(finish_cleanup_try_block): Likewise.\n\t(finish_cleanup): Likewise.\n\t(finish_function_try_block): Likewise.\n\t(finish_handler_sequence): Likewise.\n\t(finish_function_handler_sequence): Likewise.\n\t(begin_handler): Likewise.\n\t(finish_handler_parms): Likewise.\n\t(begin_catch_block): Likewise.\n\t(finish_handler): Likewise.\n\t(begin_compound_stmt): Likewise.\n\t(finish_compound_stmt): Likewise.\n\t(finish_asm_stmt): Likewise.\n\t(finish_label_stmt): Likewise.\n\t(finish_label_decl): Likewise.\n\t(finish_subobject): Likewise.\n\t(finish_decl_cleanup): Likewise.\n\t(finish_named_return_value): Likewise.\n\t(begin_stmt_expr): Likewise.\n\t(finish_stmt_expr): Likewise.\n\n\t* cp/decl.c (initialize_local_var): Changed call to finish_expr_stmt\n\tto call genrtl_expr_stmt when appropriate.\n\n\t* cp/init.c (begin_init_stmts): Changed calls to begin_stmt_expr and\n\tbegin_compound_expr to call genrtl_begin_stmt_expr and\n\tgenrtl_begin_compound_expr when appropriate.\n\t(finish_init_stmts): Changed calls to finish_compound_expr and\n\tfinish_stmt_expr to call genrtl_finish_compound_expr and\n\tgenrtl_finish_stmt_expr when appropriate.\n\t(expand_default_init): Changed call to finish_expr_stmt to call\n\tgenrtl_expr_stmt when appropriate.\n\t(build_vec_init): Likewise.\n\n\t* cp/parse.y (simple_stmt): Removed first argument from call to\n\tfinish_for_stmt. Removed first argument from call to\n\tfinish_switch_stmt.\n\n\t* cp/parse.c: Regenerated.\n\n\t* cp/pt.c (tsubst_expr): Removed first argument from call to\n\tfinish_for_stmt. Removed first argument from call to\n\tfinish_switch_stmt.\n\nFrom-SVN: r34597", "tree": {"sha": "d9713f688255fa9a4493b822900ecc5416c1762d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9713f688255fa9a4493b822900ecc5416c1762d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b1567d9e376f670019b87ca5423052b6bbde07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b1567d9e376f670019b87ca5423052b6bbde07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b1567d9e376f670019b87ca5423052b6bbde07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b1567d9e376f670019b87ca5423052b6bbde07/comments", "author": null, "committer": null, "parents": [{"sha": "59f406b7a3535d8479bf8db5bb052e3a20541672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f406b7a3535d8479bf8db5bb052e3a20541672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f406b7a3535d8479bf8db5bb052e3a20541672"}], "stats": {"total": 1961, "additions": 1234, "deletions": 727}, "files": [{"sha": "799c07614fd453ce10584d5a507f3700e0598f5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -1,3 +1,38 @@\n+2000-06-19  Benjamin Chelf  <chelf@codesourcery.com>\n+\n+\t* c-common.h (IF_COND): Added documentation.\n+\t(THEN_CLAUSE): Likewise.\n+\t(ELSE_CLAUSE): Likewise.\n+\t(WHILE_COND): Likewise.\n+\t(WHILE_BODY): Likewise.\n+\t(DO_COND): Likewise.\n+\t(DO_BODY): Likewise.\n+\t(RETURN_EXPR): Likewise.\n+\t(EXPR_STMT_EXPR): Likewise.\n+\t(FOR_INIT_STMT): Likewise.\n+\t(FOR_COND): Likewise.\n+\t(FOR_EXPR): Likewise.\n+\t(FOR_BODY): Likewise.\n+\t(SWITCH_COND): Likewise.\n+\t(SWITCH_BODY): Likewise.\n+\t(CASE_LOW): Likewise.\n+\t(CASE_HIGH): Likewise.\n+\t(GOTO_DESTINATION): Likewise.\n+\t(COMPOUND_BODY): Likewise.\n+\t(ASM_CV_QUAL): Likewise.\n+\t(ASM_STRING): Likewise.\n+\t(ASM_OUTPUTS): Likewise.\n+\t(ASM_INPUTS): Likewise.\n+\t(ASM_CLOBBERS): Likewise.\n+\t(DECL_STMT_DECL): Likewise.\n+\t(STMT_EXPR_STMT): Likewise.\n+\t(LABEL_STMT_LABEL): Likewise.\n+\n+\t* c-common.def: Added documenetion for SRCLOC, EXPR_STMT, \n+\tCOMPOUND_STMT, DECL_STMT, IF_STMT, FOR_STMT, WHILE_STMT, DO_STMT, \n+\tRETURN_STMT, BREAK_STMT, CONTINUE_STMT, SWITCH_STMT, GOTO_STMT, \n+\tLABEL_STMT, ASM_STMT, SCOPE_STMT, CASE_LABEL, STMT_EXPR.\n+\n 2000-06-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* configure.in (--enable-checking): Update --help doc to reflect"}, {"sha": "3486a4c1d8814fa9bd5ee869138a6914dac97801", "filename": "gcc/c-common.def", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -28,25 +28,60 @@ cp-tree.def in the cp subdir. */\n /* A node to remember a source position.  */\n DEFTREECODE (SRCLOC, \"srcloc\", 'x', 2)\n \n-/* A whole bunch of tree codes for the initial, superficial parsing of\n-   templates.  */\n DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\n DEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\n DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n \n+/* Used to represent an expression statement.  Use `EXPR_STMT_EXPR' to\n+   obtain the expression. */\n DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n+\n+/* Used to represent a brace-enclosed block.  The operand is\n+   COMPOUND_BODY. */ \n DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n+\n+/* Used to represent a local declaration. The operand is\n+   DECL_STMT_DECL. */\n DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n+\n+/* Represents an 'if' statement. The operands are IF_COND,\n+   THEN_CLAUSE, and ELSE_CLAUSE, respectively. */\n DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n+\n+/* Used to represent a `for' statement. The operands are\n+   FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively. */\n DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n+\n+/* Used to represent a 'while' statement. The operands are WHILE_COND\n+   and WHILE_BODY, respectively. */\n DEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n+\n+/* Used to represent a 'do' statement. The operands are DO_BODY and\n+   DO_COND, respectively. */\n DEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n+\n+/* Used to represent a 'return' statement. The operand is\n+   RETURN_EXPR. */\n DEFTREECODE (RETURN_STMT, \"return_stmt\", 'e', 1)\n+\n+/* Used to represent a 'break' statement. */\n DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n+\n+/* Used to represent a 'continue' statement. */\n DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n+\n+/* Used to represent a 'switch' statement. The operands are\n+   SWITCH_COND and SWITCH_BODY, respectively. */\n DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n+\n+/* Used to represent a 'goto' statement. The operand is GOTO_DESTINATION. */\n DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n+\n+/* Used to represent a 'label' statement. The operand is a LABEL_DECL\n+   and can be obtained through the macro LABEL_STMT_LABEL. */\n DEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n+\n+/* Used to represent an inline assembly statement. */\n DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n \n /* A SCOPE_STMT marks the beginning or end of a scope.  If\n@@ -56,6 +91,11 @@ DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n    this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n    variables declared in this scope.  */\n DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n+\n+/* Used to represent a CASE_LABEL. The operands are CASE_LOW and\n+   CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n+   'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case\n+   label. */\n DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n \n /* A STMT_EXPR represents a statement-expression.  The"}, {"sha": "cc597a7a989863899321042f79afa1d8f789ff0b", "filename": "gcc/c-common.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -167,32 +167,79 @@ extern tree simple_type_promotes_to\t\tPARAMS ((tree));\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n+\n+/* IF_STMT accessors. These give access to the condtion of the if\n+   statement, the then block of the if statement, and the else block\n+   of the if stsatement if it exists. */\n #define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n #define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n #define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n+\n+/* WHILE_STMT accessors. These give access to the condtion of the\n+   while statement and the body of the while statement, respectively. */\n #define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n #define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n+\n+/* DO_STMT accessors. These give access to the condition of the do\n+   statement and the body of the do statement, respectively. */\n #define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n #define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n+\n+/* RETURN_STMT accessor. This gives the expression associated with a\n+   return statement. */\n #define RETURN_EXPR(NODE)       TREE_OPERAND (RETURN_STMT_CHECK (NODE), 0)\n+\n+/* EXPR_STMT accessor. This gives the expression associated with an\n+   expression statement. */\n #define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n+\n+/* FOR_STMT accessors. These give access to the init statement,\n+   condition, update expression, and body of the for statement,\n+   respectively. */\n #define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n #define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n #define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n #define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n+\n+/* SWITCH_STMT accessors. These give access to the condition and body\n+   of the switch statement, respectively. */\n #define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n #define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n+\n+/* CASE_LABEL accessors. These give access to the high and low values\n+   of a case label, respectively. */\n #define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n #define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n+\n+/* GOTO_STMT accessor. This gives access to the label associated with\n+   a goto statement. */\n #define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n+\n+/* COMPOUND_STMT accessor. This gives access to the TREE_LIST of\n+   statements assocated with a compound statement. The result is the\n+   first statement in the list. Succeeding nodes can be acccessed by\n+   calling TREE_CHAIN on a node in the list. */\n #define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n+\n+/* ASM_STMT accessors. ASM_STRING returns a STRING_CST for the\n+   instruction (e.g., \"mov x, y\"). ASM_OUTPUTS, ASM_INPUTS, and\n+   ASM_CLOBBERS represent the outputs, inputs, and clobbers for the\n+   statement. */\n #define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n #define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n #define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n #define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n #define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n+\n+/* DECL_STMT accessor. This gives access to the DECL associated with\n+   the given declaration statement. */ \n #define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n+\n+/* STMT_EXPR accessor. */\n #define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n+\n+/* LABEL_STMT accessor. This gives access to the label associated with\n+   the given label statement. */\n #define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n \n /* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */"}, {"sha": "2d5731a9c58471ba8e800c317906755dfdbc0d63", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -1,3 +1,143 @@\n+2000-06-19  Benjamin Chelf  <chelf@cabriolet.stanford.edu>\n+\n+\t* cp-tree.h (genrtl_try_block): Declare function.\n+\t(genrtl_handler): Likewise.\n+\t(genrtl_catch_block): Likewise.\n+\t(genrtl_ctor_stmt): Likewise.\n+\t(genrtl_subobject): Likewise.\n+\t(genrtl_decl_cleanup): Likewise.\n+\t(genrtl_do_poplevel): Likewise.\n+\t(genrtl_do_pushlevel): Likewise.\n+\t(genrtl_clear_out_block): Likewise.\n+\t(genrtl_goto_stmt): Likewise.\n+\t(genrtl_expr_stmt): Likewise.\n+\t(genrtl_decl_stmt): Likewise.\n+\t(genrtl_if_stmt): Likewise.\n+\t(genrtl_while_stmt): Likewise.\n+\t(genrtl_do_stmt): Likewise.\n+\t(genrtl_return_stmt): Likewise.\n+\t(genrtl_for_stmt): Likewise.\n+\t(genrtl_break_stmt): Likewise.\n+\t(genrtl_continue_stmt): Likewise.\n+\t(genrtl_scope_stmt): Likewise.\n+\t(genrtl_switch_stmt): Likewise.\n+\t(genrtl_case_label): Likewise.\n+\t(genrtl_begin_compound_stmt): Likewise.\n+\t(genrtl_finish_compound_stmt): Likewise.\n+\t(genrtl_compound_stmt): Likewise.\n+\t(genrtl_asm_stmt): Likewise.\n+\t(genrtl_named_return_value): Likewise.\n+\t(genrtl_begin_stmt_expr): Likewise.\n+\t(genrtl_finish_stmt_expr): Likewise.\n+\t(finish_for_stmt): Removed first argument.\n+\t(finish_switch_stmt): Likewise.\n+\n+\t* semantics.c (genrtl_try_block): Define function.\n+\t(genrtl_handler): Likewise.\n+\t(genrtl_catch_block): Likewise.\n+\t(genrtl_ctor_stmt): Likewise.\n+\t(genrtl_subobject): Likewise.\n+\t(genrtl_decl_cleanup): Likewise.\n+\t(genrtl_do_poplevel): Likewise.\n+\t(genrtl_do_pushlevel): Likewise.\n+\t(genrtl_clear_out_block): Likewise.\n+\t(genrtl_goto_stmt): Likewise.\n+\t(genrtl_expr_stmt): Likewise.\n+\t(genrtl_decl_stmt): Likewise.\n+\t(genrtl_if_stmt): Likewise.\n+\t(genrtl_while_stmt): Likewise.\n+\t(genrtl_do_stmt): Likewise.\n+\t(genrtl_return_stmt): Likewise.\n+\t(genrtl_for_stmt): Likewise.\n+\t(genrtl_break_stmt): Likewise.\n+\t(genrtl_continue_stmt): Likewise.\n+\t(genrtl_scope_stmt): Likewise.\n+\t(genrtl_switch_stmt): Likewise.\n+\t(genrtl_case_label): Likewise.\n+\t(genrtl_begin_compound_stmt): Likewise.\n+\t(genrtl_finish_compound_stmt): Likewise.\n+\t(genrtl_compound_stmt): Likewise.\n+\t(genrtl_asm_stmt): Likewise.\n+\t(genrtl_named_return_value): Likewise.\n+\t(genrtl_begin_stmt_expr): Likewise.\n+\t(genrtl_finish_stmt_expr): Likewise.\n+\t(finish_for_stmt): Removed first argument and generate rtl \n+\tspecific code.\n+\t(finish_switch_stmt): Likewise.\n+\t(do_poplevel): Removed generate rtl specific code.\n+\t(do_pushlevel): Likewise.\n+\t(add_tree): Likewise.\n+\t(finish_goto_stmt): Likewise.\n+\t(finish_expr_stmt): Likewise.\n+\t(begin_if_stmt): Likewise.\n+\t(finish_if_stmt_cond): Likewise.\n+\t(finish_then_clause): Likewise.\n+\t(begin_else_clause): Likewise.\n+\t(finish_else_clause): Likewise.\n+\t(finish_if_stmt): Likewise.\n+\t(clear_out_block): Likewise.\n+\t(begin_while_stmt): Likewise.\n+\t(finish_while_stmt_cond): Likewise.\n+\t(finish_while_stmt): Likewise.\n+\t(begin_do_stmt): Likewise.\n+\t(finish_do_body): Likewise.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_return_stmt): Likewise.\n+\t(begin_for_stmt): Likewise.\n+\t(finish_for_init_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\t(finish_for_expr): Likewise.\n+\t(finish_break_stmt): Likewise.\n+\t(finish_continue_stmt): Likewise.\n+\t(begin_switch_stmt): Likewise.\n+\t(finish_switch_cond): Likewise.\n+\t(finish_case_label): Likewise.\n+\t(begin_try_block): Likewise.\n+\t(begin_function_try_block): Likewise.\n+\t(finish_try_block): Likewise.\n+\t(finish_cleanup_try_block): Likewise.\n+\t(finish_cleanup): Likewise.\n+\t(finish_function_try_block): Likewise.\n+\t(finish_handler_sequence): Likewise.\n+\t(finish_function_handler_sequence): Likewise.\n+\t(begin_handler): Likewise.\n+\t(finish_handler_parms): Likewise.\n+\t(begin_catch_block): Likewise.\n+\t(finish_handler): Likewise.\n+\t(begin_compound_stmt): Likewise.\n+\t(finish_compound_stmt): Likewise.\n+\t(finish_asm_stmt): Likewise.\n+\t(finish_label_stmt): Likewise.\n+\t(finish_label_decl): Likewise.\n+\t(finish_subobject): Likewise.\n+\t(finish_decl_cleanup): Likewise.\n+\t(finish_named_return_value): Likewise.\n+\t(begin_stmt_expr): Likewise.\n+\t(finish_stmt_expr): Likewise.\n+\t\n+\t* decl.c (initialize_local_var): Changed call to finish_expr_stmt\n+\tto call genrtl_expr_stmt when appropriate.\n+\n+\t* init.c (begin_init_stmts): Changed calls to begin_stmt_expr and\n+\tbegin_compound_expr to call genrtl_begin_stmt_expr and\n+\tgenrtl_begin_compound_expr when appropriate.\n+\t(finish_init_stmts): Changed calls to finish_compound_expr and\n+\tfinish_stmt_expr to call genrtl_finish_compound_expr and\n+\tgenrtl_finish_stmt_expr when appropriate.\n+\t(expand_default_init): Changed call to finish_expr_stmt to call\n+\tgenrtl_expr_stmt when appropriate.\n+\t(build_vec_init): Likewise.\n+\n+\t* parse.y (simple_stmt): Removed first argument from call to \n+\tfinish_for_stmt. Removed first argument from call to \n+\tfinish_switch_stmt.\n+\n+\t* parse.c: Regenerated.\n+\n+\t* pt.c (tsubst_expr): Removed first argument from call to \n+\tfinish_for_stmt. Removed first argument from call to \n+\tfinish_switch_stmt.\n+\t\n 2000-06-16  Benjamin Chelf  <chelf@codesourcery.com>\n \n \t* cp-tree.h (enum cplus_tree_code): Changed __DUMMY to"}, {"sha": "b93a29ec2e4e35ec3b218713d4687185b36b5a8d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -4406,12 +4406,12 @@ extern tree begin_for_stmt                      PARAMS ((void));\n extern void finish_for_init_stmt                PARAMS ((tree));\n extern void finish_for_cond                     PARAMS ((tree, tree));\n extern void finish_for_expr                     PARAMS ((tree, tree));\n-extern void finish_for_stmt                     PARAMS ((tree, tree));\n+extern void finish_for_stmt                     PARAMS ((tree));\n extern void finish_break_stmt                   PARAMS ((void));\n extern void finish_continue_stmt                PARAMS ((void));\n extern tree begin_switch_stmt                   PARAMS ((void));\n extern void finish_switch_cond                  PARAMS ((tree, tree));\n-extern void finish_switch_stmt                  PARAMS ((tree, tree));\n+extern void finish_switch_stmt                  PARAMS ((tree));\n extern void finish_case_label                   PARAMS ((tree, tree));\n extern void finish_goto_stmt                    PARAMS ((tree));\n extern tree begin_try_block                     PARAMS ((void));\n@@ -4480,6 +4480,40 @@ extern void do_pushlevel                        PARAMS ((void));\n extern tree do_poplevel                         PARAMS ((void));\n extern void finish_mem_initializers             PARAMS ((tree));\n \n+extern void genrtl_try_block                    PARAMS ((tree));\n+extern void genrtl_handler                      PARAMS ((tree));\n+extern void genrtl_catch_block                  PARAMS ((tree));\n+extern void genrtl_ctor_stmt                    PARAMS ((tree));\n+extern void genrtl_subobject                    PARAMS ((tree));\n+extern void genrtl_decl_cleanup                 PARAMS ((tree, tree));\n+extern tree genrtl_do_poplevel                  PARAMS ((void));\n+extern void genrtl_do_pushlevel                 PARAMS ((void));\n+extern void genrtl_clear_out_block              PARAMS ((void));\n+extern void genrtl_goto_stmt                    PARAMS ((tree));\n+extern void genrtl_expr_stmt                    PARAMS ((tree));\n+extern void genrtl_decl_stmt                    PARAMS ((tree));\n+extern void genrtl_if_stmt                      PARAMS ((tree));\n+extern void genrtl_while_stmt                   PARAMS ((tree));\n+extern void genrtl_do_stmt                      PARAMS ((tree));\n+extern void genrtl_return_stmt                  PARAMS ((tree));\n+extern void genrtl_for_stmt                     PARAMS ((tree));\n+extern void genrtl_break_stmt                   PARAMS ((void));\n+extern void genrtl_continue_stmt                PARAMS ((void));\n+extern void genrtl_scope_stmt                   PARAMS ((tree));\n+extern void genrtl_switch_stmt                  PARAMS ((tree));\n+extern void genrtl_case_label                   PARAMS ((tree, tree));\n+extern tree genrtl_begin_compound_stmt          PARAMS ((int));\n+extern tree genrtl_finish_compound_stmt         PARAMS ((int));\n+extern tree genrtl_compound_stmt                PARAMS ((tree));\n+extern void genrtl_asm_stmt                     PARAMS ((tree, tree,\n+\t\t\t\t\t\t\t tree, tree,\n+\t\t\t\t\t\t\t tree));\n+extern void genrtl_named_return_value           PARAMS ((tree,\n+\t\t\t\t\t\t\t tree));\n+extern tree genrtl_begin_stmt_expr              PARAMS ((void));\n+extern tree genrtl_finish_stmt_expr             PARAMS ((tree));\n+\n+\n /* in spew.c */\n extern void init_spew\t\t\t\tPARAMS ((void));\n extern int peekyylex\t\t\t\tPARAMS ((void));"}, {"sha": "3e949b8489c5382cc9e451a33fe47c60f2b3f74b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -7980,7 +7980,10 @@ initialize_local_var (decl, init, flags)\n \t\t\t  DECL_SOURCE_LINE (decl));\n \t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p;\n \t  stmts_are_full_exprs_p = 1;\n-\t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n+\t  if (building_stmt_tree ())\n+\t    finish_expr_stmt (build_aggr_init (decl, init, flags));\n+\t  else\n+\t    genrtl_expr_stmt (build_aggr_init (decl, init, flags));\n \t  stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n \t}\n "}, {"sha": "942af79a8045559e9865760bbfc4215254b20cf1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -97,8 +97,15 @@ begin_init_stmts (stmt_expr_p, compound_stmt_p)\n      tree *stmt_expr_p;\n      tree *compound_stmt_p;\n {\n-  *stmt_expr_p = begin_stmt_expr ();\n-  *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n+  if (building_stmt_tree ())\n+    *stmt_expr_p = begin_stmt_expr ();\n+  else\n+    *stmt_expr_p = genrtl_begin_stmt_expr ();\n+  \n+  if (building_stmt_tree ())\n+    *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n+  else\n+    *compound_stmt_p = genrtl_begin_compound_stmt (/*has_no_scope=*/1);\n }\n \n /* Finish out the statement-expression begun by the previous call to\n@@ -108,10 +115,18 @@ tree\n finish_init_stmts (stmt_expr, compound_stmt)\n      tree stmt_expr;\n      tree compound_stmt;\n-{\n-  finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n-  stmt_expr = finish_stmt_expr (stmt_expr);\n \n+{  \n+  if (building_stmt_tree ())\n+    finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n+  else\n+    genrtl_finish_compound_stmt (/*has_no_scope=*/1);\n+  \n+  if (building_stmt_tree ())\n+    stmt_expr = finish_stmt_expr (stmt_expr);\n+  else\n+    stmt_expr = genrtl_finish_stmt_expr (stmt_expr);\n+  \n   /* To avoid spurious warnings about unused values, we set \n      TREE_USED.  */\n   if (stmt_expr)\n@@ -1297,7 +1312,12 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n \n   rval = build_method_call (exp, ctor_name, parms, binfo, flags);\n   if (TREE_SIDE_EFFECTS (rval))\n-    finish_expr_stmt (rval);\n+    {\n+      if (building_stmt_tree ())\n+\tfinish_expr_stmt (rval);\n+      else\n+\tgenrtl_expr_stmt (rval);\n+    }\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -2988,7 +3008,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t full-expression.  */\n       if (!building_stmt_tree ())\n \t{\n-\t  finish_expr_stmt (elt_init);\n+\t  genrtl_expr_stmt (elt_init);\n \t  expand_end_target_temps ();\n \t}\n       else"}, {"sha": "f0f4f32ae2d6c0ae170cb502587b034fb585183b", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -7698,7 +7698,7 @@ case 734:\n     break;}\n case 735:\n #line 3297 \"parse.y\"\n-{ finish_for_stmt (yyvsp[-3].ttype, yyvsp[-10].ttype); ;\n+{ finish_for_stmt (yyvsp[-10].ttype); ;\n     break;}\n case 736:\n #line 3299 \"parse.y\"\n@@ -7710,7 +7710,7 @@ case 737:\n     break;}\n case 738:\n #line 3303 \"parse.y\"\n-{ finish_switch_stmt (yyvsp[-3].ttype, yyvsp[-5].ttype); ;\n+{ finish_switch_stmt (yyvsp[-5].ttype); ;\n     break;}\n case 739:\n #line 3305 \"parse.y\""}, {"sha": "136699174c9fdf750cf0bfa3a229a15f7b5583c4", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -3294,13 +3294,13 @@ simple_stmt:\n \t  xexpr ')'\n                 { finish_for_expr ($9, $<ttype>2); }\n \t  already_scoped_stmt\n-                { finish_for_stmt ($9, $<ttype>2); }\n+                { finish_for_stmt ($<ttype>2); }\n \t| SWITCH \n                 { $<ttype>$ = begin_switch_stmt (); }\n \t    '(' condition ')'\n                 { finish_switch_cond ($4, $<ttype>2); }\n \t  implicitly_scoped_stmt\n-                { finish_switch_stmt ($4, $<ttype>2); }\n+                { finish_switch_stmt ($<ttype>2); }\n \t| CASE expr_no_commas ':'\n                 { finish_case_label ($2, NULL_TREE); }\n \t  stmt"}, {"sha": "4250eee2304e035863cdc7381156a09eee6ddf7c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -7215,7 +7215,7 @@ tsubst_expr (t, args, complain, in_decl)\n \ttmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n \tfinish_for_expr (tmp, stmt);\n \ttsubst_expr (FOR_BODY (t), args, complain, in_decl);\n-\tfinish_for_stmt (tmp, stmt);\n+\tfinish_for_stmt (stmt);\n       }\n       break;\n \n@@ -7303,7 +7303,7 @@ tsubst_expr (t, args, complain, in_decl)\n \tval = tsubst_expr (SWITCH_COND (t), args, complain, in_decl);\n \tfinish_switch_cond (val, stmt);\n \ttsubst_expr (SWITCH_BODY (t), args, complain, in_decl);\n-\tfinish_switch_stmt (val, stmt);\n+\tfinish_switch_stmt (stmt);\n       }\n       break;\n "}, {"sha": "5cebea6cd83d193d3afe55d4422420e2c86f6dae", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 897, "deletions": 709, "changes": 1606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1567d9e376f670019b87ca5423052b6bbde07/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=35b1567d9e376f670019b87ca5423052b6bbde07", "patch": "@@ -86,7 +86,99 @@ static void deferred_type_access_control PARAMS ((void));\n     else\t\t\t\t\t\t\\\n       substmt = cond;\t\t\t\t\t\\\n   } while (0)\n-  \n+\n+/* Finish a scope.  */\n+\n+tree\n+do_poplevel ()\n+{\n+  tree block = NULL_TREE;\n+\n+  if (stmts_are_full_exprs_p)\n+    {\n+      tree scope_stmts;\n+\n+      if (!processing_template_decl)\n+\tscope_stmts = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n+\n+      block = poplevel (kept_level_p (), 1, 0);\n+      if (block && !processing_template_decl)\n+\t{\n+\t  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n+\t  SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n+\t}\n+    }\n+\n+  return block;\n+}\n+\n+/* Begin a new scope.  */ \n+\n+void\n+do_pushlevel ()\n+{\n+  if (stmts_are_full_exprs_p)\n+    {\n+      pushlevel (0);\n+      if (!processing_template_decl)\n+\tadd_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n+    }\n+}\n+\n+/* Helper for generating the RTL at the end of a scope. */\n+\n+tree\n+genrtl_do_poplevel ()\n+{\n+  tree block = NULL_TREE;\n+\n+  if (stmts_are_full_exprs_p)\n+    {\n+      tree scope_stmts;\n+      scope_stmts = NULL_TREE;\n+\n+      block = poplevel (kept_level_p (), 1, 0);\n+      if (block && !processing_template_decl)\n+\t{\n+\t  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n+\t  SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n+\t}\n+    }\n+\n+  return block;\n+}\n+\n+/* Helper for generating the RTL at the beginning of a scope. */\n+\n+void\n+genrtl_do_pushlevel ()\n+{\n+  emit_line_note (input_filename, lineno);\n+  clear_last_expr ();\n+\n+  if (stmts_are_full_exprs_p)\n+    {\n+      pushlevel (0); // Try to get rid of me.\n+      if (!cfun->x_whole_function_mode_p)\n+\tmy_friendly_abort (19991129);\n+    }\n+}\n+\n+/* Helper for generating the RTL. */\n+\n+void\n+genrtl_clear_out_block ()\n+{\n+  /* If COND wasn't a declaration, clear out the\n+     block we made for it and start a new one here so the\n+     optimization in expand_end_loop will work.  */\n+  if (getdecls () == NULL_TREE)\n+    {\n+      genrtl_do_poplevel ();\n+      genrtl_do_pushlevel ();\n+    }\n+}\n+\n /* T is a statement.  Add it to the statement-tree.  */\n \n void\n@@ -96,11 +188,60 @@ add_tree (t)\n   /* Add T to the statement-tree.  */\n   TREE_CHAIN (last_tree) = t;\n   SET_LAST_STMT (t);\n-\n   /* When we expand a statement-tree, we must know whether or not the\n      statements are full-expresions.  We record that fact here.  */\n-  if (building_stmt_tree ())\n-    STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p;\n+  STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p;\n+}\n+\n+/* Finish a goto-statement.  */\n+\n+void\n+finish_goto_stmt (destination)\n+     tree destination;\n+{\n+  if (TREE_CODE (destination) == IDENTIFIER_NODE)\n+    destination = lookup_label (destination);\n+\n+  /* We warn about unused labels with -Wunused.  That means we have to\n+     mark the used labels as used.  */\n+  if (TREE_CODE (destination) == LABEL_DECL)\n+    TREE_USED (destination) = 1;\n+    \n+  if (TREE_CODE (destination) != LABEL_DECL)\n+    /* We don't inline calls to functions with computed gotos.\n+       Those functions are typically up to some funny business,\n+       and may be depending on the labels being at particular\n+       addresses, or some such.  */\n+    DECL_UNINLINABLE (current_function_decl) = 1;\n+  \n+  check_goto (destination);\n+\n+  add_tree (build_min_nt (GOTO_STMT, destination));\n+}\n+\n+/* Generate the RTL for DESTINATION, which is a GOTO_STMT. */\n+\n+void\n+genrtl_goto_stmt (destination)\n+     tree destination;\n+{\n+  if (TREE_CODE (destination) == IDENTIFIER_NODE)\n+    destination = lookup_label (destination);\n+\n+  /* We warn about unused labels with -Wunused.  That means we have to\n+     mark the used labels as used.  */\n+  if (TREE_CODE (destination) == LABEL_DECL)\n+    TREE_USED (destination) = 1;\n+    \n+  emit_line_note (input_filename, lineno);\n+  \n+  if (TREE_CODE (destination) == LABEL_DECL)\n+    {\n+      label_rtx (destination);\n+      expand_goto (destination); \n+    }\n+  else\n+    expand_computed_goto (destination);\n }\n \n /* COND is the condition-expression for an if, while, etc.,\n@@ -131,37 +272,46 @@ finish_expr_stmt (expr)\n {\n   if (expr != NULL_TREE)\n     {\n-      if (building_stmt_tree ())\n-\t{\n-\t  /* Do default conversion if safe and possibly important,\n-\t     in case within ({...}).  */\n-\t  if (!processing_template_decl\n-\t      && !stmts_are_full_exprs_p\n-\t      && ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-\t\t   && lvalue_p (expr))\n-\t\t  || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE))\n-\t    expr = default_conversion (expr);\n-\n-\t  if (stmts_are_full_exprs_p)\n-\t    expr = convert_to_void (expr, \"statement\");\n-\n-\t  if (!processing_template_decl)\n-\t    expr = break_out_cleanups (expr);\n-\n-\t  add_tree (build_min_nt (EXPR_STMT, expr));\n-\t}\n-      else\n-\t{\n-\t  emit_line_note (input_filename, lineno);\n+      if (!processing_template_decl\n+\t  && !stmts_are_full_exprs_p\n+\t  && ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+\t       && lvalue_p (expr))\n+\t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE))\n+\texpr = default_conversion (expr);\n+      \n+      if (stmts_are_full_exprs_p)\n+\texpr = convert_to_void (expr, \"statement\");\n+      \n+      if (!processing_template_decl)\n+\texpr = break_out_cleanups (expr);\n+      \n+      add_tree (build_min_nt (EXPR_STMT, expr));\n+    }\n \n-\t  if (stmts_are_full_exprs_p)\n-\t    expand_start_target_temps ();\n-\t    \n-\t  cplus_expand_expr_stmt (expr);\n+  finish_stmt ();\n \n-\t  if (stmts_are_full_exprs_p)\n-\t    expand_end_target_temps ();\n-\t}\n+  /* This was an expression-statement, so we save the type of the\n+     expression.  */\n+  last_expr_type = expr ? TREE_TYPE (expr) : NULL_TREE;\n+}\n+\n+/* Generate the RTL for EXPR, which is an EXPR_STMT. */\n+\n+void \n+genrtl_expr_stmt (expr)\n+     tree expr;\n+{\n+  if (expr != NULL_TREE)\n+    {\n+      emit_line_note (input_filename, lineno);\n+      \n+      if (stmts_are_full_exprs_p)\n+\texpand_start_target_temps ();\n+      \n+      cplus_expand_expr_stmt (expr);\n+      \n+      if (stmts_are_full_exprs_p)\n+\texpand_end_target_temps ();\n     }\n \n   finish_stmt ();\n@@ -171,24 +321,77 @@ finish_expr_stmt (expr)\n   last_expr_type = expr ? TREE_TYPE (expr) : NULL_TREE;\n }\n \n+/* Generate the RTL for T, which is a DECL_STMT. */\n+\n+void\n+genrtl_decl_stmt (t)\n+     tree t;\n+{\n+  tree decl;\n+  emit_line_note (input_filename, lineno);\n+  decl = DECL_STMT_DECL (t);\n+  /* If this is a declaration for an automatic local\n+     variable, initialize it.  Note that we might also see a\n+     declaration for a namespace-scope object (declared with\n+     `extern').  We don't have to handle the initialization\n+     of those objects here; they can only be declarations,\n+     rather than definitions.  */\n+  if (TREE_CODE (decl) == VAR_DECL \n+      && !TREE_STATIC (decl)\n+      && !DECL_EXTERNAL (decl))\n+    {\n+      /* Let the back-end know about this variable.  */\n+      if (!ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n+\temit_local_var (decl);\n+      else\n+\texpand_anon_union_decl (decl, NULL_TREE, \n+\t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+    {\n+      if (DECL_ARTIFICIAL (decl) && ! TREE_USED (decl))\n+\t/* Do not emit unused decls. This is not just an\n+\t   optimization. We really do not want to emit\n+\t   __PRETTY_FUNCTION__ etc, if they're never used.  */\n+\tDECL_IGNORED_P (decl) = 1;\n+      else\n+\tmake_rtl_for_local_static (decl);\n+    }\n+}\n+\n+/* Generate the RTL for T, which is an IF_STMT. */\n+\n+void\n+genrtl_if_stmt (t)\n+     tree t;\n+{\n+  tree cond;\n+  genrtl_do_pushlevel ();\n+  cond = maybe_convert_cond (expand_cond (IF_COND (t)));\n+  emit_line_note (input_filename, lineno);\n+  expand_start_cond (cond, 0);\n+  if (THEN_CLAUSE (t))\n+    expand_stmt (THEN_CLAUSE (t));\n+  if (ELSE_CLAUSE (t))\n+    {\n+      expand_start_else ();\n+      expand_stmt (ELSE_CLAUSE (t));\n+    }\n+  expand_end_cond ();\n+  genrtl_do_poplevel ();\n+  finish_stmt ();\n+}\n+\n /* Begin an if-statement.  Returns a newly created IF_STMT if\n    appropriate.  */\n \n tree\n begin_if_stmt ()\n {\n   tree r;\n-\n   do_pushlevel ();\n-\n-  if (building_stmt_tree ())\n-    {\n-      r = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n-      add_tree (r);\n-    }\n-  else\n-    r = NULL_TREE;\n-\n+  r = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+  add_tree (r);\n   return r;\n }\n \n@@ -201,14 +404,7 @@ finish_if_stmt_cond (cond, if_stmt)\n      tree if_stmt;\n {\n   cond = maybe_convert_cond (cond);\n-\n-  if (building_stmt_tree ())\n-    FINISH_COND (cond, if_stmt, IF_COND (if_stmt));\n-  else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      expand_start_cond (cond, 0);\n-    }\n+  FINISH_COND (cond, if_stmt, IF_COND (if_stmt));\n }\n \n /* Finish the then-clause of an if-statement, which may be given by\n@@ -218,23 +414,16 @@ tree\n finish_then_clause (if_stmt)\n      tree if_stmt;\n {\n-  if (building_stmt_tree ())\n-    {\n-      RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n-      SET_LAST_STMT (if_stmt);\n-      return if_stmt;\n-    }\n-  else\n-    return NULL_TREE;\n+  RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n+  SET_LAST_STMT (if_stmt);\n+  return if_stmt;\n }\n \n /* Begin the else-clause of an if-statement.  */\n \n void \n begin_else_clause ()\n {\n-  if (!building_stmt_tree ())\n-    expand_start_else ();\n }\n \n /* Finish the else-clause of an if-statement, which may be given by\n@@ -244,45 +433,65 @@ void\n finish_else_clause (if_stmt)\n      tree if_stmt;\n {\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n+  RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n }\n \n /* Finsh an if-statement.  */\n \n void \n finish_if_stmt ()\n {\n-  if (!building_stmt_tree ())\n-    expand_end_cond ();\n-\n   do_poplevel ();\n   finish_stmt ();\n }\n \n+void\n+clear_out_block ()\n+{\n+  /* If COND wasn't a declaration, clear out the\n+     block we made for it and start a new one here so the\n+     optimization in expand_end_loop will work.  */\n+  if (getdecls () == NULL_TREE)\n+    {\n+      do_poplevel ();\n+      do_pushlevel ();\n+    }\n+}\n+\n+/* Generate the RTL for T, which is a WHILE_STMT. */\n+\n+void\n+genrtl_while_stmt (t)\n+     tree t;\n+{\n+  tree cond;\n+  emit_nop ();\n+  emit_line_note (input_filename, lineno);\n+  expand_start_loop (1); \n+  genrtl_do_pushlevel ();\n+\n+  cond = maybe_convert_cond (expand_cond (WHILE_COND (t)));\n+  emit_line_note (input_filename, lineno);\n+  expand_exit_loop_if_false (0, cond);\n+  genrtl_clear_out_block ();\n+  \n+  expand_stmt (WHILE_BODY (t));\n+\n+  genrtl_do_poplevel ();\n+  expand_end_loop ();\n+  finish_stmt ();\n+}\n+\n /* Begin a while-statement.  Returns a newly created WHILE_STMT if\n    appropriate.  */\n \n tree\n begin_while_stmt ()\n {\n   tree r;\n-\n-  if (building_stmt_tree ())\n-    {\n-      r = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n-      add_tree (r);\n-    }\n-  else\n-    {\n-      emit_nop ();\n-      emit_line_note (input_filename, lineno);\n-      expand_start_loop (1); \n-      r = NULL_TREE;\n-    }\n-\n+  r = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n+  add_tree (r);\n   do_pushlevel ();\n-\n   return r;\n }\n \n@@ -295,23 +504,8 @@ finish_while_stmt_cond (cond, while_stmt)\n      tree while_stmt;\n {\n   cond = maybe_convert_cond (cond);\n-\n-  if (building_stmt_tree ())\n-    FINISH_COND (cond, while_stmt, WHILE_COND (while_stmt));\n-  else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      expand_exit_loop_if_false (0, cond);\n-    }\n-\n-  /* If COND wasn't a declaration, clear out the\n-     block we made for it and start a new one here so the\n-     optimization in expand_end_loop will work.  */\n-  if (getdecls () == NULL_TREE)\n-    {\n-      do_poplevel ();\n-      do_pushlevel ();\n-    }\n+  FINISH_COND (cond, while_stmt, WHILE_COND (while_stmt));\n+  clear_out_block ();\n }\n \n /* Finish a while-statement, which may be given by WHILE_STMT.  */\n@@ -321,33 +515,41 @@ finish_while_stmt (while_stmt)\n      tree while_stmt;\n {\n   do_poplevel ();\n-\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (while_stmt, WHILE_BODY (while_stmt));\n-  else\n-    expand_end_loop ();\n+  RECHAIN_STMTS (while_stmt, WHILE_BODY (while_stmt));\n   finish_stmt ();\n }\n \n+/* Generate the RTL for T, which is a DO_STMT. */\n+\n+void\n+genrtl_do_stmt (t)\n+    tree t;\n+{\n+  tree cond;\n+  emit_nop ();\n+  emit_line_note (input_filename, lineno);\n+  expand_start_loop_continue_elsewhere (1);\n+\n+  expand_stmt (DO_BODY (t));\n+\n+  expand_loop_continue_here ();\n+\n+  cond = maybe_convert_cond (DO_COND (t));\n+  emit_line_note (input_filename, lineno);\n+  expand_exit_loop_if_false (0, cond);\n+  expand_end_loop ();\n+  finish_stmt ();  \n+}\n+\n /* Begin a do-statement.  Returns a newly created DO_STMT if\n    appropriate.  */\n \n tree\n begin_do_stmt ()\n {\n-  if (building_stmt_tree ())\n-    {\n-      tree r = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n-      add_tree (r);\n-      return r;\n-    }\n-  else\n-    {\n-      emit_nop ();\n-      emit_line_note (input_filename, lineno);\n-      expand_start_loop_continue_elsewhere (1);\n-      return NULL_TREE;\n-    }\n+  tree r = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n+  add_tree (r);\n+  return r;\n }\n \n /* Finish the body of a do-statement, which may be given by DO_STMT.  */\n@@ -356,10 +558,7 @@ void\n finish_do_body (do_stmt)\n      tree do_stmt;\n {\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (do_stmt, DO_BODY (do_stmt));\n-  else\n-    expand_loop_continue_here ();\n+  RECHAIN_STMTS (do_stmt, DO_BODY (do_stmt));\n }\n \n /* Finish a do-statement, which may be given by DO_STMT, and whose\n@@ -371,16 +570,18 @@ finish_do_stmt (cond, do_stmt)\n      tree do_stmt;\n {\n   cond = maybe_convert_cond (cond);\n+  DO_COND (do_stmt) = cond;\n+  finish_stmt ();\n+}\n \n-  if (building_stmt_tree ())\n-    DO_COND (do_stmt) = cond;\n-  else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      expand_exit_loop_if_false (0, cond);\n-      expand_end_loop ();\n-    }\n+/* Generate the RTL for EXPR, which is a RETURN_STMT. */\n \n+void\n+genrtl_return_stmt (expr)\n+     tree expr;\n+{\n+  emit_line_note (input_filename, lineno);\n+  c_expand_return (expr);\n   finish_stmt ();\n }\n \n@@ -391,10 +592,9 @@ void\n finish_return_stmt (expr)\n      tree expr;\n {\n-  if (doing_semantic_analysis_p () && !processing_template_decl)\n+  if (!processing_template_decl)\n     expr = check_return_expr (expr);\n-\n-  if (doing_semantic_analysis_p () && !processing_template_decl)\n+  if (!processing_template_decl)\n     {\n       if (DECL_CONSTRUCTOR_P (current_function_decl) && ctor_label)\n \t{\n@@ -417,16 +617,49 @@ finish_return_stmt (expr)\n \t  return;\n \t}\n     }\n+  add_tree (build_min_nt (RETURN_STMT, expr));\n+  finish_stmt ();\n+}\n \n-  if (building_stmt_tree ())\n-    add_tree (build_min_nt (RETURN_STMT, expr));\n-  else\n+/* Generate the RTL for T, which is a FOR_STMT. */\n+\n+void\n+genrtl_for_stmt (t)\n+     tree t;\n+{\n+  tree tmp;\n+  tree cond;\n+  if (flag_new_for_scope > 0)\n     {\n-      emit_line_note (input_filename, lineno);\n-      c_expand_return (expr);\n-    }\n+      genrtl_do_pushlevel ();\n+      note_level_for_for ();\n+    }  \n \n-  finish_stmt ();\n+  expand_stmt (FOR_INIT_STMT (t));\n+\n+  emit_nop ();\n+  emit_line_note (input_filename, lineno);\n+  expand_start_loop_continue_elsewhere (1); \n+  genrtl_do_pushlevel ();\n+  cond = maybe_convert_cond (expand_cond (FOR_COND (t)));\n+  emit_line_note (input_filename, lineno);\n+  if (cond)\n+    expand_exit_loop_if_false (0, cond);\n+  genrtl_clear_out_block ();\n+  tmp = FOR_EXPR (t);\n+\n+  expand_stmt (FOR_BODY (t));\n+\n+  /* Pop the scope for the body of the loop.  */\n+  genrtl_do_poplevel ();\n+  emit_line_note (input_filename, lineno);\n+  expand_loop_continue_here ();\n+  if (tmp) \n+    genrtl_expr_stmt (tmp);\n+  expand_end_loop ();\n+  if (flag_new_for_scope > 0)\n+    genrtl_do_poplevel ();\n+  finish_stmt (); \n }\n \n /* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */\n@@ -436,15 +669,10 @@ begin_for_stmt ()\n {\n   tree r;\n \n-  if (building_stmt_tree ())\n-    {\n-      r = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n-\t\t\tNULL_TREE, NULL_TREE);\n-      add_tree (r);\n-    }\n-  else\n-    r = NULL_TREE;\n-\n+  r = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n+\t\t    NULL_TREE, NULL_TREE);\n+  add_tree (r);\n+  \n   if (flag_new_for_scope > 0)\n     {\n       do_pushlevel ();\n@@ -461,18 +689,8 @@ void\n finish_for_init_stmt (for_stmt)\n      tree for_stmt;\n {\n-  if (building_stmt_tree ())\n-    {\n-      if (last_tree != for_stmt)\n-\tRECHAIN_STMTS (for_stmt, FOR_INIT_STMT (for_stmt));\n-    }\n-  else\n-    {\n-      emit_nop ();\n-      emit_line_note (input_filename, lineno);\n-      expand_start_loop_continue_elsewhere (1); \n-    }\n-\n+  if (last_tree != for_stmt)\n+    RECHAIN_STMTS (for_stmt, FOR_INIT_STMT (for_stmt));\n   do_pushlevel ();\n }\n \n@@ -485,24 +703,8 @@ finish_for_cond (cond, for_stmt)\n      tree for_stmt;\n {\n   cond = maybe_convert_cond (cond);\n-\n-  if (building_stmt_tree ())\n-    FINISH_COND (cond, for_stmt, FOR_COND (for_stmt));\n-  else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      if (cond)\n-\texpand_exit_loop_if_false (0, cond);\n-    }\n-  \n-  /* If the cond wasn't a declaration, clear out the\n-     block we made for it and start a new one here so the\n-     optimization in expand_end_loop will work.  */\n-  if (getdecls () == NULL_TREE)\n-    {\n-      do_poplevel ();\n-      do_pushlevel ();\n-    }  \n+  FINISH_COND (cond, for_stmt, FOR_COND (for_stmt));\n+  clear_out_block ();\n }\n \n /* Finish the increment-EXPRESSION in a for-statement, which may be\n@@ -513,49 +715,52 @@ finish_for_expr (expr, for_stmt)\n      tree expr;\n      tree for_stmt;\n {\n-  if (building_stmt_tree ())\n-    FOR_EXPR (for_stmt) = expr;\n+  FOR_EXPR (for_stmt) = expr;\n }\n \n /* Finish the body of a for-statement, which may be given by\n    FOR_STMT.  The increment-EXPR for the loop must be\n    provided.  */\n \n void\n-finish_for_stmt (expr, for_stmt)\n-     tree expr;\n+finish_for_stmt (for_stmt)\n      tree for_stmt;\n {\n   /* Pop the scope for the body of the loop.  */\n   do_poplevel ();\n-\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (for_stmt, FOR_BODY (for_stmt));\n-  else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      expand_loop_continue_here ();\n-      if (expr) \n-\tfinish_expr_stmt (expr);\n-      expand_end_loop ();\n-    }\n-\n+  RECHAIN_STMTS (for_stmt, FOR_BODY (for_stmt));\n   if (flag_new_for_scope > 0)\n     do_poplevel ();\n-\n   finish_stmt (); \n }\n \n+/* Generate the RTL for a BREAK_STMT. */\n+\n+void\n+genrtl_break_stmt ()\n+{\n+  emit_line_note (input_filename, lineno);\n+  if ( ! expand_exit_something ())\n+    cp_error (\"break statement not within loop or switch\");\n+}\n+\n /* Finish a break-statement.  */\n \n void\n finish_break_stmt ()\n {\n   emit_line_note (input_filename, lineno);\n-  if (building_stmt_tree ())\n-    add_tree (build_min_nt (BREAK_STMT));\n-  else if ( ! expand_exit_something ())\n-    cp_error (\"break statement not within loop or switch\");\n+  add_tree (build_min_nt (BREAK_STMT));\n+}\n+\n+/* Generate the RTL for a CONTINUE_STMT. */\n+\n+void\n+genrtl_continue_stmt ()\n+{\n+  emit_line_note (input_filename, lineno);\n+  if (! expand_continue_loop (0))\n+    cp_error (\"continue statement not within a loop\");   \n }\n \n /* Finish a continue-statement.  */\n@@ -564,30 +769,73 @@ void\n finish_continue_stmt ()\n {\n   emit_line_note (input_filename, lineno);\n-  if (building_stmt_tree ())\n-    add_tree (build_min_nt (CONTINUE_STMT));\n-  else if (! expand_continue_loop (0))\n-    cp_error (\"continue statement not within a loop\");   \n+  add_tree (build_min_nt (CONTINUE_STMT));\n }\n \n-/* Begin a switch-statement.  Returns a new SWITCH_STMT if\n-   appropriate.  */\n+/* Generate the RTL for T, which is a SCOPE_STMT. */\n \n-tree\n-begin_switch_stmt ()\n+void\n+genrtl_scope_stmt (t)\n+     tree t;\n {\n-  tree r;\n+  if (!SCOPE_NO_CLEANUPS_P (t))\n+    {\n+      if (SCOPE_BEGIN_P (t))\n+\texpand_start_bindings_and_block (2 * SCOPE_NULLIFIED_P (t),\n+\t\t\t\t\t SCOPE_STMT_BLOCK (t));\n+      else if (SCOPE_END_P (t))\n+\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n+    }\n+  else if (!SCOPE_NULLIFIED_P (t))\n+    {\n+      rtx note = emit_note (NULL,\n+\t\t\t    (SCOPE_BEGIN_P (t) \n+\t\t\t     ? NOTE_INSN_BLOCK_BEG\n+\t\t\t     : NOTE_INSN_BLOCK_END));\n+      NOTE_BLOCK (note) = SCOPE_STMT_BLOCK (t);\n+    }\n+}\n+\n+/* Generate the RTL for T, which is a SWITCH_STMT. */\n \n-  if (building_stmt_tree ())\n+void\n+genrtl_switch_stmt (t)\n+     tree t;\n+{\n+  tree cond;\n+  genrtl_do_pushlevel ();\n+ \n+  cond = expand_cond (SWITCH_COND (t));\n+  if (cond != error_mark_node)\n     {\n-      r = build_min_nt (SWITCH_STMT, NULL_TREE, NULL_TREE);\n-      add_tree (r);\n+      emit_line_note (input_filename, lineno);\n+      c_expand_start_case (cond);\n     }\n   else\n-    r = NULL_TREE;\n+    /* The code is in error, but we don't want expand_end_case to\n+       crash. */\n+    c_expand_start_case (boolean_false_node);\n \n-  do_pushlevel ();\n+  push_switch ();\n+\n+  expand_stmt (SWITCH_BODY (t));\n+\n+  expand_end_case (cond);\n+  pop_switch (); \n+  genrtl_do_poplevel ();\n+  finish_stmt ();  \n+}\n+\n+/* Begin a switch-statement.  Returns a new SWITCH_STMT if\n+   appropriate.  */\n \n+tree\n+begin_switch_stmt ()\n+{\n+  tree r;\n+  r = build_min_nt (SWITCH_STMT, NULL_TREE, NULL_TREE);\n+  add_tree (r);\n+  do_pushlevel ();\n   return r;\n }\n \n@@ -598,127 +846,116 @@ finish_switch_cond (cond, switch_stmt)\n      tree cond;\n      tree switch_stmt;\n {\n-  if (building_stmt_tree ())\n+  if (!processing_template_decl)\n     {\n-      if (!processing_template_decl)\n+      /* Convert the condition to an integer or enumeration type.  */\n+      cond = build_expr_type_conversion (WANT_INT | WANT_ENUM, cond, 1);\n+      if (cond == NULL_TREE)\n \t{\n-\t  /* Convert the condition to an integer or enumeration type.  */\n-\t  cond = build_expr_type_conversion (WANT_INT | WANT_ENUM, cond, 1);\n-\t  if (cond == NULL_TREE)\n-\t    {\n-\t      error (\"switch quantity not an integer\");\n-\t      cond = error_mark_node;\n-\t    }\n-\t  if (cond != error_mark_node)\n-\t    {\n-\t      tree idx;\n-\t      tree type;\n-\t      \n-\t      cond = default_conversion (cond);\n-\t      type = TREE_TYPE (cond);\n-\t      idx = get_unwidened (cond, 0);\n-\t      /* We can't strip a conversion from a signed type to an unsigned,\n-\t\t because if we did, int_fits_type_p would do the wrong thing\n-\t\t when checking case values for being in range,\n-\t\t and it's too hard to do the right thing.  */\n-\t      if (TREE_UNSIGNED (TREE_TYPE (cond)) \n-\t\t  == TREE_UNSIGNED (TREE_TYPE (idx)))\n-\t\tcond = idx;\n-\n-\t      cond = fold (build1 (CLEANUP_POINT_EXPR, type, cond));\n-\t    }\n+\t  error (\"switch quantity not an integer\");\n+\t  cond = error_mark_node;\n+\t}\n+      if (cond != error_mark_node)\n+\t{\n+\t  tree idx;\n+\t  tree type;\n+\t  \n+\t  cond = default_conversion (cond);\n+\t  type = TREE_TYPE (cond);\n+\t  idx = get_unwidened (cond, 0);\n+\t  /* We can't strip a conversion from a signed type to an unsigned,\n+\t     because if we did, int_fits_type_p would do the wrong thing\n+\t     when checking case values for being in range,\n+\t     and it's too hard to do the right thing.  */\n+\t  if (TREE_UNSIGNED (TREE_TYPE (cond)) \n+\t      == TREE_UNSIGNED (TREE_TYPE (idx)))\n+\t    cond = idx;\n+\t  \n+\t  cond = fold (build1 (CLEANUP_POINT_EXPR, type, cond));\n \t}\n-      FINISH_COND (cond, switch_stmt, SWITCH_COND (switch_stmt));\n-    }\n-  else if (cond != error_mark_node)\n-    {\n-      emit_line_note (input_filename, lineno);\n-      c_expand_start_case (cond);\n     }\n-  else\n-    /* The code is in error, but we don't want expand_end_case to\n-       crash. */\n-    c_expand_start_case (boolean_false_node);\n-\n+  FINISH_COND (cond, switch_stmt, SWITCH_COND (switch_stmt));\n   push_switch ();\n }\n \n /* Finish the body of a switch-statement, which may be given by\n    SWITCH_STMT.  The COND to switch on is indicated.  */\n \n void\n-finish_switch_stmt (cond, switch_stmt)\n-     tree cond;\n+finish_switch_stmt (switch_stmt)\n      tree switch_stmt;\n {\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (switch_stmt, SWITCH_BODY (switch_stmt));\n-  else\n-    expand_end_case (cond);\n+  RECHAIN_STMTS (switch_stmt, SWITCH_BODY (switch_stmt));\n   pop_switch (); \n   do_poplevel ();\n   finish_stmt ();\n }\n \n-/* Finish a case-label.  */\n+/* Generate the RTL for a CASE_LABEL. */\n \n void \n-finish_case_label (low_value, high_value)\n+genrtl_case_label (low_value, high_value)\n      tree low_value;\n      tree high_value;\n {\n-  if (building_stmt_tree ())\n-    {\n-      /* Add a representation for the case label to the statement\n-\t tree.  */\n-      add_tree (build_min_nt (CASE_LABEL, low_value, high_value));\n-      /* And warn about crossing initializations, etc.  */\n-      if (!processing_template_decl)\n-\tdefine_case_label ();\n-      return;\n-    }\n-\n   do_case (low_value, high_value);\n }\n \n-/* Finish a goto-statement.  */\n+/* Finish a case-label.  */\n \n-void\n-finish_goto_stmt (destination)\n-     tree destination;\n+void \n+finish_case_label (low_value, high_value)\n+     tree low_value;\n+     tree high_value;\n {\n-  if (TREE_CODE (destination) == IDENTIFIER_NODE)\n-    destination = lookup_label (destination);\n-\n-  /* We warn about unused labels with -Wunused.  That means we have to\n-     mark the used labels as used.  */\n-  if (TREE_CODE (destination) == LABEL_DECL)\n-    TREE_USED (destination) = 1;\n-    \n-  if (building_stmt_tree ())\n-    {\n-      if (TREE_CODE (destination) != LABEL_DECL)\n-\t/* We don't inline calls to functions with computed gotos.\n-\t   Those functions are typically up to some funny business,\n-\t   and may be depending on the labels being at particular\n-\t   addresses, or some such.  */\n-\tDECL_UNINLINABLE (current_function_decl) = 1;\n+  /* Add a representation for the case label to the statement\n+     tree.  */\n+  add_tree (build_min_nt (CASE_LABEL, low_value, high_value));\n+  /* And warn about crossing initializations, etc.  */\n+  if (!processing_template_decl)\n+    define_case_label ();\n+}\n \n-      check_goto (destination);\n+/* Generate the RTL for T, which is a TRY_BLOCK. */\n \n-      add_tree (build_min_nt (GOTO_STMT, destination));\n+void genrtl_try_block (t)\n+     tree t;\n+{\n+  if (CLEANUP_P (t))\n+    {\n+      expand_eh_region_start ();\n+      expand_stmt (TRY_STMTS (t));\n+      expand_eh_region_end (protect_with_terminate (TRY_HANDLERS (t)));\n     }\n   else\n     {\n-      emit_line_note (input_filename, lineno);\n+      if (FN_TRY_BLOCK_P (t)) {\n+\tif (! current_function_parms_stored)\n+\t  store_parm_decls ();\n+\texpand_start_early_try_stmts ();\n+      }\n+      else {\n+\temit_line_note (input_filename, lineno);\n+\texpand_start_try_stmts ();\n+      }\n+\n+      expand_stmt (TRY_STMTS (t));\n \n-      if (TREE_CODE (destination) == LABEL_DECL)\n+      if (FN_TRY_BLOCK_P (t))\n \t{\n-\t  label_rtx (destination);\n-\t  expand_goto (destination); \n+\t  end_protect_partials ();\n+\t  expand_start_all_catch ();\n+\t  in_function_try_handler = 1;\n+\t  expand_stmt (TRY_HANDLERS (t));\n+\t  in_function_try_handler = 0;\n+\t  expand_end_all_catch ();\n+\t}\n+      else \n+\t{\n+\t  expand_start_all_catch ();  \n+\t  expand_stmt (TRY_HANDLERS (t));\n+\t  expand_end_all_catch ();\n \t}\n-      else\n-\texpand_computed_goto (destination);\n     }\n }\n \n@@ -728,41 +965,20 @@ finish_goto_stmt (destination)\n tree\n begin_try_block ()\n {\n-  if (building_stmt_tree ())\n-    {\n-      tree r = build_min_nt (TRY_BLOCK, NULL_TREE,\n-\t\t\t     NULL_TREE);\n-      add_tree (r);\n-      return r;\n-    }\n-  else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      expand_start_try_stmts ();\n-      return NULL_TREE;\n-    }\n+  tree r = build_min_nt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n+  add_tree (r);\n+  return r;\n }\n \n /* Likewise, for a function-try-block.  */\n \n tree\n begin_function_try_block ()\n {\n-  if (building_stmt_tree ())\n-    {\n-      tree r = build_min_nt (TRY_BLOCK, NULL_TREE,\n-\t\t\t     NULL_TREE);\n-      FN_TRY_BLOCK_P (r) = 1;\n-      add_tree (r);\n-      return r;\n-    }\n-  else\n-    {\n-      if (! current_function_parms_stored)\n-\tstore_parm_decls ();\n-      expand_start_early_try_stmts ();\n-      return NULL_TREE;\n-    }\n+  tree r = build_min_nt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n+  FN_TRY_BLOCK_P (r) = 1;\n+  add_tree (r);\n+  return r;\n }\n \n /* Finish a try-block, which may be given by TRY_BLOCK.  */\n@@ -771,10 +987,7 @@ void\n finish_try_block (try_block)\n      tree try_block;\n {\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n-  else\n-    expand_start_all_catch ();  \n+  RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n }\n \n /* Finish the body of a cleanup try-block, which may be given by\n@@ -784,8 +997,7 @@ void\n finish_cleanup_try_block (try_block)\n      tree try_block;\n {\n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+  RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n }\n \n /* Finish an implicitly generated try-block, with a cleanup is given\n@@ -796,13 +1008,8 @@ finish_cleanup (cleanup, try_block)\n      tree cleanup;\n      tree try_block;\n {\n-  if (building_stmt_tree ()) \n-    {\n-      TRY_HANDLERS (try_block) = cleanup;\n-      CLEANUP_P (try_block) = 1;\n-    }\n-  else\n-    expand_eh_region_end (protect_with_terminate (cleanup));\n+  TRY_HANDLERS (try_block) = cleanup;\n+  CLEANUP_P (try_block) = 1;\n }\n \n /* Likewise, for a function-try-block.  */\n@@ -811,25 +1018,16 @@ void\n finish_function_try_block (try_block)\n      tree try_block; \n {\n-  if (building_stmt_tree ())\n+  if (TREE_CHAIN (try_block) \n+      && TREE_CODE (TREE_CHAIN (try_block)) == CTOR_INITIALIZER)\n     {\n-      if (TREE_CHAIN (try_block) \n-\t  && TREE_CODE (TREE_CHAIN (try_block)) == CTOR_INITIALIZER)\n-\t{\n-\t  /* Chain the compound statement after the CTOR_INITIALIZER.  */\n-\t  TREE_CHAIN (TREE_CHAIN (try_block)) = last_tree;\n-\t  /* And make the CTOR_INITIALIZER the body of the try-block.  */\n-\t  RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n-\t}\n-      else\n-\tRECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+      /* Chain the compound statement after the CTOR_INITIALIZER.  */\n+      TREE_CHAIN (TREE_CHAIN (try_block)) = last_tree;\n+      /* And make the CTOR_INITIALIZER the body of the try-block.  */\n+      RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n     }\n   else\n-    {\n-      end_protect_partials ();\n-      expand_start_all_catch ();\n-    }\n-\n+    RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n   in_function_try_handler = 1;\n }\n \n@@ -840,13 +1038,8 @@ void\n finish_handler_sequence (try_block)\n      tree try_block;\n {\n-  if (building_stmt_tree ())\n-    {\n-      RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n-      check_handlers (TRY_HANDLERS (try_block));\n-    }\n-  else\n-    expand_end_all_catch ();\n+  RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+  check_handlers (TRY_HANDLERS (try_block));\n }\n \n /* Likewise, for a function-try-block.  */\n@@ -856,14 +1049,28 @@ finish_function_handler_sequence (try_block)\n      tree try_block;\n {\n   in_function_try_handler = 0;\n+  RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+  check_handlers (TRY_HANDLERS (try_block));\n+}\n+\n+/* Generate the RTL for T, which is a HANDLER. */\n \n-  if (building_stmt_tree ())\n+void\n+genrtl_handler (t)\n+     tree t;\n+{\n+  genrtl_do_pushlevel ();\n+  expand_stmt (HANDLER_BODY (t));\n+  if (!processing_template_decl)\n     {\n-      RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n-      check_handlers (TRY_HANDLERS (try_block));\n+      /* Fall to outside the try statement when done executing\n+\t handler and we fall off end of handler.  This is jump\n+\t Lresume in the documentation.  */\n+      expand_goto (top_label_entry (&caught_return_label_stack));\n+      end_catch_handler ();\n     }\n-  else\n-    expand_end_all_catch ();\n+\n+  genrtl_do_poplevel ();  \n }\n \n /* Begin a handler.  Returns a HANDLER if appropriate.  */\n@@ -872,17 +1079,9 @@ tree\n begin_handler ()\n {\n   tree r;\n-\n-  if (building_stmt_tree ())\n-    {\n-      r = build_min_nt (HANDLER, NULL_TREE, NULL_TREE);\n-      add_tree (r);\n-    }\n-  else\n-    r = NULL_TREE;\n-\n+  r = build_min_nt (HANDLER, NULL_TREE, NULL_TREE);\n+  add_tree (r);\n   do_pushlevel ();\n-\n   return r;\n }\n \n@@ -907,56 +1106,135 @@ finish_handler_parms (decl, handler)\n \t  RECHAIN_STMTS (handler, HANDLER_PARMS (handler));\n \t}\n     }\n-  else if (building_stmt_tree ())\n+  else\n     blocks = expand_start_catch_block (decl);\n \n-  if (decl)\n-    TREE_TYPE (handler) = TREE_TYPE (decl);\n+  if (decl)\n+    TREE_TYPE (handler) = TREE_TYPE (decl);\n+\n+  return blocks;\n+}\n+\n+/* Generate the RTL for a CATCH_BLOCK. */\n+\n+void\n+genrtl_catch_block (type)\n+     tree type;\n+{\n+  start_catch_handler (type);\n+}\n+\n+/* Note the beginning of a handler for TYPE.  This function is called\n+   at the point to which control should be transferred when an\n+   appropriately-typed exception is thrown.  */\n+\n+void\n+begin_catch_block (type)\n+     tree type;\n+{\n+  add_tree (build (START_CATCH_STMT, type));\n+}\n+\n+/* Finish a handler, which may be given by HANDLER.  The BLOCKs are\n+   the return value from the matching call to finish_handler_parms.  */\n+\n+void\n+finish_handler (blocks, handler)\n+     tree blocks;\n+     tree handler;\n+{\n+  if (!processing_template_decl)\n+      expand_end_catch_block (blocks);\n+  do_poplevel ();\n+  RECHAIN_STMTS (handler, HANDLER_BODY (handler));\n+}\n+\n+/* Generate the RTL for T, which is a CTOR_STMT. */\n+\n+void\n+genrtl_ctor_stmt (t)\n+     tree t;\n+{\n+  if (CTOR_BEGIN_P (t))\n+    begin_protect_partials ();\n+  else\n+    /* After this point, any exceptions will cause the\n+       destructor to be executed, so we no longer need to worry\n+       about destroying the various subobjects ourselves.  */\n+    end_protect_partials ();\n+}\n+\n+/* Generate the RTL for the start of a COMPOUND_STMT. */\n+\n+tree genrtl_begin_compound_stmt (has_no_scope)\n+     int has_no_scope;\n+{\n+  tree r; \n+  int is_try = 0;\n+\n+  r = NULL_TREE;\n+\n+  last_expr_type = NULL_TREE;\n+\n+  if (!has_no_scope)\n+    {\n+      genrtl_do_pushlevel ();\n+      if (is_try)\n+\tnote_level_for_eh ();\n+    }\n+  else\n+    /* Normally, we try hard to keep the BLOCK for a\n+       statement-expression.  But, if it's a statement-expression with\n+       a scopeless block, there's nothing to keep, and we don't want\n+       to accidentally keep a block *inside* the scopeless block.  */ \n+    keep_next_level (0);\n+\n+  /* If this is the outermost block of the function, declare the\n+     variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n+  if (cfun\n+      && !current_function_name_declared \n+      && !has_no_scope)\n+    {\n+      current_function_name_declared = 1;\n+      declare_function_name ();\n+    }\n \n-  return blocks;\n+  return r;\n }\n \n-/* Note the beginning of a handler for TYPE.  This function is called\n-   at the point to which control should be transferred when an\n-   appropriately-typed exception is thrown.  */\n+/* Generate the RTL for the end of a COMPOUND_STMT. */\n \n-void\n-begin_catch_block (type)\n-     tree type;\n+tree genrtl_finish_compound_stmt (has_no_scope)\n+     int has_no_scope;\n {\n-  if (building_stmt_tree ())\n-    add_tree (build (START_CATCH_STMT, type));\n-  else\n-    start_catch_handler (type);\n-}\n+  tree r;\n+  tree t;\n \n-/* Finish a handler, which may be given by HANDLER.  The BLOCKs are\n-   the return value from the matching call to finish_handler_parms.  */\n+  if (!has_no_scope)\n+    r = genrtl_do_poplevel ();\n+  else\n+    r = NULL_TREE;\n \n-void\n-finish_handler (blocks, handler)\n-     tree blocks;\n-     tree handler;\n-{\n-  if (!processing_template_decl)\n-    {\n-      if (building_stmt_tree ())\n-\texpand_end_catch_block (blocks);\n+  /* When we call finish_stmt we will lose LAST_EXPR_TYPE.  But, since\n+     the precise purpose of that variable is store the type of the\n+     last expression statement within the last compound statement, we\n+     preserve the value.  */\n+  t = last_expr_type;\n+  finish_stmt ();\n+  last_expr_type = t;\n \n-      if (!building_stmt_tree ())\n-\t{\n-\t  /* Fall to outside the try statement when done executing\n-\t     handler and we fall off end of handler.  This is jump\n-\t     Lresume in the documentation.  */\n-\t  expand_goto (top_label_entry (&caught_return_label_stack));\n-\t  end_catch_handler ();\n-\t}\n-    }\n+  return r;\n+}\n \n-  do_poplevel ();\n+/* Generate the RTL for T, which is a COMPOUND_STMT. */\n \n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (handler, HANDLER_BODY (handler));\n+tree \n+genrtl_compound_stmt (t)\n+    tree t;\n+{\n+  genrtl_begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+  expand_stmt (COMPOUND_BODY (t));\n+  return (genrtl_finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t)));\n }\n \n /* Begin a compound-statement.  If HAS_NO_SCOPE is non-zero, the\n@@ -970,19 +1248,14 @@ begin_compound_stmt (has_no_scope)\n   tree r; \n   int is_try = 0;\n \n-  if (building_stmt_tree ())\n-    {\n-      r = build_min_nt (COMPOUND_STMT, NULL_TREE);\n-      /* Mark that this block is for a try so that we can yell at\n-         people trying to jump in.  */\n-      if (last_tree && TREE_CODE (last_tree) == TRY_BLOCK)\n-\tis_try = 1;\n-      add_tree (r);\n-      if (has_no_scope)\n-\tCOMPOUND_STMT_NO_SCOPE (r) = 1;\n-    }\n-  else\n-    r = NULL_TREE;\n+  r = build_min_nt (COMPOUND_STMT, NULL_TREE);\n+\n+  if (last_tree && TREE_CODE (last_tree) == TRY_BLOCK)\n+    is_try = 1;\n+\n+  add_tree (r);\n+  if (has_no_scope)\n+    COMPOUND_STMT_NO_SCOPE (r) = 1;\n \n   last_expr_type = NULL_TREE;\n \n@@ -1012,7 +1285,6 @@ begin_compound_stmt (has_no_scope)\n   return r;\n }\n \n-\n /* Finish a compound-statement, which may be given by COMPOUND_STMT.\n    If HAS_NO_SCOPE is non-zero, the compound statement does not define\n    a scope.  */\n@@ -1030,8 +1302,7 @@ finish_compound_stmt (has_no_scope, compound_stmt)\n   else\n     r = NULL_TREE;\n \n-  if (building_stmt_tree ())\n-    RECHAIN_STMTS (compound_stmt, COMPOUND_BODY (compound_stmt));\n+  RECHAIN_STMTS (compound_stmt, COMPOUND_BODY (compound_stmt));\n \n   /* When we call finish_stmt we will lose LAST_EXPR_TYPE.  But, since\n      the precise purpose of that variable is store the type of the\n@@ -1044,12 +1315,10 @@ finish_compound_stmt (has_no_scope, compound_stmt)\n   return r;\n }\n \n-/* Finish an asm-statement, whose components are a CV_QUALIFIER, a\n-   STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some\n-   CLOBBERS.  */\n+/* Generate the RTL for an ASM_STMT. */\n \n void\n-finish_asm_stmt (cv_qualifier, string, output_operands,\n+genrtl_asm_stmt (cv_qualifier, string, output_operands,\n \t\t input_operands, clobbers)\n      tree cv_qualifier;\n      tree string;\n@@ -1068,35 +1337,56 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n       cv_qualifier = NULL_TREE;\n     }\n \n-  if (building_stmt_tree ())\n+  emit_line_note (input_filename, lineno);\n+  if (output_operands != NULL_TREE || input_operands != NULL_TREE\n+      || clobbers != NULL_TREE)\n     {\n-      tree r = build_min_nt (ASM_STMT, cv_qualifier, string,\n-\t\t\t     output_operands, input_operands,\n-\t\t\t     clobbers);\n-      add_tree (r);\n+      tree t;\n+      \n+      for (t = input_operands; t; t = TREE_CHAIN (t))\n+\tTREE_VALUE (t) = decay_conversion (TREE_VALUE (t));\n+      \n+      c_expand_asm_operands (string, output_operands,\n+\t\t\t     input_operands, \n+\t\t\t     clobbers,\n+\t\t\t     cv_qualifier != NULL_TREE,\n+\t\t\t     input_filename, lineno);\n     }\n   else\n-    {\n-      emit_line_note (input_filename, lineno);\n-      if (output_operands != NULL_TREE || input_operands != NULL_TREE\n-\t    || clobbers != NULL_TREE)\n-\t{\n-\t  tree t;\n+    expand_asm (string);\n+  \n+  finish_stmt ();\n+}\n \n-\t  for (t = input_operands; t; t = TREE_CHAIN (t))\n-\t    TREE_VALUE (t) = decay_conversion (TREE_VALUE (t));\n+/* Finish an asm-statement, whose components are a CV_QUALIFIER, a\n+   STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some\n+   CLOBBERS.  */\n \n-\t  c_expand_asm_operands (string, output_operands,\n-\t\t\t\t input_operands, \n-\t\t\t\t clobbers,\n-\t\t\t\t cv_qualifier != NULL_TREE,\n-\t\t\t\t input_filename, lineno);\n-\t}\n-      else\n-\texpand_asm (string);\n-      \n-      finish_stmt ();\n+void\n+finish_asm_stmt (cv_qualifier, string, output_operands,\n+\t\t input_operands, clobbers)\n+     tree cv_qualifier;\n+     tree string;\n+     tree output_operands;\n+     tree input_operands;\n+     tree clobbers;\n+{\n+  tree r;\n+  if (TREE_CHAIN (string))\n+    string = combine_strings (string);\n+\n+  if (cv_qualifier != NULL_TREE\n+      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n+    {\n+      cp_warning (\"%s qualifier ignored on asm\",\n+\t\t  IDENTIFIER_POINTER (cv_qualifier));\n+      cv_qualifier = NULL_TREE;\n     }\n+\n+  r = build_min_nt (ASM_STMT, cv_qualifier, string,\n+\t\t    output_operands, input_operands,\n+\t\t    clobbers);\n+  add_tree (r);\n }\n \n /* Finish a label with the indicated NAME.  */\n@@ -1106,11 +1396,7 @@ finish_label_stmt (name)\n      tree name;\n {\n   tree decl = define_label (input_filename, lineno, name);\n-\n-  if (building_stmt_tree ())\n-    add_tree (build_min_nt (LABEL_STMT, decl));\n-  else if (decl)\n-    expand_label (decl);\n+  add_tree (build_min_nt (LABEL_STMT, decl));\n }\n \n /* Finish a series of declarations for local labels.  G++ allows users\n@@ -1122,8 +1408,7 @@ finish_label_decl (name)\n      tree name;\n {\n   tree decl = declare_local_label (name);\n-  if (building_stmt_tree ())\n-    add_decl_stmt (decl);\n+  add_decl_stmt (decl);\n }\n \n /* Create a declaration statement for the declaration given by the\n@@ -1137,7 +1422,16 @@ add_decl_stmt (decl)\n \n   /* We need the type to last until instantiation time.  */\n   decl_stmt = build_min_nt (DECL_STMT, decl);\n-  add_tree (decl_stmt);\n+  add_tree (decl_stmt); \n+}\n+\n+/* Generate the RTL for a SUBOBJECT. */\n+\n+void \n+genrtl_subobject (cleanup)\n+     tree cleanup;\n+{\n+  add_partial_entry (cleanup);\n }\n \n /* We're in a constructor, and have just constructed a a subobject of\n@@ -1148,13 +1442,19 @@ void\n finish_subobject (cleanup)\n      tree cleanup;\n {\n-  if (building_stmt_tree ())\n-    {\n-      tree r = build_min_nt (SUBOBJECT, cleanup);\n-      add_tree (r);\n-    }\n-  else\n-    add_partial_entry (cleanup);\n+  tree r = build_min_nt (SUBOBJECT, cleanup);\n+  add_tree (r);\n+}\n+\n+/* Generate the RTL for a DECL_CLEANUP. */\n+\n+void \n+genrtl_decl_cleanup (decl, cleanup)\n+     tree decl;\n+     tree cleanup;\n+{\n+  if (!decl || (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node))\n+    expand_decl_cleanup (decl, cleanup);\n }\n \n /* When DECL goes out of scope, make sure that CLEANUP is executed.  */\n@@ -1164,11 +1464,61 @@ finish_decl_cleanup (decl, cleanup)\n      tree decl;\n      tree cleanup;\n {\n-  if (building_stmt_tree ())\n-    add_tree (build_min_nt (CLEANUP_STMT, decl, cleanup));\n-  else if (!decl \n-\t   || (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node))\n-    expand_decl_cleanup (decl, cleanup);\n+  add_tree (build_min_nt (CLEANUP_STMT, decl, cleanup));\n+}\n+\n+/* Generate the RTL for a RETURN_INIT. */\n+\n+void\n+genrtl_named_return_value (return_id, init)\n+     tree return_id, init;\n+{\n+  tree decl;\n+  /* Clear this out so that finish_named_return_value can set it\n+     again.  */\n+  DECL_NAME (DECL_RESULT (current_function_decl)) = NULL_TREE;\n+\n+  decl = DECL_RESULT (current_function_decl);\n+  if (pedantic)\n+    /* Give this error as many times as there are occurrences,\n+       so that users can use Emacs compilation buffers to find\n+       and fix all such places.  */\n+    pedwarn (\"ISO C++ does not permit named return values\");\n+\n+  if (return_id != NULL_TREE)\n+    {\n+      if (DECL_NAME (decl) == NULL_TREE)\n+\t{\n+\t  DECL_NAME (decl) = return_id;\n+\t  DECL_ASSEMBLER_NAME (decl) = return_id;\n+\t}\n+      else\n+\t{\n+\t  cp_error (\"return identifier `%D' already in place\", return_id);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Can't let this happen for constructors.  */\n+  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+    {\n+      error (\"can't redefine default return value for constructors\");\n+      return;\n+    }\n+\n+  /* If we have a named return value, put that in our scope as well.  */\n+  if (DECL_NAME (decl) != NULL_TREE)\n+    {\n+      /* Let `cp_finish_decl' know that this initializer is ok.  */\n+      DECL_INITIAL (decl) = init;\n+      cp_finish_decl (decl, init, NULL_TREE, 0);\n+      store_return_init (decl);\n+    }\n+\n+  /* Don't use tree-inlining for functions with named return values.\n+     That doesn't work properly because we don't do any translation of\n+     the RETURN_INITs when they are copied.  */\n+  DECL_UNINLINABLE (current_function_decl) = 1;\n }\n \n /* Bind a name and initialization to the return value of\n@@ -1214,14 +1564,7 @@ finish_named_return_value (return_id, init)\n       DECL_INITIAL (decl) = init;\n       if (doing_semantic_analysis_p ())\n \tpushdecl (decl);\n-\n-      if (building_stmt_tree ())\n-\tadd_tree (build_min_nt (RETURN_INIT, return_id, init));\n-      else\n-\t{\n-\t  cp_finish_decl (decl, init, NULL_TREE, 0);\n-\t  store_return_init (decl);\n-\t}\n+      add_tree (build_min_nt (RETURN_INIT, return_id, init));\n     }\n \n   /* Don't use tree-inlining for functions with named return values.\n@@ -1375,6 +1718,7 @@ setup_vtbl_ptr (member_init_list, base_init_list)\n   vtbls_set_up_p = 1;\n }\n \n+\n /* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n    whether this statements opens or closes a scope.  PARTIAL_P is true\n    for a partial scope, i.e, the scope that begins after a label when\n@@ -1418,55 +1762,6 @@ add_scope_stmt (begin_p, partial_p)\n   return top;\n }\n \n-/* Begin a new scope.  */\n-\n-void\n-do_pushlevel ()\n-{\n-  if (!building_stmt_tree ())\n-    {\n-      emit_line_note (input_filename, lineno);\n-      clear_last_expr ();\n-    }\n-  if (stmts_are_full_exprs_p)\n-    {\n-      pushlevel (0);\n-      if (!building_stmt_tree ()\n-\t  && !cfun->x_whole_function_mode_p)\n-\tmy_friendly_abort (19991129);\n-\n-      if (building_stmt_tree () && !processing_template_decl)\n-\tadd_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n-    }\n-}\n-\n-/* Finish a scope.  */\n-\n-tree\n-do_poplevel ()\n-{\n-  tree block = NULL_TREE;\n-\n-  if (stmts_are_full_exprs_p)\n-    {\n-      tree scope_stmts;\n-\n-      if (building_stmt_tree () && !processing_template_decl)\n-\tscope_stmts = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-      else\n-\tscope_stmts = NULL_TREE;\n-\n-      block = poplevel (kept_level_p (), 1, 0);\n-      if (block && !processing_template_decl)\n-\t{\n-\t  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n-\t  SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n-\t}\n-    }\n-\n-  return block;\n-}\n-\n /* Finish a parenthesized expression EXPR.  */\n \n tree\n@@ -1480,6 +1775,21 @@ finish_parenthesized_expr (expr)\n   return expr;\n }\n \n+/* The last_tree will be NULL_TREE when entering this function. Unlike\n+   the other genrtl functions, in this function, that state can change\n+   hence the check at the end as in the original version of\n+   begin_stmt_expr. Generate the RTL for the start of a STMT_EXPR. */\n+tree\n+genrtl_begin_stmt_expr ()\n+{\n+  if (! cfun && !last_tree)\n+    begin_stmt_tree (&scope_chain->x_saved_tree);\n+\n+  keep_next_level (1);\n+  \n+  return (last_tree != NULL_TREE) ? last_tree : expand_start_stmt_expr(); \n+}\n+\n /* Begin a statement-expression.  The value returned must be passed to\n    finish_stmt_expr.  */\n \n@@ -1497,7 +1807,25 @@ begin_stmt_expr ()\n      statement will be chained onto the tree structure, starting at\n      last_tree.  We return last_tree so that we can later unhook the\n      compound statement.  */\n-  return building_stmt_tree () ? last_tree : expand_start_stmt_expr(); \n+  return last_tree; \n+}\n+\n+/* Generate the RTL for the end of the STMT_EXPR. */\n+\n+tree \n+genrtl_finish_stmt_expr (rtl_expr)\n+     tree rtl_expr;\n+{\n+  tree result;\n+\n+  rtl_expr = expand_end_stmt_expr (rtl_expr);\n+  result = rtl_expr;\n+  \n+  if (! cfun\n+      && TREE_CHAIN (scope_chain->x_saved_tree) == NULL_TREE)\n+    finish_stmt_tree (&scope_chain->x_saved_tree);\n+\n+  return result;\n }\n \n /* Finish a statement-expression.  RTL_EXPR should be the value\n@@ -1511,25 +1839,17 @@ finish_stmt_expr (rtl_expr)\n {\n   tree result;\n \n-  if (!building_stmt_tree ())\n-    rtl_expr = expand_end_stmt_expr (rtl_expr);\n-\n-  if (building_stmt_tree ())\n-    {\n-      /* If the last thing in the statement-expression was not an\n-\t expression-statement, then it has type `void'.  */\n-      if (!last_expr_type)\n-\tlast_expr_type = void_type_node;\n-      result = build_min (STMT_EXPR, last_expr_type, last_tree);\n-      TREE_SIDE_EFFECTS (result) = 1;\n-      \n-      /* Remove the compound statement from the tree structure; it is\n-\t now saved in the STMT_EXPR.  */\n-      SET_LAST_STMT (rtl_expr);\n-      TREE_CHAIN (last_tree) = NULL_TREE;\n-    }\n-  else \n-    result = rtl_expr;\n+  /* If the last thing in the statement-expression was not an\n+     expression-statement, then it has type `void'.  */\n+  if (!last_expr_type)\n+    last_expr_type = void_type_node;\n+  result = build_min (STMT_EXPR, last_expr_type, last_tree);\n+  TREE_SIDE_EFFECTS (result) = 1;\n+  \n+  /* Remove the compound statement from the tree structure; it is\n+     now saved in the STMT_EXPR.  */\n+  SET_LAST_STMT (rtl_expr);\n+  TREE_CHAIN (last_tree) = NULL_TREE;\n \n   /* If we created a statement-tree for this statement-expression,\n      remove it now.  */ \n@@ -2449,228 +2769,96 @@ expand_stmt (t)\n       switch (TREE_CODE (t))\n \t{\n \tcase RETURN_STMT:\n-\t  finish_return_stmt (RETURN_EXPR (t));\n+\t  genrtl_return_stmt (RETURN_EXPR (t));\n \t  break;\n \n \tcase EXPR_STMT:\n-\t  finish_expr_stmt (EXPR_STMT_EXPR (t));\n+\t  genrtl_expr_stmt (EXPR_STMT_EXPR (t));\n \t  break;\n \n \tcase DECL_STMT:\n-\t  {\n-\t    tree decl;\n-\n-\t    emit_line_note (input_filename, lineno);\n-\t    decl = DECL_STMT_DECL (t);\n-\t    /* If this is a declaration for an automatic local\n-\t       variable, initialize it.  Note that we might also see a\n-\t       declaration for a namespace-scope object (declared with\n-\t       `extern').  We don't have to handle the initialization\n-\t       of those objects here; they can only be declarations,\n-\t       rather than definitions.  */\n-\t    if (TREE_CODE (decl) == VAR_DECL \n-\t\t&& !TREE_STATIC (decl)\n-\t\t&& !DECL_EXTERNAL (decl))\n-\t      {\n-\t\t/* Let the back-end know about this variable.  */\n-\t\tif (!ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n-\t\t  emit_local_var (decl);\n-\t\telse\n-\t\t  expand_anon_union_decl (decl, NULL_TREE, \n-\t\t\t\t\t  DECL_ANON_UNION_ELEMS (decl));\n-\t      }\n-\t    else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n-\t      {\n-\t\tif (DECL_ARTIFICIAL (decl) && ! TREE_USED (decl))\n-\t\t  /* Do not emit unused decls. This is not just an\n-\t\t     optimization. We really do not want to emit\n-\t\t     __PRETTY_FUNCTION__ etc, if they're never used.  */\n-\t\t  DECL_IGNORED_P (decl) = 1;\n-\t\telse\n-\t\t  make_rtl_for_local_static (decl);\n-\t      }\n-\t  }\n+\t  genrtl_decl_stmt (t);\n \t  break;\n \n \tcase CLEANUP_STMT:\n-\t  finish_decl_cleanup (CLEANUP_DECL (t), CLEANUP_EXPR (t));\n+\t  genrtl_decl_cleanup (CLEANUP_DECL (t), CLEANUP_EXPR (t));\n \t  break;\n \n \tcase START_CATCH_STMT:\n-\t  begin_catch_block (TREE_TYPE (t));\n+\t  genrtl_catch_block (TREE_TYPE (t));\n \t  break;\n \n \tcase CTOR_STMT:\n-\t  if (CTOR_BEGIN_P (t))\n-\t    begin_protect_partials ();\n-\t  else\n-\t    /* After this point, any exceptions will cause the\n-\t       destructor to be executed, so we no longer need to worry\n-\t       about destroying the various subobjects ourselves.  */\n-\t    end_protect_partials ();\n+\t  genrtl_ctor_stmt (t);\n \t  break;\n \n \tcase FOR_STMT:\n-\t  {\n-\t    tree tmp;\n-\n-\t    begin_for_stmt ();\n-\t    expand_stmt (FOR_INIT_STMT (t));\n-\t    finish_for_init_stmt (NULL_TREE);\n-\t    finish_for_cond (expand_cond (FOR_COND (t)), NULL_TREE);\n-\t    tmp = FOR_EXPR (t);\n-\t    finish_for_expr (tmp, NULL_TREE);\n-\t    expand_stmt (FOR_BODY (t));\n-\t    finish_for_stmt (tmp, NULL_TREE);\n-\t  }\n+\t  genrtl_for_stmt (t);\n \t  break;\n \n \tcase WHILE_STMT:\n-\t  {\n-\t    begin_while_stmt ();\n-\t    finish_while_stmt_cond (expand_cond (WHILE_COND (t)), NULL_TREE);\n-\t    expand_stmt (WHILE_BODY (t));\n-\t    finish_while_stmt (NULL_TREE);\n-\t  }\n+\t  genrtl_while_stmt (t);\n \t  break;\n \n \tcase DO_STMT:\n-\t  {\n-\t    begin_do_stmt ();\n-\t    expand_stmt (DO_BODY (t));\n-\t    finish_do_body (NULL_TREE);\n-\t    finish_do_stmt (DO_COND (t), NULL_TREE);\n-\t  }\n+\t  genrtl_do_stmt (t);\n \t  break;\n \n \tcase IF_STMT:\n-\t  begin_if_stmt ();\n-\t  finish_if_stmt_cond (expand_cond (IF_COND (t)), NULL_TREE);\n-\t  if (THEN_CLAUSE (t))\n-\t    {\n-\t      expand_stmt (THEN_CLAUSE (t));\n-\t      finish_then_clause (NULL_TREE);\n-\t    }\n-\t  if (ELSE_CLAUSE (t))\n-\t    {\n-\t      begin_else_clause ();\n-\t      expand_stmt (ELSE_CLAUSE (t));\n-\t      finish_else_clause (NULL_TREE);\n-\t    }\n-\t  finish_if_stmt ();\n+\t  genrtl_if_stmt (t);\n \t  break;\n \n \tcase COMPOUND_STMT:\n-\t  begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n-\t  expand_stmt (COMPOUND_BODY (t));\n-\t  rval = finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n-\t\t\t\t       NULL_TREE);\n+\t  rval = genrtl_compound_stmt (t);\n \t  break;\n \n \tcase BREAK_STMT:\n-\t  finish_break_stmt ();\n+\t  genrtl_break_stmt ();\n \t  break;\n \n \tcase CONTINUE_STMT:\n-\t  finish_continue_stmt ();\n+\t  genrtl_continue_stmt ();\n \t  break;\n \n \tcase SWITCH_STMT:\n-\t  {\n-\t    tree cond;\n-\n-\t    begin_switch_stmt ();\n-\t    cond = expand_cond (SWITCH_COND (t));\n-\t    finish_switch_cond (cond, NULL_TREE);\n-\t    expand_stmt (SWITCH_BODY (t));\n-\t    finish_switch_stmt (cond, NULL_TREE);\n-\t  }\n+\t  genrtl_switch_stmt (t);\n \t  break;\n \n \tcase CASE_LABEL:\n-\t  finish_case_label (CASE_LOW (t), CASE_HIGH (t));\n+\t  genrtl_case_label (CASE_LOW (t), CASE_HIGH (t));\n \t  break;\n \n \tcase LABEL_STMT:\n \t  expand_label (LABEL_STMT_LABEL (t));\n \t  break;\n \n \tcase GOTO_STMT:\n-\t  finish_goto_stmt (GOTO_DESTINATION (t));\n+\t  genrtl_goto_stmt (GOTO_DESTINATION (t));\n \t  break;\n \n \tcase ASM_STMT:\n-\t  finish_asm_stmt (ASM_CV_QUAL (t), ASM_STRING (t), ASM_OUTPUTS\n-\t\t\t   (t), ASM_INPUTS (t), ASM_CLOBBERS (t));\n+\t  genrtl_asm_stmt (ASM_CV_QUAL (t), ASM_STRING (t),\n+\t\t\t   ASM_OUTPUTS (t), ASM_INPUTS (t), ASM_CLOBBERS (t));\n \t  break;\n \n \tcase TRY_BLOCK:\n-\t  if (CLEANUP_P (t))\n-\t    {\n-\t      expand_eh_region_start ();\n-\t      expand_stmt (TRY_STMTS (t));\n-\t      finish_cleanup_try_block (NULL_TREE);\n-\t      finish_cleanup (TRY_HANDLERS (t), NULL_TREE);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (FN_TRY_BLOCK_P (t))\n-\t\tbegin_function_try_block ();\n-\t      else\n-\t\tbegin_try_block ();\n-\n-\t      expand_stmt (TRY_STMTS (t));\n-\n-\t      if (FN_TRY_BLOCK_P (t))\n-\t\t{\n-\t\t  finish_function_try_block (NULL_TREE);\n-\t\t  expand_stmt (TRY_HANDLERS (t));\n-\t\t  finish_function_handler_sequence (NULL_TREE);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  finish_try_block (NULL_TREE);\n-\t\t  expand_stmt (TRY_HANDLERS (t));\n-\t\t  finish_handler_sequence (NULL_TREE);\n-\t\t}\n-\t    }\n+\t  genrtl_try_block (t);\n \t  break;\n \n \tcase HANDLER:\n-\t  begin_handler ();\n-\t  expand_stmt (HANDLER_BODY (t));\n-\t  finish_handler (NULL_TREE, NULL_TREE);\n+\t  genrtl_handler (t);\n \t  break;\n \n \tcase SUBOBJECT:\n-\t  finish_subobject (SUBOBJECT_CLEANUP (t));\n+\t  genrtl_subobject (SUBOBJECT_CLEANUP (t));\n \t  break;\n \n \tcase SCOPE_STMT:\n-\t  if (!SCOPE_NO_CLEANUPS_P (t))\n-\t    {\n-\t      if (SCOPE_BEGIN_P (t))\n-\t\texpand_start_bindings_and_block (2 * SCOPE_NULLIFIED_P (t),\n-\t\t\t\t\t\t SCOPE_STMT_BLOCK (t));\n-\t      else if (SCOPE_END_P (t))\n-\t\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n-\t    }\n-\t  else if (!SCOPE_NULLIFIED_P (t))\n-\t    {\n-\t      rtx note = emit_note (NULL,\n-\t\t\t\t    (SCOPE_BEGIN_P (t) \n-\t\t\t\t     ? NOTE_INSN_BLOCK_BEG\n-\t\t\t\t     : NOTE_INSN_BLOCK_END));\n-\t      NOTE_BLOCK (note) = SCOPE_STMT_BLOCK (t);\n-\t    }\n-\t      \n+\t  genrtl_scope_stmt (t);\n \t  break;\n \n \tcase RETURN_INIT:\n-\t  /* Clear this out so that finish_named_return_value can set it\n-\t     again.  */\n-\t  DECL_NAME (DECL_RESULT (current_function_decl)) = NULL_TREE;\n-\t  finish_named_return_value (TREE_OPERAND (t, 0), \n+\t  genrtl_named_return_value (TREE_OPERAND (t, 0), \n \t\t\t\t     TREE_OPERAND (t, 1));\n \t  break;\n "}]}