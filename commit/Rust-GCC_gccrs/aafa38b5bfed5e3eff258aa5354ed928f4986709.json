{"sha": "aafa38b5bfed5e3eff258aa5354ed928f4986709", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFmYTM4YjViZmVkNWUzZWZmMjU4YWE1MzU0ZWQ5MjhmNDk4NjcwOQ==", "commit": {"author": {"name": "Jiufu Guo", "email": "guojiufu@linux.ibm.com", "date": "2021-07-15T09:21:00Z"}, "committer": {"name": "Jiufu Guo", "email": "guojiufu@linux.ibm.com", "date": "2021-07-29T00:42:56Z"}, "message": "Use preferred mode for doloop IV [PR61837]\n\nCurrently, doloop.xx variable is using the type as niter which may be\nshorter than word size.  For some targets, it would be better to use\nword size type.  For example, on 64bit system, to access 32bit value,\nsubreg maybe used.  Then using 64bit type maybe better for niter if\nit can be present in both 32bit and 64bit.\n\nThis patch add target hook to query preferred mode for doloop IV,\nand update mode accordingly.\n\ngcc/ChangeLog:\n\n2021-07-29  Jiufu Guo  <guojiufu@linux.ibm.com>\n\n\tPR target/61837\n\t* config/rs6000/rs6000.c (TARGET_PREFERRED_DOLOOP_MODE): New hook.\n\t(rs6000_preferred_doloop_mode): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in: Add hook preferred_doloop_mode.\n\t* target.def (preferred_doloop_mode): New hook.\n\t* targhooks.c (default_preferred_doloop_mode): New hook.\n\t* targhooks.h (default_preferred_doloop_mode): New hook.\n\t* tree-ssa-loop-ivopts.c (compute_doloop_base_on_mode): New function.\n\t(add_iv_candidate_for_doloop): Call targetm.preferred_doloop_mode\n\tand compute_doloop_base_on_mode.\n\ngcc/testsuite/ChangeLog:\n\n2021-07-29  Jiufu Guo  <guojiufu@linux.ibm.com>\n\n\tPR target/61837\n\t* gcc.target/powerpc/pr61837.c: New test.", "tree": {"sha": "aa79d882438826d124bc09c9c61168a939e15f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa79d882438826d124bc09c9c61168a939e15f8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aafa38b5bfed5e3eff258aa5354ed928f4986709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aafa38b5bfed5e3eff258aa5354ed928f4986709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aafa38b5bfed5e3eff258aa5354ed928f4986709", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aafa38b5bfed5e3eff258aa5354ed928f4986709/comments", "author": null, "committer": null, "parents": [{"sha": "3916902930769d5172c0feaa5f535ca7b2bafdf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3916902930769d5172c0feaa5f535ca7b2bafdf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3916902930769d5172c0feaa5f535ca7b2bafdf7"}], "stats": {"total": 133, "additions": 131, "deletions": 2}, "files": [{"sha": "2de5a96e1b6cbfb9b8cc3a5b3356e58d62e18e1f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -1700,6 +1700,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_DOLOOP_COST_FOR_ADDRESS\n #define TARGET_DOLOOP_COST_FOR_ADDRESS 1000000000\n \n+#undef TARGET_PREFERRED_DOLOOP_MODE\n+#define TARGET_PREFERRED_DOLOOP_MODE rs6000_preferred_doloop_mode\n+\n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV rs6000_atomic_assign_expand_fenv\n \n@@ -27935,6 +27938,14 @@ rs6000_predict_doloop_p (struct loop *loop)\n   return true;\n }\n \n+/* Implement TARGET_PREFERRED_DOLOOP_MODE. */\n+\n+static machine_mode\n+rs6000_preferred_doloop_mode (machine_mode)\n+{\n+  return word_mode;\n+}\n+\n /* Implement TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P.  */\n \n static bool"}, {"sha": "d5f8852cc709fd6720d1eca827f373526767d755", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -12011,6 +12011,15 @@ By default, the RTL loop optimizer does not use a present doloop pattern for\n loops containing function calls or branch on table instructions.\n @end deftypefn\n \n+@deftypefn {Target Hook} machine_mode TARGET_PREFERRED_DOLOOP_MODE (machine_mode @var{mode})\n+This hook takes a @var{mode} for a doloop IV, where @code{mode} is the\n+original mode for the operation.  If the target prefers an alternate\n+@code{mode} for the operation, then this hook should return that mode;\n+otherwise the original @code{mode} should be returned.  For example, on a\n+64-bit target, @code{DImode} might be preferred over @code{SImode}.  Both the\n+original and the returned modes should be @code{MODE_INT}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_LEGITIMATE_COMBINED_INSN (rtx_insn *@var{insn})\n Take an instruction in @var{insn} and return @code{false} if the instruction\n is not appropriate as a combination of two or more instructions.  The"}, {"sha": "0b603423985eaf7ed36a4f62261556e127aaed1a", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -7943,6 +7943,8 @@ to by @var{ce_info}.\n \n @hook TARGET_INVALID_WITHIN_DOLOOP\n \n+@hook TARGET_PREFERRED_DOLOOP_MODE\n+\n @hook TARGET_LEGITIMATE_COMBINED_INSN\n \n @hook TARGET_CAN_FOLLOW_JUMP"}, {"sha": "94e45a9fb99cd62a354b4794d2b7a6f7eafd3afb", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -4455,6 +4455,19 @@ loops containing function calls or branch on table instructions.\",\n  const char *, (const rtx_insn *insn),\n  default_invalid_within_doloop)\n \n+/* Returns the machine mode which the target prefers for doloop IV.  */\n+DEFHOOK\n+(preferred_doloop_mode,\n+\"This hook takes a @var{mode} for a doloop IV, where @code{mode} is the\\n\\\n+original mode for the operation.  If the target prefers an alternate\\n\\\n+@code{mode} for the operation, then this hook should return that mode;\\n\\\n+otherwise the original @code{mode} should be returned.  For example, on a\\n\\\n+64-bit target, @code{DImode} might be preferred over @code{SImode}.  Both the\\n\\\n+original and the returned modes should be @code{MODE_INT}.\",\n+ machine_mode,\n+ (machine_mode mode),\n+ default_preferred_doloop_mode)\n+\n /* Returns true for a legitimate combined insn.  */\n DEFHOOK\n (legitimate_combined_insn,"}, {"sha": "eb5190910dcf7d0acd09bba282fb5ce87887b163", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -660,6 +660,14 @@ default_predict_doloop_p (class loop *loop ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* By default, just use the input MODE itself.  */\n+\n+machine_mode\n+default_preferred_doloop_mode (machine_mode mode)\n+{\n+  return mode;\n+}\n+\n /* NULL if INSN insn is valid within a low-overhead loop, otherwise returns\n    an error message.\n "}, {"sha": "f92e102c450c23288cc79ed41c0d64cbf87826a4", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -88,6 +88,7 @@ extern bool default_fixed_point_supported_p (void);\n extern bool default_has_ifunc_p (void);\n \n extern bool default_predict_doloop_p (class loop *);\n+extern machine_mode default_preferred_doloop_mode (machine_mode);\n extern const char * default_invalid_within_doloop (const rtx_insn *);\n \n extern tree default_builtin_vectorized_function (unsigned int, tree, tree);"}, {"sha": "e5a0c4fdb16301ccd43cee3479a9e8a1998a0882", "filename": "gcc/testsuite/gcc.target/powerpc/pr61837.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr61837.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr61837.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr61837.c?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-rtl-loop2_doloop -fno-unroll-loops\" } */\n+/* The inner loop would use the doloop IV in word_mode.  And then\n+   there is no need to access it though zero_extend on shorter mode.  */\n+void foo(int *p1, long *p2, int s)\n+{\n+  int n, v, i;\n+\n+  v = 0;\n+  for (n = 0; n <= 100; n++) {\n+     for (i = 0; i < s; i++)\n+        if (p2[i] == n)\n+           p1[i] = v;\n+     v += 88;\n+  }\n+}\n+\n+/* { dg-final {scan-rtl-dump-not {(?p)zero_extend.*doloop} \"loop2_doloop\"} } */\n+/* { dg-final {scan-rtl-dump-not {(?p)reg:SI.*doloop} \"loop2_doloop\" { target lp64 } } } */\n+"}, {"sha": "47b867fab3e0f7367fccba19225007bea91a2fb9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aafa38b5bfed5e3eff258aa5354ed928f4986709/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=aafa38b5bfed5e3eff258aa5354ed928f4986709", "patch": "@@ -5657,6 +5657,59 @@ relate_compare_use_with_all_cands (struct ivopts_data *data)\n     }\n }\n \n+/* If PREFERRED_MODE is suitable and profitable, use the preferred\n+   PREFERRED_MODE to compute doloop iv base from niter: base = niter + 1.  */\n+\n+static tree\n+compute_doloop_base_on_mode (machine_mode preferred_mode, tree niter,\n+\t\t\t     const widest_int &iterations_max)\n+{\n+  tree ntype = TREE_TYPE (niter);\n+  tree pref_type = lang_hooks.types.type_for_mode (preferred_mode, 1);\n+  if (!pref_type)\n+    return fold_build2 (PLUS_EXPR, ntype, unshare_expr (niter),\n+\t\t\tbuild_int_cst (ntype, 1));\n+\n+  gcc_assert (TREE_CODE (pref_type) == INTEGER_TYPE);\n+\n+  int prec = TYPE_PRECISION (ntype);\n+  int pref_prec = TYPE_PRECISION (pref_type);\n+\n+  tree base;\n+\n+  /* Check if the PREFERRED_MODED is able to present niter.  */\n+  if (pref_prec > prec\n+      || wi::ltu_p (iterations_max,\n+\t\t    widest_int::from (wi::max_value (pref_prec, UNSIGNED),\n+\t\t\t\t      UNSIGNED)))\n+    {\n+      /* No wrap, it is safe to use preferred type after niter + 1.  */\n+      if (wi::ltu_p (iterations_max,\n+\t\t     widest_int::from (wi::max_value (prec, UNSIGNED),\n+\t\t\t\t       UNSIGNED)))\n+\t{\n+\t  /* This could help to optimize \"-1 +1\" pair when niter looks\n+\t     like \"n-1\": n is in original mode.  \"base = (n - 1) + 1\"\n+\t     in PREFERRED_MODED: it could be base = (PREFERRED_TYPE)n.  */\n+\t  base = fold_build2 (PLUS_EXPR, ntype, unshare_expr (niter),\n+\t\t\t      build_int_cst (ntype, 1));\n+\t  base = fold_convert (pref_type, base);\n+\t}\n+\n+      /* To avoid wrap, convert niter to preferred type before plus 1.  */\n+      else\n+\t{\n+\t  niter = fold_convert (pref_type, niter);\n+\t  base = fold_build2 (PLUS_EXPR, pref_type, unshare_expr (niter),\n+\t\t\t      build_int_cst (pref_type, 1));\n+\t}\n+    }\n+  else\n+    base = fold_build2 (PLUS_EXPR, ntype, unshare_expr (niter),\n+\t\t\tbuild_int_cst (ntype, 1));\n+  return base;\n+}\n+\n /* Add one doloop dedicated IV candidate:\n      - Base is (may_be_zero ? 1 : (niter + 1)).\n      - Step is -1.  */\n@@ -5688,8 +5741,20 @@ add_iv_candidate_for_doloop (struct ivopts_data *data)\n \treturn;\n     }\n \n-  tree base = fold_build2 (PLUS_EXPR, ntype, unshare_expr (niter),\n-\t\t\t   build_int_cst (ntype, 1));\n+  machine_mode mode = TYPE_MODE (ntype);\n+  machine_mode pref_mode = targetm.preferred_doloop_mode (mode);\n+\n+  tree base;\n+  if (mode != pref_mode)\n+    {\n+      base = compute_doloop_base_on_mode (pref_mode, niter, niter_desc->max);\n+      ntype = TREE_TYPE (base);\n+    }\n+  else\n+    base = fold_build2 (PLUS_EXPR, ntype, unshare_expr (niter),\n+\t\t\tbuild_int_cst (ntype, 1));\n+\n+\n   add_candidate (data, base, build_int_cst (ntype, -1), true, NULL, NULL, true);\n }\n "}]}