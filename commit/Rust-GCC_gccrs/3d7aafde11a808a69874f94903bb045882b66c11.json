{"sha": "3d7aafde11a808a69874f94903bb045882b66c11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q3YWFmZGUxMWE4MDhhNjk4NzRmOTQ5MDNiYjA0NTg4MmI2NmMxMQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-01T15:59:10Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-01T15:59:10Z"}, "message": "genrecog.c: Use ISO C90 prototypes.\n\n\t* genrecog.c: Use ISO C90 prototypes.\n\t(nodes_identical): Correct declaration to match prototype.\n\t(maybe_both_true): Likewise.\n\t(merge_trees): Likewise.\n\n\t* genpeep.c (gen_peephole): Remove #if 0 code.\n\tUse ISO C90 prototypes.\n\n\t* genattrtab.c (copy_rtx_unchanging): Remove #if 0'ed code.\n\tRemove #if 0'ed function simplify_by_alternatives.\n\t(optimize_attrs): Remove #if 0'ed code.\n\tRemove ^L.\n\tUse ISO C90 prototypes.\n\t(make_canonical): Remove #if 0'ed code.\n\t(convert_const_symbol_ref): Remove #if 0'ed function.\n\n\t* gen-protos.c (main): Check for argument.\n\n\t* rtl.h: Use ISO C90 prototypes for functions from lists.c.\n\n\t* params.h: Use ISO C90 prototypes.\n\t* params.c: Likewise.\n\t* intl.c: Likewise.\n\t* intl.h: Likewise.\n\t* lists.c: Likewise.\n\t* errors.c: Likewise.\n\t* errors.h: Likewise.\n\t* gencodes.c: Likewise.\n\t* genpreds.c: Likewise.\n\t* genattr.c: Likewise.\n\t* gen-protos.c: Likewise.\n\t* genflags.c: Likewise\n\t* genconditions.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* gencheck.c: Likewise.\n\t* genconfig.c: Likewise.\n\t* genconstants.c: Likewise.\n\t* genemit.c: Likewise.\n\t* genextract.c: Likewise.\n\t* gengenrtl.c: Likewise.\n\t* gengtype.c: Likewise.\n\t* gengtype.h: Likewise.\n\t* genopinit.c: Likewise.\n\t* genoutput.c: Likewise.\n\t* gensupport.c: Likewise.\n\t* gensupport.h: Likewise.\n\nFrom-SVN: r67296", "tree": {"sha": "1ed2af1b719c9ea42b10268e89af837f6cc20554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ed2af1b719c9ea42b10268e89af837f6cc20554"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d7aafde11a808a69874f94903bb045882b66c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7aafde11a808a69874f94903bb045882b66c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7aafde11a808a69874f94903bb045882b66c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7aafde11a808a69874f94903bb045882b66c11/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5a88a76ab2b4f100b4829a6b1ff80ee79075e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a88a76ab2b4f100b4829a6b1ff80ee79075e5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a88a76ab2b4f100b4829a6b1ff80ee79075e5a"}], "stats": {"total": 3753, "additions": 1564, "deletions": 2189}, "files": [{"sha": "56ddb8297860b396057c7a85d3b595449aa29dca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,52 @@\n 2003-06-01  Andreas Jaeger  <aj@suse.de>\n \n+\t* genrecog.c: Use ISO C90 prototypes.\n+\t(nodes_identical): Correct declaration to match prototype.\n+\t(maybe_both_true): Likewise.\n+\t(merge_trees): Likewise.\n+\n+\t* genpeep.c (gen_peephole): Remove #if 0 code.\n+\tUse ISO C90 prototypes.\n+\n+\t* genattrtab.c (copy_rtx_unchanging): Remove #if 0'ed code.\n+\tRemove #if 0'ed function simplify_by_alternatives.\n+\t(optimize_attrs): Remove #if 0'ed code.\n+\tRemove ^L.\n+\tUse ISO C90 prototypes.\n+\t(make_canonical): Remove #if 0'ed code.\n+\t(convert_const_symbol_ref): Remove #if 0'ed function.\n+\n+\t* gen-protos.c (main): Check for argument.\n+\n+\t* rtl.h: Use ISO C90 prototypes for functions from lists.c.\n+\n+\t* params.h: Use ISO C90 prototypes.\n+\t* params.c: Likewise.\n+\t* intl.c: Likewise.\n+\t* intl.h: Likewise.\n+\t* lists.c: Likewise.\n+\t* errors.c: Likewise.\n+\t* errors.h: Likewise.\n+\t* gencodes.c: Likewise.\n+\t* genpreds.c: Likewise.\n+\t* genattr.c: Likewise.\n+\t* gen-protos.c: Likewise.\n+\t* genflags.c: Likewise\n+\t* genconditions.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* gencheck.c: Likewise.\n+\t* genconfig.c: Likewise.\n+\t* genconstants.c: Likewise.\n+\t* genemit.c: Likewise.\n+\t* genextract.c: Likewise.\n+\t* gengenrtl.c: Likewise.\n+\t* gengtype.c: Likewise.\n+\t* gengtype.h: Likewise.\n+\t* genopinit.c: Likewise.\n+\t* genoutput.c: Likewise.\n+\t* gensupport.c: Likewise.\n+\t* gensupport.h: Likewise.\n+\n \t* sdbout.h: Use ISO C90 prototypes.\n \n \t* sdbout.c (CONTIN): Removed empty macro."}, {"sha": "6cbc29c47e35f0e3e91477eef16070d9434ed02b", "filename": "gcc/errors.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,6 @@\n /* Basic error reporting routines.\n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -42,7 +43,7 @@ void\n warning (const char *format, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n   fprintf (stderr, \"%s: warning: \", progname);\n   vfprintf (stderr, format, ap);\n@@ -57,7 +58,7 @@ void\n error (const char *format, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n   fprintf (stderr, \"%s: \", progname);\n   vfprintf (stderr, format, ap);\n@@ -74,7 +75,7 @@ void\n fatal (const char *format, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n   fprintf (stderr, \"%s: \", progname);\n   vfprintf (stderr, format, ap);\n@@ -89,7 +90,7 @@ void\n internal_error (const char *format, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n   fprintf (stderr, \"%s: Internal error: \", progname);\n   vfprintf (stderr, format, ap);\n@@ -105,8 +106,7 @@ internal_error (const char *format, ...)\n    version if for the gen* programs and so needn't handle subdirectories.  */\n \n const char *\n-trim_filename (name)\n-     const char *name;\n+trim_filename (const char *name)\n {\n   static const char this_file[] = __FILE__;\n   const char *p = name, *q = this_file;\n@@ -130,10 +130,7 @@ trim_filename (name)\n    This file is used only by build programs, so we're not as polite as\n    the version in diagnostic.c.  */\n void\n-fancy_abort (file, line, func)\n-     const char *file;\n-     int line;\n-     const char *func;\n+fancy_abort (const char *file, int line, const char *func)\n {\n   internal_error (\"abort in %s, at %s:%d\", func, file, line);\n }"}, {"sha": "9e0bf1e8e01e11d37a4f21b1ffcf2e5b7d8361e3", "filename": "gcc/errors.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Ferrors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Ferrors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.h?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,6 @@\n /* Basic error reporting routines.\n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -29,12 +30,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_ERRORS_H\n #define GCC_ERRORS_H\n \n-extern void warning PARAMS ((const char *, ...));\n-extern void error   PARAMS ((const char *, ...));\n-extern void fatal   PARAMS ((const char *, ...)) ATTRIBUTE_NORETURN;\n-extern void internal_error   PARAMS ((const char *, ...)) ATTRIBUTE_NORETURN;\n-extern const char *trim_filename   PARAMS ((const char *));\n-extern void fancy_abort PARAMS ((const char *, int, const char *))\n+extern void warning (const char *, ...);\n+extern void error (const char *, ...);\n+extern void fatal (const char *, ...) ATTRIBUTE_NORETURN;\n+extern void internal_error (const char *, ...) ATTRIBUTE_NORETURN;\n+extern const char *trim_filename (const char *);\n+extern void fancy_abort (const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n \n extern int have_error;"}, {"sha": "64ef406cf88d3a3c3bd37b79842815859992ee48", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,6 +1,6 @@\n /* gen-protos.c - massages a list of prototypes, for use by fixproto.\n    Copyright (C) 1993, 1994, 1995, 1996, 1998,\n-   1999 Free Software Foundation, Inc.\n+   1999, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -26,17 +26,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n int verbose = 0;\n const char *progname;\n \n-static void add_hash\t\tPARAMS ((const char *));\n-static int parse_fn_proto\tPARAMS ((char *, char *, struct fn_decl *));\n+static void add_hash (const char *);\n+static int parse_fn_proto (char *, char *, struct fn_decl *);\n \n #define HASH_SIZE 2503 /* a prime */\n int hash_tab[HASH_SIZE];\n int next_index;\n int collisions;\n \n static void\n-add_hash (fname)\n-     const char *fname;\n+add_hash (const char *fname)\n {\n   int i, i0;\n \n@@ -67,9 +66,7 @@ add_hash (fname)\n    The fields of FN point to the input string.  */\n \n static int\n-parse_fn_proto (start, end, fn)\n-     char *start, *end;\n-     struct fn_decl *fn;\n+parse_fn_proto (char *start, char *end, struct fn_decl *fn)\n {\n   char *ptr;\n   int param_nesting = 1;\n@@ -131,19 +128,18 @@ parse_fn_proto (start, end, fn)\n   return 1;\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc ATTRIBUTE_UNUSED;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   FILE *inf = stdin;\n   FILE *outf = stdout;\n   int i;\n   sstring linebuf;\n   struct fn_decl fn_decl;\n \n+  if (argc <= 1)\n+    fatal (\"no input file name\");\n+\n   i = strlen (argv[0]);\n   while (i > 0 && argv[0][i-1] != '/') --i;\n   progname = &argv[0][i];\n@@ -155,7 +151,7 @@ main (argc, argv)\n   /* A hash table entry of 0 means \"unused\" so reserve it.  */\n   fprintf (outf, \"  {\\\"\\\", \\\"\\\", \\\"\\\", 0},\\n\");\n   next_index = 1;\n-  \n+\n   for (;;)\n     {\n       int c = skip_spaces (inf, ' ');\n@@ -192,6 +188,6 @@ main (argc, argv)\n \n   fprintf (stderr, \"gen-protos: %d entries %d collisions\\n\",\n \t   next_index, collisions);\n-  \n+\n   return 0;\n }"}, {"sha": "9914384da388cc576e7c35cd85bf3817db0bec02", "filename": "gcc/genattr.c", "status": "modified", "additions": 55, "deletions": 70, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,6 @@\n /* Generate attribute information (insn-attr.h) from machine description.\n-   Copyright (C) 1991, 1994, 1996, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1994, 1996, 1998, 1999, 2000, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GCC.\n@@ -51,52 +52,46 @@ struct function_unit\n   struct range issue_delay;\t/* Range of issue delay values.  */\n };\n \n-static void extend_range PARAMS ((struct range *, int, int));\n-static void init_range PARAMS ((struct range *));\n-static void write_upcase PARAMS ((const char *));\n-static void gen_attr PARAMS ((rtx));\n-static void write_units PARAMS ((int, struct range *, struct range *,\n-\t\t\t       struct range *, struct range *,\n-\t\t\t       struct range *));\n+static void extend_range (struct range *, int, int);\n+static void init_range (struct range *);\n+static void write_upcase (const char *);\n+static void gen_attr (rtx);\n+static void write_units (int, struct range *, struct range *,\n+\t\t\t struct range *, struct range *,\n+\t\t\t struct range *);\n static void\n-extend_range (range, min, max)\n-     struct range *range;\n-     int min;\n-     int max;\n+extend_range (struct range *range, int min, int max)\n {\n   if (range->min > min) range->min = min;\n   if (range->max < max) range->max = max;\n }\n \n static void\n-init_range (range)\n-     struct range *range;\n+init_range (struct range *range)\n {\n   range->min = 100000;\n   range->max = -1;\n }\n \n static void\n-write_upcase (str)\n-    const char *str;\n+write_upcase (const char *str)\n {\n   for (; *str; str++)\n     putchar (TOUPPER(*str));\n }\n \n static void\n-gen_attr (attr)\n-     rtx attr;\n+gen_attr (rtx attr)\n {\n   const char *p, *tag;\n-  int is_const = GET_CODE (XEXP (attr, 2)) == CONST;  \n+  int is_const = GET_CODE (XEXP (attr, 2)) == CONST;\n \n   printf (\"#define HAVE_ATTR_%s\\n\", XSTR (attr, 0));\n \n   /* If numeric attribute, don't need to write an enum.  */\n   p = XSTR (attr, 1);\n   if (*p == '\\0')\n-    printf (\"extern int get_attr_%s PARAMS ((%s));\\n\", XSTR (attr, 0),\n+    printf (\"extern int get_attr_%s (%s);\\n\", XSTR (attr, 0),\n \t    (is_const ? \"void\" : \"rtx\"));\n   else\n     {\n@@ -113,7 +108,7 @@ gen_attr (attr)\n \t}\n \n       fputs (\"};\\n\", stdout);\n-      printf (\"extern enum attr_%s get_attr_%s PARAMS ((%s));\\n\\n\",\n+      printf (\"extern enum attr_%s get_attr_%s (%s);\\n\\n\",\n \t      XSTR (attr, 0), XSTR (attr, 0), (is_const ? \"void\" : \"rtx\"));\n     }\n \n@@ -122,29 +117,24 @@ gen_attr (attr)\n   if (! strcmp (XSTR (attr, 0), \"length\"))\n     {\n       puts (\"\\\n-extern void shorten_branches PARAMS ((rtx));\\n\\\n-extern int insn_default_length PARAMS ((rtx));\\n\\\n-extern int insn_variable_length_p PARAMS ((rtx));\\n\\\n-extern int insn_current_length PARAMS ((rtx));\\n\\n\\\n+extern void shorten_branches (rtx);\\n\\\n+extern int insn_default_length (rtx);\\n\\\n+extern int insn_variable_length_p (rtx);\\n\\\n+extern int insn_current_length (rtx);\\n\\n\\\n #include \\\"insn-addr.h\\\"\\n\");\n     }\n }\n \n static void\n-write_units (num_units, multiplicity, simultaneity,\n-\t     ready_cost, issue_delay, blockage)\n-     int num_units;\n-     struct range *multiplicity;\n-     struct range *simultaneity;\n-     struct range *ready_cost;\n-     struct range *issue_delay;\n-     struct range *blockage;\n+write_units (int num_units, struct range *multiplicity, struct range *simultaneity,\n+\t     struct range *ready_cost, struct range *issue_delay,\n+\t     struct range *blockage)\n {\n   int i, q_size;\n \n   printf (\"#define INSN_SCHEDULING\\n\\n\");\n-  printf (\"extern int result_ready_cost PARAMS ((rtx));\\n\");\n-  printf (\"extern int function_units_used PARAMS ((rtx));\\n\\n\");\n+  printf (\"extern int result_ready_cost (rtx);\\n\");\n+  printf (\"extern int function_units_used (rtx);\\n\\n\");\n   printf (\"extern const struct function_unit_desc\\n\");\n   printf (\"{\\n\");\n   printf (\"  const char *const name;\\n\");\n@@ -153,11 +143,11 @@ write_units (num_units, multiplicity, simultaneity,\n   printf (\"  const int simultaneity;\\n\");\n   printf (\"  const int default_cost;\\n\");\n   printf (\"  const int max_issue_delay;\\n\");\n-  printf (\"  int (*const ready_cost_function) PARAMS ((rtx));\\n\");\n-  printf (\"  int (*const conflict_cost_function) PARAMS ((rtx, rtx));\\n\");\n+  printf (\"  int (*const ready_cost_function) (rtx);\\n\");\n+  printf (\"  int (*const conflict_cost_function) (rtx, rtx);\\n\");\n   printf (\"  const int max_blockage;\\n\");\n-  printf (\"  unsigned int (*const blockage_range_function) PARAMS ((rtx));\\n\");\n-  printf (\"  int (*const blockage_function) PARAMS ((rtx, rtx));\\n\");\n+  printf (\"  unsigned int (*const blockage_range_function) (rtx);\\n\");\n+  printf (\"  int (*const blockage_function) (rtx, rtx);\\n\");\n   printf (\"} function_units[];\\n\\n\");\n   printf (\"#define FUNCTION_UNITS_SIZE %d\\n\", num_units);\n   printf (\"#define MIN_MULTIPLICITY %d\\n\", multiplicity->min);\n@@ -182,12 +172,8 @@ write_units (num_units, multiplicity, simultaneity,\n   printf (\"#define INSN_QUEUE_SIZE %d\\n\", q_size);\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n   int have_delay = 0;\n@@ -224,7 +210,7 @@ main (argc, argv)\n \n   puts (\"#define HAVE_ATTR_alternative\");\n   puts (\"#define get_attr_alternative(insn) which_alternative\");\n-     \n+\n   /* Read the machine description.  */\n \n   while (1)\n@@ -243,9 +229,9 @@ main (argc, argv)\n \t  if (! have_delay)\n \t    {\n \t      printf (\"#define DELAY_SLOTS\\n\");\n-\t      printf (\"extern int num_delay_slots PARAMS ((rtx));\\n\");\n-\t      printf (\"extern int eligible_for_delay PARAMS ((rtx, int, rtx, int));\\n\\n\");\n-\t      printf (\"extern int const_num_delay_slots PARAMS ((rtx));\\n\\n\");\n+\t      printf (\"extern int num_delay_slots (rtx);\\n\");\n+\t      printf (\"extern int eligible_for_delay (rtx, int, rtx, int);\\n\\n\");\n+\t      printf (\"extern int const_num_delay_slots (rtx);\\n\\n\");\n \t      have_delay = 1;\n \t    }\n \n@@ -254,14 +240,14 @@ main (argc, argv)\n \t      if (XVECEXP (desc, 1, i + 1) && ! have_annul_true)\n \t\t{\n \t\t  printf (\"#define ANNUL_IFTRUE_SLOTS\\n\");\n-\t\t  printf (\"extern int eligible_for_annul_true PARAMS ((rtx, int, rtx, int));\\n\");\n+\t\t  printf (\"extern int eligible_for_annul_true (rtx, int, rtx, int);\\n\");\n \t\t  have_annul_true = 1;\n \t\t}\n \n \t      if (XVECEXP (desc, 1, i + 2) && ! have_annul_false)\n \t\t{\n \t\t  printf (\"#define ANNUL_IFFALSE_SLOTS\\n\");\n-\t\t  printf (\"extern int eligible_for_annul_false PARAMS ((rtx, int, rtx, int));\\n\");\n+\t\t  printf (\"extern int eligible_for_annul_false (rtx, int, rtx, int);\\n\");\n \t\t  have_annul_false = 1;\n \t\t}\n \t    }\n@@ -379,30 +365,30 @@ main (argc, argv)\n       printf (\"   same processor cycle. */\\n\");\n       printf (\"#define MAX_DFA_ISSUE_RATE max_dfa_issue_rate\\n\\n\");\n       printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n-      printf (\"extern int insn_default_latency PARAMS ((rtx));\\n\\n\");\n+      printf (\"extern int insn_default_latency (rtx);\\n\\n\");\n       printf (\"/* Return nonzero if there is a bypass for given insn\\n\");\n       printf (\"   which is a data producer.  */\\n\");\n-      printf (\"extern int bypass_p PARAMS ((rtx));\\n\\n\");\n+      printf (\"extern int bypass_p (rtx);\\n\\n\");\n       printf (\"/* Insn latency time on data consumed by the 2nd insn.\\n\");\n       printf (\"   Use the function if bypass_p returns nonzero for\\n\");\n       printf (\"   the 1st insn. */\\n\");\n-      printf (\"extern int insn_latency PARAMS ((rtx, rtx));\\n\\n\");\n+      printf (\"extern int insn_latency (rtx, rtx);\\n\\n\");\n       printf (\"\\n#if AUTOMATON_ALTS\\n\");\n       printf (\"/* The following function returns number of alternative\\n\");\n       printf (\"   reservations of given insn.  It may be used for better\\n\");\n       printf (\"   insns scheduling heuristics. */\\n\");\n-      printf (\"extern int insn_alts PARAMS ((rtx));\\n\\n\");\n+      printf (\"extern int insn_alts (rtx);\\n\\n\");\n       printf (\"#endif\\n\\n\");\n       printf (\"/* Maximal possible number of insns waiting results being\\n\");\n       printf (\"   produced by insns whose execution is not finished. */\\n\");\n       printf (\"extern int max_insn_queue_index;\\n\\n\");\n       printf (\"/* Pointer to data describing current state of DFA.  */\\n\");\n       printf (\"typedef void *state_t;\\n\\n\");\n       printf (\"/* Size of the data in bytes.  */\\n\");\n-      printf (\"extern int state_size PARAMS ((void));\\n\\n\");\n+      printf (\"extern int state_size (void);\\n\\n\");\n       printf (\"/* Initiate given DFA state, i.e. Set up the state\\n\");\n       printf (\"   as all functional units were not reserved.  */\\n\");\n-      printf (\"extern void state_reset PARAMS ((state_t));\\n\");\n+      printf (\"extern void state_reset (state_t);\\n\");\n       printf (\"/* The following function returns negative value if given\\n\");\n       printf (\"   insn can be issued in processor state described by given\\n\");\n       printf (\"   DFA state.  In this case, the DFA state is changed to\\n\");\n@@ -412,51 +398,51 @@ main (argc, argv)\n       printf (\"   for superscalar or VLIW processors.  If the second\\n\");\n       printf (\"   parameter is NULL the function changes given DFA state\\n\");\n       printf (\"   as new processor cycle started.  */\\n\");\n-      printf (\"extern int state_transition PARAMS ((state_t, rtx));\\n\");\n+      printf (\"extern int state_transition (state_t, rtx);\\n\");\n       printf (\"\\n#if AUTOMATON_STATE_ALTS\\n\");\n       printf (\"/* The following function returns number of possible\\n\");\n       printf (\"   alternative reservations of given insn in given\\n\");\n       printf (\"   DFA state.  It may be used for better insns scheduling\\n\");\n       printf (\"   heuristics.  By default the function is defined if\\n\");\n       printf (\"   macro AUTOMATON_STATE_ALTS is defined because its\\n\");\n       printf (\"   implementation may require much memory.  */\\n\");\n-      printf (\"extern int state_alts PARAMS ((state_t, rtx));\\n\");\n+      printf (\"extern int state_alts (state_t, rtx);\\n\");\n       printf (\"#endif\\n\\n\");\n-      printf (\"extern int min_issue_delay PARAMS ((state_t, rtx));\\n\");\n+      printf (\"extern int min_issue_delay (state_t, rtx);\\n\");\n       printf (\"/* The following function returns nonzero if no one insn\\n\");\n       printf (\"   can be issued in current DFA state. */\\n\");\n-      printf (\"extern int state_dead_lock_p PARAMS ((state_t));\\n\");\n+      printf (\"extern int state_dead_lock_p (state_t);\\n\");\n       printf (\"/* The function returns minimal delay of issue of the 2nd\\n\");\n       printf (\"   insn after issuing the 1st insn in given DFA state.\\n\");\n       printf (\"   The 1st insn should be issued in given state (i.e.\\n\");\n       printf (\"    state_transition should return negative value for\\n\");\n       printf (\"    the insn and the state).  Data dependencies between\\n\");\n       printf (\"    the insns are ignored by the function.  */\\n\");\n       printf\n-\t(\"extern int min_insn_conflict_delay PARAMS ((state_t, rtx, rtx));\\n\");\n+\t(\"extern int min_insn_conflict_delay (state_t, rtx, rtx);\\n\");\n       printf (\"/* The following function outputs reservations for given\\n\");\n       printf (\"   insn as they are described in the corresponding\\n\");\n       printf (\"   define_insn_reservation.  */\\n\");\n-      printf (\"extern void print_reservation PARAMS ((FILE *, rtx));\\n\");\n+      printf (\"extern void print_reservation (FILE *, rtx);\\n\");\n       printf (\"\\n#if CPU_UNITS_QUERY\\n\");\n       printf (\"/* The following function returns code of functional unit\\n\");\n       printf (\"   with given name (see define_cpu_unit). */\\n\");\n-      printf (\"extern int get_cpu_unit_code PARAMS ((const char *));\\n\");\n+      printf (\"extern int get_cpu_unit_code (const char *);\\n\");\n       printf (\"/* The following function returns nonzero if functional\\n\");\n       printf (\"   unit with given code is currently reserved in given\\n\");\n       printf (\"   DFA state.  */\\n\");\n-      printf (\"extern int cpu_unit_reservation_p PARAMS ((state_t, int));\\n\");\n+      printf (\"extern int cpu_unit_reservation_p (state_t, int);\\n\");\n       printf (\"#endif\\n\\n\");\n       printf (\"/* Clean insn code cache.  It should be called if there\\n\");\n       printf (\"   is a chance that condition value in a\\n\");\n       printf (\"   define_insn_reservation will be changed after\\n\");\n       printf (\"   last call of dfa_start.  */\\n\");\n-      printf (\"extern void dfa_clean_insn_cache PARAMS ((void));\\n\\n\");\n+      printf (\"extern void dfa_clean_insn_cache (void);\\n\\n\");\n       printf (\"/* Initiate and finish work with DFA.  They should be\\n\");\n       printf (\"   called as the first and the last interface\\n\");\n       printf (\"   functions.  */\\n\");\n-      printf (\"extern void dfa_start PARAMS ((void));\\n\");\n-      printf (\"extern void dfa_finish PARAMS ((void));\\n\");\n+      printf (\"extern void dfa_start (void);\\n\");\n+      printf (\"extern void dfa_finish (void);\\n\");\n     }\n   else\n     {\n@@ -465,7 +451,7 @@ main (argc, argv)\n       printf (\"typedef void *state_t;\\n\\n\");\n     }\n \n-  /* Output flag masks for use by reorg.  \n+  /* Output flag masks for use by reorg.\n \n      Flags are used to hold branch direction and prediction information\n      for use by eligible_for_...  */\n@@ -486,8 +472,7 @@ main (argc, argv)\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "b9ad9dd72821dfa4431e296fd971e05ba3e003d4", "filename": "gcc/genautomata.c", "status": "modified", "additions": 702, "deletions": 1003, "changes": 1705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=3d7aafde11a808a69874f94903bb045882b66c11"}, {"sha": "fd037bdd7f57896f703f1de94efa77dcc010b3f2", "filename": "gcc/gencheck.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgencheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgencheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencheck.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,6 @@\n /* Generate check macros for tree codes.\n-   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -32,20 +33,16 @@ static const char *const tree_codes[] = {\n (char*) 0\n };\n \n-static void usage PARAMS ((void));\n+static void usage (void);\n \n static void\n-usage ()\n+usage (void)\n {\n   fputs (\"Usage: gencheck\\n\", stderr);\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc;\n-     char **argv ATTRIBUTE_UNUSED;\n+main (int argc, char **argv ATTRIBUTE_UNUSED)\n {\n   int i;\n "}, {"sha": "13aa2c58773f1165ac35f829df2d80cb9a68812f", "filename": "gcc/gencodes.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -2,7 +2,7 @@\n    - some macros CODE_FOR_... giving the insn_code_number value\n    for each of the defined standard insn names.\n    Copyright (C) 1987, 1991, 1995, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -30,12 +30,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"errors.h\"\n #include \"gensupport.h\"\n \n-static void gen_insn PARAMS ((rtx, int));\n-\n static void\n-gen_insn (insn, code)\n-     rtx insn;\n-     int code;\n+gen_insn (rtx insn, int code)\n {\n   const char *name = XSTR (insn, 0);\n   int truth = maybe_eval_c_test (XSTR (insn, 2));\n@@ -52,12 +48,8 @@ gen_insn (insn, code)\n     }\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n \n@@ -111,8 +103,7 @@ enum insn_code {\");\n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n \n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "fc55d1c9dd2d2a57cdee6b53b832e15fc4fc9bdf", "filename": "gcc/genconditions.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* Process machine description and calculate constant conditions.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -40,20 +40,17 @@ static int saw_eh_return;\n \n static htab_t condition_table;\n \n-static void add_condition\tPARAMS ((const char *));\n-static void write_header\tPARAMS ((void));\n-static void write_conditions\tPARAMS ((void));\n-static int write_one_condition\tPARAMS ((PTR *, PTR));\n-\n-extern int main\t\t\tPARAMS ((int, char **));\n+static void add_condition\t(const char *);\n+static void write_header\t(void);\n+static void write_conditions\t(void);\n+static int write_one_condition\t(void **, void *);\n \n /* Record the C test expression EXPR in the condition_table.\n    Duplicates clobber previous entries, which leaks memory, but\n    we don't care for this application.  */\n \n static void\n-add_condition (expr)\n-     const char *expr;\n+add_condition (const char *expr)\n {\n   struct c_test *test;\n \n@@ -69,7 +66,7 @@ add_condition (expr)\n /* Generate the header for insn-conditions.c.  */\n \n static void\n-write_header ()\n+write_header (void)\n {\n   puts (\"\\\n /* Generated automatically by the program `genconditions' from the target\\n\\\n@@ -122,7 +119,7 @@ write_header ()\n extern rtx insn;\\n\\\n extern rtx ins1;\\n\\\n extern rtx operands[];\\n\\\n-extern int next_insn_tests_no_inequality PARAMS ((rtx));\\n\");\n+extern int next_insn_tests_no_inequality (rtx);\\n\");\n \n   puts (\"\\\n /* If we don't have __builtin_constant_p, or it's not acceptable in\\n\\\n@@ -142,9 +139,7 @@ extern int next_insn_tests_no_inequality PARAMS ((rtx));\\n\");\n     MAYBE_EVAL (! optimize_size && ! TARGET_READ_MODIFY_WRITE) },  */\n \n static int\n-write_one_condition (slot, dummy)\n-     PTR *slot;\n-     PTR dummy ATTRIBUTE_UNUSED;\n+write_one_condition (void **slot, void *dummy ATTRIBUTE_UNUSED)\n {\n   const struct c_test *test = * (const struct c_test **) slot;\n   const char *p;\n@@ -167,7 +162,7 @@ write_one_condition (slot, dummy)\n /* Write out the complete conditions table, its size, and a flag\n    indicating that gensupport.c can now do insn elision.  */\n static void\n-write_conditions ()\n+write_conditions (void)\n {\n   puts (\"\\\n /* This table lists each condition found in the machine description.\\n\\\n@@ -186,9 +181,7 @@ const struct c_test insn_conditions[] = {\");\n }\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n   int pattern_lineno; /* not used */"}, {"sha": "c76bdb9d64594891aadd7822478b067c08c29d74", "filename": "gcc/genconfig.c", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,7 +1,7 @@\n /* Generate from machine description:\n    - some #define configuration flags.\n-   Copyright (C) 1987, 1991, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1997, 1998, 1999, 2000, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -50,12 +50,12 @@ static int max_insns_per_peep2;\n static int clobbers_seen_this_insn;\n static int dup_operands_seen_this_insn;\n \n-static void walk_insn_part PARAMS ((rtx, int, int));\n-static void gen_insn PARAMS ((rtx));\n-static void gen_expand PARAMS ((rtx));\n-static void gen_split PARAMS ((rtx));\n-static void gen_peephole PARAMS ((rtx));\n-static void gen_peephole2 PARAMS ((rtx));\n+static void walk_insn_part (rtx, int, int);\n+static void gen_insn (rtx);\n+static void gen_expand (rtx);\n+static void gen_split (rtx);\n+static void gen_peephole (rtx);\n+static void gen_peephole2 (rtx);\n \n /* RECOG_P will be nonzero if this pattern was seen in a context where it will\n    be used to recognize, rather than just generate an insn. \n@@ -64,10 +64,7 @@ static void gen_peephole2 PARAMS ((rtx));\n    of a SET whose destination is not (pc).  */\n \n static void\n-walk_insn_part (part, recog_p, non_pc_set_src)\n-     rtx part;\n-     int recog_p;\n-     int non_pc_set_src;\n+walk_insn_part (rtx part, int recog_p, int non_pc_set_src)\n {\n   int i, j;\n   RTX_CODE code;\n@@ -171,8 +168,7 @@ walk_insn_part (part, recog_p, non_pc_set_src)\n }\n \n static void\n-gen_insn (insn)\n-     rtx insn;\n+gen_insn (rtx insn)\n {\n   int i;\n \n@@ -192,8 +188,7 @@ gen_insn (insn)\n /* Similar but scan a define_expand.  */\n \n static void\n-gen_expand (insn)\n-     rtx insn;\n+gen_expand (rtx insn)\n {\n   int i;\n \n@@ -219,8 +214,7 @@ gen_expand (insn)\n /* Similar but scan a define_split.  */\n \n static void\n-gen_split (split)\n-     rtx split;\n+gen_split (rtx split)\n {\n   int i;\n \n@@ -234,8 +228,7 @@ gen_split (split)\n }\n \n static void\n-gen_peephole (peep)\n-     rtx peep;\n+gen_peephole (rtx peep)\n {\n   int i;\n \n@@ -246,8 +239,7 @@ gen_peephole (peep)\n }\n \n static void\n-gen_peephole2 (peep)\n-     rtx peep;\n+gen_peephole2 (rtx peep)\n {\n   int i, n;\n \n@@ -265,12 +257,8 @@ gen_peephole2 (peep)\n     max_insns_per_peep2 = n;\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n \n@@ -379,8 +367,7 @@ main (argc, argv)\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "a49c5476d2523cb32e1ff2e5c759790baae28955", "filename": "gcc/genconstants.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconstants.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -2,8 +2,8 @@\n    a series of #define statements, one for each constant named in\n    a (define_constants ...) pattern.\n \n-   Copyright (C) 1987, 1991, 1995, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1995, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -34,16 +34,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"errors.h\"\n #include \"gensupport.h\"\n \n-static int print_md_constant PARAMS ((void **, void *));\n-extern int main PARAMS ((int, char **));\n+static int print_md_constant (void **, void *);\n \n /* Called via traverse_md_constants; emit a #define for\n    the current constant definition.  */\n \n static int\n-print_md_constant (slot, info)\n-     void **slot;\n-     void *info;\n+print_md_constant (void **slot, void *info)\n {\n   struct md_constant *def = *slot;\n   FILE *file = info;\n@@ -53,9 +50,7 @@ print_md_constant (slot, info)\n }\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int dummy1, dummy2;\n   rtx desc;"}, {"sha": "619dfa0c2e88b450c28420985714f4034e9111cd", "filename": "gcc/genemit.c", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to emit insns as rtl.\n-   Copyright (C) 1987, 1988, 1991, 1994, 1995, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n+   2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -37,7 +37,7 @@ static int insn_code_number;\n static int insn_index_number;\n \n /* Data structure for recording the patterns of insns that have CLOBBERs.\n-   We use this to output a function that adds these CLOBBERs to a \n+   We use this to output a function that adds these CLOBBERs to a\n    previously-allocated PARALLEL expression.  */\n \n struct clobber_pat\n@@ -57,22 +57,21 @@ struct clobber_ent\n   struct clobber_ent *next;\n };\n \n-static void max_operand_1\t\tPARAMS ((rtx));\n-static int max_operand_vec\t\tPARAMS ((rtx, int));\n-static void print_code\t\t\tPARAMS ((RTX_CODE));\n-static void gen_exp\t\t\tPARAMS ((rtx, enum rtx_code, char *));\n-static void gen_insn\t\t\tPARAMS ((rtx, int));\n-static void gen_expand\t\t\tPARAMS ((rtx));\n-static void gen_split\t\t\tPARAMS ((rtx));\n-static void output_add_clobbers\t\tPARAMS ((void));\n-static void output_added_clobbers_hard_reg_p PARAMS ((void));\n-static void gen_rtx_scratch\t\tPARAMS ((rtx, enum rtx_code));\n-static void output_peephole2_scratches\tPARAMS ((rtx));\n+static void max_operand_1\t\t(rtx);\n+static int max_operand_vec\t\t(rtx, int);\n+static void print_code\t\t\t(RTX_CODE);\n+static void gen_exp\t\t\t(rtx, enum rtx_code, char *);\n+static void gen_insn\t\t\t(rtx, int);\n+static void gen_expand\t\t\t(rtx);\n+static void gen_split\t\t\t(rtx);\n+static void output_add_clobbers\t\t(void);\n+static void output_added_clobbers_hard_reg_p (void);\n+static void gen_rtx_scratch\t\t(rtx, enum rtx_code);\n+static void output_peephole2_scratches\t(rtx);\n \n \f\n static void\n-max_operand_1 (x)\n-     rtx x;\n+max_operand_1 (rtx x)\n {\n   RTX_CODE code;\n   int i;\n@@ -112,9 +111,7 @@ max_operand_1 (x)\n }\n \n static int\n-max_operand_vec (insn, arg)\n-     rtx insn;\n-     int arg;\n+max_operand_vec (rtx insn, int arg)\n {\n   int len = XVECLEN (insn, arg);\n   int i;\n@@ -130,18 +127,15 @@ max_operand_vec (insn, arg)\n }\n \f\n static void\n-print_code (code)\n-     RTX_CODE code;\n+print_code (RTX_CODE code)\n {\n   const char *p1;\n   for (p1 = GET_RTX_NAME (code); *p1; p1++)\n     putchar (TOUPPER(*p1));\n }\n \n static void\n-gen_rtx_scratch (x, subroutine_type)\n-     rtx x;\n-     enum rtx_code subroutine_type;\n+gen_rtx_scratch (rtx x, enum rtx_code subroutine_type)\n {\n   if (subroutine_type == DEFINE_PEEPHOLE2)\n     {\n@@ -157,10 +151,7 @@ gen_rtx_scratch (x, subroutine_type)\n    substituting any operand references appearing within.  */\n \n static void\n-gen_exp (x, subroutine_type, used)\n-     rtx x;\n-     enum rtx_code subroutine_type;\n-     char *used;\n+gen_exp (rtx x, enum rtx_code subroutine_type, char *used)\n {\n   RTX_CODE code;\n   int i;\n@@ -294,14 +285,12 @@ gen_exp (x, subroutine_type, used)\n \tabort ();\n     }\n   printf (\")\");\n-}  \n+}\n \f\n /* Generate the `gen_...' function for a DEFINE_INSN.  */\n \n static void\n-gen_insn (insn, lineno)\n-     rtx insn;\n-     int lineno;\n+gen_insn (rtx insn, int lineno)\n {\n   int operands;\n   int i;\n@@ -349,7 +338,7 @@ gen_insn (insn, lineno)\n \t\t  rtx new = XEXP (XVECEXP (insn, 1, j), 0);\n \n \t\t  /* OLD and NEW are the same if both are to be a SCRATCH\n-\t\t     of the same mode, \n+\t\t     of the same mode,\n \t\t     or if both are registers of the same mode and number.  */\n \t\t  if (! (GET_MODE (old) == GET_MODE (new)\n \t\t\t && ((GET_CODE (old) == MATCH_SCRATCH\n@@ -358,15 +347,15 @@ gen_insn (insn, lineno)\n \t\t\t\t && REGNO (old) == REGNO (new)))))\n \t\t    break;\n \t\t}\n-      \n+\n \t      if (j == XVECLEN (insn, 1))\n \t\tbreak;\n \t    }\n \n \t  if (p == 0)\n \t    {\n \t      p = (struct clobber_pat *) xmalloc (sizeof (struct clobber_pat));\n-\t  \n+\n \t      p->insns = 0;\n \t      p->pattern = insn;\n \t      p->first_clobber = i + 1;\n@@ -432,8 +421,7 @@ gen_insn (insn, lineno)\n /* Generate the `gen_...' function for a DEFINE_EXPAND.  */\n \n static void\n-gen_expand (expand)\n-     rtx expand;\n+gen_expand (rtx expand)\n {\n   int operands;\n   int i;\n@@ -569,8 +557,7 @@ gen_expand (expand)\n /* Like gen_expand, but generates insns resulting from splitting SPLIT.  */\n \n static void\n-gen_split (split)\n-     rtx split;\n+gen_split (rtx split)\n {\n   int i;\n   int operands;\n@@ -596,7 +583,7 @@ gen_split (split)\n   /* Output the prototype, function name and argument declarations.  */\n   if (GET_CODE (split) == DEFINE_PEEPHOLE2)\n     {\n-      printf (\"extern rtx gen_%s_%d PARAMS ((rtx, rtx *));\\n\",\n+      printf (\"extern rtx gen_%s_%d (rtx, rtx *);\\n\",\n \t      name, insn_code_number);\n       printf (\"rtx\\ngen_%s_%d (curr_insn, operands)\\n\",\n \t      name, insn_code_number);\n@@ -605,7 +592,7 @@ gen_split (split)\n     }\n   else\n     {\n-      printf (\"extern rtx gen_split_%d PARAMS ((rtx *));\\n\", insn_code_number);\n+      printf (\"extern rtx gen_split_%d (rtx *);\\n\", insn_code_number);\n       printf (\"rtx\\ngen_%s_%d (operands)\\n\", name, insn_code_number);\n       printf (\"      rtx *operands%s;\\n\", unused);\n     }\n@@ -724,7 +711,7 @@ output_add_clobbers ()\n    hard reg and 0 if they just clobber SCRATCH.  */\n \n static void\n-output_added_clobbers_hard_reg_p ()\n+output_added_clobbers_hard_reg_p (void)\n {\n   struct clobber_pat *clobber;\n   struct clobber_ent *ent;\n@@ -761,8 +748,7 @@ output_added_clobbers_hard_reg_p ()\n    scratch registers used by the peephole2 pattern in SPLIT.  */\n \n static void\n-output_peephole2_scratches (split)\n-     rtx split;\n+output_peephole2_scratches (rtx split)\n {\n   int i;\n   int insn_nr = 0;\n@@ -788,7 +774,7 @@ output_peephole2_scratches (split)\n \t      cur_insn_nr++;\n \n \t  printf (\"  if ((operands[%d] = peep2_find_free_register (%d, %d, \\\"%s\\\", %smode, &_regs_allocated)) == NULL_RTX)\\n\\\n-    return NULL;\\n\", \n+    return NULL;\\n\",\n \t\t  XINT (elt, 0),\n \t\t  insn_nr, last_insn_nr,\n \t\t  XSTR (elt, 1),\n@@ -800,12 +786,8 @@ output_peephole2_scratches (split)\n     }\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n \n@@ -896,8 +878,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "e63c26288af984f0e5151d95b1d259fb82f7c86a", "filename": "gcc/genextract.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to extract operands from insn as rtl.\n-   Copyright (C) 1987, 1991, 1992, 1993, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1992, 1993, 1997, 1998, 1999, 2000, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -31,7 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n \n /* This structure contains all the information needed to describe one\n-   set of extractions methods.  Each method may be used by more than \n+   set of extractions methods.  Each method may be used by more than\n    one pattern if the operands are in the same place.\n \n    The string for each operand describes that path to the operand and\n@@ -95,14 +95,13 @@ static int dupnums[MAX_DUP_OPERANDS];\n \n static struct code_ptr *peepholes;\n \n-static void gen_insn PARAMS ((rtx));\n-static void walk_rtx PARAMS ((rtx, const char *));\n-static void print_path PARAMS ((const char *));\n-static void record_insn_name PARAMS ((int, const char *));\n+static void gen_insn (rtx);\n+static void walk_rtx (rtx, const char *);\n+static void print_path (const char *);\n+static void record_insn_name (int, const char *);\n \n static void\n-gen_insn (insn)\n-     rtx insn;\n+gen_insn (rtx insn)\n {\n   int i;\n   struct extraction *p;\n@@ -181,9 +180,7 @@ gen_insn (insn)\n }\n \f\n static void\n-walk_rtx (x, path)\n-     rtx x;\n-     const char *path;\n+walk_rtx (rtx x, const char *path)\n {\n   RTX_CODE code;\n   int i;\n@@ -222,19 +219,19 @@ walk_rtx (x, path)\n       duplocs[dup_count] = xstrdup (path);\n       dupnums[dup_count] = XINT (x, 0);\n       dup_count++;\n-      \n+\n       newpath = (char *) xmalloc (depth + 2);\n       strcpy (newpath, path);\n       newpath[depth + 1] = 0;\n-      \n+\n       for (i = XVECLEN (x, 1) - 1; i >= 0; i--)\n         {\n \t  newpath[depth] = (code == MATCH_OP_DUP ? '0' : 'a') + i;\n \t  walk_rtx (XVECEXP (x, 1, i), newpath);\n         }\n       free (newpath);\n       return;\n-      \n+\n     case MATCH_OPERATOR:\n       oplocs[XINT (x, 0)] = xstrdup (path);\n       op_count = MAX (op_count, XINT (x, 0) + 1);\n@@ -306,8 +303,7 @@ walk_rtx (x, path)\n    evaluate to the rtx at that point.  */\n \n static void\n-print_path (path)\n-     const char *path;\n+print_path (const char *path)\n {\n   int len = strlen (path);\n   int i;\n@@ -332,7 +328,7 @@ print_path (path)\n       else\n \tabort ();\n     }\n-  \n+\n   printf (\"pat\");\n \n   for (i = 0; i < len; i++)\n@@ -346,12 +342,9 @@ print_path (path)\n     }\n }\n \f\n-extern int main PARAMS ((int, char **));\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n   int i;\n@@ -458,7 +451,7 @@ from the machine description file `md'.  */\\n\\n\");\n \t  else\n \t    printf (\"    case %d:\\n\", i);\n \t}\n-      \n+\n       for (i = 0; i < p->op_count; i++)\n \t{\n \t  if (p->oplocs[i] == 0)\n@@ -522,7 +515,7 @@ record_insn_name (code, name)\n       new_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n       insn_name_ptr =\n \t(char **) xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n-      memset (insn_name_ptr + insn_name_ptr_size, 0, \n+      memset (insn_name_ptr + insn_name_ptr_size, 0,\n \t      sizeof(char *) * (new_size - insn_name_ptr_size));\n       insn_name_ptr_size = new_size;\n     }\n@@ -537,6 +530,6 @@ record_insn_name (code, name)\n       last_real_name = new = xstrdup (name);\n       last_real_code = code;\n     }\n-  \n+\n   insn_name_ptr[code] = new;\n-}  \n+}"}, {"sha": "1eb3a730823b191add49385313e7b35b8f1d2e02", "filename": "gcc/genflags.c", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -2,7 +2,7 @@\n    - some flags HAVE_... saying which simple standard instructions are\n    available for this machine.\n    Copyright (C) 1987, 1991, 1995, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -40,17 +40,16 @@ static int max_id_len;\n /* Max operand encountered in a scan over some insn.  */\n static int max_opno;\n \n-static void max_operand_1\tPARAMS ((rtx));\n-static int num_operands\t\tPARAMS ((rtx));\n-static void gen_proto\t\tPARAMS ((rtx));\n-static void gen_macro\t\tPARAMS ((const char *, int, int));\n-static void gen_insn\t\tPARAMS ((rtx));\n+static void max_operand_1 (rtx);\n+static int num_operands (rtx);\n+static void gen_proto (rtx);\n+static void gen_macro (const char *, int, int);\n+static void gen_insn (rtx);\n \n /* Count the number of match_operand's found.  */\n \n static void\n-max_operand_1 (x)\n-     rtx x;\n+max_operand_1 (rtx x)\n {\n   RTX_CODE code;\n   int i;\n@@ -82,8 +81,7 @@ max_operand_1 (x)\n }\n \n static int\n-num_operands (insn)\n-     rtx insn;\n+num_operands (rtx insn)\n {\n   int len = XVECLEN (insn, 1);\n   int i;\n@@ -100,9 +98,7 @@ num_operands (insn)\n    of arguments it takes.  Any missing arguments are assumed to be at\n    the end.  */\n static void\n-gen_macro (name, real, expect)\n-     const char *name;\n-     int real, expect;\n+gen_macro (const char *name, int real, int expect)\n {\n   int i;\n \n@@ -131,8 +127,7 @@ gen_macro (name, real, expect)\n    does nothing.  */\n \n static void\n-gen_proto (insn)\n-     rtx insn;\n+gen_proto (rtx insn)\n {\n   int num = num_operands (insn);\n   int i;\n@@ -159,21 +154,21 @@ gen_proto (insn)\n     }\n \n   if (truth != 0)\n-    printf (\"extern rtx        gen_%-*s PARAMS ((\", max_id_len, name);\n+    printf (\"extern rtx        gen_%-*s (\", max_id_len, name);\n   else\n-    printf (\"static inline rtx gen_%-*s PARAMS ((\", max_id_len, name);\n+    printf (\"static inline rtx gen_%-*s (\", max_id_len, name);\n \n   if (num == 0)\n     fputs (\"void\", stdout);\n   else\n     {\n       for (i = 1; i < num; i++)\n \tfputs (\"rtx, \", stdout);\n-      \n+\n       fputs (\"rtx\", stdout);\n     }\n \n-  puts (\"));\");\n+  puts (\");\");\n \n   /* Some back ends want to take the address of generator functions,\n      so we cannot simply use #define for these dummy definitions.  */\n@@ -197,8 +192,7 @@ gen_proto (insn)\n }\n \n static void\n-gen_insn (insn)\n-     rtx insn;\n+gen_insn (rtx insn)\n {\n   const char *name = XSTR (insn, 0);\n   const char *p;\n@@ -238,12 +232,8 @@ gen_insn (insn)\n   obstack_grow (&obstack, &insn, sizeof (rtx));\n }\n \n-extern int main PARAMS ((int, char **));\n-\n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n   rtx dummy;\n@@ -262,7 +252,7 @@ main (argc, argv)\n \n   if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n-  \n+\n   puts (\"/* Generated automatically by the program `genflags'\");\n   puts (\"   from the machine description file `md'.  */\\n\");\n   puts (\"#ifndef GCC_INSN_FLAGS_H\");\n@@ -299,8 +289,7 @@ main (argc, argv)\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "9dbb7342f0835c89b75e3d513faac996b3e8afc5", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,6 @@\n /* Generate code to allocate RTL structures.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -44,24 +45,23 @@ static const struct rtx_definition defs[] =\n \n static const char *formats[NUM_RTX_CODE];\n \n-static const char *type_from_format\tPARAMS ((int));\n-static const char *accessor_from_format\tPARAMS ((int));\n-static int special_format\t\tPARAMS ((const char *));\n-static int special_rtx\t\t\tPARAMS ((int));\n-static int excluded_rtx\t\t\tPARAMS ((int));\n-static void find_formats\t\tPARAMS ((void));\n-static void gendecl\t\t\tPARAMS ((const char *));\n-static void genmacro\t\t\tPARAMS ((int));\n-static void gendef\t\t\tPARAMS ((const char *));\n-static void genlegend\t\t\tPARAMS ((void));\n-static void genheader\t\t\tPARAMS ((void));\n-static void gencode\t\t\tPARAMS ((void));\n+static const char *type_from_format\t(int);\n+static const char *accessor_from_format\t(int);\n+static int special_format\t\t(const char *);\n+static int special_rtx\t\t\t(int);\n+static int excluded_rtx\t\t\t(int);\n+static void find_formats\t\t(void);\n+static void gendecl\t\t\t(const char *);\n+static void genmacro\t\t\t(int);\n+static void gendef\t\t\t(const char *);\n+static void genlegend\t\t\t(void);\n+static void genheader\t\t\t(void);\n+static void gencode\t\t\t(void);\n \f\n /* Decode a format letter into a C type string.  */\n \n static const char *\n-type_from_format (c)\n-     int c;\n+type_from_format (int c)\n {\n   switch (c)\n     {\n@@ -93,8 +93,7 @@ type_from_format (c)\n /* Decode a format letter into the proper accessor function.  */\n \n static const char *\n-accessor_from_format (c)\n-     int c;\n+accessor_from_format (int c)\n {\n   switch (c)\n     {\n@@ -131,8 +130,7 @@ accessor_from_format (c)\n    the list of formats we write routines to create.  */\n \n static int\n-special_format (fmt)\n-     const char *fmt;\n+special_format (const char *fmt)\n {\n   return (strchr (fmt, '*') != 0\n \t  || strchr (fmt, 'V') != 0\n@@ -145,8 +143,7 @@ special_format (fmt)\n    is a wrapper in emit-rtl.c).  */\n \n static int\n-special_rtx (idx)\n-     int idx;\n+special_rtx (int idx)\n {\n   return (strcmp (defs[idx].enumname, \"CONST_INT\") == 0\n \t  || strcmp (defs[idx].enumname, \"REG\") == 0\n@@ -160,16 +157,15 @@ special_rtx (idx)\n    cannot have the obvious interface).  */\n \n static int\n-excluded_rtx (idx)\n-     int idx;\n+excluded_rtx (int idx)\n {\n   return (strcmp (defs[idx].enumname, \"CONST_DOUBLE\") == 0);\n }\n \n /* Place a list of all format specifiers we use into the array FORMAT.  */\n \n static void\n-find_formats ()\n+find_formats (void)\n {\n   int i;\n \n@@ -192,13 +188,12 @@ find_formats ()\n /* Write the declarations for the routine to allocate RTL with FORMAT.  */\n \n static void\n-gendecl (format)\n-     const char *format;\n+gendecl (const char *format)\n {\n   const char *p;\n   int i, pos;\n \n-  printf (\"extern rtx gen_rtx_fmt_%s\\tPARAMS ((RTX_CODE, \", format);\n+  printf (\"extern rtx gen_rtx_fmt_%s\\t (RTX_CODE, \", format);\n   printf (\"enum machine_mode mode\");\n \n   /* Write each parameter that is needed and start a new line when the line\n@@ -216,15 +211,14 @@ gendecl (format)\n \tpos += ourlen;\n       }\n \n-  printf (\"));\\n\");\n+  printf (\");\\n\");\n }\n \n /* Generate macros to generate RTL of code IDX using the functions we\n    write.  */\n \n static void\n-genmacro (idx)\n-     int idx;\n+genmacro (int idx)\n {\n   const char *p;\n   int i;\n@@ -257,8 +251,7 @@ genmacro (idx)\n    format is FORMAT.  */\n \n static void\n-gendef (format)\n-     const char *format;\n+gendef (const char *format)\n {\n   const char *p;\n   int i, j;\n@@ -298,15 +291,15 @@ gendef (format)\n /* Generate the documentation header for files we write.  */\n \n static void\n-genlegend ()\n+genlegend (void)\n {\n   puts (\"/* Generated automatically by gengenrtl from rtl.def.  */\\n\");\n }\n \n /* Generate the text of the header file we make, genrtl.h.  */\n \n static void\n-genheader ()\n+genheader (void)\n {\n   int i;\n   const char **fmt;\n@@ -329,7 +322,7 @@ genheader ()\n /* Generate the text of the code file we write, genrtl.c.  */\n \n static void\n-gencode ()\n+gencode (void)\n {\n   const char **fmt;\n \n@@ -348,12 +341,9 @@ gencode ()\n /* This is the main program.  We accept only one argument, \"-h\", which\n    says we are writing the genrtl.h file.  Otherwise we are writing the\n    genrtl.c file.  */\n-extern int main PARAMS ((int, char **));\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   find_formats ();\n   genlegend ();"}, {"sha": "52e8780f492a0d36dea54ee5f533b6e80ce0ed53", "filename": "gcc/gengtype.c", "status": "modified", "additions": 271, "deletions": 362, "changes": 633, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -32,18 +32,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Nonzero iff an error has occurred.  */\n static int hit_error = 0;\n \n-static void gen_rtx_next PARAMS ((void));\n-static void write_rtx_next PARAMS ((void));\n-static void open_base_files PARAMS ((void));\n-static void close_output_files PARAMS ((void));\n+static void gen_rtx_next (void);\n+static void write_rtx_next (void);\n+static void open_base_files (void);\n+static void close_output_files (void);\n \n /* Report an error at POS, printing MSG.  */\n \n void\n error_at_line (struct fileloc *pos, const char *msg, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msg);\n \n   fprintf (stderr, \"%s:%d: \", pos->file, pos->line);\n@@ -56,10 +56,7 @@ error_at_line (struct fileloc *pos, const char *msg, ...)\n \n /* vasprintf, but produces fatal message on out-of-memory.  */\n int\n-xvasprintf (result, format, args)\n-     char ** result;\n-     const char *format;\n-     va_list args;\n+xvasprintf (char **result, const char *format, va_list args)\n {\n   int ret = vasprintf (result, format, args);\n   if (*result == NULL || ret < 0)\n@@ -76,7 +73,7 @@ xasprintf (const char *format, ...)\n {\n   char *result;\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n   xvasprintf (&result, format, ap);\n   va_end (ap);\n@@ -88,7 +85,7 @@ xasprintf (const char *format, ...)\n struct type string_type = {\n   TYPE_STRING, NULL, NULL, GC_USED\n   UNION_INIT_ZERO\n-}; \n+};\n \n /* Lists of various things.  */\n \n@@ -97,19 +94,16 @@ static type_p structures;\n static type_p param_structs;\n static pair_p variables;\n \n-static void do_scalar_typedef PARAMS ((const char *, struct fileloc *));\n-static type_p find_param_structure \n-  PARAMS ((type_p t, type_p param[NUM_PARAM]));\n-static type_p adjust_field_tree_exp PARAMS ((type_p t, options_p opt));\n-static type_p adjust_field_rtx_def PARAMS ((type_p t, options_p opt));\n+static void do_scalar_typedef (const char *, struct fileloc *);\n+static type_p find_param_structure\n+  (type_p t, type_p param[NUM_PARAM]);\n+static type_p adjust_field_tree_exp (type_p t, options_p opt);\n+static type_p adjust_field_rtx_def (type_p t, options_p opt);\n \n /* Define S as a typedef to T at POS.  */\n \n void\n-do_typedef (s, t, pos)\n-     const char *s;\n-     type_p t;\n-     struct fileloc *pos;\n+do_typedef (const char *s, type_p t, struct fileloc *pos)\n {\n   pair_p p;\n \n@@ -135,19 +129,15 @@ do_typedef (s, t, pos)\n /* Define S as a typename of a scalar.  */\n \n static void\n-do_scalar_typedef (s, pos)\n-     const char *s;\n-     struct fileloc *pos;\n+do_scalar_typedef (const char *s, struct fileloc *pos)\n {\n   do_typedef (s, create_scalar_type (s, strlen (s)), pos);\n }\n \n /* Return the type previously defined for S.  Use POS to report errors.  */\n \n type_p\n-resolve_typedef (s, pos)\n-     const char *s;\n-     struct fileloc *pos;\n+resolve_typedef (const char *s, struct fileloc *pos)\n {\n   pair_p p;\n   for (p = typedefs; p != NULL; p = p->next)\n@@ -161,26 +151,22 @@ resolve_typedef (s, pos)\n    at POS with fields FIELDS and options O.  */\n \n void\n-new_structure (name, isunion, pos, fields, o)\n-     const char *name;\n-     int isunion;\n-     struct fileloc *pos;\n-     pair_p fields;\n-     options_p o;\n+new_structure (const char *name, int isunion, struct fileloc *pos,\n+\t       pair_p fields, options_p o)\n {\n   type_p si;\n   type_p s = NULL;\n   lang_bitmap bitmap = get_base_file_bitmap (pos->file);\n \n   for (si = structures; si != NULL; si = si->next)\n-    if (strcmp (name, si->u.s.tag) == 0 \n+    if (strcmp (name, si->u.s.tag) == 0\n \t&& UNION_P (si) == isunion)\n       {\n \ttype_p ls = NULL;\n \tif (si->kind == TYPE_LANG_STRUCT)\n \t  {\n \t    ls = si;\n-\t    \n+\n \t    for (si = ls->u.s.lang_struct; si != NULL; si = si->next)\n \t      if (si->u.s.bitmap == bitmap)\n \t\ts = si;\n@@ -209,7 +195,7 @@ new_structure (name, isunion, pos, fields, o)\n \t  }\n \tbreak;\n       }\n-  \n+\n   if (s == NULL)\n     {\n       s = xcalloc (1, sizeof (struct type));\n@@ -239,14 +225,12 @@ new_structure (name, isunion, pos, fields, o)\n    was defined previously.  */\n \n type_p\n-find_structure (name, isunion)\n-     const char *name;\n-     int isunion;\n+find_structure (const char *name, int isunion)\n {\n   type_p s;\n \n   for (s = structures; s != NULL; s = s->next)\n-    if (strcmp (name, s->u.s.tag) == 0 \n+    if (strcmp (name, s->u.s.tag) == 0\n \t&& UNION_P (s) == isunion)\n       return s;\n \n@@ -264,15 +248,13 @@ find_structure (name, isunion)\n    union if none was defined previously.  */\n \n static type_p\n-find_param_structure (t, param)\n-     type_p t;\n-     type_p param[NUM_PARAM];\n+find_param_structure (type_p t, type_p param[NUM_PARAM])\n {\n   type_p res;\n-  \n+\n   for (res = param_structs; res; res = res->next)\n     if (res->u.param_struct.stru == t\n-\t&& memcmp (res->u.param_struct.param, param, \n+\t&& memcmp (res->u.param_struct.param, param,\n \t\t   sizeof (type_p) * NUM_PARAM) == 0)\n       break;\n   if (res == NULL)\n@@ -290,9 +272,7 @@ find_param_structure (t, param)\n /* Return a scalar type with name NAME.  */\n \n type_p\n-create_scalar_type (name, name_len)\n-     const char *name;\n-     size_t name_len;\n+create_scalar_type (const char *name, size_t name_len)\n {\n   type_p r = xcalloc (1, sizeof (struct type));\n   r->kind = TYPE_SCALAR;\n@@ -303,8 +283,7 @@ create_scalar_type (name, name_len)\n /* Return a pointer to T.  */\n \n type_p\n-create_pointer (t)\n-     type_p t;\n+create_pointer (type_p t)\n {\n   if (! t->pointer_to)\n     {\n@@ -319,12 +298,10 @@ create_pointer (t)\n /* Return an array of length LEN.  */\n \n type_p\n-create_array (t, len)\n-     type_p t;\n-     const char *len;\n+create_array (type_p t, const char *len)\n {\n   type_p v;\n-  \n+\n   v = xcalloc (1, sizeof (*v));\n   v->kind = TYPE_ARRAY;\n   v->u.a.p = t;\n@@ -336,11 +313,7 @@ create_array (t, len)\n    to `variables'.  */\n \n void\n-note_variable (s, t, o, pos)\n-     const char *s;\n-     type_p t;\n-     options_p o;\n-     struct fileloc *pos;\n+note_variable (const char *s, type_p t, options_p o, struct fileloc *pos)\n {\n   pair_p n;\n   n = xmalloc (sizeof (*n));\n@@ -366,19 +339,19 @@ static int rtx_next_new[NUM_RTX_CODE];\n    in gengtype at all, but it's needed for adjust_field_rtx_def.  */\n \n static void\n-gen_rtx_next ()\n+gen_rtx_next (void)\n {\n   int i;\n   for (i = 0; i < NUM_RTX_CODE; i++)\n     {\n       int k;\n-      \n+\n       rtx_next_new[i] = -1;\n       if (strncmp (rtx_format[i], \"iuu\", 3) == 0)\n \trtx_next_new[i] = 2;\n       else if (i == COND_EXEC || i == SET || i == EXPR_LIST || i == INSN_LIST)\n \trtx_next_new[i] = 1;\n-      else \n+      else\n \tfor (k = strlen (rtx_format[i]) - 1; k >= 0; k--)\n \t  if (rtx_format[i][k] == 'e' || rtx_format[i][k] == 'u')\n \t    rtx_next_new[i] = k;\n@@ -387,18 +360,18 @@ gen_rtx_next ()\n \n /* Write out the contents of the rtx_next array.  */\n static void\n-write_rtx_next ()\n+write_rtx_next (void)\n {\n   outf_p f = get_output_file_with_visibility (NULL);\n   int i;\n-  \n+\n   oprintf (f, \"\\n/* Used to implement the RTX_NEXT macro.  */\\n\");\n   oprintf (f, \"const unsigned char rtx_next[NUM_RTX_CODE] = {\\n\");\n   for (i = 0; i < NUM_RTX_CODE; i++)\n     if (rtx_next_new[i] == -1)\n       oprintf (f, \"  0,\\n\");\n     else\n-      oprintf (f, \n+      oprintf (f,\n \t       \"  offsetof (struct rtx_def, fld) + %d * sizeof (rtunion),\\n\",\n \t       rtx_next_new[i]);\n   oprintf (f, \"};\\n\");\n@@ -409,9 +382,7 @@ write_rtx_next ()\n    are based in a complex way on the type of RTL.  */\n \n static type_p\n-adjust_field_rtx_def (t, opt)\n-     type_p t;\n-     options_p opt ATTRIBUTE_UNUSED;\n+adjust_field_rtx_def (type_p t, options_p opt ATTRIBUTE_UNUSED)\n {\n   pair_p flds = NULL;\n   options_p nodot;\n@@ -424,14 +395,14 @@ adjust_field_rtx_def (t, opt)\n #include \"rtl.def\"\n #undef DEF_RTL_EXPR\n   };\n-  \n+\n   if (t->kind != TYPE_ARRAY)\n     {\n-      error_at_line (&lexer_line, \n+      error_at_line (&lexer_line,\n \t\t     \"special `rtx_def' must be applied to an array\");\n       return &string_type;\n     }\n-  \n+\n   nodot = xmalloc (sizeof (*nodot));\n   nodot->next = NULL;\n   nodot->name = \"dot\";\n@@ -453,7 +424,7 @@ adjust_field_rtx_def (t, opt)\n     for (c = NOTE_INSN_BIAS; c <= NOTE_INSN_MAX; c++)\n       {\n \tpair_p old_note_flds = note_flds;\n-\t\n+\n \tnote_flds = xmalloc (sizeof (*note_flds));\n \tnote_flds->line.file = __FILE__;\n \tnote_flds->line.line = __LINE__;\n@@ -478,7 +449,7 @@ adjust_field_rtx_def (t, opt)\n \t    note_flds->name = \"rttree\";\n \t    note_flds->type = tree_tp;\n \t    break;\n-\t    \n+\n \t  case NOTE_INSN_EXPECTED_VALUE:\n \t    note_flds->name = \"rtx\";\n \t    note_flds->type = rtx_tp;\n@@ -492,7 +463,7 @@ adjust_field_rtx_def (t, opt)\n       }\n     new_structure (\"rtx_def_note_subunion\", 1, &lexer_line, note_flds, NULL);\n   }\n-  \n+\n   note_union_tp = find_structure (\"rtx_def_note_subunion\", 1);\n \n   for (i = 0; i < NUM_RTX_CODE; i++)\n@@ -553,14 +524,14 @@ adjust_field_rtx_def (t, opt)\n \t\tt = scalar_tp, subname = \"rtint\";\n \t      else\n \t\t{\n-\t\t  error_at_line (&lexer_line, \n+\t\t  error_at_line (&lexer_line,\n \t\t\t\"rtx type `%s' has `0' in position %lu, can't handle\",\n \t\t\t\t rtx_name[i], (unsigned long) aindex);\n \t\t  t = &string_type;\n \t\t  subname = \"rtint\";\n \t\t}\n \t      break;\n-\t      \n+\n \t    case 's':\n \t    case 'S':\n \t    case 'T':\n@@ -596,7 +567,7 @@ adjust_field_rtx_def (t, opt)\n \t      break;\n \n \t    default:\n-\t      error_at_line (&lexer_line, \n+\t      error_at_line (&lexer_line,\n \t\t     \"rtx type `%s' has `%c' in position %lu, can't handle\",\n \t\t\t     rtx_name[i], rtx_format[i][aindex],\n \t\t\t     (unsigned long)aindex);\n@@ -654,14 +625,12 @@ adjust_field_rtx_def (t, opt)\n \n /* Handle `special(\"tree_exp\")'.  This is a special case for\n    field `operands' of struct tree_exp, which although it claims to contain\n-   pointers to trees, actually sometimes contains pointers to RTL too.  \n+   pointers to trees, actually sometimes contains pointers to RTL too.\n    Passed T, the old type of the field, and OPT its options.  Returns\n    a new type for the field.  */\n \n static type_p\n-adjust_field_tree_exp (t, opt)\n-     type_p t;\n-     options_p opt ATTRIBUTE_UNUSED;\n+adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n {\n   pair_p flds;\n   options_p nodot;\n@@ -677,14 +646,14 @@ adjust_field_tree_exp (t, opt)\n     { \"WITH_CLEANUP_EXPR\", 2, 1 },\n     { \"METHOD_CALL_EXPR\", 3, 1 }\n   };\n-  \n+\n   if (t->kind != TYPE_ARRAY)\n     {\n-      error_at_line (&lexer_line, \n+      error_at_line (&lexer_line,\n \t\t     \"special `tree_exp' must be applied to an array\");\n       return &string_type;\n     }\n-  \n+\n   nodot = xmalloc (sizeof (*nodot));\n   nodot->next = NULL;\n   nodot->name = \"dot\";\n@@ -707,16 +676,16 @@ adjust_field_tree_exp (t, opt)\n     flds->opt->name = \"default\";\n     flds->opt->info = \"\";\n   }\n-  \n+\n   for (i = 0; i < ARRAY_SIZE (data); i++)\n     {\n       pair_p old_flds = flds;\n       pair_p subfields = NULL;\n       int r_index;\n       const char *sname;\n-      \n-      for (r_index = 0; \n-\t   r_index < data[i].first_rtl + data[i].num_rtl; \n+\n+      for (r_index = 0;\n+\t   r_index < data[i].first_rtl + data[i].num_rtl;\n \t   r_index++)\n \t{\n \t  pair_p old_subf = subfields;\n@@ -758,12 +727,10 @@ adjust_field_tree_exp (t, opt)\n    - Converts structures for which a parameter is provided to\n      TYPE_PARAM_STRUCT;\n    - Handles \"special\" options.\n-*/   \n+*/\n \n type_p\n-adjust_field_type (t, opt)\n-     type_p t;\n-     options_p opt;\n+adjust_field_type (type_p t, options_p opt)\n {\n   int length_p = 0;\n   const int pointer_p = t->kind == TYPE_POINTER;\n@@ -773,7 +740,7 @@ adjust_field_type (t, opt)\n \n   for (i = 0; i < NUM_PARAM; i++)\n     params[i] = NULL;\n-  \n+\n   for (; opt; opt = opt->next)\n     if (strcmp (opt->name, \"length\") == 0)\n       length_p = 1;\n@@ -787,7 +754,7 @@ adjust_field_type (t, opt)\n \tif (! UNION_OR_STRUCT_P (t)\n \t    && (t->kind != TYPE_POINTER || ! UNION_OR_STRUCT_P (t->u.p)))\n \t  {\n-\t    error_at_line (&lexer_line, \n+\t    error_at_line (&lexer_line,\n    \"option `%s' may only be applied to structures or structure pointers\",\n \t\t\t   opt->name);\n \t    return t;\n@@ -815,7 +782,7 @@ adjust_field_type (t, opt)\n   if (params_p)\n     {\n       type_p realt;\n-      \n+\n       if (pointer_p)\n \tt = t->u.p;\n       realt = find_param_structure (t, params);\n@@ -842,27 +809,24 @@ adjust_field_type (t, opt)\n    in TYPEINFO.  POS is used for error messages.  */\n \n void\n-note_yacc_type (o, fields, typeinfo, pos)\n-     options_p o;\n-     pair_p fields;\n-     pair_p typeinfo;\n-     struct fileloc *pos;\n+note_yacc_type (options_p o, pair_p fields, pair_p typeinfo,\n+\t\tstruct fileloc *pos)\n {\n   pair_p p;\n   pair_p *p_p;\n-  \n+\n   for (p = typeinfo; p; p = p->next)\n     {\n       pair_p m;\n-      \n+\n       if (p->name == NULL)\n \tcontinue;\n \n       if (p->type == (type_p) 1)\n \t{\n \t  pair_p pp;\n \t  int ok = 0;\n-\t  \n+\n \t  for (pp = typeinfo; pp; pp = pp->next)\n \t    if (pp->type != (type_p) 1\n \t\t&& strcmp (pp->opt->info, p->opt->info) == 0)\n@@ -879,12 +843,12 @@ note_yacc_type (o, fields, typeinfo, pos)\n \t  p->type = m->type;\n       if (p->type == NULL)\n \t{\n-\t  error_at_line (&p->line, \n+\t  error_at_line (&p->line,\n \t\t\t \"couldn't match fieldname `%s'\", p->name);\n \t  p->name = NULL;\n \t}\n     }\n-  \n+\n   p_p = &typeinfo;\n   while (*p_p)\n     {\n@@ -901,20 +865,16 @@ note_yacc_type (o, fields, typeinfo, pos)\n   do_typedef (\"YYSTYPE\", find_structure (\"yy_union\", 1), pos);\n }\n \f\n-static void process_gc_options PARAMS ((options_p, enum gc_used_enum, \n-\t\t\t\t\tint *, int *, int *));\n-static void set_gc_used_type PARAMS ((type_p, enum gc_used_enum, type_p *));\n-static void set_gc_used PARAMS ((pair_p));\n+static void process_gc_options (options_p, enum gc_used_enum,\n+\t\t\t\tint *, int *, int *);\n+static void set_gc_used_type (type_p, enum gc_used_enum, type_p *);\n+static void set_gc_used (pair_p);\n \n /* Handle OPT for set_gc_used_type.  */\n \n static void\n-process_gc_options (opt, level, maybe_undef, pass_param, length)\n-     options_p opt;\n-     enum gc_used_enum level;\n-     int *maybe_undef;\n-     int *pass_param;\n-     int *length;\n+process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n+\t\t    int *pass_param, int *length)\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n@@ -931,14 +891,11 @@ process_gc_options (opt, level, maybe_undef, pass_param, length)\n /* Set the gc_used field of T to LEVEL, and handle the types it references.  */\n \n static void\n-set_gc_used_type (t, level, param)\n-     type_p t;\n-     enum gc_used_enum level;\n-     type_p param[NUM_PARAM];\n+set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n {\n   if (t->gc_used >= level)\n     return;\n-  \n+\n   t->gc_used = level;\n \n   switch (t->kind)\n@@ -958,7 +915,7 @@ set_gc_used_type (t, level, param)\n \t    int length = 0;\n \t    process_gc_options (f->opt, level, &maybe_undef, &pass_param,\n \t\t\t\t&length);\n-\t    \n+\n \t    if (length && f->type->kind == TYPE_POINTER)\n \t      set_gc_used_type (f->type->u.p, GC_USED, NULL);\n \t    else if (maybe_undef && f->type->kind == TYPE_POINTER)\n@@ -979,7 +936,7 @@ set_gc_used_type (t, level, param)\n     case TYPE_ARRAY:\n       set_gc_used_type (t->u.a.p, GC_USED, param);\n       break;\n-      \n+\n     case TYPE_LANG_STRUCT:\n       for (t = t->u.s.lang_struct; t; t = t->next)\n \tset_gc_used_type (t, level, param);\n@@ -997,7 +954,7 @@ set_gc_used_type (t, level, param)\n       else\n \tlevel = GC_USED;\n       t->u.param_struct.stru->gc_used = GC_UNUSED;\n-      set_gc_used_type (t->u.param_struct.stru, level, \n+      set_gc_used_type (t->u.param_struct.stru, level,\n \t\t\tt->u.param_struct.param);\n       break;\n \n@@ -1009,8 +966,7 @@ set_gc_used_type (t, level, param)\n /* Set the gc_used fields of all the types pointed to by VARIABLES.  */\n \n static void\n-set_gc_used (variables)\n-     pair_p variables;\n+set_gc_used (pair_p variables)\n {\n   pair_p p;\n   for (p = variables; p; p = p->next)\n@@ -1040,19 +996,17 @@ static int srcdir_len = 0;\n #define NUM_BASE_FILES (ARRAY_SIZE (lang_dir_names) - 1)\n outf_p base_files[NUM_BASE_FILES];\n \n-static outf_p create_file PARAMS ((const char *, const char *));\n-static const char * get_file_basename PARAMS ((const char *));\n+static outf_p create_file (const char *, const char *);\n+static const char * get_file_basename (const char *);\n \n /* Create and return an outf_p for a new file for NAME, to be called\n    ONAME.  */\n \n static outf_p\n-create_file (name, oname)\n-     const char *name;\n-     const char *oname;\n+create_file (const char *name, const char *oname)\n {\n   static const char *const hdr[] = {\n-    \"   Copyright (C) 2002 Free Software Foundation, Inc.\\n\",\n+    \"   Copyright (C) 2003 Free Software Foundation, Inc.\\n\",\n     \"\\n\",\n     \"This file is part of GCC.\\n\",\n     \"\\n\",\n@@ -1075,7 +1029,7 @@ create_file (name, oname)\n   };\n   outf_p f;\n   size_t i;\n-  \n+\n   f = xcalloc (sizeof (*f), 1);\n   f->next = output_files;\n   f->name = oname;\n@@ -1088,13 +1042,13 @@ create_file (name, oname)\n }\n \n /* Print, like fprintf, to O.  */\n-void \n+void\n oprintf (outf_p o, const char *format, ...)\n {\n   char *s;\n   size_t slength;\n   va_list ap;\n-  \n+\n   va_start (ap, format);\n   slength = xvasprintf (&s, format, ap);\n \n@@ -1118,14 +1072,14 @@ oprintf (outf_p o, const char *format, ...)\n /* Open the global header file and the language-specific header files.  */\n \n static void\n-open_base_files ()\n+open_base_files (void)\n {\n   size_t i;\n-  \n+\n   header_file = create_file (\"GCC\", \"gtype-desc.h\");\n \n   for (i = 0; i < NUM_BASE_FILES; i++)\n-    base_files[i] = create_file (lang_dir_names[i], \n+    base_files[i] = create_file (lang_dir_names[i],\n \t\t\t\t xasprintf (\"gtype-%s.h\", lang_dir_names[i]));\n \n   /* gtype-desc.c is a little special, so we create it here.  */\n@@ -1141,7 +1095,7 @@ open_base_files ()\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;\n-      \n+\n     gtype_desc_c = create_file (\"GCC\", \"gtype-desc.c\");\n     for (ifp = ifiles; *ifp; ifp++)\n       oprintf (gtype_desc_c, \"#include \\\"%s\\\"\\n\", *ifp);\n@@ -1151,19 +1105,18 @@ open_base_files ()\n /* Determine the pathname to F relative to $(srcdir).  */\n \n static const char *\n-get_file_basename (f)\n-     const char *f;\n+get_file_basename (const char *f)\n {\n   const char *basename;\n   unsigned i;\n-  \n+\n   basename = strrchr (f, '/');\n-  \n+\n   if (!basename)\n     return f;\n-  \n+\n   basename++;\n-  \n+\n   for (i = 1; i < NUM_BASE_FILES; i++)\n     {\n       const char * s1;\n@@ -1182,28 +1135,27 @@ get_file_basename (f)\n           break;\n         }\n     }\n-  \n+\n   return basename;\n }\n \n /* Return a bitmap which has bit `1 << BASE_FILE_<lang>' set iff\n-   INPUT_FILE is used by <lang>.  \n+   INPUT_FILE is used by <lang>.\n \n    This function should be written to assume that a file _is_ used\n    if the situation is unclear.  If it wrongly assumes a file _is_ used,\n    a linker error will result.  If it wrongly assumes a file _is not_ used,\n    some GC roots may be missed, which is a much harder-to-debug problem.  */\n \n unsigned\n-get_base_file_bitmap (input_file)\n-     const char *input_file;\n+get_base_file_bitmap (const char *input_file)\n {\n   const char *basename = get_file_basename (input_file);\n   const char *slashpos = strchr (basename, '/');\n   unsigned j;\n   unsigned k;\n   unsigned bitmap;\n-  \n+\n   if (slashpos)\n     {\n       size_t i;\n@@ -1235,7 +1187,7 @@ get_base_file_bitmap (input_file)\n             }\n         }\n     }\n-    \n+\n   /* Otherwise, set all languages.  */\n   if (!bitmap)\n     bitmap = (1 << NUM_BASE_FILES) - 1;\n@@ -1248,8 +1200,7 @@ get_base_file_bitmap (input_file)\n    INPUT_FILE.  */\n \n outf_p\n-get_output_file_with_visibility (input_file)\n-     const char *input_file;\n+get_output_file_with_visibility (const char *input_file)\n {\n   outf_p r;\n   size_t len;\n@@ -1272,7 +1223,7 @@ get_output_file_with_visibility (input_file)\n       || (len > 3 && memcmp (basename+len-3, \".in\", 3) == 0))\n     {\n       char *s;\n-      \n+\n       output_name = s = xasprintf (\"gt-%s\", basename);\n       for (; *s != '.'; s++)\n \tif (! ISALNUM (*s) && *s != '-')\n@@ -1284,10 +1235,10 @@ get_output_file_with_visibility (input_file)\n     output_name = \"gt-c-common.h\", for_name = \"c-common.c\";\n   else if (strcmp (basename, \"c-tree.h\") == 0)\n     output_name = \"gt-c-decl.h\", for_name = \"c-decl.c\";\n-  else \n+  else\n     {\n       size_t i;\n-      \n+\n       for (i = 0; i < NUM_BASE_FILES; i++)\n \tif (memcmp (basename, lang_dir_names[i], strlen (lang_dir_names[i])) == 0\n \t    && basename[strlen(lang_dir_names[i])] == '/')\n@@ -1313,22 +1264,21 @@ get_output_file_with_visibility (input_file)\n    that uses INPUT_FILE.  */\n \n const char *\n-get_output_file_name (input_file)\n-     const char *input_file;\n+get_output_file_name (const char *input_file)\n {\n   return get_output_file_with_visibility (input_file)->name;\n }\n \n /* Copy the output to its final destination,\n    but don't unnecessarily change modification times.  */\n \n-static void close_output_files PARAMS ((void));\n+static void close_output_files (void);\n \n static void\n-close_output_files ()\n+close_output_files (void)\n {\n   outf_p of;\n-  \n+\n   for (of = output_files; of; of = of->next)\n     {\n       FILE * newfile;\n@@ -1385,14 +1335,14 @@ struct walk_type_data;\n    For structures, given a pointer to the item in 'val'.\n    For misc. pointers, given the item in 'val'.\n */\n-typedef void (*process_field_fn) \n-     PARAMS ((type_p f, const struct walk_type_data *p));\n+typedef void (*process_field_fn)\n+     (type_p f, const struct walk_type_data *p);\n typedef void (*func_name_fn)\n-     PARAMS ((type_p s, const struct walk_type_data *p));\n+     (type_p s, const struct walk_type_data *p);\n \n /* Parameters for write_types.  */\n \n-struct write_types_data \n+struct write_types_data\n {\n   const char *prefix;\n   const char *param_prefix;\n@@ -1402,35 +1352,35 @@ struct write_types_data\n   const char *comment;\n };\n \n-static void output_escaped_param PARAMS ((struct walk_type_data *d, \n-\t\t\t\t\t  const char *, const char *));\n-static void output_mangled_typename PARAMS ((outf_p, type_p));\n-static void walk_type PARAMS ((type_p t, struct walk_type_data *d));\n+static void output_escaped_param (struct walk_type_data *d,\n+\t\t\t\t  const char *, const char *);\n+static void output_mangled_typename (outf_p, type_p);\n+static void walk_type (type_p t, struct walk_type_data *d);\n static void write_func_for_structure\n-     PARAMS ((type_p orig_s, type_p s, type_p * param,\n-\t      const struct write_types_data *wtd));\n-static void write_types_process_field \n-     PARAMS ((type_p f, const struct walk_type_data *d));\n-static void write_types PARAMS ((type_p structures, \n-\t\t\t\t type_p param_structs,\n-\t\t\t\t const struct write_types_data *wtd));\n+     (type_p orig_s, type_p s, type_p * param,\n+      const struct write_types_data *wtd);\n+static void write_types_process_field\n+     (type_p f, const struct walk_type_data *d);\n+static void write_types (type_p structures,\n+\t\t\t type_p param_structs,\n+\t\t\t const struct write_types_data *wtd);\n static void write_types_local_process_field\n-     PARAMS ((type_p f, const struct walk_type_data *d));\n+     (type_p f, const struct walk_type_data *d);\n static void write_local_func_for_structure\n-     PARAMS ((type_p orig_s, type_p s, type_p * param));\n-static void write_local PARAMS ((type_p structures, \n-\t\t\t\t type_p param_structs));\n-static void write_enum_defn PARAMS ((type_p structures, type_p param_structs));\n-static int contains_scalar_p PARAMS ((type_p t));\n-static void put_mangled_filename PARAMS ((outf_p , const char *));\n-static void finish_root_table PARAMS ((struct flist *flp, const char *pfx, \n-\t\t\t\t       const char *tname, const char *lastname,\n-\t\t\t\t       const char *name));\n-static void write_root PARAMS ((outf_p , pair_p, type_p, const char *, int,\n-\t\t\t\t   struct fileloc *, const char *));\n-static void write_array PARAMS ((outf_p f, pair_p v,\n-\t\t\t\t const struct write_types_data *wtd));\n-static void write_roots PARAMS ((pair_p));\n+     (type_p orig_s, type_p s, type_p * param);\n+static void write_local (type_p structures,\n+\t\t\t type_p param_structs);\n+static void write_enum_defn (type_p structures, type_p param_structs);\n+static int contains_scalar_p (type_p t);\n+static void put_mangled_filename (outf_p , const char *);\n+static void finish_root_table (struct flist *flp, const char *pfx,\n+\t\t\t       const char *tname, const char *lastname,\n+\t\t\t       const char *name);\n+static void write_root (outf_p , pair_p, type_p, const char *, int,\n+\t\t\tstruct fileloc *, const char *);\n+static void write_array (outf_p f, pair_p v,\n+\t\t\t const struct write_types_data *wtd);\n+static void write_roots (pair_p);\n \n /* Parameters for walk_type.  */\n \n@@ -1456,9 +1406,7 @@ struct walk_type_data\n /* Print a mangled name representing T to OF.  */\n \n static void\n-output_mangled_typename (of, t)\n-     outf_p of;\n-     type_p t;\n+output_mangled_typename (outf_p of, type_p t)\n {\n   if (t == NULL)\n     oprintf (of, \"Z\");\n@@ -1485,7 +1433,7 @@ output_mangled_typename (of, t)\n \tfor (i = 0; i < NUM_PARAM; i++)\n \t  if (t->u.param_struct.param[i] != NULL)\n \t    output_mangled_typename (of, t->u.param_struct.param[i]);\n-\toutput_mangled_typename (of, t->u.param_struct.stru);\t\n+\toutput_mangled_typename (of, t->u.param_struct.stru);\n       }\n       break;\n     case TYPE_ARRAY:\n@@ -1499,13 +1447,11 @@ output_mangled_typename (of, t)\n    print error messages.  */\n \n static void\n-output_escaped_param (d, param, oname)\n-     struct walk_type_data *d;\n-     const char *param;\n-     const char *oname;\n+output_escaped_param (struct walk_type_data *d, const char *param,\n+\t\t      const char *oname)\n {\n   const char *p;\n-  \n+\n   for (p = param; *p; p++)\n     if (*p != '%')\n       oprintf (d->of, \"%c\", *p);\n@@ -1546,17 +1492,15 @@ output_escaped_param (d, param, oname)\n    option).  */\n \n static void\n-walk_type (t, d)\n-     type_p t;\n-     struct walk_type_data *d;\n+walk_type (type_p t, struct walk_type_data *d)\n {\n   const char *length = NULL;\n   const char *desc = NULL;\n   int maybe_undef_p = 0;\n   int use_param_num = -1;\n   int use_params_p = 0;\n   options_p oo;\n-  \n+\n   d->needs_cast_p = 0;\n   for (oo = d->opt; oo; oo = oo->next)\n     if (strcmp (oo->name, \"length\") == 0)\n@@ -1603,23 +1547,23 @@ walk_type (t, d)\n   if (use_params_p)\n     {\n       int pointer_p = t->kind == TYPE_POINTER;\n-      \n+\n       if (pointer_p)\n \tt = t->u.p;\n       if (! UNION_OR_STRUCT_P (t))\n \terror_at_line (d->line, \"`use_params' option on unimplemented type\");\n-      else \n+      else\n \tt = find_param_structure (t, d->param);\n       if (pointer_p)\n \tt = create_pointer (t);\n     }\n-      \n+\n   if (use_param_num != -1)\n     {\n       if (d->param != NULL && d->param[use_param_num] != NULL)\n \t{\n \t  type_p nt = d->param[use_param_num];\n-\t  \n+\n \t  if (t->kind == TYPE_ARRAY)\n \t    nt = create_array (nt, t->u.a.len);\n \t  else if (length != NULL && t->kind == TYPE_POINTER)\n@@ -1633,23 +1577,23 @@ walk_type (t, d)\n \terror_at_line (d->line, \"no parameter defined for `%s'\",\n \t\t       d->val);\n     }\n-  \n-  if (maybe_undef_p \n+\n+  if (maybe_undef_p\n       && (t->kind != TYPE_POINTER || ! UNION_OR_STRUCT_P (t->u.p)))\n     {\n-      error_at_line (d->line, \n+      error_at_line (d->line,\n \t\t     \"field `%s' has invalid option `maybe_undef_p'\\n\",\n \t\t     d->val);\n       return;\n     }\n-  \n+\n   switch (t->kind)\n     {\n     case TYPE_SCALAR:\n     case TYPE_STRING:\n       d->process_field (t, d);\n       break;\n-      \n+\n     case TYPE_POINTER:\n       {\n \tif (maybe_undef_p\n@@ -1664,15 +1608,15 @@ walk_type (t, d)\n \t    if (! UNION_OR_STRUCT_P (t->u.p)\n \t\t&& t->u.p->kind != TYPE_PARAM_STRUCT)\n \t      {\n-\t\terror_at_line (d->line, \n+\t\terror_at_line (d->line,\n \t\t\t       \"field `%s' is pointer to unimplemented type\",\n \t\t\t       d->val);\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    d->process_field (t->u.p, d);\n \t  }\n-\telse \n+\telse\n \t  {\n \t    int loopcounter = d->counter++;\n \t    const char *oldval = d->val;\n@@ -1683,7 +1627,7 @@ walk_type (t, d)\n \t    d->indent += 2;\n \t    oprintf (d->of, \"%*ssize_t i%d;\\n\", d->indent, \"\", loopcounter);\n \t    d->process_field(t, d);\n-\t    oprintf (d->of, \"%*sfor (i%d = 0; i%d < (size_t)(\", d->indent, \"\", \n+\t    oprintf (d->of, \"%*sfor (i%d = 0; i%d < (size_t)(\", d->indent, \"\",\n \t\t     loopcounter, loopcounter);\n \t    output_escaped_param (d, length, \"length\");\n \t    oprintf (d->of, \"); i%d++) {\\n\", loopcounter);\n@@ -1714,11 +1658,11 @@ walk_type (t, d)\n \t   any code.  */\n \tif (t->u.a.p->kind == TYPE_SCALAR)\n \t  break;\n-\t\n+\n \toprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n \td->indent += 2;\n \toprintf (d->of, \"%*ssize_t i%d;\\n\", d->indent, \"\", loopcounter);\n-\toprintf (d->of, \"%*sfor (i%d = 0; i%d < (size_t)(\", d->indent, \"\", \n+\toprintf (d->of, \"%*sfor (i%d = 0; i%d < (size_t)(\", d->indent, \"\",\n \t\t loopcounter, loopcounter);\n \tif (length)\n \t  output_escaped_param (d, length, \"length\");\n@@ -1738,7 +1682,7 @@ walk_type (t, d)\n \toprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n       }\n       break;\n-      \n+\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n       {\n@@ -1823,7 +1767,7 @@ walk_type (t, d)\n \t\tseen_default_p = 1;\n \t      }\n \t    else if (! union_p && (default_p || tagid))\n-\t      error_at_line (d->line, \n+\t      error_at_line (d->line,\n \t\t\t     \"can't use `%s' outside a union on field `%s'\",\n \t\t\t     default_p ? \"default\" : \"tag\", f->name);\n \t    else if (union_p && ! (default_p || tagid)\n@@ -1835,10 +1779,10 @@ walk_type (t, d)\n \t\tcontinue;\n \t      }\n \t    else if (union_p && ! (default_p || tagid))\n-\t      error_at_line (d->line, \n+\t      error_at_line (d->line,\n \t\t\t     \"field `%s' is missing `tag' or `default' option\",\n \t\t\t     f->name);\n-\t    \n+\n \t    d->line = &f->line;\n \t    d->val = newval = xasprintf (\"%s%s%s\", oldval, dot, f->name);\n \t    d->opt = f->opt;\n@@ -1892,13 +1836,13 @@ walk_type (t, d)\n     case TYPE_PARAM_STRUCT:\n       {\n \ttype_p *oldparam = d->param;\n-\t\n+\n \td->param = t->u.param_struct.param;\n \twalk_type (t->u.param_struct.stru, d);\n \td->param = oldparam;\n       }\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -1907,18 +1851,16 @@ walk_type (t, d)\n /* process_field routine for marking routines.  */\n \n static void\n-write_types_process_field (f, d)\n-     type_p f;\n-     const struct walk_type_data *d;\n+write_types_process_field (type_p f, const struct walk_type_data *d)\n {\n   const struct write_types_data *wtd;\n   const char *cast = d->needs_cast_p ? \"(void *)\" : \"\";\n   wtd = (const struct write_types_data *) d->cookie;\n-  \n+\n   switch (f->kind)\n     {\n     case TYPE_POINTER:\n-      oprintf (d->of, \"%*s%s (%s%s\", d->indent, \"\", \n+      oprintf (d->of, \"%*s%s (%s%s\", d->indent, \"\",\n \t       wtd->subfield_marker_routine, cast, d->val);\n       if (wtd->param_prefix)\n \t{\n@@ -1933,7 +1875,7 @@ write_types_process_field (f, d)\n \t}\n       oprintf (d->of, \");\\n\");\n       if (d->reorder_fn && wtd->reorder_note_routine)\n-\toprintf (d->of, \"%*s%s (%s%s, %s, %s);\\n\", d->indent, \"\", \n+\toprintf (d->of, \"%*s%s (%s%s, %s, %s);\\n\", d->indent, \"\",\n \t\t wtd->reorder_note_routine, cast, d->val,\n \t\t d->prev_val[3], d->reorder_fn);\n       break;\n@@ -1950,14 +1892,14 @@ write_types_process_field (f, d)\n       output_mangled_typename (d->of, f);\n       oprintf (d->of, \" (%s%s);\\n\", cast, d->val);\n       if (d->reorder_fn && wtd->reorder_note_routine)\n-\toprintf (d->of, \"%*s%s (%s%s, %s%s, %s);\\n\", d->indent, \"\", \n+\toprintf (d->of, \"%*s%s (%s%s, %s%s, %s);\\n\", d->indent, \"\",\n \t\t wtd->reorder_note_routine, cast, d->val, cast, d->val,\n \t\t d->reorder_fn);\n       break;\n \n     case TYPE_SCALAR:\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -1972,28 +1914,25 @@ write_types_process_field (f, d)\n */\n \n static void\n-write_func_for_structure (orig_s, s, param, wtd)\n-     type_p orig_s;\n-     type_p s;\n-     type_p * param;\n-     const struct write_types_data *wtd;\n+write_func_for_structure  (type_p orig_s, type_p s, type_p *param,\n+\t\t\t   const struct write_types_data *wtd)\n {\n   const char *fn = s->u.s.line.file;\n   int i;\n   const char *chain_next = NULL;\n   const char *chain_prev = NULL;\n   options_p opt;\n   struct walk_type_data d;\n-  \n+\n   /* This is a hack, and not the good kind either.  */\n   for (i = NUM_PARAM - 1; i >= 0; i--)\n-    if (param && param[i] && param[i]->kind == TYPE_POINTER \n+    if (param && param[i] && param[i]->kind == TYPE_POINTER\n \t&& UNION_OR_STRUCT_P (param[i]->u.p))\n       fn = param[i]->u.p->u.s.line.file;\n-  \n+\n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_with_visibility (fn);\n-  \n+\n   for (opt = s->u.s.opt; opt; opt = opt->next)\n     if (strcmp (opt->name, \"chain_next\") == 0)\n       chain_next = (const char *) opt->info;\n@@ -2064,13 +2003,13 @@ write_func_for_structure (orig_s, s, param, wtd)\n \t  oprintf (d.of, \"      {\\n\");\n \t  oprintf (d.of, \"        %s %s * const xprev = (\",\n \t\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-\t  \n+\n \t  d.prev_val[2] = \"*x\";\n \t  output_escaped_param (&d, chain_prev, \"chain_prev\");\n \t  oprintf (d.of, \");\\n\");\n \t  oprintf (d.of, \"        if (xprev == NULL) break;\\n\");\n \t  oprintf (d.of, \"        x = xprev;\\n\");\n-\t  oprintf (d.of, \"        (void) %s (xprev\", \n+\t  oprintf (d.of, \"        (void) %s (xprev\",\n \t\t   wtd->marker_routine);\n \t  if (wtd->param_prefix)\n \t    {\n@@ -2083,11 +2022,11 @@ write_func_for_structure (orig_s, s, param, wtd)\n       oprintf (d.of, \"  while (x != xlimit)\\n\");\n     }\n   oprintf (d.of, \"    {\\n\");\n-  \n+\n   d.prev_val[2] = \"*x\";\n   d.indent = 6;\n   walk_type (s, &d);\n-  \n+\n   if (chain_next != NULL)\n     {\n       oprintf (d.of, \"      x = (\");\n@@ -2102,20 +2041,18 @@ write_func_for_structure (orig_s, s, param, wtd)\n /* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n-write_types (structures, param_structs, wtd)\n-     type_p structures;\n-     type_p param_structs;\n-     const struct write_types_data *wtd;\n+write_types (type_p structures, type_p param_structs,\n+\t     const struct write_types_data *wtd)\n {\n   type_p s;\n-  \n+\n   oprintf (header_file, \"\\n/* %s*/\\n\", wtd->comment);\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO\n \t|| s->gc_used == GC_MAYBE_POINTED_TO)\n       {\n \toptions_p opt;\n-\t\n+\n \tif (s->gc_used == GC_MAYBE_POINTED_TO\n \t    && s->u.s.line.file == NULL)\n \t  continue;\n@@ -2124,41 +2061,41 @@ write_types (structures, param_structs, wtd)\n \toutput_mangled_typename (header_file, s);\n \toprintf (header_file, \"(X) do { \\\\\\n\");\n \toprintf (header_file,\n-\t\t \"  if (X != NULL) gt_%sx_%s (X);\\\\\\n\", wtd->prefix, \n+\t\t \"  if (X != NULL) gt_%sx_%s (X);\\\\\\n\", wtd->prefix,\n \t\t s->u.s.tag);\n \toprintf (header_file,\n \t\t \"  } while (0)\\n\");\n-\t\n+\n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n \t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n \t    {\n \t      type_p t = (type_p) opt->info;\n-\t      if (t->kind == TYPE_STRUCT \n+\t      if (t->kind == TYPE_STRUCT\n \t\t  || t->kind == TYPE_UNION\n \t\t  || t->kind == TYPE_LANG_STRUCT)\n \t\toprintf (header_file,\n \t\t\t \"#define gt_%sx_%s gt_%sx_%s\\n\",\n \t\t\t wtd->prefix, s->u.s.tag, wtd->prefix, t->u.s.tag);\n \t      else\n-\t\terror_at_line (&s->u.s.line, \n+\t\terror_at_line (&s->u.s.line,\n \t\t\t       \"structure alias is not a structure\");\n \t      break;\n \t    }\n \tif (opt)\n \t  continue;\n \n \t/* Declare the marker procedure only once.  */\n-\toprintf (header_file, \n-\t\t \"extern void gt_%sx_%s PARAMS ((void *));\\n\",\n+\toprintf (header_file,\n+\t\t \"extern void gt_%sx_%s (void *);\\n\",\n \t\t wtd->prefix, s->u.s.tag);\n-  \n+\n \tif (s->u.s.line.file == NULL)\n \t  {\n-\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\", \n+\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\",\n \t\t     s->u.s.tag);\n \t    continue;\n \t  }\n-  \n+\n \tif (s->kind == TYPE_LANG_STRUCT)\n \t  {\n \t    type_p ss;\n@@ -2178,15 +2115,15 @@ write_types (structures, param_structs, wtd)\n \t/* Declare the marker procedure.  */\n \toprintf (header_file, \"extern void gt_%s_\", wtd->prefix);\n \toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \" PARAMS ((void *));\\n\");\n-  \n+\toprintf (header_file, \" (void *);\\n\");\n+\n \tif (stru->u.s.line.file == NULL)\n \t  {\n-\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\", \n+\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\",\n \t\t     s->u.s.tag);\n \t    continue;\n \t  }\n-  \n+\n \tif (stru->kind == TYPE_LANG_STRUCT)\n \t  {\n \t    type_p ss;\n@@ -2216,9 +2153,7 @@ static const struct write_types_data pch_wtd =\n /* process_field routine for local pointer-walking.  */\n \n static void\n-write_types_local_process_field (f, d)\n-     type_p f;\n-     const struct walk_type_data *d;\n+write_types_local_process_field (type_p f, const struct walk_type_data *d)\n {\n   switch (f->kind)\n     {\n@@ -2235,7 +2170,7 @@ write_types_local_process_field (f, d)\n \n     case TYPE_SCALAR:\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -2248,24 +2183,21 @@ write_types_local_process_field (f, d)\n */\n \n static void\n-write_local_func_for_structure (orig_s, s, param)\n-     type_p orig_s;\n-     type_p s;\n-     type_p * param;\n+write_local_func_for_structure (type_p orig_s, type_p s, type_p *param)\n {\n   const char *fn = s->u.s.line.file;\n   int i;\n   struct walk_type_data d;\n-  \n+\n   /* This is a hack, and not the good kind either.  */\n   for (i = NUM_PARAM - 1; i >= 0; i--)\n-    if (param && param[i] && param[i]->kind == TYPE_POINTER \n+    if (param && param[i] && param[i]->kind == TYPE_POINTER\n \t&& UNION_OR_STRUCT_P (param[i]->u.p))\n       fn = param[i]->u.p->u.s.line.file;\n-  \n+\n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_with_visibility (fn);\n-  \n+\n   d.process_field = write_types_local_process_field;\n   d.opt = s->u.s.opt;\n   d.line = &s->u.s.line;\n@@ -2297,27 +2229,25 @@ write_local_func_for_structure (orig_s, s, param)\n /* Write out local marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n-write_local (structures, param_structs)\n-     type_p structures;\n-     type_p param_structs;\n+write_local (type_p structures, type_p param_structs)\n {\n   type_p s;\n-  \n+\n   oprintf (header_file, \"\\n/* Local pointer-walking routines.  */\\n\");\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO\n \t|| s->gc_used == GC_MAYBE_POINTED_TO)\n       {\n \toptions_p opt;\n-\t\n+\n \tif (s->u.s.line.file == NULL)\n \t  continue;\n \n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n \t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n \t    {\n \t      type_p t = (type_p) opt->info;\n-\t      if (t->kind == TYPE_STRUCT \n+\t      if (t->kind == TYPE_STRUCT\n \t\t  || t->kind == TYPE_UNION\n \t\t  || t->kind == TYPE_LANG_STRUCT)\n \t\t{\n@@ -2328,7 +2258,7 @@ write_local (structures, param_structs)\n \t\t  oprintf (header_file, \"\\n\");\n \t\t}\n \t      else\n-\t\terror_at_line (&s->u.s.line, \n+\t\terror_at_line (&s->u.s.line,\n \t\t\t       \"structure alias is not a structure\");\n \t      break;\n \t    }\n@@ -2338,9 +2268,9 @@ write_local (structures, param_structs)\n \t/* Declare the marker procedure only once.  */\n \toprintf (header_file, \"extern void gt_pch_p_\");\n \toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \n-\t \"\\n    PARAMS ((void *, void *, gt_pointer_operator, void *));\\n\");\n-  \n+\toprintf (header_file,\n+\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n+\n \tif (s->kind == TYPE_LANG_STRUCT)\n \t  {\n \t    type_p ss;\n@@ -2360,16 +2290,16 @@ write_local (structures, param_structs)\n \t/* Declare the marker procedure.  */\n \toprintf (header_file, \"extern void gt_pch_p_\");\n \toutput_mangled_typename (header_file, s);\n-\toprintf (header_file, \n-\t \"\\n    PARAMS ((void *, void *, gt_pointer_operator, void *));\\n\");\n-  \n+\toprintf (header_file,\n+\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n+\n \tif (stru->u.s.line.file == NULL)\n \t  {\n-\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\", \n+\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\",\n \t\t     s->u.s.tag);\n \t    continue;\n \t  }\n-  \n+\n \tif (stru->kind == TYPE_LANG_STRUCT)\n \t  {\n \t    type_p ss;\n@@ -2384,12 +2314,10 @@ write_local (structures, param_structs)\n /* Write out the 'enum' definition for gt_types_enum.  */\n \n static void\n-write_enum_defn (structures, param_structs)\n-     type_p structures;\n-     type_p param_structs;\n+write_enum_defn  (type_p structures, type_p param_structs)\n {\n   type_p s;\n-  \n+\n   oprintf (header_file, \"\\n/* Enumeration of types known.  */\\n\");\n   oprintf (header_file, \"enum gt_types_enum {\\n\");\n   for (s = structures; s; s = s->next)\n@@ -2418,8 +2346,7 @@ write_enum_defn (structures, param_structs)\n /* Might T contain any non-pointer elements?  */\n \n static int\n-contains_scalar_p (t)\n-     type_p t;\n+contains_scalar_p (type_p t)\n {\n   switch (t->kind)\n     {\n@@ -2438,9 +2365,7 @@ contains_scalar_p (t)\n /* Mangle FN and print it to F.  */\n \n static void\n-put_mangled_filename (f, fn)\n-     outf_p f;\n-     const char *fn;\n+put_mangled_filename (outf_p f, const char *fn)\n {\n   const char *name = get_output_file_name (fn);\n   for (; *name != 0; name++)\n@@ -2455,15 +2380,11 @@ put_mangled_filename (f, fn)\n    the resulting code.  */\n \n static void\n-finish_root_table (flp, pfx, lastname, tname, name)\n-     struct flist *flp;\n-     const char *pfx;\n-     const char *tname;\n-     const char *lastname;\n-     const char *name;\n+finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n+\t\t   const char *tname, const char *name)\n {\n   struct flist *fli2;\n-  \n+\n   for (fli2 = flp; fli2; fli2 = fli2->next)\n     if (fli2->started_p)\n       {\n@@ -2487,15 +2408,15 @@ finish_root_table (flp, pfx, lastname, tname, name)\n \t      oprintf (base_files[fnum], \"[];\\n\");\n \t    }\n       }\n-  \n+\n   {\n     size_t fnum;\n     for (fnum = 0; fnum < NUM_BASE_FILES; fnum++)\n       oprintf (base_files [fnum],\n \t       \"const struct %s * const %s[] = {\\n\",\n \t       tname, name);\n   }\n-  \n+\n \n   for (fli2 = flp; fli2; fli2 = fli2->next)\n     if (fli2->started_p)\n@@ -2530,14 +2451,8 @@ finish_root_table (flp, pfx, lastname, tname, name)\n    is nonzero iff we are building the root table for hash table caches.  */\n \n static void\n-write_root (f, v, type, name, has_length, line, if_marked)\n-     outf_p f;\n-     pair_p v;\n-     type_p type;\n-     const char *name;\n-     int has_length;\n-     struct fileloc *line;\n-     const char *if_marked;\n+write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n+\t    struct fileloc *line, const char *if_marked)\n {\n   switch (type->kind)\n     {\n@@ -2549,7 +2464,7 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \t    int skip_p = 0;\n \t    const char *desc = NULL;\n \t    options_p o;\n-\t    \n+\n \t    for (o = fld->opt; o; o = o->next)\n \t      if (strcmp (o->name, \"skip\") == 0)\n \t\tskip_p = 1;\n@@ -2559,26 +2474,26 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \t\terror_at_line (line,\n \t\t       \"field `%s' of global `%s' has unknown option `%s'\",\n \t\t\t       fld->name, name, o->name);\n-\t    \n+\n \t    if (skip_p)\n \t      continue;\n \t    else if (desc && fld->type->kind == TYPE_UNION)\n \t      {\n \t\tpair_p validf = NULL;\n \t\tpair_p ufld;\n-\t\t\n+\n \t\tfor (ufld = fld->type->u.s.fields; ufld; ufld = ufld->next)\n \t\t  {\n \t\t    const char *tag = NULL;\n \t\t    options_p oo;\n-\t\t    \n+\n \t\t    for (oo = ufld->opt; oo; oo = oo->next)\n \t\t      if (strcmp (oo->name, \"tag\") == 0)\n \t\t\ttag = (const char *)oo->info;\n \t\t    if (tag == NULL || strcmp (tag, desc) != 0)\n \t\t      continue;\n \t\t    if (validf != NULL)\n-\t\t      error_at_line (line, \n+\t\t      error_at_line (line,\n \t\t\t   \"both `%s.%s.%s' and `%s.%s.%s' have tag `%s'\",\n \t\t\t\t     name, fld->name, validf->name,\n \t\t\t\t     name, fld->name, ufld->name,\n@@ -2588,15 +2503,15 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \t\tif (validf != NULL)\n \t\t  {\n \t\t    char *newname;\n-\t\t    newname = xasprintf (\"%s.%s.%s\", \n+\t\t    newname = xasprintf (\"%s.%s.%s\",\n \t\t\t\t\t name, fld->name, validf->name);\n \t\t    write_root (f, v, validf->type, newname, 0, line,\n \t\t\t\tif_marked);\n \t\t    free (newname);\n \t\t  }\n \t      }\n \t    else if (desc)\n-\t      error_at_line (line, \n+\t      error_at_line (line,\n \t\t     \"global `%s.%s' has `desc' option but is not union\",\n \t\t\t     name, fld->name);\n \t    else\n@@ -2618,15 +2533,15 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \tfree (newname);\n       }\n       break;\n-      \n+\n     case TYPE_POINTER:\n       {\n \ttype_p ap, tp;\n-\t\n+\n \toprintf (f, \"  {\\n\");\n \toprintf (f, \"    &%s,\\n\", name);\n \toprintf (f, \"    1\");\n-\t\n+\n \tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n \t  if (ap->u.a.len[0])\n \t    oprintf (f, \" * (%s)\", ap->u.a.len);\n@@ -2637,9 +2552,9 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n \t  oprintf (f, \"[0]\");\n \toprintf (f, \"),\\n\");\n-\t\n+\n \ttp = type->u.p;\n-\t\n+\n \tif (! has_length && UNION_OR_STRUCT_P (tp))\n \t  {\n \t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", tp->u.s.tag);\n@@ -2660,7 +2575,7 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \t  }\n \telse\n \t  {\n-\t    error_at_line (line, \n+\t    error_at_line (line,\n \t\t\t   \"global `%s' is pointer to unimplemented type\",\n \t\t\t   name);\n \t  }\n@@ -2681,12 +2596,12 @@ write_root (f, v, type, name, has_length, line, if_marked)\n \toprintf (f, \"  },\\n\");\n       }\n       break;\n-\t\n+\n     case TYPE_SCALAR:\n       break;\n-      \n+\n     default:\n-      error_at_line (line, \n+      error_at_line (line,\n \t\t     \"global `%s' is unimplemented type\",\n \t\t     name);\n     }\n@@ -2695,14 +2610,11 @@ write_root (f, v, type, name, has_length, line, if_marked)\n /* This generates a routine to walk an array.  */\n \n static void\n-write_array (f, v, wtd)\n-     outf_p f;\n-     pair_p v;\n-     const struct write_types_data *wtd;\n+write_array (outf_p f, pair_p v, const struct write_types_data *wtd)\n {\n   struct walk_type_data d;\n   char *prevval3;\n-  \n+\n   memset (&d, 0, sizeof (d));\n   d.of = f;\n   d.cookie = wtd;\n@@ -2717,9 +2629,9 @@ write_array (f, v, wtd)\n   if (wtd->param_prefix)\n     {\n       oprintf (f, \"static void gt_%sa_%s\\n\", wtd->param_prefix, v->name);\n-      oprintf (f, \n-       \"    PARAMS ((void *, void *, gt_pointer_operator, void *));\\n\");\n-      oprintf (f, \"static void gt_%sa_%s (this_obj, x_p, op, cookie)\\n\", \n+      oprintf (f,\n+       \"    (void *, void *, gt_pointer_operator, void *);\\n\");\n+      oprintf (f, \"static void gt_%sa_%s (this_obj, x_p, op, cookie)\\n\",\n \t       wtd->param_prefix, v->name);\n       oprintf (d.of, \"      void *this_obj ATTRIBUTE_UNUSED;\\n\");\n       oprintf (d.of, \"      void *x_p ATTRIBUTE_UNUSED;\\n\");\n@@ -2733,7 +2645,7 @@ write_array (f, v, wtd)\n     }\n \n   d.opt = v->opt;\n-  oprintf (f, \"static void gt_%sa_%s PARAMS ((void *));\\n\",\n+  oprintf (f, \"static void gt_%sa_%s (void *);\\n\",\n \t   wtd->prefix, v->name);\n   oprintf (f, \"static void\\ngt_%sa_%s (x_p)\\n\",\n \t   wtd->prefix, v->name);\n@@ -2749,8 +2661,7 @@ write_array (f, v, wtd)\n /* Output a table describing the locations and types of VARIABLES.  */\n \n static void\n-write_roots (variables)\n-     pair_p variables;\n+write_roots (pair_p variables)\n {\n   pair_p v;\n   struct flist *flp = NULL;\n@@ -2770,14 +2681,14 @@ write_roots (variables)\n \t  deletable_p = 1;\n \telse if (strcmp (o->name, \"param_is\") == 0)\n \t  ;\n- \telse if (strncmp (o->name, \"param\", 5) == 0\n+\telse if (strncmp (o->name, \"param\", 5) == 0\n \t\t && ISDIGIT (o->name[5])\n \t\t && strcmp (o->name + 6, \"_is\") == 0)\n \t  ;\n \telse if (strcmp (o->name, \"if_marked\") == 0)\n \t  ;\n \telse\n-\t  error_at_line (&v->line, \n+\t  error_at_line (&v->line,\n \t\t\t \"global `%s' has unknown option `%s'\",\n \t\t\t v->name, o->name);\n \n@@ -2814,7 +2725,7 @@ write_roots (variables)\n       int skip_p = 0;\n       int length_p = 0;\n       options_p o;\n-      \n+\n       for (o = v->opt; o; o = o->next)\n \tif (strcmp (o->name, \"length\") == 0)\n \t  length_p = 1;\n@@ -2840,7 +2751,7 @@ write_roots (variables)\n       write_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n     }\n \n-  finish_root_table (flp, \"ggc_r\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\", \n+  finish_root_table (flp, \"ggc_r\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_ggc_rtab\");\n \n   for (v = variables; v; v = v->next)\n@@ -2870,11 +2781,11 @@ write_roots (variables)\n \t  put_mangled_filename (f, v->line.file);\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n-      \n+\n       oprintf (f, \"  { &%s, 1, sizeof (%s), NULL, NULL },\\n\",\n \t       v->name, v->name);\n     }\n-  \n+\n   finish_root_table (flp, \"ggc_rd\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_ggc_deletable_rtab\");\n \n@@ -2885,7 +2796,7 @@ write_roots (variables)\n       const char *if_marked = NULL;\n       int length_p = 0;\n       options_p o;\n-      \n+\n       for (o = v->opt; o; o = o->next)\n \tif (strcmp (o->name, \"length\") == 0)\n \t  length_p = 1;\n@@ -2914,11 +2825,11 @@ write_roots (variables)\n \t  put_mangled_filename (f, v->line.file);\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n-      \n+\n       write_root (f, v, v->type->u.p->u.param_struct.param[0],\n \t\t     v->name, length_p, &v->line, if_marked);\n     }\n-  \n+\n   finish_root_table (flp, \"ggc_rc\", \"LAST_GGC_CACHE_TAB\", \"ggc_cache_tab\",\n \t\t     \"gt_ggc_cache_rtab\");\n \n@@ -2929,7 +2840,7 @@ write_roots (variables)\n       int length_p = 0;\n       int if_marked_p = 0;\n       options_p o;\n-      \n+\n       for (o = v->opt; o; o = o->next)\n \tif (strcmp (o->name, \"length\") == 0)\n \t  length_p = 1;\n@@ -2953,7 +2864,7 @@ write_roots (variables)\n \n       write_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n     }\n-  \n+\n   finish_root_table (flp, \"pch_rc\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_pch_cache_rtab\");\n \n@@ -2986,26 +2897,24 @@ write_roots (variables)\n \t  put_mangled_filename (f, v->line.file);\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n-      \n+\n       oprintf (f, \"  { &%s, 1, sizeof (%s), NULL, NULL },\\n\",\n \t       v->name, v->name);\n     }\n-  \n+\n   finish_root_table (flp, \"pch_rs\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_pch_scalar_rtab\");\n }\n \n \f\n-extern int main PARAMS ((int argc, char **argv));\n-int \n-main(argc, argv)\n-     int argc ATTRIBUTE_UNUSED;\n-     char **argv ATTRIBUTE_UNUSED;\n+extern int main (int argc, char **argv);\n+int\n+main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n {\n   unsigned i;\n   static struct fileloc pos = { __FILE__, __LINE__ };\n   unsigned j;\n-  \n+\n   gen_rtx_next ();\n \n   srcdir_len = strlen (srcdir);"}, {"sha": "3a3157ec3771fdbb033c45d52993d687fada6009", "filename": "gcc/gengtype.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* Process source files and output type information.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -111,36 +111,36 @@ extern struct fileloc lexer_line;\n \n /* Print an error message.  */\n extern void error_at_line \n-  PARAMS ((struct fileloc *pos, const char *msg, ...)) ATTRIBUTE_PRINTF_2;\n+  (struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n /* Combines xmalloc() and vasprintf().  */\n-extern int xvasprintf PARAMS ((char **, const char *, va_list))\n+extern int xvasprintf (char **, const char *, va_list)\n      ATTRIBUTE_PRINTF (2, 0);\n /* Like the above, but more convenient for quick coding.  */\n-extern char * xasprintf PARAMS ((const char *, ...))\n+extern char * xasprintf (const char *, ...)\n      ATTRIBUTE_PRINTF_1;\n \n /* Constructor routines for types.  */\n-extern void do_typedef PARAMS ((const char *s, type_p t, struct fileloc *pos));\n-extern type_p resolve_typedef PARAMS ((const char *s, struct fileloc *pos));\n-extern void new_structure PARAMS ((const char *name, int isunion, \n-\t\t\t\t   struct fileloc *pos, pair_p fields, \n-\t\t\t\t   options_p o));\n-extern type_p find_structure PARAMS ((const char *s, int isunion));\n-extern type_p create_scalar_type PARAMS ((const char *name, size_t name_len));\n-extern type_p create_pointer PARAMS ((type_p t));\n-extern type_p create_array PARAMS ((type_p t, const char *len));\n-extern type_p adjust_field_type PARAMS ((type_p, options_p));\n-extern void note_variable PARAMS ((const char *s, type_p t, options_p o,\n-\t\t\t\t   struct fileloc *pos));\n-extern void note_yacc_type PARAMS ((options_p o, pair_p fields,\n-\t\t\t\t    pair_p typeinfo, struct fileloc *pos));\n+extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n+extern type_p resolve_typedef (const char *s, struct fileloc *pos);\n+extern void new_structure (const char *name, int isunion, \n+\t\t\t   struct fileloc *pos, pair_p fields, \n+\t\t\t   options_p o);\n+extern type_p find_structure (const char *s, int isunion);\n+extern type_p create_scalar_type (const char *name, size_t name_len);\n+extern type_p create_pointer (type_p t);\n+extern type_p create_array (type_p t, const char *len);\n+extern type_p adjust_field_type (type_p, options_p);\n+extern void note_variable (const char *s, type_p t, options_p o,\n+\t\t\t   struct fileloc *pos);\n+extern void note_yacc_type (options_p o, pair_p fields,\n+\t\t\t    pair_p typeinfo, struct fileloc *pos);\n \n /* Lexer and parser routines, most automatically generated.  */\n-extern int yylex PARAMS((void));\n-extern void yyerror PARAMS ((const char *));\n-extern int yyparse PARAMS ((void));\n-extern void parse_file PARAMS ((const char *name));\n+extern int yylex (void);\n+extern void yyerror (const char *);\n+extern int yyparse (void);\n+extern void parse_file (const char *name);\n \n /* Output file handling.  */\n \n@@ -164,8 +164,8 @@ extern outf_p header_file;\n    made in INPUT_FILE and is linked into every language that uses\n    INPUT_FILE.  */\n extern outf_p get_output_file_with_visibility \n-   PARAMS ((const char *input_file));\n-const char *get_output_file_name PARAMS ((const char *));\n+   (const char *input_file);\n+const char *get_output_file_name (const char *);\n \n /* A list of output files suitable for definitions.  There is one\n    BASE_FILES entry for each language.  */\n@@ -174,8 +174,8 @@ extern outf_p base_files[];\n /* A bitmap that specifies which of BASE_FILES should be used to\n    output a definition that is different for each language and must be\n    defined once in each language that uses INPUT_FILE.  */\n-extern lang_bitmap get_base_file_bitmap PARAMS ((const char *input_file));\n+extern lang_bitmap get_base_file_bitmap (const char *input_file);\n \n /* Print, like fprintf, to O.  */\n-extern void oprintf PARAMS ((outf_p o, const char *S, ...))\n+extern void oprintf (outf_p o, const char *S, ...)\n      ATTRIBUTE_PRINTF_2;"}, {"sha": "bba458d5f08e115f72238825759034712e0f8ca0", "filename": "gcc/genopinit.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -149,11 +149,10 @@ static const char * const optabs[] =\n   \"movstr_optab[$A] = CODE_FOR_$(movstr$a$)\",\n   \"clrstr_optab[$A] = CODE_FOR_$(clrstr$a$)\" };\n \n-static void gen_insn PARAMS ((rtx));\n+static void gen_insn (rtx);\n \n static void\n-gen_insn (insn)\n-     rtx insn;\n+gen_insn (rtx insn)\n {\n   const char *name = XSTR (insn, 0);\n   int m1 = 0, m2 = 0, op = 0;\n@@ -321,12 +320,10 @@ gen_insn (insn)\n   printf (\";\\n\");\n }\n \n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n \n@@ -377,8 +374,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "2f464cf2a62ccdff8b77e321bffdb385c4849d59", "filename": "gcc/genoutput.c", "status": "modified", "additions": 48, "deletions": 73, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -99,8 +99,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define MAX_MAX_OPERANDS 40\n \n-static int n_occurrences\t\tPARAMS ((int, const char *));\n-static const char *strip_whitespace\tPARAMS ((const char *));\n+static int n_occurrences\t\t(int, const char *);\n+static const char *strip_whitespace\t(const char *);\n \n /* insns in the machine description are assigned sequential code numbers\n    that are used by insn-recog.c (produced by genrecog) to communicate\n@@ -173,28 +173,27 @@ struct data\n \n static struct data *idata, **idata_end = &idata;\n \f\n-static void output_prologue PARAMS ((void));\n-static void output_predicate_decls PARAMS ((void));\n-static void output_operand_data PARAMS ((void));\n-static void output_insn_data PARAMS ((void));\n-static void output_get_insn_name PARAMS ((void));\n-static void scan_operands PARAMS ((struct data *, rtx, int, int));\n-static int compare_operands PARAMS ((struct operand_data *,\n-\t\t\t\t   struct operand_data *));\n-static void place_operands PARAMS ((struct data *));\n-static void process_template PARAMS ((struct data *, const char *));\n-static void validate_insn_alternatives PARAMS ((struct data *));\n-static void validate_insn_operands PARAMS ((struct data *));\n-static void gen_insn PARAMS ((rtx, int));\n-static void gen_peephole PARAMS ((rtx, int));\n-static void gen_expand PARAMS ((rtx, int));\n-static void gen_split PARAMS ((rtx, int));\n-static void check_constraint_len PARAMS ((void));\n-static int constraint_len PARAMS ((const char *, int));\n+static void output_prologue (void);\n+static void output_predicate_decls (void);\n+static void output_operand_data (void);\n+static void output_insn_data (void);\n+static void output_get_insn_name (void);\n+static void scan_operands (struct data *, rtx, int, int);\n+static int compare_operands (struct operand_data *,\n+\t\t\t     struct operand_data *);\n+static void place_operands (struct data *);\n+static void process_template (struct data *, const char *);\n+static void validate_insn_alternatives (struct data *);\n+static void validate_insn_operands (struct data *);\n+static void gen_insn (rtx, int);\n+static void gen_peephole (rtx, int);\n+static void gen_expand (rtx, int);\n+static void gen_split (rtx, int);\n+static void check_constraint_len (void);\n+static int constraint_len (const char *, int);\n \f\n const char *\n-get_insn_name (index)\n-     int index;\n+get_insn_name (int index)\n {\n   static char buf[100];\n \n@@ -216,7 +215,7 @@ get_insn_name (index)\n }\n \n static void\n-output_prologue ()\n+output_prologue (void)\n {\n   printf (\"/* Generated automatically by the program `genoutput'\\n\\\n    from the machine description file `md'.  */\\n\\n\");\n@@ -251,7 +250,7 @@ output_prologue ()\n struct predicate { const char *name; struct predicate *next; };\n \n static void\n-output_predicate_decls ()\n+output_predicate_decls (void)\n {\n   struct predicate *predicates = 0;\n   struct operand_data *d;\n@@ -266,7 +265,7 @@ output_predicate_decls ()\n \n \tif (p == 0)\n \t  {\n-\t    printf (\"extern int %s PARAMS ((rtx, enum machine_mode));\\n\",\n+\t    printf (\"extern int %s (rtx, enum machine_mode);\\n\",\n \t\t    d->predicate);\n \t    p = (struct predicate *) xmalloc (sizeof (struct predicate));\n \t    p->name = d->predicate;\n@@ -284,7 +283,7 @@ output_predicate_decls ()\n }\n \n static void\n-output_operand_data ()\n+output_operand_data (void)\n {\n   struct operand_data *d;\n \n@@ -311,7 +310,7 @@ output_operand_data ()\n }\n \n static void\n-output_insn_data ()\n+output_insn_data (void)\n {\n   struct data *d;\n   int name_offset = 0;\n@@ -369,7 +368,7 @@ output_insn_data ()\n \t  {\n \t    const char *p = d->template;\n \t    char prev = 0;\n-\t    \n+\n \t    printf (\"    \\\"\");\n \t    while (*p)\n \t      {\n@@ -413,7 +412,7 @@ output_insn_data ()\n }\n \n static void\n-output_get_insn_name ()\n+output_get_insn_name (void)\n {\n   printf (\"const char *\\n\");\n   printf (\"get_insn_name (code)\\n\");\n@@ -438,11 +437,8 @@ static int max_opno;\n static int num_dups;\n \n static void\n-scan_operands (d, part, this_address_p, this_strict_low)\n-     struct data *d;\n-     rtx part;\n-     int this_address_p;\n-     int this_strict_low;\n+scan_operands (struct data *d, rtx part, int this_address_p,\n+\t       int this_strict_low)\n {\n   int i, j;\n   const char *format_ptr;\n@@ -554,7 +550,7 @@ scan_operands (d, part, this_address_p, this_strict_low)\n     case STRICT_LOW_PART:\n       scan_operands (d, XEXP (part, 0), 0, 1);\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -579,8 +575,7 @@ scan_operands (d, part, this_address_p, this_strict_low)\n /* Compare two operands for content equality.  */\n \n static int\n-compare_operands (d0, d1)\n-     struct operand_data *d0, *d1;\n+compare_operands (struct operand_data *d0, struct operand_data *d1)\n {\n   const char *p0, *p1;\n \n@@ -618,8 +613,7 @@ compare_operands (d0, d1)\n    find a subsequence that is the same, or allocate a new one at the end.  */\n \n static void\n-place_operands (d)\n-     struct data *d;\n+place_operands (struct data *d)\n {\n   struct operand_data *od, *od2;\n   int i;\n@@ -673,9 +667,7 @@ place_operands (d)\n    templates, or C code to generate the assembler code template.  */\n \n static void\n-process_template (d, template)\n-    struct data *d;\n-    const char *template;\n+process_template (struct data *d, const char *template)\n {\n   const char *cp;\n   int i;\n@@ -686,7 +678,7 @@ process_template (d, template)\n       d->template = 0;\n       d->output_format = INSN_OUTPUT_FORMAT_FUNCTION;\n \n-      printf (\"\\nstatic const char *output_%d PARAMS ((rtx *, rtx));\\n\",\n+      printf (\"\\nstatic const char *output_%d (rtx *, rtx);\\n\",\n \t      d->code_number);\n       puts (\"\\nstatic const char *\");\n       printf (\"output_%d (operands, insn)\\n\", d->code_number);\n@@ -744,8 +736,7 @@ process_template (d, template)\n /* Check insn D for consistency in number of constraint alternatives.  */\n \n static void\n-validate_insn_alternatives (d)\n-     struct data *d;\n+validate_insn_alternatives (struct data *d)\n {\n   int n = 0, start;\n \n@@ -816,8 +807,7 @@ validate_insn_alternatives (d)\n /* Verify that there are no gaps in operand numbers for INSNs.  */\n \n static void\n-validate_insn_operands (d)\n-     struct data *d;\n+validate_insn_operands (struct data *d)\n {\n   int i;\n \n@@ -834,9 +824,7 @@ validate_insn_operands (d)\n    a hairy output action, output a function for now.  */\n \n static void\n-gen_insn (insn, lineno)\n-     rtx insn;\n-     int lineno;\n+gen_insn (rtx insn, int lineno)\n {\n   struct data *d = (struct data *) xmalloc (sizeof (struct data));\n   int i;\n@@ -877,9 +865,7 @@ gen_insn (insn, lineno)\n    If the insn has a hairy output action, output it now.  */\n \n static void\n-gen_peephole (peep, lineno)\n-     rtx peep;\n-     int lineno;\n+gen_peephole (rtx peep, int lineno)\n {\n   struct data *d = (struct data *) xmalloc (sizeof (struct data));\n   int i;\n@@ -917,9 +903,7 @@ gen_peephole (peep, lineno)\n    only for the purposes of `insn_gen_function'.  */\n \n static void\n-gen_expand (insn, lineno)\n-     rtx insn;\n-     int lineno;\n+gen_expand (rtx insn, int lineno)\n {\n   struct data *d = (struct data *) xmalloc (sizeof (struct data));\n   int i;\n@@ -962,9 +946,7 @@ gen_expand (insn, lineno)\n    only for reasons of consistency and to simplify genrecog.  */\n \n static void\n-gen_split (split, lineno)\n-     rtx split;\n-     int lineno;\n+gen_split (rtx split, int lineno)\n {\n   struct data *d = (struct data *) xmalloc (sizeof (struct data));\n   int i;\n@@ -999,12 +981,10 @@ gen_split (split, lineno)\n   place_operands (d);\n }\n \n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n \n@@ -1037,7 +1017,7 @@ main (argc, argv)\n       if (GET_CODE (desc) == DEFINE_EXPAND)\n \tgen_expand (desc, line_no);\n       if (GET_CODE (desc) == DEFINE_SPLIT\n- \t  || GET_CODE (desc) == DEFINE_PEEPHOLE2)\n+\t  || GET_CODE (desc) == DEFINE_PEEPHOLE2)\n \tgen_split (desc, line_no);\n       next_index_number++;\n     }\n@@ -1057,9 +1037,7 @@ main (argc, argv)\n    -1 if S is the null string.  */\n \n static int\n-n_occurrences (c, s)\n-     int c;\n-     const char *s;\n+n_occurrences (int c, const char *s)\n {\n   int n = 0;\n \n@@ -1076,8 +1054,7 @@ n_occurrences (c, s)\n    Return a new string.  */\n \n static const char *\n-strip_whitespace (s)\n-     const char *s;\n+strip_whitespace (const char *s)\n {\n   char *p, *q;\n   char ch;\n@@ -1098,7 +1075,7 @@ strip_whitespace (s)\n    tampered with.  This isn't bullet-proof, but it should catch\n    most genuine mistakes.  */\n static void\n-check_constraint_len ()\n+check_constraint_len (void)\n {\n   const char *p;\n   int d;\n@@ -1110,9 +1087,7 @@ check_constraint_len ()\n }\n \n static int\n-constraint_len (p, genoutput_default_constraint_len)\n-     const char *p;\n-     int genoutput_default_constraint_len;\n+constraint_len (const char *p, int genoutput_default_constraint_len)\n {\n   /* Check that we still match defaults.h .  First we do a generation-time\n      check that fails if the value is not the expected one...  */"}, {"sha": "5e22ec0b0687b57019618f5e0e679734cdb51b06", "filename": "gcc/genpeep.c", "status": "modified", "additions": 14, "deletions": 40, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to perform peephole optimizations.\n    Copyright (C) 1987, 1989, 1992, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -53,24 +53,20 @@ static int n_operands;\n \n static int insn_code_number = 0;\n \n-static void gen_peephole PARAMS ((rtx));\n-static void match_rtx PARAMS ((rtx, struct link *, int));\n-static void print_path PARAMS ((struct link *));\n-static void print_code PARAMS ((RTX_CODE));\n+static void gen_peephole (rtx);\n+static void match_rtx (rtx, struct link *, int);\n+static void print_path (struct link *);\n+static void print_code (RTX_CODE);\n \f\n static void\n-gen_peephole (peep)\n-     rtx peep;\n+gen_peephole (rtx peep)\n {\n   int ninsns = XVECLEN (peep, 0);\n   int i;\n \n   n_operands = 0;\n \n   printf (\"  insn = ins1;\\n\");\n-#if 0\n-  printf (\"  want_jump = 0;\\n\");\n-#endif\n \n   for (i = 0; i < ninsns; i++)\n     {\n@@ -86,14 +82,9 @@ gen_peephole (peep)\n \n \t  printf (\"  if (GET_CODE (insn) == CODE_LABEL\\n\\\n       || GET_CODE (insn) == BARRIER)\\n    goto L%d;\\n\",\n-  \t\t  insn_code_number);\n+\t\t  insn_code_number);\n \t}\n \n-#if 0\n-      printf (\"  if (GET_CODE (insn) == JUMP_INSN)\\n\");\n-      printf (\"    want_jump = JUMP_LABEL (insn);\\n\");\n-#endif\n-\n       printf (\"  pat = PATTERN (insn);\\n\");\n \n       /* Walk the insn's pattern, remembering at all times the path\n@@ -117,15 +108,6 @@ gen_peephole (peep)\n \n   printf (\"  PATTERN (ins1) = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (%d, operands));\\n\", n_operands);\n \n-#if 0\n-  printf (\"  if (want_jump && GET_CODE (ins1) != JUMP_INSN)\\n\");\n-  printf (\"    {\\n\");\n-  printf (\"      rtx insn2 = emit_jump_insn_before (PATTERN (ins1), ins1);\\n\");\n-  printf (\"      delete_related_insns (ins1);\\n\");\n-  printf (\"      ins1 = ins2;\\n\");\n-  printf (\"    }\\n\");\n-#endif\n-\n   /* Record this define_peephole's insn code in the insn,\n      as if it had been recognized to match this.  */\n   printf (\"  INSN_CODE (ins1) = %d;\\n\",\n@@ -143,10 +125,7 @@ gen_peephole (peep)\n }\n \f\n static void\n-match_rtx (x, path, fail_label)\n-     rtx x;\n-     struct link *path;\n-     int fail_label;\n+match_rtx (rtx x, struct link *path, int fail_label)\n {\n   RTX_CODE code;\n   int i;\n@@ -256,7 +235,7 @@ match_rtx (x, path, fail_label)\n     case ADDRESS:\n       match_rtx (XEXP (x, 0), path, fail_label);\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -343,8 +322,7 @@ match_rtx (x, path, fail_label)\n    evaluate to the rtx at that point.  */\n \n static void\n-print_path (path)\n-     struct link *path;\n+print_path (struct link *path)\n {\n   if (path == 0)\n     printf (\"pat\");\n@@ -363,20 +341,17 @@ print_path (path)\n }\n \f\n static void\n-print_code (code)\n-     RTX_CODE code;\n+print_code (RTX_CODE code)\n {\n   const char *p1;\n   for (p1 = GET_RTX_NAME (code); *p1; p1++)\n     putchar (TOUPPER(*p1));\n }\n \n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n \n@@ -457,8 +432,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}, {"sha": "e52e424dd3c06528ede253f996864ac16ba45ab2", "filename": "gcc/genpreds.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -2,7 +2,7 @@\n    - some macros CODE_FOR_... giving the insn_code_number value\n    for each of the defined standard insn names.\n    Copyright (C) 1987, 1991, 1995, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -29,11 +29,9 @@ Boston, MA 02111-1307, USA.  */\n #define NO_GENRTL_H\n #include \"rtl.h\"\n \n-static void output_predicate_decls PARAMS ((void));\n-extern int main PARAMS ((void));\n \n static void\n-output_predicate_decls ()\n+output_predicate_decls (void)\n {\n #ifdef PREDICATE_CODES\n   static const struct {\n@@ -46,14 +44,14 @@ output_predicate_decls ()\n \n   puts (\"#ifdef RTX_CODE\\n\");\n   for (i = 0; i < ARRAY_SIZE (predicate); i++)\n-    printf (\"extern int %s PARAMS ((rtx, enum machine_mode));\\n\",\n+    printf (\"extern int %s (rtx, enum machine_mode);\\n\",\n \t    predicate[i].name);\n   puts (\"\\n#endif /* RTX_CODE */\\n\");\n #endif\n }\n \n int\n-main ()\n+main (void)\n {\n   puts (\"/* Generated automatically by the program `genpreds'.  */\\n\");\n   puts (\"#ifndef GCC_TM_PREDS_H\");"}, {"sha": "f6f733fe29916c98d90e43678b975ed26248fa07", "filename": "gcc/genrecog.c", "status": "modified", "additions": 99, "deletions": 170, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to recognize rtl as insns.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -229,96 +229,94 @@ static const char *const special_mode_pred_table[] = {\n #define NUM_SPECIAL_MODE_PREDS ARRAY_SIZE (special_mode_pred_table)\n \n static struct decision *new_decision\n-  PARAMS ((const char *, struct decision_head *));\n+  (const char *, struct decision_head *);\n static struct decision_test *new_decision_test\n-  PARAMS ((enum decision_type, struct decision_test ***));\n+  (enum decision_type, struct decision_test ***);\n static rtx find_operand\n-  PARAMS ((rtx, int));\n+  (rtx, int);\n static rtx find_matching_operand\n-  PARAMS ((rtx, int));\n+  (rtx, int);\n static void validate_pattern\n-  PARAMS ((rtx, rtx, rtx, int));\n+  (rtx, rtx, rtx, int);\n static struct decision *add_to_sequence\n-  PARAMS ((rtx, struct decision_head *, const char *, enum routine_type, int));\n+  (rtx, struct decision_head *, const char *, enum routine_type, int);\n \n static int maybe_both_true_2\n-  PARAMS ((struct decision_test *, struct decision_test *));\n+  (struct decision_test *, struct decision_test *);\n static int maybe_both_true_1\n-  PARAMS ((struct decision_test *, struct decision_test *));\n+  (struct decision_test *, struct decision_test *);\n static int maybe_both_true\n-  PARAMS ((struct decision *, struct decision *, int));\n+  (struct decision *, struct decision *, int);\n \n static int nodes_identical_1\n-  PARAMS ((struct decision_test *, struct decision_test *));\n+  (struct decision_test *, struct decision_test *);\n static int nodes_identical\n-  PARAMS ((struct decision *, struct decision *));\n+  (struct decision *, struct decision *);\n static void merge_accept_insn\n-  PARAMS ((struct decision *, struct decision *));\n+  (struct decision *, struct decision *);\n static void merge_trees\n-  PARAMS ((struct decision_head *, struct decision_head *));\n+  (struct decision_head *, struct decision_head *);\n \n static void factor_tests\n-  PARAMS ((struct decision_head *));\n+  (struct decision_head *);\n static void simplify_tests\n-  PARAMS ((struct decision_head *));\n+  (struct decision_head *);\n static int break_out_subroutines\n-  PARAMS ((struct decision_head *, int));\n+  (struct decision_head *, int);\n static void find_afterward\n-  PARAMS ((struct decision_head *, struct decision *));\n+  (struct decision_head *, struct decision *);\n \n static void change_state\n-  PARAMS ((const char *, const char *, struct decision *, const char *));\n+  (const char *, const char *, struct decision *, const char *);\n static void print_code\n-  PARAMS ((enum rtx_code));\n+  (enum rtx_code);\n static void write_afterward\n-  PARAMS ((struct decision *, struct decision *, const char *));\n+  (struct decision *, struct decision *, const char *);\n static struct decision *write_switch\n-  PARAMS ((struct decision *, int));\n+  (struct decision *, int);\n static void write_cond\n-  PARAMS ((struct decision_test *, int, enum routine_type));\n+  (struct decision_test *, int, enum routine_type);\n static void write_action\n-  PARAMS ((struct decision *, struct decision_test *, int, int,\n-\t   struct decision *, enum routine_type));\n+  (struct decision *, struct decision_test *, int, int,\n+   struct decision *, enum routine_type);\n static int is_unconditional\n-  PARAMS ((struct decision_test *, enum routine_type));\n+  (struct decision_test *, enum routine_type);\n static int write_node\n-  PARAMS ((struct decision *, int, enum routine_type));\n+  (struct decision *, int, enum routine_type);\n static void write_tree_1\n-  PARAMS ((struct decision_head *, int, enum routine_type));\n+  (struct decision_head *, int, enum routine_type);\n static void write_tree\n-  PARAMS ((struct decision_head *, const char *, enum routine_type, int));\n+  (struct decision_head *, const char *, enum routine_type, int);\n static void write_subroutine\n-  PARAMS ((struct decision_head *, enum routine_type));\n+  (struct decision_head *, enum routine_type);\n static void write_subroutines\n-  PARAMS ((struct decision_head *, enum routine_type));\n+  (struct decision_head *, enum routine_type);\n static void write_header\n-  PARAMS ((void));\n+  (void);\n \n static struct decision_head make_insn_sequence\n-  PARAMS ((rtx, enum routine_type));\n+  (rtx, enum routine_type);\n static void process_tree\n-  PARAMS ((struct decision_head *, enum routine_type));\n+  (struct decision_head *, enum routine_type);\n \n static void record_insn_name\n-  PARAMS ((int, const char *));\n+  (int, const char *);\n \n static void debug_decision_0\n-  PARAMS ((struct decision *, int, int));\n+  (struct decision *, int, int);\n static void debug_decision_1\n-  PARAMS ((struct decision *, int));\n+  (struct decision *, int);\n static void debug_decision_2\n-  PARAMS ((struct decision_test *));\n+  (struct decision_test *);\n extern void debug_decision\n-  PARAMS ((struct decision *));\n+  (struct decision *);\n extern void debug_decision_list\n-  PARAMS ((struct decision *));\n+  (struct decision *);\n \f\n /* Create a new node in sequence after LAST.  */\n \n static struct decision *\n-new_decision (position, last)\n-     const char *position;\n-     struct decision_head *last;\n+new_decision (const char *position, struct decision_head *last)\n {\n   struct decision *new\n     = (struct decision *) xmalloc (sizeof (struct decision));\n@@ -335,9 +333,7 @@ new_decision (position, last)\n /* Create a new test and link it in at PLACE.  */\n \n static struct decision_test *\n-new_decision_test (type, pplace)\n-     enum decision_type type;\n-     struct decision_test ***pplace;\n+new_decision_test (enum decision_type type, struct decision_test ***pplace)\n {\n   struct decision_test **place = *pplace;\n   struct decision_test *test;\n@@ -356,9 +352,7 @@ new_decision_test (type, pplace)\n /* Search for and return operand N.  */\n \n static rtx\n-find_operand (pattern, n)\n-     rtx pattern;\n-     int n;\n+find_operand (rtx pattern, int n)\n {\n   const char *fmt;\n   RTX_CODE code;\n@@ -411,9 +405,7 @@ find_operand (pattern, n)\n    constraint for operand N.  */\n \n static rtx\n-find_matching_operand (pattern, n)\n-     rtx pattern;\n-     int n;\n+find_matching_operand (rtx pattern, int n)\n {\n   const char *fmt;\n   RTX_CODE code;\n@@ -466,11 +458,7 @@ find_matching_operand (pattern, n)\n    '+' within a context that requires in-out constraints.  */\n \n static void\n-validate_pattern (pattern, insn, set, set_code)\n-     rtx pattern;\n-     rtx insn;\n-     rtx set;\n-     int set_code;\n+validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n {\n   const char *fmt;\n   RTX_CODE code;\n@@ -553,7 +541,7 @@ validate_pattern (pattern, insn, set, set_code)\n \t  {\n \t    const char constraints0 = XSTR (pattern, 2)[0];\n \n-\t    /* In DEFINE_EXPAND, DEFINE_SPLIT, and DEFINE_PEEPHOLE2, we \n+\t    /* In DEFINE_EXPAND, DEFINE_SPLIT, and DEFINE_PEEPHOLE2, we\n \t       don't use the MATCH_OPERAND constraint, only the predicate.\n \t       This is confusing to folks doing new ports, so help them\n \t       not make the mistake.  */\n@@ -566,7 +554,7 @@ validate_pattern (pattern, insn, set, set_code)\n \t\t\t\t     \"warning: constraints not supported in %s\",\n \t\t\t\t     rtx_name[GET_CODE (insn)]);\n \t      }\n-\t      \n+\n \t    /* A MATCH_OPERAND that is a SET should have an output reload.  */\n \t    else if (set && constraints0)\n \t      {\n@@ -590,7 +578,7 @@ validate_pattern (pattern, insn, set, set_code)\n \t\telse if (constraints0 != '=' && constraints0 != '+')\n \t\t  {\n \t\t    message_with_line (pattern_lineno,\n-\t\t\t\t       \"operand %d missing output reload\", \n+\t\t\t\t       \"operand %d missing output reload\",\n \t\t\t\t       XINT (pattern, 0));\n \t\t    error_count++;\n \t\t  }\n@@ -767,12 +755,8 @@ validate_pattern (pattern, insn, set, set_code)\n    A pointer to the final node in the chain is returned.  */\n \n static struct decision *\n-add_to_sequence (pattern, last, position, insn_type, top)\n-     rtx pattern;\n-     struct decision_head *last;\n-     const char *position;\n-     enum routine_type insn_type;\n-     int top;\n+add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n+\t\t enum routine_type insn_type, int top)\n {\n   RTX_CODE code;\n   struct decision *this, *sub;\n@@ -1062,8 +1046,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n    Returns > 0 for \"definitely both true\" and < 0 for \"maybe both true\".  */\n \n static int\n-maybe_both_true_2 (d1, d2)\n-     struct decision_test *d1, *d2;\n+maybe_both_true_2 (struct decision_test *d1, struct decision_test *d2)\n {\n   if (d1->type == d2->type)\n     {\n@@ -1173,8 +1156,7 @@ maybe_both_true_2 (d1, d2)\n    Returns > 0 for \"definitely both true\" and < 0 for \"maybe both true\".  */\n \n static int\n-maybe_both_true_1 (d1, d2)\n-     struct decision_test *d1, *d2;\n+maybe_both_true_1 (struct decision_test *d1, struct decision_test *d2)\n {\n   struct decision_test *t1, *t2;\n \n@@ -1208,9 +1190,8 @@ maybe_both_true_1 (d1, d2)\n    recursively descend.  */\n \n static int\n-maybe_both_true (d1, d2, toplevel)\n-     struct decision *d1, *d2;\n-     int toplevel;\n+maybe_both_true (struct decision *d1, struct decision *d2,\n+\t\t int toplevel)\n {\n   struct decision *p1, *p2;\n   int cmp;\n@@ -1277,8 +1258,7 @@ maybe_both_true (d1, d2, toplevel)\n /* A subroutine of nodes_identical.  Examine two tests for equivalence.  */\n \n static int\n-nodes_identical_1 (d1, d2)\n-     struct decision_test *d1, *d2;\n+nodes_identical_1 (struct decision_test *d1, struct decision_test *d2)\n {\n   switch (d1->type)\n     {\n@@ -1325,8 +1305,7 @@ nodes_identical_1 (d1, d2)\n    consider different orderings on the tests.  */\n \n static int\n-nodes_identical (d1, d2)\n-     struct decision *d1, *d2;\n+nodes_identical (struct decision *d1, struct decision *d2)\n {\n   struct decision_test *t1, *t2;\n \n@@ -1362,8 +1341,7 @@ nodes_identical (d1, d2)\n    source machine description.  */\n \n static void\n-merge_accept_insn (oldd, addd)\n-     struct decision *oldd, *addd;\n+merge_accept_insn (struct decision *oldd, struct decision *addd)\n {\n   struct decision_test *old, *add;\n \n@@ -1407,8 +1385,7 @@ merge_accept_insn (oldd, addd)\n /* Merge two decision trees OLDH and ADDH, modifying OLDH destructively.  */\n \n static void\n-merge_trees (oldh, addh)\n-     struct decision_head *oldh, *addh;\n+merge_trees (struct decision_head *oldh, struct decision_head *addh)\n {\n   struct decision *next, *add;\n \n@@ -1492,8 +1469,7 @@ merge_trees (oldh, addh)\n    (depending on the test type) to emit switch statements later.  */\n \n static void\n-factor_tests (head)\n-     struct decision_head *head;\n+factor_tests (struct decision_head *head)\n {\n   struct decision *first, *next;\n \n@@ -1578,8 +1554,7 @@ factor_tests (head)\n    predicates, remove them.  */\n \n static void\n-simplify_tests (head)\n-     struct decision_head *head;\n+simplify_tests (struct decision_head *head)\n {\n   struct decision *tree;\n \n@@ -1616,9 +1591,7 @@ simplify_tests (head)\n    that is generated.  */\n \n static int\n-break_out_subroutines (head, initial)\n-     struct decision_head *head;\n-     int initial;\n+break_out_subroutines (struct decision_head *head, int initial)\n {\n   int size = 0;\n   struct decision *sub;\n@@ -1638,9 +1611,7 @@ break_out_subroutines (head, initial)\n    when p is true.  */\n \n static void\n-find_afterward (head, real_afterward)\n-     struct decision_head *head;\n-     struct decision *real_afterward;\n+find_afterward (struct decision_head *head, struct decision *real_afterward)\n {\n   struct decision *p, *q, *afterward;\n \n@@ -1687,11 +1658,8 @@ find_afterward (head, real_afterward)\n    match multiple insns and we try to step past the end of the stream.  */\n \n static void\n-change_state (oldpos, newpos, afterward, indent)\n-     const char *oldpos;\n-     const char *newpos;\n-     struct decision *afterward;\n-     const char *indent;\n+change_state (const char *oldpos, const char *newpos,\n+\t      struct decision *afterward, const char *indent)\n {\n   int odepth = strlen (oldpos);\n   int ndepth = strlen (newpos);\n@@ -1748,8 +1716,7 @@ change_state (oldpos, newpos, afterward, indent)\n    the name.  */\n \n static void\n-print_code (code)\n-     enum rtx_code code;\n+print_code (enum rtx_code code)\n {\n   const char *p;\n   for (p = GET_RTX_NAME (code); *p; p++)\n@@ -1759,10 +1726,8 @@ print_code (code)\n /* Emit code to cross an afterward link -- change state and branch.  */\n \n static void\n-write_afterward (start, afterward, indent)\n-     struct decision *start;\n-     struct decision *afterward;\n-     const char *indent;\n+write_afterward (struct decision *start, struct decision *afterward,\n+\t\t const char *indent)\n {\n   if (!afterward || start->subroutine_number > 0)\n     printf(\"%sgoto ret0;\\n\", indent);\n@@ -1777,9 +1742,7 @@ write_afterward (start, afterward, indent)\n    nodes at START.  Return the first node yet untested.  */\n \n static struct decision *\n-write_switch (start, depth)\n-     struct decision *start;\n-     int depth;\n+write_switch (struct decision *start, int depth)\n {\n   struct decision *p = start;\n   enum decision_type type = p->tests->type;\n@@ -1976,10 +1939,8 @@ write_switch (start, depth)\n /* Emit code for one test.  */\n \n static void\n-write_cond (p, depth, subroutine_type)\n-     struct decision_test *p;\n-     int depth;\n-     enum routine_type subroutine_type;\n+write_cond (struct decision_test *p, int depth,\n+\t    enum routine_type subroutine_type)\n {\n   switch (p->type)\n     {\n@@ -2051,12 +2012,9 @@ write_cond (p, depth, subroutine_type)\n    perform a state change.  For the `accept' tests we must do more work.  */\n \n static void\n-write_action (p, test, depth, uncond, success, subroutine_type)\n-     struct decision *p;\n-     struct decision_test *test;\n-     int depth, uncond;\n-     struct decision *success;\n-     enum routine_type subroutine_type;\n+write_action (struct decision *p, struct decision_test *test,\n+\t      int depth, int uncond, struct decision *success,\n+\t      enum routine_type subroutine_type)\n {\n   const char *indent;\n   int want_close = 0;\n@@ -2142,9 +2100,7 @@ write_action (p, test, depth, uncond, success, subroutine_type)\n /* ??? is_unconditional is a stupid name for a tri-state function.  */\n \n static int\n-is_unconditional (t, subroutine_type)\n-     struct decision_test *t;\n-     enum routine_type subroutine_type;\n+is_unconditional (struct decision_test *t, enum routine_type subroutine_type)\n {\n   if (t->type == DT_accept_op)\n     return 1;\n@@ -2171,10 +2127,8 @@ is_unconditional (t, subroutine_type)\n    Return true if there is no fallthru path.  */\n \n static int\n-write_node (p, depth, subroutine_type)\n-     struct decision *p;\n-     int depth;\n-     enum routine_type subroutine_type;\n+write_node (struct decision *p, int depth,\n+\t    enum routine_type subroutine_type)\n {\n   struct decision_test *test, *last_test;\n   int uncond;\n@@ -2210,10 +2164,8 @@ write_node (p, depth, subroutine_type)\n /* Emit code for all of the sibling nodes of HEAD.  */\n \n static void\n-write_tree_1 (head, depth, subroutine_type)\n-     struct decision_head *head;\n-     int depth;\n-     enum routine_type subroutine_type;\n+write_tree_1 (struct decision_head *head, int depth,\n+\t      enum routine_type subroutine_type)\n {\n   struct decision *p, *next;\n   int uncond = 0;\n@@ -2246,11 +2198,8 @@ write_tree_1 (head, depth, subroutine_type)\n    position at the node that branched to this node.  */\n \n static void\n-write_tree (head, prevpos, type, initial)\n-     struct decision_head *head;\n-     const char *prevpos;\n-     enum routine_type type;\n-     int initial;\n+write_tree (struct decision_head *head, const char *prevpos,\n+\t    enum routine_type type, int initial)\n {\n   struct decision *p = head->first;\n \n@@ -2306,9 +2255,7 @@ write_tree (head, prevpos, type, initial)\n    node TREE.  */\n \n static void\n-write_subroutine (head, type)\n-     struct decision_head *head;\n-     enum routine_type type;\n+write_subroutine (struct decision_head *head, enum routine_type type)\n {\n   int subfunction = head->first ? head->first->subroutine_number : 0;\n   const char *s_or_e;\n@@ -2327,22 +2274,22 @@ write_subroutine (head, type)\n   switch (type)\n     {\n     case RECOG:\n-      printf (\"%sint recog%s PARAMS ((rtx, rtx, int *));\\n\", s_or_e, extension);\n+      printf (\"%sint recog%s (rtx, rtx, int *);\\n\", s_or_e, extension);\n       printf (\"%sint\\n\\\n recog%s (x0, insn, pnum_clobbers)\\n\\\n      rtx x0 ATTRIBUTE_UNUSED;\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\\\n      int *pnum_clobbers ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     case SPLIT:\n-      printf (\"%srtx split%s PARAMS ((rtx, rtx));\\n\", s_or_e, extension);\n+      printf (\"%srtx split%s (rtx, rtx);\\n\", s_or_e, extension);\n       printf (\"%srtx\\n\\\n split%s (x0, insn)\\n\\\n      rtx x0 ATTRIBUTE_UNUSED;\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     case PEEPHOLE2:\n-      printf (\"%srtx peephole2%s PARAMS ((rtx, rtx, int *));\\n\",\n+      printf (\"%srtx peephole2%s (rtx, rtx, int *);\\n\",\n \t      s_or_e, extension);\n       printf (\"%srtx\\n\\\n peephole2%s (x0, insn, _pmatch_len)\\n\\\n@@ -2373,9 +2320,7 @@ peephole2%s (x0, insn, _pmatch_len)\\n\\\n    subroutines, but did not write them out.  Do so now.  */\n \n static void\n-write_subroutines (head, type)\n-     struct decision_head *head;\n-     enum routine_type type;\n+write_subroutines (struct decision_head *head, enum routine_type type)\n {\n   struct decision *p;\n \n@@ -2390,7 +2335,7 @@ write_subroutines (head, type)\n /* Begin the output file.  */\n \n static void\n-write_header ()\n+write_header (void)\n {\n   puts (\"\\\n /* Generated automatically by the program `genrecog' from the target\\n\\\n@@ -2452,9 +2397,7 @@ write_header ()\n    TYPE says what type of routine we are recognizing (RECOG or SPLIT).  */\n \n static struct decision_head\n-make_insn_sequence (insn, type)\n-     rtx insn;\n-     enum routine_type type;\n+make_insn_sequence (rtx insn, enum routine_type type)\n {\n   rtx x;\n   const char *c_test = XSTR (insn, type == RECOG ? 2 : 1);\n@@ -2609,12 +2552,12 @@ make_insn_sequence (insn, type)\n \n     case SPLIT:\n       /* Define the subroutine we will call below and emit in genemit.  */\n-      printf (\"extern rtx gen_split_%d PARAMS ((rtx *));\\n\", next_insn_code);\n+      printf (\"extern rtx gen_split_%d (rtx *);\\n\", next_insn_code);\n       break;\n \n     case PEEPHOLE2:\n       /* Define the subroutine we will call below and emit in genemit.  */\n-      printf (\"extern rtx gen_peephole2_%d PARAMS ((rtx, rtx *));\\n\",\n+      printf (\"extern rtx gen_peephole2_%d (rtx, rtx *);\\n\",\n \t      next_insn_code);\n       break;\n     }\n@@ -2623,9 +2566,7 @@ make_insn_sequence (insn, type)\n }\n \n static void\n-process_tree (head, subroutine_type)\n-     struct decision_head *head;\n-     enum routine_type subroutine_type;\n+process_tree (struct decision_head *head, enum routine_type subroutine_type)\n {\n   if (head->first == NULL)\n     {\n@@ -2652,12 +2593,10 @@ process_tree (head, subroutine_type)\n   write_subroutine (head, subroutine_type);\n }\n \f\n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n   struct decision_head recog_tree, split_tree, peephole2_tree, h;\n@@ -2721,8 +2660,7 @@ main (argc, argv)\n \f\n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code;\n+get_insn_name (int code)\n {\n   if (code < insn_name_ptr_size)\n     return insn_name_ptr[code];\n@@ -2731,9 +2669,7 @@ get_insn_name (code)\n }\n \n static void\n-record_insn_name (code, name)\n-     int code;\n-     const char *name;\n+record_insn_name (int code, const char *name)\n {\n   static const char *last_real_name = \"insn\";\n   static int last_real_code = 0;\n@@ -2765,8 +2701,7 @@ record_insn_name (code, name)\n }\n \f\n static void\n-debug_decision_2 (test)\n-     struct decision_test *test;\n+debug_decision_2 (struct decision_test *test)\n {\n   switch (test->type)\n     {\n@@ -2823,9 +2758,7 @@ debug_decision_2 (test)\n }\n \n static void\n-debug_decision_1 (d, indent)\n-     struct decision *d;\n-     int indent;\n+debug_decision_1 (struct decision *d, int indent)\n {\n   int i;\n   struct decision_test *test;\n@@ -2858,9 +2791,7 @@ debug_decision_1 (d, indent)\n }\n \n static void\n-debug_decision_0 (d, indent, maxdepth)\n-     struct decision *d;\n-     int indent, maxdepth;\n+debug_decision_0 (struct decision *d, int indent, int maxdepth)\n {\n   struct decision *n;\n   int i;\n@@ -2881,15 +2812,13 @@ debug_decision_0 (d, indent, maxdepth)\n }\n \n void\n-debug_decision (d)\n-     struct decision *d;\n+debug_decision (struct decision *d)\n {\n   debug_decision_0 (d, 0, 1000000);\n }\n \n void\n-debug_decision_list (d)\n-     struct decision *d;\n+debug_decision_list (struct decision *d)\n {\n   while (d)\n     {"}, {"sha": "979c33533205a7460375c9336072fa0ddc5a6008", "filename": "gcc/gensupport.c", "status": "modified", "additions": 55, "deletions": 86, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,6 @@\n /* Support routines for the various generation passes.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -68,8 +69,8 @@ static struct queue_elem **define_cond_exec_tail = &define_cond_exec_queue;\n static struct queue_elem *other_queue;\n static struct queue_elem **other_tail = &other_queue;\n \n-static void queue_pattern PARAMS ((rtx, struct queue_elem ***,\n-\t\t\t\t   const char *, int));\n+static void queue_pattern (rtx, struct queue_elem ***,\n+\t\t\t   const char *, int);\n \n /* Current maximum length of directory names in the search path\n    for include files.  (Altered as we get more of them.)  */\n@@ -87,30 +88,30 @@ struct file_name_list *first_dir_md_include = 0;  /* First dir to search */\n struct file_name_list *first_bracket_include = 0;\n struct file_name_list *last_dir_md_include = 0;        /* Last in chain */\n \n-static void remove_constraints PARAMS ((rtx));\n-static void process_rtx PARAMS ((rtx, int));\n-\n-static int is_predicable PARAMS ((struct queue_elem *));\n-static void identify_predicable_attribute PARAMS ((void));\n-static int n_alternatives PARAMS ((const char *));\n-static void collect_insn_data PARAMS ((rtx, int *, int *));\n-static rtx alter_predicate_for_insn PARAMS ((rtx, int, int, int));\n-static const char *alter_test_for_insn PARAMS ((struct queue_elem *,\n-\t\t\t\t\t\tstruct queue_elem *));\n-static char *shift_output_template PARAMS ((char *, const char *, int));\n-static const char *alter_output_for_insn PARAMS ((struct queue_elem *,\n-\t\t\t\t\t\t  struct queue_elem *,\n-\t\t\t\t\t\t  int, int));\n-static void process_one_cond_exec PARAMS ((struct queue_elem *));\n-static void process_define_cond_exec PARAMS ((void));\n-static void process_include PARAMS ((rtx, int));\n-static char *save_string PARAMS ((const char *, int));\n+static void remove_constraints (rtx);\n+static void process_rtx (rtx, int);\n+\n+static int is_predicable (struct queue_elem *);\n+static void identify_predicable_attribute (void);\n+static int n_alternatives (const char *);\n+static void collect_insn_data (rtx, int *, int *);\n+static rtx alter_predicate_for_insn (rtx, int, int, int);\n+static const char *alter_test_for_insn (struct queue_elem *,\n+\t\t\t\t\tstruct queue_elem *);\n+static char *shift_output_template (char *, const char *, int);\n+static const char *alter_output_for_insn (struct queue_elem *,\n+\t\t\t\t\t  struct queue_elem *,\n+\t\t\t\t\t  int, int);\n+static void process_one_cond_exec (struct queue_elem *);\n+static void process_define_cond_exec (void);\n+static void process_include (rtx, int);\n+static char *save_string (const char *, int);\n \f\n void\n message_with_line (int lineno, const char *msg, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msg);\n \n   fprintf (stderr, \"%s:%d: \", read_rtx_filename, lineno);\n@@ -124,9 +125,8 @@ message_with_line (int lineno, const char *msg, ...)\n    the gensupport programs.  */\n \n rtx\n-gen_rtx_CONST_INT (mode, arg)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT arg;\n+gen_rtx_CONST_INT (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   HOST_WIDE_INT arg)\n {\n   rtx rt = rtx_alloc (CONST_INT);\n \n@@ -137,11 +137,8 @@ gen_rtx_CONST_INT (mode, arg)\n /* Queue PATTERN on LIST_TAIL.  */\n \n static void\n-queue_pattern (pattern, list_tail, filename, lineno)\n-     rtx pattern;\n-     struct queue_elem ***list_tail;\n-     const char *filename;\n-     int lineno;\n+queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n+\t       const char *filename, int lineno)\n {\n   struct queue_elem *e = (struct queue_elem *) xmalloc (sizeof (*e));\n   e->data = pattern;\n@@ -155,8 +152,7 @@ queue_pattern (pattern, list_tail, filename, lineno)\n /* Recursively remove constraints from an rtx.  */\n \n static void\n-remove_constraints (part)\n-     rtx part;\n+remove_constraints (rtx part)\n {\n   int i, j;\n   const char *format_ptr;\n@@ -186,13 +182,11 @@ remove_constraints (part)\n       }\n }\n \n-/* Process an include file assuming that it lives in gcc/config/{target}/ \n+/* Process an include file assuming that it lives in gcc/config/{target}/\n    if the include looks like (include \"file\").  */\n \n static void\n-process_include (desc, lineno)\n-     rtx desc;\n-     int lineno;\n+process_include (rtx desc, int lineno)\n {\n   const char *filename = XSTR (desc, 0);\n   const char *old_filename;\n@@ -212,7 +206,7 @@ process_include (desc, lineno)\n \n \t  pathname = concat (stackp->fname, sep, filename, NULL);\n \t  input_file = fopen (pathname, \"r\");\n-\t  if (input_file != NULL) \n+\t  if (input_file != NULL)\n \t    goto success;\n \t  free (pathname);\n \t}\n@@ -268,9 +262,7 @@ process_include (desc, lineno)\n /* Process a top level rtx in some way, queueing as appropriate.  */\n \n static void\n-process_rtx (desc, lineno)\n-     rtx desc;\n-     int lineno;\n+process_rtx (rtx desc, int lineno)\n {\n   switch (GET_CODE (desc))\n     {\n@@ -338,8 +330,7 @@ process_rtx (desc, lineno)\n    a DEFINE_INSN.  */\n \n static int\n-is_predicable (elem)\n-     struct queue_elem *elem;\n+is_predicable (struct queue_elem *elem)\n {\n   rtvec vec = XVEC (elem->data, 4);\n   const char *value;\n@@ -427,7 +418,7 @@ is_predicable (elem)\n    and its default.  */\n \n static void\n-identify_predicable_attribute ()\n+identify_predicable_attribute (void)\n {\n   struct queue_elem *elem;\n   char *p_true, *p_false;\n@@ -494,8 +485,7 @@ identify_predicable_attribute ()\n /* Return the number of alternatives in constraint S.  */\n \n static int\n-n_alternatives (s)\n-     const char *s;\n+n_alternatives (const char *s)\n {\n   int n = 1;\n \n@@ -510,9 +500,7 @@ n_alternatives (s)\n    operands.  */\n \n static void\n-collect_insn_data (pattern, palt, pmax)\n-     rtx pattern;\n-     int *palt, *pmax;\n+collect_insn_data (rtx pattern, int *palt, int *pmax)\n {\n   const char *fmt;\n   enum rtx_code code;\n@@ -568,9 +556,7 @@ collect_insn_data (pattern, palt, pmax)\n }\n \n static rtx\n-alter_predicate_for_insn (pattern, alt, max_op, lineno)\n-     rtx pattern;\n-     int alt, max_op, lineno;\n+alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n {\n   const char *fmt;\n   enum rtx_code code;\n@@ -659,8 +645,8 @@ alter_predicate_for_insn (pattern, alt, max_op, lineno)\n }\n \n static const char *\n-alter_test_for_insn (ce_elem, insn_elem)\n-     struct queue_elem *ce_elem, *insn_elem;\n+alter_test_for_insn (struct queue_elem *ce_elem,\n+\t\t     struct queue_elem *insn_elem)\n {\n   const char *ce_test, *insn_test;\n \n@@ -679,10 +665,7 @@ alter_test_for_insn (ce_elem, insn_elem)\n    adjusted string.  */\n \n static char *\n-shift_output_template (new, old, disp)\n-     char *new;\n-     const char *old;\n-     int disp;\n+shift_output_template (char *new, const char *old, int disp)\n {\n   while (*old)\n     {\n@@ -706,9 +689,9 @@ shift_output_template (new, old, disp)\n }\n \n static const char *\n-alter_output_for_insn (ce_elem, insn_elem, alt, max_op)\n-     struct queue_elem *ce_elem, *insn_elem;\n-     int alt, max_op;\n+alter_output_for_insn (struct queue_elem *ce_elem,\n+\t\t       struct queue_elem *insn_elem,\n+\t\t       int alt, int max_op)\n {\n   const char *ce_out, *insn_out;\n   char *new, *p;\n@@ -768,8 +751,7 @@ alter_output_for_insn (ce_elem, insn_elem, alt, max_op)\n /* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */\n \n static void\n-process_one_cond_exec (ce_elem)\n-     struct queue_elem *ce_elem;\n+process_one_cond_exec (struct queue_elem *ce_elem)\n {\n   struct queue_elem *insn_elem;\n   for (insn_elem = define_insn_queue; insn_elem ; insn_elem = insn_elem->next)\n@@ -845,7 +827,7 @@ process_one_cond_exec (ce_elem)\n    patterns appropriately.  */\n \n static void\n-process_define_cond_exec ()\n+process_define_cond_exec (void)\n {\n   struct queue_elem *elem;\n \n@@ -858,9 +840,7 @@ process_define_cond_exec ()\n }\n \n static char *\n-save_string (s, len)\n-     const char *s;\n-     int len;\n+save_string (const char *s, int len)\n {\n   register char *result = xmalloc (len + 1);\n \n@@ -873,9 +853,7 @@ save_string (s, len)\n /* The entry point for initializing the reader.  */\n \n int\n-init_md_reader_args (argc, argv)\n-     int argc;\n-     char **argv;\n+init_md_reader_args (int argc, char **argv)\n {\n   int i;\n   const char *in_fname;\n@@ -928,16 +906,15 @@ init_md_reader_args (argc, argv)\n /* The entry point for initializing the reader.  */\n \n int\n-init_md_reader (filename)\n-     const char *filename;\n+init_md_reader (const char *filename)\n {\n   FILE *input_file;\n   int c;\n   size_t i;\n   char *lastsl;\n \n   lastsl = strrchr (filename, '/');\n-  if (lastsl != NULL) \n+  if (lastsl != NULL)\n     base_dir = save_string (filename, lastsl - filename + 1 );\n \n   read_rtx_filename = filename;\n@@ -987,9 +964,7 @@ init_md_reader (filename)\n /* The entry point for reading a single rtx from an md file.  */\n \n rtx\n-read_md_rtx (lineno, seqnr)\n-     int *lineno;\n-     int *seqnr;\n+read_md_rtx (int *lineno, int *seqnr)\n {\n   struct queue_elem **queue, *elem;\n   rtx desc;\n@@ -1052,8 +1027,7 @@ read_md_rtx (lineno, seqnr)\n /* Compute a hash function of a c_test structure, which is keyed\n    by its ->expr field.  */\n hashval_t\n-hash_c_test (x)\n-     const PTR x;\n+hash_c_test (const void *x)\n {\n   const struct c_test *a = (const struct c_test *) x;\n   const unsigned char *base, *s = (const unsigned char *) a->expr;\n@@ -1079,9 +1053,7 @@ hash_c_test (x)\n \n /* Compare two c_test expression structures.  */\n int\n-cmp_c_test (x, y)\n-     const PTR x;\n-     const PTR y;\n+cmp_c_test (const void *x, const void *y)\n {\n   const struct c_test *a = (const struct c_test *) x;\n   const struct c_test *b = (const struct c_test *) y;\n@@ -1094,8 +1066,7 @@ cmp_c_test (x, y)\n    at compile time.  Returns a tristate: 1 for known true, 0 for\n    known false, -1 for unknown.  */\n int\n-maybe_eval_c_test (expr)\n-     const char *expr;\n+maybe_eval_c_test (const char *expr)\n {\n   const struct c_test *test;\n   struct c_test dummy;\n@@ -1117,8 +1088,7 @@ maybe_eval_c_test (expr)\n /* Given a string, return the number of comma-separated elements in it.\n    Return 0 for the null string.  */\n int\n-n_comma_elts (s)\n-     const char *s;\n+n_comma_elts (const char *s)\n {\n   int n;\n \n@@ -1139,8 +1109,7 @@ n_comma_elts (s)\n    a comma and an element is ignored.  */\n \n const char *\n-scan_comma_elt (pstr)\n-     const char **pstr;\n+scan_comma_elt (const char **pstr)\n {\n   const char *start;\n   const char *p = *pstr;"}, {"sha": "7ceccfbaeb119ac3572bbafbb67d76cbf5c2a274", "filename": "gcc/gensupport.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for rtx-reader support for gen* routines.\n-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -24,11 +24,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n struct obstack;\n extern struct obstack *rtl_obstack;\n \n-extern int init_md_reader_args\tPARAMS ((int, char **));\n-extern int init_md_reader\tPARAMS ((const char *));\n-extern rtx read_md_rtx\t\tPARAMS ((int *, int *));\n+extern int init_md_reader_args (int, char **);\n+extern int init_md_reader (const char *);\n+extern rtx read_md_rtx (int *, int *);\n \n-extern void message_with_line\tPARAMS ((int, const char *, ...))\n+extern void message_with_line (int, const char *, ...)\n      ATTRIBUTE_PRINTF_2;\n \n /* Set this to 0 to disable automatic elision of insn patterns which\n@@ -46,7 +46,7 @@ extern const int insn_elision_unavailable;\n    time, return its truth value; else return -1.  The test must have\n    appeared somewhere in the machine description when genconditions\n    was run.  */\n-extern int maybe_eval_c_test\tPARAMS ((const char *));\n+extern int maybe_eval_c_test (const char *);\n \n /* This table should not be accessed directly; use maybe_eval_c_test.  */\n struct c_test\n@@ -59,11 +59,11 @@ extern const struct c_test insn_conditions[];\n extern const size_t n_insn_conditions;\n \n #ifdef __HASHTAB_H__\n-extern hashval_t hash_c_test PARAMS ((const PTR));\n-extern int cmp_c_test PARAMS ((const PTR, const PTR));\n+extern hashval_t hash_c_test (const void *);\n+extern int cmp_c_test (const void *, const void *);\n #endif\n \n-extern int n_comma_elts\t\tPARAMS ((const char *));\n-extern const char *scan_comma_elt PARAMS ((const char **));\n+extern int n_comma_elts\t(const char *);\n+extern const char *scan_comma_elt (const char **);\n \n #endif /* GCC_GENSUPPORT_H */"}, {"sha": "04613294ac4191341111b0f21a1fed2e619691b1", "filename": "gcc/intl.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fintl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fintl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* Message translation utilities.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -32,7 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    terminal, so it has be set to output messages correctly.  */\n \n void\n-gcc_init_libintl ()\n+gcc_init_libintl (void)\n {\n #ifdef HAVE_LC_MESSAGES\n   setlocale (LC_CTYPE, \"\");\n@@ -52,8 +52,7 @@ gcc_init_libintl ()\n    This is for indenting subsequent output.  */\n \n size_t\n-gcc_gettext_width (msgstr)\n-     const char *msgstr;\n+gcc_gettext_width (const char *msgstr)\n {\n   size_t nwcs = mbstowcs (0, msgstr, 0);\n   wchar_t *wmsgstr = alloca ((nwcs + 1) * sizeof (wchar_t));\n@@ -68,8 +67,7 @@ gcc_gettext_width (msgstr)\n    the length of the string.  */\n \n size_t\n-gcc_gettext_width (msgstr)\n-     const char *msgstr;\n+gcc_gettext_width (const char *msgstr)\n {\n   return strlen (msgstr);\n }"}, {"sha": "3acc511cc07aadfa97d0809e9b55e4d784d931fd", "filename": "gcc/intl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fintl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fintl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl.h?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* intl.h - internationalization\n-   Copyright 1998, 2001 Free Software Foundation, Inc.\n+   Copyright 1998, 2001, 2003 Free Software Foundation, Inc.\n \n    GCC is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -38,8 +38,8 @@\n #endif\n \n #ifdef ENABLE_NLS\n-extern void gcc_init_libintl PARAMS ((void));\n-extern size_t gcc_gettext_width PARAMS ((const char *));\n+extern void gcc_init_libintl (void);\n+extern size_t gcc_gettext_width (const char *);\n #else\n /* Stubs.  */\n # undef textdomain"}, {"sha": "57eda4b2f1f261022fec37f867b68c6419671134", "filename": "gcc/lists.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,6 +1,6 @@\n /* List management for the GNU C-Compiler expander.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999 Free Software Foundation, Inc.\n+   1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -27,7 +27,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"rtl.h\"\n #include \"ggc.h\"\n \n-static void free_list PARAMS ((rtx *, rtx *));\n+static void free_list (rtx *, rtx *);\n \n /* Functions for maintaining cache-able lists of EXPR_LIST and INSN_LISTs.  */\n \n@@ -43,8 +43,7 @@ static GTY ((deletable (\"\"))) rtx unused_expr_list;\n    nodes of one type only.  This is only called by free_EXPR_LIST_list\n    and free_INSN_LIST_list.  */\n static void\n-free_list (listp, unused_listp)\n-     rtx *listp, *unused_listp;\n+free_list (rtx *listp, rtx *unused_listp)\n {\n   rtx link, prev_link;\n \n@@ -66,8 +65,7 @@ free_list (listp, unused_listp)\n    node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST\n    is made.  */\n rtx\n-alloc_INSN_LIST (val, next)\n-     rtx val, next;\n+alloc_INSN_LIST (rtx val, rtx next)\n {\n   rtx r;\n \n@@ -89,9 +87,7 @@ alloc_INSN_LIST (val, next)\n    node available, we'll use it, otherwise a call to gen_rtx_EXPR_LIST\n    is made.  */\n rtx\n-alloc_EXPR_LIST (kind, val, next)\n-     int kind;\n-     rtx val, next;\n+alloc_EXPR_LIST (int kind, rtx val, rtx next)\n {\n   rtx r;\n \n@@ -111,8 +107,7 @@ alloc_EXPR_LIST (kind, val, next)\n \n /* This function will free up an entire list of EXPR_LIST nodes.  */\n void\n-free_EXPR_LIST_list (listp)\n-     rtx *listp;\n+free_EXPR_LIST_list (rtx *listp)\n {\n   if (*listp == 0)\n     return;\n@@ -121,8 +116,7 @@ free_EXPR_LIST_list (listp)\n \n /* This function will free up an entire list of INSN_LIST nodes.  */\n void\n-free_INSN_LIST_list (listp)\n-     rtx *listp;\n+free_INSN_LIST_list (rtx *listp)\n {\n   if (*listp == 0)\n     return;\n@@ -131,17 +125,15 @@ free_INSN_LIST_list (listp)\n \n /* This function will free up an individual EXPR_LIST node.  */\n void\n-free_EXPR_LIST_node (ptr)\n-     rtx ptr;\n+free_EXPR_LIST_node (rtx ptr)\n {\n   XEXP (ptr, 1) = unused_expr_list;\n   unused_expr_list = ptr;\n }\n \n /* This function will free up an individual INSN_LIST node.  */\n void\n-free_INSN_LIST_node (ptr)\n-     rtx ptr;\n+free_INSN_LIST_node (rtx ptr)\n {\n   XEXP (ptr, 1) = unused_insn_list;\n   unused_insn_list = ptr;"}, {"sha": "3ef0a7fdf5ad194db7cd1df96aeb0bef4a878750", "filename": "gcc/params.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* params.c - Run-time parameters.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n \n This file is part of GCC.\n@@ -40,9 +40,7 @@ static size_t num_compiler_params;\n /* Add the N PARAMS to the current list of compiler parameters.  */\n \n void\n-add_params (params, n)\n-     const param_info params[];\n-     size_t n;\n+add_params (const param_info params[], size_t n)\n {\n   /* Allocate enough space for the new parameters.  */\n   compiler_params =\n@@ -60,9 +58,7 @@ add_params (params, n)\n /* Set the VALUE associated with the parameter given by NAME.  */\n \n void\n-set_param_value (name, value)\n-     const char *name;\n-     int value;\n+set_param_value (const char *name, int value)\n {\n   size_t i;\n "}, {"sha": "0a784454ccd1d638c90c7e7209433df152cfefbf", "filename": "gcc/params.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -1,5 +1,5 @@\n /* params.h - Run-time parameters.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>.\n \n This file is part of GCC.\n@@ -59,13 +59,11 @@ extern param_info *compiler_params;\n \n /* Add the N PARAMS to the current list of compiler parameters.  */\n \n-extern void add_params\n-  PARAMS ((const param_info params[], size_t n));\n+extern void add_params (const param_info params[], size_t n);\n \n /* Set the VALUE associated with the parameter given by NAME.  */\n \n-extern void set_param_value\n-  PARAMS ((const char *name, int value));\n+extern void set_param_value (const char *name, int value);\n \n \f\n /* The parameters in use by language-independent code.  */"}, {"sha": "ea0c9b38d5d5495e99a8955ed8ee9ffbefaf8182", "filename": "gcc/rtl.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7aafde11a808a69874f94903bb045882b66c11/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3d7aafde11a808a69874f94903bb045882b66c11", "patch": "@@ -135,7 +135,7 @@ typedef union rtunion_def rtunion;\n \n /* RTL expression (\"rtx\").  */\n \n-struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"), \n+struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n \t\t    chain_prev (\"RTX_PREV (&%h)\")))\n {\n   /* The kind of expression this is.  */\n@@ -377,75 +377,75 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1)\t\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n-      \t\t\t     __FUNCTION__);\t\t\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK2(NAME, RTX, C1, C2) __extension__\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n    if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2)\t\t\t\\\n      rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n-      \t\t\t      __FUNCTION__);\t\t\t\t\\\n+\t\t\t      __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3) __extension__\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2 \t\t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n        && GET_CODE(_rtx) != C3)\t\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n-      \t\t\t     __FUNCTION__);\t\t\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4) __extension__\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4)\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n-      \t\t\t      __FUNCTION__);\t\t\t\t\\\n+\t\t\t      __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5) __extension__\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5)\t\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n-       \t\t\t     __FUNCTION__);\t\t\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6)\t\t\t\\\n      rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n-      \t\t\t     __FUNCTION__);\t\t\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n        && GET_CODE(_rtx) != C7)\t\t\t\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n-       \t\t\t     __FUNCTION__);\t\t\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n #define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n ({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n-   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t \t\t\\\n+   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n        && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n        && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n        && GET_CODE(_rtx) != C7 && GET_CODE(_rtx) != C8)\t\t\t\\\n      rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n-       \t\t\t     __FUNCTION__);\t\t\t\t\\\n+\t\t\t     __FUNCTION__);\t\t\t\t\\\n    _rtx; })\n \n extern void rtl_check_failed_flag PARAMS ((const char *, rtx, const char *,\n-      \t\t\t\t\t   int, const char *))\n+\t\t\t\t\t   int, const char *))\n     ATTRIBUTE_NORETURN\n     ;\n \n@@ -455,7 +455,7 @@ extern void rtl_check_failed_flag PARAMS ((const char *, rtx, const char *,\n #define RTL_FLAG_CHECK2(NAME, RTX, C1, C2)\t\t\t\t(RTX)\n #define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3)\t\t\t\t(RTX)\n #define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4)\t\t\t(RTX)\n-#define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5)  \t\t(RTX)\n+#define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5)\t\t(RTX)\n #define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t(RTX)\n #define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t(RTX)\n #define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t(RTX)\n@@ -673,7 +673,7 @@ enum reg_note\n   REG_CC_SETTER, REG_CC_USER,\n \n   /* Points to a CODE_LABEL.  Used by non-JUMP_INSNs to say that the\n-     CODE_LABEL contained in the REG_LABEL note is used by the insn. \n+     CODE_LABEL contained in the REG_LABEL note is used by the insn.\n      This note is an INSN_LIST.  */\n   REG_LABEL,\n \n@@ -724,14 +724,14 @@ enum reg_note\n \n   /* Indicates that this insn (which is part of the prologue) computes\n      a value which might not be used later, and if so it's OK to delete\n-     the insn.  Normally, deleting any insn in the prologue is an error. \n+     the insn.  Normally, deleting any insn in the prologue is an error.\n      At present the parameter is unused and set to (const_int 0).  */\n   REG_MAYBE_DEAD,\n \n   /* Indicates that a call does not return.  */\n   REG_NORETURN,\n \n-  /* Indicates that an indirect jump is a non-local goto instead of a \n+  /* Indicates that an indirect jump is a non-local goto instead of a\n      computed goto.  */\n   REG_NON_LOCAL_GOTO,\n \n@@ -782,7 +782,7 @@ extern const char * const reg_note_name[];\n    between ints and pointers if we use a different macro for the block number.)\n    */\n \n-#define NOTE_SOURCE_FILE(INSN) \tXCSTR (INSN, 4, NOTE)\n+#define NOTE_SOURCE_FILE(INSN)\tXCSTR (INSN, 4, NOTE)\n #define NOTE_BLOCK(INSN)\tXCTREE (INSN, 4, NOTE)\n #define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 4, NOTE)\n #define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 4, NOTE)\n@@ -795,7 +795,7 @@ extern const char * const reg_note_name[];\n #define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 5, NOTE)\n \n /* Nonzero if INSN is a note marking the beginning of a basic block.  */\n-#define NOTE_INSN_BASIC_BLOCK_P(INSN) \t\t\t\\\n+#define NOTE_INSN_BASIC_BLOCK_P(INSN)\t\t\t\\\n   (GET_CODE (INSN) == NOTE\t\t\t\t\\\n    && NOTE_LINE_NUMBER (INSN) == NOTE_INSN_BASIC_BLOCK)\n \n@@ -867,7 +867,7 @@ enum insn_note\n      their homes, etc.  */\n   NOTE_INSN_FUNCTION_BEG,\n \n-  /* These note where exception handling regions begin and end. \n+  /* These note where exception handling regions begin and end.\n      Uses NOTE_EH_HANDLER to identify the region in question.  */\n   NOTE_INSN_EH_REGION_BEG,\n   NOTE_INSN_EH_REGION_END,\n@@ -1015,7 +1015,7 @@ enum label_kind\n /* For a CONST_DOUBLE:\n    For a DImode, there are two integers CONST_DOUBLE_LOW is the\n      low-order word and ..._HIGH the high-order.\n-   For a float, there is a REAL_VALUE_TYPE structure, and \n+   For a float, there is a REAL_VALUE_TYPE structure, and\n      CONST_DOUBLE_REAL_VALUE(r) is a pointer to it.  */\n #define CONST_DOUBLE_LOW(r) XCWINT (r, 0, CONST_DOUBLE)\n #define CONST_DOUBLE_HIGH(r) XCWINT (r, 1, CONST_DOUBLE)\n@@ -1035,15 +1035,15 @@ enum label_kind\n \n /* in rtlanal.c */\n extern unsigned int subreg_lsb\t\tPARAMS ((rtx));\n-extern unsigned int subreg_regno_offset \tPARAMS ((unsigned int, \n-\t\t\t\t\t\t\t enum machine_mode, \n-\t\t\t\t\t\t\t unsigned int, \n+extern unsigned int subreg_regno_offset\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t unsigned int,\n \t\t\t\t\t\t\t enum machine_mode));\n-extern bool subreg_offset_representable_p \tPARAMS ((unsigned int, \n-\t\t\t\t\t\t\t enum machine_mode, \n-\t\t\t\t\t\t\t unsigned int, \n+extern bool subreg_offset_representable_p\tPARAMS ((unsigned int,\n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t unsigned int,\n \t\t\t\t\t\t\t enum machine_mode));\n-extern unsigned int subreg_regno \tPARAMS ((rtx));\n+extern unsigned int subreg_regno\tPARAMS ((rtx));\n \n /* 1 if RTX is a subreg containing a reg that is already known to be\n    sign- or zero-extended from the mode of the subreg to the mode of\n@@ -1735,12 +1735,12 @@ extern rtx find_use_as_address\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n \n /* lists.c */\n \n-void free_EXPR_LIST_list \t\tPARAMS ((rtx *));\n-void free_INSN_LIST_list \t\tPARAMS ((rtx *));\n-void free_EXPR_LIST_node \t\tPARAMS ((rtx));\n-void free_INSN_LIST_node \t\tPARAMS ((rtx));\n-rtx alloc_INSN_LIST\t\t\tPARAMS ((rtx, rtx));\n-rtx alloc_EXPR_LIST\t\t\tPARAMS ((int, rtx, rtx));\n+void free_EXPR_LIST_list\t\t(rtx *);\n+void free_INSN_LIST_list\t\t(rtx *);\n+void free_EXPR_LIST_node\t\t(rtx);\n+void free_INSN_LIST_node\t\t(rtx);\n+rtx alloc_INSN_LIST\t\t\t(rtx, rtx);\n+rtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n \n /* regclass.c */\n \n@@ -1931,7 +1931,7 @@ extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n #define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n \n /* Nonzero if REGNUM is a pointer into the stack frame.  */\n-#define REGNO_PTR_FRAME_P(REGNUM) \t\t\\\n+#define REGNO_PTR_FRAME_P(REGNUM)\t\t\\\n   ((REGNUM) == STACK_POINTER_REGNUM\t\t\\\n    || (REGNUM) == FRAME_POINTER_REGNUM\t\t\\\n    || (REGNUM) == HARD_FRAME_POINTER_REGNUM\t\\\n@@ -2400,6 +2400,6 @@ extern void tracer\t\t\tPARAMS ((void));\n /* Create libcall block around the call.  */\n #define ECF_LIBCALL_BLOCK\t4096\n \n-extern int flags_from_decl_or_type \t\tPARAMS ((tree));\n+extern int flags_from_decl_or_type\t\tPARAMS ((tree));\n \n #endif /* ! GCC_RTL_H */"}]}