{"sha": "1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVhZWE0MDkwOGU3ZTlmNGYyYjZiYjk3YmNmODJhMmUzNWZkNjQ1Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-07T03:23:13Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-07T03:23:13Z"}, "message": "fold-const.c (fold_binary): Unroll the very first \"for\" loop.\n\n\t* fold-const.c (fold_binary): Unroll the very first \"for\"\n\tloop.\n\nFrom-SVN: r96003", "tree": {"sha": "a7eb69b36d0f65d07b93e36e1a32cbb6743f4e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7eb69b36d0f65d07b93e36e1a32cbb6743f4e92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453/comments", "author": null, "committer": null, "parents": [{"sha": "209eaaffeb2d308fc1e2553d95dd34d691f44537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/209eaaffeb2d308fc1e2553d95dd34d691f44537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/209eaaffeb2d308fc1e2553d95dd34d691f44537"}], "stats": {"total": 61, "additions": 44, "deletions": 17}, "files": [{"sha": "451b7a2acfe39112ebf90022438a9cd05195d98c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453", "patch": "@@ -2,6 +2,9 @@\n \n \t* fold-const.c (fold_binary): Remove handling of RANGE_EXPR.\n \n+\t* fold-const.c (fold_binary): Unroll the very first \"for\"\n+\tloop.\n+\n 2005-03-06  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/predicates.md (branch_comparison_operator): Remove"}, {"sha": "e9fd5521d49f93edb5cc1bbe9fc1d69977584060", "filename": "gcc/fold-const.c", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1eaea40908e7e9f4f2b6bb97bcf82a2e35fd6453", "patch": "@@ -7038,21 +7038,17 @@ fold_binary (tree expr)\n   /* WINS will be nonzero when the switch is done\n      if all operands are constant.  */\n   int wins = 1;\n-  int i;\n \n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 2);\n \n-  op0 = TREE_OPERAND (t, 0);\n-  op1 = TREE_OPERAND (t, 1);\n-  for (i = 0; i < 2; i++)\n+  arg0 = op0 = TREE_OPERAND (t, 0);\n+  arg1 = op1 = TREE_OPERAND (t, 1);\n+\n+  if (arg0)\n     {\n-      tree op = TREE_OPERAND (t, i);\n       tree subop;\n \n-      if (op == 0)\n-\tcontinue;\t\t/* Valid for CALL_EXPR, at least.  */\n-\n       /* Strip any conversions that don't change the mode.  This is\n \t safe for every expression, except for a comparison expression\n \t because its signedness is derived from its operands.  So, in\n@@ -7065,26 +7061,54 @@ fold_binary (tree expr)\n \t cases, the appropriate type conversions should be put back in\n \t the tree that will get out of the constant folder.  */\n       if (kind == tcc_comparison)\n-\tSTRIP_SIGN_NOPS (op);\n+\tSTRIP_SIGN_NOPS (arg0);\n       else\n-\tSTRIP_NOPS (op);\n+\tSTRIP_NOPS (arg0);\n \n-      if (TREE_CODE (op) == COMPLEX_CST)\n-\tsubop = TREE_REALPART (op);\n+      if (TREE_CODE (arg0) == COMPLEX_CST)\n+\tsubop = TREE_REALPART (arg0);\n       else\n-\tsubop = op;\n+\tsubop = arg0;\n \n       if (TREE_CODE (subop) != INTEGER_CST\n \t  && TREE_CODE (subop) != REAL_CST)\n \t/* Note that TREE_CONSTANT isn't enough:\n \t   static var addresses are constant but we can't\n \t   do arithmetic on them.  */\n \twins = 0;\n+    }\n+\n+  if (arg1)\n+    {\n+      tree subop;\n+\n+      /* Strip any conversions that don't change the mode.  This is\n+\t safe for every expression, except for a comparison expression\n+\t because its signedness is derived from its operands.  So, in\n+\t the latter case, only strip conversions that don't change the\n+\t signedness.\n \n-      if (i == 0)\n-\targ0 = op;\n-      else if (i == 1)\n-\targ1 = op;\n+\t Note that this is done as an internal manipulation within the\n+\t constant folder, in order to find the simplest representation\n+\t of the arguments so that their form can be studied.  In any\n+\t cases, the appropriate type conversions should be put back in\n+\t the tree that will get out of the constant folder.  */\n+      if (kind == tcc_comparison)\n+\tSTRIP_SIGN_NOPS (arg1);\n+      else\n+\tSTRIP_NOPS (arg1);\n+\n+      if (TREE_CODE (arg1) == COMPLEX_CST)\n+\tsubop = TREE_REALPART (arg1);\n+      else\n+\tsubop = arg1;\n+\n+      if (TREE_CODE (subop) != INTEGER_CST\n+\t  && TREE_CODE (subop) != REAL_CST)\n+\t/* Note that TREE_CONSTANT isn't enough:\n+\t   static var addresses are constant but we can't\n+\t   do arithmetic on them.  */\n+\twins = 0;\n     }\n \n   /* If this is a commutative operation, and ARG0 is a constant, move it"}]}