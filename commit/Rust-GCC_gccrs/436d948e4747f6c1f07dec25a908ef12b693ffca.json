{"sha": "436d948e4747f6c1f07dec25a908ef12b693ffca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM2ZDk0OGU0NzQ3ZjZjMWYwN2RlYzI1YTkwOGVmMTJiNjkzZmZjYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-20T19:04:43Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-20T19:04:43Z"}, "message": "expr.c (store_expr): Remove code that is run when want_value & 1 is nonzero.\n\n\t* expr.c (store_expr): Remove code that is run when\n\twant_value & 1 is nonzero.\n\nFrom-SVN: r89340", "tree": {"sha": "acf82616a91fb536b5dd19ceb98e51ccc791778f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acf82616a91fb536b5dd19ceb98e51ccc791778f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/436d948e4747f6c1f07dec25a908ef12b693ffca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436d948e4747f6c1f07dec25a908ef12b693ffca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/436d948e4747f6c1f07dec25a908ef12b693ffca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436d948e4747f6c1f07dec25a908ef12b693ffca/comments", "author": null, "committer": null, "parents": [{"sha": "b235bd44145b38dc378f2d8fd67475d8193fb71a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b235bd44145b38dc378f2d8fd67475d8193fb71a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b235bd44145b38dc378f2d8fd67475d8193fb71a"}], "stats": {"total": 113, "additions": 20, "deletions": 93}, "files": [{"sha": "937a0e16834cd14aea527caaf97058fde95f40f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d948e4747f6c1f07dec25a908ef12b693ffca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d948e4747f6c1f07dec25a908ef12b693ffca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=436d948e4747f6c1f07dec25a908ef12b693ffca", "patch": "@@ -1,3 +1,8 @@\n+2004-10-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* expr.c (store_expr): Remove code that is run when\n+\twant_value & 1 is nonzero.\n+\n 2004-10-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gthr-posix.h (__gthread_active_p): Use __extension__ around cast"}, {"sha": "6ec3c4e4ee0c50e446fb730ca96ff323984d8a5c", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 93, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d948e4747f6c1f07dec25a908ef12b693ffca/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d948e4747f6c1f07dec25a908ef12b693ffca/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=436d948e4747f6c1f07dec25a908ef12b693ffca", "patch": "@@ -3738,25 +3738,13 @@ expand_assignment (tree to, tree from)\n /* Generate code for computing expression EXP,\n    and storing the value into TARGET.\n \n-   If WANT_VALUE & 1 is nonzero, return a copy of the value\n-   not in TARGET, so that we can be sure to use the proper\n-   value in a containing expression even if TARGET has something\n-   else stored in it.  If possible, we copy the value through a pseudo\n-   and return that pseudo.  Or, if the value is constant, we try to\n-   return the constant.  In some cases, we return a pseudo\n-   copied *from* TARGET.\n-\n    If the mode is BLKmode then we may return TARGET itself.\n    It turns out that in BLKmode it doesn't cause a problem.\n    because C has no operators that could combine two different\n    assignments into the same BLKmode object with different values\n    with no sequence point.  Will other languages need this to\n    be more thorough?\n \n-   If WANT_VALUE & 1 is 0, we return NULL, to make sure\n-   to catch quickly any cases where the caller uses the value\n-   and fails to set WANT_VALUE.\n-\n    If WANT_VALUE & 2 is set, this is a store into a call param on the\n    stack, and block moves may need to be treated specially.  */\n \n@@ -3768,6 +3756,10 @@ store_expr (tree exp, rtx target, int want_value)\n   int dont_return_target = 0;\n   int dont_store_target = 0;\n \n+  /* The bit 0 of WANT_VALUE used to be used to request a value of the\n+     expression.  This feature has been removed.  */\n+  gcc_assert ((want_value & 1) == 0);\n+\n   if (VOID_TYPE_P (TREE_TYPE (exp)))\n     {\n       /* C++ can generate ?: expressions with a throw expression in one\n@@ -3805,32 +3797,7 @@ store_expr (tree exp, rtx target, int want_value)\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n-      return want_value & 1 ? target : NULL_RTX;\n-    }\n-  else if ((want_value & 1) != 0\n-\t   && MEM_P (target)\n-\t   && ! MEM_VOLATILE_P (target)\n-\t   && GET_MODE (target) != BLKmode)\n-    /* If target is in memory and caller wants value in a register instead,\n-       arrange that.  Pass TARGET as target for expand_expr so that,\n-       if EXP is another assignment, WANT_VALUE will be nonzero for it.\n-       We know expand_expr will not use the target in that case.\n-       Don't do this if TARGET is volatile because we are supposed\n-       to write it and then read it.  */\n-    {\n-      temp = expand_expr (exp, target, GET_MODE (target),\n-\t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n-      if (GET_MODE (temp) != BLKmode && GET_MODE (temp) != VOIDmode)\n-\t{\n-\t  /* If TEMP is already in the desired TARGET, only copy it from\n-\t     memory and don't store it there again.  */\n-\t  if (temp == target\n-\t      || (rtx_equal_p (temp, target)\n-\t\t  && ! side_effects_p (temp) && ! side_effects_p (target)))\n-\t    dont_store_target = 1;\n-\t  temp = copy_to_reg (temp);\n-\t}\n-      dont_return_target = 1;\n+      return NULL_RTX;\n     }\n   else if (GET_CODE (target) == SUBREG && SUBREG_PROMOTED_VAR_P (target))\n     /* If this is a scalar in a register that is stored in a wider mode\n@@ -3840,14 +3807,13 @@ store_expr (tree exp, rtx target, int want_value)\n     {\n       rtx inner_target = 0;\n \n-      /* If we don't want a value, we can do the conversion inside EXP,\n-\t which will often result in some optimizations.  Do the conversion\n-\t in two steps: first change the signedness, if needed, then\n-\t the extend.  But don't do this if the type of EXP is a subtype\n-\t of something else since then the conversion might involve\n-\t more than just converting modes.  */\n-      if ((want_value & 1) == 0\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (exp))\n+      /* We can do the conversion inside EXP, which will often result\n+\t in some optimizations.  Do the conversion in two steps: first\n+\t change the signedness, if needed, then the extend.  But don't\n+\t do this if the type of EXP is a subtype of something else\n+\t since then the conversion might involve more than just\n+\t converting modes.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (exp))\n \t  && TREE_TYPE (TREE_TYPE (exp)) == 0\n \t  && (!lang_hooks.reduce_bit_field_operations\n \t      || (GET_MODE_PRECISION (GET_MODE (target))\n@@ -3870,14 +3836,6 @@ store_expr (tree exp, rtx target, int want_value)\n       temp = expand_expr (exp, inner_target, VOIDmode,\n \t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n \n-      /* If TEMP is a MEM and we want a result value, make the access\n-\t now so it gets done only once.  Strictly speaking, this is\n-\t only necessary if the MEM is volatile, or if the address\n-\t overlaps TARGET.  But not performing the load twice also\n-\t reduces the amount of rtl we generate and then have to CSE.  */\n-      if (MEM_P (temp) && (want_value & 1) != 0)\n-\ttemp = copy_to_reg (temp);\n-\n       /* If TEMP is a VOIDmode constant, use convert_modes to make\n \t sure that we properly convert it.  */\n       if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)\n@@ -3892,26 +3850,7 @@ store_expr (tree exp, rtx target, int want_value)\n       convert_move (SUBREG_REG (target), temp,\n \t\t    SUBREG_PROMOTED_UNSIGNED_P (target));\n \n-      /* If we promoted a constant, change the mode back down to match\n-\t target.  Otherwise, the caller might get confused by a result whose\n-\t mode is larger than expected.  */\n-\n-      if ((want_value & 1) != 0 && GET_MODE (temp) != GET_MODE (target))\n-\t{\n-\t  if (GET_MODE (temp) != VOIDmode)\n-\t    {\n-\t      temp = gen_lowpart_SUBREG (GET_MODE (target), temp);\n-\t      SUBREG_PROMOTED_VAR_P (temp) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET (temp,\n-\t\tSUBREG_PROMOTED_UNSIGNED_P (target));\n-\t    }\n-\t  else\n-\t    temp = convert_modes (GET_MODE (target),\n-\t\t\t\t  GET_MODE (SUBREG_REG (target)),\n-\t\t\t\t  temp, SUBREG_PROMOTED_UNSIGNED_P (target));\n-\t}\n-\n-      return want_value & 1 ? temp : NULL_RTX;\n+      return NULL_RTX;\n     }\n   else\n     {\n@@ -3930,7 +3869,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n \t  && !(MEM_P (target) && MEM_VOLATILE_P (target))\n \t  && ! rtx_equal_p (temp, target)\n-\t  && (CONSTANT_P (temp) || (want_value & 1) != 0))\n+\t  && CONSTANT_P (temp))\n \tdont_return_target = 1;\n     }\n \n@@ -4077,24 +4016,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t}\n     }\n \n-  /* If we don't want a value, return NULL_RTX.  */\n-  if ((want_value & 1) == 0)\n-    return NULL_RTX;\n-\n-  /* If we are supposed to return TEMP, do so as long as it isn't a MEM.\n-     ??? The latter test doesn't seem to make sense.  */\n-  else if (dont_return_target && !MEM_P (temp))\n-    return temp;\n-\n-  /* Return TARGET itself if it is a hard register.  */\n-  else if ((want_value & 1) != 0\n-\t   && GET_MODE (target) != BLKmode\n-\t   && ! (REG_P (target)\n-\t\t && REGNO (target) < FIRST_PSEUDO_REGISTER))\n-    return copy_to_reg (target);\n-\n-  else\n-    return target;\n+  return NULL_RTX;\n }\n \f\n /* Examine CTOR.  Discover how many scalar fields are set to nonzero"}]}