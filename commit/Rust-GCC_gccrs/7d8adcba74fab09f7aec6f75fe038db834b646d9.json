{"sha": "7d8adcba74fab09f7aec6f75fe038db834b646d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4YWRjYmE3NGZhYjA5ZjdhZWM2Zjc1ZmUwMzhkYjgzNGI2NDZkOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-09T20:34:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-09T20:34:18Z"}, "message": "ipa-devirt.c (odr_types_equivalent_p): Fix formating.\n\n\n\t* ipa-devirt.c (odr_types_equivalent_p): Fix formating.\n\t(add_type_duplicate): Fix comparison of BINFOs.\n\nFrom-SVN: r220546", "tree": {"sha": "a1aa06183cb5b8d8a0c83a3b176e3b7213ea6272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1aa06183cb5b8d8a0c83a3b176e3b7213ea6272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d8adcba74fab09f7aec6f75fe038db834b646d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8adcba74fab09f7aec6f75fe038db834b646d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8adcba74fab09f7aec6f75fe038db834b646d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8adcba74fab09f7aec6f75fe038db834b646d9/comments", "author": null, "committer": null, "parents": [{"sha": "62c7e4b7485d26f3bbc3cf648ea86346955ac4c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c7e4b7485d26f3bbc3cf648ea86346955ac4c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c7e4b7485d26f3bbc3cf648ea86346955ac4c7"}], "stats": {"total": 121, "additions": 101, "deletions": 20}, "files": [{"sha": "445e9a93afe320b2b0c457f8b501c7155758a071", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8adcba74fab09f7aec6f75fe038db834b646d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8adcba74fab09f7aec6f75fe038db834b646d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d8adcba74fab09f7aec6f75fe038db834b646d9", "patch": "@@ -1,3 +1,8 @@\n+2015-02-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (odr_types_equivalent_p): Fix formating.\n+\t(add_type_duplicate): Fix comparison of BINFOs.\n+\n 2015-02-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-polymorphic-call.c (ipa_polymorphic_call_context): Avoid ICE"}, {"sha": "790e483f77513a022bf4bdeb4fefd145b5b0c01e", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 96, "deletions": 20, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8adcba74fab09f7aec6f75fe038db834b646d9/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8adcba74fab09f7aec6f75fe038db834b646d9/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=7d8adcba74fab09f7aec6f75fe038db834b646d9", "patch": "@@ -807,7 +807,8 @@ warn_types_mismatch (tree t1, tree t2)\n    gimple_canonical_types_compatible_p.  */\n \n static bool\n-odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<type_pair,pair_traits> *visited)\n+odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n+\t\t\thash_set<type_pair,pair_traits> *visited)\n {\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n@@ -1206,8 +1207,8 @@ add_type_duplicate (odr_type val, tree type)\n     val->types_set = new hash_set<tree>;\n \n   /* Always prefer complete type to be the leader.  */\n-  if (!COMPLETE_TYPE_P (val->type)\n-      && COMPLETE_TYPE_P (type))\n+  if ((!COMPLETE_TYPE_P (val->type) || !TYPE_BINFO (val->type))\n+      && (COMPLETE_TYPE_P (type) && TYPE_BINFO (val->type)))\n     {\n       tree tmp = type;\n \n@@ -1229,7 +1230,8 @@ add_type_duplicate (odr_type val, tree type)\n       vec_safe_push (val->types, type);\n \n       /* First we compare memory layout.  */\n-      if (!odr_types_equivalent_p (val->type, type, !flag_ltrans && !val->odr_violated,\n+      if (!odr_types_equivalent_p (val->type, type,\n+\t\t\t\t   !flag_ltrans && !val->odr_violated,\n \t\t\t\t   &warned, &visited))\n \t{\n \t  merge = false;\n@@ -1253,31 +1255,105 @@ add_type_duplicate (odr_type val, tree type)\n \t  && TREE_CODE (type) == RECORD_TYPE\n \t  && TYPE_BINFO (val->type) && TYPE_BINFO (type))\n \t{\n-\t  for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-\t    if (polymorphic_type_binfo_p (BINFO_BASE_BINFO (TYPE_BINFO (type), i)))\n+\t  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n+\t      != BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n+\t    {\n+\t      if (!warned && !val->odr_violated)\n+\t\t{\n+\t\t  tree extra_base;\n+\t\t  warn_odr (type, val->type, NULL, NULL, !warned, &warned,\n+\t\t\t    \"a type with the same name but different \"\n+\t\t\t    \"number of polymorphic bases is \"\n+\t\t\t    \"defined in another translation unit\");\n+\t\t  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n+\t\t      > BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n+\t\t    extra_base = BINFO_BASE_BINFO\n+\t\t\t\t (TYPE_BINFO (type),\n+\t\t\t\t  BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)));\n+\t\t  else\n+\t\t    extra_base = BINFO_BASE_BINFO\n+\t\t\t\t (TYPE_BINFO (val->type),\n+\t\t\t\t  BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n+\t\t  inform (DECL_SOURCE_LOCATION \n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (extra_base))),\n+\t\t\t  \"the extra base is defined here \");\n+\t\t}\n+\t      base_mismatch = true;\n+\t    }\n+\t  else\n+\t    for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n \t      {\n-\t\todr_type base = get_odr_type\n-\t\t\t\t   (BINFO_TYPE\n-\t\t\t\t      (BINFO_BASE_BINFO (TYPE_BINFO (type),\n-\t\t\t\t\t\t\t i)),\n-\t\t\t\t    true);\n-\t\tif (val->bases.length () <= j || val->bases[j] != base)\n-\t\t  base_mismatch = true;\n-\t\tj++;\n+\t\ttree base1 = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n+\t\ttree base2 = BINFO_BASE_BINFO (TYPE_BINFO (val->type), i);\n+\t\ttree type1 = BINFO_TYPE (base1);\n+\t\ttree type2 = BINFO_TYPE (base2);\n+\n+\t\tif (types_odr_comparable (type1, type2))\n+\t\t  {\n+\t\t    if (!types_same_for_odr (type1, type2))\n+\t\t      base_mismatch = true;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    hash_set<type_pair,pair_traits> visited;\n+\t\t    if (!odr_types_equivalent_p (type1, type2, false, NULL,\n+\t\t\t\t\t\t &visited))\n+\t\t      base_mismatch = true;\n+\t\t  }\n+\t\tif (base_mismatch)\n+\t\t  {\n+\t\t    if (!warned && !val->odr_violated)\n+\t\t      warn_odr (type, val->type, NULL, NULL,\n+\t\t\t\t!warned, &warned,\n+\t\t\t\t\"a type with the same name but different base \"\n+\t\t\t\t\"type is defined in another translation unit\");\n+\t\t    warn_types_mismatch (type1, type2);\n+\t\t    break;\n+\t\t  }\n+\t\tif (BINFO_OFFSET (base1) != BINFO_OFFSET (base2))\n+\t\t  {\n+\t\t    base_mismatch = true;\n+\t\t    if (!warned && !val->odr_violated)\n+\t\t      warn_odr (type, val->type, NULL, NULL,\n+\t\t\t\t!warned, &warned,\n+\t\t\t\t\"a type with the same name but different base \"\n+\t\t\t\t\"layout is defined in another translation unit\");\n+\t\t    break;\n+\t\t  }\n \t      }\n+\t  /* Sanity check that all bases will be build same way again.  */\n+\t  if (!base_mismatch && val->bases.length ())\n+\t    {\n+\t      unsigned int num_poly_bases = 0;\n+\n+\t      for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\t\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n+\t\t\t\t\t\t (TYPE_BINFO (type), i)))\n+\t\t  num_poly_bases++;\n+\t      gcc_assert (num_poly_bases == val->bases.length ());\n+\t      for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t\t   i++)\n+\t\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO \n+\t\t\t\t\t       (TYPE_BINFO (type), i)))\n+\t\t  {\n+\t\t    odr_type base = get_odr_type\n+\t\t\t\t       (BINFO_TYPE\n+\t\t\t\t\t  (BINFO_BASE_BINFO (TYPE_BINFO (type),\n+\t\t\t\t\t\t\t     i)),\n+\t\t\t\t\ttrue);\n+\t\t    gcc_assert (val->bases[j] == base);\n+\t\t    j++;\n+\t\t  }\n+\t    }\n \t  if (base_mismatch)\n \t    {\n \t      merge = false;\n \t      odr_violation_reported = true;\n-\n-\t      if (!warned && !val->odr_violated)\n-\t\twarn_odr (type, val->type, NULL, NULL, !warned, &warned,\n-\t\t\t  \"a type with the same name but different bases is \"\n-\t\t\t  \"defined in another translation unit\");\n \t      val->odr_violated = true;\n+\n \t      if (symtab->dump_file)\n \t\t{\n-\t\t  fprintf (symtab->dump_file, \"ODR bse violation or merging bug?\\n\");\n+\t\t  fprintf (symtab->dump_file, \"ODR base violation\\n\");\n \t\t\n \t\t  print_node (symtab->dump_file, \"\", val->type, 0);\n \t\t  putc ('\\n',symtab->dump_file);"}]}