{"sha": "ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMzMTc4NTlkNDA5NDM0YjBmNWVmOGVjODlhN2FiY2FjYjEwYmQzZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-01-17T14:14:26Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-01-17T14:14:26Z"}, "message": "re PR libstdc++/19433 (set, multiset, map, multimap misuse hint on insert)\n\n2005-01-17  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/19433\n\t* include/bits/stl_tree.h (_Rb_tree<>::insert_unique(iterator,\n\tconst _Val&), _Rb_tree<>::insert_equal(iterator, const _Val&)):\n\tObtain amortized constant complexity if t is inserted right after\n\tp - not before p - as per Table 69.\n\t* testsuite/performance/23_containers/set_insert_from_sorted.cc: New.\n\n\t* testsuite/23_containers/multiset/insert/2.cc: New.\n\t* testsuite/23_containers/set/insert/1.cc: Likewise.\n\n\t* testsuite/performance/23_containers/set_create_from_sorted.cc:\n\tSimplify.\n\n\t* include/bits/stl_tree.h: Add a few missing std:: qualifications.\n\nFrom-SVN: r93761", "tree": {"sha": "06c3e5f2c891c55b59db68dc352490470d7d95b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06c3e5f2c891c55b59db68dc352490470d7d95b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/comments", "author": null, "committer": null, "parents": [{"sha": "ef9312c1c71822c6d5ab5367ff9489301a00e257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9312c1c71822c6d5ab5367ff9489301a00e257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9312c1c71822c6d5ab5367ff9489301a00e257"}], "stats": {"total": 374, "additions": 308, "deletions": 66}, "files": [{"sha": "8bd52a5d5d43ce0a5cad5e9efc1eca73b08408be", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "patch": "@@ -1,3 +1,20 @@\n+2005-01-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/19433\n+\t* include/bits/stl_tree.h (_Rb_tree<>::insert_unique(iterator,\n+\tconst _Val&), _Rb_tree<>::insert_equal(iterator, const _Val&)):\n+\tObtain amortized constant complexity if t is inserted right after\n+\tp - not before p - as per Table 69.\n+\t* testsuite/performance/23_containers/set_insert_from_sorted.cc: New.\n+\t\n+\t* testsuite/23_containers/multiset/insert/2.cc: New.\n+\t* testsuite/23_containers/set/insert/1.cc: Likewise.\n+\t\n+\t* testsuite/performance/23_containers/set_create_from_sorted.cc:\n+\tSimplify.\n+\n+\t* include/bits/stl_tree.h: Add a few missing std:: qualifications.\n+\n 2005-01-16  Jonathan Wakely  <redi@gcc.gnu.org>\n \n \t* include/ext/rope: Qualify calls to std::copy() by sequence_buffer."}, {"sha": "197d52a2a08a2d8d752032c0f6e003aace8eaf10", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "patch": "@@ -1,6 +1,6 @@\n // RB tree implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -708,7 +708,7 @@ namespace std\n \t       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     {\n       return __x.size() == __y.size()\n-\t     && equal(__x.begin(), __x.end(), __y.begin());\n+\t     && std::equal(__x.begin(), __x.end(), __y.begin());\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -717,8 +717,8 @@ namespace std\n     operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n \t      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     {\n-      return lexicographical_compare(__x.begin(), __x.end(), \n-\t\t\t\t     __y.begin(), __y.end());\n+      return std::lexicographical_compare(__x.begin(), __x.end(), \n+\t\t\t\t\t  __y.begin(), __y.end());\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -892,39 +892,29 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == _M_leftmost())\n+      if (__position._M_node == _M_end()\n+\t  || __position._M_node == _M_rightmost())\n \t{\n-\t  // begin()\n \t  if (size() > 0\n-\t      && _M_impl._M_key_compare(_KeyOfValue()(__v), \n-\t\t\t\t\t_S_key(__position._M_node)))\n-\t    return _M_insert(__position._M_node, __position._M_node, __v);\n-\t  // First argument just needs to be non-null.\n-\t  else\n-\t    return insert_unique(__v).first;\n-\t}\n-      else if (__position._M_node == _M_end())\n-\t{\n-\t  // end()\n-\t  if (_M_impl._M_key_compare(_S_key(_M_rightmost()), \n-\t\t\t\t     _KeyOfValue()(__v)))\n+\t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n+\t\t\t\t\t_KeyOfValue()(__v)))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_unique(__v).first;\n \t}\n       else\n \t{\n-\t  iterator __before = __position;\n-\t  --__before;\n-\t  if (_M_impl._M_key_compare(_S_key(__before._M_node), \n+\t  iterator __after = __position;\n+\t  ++__after;\n+\t  if (_M_impl._M_key_compare(_S_key(__position._M_node), \n \t\t\t\t     _KeyOfValue()(__v))\n \t      && _M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t_S_key(__position._M_node)))\n+\t\t\t\t\t_S_key(__after._M_node)))\n \t    {\n-\t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v);\n+\t      if (_S_right(__position._M_node) == 0)\n+\t\treturn _M_insert(0, __position._M_node, __v);\n \t      else\n-\t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n+\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n \t      // First argument just needs to be non-null.\n \t    }\n \t  else\n@@ -938,39 +928,29 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == _M_leftmost())\n+      if (__position._M_node == _M_end()\n+\t  || __position._M_node == _M_rightmost())\n \t{\n-\t  // begin()\n \t  if (size() > 0\n-\t      && !_M_impl._M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t\t _KeyOfValue()(__v)))\n-\t    return _M_insert(__position._M_node, __position._M_node, __v);\n-\t  // first argument just needs to be non-null\n-\t  else\n-\t    return insert_equal(__v);\n-\t}\n-      else if (__position._M_node == _M_end())\n-\t{\n-\t  // end()\n-\t  if (!_M_impl._M_key_compare(_KeyOfValue()(__v), \n-\t\t\t\t      _S_key(_M_rightmost())))\n+\t      && !_M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t\t _S_key(_M_rightmost())))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_equal(__v);\n \t}\n       else\n \t{\n-\t  iterator __before = __position;\n-\t  --__before;\n+\t  iterator __after = __position;\n+\t  ++__after;\n \t  if (!_M_impl._M_key_compare(_KeyOfValue()(__v), \n-\t\t\t\t      _S_key(__before._M_node))\n-\t      && !_M_impl._M_key_compare(_S_key(__position._M_node),\n+\t\t\t\t      _S_key(__position._M_node))\n+\t      && !_M_impl._M_key_compare(_S_key(__after._M_node),\n \t\t\t\t\t _KeyOfValue()(__v)))\n \t    {\n-\t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v);\n+\t      if (_S_right(__position._M_node) == 0)\n+\t\treturn _M_insert(0, __position._M_node, __v);\n \t      else\n-\t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n+\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n \t      // First argument just needs to be non-null.\n \t    }\n \t  else"}, {"sha": "6f586e4eac1d4e75eecbf3a9f60e78cdadfb753d", "filename": "libstdc++-v3/testsuite/23_containers/multiset/insert/2.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finsert%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finsert%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finsert%2F2.cc?ref=ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "patch": "@@ -0,0 +1,97 @@\n+// 2005-01-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+// A few tests for insert with hint, in the occasion of libstdc++/19422\n+// and libstdc++/19433.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multiset<int> ms0, ms1;\n+  multiset<int>::iterator iter1;\n+  \n+  ms0.insert(1);\n+  ms1.insert(ms1.end(), 1);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(3);\n+  ms1.insert(ms1.begin(), 3);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(4);\n+  iter1 = ms1.insert(ms1.end(), 4);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(6);\n+  ms1.insert(iter1, 6);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(2);\n+  ms1.insert(ms1.begin(), 2);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(7);\n+  ms1.insert(ms1.end(), 7);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(5);\n+  ms1.insert(ms1.find(4), 5);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(0);\n+  ms1.insert(ms1.end(), 0);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(8);\n+  ms1.insert(ms1.find(3), 8);\n+  VERIFY( ms0 == ms1 );\n+  \n+  ms0.insert(9);\n+  ms1.insert(ms1.end(), 9);\n+  VERIFY( ms0 == ms1 );\n+\n+  ms0.insert(10);\n+  ms1.insert(ms1.begin(), 10);\n+  VERIFY( ms0 == ms1 );\n+}\n+\n+#if !__GXX_WEAK__ && _MT_ALLOCATOR_H\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template class __gnu_cxx::__mt_alloc<std::_Rb_tree_node<int> >;\n+#endif\n+\n+int main ()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7d1ef2f9d34259d2194bf18b98e0d252d68c9024", "filename": "libstdc++-v3/testsuite/23_containers/set/insert/1.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finsert%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finsert%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finsert%2F1.cc?ref=ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "patch": "@@ -0,0 +1,97 @@\n+// 2005-01-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+// A few tests for insert with hint, in the occasion of libstdc++/19422\n+// and libstdc++/19433.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  set<int> s0, s1;\n+  set<int>::iterator iter1;\n+  \n+  s0.insert(1);\n+  s1.insert(s1.end(), 1);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(3);\n+  s1.insert(s1.begin(), 3);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(4);\n+  iter1 = s1.insert(s1.end(), 4);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(6);\n+  s1.insert(iter1, 6);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(2);\n+  s1.insert(s1.begin(), 2);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(7);\n+  s1.insert(s1.end(), 7);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(5);\n+  s1.insert(s1.find(4), 5);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(0);\n+  s1.insert(s1.end(), 0);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(8);\n+  s1.insert(s1.find(3), 8);\n+  VERIFY( s0 == s1 );\n+  \n+  s0.insert(9);\n+  s1.insert(s1.end(), 9);\n+  VERIFY( s0 == s1 );\n+\n+  s0.insert(10);\n+  s1.insert(s1.begin(), 10);\n+  VERIFY( s0 == s1 );\n+}\n+\n+#if !__GXX_WEAK__ && _MT_ALLOCATOR_H\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template class __gnu_cxx::__mt_alloc<std::_Rb_tree_node<int> >;\n+#endif\n+\n+int main ()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "17eaadd0b783b49498e43d5a6b4691de224f1044", "filename": "libstdc++-v3/testsuite/performance/23_containers/set_create_from_sorted.cc", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Fset_create_from_sorted.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Fset_create_from_sorted.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Fset_create_from_sorted.cc?ref=ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "patch": "@@ -27,11 +27,9 @@\n \n #include <vector>\n #include <set>\n-#include <list>\n #include <sstream>\n #include <testsuite_performance.h>\n \n-// adjust for your setup\n static const unsigned max_size = 1000000; // avoid excessive swap file use!\n static const unsigned iterations = 10;    // make results less random while\n static const unsigned step = 50000;       // keeping the total time reasonable\n@@ -45,39 +43,22 @@ int main()\n   resource_counter resource;\n \n   typedef set<unsigned>  the_set;\n-  typedef list<unsigned> the_list;\n \n   vector<unsigned> v(max_size, 0);\n   for (unsigned i = 0; i != max_size; ++i)\n     v[i] = i; // initialize sorted array\n \n-  report_header(__FILE__, \"set:\");\n   for (unsigned count = step; count <= max_size; count += step)\n     {\n       ostringstream oss;\n       oss << count;\n \n-      // measure set construction time\n+      // measure set construction time (linear in count (Table 69))\n       start_counters(time, resource);\n       for (unsigned i = 0; i != iterations; ++i)\n \tthe_set(v.begin(), v.begin() + count);\n       stop_counters(time, resource);\n       report_performance(__FILE__, oss.str(), time, resource);\n       clear_counters(time, resource);\n     }\n-\n-  report_header(__FILE__, \"list:\");\n-  for (unsigned count = step; count <= max_size; count += step)\n-    {\n-      ostringstream oss;\n-      oss << count;\n-\n-      // measure list construction time (surely linear in count)\n-      start_counters(time, resource);\n-      for (unsigned i = 0; i != iterations; ++i)\n-\tthe_list(v.begin(), v.begin() + count);\n-      stop_counters(time, resource);\n-      report_performance(__FILE__, oss.str(), time, resource);\n-      clear_counters(time, resource);\n-    }\n }"}, {"sha": "48cb952a5379b355ba5acc6c46b36f78b24f984d", "filename": "libstdc++-v3/testsuite/performance/23_containers/set_insert_from_sorted.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Fset_insert_from_sorted.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac317859d409434b0f5ef8ec89a7abcacb10bd3e/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Fset_insert_from_sorted.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Fset_insert_from_sorted.cc?ref=ac317859d409434b0f5ef8ec89a7abcacb10bd3e", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <vector>\n+#include <set>\n+#include <sstream>\n+#include <testsuite_performance.h>\n+\n+static const unsigned max_size = 1000000; // avoid excessive swap file use!\n+static const unsigned iterations = 10;    // make results less random while\n+static const unsigned step = 50000;       // keeping the total time reasonable\n+\n+// libstdc++/19433\n+int main()\n+{\n+  using namespace std;\n+  using namespace __gnu_test;\n+  time_counter time;\n+  resource_counter resource;\n+\n+  typedef set<unsigned>  the_set;\n+\n+  vector<unsigned> v(max_size, 0);\n+  for (unsigned i = 0; i != max_size; ++i)\n+    v[i] = i; // initialize sorted array\n+\n+  for (unsigned count = step; count <= max_size; count += step)\n+    {\n+      ostringstream oss;\n+      oss << count;\n+\n+      start_counters(time, resource);\n+      for (unsigned i = 0; i != iterations; ++i)\n+\t{\n+\t  the_set test_set;\n+\t  the_set::iterator iter = test_set.end();\n+\n+\t  // each insert in amortized constant time (Table 69)\n+\t  for (unsigned j = 0; j != count; ++j)\n+\t    iter = test_set.insert(iter, v[j]);\n+\t}\n+      stop_counters(time, resource);\n+      report_performance(__FILE__, oss.str(), time, resource);\n+      clear_counters(time, resource);\n+    }\n+}"}]}