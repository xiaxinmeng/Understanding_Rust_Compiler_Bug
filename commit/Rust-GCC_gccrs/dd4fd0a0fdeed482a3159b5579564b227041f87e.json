{"sha": "dd4fd0a0fdeed482a3159b5579564b227041f87e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ0ZmQwYTBmZGVlZDQ4MmEzMTU5YjU1Nzk1NjRiMjI3MDQxZjg3ZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-05-01T22:41:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-05-01T22:41:55Z"}, "message": "h8300.c (h8300_adjust_insn_length): Adjust the cost of shifts by small constant values.\n\n        * h8300/h8300.c (h8300_adjust_insn_length): Adjust the cost of\n        shifts by small constant values.\n        * h8300/h8300.md: Refine comments.  Remove names from many\n        patterns which don't need them.\n        (compare insns): Don't underestimate lengths.\n        (andqi3 expander): Remove constrains.\n        (andhi3): Don't underestimate length.\n        (andsi3): Don't underestimate length.  Improve code when upper\n        or lower half of destination is being cleared.\n        (indirect_jump_h8300, indirect_jump_h8300h): Simplify.\n        (shift insns): Remove useless \"I\" constraint.\n\nFrom-SVN: r11912", "tree": {"sha": "8edf7a26211bf37aa69cb7eae40f8e507b2dd71c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8edf7a26211bf37aa69cb7eae40f8e507b2dd71c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd4fd0a0fdeed482a3159b5579564b227041f87e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4fd0a0fdeed482a3159b5579564b227041f87e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd4fd0a0fdeed482a3159b5579564b227041f87e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4fd0a0fdeed482a3159b5579564b227041f87e/comments", "author": null, "committer": null, "parents": [{"sha": "17d6fedc573f97792a04b363e59a030584de2459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17d6fedc573f97792a04b363e59a030584de2459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17d6fedc573f97792a04b363e59a030584de2459"}], "stats": {"total": 210, "additions": 128, "deletions": 82}, "files": [{"sha": "60203d19a78c42d98d50d6f27e21ac4282352a46", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4fd0a0fdeed482a3159b5579564b227041f87e/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4fd0a0fdeed482a3159b5579564b227041f87e/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=dd4fd0a0fdeed482a3159b5579564b227041f87e", "patch": "@@ -2342,5 +2342,46 @@ h8300_adjust_insn_length (insn, length)\n \t}\n     }\n \n+  /* Shifts need various adjustments.  */\n+  if (GET_CODE (pat) == PARALLEL\n+      && GET_CODE (XVECEXP (pat, 0, 0)) == SET\n+      && (GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == ASHIFTRT\n+          || GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == LSHIFTRT\n+          || GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == ASHIFT))\n+    {\n+      rtx src = SET_SRC (XVECEXP (pat, 0, 0));\n+      enum machine_mode mode = GET_MODE (src);\n+\n+      if (GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\treturn 0;\n+\n+      /* QImode shifts by small constants take one insn\n+\t per shift.  So the adjustment is 20 (md length) -\n+\t # shifts * 2.  */\n+      if (mode == QImode && INTVAL (XEXP (src, 1)) <= 4)\n+\treturn -(20 - INTVAL (XEXP (src, 1)) * 2);\n+\n+      /* Similarly for HImode and SImode shifts by\n+\t small constants on the H8/300H.  */\n+      if (TARGET_H8300H\n+\t  && (mode == HImode || mode == SImode)\n+\t  && INTVAL (XEXP (src, 1)) <= 4)\n+\treturn -(20 - INTVAL (XEXP (src, 1)) * 2);\n+\n+      /* HImode shifts by small constants for the H8/300.  */\n+      if (mode == HImode\n+\t  && INTVAL (XEXP (src, 1)) <= 4)\n+\treturn -(20 - (INTVAL (XEXP (src, 1))\n+\t\t       * (GET_CODE (src) == ASHIFT ? 2 : 4)));\n+\n+      /* SImode shifts by small constants for the H8/300.  */\n+      if (mode == SImode\n+\t  && INTVAL (XEXP (src, 1)) <= 2)\n+\treturn -(20 - (INTVAL (XEXP (src, 1))\n+\t\t       * (GET_CODE (src) == ASHIFT ? 6 : 8)));\n+\n+      /* XXX ??? Could check for more shift/rotate cases here.  */\n+    }\n+    \n   return 0;\n }"}, {"sha": "be2fb158004e3ff7d7cb8af42dd5728e95b81c37", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4fd0a0fdeed482a3159b5579564b227041f87e/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4fd0a0fdeed482a3159b5579564b227041f87e/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=dd4fd0a0fdeed482a3159b5579564b227041f87e", "patch": "@@ -32,7 +32,16 @@\n ;; Many logical operations should have \"bit\" variants if only one\n ;; bit is going to be operated on.\n \n-;; Should be HI & SImode tstXX insns which test one bit using btst.\n+;; (and (logical op) (const_int X))\n+;; If const_int only specifies a few bits (like a single byte in a 4 byte\n+;; operation, then it's more efficient to only apply the and and logical_op\n+;; to the bits we care about.\n+\n+;; Some of the extend instructions accept a general_operand_src, which\n+;; allows all the normal memory addressing modes.  The length computations\n+;; don't take this into account.  The lengths in the MD file should be\n+;; \"worst case\" and then be adjusted to their correct values by\n+;; h8300_adjust_insn_length.\n \n ;; On the h8300h, adds/subs operate on the 32bit \"er\" registers.  Right\n ;; now GCC doesn't expose the \"e\" half to the compiler, so using add/subs\n@@ -43,6 +52,12 @@\n ;; There's currently no way to have a insv/extzv expander for the h8/300h\n ;; because word_mode is different for the h8/300 and h8/300h.\n \n+;; Shifts/rotates by small constants should be handled by special\n+;; patterns so we get the length and cc status correct.\n+\n+;; Bitfield operations no longer accept memory operands.  We need\n+;; to add variants which operate on memory back to the MD.\n+\n ;; ??? Implement remaining bit ops available on the h8300\n \n (define_attr \"type\" \"branch,arith\"\n@@ -100,7 +115,7 @@\n   [(set (attr \"length\") (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4)))\n    (set_attr \"cc\" \"set\")])\n \n-(define_insn \"movqi_internal\"\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r,<,r,o\")\n \t(match_operand:QI 1 \"general_operand_src\" \"I,r>,r,io,r\"))]\n   \"register_operand (operands[0],QImode)\n@@ -162,7 +177,7 @@\n   [(set (attr \"length\") (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4)))\n    (set_attr \"cc\" \"set\")])\n \n-(define_insn \"movhi_internal\"\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,<,r,o\")\n \t(match_operand:HI 1 \"general_operand_src\" \"I,r>,r,io,r\"))]\n   \"register_operand (operands[0],HImode)\n@@ -511,28 +526,28 @@\n   [(set (cc0)\n \t(compare:HI (match_operand:HI 0 \"register_operand\" \"r\")\n \t\t    (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"!TARGET_H8300H\"\n+  \"TARGET_H8300\"\n   \"cmp.w\t%T1,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"compare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare:HI (match_operand:HI 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"ri\")))]\n+\t(compare:HI (match_operand:HI 0 \"register_operand\" \"r,r\")\n+\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"r,i\")))]\n   \"TARGET_H8300H\"\n   \"cmp.w\t%T1,%T0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"compare\")])\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"compare,compare\")])\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"ri\")))]\n+\t(compare:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")))]\n   \"TARGET_H8300H\"\n   \"cmp.l\t%S1,%S0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"compare\")])\n+  [(set_attr \"length\" \"2,6\")\n+   (set_attr \"cc\" \"compare,compare\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n@@ -622,8 +637,8 @@\n   \"@\n    add\t%w2,%w0\\;addx\t%x2,%x0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n    add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n-   mov\t%f1,%f0\\;mov\t%e1,%e0\\;add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n-  [(set_attr \"length\" \"8,6,20\")\n+   mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\;add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n+  [(set_attr \"length\" \"8,6,10\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"addsi_h8300h\"\n@@ -686,7 +701,7 @@\n   \"TARGET_H8300\"\n   \"@\n    sub.w\t%T2,%T0\n-   add.b\t%E2,%s0\\;addx\t%F2,%t0 ; -%0\"\n+   add.b\t%E2,%s0\\;addx\t%F2,%t0\"\n   [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"set_zn_c0,clobber\")])\n \n@@ -876,7 +891,7 @@\n ;; AND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"andqi3_internal\"\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n \t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,O\")))]\n@@ -888,9 +903,9 @@\n    (set_attr \"cc\" \"set,none_0hit\")])\n \n (define_expand \"andqi3\"\n-  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n-\t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,O\")))]\n+  [(set (match_operand:QI 0 \"bit_operand\" \"\")\n+\t(and:QI (match_operand:QI 1 \"bit_operand\" \"\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -899,9 +914,9 @@\n }\")\n \n (define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"J,rn\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"rn\")))]\n   \"\"\n   \"*\n {\n@@ -919,53 +934,68 @@\n     return \\\"and.w %T2,%T0\\\";\n   return \\\"and\t%s2,%s0\\;and\t%t2,%t0;\\\";\n }\"\n-  [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"clobber,clobber\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"J,rn\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rn\")))]\n   \"\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int i = INTVAL (operands[2]);\n-\n-      /* ??? If we used e0..e7, then we could sub.w eX,eX to\n-\t clear the high word if (i & 0xffff0000) == 0.  */\n+      int upper_cleared, lower_cleared;\n \n       /* The h8300h can't do byte-wise operations on the\n \t upper 16bits of 32bit registers.  However, if\n-\t those bits aren't going to change, then we can\n-\t work on the low-order bits.  */\n+\t those bits aren't going to change, or they're\n+\t going to be zero'd out, then we can work on the\n+\t low-order bits.  */\n       if (TARGET_H8300H\n-\t  && (i & 0xffff0000) != 0xffff0000)\n+\t  && ((i & 0xffff0000) != 0xffff0000\n+\t      || (i & 0xffff0000) == 0x00000000))\n         return \\\"and.l\t%S2,%S0\\\";\n \n-      if ((i & 0x000000ff) != 0x000000ff) \n+      lower_cleared = 0;\n+      if ((i & 0x0000ffff) == 0x00000000)\n+\t{\n+\t  output_asm_insn (\\\"sub.w\t%f0,%f0\\\", operands);\n+\t  lower_cleared = 1;\n+\t}\n+\n+      upper_cleared = 0;\n+      if ((i & 0xffff0000) == 0x00000000)\n+\t{\n+\t  output_asm_insn (\\\"sub.w\t%e0,%e0\\\", operands);\n+\t  upper_cleared = 1;\n+\t}\n+\n+      if ((i & 0x000000ff) != 0x000000ff && !lower_cleared)\n \toutput_asm_insn (\\\"and\t%w2,%w0\\\", operands);\n-      if ((i & 0x0000ff00) != 0x0000ff00) \n+      if ((i & 0x0000ff00) != 0x0000ff00 && !lower_cleared)\n \toutput_asm_insn (\\\"and\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0x00ff0000) \n+      if ((i & 0x00ff0000) != 0x00ff0000 && !upper_cleared) \n \toutput_asm_insn (\\\"and\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0xff000000) \n+      if ((i & 0xff000000) != 0xff000000 && !upper_cleared) \n \toutput_asm_insn (\\\"and\t%z2,%z0\\\", operands);\n       return \\\"\\\";\n     }\n   if (TARGET_H8300H)\n     return \\\"and.l\t%S2,%S0\\\";\n   return \\\"and\t%w2,%w0\\;and\t%x2,%x0\\;and\t%y2,%y0\\;and\t%z2,%z0\\;\\\";\n }\"\n-  [(set_attr \"length\" \"2,8\")\n-   (set_attr \"cc\" \"clobber,clobber\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"iorqi3_internal\"\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n \t(ior:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,P\")))]\n@@ -1051,7 +1081,7 @@\n ;; XOR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"xorqi3_internal\"\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n \t(xor:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,P\")))]\n@@ -1231,7 +1261,7 @@\n   [(set_attr \"cc\" \"clobber\")\n    (set (attr \"length\")\n \t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n-\t\t      (const_int 8)\n+\t\t      (const_int 4)\n \t\t      (const_int 2)))])\n \n (define_insn \"one_cmplsi2\"\n@@ -1441,25 +1471,21 @@\n ;; This is a define expand, because pointers may be either 16 or 32 bits.\n \n (define_expand \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"jump_address_operand\" \"Vr\"))]\n+  [(set (pc) (match_operand 0 \"jump_address_operand\" \"\"))]\n   \"\"\n   \"\")\n \n (define_insn \"indirect_jump_h8300\"\n-  [(set (pc) (match_operand:HI 0 \"jump_address_operand\" \"V,r\"))]\n+  [(set (pc) (match_operand:HI 0 \"jump_address_operand\" \"Vr\"))]\n   \"TARGET_H8300\"\n-  \"@\n-   jmp\t@%0\n-   jmp\t@%0\"\n+  \"jmp\t@%0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"indirect_jump_h8300h\"\n-  [(set (pc) (match_operand:SI 0 \"jump_address_operand\" \"V,r\"))]\n+  [(set (pc) (match_operand:SI 0 \"jump_address_operand\" \"Vr\"))]\n   \"TARGET_H8300H\"\n-  \"@\n-   jmp @%0\n-   jmp @%0\"\n+  \"jmp @%0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n@@ -1559,10 +1585,8 @@\n     }\n }\")\n \n-\n-;; I don't know why, but if I try to simplify extendhisi2 in the\n-;; natural way, I get about a 2X code bloat on the h8300 without\n-;; optimization, and a small bloat with optimization.  Weird.\n+;; This is used when not optimizing.  It avoids severe code explosion\n+;; due to poor register allocation.\n (define_expand \"zero_extendhisi2_h8300\"\n   [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n    (set (reg:SI 0) (zero_extend:SI (reg:HI 1)))\n@@ -1644,9 +1668,8 @@\n     }\n }\")\n \n-;; I don't know why, but if I try to simplify extendhisi2 in the\n-;; natural way, I get about a 2X code bloat on the h8300 without\n-;; optimization, and a small bloat with optimization.  Weird.\n+;; This is used when not optimizing.  It avoids severe code explosion\n+;; due to poor register allocation.\n (define_expand \"extendhisi2_h8300\"\n   [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n    (set (reg:SI 0) (sign_extend:SI (reg:HI 1)))\n@@ -1716,21 +1739,15 @@\n   \"\"\n   \"if (expand_a_shift (QImode, LSHIFTRT, operands)) DONE;else FAIL;\")\n \n-;; WARNING: The constraints on the scratch register say one is not needed\n-;; for constant shifts of 1,2,3,4.  Emit_a_shift() must know this.\n-\n-(define_insn \"shiftbyn_QI\"\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:QI 3 \"nshift_operator\" \n \t\t\t[ (match_operand:QI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"IKM,rn\")]))\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"KM,rn\")]))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n   \"\"\n   \"* return emit_a_shift (insn, operands);\"\n   [(set_attr \"length\" \"20\")\n-;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.\n-;; However, for cases that loop or are done in pieces, cc does not contain\n-;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n \n ;; HI BIT SHIFTS\n@@ -1756,21 +1773,15 @@\n   \"\"\n   \"if (expand_a_shift (HImode, ASHIFTRT, operands)) DONE;else FAIL;\")\n \n-;; WARNING: The constraints on the scratch register say one is not needed\n-;; for constant shifts of 1,2,3,4.  Emit_a_shift() must know this.\n-\n-(define_insn \"shiftbyn_HI\"\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:HI 3 \"nshift_operator\" \n \t\t\t[ (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"IKM,rn\")]))\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"KM,rn\")]))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n   \"\"\n   \"* return emit_a_shift (insn, operands);\"\n   [(set_attr \"length\" \"20\")\n-;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.\n-;; However, for cases that loop or are done in pieces, cc does not contain\n-;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n \n ;;  SI BIT SHIFTS\n@@ -1799,21 +1810,15 @@\n   \"\"\n   \"if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;else FAIL;\")\n \n-;; WARNING: The constraints on the scratch register say one is not needed\n-;; for constant shifts of 1,2.  Emit_a_shift() must know this.\n-\n-(define_insn \"shiftbyn_SI\"\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:SI 3 \"nshift_operator\" \n \t\t\t[ (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"IK,rn\")]))\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"K,rn\")]))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n   \"\"\n   \"* return emit_a_shift (insn, operands);\"\n   [(set_attr \"length\" \"20\")\n-;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.\n-;; However, for cases that loop or are done in pieces, cc does not contain\n-;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n \f\n ;; -----------------------------------------------------------------"}]}