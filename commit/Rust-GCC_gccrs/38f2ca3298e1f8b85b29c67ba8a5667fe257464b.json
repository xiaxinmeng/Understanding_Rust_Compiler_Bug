{"sha": "38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmMmNhMzI5OGUxZjhiODViMjljNjdiYThhNTY2N2ZlMjU3NDY0Yg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2012-11-20T16:26:09Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-11-20T16:26:09Z"}, "message": "Convert vec<> into a POD.\n\nThis fixes PR 55398 by making vec<> a true POD.  I thought we could get\naway with having private fields, but we can't.  We fail to pass vec<>\ninstances through varargs.\n\nThe patch makes every field public and mangles the field names in the\nhope that no future patch will try to make use of them directly.  It's\nhorrible, but I could not think of anything better.\n\nTested with clang++ as the host compiler.\n\n2012-11-20  Diego Novillo  <dnovillo@google.com>\n\n    PR middle-end/55398\n    * vec.h (class vec_prefix): Make every field public.\n    Rename field alloc_ to alloc_PRIVATE_.\n    Rename field num_ to num_PRIVATE_.\n    Update all users.\n    (class vec<T, A, vl_embed>): Make every field public.\n    Rename field pfx_ to pfx_PRIVATE_.\n    Rename field data_ to data_PRIVATE_.\n    Update all users.\n    (class vec<T, A, vl_ptr>): Make every field public.\n    Rename field vec_ to vec_PRIVATE_.\n    Update all users.\n\nFrom-SVN: r193667", "tree": {"sha": "c6eacf875d89904de020dba161a8e1c743b4f46f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6eacf875d89904de020dba161a8e1c743b4f46f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a397c3e09d7909f4585b864da9660544d8349f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a397c3e09d7909f4585b864da9660544d8349f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a397c3e09d7909f4585b864da9660544d8349f3"}], "stats": {"total": 231, "additions": 130, "deletions": 101}, "files": [{"sha": "b6b5058ae851fd8c40e89c090ccc2cf2882f6ec2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "patch": "@@ -1,3 +1,18 @@\n+2012-11-20  Diego Novillo  <dnovillo@google.com>\n+\n+\tPR middle-end/55398\n+\t* vec.h (class vec_prefix): Make every field public.\n+\tRename field alloc_ to alloc_PRIVATE_.\n+\tRename field num_ to num_PRIVATE_.\n+\tUpdate all users.\n+\t(class vec<T, A, vl_embed>): Make every field public.\n+\tRename field pfx_ to pfx_PRIVATE_.\n+\tRename field data_ to data_PRIVATE_.\n+\tUpdate all users.\n+\t(class vec<T, A, vl_ptr>): Make every field public.\n+\tRename field vec_ to vec_PRIVATE_.\n+\tUpdate all users.\n+\n 2012-11-20  Kai Tietz  <ktietz@redhat.com>\n \n \tPR target/55268"}, {"sha": "3f8f55003037b6e8516c09b418d73ae1036d672a", "filename": "gcc/vec.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "patch": "@@ -121,8 +121,8 @@ vec_descriptor (const char *name, int line, const char *function)\n /* Account the overhead.  */\n \n void\n-vec_prefix::register_overhead (size_t size, const char *name, int line,\n-\t\t\t       const char *function)\n+vec_prefix::register_overhead_PRIVATE_ (size_t size, const char *name, int line,\n+\t\t\t                const char *function)\n {\n   struct vec_descriptor *loc = vec_descriptor (name, line, function);\n   struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n@@ -148,7 +148,7 @@ vec_prefix::register_overhead (size_t size, const char *name, int line,\n /* Notice that the memory allocated for the vector has been freed.  */\n \n void\n-vec_prefix::release_overhead (void)\n+vec_prefix::release_overhead_PRIVATE_ (void)\n {\n   PTR *slot = htab_find_slot_with_hash (ptr_hash, this,\n \t\t\t\t\thtab_hash_pointer (this),\n@@ -165,15 +165,16 @@ vec_prefix::release_overhead (void)\n    exponentially.  PFX is the control data for the vector.  */\n \n unsigned\n-vec_prefix::calculate_allocation (vec_prefix *pfx, unsigned reserve, bool exact)\n+vec_prefix::calculate_allocation_PRIVATE_ (vec_prefix *pfx, unsigned reserve,\n+\t\t\t\t\t   bool exact)\n {\n   unsigned alloc = 0;\n   unsigned num = 0;\n \n   if (pfx)\n     {\n-      alloc = pfx->alloc_;\n-      num = pfx->num_;\n+      alloc = pfx->alloc_PRIVATE_;\n+      num = pfx->num_PRIVATE_;\n     }\n   else if (!reserve)\n     /* If there's no vector, and we've not requested anything, then we"}, {"sha": "61ae9bfb2f9be35ae3767e9a219c770e2dac9617", "filename": "gcc/vec.h", "status": "modified", "additions": 108, "deletions": 95, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f2ca3298e1f8b85b29c67ba8a5667fe257464b/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=38f2ca3298e1f8b85b29c67ba8a5667fe257464b", "patch": "@@ -216,11 +216,13 @@ extern void dump_vec_loc_statistics (void);\n \n class vec_prefix\n {\n-protected:\n+  /* FIXME - These fields should be private, but we need to cater to\n+\t     compilers that have stricter notions of PODness for types.  */\n+public:\n   /* Memory allocation support routines in vec.c.  */\n-  void register_overhead (size_t, const char *, int, const char *);\n-  void release_overhead (void);\n-  static unsigned calculate_allocation (vec_prefix *, unsigned, bool);\n+  void register_overhead_PRIVATE_ (size_t, const char *, int, const char *);\n+  void release_overhead_PRIVATE_ (void);\n+  static unsigned calculate_allocation_PRIVATE_ (vec_prefix *, unsigned, bool);\n \n   /* Note that vec_prefix should be a base class for vec, but we use\n      offsetof() on vector fields of tree structures (e.g.,\n@@ -236,8 +238,8 @@ class vec_prefix\n   friend struct va_heap;\n   friend struct va_stack;\n \n-  unsigned alloc_;\n-  unsigned num_;\n+  unsigned alloc_PRIVATE_;\n+  unsigned num_PRIVATE_;\n };\n \n template<typename, typename, typename> class vec;\n@@ -285,24 +287,24 @@ inline void\n va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n \t\t  MEM_STAT_DECL)\n {\n-  unsigned alloc = vec_prefix::calculate_allocation (v ? &v->pfx_ : 0, reserve,\n-\t\t\t\t\t\t     exact);\n+  unsigned alloc = vec_prefix::calculate_allocation_PRIVATE_ (\n+\t  v ? &v->pfx_PRIVATE_ : 0, reserve, exact);\n   if (!alloc)\n     {\n       release (v);\n       return;\n     }\n \n   if (GATHER_STATISTICS && v)\n-    v->pfx_.release_overhead ();\n+    v->pfx_PRIVATE_.release_overhead_PRIVATE_ ();\n \n   size_t size = vec<T, va_heap, vl_embed>::embedded_size (alloc);\n   unsigned nelem = v ? v->length () : 0;\n   v = static_cast <vec<T, va_heap, vl_embed> *> (xrealloc (v, size));\n   v->embedded_init (alloc, nelem);\n \n   if (GATHER_STATISTICS)\n-    v->pfx_.register_overhead (size FINAL_PASS_MEM_STAT);\n+    v->pfx_PRIVATE_.register_overhead_PRIVATE_ (size FINAL_PASS_MEM_STAT);\n }\n \n \n@@ -312,8 +314,11 @@ template<typename T>\n void\n va_heap::release (vec<T, va_heap, vl_embed> *&v)\n {\n+  if (v == NULL)\n+    return;\n+\n   if (GATHER_STATISTICS)\n-    v->pfx_.release_overhead ();\n+    v->pfx_PRIVATE_.release_overhead_PRIVATE_ ();\n   ::free (v);\n   v = NULL;\n }\n@@ -349,8 +354,8 @@ void\n va_gc::reserve (vec<T, A, vl_embed> *&v, unsigned reserve, bool exact\n \t\tMEM_STAT_DECL)\n {\n-  unsigned alloc = vec_prefix::calculate_allocation (v ? &v->pfx_ : 0, reserve,\n-\t\t\t\t\t\t     exact);\n+  unsigned alloc = vec_prefix::calculate_allocation_PRIVATE_ (\n+\t  v ? &v->pfx_PRIVATE_ : 0, reserve, exact);\n   if (!alloc)\n     {\n       ::ggc_free (v);\n@@ -418,9 +423,9 @@ void\n va_stack::alloc (vec<T, va_stack, vl_ptr> &v, unsigned nelems,\n \t\t vec<T, va_stack, vl_embed> *space)\n {\n-  v.vec_ = space;\n-  register_stack_vec (static_cast<void *> (v.vec_));\n-  v.vec_->embedded_init (nelems, 0);\n+  v.vec_PRIVATE_ = space;\n+  register_stack_vec (static_cast<void *> (v.vec_PRIVATE_));\n+  v.vec_PRIVATE_->embedded_init (nelems, 0);\n }\n \n \n@@ -447,15 +452,17 @@ va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact\n     }\n \n   /* Move VEC_ to the heap.  */\n-  nelems += v->pfx_.num_;\n+  nelems += v->pfx_PRIVATE_.num_PRIVATE_;\n   vec<T, va_stack, vl_embed> *oldvec = v;\n   v = NULL;\n   va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&>(v), nelems,\n \t\t    exact);\n   if (v && oldvec)\n     {\n-      v->pfx_.num_ = oldvec->length ();\n-      memcpy (v->data_, oldvec->data_, oldvec->length () * sizeof (T));\n+      v->pfx_PRIVATE_.num_PRIVATE_ = oldvec->length ();\n+      memcpy (v->data_PRIVATE_,\n+\t      oldvec->data_PRIVATE_,\n+\t      oldvec->length () * sizeof (T));\n     }\n }\n \n@@ -467,6 +474,9 @@ template<typename T>\n void\n va_stack::release (vec<T, va_stack, vl_embed> *&v)\n {\n+  if (v == NULL)\n+    return;\n+\n   int ix = stack_vec_register_index (static_cast<void *> (v));\n   if (ix >= 0)\n     {\n@@ -531,11 +541,11 @@ template<typename T, typename A>\n class GTY((user)) vec<T, A, vl_embed>\n {\n public:\n-  unsigned allocated (void) const { return pfx_.alloc_; }\n-  unsigned length (void) const { return pfx_.num_; }\n-  bool is_empty (void) const { return pfx_.num_ == 0; }\n-  T *address (void) { return data_; }\n-  const T *address (void) const { return data_; }\n+  unsigned allocated (void) const { return pfx_PRIVATE_.alloc_PRIVATE_; }\n+  unsigned length (void) const { return pfx_PRIVATE_.num_PRIVATE_; }\n+  bool is_empty (void) const { return pfx_PRIVATE_.num_PRIVATE_ == 0; }\n+  T *address (void) { return data_PRIVATE_; }\n+  const T *address (void) const { return data_PRIVATE_; }\n   const T &operator[] (unsigned) const;\n   T &operator[] (unsigned);\n   T &last (void);\n@@ -568,9 +578,10 @@ class GTY((user)) vec<T, A, vl_embed>\n   friend struct va_heap;\n   friend struct va_stack;\n \n-private:\n-  vec_prefix pfx_;\n-  T data_[1];\n+  /* FIXME - These fields should be private, but we need to cater to\n+\t     compilers that have stricter notions of PODness for types.  */\n+  vec_prefix pfx_PRIVATE_;\n+  T data_PRIVATE_[1];\n };\n \n \n@@ -782,16 +793,16 @@ template<typename T, typename A>\n inline const T &\n vec<T, A, vl_embed>::operator[] (unsigned ix) const\n {\n-  gcc_checking_assert (ix < pfx_.num_);\n-  return data_[ix];\n+  gcc_checking_assert (ix < pfx_PRIVATE_.num_PRIVATE_);\n+  return data_PRIVATE_[ix];\n }\n \n template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::operator[] (unsigned ix)\n {\n-  gcc_checking_assert (ix < pfx_.num_);\n-  return data_[ix];\n+  gcc_checking_assert (ix < pfx_PRIVATE_.num_PRIVATE_);\n+  return data_PRIVATE_[ix];\n }\n \n \n@@ -801,8 +812,8 @@ template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::last (void)\n {\n-  gcc_checking_assert (pfx_.num_ > 0);\n-  return (*this)[pfx_.num_ - 1];\n+  gcc_checking_assert (pfx_PRIVATE_.num_PRIVATE_ > 0);\n+  return (*this)[pfx_PRIVATE_.num_PRIVATE_ - 1];\n }\n \n \n@@ -816,7 +827,7 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::space (unsigned nelems) const\n {\n-  return pfx_.alloc_ - pfx_.num_ >= nelems;\n+  return pfx_PRIVATE_.alloc_PRIVATE_ - pfx_PRIVATE_.num_PRIVATE_ >= nelems;\n }\n \n \n@@ -831,9 +842,9 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::iterate (unsigned ix, T *ptr) const\n {\n-  if (ix < pfx_.num_)\n+  if (ix < pfx_PRIVATE_.num_PRIVATE_)\n     {\n-      *ptr = data_[ix];\n+      *ptr = data_PRIVATE_[ix];\n       return true;\n     }\n   else\n@@ -857,9 +868,9 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_embed>::iterate (unsigned ix, T **ptr) const\n {\n-  if (ix < pfx_.num_)\n+  if (ix < pfx_PRIVATE_.num_PRIVATE_)\n     {\n-      *ptr = CONST_CAST (T *, &data_[ix]);\n+      *ptr = CONST_CAST (T *, &data_PRIVATE_[ix]);\n       return true;\n     }\n   else\n@@ -882,7 +893,7 @@ vec<T, A, vl_embed>::copy (ALONE_MEM_STAT_DECL) const\n     {\n       vec_alloc (new_vec, len PASS_MEM_STAT);\n       new_vec->embedded_init (len, len);\n-      memcpy (new_vec->address(), data_, sizeof (T) * len);\n+      memcpy (new_vec->address(), data_PRIVATE_, sizeof (T) * len);\n     }\n   return new_vec;\n }\n@@ -900,7 +911,7 @@ vec<T, A, vl_embed>::splice (vec<T, A, vl_embed> &src)\n     {\n       gcc_checking_assert (space (len));\n       memcpy (address() + length(), src.address(), len * sizeof (T));\n-      pfx_.num_ += len;\n+      pfx_PRIVATE_.num_PRIVATE_ += len;\n     }\n }\n \n@@ -922,7 +933,7 @@ inline T *\n vec<T, A, vl_embed>::quick_push (const T &obj)\n {\n   gcc_checking_assert (space (1));\n-  T *slot = &data_[pfx_.num_++];\n+  T *slot = &data_PRIVATE_[pfx_PRIVATE_.num_PRIVATE_++];\n   *slot = obj;\n   return slot;\n }\n@@ -935,7 +946,7 @@ inline T &\n vec<T, A, vl_embed>::pop (void)\n {\n   gcc_checking_assert (length () > 0);\n-  return data_[--pfx_.num_];\n+  return data_PRIVATE_[--pfx_PRIVATE_.num_PRIVATE_];\n }\n \n \n@@ -947,7 +958,7 @@ inline void\n vec<T, A, vl_embed>::truncate (unsigned size)\n {\n   gcc_checking_assert (length () >= size);\n-  pfx_.num_ = size;\n+  pfx_PRIVATE_.num_PRIVATE_ = size;\n }\n \n \n@@ -960,8 +971,8 @@ vec<T, A, vl_embed>::quick_insert (unsigned ix, const T &obj)\n {\n   gcc_checking_assert (length () < allocated ());\n   gcc_checking_assert (ix <= length ());\n-  T *slot = &data_[ix];\n-  memmove (slot + 1, slot, (pfx_.num_++ - ix) * sizeof (T));\n+  T *slot = &data_PRIVATE_[ix];\n+  memmove (slot + 1, slot, (pfx_PRIVATE_.num_PRIVATE_++ - ix) * sizeof (T));\n   *slot = obj;\n }\n \n@@ -975,8 +986,8 @@ inline void\n vec<T, A, vl_embed>::ordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length());\n-  T *slot = &data_[ix];\n-  memmove (slot, slot + 1, (--pfx_.num_ - ix) * sizeof (T));\n+  T *slot = &data_PRIVATE_[ix];\n+  memmove (slot, slot + 1, (--pfx_PRIVATE_.num_PRIVATE_ - ix) * sizeof (T));\n }\n \n \n@@ -988,7 +999,7 @@ inline void\n vec<T, A, vl_embed>::unordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length());\n-  data_[ix] = data_[--pfx_.num_];\n+  data_PRIVATE_[ix] = data_PRIVATE_[--pfx_PRIVATE_.num_PRIVATE_];\n }\n \n \n@@ -1000,9 +1011,9 @@ inline void\n vec<T, A, vl_embed>::block_remove (unsigned ix, unsigned len)\n {\n   gcc_checking_assert (ix + len <= length());\n-  T *slot = &data_[ix];\n-  pfx_.num_ -= len;\n-  memmove (slot, slot + len, (pfx_.num_ - ix) * sizeof (T));\n+  T *slot = &data_PRIVATE_[ix];\n+  pfx_PRIVATE_.num_PRIVATE_ -= len;\n+  memmove (slot, slot + len, (pfx_PRIVATE_.num_PRIVATE_ - ix) * sizeof (T));\n }\n \n \n@@ -1066,7 +1077,7 @@ inline size_t\n vec<T, A, vl_embed>::embedded_size (unsigned alloc)\n {\n   typedef vec<T, A, vl_embed> vec_embedded;\n-  return offsetof (vec_embedded, data_) + alloc * sizeof (T);\n+  return offsetof (vec_embedded, data_PRIVATE_) + alloc * sizeof (T);\n }\n \n \n@@ -1077,8 +1088,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num)\n {\n-  pfx_.alloc_ = alloc;\n-  pfx_.num_ = num;\n+  pfx_PRIVATE_.alloc_PRIVATE_ = alloc;\n+  pfx_PRIVATE_.num_PRIVATE_ = num;\n }\n \n \n@@ -1089,8 +1100,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::quick_grow (unsigned len)\n {\n-  gcc_checking_assert (length () <= len && len <= pfx_.alloc_);\n-  pfx_.num_ = len;\n+  gcc_checking_assert (length () <= len && len <= pfx_PRIVATE_.alloc_PRIVATE_);\n+  pfx_PRIVATE_.num_PRIVATE_ = len;\n }\n \n \n@@ -1195,22 +1206,22 @@ class vec<T, A, vl_ptr>\n \n   /* Vector operations.  */\n   bool exists (void) const\n-  { return vec_ != NULL; }\n+  { return vec_PRIVATE_ != NULL; }\n \n   bool is_empty (void) const\n-  { return vec_ ? vec_->is_empty() : true; }\n+  { return vec_PRIVATE_ ? vec_PRIVATE_->is_empty() : true; }\n \n   unsigned length (void) const\n-  { return vec_ ? vec_->length() : 0; }\n+  { return vec_PRIVATE_ ? vec_PRIVATE_->length() : 0; }\n \n   T *address (void)\n-  { return vec_ ? vec_->data_ : NULL; }\n+  { return vec_PRIVATE_ ? vec_PRIVATE_->data_PRIVATE_ : NULL; }\n \n   const T *address (void) const\n-  { return vec_ ? vec_->data_ : NULL; }\n+  { return vec_PRIVATE_ ? vec_PRIVATE_->data_PRIVATE_ : NULL; }\n \n   const T &operator[] (unsigned ix) const\n-  { return (*vec_)[ix]; }\n+  { return (*vec_PRIVATE_)[ix]; }\n \n   bool operator!=(const vec &other) const\n   { return !(*this == other); }\n@@ -1219,13 +1230,13 @@ class vec<T, A, vl_ptr>\n   { return address() == other.address(); }\n \n   T &operator[] (unsigned ix)\n-  { return (*vec_)[ix]; }\n+  { return (*vec_PRIVATE_)[ix]; }\n \n   T &last (void)\n-  { return vec_->last(); }\n+  { return vec_PRIVATE_->last(); }\n \n   bool space (int nelems) const\n-  { return vec_ ? vec_->space (nelems) : nelems == 0; }\n+  { return vec_PRIVATE_ ? vec_PRIVATE_->space (nelems) : nelems == 0; }\n \n   bool iterate (unsigned ix, T *p) const;\n   bool iterate (unsigned ix, T **p) const;\n@@ -1254,8 +1265,9 @@ class vec<T, A, vl_ptr>\n   friend void va_stack::alloc(vec<T1, va_stack, vl_ptr>&, unsigned,\n \t\t\t      vec<T1, va_stack, vl_embed> *);\n \n-private:\n-  vec<T, A, vl_embed> *vec_;\n+  /* FIXME - This field should be private, but we need to cater to\n+\t     compilers that have stricter notions of PODness for types.  */\n+  vec<T, A, vl_embed> *vec_PRIVATE_;\n };\n \n \n@@ -1358,8 +1370,8 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const\n {\n-  if (vec_)\n-    return vec_->iterate (ix, ptr);\n+  if (vec_PRIVATE_)\n+    return vec_PRIVATE_->iterate (ix, ptr);\n   else\n     {\n       *ptr = 0;\n@@ -1381,8 +1393,8 @@ template<typename T, typename A>\n inline bool\n vec<T, A, vl_ptr>::iterate (unsigned ix, T **ptr) const\n {\n-  if (vec_)\n-    return vec_->iterate (ix, ptr);\n+  if (vec_PRIVATE_)\n+    return vec_PRIVATE_->iterate (ix, ptr);\n   else\n     {\n       *ptr = 0;\n@@ -1422,7 +1434,7 @@ vec<T, A, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n {\n   vec<T, A, vl_ptr> new_vec = vec<T, A, vl_ptr>();\n   if (length ())\n-    new_vec.vec_ = vec_->copy ();\n+    new_vec.vec_PRIVATE_ = vec_PRIVATE_->copy ();\n   return new_vec;\n }\n \n@@ -1442,7 +1454,7 @@ vec<T, A, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n {\n   bool extend = nelems ? !space (nelems) : false;\n   if (extend)\n-    A::reserve (vec_, nelems, exact PASS_MEM_STAT);\n+    A::reserve (vec_PRIVATE_, nelems, exact PASS_MEM_STAT);\n   return extend;\n }\n \n@@ -1469,7 +1481,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::create (unsigned nelems MEM_STAT_DECL)\n {\n-  vec_ = NULL;\n+  vec_PRIVATE_ = NULL;\n   if (nelems > 0)\n     reserve_exact (nelems PASS_MEM_STAT);\n }\n@@ -1481,8 +1493,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::release (void)\n {\n-  if (vec_)\n-    A::release (vec_);\n+  if (vec_PRIVATE_)\n+    A::release (vec_PRIVATE_);\n }\n \n \n@@ -1495,8 +1507,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::splice (vec<T, A, vl_ptr> &src)\n {\n-  if (src.vec_)\n-    vec_->splice (*(src.vec_));\n+  if (src.vec_PRIVATE_)\n+    vec_PRIVATE_->splice (*(src.vec_PRIVATE_));\n }\n \n \n@@ -1525,7 +1537,7 @@ template<typename T, typename A>\n inline T *\n vec<T, A, vl_ptr>::quick_push (const T &obj)\n {\n-  return vec_->quick_push (obj);\n+  return vec_PRIVATE_->quick_push (obj);\n }\n \n \n@@ -1548,7 +1560,7 @@ template<typename T, typename A>\n inline T &\n vec<T, A, vl_ptr>::pop (void)\n {\n-  return vec_->pop ();\n+  return vec_PRIVATE_->pop ();\n }\n \n \n@@ -1559,8 +1571,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::truncate (unsigned size)\n {\n-  if (vec_)\n-    vec_->truncate (size);\n+  if (vec_PRIVATE_)\n+    vec_PRIVATE_->truncate (size);\n   else\n     gcc_checking_assert (size == 0);\n }\n@@ -1577,7 +1589,7 @@ vec<T, A, vl_ptr>::safe_grow (unsigned len MEM_STAT_DECL)\n   unsigned oldlen = length ();\n   gcc_checking_assert (oldlen <= len);\n   reserve_exact (len - oldlen PASS_MEM_STAT);\n-  vec_->quick_grow (len);\n+  vec_PRIVATE_->quick_grow (len);\n }\n \n \n@@ -1602,8 +1614,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_grow (unsigned len)\n {\n-  gcc_checking_assert (vec_);\n-  vec_->quick_grow (len);\n+  gcc_checking_assert (vec_PRIVATE_);\n+  vec_PRIVATE_->quick_grow (len);\n }\n \n \n@@ -1615,8 +1627,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_grow_cleared (unsigned len)\n {\n-  gcc_checking_assert (vec_);\n-  vec_->quick_grow_cleared (len);\n+  gcc_checking_assert (vec_PRIVATE_);\n+  vec_PRIVATE_->quick_grow_cleared (len);\n }\n \n \n@@ -1627,7 +1639,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::quick_insert (unsigned ix, const T &obj)\n {\n-  vec_->quick_insert (ix, obj);\n+  vec_PRIVATE_->quick_insert (ix, obj);\n }\n \n \n@@ -1651,7 +1663,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::ordered_remove (unsigned ix)\n {\n-  vec_->ordered_remove (ix);\n+  vec_PRIVATE_->ordered_remove (ix);\n }\n \n \n@@ -1662,7 +1674,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::unordered_remove (unsigned ix)\n {\n-  vec_->unordered_remove (ix);\n+  vec_PRIVATE_->unordered_remove (ix);\n }\n \n \n@@ -1673,7 +1685,7 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::block_remove (unsigned ix, unsigned len)\n {\n-  vec_->block_remove (ix, len);\n+  vec_PRIVATE_->block_remove (ix, len);\n }\n \n \n@@ -1684,8 +1696,8 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n {\n-  if (vec_)\n-    vec_->qsort (cmp);\n+  if (vec_PRIVATE_)\n+    vec_PRIVATE_->qsort (cmp);\n }\n \n \n@@ -1696,9 +1708,10 @@ vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n \n template<typename T, typename A>\n inline unsigned\n-vec<T, A, vl_ptr>::lower_bound (T obj, bool (*lessthan)(const T &, const T &)) const\n+vec<T, A, vl_ptr>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n+    const\n {\n-  return vec_ ? vec_->lower_bound (obj, lessthan) : 0;\n+  return vec_PRIVATE_ ? vec_PRIVATE_->lower_bound (obj, lessthan) : 0;\n }\n \n #endif // GCC_VEC_H"}]}