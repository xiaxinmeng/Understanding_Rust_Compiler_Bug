{"sha": "10d22567504587ae20ff4dbe8188f7ead6776cdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBkMjI1Njc1MDQ1ODdhZTIwZmY0ZGJlODE4OGY3ZWFkNjc3NmNkZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-02-06T18:20:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-02-06T18:20:47Z"}, "message": "tree-vrp.c (execute_vrp): Do not pass dump argument to.\n\n\t* tree-vrp.c (execute_vrp): Do not pass dump argument to.\n\tloop_optimizer_init and loop_optimizer_finalize\n\t* tree-ssa-sink.c (execute_sink_code): Ditto.\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Ditto.\n\t* tree-ssa-loop.c (tree_loop_optimizer_init, tree_ssa_loop_init,\n\ttree_ssa_loop_done): Ditto.\n\t* tree-ssa-pre.c (init_pre, fini_pre): Ditto.\n\t* sched-ebb.c: Include output.h.\n\t(schedule_ebbs): Do not use dump argument.\n\t* value-prof.h (struct profile_hooks): Remove profile_dump_file.\n\t* loop.c (loop_dump_stream): Removed.\n\t(loop_optimize, rest_of_handle_loop_optimize): Do not use dump\n\targument.\n\t(scan_loop, move_movables, find_and_verify_loops, mark_loop_jump,\n\temit_prefetch_instructions, loop_bivs_find, loop_bivs_check,\n\tfinal_biv_value, loop_biv_eliminable_p, loop_givs_rescan,\n\tloop_iterations, strength_reduce, record_biv, record_giv,\n\tfinal_giv_value, check_final_value, check_ext_dependent_givs,\n\tcombine_givs, check_dbra_loop, maybe_eliminate_biv, load_mems,\n\ttry_copy_prop, loop_delete_insns, try_swap_copy_prop): Use\n\tdump_file instead of loop_dump_stream.\n\t* ddg.c (print_ddg_edge, print_ddg, vcg_print_ddg): Do not call\n\targument dump_file.\n\t* reorg.c (dbr_schedule, rest_of_handle_delay_slots): Do not use\n\tdump argument.\n\t* flow.c (life_analysis, rest_of_handle_life): Ditto.\n\t* haifa-sched.c: Include output.h\n\t(schedule_insns, sched_init): Do not use dump argument.\n\t* mode-switching.c (optimize_mode_switching): Ditto.\n\t* modulo-sched.c (stats_file): Removed.\n\t(print_node_sched_params): Do not call argument dump_file.\n\t(sms_schedule_by_order, loop_canon_p, sms_schedule,\n\trest_of_handle_sms): Do not use dump argument.  Use dump_file instead\n\tof stats_file.\n\t* cse.c (cse_main, rest_of_handle_cse, rest_of_handle_cse2): Do not\n\tuse dump argument.\n\t* loop-init.c (loop_optimizer_init, loop_optimizer_finalize,\n\trtl_loop_init, rtl_loop_done): Ditto.\n\t* global.c (global_alloc, rest_of_handle_global_alloc): Ditto.\n\t* predict.c (combine_predictions_for_bb, tree_estimate_probability):\n\tDitto.\n\t* recog.c (peephole2_optimize, rest_of_handle_peephole2): Ditto.\n\t* lcm.c (pre_edge_lcm, pre_edge_rev_lcm): Ditto.\n\t* regmove.c (fixup_match_1, fixup_match_2, regmove_optimize,\n\trest_of_handle_regmove, rest_of_handle_stack_adjustments): Ditto.\n\t* emit-rtl.c (renumber_insns): Ditto.\n\t* cfgexpand.c (add_reg_br_prob_note, expand_gimple_cond_expr,\n\texpand_gimple_basic_block, tree_expand_cfg): Ditto.\n\t* regclass.c (regclass): Ditto.\n\t* tree-outof-ssa.c (analyze_edges_for_bb, perform_edge_inserts,\n\tremove_ssa_form, rewrite_out_of_ssa): Ditto.\n\t* reg-stack.c (compensate_edge, compensate_edges, convert_regs_1,\n\tconvert_regs_2, convert_regs, reg_to_stack, rest_of_handle_stack_regs):\n\tDitto.\n\t* sched-rgn.c (schedule_insns, rest_of_handle_sched): Ditto.\n\t* local-alloc.c (rest_of_handle_local_alloc): Do not pass dump_file\n\tto regclass.\n\t* gcse.c (gcse_file, debug_stderr): Removed.\n\t(gcse_main, bypass_jumps, rest_of_handle_jump_bypass,\n\trest_of_handle_gcse): Do not use dump argument.\n\t(cprop_jump, cprop_insn, do_local_cprop, cprop, find_implicit_sets,\n\tone_cprop_pass, bypass_block, compute_pre_data, insert_insn_end_bb,\n\tpre_edge_insert, pre_insert_copy_insn, pre_delete, one_pre_gcse_pass,\n\tcompute_code_hoist_vbeinout, compute_code_hoist_data,\n\tone_code_hoisting_pass, trim_ld_motion_mems, update_ld_motion_stores,\n\tcompute_store_table, build_store_vectors, insert_insn_start_bb,\n\tinsert_store, remove_reachable_equiv_notes, replace_store_insn,\n\tstore_motion): Use dump_file instead of gcse_file.\n\t* ipa-type-escape.c (type_escape_execute): Remove debugging comments.\n\t* profile.c (profile_dump_file): Removed.\n\t(branch_prob): Use dump_file instead of profile_dump_file.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Do not call argument\n\tdump_file.\n\t* tree-ssa-copy.c (dump_copy_of): Ditto.\n\t* rtl-factoring.c (rtl_seqabstr, rest_of_rtl_seqabstr): Do not pass\n\tdump file to life_analysis.\n\t* bt-load.c (branch_target_load_optimize): Ditto.\n\t* cfgcleanup.c (rest_of_handle_jump2): Do not pass dump_file to\n\trenumber_insns.\n\t* rtl.h (cse_main, renumber_insns, schedule_insns, schedule_ebbs,\n\tregclass, dbr_schedule): Declaration changed.\n\t* sched-int.h (sched_init): Declaration changed.\n\t* tree-profile.c (tree_profile_dump_file): Removed.\n\t(tree_profile_hooks): Removed profile_dump_file hook.\n\t* rtl-profile (rtl_profile_dump_file): Removed.\n\t(rtl_profile_hooks): emoved profile_dump_file hook.\n\t* cfgloop.h (loop_optimizer_init, loop_optimizer_finalize): Declaration\n\tchanged.\n\t* c-gimplify.c (c_genericize): Do not call local variable dump_file.\n\t* tree-cfg.c (build_tree_cfg): Ditto.\n\t* Makefile.in (haifa-sched.o, sched-ebb.o): Add output.h dependency.\n\t* basic-block.h (life_analysis, pre_edge_lcm, pre_edge_rev_lcm):\n\tDeclaration changed.\n\t* config/sh/sh.c (sh_output_mi_thunk): Do not pass dump_file to\n\tlife_analysis and schedule_insns.\n\t* config/m68hc11/m68hc11.c (m68hc11_reorg): Do not pass dump_file to\n\tlife_analysis.\n\t* config/mt/mt.c (mt_machine_reorg): Do not pass dump_file to\n\tdbr_schedule.\n\t* config/mips/mips.c (mips_reorg): Ditto.\n\t* config/ia64/ia64.c (ia64_reorg): Do not pass dump_file to\n\tschedule_ebbs.\n\nFrom-SVN: r110656", "tree": {"sha": "acb6601c5a9ddbbe44f73689c705a8c06f41dc41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acb6601c5a9ddbbe44f73689c705a8c06f41dc41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10d22567504587ae20ff4dbe8188f7ead6776cdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d22567504587ae20ff4dbe8188f7ead6776cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d22567504587ae20ff4dbe8188f7ead6776cdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d22567504587ae20ff4dbe8188f7ead6776cdd/comments", "author": null, "committer": null, "parents": [{"sha": "7269aee7d553dc3b89aadc00950024fde12631b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7269aee7d553dc3b89aadc00950024fde12631b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7269aee7d553dc3b89aadc00950024fde12631b4"}], "stats": {"total": 1535, "additions": 782, "deletions": 753}, "files": [{"sha": "2694394be19f7f959724599859dd43da1d4b490b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -1,3 +1,108 @@\n+2006-02-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-vrp.c (execute_vrp): Do not pass dump argument to.\n+\tloop_optimizer_init and loop_optimizer_finalize\n+\t* tree-ssa-sink.c (execute_sink_code): Ditto.\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Ditto.\n+\t* tree-ssa-loop.c (tree_loop_optimizer_init, tree_ssa_loop_init,\n+\ttree_ssa_loop_done): Ditto.\n+\t* tree-ssa-pre.c (init_pre, fini_pre): Ditto.\n+\t* sched-ebb.c: Include output.h.\n+\t(schedule_ebbs): Do not use dump argument.\n+\t* value-prof.h (struct profile_hooks): Remove profile_dump_file.\n+\t* loop.c (loop_dump_stream): Removed.\n+\t(loop_optimize, rest_of_handle_loop_optimize): Do not use dump\n+\targument.\n+\t(scan_loop, move_movables, find_and_verify_loops, mark_loop_jump,\n+\temit_prefetch_instructions, loop_bivs_find, loop_bivs_check,\n+\tfinal_biv_value, loop_biv_eliminable_p, loop_givs_rescan,\n+\tloop_iterations, strength_reduce, record_biv, record_giv,\n+\tfinal_giv_value, check_final_value, check_ext_dependent_givs,\n+\tcombine_givs, check_dbra_loop, maybe_eliminate_biv, load_mems,\n+\ttry_copy_prop, loop_delete_insns, try_swap_copy_prop): Use\n+\tdump_file instead of loop_dump_stream.\n+\t* ddg.c (print_ddg_edge, print_ddg, vcg_print_ddg): Do not call\n+\targument dump_file.\n+\t* reorg.c (dbr_schedule, rest_of_handle_delay_slots): Do not use\n+\tdump argument.\n+\t* flow.c (life_analysis, rest_of_handle_life): Ditto.\n+\t* haifa-sched.c: Include output.h\n+\t(schedule_insns, sched_init): Do not use dump argument.\n+\t* mode-switching.c (optimize_mode_switching): Ditto.\n+\t* modulo-sched.c (stats_file): Removed.\n+\t(print_node_sched_params): Do not call argument dump_file.\n+\t(sms_schedule_by_order, loop_canon_p, sms_schedule,\n+\trest_of_handle_sms): Do not use dump argument.  Use dump_file instead\n+\tof stats_file.\n+\t* cse.c (cse_main, rest_of_handle_cse, rest_of_handle_cse2): Do not\n+\tuse dump argument.\n+\t* loop-init.c (loop_optimizer_init, loop_optimizer_finalize,\n+\trtl_loop_init, rtl_loop_done): Ditto.\n+\t* global.c (global_alloc, rest_of_handle_global_alloc): Ditto.\n+\t* predict.c (combine_predictions_for_bb, tree_estimate_probability):\n+\tDitto.\n+\t* recog.c (peephole2_optimize, rest_of_handle_peephole2): Ditto.\n+\t* lcm.c (pre_edge_lcm, pre_edge_rev_lcm): Ditto.\n+\t* regmove.c (fixup_match_1, fixup_match_2, regmove_optimize,\n+\trest_of_handle_regmove, rest_of_handle_stack_adjustments): Ditto.\n+\t* emit-rtl.c (renumber_insns): Ditto.\n+\t* cfgexpand.c (add_reg_br_prob_note, expand_gimple_cond_expr,\n+\texpand_gimple_basic_block, tree_expand_cfg): Ditto.\n+\t* regclass.c (regclass): Ditto.\n+\t* tree-outof-ssa.c (analyze_edges_for_bb, perform_edge_inserts,\n+\tremove_ssa_form, rewrite_out_of_ssa): Ditto.\n+\t* reg-stack.c (compensate_edge, compensate_edges, convert_regs_1,\n+\tconvert_regs_2, convert_regs, reg_to_stack, rest_of_handle_stack_regs):\n+\tDitto.\n+\t* sched-rgn.c (schedule_insns, rest_of_handle_sched): Ditto.\n+\t* local-alloc.c (rest_of_handle_local_alloc): Do not pass dump_file\n+\tto regclass.\n+\t* gcse.c (gcse_file, debug_stderr): Removed.\n+\t(gcse_main, bypass_jumps, rest_of_handle_jump_bypass,\n+\trest_of_handle_gcse): Do not use dump argument.\n+\t(cprop_jump, cprop_insn, do_local_cprop, cprop, find_implicit_sets,\n+\tone_cprop_pass, bypass_block, compute_pre_data, insert_insn_end_bb,\n+\tpre_edge_insert, pre_insert_copy_insn, pre_delete, one_pre_gcse_pass,\n+\tcompute_code_hoist_vbeinout, compute_code_hoist_data,\n+\tone_code_hoisting_pass, trim_ld_motion_mems, update_ld_motion_stores,\n+\tcompute_store_table, build_store_vectors, insert_insn_start_bb,\n+\tinsert_store, remove_reachable_equiv_notes, replace_store_insn,\n+\tstore_motion): Use dump_file instead of gcse_file.\n+\t* ipa-type-escape.c (type_escape_execute): Remove debugging comments.\n+\t* profile.c (profile_dump_file): Removed.\n+\t(branch_prob): Use dump_file instead of profile_dump_file.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Do not call argument\n+\tdump_file.\n+\t* tree-ssa-copy.c (dump_copy_of): Ditto.\n+\t* rtl-factoring.c (rtl_seqabstr, rest_of_rtl_seqabstr): Do not pass\n+\tdump file to life_analysis.\n+\t* bt-load.c (branch_target_load_optimize): Ditto.\n+\t* cfgcleanup.c (rest_of_handle_jump2): Do not pass dump_file to\n+\trenumber_insns.\n+\t* rtl.h (cse_main, renumber_insns, schedule_insns, schedule_ebbs,\n+\tregclass, dbr_schedule): Declaration changed.\n+\t* sched-int.h (sched_init): Declaration changed.\n+\t* tree-profile.c (tree_profile_dump_file): Removed.\n+\t(tree_profile_hooks): Removed profile_dump_file hook.\n+\t* rtl-profile (rtl_profile_dump_file): Removed.\n+\t(rtl_profile_hooks): emoved profile_dump_file hook.\n+\t* cfgloop.h (loop_optimizer_init, loop_optimizer_finalize): Declaration\n+\tchanged.\n+\t* c-gimplify.c (c_genericize): Do not call local variable dump_file.\n+\t* tree-cfg.c (build_tree_cfg): Ditto.\n+\t* Makefile.in (haifa-sched.o, sched-ebb.o): Add output.h dependency.\n+\t* basic-block.h (life_analysis, pre_edge_lcm, pre_edge_rev_lcm):\n+\tDeclaration changed.\n+\t* config/sh/sh.c (sh_output_mi_thunk): Do not pass dump_file to\n+\tlife_analysis and schedule_insns.\n+\t* config/m68hc11/m68hc11.c (m68hc11_reorg): Do not pass dump_file to\n+\tlife_analysis.\n+\t* config/mt/mt.c (mt_machine_reorg): Do not pass dump_file to\n+\tdbr_schedule.\n+\t* config/mips/mips.c (mips_reorg): Ditto.\n+\t* config/ia64/ia64.c (ia64_reorg): Do not pass dump_file to\n+\tschedule_ebbs.\n+\n 2006-02-06  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/s390/s390.c (TARGET_MANGLE_FUNDAMENTAL_TYPE): Define."}, {"sha": "2aef2511d58a319328188c0c5e2738d5e9f45b4b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2505,7 +2505,7 @@ modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \\\n    cfghooks.h $(DF_H) $(GCOV_IO_H) hard-reg-set.h $(TM_H) timevar.h tree-pass.h\n haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \\\n-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H) output.h\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h \\\n@@ -2517,7 +2517,7 @@ sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) \\\n-   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H)\n+   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H) output.h\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H) \\\n    $(TM_P_H) real.h toplev.h tree-pass.h"}, {"sha": "2a2e8de30dc421bff7cc1c8a09eb0125d58c21a2", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -852,7 +852,7 @@ enum update_life_extent\n \t\t\t\t\t     to match only full blocks  */\n #define STRUCT_EQUIV_MATCH_JUMPS 8192\t/* Also include the jumps at the end of the block in the comparison.  */\n \n-extern void life_analysis (FILE *, int);\n+extern void life_analysis (int);\n extern int update_life_info (sbitmap, enum update_life_extent, int);\n extern int update_life_info_in_dirty_blocks (enum update_life_extent, int);\n extern int count_or_remove_death_notes (sbitmap, int);\n@@ -865,10 +865,10 @@ extern struct propagate_block_info *init_propagate_block_info\n extern void free_propagate_block_info (struct propagate_block_info *);\n \n /* In lcm.c */\n-extern struct edge_list *pre_edge_lcm (FILE *, int, sbitmap *, sbitmap *,\n+extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n \t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n \t\t\t\t       sbitmap **);\n-extern struct edge_list *pre_edge_rev_lcm (FILE *, int, sbitmap *,\n+extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap **,\n \t\t\t\t\t   sbitmap **);"}, {"sha": "a0a89bc2fbf8126845e10d659e5c9993167f75cf", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -1467,7 +1467,7 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n       cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n #endif\n \n-      life_analysis (NULL, 0);\n+      life_analysis (0);\n \n       /* Dominator info is also needed for migrate_btr_def.  */\n       calculate_dominance_info (CDI_DOMINATORS);"}, {"sha": "4208afb64f4d777a9720498a1a9323f660f8077a", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -77,29 +77,29 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n void\n c_genericize (tree fndecl)\n {\n-  FILE *dump_file;\n+  FILE *dump_orig;\n   int local_dump_flags;\n   struct cgraph_node *cgn;\n \n   /* Dump the C-specific tree IR.  */\n-  dump_file = dump_begin (TDI_original, &local_dump_flags);\n-  if (dump_file)\n+  dump_orig = dump_begin (TDI_original, &local_dump_flags);\n+  if (dump_orig)\n     {\n-      fprintf (dump_file, \"\\n;; Function %s\",\n+      fprintf (dump_orig, \"\\n;; Function %s\",\n \t       lang_hooks.decl_printable_name (fndecl, 2));\n-      fprintf (dump_file, \" (%s)\\n\",\n+      fprintf (dump_orig, \" (%s)\\n\",\n \t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)));\n-      fprintf (dump_file, \";; enabled by -%s\\n\", dump_flag_name (TDI_original));\n-      fprintf (dump_file, \"\\n\");\n+      fprintf (dump_orig, \";; enabled by -%s\\n\", dump_flag_name (TDI_original));\n+      fprintf (dump_orig, \"\\n\");\n \n       if (local_dump_flags & TDF_RAW)\n \tdump_node (DECL_SAVED_TREE (fndecl),\n-\t\t   TDF_SLIM | local_dump_flags, dump_file);\n+\t\t   TDF_SLIM | local_dump_flags, dump_orig);\n       else\n-\tprint_c_tree (dump_file, DECL_SAVED_TREE (fndecl));\n-      fprintf (dump_file, \"\\n\");\n+\tprint_c_tree (dump_orig, DECL_SAVED_TREE (fndecl));\n+      fprintf (dump_orig, \"\\n\");\n \n-      dump_end (TDI_original, dump_file);\n+      dump_end (TDI_original, dump_orig);\n     }\n \n   /* Go ahead and gimplify for now.  */"}, {"sha": "7be7e87818ceaf22b869d10004862a2b1b26c3ab", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2356,7 +2356,7 @@ rest_of_handle_jump2 (void)\n      future passes, allocate arrays whose dimensions involve the\n      maximum instruction UID, so if we can reduce the maximum UID\n      we'll save big on memory.  */\n-  renumber_insns (dump_file);\n+  renumber_insns ();\n }\n \n "}, {"sha": "5548449141bfef283ae97c851599f16ea15ebc4d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -46,7 +46,7 @@ Boston, MA 02110-1301, USA.  */\n    re-distribute it when the conditional expands into multiple conditionals.\n    This is however difficult to do.  */\n static void\n-add_reg_br_prob_note (FILE *dump_file, rtx last, int probability)\n+add_reg_br_prob_note (rtx last, int probability)\n {\n   if (profile_status == PROFILE_ABSENT)\n     return;\n@@ -1113,7 +1113,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   if (TREE_CODE (then_exp) == GOTO_EXPR && IS_EMPTY_STMT (else_exp))\n     {\n       jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n-      add_reg_br_prob_note (dump_file, last, true_edge->probability);\n+      add_reg_br_prob_note (last, true_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n       if (EXPR_LOCUS (then_exp))\n \temit_line_note (*(EXPR_LOCUS (then_exp)));\n@@ -1122,7 +1122,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   if (TREE_CODE (else_exp) == GOTO_EXPR && IS_EMPTY_STMT (then_exp))\n     {\n       jumpifnot (pred, label_rtx (GOTO_DESTINATION (else_exp)));\n-      add_reg_br_prob_note (dump_file, last, false_edge->probability);\n+      add_reg_br_prob_note (last, false_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n       if (EXPR_LOCUS (else_exp))\n \temit_line_note (*(EXPR_LOCUS (else_exp)));\n@@ -1132,7 +1132,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n \t      && TREE_CODE (else_exp) == GOTO_EXPR);\n \n   jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n-  add_reg_br_prob_note (dump_file, last, true_edge->probability);\n+  add_reg_br_prob_note (last, true_edge->probability);\n   last = get_last_insn ();\n   expand_expr (else_exp, const0_rtx, VOIDmode, 0);\n \n@@ -1272,7 +1272,7 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n /* Expand basic block BB from GIMPLE trees to RTL.  */\n \n static basic_block\n-expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n+expand_gimple_basic_block (basic_block bb)\n {\n   block_stmt_iterator bsi = bsi_start (bb);\n   tree stmt = NULL;\n@@ -1621,7 +1621,7 @@ tree_expand_cfg (void)\n   init_block = construct_init_block ();\n \n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n-    bb = expand_gimple_basic_block (bb, dump_file);\n+    bb = expand_gimple_basic_block (bb);\n \n   construct_exit_block ();\n "}, {"sha": "2843d79ed3dd759a423518b0062f53e3a2e2f1df", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -437,8 +437,8 @@ extern unsigned global_cost_for_size (unsigned, unsigned, unsigned);\n extern void init_set_costs (void);\n \n /* Loop optimizer initialization.  */\n-extern struct loops *loop_optimizer_init (FILE *, unsigned);\n-extern void loop_optimizer_finalize (struct loops *, FILE *);\n+extern struct loops *loop_optimizer_init (unsigned);\n+extern void loop_optimizer_finalize (struct loops *);\n \n /* Optimization passes.  */\n extern void unswitch_loops (struct loops *);"}, {"sha": "edcadad46c0d65d09144a24dbebe36200b4b5f41", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -7796,7 +7796,7 @@ ia64_reorg (void)\n \t  _1mfb_ = get_cpu_unit_code (\"1b_1mfb.\");\n \t  _1mlx_ = get_cpu_unit_code (\"1b_1mlx.\");\n \t}\n-      schedule_ebbs (dump_file);\n+      schedule_ebbs ();\n       finish_bundle_states ();\n       if (ia64_tune == PROCESSOR_ITANIUM)\n \t{"}, {"sha": "1b7069d4a169d8a73cb4f2f553da66b8091af01e", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -5062,7 +5062,7 @@ m68hc11_reorg (void)\n             }\n         }\n \n-      life_analysis (0, PROP_REG_INFO | PROP_DEATH_NOTES);\n+      life_analysis (PROP_REG_INFO | PROP_DEATH_NOTES);\n     }\n \n   z_replacement_completed = 2;"}, {"sha": "82db1ac4bb5becacf2099cc2b1ddc85b5cc684ce", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -8922,7 +8922,7 @@ mips_reorg (void)\n   else if (TARGET_EXPLICIT_RELOCS)\n     {\n       if (mips_flag_delayed_branch)\n-\tdbr_schedule (get_insns (), dump_file);\n+\tdbr_schedule (get_insns ());\n       mips_avoid_hazards ();\n       if (TUNE_MIPS4130 && TARGET_VR4130_ALIGN)\n \tvr4130_align_insns ();"}, {"sha": "59529acfb0e4aea7ffc9a79e3940a0435e00862e", "filename": "gcc/config/mt/mt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fmt%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fmt%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2452,7 +2452,7 @@ mt_machine_reorg (void)\n     mt_reorg_loops (dump_file);\n \n   if (mt_flag_delayed_branch)\n-    dbr_schedule (get_insns (), dump_file);\n+    dbr_schedule (get_insns ());\n   \n   if (TARGET_MS2)\n     {"}, {"sha": "056b32b2c426b04fc3e66e1644d72fe289665030", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -9820,11 +9820,11 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n       if (flag_schedule_insns_after_reload)\n \t{\n-\t  life_analysis (dump_file, PROP_FINAL);\n+\t  life_analysis (PROP_FINAL);\n \n \t  split_all_insns (1);\n \n-\t  schedule_insns (dump_file);\n+\t  schedule_insns ();\n \t}\n       /* We must split jmp insn in PIC case.  */\n       else if (flag_pic)\n@@ -9834,7 +9834,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   sh_reorg ();\n \n   if (optimize > 0 && flag_delayed_branch)\n-    dbr_schedule (insns, dump_file);\n+    dbr_schedule (insns);\n \n   shorten_branches (insns);\n   final_start_function (insns, file, 1);"}, {"sha": "0f902ba4735c3f288fd83bc74aeee99a3a4ff4e9", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -6803,7 +6803,7 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n    in conditional jump instructions.  */\n \n int\n-cse_main (rtx f, int nregs, FILE *file)\n+cse_main (rtx f, int nregs)\n {\n   struct cse_basic_block_data val;\n   rtx insn = f;\n@@ -6869,8 +6869,8 @@ cse_main (rtx f, int nregs, FILE *file)\n       cse_basic_block_end = val.high_cuid;\n       max_qty = val.nsets * 2;\n \n-      if (file)\n-\tfprintf (file, \";; Processing block from %d to %d, %d sets.\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Processing block from %d to %d, %d sets.\\n\",\n \t\t INSN_UID (insn), val.last ? INSN_UID (val.last) : 0,\n \t\t val.nsets);\n \n@@ -7848,7 +7848,7 @@ rest_of_handle_cse (void)\n \n   reg_scan (get_insns (), max_reg_num ());\n \n-  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n+  tem = cse_main (get_insns (), max_reg_num ());\n   if (tem)\n     rebuild_jump_labels (get_insns ());\n   if (purge_all_dead_edges ())\n@@ -7901,7 +7901,7 @@ rest_of_handle_cse2 (void)\n   if (dump_file)\n     dump_flow_info (dump_file);\n \n-  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n+  tem = cse_main (get_insns (), max_reg_num ());\n \n   /* Run a pass to eliminate duplicated assignments to condition code\n      registers.  We have to run this after bypass_jumps, because it"}, {"sha": "83dbb2181aff8017bfeb0fae703a4f4c62425569", "filename": "gcc/ddg.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -546,7 +546,7 @@ free_ddg (ddg_ptr g)\n }\n \n void\n-print_ddg_edge (FILE *dump_file, ddg_edge_ptr e)\n+print_ddg_edge (FILE *file, ddg_edge_ptr e)\n {\n   char dep_c;\n \n@@ -561,65 +561,65 @@ print_ddg_edge (FILE *dump_file, ddg_edge_ptr e)\n       dep_c = 'T';\n   }\n \n-  fprintf (dump_file, \" [%d -(%c,%d,%d)-> %d] \", INSN_UID (e->src->insn),\n+  fprintf (file, \" [%d -(%c,%d,%d)-> %d] \", INSN_UID (e->src->insn),\n \t   dep_c, e->latency, e->distance, INSN_UID (e->dest->insn));\n }\n \n /* Print the DDG nodes with there in/out edges to the dump file.  */\n void\n-print_ddg (FILE *dump_file, ddg_ptr g)\n+print_ddg (FILE *file, ddg_ptr g)\n {\n   int i;\n \n   for (i = 0; i < g->num_nodes; i++)\n     {\n       ddg_edge_ptr e;\n \n-      print_rtl_single (dump_file, g->nodes[i].insn);\n-      fprintf (dump_file, \"OUT ARCS: \");\n+      print_rtl_single (file, g->nodes[i].insn);\n+      fprintf (file, \"OUT ARCS: \");\n       for (e = g->nodes[i].out; e; e = e->next_out)\n-\tprint_ddg_edge (dump_file, e);\n+\tprint_ddg_edge (file, e);\n \n-      fprintf (dump_file, \"\\nIN ARCS: \");\n+      fprintf (file, \"\\nIN ARCS: \");\n       for (e = g->nodes[i].in; e; e = e->next_in)\n-\tprint_ddg_edge (dump_file, e);\n+\tprint_ddg_edge (file, e);\n \n-      fprintf (dump_file, \"\\n\");\n+      fprintf (file, \"\\n\");\n     }\n }\n \n /* Print the given DDG in VCG format.  */\n void\n-vcg_print_ddg (FILE *dump_file, ddg_ptr g)\n+vcg_print_ddg (FILE *file, ddg_ptr g)\n {\n   int src_cuid;\n \n-  fprintf (dump_file, \"graph: {\\n\");\n+  fprintf (file, \"graph: {\\n\");\n   for (src_cuid = 0; src_cuid < g->num_nodes; src_cuid++)\n     {\n       ddg_edge_ptr e;\n       int src_uid = INSN_UID (g->nodes[src_cuid].insn);\n \n-      fprintf (dump_file, \"node: {title: \\\"%d_%d\\\" info1: \\\"\", src_cuid, src_uid);\n-      print_rtl_single (dump_file, g->nodes[src_cuid].insn);\n-      fprintf (dump_file, \"\\\"}\\n\");\n+      fprintf (file, \"node: {title: \\\"%d_%d\\\" info1: \\\"\", src_cuid, src_uid);\n+      print_rtl_single (file, g->nodes[src_cuid].insn);\n+      fprintf (file, \"\\\"}\\n\");\n       for (e = g->nodes[src_cuid].out; e; e = e->next_out)\n \t{\n \t  int dst_uid = INSN_UID (e->dest->insn);\n \t  int dst_cuid = e->dest->cuid;\n \n \t  /* Give the backarcs a different color.  */\n \t  if (e->distance > 0)\n-\t    fprintf (dump_file, \"backedge: {color: red \");\n+\t    fprintf (file, \"backedge: {color: red \");\n \t  else\n-\t    fprintf (dump_file, \"edge: { \");\n+\t    fprintf (file, \"edge: { \");\n \n-\t  fprintf (dump_file, \"sourcename: \\\"%d_%d\\\" \", src_cuid, src_uid);\n-\t  fprintf (dump_file, \"targetname: \\\"%d_%d\\\" \", dst_cuid, dst_uid);\n-\t  fprintf (dump_file, \"label: \\\"%d_%d\\\"}\\n\", e->latency, e->distance);\n+\t  fprintf (file, \"sourcename: \\\"%d_%d\\\" \", src_cuid, src_uid);\n+\t  fprintf (file, \"targetname: \\\"%d_%d\\\" \", dst_cuid, dst_uid);\n+\t  fprintf (file, \"label: \\\"%d_%d\\\"}\\n\", e->latency, e->distance);\n \t}\n     }\n-  fprintf (dump_file, \"}\\n\");\n+  fprintf (file, \"}\\n\");\n }\n \n /* Create an edge and initialize it with given values.  */"}, {"sha": "62a10807d1469b86cfae6b4747be8d509bb53d6e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2811,7 +2811,7 @@ get_max_uid (void)\n /* Renumber instructions so that no instruction UIDs are wasted.  */\n \n void\n-renumber_insns (FILE *stream)\n+renumber_insns (void)\n {\n   rtx insn;\n \n@@ -2828,8 +2828,8 @@ renumber_insns (FILE *stream)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (stream)\n-\tfprintf (stream, \"Renumbering insn %d to %d\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Renumbering insn %d to %d\\n\",\n \t\t INSN_UID (insn), cur_insn_uid);\n       INSN_UID (insn) = cur_insn_uid++;\n     }"}, {"sha": "ad4ab7c4d079564e93ff9399aea5b40c06f487ff", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -354,7 +354,7 @@ first_insn_after_basic_block_note (basic_block block)\n    FLAGS is a set of PROP_* flags to be used in accumulating flow info.  */\n \n void\n-life_analysis (FILE *file, int flags)\n+life_analysis (int flags)\n {\n #ifdef ELIMINABLE_REGS\n   int i;\n@@ -437,8 +437,8 @@ life_analysis (FILE *file, int flags)\n   if (optimize && (flags & PROP_SCAN_DEAD_STORES))\n     end_alias_analysis ();\n \n-  if (file)\n-    dump_flow_info (file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   /* Removing dead insns should have made jumptables really dead.  */\n   delete_dead_jumptables ();\n@@ -4637,7 +4637,7 @@ rest_of_handle_life (void)\n {\n   regclass_init ();\n \n-  life_analysis (dump_file, PROP_FINAL);\n+  life_analysis (PROP_FINAL);\n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE | CLEANUP_LOG_LINKS\n                  | (flag_thread_jumps ? CLEANUP_THREADING : 0));"}, {"sha": "c763678c0116afedfcc987fa8db6d1e1955a33ac", "filename": "gcc/gcse.c", "status": "modified", "additions": 124, "deletions": 142, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -271,9 +271,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \f\n /* GCSE global vars.  */\n \n-/* -dG dump file.  */\n-static FILE *gcse_file;\n-\n /* Note whether or not we should run jump optimization after gcse.  We\n    want to do this for two cases.\n \n@@ -282,13 +279,6 @@ static FILE *gcse_file;\n     * If we added any labels via edge splitting.  */\n static int run_jump_opt_after_gcse;\n \n-/* Bitmaps are normally not included in debugging dumps.\n-   However it's useful to be able to print them from GDB.\n-   We could create special functions for this, but it's simpler to\n-   just allow passing stderr to the dump_foo fns.  Since stderr can\n-   be a macro, we store a copy here.  */\n-static FILE *debug_stderr;\n-\n /* An obstack for our working variables.  */\n static struct obstack gcse_obstack;\n \n@@ -661,7 +651,7 @@ static bool is_too_expensive (const char *);\n    change is mode.  */\n \n static int\n-gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n+gcse_main (rtx f ATTRIBUTE_UNUSED)\n {\n   int changed, pass;\n   /* Bytes used at start of pass.  */\n@@ -679,16 +669,12 @@ gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n   /* Assume that we do not need to run jump optimizations after gcse.  */\n   run_jump_opt_after_gcse = 0;\n \n-  /* For calling dump_foo fns from gdb.  */\n-  debug_stderr = stderr;\n-  gcse_file = file;\n-\n   /* Identify the basic block information for this function, including\n      successors and predecessors.  */\n   max_gcse_regno = max_reg_num ();\n \n-  if (file)\n-    dump_flow_info (file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n@@ -720,8 +706,8 @@ gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n   while (changed && pass < MAX_GCSE_PASSES)\n     {\n       changed = 0;\n-      if (file)\n-\tfprintf (file, \"GCSE pass %d\\n\\n\", pass + 1);\n+      if (dump_file)\n+\tfprintf (dump_file, \"GCSE pass %d\\n\\n\", pass + 1);\n \n       /* Initialize bytes_used to the space for the pred/succ lists,\n \t and the reg_set_table data.  */\n@@ -786,10 +772,10 @@ gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n \t  timevar_pop (TV_HOIST);\n \t}\n \n-      if (file)\n+      if (dump_file)\n \t{\n-\t  fprintf (file, \"\\n\");\n-\t  fflush (file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t  fflush (dump_file);\n \t}\n \n       obstack_free (&gcse_obstack, gcse_obstack_bottom);\n@@ -807,11 +793,11 @@ gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n   timevar_pop (TV_CPROP2);\n   free_gcse_mem ();\n \n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"GCSE of %s: %d basic blocks, \",\n+      fprintf (dump_file, \"GCSE of %s: %d basic blocks, \",\n \t       current_function_name (), n_basic_blocks);\n-      fprintf (file, \"%d pass%s, %d bytes\\n\\n\",\n+      fprintf (dump_file, \"%d pass%s, %d bytes\\n\\n\",\n \t       pass, pass > 1 ? \"es\" : \"\", max_pass_bytes);\n     }\n \n@@ -2861,13 +2847,13 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n   run_jump_opt_after_gcse = 1;\n \n   global_const_prop_count++;\n-  if (gcse_file != NULL)\n+  if (dump_file != NULL)\n     {\n-      fprintf (gcse_file,\n+      fprintf (dump_file,\n \t       \"GLOBAL CONST-PROP: Replacing reg %d in jump_insn %d with constant \",\n \t       REGNO (from), INSN_UID (jump));\n-      print_rtl (gcse_file, src);\n-      fprintf (gcse_file, \"\\n\");\n+      print_rtl (dump_file, src);\n+      fprintf (dump_file, \"\\n\");\n     }\n   purge_dead_edges (bb);\n \n@@ -2966,12 +2952,12 @@ cprop_insn (rtx insn, int alter_jumps)\n \t    {\n \t      changed = 1;\n \t      global_const_prop_count++;\n-\t      if (gcse_file != NULL)\n+\t      if (dump_file != NULL)\n \t\t{\n-\t\t  fprintf (gcse_file, \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n-\t\t  fprintf (gcse_file, \"insn %d with constant \", INSN_UID (insn));\n-\t\t  print_rtl (gcse_file, src);\n-\t\t  fprintf (gcse_file, \"\\n\");\n+\t\t  fprintf (dump_file, \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n+\t\t  fprintf (dump_file, \"insn %d with constant \", INSN_UID (insn));\n+\t\t  print_rtl (dump_file, src);\n+\t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t      if (INSN_DELETED_P (insn))\n \t\treturn 1;\n@@ -2985,11 +2971,11 @@ cprop_insn (rtx insn, int alter_jumps)\n \t    {\n \t      changed = 1;\n \t      global_copy_prop_count++;\n-\t      if (gcse_file != NULL)\n+\t      if (dump_file != NULL)\n \t\t{\n-\t\t  fprintf (gcse_file, \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n+\t\t  fprintf (dump_file, \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n \t\t\t   regno, INSN_UID (insn));\n-\t\t  fprintf (gcse_file, \" with reg %d\\n\", REGNO (src));\n+\t\t  fprintf (dump_file, \" with reg %d\\n\", REGNO (src));\n \t\t}\n \n \t      /* The original insn setting reg_used may or may not now be\n@@ -3102,27 +3088,27 @@ do_local_cprop (rtx x, rtx insn, bool alter_jumps, rtx *libcall_sp)\n \t  adjusted = adjust_libcall_notes (x, newcnst, insn, libcall_sp);\n \t  gcc_assert (adjusted);\n \t  \n-\t  if (gcse_file != NULL)\n+\t  if (dump_file != NULL)\n \t    {\n-\t      fprintf (gcse_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n+\t      fprintf (dump_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n \t\t       REGNO (x));\n-\t      fprintf (gcse_file, \"insn %d with constant \",\n+\t      fprintf (dump_file, \"insn %d with constant \",\n \t\t       INSN_UID (insn));\n-\t      print_rtl (gcse_file, newcnst);\n-\t      fprintf (gcse_file, \"\\n\");\n+\t      print_rtl (dump_file, newcnst);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  local_const_prop_count++;\n \t  return true;\n \t}\n       else if (newreg && newreg != x && try_replace_reg (x, newreg, insn))\n \t{\n \t  adjust_libcall_notes (x, newreg, insn, libcall_sp);\n-\t  if (gcse_file != NULL)\n+\t  if (dump_file != NULL)\n \t    {\n-\t      fprintf (gcse_file,\n+\t      fprintf (dump_file,\n \t\t       \"LOCAL COPY-PROP: Replacing reg %d in insn %d\",\n \t\t       REGNO (x), INSN_UID (insn));\n-\t      fprintf (gcse_file, \" with reg %d\\n\", REGNO (newreg));\n+\t      fprintf (dump_file, \" with reg %d\\n\", REGNO (newreg));\n \t    }\n \t  local_copy_prop_count++;\n \t  return true;\n@@ -3259,8 +3245,8 @@ cprop (int alter_jumps)\n   /* Note we start at block 1.  */\n   if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n     {\n-      if (gcse_file != NULL)\n-\tfprintf (gcse_file, \"\\n\");\n+      if (dump_file != NULL)\n+\tfprintf (dump_file, \"\\n\");\n       return 0;\n     }\n \n@@ -3284,8 +3270,8 @@ cprop (int alter_jumps)\n \t  }\n     }\n \n-  if (gcse_file != NULL)\n-    fprintf (gcse_file, \"\\n\");\n+  if (dump_file != NULL)\n+    fprintf (dump_file, \"\\n\");\n \n   return changed;\n }\n@@ -3374,19 +3360,19 @@ find_implicit_sets (void)\n \t\tnew = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n \t\t\t\t\t     XEXP (cond, 1));\n \t\timplicit_sets[dest->index] = new;\n-\t\tif (gcse_file)\n+\t\tif (dump_file)\n \t\t  {\n-\t\t    fprintf(gcse_file, \"Implicit set of reg %d in \",\n+\t\t    fprintf(dump_file, \"Implicit set of reg %d in \",\n \t\t\t    REGNO (XEXP (cond, 0)));\n-\t\t    fprintf(gcse_file, \"basic block %d\\n\", dest->index);\n+\t\t    fprintf(dump_file, \"basic block %d\\n\", dest->index);\n \t\t  }\n \t\tcount++;\n \t      }\n \t  }\n       }\n \n-  if (gcse_file)\n-    fprintf (gcse_file, \"Found %d implicit sets\\n\", count);\n+  if (dump_file)\n+    fprintf (dump_file, \"Found %d implicit sets\\n\", count);\n }\n \n /* Perform one copy/constant propagation pass.\n@@ -3415,8 +3401,8 @@ one_cprop_pass (int pass, bool cprop_jumps, bool bypass_jumps)\n   free (implicit_sets);\n   implicit_sets = NULL;\n \n-  if (gcse_file)\n-    dump_hash_table (gcse_file, \"SET\", &set_hash_table);\n+  if (dump_file)\n+    dump_hash_table (dump_file, \"SET\", &set_hash_table);\n   if (set_hash_table.n_elems > 0)\n     {\n       alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n@@ -3429,13 +3415,13 @@ one_cprop_pass (int pass, bool cprop_jumps, bool bypass_jumps)\n \n   free_hash_table (&set_hash_table);\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"CPROP of %s, pass %d: %d bytes needed, \",\n+      fprintf (dump_file, \"CPROP of %s, pass %d: %d bytes needed, \",\n \t       current_function_name (), pass, bytes_used);\n-      fprintf (gcse_file, \"%d local const props, %d local copy props, \",\n+      fprintf (dump_file, \"%d local const props, %d local copy props, \",\n \t       local_const_prop_count, local_copy_prop_count);\n-      fprintf (gcse_file, \"%d global const props, %d global copy props\\n\\n\",\n+      fprintf (dump_file, \"%d global const props, %d global copy props\\n\\n\",\n \t       global_const_prop_count, global_copy_prop_count);\n     }\n   /* Global analysis may get into infinite loops for unreachable blocks.  */\n@@ -3651,13 +3637,13 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t\t    insert_insn_on_edge (copy_insn (pat), e);\n \t\t}\n \n-\t      if (gcse_file != NULL)\n+\t      if (dump_file != NULL)\n \t\t{\n-\t\t  fprintf (gcse_file, \"JUMP-BYPASS: Proved reg %d \"\n+\t\t  fprintf (dump_file, \"JUMP-BYPASS: Proved reg %d \"\n \t\t\t\t      \"in jump_insn %d equals constant \",\n \t\t\t   regno, INSN_UID (jump));\n-\t\t  print_rtl (gcse_file, SET_SRC (set->expr));\n-\t\t  fprintf (gcse_file, \"\\nBypass edge from %d->%d to %d\\n\",\n+\t\t  print_rtl (dump_file, SET_SRC (set->expr));\n+\t\t  fprintf (dump_file, \"\\nBypass edge from %d->%d to %d\\n\",\n \t\t\t   e->src->index, old_dest->index, dest->index);\n \t\t}\n \t      change = 1;\n@@ -3862,7 +3848,7 @@ compute_pre_data (void)\n       sbitmap_not (ae_kill[bb->index], ae_kill[bb->index]);\n     }\n \n-  edge_list = pre_edge_lcm (gcse_file, expr_hash_table.n_elems, transp, comp, antloc,\n+  edge_list = pre_edge_lcm (expr_hash_table.n_elems, transp, comp, antloc,\n \t\t\t    ae_kill, &pre_insert_map, &pre_delete_map);\n   sbitmap_vector_free (antloc);\n   antloc = NULL;\n@@ -4105,11 +4091,11 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n \n   gcse_create_count++;\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"PRE/HOIST: end of bb %d, insn %d, \",\n+      fprintf (dump_file, \"PRE/HOIST: end of bb %d, insn %d, \",\n \t       bb->index, INSN_UID (new_insn));\n-      fprintf (gcse_file, \"copying expression %d to reg %d\\n\",\n+      fprintf (dump_file, \"copying expression %d to reg %d\\n\",\n \t       expr->bitmap_index, regno);\n     }\n }\n@@ -4174,12 +4160,12 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \t\t\t    insert_insn_on_edge (insn, eg);\n \t\t\t  }\n \n-\t\t\tif (gcse_file)\n+\t\t\tif (dump_file)\n \t\t\t  {\n-\t\t\t    fprintf (gcse_file, \"PRE/HOIST: edge (%d,%d), \",\n+\t\t\t    fprintf (dump_file, \"PRE/HOIST: edge (%d,%d), \",\n \t\t\t\t     bb->index,\n \t\t\t\t     INDEX_EDGE_SUCC_BB (edge_list, e)->index);\n-\t\t\t    fprintf (gcse_file, \"copy expression %d\\n\",\n+\t\t\t    fprintf (dump_file, \"copy expression %d\\n\",\n \t\t\t\t     expr->bitmap_index);\n \t\t\t  }\n \n@@ -4300,8 +4286,8 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n \n   gcse_create_count++;\n \n-  if (gcse_file)\n-    fprintf (gcse_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"PRE: bb %d, insn %d, copy expression %d in insn %d to reg %d\\n\",\n \t      BLOCK_NUM (insn), INSN_UID (new_insn), indx,\n \t      INSN_UID (insn), regno);\n@@ -4453,12 +4439,12 @@ pre_delete (void)\n \t\tchanged = 1;\n \t\tgcse_subst_count++;\n \n-\t\tif (gcse_file)\n+\t\tif (dump_file)\n \t\t  {\n-\t\t    fprintf (gcse_file,\n+\t\t    fprintf (dump_file,\n \t\t\t     \"PRE: redundant insn %d (expression %d) in \",\n \t\t\t       INSN_UID (insn), indx);\n-\t\t    fprintf (gcse_file, \"bb %d, reaching reg is %d\\n\",\n+\t\t    fprintf (dump_file, \"bb %d, reaching reg is %d\\n\",\n \t\t\t     bb->index, REGNO (expr->reaching_reg));\n \t\t  }\n \t      }\n@@ -4550,8 +4536,8 @@ one_pre_gcse_pass (int pass)\n \n   compute_hash_table (&expr_hash_table);\n   trim_ld_motion_mems ();\n-  if (gcse_file)\n-    dump_hash_table (gcse_file, \"Expression\", &expr_hash_table);\n+  if (dump_file)\n+    dump_hash_table (dump_file, \"Expression\", &expr_hash_table);\n \n   if (expr_hash_table.n_elems > 0)\n     {\n@@ -4566,11 +4552,11 @@ one_pre_gcse_pass (int pass)\n   remove_fake_exit_edges ();\n   free_hash_table (&expr_hash_table);\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"\\nPRE GCSE of %s, pass %d: %d bytes needed, \",\n+      fprintf (dump_file, \"\\nPRE GCSE of %s, pass %d: %d bytes needed, \",\n \t       current_function_name (), pass, bytes_used);\n-      fprintf (gcse_file, \"%d substs, %d insns created\\n\",\n+      fprintf (dump_file, \"%d substs, %d insns created\\n\",\n \t       gcse_subst_count, gcse_create_count);\n     }\n \n@@ -4749,8 +4735,8 @@ compute_code_hoist_vbeinout (void)\n       passes++;\n     }\n \n-  if (gcse_file)\n-    fprintf (gcse_file, \"hoisting vbeinout computation: %d passes\\n\", passes);\n+  if (dump_file)\n+    fprintf (dump_file, \"hoisting vbeinout computation: %d passes\\n\", passes);\n }\n \n /* Top level routine to do the dataflow analysis needed by code hoisting.  */\n@@ -4762,8 +4748,8 @@ compute_code_hoist_data (void)\n   compute_transpout ();\n   compute_code_hoist_vbeinout ();\n   calculate_dominance_info (CDI_DOMINATORS);\n-  if (gcse_file)\n-    fprintf (gcse_file, \"\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n }\n \n /* Determine if the expression identified by EXPR_INDEX would\n@@ -4995,8 +4981,8 @@ one_code_hoisting_pass (void)\n \n   alloc_hash_table (max_cuid, &expr_hash_table, 0);\n   compute_hash_table (&expr_hash_table);\n-  if (gcse_file)\n-    dump_hash_table (gcse_file, \"Code Hosting Expressions\", &expr_hash_table);\n+  if (dump_file)\n+    dump_hash_table (dump_file, \"Code Hosting Expressions\", &expr_hash_table);\n \n   if (expr_hash_table.n_elems > 0)\n     {\n@@ -5389,8 +5375,8 @@ trim_ld_motion_mems (void)\n     }\n \n   /* Show the world what we've found.  */\n-  if (gcse_file && pre_ldst_mems != NULL)\n-    print_ldst_list (gcse_file);\n+  if (dump_file && pre_ldst_mems != NULL)\n+    print_ldst_list (dump_file);\n }\n \n /* This routine will take an expression which we are replacing with\n@@ -5429,13 +5415,13 @@ update_ld_motion_stores (struct expr * expr)\n \t  if (expr->reaching_reg == src)\n \t    continue;\n \n-\t  if (gcse_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (gcse_file, \"PRE:  store updated with reaching reg \");\n-\t      print_rtl (gcse_file, expr->reaching_reg);\n-\t      fprintf (gcse_file, \":\\n\t\");\n-\t      print_inline_rtx (gcse_file, insn, 8);\n-\t      fprintf (gcse_file, \"\\n\");\n+\t      fprintf (dump_file, \"PRE:  store updated with reaching reg \");\n+\t      print_rtl (dump_file, expr->reaching_reg);\n+\t      fprintf (dump_file, \":\\n\t\");\n+\t      print_inline_rtx (dump_file, insn, 8);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \n \t  copy = gen_move_insn ( reg, copy_rtx (SET_SRC (pat)));\n@@ -5848,10 +5834,10 @@ compute_store_table (void)\n \n   ret = enumerate_ldsts ();\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"ST_avail and ST_antic (shown under loads..)\\n\");\n-      print_ldst_list (gcse_file);\n+      fprintf (dump_file, \"ST_avail and ST_antic (shown under loads..)\\n\");\n+      print_ldst_list (dump_file);\n     }\n \n   free (last_set_in);\n@@ -6073,8 +6059,8 @@ build_store_vectors (void)\n \t  if (TEST_BIT (ae_gen[bb->index], ptr->index))\n \t    {\n \t      rtx r = gen_reg_rtx (GET_MODE (ptr->pattern));\n-\t      if (gcse_file)\n-\t\tfprintf (gcse_file, \"Removing redundant store:\\n\");\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Removing redundant store:\\n\");\n \t      replace_store_insn (r, XEXP (st, 0), bb, ptr);\n \t      continue;\n \t    }\n@@ -6119,12 +6105,12 @@ build_store_vectors (void)\n \n   free (regs_set_in_block);\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (gcse_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n-      dump_sbitmap_vector (gcse_file, \"st_kill\", \"\", ae_kill, last_basic_block);\n-      dump_sbitmap_vector (gcse_file, \"Transpt\", \"\", transp, last_basic_block);\n-      dump_sbitmap_vector (gcse_file, \"st_avloc\", \"\", ae_gen, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_kill\", \"\", ae_kill, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"Transpt\", \"\", transp, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_avloc\", \"\", ae_gen, last_basic_block);\n     }\n }\n \n@@ -6151,12 +6137,12 @@ insert_insn_start_bb (rtx insn, basic_block bb)\n \n   insn = emit_insn_after_noloc (insn, prev);\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"STORE_MOTION  insert store at start of BB %d:\\n\",\n+      fprintf (dump_file, \"STORE_MOTION  insert store at start of BB %d:\\n\",\n \t       bb->index);\n-      print_inline_rtx (gcse_file, insn, 6);\n-      fprintf (gcse_file, \"\\n\");\n+      print_inline_rtx (dump_file, insn, 6);\n+      fprintf (dump_file, \"\\n\");\n     }\n }\n \n@@ -6216,12 +6202,12 @@ insert_store (struct ls_expr * expr, edge e)\n \n   insert_insn_on_edge (insn, e);\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"STORE_MOTION  insert insn on edge (%d, %d):\\n\",\n+      fprintf (dump_file, \"STORE_MOTION  insert insn on edge (%d, %d):\\n\",\n \t       e->src->index, e->dest->index);\n-      print_inline_rtx (gcse_file, insn, 6);\n-      fprintf (gcse_file, \"\\n\");\n+      print_inline_rtx (dump_file, insn, 6);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   return 1;\n@@ -6291,8 +6277,8 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n \t    if (!note || !expr_equiv_p (XEXP (note, 0), mem))\n \t      continue;\n \n-\t    if (gcse_file)\n-\t      fprintf (gcse_file, \"STORE_MOTION  drop REG_EQUAL note at insn %d:\\n\",\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"STORE_MOTION  drop REG_EQUAL note at insn %d:\\n\",\n \t\t       INSN_UID (insn));\n \t    remove_note (insn, note);\n \t  }\n@@ -6322,14 +6308,14 @@ replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n   insn = gen_move_insn (reg, SET_SRC (single_set (del)));\n   insn = emit_insn_after (insn, del);\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file,\n+      fprintf (dump_file,\n \t       \"STORE_MOTION  delete insn in BB %d:\\n      \", bb->index);\n-      print_inline_rtx (gcse_file, del, 6);\n-      fprintf (gcse_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n-      print_inline_rtx (gcse_file, insn, 6);\n-      fprintf (gcse_file, \"\\n\");\n+      print_inline_rtx (dump_file, del, 6);\n+      fprintf (dump_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n+      print_inline_rtx (dump_file, insn, 6);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n   for (ptr = ANTIC_STORE_LIST (smexpr); ptr; ptr = XEXP (ptr, 1))\n@@ -6375,8 +6361,8 @@ replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n \tif (!note || !expr_equiv_p (XEXP (note, 0), mem))\n \t  continue;\n \n-\tif (gcse_file)\n-\t  fprintf (gcse_file, \"STORE_MOTION  drop REG_EQUAL note at insn %d:\\n\",\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"STORE_MOTION  drop REG_EQUAL note at insn %d:\\n\",\n \t\t   INSN_UID (insn));\n \tremove_note (insn, note);\n       }\n@@ -6447,10 +6433,10 @@ store_motion (void)\n   struct ls_expr * ptr;\n   int update_flow = 0;\n \n-  if (gcse_file)\n+  if (dump_file)\n     {\n-      fprintf (gcse_file, \"before store motion\\n\");\n-      print_rtl (gcse_file, get_insns ());\n+      fprintf (dump_file, \"before store motion\\n\");\n+      print_rtl (dump_file, get_insns ());\n     }\n \n   init_alias_analysis ();\n@@ -6471,7 +6457,7 @@ store_motion (void)\n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n \n-  edge_list = pre_edge_rev_lcm (gcse_file, num_stores, transp, ae_gen,\n+  edge_list = pre_edge_rev_lcm (num_stores, transp, ae_gen,\n \t\t\t\tst_antloc, ae_kill, &pre_insert_map,\n \t\t\t\t&pre_delete_map);\n \n@@ -6487,8 +6473,8 @@ store_motion (void)\n \n       if (x >= 0)\n \t{\n-\t  if (gcse_file != NULL)\n-\t    fprintf (gcse_file,\n+\t  if (dump_file != NULL)\n+\t    fprintf (dump_file,\n \t\t     \"Can't replace store %d: abnormal edge from %d to %d\\n\",\n \t\t     ptr->index, INDEX_EDGE (edge_list, x)->src->index,\n \t\t     INDEX_EDGE (edge_list, x)->dest->index);\n@@ -6519,7 +6505,7 @@ store_motion (void)\n /* Entry point for jump bypassing optimization pass.  */\n \n static int\n-bypass_jumps (FILE *file)\n+bypass_jumps (void)\n {\n   int changed;\n \n@@ -6528,16 +6514,12 @@ bypass_jumps (FILE *file)\n   if (current_function_calls_setjmp)\n     return 0;\n \n-  /* For calling dump_foo fns from gdb.  */\n-  debug_stderr = stderr;\n-  gcse_file = file;\n-\n   /* Identify the basic block information for this function, including\n      successors and predecessors.  */\n   max_gcse_regno = max_reg_num ();\n \n-  if (file)\n-    dump_flow_info (file);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n@@ -6567,11 +6549,11 @@ bypass_jumps (FILE *file)\n   changed = one_cprop_pass (MAX_GCSE_PASSES + 2, true, true);\n   free_gcse_mem ();\n \n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"BYPASS of %s: %d basic blocks, \",\n+      fprintf (dump_file, \"BYPASS of %s: %d basic blocks, \",\n \t       current_function_name (), n_basic_blocks);\n-      fprintf (file, \"%d bytes\\n\\n\", bytes_used);\n+      fprintf (dump_file, \"%d bytes\\n\\n\", bytes_used);\n     }\n \n   obstack_free (&gcse_obstack, NULL);\n@@ -6637,7 +6619,7 @@ rest_of_handle_jump_bypass (void)\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   reg_scan (get_insns (), max_reg_num ());\n \n-  if (bypass_jumps (dump_file))\n+  if (bypass_jumps ())\n     {\n       rebuild_jump_labels (get_insns ());\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n@@ -6677,7 +6659,7 @@ rest_of_handle_gcse (void)\n   int save_csb, save_cfj;\n   int tem2 = 0, tem;\n \n-  tem = gcse_main (get_insns (), dump_file);\n+  tem = gcse_main (get_insns ());\n   rebuild_jump_labels (get_insns ());\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n@@ -6691,7 +6673,7 @@ rest_of_handle_gcse (void)\n     {\n       timevar_push (TV_CSE);\n       reg_scan (get_insns (), max_reg_num ());\n-      tem2 = cse_main (get_insns (), max_reg_num (), dump_file);\n+      tem2 = cse_main (get_insns (), max_reg_num ());\n       purge_all_dead_edges ();\n       delete_trivially_dead_insns (get_insns (), max_reg_num ());\n       timevar_pop (TV_CSE);"}, {"sha": "4cead231eeced9f0ac271cb222983b516e5d19e1", "filename": "gcc/global.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -326,14 +326,12 @@ static void make_accurate_live_analysis (void);\n \f\n \n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n-   FILE is a file to output debugging information on,\n-   or zero if such output is not desired.\n \n    Return value is nonzero if reload failed\n    and we must not do any more for this function.  */\n \n static int\n-global_alloc (FILE *file)\n+global_alloc (void)\n {\n   int retval;\n #ifdef ELIMINABLE_REGS\n@@ -590,8 +588,8 @@ global_alloc (FILE *file)\n \n       prune_preferences ();\n \n-      if (file)\n-\tdump_conflicts (file);\n+      if (dump_file)\n+\tdump_conflicts (dump_file);\n \n       /* Try allocating them, one by one, in that order,\n \t except for parameters marked with reg_live_length[regno] == -2.  */\n@@ -2510,7 +2508,7 @@ rest_of_handle_global_alloc (void)\n      pass fixing up any insns that are invalid.  */\n \n   if (optimize)\n-    failure = global_alloc (dump_file);\n+    failure = global_alloc ();\n   else\n     {\n       build_insn_chain (get_insns ());"}, {"sha": "325573a66cb0bce20319764a261303d015c7c736", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -142,6 +142,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"recog.h\"\n #include \"sched-int.h\"\n #include \"target.h\"\n+#include \"output.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -501,7 +502,7 @@ struct sched_info *current_sched_info;\n \f\n #ifndef INSN_SCHEDULING\n void\n-schedule_insns (FILE *dump_file ATTRIBUTE_UNUSED)\n+schedule_insns (void)\n {\n }\n #else\n@@ -2210,11 +2211,10 @@ set_priorities (rtx head, rtx tail)\n   return n_insn;\n }\n \n-/* Initialize some global state for the scheduler.  DUMP_FILE is to be used\n-   for debugging output.  */\n+/* Initialize some global state for the scheduler.  */\n \n void\n-sched_init (FILE *dump_file)\n+sched_init (void)\n {\n   int luid;\n   basic_block b;"}, {"sha": "3f61d4ed70ac47baaa333a4b3e0e0a18869498ce", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -1773,9 +1773,6 @@ type_escape_execute (void)\n       result = splay_tree_successor (all_canon_types, (splay_tree_key) key);\n     }\n \n-/*   { */\n-/*     FILE * tmp = dump_file; */\n-/*     dump_file = stderr; */\n   if (dump_file)\n     { \n       EXECUTE_IF_SET_IN_BITMAP (global_types_seen, 0, i, bi)\n@@ -1792,8 +1789,6 @@ type_escape_execute (void)\n \t    fprintf(dump_file, \" contained\\n\");\n \t}\n     }\n-/*   dump_file = tmp; */\n-/*   } */\n \n   /* Get rid of uid_to_addressof_up_map and its bitmaps.  */\n   result = splay_tree_min (uid_to_addressof_up_map);"}, {"sha": "44b045654da0d892d2f10338d7778d84b585413e", "filename": "gcc/ipa.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -94,7 +94,7 @@ cgraph_postorder (struct cgraph_node **order)\n    removes unneeded bodies of extern inline functions.  */\n \n bool\n-cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *dump_file)\n+cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   struct cgraph_node *first = (void *) 1;\n   struct cgraph_node *node;\n@@ -104,8 +104,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *dump_file)\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif\n-  if (dump_file)\n-    fprintf (dump_file, \"\\nReclaiming functions:\");\n+  if (file)\n+    fprintf (file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n   for (node = cgraph_nodes; node; node = node->next)\n     gcc_assert (!node->aux);\n@@ -163,8 +163,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *dump_file)\n \t    local_insns = node->local.self_insns;\n \t  else\n \t    local_insns = 0;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" %s\", cgraph_node_name (node));\n+\t  if (file)\n+\t    fprintf (file, \" %s\", cgraph_node_name (node));\n \t  if (!node->analyzed || !DECL_EXTERNAL (node->decl)\n \t      || before_inlining_p)\n \t    cgraph_remove_node (node);\n@@ -203,7 +203,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *dump_file)\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n-  if (dump_file)\n-    fprintf (dump_file, \"\\nReclaimed %i insns\", insns);\n+  if (file)\n+    fprintf (file, \"\\nReclaimed %i insns\", insns);\n   return changed;\n }"}, {"sha": "2571b56ff540180855bdd70cee682dcfdef78e43", "filename": "gcc/lcm.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -376,7 +376,7 @@ compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n    map the insert vector to what edge an expression should be inserted on.  */\n \n struct edge_list *\n-pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n+pre_edge_lcm (int n_exprs, sbitmap *transp,\n \t      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,\n \t      sbitmap **insert, sbitmap **delete)\n {\n@@ -390,15 +390,15 @@ pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   num_edges = NUM_EDGES (edge_list);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"Edge List:\\n\");\n-      verify_edge_list (file, edge_list);\n-      print_edge_list (file, edge_list);\n-      dump_sbitmap_vector (file, \"transp\", \"\", transp, last_basic_block);\n-      dump_sbitmap_vector (file, \"antloc\", \"\", antloc, last_basic_block);\n-      dump_sbitmap_vector (file, \"avloc\", \"\", avloc, last_basic_block);\n-      dump_sbitmap_vector (file, \"kill\", \"\", kill, last_basic_block);\n+      fprintf (dump_file, \"Edge List:\\n\");\n+      verify_edge_list (dump_file, edge_list);\n+      print_edge_list (dump_file, edge_list);\n+      dump_sbitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"antloc\", \"\", antloc, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"avloc\", \"\", avloc, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"kill\", \"\", kill, last_basic_block);\n     }\n #endif\n \n@@ -414,10 +414,10 @@ pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   compute_antinout_edge (antloc, transp, antin, antout);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (file, \"antin\", \"\", antin, last_basic_block);\n-      dump_sbitmap_vector (file, \"antout\", \"\", antout, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"antin\", \"\", antin, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"antout\", \"\", antout, last_basic_block);\n     }\n #endif\n \n@@ -426,8 +426,8 @@ pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n-    dump_sbitmap_vector (file, \"earliest\", \"\", earliest, num_edges);\n+  if (dump_file)\n+    dump_sbitmap_vector (dump_file, \"earliest\", \"\", earliest, num_edges);\n #endif\n \n   sbitmap_vector_free (antout);\n@@ -441,10 +441,10 @@ pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   compute_laterin (edge_list, earliest, antloc, later, laterin);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (file, \"laterin\", \"\", laterin, last_basic_block + 1);\n-      dump_sbitmap_vector (file, \"later\", \"\", later, num_edges);\n+      dump_sbitmap_vector (dump_file, \"laterin\", \"\", laterin, last_basic_block + 1);\n+      dump_sbitmap_vector (dump_file, \"later\", \"\", later, num_edges);\n     }\n #endif\n \n@@ -458,10 +458,10 @@ pre_edge_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   sbitmap_vector_free (later);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete,\n+      dump_sbitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n+      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *delete,\n \t\t\t   last_basic_block);\n     }\n #endif\n@@ -710,7 +710,7 @@ compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n    an expression should be inserted on.  */\n \n struct edge_list *\n-pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n+pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n \t\t  sbitmap *st_avloc, sbitmap *st_antloc, sbitmap *kill,\n \t\t  sbitmap **insert, sbitmap **delete)\n {\n@@ -735,25 +735,25 @@ pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   compute_available (st_avloc, kill, st_avout, st_avin);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"Edge List:\\n\");\n-      verify_edge_list (file, edge_list);\n-      print_edge_list (file, edge_list);\n-      dump_sbitmap_vector (file, \"transp\", \"\", transp, last_basic_block);\n-      dump_sbitmap_vector (file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n-      dump_sbitmap_vector (file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n-      dump_sbitmap_vector (file, \"st_antin\", \"\", st_antin, last_basic_block);\n-      dump_sbitmap_vector (file, \"st_antout\", \"\", st_antout, last_basic_block);\n-      dump_sbitmap_vector (file, \"st_kill\", \"\", kill, last_basic_block);\n+      fprintf (dump_file, \"Edge List:\\n\");\n+      verify_edge_list (dump_file, edge_list);\n+      print_edge_list (dump_file, edge_list);\n+      dump_sbitmap_vector (dump_file, \"transp\", \"\", transp, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_avloc\", \"\", st_avloc, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_antloc\", \"\", st_antloc, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_antin\", \"\", st_antin, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_antout\", \"\", st_antout, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_kill\", \"\", kill, last_basic_block);\n     }\n #endif\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (file, \"st_avout\", \"\", st_avout, last_basic_block);\n-      dump_sbitmap_vector (file, \"st_avin\", \"\", st_avin, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_avout\", \"\", st_avout, last_basic_block);\n+      dump_sbitmap_vector (dump_file, \"st_avin\", \"\", st_avin, last_basic_block);\n     }\n #endif\n \n@@ -763,8 +763,8 @@ pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n \t\t    kill, farthest);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n-    dump_sbitmap_vector (file, \"farthest\", \"\", farthest, num_edges);\n+  if (dump_file)\n+    dump_sbitmap_vector (dump_file, \"farthest\", \"\", farthest, num_edges);\n #endif\n \n   sbitmap_vector_free (st_antin);\n@@ -780,11 +780,11 @@ pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (file, \"nearerout\", \"\", nearerout,\n+      dump_sbitmap_vector (dump_file, \"nearerout\", \"\", nearerout,\n \t\t\t   last_basic_block + 1);\n-      dump_sbitmap_vector (file, \"nearer\", \"\", nearer, num_edges);\n+      dump_sbitmap_vector (dump_file, \"nearer\", \"\", nearer, num_edges);\n     }\n #endif\n \n@@ -799,10 +799,10 @@ pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   sbitmap_vector_free (nearer);\n \n #ifdef LCM_DEBUG_INFO\n-  if (file)\n+  if (dump_file)\n     {\n-      dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete,\n+      dump_sbitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n+      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *delete,\n \t\t\t   last_basic_block);\n     }\n #endif"}, {"sha": "8ba94473a83ede3fda0945ca8f6ca8f4ed4b452e", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2542,7 +2542,7 @@ rest_of_handle_local_alloc (void)\n \n   allocate_initial_values (reg_equiv_memory_loc);\n \n-  regclass (get_insns (), max_reg_num (), dump_file);\n+  regclass (get_insns (), max_reg_num ());\n   rebuild_notes = local_alloc ();\n \n   /* Local allocation may have turned an indirect jump into a direct"}, {"sha": "44f02b704c9cd5f475048bc8cc4de66aaaa290c4", "filename": "gcc/loop-init.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -38,7 +38,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    loops.  */\n \n struct loops *\n-loop_optimizer_init (FILE *dumpfile, unsigned flags)\n+loop_optimizer_init (unsigned flags)\n {\n   struct loops *loops = XCNEW (struct loops);\n   edge e;\n@@ -93,7 +93,7 @@ loop_optimizer_init (FILE *dumpfile, unsigned flags)\n     mark_single_exit_loops (loops);\n \n   /* Dump loops.  */\n-  flow_loops_dump (loops, dumpfile, NULL, 1);\n+  flow_loops_dump (loops, dump_file, NULL, 1);\n \n #ifdef ENABLE_CHECKING\n   verify_dominators (CDI_DOMINATORS);\n@@ -105,7 +105,7 @@ loop_optimizer_init (FILE *dumpfile, unsigned flags)\n \n /* Finalize loop optimizer.  */\n void\n-loop_optimizer_finalize (struct loops *loops, FILE *dumpfile)\n+loop_optimizer_finalize (struct loops *loops)\n {\n   unsigned i;\n \n@@ -116,9 +116,6 @@ loop_optimizer_finalize (struct loops *loops, FILE *dumpfile)\n     if (loops->parray[i])\n       free_simple_loop_desc (loops->parray[i]);\n \n-  /* Another dump.  */\n-  flow_loops_dump (loops, dumpfile, NULL, 1);\n-\n   /* Clean up.  */\n   flow_loops_free (loops);\n   free (loops);\n@@ -173,7 +170,7 @@ rtl_loop_init (void)\n   /* Initialize structures for layout changes.  */\n   cfg_layout_initialize (0);\n \n-  current_loops = loop_optimizer_init (dump_file, LOOPS_NORMAL);\n+  current_loops = loop_optimizer_init (LOOPS_NORMAL);\n }\n \n struct tree_opt_pass pass_rtl_loop_init =\n@@ -201,7 +198,7 @@ rtl_loop_done (void)\n   basic_block bb;\n \n   if (current_loops)\n-    loop_optimizer_finalize (current_loops, dump_file);\n+    loop_optimizer_finalize (current_loops);\n \n   free_dominance_info (CDI_DOMINATORS);\n "}, {"sha": "fcb7d1ab21f3cce31965f17c3816d2fc4bc9bd2f", "filename": "gcc/loop.c", "status": "modified", "additions": 198, "deletions": 204, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -590,8 +590,6 @@ struct movable\n };\n \n \n-static FILE *loop_dump_stream;\n-\n /* Forward declarations.  */\n \n static void invalidate_loops_containing_label (rtx);\n@@ -799,21 +797,17 @@ compute_luids (rtx start, rtx end, int prev_luid)\n }\n \f\n /* Entry point of this file.  Perform loop optimization\n-   on the current function.  F is the first insn of the function\n-   and DUMPFILE is a stream for output of a trace of actions taken\n-   (or 0 if none should be output).  */\n+   on the current function.  F is the first insn of the function.  */\n \n static void\n-loop_optimize (rtx f, FILE *dumpfile, int flags)\n+loop_optimize (rtx f, int flags)\n {\n   rtx insn;\n   int i;\n   struct loops loops_data;\n   struct loops *loops = &loops_data;\n   struct loop_info *loops_info;\n \n-  loop_dump_stream = dumpfile;\n-\n   init_recog_no_volatile ();\n \n   max_reg_before_loop = max_reg_num ();\n@@ -1091,8 +1085,8 @@ scan_loop (struct loop *loop, int flags)\n   if (INSN_UID (loop->scan_start) >= max_uid_for_loop\n       || !LABEL_P (loop->scan_start))\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"\\nLoop from %d to %d is phony.\\n\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nLoop from %d to %d is phony.\\n\\n\",\n \t\t INSN_UID (loop_start), INSN_UID (loop_end));\n       return;\n     }\n@@ -1103,8 +1097,8 @@ scan_loop (struct loop *loop, int flags)\n   loop_regs_scan (loop, loop_info->mems_idx + 16);\n   insn_count = count_insns_in_loop (loop);\n \n-  if (loop_dump_stream)\n-    fprintf (loop_dump_stream, \"\\nLoop from %d to %d: %d real insns.\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nLoop from %d to %d: %d real insns.\\n\",\n \t     INSN_UID (loop_start), INSN_UID (loop_end), insn_count);\n \n   /* Scan through the loop finding insns that are safe to move.\n@@ -2195,27 +2189,27 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n     {\n       /* Describe this movable insn.  */\n \n-      if (loop_dump_stream)\n+      if (dump_file)\n \t{\n-\t  fprintf (loop_dump_stream, \"Insn %d: regno %d (life %d), \",\n+\t  fprintf (dump_file, \"Insn %d: regno %d (life %d), \",\n \t\t   INSN_UID (m->insn), m->regno, m->lifetime);\n \t  if (m->consec > 0)\n-\t    fprintf (loop_dump_stream, \"consec %d, \", m->consec);\n+\t    fprintf (dump_file, \"consec %d, \", m->consec);\n \t  if (m->cond)\n-\t    fprintf (loop_dump_stream, \"cond \");\n+\t    fprintf (dump_file, \"cond \");\n \t  if (m->force)\n-\t    fprintf (loop_dump_stream, \"force \");\n+\t    fprintf (dump_file, \"force \");\n \t  if (m->global)\n-\t    fprintf (loop_dump_stream, \"global \");\n+\t    fprintf (dump_file, \"global \");\n \t  if (m->done)\n-\t    fprintf (loop_dump_stream, \"done \");\n+\t    fprintf (dump_file, \"done \");\n \t  if (m->move_insn)\n-\t    fprintf (loop_dump_stream, \"move-insn \");\n+\t    fprintf (dump_file, \"move-insn \");\n \t  if (m->match)\n-\t    fprintf (loop_dump_stream, \"matches %d \",\n+\t    fprintf (dump_file, \"matches %d \",\n \t\t     INSN_UID (m->match->insn));\n \t  if (m->forces)\n-\t    fprintf (loop_dump_stream, \"forces %d \",\n+\t    fprintf (dump_file, \"forces %d \",\n \t\t     INSN_UID (m->forces->insn));\n \t}\n \n@@ -2243,11 +2237,11 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t  p = m->insn;\n \t  regno = m->regno;\n \n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"savings %d \", savings);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"savings %d \", savings);\n \n-\t  if (regs->array[regno].moved_once && loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"halved since already moved \");\n+\t  if (regs->array[regno].moved_once && dump_file)\n+\t    fprintf (dump_file, \"halved since already moved \");\n \n \t  /* An insn MUST be moved if we already moved something else\n \t     which is safe only if this one is moved too: that is,\n@@ -2305,8 +2299,8 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t  if (new_start == 0)\n \t\t    new_start = i1;\n \n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream, \" moved to %d\", INSN_UID (i1));\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \" moved to %d\", INSN_UID (i1));\n \t\t}\n \t      /* If we are to re-generate the item being moved with a\n \t\t new move insn, first delete what we have and then emit\n@@ -2377,8 +2371,8 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t\t\t m->is_equiv ? REG_EQUIV : REG_EQUAL,\n \t\t\t\t\t m->set_src);\n \n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream, \" moved to %d\", INSN_UID (i1));\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \" moved to %d\", INSN_UID (i1));\n \n \t\t  /* The more regs we move, the less we like moving them.  */\n \t\t  threshold -= 3;\n@@ -2566,8 +2560,8 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t      if (new_start == 0)\n \t\t\tnew_start = i1;\n \n-\t\t      if (loop_dump_stream)\n-\t\t\tfprintf (loop_dump_stream, \" moved to %d\",\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \" moved to %d\",\n \t\t\t\t INSN_UID (i1));\n \n \t\t      /* If library call, now fix the REG_NOTES that contain\n@@ -2679,14 +2673,14 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t}\n \t\t    }\n \t    }\n-\t  else if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"not desirable\");\n+\t  else if (dump_file)\n+\t    fprintf (dump_file, \"not desirable\");\n \t}\n-      else if (loop_dump_stream && !m->match)\n-\tfprintf (loop_dump_stream, \"not safe\");\n+      else if (dump_file && !m->match)\n+\tfprintf (dump_file, \"not safe\");\n \n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n\");\n     }\n \n   if (new_start == 0)\n@@ -3102,8 +3096,8 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t  for (loop = current_loop; loop; loop = loop->outer)\n \t    {\n \t      loop->invalid = 1;\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"\\nLoop at %d ignored due to setjmp.\\n\",\n \t\t\t INSN_UID (loop->start));\n \t    }\n@@ -3464,8 +3458,8 @@ mark_loop_jump (rtx x, struct loop *loop)\n \t      return;\n \n \t  /* If we get here, we know we need to invalidate a loop.  */\n-\t  if (loop_dump_stream && ! dest_loop->invalid)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file && ! dest_loop->invalid)\n+\t    fprintf (dump_file,\n \t\t     \"\\nLoop at %d ignored due to multiple entry points.\\n\",\n \t\t     INSN_UID (dest_loop->start));\n \n@@ -3504,8 +3498,8 @@ mark_loop_jump (rtx x, struct loop *loop)\n \t{\n \t  for (outer_loop = loop; outer_loop; outer_loop = outer_loop->outer)\n \t    {\n-\t      if (loop_dump_stream && ! outer_loop->invalid)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file && ! outer_loop->invalid)\n+\t\tfprintf (dump_file,\n \t\t\t \"\\nLoop at %d ignored due to unknown exit jump.\\n\",\n \t\t\t INSN_UID (outer_loop->start));\n \t      outer_loop->invalid = 1;\n@@ -4143,8 +4137,8 @@ emit_prefetch_instructions (struct loop *loop)\n      slow enough to read the memory.  */\n   if (PREFETCH_NO_CALL && LOOP_INFO (loop)->has_call)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Prefetch: ignoring loop: has call.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"Prefetch: ignoring loop: has call.\\n\");\n \n       return;\n     }\n@@ -4154,8 +4148,8 @@ emit_prefetch_instructions (struct loop *loop)\n       && LOOP_INFO (loop)->n_iterations\n       && LOOP_INFO (loop)->n_iterations <= PREFETCH_LOW_LOOPCNT)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Prefetch: ignoring loop: not enough iterations.\\n\");\n       return;\n     }\n@@ -4180,26 +4174,26 @@ emit_prefetch_instructions (struct loop *loop)\n \t     heuristics more conservative.  */\n \t  if (GET_CODE (biv->add_val) != CONST_INT)\n \t    {\n-\t      if (loop_dump_stream)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (loop_dump_stream,\n+\t\t  fprintf (dump_file,\n \t\t    \"Prefetch: ignoring biv %d: non-constant addition at insn %d:\",\n \t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n-\t\t  print_rtl (loop_dump_stream, biv->add_val);\n-\t\t  fprintf (loop_dump_stream, \"\\n\");\n+\t\t  print_rtl (dump_file, biv->add_val);\n+\t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t      break;\n \t    }\n \n \t  if (biv->maybe_multiple)\n \t    {\n-\t      if (loop_dump_stream)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (loop_dump_stream,\n+\t\t  fprintf (dump_file,\n \t\t\t   \"Prefetch: ignoring biv %d: maybe_multiple at insn %i:\",\n \t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n-\t\t  print_rtl (loop_dump_stream, biv->add_val);\n-\t\t  fprintf (loop_dump_stream, \"\\n\");\n+\t\t  print_rtl (dump_file, biv->add_val);\n+\t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t      break;\n \t    }\n@@ -4266,8 +4260,8 @@ emit_prefetch_instructions (struct loop *loop)\n \n \t  if (ignore_reason != NULL)\n \t    {\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"Prefetch: ignoring giv at %d: %s.\\n\",\n \t\t\t INSN_UID (iv->insn), ignore_reason);\n \t      continue;\n@@ -4290,8 +4284,8 @@ emit_prefetch_instructions (struct loop *loop)\n \t    note_stores (PATTERN (iv->insn), check_store, &d);\n \t  else\n \t    {\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream, \"Prefetch: Ignoring giv at %d: %s\\n\",\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Prefetch: Ignoring giv at %d: %s\\n\",\n \t\t\t INSN_UID (iv->insn), \"in conditional code.\");\n \t      continue;\n \t    }\n@@ -4345,8 +4339,8 @@ emit_prefetch_instructions (struct loop *loop)\n \t      num_prefetches++;\n \t      if (num_prefetches >= MAX_PREFETCHES)\n \t\t{\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Maximal number of prefetches exceeded.\\n\");\n \t\t  return;\n \t\t}\n@@ -4383,8 +4377,8 @@ emit_prefetch_instructions (struct loop *loop)\n \telse\n \t  {\n \t    info[i].prefetch_in_loop = 0, info[i].prefetch_before_loop = 0;\n-\t    if (loop_dump_stream)\n-\t      fprintf (loop_dump_stream,\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n \t\t  \"Prefetch: ignoring giv at %d: %d%% density is too low.\\n\",\n \t\t       INSN_UID (info[i].giv->insn), density);\n \t  }\n@@ -4408,8 +4402,8 @@ emit_prefetch_instructions (struct loop *loop)\n     {\n       if ((ahead = SIMULTANEOUS_PREFETCHES / num_real_prefetches) == 0)\n \t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Prefetch: ignoring prefetches within loop: ahead is zero; %d < %d\\n\",\n \t\t     SIMULTANEOUS_PREFETCHES, num_real_prefetches);\n \t  num_real_prefetches = 0, num_real_write_prefetches = 0;\n@@ -4438,27 +4432,27 @@ emit_prefetch_instructions (struct loop *loop)\n \t    num_write_prefetches_before += n;\n \t}\n \n-      if (loop_dump_stream)\n+      if (dump_file)\n \t{\n \t  if (info[i].prefetch_in_loop == 0\n \t      && info[i].prefetch_before_loop == 0)\n \t    continue;\n-\t  fprintf (loop_dump_stream, \"Prefetch insn: %d\",\n+\t  fprintf (dump_file, \"Prefetch insn: %d\",\n \t\t   INSN_UID (info[i].giv->insn));\n-\t  fprintf (loop_dump_stream,\n+\t  fprintf (dump_file,\n \t\t   \"; in loop: %d; before: %d; %s\\n\",\n \t\t   info[i].prefetch_in_loop,\n \t\t   info[i].prefetch_before_loop,\n \t\t   info[i].write ? \"read/write\" : \"read only\");\n-\t  fprintf (loop_dump_stream,\n+\t  fprintf (dump_file,\n \t\t   \" density: %d%%; bytes_accessed: %u; total_bytes: %u\\n\",\n \t\t   (int) (info[i].bytes_accessed * 100 / info[i].stride),\n \t\t   info[i].bytes_accessed, info[i].total_bytes);\n-\t  fprintf (loop_dump_stream, \" index: \" HOST_WIDE_INT_PRINT_DEC\n+\t  fprintf (dump_file, \" index: \" HOST_WIDE_INT_PRINT_DEC\n \t\t   \"; stride: \" HOST_WIDE_INT_PRINT_DEC \"; address: \",\n \t\t   info[i].index, info[i].stride);\n-\t  print_rtl (loop_dump_stream, info[i].base_address);\n-\t  fprintf (loop_dump_stream, \"\\n\");\n+\t  print_rtl (dump_file, info[i].base_address);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n \n@@ -4467,11 +4461,11 @@ emit_prefetch_instructions (struct loop *loop)\n       /* Record that this loop uses prefetch instructions.  */\n       LOOP_INFO (loop)->has_prefetch = 1;\n \n-      if (loop_dump_stream)\n+      if (dump_file)\n \t{\n-\t  fprintf (loop_dump_stream, \"Real prefetches needed within loop: %d (write: %d)\\n\",\n+\t  fprintf (dump_file, \"Real prefetches needed within loop: %d (write: %d)\\n\",\n \t\t   num_real_prefetches, num_real_write_prefetches);\n-\t  fprintf (loop_dump_stream, \"Real prefetches needed before loop: %d (write: %d)\\n\",\n+\t  fprintf (dump_file, \"Real prefetches needed before loop: %d (write: %d)\\n\",\n \t\t   num_prefetches_before, num_write_prefetches_before);\n \t}\n     }\n@@ -4811,8 +4805,8 @@ loop_bivs_find (struct loop *loop)\n \t     move.  So leave it alone.  */\n \t  || ! bl->incremented)\n \t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Biv %d: discarded, %s\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Biv %d: discarded, %s\\n\",\n \t\t     bl->regno,\n \t\t     (REG_IV_TYPE (ivs, bl->regno) != BASIC_INDUCT\n \t\t      ? \"not induction variable\"\n@@ -4826,8 +4820,8 @@ loop_bivs_find (struct loop *loop)\n \t{\n \t  backbl = &bl->next;\n \n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Biv %d: verified\\n\", bl->regno);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Biv %d: verified\\n\", bl->regno);\n \t}\n     }\n }\n@@ -4916,8 +4910,8 @@ loop_bivs_check (struct loop *loop)\n       else\n \tsrc = SET_SRC (bl->init_set);\n \n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Biv %d: initialized at insn %d: initial value \",\n \t\t bl->regno, INSN_UID (bl->init_insn));\n \n@@ -4929,16 +4923,16 @@ loop_bivs_check (struct loop *loop)\n \t{\n \t  bl->initial_value = src;\n \n-\t  if (loop_dump_stream)\n+\t  if (dump_file)\n \t    {\n-\t      print_simple_rtl (loop_dump_stream, src);\n-\t      fputc ('\\n', loop_dump_stream);\n+\t      print_simple_rtl (dump_file, src);\n+\t      fputc ('\\n', dump_file);\n \t    }\n \t}\n       /* If we can't make it a giv,\n \t let biv keep initial value of \"itself\".  */\n-      else if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"is complex\\n\");\n+      else if (dump_file)\n+\tfprintf (dump_file, \"is complex\\n\");\n     }\n }\n \n@@ -5152,8 +5146,8 @@ final_biv_value (const struct loop *loop, struct iv_class *bl)\n      no other loop exits, so we can return any value.  */\n   if (bl->reversed)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Final biv value for %d, reversed biv.\\n\", bl->regno);\n \n       return const0_rtx;\n@@ -5182,8 +5176,8 @@ final_biv_value (const struct loop *loop, struct iv_class *bl)\n \t  loop_iv_add_mult_sink (loop, increment, GEN_INT (n_iterations),\n \t\t\t\t bl->initial_value, tem);\n \n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Final biv value for %d, calculated.\\n\", bl->regno);\n \n \t  return tem;\n@@ -5193,8 +5187,8 @@ final_biv_value (const struct loop *loop, struct iv_class *bl)\n   /* Check to see if the biv is dead at all loop exits.  */\n   if (reg_dead_after_loop (loop, bl->biv->src_reg))\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Final biv value for %d, biv dead after loop exit.\\n\",\n \t\t bl->regno);\n \n@@ -5220,8 +5214,8 @@ loop_biv_eliminable_p (struct loop *loop, struct iv_class *bl,\n #ifdef HAVE_decrement_and_branch_until_zero\n   if (bl->nonneg)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Cannot eliminate nonneg biv %d.\\n\", bl->regno);\n       return 0;\n     }\n@@ -5242,12 +5236,12 @@ loop_biv_eliminable_p (struct loop *loop, struct iv_class *bl,\n       || (bl->final_value = final_biv_value (loop, bl)))\n     return maybe_eliminate_biv (loop, bl, 0, threshold,\tinsn_count);\n \n-  if (loop_dump_stream)\n+  if (dump_file)\n     {\n-      fprintf (loop_dump_stream,\n+      fprintf (dump_file,\n \t       \"Cannot eliminate biv %d.\\n\",\n \t       bl->regno);\n-      fprintf (loop_dump_stream,\n+      fprintf (dump_file,\n \t       \"First use: insn %d, last use: insn %d.\\n\",\n \t       REGNO_FIRST_UID (bl->regno),\n \t       REGNO_LAST_UID (bl->regno));\n@@ -5537,8 +5531,8 @@ loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n \t      else\n \t\t{\n \t\t  end_sequence ();\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"unable to reduce iv in insn %d\\n\",\n \t\t\t     INSN_UID (v->insn));\n \t\t  bl->all_reduced = 0;\n@@ -5585,12 +5579,12 @@ loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n \t\t\t\tgen_load_of_final_value (v->dest_reg,\n \t\t\t\t\t\t\t v->final_value));\n \n-      if (loop_dump_stream)\n+      if (dump_file)\n \t{\n-\t  fprintf (loop_dump_stream, \"giv at %d reduced to \",\n+\t  fprintf (dump_file, \"giv at %d reduced to \",\n \t\t   INSN_UID (v->insn));\n-\t  print_simple_rtl (loop_dump_stream, v->new_reg);\n-\t  fprintf (loop_dump_stream, \"\\n\");\n+\t  print_simple_rtl (dump_file, v->new_reg);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n }\n@@ -5826,8 +5820,8 @@ loop_iterations (struct loop *loop)\n      the last loop insn is a jump to the top of the loop.  */\n   if (!JUMP_P (last_loop_insn))\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: No final conditional branch found.\\n\");\n       return 0;\n     }\n@@ -5836,8 +5830,8 @@ loop_iterations (struct loop *loop)\n      we cannot (easily) determine the iteration count.  */\n   if (LABEL_NUSES (JUMP_LABEL (last_loop_insn)) > 1)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Loop has multiple back edges.\\n\");\n       return 0;\n     }\n@@ -5849,8 +5843,8 @@ loop_iterations (struct loop *loop)\n   comparison = get_condition_for_loop (loop, last_loop_insn);\n   if (comparison == 0)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: No final comparison found.\\n\");\n       return 0;\n     }\n@@ -5864,8 +5858,8 @@ loop_iterations (struct loop *loop)\n \n   if (!REG_P (iteration_var))\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Comparison not against register.\\n\");\n       return 0;\n     }\n@@ -5895,8 +5889,8 @@ loop_iterations (struct loop *loop)\n      reg_iv_type entry for it.  */\n   if ((unsigned) REGNO (iteration_var) >= ivs->n_regs)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: No reg_iv_type entry for iteration var.\\n\");\n       return 0;\n     }\n@@ -5907,15 +5901,15 @@ loop_iterations (struct loop *loop)\n   else if ((GET_MODE_BITSIZE (GET_MODE (iteration_var))\n \t    > HOST_BITS_PER_WIDE_INT))\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Iteration var rejected because mode too large.\\n\");\n       return 0;\n     }\n   else if (GET_MODE_CLASS (GET_MODE (iteration_var)) != MODE_INT)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Iteration var not an integer.\\n\");\n       return 0;\n     }\n@@ -5941,8 +5935,8 @@ loop_iterations (struct loop *loop)\n       initial_value = bl->initial_value;\n       if (!bl->biv->always_executed || bl->biv->maybe_multiple)\n \t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Loop iterations: Basic induction var not set once in each iteration.\\n\");\n \t  return 0;\n \t}\n@@ -5959,8 +5953,8 @@ loop_iterations (struct loop *loop)\n \n       if (!v->always_executed || v->maybe_multiple)\n \t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Loop iterations: General induction var not set once in each iteration.\\n\");\n \t  return 0;\n \t}\n@@ -5989,8 +5983,8 @@ loop_iterations (struct loop *loop)\n \t\t{\n \t\t  if (REG_P (biv_inc->add_val))\n \t\t    {\n-\t\t      if (loop_dump_stream)\n-\t\t\tfprintf (loop_dump_stream,\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n \t\t\t\t \"Loop iterations: Basic induction var add_val is REG %d.\\n\",\n \t\t\t\t REGNO (biv_inc->add_val));\n \t\t\treturn 0;\n@@ -6004,8 +5998,8 @@ loop_iterations (struct loop *loop)\n \t\t}\n \t    }\n \t}\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Giv iterator, initial value bias %ld.\\n\",\n \t\t (long) offset);\n \n@@ -6019,8 +6013,8 @@ loop_iterations (struct loop *loop)\n     }\n   else\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Not basic or general induction var.\\n\");\n       return 0;\n     }\n@@ -6165,8 +6159,8 @@ loop_iterations (struct loop *loop)\n \n   if (increment == 0)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Loop iterations: Increment value can't be calculated.\\n\");\n       return 0;\n     }\n@@ -6181,12 +6175,12 @@ loop_iterations (struct loop *loop)\n \n       if (GET_CODE (increment) != CONST_INT)\n \t{\n-\t  if (loop_dump_stream)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (loop_dump_stream,\n+\t      fprintf (dump_file,\n \t\t       \"Loop iterations: Increment value not constant \");\n-\t      print_simple_rtl (loop_dump_stream, increment);\n-\t      fprintf (loop_dump_stream, \".\\n\");\n+\t      print_simple_rtl (dump_file, increment);\n+\t      fprintf (dump_file, \".\\n\");\n \t    }\n \t  return 0;\n \t}\n@@ -6195,32 +6189,32 @@ loop_iterations (struct loop *loop)\n \n   if (GET_CODE (initial_value) != CONST_INT)\n     {\n-      if (loop_dump_stream)\n+      if (dump_file)\n \t{\n-\t  fprintf (loop_dump_stream,\n+\t  fprintf (dump_file,\n \t\t   \"Loop iterations: Initial value not constant \");\n-\t  print_simple_rtl (loop_dump_stream, initial_value);\n-\t  fprintf (loop_dump_stream, \".\\n\");\n+\t  print_simple_rtl (dump_file, initial_value);\n+\t  fprintf (dump_file, \".\\n\");\n \t}\n       return 0;\n     }\n   else if (GET_CODE (final_value) != CONST_INT)\n     {\n-      if (loop_dump_stream)\n+      if (dump_file)\n \t{\n-\t  fprintf (loop_dump_stream,\n+\t  fprintf (dump_file,\n \t\t   \"Loop iterations: Final value not constant \");\n-\t  print_simple_rtl (loop_dump_stream, final_value);\n-\t  fprintf (loop_dump_stream, \".\\n\");\n+\t  print_simple_rtl (dump_file, final_value);\n+\t  fprintf (dump_file, \".\\n\");\n \t}\n       return 0;\n     }\n   else if (comparison_code == EQ)\n     {\n       rtx inc_once;\n \n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Loop iterations: EQ comparison loop.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"Loop iterations: EQ comparison loop.\\n\");\n \n       inc_once = gen_int_mode (INTVAL (initial_value) + INTVAL (increment),\n \t\t\t       GET_MODE (iteration_var));\n@@ -6304,8 +6298,8 @@ loop_iterations (struct loop *loop)\n     ;\n   else\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Loop iterations: Not normal loop.\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"Loop iterations: Not normal loop.\\n\");\n       return 0;\n     }\n \n@@ -6477,8 +6471,8 @@ strength_reduce (struct loop *loop, int flags)\n \t  if (v->lifetime * threshold * benefit < insn_count\n \t      && ! bl->reversed)\n \t    {\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"giv of insn %d not worth while, %d vs %d.\\n\",\n \t\t\t INSN_UID (v->insn),\n \t\t\t v->lifetime * threshold * benefit, insn_count);\n@@ -6489,8 +6483,8 @@ strength_reduce (struct loop *loop, int flags)\n \t\t   && (may_trap_or_fault_p (v->add_val)\n \t\t       || may_trap_or_fault_p (v->mult_val)))\n \t    {\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"giv of insn %d: not always computable.\\n\",\n \t\t\t INSN_UID (v->insn));\n \t      v->ignore = 1;\n@@ -6505,8 +6499,8 @@ strength_reduce (struct loop *loop, int flags)\n \t\tif (tv->mult_val == const1_rtx\n \t\t    && ! product_cheap_p (tv->add_val, v->mult_val))\n \t\t  {\n-\t\t    if (loop_dump_stream)\n-\t\t      fprintf (loop_dump_stream,\n+\t\t    if (dump_file)\n+\t\t      fprintf (dump_file,\n \t\t\t       \"giv of insn %d: would need a multiply.\\n\",\n \t\t\t       INSN_UID (v->insn));\n \t\t    v->ignore = 1;\n@@ -6589,8 +6583,8 @@ strength_reduce (struct loop *loop, int flags)\n \t\t\t\t      gen_load_of_final_value (bl->biv->dest_reg,\n \t\t\t\t\t\t\t       bl->final_value));\n \n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Reg %d: biv eliminated\\n\",\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Reg %d: biv eliminated\\n\",\n \t\t     bl->regno);\n \t}\n       /* See above note wrt final_value.  But since we couldn't eliminate\n@@ -6611,8 +6605,8 @@ strength_reduce (struct loop *loop, int flags)\n \tINSN_CODE (p) = -1;\n       }\n \n-  if (loop_dump_stream)\n-    fprintf (loop_dump_stream, \"\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n \n   loop_ivs_free (loop);\n   if (reg_map)\n@@ -6947,8 +6941,8 @@ record_biv (struct loop *loop, struct induction *v, rtx insn, rtx dest_reg,\n   if (mult_val == const1_rtx)\n     bl->incremented = 1;\n \n-  if (loop_dump_stream)\n-    loop_biv_dump (v, loop_dump_stream, 0);\n+  if (dump_file)\n+    loop_biv_dump (v, dump_file, 0);\n }\n \f\n /* Fill in the data about one giv.\n@@ -7155,8 +7149,8 @@ record_giv (const struct loop *loop, struct induction *v, rtx insn,\n       }\n   }\n \n-  if (loop_dump_stream)\n-    loop_giv_dump (v, loop_dump_stream, 0);\n+  if (dump_file)\n+    loop_giv_dump (v, dump_file, 0);\n }\n \n /* Try to calculate the final value of the giv, the value it will have at\n@@ -7181,8 +7175,8 @@ final_giv_value (const struct loop *loop, struct induction *v)\n      and there are no other loop exits, so we can return any value.  */\n   if (bl->reversed)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Final giv value for %d, depends on reversed biv\\n\",\n \t\t REGNO (v->dest_reg));\n       return const0_rtx;\n@@ -7258,8 +7252,8 @@ final_giv_value (const struct loop *loop, struct induction *v)\n \t  /* Now calculate the giv's final value.  */\n \t  loop_iv_add_mult_sink (loop, tem, v->mult_val, v->add_val, tem);\n \n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Final giv value for %d, calc from biv's value.\\n\",\n \t\t     REGNO (v->dest_reg));\n \n@@ -7273,8 +7267,8 @@ final_giv_value (const struct loop *loop, struct induction *v)\n   /* Check to see if the biv is dead at all loop exits.  */\n   if (reg_dead_after_loop (loop, v->dest_reg))\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Final giv value for %d, giv dead after loop exit.\\n\",\n \t\t REGNO (v->dest_reg));\n \n@@ -7407,8 +7401,8 @@ check_final_value (const struct loop *loop, struct induction *v)\n \t\t  v->replaceable = 0;\n \t\t  v->not_replaceable = 1;\n \n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Found branch outside giv lifetime.\\n\");\n \n \t\t  break;\n@@ -7421,8 +7415,8 @@ check_final_value (const struct loop *loop, struct induction *v)\n \tv->final_value = final_value;\n     }\n \n-  if (loop_dump_stream && v->replaceable)\n-    fprintf (loop_dump_stream, \"Insn %d: giv reg %d final_value replaceable\\n\",\n+  if (dump_file && v->replaceable)\n+    fprintf (dump_file, \"Insn %d: giv reg %d final_value replaceable\\n\",\n \t     INSN_UID (v->insn), REGNO (v->dest_reg));\n }\n \f\n@@ -8935,15 +8929,15 @@ check_ext_dependent_givs (const struct loop *loop, struct iv_class *bl)\n \tif (incr != 0\n \t    && extension_within_bounds_p (loop, bl, incr, v->ext_dependent))\n \t  {\n-\t    if (loop_dump_stream)\n-\t      fprintf (loop_dump_stream,\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n \t\t       \"Verified ext dependent giv at %d of reg %d\\n\",\n \t\t       INSN_UID (v->insn), bl->regno);\n \t  }\n \telse\n \t  {\n-\t    if (loop_dump_stream)\n-\t      fprintf (loop_dump_stream,\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n \t\t       \"Failed ext dependent giv at %d\\n\",\n \t\t       INSN_UID (v->insn));\n \n@@ -9069,18 +9063,18 @@ combine_givs (struct loop_regs *regs, struct iv_class *bl)\n restart:\n   qsort (stats, giv_count, sizeof (*stats), cmp_combine_givs_stats);\n \n-  if (loop_dump_stream)\n+  if (dump_file)\n     {\n-      fprintf (loop_dump_stream, \"Sorted combine statistics:\\n\");\n+      fprintf (dump_file, \"Sorted combine statistics:\\n\");\n       for (k = 0; k < giv_count; k++)\n \t{\n \t  g1 = giv_array[stats[k].giv_number];\n \t  if (!g1->combined_with && !g1->same)\n-\t    fprintf (loop_dump_stream, \" {%d, %d}\",\n+\t    fprintf (dump_file, \" {%d, %d}\",\n \t\t     INSN_UID (giv_array[stats[k].giv_number]->insn),\n \t\t     stats[k].total_benefit);\n \t}\n-      putc ('\\n', loop_dump_stream);\n+      putc ('\\n', dump_file);\n     }\n \n   for (k = 0; k < giv_count; k++)\n@@ -9132,8 +9126,8 @@ combine_givs (struct loop_regs *regs, struct iv_class *bl)\n \t\t    stats[l].total_benefit -= g2->benefit + extra_benefit;\n \t\t}\n \n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"giv at %d combined with giv at %d; new benefit %d + %d, lifetime %d\\n\",\n \t\t\t INSN_UID (g2->insn), INSN_UID (g1->insn),\n \t\t\t g1->benefit, g1_add_benefit, g1->lifetime);\n@@ -9694,8 +9688,8 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \t  rtx tem;\n \n \t  /* Loop can be reversed.  */\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Can reverse loop\\n\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Can reverse loop\\n\");\n \n \t  /* Now check other conditions:\n \n@@ -9989,13 +9983,13 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \n \t      bl->reversed = 1;\n \n-\t      if (loop_dump_stream)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (loop_dump_stream, \"Reversed loop\");\n+\t\t  fprintf (dump_file, \"Reversed loop\");\n \t\t  if (bl->nonneg)\n-\t\t    fprintf (loop_dump_stream, \" and added reg_nonneg\\n\");\n+\t\t    fprintf (dump_file, \" and added reg_nonneg\\n\");\n \t\t  else\n-\t\t    fprintf (loop_dump_stream, \"\\n\");\n+\t\t    fprintf (dump_file, \"\\n\");\n \t\t}\n \n \t      return 1;\n@@ -10061,8 +10055,8 @@ maybe_eliminate_biv (const struct loop *loop, struct iv_class *bl,\n \t  && ! maybe_eliminate_biv_1 (loop, PATTERN (p), p, bl,\n \t\t\t\t      eliminate_p, where_bb, where_insn))\n \t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Cannot eliminate biv %d: biv used in insn %d.\\n\",\n \t\t     bl->regno, INSN_UID (p));\n \t  break;\n@@ -10077,8 +10071,8 @@ maybe_eliminate_biv (const struct loop *loop, struct iv_class *bl,\n \n   if (p == loop->end)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"biv %d %s eliminated.\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"biv %d %s eliminated.\\n\",\n \t\t bl->regno, eliminate_p ? \"was\" : \"can be\");\n       return 1;\n     }\n@@ -11016,12 +11010,12 @@ load_mems (const struct loop *loop)\n \t      loop_insn_emit_after (loop, 0, label, set);\n \t    }\n \n-\t  if (loop_dump_stream)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (loop_dump_stream, \"Hoisted regno %d %s from \",\n+\t      fprintf (dump_file, \"Hoisted regno %d %s from \",\n \t\t       REGNO (reg), (written ? \"r/w\" : \"r/o\"));\n-\t      print_rtl (loop_dump_stream, mem);\n-\t      fputc ('\\n', loop_dump_stream);\n+\t      print_rtl (dump_file, mem);\n+\t      fputc ('\\n', dump_file);\n \t    }\n \n \t  /* Attempt a bit of copy propagation.  This helps untangle the\n@@ -11142,8 +11136,8 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n   gcc_assert (init_insn);\n   if (apply_change_group ())\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"  Replaced reg %d\", regno);\n+      if (dump_file)\n+\tfprintf (dump_file, \"  Replaced reg %d\", regno);\n       if (store_is_first && replaced_last)\n \t{\n \t  rtx first;\n@@ -11162,8 +11156,8 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n \t  /* Delete the instructions.  */\n \t  loop_delete_insns (first, init_insn);\n \t}\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \".\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \".\\n\");\n     }\n }\n \n@@ -11175,8 +11169,8 @@ loop_delete_insns (rtx first, rtx last)\n {\n   while (1)\n     {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \", deleting init_insn (%d)\",\n+      if (dump_file)\n+\tfprintf (dump_file, \", deleting init_insn (%d)\",\n \t\t INSN_UID (first));\n       delete_insn (first);\n \n@@ -11256,8 +11250,8 @@ try_swap_copy_prop (const struct loop *loop, rtx replacement,\n \n \t  if (apply_change_group ())\n \t    {\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"  Swapped set of reg %d at %d with reg %d at %d.\\n\",\n \t\t\t regno, INSN_UID (insn),\n \t\t\t new_regno, INSN_UID (prev_insn));\n@@ -11793,7 +11787,7 @@ rest_of_handle_loop_optimize (void)\n       cleanup_barriers ();\n       \n       /* We only want to perform unrolling once.  */\n-      loop_optimize (get_insns (), dump_file, 0);\n+      loop_optimize (get_insns (), 0);\n       \n       /* The first call to loop_optimize makes some instructions\n          trivially dead.  We delete those instructions now in the\n@@ -11806,7 +11800,7 @@ rest_of_handle_loop_optimize (void)\n       reg_scan (get_insns (), max_reg_num ());\n     } \n   cleanup_barriers ();\n-  loop_optimize (get_insns (), dump_file, do_prefetch);\n+  loop_optimize (get_insns (), do_prefetch);\n       \n   /* Loop can create trivially dead instructions.  */\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());"}, {"sha": "26acab20f90069013cb5c2d66c505248e5d7a7aa", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -383,7 +383,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n    necessary mode switches.  Return true if we did work.  */\n \n static int\n-optimize_mode_switching (FILE *file)\n+optimize_mode_switching (void)\n {\n   rtx insn;\n   int e;\n@@ -563,7 +563,7 @@ optimize_mode_switching (FILE *file)\n \n       FOR_EACH_BB (bb)\n \tsbitmap_not (kill[bb->index], transp[bb->index]);\n-      edge_list = pre_edge_lcm (file, n_entities, transp, comp, antic,\n+      edge_list = pre_edge_lcm (n_entities, transp, comp, antic,\n \t\t\t\tkill, &insert, &delete);\n \n       for (j = n_entities - 1; j >= 0; j--)\n@@ -740,7 +740,7 @@ rest_of_handle_mode_switching (void)\n {\n #ifdef OPTIMIZE_MODE_SWITCHING\n   no_new_pseudos = 0;\n-  optimize_mode_switching (NULL);\n+  optimize_mode_switching ();\n   no_new_pseudos = 1;\n #endif /* OPTIMIZE_MODE_SWITCHING */\n }"}, {"sha": "86bf1a3a14f2a6eab489787c9893f4dcfbe07e2f", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 63, "deletions": 69, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -181,13 +181,9 @@ static bool ps_unschedule_node (partial_schedule_ptr, ddg_node_ptr );\n \n static int issue_rate;\n \n-/* For printing statistics.  */\n-static FILE *stats_file;\n-\n static int sms_order_nodes (ddg_ptr, int, int * result);\n static void set_node_sched_params (ddg_ptr);\n-static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int,\n-\t\t\t\t\t\t   int *, FILE*);\n+static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n static void permute_partial_schedule (partial_schedule_ptr ps, rtx last);\n static void generate_prolog_epilog (partial_schedule_ptr ,struct loop * loop, rtx);\n static void duplicate_insns_of_cycles (partial_schedule_ptr ps,\n@@ -374,26 +370,26 @@ set_node_sched_params (ddg_ptr g)\n }\n \n static void\n-print_node_sched_params (FILE * dump_file, int num_nodes)\n+print_node_sched_params (FILE * file, int num_nodes)\n {\n   int i;\n \n-  if (! dump_file)\n+  if (! file)\n     return;\n   for (i = 0; i < num_nodes; i++)\n     {\n       node_sched_params_ptr nsp = &node_sched_params[i];\n       rtx reg_move = nsp->first_reg_move;\n       int j;\n \n-      fprintf (dump_file, \"Node %d:\\n\", i);\n-      fprintf (dump_file, \" asap = %d:\\n\", nsp->asap);\n-      fprintf (dump_file, \" time = %d:\\n\", nsp->time);\n-      fprintf (dump_file, \" nreg_moves = %d:\\n\", nsp->nreg_moves);\n+      fprintf (file, \"Node %d:\\n\", i);\n+      fprintf (file, \" asap = %d:\\n\", nsp->asap);\n+      fprintf (file, \" time = %d:\\n\", nsp->time);\n+      fprintf (file, \" nreg_moves = %d:\\n\", nsp->nreg_moves);\n       for (j = 0; j < nsp->nreg_moves; j++)\n \t{\n-\t  fprintf (dump_file, \" reg_move = \");\n-\t  print_rtl_single (dump_file, reg_move);\n+\t  fprintf (file, \" reg_move = \");\n+\t  print_rtl_single (file, reg_move);\n \t  reg_move = PREV_INSN (reg_move);\n \t}\n     }\n@@ -824,7 +820,7 @@ loop_single_full_bb_p (struct loop *loop)\n /* Return true if the loop is in its canonical form and false if not.\n    i.e. SIMPLE_SMS_LOOP_P and have one preheader block, and single exit.  */\n static bool\n-loop_canon_p (struct loop *loop, FILE *dump_file)\n+loop_canon_p (struct loop *loop)\n {\n \n   if (loop->inner || ! loop->outer)\n@@ -841,7 +837,7 @@ loop_canon_p (struct loop *loop, FILE *dump_file)\n \t    {\n \t      expanded_location xloc;\n \t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t      fprintf (stats_file, \" %s %d (file, line)\\n\",\n+\t      fprintf (dump_file, \" %s %d (file, line)\\n\",\n \t\t       xloc.file, xloc.line);\n \t    }\n \t}\n@@ -859,7 +855,7 @@ loop_canon_p (struct loop *loop, FILE *dump_file)\n \t    {\n \t      expanded_location xloc;\n   \t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t      fprintf (stats_file, \" %s %d (file, line)\\n\",\n+\t      fprintf (dump_file, \" %s %d (file, line)\\n\",\n \t\t       xloc.file, xloc.line);\n \t    }\n \t}\n@@ -897,7 +893,7 @@ canon_loop (struct loop *loop)\n /* Main entry point, perform SMS scheduling on the loops of the function\n    that consist of single basic blocks.  */\n static void\n-sms_schedule (FILE *dump_file)\n+sms_schedule (void)\n {\n   static int passes = 0;\n   rtx insn;\n@@ -915,13 +911,11 @@ sms_schedule (FILE *dump_file)\n   edge latch_edge;\n   gcov_type trip_count = 0;\n \n-  loops = loop_optimizer_init (dump_file, (LOOPS_HAVE_PREHEADERS\n-\t\t\t\t\t   | LOOPS_HAVE_MARKED_SINGLE_EXITS));\n+  loops = loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n+\t\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n   if (!loops)\n     return;  /* There is no loops to schedule.  */\n \n-  stats_file = dump_file;\n-\n   /* Initialize issue_rate.  */\n   if (targetm.sched.issue_rate)\n     {\n@@ -936,7 +930,7 @@ sms_schedule (FILE *dump_file)\n \n   /* Initialize the scheduler.  */\n   current_sched_info = &sms_sched_info;\n-  sched_init (NULL);\n+  sched_init ();\n \n   /* Init Data Flow analysis, to be used in interloop dep calculation.  */\n   df = df_init (DF_HARD_REGS | DF_EQUIV_NOTES |\tDF_SUBREGS);\n@@ -967,7 +961,7 @@ sms_schedule (FILE *dump_file)\n           break;\n         }\n \n-      if (! loop_canon_p (loop, dump_file))\n+      if (! loop_canon_p (loop))\n         continue;\n \n       if (! loop_single_full_bb_p (loop))\n@@ -986,32 +980,32 @@ sms_schedule (FILE *dump_file)\n       if ( latch_edge->count\n           && (latch_edge->count < loop->single_exit->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD))\n \t{\n-\t  if (stats_file)\n+\t  if (dump_file)\n \t    {\n \t      rtx line_note = find_line_note (tail);\n \n \t      if (line_note)\n \t\t{\n \t\t  expanded_location xloc;\n \t\t  NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t\t  fprintf (stats_file, \"SMS bb %s %d (file, line)\\n\",\n+\t\t  fprintf (dump_file, \"SMS bb %s %d (file, line)\\n\",\n \t\t\t   xloc.file, xloc.line);\n \t\t}\n-\t      fprintf (stats_file, \"SMS single-bb-loop\\n\");\n+\t      fprintf (dump_file, \"SMS single-bb-loop\\n\");\n \t      if (profile_info && flag_branch_probabilities)\n \t    \t{\n-\t      \t  fprintf (stats_file, \"SMS loop-count \");\n-\t      \t  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t      \t  fprintf (dump_file, \"SMS loop-count \");\n+\t      \t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n \t             \t   (HOST_WIDEST_INT) bb->count);\n-\t      \t  fprintf (stats_file, \"\\n\");\n-                  fprintf (stats_file, \"SMS trip-count \");\n-                  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t      \t  fprintf (dump_file, \"\\n\");\n+                  fprintf (dump_file, \"SMS trip-count \");\n+                  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n                            (HOST_WIDEST_INT) trip_count);\n-                  fprintf (stats_file, \"\\n\");\n-\t      \t  fprintf (stats_file, \"SMS profile-sum-max \");\n-\t      \t  fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+                  fprintf (dump_file, \"\\n\");\n+\t      \t  fprintf (dump_file, \"SMS profile-sum-max \");\n+\t      \t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n \t          \t   (HOST_WIDEST_INT) profile_info->sum_max);\n-\t      \t  fprintf (stats_file, \"\\n\");\n+\t      \t  fprintf (dump_file, \"\\n\");\n \t    \t}\n \t    }\n           continue;\n@@ -1031,24 +1025,24 @@ sms_schedule (FILE *dump_file)\n \n       if (insn != NEXT_INSN (tail))\n \t{\n-\t  if (stats_file)\n+\t  if (dump_file)\n \t    {\n \t      if (CALL_P (insn))\n-\t\tfprintf (stats_file, \"SMS loop-with-call\\n\");\n+\t\tfprintf (dump_file, \"SMS loop-with-call\\n\");\n \t      else if (BARRIER_P (insn))\n-\t\tfprintf (stats_file, \"SMS loop-with-barrier\\n\");\n+\t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n \t      else\n-\t\tfprintf (stats_file, \"SMS loop-with-not-single-set\\n\");\n-\t      print_rtl_single (stats_file, insn);\n+\t\tfprintf (dump_file, \"SMS loop-with-not-single-set\\n\");\n+\t      print_rtl_single (dump_file, insn);\n \t    }\n \n \t  continue;\n \t}\n \n       if (! (g = create_ddg (bb, df, 0)))\n         {\n-          if (stats_file)\n-\t    fprintf (stats_file, \"SMS doloop\\n\");\n+          if (dump_file)\n+\t    fprintf (dump_file, \"SMS doloop\\n\");\n \t  continue;\n         }\n \n@@ -1084,33 +1078,33 @@ sms_schedule (FILE *dump_file)\n       if (loop->single_exit->count)\n \ttrip_count = latch_edge->count / loop->single_exit->count;\n \n-      if (stats_file)\n+      if (dump_file)\n \t{\n \t  rtx line_note = find_line_note (tail);\n \n \t  if (line_note)\n \t    {\n \t      expanded_location xloc;\n \t      NOTE_EXPANDED_LOCATION (xloc, line_note);\n-\t      fprintf (stats_file, \"SMS bb %s %d (file, line)\\n\",\n+\t      fprintf (dump_file, \"SMS bb %s %d (file, line)\\n\",\n \t\t       xloc.file, xloc.line);\n \t    }\n-\t  fprintf (stats_file, \"SMS single-bb-loop\\n\");\n+\t  fprintf (dump_file, \"SMS single-bb-loop\\n\");\n \t  if (profile_info && flag_branch_probabilities)\n \t    {\n-\t      fprintf (stats_file, \"SMS loop-count \");\n-\t      fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t      fprintf (dump_file, \"SMS loop-count \");\n+\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n \t               (HOST_WIDEST_INT) bb->count);\n-\t      fprintf (stats_file, \"\\n\");\n-\t      fprintf (stats_file, \"SMS profile-sum-max \");\n-\t      fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+\t      fprintf (dump_file, \"\\n\");\n+\t      fprintf (dump_file, \"SMS profile-sum-max \");\n+\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n \t               (HOST_WIDEST_INT) profile_info->sum_max);\n-\t      fprintf (stats_file, \"\\n\");\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n-\t  fprintf (stats_file, \"SMS doloop\\n\");\n-\t  fprintf (stats_file, \"SMS built-ddg %d\\n\", g->num_nodes);\n-          fprintf (stats_file, \"SMS num-loads %d\\n\", g->num_loads);\n-          fprintf (stats_file, \"SMS num-stores %d\\n\", g->num_stores);\n+\t  fprintf (dump_file, \"SMS doloop\\n\");\n+\t  fprintf (dump_file, \"SMS built-ddg %d\\n\", g->num_nodes);\n+          fprintf (dump_file, \"SMS num-loads %d\\n\", g->num_loads);\n+          fprintf (dump_file, \"SMS num-stores %d\\n\", g->num_stores);\n \t}\n \n \n@@ -1127,12 +1121,12 @@ sms_schedule (FILE *dump_file)\n \t}\n       gcc_assert (count_reg);\n \n-      if (stats_file && count_init)\n+      if (dump_file && count_init)\n         {\n-          fprintf (stats_file, \"SMS const-doloop \");\n-          fprintf (stats_file, HOST_WIDEST_INT_PRINT_DEC,\n+          fprintf (dump_file, \"SMS const-doloop \");\n+          fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC,\n \t\t     loop_count);\n-          fprintf (stats_file, \"\\n\");\n+          fprintf (dump_file, \"\\n\");\n         }\n \n       node_order = XNEWVEC (int, g->num_nodes);\n@@ -1142,15 +1136,15 @@ sms_schedule (FILE *dump_file)\n       mii = MAX (res_MII (g), rec_mii);\n       maxii = (calculate_maxii (g) * SMS_MAX_II_FACTOR) / 100;\n \n-      if (stats_file)\n-\tfprintf (stats_file, \"SMS iis %d %d %d (rec_mii, mii, maxii)\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"SMS iis %d %d %d (rec_mii, mii, maxii)\\n\",\n \t\t rec_mii, mii, maxii);\n \n       /* After sms_order_nodes and before sms_schedule_by_order, to copy over\n \t ASAP.  */\n       set_node_sched_params (g);\n \n-      ps = sms_schedule_by_order (g, mii, maxii, node_order, dump_file);\n+      ps = sms_schedule_by_order (g, mii, maxii, node_order);\n \n       if (ps)\n \tstage_count = PS_STAGE_COUNT (ps);\n@@ -1178,13 +1172,13 @@ sms_schedule (FILE *dump_file)\n \t  int new_cycles;\n \t  struct undo_replace_buff_elem *reg_move_replaces;\n \n-\t  if (stats_file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (stats_file,\n+\t      fprintf (dump_file,\n \t\t       \"SMS succeeded %d %d (with ii, sc)\\n\", ps->ii,\n \t\t       stage_count);\n-\t      print_partial_schedule (ps, stats_file);\n-\t      fprintf (stats_file,\n+\t      print_partial_schedule (ps, dump_file);\n+\t      fprintf (dump_file,\n \t\t       \"SMS Branch (%d) will later be scheduled at cycle %d.\\n\",\n \t\t       g->closing_branch->cuid, PS_MIN_CYCLE (ps) - 1);\n \t    }\n@@ -1267,7 +1261,7 @@ sms_schedule (FILE *dump_file)\n \n   /* Release scheduler data, needed until now because of DFA.  */\n   sched_finish ();\n-  loop_optimizer_finalize (loops, dump_file);\n+  loop_optimizer_finalize (loops);\n }\n \n /* The SMS scheduling algorithm itself\n@@ -1481,7 +1475,7 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n /* This function implements the scheduling algorithm for SMS according to the\n    above algorithm.  */\n static partial_schedule_ptr\n-sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *dump_file)\n+sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n {\n   int ii = mii;\n   int i, c, success;\n@@ -2510,7 +2504,7 @@ rest_of_handle_sms (void)\n   no_new_pseudos = 0;\n   /* Collect loop information to be used in SMS.  */\n   cfg_layout_initialize (CLEANUP_UPDATE_LIFE);\n-  sms_schedule (dump_file);\n+  sms_schedule ();\n \n   /* Update the life information, because we add pseudos.  */\n   max_regno = max_reg_num ();"}, {"sha": "dd76496e45e8a348330518aa70595b16c4352ce2", "filename": "gcc/predict.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -478,7 +478,7 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n    Remove now useless prediction entries.  */\n \n static void\n-combine_predictions_for_bb (FILE *file, basic_block bb)\n+combine_predictions_for_bb (basic_block bb)\n {\n   int best_probability = PROB_EVEN;\n   int best_predictor = END_PREDICTORS;\n@@ -512,14 +512,14 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n       if (!bb->count)\n \tset_even_probabilities (bb);\n       bb->predictions = NULL;\n-      if (file)\n-\tfprintf (file, \"%i edges in bb %i predicted to even probabilities\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"%i edges in bb %i predicted to even probabilities\\n\",\n \t\t nedges, bb->index);\n       return;\n     }\n \n-  if (file)\n-    fprintf (file, \"Predictions for bb %i\\n\", bb->index);\n+  if (dump_file)\n+    fprintf (dump_file, \"Predictions for bb %i\\n\", bb->index);\n \n   /* We implement \"first match\" heuristics and use probability guessed\n      by predictor with smallest index.  */\n@@ -556,18 +556,18 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n     first_match = true;\n \n   if (!found)\n-    dump_prediction (file, PRED_NO_PREDICTION, combined_probability, bb, true);\n+    dump_prediction (dump_file, PRED_NO_PREDICTION, combined_probability, bb, true);\n   else\n     {\n-      dump_prediction (file, PRED_DS_THEORY, combined_probability, bb,\n+      dump_prediction (dump_file, PRED_DS_THEORY, combined_probability, bb,\n \t\t       !first_match);\n-      dump_prediction (file, PRED_FIRST_MATCH, best_probability, bb,\n+      dump_prediction (dump_file, PRED_FIRST_MATCH, best_probability, bb,\n \t\t       first_match);\n     }\n \n   if (first_match)\n     combined_probability = best_probability;\n-  dump_prediction (file, PRED_COMBINED, combined_probability, bb, true);\n+  dump_prediction (dump_file, PRED_COMBINED, combined_probability, bb, true);\n \n   for (pred = bb->predictions; pred; pred = pred->ep_next)\n     {\n@@ -576,7 +576,7 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n \n       if (pred->ep_edge != EDGE_SUCC (bb, 0))\n \tprobability = REG_BR_PROB_BASE - probability;\n-      dump_prediction (file, predictor, probability, bb,\n+      dump_prediction (dump_file, predictor, probability, bb,\n \t\t       !first_match || best_predictor == predictor);\n     }\n   bb->predictions = NULL;\n@@ -1385,7 +1385,7 @@ tree_estimate_probability (void)\n       tree_predict_by_opcode (bb);\n     }\n   FOR_EACH_BB (bb)\n-    combine_predictions_for_bb (dump_file, bb);\n+    combine_predictions_for_bb (bb);\n \n   if (!flag_loop_optimize)\n     strip_builtin_expect ();"}, {"sha": "614e7366945db09bb9c8b22cdefcad4be90a9010", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -72,12 +72,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Hooks for profiling.  */\n static struct profile_hooks* profile_hooks;\n \n-/* File for profiling debug output.  */\n-static inline FILE*\n-profile_dump_file (void) {\n-  return profile_hooks->profile_dump_file ();\n-}\n-\n /* Additional information about the edges we need.  */\n struct edge_info {\n   unsigned int count_valid : 1;\n@@ -1155,8 +1149,8 @@ branch_prob (void)\n       /* Re-merge split basic blocks and the mess introduced by\n \t insert_insn_on_edge.  */\n       cleanup_cfg (profile_arc_flag ? CLEANUP_EXPENSIVE : 0);\n-      if (profile_dump_file())\n-\tdump_flow_info (profile_dump_file());\n+      if (dump_file)\n+\tdump_flow_info (dump_file);\n     }\n \n   free_edge_list (el);"}, {"sha": "9d937ed0448010d2ab72408a191bf900092f30bb", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -3023,7 +3023,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n /* Perform the peephole2 optimization pass.  */\n \n static void\n-peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n+peephole2_optimize (void)\n {\n   rtx insn, prev;\n   regset live;\n@@ -3446,7 +3446,7 @@ static void\n rest_of_handle_peephole2 (void)\n {\n #ifdef HAVE_peephole2\n-  peephole2_optimize (dump_file);\n+  peephole2_optimize ();\n #endif\n }\n "}, {"sha": "eb7a3c127512424bbbe3c7a1080a16cc4a1d950d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2624,16 +2624,16 @@ propagate_stack (edge e)\n    should have been defined by now.  */\n \n static bool\n-compensate_edge (edge e, FILE *file)\n+compensate_edge (edge e)\n {\n   basic_block source = e->src, target = e->dest;\n   stack target_stack = &BLOCK_INFO (target)->stack_in;\n   stack source_stack = &BLOCK_INFO (source)->stack_out;\n   struct stack_def regstack;\n   int reg;\n \n-  if (file)\n-    fprintf (file, \"Edge %d->%d: \", source->index, target->index);\n+  if (dump_file)\n+    fprintf (dump_file, \"Edge %d->%d: \", source->index, target->index);\n \n   gcc_assert (target_stack->top != -2);\n \n@@ -2646,16 +2646,16 @@ compensate_edge (edge e, FILE *file)\n \n       if (reg == -1)\n \t{\n-\t  if (file)\n-\t    fprintf (file, \"no changes needed\\n\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"no changes needed\\n\");\n \t  return false;\n \t}\n     }\n \n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"correcting stack to \");\n-      print_stack (file, target_stack);\n+      fprintf (dump_file, \"correcting stack to \");\n+      print_stack (dump_file, target_stack);\n     }\n \n   /* Abnormal calls may appear to have values live in st(0), but the\n@@ -2724,7 +2724,7 @@ compensate_edge (edge e, FILE *file)\n    source block to the stack_in of the destination block.  */\n \n static bool\n-compensate_edges (FILE *file)\n+compensate_edges (void)\n {\n   bool inserted = false;\n   basic_block bb;\n@@ -2738,7 +2738,7 @@ compensate_edges (FILE *file)\n         edge_iterator ei;\n \n         FOR_EACH_EDGE (e, ei, bb->succs)\n-\t  inserted |= compensate_edge (e, file);\n+\t  inserted |= compensate_edge (e);\n       }\n   return inserted;\n }\n@@ -2777,7 +2777,7 @@ better_edge (edge e1, edge e2)\n /* Convert stack register references in one block.  */\n \n static void\n-convert_regs_1 (FILE *file, basic_block block)\n+convert_regs_1 (basic_block block)\n {\n   struct stack_def regstack;\n   block_info bi = BLOCK_INFO (block);\n@@ -2811,10 +2811,10 @@ convert_regs_1 (FILE *file, basic_block block)\n \t}\n     }\n \n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"\\nBasic block %d\\nInput stack: \", block->index);\n-      print_stack (file, &bi->stack_in);\n+      fprintf (dump_file, \"\\nBasic block %d\\nInput stack: \", block->index);\n+      print_stack (dump_file, &bi->stack_in);\n     }\n \n   /* Process all insns in this block.  Keep track of NEXT so that we\n@@ -2839,26 +2839,26 @@ convert_regs_1 (FILE *file, basic_block block)\n       if (stack_regs_mentioned (insn)\n \t  || CALL_P (insn))\n \t{\n-\t  if (file)\n+\t  if (dump_file)\n \t    {\n-\t      fprintf (file, \"  insn %d input stack: \",\n+\t      fprintf (dump_file, \"  insn %d input stack: \",\n \t\t       INSN_UID (insn));\n-\t      print_stack (file, &regstack);\n+\t      print_stack (dump_file, &regstack);\n \t    }\n \t  control_flow_insn_deleted |= subst_stack_regs (insn, &regstack);\n \t  starting_stack_p = false;\n \t}\n     }\n   while (next);\n \n-  if (file)\n+  if (dump_file)\n     {\n-      fprintf (file, \"Expected live registers [\");\n+      fprintf (dump_file, \"Expected live registers [\");\n       for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; ++reg)\n \tif (TEST_HARD_REG_BIT (bi->out_reg_set, reg))\n-\t  fprintf (file, \" %d\", reg);\n-      fprintf (file, \" ]\\nOutput stack: \");\n-      print_stack (file, &regstack);\n+\t  fprintf (dump_file, \" %d\", reg);\n+      fprintf (dump_file, \" ]\\nOutput stack: \");\n+      print_stack (dump_file, &regstack);\n     }\n \n   insn = BB_END (block);\n@@ -2876,8 +2876,8 @@ convert_regs_1 (FILE *file, basic_block block)\n \t{\n \t  rtx set;\n \n-\t  if (file)\n-\t    fprintf (file, \"Emitting insn initializing reg %d\\n\", reg);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Emitting insn initializing reg %d\\n\", reg);\n \n \t  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode), not_a_num);\n \t  insn = emit_insn_after (set, insn);\n@@ -2918,7 +2918,7 @@ convert_regs_1 (FILE *file, basic_block block)\n /* Convert registers in all blocks reachable from BLOCK.  */\n \n static void\n-convert_regs_2 (FILE *file, basic_block block)\n+convert_regs_2 (basic_block block)\n {\n   basic_block *stack, *sp;\n \n@@ -2959,7 +2959,7 @@ convert_regs_2 (FILE *file, basic_block block)\n \t      *sp++ = e->dest;\n \t  }\n \n-      convert_regs_1 (file, block);\n+      convert_regs_1 (block);\n     }\n   while (sp != stack);\n \n@@ -2971,7 +2971,7 @@ convert_regs_2 (FILE *file, basic_block block)\n    to the stack-like registers the 387 uses.  */\n \n static void\n-convert_regs (FILE *file)\n+convert_regs (void)\n {\n   int inserted;\n   basic_block b;\n@@ -2991,7 +2991,7 @@ convert_regs (FILE *file)\n \n   /* Process all blocks reachable from all entry points.  */\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    convert_regs_2 (file, e->dest);\n+    convert_regs_2 (e->dest);\n \n   /* ??? Process all unreachable blocks.  Though there's no excuse\n      for keeping these even when not optimizing.  */\n@@ -3000,19 +3000,19 @@ convert_regs (FILE *file)\n       block_info bi = BLOCK_INFO (b);\n \n       if (! bi->done)\n-\tconvert_regs_2 (file, b);\n+\tconvert_regs_2 (b);\n     }\n \n-  inserted |= compensate_edges (file);\n+  inserted |= compensate_edges ();\n \n   clear_aux_for_blocks ();\n \n   fixup_abnormal_edges ();\n   if (inserted)\n     commit_edge_insertions ();\n \n-  if (file)\n-    fputc ('\\n', file);\n+  if (dump_file)\n+    fputc ('\\n', dump_file);\n }\n \f\n /* Convert register usage from \"flat\" register file usage to a \"stack\n@@ -3024,7 +3024,7 @@ convert_regs (FILE *file)\n    the edges.  */\n \n static bool\n-reg_to_stack (FILE *file)\n+reg_to_stack (void)\n {\n   basic_block bb;\n   int i;\n@@ -3050,7 +3050,7 @@ reg_to_stack (FILE *file)\n \t  && flag_schedule_insns_after_reload))\n     {\n       count_or_remove_death_notes (NULL, 1);\n-      life_analysis (file, PROP_DEATH_NOTES);\n+      life_analysis (PROP_DEATH_NOTES);\n     }\n   mark_dfs_back_edges ();\n \n@@ -3117,7 +3117,7 @@ reg_to_stack (FILE *file)\n   VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n \t\t    \"stack_regs_mentioned cache\");\n \n-  convert_regs (file);\n+  convert_regs ();\n \n   free_aux_for_blocks ();\n   return true;\n@@ -3140,7 +3140,7 @@ static void\n rest_of_handle_stack_regs (void)\n {\n #ifdef STACK_REGS\n-  if (reg_to_stack (dump_file) && optimize)\n+  if (reg_to_stack () && optimize)\n     {\n       if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n                        | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))"}, {"sha": "7c50d8adf1f40a369335eb02113a7aed0d40dd27", "filename": "gcc/regclass.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -1182,7 +1182,7 @@ init_reg_autoinc (void)\n    This pass comes just before local register allocation.  */\n \n void\n-regclass (rtx f, int nregs, FILE *dump)\n+regclass (rtx f, int nregs)\n {\n   rtx insn;\n   int i;\n@@ -1207,8 +1207,8 @@ regclass (rtx f, int nregs, FILE *dump)\n     {\n       basic_block bb;\n \n-      if (dump)\n-\tfprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n\\nPass %i\\n\\n\",pass);\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n       memset (costs, 0, nregs * sizeof (struct costs));\n@@ -1250,10 +1250,10 @@ regclass (rtx f, int nregs, FILE *dump)\n       if (pass == 0)\n \treg_pref = reg_pref_buffer;\n \n-      if (dump)\n+      if (dump_file)\n \t{\n-\t  dump_regclass (dump);\n-\t  fprintf (dump,\"\\n\");\n+\t  dump_regclass (dump_file);\n+\t  fprintf (dump_file,\"\\n\");\n \t}\n       for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n \t{\n@@ -1299,7 +1299,7 @@ regclass (rtx f, int nregs, FILE *dump)\n \t     should be provided as a register class.  Don't do this if we\n \t     will be doing it again later.  */\n \n-\t  if ((pass == 1  || dump) || ! flag_expensive_optimizations)\n+\t  if ((pass == 1  || dump_file) || ! flag_expensive_optimizations)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (p->cost[class] < p->mem_cost\n \t\t  && (reg_class_size[(int) reg_class_subunion[(int) alt][class]]\n@@ -1318,17 +1318,17 @@ regclass (rtx f, int nregs, FILE *dump)\n \t  if (alt == best)\n \t    alt = NO_REGS;\n \n-\t  if (dump\n+\t  if (dump_file\n \t      && (reg_pref[i].prefclass != (int) best\n \t\t  || reg_pref[i].altclass != (int) alt))\n \t    {\n-\t      fprintf (dump, \"  Register %i\", i);\n+\t      fprintf (dump_file, \"  Register %i\", i);\n \t      if (alt == ALL_REGS || best == ALL_REGS)\n-\t\tfprintf (dump, \" pref %s\\n\", reg_class_names[(int) best]);\n+\t\tfprintf (dump_file, \" pref %s\\n\", reg_class_names[(int) best]);\n \t      else if (alt == NO_REGS)\n-\t\tfprintf (dump, \" pref %s or none\\n\", reg_class_names[(int) best]);\n+\t\tfprintf (dump_file, \" pref %s or none\\n\", reg_class_names[(int) best]);\n \t      else\n-\t\tfprintf (dump, \" pref %s, else %s\\n\",\n+\t\tfprintf (dump_file, \" pref %s, else %s\\n\",\n \t\t\t reg_class_names[(int) best],\n \t\t\t reg_class_names[(int) alt]);\n \t    }"}, {"sha": "1502c0858df9f627931e769ec6975b131597a5d4", "filename": "gcc/regmove.c", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -76,12 +76,12 @@ static void flags_set_1 (rtx, rtx, void *);\n static int try_auto_increment (rtx, rtx, rtx, rtx, HOST_WIDE_INT, int);\n static int find_matches (rtx, struct match *);\n static void replace_in_call_usage (rtx *, unsigned int, rtx, rtx);\n-static int fixup_match_1 (rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *);\n+static int fixup_match_1 (rtx, rtx, rtx, rtx, rtx, int, int, int);\n static int reg_is_remote_constant_p (rtx, rtx, rtx);\n static int stable_and_no_regs_but_for_p (rtx, rtx, rtx);\n static int regclass_compatible_p (int, int);\n static int replacement_quality (rtx);\n-static int fixup_match_2 (rtx, rtx, rtx, rtx, FILE *);\n+static int fixup_match_2 (rtx, rtx, rtx, rtx);\n \n /* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */\n@@ -916,7 +916,7 @@ reg_is_remote_constant_p (rtx reg, rtx insn, rtx first)\n    hard register as ultimate source, like the frame pointer.  */\n \n static int\n-fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n+fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n {\n   rtx p, dst_death = 0;\n   int length, num_calls = 0;\n@@ -965,8 +965,8 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n \t\t  REG_N_CALLS_CROSSED (REGNO (dst)) += num_calls;\n \t\t}\n \n-\t      if (regmove_dump_file)\n-\t\tfprintf (regmove_dump_file,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"Fixed operand of insn %d.\\n\",\n \t\t\t  INSN_UID (insn));\n \n@@ -1038,7 +1038,7 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n    (or 0 if none should be output).  */\n \n static void\n-regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n+regmove_optimize (rtx f, int nregs)\n {\n   int old_max_uid = get_max_uid ();\n   rtx insn;\n@@ -1072,8 +1072,8 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n       if (! flag_regmove && pass >= flag_expensive_optimizations)\n \tgoto done;\n \n-      if (regmove_dump_file)\n-\tfprintf (regmove_dump_file, \"Starting %s pass...\\n\",\n+      if (dump_file)\n+\tfprintf (dump_file, \"Starting %s pass...\\n\",\n \t\t pass ? \"backward\" : \"forward\");\n \n       for (insn = pass ? get_last_insn () : f; insn;\n@@ -1209,17 +1209,16 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t\tcontinue;\n \n \t      if (fixup_match_1 (insn, set, src, src_subreg, dst, pass,\n-\t\t\t\t op_no, match_no,\n-\t\t\t\t regmove_dump_file))\n+\t\t\t\t op_no, match_no))\n \t\tbreak;\n \t    }\n \t}\n     }\n \n   /* A backward pass.  Replace input operands with output operands.  */\n \n-  if (regmove_dump_file)\n-    fprintf (regmove_dump_file, \"Starting backward pass...\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"Starting backward pass...\\n\");\n \n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n     {\n@@ -1308,8 +1307,7 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT\n \t\t      && XEXP (SET_SRC (set), 0) == src\n \t\t      && fixup_match_2 (insn, dst, src,\n-\t\t\t\t\tXEXP (SET_SRC (set), 1),\n-\t\t\t\t\tregmove_dump_file))\n+\t\t\t\t\tXEXP (SET_SRC (set), 1)))\n \t\t    break;\n \t\t  continue;\n \t\t}\n@@ -1368,8 +1366,8 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t\t}\n \n \n-\t      if (regmove_dump_file)\n-\t\tfprintf (regmove_dump_file,\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n \t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n \t\t\t op_no, INSN_UID (insn), match_no);\n \n@@ -1472,8 +1470,8 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t\t\tREG_LIVE_LENGTH (srcno) = 2;\n \t\t    }\n \n-\t\t  if (regmove_dump_file)\n-\t\t    fprintf (regmove_dump_file,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n \t\t\t     op_no, INSN_UID (insn), match_no);\n \n@@ -1643,8 +1641,7 @@ replace_in_call_usage (rtx *loc, unsigned int dst_reg, rtx src, rtx insn)\n \n static int\n fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n-\t       int backward, int operand_number, int match_number,\n-\t       FILE *regmove_dump_file)\n+\t       int backward, int operand_number, int match_number)\n {\n   rtx p;\n   rtx post_inc = 0, post_inc_set = 0, search_end = 0;\n@@ -1679,8 +1676,8 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n \tcode = NOTE;\n     }\n \n-  if (regmove_dump_file)\n-    fprintf (regmove_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Could fix operand %d of insn %d matching operand %d.\\n\",\n \t     operand_number, INSN_UID (insn), match_number);\n \n@@ -2020,8 +2017,8 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n       if (REG_LIVE_LENGTH (REGNO (dst)) < 2)\n \tREG_LIVE_LENGTH (REGNO (dst)) = 2;\n     }\n-  if (regmove_dump_file)\n-    fprintf (regmove_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n \t     operand_number, INSN_UID (insn), match_number);\n   return 1;\n@@ -2476,7 +2473,7 @@ gate_handle_regmove (void)\n static void\n rest_of_handle_regmove (void)\n {\n-  regmove_optimize (get_insns (), max_reg_num (), dump_file);\n+  regmove_optimize (get_insns (), max_reg_num ());\n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n }\n \n@@ -2508,7 +2505,7 @@ gate_handle_stack_adjustments (void)\n static void\n rest_of_handle_stack_adjustments (void)\n {\n-  life_analysis (dump_file, PROP_POSTRELOAD);\n+  life_analysis (PROP_POSTRELOAD);\n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n                | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n "}, {"sha": "0029b7caaea54213e1a48be5349bca4c2861bc4d", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -3532,7 +3532,7 @@ make_return_insns (rtx first)\n /* Try to find insns to place in delay slots.  */\n \n void\n-dbr_schedule (rtx first, FILE *file)\n+dbr_schedule (rtx first)\n {\n   rtx insn, next, epilogue_insn = 0;\n   int i;\n@@ -3779,7 +3779,7 @@ static void\n rest_of_handle_delay_slots (void)\n {\n #ifdef DELAY_SLOTS\n-  dbr_schedule (get_insns (), dump_file);\n+  dbr_schedule (get_insns ());\n #endif\n }   \n "}, {"sha": "864836e07b92b60590385867712b515cbb669e2f", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -1394,9 +1394,8 @@ rtl_seqabstr (void)\n       /* Update notes.  */\n       count_or_remove_death_notes (NULL, 1);\n \n-      life_analysis (dump_file, PROP_DEATH_NOTES |\n-                                PROP_SCAN_DEAD_CODE |\n-                                PROP_KILL_DEAD_CODE);\n+      life_analysis (PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE\n+\t\t     | PROP_KILL_DEAD_CODE);\n \n       /* Extra cleanup.  */\n       cleanup_cfg (CLEANUP_EXPENSIVE |\n@@ -1418,9 +1417,7 @@ gate_rtl_seqabstr (void)\n static void\n rest_of_rtl_seqabstr (void)\n {\n-  life_analysis (dump_file, PROP_DEATH_NOTES |\n-                            PROP_SCAN_DEAD_CODE |\n-                            PROP_KILL_DEAD_CODE);\n+  life_analysis (PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE | PROP_KILL_DEAD_CODE);\n \n   cleanup_cfg (CLEANUP_EXPENSIVE |\n                CLEANUP_UPDATE_LIFE |"}, {"sha": "0da5ddd5fed804a87850bfe9b4b3bccf44ef7325", "filename": "gcc/rtl-profile.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frtl-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frtl-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-profile.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -358,11 +358,6 @@ rtl_gen_const_delta_profiler (histogram_value value, unsigned tag, unsigned base\n   safe_insert_insn_on_edge (sequence, e);\n }\n \n-/* Return the file on which profile dump output goes, if any.  */\n-\n-static FILE *rtl_profile_dump_file (void) {\n-  return dump_file;\n-}\n \f\n struct profile_hooks rtl_profile_hooks =\n {\n@@ -371,6 +366,5 @@ struct profile_hooks rtl_profile_hooks =\n   rtl_gen_interval_profiler,\n   rtl_gen_pow2_profiler,\n   rtl_gen_one_value_profiler,\n-  rtl_gen_const_delta_profiler,\n-  rtl_profile_dump_file\n+  rtl_gen_const_delta_profiler\n };"}, {"sha": "56544b4d670deba839e4fda23da11a1ddd75035b", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -1908,7 +1908,7 @@ extern int rtx_to_tree_code (enum rtx_code);\n \n /* In cse.c */\n extern int delete_trivially_dead_insns (rtx, int);\n-extern int cse_main (rtx, int, FILE *);\n+extern int cse_main (rtx, int);\n extern int exp_equiv_p (rtx, rtx, int, bool);\n extern unsigned hash_rtx (rtx x, enum machine_mode, int *, int *, bool);\n \n@@ -1974,7 +1974,7 @@ extern void add_insn_after (rtx, rtx);\n extern void remove_insn (rtx);\n extern void emit_insn_after_with_line_notes (rtx, rtx, rtx);\n extern rtx emit (rtx);\n-extern void renumber_insns (FILE *);\n+extern void renumber_insns (void);\n extern void remove_unnecessary_notes (void);\n extern rtx delete_insn (rtx);\n extern rtx entry_of_function (void);\n@@ -2001,10 +2001,10 @@ extern void dump_insn_slim (FILE *f, rtx x);\n extern void debug_insn_slim (rtx x);\n \n /* In sched-rgn.c.  */\n-extern void schedule_insns (FILE *);\n+extern void schedule_insns (void);\n \n /* In sched-ebb.c.  */\n-extern void schedule_ebbs (FILE *);\n+extern void schedule_ebbs (void);\n \n /* In haifa-sched.c.  */\n extern void fix_sched_param (const char *, const char *);\n@@ -2077,7 +2077,7 @@ extern void init_regs (void);\n extern void init_fake_stack_mems (void);\n extern void init_reg_sets (void);\n extern void regclass_init (void);\n-extern void regclass (rtx, int, FILE *);\n+extern void regclass (rtx, int);\n extern void reg_scan (rtx, unsigned int);\n extern void reg_scan_update (rtx, rtx, unsigned int);\n extern void fix_register (const char *, int, int);\n@@ -2091,7 +2091,7 @@ extern bool invalid_mode_change_p (unsigned int, enum reg_class,\n \t\t\t\t   enum machine_mode);\n \n /* In reorg.c */\n-extern void dbr_schedule (rtx, FILE *);\n+extern void dbr_schedule (rtx);\n \n /* In local-alloc.c */\n extern void dump_local_alloc (FILE *);"}, {"sha": "d5391d0b5dfa15c9ec9e03de1f3e0e1a5a6e388c", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -41,6 +41,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"params.h\"\n #include \"sched-int.h\"\n #include \"target.h\"\n+#include \"output.h\"\n \f\n /* The number of insns to be scheduled in total.  */\n static int target_n_insns;\n@@ -551,11 +552,10 @@ schedule_ebb (rtx head, rtx tail)\n   return b;\n }\n \n-/* The one entry point in this file.  DUMP_FILE is the dump file for\n-   this pass.  */\n+/* The one entry point in this file.  */\n \n void\n-schedule_ebbs (FILE *dump_file)\n+schedule_ebbs (void)\n {\n   basic_block bb;\n   int probability_cutoff;\n@@ -571,7 +571,7 @@ schedule_ebbs (FILE *dump_file)\n   if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return;\n \n-  sched_init (dump_file);\n+  sched_init ();\n \n   current_sched_info = &ebb_sched_info;\n "}, {"sha": "a671d930dadb6b034f7ba6684f745b0bdf30dcba", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -359,7 +359,7 @@ extern int insn_cost (rtx, rtx, rtx);\n extern int set_priorities (rtx, rtx);\n \n extern void schedule_block (int, int);\n-extern void sched_init (FILE *);\n+extern void sched_init (void);\n extern void sched_finish (void);\n \n extern void ready_add (struct ready_list *, rtx);"}, {"sha": "9a239bb0b384c1902760f6d630e325198a7afcc5", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2511,11 +2511,10 @@ init_regions (void)\n     count_or_remove_death_notes (NULL, 1);\n }\n \n-/* The one entry point in this file.  DUMP_FILE is the dump file for\n-   this pass.  */\n+/* The one entry point in this file.  */\n \n void\n-schedule_insns (FILE *dump_file)\n+schedule_insns (void)\n {\n   sbitmap large_region_blocks, blocks;\n   int rgn;\n@@ -2529,7 +2528,7 @@ schedule_insns (FILE *dump_file)\n \n   nr_inter = 0;\n   nr_spec = 0;\n-  sched_init (dump_file);\n+  sched_init ();\n \n   init_regions ();\n \n@@ -2656,7 +2655,7 @@ rest_of_handle_sched (void)\n   /* Do control and data sched analysis,\n      and write some of the results to dump file.  */\n \n-  schedule_insns (dump_file);\n+  schedule_insns ();\n #endif\n }\n \n@@ -2682,14 +2681,14 @@ rest_of_handle_sched2 (void)\n \n   if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n     {\n-      schedule_ebbs (dump_file);\n+      schedule_ebbs ();\n       /* No liveness updating code yet, but it should be easy to do.\n          reg-stack recomputes the liveness when needed for now.  */\n       count_or_remove_death_notes (NULL, 1);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n     }\n   else\n-    schedule_insns (dump_file);\n+    schedule_insns ();\n #endif\n }\n "}, {"sha": "0724c1021636a4bc6a90220b7500a87cf93f3300", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -207,11 +207,11 @@ build_tree_cfg (tree *tp)\n   /* Write the flowgraph to a VCG file.  */\n   {\n     int local_dump_flags;\n-    FILE *dump_file = dump_begin (TDI_vcg, &local_dump_flags);\n-    if (dump_file)\n+    FILE *vcg_file = dump_begin (TDI_vcg, &local_dump_flags);\n+    if (vcg_file)\n       {\n-\ttree_cfg2vcg (dump_file);\n-\tdump_end (TDI_vcg, dump_file);\n+\ttree_cfg2vcg (vcg_file);\n+\tdump_end (TDI_vcg, vcg_file);\n       }\n   }\n "}, {"sha": "78ec5e7b35645059ba8bb296383e45db6580047e", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -2052,11 +2052,10 @@ fini_analyze_edges_for_bb (void)\n \n \n /* Look at all the incoming edges to block BB, and decide where the best place\n-   to insert the stmts on each edge are, and perform those insertions.   Output\n-   any debug information to DEBUG_FILE.  */\n+   to insert the stmts on each edge are, and perform those insertions.  */\n \n static void\n-analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n+analyze_edges_for_bb (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -2180,8 +2179,8 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n     }\n \n \n-  if (debug_file)\n-    fprintf (debug_file, \"\\nOpportunities in BB %d for stmt/block reduction:\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nOpportunities in BB %d for stmt/block reduction:\\n\",\n \t     bb->index);\n \n   \n@@ -2207,19 +2206,19 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n         new_edge = make_forwarder_block (leader->dest, same_stmt_list_p, \n \t\t\t\t\t NULL);\n \tbb = new_edge->dest;\n-\tif (debug_file)\n+\tif (dump_file)\n \t  {\n-\t    fprintf (debug_file, \"Splitting BB %d for Common stmt list.  \", \n+\t    fprintf (dump_file, \"Splitting BB %d for Common stmt list.  \", \n \t\t     leader->dest->index);\n-\t    fprintf (debug_file, \"Original block is now BB%d.\\n\", bb->index);\n-\t    print_generic_stmt (debug_file, curr_stmt_list, TDF_VOPS);\n+\t    fprintf (dump_file, \"Original block is now BB%d.\\n\", bb->index);\n+\t    print_generic_stmt (dump_file, curr_stmt_list, TDF_VOPS);\n \t  }\n \n \tFOR_EACH_EDGE (e, ei, new_edge->src->preds)\n \t  {\n \t    e->aux = NULL;\n-\t    if (debug_file)\n-\t      fprintf (debug_file, \"  Edge (%d->%d) lands here.\\n\", \n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"  Edge (%d->%d) lands here.\\n\", \n \t\t       e->src->index, e->dest->index);\n \t  }\n \n@@ -2246,11 +2245,10 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n /* This function will analyze the insertions which were performed on edges,\n    and decide whether they should be left on that edge, or whether it is more\n    efficient to emit some subset of them in a single block.  All stmts are\n-   inserted somewhere, and if non-NULL, debug information is printed via \n-   DUMP_FILE.  */\n+   inserted somewhere.  */\n \n static void\n-perform_edge_inserts (FILE *dump_file)\n+perform_edge_inserts (void)\n {\n   basic_block bb;\n \n@@ -2268,9 +2266,9 @@ perform_edge_inserts (FILE *dump_file)\n   init_analyze_edges_for_bb ();\n \n   FOR_EACH_BB (bb)\n-    analyze_edges_for_bb (bb, dump_file);\n+    analyze_edges_for_bb (bb);\n \n-  analyze_edges_for_bb (EXIT_BLOCK_PTR, dump_file);\n+  analyze_edges_for_bb (EXIT_BLOCK_PTR);\n \n   /* Free data structures used in analyze_edges_for_bb.   */\n   fini_analyze_edges_for_bb ();\n@@ -2311,21 +2309,17 @@ perform_edge_inserts (FILE *dump_file)\n }\n \n \n-/* Remove the variables specified in MAP from SSA form.  Any debug information\n-   is sent to DUMP.  FLAGS indicate what options should be used.  */\n+/* Remove the variables specified in MAP from SSA form.  FLAGS indicate what\n+   options should be used.  */\n \n static void\n-remove_ssa_form (FILE *dump, var_map map, int flags)\n+remove_ssa_form (var_map map, int flags)\n {\n   tree_live_info_p liveinfo;\n   basic_block bb;\n   tree phi, next;\n-  FILE *save;\n   tree *values = NULL;\n \n-  save = dump_file;\n-  dump_file = dump;\n-\n   /* If we are not combining temps, don't calculate live ranges for variables\n      with only one SSA version.  */\n   if ((flags & SSANORM_COMBINE_TEMPS) == 0)\n@@ -2396,9 +2390,7 @@ remove_ssa_form (FILE *dump, var_map map, int flags)\n   fini_ssa_operands ();\n \n   /* If any copies were inserted on edges, analyze and insert them now.  */\n-  perform_edge_inserts (dump_file);\n-\n-  dump_file = save;\n+  perform_edge_inserts ();\n }\n \n /* Search every PHI node for arguments associated with backedges which\n@@ -2527,7 +2519,7 @@ rewrite_out_of_ssa (void)\n   if (flag_tree_ter && !flag_mudflap)\n     ssa_flags |= SSANORM_PERFORM_TER;\n \n-  remove_ssa_form (dump_file, map, ssa_flags);\n+  remove_ssa_form (map, ssa_flags);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_tree_cfg (dump_file, dump_flags & ~TDF_DETAILS);"}, {"sha": "157c600927e76f31b4eaf4cdfbf872f6df6efe48", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -234,12 +234,6 @@ do_tree_profiling (void)\n   return false;\n }\n \n-/* Return the file on which profile dump output goes, if any.  */\n-\n-static FILE *tree_profile_dump_file (void) {\n-  return dump_file;\n-}\n-\n static void\n tree_profiling (void)\n {\n@@ -306,8 +300,7 @@ struct profile_hooks tree_profile_hooks =\n   tree_gen_interval_profiler,   /* gen_interval_profiler */\n   tree_gen_pow2_profiler,       /* gen_pow2_profiler */\n   tree_gen_one_value_profiler,  /* gen_one_value_profiler */\n-  tree_gen_const_delta_profiler,/* gen_const_delta_profiler */\n-  tree_profile_dump_file\t/* profile_dump_file */\n+  tree_gen_const_delta_profiler /* gen_const_delta_profiler */\n };\n \n #include \"gt-tree-profile.h\""}, {"sha": "157e8fea48301e34657c3374a0dcf39177167fc5", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -479,15 +479,15 @@ set_copy_of_val (tree dest, tree first, tree mem_ref)\n }\n \n \n-/* Dump the copy-of value for variable VAR to DUMP_FILE.  */\n+/* Dump the copy-of value for variable VAR to FILE.  */\n \n static void\n-dump_copy_of (FILE *dump_file, tree var)\n+dump_copy_of (FILE *file, tree var)\n {\n   tree val;\n   sbitmap visited;\n \n-  print_generic_expr (dump_file, var, dump_flags);\n+  print_generic_expr (file, var, dump_flags);\n \n   if (TREE_CODE (var) != SSA_NAME)\n     return;\n@@ -496,29 +496,29 @@ dump_copy_of (FILE *dump_file, tree var)\n   sbitmap_zero (visited);\n   SET_BIT (visited, SSA_NAME_VERSION (var));\n   \n-  fprintf (dump_file, \" copy-of chain: \");\n+  fprintf (file, \" copy-of chain: \");\n \n   val = var;\n-  print_generic_expr (dump_file, val, 0);\n-  fprintf (dump_file, \" \");\n+  print_generic_expr (file, val, 0);\n+  fprintf (file, \" \");\n   while (copy_of[SSA_NAME_VERSION (val)].value)\n     {\n-      fprintf (dump_file, \"-> \");\n+      fprintf (file, \"-> \");\n       val = copy_of[SSA_NAME_VERSION (val)].value;\n-      print_generic_expr (dump_file, val, 0);\n-      fprintf (dump_file, \" \");\n+      print_generic_expr (file, val, 0);\n+      fprintf (file, \" \");\n       if (TEST_BIT (visited, SSA_NAME_VERSION (val)))\n         break;\n       SET_BIT (visited, SSA_NAME_VERSION (val));\n     }\n \n   val = get_copy_of_val (var)->value;\n   if (val == NULL_TREE)\n-    fprintf (dump_file, \"[UNDEFINED]\");\n+    fprintf (file, \"[UNDEFINED]\");\n   else if (val != var)\n-    fprintf (dump_file, \"[COPY]\");\n+    fprintf (file, \"[COPY]\");\n   else\n-    fprintf (dump_file, \"[NOT A COPY]\");\n+    fprintf (file, \"[NOT A COPY]\");\n   \n   sbitmap_free (visited);\n }"}, {"sha": "1ce95bd916720f495ee8314bae61f14244b45161", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -132,8 +132,8 @@ copy_loop_headers (void)\n   unsigned n_bbs;\n   unsigned bbs_size;\n \n-  loops = loop_optimizer_init (dump_file, (LOOPS_HAVE_PREHEADERS\n-\t\t\t\t\t   | LOOPS_HAVE_SIMPLE_LATCHES));\n+  loops = loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n+\t\t\t       | LOOPS_HAVE_SIMPLE_LATCHES);\n   if (!loops)\n     return;\n \n@@ -213,7 +213,7 @@ copy_loop_headers (void)\n   free (bbs);\n   free (copied_bbs);\n \n-  loop_optimizer_finalize (loops, NULL);\n+  loop_optimizer_finalize (loops);\n }\n \n static bool"}, {"sha": "a735084803e2bfe9b25dff0c44442e59709aa7ee", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -42,16 +42,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n struct loops *current_loops = NULL;\n \n-/* Initializes the loop structures.  DUMP is the file to that the details\n-   about the analysis should be dumped.  */\n+/* Initializes the loop structures.  */\n \n static struct loops *\n-tree_loop_optimizer_init (FILE *dump)\n+tree_loop_optimizer_init (void)\n {\n   struct loops *loops;\n  \n-  loops = loop_optimizer_init (dump, (LOOPS_NORMAL\n-\t\t\t\t      | LOOPS_HAVE_MARKED_SINGLE_EXITS));\n+  loops = loop_optimizer_init (LOOPS_NORMAL\n+\t\t\t       | LOOPS_HAVE_MARKED_SINGLE_EXITS);\n \n   if (!loops)\n     return NULL;\n@@ -91,7 +90,7 @@ struct tree_opt_pass pass_tree_loop =\n static void\n tree_ssa_loop_init (void)\n {\n-  current_loops = tree_loop_optimizer_init (dump_file);\n+  current_loops = tree_loop_optimizer_init ();\n   if (!current_loops)\n     return;\n \n@@ -448,8 +447,7 @@ tree_ssa_loop_done (void)\n \n   free_numbers_of_iterations_estimates (current_loops);\n   scev_finalize ();\n-  loop_optimizer_finalize (current_loops,\n-\t\t\t   (dump_flags & TDF_DETAILS ? dump_file : NULL));\n+  loop_optimizer_finalize (current_loops);\n   current_loops = NULL;\n }\n   "}, {"sha": "d2edf218758b75dd1f335e167532cb2cd4d3a1fe", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -3614,7 +3614,7 @@ init_pre (bool do_fre)\n \n   vn_init ();\n   if (!do_fre)\n-    current_loops = loop_optimizer_init (dump_file, LOOPS_NORMAL);\n+    current_loops = loop_optimizer_init (LOOPS_NORMAL);\n \n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n@@ -3729,7 +3729,7 @@ fini_pre (bool do_fre)\n     }\n   if (!do_fre && current_loops)\n     {\n-      loop_optimizer_finalize (current_loops, dump_file);\n+      loop_optimizer_finalize (current_loops);\n       current_loops = NULL;\n     }\n }"}, {"sha": "3242f3f453358001936bf627d8cf31a393311242", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -522,7 +522,8 @@ sink_code_in_bb (basic_block bb)\n static void\n execute_sink_code (void)\n {\n-  struct loops *loops = loop_optimizer_init (dump_file, LOOPS_NORMAL);\n+  struct loops *loops = loop_optimizer_init (LOOPS_NORMAL);\n+\n   connect_infinite_loops_to_exit ();\n   memset (&sink_stats, 0, sizeof (sink_stats));\n   calculate_dominance_info (CDI_DOMINATORS | CDI_POST_DOMINATORS);\n@@ -531,7 +532,7 @@ execute_sink_code (void)\n     fprintf (dump_file, \"Sunk statements:%d\\n\", sink_stats.sunk);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();\n-  loop_optimizer_finalize (loops, dump_file);\n+  loop_optimizer_finalize (loops);\n }\n \n /* Gate and execute functions for PRE.  */"}, {"sha": "8e845ff56164d5859a567a49727cee4033f4e5b2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -4308,7 +4308,7 @@ execute_vrp (void)\n {\n   insert_range_assertions ();\n \n-  current_loops = loop_optimizer_init (NULL, LOOPS_NORMAL);\n+  current_loops = loop_optimizer_init (LOOPS_NORMAL);\n   if (current_loops)\n     scev_initialize (current_loops);\n \n@@ -4319,7 +4319,7 @@ execute_vrp (void)\n   if (current_loops)\n     {\n       scev_finalize ();\n-      loop_optimizer_finalize (current_loops, NULL);\n+      loop_optimizer_finalize (current_loops);\n       current_loops = NULL;\n     }\n "}, {"sha": "7695c03bbaea4552bb8e649d76dd68e379b9b819", "filename": "gcc/value-prof.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d22567504587ae20ff4dbe8188f7ead6776cdd/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=10d22567504587ae20ff4dbe8188f7ead6776cdd", "patch": "@@ -94,7 +94,6 @@ struct profile_hooks {\n   /* Insert code to find the most common value of a difference between two\n      evaluations of an expression.  */\n   void (*gen_const_delta_profiler) (histogram_value, unsigned, unsigned);\n-  FILE * (*profile_dump_file) (void);\n };\n \n /* In profile.c.  */"}]}