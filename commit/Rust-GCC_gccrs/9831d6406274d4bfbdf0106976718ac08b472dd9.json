{"sha": "9831d6406274d4bfbdf0106976718ac08b472dd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgzMWQ2NDA2Mjc0ZDRiZmJkZjAxMDY5NzY3MThhYzA4YjQ3MmRkOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-08T23:42:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-08T23:42:18Z"}, "message": "* flow.c (new_insn_dead_notes): Don't early out for preexisting regs.\n\nFrom-SVN: r29217", "tree": {"sha": "01131e6136aef32fd853c3e9f7a9176a62fd99c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01131e6136aef32fd853c3e9f7a9176a62fd99c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9831d6406274d4bfbdf0106976718ac08b472dd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9831d6406274d4bfbdf0106976718ac08b472dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9831d6406274d4bfbdf0106976718ac08b472dd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9831d6406274d4bfbdf0106976718ac08b472dd9/comments", "author": null, "committer": null, "parents": [{"sha": "b6b4c6c6f9aef8cdcf37eb3c2518eff0b68a787f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6b4c6c6f9aef8cdcf37eb3c2518eff0b68a787f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6b4c6c6f9aef8cdcf37eb3c2518eff0b68a787f"}], "stats": {"total": 17, "additions": 17, "deletions": 0}, "files": [{"sha": "8f47f954e4b5033c597fcbf6f549d09331dad61d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9831d6406274d4bfbdf0106976718ac08b472dd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9831d6406274d4bfbdf0106976718ac08b472dd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9831d6406274d4bfbdf0106976718ac08b472dd9", "patch": "@@ -1,3 +1,7 @@\n+Wed Sep  8 16:41:27 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (new_insn_dead_notes): Don't early out for preexisting regs.\n+\n Wed Sep  8 16:07:52 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* gengenrtl.c (CONST_DOUBLE_FORMAT): Take the size REAL_ARITHMETIC "}, {"sha": "bd42a56bc5b3ac05c4c06177f2a257d5843149f0", "filename": "gcc/flow.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9831d6406274d4bfbdf0106976718ac08b472dd9/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9831d6406274d4bfbdf0106976718ac08b472dd9/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=9831d6406274d4bfbdf0106976718ac08b472dd9", "patch": "@@ -5351,6 +5351,7 @@ new_insn_dead_notes (pat, insn, first, last, orig_first_insn, orig_last_insn)\n \n   if (GET_CODE (dest) == REG)\n     {\n+#if 0\n       /* If the original insns already used this register, we may not\n          add new notes for it.  One example for a replacement that\n          needs this test is when a multi-word memory access with\n@@ -5370,6 +5371,17 @@ new_insn_dead_notes (pat, insn, first, last, orig_first_insn, orig_last_insn)\n \t REG_DEAD notes. This can probably be accurately done by\n \t calling mark_referenced_resources() on the old stream before\n \t replacing the old insns.  */\n+      /* ??? The conclusion reached here -- that we can't add DEAD notes\n+\t when the register is preexisting -- is false.  I can't envision\n+\t a sequence postulated above that wouldn't be properly handled\n+\t by the code below.  In the meantime, consider the 1->2 split\n+\n+\t    (set (reg:SI 100) (ne:SI (reg:SI 100) (const_int 0)))\n+\t to\n+\t    (set (reg:CC icc) (compare:CC (reg:SI 100) (const_int 0)))\n+\t    (set (reg:SI 100) (ne:SI (reg:CC icc) (const_int 0)))\n+\n+\t We do in fact need a new DEAD note on the first insn for reg 100.  */\n \n       for (tem = orig_first_insn; tem != NULL_RTX; tem = NEXT_INSN (tem))\n \t{\n@@ -5379,6 +5391,7 @@ new_insn_dead_notes (pat, insn, first, last, orig_first_insn, orig_last_insn)\n \t  if (tem == orig_last_insn)\n \t    break;\n \t}\n+#endif\n \n       /* So it's a new register, presumably only used within this\n \t group of insns. Find the last insn in the set of new insns"}]}