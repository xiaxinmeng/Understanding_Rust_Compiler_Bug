{"sha": "e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "node_id": "C_kwDOANBUbNoAKGUzZWY4MzJhOWU4ZDZhOTUwYTQzOWUzNGU1NzZlYjRjYjIwMmRjNDg", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-20T07:17:09Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2022-01-05T20:46:52Z"}, "message": "libstdc++: Optimize operations on small size hashtable [PR 68303]\n\nWhen hasher is identified as slow and the number of elements is limited in the\ncontainer use a brute-force loop on those elements to look for a given key using\nthe key_equal functor. For the moment the default threshold to consider the\ncontainer as small is 20.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/68303\n\t* include/bits/hashtable_policy.h\n\t(_Hashtable_hash_traits<_Hash>): New.\n\t(_Hash_code_base<>::_M_hash_code(const _Hash_node_value<>&)): New.\n\t(_Hashtable_base<>::_M_key_equals): New.\n\t(_Hashtable_base<>::_M_equals): Use latter.\n\t(_Hashtable_base<>::_M_key_equals_tr): New.\n\t(_Hashtable_base<>::_M_equals_tr): Use latter.\n\t* include/bits/hashtable.h\n\t(_Hashtable<>::__small_size_threshold()): New, use _Hashtable_hash_traits.\n\t(_Hashtable<>::find): Loop through elements to look for key if size is lower\n\tthan __small_size_threshold().\n\t(_Hashtable<>::_M_emplace(true_type, _Args&&...)): Likewise.\n\t(_Hashtable<>::_M_insert_unique(_Kt&&, _Args&&, const _NodeGenerator&)): Likewise.\n\t(_Hashtable<>::_M_compute_hash_code(const_iterator, const key_type&)): New.\n\t(_Hashtable<>::_M_emplace(const_iterator, false_type, _Args&&...)): Use latter.\n\t(_Hashtable<>::_M_find_before_node(const key_type&)): New.\n\t(_Hashtable<>::_M_erase(true_type, const key_type&)): Use latter.\n\t(_Hashtable<>::_M_erase(false_type, const key_type&)): Likewise.\n\t* src/c++11/hashtable_c++0x.cc: Include <bits/functional_hash.h>.\n\t* testsuite/util/testsuite_performance.h\n\t(report_performance): Use 9 width to display memory.\n\t* testsuite/performance/23_containers/insert_erase/unordered_small_size.cc:\n\tNew performance test case.", "tree": {"sha": "7c320c7476a610b34c0acc241020f9cade94fa66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c320c7476a610b34c0acc241020f9cade94fa66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/comments", "author": null, "committer": null, "parents": [{"sha": "194f712f8b7a6a31651f4cf57d49fbf701da5ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194f712f8b7a6a31651f4cf57d49fbf701da5ed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/194f712f8b7a6a31651f4cf57d49fbf701da5ed6"}], "stats": {"total": 368, "additions": 333, "deletions": 35}, "files": [{"sha": "5e1a417f7cda010002f65c763c29be75703ee380", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 161, "deletions": 26, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "patch": "@@ -419,6 +419,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_uses_single_bucket() const\n       { return _M_uses_single_bucket(_M_buckets); }\n \n+      static constexpr size_t\n+      __small_size_threshold() noexcept\n+      {\n+\treturn\n+\t  __detail::_Hashtable_hash_traits<_Hash>::__small_size_threshold();\n+      }\n+\n       __hashtable_alloc&\n       _M_base_alloc() { return *this; }\n \n@@ -788,6 +795,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_bucket_index(__hash_code __c) const\n       { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }\n \n+      __node_base_ptr\n+      _M_find_before_node(const key_type&);\n+\n       // Find and insert helper functions and types\n       // Find the node before the one matching the criteria.\n       __node_base_ptr\n@@ -831,6 +841,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base_ptr\n       _M_get_previous_node(size_type __bkt, __node_ptr __n);\n \n+      pair<const_iterator, __hash_code>\n+      _M_compute_hash_code(const_iterator __hint, const key_type& __k) const;\n+\n       // Insert node __n with hash code __code, in bucket __bkt if no\n       // rehash (assumes no element with same key already present).\n       // Takes ownership of __n if insertion succeeds, throws otherwise.\n@@ -1126,7 +1139,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void _M_rehash(size_type __bkt_count, const __rehash_state& __state);\n     };\n \n-\n   // Definitions of class template _Hashtable's out-of-line member functions.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n@@ -1628,6 +1640,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     find(const key_type& __k)\n     -> iterator\n     {\n+      if (size() <= __small_size_threshold())\n+\t{\n+\t  for (auto __it = begin(); __it != end(); ++__it)\n+\t    if (this->_M_key_equals(__k, *__it._M_cur))\n+\t      return __it;\n+\t  return end();\n+\t}\n+\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__code);\n       return iterator(_M_find_node(__bkt, __k, __code));\n@@ -1643,6 +1663,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     find(const key_type& __k) const\n     -> const_iterator\n     {\n+      if (size() <= __small_size_threshold())\n+\t{\n+\t  for (auto __it = begin(); __it != end(); ++__it)\n+\t    if (this->_M_key_equals(__k, *__it._M_cur))\n+\t      return __it;\n+\t  return end();\n+\t}\n+\n       __hash_code __code = this->_M_hash_code(__k);\n       std::size_t __bkt = _M_bucket_index(__code);\n       return const_iterator(_M_find_node(__bkt, __k, __code));\n@@ -1855,6 +1883,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n #endif\n \n+  // Find the node before the one whose key compares equal to k.\n+  // Return nullptr if no node is found.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    auto\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_find_before_node(const key_type& __k)\n+    -> __node_base_ptr\n+    {\n+      __node_base_ptr __prev_p = &_M_before_begin;\n+      if (!__prev_p->_M_nxt)\n+\treturn nullptr;\n+\n+      for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);\n+\t   __p != nullptr;\n+\t   __p = __p->_M_next())\n+\t{\n+\t  if (this->_M_key_equals(__k, *__p))\n+\t    return __prev_p;\n+\n+\t  __prev_p = __p;\n+\t}\n+\n+      return nullptr;\n+    }\n+\n   // Find the node before the one whose key compares equal to k in the bucket\n   // bkt. Return nullptr if no node is found.\n   template<typename _Key, typename _Value, typename _Alloc,\n@@ -2003,11 +2060,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// First build the node to get access to the hash code\n \t_Scoped_node __node { this, std::forward<_Args>(__args)...  };\n \tconst key_type& __k = _ExtractKey{}(__node._M_node->_M_v());\n+\tif (size() <= __small_size_threshold())\n+\t  {\n+\t    for (auto __it = begin(); __it != end(); ++__it)\n+\t      if (this->_M_key_equals(__k, *__it._M_cur))\n+\t\t// There is already an equivalent node, no insertion\n+\t\treturn { __it, false };\n+\t  }\n+\n \t__hash_code __code = this->_M_hash_code(__k);\n \tsize_type __bkt = _M_bucket_index(__code);\n-\tif (__node_ptr __p = _M_find_node(__bkt, __k, __code))\n-\t  // There is already an equivalent node, no insertion\n-\t  return std::make_pair(iterator(__p), false);\n+\tif (size() > __small_size_threshold())\n+\t  if (__node_ptr __p = _M_find_node(__bkt, __k, __code))\n+\t    // There is already an equivalent node, no insertion\n+\t    return { iterator(__p), false };\n \n \t// Insert the node\n \tauto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);\n@@ -2031,13 +2097,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Scoped_node __node { this, std::forward<_Args>(__args)...  };\n \tconst key_type& __k = _ExtractKey{}(__node._M_node->_M_v());\n \n-\t__hash_code __code = this->_M_hash_code(__k);\n+\tauto __res = this->_M_compute_hash_code(__hint, __k);\n \tauto __pos\n-\t  = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);\n+\t  = _M_insert_multi_node(__res.first._M_cur, __res.second,\n+\t\t\t\t __node._M_node);\n \t__node._M_node = nullptr;\n \treturn __pos;\n       }\n \n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n+    auto\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_compute_hash_code(const_iterator __hint, const key_type& __k) const\n+    -> pair<const_iterator, __hash_code>\n+    {\n+      if (size() <= __small_size_threshold())\n+\t{\n+\t  if (__hint != cend())\n+\t    {\n+\t      for (auto __it = __hint; __it != cend(); ++__it)\n+\t\tif (this->_M_key_equals(__k, *__it._M_cur))\n+\t\t  return { __it, this->_M_hash_code(*__it._M_cur) };\n+\t    }\n+\n+\t  for (auto __it = cbegin(); __it != __hint; ++__it)\n+\t    if (this->_M_key_equals(__k, *__it._M_cur))\n+\t      return { __it, this->_M_hash_code(*__it._M_cur) };\n+\t}\n+\n+      return { __hint, this->_M_hash_code(__k) };\n+    }\n+\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _Hash, typename _RangeHash, typename _Unused,\n@@ -2136,11 +2230,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t       const _NodeGenerator& __node_gen)\n       -> pair<iterator, bool>\n       {\n+\tif (size() <= __small_size_threshold())\n+\t  for (auto __it = begin(); __it != end(); ++__it)\n+\t    if (this->_M_key_equals_tr(__k, *__it._M_cur))\n+\t      return { __it, false };\n+\n \t__hash_code __code = this->_M_hash_code_tr(__k);\n \tsize_type __bkt = _M_bucket_index(__code);\n \n-\tif (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))\n-\t  return { iterator(__node), false };\n+\tif (size() > __small_size_threshold())\n+\t  if (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))\n+\t    return { iterator(__node), false };\n \n \t_Scoped_node __node {\n \t  __node_builder_t::_S_build(std::forward<_Kt>(__k),\n@@ -2172,11 +2272,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n \n \t// Second compute the hash code so that we don't rehash if it throws.\n-\t__hash_code __code\n-\t  = this->_M_hash_code(_ExtractKey{}(__node._M_node->_M_v()));\n+\tauto __res = this->_M_compute_hash_code(\n+\t  __hint, _ExtractKey{}(__node._M_node->_M_v()));\n \n \tauto __pos\n-\t  = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);\n+\t  = _M_insert_multi_node(__res.first._M_cur, __res.second,\n+\t\t\t\t __node._M_node);\n \t__node._M_node = nullptr;\n \treturn __pos;\n       }\n@@ -2239,16 +2340,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_erase(true_type /* __uks */, const key_type& __k)\n     -> size_type\n     {\n-      __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__code);\n+      __node_base_ptr __prev_n;\n+      __node_ptr __n;\n+      std::size_t __bkt;\n+      if (size() <= __small_size_threshold())\n+\t{\n+\t  __prev_n = _M_find_before_node(__k);\n+\t  if (!__prev_n)\n+\t    return 0;\n \n-      // Look for the node before the first matching node.\n-      __node_base_ptr __prev_n = _M_find_before_node(__bkt, __k, __code);\n-      if (!__prev_n)\n-\treturn 0;\n+\t  // We found a matching node, erase it.\n+\t  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n+\t  __bkt = _M_bucket_index(*__n);\n+\t}\n+      else\n+\t{\n+\t  __hash_code __code = this->_M_hash_code(__k);\n+\t  __bkt = _M_bucket_index(__code);\n+\n+\t  // Look for the node before the first matching node.\n+\t  __prev_n = _M_find_before_node(__bkt, __k, __code);\n+\t  if (!__prev_n)\n+\t    return 0;\n+\n+\t  // We found a matching node, erase it.\n+\t  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n+\t}\n \n-      // We found a matching node, erase it.\n-      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n       _M_erase(__bkt, __prev_n, __n);\n       return 1;\n     }\n@@ -2263,21 +2381,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_erase(false_type /* __uks */, const key_type& __k)\n     -> size_type\n     {\n-      __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__code);\n+      std::size_t __bkt;\n+      __node_base_ptr __prev_n;\n+      __node_ptr __n;\n+      if (size() <= __small_size_threshold())\n+\t{\n+\t  __prev_n = _M_find_before_node(__k);\n+\t  if (!__prev_n)\n+\t    return 0;\n \n-      // Look for the node before the first matching node.\n-      __node_base_ptr __prev_n = _M_find_before_node(__bkt, __k, __code);\n-      if (!__prev_n)\n-\treturn 0;\n+\t  // We found a matching node, erase it.\n+\t  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n+\t  __bkt = _M_bucket_index(*__n);\n+\t}\n+      else\n+\t{\n+\t  __hash_code __code = this->_M_hash_code(__k);\n+\t  __bkt = _M_bucket_index(__code);\n+\n+\t  // Look for the node before the first matching node.\n+\t  __prev_n = _M_find_before_node(__bkt, __k, __code);\n+\t  if (!__prev_n)\n+\t    return 0;\n+\n+\t  __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n+\t}\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 526. Is it undefined if a function in the standard changes\n       // in parameters?\n       // We use one loop to find all matching nodes and another to deallocate\n       // them so that the key stays valid during the first loop. It might be\n       // invalidated indirectly when destroying nodes.\n-      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);\n       __node_ptr __n_last = __n->_M_next();\n       while (__n_last && this->_M_node_equals(*__n, *__n_last))\n \t__n_last = __n_last->_M_next();"}, {"sha": "3b60eb9ae7299668ed4fe3bf5e81fdd0b32c35b1", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "patch": "@@ -246,6 +246,20 @@ namespace __detail\n       using __unique_keys = __bool_constant<_Unique_keys>;\n     };\n \n+  /**\n+   *  struct _Hashtable_hash_traits\n+   *\n+   *  Important traits for hash tables depending on associated hasher.\n+   *\n+   */\n+  template<typename _Hash>\n+    struct _Hashtable_hash_traits\n+    {\n+      static constexpr std::size_t\n+      __small_size_threshold() noexcept\n+      { return std::__is_fast_hash<_Hash>::value ? 0 : 20; }\n+    };\n+\n   /**\n    *  struct _Hash_node_base\n    *\n@@ -1105,10 +1119,12 @@ namespace __detail\n \t\t\t_Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,\n \t\t\ttrue_type /* Has load factor */>\n     {\n+    private:\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t     _Equal, _Hash, _RangeHash, _Unused,\n \t\t\t\t     _RehashPolicy, _Traits>;\n \n+    public:\n       float\n       max_load_factor() const noexcept\n       {\n@@ -1263,6 +1279,14 @@ namespace __detail\n \t\tconst _Hash_node_value<_Value, __cache_hash_code>& __n) const\n \t{ return _M_hash_code(_ExtractKey{}(__n._M_v())); }\n \n+      __hash_code\n+      _M_hash_code(const _Hash_node_value<_Value, false>& __n) const\n+      { return _M_hash_code(_ExtractKey{}(__n._M_v())); }\n+\n+      __hash_code\n+      _M_hash_code(const _Hash_node_value<_Value, true>& __n) const\n+      { return __n._M_hash_code; }\n+\n       std::size_t\n       _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const\n       { return _RangeHash{}(__c, __bkt_count); }\n@@ -1641,35 +1665,48 @@ namespace __detail\n       { }\n \n       bool\n-      _M_equals(const _Key& __k, __hash_code __c,\n-\t\tconst _Hash_node_value<_Value, __hash_cached::value>& __n) const\n+      _M_key_equals(const _Key& __k,\n+\t\t    const _Hash_node_value<_Value,\n+\t\t\t\t\t   __hash_cached::value>& __n) const\n       {\n \tstatic_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},\n \t  \"key equality predicate must be invocable with two arguments of \"\n \t  \"key type\");\n-\treturn _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n+\treturn _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n       }\n \n       template<typename _Kt>\n \tbool\n-\t_M_equals_tr(const _Kt& __k, __hash_code __c,\n-\t\t     const _Hash_node_value<_Value,\n-\t\t\t\t\t    __hash_cached::value>& __n) const\n+\t_M_key_equals_tr(const _Kt& __k,\n+\t\t\t const _Hash_node_value<_Value,\n+\t\t\t\t\t     __hash_cached::value>& __n) const\n \t{\n \t  static_assert(\n \t    __is_invocable<const _Equal&, const _Kt&, const _Key&>{},\n \t    \"key equality predicate must be invocable with two arguments of \"\n \t    \"key type\");\n-\t  return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n+\t  return _M_eq()(__k, _ExtractKey{}(__n._M_v()));\n \t}\n \n+      bool\n+      _M_equals(const _Key& __k, __hash_code __c,\n+\t\tconst _Hash_node_value<_Value, __hash_cached::value>& __n) const\n+      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }\n+\n+      template<typename _Kt>\n+\tbool\n+\t_M_equals_tr(const _Kt& __k, __hash_code __c,\n+\t\t     const _Hash_node_value<_Value,\n+\t\t\t\t\t    __hash_cached::value>& __n) const\n+\t{ return _S_equals(__c, __n) && _M_key_equals_tr(__k, __n); }\n+\n       bool\n       _M_node_equals(\n \tconst _Hash_node_value<_Value, __hash_cached::value>& __lhn,\n \tconst _Hash_node_value<_Value, __hash_cached::value>& __rhn) const\n       {\n \treturn _S_node_equals(__lhn, __rhn)\n-\t  && _M_eq()(_ExtractKey{}(__lhn._M_v()), _ExtractKey{}(__rhn._M_v()));\n+\t  && _M_key_equals(_ExtractKey{}(__lhn._M_v()), __rhn);\n       }\n \n       void"}, {"sha": "b42f436e9ce42f2a6cdd4d758f448adf8a615ef2", "filename": "libstdc++-v3/src/c++11/hashtable_c++0x.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc?ref=e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "patch": "@@ -30,6 +30,7 @@\n #include <tuple>\n #include <ext/aligned_buffer.h>\n #include <ext/alloc_traits.h>\n+#include <bits/functional_hash.h>\n #include <bits/hashtable_policy.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "ae63c15b5da90eb217ae30ee49e776e5d98f800f", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert_erase/unordered_small_size.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2Funordered_small_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2Funordered_small_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2Funordered_small_size.cc?ref=e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "patch": "@@ -0,0 +1,125 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <sstream>\n+#include <vector>\n+#include <unordered_set>\n+#include <testsuite_performance.h>\n+\n+namespace\n+{\n+  const int nb_elements = 20;\n+  const int nb_insts = 150000;\n+\n+  template<typename _ElemType>\n+    void bench(const char* desc, const std::vector<_ElemType>& elems)\n+    {\n+      using namespace __gnu_test;\n+\n+      time_counter time;\n+      resource_counter resource;\n+\n+      std::vector<std::unordered_set<_ElemType>> insts(nb_insts);\n+      for (int j = 0; j != nb_insts; ++j)\n+\tinsts.emplace_back();\n+\n+      start_counters(time, resource);\n+\n+      for (auto& us : insts)\n+\tfor (int i = 0; i != nb_elements; ++i)\n+\t  us.insert(elems[i]);\n+\n+      stop_counters(time, resource);\n+\n+      std::ostringstream ostr;\n+      ostr << desc << \" 1st insert\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+      start_counters(time, resource);\n+\n+      for (auto& us : insts)\n+\tfor (int i = nb_elements - 1; i >= 0; --i)\n+\t  {\n+\t    auto it = us.find(elems[i]);\n+\t    if (it != us.end())\n+\t      us.erase(it);\n+\t  }\n+\n+      stop_counters(time, resource);\n+\n+      ostr.str(\"\");\n+      ostr << desc << \" find/erase\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+      start_counters(time, resource);\n+\n+      for (auto& us : insts)\n+\t{\n+\t  us.insert(elems[0]);\n+\t  for (int i = nb_elements - 1; i >= 0; --i)\n+\t    us.insert(elems[i]);\n+\t}\n+\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \" 2nd insert\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+      start_counters(time, resource);\n+\n+      for (auto& us : insts)\n+\tfor (int j = nb_elements - 1; j >= 0; --j)\n+\t  us.erase(elems[j]);\n+\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \" erase key \";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+    }\n+}\n+\n+int main()\n+{\n+  {\n+    std::vector<int> elems;\n+    elems.reserve(nb_elements);\n+    for (int i = 0; i != nb_elements; ++i)\n+      elems.push_back(i);\n+\n+    bench(\"std::unordered_set<int>:    \", elems);\n+  }\n+\n+  {\n+    std::vector<std::string> elems;\n+    {\n+      elems.reserve(nb_elements);\n+      for (int i = 0; i != nb_elements; ++i)\n+\t{\n+\t  std::ostringstream ostr;\n+\t  ostr << \"string #\" << i << ' ' << std::string(1000, 'a' + i);\n+\t  elems.push_back(ostr.str());\n+\t}\n+    }\n+\n+    bench(\"std::unordered_set<string>: \", elems);\n+  }\n+\n+  return 0;\n+}"}, {"sha": "2e05bef8460ef592aeebdde152ebcafc959a17c3", "filename": "libstdc++-v3/testsuite/util/testsuite_performance.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_performance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3ef832a9e8d6a950a439e34e576eb4cb202dc48/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_performance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_performance.h?ref=e3ef832a9e8d6a950a439e34e576eb4cb202dc48", "patch": "@@ -239,7 +239,7 @@ namespace __gnu_test\n     out << std::setw(4) << t.real_time() << \"r\" << space;\n     out << std::setw(4) << t.user_time() << \"u\" << space;\n     out << std::setw(4) << t.system_time() << \"s\" << space;\n-    out << std::setw(8) << r.allocated_memory() << \"mem\" << space;\n+    out << std::setw(9) << r.allocated_memory() << \"mem\" << space;\n     out << std::setw(4) << r.hard_page_fault() << \"pf\" << space;\n \n     out << std::endl;"}]}