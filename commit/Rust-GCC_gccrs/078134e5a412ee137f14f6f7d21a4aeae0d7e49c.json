{"sha": "078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4MTM0ZTVhNDEyZWUxMzdmMTRmNmY3ZDIxYTRhZWFlMGQ3ZTQ5Yw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2016-10-25T08:35:17Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2016-10-25T08:35:17Z"}, "message": "New avt target pass to work around performance loss by PR fix.\n\ngcc/\n\tNew avt target pass to work around performance loss by PR fix.\n\tPR target/71676\n\tPR target/71678\n\t* config/avr/avr.md (casesi_<mode>_sequence) [qi,hi]: New insn.\n\t(*cmp<mode>) [qi,qq,uqq,hi,hq,uhq,ha,uha]: Rename to cmp<mode>3.\n\t* config/avr/predicates.md (extend_operator): New.\n\t* config/avr/avr-passes.def (avr_pass_casesi): Register new pass.\n\t* config/avr/avr-protos.h (avr_casei_sequence_check_operands)\n\t(make_avr_pass_casesi): New prototypes.\n\t* config/avr/avr.c (print-rtl.h): Include it.\n\t(pass_data avr_pass_data_casesi): Data for new pass.\n\t(avr_pass_casesi): New class implementing rtl_opt_pass .avr-casesi.\n\t(make_avr_pass_casesi, avr_parallel_insn_from_insns)\n\t(avr_is_casesi_sequence, avr_casei_sequence_check_operands)\n\t(avr_optimize_casesi): New functions.\ngcc/testsuite/\n\tPR target/71676\n\tPR target/71678\n\t* gcc.target/avr/pr71676-2.c: New test.\n\nFrom-SVN: r241504", "tree": {"sha": "897f2cea4b36b4f0f68afebad404e621814b4005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897f2cea4b36b4f0f68afebad404e621814b4005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7212a155c2f3fdf585f7693159aa4d932d9a585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7212a155c2f3fdf585f7693159aa4d932d9a585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7212a155c2f3fdf585f7693159aa4d932d9a585"}], "stats": {"total": 518, "additions": 510, "deletions": 8}, "files": [{"sha": "4385936330927e28361a73f3e8a8c965ab9a14cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -1,3 +1,22 @@\n+2016-10-25  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tNew avt target pass to work around performance loss by PR fix.\n+\n+\tPR target/71676\n+\tPR target/71678\n+\t* config/avr/avr.md (casesi_<mode>_sequence) [qi,hi]: New insn.\n+\t(*cmp<mode>) [qi,qq,uqq,hi,hq,uhq,ha,uha]: Rename to cmp<mode>3.\n+\t* config/avr/predicates.md (extend_operator): New.\n+\t* config/avr/avr-passes.def (avr_pass_casesi): Register new pass.\n+\t* config/avr/avr-protos.h (avr_casei_sequence_check_operands)\n+\t(make_avr_pass_casesi): New prototypes.\n+\t* config/avr/avr.c (print-rtl.h): Include it.\n+\t(pass_data avr_pass_data_casesi): Data for new pass.\n+\t(avr_pass_casesi): New class implementing rtl_opt_pass .avr-casesi.\n+\t(make_avr_pass_casesi, avr_parallel_insn_from_insns)\n+\t(avr_is_casesi_sequence, avr_casei_sequence_check_operands)\n+\t(avr_optimize_casesi): New functions.\n+\n 2016-10-25  Georg-Johann Lay  <avr@gjlay.de>\n \t    Pitchumani Sivanupandi <pitchumani.sivanupandi@microchip.com>\n "}, {"sha": "b536a22ddd6adcde2b70464ed9e48f08566ba418", "filename": "gcc/config/avr/avr-passes.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-passes.def?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -17,6 +17,17 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* casesi uses a SImode switch index which is quite costly as most code will\n+   work on HImode or QImode.  The following pass runs right after .expand and\n+   tries to fix such situations by operating on the original mode.  This\n+   reduces code size and register pressure.\n+\n+   The assertion is that the code generated by casesi is unaltered and a\n+   a sign-extend or zero-extend from QImode or HImode precedes the casesi\n+   insns withaout any insns in between.  */\n+\n+INSERT_PASS_AFTER (pass_expand, 1, avr_pass_casesi);\n+\n /* This avr-specific pass (re)computes insn notes, in particular REG_DEAD\n    notes which are used by `avr.c::reg_unused_after' and branch offset\n    computations.  These notes must be correct, i.e. there must be no"}, {"sha": "9238f5163ab85eb0951dd405ac65e38ec4bcecc5", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -129,6 +129,7 @@ extern bool avr_mem_memx_p (rtx);\n extern bool avr_load_libgcc_p (rtx);\n extern bool avr_xload_libgcc_p (machine_mode);\n extern rtx avr_eval_addr_attrib (rtx x);\n+extern bool avr_casei_sequence_check_operands (rtx *xop);\n \n static inline unsigned\n regmask (machine_mode mode, unsigned regno)\n@@ -158,6 +159,7 @@ namespace gcc { class context; }\n class rtl_opt_pass;\n \n extern rtl_opt_pass *make_avr_pass_recompute_notes (gcc::context *);\n+extern rtl_opt_pass *make_avr_pass_casesi (gcc::context *);\n \n /* From avr-log.c */\n "}, {"sha": "7ad2b6422b01f791d10696cc928a132a691b443c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -48,6 +48,7 @@\n #include \"builtins.h\"\n #include \"context.h\"\n #include \"tree-pass.h\"\n+#include \"print-rtl.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -334,6 +335,41 @@ class avr_pass_recompute_notes : public rtl_opt_pass\n   }\n }; // avr_pass_recompute_notes\n \n+static const pass_data avr_pass_data_casesi =\n+{\n+  RTL_PASS,      // type\n+  \"\",            // name (will be patched)\n+  OPTGROUP_NONE, // optinfo_flags\n+  TV_DF_SCAN,    // tv_id\n+  0,             // properties_required\n+  0,             // properties_provided\n+  0,             // properties_destroyed\n+  0,             // todo_flags_start\n+  0              // todo_flags_finish\n+};\n+\n+\n+class avr_pass_casesi : public rtl_opt_pass\n+{\n+public:\n+  avr_pass_casesi (gcc::context *ctxt, const char *name)\n+    : rtl_opt_pass (avr_pass_data_casesi, ctxt)\n+  {\n+    this->name = name;\n+  }\n+\n+  void avr_rest_of_handle_casesi (function*);\n+\n+  virtual bool gate (function*) { return optimize > 0; }\n+\n+  virtual unsigned int execute (function *func)\n+  {\n+    avr_rest_of_handle_casesi (func);\n+\n+    return 0;\n+  }\n+}; // avr_pass_casesi\n+\n } // anon namespace\n \n rtl_opt_pass*\n@@ -342,6 +378,320 @@ make_avr_pass_recompute_notes (gcc::context *ctxt)\n   return new avr_pass_recompute_notes (ctxt, \"avr-notes-free-cfg\");\n }\n \n+rtl_opt_pass*\n+make_avr_pass_casesi (gcc::context *ctxt)\n+{\n+  return new avr_pass_casesi (ctxt, \"avr-casesi\");\n+}\n+\n+\n+/* Make one parallel insn with all the patterns from insns i[0]..i[5].  */\n+\n+static rtx_insn*\n+avr_parallel_insn_from_insns (rtx_insn *i[6])\n+{\n+  rtvec vec = gen_rtvec (6, PATTERN (i[0]), PATTERN (i[1]), PATTERN (i[2]),\n+                         PATTERN (i[3]), PATTERN (i[4]), PATTERN (i[5]));\n+  start_sequence();\n+  emit (gen_rtx_PARALLEL (VOIDmode, vec));\n+  rtx_insn *insn = get_insns();\n+  end_sequence();\n+\n+  return insn;\n+}\n+\n+\n+/* Return true if we see an insn stream generated by casesi expander together\n+   with an extension to SImode of the switch value.\n+\n+   If this is the case, fill in the insns from casesi to INSNS[1..5] and\n+   the SImode extension to INSNS[0].  Moreover, extract the operands of\n+   pattern casesi_<mode>_sequence forged from the sequence to recog_data.  */\n+   \n+static bool\n+avr_is_casesi_sequence (basic_block bb, rtx_insn *insn, rtx_insn *insns[6])\n+{\n+  rtx set_5, set_0;\n+\n+  /* A first and quick test for a casesi sequences.  As a side effect of\n+     the test, harvest respective insns to INSNS[0..5].  */\n+\n+  if (!(JUMP_P (insns[5] = insn)\n+        // casesi is the only insn that comes up with UNSPEC_INDEX_JMP,\n+        // hence the following test ensures that we are actually dealing\n+        // with code from casesi.\n+        && (set_5 = single_set (insns[5]))\n+        && UNSPEC == GET_CODE (SET_SRC (set_5))\n+        && UNSPEC_INDEX_JMP == XINT (SET_SRC (set_5), 1)\n+\n+        && (insns[4] = prev_real_insn (insns[5]))\n+        && (insns[3] = prev_real_insn (insns[4]))\n+        && (insns[2] = prev_real_insn (insns[3]))\n+        && (insns[1] = prev_real_insn (insns[2]))\n+\n+        // Insn prior to casesi.\n+        && (insns[0] = prev_real_insn (insns[1]))\n+        && (set_0 = single_set (insns[0]))\n+        && extend_operator (SET_SRC (set_0), SImode)))\n+    {\n+      return false;\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; Sequence from casesi in \"\n+               \"[bb %d]:\\n\\n\", bb->index);\n+      for (int i = 0; i < 6; i++)\n+        print_rtl_single (dump_file, insns[i]);\n+    }\n+\n+  /* We have to deal with quite some operands.  Extracting them by hand\n+     would be tedious, therefore wrap the insn patterns into a parallel,\n+     run recog against it and then use insn extract to get the operands. */\n+\n+  rtx_insn *xinsn = avr_parallel_insn_from_insns (insns);\n+\n+  INSN_CODE (xinsn) = recog (PATTERN (xinsn), xinsn, NULL /* num_clobbers */);\n+\n+  /* Failing to recognize means that someone changed the casesi expander or\n+     that some passes prior to this one performed some unexpected changes.\n+     Gracefully drop such situations instead of aborting.  */\n+\n+  if (INSN_CODE (xinsn) < 0)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; Sequence not recognized, giving up.\\n\\n\");\n+\n+      return false;\n+    }\n+\n+  gcc_assert (CODE_FOR_casesi_qi_sequence == INSN_CODE (xinsn)\n+              || CODE_FOR_casesi_hi_sequence == INSN_CODE (xinsn));\n+\n+  extract_insn (xinsn);\n+\n+  // Assert on the anatomy of xinsn's operands we are going to work with.\n+\n+  gcc_assert (11 == recog_data.n_operands);\n+  gcc_assert (4 == recog_data.n_dups);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; Operands extracted:\\n\");\n+      for (int i = 0; i < recog_data.n_operands; i++)\n+        avr_fdump (dump_file, \";; $%d = %r\\n\", i, recog_data.operand[i]);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Perform some extra checks on operands of casesi_<mode>_sequence.\n+   Not all operand dependencies can be described by means of predicates.\n+   This function performs left over checks and should always return true.\n+   Returning false means that someone changed the casesi expander but did\n+   not adjust casesi_<mode>_sequence.  */\n+\n+bool\n+avr_casei_sequence_check_operands (rtx *xop)\n+{\n+  rtx sub_5 = NULL_RTX;\n+\n+  if (AVR_HAVE_EIJMP_EICALL\n+      // The last clobber op of the tablejump.\n+      && xop[8] == all_regs_rtx[24])\n+    {\n+      // $6 is: (subreg:SI ($5) 0)\n+      sub_5 = xop[6];\n+    }\n+\n+  if (!AVR_HAVE_EIJMP_EICALL\n+      // $6 is: (plus:HI (subreg:SI ($5) 0)\n+      //                 (label_ref ($3)))\n+      && PLUS == GET_CODE (xop[6])\n+      && LABEL_REF == GET_CODE (XEXP (xop[6], 1))\n+      && rtx_equal_p (xop[3], XEXP (XEXP (xop[6], 1), 0))\n+      // The last clobber op of the tablejump.\n+      && xop[8] == const0_rtx)\n+    {\n+      sub_5 = XEXP (xop[6], 0);\n+    }\n+\n+  if (sub_5\n+      && SUBREG_P (sub_5)\n+      && 0 == SUBREG_BYTE (sub_5)\n+      && rtx_equal_p (xop[5], SUBREG_REG (sub_5)))\n+    return true;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Failed condition for casesi_<mode>_sequence\\n\\n\");\n+\n+  return false;\n+}\n+\n+\n+/* INSNS[1..5] is a sequence as generated by casesi and INSNS[0] is an\n+   extension of an 8-bit or 16-bit integer to SImode.  XOP contains the\n+   operands of INSNS as extracted by insn_extract from pattern\n+   casesi_<mode>_sequence:\n+\n+      $0: SImode reg switch value as result of $9.\n+      $1: Negative of smallest index in switch.\n+      $2: Number of entries in switch.\n+      $3: Label to table.\n+      $4: Label if out-of-bounds.\n+      $5: $0 + $1.\n+      $6: 3-byte PC: subreg:HI ($5) + label_ref ($3)\n+          2-byte PC: subreg:HI ($5)\n+      $7: HI reg index into table (Z or pseudo)\n+      $8: R24 or const0_rtx (to be clobbered)\n+      $9: Extension to SImode of an 8-bit or 16-bit integer register $10.\n+      $10: QImode or HImode register input of $9.\n+\n+   Try to optimize this sequence, i.e. use the original HImode / QImode\n+   switch value instead of SImode.  */\n+\n+static void\n+avr_optimize_casesi (rtx_insn *insns[6], rtx *xop)\n+{\n+  // Original mode of the switch value; this is QImode or HImode.\n+  machine_mode mode = GET_MODE (xop[10]);\n+\n+  // How the original switch value was extended to SImode; this is\n+  // SIGN_EXTEND or ZERO_EXTEND.\n+  enum rtx_code code = GET_CODE (xop[9]);\n+\n+  // Lower index, upper index (plus one) and range of case calues.\n+  HOST_WIDE_INT low_idx = -INTVAL (xop[1]);\n+  HOST_WIDE_INT num_idx = INTVAL (xop[2]);\n+  HOST_WIDE_INT hig_idx = low_idx + num_idx;\n+\n+  // Maximum ranges of (un)signed QImode resp. HImode.\n+  int imin = QImode == mode ? INT8_MIN : INT16_MIN;\n+  int imax = QImode == mode ? INT8_MAX : INT16_MAX;\n+  unsigned umax = QImode == mode ? UINT8_MAX : UINT16_MAX;\n+\n+  // Testing the case range and whether it fits into the range of the\n+  // (un)signed mode.  This test should actually always pass because it\n+  // makes no sense to have case values outside the mode range.  Notice\n+  // that case labels which are unreachable because they are outside the\n+  // mode of the switch value (e.g. \"case -1\" for uint8_t) have already\n+  // been thrown away by the middle-end.\n+\n+  if (SIGN_EXTEND == code\n+      && low_idx >= imin\n+      && hig_idx <= imax)\n+    {\n+      // ok\n+    }\n+  else if (ZERO_EXTEND == code\n+           && low_idx >= 0\n+           && (unsigned) hig_idx <= umax)\n+    {\n+      // ok\n+    }\n+  else\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; Case ranges too big, giving up.\\n\\n\");\n+      return;\n+    }\n+\n+  // Do normalization of switch value $10 and out-of-bound check in its\n+  // original mode instead of in SImode.  Use a newly created pseudo.\n+  // This will replace insns[1..2].\n+\n+  start_sequence();\n+\n+  rtx_insn *seq1, *seq2, *last1, *last2;\n+\n+  rtx reg = copy_to_mode_reg (mode, xop[10]);\n+\n+  rtx (*gen_add)(rtx,rtx,rtx) = QImode == mode ? gen_addqi3 : gen_addhi3;\n+  rtx (*gen_cmp)(rtx,rtx) = QImode == mode ? gen_cmpqi3 : gen_cmphi3;\n+\n+  emit_insn (gen_add (reg, reg, gen_int_mode (-low_idx, mode)));\n+  emit_insn (gen_cmp (reg, gen_int_mode (num_idx, mode)));\n+\n+  seq1 = get_insns();\n+  last1 = get_last_insn();\n+  end_sequence();\n+\n+  emit_insn_before (seq1, insns[1]);\n+\n+  // After the out-of-bounds test and corresponding branch, use a\n+  // 16-bit index.  If QImode is used, extend it to HImode first.\n+  // This will replace insns[4].\n+\n+  start_sequence();\n+\n+  if (QImode == mode)\n+    reg = force_reg (HImode, gen_rtx_fmt_e (code, HImode, reg));\n+\n+  rtx pat_4 = AVR_3_BYTE_PC\n+    ? gen_movhi (xop[7], reg)\n+    : gen_addhi3 (xop[7], reg, gen_rtx_LABEL_REF (VOIDmode, xop[3]));\n+\n+  emit_insn (pat_4);\n+\n+  seq2 = get_insns();\n+  last2 = get_last_insn();\n+  end_sequence();\n+\n+  emit_insn_after (seq2, insns[4]);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; New insns: \");\n+\n+      for (rtx_insn *insn = seq1; ; insn = NEXT_INSN (insn))\n+        {\n+          fprintf (dump_file, \"%d, \", INSN_UID (insn));\n+          if (insn == last1)\n+            break;\n+        }\n+      for (rtx_insn *insn = seq2; ; insn = NEXT_INSN (insn))\n+        {\n+          fprintf (dump_file, \"%d%s\", INSN_UID (insn),\n+                   insn == last2 ? \".\\n\\n\" : \", \");\n+          if (insn == last2)\n+            break;\n+        }\n+\n+      fprintf (dump_file, \";; Deleting insns: %d, %d, %d.\\n\\n\",\n+               INSN_UID (insns[1]), INSN_UID (insns[2]), INSN_UID (insns[4]));\n+    }\n+\n+  // Pseudodelete the SImode and subreg of SImode insns.  We don't care\n+  // about the extension insns[0]: Its result is now unused and other\n+  // passes will clean it up.\n+\n+  SET_INSN_DELETED (insns[1]);\n+  SET_INSN_DELETED (insns[2]);\n+  SET_INSN_DELETED (insns[4]);\n+}\n+\n+\n+void\n+avr_pass_casesi::avr_rest_of_handle_casesi (function *func)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, func)\n+    {\n+      rtx_insn *insn, *insns[6];\n+\n+      FOR_BB_INSNS (bb, insn)\n+        {\n+          if (avr_is_casesi_sequence (bb, insn, insns))\n+            {\n+              avr_optimize_casesi (insns, recog_data.operand);\n+            }\n+        }\n+    }\n+}\n+\n \n /* Set `avr_arch' as specified by `-mmcu='.\n    Return true on success.  */"}, {"sha": "cfc6b8d0dc702112220c69f2ca2525e54ba30dc8", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -4598,9 +4598,9 @@\n    (set_attr \"length\" \"4\")])\n \n \n-;; \"*cmpqi\"\n-;; \"*cmpqq\" \"*cmpuqq\"\n-(define_insn \"*cmp<mode>\"\n+;; \"cmpqi3\"\n+;; \"cmpqq3\" \"cmpuqq3\"\n+(define_insn \"cmp<mode>3\"\n   [(set (cc0)\n         (compare (match_operand:ALL1 0 \"register_operand\"  \"r  ,r,d\")\n                  (match_operand:ALL1 1 \"nonmemory_operand\" \"Y00,r,i\")))]\n@@ -4640,10 +4640,10 @@\n   [(set_attr \"cc\" \"compare\")\n    (set_attr \"length\" \"2\")])\n \n-;; \"*cmphi\"\n-;; \"*cmphq\" \"*cmpuhq\"\n-;; \"*cmpha\" \"*cmpuha\"\n-(define_insn \"*cmp<mode>\"\n+;; \"cmphi3\"\n+;; \"cmphq3\" \"cmpuhq3\"\n+;; \"cmpha3\" \"cmpuha3\"\n+(define_insn \"cmp<mode>3\"\n   [(set (cc0)\n         (compare (match_operand:ALL2 0 \"register_operand\"  \"!w  ,r  ,r,d ,r  ,d,r\")\n                  (match_operand:ALL2 1 \"nonmemory_operand\"  \"Y00,Y00,r,s ,s  ,M,n Ynn\")))\n@@ -5153,6 +5153,27 @@\n    (set_attr \"cc\" \"clobber\")])\n \n \n+;; FIXME: casesi comes up with an SImode switch value $0 which\n+;;   is quite some overhead because most code would use HI or\n+;;   even QI.  We add an AVR specific pass .avr-casesi which\n+;;   tries to recover from the superfluous extension to SImode.\n+;;\n+;;   Using \"tablejump\" could be a way out, but this also does\n+;;   not perform in a satisfying manner as the middle end will\n+;;   already multiply the table index by 2.  Note that this\n+;;   multiplication is performed by libgcc's __tablejump2__.\n+;;   The multiplication there, however, runs *after* the table\n+;;   start (a byte address) has been added, not before it like\n+;;   \"tablejump\" will do.\n+;;\n+;;   The preferred solution would be to let the middle ends pass\n+;;   down information on the index as an additional casesi operand.\n+;;\n+;;   If this expander is changed, you'll likely have to go through\n+;;   \"casesi_<mode>_sequence\" (used to recog + extract casesi\n+;;   sequences in pass .avr-casesi) and propagate all adjustments\n+;;   also to that pattern and the code of the extra pass.\n+  \n (define_expand \"casesi\"\n   [(parallel [(set (match_dup 5)\n                    (plus:SI (match_operand:SI 0 \"register_operand\")\n@@ -5198,6 +5219,49 @@\n   })\n \n \n+;; This insn is used only for easy operand extraction.\n+;; The elements must match an extension to SImode plus\n+;; a sequence generated by casesi above.\n+\n+;; \"casesi_qi_sequence\"\n+;; \"casesi_hi_sequence\"\n+(define_insn \"casesi_<mode>_sequence\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+        (match_operator:SI 9 \"extend_operator\"\n+                           [(match_operand:QIHI 10 \"register_operand\")]))\n+\n+   ;; What follows is a matcher for code from casesi.\n+   ;; We keep the same operand numbering (except for $9 and $10\n+   ;; which don't appear in casesi).\n+   (parallel [(set (match_operand:SI 5 \"register_operand\")\n+                   (plus:SI (match_dup 0)\n+                            (match_operand:SI 1 \"const_int_operand\")))\n+              (clobber (scratch:QI))])\n+   (parallel [(set (cc0)\n+                   (compare (match_dup 5)\n+                            (match_operand:SI 2 \"const_int_operand\")))\n+              (clobber (scratch:QI))])\n+\n+   (set (pc)\n+        (if_then_else (gtu (cc0)\n+                           (const_int 0))\n+                      (label_ref (match_operand 4))\n+                      (pc)))\n+\n+   (set (match_operand:HI 7 \"register_operand\")\n+        (match_operand:HI 6))\n+\n+   (parallel [(set (pc)\n+                   (unspec:HI [(match_dup 7)] UNSPEC_INDEX_JMP))\n+              (use (label_ref (match_operand 3)))\n+              (clobber (match_dup 7))\n+              (clobber (match_operand:QI 8))])]\n+  \"optimize\n+   && avr_casei_sequence_check_operands (operands)\"\n+  { gcc_unreachable(); }\n+  )\n+\n+\n ;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ;; This instruction sets Z flag\n \n@@ -5550,7 +5614,7 @@\n \n ;; This peephole avoids code like\n ;;\n-;;     TST   Rn     ; *cmpqi\n+;;     TST   Rn     ; cmpqi3\n ;;     BREQ  .+2    ; branch\n ;;     RJMP  .Lm\n ;;"}, {"sha": "6a7a1b98d25145325429ec1f616d14bce5822629", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -178,6 +178,10 @@\n   (and (match_operand 0 \"comparison_operator\")\n        (not (match_code \"gt,gtu,le,leu\"))))\n \n+;; True for SIGN_EXTEND, ZERO_EXTEND.\n+(define_predicate \"extend_operator\"\n+  (match_code \"sign_extend,zero_extend\"))\n+\n ;; Return true if OP is a valid call operand.\n (define_predicate \"call_insn_operand\"\n   (and (match_code \"mem\")"}, {"sha": "4fa3b4f9b6491cf5c78ea6c14b04daeac3e942f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -1,3 +1,9 @@\n+2016-10-25  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/71676\n+\tPR target/71678\n+\t* gcc.target/avr/pr71676-2.c: New test.\n+\n 2016-10-25  Georg-Johann Lay  <avr@gjlay.de>\n \t    Pitchumani Sivanupandi <pitchumani.sivanupandi@microchip.com>\n "}, {"sha": "a3a7a08032d5b6226af92adc4af76f37bf5add53", "filename": "gcc/testsuite/gcc.target/avr/pr71676-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr71676-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/078134e5a412ee137f14f6f7d21a4aeae0d7e49c/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr71676-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr71676-2.c?ref=078134e5a412ee137f14f6f7d21a4aeae0d7e49c", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-dp -w -Os -fno-tree-switch-conversion\" } */\n+\n+#define MK_FUN(NAME, TYP, V)                            \\\n+  unsigned char __attribute__((noinline,noclone))       \\\n+  select_## NAME (TYP x, unsigned char y)               \\\n+  {                                                     \\\n+    switch (x)                                          \\\n+      {                                                 \\\n+      case V + 0: return 0 + y;                         \\\n+      case V + 1: return 1;                             \\\n+      case V + 2: return 2 + y;                         \\\n+      case V + 3: return 3;                             \\\n+      case V + 4: return 4 + y;                         \\\n+      case V + 5: return 5;                             \\\n+      case V + 6: return 6 + y;                         \\\n+      case V + 7: return 7;                             \\\n+      case V + 8: return 8 + y;                         \\\n+      case V + 9: return 9;                             \\\n+      case V + 10: return 10 + y;                       \\\n+      case V + 11: return 11;                           \\\n+      case V + 12: return 12 + y;                       \\\n+      case V + 13: return 13;                           \\\n+      case V + 14: return 14 + y;                       \\\n+      case V + 15: return 15;                           \\\n+      }                                                 \\\n+    return x;                                           \\\n+  }\n+\n+MK_FUN (0_s8, signed char, 0)\n+MK_FUN (0_u8, unsigned char, 0)\n+MK_FUN (0_s16, signed int, 0)\n+MK_FUN (0_u16, unsigned int, 0)\n+\n+MK_FUN (m4_s8, signed char, -4)\n+MK_FUN (m4_u8, unsigned char, -4)\n+MK_FUN (m4_s16, signed int, -4)\n+MK_FUN (m4_u16, unsigned int, -4)\n+\n+MK_FUN (4_s8, signed char, 4)\n+MK_FUN (4_u8, unsigned char, 4)\n+MK_FUN (4_s16, signed int, 4)\n+MK_FUN (4_u16, unsigned int, 4)\n+\n+/* { dg-final { scan-assembler-not \"extendqisi\" } } */\n+/* { dg-final { scan-assembler-not \"extendhisi\" } } */"}]}