{"sha": "9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwM2I3ZjdjYThiNTNmZDM3NWNkM2VlZWYwMDBjZDY3M2U5YWVhMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-05-30T19:04:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-05-30T19:04:09Z"}, "message": "config.gcc (arm-wrs-vxworks): Remove dbxelf.h from tm_file.\n\ngcc/\n\t* config.gcc (arm-wrs-vxworks): Remove dbxelf.h from tm_file.\n\tAdd vx-common.h.  Include vxworks.h between vx-common.h and\n\tarm/vxworks.h.\n\t* config/vx-common.h (DWARF2_UNWIND_INFO): Undefine before\n\tredefining.\n\t* config/vxworks.h (TARGET_ASM_CONSTRUCTOR): Likewise.\n\t(TARGET_ASM_DESTRUCTOR): Likewise.\n\t* config/arm/vxworks.h (TARGET_OS_CPP_BUILTINS): Check arm_arch_xscale\n\tinstead of arm_is_xscale.  Use VXWORKS_OS_CPP_BUILTINS.\n\t(OVERRIDE_OPTIONS, SUBTARGET_CPP_SPEC): Define.\n\t(CC1_SPEC): Add -tstrongarm.  Line up backslashes.\n\t(VXWORKS_ENDIAN_SPEC): Define.\n\t(ASM_SPEC): Add VXWORKS_ENDIAN_SPEC.\n\t(LIB_SPEC, STARTFILE_SPEC, ENDFILE_SPEC): Redefine to their\n\tVXWORKS_* equivalents.\n\t(LINK_SPEC): Likewise, but add VXWORKS_ENDIAN_SPEC.\n\t(ASM_FILE_START): Delete.\n\t(TARGET_VERSION): Reformat.\n\t(FPUTYPE_DEFAULT, FUNCTION_PROFILER): Define.\n\t(DEFAULT_STRUCTURE_SIZE_BOUNDARY): Define.\n\t* config/arm/t-vxworks (LIB1ASMSRC, LIB1ASMFUNCS): Define.\n\t(FPBIT, DPBIT): Define.\n\t(fp-bit.c, dp-bit.c): New rules.\n\t(MULTILIB_OPTIONS): Add strongarm, -mrtp and -mrtp/-fPIC multilibs.\n\t(MULTILIB_MATCHES, MULTILIB_EXCEPTIONS): Define.\n\t* config/arm/arm-protos.h (arm_emit_call_insn): Declare.\n\t* config/arm/arm.h: Include vxworks-dummy.h.\n\t* config/arm/arm.c (arm_elf_asm_constructor, arm_elf_asm_destructor):\n\tMark with ATTRIBUTE_UNUSED.\n\t(arm_override_options): Do not allow VxWorks RTP PIC to be used\n\tfor Thumb.  Force r9 to be the PIC register for VxWorks RTPs and\n\tmake it incompatible with -msingle-pic-base.\n\t(arm_function_ok_for_sibcall): Return false for calls that might\n\tgo through a VxWorks PIC PLT entry.\n\t(require_pic_register): New function, split out from...\n\t(legitimize_pic_address): ...here.  Do not use GOTOFF accesses\n\tfor VxWorks RTPs.\n\t(arm_load_pic_register): Handle the VxWorks RTP initialization\n\tsequence.  Use pic_reg as a shorthand for cfun->machine->pic_reg.\n\t(arm_emit_call_insn): New function.\n\t(arm_assemble_integer): Do not use GOTOFF accesses for VxWorks RTP.\n\t* config/arm/arm.md (UNSPEC_PIC_OFFSET): New unspec number.\n\t(pic_offset_arm): New pattern.\n\t(call, call_value): Use arm_emit_call_insn.\n\t(call_internal, call_value_internal): New expanders.\n\t* config/arm/lib1funcs.asm (__PLT__): Define to empty for\n\tVxWorks unless __PIC__.\n\nFrom-SVN: r125196", "tree": {"sha": "baff0d3a538bb698c45e8ef4c45ce55e481960cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baff0d3a538bb698c45e8ef4c45ce55e481960cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/comments", "author": null, "committer": null, "parents": [{"sha": "f52ae0770fce807982338b7018c30c7c6cf77d3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52ae0770fce807982338b7018c30c7c6cf77d3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f52ae0770fce807982338b7018c30c7c6cf77d3a"}], "stats": {"total": 490, "additions": 344, "deletions": 146}, "files": [{"sha": "940dd314fd18062f85b710feb0a3cdeaf0c6b801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -1,3 +1,53 @@\n+2007-05-30  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config.gcc (arm-wrs-vxworks): Remove dbxelf.h from tm_file.\n+\tAdd vx-common.h.  Include vxworks.h between vx-common.h and\n+\tarm/vxworks.h.\n+\t* config/vx-common.h (DWARF2_UNWIND_INFO): Undefine before\n+\tredefining.\n+\t* config/vxworks.h (TARGET_ASM_CONSTRUCTOR): Likewise.\n+\t(TARGET_ASM_DESTRUCTOR): Likewise.\n+\t* config/arm/vxworks.h (TARGET_OS_CPP_BUILTINS): Check arm_arch_xscale\n+\tinstead of arm_is_xscale.  Use VXWORKS_OS_CPP_BUILTINS.\n+\t(OVERRIDE_OPTIONS, SUBTARGET_CPP_SPEC): Define.\n+\t(CC1_SPEC): Add -tstrongarm.  Line up backslashes.\n+\t(VXWORKS_ENDIAN_SPEC): Define.\n+\t(ASM_SPEC): Add VXWORKS_ENDIAN_SPEC.\n+\t(LIB_SPEC, STARTFILE_SPEC, ENDFILE_SPEC): Redefine to their\n+\tVXWORKS_* equivalents.\n+\t(LINK_SPEC): Likewise, but add VXWORKS_ENDIAN_SPEC.\n+\t(ASM_FILE_START): Delete.\n+\t(TARGET_VERSION): Reformat.\n+\t(FPUTYPE_DEFAULT, FUNCTION_PROFILER): Define.\n+\t(DEFAULT_STRUCTURE_SIZE_BOUNDARY): Define.\n+\t* config/arm/t-vxworks (LIB1ASMSRC, LIB1ASMFUNCS): Define.\n+\t(FPBIT, DPBIT): Define.\n+\t(fp-bit.c, dp-bit.c): New rules.\n+\t(MULTILIB_OPTIONS): Add strongarm, -mrtp and -mrtp/-fPIC multilibs.\n+\t(MULTILIB_MATCHES, MULTILIB_EXCEPTIONS): Define.\n+\t* config/arm/arm-protos.h (arm_emit_call_insn): Declare.\n+\t* config/arm/arm.h: Include vxworks-dummy.h.\n+\t* config/arm/arm.c (arm_elf_asm_constructor, arm_elf_asm_destructor):\n+\tMark with ATTRIBUTE_UNUSED.\n+\t(arm_override_options): Do not allow VxWorks RTP PIC to be used\n+\tfor Thumb.  Force r9 to be the PIC register for VxWorks RTPs and\n+\tmake it incompatible with -msingle-pic-base.\n+\t(arm_function_ok_for_sibcall): Return false for calls that might\n+\tgo through a VxWorks PIC PLT entry.\n+\t(require_pic_register): New function, split out from...\n+\t(legitimize_pic_address): ...here.  Do not use GOTOFF accesses\n+\tfor VxWorks RTPs.\n+\t(arm_load_pic_register): Handle the VxWorks RTP initialization\n+\tsequence.  Use pic_reg as a shorthand for cfun->machine->pic_reg.\n+\t(arm_emit_call_insn): New function.\n+\t(arm_assemble_integer): Do not use GOTOFF accesses for VxWorks RTP.\n+\t* config/arm/arm.md (UNSPEC_PIC_OFFSET): New unspec number.\n+\t(pic_offset_arm): New pattern.\n+\t(call, call_value): Use arm_emit_call_insn.\n+\t(call_internal, call_value_internal): New expanders.\n+\t* config/arm/lib1funcs.asm (__PLT__): Define to empty for\n+\tVxWorks unless __PIC__.\n+\n 2007-05-30  Eric Christopher  <echristo@gmail.com>\n \n \t* genrecog.c: Include regs.h in generated file."}, {"sha": "1b7caa86238cc96c65a571e6b885719cb1a13407", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -697,7 +697,7 @@ arm-semi-aof | armel-semi-aof)\n \ttmake_file=\"arm/t-arm arm/t-semi\"\n \t;;\n arm-wrs-vxworks)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h vxworks.h arm/elf.h arm/aout.h ${tm_file} arm/vxworks.h\"\n+\ttm_file=\"elfos.h svr4.h arm/elf.h arm/aout.h ${tm_file} vx-common.h vxworks.h arm/vxworks.h\"\n \ttmake_file=\"${tmake_file} arm/t-arm arm/t-vxworks\"\n \t;;\n arm*-*-freebsd*|strongarm*-*-freebsd*)"}, {"sha": "ea812711af103f16b1481c96d281465620b35a7e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -102,6 +102,7 @@ extern void arm_reload_out_hi (rtx *);\n extern int arm_const_double_inline_cost (rtx);\n extern bool arm_const_double_by_parts (rtx);\n extern const char *fp_immediate_constant (rtx);\n+extern void arm_emit_call_insn (rtx, rtx);\n extern const char *output_call (rtx *);\n extern const char *output_call_mem (rtx *);\n extern const char *output_mov_long_double_fpa_from_arm (rtx *);"}, {"sha": "587b74f0af73bfd66133cbb70d28440550f2a8cf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 179, "deletions": 105, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -148,8 +148,8 @@ static int arm_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n \n #ifdef OBJECT_FORMAT_ELF\n-static void arm_elf_asm_constructor (rtx, int);\n-static void arm_elf_asm_destructor (rtx, int);\n+static void arm_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;\n+static void arm_elf_asm_destructor (rtx, int) ATTRIBUTE_UNUSED;\n #endif\n #ifndef ARM_PE\n static void arm_encode_section_info (tree, rtx, int);\n@@ -1338,10 +1338,23 @@ arm_override_options (void)\n \t\t ARM_DOUBLEWORD_ALIGN ? \"8, 32 or 64\": \"8 or 32\");\n     }\n \n+  if (!TARGET_ARM && TARGET_VXWORKS_RTP && flag_pic)\n+    {\n+      error (\"RTP PIC is incompatible with Thumb\");\n+      flag_pic = 0;\n+    }\n+\n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  The EABI specifies r9 as the PIC register.  */\n   if (flag_pic && TARGET_SINGLE_PIC_BASE)\n-    arm_pic_register = (TARGET_APCS_STACK || TARGET_AAPCS_BASED) ? 9 : 10;\n+    {\n+      if (TARGET_VXWORKS_RTP)\n+\twarning (0, \"RTP PIC is incompatible with -msingle-pic-base\");\n+      arm_pic_register = (TARGET_APCS_STACK || TARGET_AAPCS_BASED) ? 9 : 10;\n+    }\n+\n+  if (flag_pic && TARGET_VXWORKS_RTP)\n+    arm_pic_register = 9;\n \n   if (arm_pic_register_string != NULL)\n     {\n@@ -1354,7 +1367,9 @@ arm_override_options (void)\n       else if (pic_register < 0 || call_used_regs[pic_register]\n \t       || pic_register == HARD_FRAME_POINTER_REGNUM\n \t       || pic_register == STACK_POINTER_REGNUM\n-\t       || pic_register >= PC_REGNUM)\n+\t       || pic_register >= PC_REGNUM\n+\t       || (TARGET_VXWORKS_RTP\n+\t\t   && (unsigned int) pic_register != arm_pic_register))\n \terror (\"unable to use '%s' for PIC register\", arm_pic_register_string);\n       else\n \tarm_pic_register = pic_register;\n@@ -3214,6 +3229,11 @@ arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n   if (decl == NULL || TARGET_THUMB)\n     return false;\n \n+  /* The PIC register is live on entry to VxWorks PLT entries, so we\n+     must make the call before restoring the PIC register.  */\n+  if (TARGET_VXWORKS_RTP && flag_pic && !targetm.binds_local_p (decl))\n+    return false;\n+\n   /* Cannot tail-call to long calls, since these are out of range of\n      a branch instruction.  */\n   if (arm_is_long_call_p (decl))\n@@ -3255,6 +3275,54 @@ legitimate_pic_operand_p (rtx x)\n   return 1;\n }\n \n+/* Record that the current function needs a PIC register.  Initialize\n+   cfun->machine->pic_reg if we have not already done so.  */\n+\n+static void\n+require_pic_register (void)\n+{\n+  /* A lot of the logic here is made obscure by the fact that this\n+     routine gets called as part of the rtx cost estimation process.\n+     We don't want those calls to affect any assumptions about the real\n+     function; and further, we can't call entry_of_function() until we\n+     start the real expansion process.  */\n+  if (!current_function_uses_pic_offset_table)\n+    {\n+      gcc_assert (!no_new_pseudos);\n+      if (arm_pic_register != INVALID_REGNUM)\n+\t{\n+\t  cfun->machine->pic_reg = gen_rtx_REG (Pmode, arm_pic_register);\n+\n+\t  /* Play games to avoid marking the function as needing pic\n+\t     if we are being called as part of the cost-estimation\n+\t     process.  */\n+\t  if (current_ir_type () != IR_GIMPLE)\n+\t    current_function_uses_pic_offset_table = 1;\n+\t}\n+      else\n+\t{\n+\t  rtx seq;\n+\n+\t  cfun->machine->pic_reg = gen_reg_rtx (Pmode);\n+\n+\t  /* Play games to avoid marking the function as needing pic\n+\t     if we are being called as part of the cost-estimation\n+\t     process.  */\n+\t  if (current_ir_type () != IR_GIMPLE)\n+\t    {\n+\t      current_function_uses_pic_offset_table = 1;\n+\t      start_sequence ();\n+\n+\t      arm_load_pic_register (0UL);\n+\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\t      emit_insn_after (seq, entry_of_function ());\n+\t    }\n+\t}\n+    }\n+}\n+\n rtx\n legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n {\n@@ -3267,48 +3335,8 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       rtx insn;\n       int subregs = 0;\n \n-      /* If this function doesn't have a pic register, create one now.\n-\t A lot of the logic here is made obscure by the fact that this\n-\t routine gets called as part of the rtx cost estimation\n-\t process.  We don't want those calls to affect any assumptions\n-\t about the real function; and further, we can't call\n-\t entry_of_function() until we start the real expansion\n-\t process.  */\n-      if (!current_function_uses_pic_offset_table)\n-\t{\n-\t  gcc_assert (!no_new_pseudos);\n-\t  if (arm_pic_register != INVALID_REGNUM)\n-\t    {\n-\t      cfun->machine->pic_reg = gen_rtx_REG (Pmode, arm_pic_register);\n-\n-\t      /* Play games to avoid marking the function as needing pic\n-\t\t if we are being called as part of the cost-estimation\n-\t\t process.  */\n-\t      if (current_ir_type () != IR_GIMPLE)\n-\t\tcurrent_function_uses_pic_offset_table = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx seq;\n-\n-\t      cfun->machine->pic_reg = gen_reg_rtx (Pmode);\n-\n-\t      /* Play games to avoid marking the function as needing pic\n-\t\t if we are being called as part of the cost-estimation\n-\t\t process.  */\n-\t      if (current_ir_type () != IR_GIMPLE)\n-\t\t{\n-\t\t  current_function_uses_pic_offset_table = 1;\n-\t\t  start_sequence ();\n-\n-\t\t  arm_load_pic_register (0UL);\n-\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insn_after (seq, entry_of_function ());\n-\t\t}\n-\t    }\n-\t}\n+      /* If this function doesn't have a pic register, create one now.  */\n+      require_pic_register ();\n \n       if (reg == 0)\n \t{\n@@ -3335,10 +3363,17 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       else /* TARGET_THUMB1 */\n \temit_insn (gen_pic_load_addr_thumb1 (address, orig));\n \n+      /* VxWorks does not impose a fixed gap between segments; the run-time\n+\t gap can be different from the object-file gap.  We therefore can't\n+\t use GOTOFF unless we are absolutely sure that the symbol is in the\n+\t same segment as the GOT.  Unfortunately, the flexibility of linker\n+\t scripts means that we can't be sure of that in general, so assume\n+\t that GOTOFF is never valid on VxWorks.  */\n       if ((GET_CODE (orig) == LABEL_REF\n \t   || (GET_CODE (orig) == SYMBOL_REF &&\n \t       SYMBOL_REF_LOCAL_P (orig)))\n-\t  && NEED_GOT_RELOC)\n+\t  && NEED_GOT_RELOC\n+\t  && !TARGET_VXWORKS_RTP)\n \tpic_ref = gen_rtx_PLUS (Pmode, cfun->machine->pic_reg, address);\n       else\n \t{\n@@ -3478,80 +3513,96 @@ void\n arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n {\n #ifndef AOF_ASSEMBLER\n-  rtx l1, labelno, pic_tmp, pic_tmp2, pic_rtx;\n+  rtx l1, labelno, pic_tmp, pic_tmp2, pic_rtx, pic_reg;\n   rtx global_offset_table;\n \n   if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n     return;\n \n   gcc_assert (flag_pic);\n \n-  /* We use an UNSPEC rather than a LABEL_REF because this label never appears\n-     in the code stream.  */\n-\n-  labelno = GEN_INT (pic_labelno++);\n-  l1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n-  l1 = gen_rtx_CONST (VOIDmode, l1);\n-\n-  global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-  /* On the ARM the PC register contains 'dot + 8' at the time of the\n-     addition, on the Thumb it is 'dot + 4'.  */\n-  pic_tmp = plus_constant (l1, TARGET_ARM ? 8 : 4);\n-  if (GOT_PCREL)\n-    pic_tmp2 = gen_rtx_CONST (VOIDmode,\n-\t\t\t    gen_rtx_PLUS (Pmode, global_offset_table, pc_rtx));\n-  else\n-    pic_tmp2 = gen_rtx_CONST (VOIDmode, global_offset_table);\n+  pic_reg = cfun->machine->pic_reg;\n+  if (TARGET_VXWORKS_RTP)\n+    {\n+      pic_rtx = gen_rtx_SYMBOL_REF (Pmode, VXWORKS_GOTT_BASE);\n+      pic_rtx = gen_rtx_CONST (Pmode, pic_rtx);\n+      emit_insn (gen_pic_load_addr_arm (pic_reg, pic_rtx));\n \n-  pic_rtx = gen_rtx_CONST (Pmode, gen_rtx_MINUS (Pmode, pic_tmp2, pic_tmp));\n+      emit_insn (gen_rtx_SET (Pmode, pic_reg, gen_rtx_MEM (Pmode, pic_reg)));\n \n-  if (TARGET_ARM)\n-    {\n-      emit_insn (gen_pic_load_addr_arm (cfun->machine->pic_reg, pic_rtx));\n-      emit_insn (gen_pic_add_dot_plus_eight (cfun->machine->pic_reg,\n-\t\t\t\t\t     cfun->machine->pic_reg, labelno));\n+      pic_tmp = gen_rtx_SYMBOL_REF (Pmode, VXWORKS_GOTT_INDEX);\n+      emit_insn (gen_pic_offset_arm (pic_reg, pic_reg, pic_tmp));\n     }\n-  else if (TARGET_THUMB2)\n+  else\n     {\n-      /* Thumb-2 only allows very limited access to the PC.  Calculate the\n-\t address in a temporary register.  */\n-      if (arm_pic_register != INVALID_REGNUM)\n+      /* We use an UNSPEC rather than a LABEL_REF because this label\n+\t never appears in the code stream.  */\n+\n+      labelno = GEN_INT (pic_labelno++);\n+      l1 = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);\n+      l1 = gen_rtx_CONST (VOIDmode, l1);\n+\n+      global_offset_table\n+\t= gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+      /* On the ARM the PC register contains 'dot + 8' at the time of the\n+\t addition, on the Thumb it is 'dot + 4'.  */\n+      pic_tmp = plus_constant (l1, TARGET_ARM ? 8 : 4);\n+      if (GOT_PCREL)\n \t{\n-\t  pic_tmp = gen_rtx_REG (SImode,\n-\t\t\t\t thumb_find_work_register (saved_regs));\n+\t  pic_tmp2 = gen_rtx_PLUS (Pmode, global_offset_table, pc_rtx);\n+\t  pic_tmp2 = gen_rtx_CONST (VOIDmode, pic_tmp2);\n \t}\n       else\n+\tpic_tmp2 = gen_rtx_CONST (VOIDmode, global_offset_table);\n+\n+      pic_rtx = gen_rtx_MINUS (Pmode, pic_tmp2, pic_tmp);\n+      pic_rtx = gen_rtx_CONST (Pmode, pic_rtx);\n+\n+      if (TARGET_ARM)\n \t{\n-\t  gcc_assert (!no_new_pseudos);\n-\t  pic_tmp = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_pic_load_addr_arm (pic_reg, pic_rtx));\n+\t  emit_insn (gen_pic_add_dot_plus_eight (pic_reg, pic_reg, labelno));\n \t}\n+      else if (TARGET_THUMB2)\n+\t{\n+\t  /* Thumb-2 only allows very limited access to the PC.  Calculate the\n+\t     address in a temporary register.  */\n+\t  if (arm_pic_register != INVALID_REGNUM)\n+\t    {\n+\t      pic_tmp = gen_rtx_REG (SImode,\n+\t\t\t\t     thumb_find_work_register (saved_regs));\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (!no_new_pseudos);\n+\t      pic_tmp = gen_reg_rtx (Pmode);\n+\t    }\n \n-      emit_insn (gen_pic_load_addr_thumb2 (cfun->machine->pic_reg, pic_rtx));\n-      emit_insn (gen_pic_load_dot_plus_four (pic_tmp, labelno));\n-      emit_insn (gen_addsi3(cfun->machine->pic_reg, cfun->machine->pic_reg,\n-\t\t\t    pic_tmp));\n-    }\n-  else /* TARGET_THUMB1 */\n-    {\n-      if (arm_pic_register != INVALID_REGNUM\n-\t  && REGNO (cfun->machine->pic_reg) > LAST_LO_REGNUM)\n+\t  emit_insn (gen_pic_load_addr_thumb2 (pic_reg, pic_rtx));\n+\t  emit_insn (gen_pic_load_dot_plus_four (pic_tmp, labelno));\n+\t  emit_insn (gen_addsi3 (pic_reg, pic_reg, pic_tmp));\n+\t}\n+      else /* TARGET_THUMB1 */\n \t{\n-\t  /* We will have pushed the pic register, so we should always be\n-\t     able to find a work register.  */\n-\t  pic_tmp = gen_rtx_REG (SImode,\n-\t\t\t\t thumb_find_work_register (saved_regs));\n-\t  emit_insn (gen_pic_load_addr_thumb1 (pic_tmp, pic_rtx));\n-\t  emit_insn (gen_movsi (pic_offset_table_rtx, pic_tmp));\n+\t  if (arm_pic_register != INVALID_REGNUM\n+\t      && REGNO (pic_reg) > LAST_LO_REGNUM)\n+\t    {\n+\t      /* We will have pushed the pic register, so we should always be\n+\t\t able to find a work register.  */\n+\t      pic_tmp = gen_rtx_REG (SImode,\n+\t\t\t\t     thumb_find_work_register (saved_regs));\n+\t      emit_insn (gen_pic_load_addr_thumb1 (pic_tmp, pic_rtx));\n+\t      emit_insn (gen_movsi (pic_offset_table_rtx, pic_tmp));\n+\t    }\n+\t  else\n+\t    emit_insn (gen_pic_load_addr_thumb1 (pic_reg, pic_rtx));\n+\t  emit_insn (gen_pic_add_dot_plus_four (pic_reg, pic_reg, labelno));\n \t}\n-      else\n-\temit_insn (gen_pic_load_addr_thumb1 (cfun->machine->pic_reg, pic_rtx));\n-      emit_insn (gen_pic_add_dot_plus_four (cfun->machine->pic_reg,\n-\t\t\t\t\t    cfun->machine->pic_reg, labelno));\n     }\n \n   /* Need to emit this whether or not we obey regdecls,\n      since setjmp/longjmp can cause life info to screw up.  */\n-  emit_insn (gen_rtx_USE (VOIDmode, cfun->machine->pic_reg));\n+  emit_insn (gen_rtx_USE (VOIDmode, pic_reg));\n #endif /* AOF_ASSEMBLER */\n }\n \n@@ -8862,6 +8913,30 @@ vfp_emit_fstmd (int base_reg, int count)\n   return count * 8;\n }\n \n+/* Emit a call instruction with pattern PAT.  ADDR is the address of\n+   the call target.  */\n+\n+void\n+arm_emit_call_insn (rtx pat, rtx addr)\n+{\n+  rtx insn;\n+\n+  insn = emit_call_insn (pat);\n+\n+  /* The PIC register is live on entry to VxWorks PIC PLT entries.\n+     If the call might use such an entry, add a use of the PIC register\n+     to the instruction's CALL_INSN_FUNCTION_USAGE.  */\n+  if (TARGET_VXWORKS_RTP\n+      && flag_pic\n+      && GET_CODE (addr) == SYMBOL_REF\n+      && (SYMBOL_REF_DECL (addr)\n+\t  ? !targetm.binds_local_p (SYMBOL_REF_DECL (addr))\n+\t  : !SYMBOL_REF_LOCAL_P (addr)))\n+    {\n+      require_pic_register ();\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), cfun->machine->pic_reg);\n+    }\n+}\n \n /* Output a 'call' insn.  */\n const char *\n@@ -11947,14 +12022,13 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       if (NEED_GOT_RELOC && flag_pic && making_const_table &&\n \t  (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))\n \t{\n-\t  if (GET_CODE (x) == SYMBOL_REF\n-\t      && (CONSTANT_POOL_ADDRESS_P (x)\n-\t\t  || SYMBOL_REF_LOCAL_P (x)))\n-\t    fputs (\"(GOTOFF)\", asm_out_file);\n-\t  else if (GET_CODE (x) == LABEL_REF)\n-\t    fputs (\"(GOTOFF)\", asm_out_file);\n-\t  else\n+\t  /* See legitimize_pic_address for an explanation of the\n+\t     TARGET_VXWORKS_RTP check.  */\n+\t  if (TARGET_VXWORKS_RTP\n+\t      || (GET_CODE (x) == SYMBOL_REF && !SYMBOL_REF_LOCAL_P (x)))\n \t    fputs (\"(GOT)\", asm_out_file);\n+\t  else\n+\t    fputs (\"(GOTOFF)\", asm_out_file);\n \t}\n       fputc ('\\n', asm_out_file);\n       return true;"}, {"sha": "62d7485d01f7035e1f054b6710539d5ebe24e926", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -26,6 +26,8 @@\n #ifndef GCC_ARM_H\n #define GCC_ARM_H\n \n+#include \"config/vxworks-dummy.h\"\n+\n /* The architecture define.  */\n extern char arm_arch_name[];\n "}, {"sha": "664f23d8fe86f85ecdd3a3aa5e0fdc4e5c06d214", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -95,6 +95,8 @@\n                          ; instruction stream.\n    (UNSPEC_STACK_ALIGN 20) ; Doubleword aligned stack pointer.  Used to\n \t\t\t   ; generate correct unwind information.\n+   (UNSPEC_PIC_OFFSET 22) ; A symbolic 12-bit OFFSET that has been treated\n+\t\t\t  ; correctly for PIC usage.\n   ]\n )\n \n@@ -4919,6 +4921,16 @@\n   \"\"\n )\n \n+(define_insn \"pic_offset_arm\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (unspec:SI [(match_operand:SI 2 \"\" \"X\")]\n+\t\t\t\t    UNSPEC_PIC_OFFSET))))]\n+  \"TARGET_VXWORKS_RTP && TARGET_ARM && flag_pic\"\n+  \"ldr%?\\\\t%0, [%1,%2]\"\n+  [(set_attr \"type\" \"load1\")]\n+)\n+\n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0 \"\" \"\"))]\n   \"flag_pic\"\n@@ -8145,7 +8157,7 @@\n   \"TARGET_EITHER\"\n   \"\n   {\n-    rtx callee;\n+    rtx callee, pat;\n     \n     /* In an untyped call, we can get NULL for operand 2.  */\n     if (operands[2] == NULL_RTX)\n@@ -8159,9 +8171,19 @@\n \t? arm_is_long_call_p (SYMBOL_REF_DECL (callee))\n \t: !REG_P (callee))\n       XEXP (operands[0], 0) = force_reg (Pmode, callee);\n+\n+    pat = gen_call_internal (operands[0], operands[1], operands[2]);\n+    arm_emit_call_insn (pat, XEXP (operands[0], 0));\n+    DONE;\n   }\"\n )\n \n+(define_expand \"call_internal\"\n+  [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n+\t            (match_operand 1 \"general_operand\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (clobber (reg:SI LR_REGNUM))])])\n+\n (define_insn \"*call_reg_armv5\"\n   [(call (mem:SI (match_operand:SI 0 \"s_register_operand\" \"r\"))\n          (match_operand 1 \"\" \"\"))\n@@ -8239,7 +8261,7 @@\n   \"TARGET_EITHER\"\n   \"\n   {\n-    rtx callee;\n+    rtx pat, callee;\n     \n     /* In an untyped call, we can get NULL for operand 2.  */\n     if (operands[3] == 0)\n@@ -8253,9 +8275,21 @@\n \t? arm_is_long_call_p (SYMBOL_REF_DECL (callee))\n \t: !REG_P (callee))\n       XEXP (operands[1], 0) = force_reg (Pmode, callee);\n+\n+    pat = gen_call_value_internal (operands[0], operands[1],\n+\t\t\t\t   operands[2], operands[3]);\n+    arm_emit_call_insn (pat, XEXP (operands[1], 0));\n+    DONE;\n   }\"\n )\n \n+(define_expand \"call_value_internal\"\n+  [(parallel [(set (match_operand       0 \"\" \"\")\n+\t           (call (match_operand 1 \"memory_operand\" \"\")\n+\t\t         (match_operand 2 \"general_operand\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n+\t      (clobber (reg:SI LR_REGNUM))])])\n+\n (define_insn \"*call_value_reg_armv5\"\n   [(set (match_operand 0 \"\" \"\")\n         (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))"}, {"sha": "0c6e440e598de160cd41729adac190946f29079c", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -54,6 +54,8 @@ Boston, MA 02110-1301, USA.  */\n #ifdef __ELF__\n #ifdef __thumb__\n #define __PLT__  /* Not supported in Thumb assembler (for now).  */\n+#elif defined __vxworks && !defined __PIC__\n+#define __PLT__ /* Not supported by the kernel loader.  */\n #else\n #define __PLT__ (PLT)\n #endif"}, {"sha": "978aa5ef2f5978dd3d96d86e76ed45f6a9b5def8", "filename": "gcc/config/arm/t-vxworks", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Ft-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Ft-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-vxworks?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -1,10 +1,27 @@\n-# Multilibs for VxWorks.\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func _call_via_rX _interwork_call_via_rX\n \n-MULTILIB_OPTIONS = \\\n-  t4/t4be/t4t/t4tbe/t5/t5be/t5t/t5tbe/txscale/txscalebe\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_DIRNAMES = \\\n-  ARMARCH4gnu ARMARCH4gnube ARMARCH4_Tgnu ARMARCH4_Tgnube \\\n-  ARMARCH5gnu ARMARCH5gnube ARMARCH5_Tgnu ARMARCH5_Tgnube \\\n-  XSCALEgnu XSCALEgnube\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n \n+MULTILIB_OPTIONS = \\\n+  mrtp fPIC \\\n+  t4/t4be/t4t/t4tbe/t5/t5be/t5t/t5tbe/tstrongarm/txscale/txscalebe\n+MULTILIB_MATCHES = fPIC=fpic\n+# Don't build -fPIC multilibs for kernel or Thumb code.\n+MULTILIB_EXCEPTIONS = fPIC* mrtp/fPIC/*t[45]t*"}, {"sha": "e3f2be0c6659cac224bdd1535a03362373f47978", "filename": "gcc/config/arm/vxworks.h", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Farm%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvxworks.h?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -25,13 +25,12 @@ Boston, MA 02110-1301, USA.  */\n \n #define TARGET_OS_CPP_BUILTINS()\t\t\\\n   do {\t\t\t\t\t\t\\\n-    builtin_define (\"__vxworks\");\t\t\\\n     if (TARGET_BIG_END)\t\t\t\t\\\n       builtin_define (\"ARMEB\");\t\t\t\\\n     else\t\t\t\t\t\\\n       builtin_define (\"ARMEL\");\t\t\t\\\n \t\t\t\t\t\t\\\n-    if (arm_is_xscale)\t\t\t\t\\\n+    if (arm_arch_xscale)\t\t\t\\\n       builtin_define (\"CPU=XSCALE\");\t\t\\\n     else if (arm_arch5)\t\t\t\t\\\n       builtin_define (\"CPU=ARMARCH5\");\t\t\\\n@@ -42,54 +41,70 @@ Boston, MA 02110-1301, USA.  */\n \telse\t\t\t\t\t\\\n \t  builtin_define (\"CPU=ARMARCH4\");\t\\\n       }\t\t\t\t\t\t\\\n+    VXWORKS_OS_CPP_BUILTINS ();\t\t\t\\\n   } while (0)\n \n+#undef OVERRIDE_OPTIONS\n+#define OVERRIDE_OPTIONS\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      VXWORKS_OVERRIDE_OPTIONS;\t\t\t\\\n+      arm_override_options ();\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Subsume the arm/elf.h definition, and add RTP hooks.  */\n+#undef SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC \"-D__ELF__\" VXWORKS_ADDITIONAL_CPP_SPEC\n+\n #undef  CC1_SPEC\n #define CC1_SPEC\t\t\t\t\t\t\t\\\n-\"%{t4:        -mlittle-endian -march=armv4 ;\t\t\t\\\n-   t4be:      -mbig-endian -march=armv4 ;\t\t\t\\\n+\"%{tstrongarm:-mlittle-endian -mcpu=strongarm ;\t\t\t\t\\\n+   t4:        -mlittle-endian -march=armv4 ;\t\t\t\t\\\n+   t4be:      -mbig-endian -march=armv4 ;\t\t\t\t\\\n    t4t:       -mthumb -mthumb-interwork -mlittle-endian -march=armv4t ;\t\\\n    t4tbe:     -mthumb -mthumb-interwork -mbig-endian -march=armv4t ;\t\\\n-   t5:        -mlittle-endian -march=armv5 ;\t\t\t\\\n-   t5be:      -mbig-endian -march=armv5 ;\t\t\t\\\n+   t5:        -mlittle-endian -march=armv5 ;\t\t\t\t\\\n+   t5be:      -mbig-endian -march=armv5 ;\t\t\t\t\\\n    t5t:       -mthumb -mthumb-interwork -mlittle-endian -march=armv5 ;\t\\\n    t5tbe:     -mthumb -mthumb-interwork -mbig-endian -march=armv5 ;\t\\\n-   txscale:   -mlittle-endian -mcpu=xscale ;\t\t\t\\\n-   txscalebe: -mbig-endian -mcpu=xscale ;\t\t\t\\\n+   txscale:   -mlittle-endian -mcpu=xscale ;\t\t\t\t\\\n+   txscalebe: -mbig-endian -mcpu=xscale ;\t\t\t\t\\\n             : -march=armv4}\"\n \n+/* Pass -EB for big-endian targets.  */\n+#define VXWORKS_ENDIAN_SPEC \\\n+  \"%{mbig-endian|t4be|t4tbe|t5be|t5tbe|txscalebe:-EB}\"\n+\n /* The -Q options from svr4.h aren't understood and must be removed.  */\n #undef  ASM_SPEC\n #define ASM_SPEC \\\n-  \"%{v:-V} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n+  \"%{v:-V} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \" VXWORKS_ENDIAN_SPEC\n \n-/* VxWorks does all the library stuff itself.  */\n-#undef  LIB_SPEC\n-#define LIB_SPEC \t\"\"\n+#undef LINK_SPEC\n+#define LINK_SPEC VXWORKS_LINK_SPEC \" \" VXWORKS_ENDIAN_SPEC\n \n-/* VxWorks uses object files, not loadable images.  make linker just\n-   combine objects.  */\n-#undef  LINK_SPEC\n-#define LINK_SPEC \t\"-r\"\n+#undef LIB_SPEC\n+#define LIB_SPEC VXWORKS_LIB_SPEC\n \n-/* VxWorks provides the functionality of crt0.o and friends itself.  */\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \t\"\"\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC VXWORKS_STARTFILE_SPEC\n \n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC \t\"\"\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC VXWORKS_ENDFILE_SPEC\n \n-#undef  TARGET_VERSION\n-#define TARGET_VERSION\tfputs (\" (ARM/VxWorks)\", stderr);\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (ARM/VxWorks)\", stderr);\n \n /* There is no default multilib.  */\n #undef MULTILIB_DEFAULTS\n \n-#undef  ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \t\t\t\t\t\t\\\n-  do \t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"%s Generated by GCC %s for ARM/VxWorks\\n\",\t\\\n-\t       ASM_COMMENT_START, version_string);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+#define FPUTYPE_DEFAULT FPUTYPE_VFP\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER VXWORKS_FUNCTION_PROFILER\n+\n+/* We want to be compatible with a version of \"2.96\" at one point in\n+   the past before this macro was changed.  */\n+#undef DEFAULT_STRUCTURE_SIZE_BOUNDARY\n+#define DEFAULT_STRUCTURE_SIZE_BOUNDARY 8"}, {"sha": "d2ae6739347ed2dde95e17adf072388a901842fd", "filename": "gcc/config/vx-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Fvx-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Fvx-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvx-common.h?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -63,6 +63,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define WINT_TYPE_SIZE 16\n \n /* Dwarf2 unwind info is not supported.  */\n+#undef DWARF2_UNWIND_INFO\n #define DWARF2_UNWIND_INFO 0\n \n /* VxWorks uses DWARF2.  */"}, {"sha": "c97537162323fd85adc0012f9a1e0b4d578f3477", "filename": "gcc/config/vxworks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9403b7f7ca8b53fd375cd3eeef000cd673e9aea1/gcc%2Fconfig%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.h?ref=9403b7f7ca8b53fd375cd3eeef000cd673e9aea1", "patch": "@@ -92,7 +92,9 @@ extern void vxworks_override_options (void);\n \n /* VxWorks requires special handling of constructors and destructors.\n    All VxWorks configurations must use these functions.  */\n+#undef TARGET_ASM_CONSTRUCTOR\n #define TARGET_ASM_CONSTRUCTOR vxworks_asm_out_constructor\n+#undef TARGET_ASM_DESTRUCTOR\n #define TARGET_ASM_DESTRUCTOR vxworks_asm_out_destructor\n extern void vxworks_asm_out_constructor (rtx symbol, int priority);\n extern void vxworks_asm_out_destructor (rtx symbol, int priority);"}]}