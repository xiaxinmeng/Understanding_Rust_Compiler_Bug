{"sha": "cab54dfa3ad330dd2ccb876e85112cc4363786d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FiNTRkZmEzYWQzMzBkZDJjY2I4NzZlODUxMTJjYzQzNjM3ODZkNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-10-21T22:12:46Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-10-21T22:12:46Z"}, "message": "i386-protos.h (memory_address_length): Add new bool argument.\n\n\t* config/i386/i386-protos.h (memory_address_length): Add new bool\n\targument.  Update all uses.\n\t* config/i386/i386.c (memory_address_length): If not LEA insn, then\n\tadd length of addr32 prefix based on mode of base or index register.\n\t(ix86_attr_length_address_default) <TYPE_LEA>: Do not handle SImode\n\taddresses here.  Update call to memory_address_length.\n\t(ix86_print_address_operand): Use SImode_address_operand predicate.\n\t* config/i386/predicates.md (SImode_address_operand): New.\n\t* config/i386/i386.md (lea<mode>): Use SImode_address_operand\n\tto calculate \"mode\" attribute.  Use SImode_address_operand predicate\n\tinstead of open-coding accepted RTX codes.\n\nFrom-SVN: r192660", "tree": {"sha": "b7154eb94cb5fcc8262e1ed94e79ec04396f1824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7154eb94cb5fcc8262e1ed94e79ec04396f1824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cab54dfa3ad330dd2ccb876e85112cc4363786d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab54dfa3ad330dd2ccb876e85112cc4363786d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cab54dfa3ad330dd2ccb876e85112cc4363786d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab54dfa3ad330dd2ccb876e85112cc4363786d5/comments", "author": null, "committer": null, "parents": [{"sha": "84cac7eff72290d1b2a57c75df602a02ffd2f56e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84cac7eff72290d1b2a57c75df602a02ffd2f56e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84cac7eff72290d1b2a57c75df602a02ffd2f56e"}], "stats": {"total": 129, "additions": 72, "deletions": 57}, "files": [{"sha": "f7e2572ee1b39869c8431b6bffdfba9657938f54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cab54dfa3ad330dd2ccb876e85112cc4363786d5", "patch": "@@ -1,3 +1,17 @@\n+2012-10-21  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-protos.h (memory_address_length): Add new bool\n+\targument.  Update all uses.\n+\t* config/i386/i386.c (memory_address_length): If not LEA insn, then\n+\tadd length of addr32 prefix based on mode of base or index register.\n+\t(ix86_attr_length_address_default) <TYPE_LEA>: Do not handle SImode\n+\taddresses here.  Update call to memory_address_length.\n+\t(ix86_print_address_operand): Use SImode_address_operand predicate.\n+\t* config/i386/predicates.md (SImode_address_operand): New.\n+\t* config/i386/i386.md (lea<mode>): Use SImode_address_operand\n+\tto calculate \"mode\" attribute.  Use SImode_address_operand predicate\n+\tinstead of open-coding accepted RTX codes.\n+\n 2012-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* rtl.def (ADDR_DIFF_VEC): Fix comment typo.\n@@ -23,9 +37,10 @@\n \t* calls.c (expand_call): Don't deal specifically with BLKmode values\n \treturned in naked registers.\n \t* expr.h (copy_blkmode_from_reg): Adjust prototype.\n-\t* expr.c (copy_blkmode_from_reg): Rename first parameter into TARGET and\n-\tmake it required.  Assert that SRCREG hasn't BLKmode.  Add a couple of \n-\tshort-circuits for common cases and be prepared for sub-word registers.\n+\t* expr.c (copy_blkmode_from_reg): Rename first parameter into\n+\tTARGET and make it required.  Assert that SRCREG hasn't BLKmode.\n+\tAdd a couple of short-circuits for common cases and be prepared\n+\tfor sub-word registers.\n \t(expand_assignment): Call copy_blkmode_from_reg for BLKmode values\n \treturned in naked registers.\n \t(store_expr): Likewise.\n@@ -61,7 +76,8 @@\n \n 2012-10-19  Jan Hubicka  <jh@suse.cz>\n \n-\t* builtins.def (BUILT_IN_UNREACHABLE): Make ATTR_CONST_NORETURN_NOTHROW_LEAF_LIST.\n+\t* builtins.def (BUILT_IN_UNREACHABLE): Make\n+\tATTR_CONST_NORETURN_NOTHROW_LEAF_LIST.\n \t* builtin-attrs.def (ATTR_CONST_NORETURN_NOTHROW_LEAF_LIST): Define.\n \n 2012-10-19  Michael Meissner  <meissner@linux.vnet.ibm.com>"}, {"sha": "96971aeb628bb6f01ea56b5119fb55f5c7404ca5", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=cab54dfa3ad330dd2ccb876e85112cc4363786d5", "patch": "@@ -282,7 +282,7 @@ struct ix86_address\n };\n \n extern int ix86_decompose_address (rtx, struct ix86_address *);\n-extern int memory_address_length (rtx addr);\n+extern int memory_address_length (rtx, bool);\n extern void x86_output_aligned_bss (FILE *, tree, const char *,\n \t\t\t\t    unsigned HOST_WIDE_INT, int);\n extern void x86_elf_aligned_common (FILE *, const char *,"}, {"sha": "742a34b3185f21c633b2eca643106bab0603f130", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cab54dfa3ad330dd2ccb876e85112cc4363786d5", "patch": "@@ -14979,19 +14979,24 @@ ix86_print_operand_address (FILE *file, rtx addr)\n   else\n     {\n       /* Print SImode register names to force addr32 prefix.  */\n-      if (GET_CODE (addr) == SUBREG)\n-\t{\n-\t  gcc_assert (TARGET_64BIT);\n-\t  gcc_assert (GET_MODE (addr) == SImode);\n-\t  gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n-\t  gcc_assert (!code);\n-\t  code = 'l';\n-\t}\n-      else if (GET_CODE (addr) == ZERO_EXTEND\n-\t       || GET_CODE (addr) == AND)\n+      if (SImode_address_operand (addr, VOIDmode))\n \t{\n+#ifdef ENABLE_CHECKING\n \t  gcc_assert (TARGET_64BIT);\n-\t  gcc_assert (GET_MODE (addr) == DImode);\n+\t  switch (GET_CODE (addr))\n+\t    {\n+\t    case SUBREG:\n+\t      gcc_assert (GET_MODE (addr) == SImode);\n+\t      gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n+\t      break;\n+\t    case ZERO_EXTEND:\n+\t    case AND:\n+\t      gcc_assert (GET_MODE (addr) == DImode);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+#endif\n \t  gcc_assert (!code);\n \t  code = 'l';\n \t}\n@@ -23752,14 +23757,14 @@ assign_386_stack_local (enum machine_mode mode, enum ix86_stack_slot n)\n \f\n /* Calculate the length of the memory address in the instruction encoding.\n    Includes addr32 prefix, does not include the one-byte modrm, opcode,\n-   or other prefixes.  */\n+   or other prefixes.  We never generate addr32 prefix for LEA insn.  */\n \n int\n-memory_address_length (rtx addr)\n+memory_address_length (rtx addr, bool lea)\n {\n   struct ix86_address parts;\n   rtx base, index, disp;\n-  int len;\n+  int len = 0;\n   int ok;\n \n   if (GET_CODE (addr) == PRE_DEC\n@@ -23780,10 +23785,6 @@ memory_address_length (rtx addr)\n   index = parts.index;\n   disp = parts.disp;\n \n-  /* Add length of addr32 prefix.  */\n-  len = (GET_CODE (addr) == ZERO_EXTEND\n-\t || GET_CODE (addr) == AND);\n-\n   /* Rule of thumb:\n        - esp as the base always wants an index,\n        - ebp as the base always wants a displacement,\n@@ -23796,13 +23797,13 @@ memory_address_length (rtx addr)\n       /* esp (for its index) and ebp (for its displacement) need\n \t the two-byte modrm form.  Similarly for r12 and r13 in 64-bit\n \t code.  */\n-      if (REG_P (addr)\n-\t  && (addr == arg_pointer_rtx\n-\t      || addr == frame_pointer_rtx\n-\t      || REGNO (addr) == SP_REG\n-\t      || REGNO (addr) == BP_REG\n-\t      || REGNO (addr) == R12_REG\n-\t      || REGNO (addr) == R13_REG))\n+      if (REG_P (base)\n+\t  && (base == arg_pointer_rtx\n+\t      || base == frame_pointer_rtx\n+\t      || REGNO (base) == SP_REG\n+\t      || REGNO (base) == BP_REG\n+\t      || REGNO (base) == R12_REG\n+\t      || REGNO (base) == R13_REG))\n \tlen = 1;\n     }\n \n@@ -23834,7 +23835,6 @@ memory_address_length (rtx addr)\n \t    len += 1;\n \t}\n     }\n-\n   else\n     {\n       /* Find the length of the displacement constant.  */\n@@ -23870,6 +23870,12 @@ memory_address_length (rtx addr)\n       break;\n     }\n \n+  /*  If this is not LEA instruction, add the length of addr32 prefix.  */\n+  if (TARGET_64BIT && !lea\n+      && ((base && GET_MODE (base) == SImode)\n+\t  || (index && GET_MODE (index) == SImode)))\n+    len += 1;\n+\n   return len;\n }\n \n@@ -23921,7 +23927,8 @@ ix86_attr_length_immediate_default (rtx insn, bool shortform)\n \t  case MODE_SI:\n \t    len = 4;\n \t    break;\n-\t  /* Immediates for DImode instructions are encoded as 32bit sign extended values.  */\n+\t  /* Immediates for DImode instructions are encoded\n+\t     as 32bit sign extended values.  */\n \t  case MODE_DI:\n \t    len = 4;\n \t    break;\n@@ -23931,6 +23938,7 @@ ix86_attr_length_immediate_default (rtx insn, bool shortform)\n       }\n   return len;\n }\n+\n /* Compute default value for \"length_address\" attribute.  */\n int\n ix86_attr_length_address_default (rtx insn)\n@@ -23947,15 +23955,8 @@ ix86_attr_length_address_default (rtx insn)\n       gcc_assert (GET_CODE (set) == SET);\n \n       addr = SET_SRC (set);\n-      if (TARGET_64BIT && get_attr_mode (insn) == MODE_SI)\n-\t{\n-\t  if (GET_CODE (addr) == ZERO_EXTEND)\n-\t    addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) == SUBREG)\n-\t    addr = SUBREG_REG (addr);\n-\t}\n \n-      return memory_address_length (addr);\n+      return memory_address_length (addr, true);\n     }\n \n   extract_insn_cached (insn);\n@@ -23977,7 +23978,7 @@ ix86_attr_length_address_default (rtx insn)\n \t    if (*constraints == 'X')\n \t      continue;\n \t  }\n-\treturn memory_address_length (XEXP (recog_data.operand[i], 0));\n+\treturn memory_address_length (XEXP (recog_data.operand[i], 0), false);\n       }\n   return 0;\n }"}, {"sha": "049d53494f920e1dd5554b767ca5fd5af46817e4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cab54dfa3ad330dd2ccb876e85112cc4363786d5", "patch": "@@ -5494,18 +5494,9 @@\n {\n   rtx addr = operands[1];\n \n-  if (GET_CODE (addr) == SUBREG)\n+  if (SImode_address_operand (addr, VOIDmode))\n     {\n       gcc_assert (TARGET_64BIT);\n-      gcc_assert (<MODE>mode == SImode);\n-      gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n-      return \"lea{l}\\t{%E1, %0|%0, %E1}\";\n-    }\n-  else if (GET_CODE (addr) == ZERO_EXTEND\n-\t   || GET_CODE (addr) == AND)\n-    {\n-      gcc_assert (TARGET_64BIT);\n-      gcc_assert (<MODE>mode == DImode);\n       return \"lea{l}\\t{%E1, %k0|%k0, %E1}\";\n     }\n   else \n@@ -5526,15 +5517,18 @@\n \n   /* Emit all operations in SImode for zero-extended addresses.  Recall\n      that x86_64 inheretly zero-extends SImode operations to DImode.  */\n-  if (GET_CODE (operands[1]) == ZERO_EXTEND\n-      || GET_CODE (operands[1]) == AND)\n+  if (SImode_address_operand (operands[1], VOIDmode))\n     mode = SImode;\n \n   ix86_split_lea_for_addr (curr_insn, operands, mode);\n   DONE;\n }\n   [(set_attr \"type\" \"lea\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set (attr \"mode\")\n+     (if_then_else\n+       (match_operand 1 \"SImode_address_operand\")\n+       (const_string \"SI\")\n+       (const_string \"<MODE>\")))])\n \f\n ;; Add instructions\n \n@@ -17832,7 +17826,7 @@\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"atom_sse_attr\" \"prefetch\")\n    (set (attr \"length_address\")\n-\t(symbol_ref \"memory_address_length (operands[0])\"))\n+\t(symbol_ref \"memory_address_length (operands[0], false)\"))\n    (set_attr \"memory\" \"none\")])\n \n (define_insn \"*prefetch_3dnow\"\n@@ -17848,7 +17842,7 @@\n }\n   [(set_attr \"type\" \"mmx\")\n    (set (attr \"length_address\")\n-\t(symbol_ref \"memory_address_length (operands[0])\"))\n+\t(symbol_ref \"memory_address_length (operands[0], false)\"))\n    (set_attr \"memory\" \"none\")])\n \n (define_expand \"stack_protect_set\""}, {"sha": "4e5c17d8b37c4426c8411142c78c7ddd261d9699", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab54dfa3ad330dd2ccb876e85112cc4363786d5/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=cab54dfa3ad330dd2ccb876e85112cc4363786d5", "patch": "@@ -813,6 +813,10 @@\n   return parts.seg == SEG_DEFAULT;\n })\n \n+;; Return true for RTX codes that force SImode address.\n+(define_predicate \"SImode_address_operand\"\n+  (match_code \"subreg,zero_extend,and\"))\n+\n ;; Return true if op if a valid base register, displacement or\n ;; sum of base register and displacement for VSIB addressing.\n (define_predicate \"vsib_address_operand\"\n@@ -982,7 +986,7 @@\n ;; by the modRM array.\n (define_predicate \"long_memory_operand\"\n   (and (match_operand 0 \"memory_operand\")\n-       (match_test \"memory_address_length (op)\")))\n+       (match_test \"memory_address_length (op, false)\")))\n \n ;; Return true if OP is a comparison operator that can be issued by fcmov.\n (define_predicate \"fcmov_comparison_operator\""}]}