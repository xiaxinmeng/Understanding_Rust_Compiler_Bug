{"sha": "e68035acfd6997ed97eb32aec4f277f3b6858550", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4MDM1YWNmZDY5OTdlZDk3ZWIzMmFlYzRmMjc3ZjNiNjg1ODU1MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-17T23:43:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-17T23:43:08Z"}, "message": "compiler, runtime: allocate defer records on the stack\n    \n    When a defer is executed at most once in a function body,\n    we can allocate the defer record for it on the stack instead\n    of on the heap.\n    \n    This should make defers like this (which are very common) faster.\n    \n    This is a port of CL 171758 from the gc repo.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/190410\n\nFrom-SVN: r274613", "tree": {"sha": "f0e21a4a0680568bf5045771a16e20292aad1cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0e21a4a0680568bf5045771a16e20292aad1cfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e68035acfd6997ed97eb32aec4f277f3b6858550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68035acfd6997ed97eb32aec4f277f3b6858550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68035acfd6997ed97eb32aec4f277f3b6858550", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68035acfd6997ed97eb32aec4f277f3b6858550/comments", "author": null, "committer": null, "parents": [{"sha": "b9a21efdea18862f79c68ceb2eee0704844ead53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a21efdea18862f79c68ceb2eee0704844ead53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a21efdea18862f79c68ceb2eee0704844ead53"}], "stats": {"total": 181, "additions": 176, "deletions": 5}, "files": [{"sha": "ef5bb41c75606c824879e4537588db6ae17235c7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -1,4 +1,4 @@\n-838f926c93898767f0337122725a4f52a1335186\n+4b47cadf938caadf563f8d0bb3f7111d06f61752\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7eac880af6a41c14fe3e7e248d821e206ffeb7c0", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -287,6 +287,10 @@ DEF_GO_RUNTIME(GO, \"__go_go\", P2(UINTPTR, POINTER), R1(POINTER))\n DEF_GO_RUNTIME(DEFERPROC, \"runtime.deferproc\", P3(BOOLPTR, UINTPTR, POINTER),\n \t       R0())\n \n+// Defer a function, with stack-allocated defer structure.\n+DEF_GO_RUNTIME(DEFERPROCSTACK, \"runtime.deferprocStack\",\n+               P4(POINTER, BOOLPTR, UINTPTR, POINTER), R0())\n+\n \n // Convert an empty interface to an empty interface, returning ok.\n DEF_GO_RUNTIME(IFACEE2E2, \"runtime.ifaceE2E2\", P1(EFACE), R2(EFACE, BOOL))"}, {"sha": "27c309e5fdb62597ec96c3e2866646303b69b0ca", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -2614,7 +2614,11 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n   if (this->classification() == STATEMENT_GO)\n     s = Statement::make_go_statement(call, location);\n   else if (this->classification() == STATEMENT_DEFER)\n-    s = Statement::make_defer_statement(call, location);\n+    {\n+      s = Statement::make_defer_statement(call, location);\n+      if ((Node::make_node(this)->encoding() & ESCAPE_MASK) == Node::ESCAPE_NONE)\n+        s->defer_statement()->set_on_stack();\n+    }\n   else\n     go_unreachable();\n \n@@ -3019,13 +3023,45 @@ Defer_statement::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n   Expression* ds = context->function()->func_value()->defer_stack(loc);\n \n-  Expression* call = Runtime::make_call(Runtime::DEFERPROC, loc, 3,\n-\t\t\t\t\tds, fn, arg);\n+  Expression* call;\n+  if (this->on_stack_)\n+    {\n+      if (context->gogo()->debug_optimization())\n+        go_debug(loc, \"stack allocated defer\");\n+\n+      Type* defer_type = Defer_statement::defer_struct_type();\n+      Expression* defer = Expression::make_allocation(defer_type, loc);\n+      defer->allocation_expression()->set_allocate_on_stack();\n+      defer->allocation_expression()->set_no_zero();\n+      call = Runtime::make_call(Runtime::DEFERPROCSTACK, loc, 4,\n+                                defer, ds, fn, arg);\n+    }\n+  else\n+    call = Runtime::make_call(Runtime::DEFERPROC, loc, 3,\n+                              ds, fn, arg);\n   Bexpression* bcall = call->get_backend(context);\n   Bfunction* bfunction = context->function()->func_value()->get_decl();\n   return context->backend()->expression_statement(bfunction, bcall);\n }\n \n+Type*\n+Defer_statement::defer_struct_type()\n+{\n+  Type* ptr_type = Type::make_pointer_type(Type::make_void_type());\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  Type* bool_type = Type::make_boolean_type();\n+  return Type::make_builtin_struct_type(9,\n+                                        \"link\", ptr_type,\n+                                        \"frame\", ptr_type,\n+                                        \"panicStack\", ptr_type,\n+                                        \"_panic\", ptr_type,\n+                                        \"pfn\", uintptr_type,\n+                                        \"arg\", ptr_type,\n+                                        \"retaddr\", uintptr_type,\n+                                        \"makefunccanrecover\", bool_type,\n+                                        \"heap\", bool_type);\n+}\n+\n // Dump the AST representation for defer statement.\n \n void"}, {"sha": "311bbaaca5ebfa5f504a18ead70a5d72088c165e", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -24,6 +24,7 @@ class Expression_statement;\n class Block_statement;\n class Return_statement;\n class Thunk_statement;\n+class Defer_statement;\n class Goto_statement;\n class Goto_unnamed_statement;\n class Label_statement;\n@@ -403,6 +404,11 @@ class Statement\n   Thunk_statement*\n   thunk_statement();\n \n+  // If this is a defer statement, return it.  Otherwise return NULL.\n+  Defer_statement*\n+  defer_statement()\n+  { return this->convert<Defer_statement, STATEMENT_DEFER>(); }\n+\n   // If this is a goto statement, return it.  Otherwise return NULL.\n   Goto_statement*\n   goto_statement()\n@@ -1419,15 +1425,26 @@ class Defer_statement : public Thunk_statement\n {\n  public:\n   Defer_statement(Call_expression* call, Location location)\n-    : Thunk_statement(STATEMENT_DEFER, call, location)\n+    : Thunk_statement(STATEMENT_DEFER, call, location),\n+      on_stack_(false)\n   { }\n \n+  void\n+  set_on_stack()\n+  { this->on_stack_ = true; }\n+\n  protected:\n   Bstatement*\n   do_get_backend(Translate_context*);\n \n   void\n   do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  static Type*\n+  defer_struct_type();\n+\n+  bool on_stack_;\n };\n \n // A goto statement."}, {"sha": "2463a48d4284554f2f51735c3dda20acd7269eb9", "filename": "libgo/go/runtime/mgcmark.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcmark.go?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -657,6 +657,11 @@ func scanstack(gp *g, gcw *gcWork) {\n \t\tscanstackblock(uintptr(unsafe.Pointer(&gp.context)), unsafe.Sizeof(gp.context), gcw)\n \t}\n \n+\t// Note: in the gc runtime scanstack also scans defer records.\n+\t// This is necessary as it uses stack objects (a.k.a. stack tracing).\n+\t// We don't (yet) do stack objects, and regular stack/heap scan\n+\t// will take care of defer records just fine.\n+\n \tgp.gcscanvalid = true\n }\n "}, {"sha": "88c0a4d8fd21303c89c2d00fde4c15f756a5fdcb", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -13,6 +13,7 @@ import (\n // themselves, so that the compiler will export them.\n //\n //go:linkname deferproc runtime.deferproc\n+//go:linkname deferprocStack runtime.deferprocStack\n //go:linkname deferreturn runtime.deferreturn\n //go:linkname setdeferretaddr runtime.setdeferretaddr\n //go:linkname checkdefer runtime.checkdefer\n@@ -124,6 +125,38 @@ func deferproc(frame *bool, pfn uintptr, arg unsafe.Pointer) {\n \td.makefunccanrecover = false\n }\n \n+// deferprocStack queues a new deferred function with a defer record on the stack.\n+// The defer record, d, does not need to be initialized.\n+// Other arguments are the same as in deferproc.\n+//go:nosplit\n+func deferprocStack(d *_defer, frame *bool, pfn uintptr, arg unsafe.Pointer) {\n+\tgp := getg()\n+\tif gp.m.curg != gp {\n+\t\t// go code on the system stack can't defer\n+\t\tthrow(\"defer on system stack\")\n+\t}\n+\td.pfn = pfn\n+\td.retaddr = 0\n+\td.makefunccanrecover = false\n+\td.heap = false\n+\t// The lines below implement:\n+\t//   d.frame = frame\n+\t//   d.arg = arg\n+\t//   d._panic = nil\n+\t//   d.panicStack = gp._panic\n+\t//   d.link = gp._defer\n+\t// But without write barriers. They are writes to the stack so they\n+\t// don't need a write barrier, and furthermore are to uninitialized\n+\t// memory, so they must not use a write barrier.\n+\t*(*uintptr)(unsafe.Pointer(&d.frame)) = uintptr(unsafe.Pointer(frame))\n+\t*(*uintptr)(unsafe.Pointer(&d.arg)) = uintptr(unsafe.Pointer(arg))\n+\t*(*uintptr)(unsafe.Pointer(&d._panic)) = 0\n+\t*(*uintptr)(unsafe.Pointer(&d.panicStack)) = uintptr(unsafe.Pointer(gp._panic))\n+\t*(*uintptr)(unsafe.Pointer(&d.link)) = uintptr(unsafe.Pointer(gp._defer))\n+\n+\tgp._defer = d\n+}\n+\n // Allocate a Defer, usually using per-P pool.\n // Each defer must be released with freedefer.\n func newdefer() *_defer {\n@@ -155,11 +188,13 @@ func newdefer() *_defer {\n \t\t\t// Duplicate the tail below so if there's a\n \t\t\t// crash in checkPut we can tell if d was just\n \t\t\t// allocated or came from the pool.\n+\t\t\td.heap = true\n \t\t\td.link = gp._defer\n \t\t\tgp._defer = d\n \t\t\treturn d\n \t\t}\n \t}\n+\td.heap = true\n \td.link = gp._defer\n \tgp._defer = d\n \treturn d\n@@ -179,6 +214,9 @@ func freedefer(d *_defer) {\n \tif d.pfn != 0 {\n \t\tfreedeferfn()\n \t}\n+\tif !d.heap {\n+\t\treturn\n+\t}\n \tpp := getg().m.p.ptr()\n \tif len(pp.deferpool) == cap(pp.deferpool) {\n \t\t// Transfer half of local cache to the central cache."}, {"sha": "e4dfbdfeaf4959201a3d3503aee8cf4ebb131d81", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -746,6 +746,12 @@ func extendRandom(r []byte, n int) {\n \n // A _defer holds an entry on the list of deferred calls.\n // If you add a field here, add code to clear it in freedefer.\n+// This struct must match the code in Defer_statement::defer_struct_type\n+// in the compiler.\n+// Some defers will be allocated on the stack and some on the heap.\n+// All defers are logically part of the stack, so write barriers to\n+// initialize them are not required. All defers must be manually scanned,\n+// and for heap defers, marked.\n type _defer struct {\n \t// The next entry in the stack.\n \tlink *_defer\n@@ -781,6 +787,9 @@ type _defer struct {\n \t// function function will be somewhere in libffi, so __retaddr\n \t// is not useful.\n \tmakefunccanrecover bool\n+\n+\t// Whether the _defer is heap allocated.\n+\theap bool\n }\n \n // panics"}, {"sha": "b6962532ffd36f09982311f9a1fe6ba9394c3d28", "filename": "libgo/go/runtime/stack_test.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fstack_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68035acfd6997ed97eb32aec4f277f3b6858550/libgo%2Fgo%2Fruntime%2Fstack_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstack_test.go?ref=e68035acfd6997ed97eb32aec4f277f3b6858550", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime_test\n+\n+import \"testing\"\n+\n+func TestDeferHeapAndStack(t *testing.T) {\n+\tP := 4     // processors\n+\tN := 10000 // iterations\n+\tD := 200   // stack depth\n+\n+\tif testing.Short() {\n+\t\tP /= 2\n+\t\tN /= 10\n+\t\tD /= 10\n+\t}\n+\tc := make(chan bool)\n+\tfor p := 0; p < P; p++ {\n+\t\tgo func() {\n+\t\t\tfor i := 0; i < N; i++ {\n+\t\t\t\tif deferHeapAndStack(D) != 2*D {\n+\t\t\t\t\tpanic(\"bad result\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tc <- true\n+\t\t}()\n+\t}\n+\tfor p := 0; p < P; p++ {\n+\t\t<-c\n+\t}\n+}\n+\n+// deferHeapAndStack(n) computes 2*n\n+func deferHeapAndStack(n int) (r int) {\n+\tif n == 0 {\n+\t\treturn 0\n+\t}\n+\tif n%2 == 0 {\n+\t\t// heap-allocated defers\n+\t\tfor i := 0; i < 2; i++ {\n+\t\t\tdefer func() {\n+\t\t\t\tr++\n+\t\t\t}()\n+\t\t}\n+\t} else {\n+\t\t// stack-allocated defers\n+\t\tdefer func() {\n+\t\t\tr++\n+\t\t}()\n+\t\tdefer func() {\n+\t\t\tr++\n+\t\t}()\n+\t}\n+\tr = deferHeapAndStack(n - 1)\n+\tescapeMe(new([1024]byte)) // force some GCs\n+\treturn\n+}\n+\n+// Pass a value to escapeMe to force it to escape.\n+var escapeMe = func(x interface{}) {}"}]}