{"sha": "bf1660a67066f9ad75d368466f5be15cc23a6ca1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxNjYwYTY3MDY2ZjlhZDc1ZDM2ODQ2NmY1YmUxNWNjMjNhNmNhMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-06-10T16:32:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-06-10T16:32:45Z"}, "message": "alias.c (static_reg_base_value): New to hold RTL for items allocated once per function for the aliasing code.\n\n\t* alias.c (static_reg_base_value): New to hold RTL for\n\titems allocated once per function for the aliasing code.\n\t(init_alias_once_per_function): Initialize static_reg_base_value.\n\t(init_alias_analysis): Avoid throw-away allocations of RTL by\n\tusing pre-computed values in static_reg_base_value.\n\t* function.c (prepare_function_start): Call\n\tinit_alias_once_per_function appropriately.\n\t* rtl.h (init_alias_once_per_function): Declare.\n\t* caller-save (init_caller_save): Restructure slightly to\n\tavoid lots of silly RTL generation.\n\t* expr.c (init_expr_once): Likewise.\n\t* reload1.c (reload_cse_regs_1): Allocate throw-away register\n\tRTL object here.  Pass it into children.\n\t(reload_cse_simplify_operands): Use passed-in register RTL\n\tobject.\n\t(reload_cse_simplify): Pass through throw-away register\n\tRTL object.\n\nFrom-SVN: r54442", "tree": {"sha": "b6731a46c8b99043d03fbda9812dc896be80aba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6731a46c8b99043d03fbda9812dc896be80aba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf1660a67066f9ad75d368466f5be15cc23a6ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1660a67066f9ad75d368466f5be15cc23a6ca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1660a67066f9ad75d368466f5be15cc23a6ca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1660a67066f9ad75d368466f5be15cc23a6ca1/comments", "author": null, "committer": null, "parents": [{"sha": "8dc5848454ac4c24ce5a3fead6dd4e4ef4cb3a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc5848454ac4c24ce5a3fead6dd4e4ef4cb3a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc5848454ac4c24ce5a3fead6dd4e4ef4cb3a2f"}], "stats": {"total": 139, "additions": 111, "deletions": 28}, "files": [{"sha": "cac8e5a6b89888f9d11cb61d0be9f445f1564560", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -1,3 +1,23 @@\n+2002-06-10  Jeffrey Law  <law@redhat.com>\n+\n+\t* alias.c (static_reg_base_value): New to hold RTL for\n+\titems allocated once per function for the aliasing code.\n+\t(init_alias_once_per_function): Initialize static_reg_base_value.\n+\t(init_alias_analysis): Avoid throw-away allocations of RTL by\n+\tusing pre-computed values in static_reg_base_value.\n+\t* function.c (prepare_function_start): Call\n+\tinit_alias_once_per_function appropriately.\n+\t* rtl.h (init_alias_once_per_function): Declare.\n+\t* caller-save (init_caller_save): Restructure slightly to\n+\tavoid lots of silly RTL generation.\n+\t* expr.c (init_expr_once): Likewise.\n+\t* reload1.c (reload_cse_regs_1): Allocate throw-away register\n+\tRTL object here.  Pass it into children.\n+\t(reload_cse_simplify_operands): Use passed-in register RTL\n+\tobject.\n+\t(reload_cse_simplify): Pass through throw-away register\n+\tRTL object.\n+\n 2002-06-10  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* Makefile.in (ssa.o): Add dependency on $(RTL_H), which was missing."}, {"sha": "4969aa6d47134ec7abd4411e303ebaccc351e7c4", "filename": "gcc/alias.c", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -156,6 +156,10 @@ static GTY((length (\"reg_base_value_size\"))) rtx *reg_base_value;\n static rtx *new_reg_base_value;\n static unsigned int reg_base_value_size; /* size of reg_base_value array */\n \n+/* Static hunks of RTL used by the aliasing code; these are initialized\n+   once per function to avoid unnecessary RTL allocations.  */\n+static GTY (()) rtx static_reg_base_value[FIRST_PSEUDO_REGISTER];\n+\n #define REG_BASE_VALUE(X) \\\n   (REGNO (X) < reg_base_value_size \\\n    ? reg_base_value[REGNO (X)] : 0)\n@@ -2638,6 +2642,43 @@ init_alias_once ()\n   alias_sets = splay_tree_new (splay_tree_compare_ints, 0, 0);\n }\n \n+/* Per-function initializer for the aliasing code.\n+\n+   Allocate RTL for argument and other special use registers once\n+   per function here intead of multiple times per function in \n+   init_alias_analysis.  */\n+\n+void\n+init_alias_once_per_function ()\n+{\n+  int i;\n+\n+  /* Generate and mark all hard registers which may contain an address.\n+     The stack, frame and argument pointers may contain an address.\n+     An argument register which can hold a Pmode value may contain\n+     an address even if it is not in BASE_REGS.\n+\n+     The address expression is VOIDmode for an argument and\n+     Pmode for other registers.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (argument_registers, i))\n+      static_reg_base_value[i]\n+\t= gen_rtx_ADDRESS (VOIDmode, gen_rtx_REG (Pmode, i));\n+\n+\n+  static_reg_base_value[STACK_POINTER_REGNUM]\n+    = gen_rtx_ADDRESS (Pmode, stack_pointer_rtx);\n+  static_reg_base_value[ARG_POINTER_REGNUM]\n+    = gen_rtx_ADDRESS (Pmode, arg_pointer_rtx);\n+  static_reg_base_value[FRAME_POINTER_REGNUM]\n+    = gen_rtx_ADDRESS (Pmode, frame_pointer_rtx);\n+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n+  static_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n+    = gen_rtx_ADDRESS (Pmode, hard_frame_pointer_rtx);\n+#endif\n+}\n+\n /* Initialize the aliasing machinery.  Initialize the REG_KNOWN_VALUE\n    array.  */\n \n@@ -2725,20 +2766,18 @@ init_alias_analysis ()\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (argument_registers, i))\n-\t  new_reg_base_value[i] = gen_rtx_ADDRESS (VOIDmode,\n-\t\t\t\t\t\t   gen_rtx_REG (Pmode, i));\n+\t  new_reg_base_value[i] = static_reg_base_value[i];\n \n       new_reg_base_value[STACK_POINTER_REGNUM]\n-\t= gen_rtx_ADDRESS (Pmode, stack_pointer_rtx);\n+\t= static_reg_base_value[STACK_POINTER_REGNUM];\n       new_reg_base_value[ARG_POINTER_REGNUM]\n-\t= gen_rtx_ADDRESS (Pmode, arg_pointer_rtx);\n+\t= static_reg_base_value[ARG_POINTER_REGNUM];\n       new_reg_base_value[FRAME_POINTER_REGNUM]\n-\t= gen_rtx_ADDRESS (Pmode, frame_pointer_rtx);\n+\t= static_reg_base_value[FRAME_POINTER_REGNUM];\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n       new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n-\t= gen_rtx_ADDRESS (Pmode, hard_frame_pointer_rtx);\n+\t= static_reg_base_value[HARD_FRAME_POINTER_REGNUM];\n #endif\n-\n       /* Walk the insns adding values to the new_reg_base_value array.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{"}, {"sha": "920bafd241b81399fd993143610b39428e8ae5d4", "filename": "gcc/caller-save.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -115,6 +115,9 @@ init_caller_save ()\n   rtx address;\n   int i, j;\n   enum machine_mode mode;\n+  rtx savepat, restpat;\n+  rtx test_reg, test_mem;\n+  rtx saveinsn, restinsn;\n \n   /* First find all the registers that we need to deal with and all\n      the modes that they can have.  If we can't find a mode to use,\n@@ -179,22 +182,32 @@ init_caller_save ()\n     address = addr_reg;\n \n   /* Next we try to form an insn to save and restore the register.  We\n-     see if such an insn is recognized and meets its constraints.  */\n+     see if such an insn is recognized and meets its constraints. \n+\n+     To avoid lots of unnecessary RTL allocation, we construct all the RTL\n+     once, then modify the memory and register operands in-place.  */\n+\n+  test_reg = gen_rtx_REG (VOIDmode, 0);\n+  test_mem = gen_rtx_MEM (VOIDmode, address);\n+  savepat = gen_rtx_SET (VOIDmode, test_mem, test_reg);\n+  restpat = gen_rtx_SET (VOIDmode, test_reg, test_mem);\n+  saveinsn = emit_insn (savepat);\n+  restinsn = emit_insn (restpat);\n \n   start_sequence ();\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (mode = 0 ; mode < MAX_MACHINE_MODE; mode++)\n       if (HARD_REGNO_MODE_OK (i, mode))\n         {\n-\t  rtx mem = gen_rtx_MEM (mode, address);\n-\t  rtx reg = gen_rtx_REG (mode, i);\n-\t  rtx savepat = gen_rtx_SET (VOIDmode, mem, reg);\n-\t  rtx restpat = gen_rtx_SET (VOIDmode, reg, mem);\n-\t  rtx saveinsn = emit_insn (savepat);\n-\t  rtx restinsn = emit_insn (restpat);\n \t  int ok;\n \n+\t  /* Update the register number and modes of the register\n+\t     and memory operand.  */\n+\t  REGNO (test_reg) = i;\n+\t  PUT_MODE (test_reg, mode);\n+\t  PUT_MODE (test_mem, mode);\n+\n \t  reg_save_code[i][mode] = recog_memoized (saveinsn);\n \t  reg_restore_code[i][mode] = recog_memoized (restinsn);\n "}, {"sha": "d7dc5316a268fef59eebd1d669d45293901f8e5a", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -214,13 +214,18 @@ init_expr_once ()\n   enum machine_mode mode;\n   int num_clobbers;\n   rtx mem, mem1;\n+  rtx reg;\n \n   /* Try indexing by frame ptr and try by stack ptr.\n      It is known that on the Convex the stack ptr isn't a valid index.\n      With luck, one or the other is valid on any machine.  */\n   mem = gen_rtx_MEM (VOIDmode, stack_pointer_rtx);\n   mem1 = gen_rtx_MEM (VOIDmode, frame_pointer_rtx);\n \n+  /* A scratch register we can modify in-place below to avoid\n+     useless RTL allocations.  */\n+  reg = gen_rtx_REG (VOIDmode, -1);\n+\n   insn = rtx_alloc (INSN);\n   pat = gen_rtx_SET (0, NULL_RTX, NULL_RTX);\n   PATTERN (insn) = pat;\n@@ -229,11 +234,11 @@ init_expr_once ()\n        mode = (enum machine_mode) ((int) mode + 1))\n     {\n       int regno;\n-      rtx reg;\n \n       direct_load[(int) mode] = direct_store[(int) mode] = 0;\n       PUT_MODE (mem, mode);\n       PUT_MODE (mem1, mode);\n+      PUT_MODE (reg, mode);\n \n       /* See if there is some register that can be used in this mode and\n \t directly loaded or stored from memory.  */\n@@ -246,7 +251,7 @@ init_expr_once ()\n \t    if (! HARD_REGNO_MODE_OK (regno, mode))\n \t      continue;\n \n-\t    reg = gen_rtx_REG (mode, regno);\n+\t    REGNO (reg) = regno;\n \n \t    SET_SRC (pat) = mem;\n \t    SET_DEST (pat) = reg;"}, {"sha": "96c256362613eb61af1565d3cc376d247e449060", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -6208,6 +6208,9 @@ prepare_function_start ()\n   /* Initialize the RTL mechanism.  */\n   init_emit ();\n \n+  /* Do per-function initialization of the alias analyzer.  */\n+  init_alias_once_per_function ();\n+\n   /* Initialize the queue of pending postincrement and postdecrements,\n      and some other info in expr.c.  */\n   init_expr ();"}, {"sha": "ca25abff22c914ef37d3d903e0e0c2b9f82740f6", "filename": "gcc/reload1.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -443,7 +443,7 @@ static rtx inc_for_reload\t\tPARAMS ((rtx, rtx, rtx, int));\n static void reload_cse_regs_1\t\tPARAMS ((rtx));\n static int reload_cse_noop_set_p\tPARAMS ((rtx));\n static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n-static int reload_cse_simplify_operands\tPARAMS ((rtx));\n+static int reload_cse_simplify_operands\tPARAMS ((rtx, rtx));\n static void reload_combine\t\tPARAMS ((void));\n static void reload_combine_note_use\tPARAMS ((rtx *, rtx));\n static void reload_combine_note_store\tPARAMS ((rtx, rtx, void *));\n@@ -457,7 +457,7 @@ static HOST_WIDE_INT sext_for_mode\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t HOST_WIDE_INT));\n static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n-static void reload_cse_simplify\t\tPARAMS ((rtx));\n+static void reload_cse_simplify\t\tPARAMS ((rtx, rtx));\n void fixup_abnormal_edges\t\tPARAMS ((void));\n extern void dump_needs\t\t\tPARAMS ((struct insn_chain *));\n \f\n@@ -7992,8 +7992,9 @@ reload_cse_noop_set_p (set)\n \n /* Try to simplify INSN.  */\n static void\n-reload_cse_simplify (insn)\n+reload_cse_simplify (insn, testreg)\n      rtx insn;\n+     rtx testreg;\n {\n   rtx body = PATTERN (insn);\n \n@@ -8021,7 +8022,7 @@ reload_cse_simplify (insn)\n       if (count > 0)\n \tapply_change_group ();\n       else\n-\treload_cse_simplify_operands (insn);\n+\treload_cse_simplify_operands (insn, testreg);\n     }\n   else if (GET_CODE (body) == PARALLEL)\n     {\n@@ -8064,7 +8065,7 @@ reload_cse_simplify (insn)\n       if (count > 0)\n \tapply_change_group ();\n       else\n-\treload_cse_simplify_operands (insn);\n+\treload_cse_simplify_operands (insn, testreg);\n     }\n }\n \n@@ -8090,14 +8091,15 @@ reload_cse_regs_1 (first)\n      rtx first;\n {\n   rtx insn;\n+  rtx testreg = gen_rtx_REG (VOIDmode, -1);\n \n   cselib_init ();\n   init_alias_analysis ();\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n-\treload_cse_simplify (insn);\n+\treload_cse_simplify (insn, testreg);\n \n       cselib_process_insn (insn);\n     }\n@@ -8268,8 +8270,9 @@ reload_cse_simplify_set (set, insn)\n    hard registers.  */\n \n static int\n-reload_cse_simplify_operands (insn)\n+reload_cse_simplify_operands (insn, testreg)\n      rtx insn;\n+     rtx testreg;\n {\n   int i, j;\n \n@@ -8289,7 +8292,6 @@ reload_cse_simplify_operands (insn)\n   int *op_alt_regno[MAX_RECOG_OPERANDS];\n   /* Array of alternatives, sorted in order of decreasing desirability.  */\n   int *alternative_order;\n-  rtx reg = gen_rtx_REG (VOIDmode, -1);\n \n   extract_insn (insn);\n \n@@ -8373,8 +8375,8 @@ reload_cse_simplify_operands (insn)\n \t  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))\n \t    continue;\n \n-\t  REGNO (reg) = regno;\n-\t  PUT_MODE (reg, mode);\n+\t  REGNO (testreg) = regno;\n+\t  PUT_MODE (testreg, mode);\n \n \t  /* We found a register equal to this operand.  Now look for all\n \t     alternatives that can accept this register and have not been\n@@ -8416,10 +8418,10 @@ reload_cse_simplify_operands (insn)\n \t\t     alternative yet and the operand being replaced is not\n \t\t     a cheap CONST_INT.  */\n \t\t  if (op_alt_regno[i][j] == -1\n-\t\t      && reg_fits_class_p (reg, class, 0, mode)\n+\t\t      && reg_fits_class_p (testreg, class, 0, mode)\n \t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n \t\t\t  || (rtx_cost (recog_data.operand[i], SET)\n-\t\t\t      > rtx_cost (reg, SET))))\n+\t\t\t      > rtx_cost (testreg, SET))))\n \t\t    {\n \t\t      alternative_nregs[j]++;\n \t\t      op_alt_regno[i][j] = regno;"}, {"sha": "ee4e0939fdb1a7abe6c8b31a2cefd3ad69d59494", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1660a67066f9ad75d368466f5be15cc23a6ca1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bf1660a67066f9ad75d368466f5be15cc23a6ca1", "patch": "@@ -2166,6 +2166,7 @@ extern int anti_dependence\t\tPARAMS ((rtx, rtx));\n extern int output_dependence\t\tPARAMS ((rtx, rtx));\n extern void mark_constant_function\tPARAMS ((void));\n extern void init_alias_once\t\tPARAMS ((void));\n+extern void init_alias_once_per_function PARAMS ((void));\n extern void init_alias_analysis\t\tPARAMS ((void));\n extern void end_alias_analysis\t\tPARAMS ((void));\n extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));"}]}