{"sha": "2df373c2eb9148f995614d5405f0e4b500de4e0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRmMzczYzJlYjkxNDhmOTk1NjE0ZDU0MDVmMGU0YjUwMGRlNGUwZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-09-22T14:58:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-09-22T14:58:05Z"}, "message": "re PR bootstrap/41395 (Revision 151800 failed bootstrap)\n\n2009-09-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/41395\n\t* tree-dfa.c (get_ref_base_and_extent): Handle trailing\n\tarrays really properly.\n\n\t* gcc.c-torture/execute/pr41395-1.c: New testcase.\n\t* gcc.c-torture/execute/pr41395-2.c: Likewise.\n\nFrom-SVN: r151981", "tree": {"sha": "7e6fe3b018d1707e31a2a61b9b18a4b0501d3846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e6fe3b018d1707e31a2a61b9b18a4b0501d3846"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2df373c2eb9148f995614d5405f0e4b500de4e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df373c2eb9148f995614d5405f0e4b500de4e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df373c2eb9148f995614d5405f0e4b500de4e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df373c2eb9148f995614d5405f0e4b500de4e0d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf76ef1a4605c24827dad764ea5791207458668c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf76ef1a4605c24827dad764ea5791207458668c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf76ef1a4605c24827dad764ea5791207458668c"}], "stats": {"total": 134, "additions": 116, "deletions": 18}, "files": [{"sha": "25cc781399a45ea430c601ece0cf3fc343860808", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2df373c2eb9148f995614d5405f0e4b500de4e0d", "patch": "@@ -1,3 +1,9 @@\n+2009-09-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/41395\n+\t* tree-dfa.c (get_ref_base_and_extent): Handle trailing\n+\tarrays really properly.\n+\n 2009-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/rs6000/rs6000.c (bdesc_2arg): Fix CODE_FOR_vector_gt* codes"}, {"sha": "981e8e3833ab175f257491817749fa7476056abe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2df373c2eb9148f995614d5405f0e4b500de4e0d", "patch": "@@ -1,3 +1,9 @@\n+2009-09-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/41395\n+\t* gcc.c-torture/execute/pr41395-1.c: New testcase.\n+\t* gcc.c-torture/execute/pr41395-2.c: Likewise.\n+\n 2009-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/20090922-1.c: New test."}, {"sha": "e4df0e5d187319956f407fe103ff232e035fe1ee", "filename": "gcc/testsuite/gcc.c-torture/execute/pr41395-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41395-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41395-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41395-1.c?ref=2df373c2eb9148f995614d5405f0e4b500de4e0d", "patch": "@@ -0,0 +1,28 @@\n+struct VEC_char_base\n+{\n+  unsigned num;\n+  unsigned alloc;\n+  short vec[1];\n+};\n+\n+short __attribute__((noinline))\n+foo (struct VEC_char_base *p, int i)\n+{\n+  short *q;\n+  p->vec[i] = 0;\n+  q = &p->vec[8];\n+  *q = 1;\n+  return p->vec[i];\n+}\n+\n+extern void abort (void);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+int\n+main()\n+{\n+  struct VEC_char_base *p = malloc (sizeof (struct VEC_char_base) + 256);\n+  if (foo (p, 8) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c75e963613bb86b84d570851dff0894d2cbede49", "filename": "gcc/testsuite/gcc.c-torture/execute/pr41395-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41395-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41395-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr41395-2.c?ref=2df373c2eb9148f995614d5405f0e4b500de4e0d", "patch": "@@ -0,0 +1,35 @@\n+struct VEC_char_base\n+{\n+  unsigned num;\n+  unsigned alloc;\n+  union {\n+      short vec[1];\n+      struct {\n+\t  int i;\n+\t  int j;\n+\t  int k;\n+      } a;\n+  } u;\n+};\n+\n+short __attribute__((noinline))\n+foo (struct VEC_char_base *p, int i)\n+{\n+  short *q;\n+  p->u.vec[i] = 0;\n+  q = &p->u.vec[16];\n+  *q = 1;\n+  return p->u.vec[i];\n+}\n+\n+extern void abort (void);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+int\n+main()\n+{\n+  struct VEC_char_base *p = malloc (sizeof (struct VEC_char_base) + 256);\n+  if (foo (p, 16) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "3fd8477cf7eae05e1f56bf030b976f42b79c888b", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2df373c2eb9148f995614d5405f0e4b500de4e0d/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=2df373c2eb9148f995614d5405f0e4b500de4e0d", "patch": "@@ -752,7 +752,6 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   tree size_tree = NULL_TREE;\n   HOST_WIDE_INT bit_offset = 0;\n   bool seen_variable_array_ref = false;\n-  bool seen_union = false;\n \n   /* First get the final access size from just the outermost expression.  */\n   if (TREE_CODE (exp) == COMPONENT_REF)\n@@ -794,9 +793,6 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    tree field = TREE_OPERAND (exp, 1);\n \t    tree this_offset = component_ref_field_offset (exp);\n \n-\t    if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == UNION_TYPE)\n-\t      seen_union = true;\n-\n \t    if (this_offset\n \t\t&& TREE_CODE (this_offset) == INTEGER_CST\n \t\t&& host_integerp (this_offset, 0))\n@@ -849,6 +845,40 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    else\n \t      {\n \t\ttree asize = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t\t/* Get at the array size but include trailing padding if\n+\t\t   the array is the last element of a struct or union.  */\n+\t\tif (maxsize != -1\n+\t\t    && TREE_CODE (TREE_OPERAND (exp, 0)) == COMPONENT_REF)\n+\t\t  {\n+\t\t    tree cref = TREE_OPERAND (exp, 0);\n+\t\t    tree field = TREE_OPERAND (cref, 1);\n+\t\t    tree stype = TREE_TYPE (TREE_OPERAND (cref, 0));\n+\t\t    tree next = TREE_CHAIN (field);\n+\t\t    while (next && TREE_CODE (next) != FIELD_DECL)\n+\t\t      next = TREE_CHAIN (next);\n+\t\t    if (!next\n+\t\t\t|| TREE_CODE (stype) != RECORD_TYPE)\n+\t\t      {\n+\t\t\t/* The size including padding is the size of\n+\t\t\t   the whole structure minus the offset of the\n+\t\t\t   array in it.  */\n+\t\t\ttree field_offset = component_ref_field_offset (cref);\n+\t\t\tif (field_offset\n+\t\t\t    && host_integerp (field_offset, 0)\n+\t\t\t    && host_integerp (TYPE_SIZE_UNIT (stype), 0))\n+\t\t\t  {\n+\t\t\t    unsigned HOST_WIDE_INT as;\n+\t\t\t    as = (((TREE_INT_CST_LOW (TYPE_SIZE_UNIT (stype))\n+\t\t\t\t    - TREE_INT_CST_LOW (field_offset))\n+\t\t\t\t   * BITS_PER_UNIT)\n+\t\t\t\t  - TREE_INT_CST_LOW\n+\t\t\t\t      (DECL_FIELD_BIT_OFFSET (field)));\n+\t\t\t    asize = build_int_cstu (sizetype, as);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  asize = NULL_TREE;\n+\t\t      }\n+\t\t  }\n \t\t/* We need to adjust maxsize to the whole array bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us outside of the array otherwise.  */\n@@ -887,25 +917,18 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n        struct { int length; int a[1]; } x;           x.a[d]\n        struct { struct { int a; int b; } a[1]; } x;  x.a[d].a\n        struct { struct { int a[1]; } a[1]; } x;      x.a[0][d], x.a[d][0]\n+       struct { int len; union { int a[1]; struct X x; } u; } x; x.u.a[d]\n      where we do not know maxsize for variable index accesses to\n      the array.  The simplest way to conservatively deal with this\n      is to punt in the case that offset + maxsize reaches the\n-     base type boundary.\n-\n-     Unfortunately this is difficult to determine reliably when unions are\n-     involved and so we are conservative in such cases.\n-\n-     FIXME: This approach may be too conservative, we probably want to at least\n-     check that the union is the last field/element at its level or even\n-     propagate the calculated offsets back up the access chain and check\n-     there.  */\n+     base type boundary.  This needs to include possible trailing padding\n+     that is there for alignment purposes.  */\n \n   if (seen_variable_array_ref\n-      && (seen_union\n-\t  || (maxsize != -1\n-\t      && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n-\t      && bit_offset + maxsize\n-\t      == (signed) TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))))))\n+      && (maxsize != -1\n+\t  && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n+\t  && bit_offset + maxsize\n+\t  == (signed) TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp)))))\n     maxsize = -1;\n \n   /* ???  Due to negative offsets in ARRAY_REF we can end up with"}]}