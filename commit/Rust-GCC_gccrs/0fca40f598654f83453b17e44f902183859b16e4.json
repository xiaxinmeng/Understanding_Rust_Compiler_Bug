{"sha": "0fca40f598654f83453b17e44f902183859b16e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZjYTQwZjU5ODY1NGY4MzQ1M2IxN2U0NGY5MDIxODM4NTliMTZlNA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-08-28T11:11:14Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-08-28T11:11:14Z"}, "message": "target.h (struct vectorize): Add new target builtin.\n\n\t* target.h (struct vectorize): Add new target builtin.\n\t* tree-vectorizer.c (destroy_loop_vec_info): Call\n\tvect_free_slp_instance instead of vect_free_slp_node.\n\t* tree-vectorizer.h (enum slp_load_perm_type): New.\n\t(struct _slp_instance): Add new fields.\n\t(SLP_INSTANCE_LOAD_PERMUTATION): New.\n\t(SLP_INSTANCE_LOADS): New.\n\t(vect_free_slp_tree): Remove.\n\t(vect_free_slp_instance): Declare.\n\t(SLP_TREE_LOADS_PERM_TYPE, TARG_VEC_PERMUTE_COST): New.\n\t(vectorizable_load): Add argument.\n\t(vect_transform_slp_perm_load): New.\n\t* tree-vect-analyze.c (vect_analyze_operations): Add an argument to\n\tvectorizable_load.\n\t(vect_get_place_in_interleaving_chain): New function.\n\t(vect_free_slp_tree): Make static.\n\t(vect_free_slp_instance): New function.\n\t(vect_build_slp_tree): Add new arguments. Allow load permutations and\n\tcollect the load location in the interleaving chain.\n\t(vect_supported_slp_permutation_p): New function.\n\t(vect_supported_load_permutation_p): Likewise.\n\t(vect_analyze_slp_instance): In case of loads permutation, call\n\tvect_supported_load_permutation_p to check that the permutation is\n\tsupported.\n\t* target-def.h (TARGET_VECTORIZE_BUILTIN_VEC_PERM): New.\n\t* tree-vect-transform.c (vect_transform_stmt): Add new argument.\n\t(vect_create_mask_and_perm): New function.\n\t(vect_get_mask_element, vect_transform_slp_perm_load): Likewise.\n\t(vectorizable_load): Add an argument. Don't keep the created vectors\n\tstatements in the node if permutation is required. Call\n\tvect_transform_slp_perm_load to generate the permutation.\n\t(vect_transform_stmt): Add new argument. Call vectorizable_load with\n\tadditional argument.\n\t(vect_schedule_slp_instance): In case of loads permutation, allocate\n\tvectorized statements structure for all the related SLP nodes. Call\n\tvect_transform_stmt with addditional argument.\n\t(vect_transform_loop): Call vect_transform_stmt with correct arguments.\n\t* config/spu/spu.c (spu_builtin_vec_perm): New.\n\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Redefine.\n\t* config/spu/spu.h (TARG_VEC_PERMUTE_COS): Define.\n\t* config/rs6000/rs6000.c (rs6000_builtin_vec_perm): New.\n\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Redefine.\n\nFrom-SVN: r139706", "tree": {"sha": "e0ca36b1b58d3d02e70b7343f52d0af07126a5b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ca36b1b58d3d02e70b7343f52d0af07126a5b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fca40f598654f83453b17e44f902183859b16e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fca40f598654f83453b17e44f902183859b16e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fca40f598654f83453b17e44f902183859b16e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fca40f598654f83453b17e44f902183859b16e4/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b8c41c8ed2c55f001b14b0a432f4daa73155d278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c41c8ed2c55f001b14b0a432f4daa73155d278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c41c8ed2c55f001b14b0a432f4daa73155d278"}], "stats": {"total": 1574, "additions": 1461, "deletions": 113}, "files": [{"sha": "1f7396fa12ac58ba0ea728e7445702df4c6b62bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -1,3 +1,48 @@\n+2008-08-28  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* target.h (struct vectorize): Add new target builtin.\n+\t* tree-vectorizer.c (destroy_loop_vec_info): Call \n+\tvect_free_slp_instance instead of vect_free_slp_node.\n+\t* tree-vectorizer.h (enum slp_load_perm_type): New.\n+\t(struct _slp_instance): Add new fields.\n+\t(SLP_INSTANCE_LOAD_PERMUTATION): New.\n+\t(SLP_INSTANCE_LOADS): New.\n+\t(vect_free_slp_tree): Remove.\n+\t(vect_free_slp_instance): Declare.        \n+\t(SLP_TREE_LOADS_PERM_TYPE, TARG_VEC_PERMUTE_COST): New.\n+\t(vectorizable_load): Add argument.\n+\t(vect_transform_slp_perm_load): New.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Add an argument to \n+\tvectorizable_load.\n+\t(vect_get_place_in_interleaving_chain): New function.\n+\t(vect_free_slp_tree): Make static.\n+\t(vect_free_slp_instance): New function.\n+\t(vect_build_slp_tree): Add new arguments. Allow load permutations and \n+\tcollect the load location in the interleaving chain.\n+\t(vect_supported_slp_permutation_p): New function.\n+\t(vect_supported_load_permutation_p): Likewise.\n+\t(vect_analyze_slp_instance): In case of loads permutation, call\n+\tvect_supported_load_permutation_p to check that the permutation is \n+\tsupported.\n+\t* target-def.h (TARGET_VECTORIZE_BUILTIN_VEC_PERM): New.\n+\t* tree-vect-transform.c (vect_transform_stmt): Add new argument.\n+\t(vect_create_mask_and_perm): New function.\n+\t(vect_get_mask_element, vect_transform_slp_perm_load): Likewise.\n+\t(vectorizable_load): Add an argument. Don't keep the created vectors  \n+\tstatements in the node if permutation is required. Call \n+\tvect_transform_slp_perm_load to generate the permutation.\n+\t(vect_transform_stmt): Add new argument. Call vectorizable_load with \n+\tadditional argument.\n+\t(vect_schedule_slp_instance): In case of loads permutation, allocate  \n+\tvectorized statements structure for all the related SLP nodes. Call \n+\tvect_transform_stmt with addditional argument.\n+\t(vect_transform_loop): Call vect_transform_stmt with correct arguments. \n+\t* config/spu/spu.c (spu_builtin_vec_perm): New. \n+\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Redefine.\n+\t* config/spu/spu.h (TARG_VEC_PERMUTE_COS): Define.\n+\t* config/rs6000/rs6000.c (rs6000_builtin_vec_perm): New.\n+\t(TARGET_VECTORIZE_BUILTIN_VEC_PERM): Redefine.\n+\n 2008-08-28  Chris Fairles  <chris.fairles@gmail.com>\n \n         * gthr-posix.h (__gthread_create,  __gthread_join, __gthread_detach,"}, {"sha": "2124ea3c50d31f02bfef3ada762fd90a8fcf963a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -862,6 +862,7 @@ static tree rs6000_builtin_mask_for_load (void);\n static tree rs6000_builtin_mul_widen_even (tree);\n static tree rs6000_builtin_mul_widen_odd (tree);\n static tree rs6000_builtin_conversion (enum tree_code, tree);\n+static tree rs6000_builtin_vec_perm (tree, tree *);\n \n static void def_builtin (int, const char *, tree, int);\n static bool rs6000_vector_alignment_reachable (const_tree, bool);\n@@ -1138,6 +1139,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD rs6000_builtin_mul_widen_odd\n #undef TARGET_VECTORIZE_BUILTIN_CONVERSION\n #define TARGET_VECTORIZE_BUILTIN_CONVERSION rs6000_builtin_conversion\n+#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n+#define TARGET_VECTORIZE_BUILTIN_VEC_PERM rs6000_builtin_vec_perm\n \n #undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTOR_ALIGNMENT_REACHABLE rs6000_vector_alignment_reachable\n@@ -2080,6 +2083,40 @@ rs6000_vector_alignment_reachable (const_tree type ATTRIBUTE_UNUSED, bool is_pac\n     }\n }\n \n+/* Implement targetm.vectorize.builtin_vec_perm.  */\n+tree\n+rs6000_builtin_vec_perm (tree type, tree *mask_element_type)\n+{\n+  tree d;\n+\n+  *mask_element_type = unsigned_char_type_node;\n+\n+  switch (TYPE_MODE (type))\n+    {\n+    case V16QImode:\n+      d = rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_16QI];\n+      break;\n+\n+    case V8HImode:\n+      d = rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_8HI];\n+      break;\n+\n+    case V4SImode:\n+      d = rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_4SI];\n+      break;\n+\n+    case V4SFmode:\n+      d = rs6000_builtin_decls[ALTIVEC_BUILTIN_VPERM_4SF];\n+      break;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  gcc_assert (d);\n+  return d;\n+}\n+\n /* Handle generic options of the form -mfoo=yes/no.\n    NAME is the option name.\n    VALUE is the option value."}, {"sha": "da99d3f108a835712ae762fb97a2da7e745866d6", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -137,6 +137,7 @@ static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n static int spu_builtin_vectorization_cost (bool);\n static bool spu_vector_alignment_reachable (const_tree, bool);\n+static tree spu_builtin_vec_perm (tree, tree *);\n static int spu_sms_res_mii (struct ddg *g);\n \n extern const char *reg_names[];\n@@ -288,6 +289,9 @@ const struct attribute_spec spu_attribute_table[];\n #undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n \n+#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n+#define TARGET_VECTORIZE_BUILTIN_VEC_PERM spu_builtin_vec_perm\n+\n #undef TARGET_LIBGCC_CMP_RETURN_MODE\n #define TARGET_LIBGCC_CMP_RETURN_MODE spu_libgcc_cmp_return_mode\n \n@@ -5543,6 +5547,60 @@ spu_vector_alignment_reachable (const_tree type ATTRIBUTE_UNUSED, bool is_packed\n   return true;\n }\n \n+/* Implement targetm.vectorize.builtin_vec_perm.  */\n+tree\n+spu_builtin_vec_perm (tree type, tree *mask_element_type)\n+{\n+  struct spu_builtin_description *d;\n+\n+  *mask_element_type = unsigned_char_type_node;\n+\n+  switch (TYPE_MODE (type))\n+    {\n+    case V16QImode:\n+      if (TYPE_UNSIGNED (type))\n+        d = &spu_builtins[SPU_SHUFFLE_0];\n+      else\n+        d = &spu_builtins[SPU_SHUFFLE_1];\n+      break;\n+\n+    case V8HImode:\n+      if (TYPE_UNSIGNED (type))\n+        d = &spu_builtins[SPU_SHUFFLE_2];\n+      else\n+        d = &spu_builtins[SPU_SHUFFLE_3];\n+      break;\n+\n+    case V4SImode:\n+      if (TYPE_UNSIGNED (type))\n+        d = &spu_builtins[SPU_SHUFFLE_4];\n+      else\n+        d = &spu_builtins[SPU_SHUFFLE_5];\n+      break;\n+\n+    case V2DImode:\n+      if (TYPE_UNSIGNED (type))\n+        d = &spu_builtins[SPU_SHUFFLE_6];\n+      else\n+        d = &spu_builtins[SPU_SHUFFLE_7];\n+      break;\n+\n+    case V4SFmode:\n+      d = &spu_builtins[SPU_SHUFFLE_8];\n+      break;\n+\n+    case V2DFmode:\n+      d = &spu_builtins[SPU_SHUFFLE_9];\n+      break;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  gcc_assert (d);\n+  return d->fndecl;\n+}\n+\n /* Count the total number of instructions in each pipe and return the\n    maximum, which is used as the Minimum Iteration Interval (MII)\n    in the modulo scheduler.  get_pipe() will return -2, -1, 0, or 1."}, {"sha": "b27e9b7b12edce256c8681e6e561e36655a207f4", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -572,6 +572,11 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n #undef TARG_VEC_STORE_COST\n #define TARG_VEC_STORE_COST          1\n \n+/* Cost of vector permutation.  */\n+#ifndef TARG_VEC_PERMUTE_COST\n+#define TARG_VEC_PERMUTE_COST        1 \n+#endif\n+\n \f\n /* Misc */\n "}, {"sha": "18b0eb5831729553e1decc015ebcd8a8478c2235", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -364,6 +364,7 @@\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST 0\n #define TARGET_VECTOR_ALIGNMENT_REACHABLE \\\n   default_builtin_vector_alignment_reachable\n+#define TARGET_VECTORIZE_BUILTIN_VEC_PERM 0\n \n #define TARGET_VECTORIZE                                                \\\n   {\t\t\t\t\t\t\t\t\t\\\n@@ -373,7 +374,8 @@\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                            \\\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST,\t\t\t\\\n-    TARGET_VECTOR_ALIGNMENT_REACHABLE\t\t\t\t\t\\\n+    TARGET_VECTOR_ALIGNMENT_REACHABLE,                                  \\\n+    TARGET_VECTORIZE_BUILTIN_VEC_PERM                                   \\\n   }\n \n #define TARGET_DEFAULT_TARGET_FLAGS 0"}, {"sha": "610d7650198a252cc2b6b363c6e40e83680eb9e9", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -438,7 +438,10 @@ struct gcc_target\n     /* Return true if vector alignment is reachable (by peeling N\n        iterations) for the given type.  */\n     bool (* vector_alignment_reachable) (const_tree, bool);\n-  } vectorize;\n+\n+    /* Target builtin that implements vector permute.  */\n+    tree (* builtin_vec_perm) (tree, tree*);\n+} vectorize;\n \n   /* The initial value of target_flags.  */\n   int default_target_flags;"}, {"sha": "d5b6c83a13d06495eac4bbf982bf049c08270ee9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -1,3 +1,16 @@\n+2008-08-28  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_perm): New.\n+\t* gcc.dg/vect/slp-perm-1.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-2.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-3.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-4.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-5.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-6.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-7.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-8.c: New testcase.\n+\t* gcc.dg/vect/slp-perm-9.c: New testcase.\n+\n 2008-08-27  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR 37217"}, {"sha": "410758ce293184fba123e5da82436bc685aac78d", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-1.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+\n+#define N 16\n+\n+void foo (unsigned int *__restrict__ pInput, unsigned int *__restrict__ pOutput)\n+{\n+  unsigned int i, a, b, c;\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned int input[N], output[N], i;\n+  unsigned int check_results[N] = {1470, 395, 28271, 5958, 1655, 111653, 10446, 2915, 195035, 14934, 4175, 278417, 19422, 5435, 361799, 0};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      if (input[i] > 200)\n+        abort();\n+      output[i] = 0;\n+    }\n+\n+  foo (input, output);\n+\n+  for (i = 0; i < N; i++)\n+     if (output[i] != check_results[i])\n+       abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "da38a8dd5d65856dc56208fb7361cb2329f1dfe2", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-2.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M01 1322\n+#define M11 13\n+#define M02 74\n+#define M12 191\n+\n+#define N 16\n+\n+void foo (unsigned int *__restrict__ pInput, unsigned int *__restrict__ pOutput)\n+{\n+  unsigned int i, a, b;\n+\n+  for (i = 0; i < N / 2; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+\n+       *pOutput++ = M00 * a + M01 * b;\n+       *pOutput++ = M10 * a + M11 * b;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned int input[N], output[N], i;\n+  unsigned int check_results[N] = {1322, 13, 4166, 471, 7010, 929, 9854, 1387, 12698, 1845, 15542, 2303, 18386, 2761, 21230, 3219};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      if (input[i] > 200)\n+        abort();\n+      output[i] = 0;\n+    }\n+\n+  foo (input, output);\n+\n+  for (i = 0; i < N; i++)\n+    if (output[i] != check_results[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "312db31e30cfaaaf8a67303ae2bbab2ef43ef680", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-3.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M30 237\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M31 2280\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+#define M32 111\n+#define M03 134\n+#define M13 117\n+#define M23 11\n+#define M33 771\n+\n+#define N 16\n+\n+void foo (unsigned int *__restrict__ pInput, unsigned int *__restrict__ pOutput)\n+{\n+  unsigned int i, a, b, c, d;\n+\n+  for (i = 0; i < N / 4; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+       d = *pInput++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c + M03 * d;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c + M13 * d;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c + M23 * d;\n+       *pOutput++ = M30 * a + M31 * b + M32 * c + M33 * d;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned int input[N], output[N], i;\n+  unsigned int check_results[N] = {1872, 746, 28304, 4815, 8392, 2894, 139524, 18411, 14912, 5042, 250744, 32007, 21432, 7190, 361964, 45603};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      if (input[i] > 200)\n+        abort();\n+      output[i] = 0;\n+    }\n+\n+  foo (input, output);\n+\n+  for (i = 0; i < N - N; i++)\n+    if (output[i] != check_results[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "f4db75d000e24df6c45bd3a86370d47d8f6b33a5", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-4.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-4.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M30 237\n+#define M40 437\n+\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M31 2280\n+#define M41 284\n+\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+#define M32 111\n+#define M42 1114\n+\n+#define M03 134\n+#define M13 117\n+#define M23 11\n+#define M33 771\n+#define M43 71\n+\n+#define M04 334\n+#define M14 147\n+#define M24 115\n+#define M34 7716\n+#define M44 16\n+\n+#define N 16\n+\n+void foo (unsigned int *__restrict__ pInput, unsigned int *__restrict__ pOutput)\n+{\n+  unsigned int i, a, b, c, d, e;\n+\n+  for (i = 0; i < N / 5; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+       d = *pInput++;\n+       e = *pInput++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c + M03 * d + M04 * e;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c + M13 * d + M14 * e;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c + M23 * d + M24 * e;\n+       *pOutput++ = M30 * a + M31 * b + M32 * c + M33 * d + M34 * e;\n+       *pOutput++ = M40 * a + M41 * b + M42 * c + M43 * d + M44 * e;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned int input[N], output[N], i;\n+  unsigned int check_results[N] = {3208, 1334, 28764, 35679, 2789, 13028, 4754, 168364, 91254, 12399, 22848, 8174, 307964, 146829, 22009, 0};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      if (input[i] > 200)\n+        abort();\n+      output[i] = 0;\n+    }\n+\n+  foo (input, output);\n+\n+  for (i = 0; i < N - N; i++)\n+    if (output[i] != check_results[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "ca59a5e014bb78e895e32f9797b7598812844590", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-5.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+\n+#define K00 405\n+#define K10 112\n+#define K01 4322\n+#define K11 135\n+\n+#define N 16\n+\n+void foo (int *__restrict__ pInput, int *__restrict__ pOutput,\n+          int *__restrict__ pInput2, int *__restrict__ pOutput2)\n+{\n+  int i, a, b, c, d, e;\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+\n+       d = *pInput2++;\n+       e = *pInput2++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c;\n+\n+       *pOutput2++ = K00 * d + K01 * e;\n+       *pOutput2++ = K10 * d + K11 * e;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  int input[N], output[N], i;\n+  int check_results[N] = {1470, 395, 28271, 5958, 1655, 111653, 10446, 2915, 195035, 14934, 4175, 278417, 19422, 5435, 361799, 0};\n+  int input2[N], output2[N];\n+  int check_results2[N] = {4322, 135, 13776, 629, 23230, 1123, 32684, 1617, 42138, 2111, 0, 0, 0, 0, 0, 0};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      input2[i] = i%256;\n+      output[i] = 0;\n+      output2[i] = 0;\n+      if (input[i] > 256)\n+        abort ();\n+    }\n+\n+  foo (input, output, input2, output2);\n+\n+  for (i = 0; i < N; i++)\n+     if (output[i] != check_results[i] || output2[i] != check_results2[i])\n+       abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "ff9be8aa8e237a80669fc6f1fd77e745fb86c98c", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-6.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+\n+#define K00 405\n+#define K10 112\n+#define K01 4322\n+#define K11 135\n+\n+#define N 16\n+\n+void foo (int *__restrict__ pInput, int *__restrict__ pOutput,\n+          int *__restrict__ pInput2, int *__restrict__ pOutput2)\n+{\n+  int i, a, b, c, d, e;\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+\n+       d = *pInput2++;\n+       e = *pInput2++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c;\n+\n+       /* Regular SLP - no permutation required.  */\n+       *pOutput2++ = K00 * d;\n+       *pOutput2++ = K10 * e;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  int input[N], output[N], i;\n+  int check_results[N] = {1470, 395, 28271, 5958, 1655, 111653, 10446, 2915, 195035, 14934, 4175, 278417, 19422, 5435, 361799, 0};\n+  int input2[N], output2[N];\n+  int check_results2[N] = {0, 112, 810, 336, 1620, 560, 2430, 784, 3240, 1008, 0, 0, 0, 0, 0, 0};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      input2[i] = i%256;\n+      output[i] = 0;\n+      output2[i] = 0;\n+      if (input[i] > 256)\n+        abort ();\n+    }\n+\n+  foo (input, output, input2, output2);\n+\n+  for (i = 0; i < N; i++)\n+     if (output[i] != check_results[i] || output2[i] != check_results2[i])\n+       abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "0065407e238fc9d52c5cbf1f6d7d73febafec588", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-7.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-7.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+\n+#define K00 405\n+#define K10 112\n+#define K01 4322\n+#define K11 135\n+\n+#define N 16\n+\n+/* SLP with load permutation and loop-based vectorization.  */\n+void foo (int *__restrict__ pInput, int *__restrict__ pOutput,\n+          int *__restrict__ pInput2, int *__restrict__ pOutput2)\n+{\n+  int i, a, b, c, d;\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+       d = *pInput2++;\n+\n+       *pOutput++ = M00 * a + M01 * b + M02 * c;\n+       *pOutput++ = M10 * a + M11 * b + M12 * c;\n+       *pOutput++ = M20 * a + M21 * b + M22 * c;\n+\n+       /* Loop-based vectorization.  */\n+       *pOutput2++ = K00 * d;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  int input[N], output[N], i;\n+  int check_results[N] = {1470, 395, 28271, 5958, 1655, 111653, 10446, 2915, 195035, 14934, 4175, 278417, 19422, 5435, 361799, 0};\n+  int input2[N], output2[N];\n+  int check_results2[N] = {0, 405, 810, 1215, 1620, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i%256;\n+      input2[i] = i%256;\n+      output[i] = 0;\n+      output2[i] = 0;\n+      if (input[i] > 200)\n+        abort ();\n+    }\n+\n+  foo (input, output, input2, output2);\n+\n+  for (i = 0; i < N; i++)\n+     if (output[i] != check_results[i] || output2[i] != check_results2[i])\n+       abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+"}, {"sha": "8c60d44ed0c491223432df8059c308ceb3a22e87", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-8.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-8.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 200\n+\n+void foo (unsigned char *__restrict__ pInput, unsigned char *__restrict__ pOutput)\n+{\n+  unsigned char i, a, b, c;\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+\n+       *pOutput++ = a + b + c + 3;\n+       *pOutput++ = a + b + c + 12;\n+       *pOutput++ = a + b + c + 1;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned char input[N], output[N], i;\n+  unsigned char check_results[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i;\n+      output[i] = 0;\n+      if (input[i] > 256)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+      check_results[3*i] = 9 * i + 6;\n+      check_results[3*i+1] = 9 * i + 15;\n+      check_results[3*i+2] = 9 * i + 4;\n+    }\n+\n+  foo (input, output);\n+\n+  for (i = 0; i < N - (N % 3); i++)\n+     if (output[i] != check_results[i])\n+       abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "964e691cc68fc6013bb6a7a992499dcfff839beb", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-9.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 200\n+\n+void foo (unsigned short *__restrict__ pInput, unsigned short *__restrict__ pOutput)\n+{\n+  unsigned short i, a, b, c;\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+       a = *pInput++;\n+       b = *pInput++;\n+       c = *pInput++;\n+\n+       *pOutput++ = a + b + c + 3;\n+       *pOutput++ = a + b + c + 12;\n+       *pOutput++ = a + b + c + 1;\n+    }\n+}\n+\n+int main (int argc, const char* argv[])\n+{\n+  unsigned short input[N], output[N], i;\n+  unsigned short check_results[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      input[i] = i;\n+      output[i] = 0;\n+      if (input[i] > 256)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N / 3; i++)\n+    {\n+      check_results[3*i] = 9 * i + 6;\n+      check_results[3*i+1] = 9 * i + 15;\n+      check_results[3*i+2] = 9 * i + 4;\n+    }\n+\n+  foo (input, output);\n+\n+  for (i = 0; i < N - (N % 3); i++)\n+     if (output[i] != check_results[i])\n+       abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "e508038dfdbd6f2620d179f8d5b0e8b39c3e1726", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -1608,6 +1608,28 @@ proc check_effective_target_vect_no_bitwise { } {\n     return $et_vect_no_bitwise_saved\n }\n \n+# Return 1 if the target plus current options supports vector permutation,\n+# 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_perm { } {\n+    global et_vect_perm\n+\n+    if [info exists et_vect_perm_saved] {\n+        verbose \"check_effective_target_vect_perm: using cached result\" 2\n+    } else {\n+        set et_vect_perm_saved 0\n+        if { [istarget powerpc*-*-*]\n+             || [istarget spu-*-*] } {\n+            set et_vect_perm_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_perm: returning $et_vect_perm_saved\" 2\n+    return $et_vect_perm_saved\n+}\n+\n+\n # Return 1 if the target plus current options supports a vector\n # widening summation of *short* args into *int* result, 0 otherwise.\n # A target can also support this widening summation if it can support"}, {"sha": "c672d7affecbddd09720302e205a68fed4686ce7", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 259, "deletions": 80, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -486,7 +486,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t\t|| vectorizable_conversion (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_operation (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_assignment (stmt, NULL, NULL, NULL)\n-\t\t|| vectorizable_load (stmt, NULL, NULL, NULL)\n+\t\t|| vectorizable_load (stmt, NULL, NULL, NULL, NULL)\n \t\t|| vectorizable_call (stmt, NULL, NULL)\n \t\t|| vectorizable_store (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_condition (stmt, NULL, NULL)\n@@ -846,6 +846,31 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n }\n \n \n+/* Find the place of the data-ref in STMT in the interleaving chain that starts\n+   from FIRST_STMT. Return -1 if the data-ref is not a part of the chain.  */\n+\n+static int \n+vect_get_place_in_interleaving_chain (gimple stmt, gimple first_stmt)\n+{\n+  gimple next_stmt = first_stmt;\n+  int result = 0;\n+\n+  if (first_stmt != DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)))\n+    return -1;\n+\n+  while (next_stmt && next_stmt != stmt)\n+    {\n+      result++;\n+      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+    }\n+\n+  if (next_stmt)\n+    return result;\n+  else\n+    return -1;\n+}\n+\n+\n /* Function vect_insert_into_interleaving_chain.\n \n    Insert DRA into the interleaving chain of DRB according to DRA's INIT.  */\n@@ -2482,7 +2507,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n \n-void\n+static void\n vect_free_slp_tree (slp_tree node)\n {\n   if (!node)\n@@ -2503,6 +2528,17 @@ vect_free_slp_tree (slp_tree node)\n }\n \n \n+/* Free the memory allocated for the SLP instance.  */\n+\n+void\n+vect_free_slp_instance (slp_instance instance)\n+{\n+  vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n+  VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (instance));\n+  VEC_free (slp_tree, heap, SLP_INSTANCE_LOADS (instance));\n+}\n+\n+\n /* Get the defs for the rhs of STMT (collect them in DEF_STMTS0/1), check that\n    they are of a legal type and that they match the defs of the first stmt of\n    the SLP group (stored in FIRST_STMT_...).  */\n@@ -2705,7 +2741,9 @@ static bool\n vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node, \n \t\t     unsigned int group_size, \n \t\t     int *inside_cost, int *outside_cost,\n-\t\t     int ncopies_for_cost, unsigned int *max_nunits)\n+\t\t     int ncopies_for_cost, unsigned int *max_nunits,\n+                     VEC (int, heap) **load_permutation,\n+                     VEC (slp_tree, heap) **loads)\n {\n   VEC (gimple, heap) *def_stmts0 = VEC_alloc (gimple, heap, group_size);\n   VEC (gimple, heap) *def_stmts1 =  VEC_alloc (gimple, heap, group_size);\n@@ -2716,7 +2754,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n   enum tree_code first_stmt_code = 0, rhs_code;\n   tree first_stmt_def1_type = NULL_TREE, first_stmt_def0_type = NULL_TREE;\n   tree lhs;\n-  gimple prev_stmt = NULL;\n   bool stop_recursion = false, need_same_oprnds = false;\n   tree vectype, scalar_type, first_op1 = NULL_TREE;\n   unsigned int vectorization_factor = 0, ncopies;\n@@ -2728,6 +2765,9 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n   struct data_reference *first_dr;\n   bool pattern0 = false, pattern1 = false;\n   HOST_WIDE_INT dummy;\n+  bool permutation = false;\n+  unsigned int load_place;\n+  gimple first_load;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   for (i = 0; VEC_iterate (gimple, stmts, i, stmt); i++)\n@@ -2813,8 +2853,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t\t  if (icode == CODE_FOR_nothing)\n \t\t    {\n \t\t      if (vect_print_dump_info (REPORT_SLP))\n-\t\t\tfprintf (vect_dump,\n-\t\t\t\t \"Build SLP failed: op not supported by target.\");\n+\t\t\tfprintf (vect_dump, \"Build SLP failed: \"\n+\t\t\t\t            \"op not supported by target.\");\n \t\t      return false;\n \t\t    }\n \t\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n@@ -2878,70 +2918,60 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t    else\n \t      {\n \t\t/* Load.  */\n-\t\tif (i == 0)\n-\t\t  {\n-\t\t    /* First stmt of the SLP group should be the first load of \n-\t\t       the interleaving loop if data permutation is not allowed.\n-\t\t       Check that there is no gap between the loads.  */\n-\t\t    if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) != stmt\n-                        || DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 0) \n-\t\t      {\n-\t\t\t/* FORNOW: data permutations and gaps in loads are not \n-                           supported.  */\n-\t\t\tif (vect_print_dump_info (REPORT_SLP)) \n-\t\t\t  {\n-\t\t\t    fprintf (vect_dump, \"Build SLP failed: strided \"\n-\t\t\t\t     \" loads need permutation or have gaps \");\n-\t\t\t    print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-\t\t\t  }\n-\n-\t\t\treturn false;\n-\t\t      }\n-\n-\t\t    first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n-\t\t    if (vect_supportable_dr_alignment (first_dr)\n-\t\t\t== dr_unaligned_unsupported)\n-\t\t      {\n-\t\t\tif (vect_print_dump_info (REPORT_SLP)) \n-\t\t\t  {\n-\t\t\t    fprintf (vect_dump, \"Build SLP failed: unsupported \"\n-\t\t\t\t     \" unaligned load \");\n-\t\t\t    print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-\t\t\t  }\n-\n-\t\t\treturn false;\n-\t\t      }\n-\n-\t\t    /* Analyze costs (for the first stmt in the group).  */\n-\t\t    vect_model_load_cost (vinfo_for_stmt (stmt), \n-\t\t\t\t\t  ncopies_for_cost, *node);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-                    /* Check that we have consecutive loads from interleaving\n-                       chain and that there is no gap between the loads.  */\n-\t\t    if (DR_GROUP_NEXT_DR (vinfo_for_stmt (prev_stmt)) != stmt\n-                        || DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 1)\n-\t\t      {\n-\t\t\t/* FORNOW: data permutations and gaps in loads are not\n-                           supported.  */\n-\t\t\tif (vect_print_dump_info (REPORT_SLP)) \n-\t\t\t  {\n-\t\t\t    fprintf (vect_dump, \"Build SLP failed: strided \"\n-\t\t\t\t     \" loads need permutation or have gaps \");\n-\t\t\t    print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-\t\t\t  }\n-\t\t\treturn false;\n-\t\t      }\n-\t\t  }\n-\n-\t\tprev_stmt = stmt;\n-\n-\t\t/* We stop the tree when we reach a group of loads.  */\n-\t\tstop_recursion = true;\n-\t\tcontinue;\n-\t      }\n-\t} /* Strided access.  */\n+                /* FORNOW: Check that there is no gap between the loads.  */\n+                if ((DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) == stmt\n+                     && DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 0)\n+                    || (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) != stmt\n+                        && DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 1))\n+                  {\n+                    if (vect_print_dump_info (REPORT_SLP))\n+                      {\n+                        fprintf (vect_dump, \"Build SLP failed: strided \"\n+                                            \"loads have gaps \");\n+                        print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                      }\n+ \n+                    return false;\n+                  }\n+ \n+                first_load = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt));\n+ \n+              if (first_load == stmt)\n+                {\n+                  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n+                  if (vect_supportable_dr_alignment (first_dr)\n+                      == dr_unaligned_unsupported)\n+                    {\n+                      if (vect_print_dump_info (REPORT_SLP))\n+                        {\n+                          fprintf (vect_dump, \"Build SLP failed: unsupported \"\n+                                              \"unaligned load \");\n+                          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                        }\n+  \n+                      return false;\n+                    }\n+ \n+                  /* Analyze costs (for the first stmt in the group).  */\n+                  vect_model_load_cost (vinfo_for_stmt (stmt),\n+                                        ncopies_for_cost, *node);\n+                }\n+  \n+              /* Store the place of this load in the interleaving chain. In\n+                 case that permutation is needed we later decide if a specific\n+                 permutation is supported.  */\n+              load_place = vect_get_place_in_interleaving_chain (stmt,\n+                                                                 first_load);\n+              if (load_place != i)\n+                permutation = true;\n+ \n+              VEC_safe_push (int, heap, *load_permutation, load_place);\n+ \n+              /* We stop the tree when we reach a group of loads.  */\n+              stop_recursion = true;\n+             continue;\n+           }\n+        } /* Strided access.  */\n       else\n \t{\n \t  if (TREE_CODE_CLASS (rhs_code) == tcc_reference)\n@@ -2990,7 +3020,15 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \n   /* Strided loads were reached - stop the recursion.  */\n   if (stop_recursion)\n-    return true;\n+    {\n+      if (permutation)\n+        {\n+          VEC_safe_push (slp_tree, heap, *loads, *node); \n+          *inside_cost += TARG_VEC_PERMUTE_COST * group_size;  \n+        }\n+\n+      return true;\n+    }\n \n   /* Create SLP_TREE nodes for the definition node/s.  */ \n   if (first_stmt_dt0 == vect_loop_def)\n@@ -3003,8 +3041,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_OUTSIDE_OF_LOOP_COST (left_node) = 0;\n       SLP_TREE_INSIDE_OF_LOOP_COST (left_node) = 0;\n       if (!vect_build_slp_tree (loop_vinfo, &left_node, group_size, \n-\t\t\t\tinside_cost, outside_cost,\n-\t\t\t\tncopies_for_cost, max_nunits))\n+\t\t\t\tinside_cost, outside_cost, ncopies_for_cost, \n+\t\t\t\tmax_nunits, load_permutation, loads))\n \treturn false;\n       \n       SLP_TREE_LEFT (*node) = left_node;\n@@ -3020,8 +3058,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_OUTSIDE_OF_LOOP_COST (right_node) = 0;\n       SLP_TREE_INSIDE_OF_LOOP_COST (right_node) = 0;\n       if (!vect_build_slp_tree (loop_vinfo, &right_node, group_size,\n-\t\t\t\tinside_cost, outside_cost,\n-\t\t\t\tncopies_for_cost, max_nunits))\n+\t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n+\t\t\t\tmax_nunits, load_permutation, loads))\n \treturn false;\n       \n       SLP_TREE_RIGHT (*node) = right_node;\n@@ -3076,6 +3114,116 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n }\n \n \n+/* Check if the permutation required by the SLP INSTANCE is supported.  \n+   Reorganize the SLP nodes stored in SLP_INSTANCE_LOADS if needed.  */\n+\n+static bool\n+vect_supported_slp_permutation_p (slp_instance instance)\n+{\n+  slp_tree node = VEC_index (slp_tree, SLP_INSTANCE_LOADS (instance), 0);\n+  gimple stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n+  gimple first_load = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt));\n+  VEC (slp_tree, heap) *sorted_loads = NULL;\n+  int index;\n+  slp_tree *tmp_loads = NULL;\n+  int group_size = SLP_INSTANCE_GROUP_SIZE (instance), i, j; \n+  slp_tree load;\n+ \n+  /* FORNOW: The only supported loads permutation is loads from the same \n+     location in all the loads in the node, when the data-refs in\n+     nodes of LOADS constitute an interleaving chain.  \n+     Sort the nodes according to the order of accesses in the chain.  */\n+  tmp_loads = (slp_tree *) xmalloc (sizeof (slp_tree) * group_size);\n+  for (i = 0, j = 0; \n+       VEC_iterate (int, SLP_INSTANCE_LOAD_PERMUTATION (instance), i, index) \n+       && VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (instance), j, load); \n+       i += group_size, j++)\n+    {\n+      gimple scalar_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (load), 0);\n+      /* Check that the loads are all in the same interleaving chain.  */\n+      if (DR_GROUP_FIRST_DR (vinfo_for_stmt (scalar_stmt)) != first_load)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"Build SLP failed: unsupported data \"\n+                                   \"permutation \");\n+              print_gimple_stmt (vect_dump, scalar_stmt, 0, TDF_SLIM);\n+            }\n+             \n+          free (tmp_loads);\n+          return false; \n+        }\n+\n+      tmp_loads[index] = load;\n+    }\n+  \n+  sorted_loads = VEC_alloc (slp_tree, heap, group_size);\n+  for (i = 0; i < group_size; i++)\n+     VEC_safe_push (slp_tree, heap, sorted_loads, tmp_loads[i]);\n+\n+  VEC_free (slp_tree, heap, SLP_INSTANCE_LOADS (instance));\n+  SLP_INSTANCE_LOADS (instance) = sorted_loads;\n+  free (tmp_loads);\n+\n+  if (!vect_transform_slp_perm_load (stmt, NULL, NULL,\n+                                     SLP_INSTANCE_UNROLLING_FACTOR (instance),\n+                                     instance, true))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Check if the required load permutation is supported.\n+   LOAD_PERMUTATION contains a list of indices of the loads.\n+   In SLP this permutation is relative to the order of strided stores that are\n+   the base of the SLP instance.  */\n+\n+static bool\n+vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n+                                   VEC (int, heap) *load_permutation)\n+{\n+  int i = 0, j, prev = -1, next, k;\n+  bool supported;\n+\n+  /* FORNOW: permutations are only supported for loop-aware SLP.  */\n+  if (!slp_instn)\n+    return false;\n+\n+  if (vect_print_dump_info (REPORT_SLP))\n+    {\n+      fprintf (vect_dump, \"Load permutation \");\n+      for (i = 0; VEC_iterate (int, load_permutation, i, next); i++)\n+        fprintf (vect_dump, \"%d \", next);\n+    }\n+\n+  /* FORNOW: the only supported permutation is 0..01..1.. of length equal to \n+     GROUP_SIZE and where each sequence of same drs is of GROUP_SIZE length as \n+     well.  */\n+  supported = true;\n+  for (j = 0; j < group_size; j++)\n+    {\n+      for (i = j * group_size, k = 0;\n+           VEC_iterate (int, load_permutation, i, next) && k < group_size;\n+           i++, k++)\n+       {\n+         if (i != j * group_size && next != prev)\n+          {\n+            supported = false;\n+            break;\n+          }\n+\n+         prev = next;\n+       }  \n+    }\n+\n+  if (supported && i == group_size * group_size\n+      && vect_supported_slp_permutation_p (slp_instn))\n+    return true;\n+\n+  return false; \n+}\n+\n /* Analyze an SLP instance starting from a group of strided stores. Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.  \n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n@@ -3093,8 +3241,11 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   bool slp_impossible = false; \n   int inside_cost = 0, outside_cost = 0, ncopies_for_cost;\n   unsigned int max_nunits = 0;\n-\n-  scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))));\n+  VEC (int, heap) *load_permutation;\n+  VEC (slp_tree, heap) *loads;\n+ \n+  scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (\n+                                             vinfo_for_stmt (stmt))));\n   vectype = get_vectype_for_scalar_type (scalar_type);\n   if (!vectype)\n     {\n@@ -3134,23 +3285,49 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n      factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n      GROUP_SIZE / NUNITS otherwise.  */\n   ncopies_for_cost = unrolling_factor * group_size / nunits;\n+  \n+  load_permutation = VEC_alloc (int, heap, group_size * group_size); \n+  loads = VEC_alloc (slp_tree, heap, group_size); \n \n   /* Build the tree for the SLP instance.  */\n   if (vect_build_slp_tree (loop_vinfo, &node, group_size, &inside_cost,  \n-\t\t\t   &outside_cost, ncopies_for_cost, &max_nunits))\n+\t\t\t   &outside_cost, ncopies_for_cost, &max_nunits,\n+                           &load_permutation, &loads))\n     {\n       /* Create a new SLP instance.  */  \n       new_instance = XNEW (struct _slp_instance);\n       SLP_INSTANCE_TREE (new_instance) = node;\n       SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n-      /* Calculate the unrolling factor based on the smallest type.  */\n+      /* Calculate the unrolling factor based on the smallest type in the\n+         loop.  */\n       if (max_nunits > nunits)\n         unrolling_factor = least_common_multiple (max_nunits, group_size)\n                            / group_size;\n \n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n       SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n       SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;\n+      SLP_INSTANCE_LOADS (new_instance) = loads;\n+      SLP_INSTANCE_LOAD_PERMUTATION (new_instance) = load_permutation;\n+      if (VEC_length (slp_tree, loads))\n+        {\n+          if (!vect_supported_load_permutation_p (new_instance, group_size,\n+                                                  load_permutation)) \n+            {\n+              if (vect_print_dump_info (REPORT_SLP))\n+                {\n+                  fprintf (vect_dump, \"Build SLP failed: unsupported load \"\n+                                      \"permutation \");\n+                  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                }\n+\n+              vect_free_slp_instance (new_instance);\n+              return false;\n+            }\n+        }\n+      else\n+        VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (new_instance));\n+\n       VEC_safe_push (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo), \n \t\t     new_instance);\n       if (vect_print_dump_info (REPORT_SLP))\n@@ -3162,7 +3339,9 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   /* Failed to SLP.  */\n   /* Free the allocated memory.  */\n   vect_free_slp_tree (node);\n-\n+  VEC_free (int, heap, load_permutation);\n+  VEC_free (slp_tree, heap, loads);\n+   \n   if (slp_impossible)\n     return false;\n "}, {"sha": "3a77c5bab1c0a718ad5c46cf852daafbdfaed4e1", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 377, "deletions": 28, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Utility functions for the code transformation.  */\n static bool vect_transform_stmt (gimple, gimple_stmt_iterator *, bool *,\n-\t\t\t\t slp_tree);\n+\t\t\t\t slp_tree, slp_instance);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n   (gimple, struct loop*, tree, tree *, gimple *, bool, bool *);\n@@ -936,7 +936,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n       base_offset = force_gimple_operand (base_offset, &seq, false, tmp);\n       gimple_seq_add_seq (new_stmt_list, seq);\n     }\n-  \n+\n   /* base + base_offset */\n   addr_base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (data_ref_base), \n \t\t\t   data_ref_base, base_offset);\n@@ -5962,6 +5962,313 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n }\n \n \n+/* Create NCOPIES permutation statements using the mask MASK_BYTES (by \n+   building a vector of type MASK_TYPE from it) and two input vectors placed in\n+   DR_CHAIN at FIRST_VEC_INDX and SECOND_VEC_INDX for the first copy and\n+   shifting by STRIDE elements of DR_CHAIN for every copy.\n+   (STRIDE is the number of vectorized stmts for NODE divided by the number of\n+   copies).  \n+   VECT_STMTS_COUNTER specifies the index in the vectorized stmts of NODE, where\n+   the created stmts must be inserted.  */\n+\n+static inline void\n+vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt, \n+                           int *mask_array, int mask_nunits, \n+                           tree mask_element_type, tree mask_type,\n+                           int first_vec_indx, int second_vec_indx, \n+                           gimple_stmt_iterator *gsi, slp_tree node, \n+                           tree builtin_decl, tree vectype, \n+                           VEC(tree,heap) *dr_chain,\n+                           int ncopies, int vect_stmts_counter)\n+{\n+  tree t = NULL_TREE, mask_vec, mask, perm_dest;\n+  gimple perm_stmt = NULL;\n+  stmt_vec_info next_stmt_info;\n+  int i, group_size, stride, dr_chain_size;\n+  tree first_vec, second_vec, data_ref;\n+  tree sym;\n+  ssa_op_iter iter;\n+  VEC (tree, heap) *params = NULL;\n+\n+  /* Create a vector mask.  */\n+  for (i = mask_nunits - 1; i >= 0; --i)\n+    t = tree_cons (NULL_TREE, build_int_cst (mask_element_type, mask_array[i]),\n+                   t);\n+\n+  mask_vec = build_vector (mask_type, t);\n+  mask = vect_init_vector (stmt, mask_vec, mask_type, NULL);\n+\n+  group_size = VEC_length (gimple, SLP_TREE_SCALAR_STMTS (node));\n+  stride = SLP_TREE_NUMBER_OF_VEC_STMTS (node) / ncopies;\n+  dr_chain_size = VEC_length (tree, dr_chain); \n+\n+  /* Initialize the vect stmts of NODE to properly insert the generated \n+     stmts later.  */\n+  for (i = VEC_length (gimple, SLP_TREE_VEC_STMTS (node)); \n+       i < (int) SLP_TREE_NUMBER_OF_VEC_STMTS (node); i++)\n+    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (node), NULL);\n+\n+  perm_dest = vect_create_destination_var (gimple_assign_lhs (stmt), vectype);\n+  for (i = 0; i < ncopies; i++)\n+    {\n+      first_vec = VEC_index (tree, dr_chain, first_vec_indx);\n+      second_vec = VEC_index (tree, dr_chain, second_vec_indx);\n+\n+      /* Build argument list for the vectorized call.  */\n+      VEC_free (tree, heap, params);\n+      params = VEC_alloc (tree, heap, 3);\n+      VEC_quick_push (tree, params, first_vec);\n+      VEC_quick_push (tree, params, second_vec);\n+      VEC_quick_push (tree, params, mask);\n+\n+      /* Generate the permute statement.  */\n+      perm_stmt = gimple_build_call_vec (builtin_decl, params);\n+      data_ref = make_ssa_name (perm_dest, perm_stmt);\n+      gimple_call_set_lhs (perm_stmt, data_ref);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      FOR_EACH_SSA_TREE_OPERAND (sym, perm_stmt, iter, SSA_OP_ALL_VIRTUALS)\n+        {\n+          if (TREE_CODE (sym) == SSA_NAME)\n+            sym = SSA_NAME_VAR (sym);\n+          mark_sym_for_renaming (sym);\n+        }\n+\n+      /* Store the vector statement in NODE.  */ \n+      VEC_replace (gimple, SLP_TREE_VEC_STMTS (node), \n+                   stride * i + vect_stmts_counter, perm_stmt);\n+\n+      first_vec_indx += stride;\n+      second_vec_indx += stride;\n+    }\n+\n+  /* Mark the scalar stmt as vectorized.  */\n+  next_stmt_info = vinfo_for_stmt (next_scalar_stmt);\n+  STMT_VINFO_VEC_STMT (next_stmt_info) = perm_stmt;\n+}\n+\n+\n+/* Given FIRST_MASK_ELEMENT - the mask element in element representation, \n+   return in CURRENT_MASK_ELEMENT its equivalent in target specific\n+   representation. Check that the mask is valid and return FALSE if not. \n+   Return TRUE in NEED_NEXT_VECTOR if the permutation requires to move to\n+   the next vector, i.e., the current first vector is not needed.  */\n+   \n+static bool\n+vect_get_mask_element (gimple stmt, int first_mask_element, int m, \n+                       int mask_nunits, bool only_one_vec, int index,\n+                       int *mask, int *current_mask_element, \n+                       bool *need_next_vector)\n+{\n+  int i;\n+  static int number_of_mask_fixes = 1;\n+  static bool mask_fixed = false;\n+  static bool needs_first_vector = false;\n+\n+  /* Convert to target specific representation.  */\n+  *current_mask_element = first_mask_element + m;\n+  /* Adjust the value in case it's a mask for second and third vectors.  */\n+  *current_mask_element -= mask_nunits * (number_of_mask_fixes - 1);\n+\n+  if (*current_mask_element < mask_nunits)\n+    needs_first_vector = true;\n+\n+  /* We have only one input vector to permute but the mask accesses values in\n+     the next vector as well.  */\n+  if (only_one_vec && *current_mask_element >= mask_nunits)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"permutation requires at least two vectors \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+      return false;\n+    }\n+\n+  /* The mask requires the next vector.  */\n+  if (*current_mask_element >= mask_nunits * 2)\n+    {\n+      if (needs_first_vector || mask_fixed)\n+        {\n+          /* We either need the first vector too or have already moved to the\n+             next vector. In both cases, this permutation needs three   \n+             vectors.  */\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"permutation requires at \"\n+                                  \"least three vectors \");\n+              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+            }\n+\n+          return false;\n+        }\n+\n+      /* We move to the next vector, dropping the first one and working with\n+         the second and the third - we need to adjust the values of the mask\n+         accordingly.  */\n+      *current_mask_element -= mask_nunits * number_of_mask_fixes;\n+\n+      for (i = 0; i < index; i++)\n+        mask[i] -= mask_nunits * number_of_mask_fixes;\n+\n+      (number_of_mask_fixes)++;\n+      mask_fixed = true;\n+    }\n+\n+  *need_next_vector = mask_fixed;\n+\n+  /* This was the last element of this mask. Start a new one.  */\n+  if (index == mask_nunits - 1)\n+    {\n+      number_of_mask_fixes = 1;\n+      mask_fixed = false;\n+      needs_first_vector = false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Generate vector permute statements from a list of loads in DR_CHAIN.\n+   If ANALYZE_ONLY is TRUE, only check that it is possible to create valid\n+   permute statements for SLP_NODE_INSTANCE.  */\n+bool\n+vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n+                              gimple_stmt_iterator *gsi, int vf,\n+                              slp_instance slp_node_instance, bool analyze_only)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree mask_element_type = NULL_TREE, mask_type;\n+  int i, j, k, m, scale, mask_nunits, nunits, vec_index = 0, scalar_index;\n+  slp_tree node;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info), builtin_decl;\n+  gimple next_scalar_stmt;\n+  int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n+  int first_mask_element;\n+  int index, unroll_factor, *mask, current_mask_element, ncopies;\n+  bool only_one_vec = false, need_next_vector = false;\n+  int first_vec_index, second_vec_index, orig_vec_stmts_num, vect_stmts_counter;\n+\n+  if (!targetm.vectorize.builtin_vec_perm)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"no builtin for vect permute for \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+       return false;\n+    }\n+\n+  builtin_decl = targetm.vectorize.builtin_vec_perm (vectype,\n+                                                     &mask_element_type);\n+  if (!builtin_decl || !mask_element_type)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"no builtin for vect permute for \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+       return false;\n+    }\n+\n+  mask_type = get_vectype_for_scalar_type (mask_element_type);\n+  mask_nunits = TYPE_VECTOR_SUBPARTS (mask_type);\n+  mask = (int *) xmalloc (sizeof (int) * mask_nunits);\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  scale = mask_nunits / nunits;\n+  unroll_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n+\n+  /* The number of vector stmts to generate based only on SLP_NODE_INSTANCE\n+     unrolling factor.  */\n+  orig_vec_stmts_num = group_size * \n+                SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance) / nunits;\n+  if (orig_vec_stmts_num == 1)\n+    only_one_vec = true;\n+\n+  /* Number of copies is determined by the final vectorization factor \n+     relatively to SLP_NODE_INSTANCE unrolling factor.  */\n+  ncopies = vf / SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance); \n+\n+  /* Generate permutation masks for every NODE. Number of masks for each NODE \n+     is equal to GROUP_SIZE.  \n+     E.g., we have a group of three nodes with three loads from the same \n+     location in each node, and the vector size is 4. I.e., we have a \n+     a0b0c0a1b1c1... sequence and we need to create the following vectors: \n+     for a's: a0a0a0a1 a1a1a2a2 a2a3a3a3\n+     for b's: b0b0b0b1 b1b1b2b2 b2b3b3b3\n+     ...\n+\n+     The masks for a's should be: {0,0,0,3} {3,3,6,6} {6,9,9,9} (in target\n+     scpecific type, e.g., in bytes for Altivec.\n+     The last mask is illegal since we assume two operands for permute \n+     operation, and the mask element values can't be outside that range. Hence,\n+     the last mask must be converted into {2,5,5,5}.\n+     For the first two permutations we need the first and the second input \n+     vectors: {a0,b0,c0,a1} and {b1,c1,a2,b2}, and for the last permutation\n+     we need the second and the third vectors: {b1,c1,a2,b2} and \n+     {c2,a3,b3,c3}.  */\n+\n+  for (i = 0;\n+       VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (slp_node_instance),\n+                    i, node);\n+       i++)\n+    {\n+      scalar_index = 0;\n+      index = 0;\n+      vect_stmts_counter = 0;\n+      vec_index = 0;\n+      first_vec_index = vec_index++;\n+      if (only_one_vec)\n+        second_vec_index = first_vec_index;\n+      else\n+        second_vec_index =  vec_index++;\n+\n+      for (j = 0; j < unroll_factor; j++)\n+        {\n+          for (k = 0; k < group_size; k++)\n+            {\n+              first_mask_element = (i + j * group_size) * scale;\n+              for (m = 0; m < scale; m++)\n+                {\n+                  if (!vect_get_mask_element (stmt, first_mask_element, m, \n+                                   mask_nunits, only_one_vec, index, mask,\n+                                   &current_mask_element, &need_next_vector))\n+                    return false;\n+\n+                  mask[index++] = current_mask_element;\n+                } \n+\n+              if (index == mask_nunits)\n+                {\n+                  index = 0;\n+                  if (!analyze_only)\n+                    {\n+                      if (need_next_vector)\n+                        {\n+                          first_vec_index = second_vec_index;\n+                          second_vec_index = vec_index;\n+                        }\n+\n+                      next_scalar_stmt = VEC_index (gimple,\n+                                SLP_TREE_SCALAR_STMTS (node), scalar_index++);\n+\n+                      vect_create_mask_and_perm (stmt, next_scalar_stmt,\n+                               mask, mask_nunits, mask_element_type, mask_type, \n+                               first_vec_index, second_vec_index, gsi, node, \n+                               builtin_decl, vectype, dr_chain, ncopies, \n+                               vect_stmts_counter++);\n+                    }\n+                } \n+            } \n+        } \n+    } \n+\n+  free (mask);\n+  return true;\n+}\n+\n /* vectorizable_load.\n \n    Check if STMT reads a non scalar data-ref (array/pointer/structure) that \n@@ -5972,7 +6279,7 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n \n bool\n vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n-\t\t   slp_tree slp_node)\n+\t\t   slp_tree slp_node, slp_instance slp_node_instance)\n {\n   tree scalar_dest;\n   tree vec_dest = NULL;\n@@ -6008,6 +6315,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   struct loop *at_loop;\n   int vec_num;\n   bool slp = (slp_node != NULL);\n+  bool slp_perm = false;\n   enum tree_code code;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n@@ -6028,6 +6336,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n+  if (slp && SLP_INSTANCE_LOAD_PERMUTATION (slp_node_instance))\n+    slp_perm = true;\n+ \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -6397,33 +6708,47 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n \t  /* Collect vector loads and later create their permutation in\n \t     vect_transform_strided_load ().  */\n-          if (strided_load)\n+          if (strided_load || slp_perm)\n             VEC_quick_push (tree, dr_chain, new_temp);\n \n          /* Store vector loads in the corresponding SLP_NODE.  */\n-\t  if (slp)\n+\t  if (slp && !slp_perm)\n \t    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n \t}\n \n-      if (slp)\n+      if (slp && !slp_perm)\n \tcontinue;\n \n-      if (strided_load)\n-\t{\n-\t  if (!vect_transform_strided_load (stmt, dr_chain, group_size, gsi))\n-\t    return false;\t  \n-\t  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n-          VEC_free (tree, heap, dr_chain);\n-\t  dr_chain = VEC_alloc (tree, heap, group_size);\n-\t}\n+      if (slp_perm)\n+        {\n+          if (!vect_transform_slp_perm_load (stmt, dr_chain, gsi,\n+                                   LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+                                             slp_node_instance, false))\n+            {\n+              VEC_free (tree, heap, dr_chain);\n+              return false;\n+            }\n+        }\n       else\n-\t{\n-\t  if (j == 0)\n-\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n-\t  else\n-\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n-\t}\n+        {\n+          if (strided_load)\n+  \t    {\n+\t      if (!vect_transform_strided_load (stmt, dr_chain, group_size, gsi))\n+\t        return false;\t  \n+\n+\t      *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+              VEC_free (tree, heap, dr_chain);\n+\t      dr_chain = VEC_alloc (tree, heap, group_size);\n+\t    }\n+          else\n+\t    {\n+\t      if (j == 0)\n+\t        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t      else\n+\t        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t    }\n+        }\n     }\n \n   if (dr_chain)\n@@ -6690,7 +7015,8 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n \n static bool\n vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n-\t\t     bool *strided_store, slp_tree slp_node)\n+\t\t     bool *strided_store, slp_tree slp_node, \n+                     slp_instance slp_node_instance)\n {\n   bool is_store = false;\n   gimple vec_stmt = NULL;\n@@ -6732,7 +7058,8 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       break;\n \n     case load_vec_info_type:\n-      done = vectorizable_load (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_load (stmt, gsi, &vec_stmt, slp_node, \n+                                slp_node_instance);\n       gcc_assert (done);\n       break;\n \n@@ -7807,6 +8134,8 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   stmt_vec_info stmt_info;\n   unsigned int vec_stmts_size, nunits, group_size;\n   tree vectype;\n+  int i;\n+  slp_tree loads_node;\n \n   if (!node)\n     return false;\n@@ -7830,8 +8159,28 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n      size.  */\n   vec_stmts_size = (vectorization_factor * group_size) / nunits;\n \n-  SLP_TREE_VEC_STMTS (node) = VEC_alloc (gimple, heap, vec_stmts_size);\n-  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n+  /* In case of load permutation we have to allocate vectorized statements for\n+     all the nodes that participate in that permutation.  */\n+  if (SLP_INSTANCE_LOAD_PERMUTATION (instance))\n+    {\n+      for (i = 0;\n+           VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (instance), i, loads_node);\n+           i++)\n+        {\n+          if (!SLP_TREE_VEC_STMTS (loads_node))\n+            {\n+              SLP_TREE_VEC_STMTS (loads_node) = VEC_alloc (gimple, heap,\n+                                                           vec_stmts_size);\n+              SLP_TREE_NUMBER_OF_VEC_STMTS (loads_node) = vec_stmts_size;\n+            }\n+        }\n+    }\n+\n+  if (!SLP_TREE_VEC_STMTS (node))\n+    {\n+      SLP_TREE_VEC_STMTS (node) = VEC_alloc (gimple, heap, vec_stmts_size);\n+      SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n+    }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -7840,7 +8189,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n     }\t\n \n   si = gsi_for_stmt (stmt);\n-  is_store = vect_transform_stmt (stmt, &si, &strided_store, node);\n+  is_store = vect_transform_stmt (stmt, &si, &strided_store, node, instance);\n   if (is_store)\n     {\n       if (DR_GROUP_FIRST_DR (stmt_info))\n@@ -7980,7 +8329,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tfprintf (vect_dump, \"transform phi.\");\n-\t      vect_transform_stmt (phi, NULL, NULL, NULL);\n+\t      vect_transform_stmt (phi, NULL, NULL, NULL, NULL);\n \t    }\n \t}\n \n@@ -8059,7 +8408,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    fprintf (vect_dump, \"transform statement.\");\n \n \t  strided_store = false;\n-\t  is_store = vect_transform_stmt (stmt, &si, &strided_store, NULL);\n+\t  is_store = vect_transform_stmt (stmt, &si, &strided_store, NULL, NULL);\n           if (is_store)\n             {\n \t      if (STMT_VINFO_STRIDED_ACCESS (stmt_info))"}, {"sha": "cdab0b54df0db51fc60dc69658dcfa3e186154df", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -1802,7 +1802,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   VEC_free (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n   slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   for (j = 0; VEC_iterate (slp_instance, slp_instances, j, instance); j++)\n-    vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n+    vect_free_slp_instance (instance);\n+\n   VEC_free (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n   VEC_free (gimple, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo));\n "}, {"sha": "678dc59da72981bc675ecb2ccbb34599ae65d065", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca40f598654f83453b17e44f902183859b16e4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0fca40f598654f83453b17e44f902183859b16e4", "patch": "@@ -105,6 +105,8 @@ typedef struct _slp_tree {\n   } cost;\n } *slp_tree;\n \n+DEF_VEC_P(slp_tree);\n+DEF_VEC_ALLOC_P(slp_tree, heap);\n \n /* SLP instance is a sequence of stmts in a loop that can be packed into\n    SIMD stmts.  */\n@@ -124,6 +126,13 @@ typedef struct _slp_instance {\n     int outside_of_loop;     /* Statements generated outside loop.  */\n     int inside_of_loop;      /* Statements generated inside loop.  */\n   } cost;\n+\n+  /* Loads permutation relatively to the stores, NULL if there is no \n+     permutation.  */\n+  VEC (int, heap) *load_permutation;\n+\n+  /* The group of nodes that contain loads of this SLP instance.  */\n+  VEC (slp_tree, heap) *loads;\n } *slp_instance;\n \n DEF_VEC_P(slp_instance);\n@@ -135,6 +144,8 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_OUTSIDE_OF_LOOP_COST(S)     (S)->cost.outside_of_loop\n #define SLP_INSTANCE_INSIDE_OF_LOOP_COST(S)      (S)->cost.inside_of_loop\n+#define SLP_INSTANCE_LOAD_PERMUTATION(S)         (S)->load_permutation\n+#define SLP_INSTANCE_LOADS(S)                    (S)->loads\n \n #define SLP_TREE_LEFT(S)                         (S)->left\n #define SLP_TREE_RIGHT(S)                        (S)->right\n@@ -522,6 +533,11 @@ typedef struct _stmt_vec_info {\n #define TARG_VEC_STORE_COST          1\n #endif\n \n+/* Cost of vector permutation.  */\n+#ifndef TARG_VEC_PERMUTE_COST\n+#define TARG_VEC_PERMUTE_COST          1\n+#endif\n+\n /* The maximum number of intermediate steps required in multi-step type\n    conversion.  */\n #define MAX_INTERM_CVT_STEPS         3\n@@ -700,7 +716,7 @@ extern void free_stmt_vec_info (gimple stmt);\n /** In tree-vect-analyze.c  **/\n /* Driver for analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *);\n-extern void vect_free_slp_tree (slp_tree);\n+extern void vect_free_slp_instance (slp_instance);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);\n extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *, \n                                            HOST_WIDE_INT *);\n@@ -716,7 +732,7 @@ void vect_pattern_recog (loop_vec_info);\n \n /** In tree-vect-transform.c  **/\n extern bool vectorizable_load (gimple, gimple_stmt_iterator *, gimple *,\n-\t\t\t       slp_tree);\n+\t\t\t       slp_tree, slp_instance);\n extern bool vectorizable_store (gimple, gimple_stmt_iterator *, gimple *,\n \t\t\t\tslp_tree);\n extern bool vectorizable_operation (gimple, gimple_stmt_iterator *, gimple *,\n@@ -742,6 +758,9 @@ extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n extern void vect_model_store_cost (stmt_vec_info, int, enum vect_def_type, \n \t\t\t\t   slp_tree);\n extern void vect_model_load_cost (stmt_vec_info, int, slp_tree);\n+extern bool vect_transform_slp_perm_load (gimple, VEC (tree, heap) *, \n+                             gimple_stmt_iterator *, int, slp_instance, bool);\n+\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info);\n "}]}