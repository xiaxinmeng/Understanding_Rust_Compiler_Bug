{"sha": "73cf73af2392e00917de042a4692f6a0b6329ee8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjZjczYWYyMzkyZTAwOTE3ZGUwNDJhNDY5MmY2YTBiNjMyOWVlOA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-08-24T16:13:24Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-20T20:32:35Z"}, "message": "Use EDGE_EXECUTABLE in ranger and return UNDEFINED for those edges.\n\nIf an incoming edge is UNDEFINED, don't process it.  Track if other edges\nequate to a single value, and add an equivalence if appropriate.\n\n\tgcc/\n\t* gimple-range-fold.cc (fold_using_range::range_of_phi): Ignore\n\tundefined edges, apply an equivalence if appropriate.\n\t* gimple-range-gori.cc (gori_compute::outgoing_edge_range_p): Return\n\tUNDEFINED if EDGE_EXECUTABLE is not set.\n\t* gimple-range.cc (gimple_ranger::gimple_ranger): Set all edges\n\tas EXECUTABLE upon startup.\n\t(gimple_ranger::range_on_edge): Return UNDEFINED for edges without\n\tEDGE_EXECUTABLE set.\n\t* vr-values.c (set_and_propagate_unexecutable): New.\n\t(simplify_using_ranges::fold_cond): Call set_and_propagate.\n\t(simplify_using_ranges::simplify_switch_using_ranges): Ditto.\n\t* vr-values.h: Add prototype.\n\n\tgcc/testsuite/\n\t* gcc.dg/tree-ssa/evrp-ignore.c: New.", "tree": {"sha": "6cd6cfb9b9569ddf87064cc4563655b74efd3135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd6cfb9b9569ddf87064cc4563655b74efd3135"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73cf73af2392e00917de042a4692f6a0b6329ee8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73cf73af2392e00917de042a4692f6a0b6329ee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73cf73af2392e00917de042a4692f6a0b6329ee8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73cf73af2392e00917de042a4692f6a0b6329ee8/comments", "author": null, "committer": null, "parents": [{"sha": "5d110fe90afcd850ea21aee6429f22edd6b1b592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d110fe90afcd850ea21aee6429f22edd6b1b592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d110fe90afcd850ea21aee6429f22edd6b1b592"}], "stats": {"total": 176, "additions": 140, "deletions": 36}, "files": [{"sha": "80cc5c0dc0cf2a2465a061372b4710806a58c1a4", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=73cf73af2392e00917de042a4692f6a0b6329ee8", "patch": "@@ -760,26 +760,59 @@ fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n   if (!type)\n     return false;\n \n+  // Track if all executable arguments are the same.\n+  tree single_arg = NULL_TREE;\n+  bool seen_arg = false;\n+\n   // Start with an empty range, unioning in each argument's range.\n   r.set_undefined ();\n   for (x = 0; x < gimple_phi_num_args (phi); x++)\n     {\n       tree arg = gimple_phi_arg_def (phi, x);\n       edge e = gimple_phi_arg_edge (phi, x);\n \n-      // Register potential dependencies for stale value tracking.\n-      if (gimple_range_ssa_p (arg) && src.gori ())\n-\tsrc.gori ()->register_dependency (phi_def, arg);\n-\n       // Get the range of the argument on its edge.\n       src.get_phi_operand (arg_range, arg, e);\n-      // If we're recomputing the argument elsewhere, try to refine it.\n-      r.union_ (arg_range);\n+\n+      if (!arg_range.undefined_p ())\n+\t{\n+\t  // Register potential dependencies for stale value tracking.\n+\t  r.union_ (arg_range);\n+\t  if (gimple_range_ssa_p (arg) && src.gori ())\n+\t    src.gori ()->register_dependency (phi_def, arg);\n+\n+\t  // Track if all arguments are the same.\n+\t  if (!seen_arg)\n+\t    {\n+\t      seen_arg = true;\n+\t      single_arg = arg;\n+\t    }\n+\t  else if (single_arg != arg)\n+\t    single_arg = NULL_TREE;\n+\t}\n+\n       // Once the value reaches varying, stop looking.\n-      if (r.varying_p ())\n+      if (r.varying_p () && single_arg == NULL_TREE)\n \tbreak;\n     }\n \n+    // If the PHI boils down to a single effective argument, look at it.\n+    if (single_arg)\n+      {\n+\t// Symbolic arguments are equivalences.\n+\tif (gimple_range_ssa_p (single_arg))\n+\t  src.register_relation (phi, EQ_EXPR, phi_def, single_arg);\n+\telse if (src.get_operand (arg_range, single_arg)\n+\t\t && arg_range.singleton_p ())\n+\t  {\n+\t    // Numerical arguments that are a constant can be returned as\n+\t    // the constant. This can help fold later cases where even this\n+\t    // constant might have been UNDEFINED via an unreachable edge.\n+\t    r = arg_range;\n+\t    return true;\n+\t  }\n+      }\n+\n   // If SCEV is available, query if this PHI has any knonwn values.\n   if (scev_initialized_p () && !POINTER_TYPE_P (TREE_TYPE (phi_def)))\n     {"}, {"sha": "f5a35287beda2e441979787e72c36d6f55b3784a", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=73cf73af2392e00917de042a4692f6a0b6329ee8", "patch": "@@ -1214,29 +1214,22 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n   int_range_max lhs;\n   unsigned idx;\n \n+  if ((e->flags & EDGE_EXECUTABLE) == 0)\n+    {\n+      r.set_undefined ();\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"Outgoing edge %d->%d unexecutable.\\n\",\n+\t\t   e->src->index, e->dest->index);\n+      return true;\n+    }\n+\n   gcc_checking_assert (gimple_range_ssa_p (name));\n   // Determine if there is an outgoing edge.\n   gimple *stmt = outgoing.edge_range_p (lhs, e);\n   if (!stmt)\n     return false;\n \n   fur_stmt src (stmt, &q);\n-\n-  // If this edge is never taken, return undefined.\n-  gcond *gc = dyn_cast<gcond *> (stmt);\n-  if (gc)\n-    {\n-      if (((e->flags & EDGE_TRUE_VALUE) && gimple_cond_false_p (gc))\n-\t  || ((e->flags & EDGE_FALSE_VALUE) && gimple_cond_true_p (gc)))\n-\t{\n-\t  r.set_undefined ();\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      fprintf (dump_file, \"Outgoing edge %d->%d unexecutable.\\n\",\n-\t\t       e->src->index, e->dest->index);\n-\t  return true;\n-\t}\n-    }\n-\n   // If NAME can be calculated on the edge, use that.\n   if (is_export_p (name, e->src))\n     {"}, {"sha": "625d13647f75436bb72a1d639c27716e5e46a923", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=73cf73af2392e00917de042a4692f6a0b6329ee8", "patch": "@@ -34,13 +34,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"gimple-range.h\"\n+#include \"domwalk.h\"\n \n gimple_ranger::gimple_ranger () : tracer (\"\")\n {\n   // If the cache has a relation oracle, use it.\n   m_oracle = m_cache.oracle ();\n   if (dump_file && (param_evrp_mode & EVRP_MODE_TRACE))\n     tracer.enable_trace ();\n+  set_all_edges_as_executable (cfun);\n }\n \n bool\n@@ -164,27 +166,39 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n   int_range_max edge_range;\n   gcc_checking_assert (irange::supports_type_p (TREE_TYPE (name)));\n \n-  // PHI arguments can be constants, catch these here.\n-  if (!gimple_range_ssa_p (name))\n-    return range_of_expr (r, name);\n-\n   unsigned idx;\n   if ((idx = tracer.header (\"range_on_edge (\")))\n     {\n       print_generic_expr (dump_file, name, TDF_SLIM);\n       fprintf (dump_file, \") on edge %d->%d\\n\", e->src->index, e->dest->index);\n     }\n \n-  range_on_exit (r, e->src, name);\n-  gcc_checking_assert  (r.undefined_p ()\n-\t\t\t|| range_compatible_p (r.type(), TREE_TYPE (name)));\n+  // Check to see if the edge is executable.\n+  if ((e->flags & EDGE_EXECUTABLE) == 0)\n+    {\n+      r.set_undefined ();\n+      if (idx)\n+\ttracer.trailer (idx, \"range_on_edge [Unexecutable] \", true,\n+\t\t\tname, r);\n+      return true;\n+    }\n \n-  // Check to see if NAME is defined on edge e.\n-  if (m_cache.range_on_edge (edge_range, e, name))\n-    r.intersect (edge_range);\n+  bool res = true;\n+  if (!gimple_range_ssa_p (name))\n+    res = range_of_expr (r, name);\n+  else\n+    {\n+      range_on_exit (r, e->src, name);\n+      gcc_checking_assert  (r.undefined_p ()\n+\t\t\t    || range_compatible_p (r.type(), TREE_TYPE (name)));\n+\n+      // Check to see if NAME is defined on edge e.\n+      if (m_cache.range_on_edge (edge_range, e, name))\n+\tr.intersect (edge_range);\n+    }\n \n   if (idx)\n-    tracer.trailer (idx, \"range_on_edge\", true, name, r);\n+    tracer.trailer (idx, \"range_on_edge\", res, name, r);\n   return true;\n }\n "}, {"sha": "9bfaed6a50a1bd6764fb95a824b79799a035632c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp-ignore.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp-ignore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp-ignore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp-ignore.c?ref=73cf73af2392e00917de042a4692f6a0b6329ee8", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp -fno-tree-fre -fdisable-tree-ethread\" } */\n+\n+void kill(void);\n+\n+void foo (int x, int y, int z)\n+{\n+  // Establish y = [-INF, 54]\n+  if (y < 55)\n+    return;\n+\n+  // Establish z == x\n+  if (z != x)\n+    return;\n+\n+  // EVRP should transform this to if (0 != 0)\n+  if (y < 30)\n+    x = 0;\n+\n+  // # x_1 = PHI <x_5(D)(6), 0(7)>\n+  // The earlier transformation should make the edge from bb7\n+  // unexecutable, allowing x_1 == x_5 to be registered, and\n+  // then fold away this condition as well.\n+  if (x != z)\n+    kill();\n+\n+}\n+/* { dg-final { scan-tree-dump-not \"kill\" \"evrp\" } } */"}, {"sha": "3b8d0674471a749ae37bd17a196c0a154bf523ce", "filename": "gcc/vr-values.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=73cf73af2392e00917de042a4692f6a0b6329ee8", "patch": "@@ -3454,6 +3454,32 @@ range_fits_type_p (const value_range *vr,\n   return true;\n }\n \n+// Clear edge E of EDGE_EXECUTABLE (it is unexecutable). If it wasn't\n+// previously clear, propagate to successor blocks if appropriate.\n+\n+void\n+simplify_using_ranges::set_and_propagate_unexecutable (edge e)\n+{\n+  // If EXECUUTABLE is already clear, we're done.\n+  if ((e->flags & EDGE_EXECUTABLE) == 0)\n+    return;\n+\n+  e->flags &= ~EDGE_EXECUTABLE;\n+\n+  // Check if the destination block needs to propagate the property.\n+  basic_block bb = e->dest;\n+\n+  // If any entry edge is marked EXECUTABLE, we are done.\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_EXECUTABLE)\n+      return;\n+\n+  // This block is also unexecutable, propagate to all exit edges as well.\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    set_and_propagate_unexecutable (e);\n+}\n+\n /* If COND can be folded entirely as TRUE or FALSE, rewrite the\n    conditional as such, and return TRUE.  */\n \n@@ -3467,18 +3493,27 @@ simplify_using_ranges::fold_cond (gcond *cond)\n       if (TREE_CODE (gimple_cond_lhs (cond)) != SSA_NAME\n \t  && TREE_CODE (gimple_cond_rhs (cond)) != SSA_NAME)\n \treturn false;\n-\n+      edge e0 = EDGE_SUCC (gimple_bb (cond), 0);\n+      edge e1 = EDGE_SUCC (gimple_bb (cond), 1);\n       if (r.zero_p ())\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"\\nPredicate evaluates to: 0\\n\");\n \t  gimple_cond_make_false (cond);\n+\t  if (e0->flags & EDGE_TRUE_VALUE)\n+\t    set_and_propagate_unexecutable (e0);\n+\t  else\n+\t    set_and_propagate_unexecutable (e1);\n \t}\n       else\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"\\nPredicate evaluates to: 1\\n\");\n \t  gimple_cond_make_true (cond);\n+\t  if (e0->flags & EDGE_FALSE_VALUE)\n+\t    set_and_propagate_unexecutable (e0);\n+\t  else\n+\t    set_and_propagate_unexecutable (e1);\n \t}\n       update_stmt (cond);\n       return true;\n@@ -3769,7 +3804,7 @@ simplify_using_ranges::simplify_switch_using_ranges (gswitch *stmt)\n \t  fprintf (dump_file, \"removing unreachable case label\\n\");\n \t}\n       to_remove_edges.safe_push (e);\n-      e->flags &= ~EDGE_EXECUTABLE;\n+      set_and_propagate_unexecutable (e);\n       e->flags |= EDGE_IGNORE;\n     }\n "}, {"sha": "46939081c61d960c3b6e6873b75f5b935b683264", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cf73af2392e00917de042a4692f6a0b6329ee8/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=73cf73af2392e00917de042a4692f6a0b6329ee8", "patch": "@@ -66,6 +66,7 @@ class simplify_using_ranges\n   tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n \t\t\t\t\t\t\t     tree, tree,\n \t\t\t\t\t\t\t     bool *, gimple *s);\n+  void set_and_propagate_unexecutable (edge e);\n   void cleanup_edges_and_switches (void);\n \n   /* Vectors of edges that need removing and switch statements that"}]}