{"sha": "629387a6586a753166f5cf53d587026a34362523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI5Mzg3YTY1ODZhNzUzMTY2ZjVjZjUzZDU4NzAyNmEzNDM2MjUyMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-10-02T13:35:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-10-02T13:35:40Z"}, "message": "tree-eh.h (unsplit_eh_edges): Declare.\n\n\t* tree-eh.h (unsplit_eh_edges): Declare.\n\t* tree-eh.c (maybe_remove_unreachable_handlers): Detect more cases.\n\t(unsplit_eh_edges): New function wrapping unsplit_all_eh.\n\t* gimple-ssa-store-merging.c: Include cfganal.h cfgcleanup.h except.h.\n\t(struct store_immediate_info): Add lp_nr field.\n\t(store_immediate_info::store_immediate_info): Add NR2 parameter and\n\tinitialize lp_nr with it.\n\t(struct merged_store_group): Add lp_nr and only_constants fields.\n\t(merged_store_group::merged_store_group): Initialize them.\n\t(merged_store_group::can_be_merged_into): Deal with them.\n\t(pass_store_merging): Rename terminate_and_release_chain into\n\tterminate_and_process_chain.\n\t(pass_store_merging::terminate_and_process_all_chains): Adjust to above\n\trenaming and remove useless assertions.\n\t(pass_store_merging::terminate_all_aliasing_chains): Small tweak.\n\t(stmts_may_clobber_ref_p): Be prepared for different basic blocks.\n\t(imm_store_chain_info::coalesce_immediate_stores): Use only_constants\n\tinstead of always recomputing it and compare lp_nr.\n\t(imm_store_chain_info::output_merged_store): If the group is in an\n\tactive EH region, register new stores if they can throw.  Moreover,\n\tif the insertion has created new basic blocks, adjust the PHI nodes\n\tof the post landing pad.\n\t(imm_store_chain_info::output_merged_stores): If the original stores\n\tare in an active EH region, deregister them.\n\t(lhs_valid_for_store_merging_p): Prettify.\n\t(adjust_bit_pos): New function extracted from...\n\t(mem_valid_for_store_merging): ...here.  Use it for the base address\n\tand also for the offset if it is the addition of a constant.\n\t(lp_nr_for_store): New function.\n\t(pass_store_merging::process_store): Change return type to bool.\n\tCall lp_nr_for_store to initialize the store info.  Propagate the\n\treturn status of various called functions to the return value.\n\t(store_valid_for_store_merging_p): New predicate.\n\t(enum basic_block_status): New enumeration.\n\t(get_status_for_store_merging): New function.\n\t(pass_store_merging::execute): If the function can throw and catch\n\tnon-call exceptions, unsplit the EH edges on entry and clean up the\n\tCFG on exit if something changed.  Call get_status_for_store_merging\n\tfor every basic block and keep the chains open across basic blocks\n\twhen possible.  Terminate and process open chains at the end, if any.\n\nFrom-SVN: r276459", "tree": {"sha": "ec7b30ac680b7f471fc578669ea999a323bfd15f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec7b30ac680b7f471fc578669ea999a323bfd15f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/629387a6586a753166f5cf53d587026a34362523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629387a6586a753166f5cf53d587026a34362523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/629387a6586a753166f5cf53d587026a34362523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629387a6586a753166f5cf53d587026a34362523/comments", "author": null, "committer": null, "parents": [{"sha": "ea4b29d53a6d8e3ab2655a5d13c99bc445b8f286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4b29d53a6d8e3ab2655a5d13c99bc445b8f286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea4b29d53a6d8e3ab2655a5d13c99bc445b8f286"}], "stats": {"total": 463, "additions": 370, "deletions": 93}, "files": [{"sha": "d66b03e61deac31955422086c5919ec90dda71d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -1,3 +1,46 @@\n+2019-10-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-eh.h (unsplit_eh_edges): Declare.\n+\t* tree-eh.c (maybe_remove_unreachable_handlers): Detect more cases.\n+\t(unsplit_eh_edges): New function wrapping unsplit_all_eh.\n+\t* gimple-ssa-store-merging.c: Include cfganal.h cfgcleanup.h except.h.\n+\t(struct store_immediate_info): Add lp_nr field.\n+\t(store_immediate_info::store_immediate_info): Add NR2 parameter and\n+\tinitialize lp_nr with it.\n+\t(struct merged_store_group): Add lp_nr and only_constants fields.\n+\t(merged_store_group::merged_store_group): Initialize them.\n+\t(merged_store_group::can_be_merged_into): Deal with them.\n+\t(pass_store_merging): Rename terminate_and_release_chain into\n+\tterminate_and_process_chain.\n+\t(pass_store_merging::terminate_and_process_all_chains): Adjust to above\n+\trenaming and remove useless assertions.\n+\t(pass_store_merging::terminate_all_aliasing_chains): Small tweak.\n+\t(stmts_may_clobber_ref_p): Be prepared for different basic blocks.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Use only_constants\n+\tinstead of always recomputing it and compare lp_nr.\n+\t(imm_store_chain_info::output_merged_store): If the group is in an\n+\tactive EH region, register new stores if they can throw.  Moreover,\n+\tif the insertion has created new basic blocks, adjust the PHI nodes\n+\tof the post landing pad.\n+\t(imm_store_chain_info::output_merged_stores): If the original stores\n+\tare in an active EH region, deregister them.\n+\t(lhs_valid_for_store_merging_p): Prettify.\n+\t(adjust_bit_pos): New function extracted from...\n+\t(mem_valid_for_store_merging): ...here.  Use it for the base address\n+\tand also for the offset if it is the addition of a constant.\n+\t(lp_nr_for_store): New function.\n+\t(pass_store_merging::process_store): Change return type to bool.\n+\tCall lp_nr_for_store to initialize the store info.  Propagate the\n+\treturn status of various called functions to the return value.\n+\t(store_valid_for_store_merging_p): New predicate.\n+\t(enum basic_block_status): New enumeration.\n+\t(get_status_for_store_merging): New function.\n+\t(pass_store_merging::execute): If the function can throw and catch\n+\tnon-call exceptions, unsplit the EH edges on entry and clean up the\n+\tCFG on exit if something changed.  Call get_status_for_store_merging\n+\tfor every basic block and keep the chains open across basic blocks\n+\twhen possible.  Terminate and process open chains at the end, if any.\n+\n 2019-10-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* reginfo.c (globalize_reg): Fix shadowed variable in"}, {"sha": "270159b518d6ce4d5d626ed20e909f2c5ad3deae", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 270, "deletions": 86, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -159,7 +159,10 @@\n #include \"gimple-fold.h\"\n #include \"stor-layout.h\"\n #include \"timevar.h\"\n+#include \"cfganal.h\"\n+#include \"cfgcleanup.h\"\n #include \"tree-cfg.h\"\n+#include \"except.h\"\n #include \"tree-eh.h\"\n #include \"target.h\"\n #include \"gimplify-me.h\"\n@@ -1375,13 +1378,15 @@ class store_immediate_info\n   /* True if ops have been swapped and thus ops[1] represents\n      rhs1 of BIT_{AND,IOR,XOR}_EXPR and ops[0] represents rhs2.  */\n   bool ops_swapped_p;\n+  /* The index number of the landing pad, or 0 if there is none.  */\n+  int lp_nr;\n   /* Operands.  For BIT_*_EXPR rhs_code both operands are used, otherwise\n      just the first one.  */\n   store_operand_info ops[2];\n   store_immediate_info (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\tgimple *, unsigned int, enum tree_code,\n-\t\t\tstruct symbolic_number &, gimple *, bool,\n+\t\t\tstruct symbolic_number &, gimple *, bool, int,\n \t\t\tconst store_operand_info &,\n \t\t\tconst store_operand_info &);\n };\n@@ -1396,11 +1401,13 @@ store_immediate_info::store_immediate_info (unsigned HOST_WIDE_INT bs,\n \t\t\t\t\t    struct symbolic_number &nr,\n \t\t\t\t\t    gimple *ins_stmtp,\n \t\t\t\t\t    bool bitnotp,\n+\t\t\t\t\t    int nr2,\n \t\t\t\t\t    const store_operand_info &op0r,\n \t\t\t\t\t    const store_operand_info &op1r)\n   : bitsize (bs), bitpos (bp), bitregion_start (brs), bitregion_end (bre),\n     stmt (st), order (ord), rhs_code (rhscode), n (nr),\n-    ins_stmt (ins_stmtp), bit_not_p (bitnotp), ops_swapped_p (false)\n+    ins_stmt (ins_stmtp), bit_not_p (bitnotp), ops_swapped_p (false),\n+    lp_nr (nr2)\n #if __cplusplus >= 201103L\n     , ops { op0r, op1r }\n {\n@@ -1435,6 +1442,7 @@ class merged_store_group\n   bool bit_insertion;\n   bool only_constants;\n   unsigned int first_nonmergeable_order;\n+  int lp_nr;\n \n   auto_vec<store_immediate_info *> stores;\n   /* We record the first and last original statements in the sequence because\n@@ -1862,6 +1870,7 @@ merged_store_group::merged_store_group (store_immediate_info *info)\n   bit_insertion = false;\n   only_constants = info->rhs_code == INTEGER_CST;\n   first_nonmergeable_order = ~0U;\n+  lp_nr = info->lp_nr;\n   unsigned HOST_WIDE_INT align_bitpos = 0;\n   get_object_alignment_1 (gimple_assign_lhs (info->stmt),\n \t\t\t  &align, &align_bitpos);\n@@ -1904,6 +1913,9 @@ merged_store_group::can_be_merged_into (store_immediate_info *info)\n   if (info->rhs_code == LROTATE_EXPR)\n     return false;\n \n+  if (info->lp_nr != lp_nr)\n+    return false;\n+\n   /* The canonical case.  */\n   if (info->rhs_code == stores[0]->rhs_code)\n     return true;\n@@ -2173,10 +2185,10 @@ class pass_store_merging : public gimple_opt_pass\n      decisions when going out of SSA).  */\n   imm_store_chain_info *m_stores_head;\n \n-  void process_store (gimple *);\n-  bool terminate_and_process_all_chains ();\n+  bool process_store (gimple *);\n+  bool terminate_and_process_chain (imm_store_chain_info *);\n   bool terminate_all_aliasing_chains (imm_store_chain_info **, gimple *);\n-  bool terminate_and_release_chain (imm_store_chain_info *);\n+  bool terminate_and_process_all_chains ();\n }; // class pass_store_merging\n \n /* Terminate and process all recorded chains.  Return true if any changes\n@@ -2187,16 +2199,14 @@ pass_store_merging::terminate_and_process_all_chains ()\n {\n   bool ret = false;\n   while (m_stores_head)\n-    ret |= terminate_and_release_chain (m_stores_head);\n+    ret |= terminate_and_process_chain (m_stores_head);\n   gcc_assert (m_stores.is_empty ());\n-  gcc_assert (m_stores_head == NULL);\n-\n   return ret;\n }\n \n /* Terminate all chains that are affected by the statement STMT.\n    CHAIN_INFO is the chain we should ignore from the checks if\n-   non-NULL.  */\n+   non-NULL.  Return true if any changes were made.  */\n \n bool\n pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n@@ -2233,8 +2243,7 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n \t\t  fprintf (dump_file, \"stmt causes chain termination:\\n\");\n \t\t  print_gimple_stmt (dump_file, stmt, 0);\n \t\t}\n-\t      terminate_and_release_chain (cur);\n-\t      ret = true;\n+\t      ret |= terminate_and_process_chain (cur);\n \t      break;\n \t    }\n \t}\n@@ -2248,7 +2257,7 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n    entry is removed after the processing in any case.  */\n \n bool\n-pass_store_merging::terminate_and_release_chain (imm_store_chain_info *chain_info)\n+pass_store_merging::terminate_and_process_chain (imm_store_chain_info *chain_info)\n {\n   bool ret = chain_info->terminate_and_process_chain ();\n   m_stores.remove (chain_info->base_addr);\n@@ -2257,9 +2266,9 @@ pass_store_merging::terminate_and_release_chain (imm_store_chain_info *chain_inf\n }\n \n /* Return true if stmts in between FIRST (inclusive) and LAST (exclusive)\n-   may clobber REF.  FIRST and LAST must be in the same basic block and\n-   have non-NULL vdef.  We want to be able to sink load of REF across\n-   stores between FIRST and LAST, up to right before LAST.  */\n+   may clobber REF.  FIRST and LAST must have non-NULL vdef.  We want to\n+   be able to sink load of REF across stores between FIRST and LAST, up\n+   to right before LAST.  */\n \n bool\n stmts_may_clobber_ref_p (gimple *first, gimple *last, tree ref)\n@@ -2270,7 +2279,10 @@ stmts_may_clobber_ref_p (gimple *first, gimple *last, tree ref)\n   tree vop = gimple_vdef (last);\n   gimple *stmt;\n \n-  gcc_checking_assert (gimple_bb (first) == gimple_bb (last));\n+  /* Return true conservatively if the basic blocks are different.  */\n+  if (gimple_bb (first) != gimple_bb (last))\n+    return true;\n+\n   do\n     {\n       stmt = SSA_NAME_DEF_STMT (vop);\n@@ -2286,6 +2298,7 @@ stmts_may_clobber_ref_p (gimple *first, gimple *last, tree ref)\n       vop = gimple_vuse (stmt);\n     }\n   while (stmt != first);\n+\n   return false;\n }\n \n@@ -2759,7 +2772,9 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t\t merged_store->start + merged_store->width - 1))\n \t{\n \t  /* Only allow overlapping stores of constants.  */\n-\t  if (info->rhs_code == INTEGER_CST && merged_store->only_constants)\n+\t  if (info->rhs_code == INTEGER_CST\n+\t      && merged_store->only_constants\n+\t      && info->lp_nr == merged_store->lp_nr)\n \t    {\n \t      unsigned int last_order\n \t\t= MAX (merged_store->last_order, info->order);\n@@ -4152,6 +4167,9 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n       gimple_set_vuse (stmt, new_vuse);\n       gimple_seq_add_stmt_without_update (&seq, stmt);\n \n+      if (group->lp_nr && stmt_could_throw_p (cfun, stmt))\n+\tadd_stmt_to_eh_lp (stmt, group->lp_nr);\n+\n       tree new_vdef;\n       if (i < split_stores.length () - 1)\n \tnew_vdef = make_ssa_name (gimple_vop (cfun), stmt);\n@@ -4175,7 +4193,63 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n       if (dump_flags & TDF_DETAILS)\n \tprint_gimple_seq (dump_file, seq, 0, TDF_VOPS | TDF_MEMSYMS);\n     }\n-  gsi_insert_seq_after (&last_gsi, seq, GSI_SAME_STMT);\n+\n+  if (group->lp_nr > 0)\n+    {\n+      /* We're going to insert a sequence of (potentially) throwing stores\n+\t into an active EH region.  This means that we're going to create\n+\t new basic blocks with EH edges pointing to the post landing pad\n+\t and, therefore, to have to update its PHI nodes, if any.  For the\n+\t virtual PHI node, we're going to use the VDEFs created above, but\n+\t for the other nodes, we need to record the original reaching defs.  */\n+      eh_landing_pad lp = get_eh_landing_pad_from_number (group->lp_nr);\n+      basic_block lp_bb = label_to_block (cfun, lp->post_landing_pad);\n+      basic_block last_bb = gimple_bb (group->last_stmt);\n+      edge last_edge = find_edge (last_bb, lp_bb);\n+      auto_vec<tree, 16> last_defs;\n+      gphi_iterator gpi;\n+      for (gpi = gsi_start_phis (lp_bb); !gsi_end_p (gpi); gsi_next (&gpi))\n+\t{\n+\t  gphi *phi = gpi.phi ();\n+\t  tree last_def;\n+\t  if (virtual_operand_p (gimple_phi_result (phi)))\n+\t    last_def = NULL_TREE;\n+\t  else\n+\t    last_def = gimple_phi_arg_def (phi, last_edge->dest_idx);\n+\t  last_defs.safe_push (last_def);\n+\t}\n+\n+      /* Do the insertion.  Then, if new basic blocks have been created in the\n+\t process, rewind the chain of VDEFs create above to walk the new basic\n+\t blocks and update the corresponding arguments of the PHI nodes.  */\n+      update_modified_stmts (seq);\n+      if (gimple_find_sub_bbs (seq, &last_gsi))\n+\twhile (last_vdef != gimple_vuse (group->last_stmt))\n+\t  {\n+\t    gimple *stmt = SSA_NAME_DEF_STMT (last_vdef);\n+\t    if (stmt_could_throw_p (cfun, stmt))\n+\t      {\n+\t\tedge new_edge = find_edge (gimple_bb (stmt), lp_bb);\n+\t\tunsigned int i;\n+\t\tfor (gpi = gsi_start_phis (lp_bb), i = 0;\n+\t\t     !gsi_end_p (gpi);\n+\t\t     gsi_next (&gpi), i++)\n+\t\t  {\n+\t\t    gphi *phi = gpi.phi ();\n+\t\t    tree new_def;\n+\t\t    if (virtual_operand_p (gimple_phi_result (phi)))\n+\t\t      new_def = last_vdef;\n+\t\t    else\n+\t\t      new_def = last_defs[i];\n+\t\t    add_phi_arg (phi, new_def, new_edge, UNKNOWN_LOCATION);\n+\t\t  }\n+\t      }\n+\t    last_vdef = gimple_vuse (stmt);\n+\t  }\n+    }\n+  else\n+    gsi_insert_seq_after (&last_gsi, seq, GSI_SAME_STMT);\n+\n   for (int j = 0; j < 2; ++j)\n     if (load_seq[j])\n       gsi_insert_seq_after (&load_gsi[j], load_seq[j], GSI_SAME_STMT);\n@@ -4206,6 +4280,8 @@ imm_store_chain_info::output_merged_stores ()\n \t      gimple *stmt = store->stmt;\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n \t      gsi_remove (&gsi, true);\n+\t      if (store->lp_nr)\n+\t\tremove_stmt_from_eh_lp (stmt);\n \t      if (stmt != merged_store->last_stmt)\n \t\t{\n \t\t  unlink_stmt_vdef (stmt);\n@@ -4258,14 +4334,22 @@ imm_store_chain_info::terminate_and_process_chain ()\n static bool\n lhs_valid_for_store_merging_p (tree lhs)\n {\n-  tree_code code = TREE_CODE (lhs);\n-\n-  if (code == ARRAY_REF || code == ARRAY_RANGE_REF || code == MEM_REF\n-      || code == COMPONENT_REF || code == BIT_FIELD_REF\n-      || DECL_P (lhs))\n+  if (DECL_P (lhs))\n     return true;\n \n-  return false;\n+  switch (TREE_CODE (lhs))\n+    {\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case BIT_FIELD_REF:\n+    case COMPONENT_REF:\n+    case MEM_REF:\n+      return true;\n+    default:\n+      return false;\n+    }\n+\n+  gcc_unreachable ();\n }\n \n /* Return true if the tree RHS is a constant we want to consider\n@@ -4286,6 +4370,40 @@ rhs_valid_for_store_merging_p (tree rhs)\n \t  && native_encode_expr (rhs, NULL, size) != 0);\n }\n \n+/* Adjust *PBITPOS, *PBITREGION_START and *PBITREGION_END by BYTE_OFF bytes\n+   and return true on success or false on failure.  */\n+\n+static bool\n+adjust_bit_pos (poly_offset_int byte_off,\n+\t\tpoly_int64  *pbitpos,\n+\t\tpoly_uint64 *pbitregion_start,\n+\t\tpoly_uint64 *pbitregion_end)\n+{\n+  poly_offset_int bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+  bit_off += *pbitpos;\n+\n+  if (known_ge (bit_off, 0) && bit_off.to_shwi (pbitpos))\n+    {\n+      if (maybe_ne (*pbitregion_end, 0U))\n+\t{\n+\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+\t  bit_off += *pbitregion_start;\n+\t  if (bit_off.to_uhwi (pbitregion_start))\n+\t    {\n+\t      bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+\t      bit_off += *pbitregion_end;\n+\t      if (!bit_off.to_uhwi (pbitregion_end))\n+\t\t*pbitregion_end = 0;\n+\t    }\n+\t  else\n+\t    *pbitregion_end = 0;\n+\t}\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n /* If MEM is a memory reference usable for store merging (either as\n    store destination or for loads), return the non-NULL base_addr\n    and set *PBITSIZE, *PBITPOS, *PBITREGION_START and *PBITREGION_END.\n@@ -4330,27 +4448,8 @@ mem_valid_for_store_merging (tree mem, poly_uint64 *pbitsize,\n      PR 23684 and this way we can catch more chains.  */\n   else if (TREE_CODE (base_addr) == MEM_REF)\n     {\n-      poly_offset_int byte_off = mem_ref_offset (base_addr);\n-      poly_offset_int bit_off = byte_off << LOG2_BITS_PER_UNIT;\n-      bit_off += bitpos;\n-      if (known_ge (bit_off, 0) && bit_off.to_shwi (&bitpos))\n-\t{\n-\t  if (maybe_ne (bitregion_end, 0U))\n-\t    {\n-\t      bit_off = byte_off << LOG2_BITS_PER_UNIT;\n-\t      bit_off += bitregion_start;\n-\t      if (bit_off.to_uhwi (&bitregion_start))\n-\t\t{\n-\t\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n-\t\t  bit_off += bitregion_end;\n-\t\t  if (!bit_off.to_uhwi (&bitregion_end))\n-\t\t    bitregion_end = 0;\n-\t\t}\n-\t      else\n-\t\tbitregion_end = 0;\n-\t    }\n-\t}\n-      else\n+      if (!adjust_bit_pos (mem_ref_offset (base_addr), &bitpos,\n+\t\t\t   &bitregion_start, &bitregion_end))\n \treturn NULL_TREE;\n       base_addr = TREE_OPERAND (base_addr, 0);\n     }\n@@ -4363,29 +4462,34 @@ mem_valid_for_store_merging (tree mem, poly_uint64 *pbitsize,\n       base_addr = build_fold_addr_expr (base_addr);\n     }\n \n-  if (known_eq (bitregion_end, 0U))\n-    {\n-      bitregion_start = round_down_to_byte_boundary (bitpos);\n-      bitregion_end = bitpos;\n-      bitregion_end = round_up_to_byte_boundary (bitregion_end + bitsize);\n-    }\n-\n-  if (offset != NULL_TREE)\n+  if (offset)\n     {\n       /* If the access is variable offset then a base decl has to be\n \t address-taken to be able to emit pointer-based stores to it.\n \t ???  We might be able to get away with re-using the original\n \t base up to the first variable part and then wrapping that inside\n \t a BIT_FIELD_REF.  */\n       tree base = get_base_address (base_addr);\n-      if (! base\n-\t  || (DECL_P (base) && ! TREE_ADDRESSABLE (base)))\n+      if (!base || (DECL_P (base) && !TREE_ADDRESSABLE (base)))\n \treturn NULL_TREE;\n \n+      /* Similarly to above for the base, remove constant from the offset.  */\n+      if (TREE_CODE (offset) == PLUS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (offset, 1)) == INTEGER_CST\n+\t  && adjust_bit_pos (wi::to_poly_offset (TREE_OPERAND (offset, 1)),\n+\t\t\t     &bitpos, &bitregion_start, &bitregion_end))\n+\toffset = TREE_OPERAND (offset, 0);\n+\n       base_addr = build2 (POINTER_PLUS_EXPR, TREE_TYPE (base_addr),\n \t\t\t  base_addr, offset);\n     }\n \n+  if (known_eq (bitregion_end, 0U))\n+    {\n+      bitregion_start = round_down_to_byte_boundary (bitpos);\n+      bitregion_end = round_up_to_byte_boundary (bitpos + bitsize);\n+    }\n+\n   *pbitsize = bitsize;\n   *pbitpos = bitpos;\n   *pbitregion_start = bitregion_start;\n@@ -4448,10 +4552,24 @@ handled_load (gimple *stmt, store_operand_info *op,\n   return false;\n }\n \n+/* Return the index number of the landing pad for STMT, if any.  */\n+\n+static int\n+lp_nr_for_store (gimple *stmt)\n+{\n+  if (!cfun->can_throw_non_call_exceptions || !cfun->eh)\n+    return 0;\n+\n+  if (!stmt_could_throw_p (cfun, stmt))\n+    return 0;\n+\n+  return lookup_stmt_eh_lp (stmt);\n+}\n+\n /* Record the store STMT for store merging optimization if it can be\n-   optimized.  */\n+   optimized.  Return true if any changes were made.  */\n \n-void\n+bool\n pass_store_merging::process_store (gimple *stmt)\n {\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -4462,7 +4580,7 @@ pass_store_merging::process_store (gimple *stmt)\n     = mem_valid_for_store_merging (lhs, &bitsize, &bitpos,\n \t\t\t\t   &bitregion_start, &bitregion_end);\n   if (known_eq (bitsize, 0U))\n-    return;\n+    return false;\n \n   bool invalid = (base_addr == NULL_TREE\n \t\t  || (maybe_gt (bitsize,\n@@ -4604,15 +4722,13 @@ pass_store_merging::process_store (gimple *stmt)\n       || !bitpos.is_constant (&const_bitpos)\n       || !bitregion_start.is_constant (&const_bitregion_start)\n       || !bitregion_end.is_constant (&const_bitregion_end))\n-    {\n-      terminate_all_aliasing_chains (NULL, stmt);\n-      return;\n-    }\n+    return terminate_all_aliasing_chains (NULL, stmt);\n \n   if (!ins_stmt)\n     memset (&n, 0, sizeof (n));\n \n   class imm_store_chain_info **chain_info = NULL;\n+  bool ret = false;\n   if (base_addr)\n     chain_info = m_stores.get (base_addr);\n \n@@ -4624,14 +4740,15 @@ pass_store_merging::process_store (gimple *stmt)\n \t\t\t\t       const_bitregion_start,\n \t\t\t\t       const_bitregion_end,\n \t\t\t\t       stmt, ord, rhs_code, n, ins_stmt,\n-\t\t\t\t       bit_not_p, ops[0], ops[1]);\n+\t\t\t\t       bit_not_p, lp_nr_for_store (stmt),\n+\t\t\t\t       ops[0], ops[1]);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Recording immediate store from stmt:\\n\");\n \t  print_gimple_stmt (dump_file, stmt, 0);\n \t}\n       (*chain_info)->m_store_info.safe_push (info);\n-      terminate_all_aliasing_chains (chain_info, stmt);\n+      ret |= terminate_all_aliasing_chains (chain_info, stmt);\n       /* If we reach the limit of stores to merge in a chain terminate and\n \t process the chain now.  */\n       if ((*chain_info)->m_store_info.length ()\n@@ -4640,21 +4757,22 @@ pass_store_merging::process_store (gimple *stmt)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n \t\t     \"Reached maximum number of statements to merge:\\n\");\n-\t  terminate_and_release_chain (*chain_info);\n+\t  ret |= terminate_and_process_chain (*chain_info);\n \t}\n-      return;\n+      return ret;\n     }\n \n   /* Store aliases any existing chain?  */\n-  terminate_all_aliasing_chains (NULL, stmt);\n+  ret |= terminate_all_aliasing_chains (NULL, stmt);\n   /* Start a new chain.  */\n   class imm_store_chain_info *new_chain\n     = new imm_store_chain_info (m_stores_head, base_addr);\n   info = new store_immediate_info (const_bitsize, const_bitpos,\n \t\t\t\t   const_bitregion_start,\n \t\t\t\t   const_bitregion_end,\n \t\t\t\t   stmt, 0, rhs_code, n, ins_stmt,\n-\t\t\t\t   bit_not_p, ops[0], ops[1]);\n+\t\t\t\t   bit_not_p, lp_nr_for_store (stmt),\n+\t\t\t\t   ops[0], ops[1]);\n   new_chain->m_store_info.safe_push (info);\n   m_stores.put (base_addr, new_chain);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4665,6 +4783,52 @@ pass_store_merging::process_store (gimple *stmt)\n       print_generic_expr (dump_file, base_addr);\n       fprintf (dump_file, \"\\n\");\n     }\n+  return ret;\n+}\n+\n+/* Return true if STMT is a store valid for store merging.  */\n+\n+static bool\n+store_valid_for_store_merging_p (gimple *stmt)\n+{\n+  return gimple_assign_single_p (stmt)\n+\t && gimple_vdef (stmt)\n+\t && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt))\n+\t && !gimple_has_volatile_ops (stmt);\n+}\n+\n+enum basic_block_status { BB_INVALID, BB_VALID, BB_EXTENDED_VALID };\n+\n+/* Return the status of basic block BB wrt store merging.  */\n+\n+static enum basic_block_status\n+get_status_for_store_merging (basic_block bb)\n+{\n+  unsigned int num_statements = 0;\n+  gimple_stmt_iterator gsi;\n+  edge e;\n+\n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      if (store_valid_for_store_merging_p (stmt) && ++num_statements >= 2)\n+\tbreak;\n+    }\n+\n+  if (num_statements == 0)\n+    return BB_INVALID;\n+\n+  if (cfun->can_throw_non_call_exceptions && cfun->eh\n+      && store_valid_for_store_merging_p (gimple_seq_last_stmt (bb_seq (bb)))\n+      && (e = find_fallthru_edge (bb->succs))\n+      && e->dest == bb->next_bb)\n+    return BB_EXTENDED_VALID;\n+\n+  return num_statements >= 2 ? BB_VALID : BB_INVALID;\n }\n \n /* Entry point for the pass.  Go over each basic block recording chains of\n@@ -4677,26 +4841,28 @@ pass_store_merging::execute (function *fun)\n {\n   basic_block bb;\n   hash_set<gimple *> orig_stmts;\n+  bool changed = false, open_chains = false;\n+\n+  /* If the function can throw and catch non-call exceptions, we'll be trying\n+     to merge stores across different basic blocks so we need to first unsplit\n+     the EH edges in order to streamline the CFG of the function.  */\n+  if (cfun->can_throw_non_call_exceptions && cfun->eh)\n+    unsplit_eh_edges ();\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n+      const basic_block_status bb_status = get_status_for_store_merging (bb);\n       gimple_stmt_iterator gsi;\n-      unsigned HOST_WIDE_INT num_statements = 0;\n-      /* Record the original statements so that we can keep track of\n-\t statements emitted in this pass and not re-process new\n-\t statements.  */\n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  if (is_gimple_debug (gsi_stmt (gsi)))\n-\t    continue;\n \n-\t  if (++num_statements >= 2)\n-\t    break;\n+      if (open_chains && (bb_status == BB_INVALID || !single_pred_p (bb)))\n+\t{\n+\t  changed |= terminate_and_process_all_chains ();\n+\t  open_chains = false;\n \t}\n \n-      if (num_statements < 2)\n+      if (bb_status == BB_INVALID)\n \tcontinue;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4715,19 +4881,37 @@ pass_store_merging::execute (function *fun)\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"Volatile access terminates \"\n \t\t\t\t    \"all chains\\n\");\n-\t      terminate_and_process_all_chains ();\n+\t      changed |= terminate_and_process_all_chains ();\n+\t      open_chains = false;\n \t      continue;\n \t    }\n \n-\t  if (gimple_assign_single_p (stmt) && gimple_vdef (stmt)\n-\t      && !stmt_can_throw_internal (cfun, stmt)\n-\t      && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt)))\n-\t    process_store (stmt);\n+\t  if (store_valid_for_store_merging_p (stmt))\n+\t    changed |= process_store (stmt);\n \t  else\n-\t    terminate_all_aliasing_chains (NULL, stmt);\n+\t    changed |= terminate_all_aliasing_chains (NULL, stmt);\n+\t}\n+\n+      if (bb_status == BB_EXTENDED_VALID)\n+\topen_chains = true;\n+      else\n+\t{\n+\t  changed |= terminate_and_process_all_chains ();\n+\t  open_chains = false;\n \t}\n-      terminate_and_process_all_chains ();\n     }\n+\n+  if (open_chains)\n+    changed |= terminate_and_process_all_chains ();\n+\n+  /* If the function can throw and catch non-call exceptions and something\n+     changed during the pass, then the CFG has (very likely) changed too.  */\n+  if (cfun->can_throw_non_call_exceptions && cfun->eh && changed)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      return TODO_cleanup_cfg;\n+    }\n+\n   return 0;\n }\n "}, {"sha": "1895d84f11db12d701e7ad2713041a93470dd3e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -1,3 +1,8 @@\n+2019-10-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt82.adb: New test.\n+\t* gnat.dg/opt82_pkg.ads: New helper.\n+\n 2019-10-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/mips/call-clobbered-3.c: Remove skip for -Os."}, {"sha": "9e8e7bb1344079681c66ac4c5ec839b5effcec06", "filename": "gcc/testsuite/gnat.dg/opt82.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftestsuite%2Fgnat.dg%2Fopt82.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftestsuite%2Fgnat.dg%2Fopt82.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt82.adb?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -0,0 +1,14 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+with Opt82_Pkg; use Opt82_Pkg;\n+\n+procedure Opt82 (R : access Rec) is\n+begin\n+  R.A := 'A';\n+  R.B := 'B';\n+  R.C := 'C';\n+  R.D := 'D';\n+exception\n+  when Storage_Error => R.A := 'E';\n+end;"}, {"sha": "7b67890aafc78595e526529e5470971a70077166", "filename": "gcc/testsuite/gnat.dg/opt82_pkg.ads", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftestsuite%2Fgnat.dg%2Fopt82_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftestsuite%2Fgnat.dg%2Fopt82_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt82_pkg.ads?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -0,0 +1,10 @@\n+\n+-- { dg-final { scan-tree-dump \"= 1145258561|= 1094861636\" \"optimized\" } }\n+\n+package Opt82_Pkg is\n+\n+  type Rec is record\n+    A, B, C, D : Character;\n+  end record;\n+\n+end Opt82_Pkg;"}, {"sha": "1aba7333631be66b8ab40435e1550d9e7383b949", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -4040,15 +4040,14 @@ maybe_remove_unreachable_handlers (void)\n \n   if (cfun->eh == NULL)\n     return;\n-           \n+\n   FOR_EACH_VEC_SAFE_ELT (cfun->eh->lp_array, i, lp)\n-    if (lp && lp->post_landing_pad)\n+    if (lp\n+\t&& (lp->post_landing_pad == NULL_TREE\n+\t    || label_to_block (cfun, lp->post_landing_pad) == NULL))\n       {\n-\tif (label_to_block (cfun, lp->post_landing_pad) == NULL)\n-\t  {\n-\t    remove_unreachable_handlers ();\n-\t    return;\n-\t  }\n+\tremove_unreachable_handlers ();\n+\treturn;\n       }\n }\n \n@@ -4211,6 +4210,27 @@ unsplit_all_eh (void)\n   return changed;\n }\n \n+/* Wrapper around unsplit_all_eh that makes it usable everywhere.  */\n+\n+void\n+unsplit_eh_edges (void)\n+{\n+  bool changed;\n+\n+  /* unsplit_all_eh can die looking up unreachable landing pads.  */\n+  maybe_remove_unreachable_handlers ();\n+\n+  changed = unsplit_all_eh ();\n+\n+  /* If EH edges have been unsplit, delete unreachable forwarder blocks.  */\n+  if (changed)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      delete_unreachable_blocks ();\n+    }\n+}\n+\n /* A subroutine of cleanup_empty_eh.  Redirect all EH edges incoming\n    to OLD_BB to NEW_BB; return true on success, false on failure.\n "}, {"sha": "511bb84aefb0f85f8eba3a943ea9c9ccc226a8f9", "filename": "gcc/tree-eh.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftree-eh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/629387a6586a753166f5cf53d587026a34362523/gcc%2Ftree-eh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.h?ref=629387a6586a753166f5cf53d587026a34362523", "patch": "@@ -50,6 +50,7 @@ extern bool maybe_duplicate_eh_stmt_fn (struct function *, gimple *,\n \t\t\t\t\thash_map<void *, void *> *, int);\n extern bool maybe_duplicate_eh_stmt (gimple *, gimple *);\n extern void maybe_remove_unreachable_handlers (void);\n+extern void unsplit_eh_edges (void);\n extern bool verify_eh_edges (gimple *);\n extern bool verify_eh_dispatch_edge (geh_dispatch *);\n "}]}