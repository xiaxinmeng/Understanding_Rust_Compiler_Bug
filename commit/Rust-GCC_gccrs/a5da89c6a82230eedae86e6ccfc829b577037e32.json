{"sha": "a5da89c6a82230eedae86e6ccfc829b577037e32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVkYTg5YzZhODIyMzBlZWRhZTg2ZTZjY2ZjODI5YjU3NzAzN2UzMg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-14T17:44:00Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-14T17:44:00Z"}, "message": "c-pragma.h (cpp_register_pragma_space): Remove.\n\n\t* c-pragma.h (cpp_register_pragma_space): Remove.\n\t* cpplib.h (cpp_register_pragma_space): Remove.\n\t* cpplib.c (lookup_pragma_entry, insert_pragma_entry): New.\n\t(cpp_register_pragma_space): Remove.\n\t(cpp_register_pragma): Simplify using lookup_pragma_entry,\n\tadd sanity checks.\n\t(do_pragma): Similarly.\n\t(_cpp_init_internal_pragmas): Don't register namespaces.\n\n\t* config/v850/v850.h (REGISTER_TARGET_PRAGMAS):\n\tDon't register namespaces.\n\t* cp/lex.c (init_cp_pragma): Similarly.\n\t* doc/tm.texi: Update.\n\nFrom-SVN: r46254", "tree": {"sha": "55e7c14e31a0f32cc9e36c4dad7fe4f4d9b8b2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55e7c14e31a0f32cc9e36c4dad7fe4f4d9b8b2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5da89c6a82230eedae86e6ccfc829b577037e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5da89c6a82230eedae86e6ccfc829b577037e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5da89c6a82230eedae86e6ccfc829b577037e32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5da89c6a82230eedae86e6ccfc829b577037e32/comments", "author": null, "committer": null, "parents": [{"sha": "7c3e4ebb84f5666d8cc992abaea38ee061cf6e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3e4ebb84f5666d8cc992abaea38ee061cf6e84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3e4ebb84f5666d8cc992abaea38ee061cf6e84"}], "stats": {"total": 267, "additions": 144, "deletions": 123}, "files": [{"sha": "4bddb844139d18e5b7336c31eea0e604dae19d03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -1,3 +1,19 @@\n+2001-10-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-pragma.h (cpp_register_pragma_space): Remove.\n+\t* cpplib.h (cpp_register_pragma_space): Remove.\n+\t* cpplib.c (lookup_pragma_entry, insert_pragma_entry): New.\n+\t(cpp_register_pragma_space): Remove.\n+\t(cpp_register_pragma): Simplify using lookup_pragma_entry,\n+\tadd sanity checks.\n+\t(do_pragma): Similarly.\n+\t(_cpp_init_internal_pragmas): Don't register namespaces.\n+\n+\t* config/v850/v850.h (REGISTER_TARGET_PRAGMAS):\n+\tDon't register namespaces.\n+\t* cp/lex.c (init_cp_pragma): Similarly.\n+\t* doc/tm.texi: Update.\n+\n 2001-10-10  Craig Rodrigues  <rodrigc@gcc.gnu.org>\n \n \tPR c/4157"}, {"sha": "dddfaceec2e37dc70e7aca006c8a18910c82896e", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -51,7 +51,6 @@ typedef struct cpp_reader cpp_reader;\n extern void cpp_register_pragma PARAMS ((cpp_reader *,\n \t\t\t\t\t const char *, const char *,\n \t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n-extern void cpp_register_pragma_space PARAMS ((cpp_reader *, const char *));\n #endif\n \n #endif /* GCC_C_PRAGMA_H */"}, {"sha": "42f3c31d830ff430b1184308dfa2cb69868bc462", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -1503,7 +1503,6 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* Tell compiler we want to support GHS pragmas */\n #define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\t  \\\n-  cpp_register_pragma_space (PFILE, \"ghs\");\t\t\t\t  \\\n   cpp_register_pragma (PFILE, \"ghs\", \"interrupt\", ghs_pragma_interrupt);  \\\n   cpp_register_pragma (PFILE, \"ghs\", \"section\",   ghs_pragma_section);    \\\n   cpp_register_pragma (PFILE, \"ghs\", \"starttda\",  ghs_pragma_starttda);   \\"}, {"sha": "467619534305f10f18ab18dc2fd9faaf26100328", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -1,3 +1,7 @@\n+2001-10-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cp/lex.c (init_cp_pragma): Similarly.\n+\n 2001-10-13  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* pt.c (lookup_template_class): Build complete template arguments"}, {"sha": "ccd57a21345c8a7ca444027fd795acae30715a4c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -677,7 +677,6 @@ init_cp_pragma ()\n   cpp_register_pragma (parse_in, 0, \"implementation\",\n \t\t       handle_pragma_implementation);\n \n-  cpp_register_pragma_space (parse_in, \"GCC\");\n   cpp_register_pragma (parse_in, \"GCC\", \"interface\", handle_pragma_interface);\n   cpp_register_pragma (parse_in, \"GCC\", \"implementation\",\n \t\t       handle_pragma_implementation);"}, {"sha": "9aab392c6427253763170a9d8acf5c6520efe207", "filename": "gcc/cpplib.c", "status": "modified", "additions": 114, "deletions": 98, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -47,6 +47,20 @@ struct if_stack\n   int type;\t\t\t/* Most recent conditional, for diagnostics.  */\n };\n \n+/* Contains a registered pragma or pragma namespace.  */\n+typedef void (*pragma_cb) PARAMS ((cpp_reader *));\n+struct pragma_entry\n+{\n+  struct pragma_entry *next;\n+  const char *name;\n+  size_t len;\n+  int is_nspace;\n+  union {\n+    pragma_cb handler;\n+    struct pragma_entry *space;\n+  } u;\n+};\n+\n /* Values for the origin field of struct directive.  KANDR directives\n    come from traditional (K&R) C.  STDC89 directives come from the\n    1989 C standard.  EXTENSION directives are extensions.  */\n@@ -96,6 +110,10 @@ static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n static void do_include_common\tPARAMS ((cpp_reader *, enum include_type));\n+static struct pragma_entry *lookup_pragma_entry\n+  PARAMS ((struct pragma_entry *, const char *pragma));\n+static struct pragma_entry *insert_pragma_entry\n+  PARAMS ((cpp_reader *, struct pragma_entry **, const char *, pragma_cb));\n static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n@@ -842,149 +860,146 @@ do_ident (pfile)\n   check_eol (pfile);\n }\n \n-/* Pragmata handling.  We handle some of these, and pass the rest on\n-   to the front end.  C99 defines three pragmas and says that no macro\n-   expansion is to be performed on them; whether or not macro\n-   expansion happens for other pragmas is implementation defined.\n-   This implementation never macro-expands the text after #pragma.  */\n-\n-/* Sub-handlers for the pragmas needing treatment here.\n-   They return 1 if the token buffer is to be popped, 0 if not.  */\n-typedef void (*pragma_cb) PARAMS ((cpp_reader *));\n-struct pragma_entry\n+/* Lookup a PRAGMA name in a singly-linked CHAIN.  Returns the\n+   matching entry, or NULL if none is found.  The returned entry could\n+   be the start of a namespace chain, or a pragma.  */\n+static struct pragma_entry *\n+lookup_pragma_entry (chain, pragma)\n+     struct pragma_entry *chain;\n+     const char *pragma;\n {\n-  struct pragma_entry *next;\n-  const char *name;\n-  size_t len;\n-  int isnspace;\n-  union {\n-    pragma_cb handler;\n-    struct pragma_entry *space;\n-  } u;\n-};\n+  size_t len = strlen (pragma);\n \n-void\n-cpp_register_pragma (pfile, space, name, handler)\n+  while (chain)\n+    {\n+      if (chain->len == len && !memcmp (chain->name, pragma, len))\n+\tbreak;\n+      chain = chain->next;\n+    }\n+\n+  return chain;\n+}\n+\n+/* Create and insert a pragma entry for NAME at the beginning of a\n+   singly-linked CHAIN.  If handler is NULL, it is a namespace,\n+   otherwise it is a pragma and its handler.  */\n+static struct pragma_entry *\n+insert_pragma_entry (pfile, chain, name, handler)\n      cpp_reader *pfile;\n-     const char *space;\n+     struct pragma_entry **chain;\n      const char *name;\n      pragma_cb handler;\n {\n-  struct pragma_entry **x, *new;\n-  size_t len;\n-\n-  x = &pfile->pragmas;\n-  if (space)\n-    {\n-      struct pragma_entry *p = pfile->pragmas;\n-      len = strlen (space);\n-      while (p)\n-\t{\n-\t  if (p->isnspace && p->len == len && !memcmp (p->name, space, len))\n-\t    {\n-\t      x = &p->u.space;\n-\t      goto found;\n-\t    }\n-\t  p = p->next;\n-\t}\n-      cpp_ice (pfile, \"unknown #pragma namespace %s\", space);\n-      return;\n-    }\n+  struct pragma_entry *new;\n \n- found:\n   new = (struct pragma_entry *)\n     _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n   new->name = name;\n   new->len = strlen (name);\n-  new->isnspace = 0;\n-  new->u.handler = handler;\n+  if (handler)\n+    {\n+      new->is_nspace = 0;\n+      new->u.handler = handler;\n+    }\n+  else\n+    {\n+      new->is_nspace = 1;\n+      new->u.space = NULL;\n+    }\n \n-  new->next = *x;\n-  *x = new;\n+  new->next = *chain;\n+  *chain = new;\n+  return new;\n }\n \n+/* Register a pragma NAME in namespace SPACE.  If SPACE is null, it\n+   goes in the global namespace.  HANDLER is the handler it will call,\n+   which must be non-NULL.  */\n void\n-cpp_register_pragma_space (pfile, space)\n+cpp_register_pragma (pfile, space, name, handler)\n      cpp_reader *pfile;\n      const char *space;\n+     const char *name;\n+     pragma_cb handler;\n {\n-  struct pragma_entry *new;\n-  const struct pragma_entry *p = pfile->pragmas;\n-  size_t len = strlen (space);\n+  struct pragma_entry **chain = &pfile->pragmas;\n+  struct pragma_entry *entry;\n \n-  while (p)\n+  if (!handler)\n+    abort ();\n+\n+  if (space)\n     {\n-      if (p->isnspace && p->len == len && !memcmp (p->name, space, len))\n-\t/* Multiple different callers are allowed to register the same\n-\t   namespace.  */\n-\treturn;\n-      p = p->next;\n+      entry = lookup_pragma_entry (*chain, space);\n+      if (!entry)\n+\tentry = insert_pragma_entry (pfile, chain, space, NULL);\n+      else if (!entry->is_nspace)\n+\tgoto clash;\n+      chain = &entry->u.space;\n     }\n \n-  new = (struct pragma_entry *)\n-    _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n-  new->name = space;\n-  new->len = len;\n-  new->isnspace = 1;\n-  new->u.space = 0;\n-\n-  new->next = pfile->pragmas;\n-  pfile->pragmas = new;\n+  /* Check for duplicates.  */\n+  entry = lookup_pragma_entry (*chain, name);\n+  if (entry)\n+    {\n+      if (entry->is_nspace)\n+\tclash:\n+\tcpp_ice (pfile,\n+\t\t \"registering \\\"%s\\\" as both a pragma and a pragma namespace\",\n+\t\t entry->name);\n+      else if (space)\n+\tcpp_ice (pfile, \"#pragma %s %s is already registered\", space, name);\n+      else\n+\tcpp_ice (pfile, \"#pragma %s is already registered\", name);\n+    }\n+  else\n+    insert_pragma_entry (pfile, chain, name, handler);\n }\n-  \n+\n+/* Register the pragmas the preprocessor itself handles.  */\n void\n _cpp_init_internal_pragmas (pfile)\n      cpp_reader *pfile;\n {\n-  /* top level */\n+  /* Pragmas in the global namespace.  */\n   cpp_register_pragma (pfile, 0, \"poison\", do_pragma_poison);\n   cpp_register_pragma (pfile, 0, \"once\", do_pragma_once);\n \n-  /* GCC namespace */\n-  cpp_register_pragma_space (pfile, \"GCC\");\n-\n+  /* New GCC-specific pragmas should be put in the GCC namespace.  */\n   cpp_register_pragma (pfile, \"GCC\", \"poison\", do_pragma_poison);\n   cpp_register_pragma (pfile, \"GCC\", \"system_header\", do_pragma_system_header);\n   cpp_register_pragma (pfile, \"GCC\", \"dependency\", do_pragma_dependency);\n }\n \n+/* Pragmata handling.  We handle some, and pass the rest on to the\n+   front end.  C99 defines three pragmas and says that no macro\n+   expansion is to be performed on them; whether or not macro\n+   expansion happens for other pragmas is implementation defined.\n+   This implementation never macro-expands the text after #pragma.  */\n static void\n do_pragma (pfile)\n      cpp_reader *pfile;\n {\n-  pragma_cb handler = NULL;\n-  const struct pragma_entry *p;\n+  const struct pragma_entry *p = NULL;\n   const cpp_token *token;\n-  unsigned int count = 0;\n+  unsigned int count = 1;\n \n-  p = pfile->pragmas;\n   pfile->state.prevent_expansion++;\n \n- new_space:\n-  count++;\n   token = cpp_get_token (pfile);\n   if (token->type == CPP_NAME)\n     {\n-      const cpp_hashnode *node = token->val.node;\n-      size_t len = NODE_LEN (node);\n-\n-      while (p)\n+      p = lookup_pragma_entry (pfile->pragmas,\n+\t\t\t       (char *) NODE_NAME (token->val.node));\n+      if (p && p->is_nspace)\n \t{\n-\t  if (strlen (p->name) == len\n-\t      && !memcmp (p->name, NODE_NAME (node), len))\n-\t    {\n-\t      if (p->isnspace)\n-\t\t{\n-\t\t  p = p->u.space;\n-\t\t  goto new_space;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  handler = p->u.handler;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  p = p->next;\n+\t  count = 2;\n+\t  token = cpp_get_token (pfile);\n+\t  if (token->type == CPP_NAME)\n+\t    p = lookup_pragma_entry (p->u.space,\n+\t\t\t\t     (char *) NODE_NAME (token->val.node));\n+\t  else\n+\t    p = NULL;\n \t}\n     }\n \n@@ -996,13 +1011,14 @@ do_pragma (pfile)\n   if (pfile->cb.line_change)\n     (*pfile->cb.line_change)(pfile, token, 1);\n \n-  if (handler)\n-    (*handler) (pfile);\n+  if (p)\n+    (*p->u.handler) (pfile);\n   else if (pfile->cb.def_pragma)\n     {\n       _cpp_backup_tokens (pfile, count);\n       (*pfile->cb.def_pragma) (pfile, pfile->directive_line);\n     }\n+\n   pfile->state.prevent_expansion--;\n }\n "}, {"sha": "2ccac628114466506f71c53d38afa499378b1974", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -494,7 +494,6 @@ extern unsigned char *cpp_spell_token PARAMS ((cpp_reader *, const cpp_token *,\n extern void cpp_register_pragma PARAMS ((cpp_reader *,\n \t\t\t\t\t const char *, const char *,\n \t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n-extern void cpp_register_pragma_space PARAMS ((cpp_reader *, const char *));\n \n extern int cpp_start_read PARAMS ((cpp_reader *, const char *));\n extern void cpp_finish PARAMS ((cpp_reader *));"}, {"sha": "a790278ac9f3c455239798246710314d7a243cbd", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5da89c6a82230eedae86e6ccfc829b577037e32/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a5da89c6a82230eedae86e6ccfc829b577037e32", "patch": "@@ -8485,10 +8485,10 @@ This macro is no longer supported.  You must use\n @findex pragma\n @item REGISTER_TARGET_PRAGMAS (@var{pfile})\n Define this macro if you want to implement any target-specific pragmas.\n-If defined, it is a C expression which makes a series of calls to the\n-@code{cpp_register_pragma} and/or @code{cpp_register_pragma_space}\n-functions.  The @var{pfile} argument is the first argument to supply to\n-these functions.  The macro may also do setup required for the pragmas.\n+If defined, it is a C expression which makes a series of calls to\n+@code{cpp_register_pragma} for each pragma, with @var{pfile} passed as\n+the first argument to to these functions.  The macro may also do any\n+setup required for the pragmas.\n \n The primary reason to define this macro is to provide compatibility with\n other compilers for the same target.  In general, we discourage\n@@ -8511,14 +8511,12 @@ pragma of the form\n #pragma [@var{space}] @var{name} @dots{}\n @end smallexample\n \n-@var{space} must have been the subject of a previous call to\n-@code{cpp_register_pragma_space}, or else be a null pointer.  The\n-callback routine receives @var{pfile} as its first argument, but must\n-not use it for anything (this may change in the future).  It may read\n-any text after the @var{name} by making calls to @code{c_lex}.  Text\n-which is not read by the callback will be silently ignored.\n-\n-Note that both @var{space} and @var{name} are case sensitive.\n+@var{space} is the case-sensitive namespace of the pragma, or\n+@code{NULL} to put the pragma in the global namespace.  The callback\n+routine receives @var{pfile} as its first argument, which can be passed\n+on to cpplib's functions if necessary.  It may read any text after the\n+@var{name} by making calls to @code{c_lex}.  Text which is not read by\n+the callback will be silently ignored.\n \n For an example use of this routine, see @file{c4x.h} and the callback\n routines defined in @file{c4x.c}.\n@@ -8536,15 +8534,6 @@ rule to the makefile fragment pointed to by @code{tmake_file} that shows\n how to build this object file.\n @end deftypefun\n \n-@deftypefun void cpp_register_pragma_space (cpp_reader *@var{pfile}, const char *@var{space})\n-This routine establishes a namespace for pragmas, which will be\n-registered by subsequent calls to @code{cpp_register_pragma}.  For\n-example, pragmas defined by the C standard are in the @samp{STDC}\n-namespace, and pragmas specific to GCC are in the @samp{GCC} namespace.\n-\n-For an example use of this routine in a target header, see @file{v850.h}.\n-@end deftypefun\n-\n @findex HANDLE_SYSV_PRAGMA\n @findex #pragma\n @findex pragma"}]}