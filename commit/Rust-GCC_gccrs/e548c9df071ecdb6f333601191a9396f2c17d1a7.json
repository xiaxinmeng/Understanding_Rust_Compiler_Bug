{"sha": "e548c9df071ecdb6f333601191a9396f2c17d1a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0OGM5ZGYwNzFlY2RiNmYzMzM2MDExOTFhOTM5NmYyYzE3ZDFhNw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2015-07-08T03:02:27Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2015-07-08T03:02:27Z"}, "message": "target.def (rtx_costs): Remove \"code\" param, add \"mode\".\n\n\n\t* target.def (rtx_costs): Remove \"code\" param, add \"mode\".\n\t* rtl.h (rtx_cost, get_full_rtx_cost): Update prototype.\n\t(set_src_cost, get_full_set_src_cost): Likewise.  Move later in file.\n\t(set_rtx_cost, get_full_set_rtx_cost): Move later in file.\n\t* rtlanal.c (rtx_cost): Add \"mode\" parameter.  Update targetm.rtx_costs\n\tcall.  Track mode when given in rtx.\n\t(get_full_rtx_cost): Add \"mode\" parameter.  Update rtx_cost calls.\n\t(default_address_cost): Pass Pmode to rtx_cost.\n\t(insn_rtx_cost): Pass dest mode of set to set_src_cost.\n\t* cprop.c (try_replace_reg): Ensure set_rtx_cost is not called\n\twith NULL set.\n\t* cse.c (COST, COST_IN): Add MODE param.  Update all uses.\n\t(notreg_cost): Add mode param.  Use it.\n\t* gcse.c (want_to_gcse_p): Delete forward declaration.  Add\n\tmode param and pass to set_src_cost.  Update all calls.\n\t(hash_scan_set): Formatting.\n\t* hooks.c (hook_bool_rtx_int_int_int_intp_bool_false): Delete.\n\t(hook_bool_rtx_mode_int_int_intp_bool_false): New function.\n\t* hooks.h: Ditto.\n\t* expmed.c (init_expmed_one_conv, init_expmed_one_mode,\n\tinit_expmed, expand_mult, mult_by_coeff_cost, expand_smod_pow2,\n\temit_store_flag): Update set_src_cost and rtx_cost calls.\n\t* auto-inc-dec.c (attempt_change): Likewise.\n\t* calls.c (precompute_register_parameters): Likewise.\n\t* combine.c (expand_compound_operation, make_extraction,\n\tforce_to_mode, distribute_and_simplify_rtx): Likewise.\n\t* dojump.c (prefer_and_bit_test): Likewise.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* expr.c (compress_float_constant): Likewise.\n\t* fwprop.c (should_replace_address, try_fwprop_subst): Likewise.\n\t* ifcvt.c (noce_try_sign_mask): Likewise.\n\t* loop-doloop.c (doloop_optimize): Likewise.\n\t* loop-invariant.c (create_new_invariant): Likewise.\n\t* lower-subreg.c (shift_cost, compute_costs): Likewise.\n\t* optabs.c (avoid_expensive_constant, prepare_cmp_insn,\n\tlshift_cheap_p): Likewise.\n\t* postreload.c (reload_cse_simplify_set, reload_cse_simplify_operands,\n\ttry_replace_in_use, reload_cse_move2add): Likewise.\n\t* reload1.c (calculate_elim_costs_all_insns, note_reg_elim_costly):\n\tLikewise.\n\t* simplify-rtx.c (simplify_binary_operation_1): Likewise.\n\t* tree-ssa-loop-ivopts.c (computation_cost): Likewise.\n\t* tree-ssa-reassoc.c (optimize_range_tests_to_bit_test): Likewise.\n\t* tree-switch-conversion.c (emit_case_bit_tests): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Delete \"code\" param,\n\tadd \"mode\" param.  Use \"mode: in place of GET_MODE (x).  Pass mode\n\tto rtx_cost calls.\n\t* config/alpha/alpha.c (alpha_rtx_costs): Likewise.\n\t* config/arc/arc.c (arc_rtx_costs): Likewise.\n\t* config/arm/arm.c (arm_rtx_costs): Likewise.\n\t* config/avr/avr.c (avr_rtx_costs, avr_rtx_costs_1): Likewise.\n\t* config/bfin/bfin.c (bfin_rtx_costs): Likewise.\n\t* config/c6x/c6x.c (c6x_rtx_costs): Likewise.\n\t* config/cris/cris.c (cris_rtx_costs): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_rtx_costs): Likewise.\n\t* config/frv/frv.c (frv_rtx_costs): Likewise.\n\t* config/h8300/h8300.c (h8300_rtx_costs): Likewise.\n\t* config/i386/i386.c (ix86_rtx_costs): Likewise.\n\t* config/ia64/ia64.c (ia64_rtx_costs): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_rtx_costs): Likewise.\n\t* config/lm32/lm32.c (lm32_rtx_costs): Likewise.\n\t* config/m32c/m32c.c (m32c_rtx_costs): Likewise.\n\t* config/m32r/m32r.c (m32r_rtx_costs): Likewise.\n\t* config/m68k/m68k.c (m68k_rtx_costs): Likewise.\n\t* config/mcore/mcore.c (mcore_rtx_costs): Likewise.\n\t* config/mep/mep.c (mep_rtx_cost): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_rtx_costs): Likewise.\n\t* config/mips/mips.c (mips_rtx_costs): Likewise.\n\t* config/mmix/mmix.c (mmix_rtx_costs): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_rtx_costs): Likewise.\n\t* config/msp430/msp430.c (msp430_rtx_costs): Likewise.\n\t* config/nds32/nds32-cost.c (nds32_rtx_costs_impl): Likewise.\n\t* config/nds32/nds32-protos.h (nds32_rtx_costs_impl): Likewise.\n\t* config/nds32/nds32.c (nds32_rtx_costs): Likewise.\n\t* config/nios2/nios2.c (nios2_rtx_costs): Likewise.\n\t* config/pa/pa.c (hppa_rtx_costs): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_rtx_costs): Likewise.\n\t* config/rl78/rl78.c (rl78_rtx_costs): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_rtx_costs): Likewise.\n\t* config/s390/s390.c (s390_rtx_costs): Likewise.\n\t* config/sh/sh.c (sh_rtx_costs): Likewise.\n\t* config/sparc/sparc.c (sparc_rtx_costs): Likewise.\n\t* config/spu/spu.c (spu_rtx_costs): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_rtx_costs): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_rtx_costs): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_rtx_costs): Likewise.\n\t* config/v850/v850.c (v850_rtx_costs): Likewise.\n\t* config/vax/vax.c (vax_rtx_costs): Likewise.\n\t* config/visium/visium.c (visium_rtx_costs): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_rtx_costs): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_rtx_mult_cost): Change type of\n\t\"code\" param, and pass as outer_code to first rtx_cost call.  Pass\n\tmode to rtx_cost calls.\n\t(aarch64_address_cost, aarch64_if_then_else_costs): Update rtx_cost\n\tcalls.\n\t(aarch64_rtx_costs_wrapper): Update.\n\t* config/arm/arm.c (arm_rtx_costs_1, arm_size_rtx_costs,\n\tarm_unspec_cost, arm_new_rtx_costs, arm_slowmul_rtx_costs): Update\n\trtx_cost calls.\n\t* config/avr/avr.c (avr_final_prescan_insn): Update set_src_cost\n\tand rtx_cost calls.\n\t(avr_operand_rtx_cost): Similarly.\n\t(avr_rtx_costs_1): Correct mode passed to avr_operand_rtx_cost\n\tfor subexpressions of ZERO_EXTEND, SIGN_EXTEND and COMPARE.\n\t* config/mips/mips.c (mips_stack_address_p): Comment typo.\n\t(mips_binary_cost): Update rtx_cost and set_src_cost calls.\n\t(mips_rtx_costs): Use GET_MODE (x) to detect const_int.\n\t* config/mn10300/mn10300.c (mn10300_address_cost): Pass Pmode to\n\trtx_cost.\n\t(mn10300_rtx_costs): Correct mode passed to mn10300_address_cost.\n\t* config/rs6000/rs6000.c (rs6000_debug_rtx_costs): Update.\n\t* config/sh/sh.c (and_xor_ior_costs): Update rtx_cost call.\n\t* doc/tm.texi: Regenerate.\n\nFrom-SVN: r225532", "tree": {"sha": "53f49dedf673ef5042d1e6f2ea443c7106b2c8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53f49dedf673ef5042d1e6f2ea443c7106b2c8ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e548c9df071ecdb6f333601191a9396f2c17d1a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e548c9df071ecdb6f333601191a9396f2c17d1a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e548c9df071ecdb6f333601191a9396f2c17d1a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e548c9df071ecdb6f333601191a9396f2c17d1a7/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7131fb2b58ab692af97125b7432393ffb426d53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7131fb2b58ab692af97125b7432393ffb426d53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7131fb2b58ab692af97125b7432393ffb426d53"}], "stats": {"total": 1767, "additions": 1001, "deletions": 766}, "files": [{"sha": "f381b6f45400cb3b38b1ca137c84859791a898b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1,3 +1,119 @@\n+2015-07-08  Alan Modra  <amodra@gmail.com>\n+\n+\t* target.def (rtx_costs): Remove \"code\" param, add \"mode\".\n+\t* rtl.h (rtx_cost, get_full_rtx_cost): Update prototype.\n+\t(set_src_cost, get_full_set_src_cost): Likewise.  Move later in file.\n+\t(set_rtx_cost, get_full_set_rtx_cost): Move later in file.\n+\t* rtlanal.c (rtx_cost): Add \"mode\" parameter.  Update targetm.rtx_costs\n+\tcall.  Track mode when given in rtx.\n+\t(get_full_rtx_cost): Add \"mode\" parameter.  Update rtx_cost calls.\n+\t(default_address_cost): Pass Pmode to rtx_cost.\n+\t(insn_rtx_cost): Pass dest mode of set to set_src_cost.\n+\t* cprop.c (try_replace_reg): Ensure set_rtx_cost is not called\n+\twith NULL set.\n+\t* cse.c (COST, COST_IN): Add MODE param.  Update all uses.\n+\t(notreg_cost): Add mode param.  Use it.\n+\t* gcse.c (want_to_gcse_p): Delete forward declaration.  Add\n+\tmode param and pass to set_src_cost.  Update all calls.\n+\t(hash_scan_set): Formatting.\n+\t* hooks.c (hook_bool_rtx_int_int_int_intp_bool_false): Delete.\n+\t(hook_bool_rtx_mode_int_int_intp_bool_false): New function.\n+\t* hooks.h: Ditto.\n+\t* expmed.c (init_expmed_one_conv, init_expmed_one_mode,\n+\tinit_expmed, expand_mult, mult_by_coeff_cost, expand_smod_pow2,\n+\temit_store_flag): Update set_src_cost and rtx_cost calls.\n+\t* auto-inc-dec.c (attempt_change): Likewise.\n+\t* calls.c (precompute_register_parameters): Likewise.\n+\t* combine.c (expand_compound_operation, make_extraction,\n+\tforce_to_mode, distribute_and_simplify_rtx): Likewise.\n+\t* dojump.c (prefer_and_bit_test): Likewise.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* expr.c (compress_float_constant): Likewise.\n+\t* fwprop.c (should_replace_address, try_fwprop_subst): Likewise.\n+\t* ifcvt.c (noce_try_sign_mask): Likewise.\n+\t* loop-doloop.c (doloop_optimize): Likewise.\n+\t* loop-invariant.c (create_new_invariant): Likewise.\n+\t* lower-subreg.c (shift_cost, compute_costs): Likewise.\n+\t* optabs.c (avoid_expensive_constant, prepare_cmp_insn,\n+\tlshift_cheap_p): Likewise.\n+\t* postreload.c (reload_cse_simplify_set, reload_cse_simplify_operands,\n+\ttry_replace_in_use, reload_cse_move2add): Likewise.\n+\t* reload1.c (calculate_elim_costs_all_insns, note_reg_elim_costly):\n+\tLikewise.\n+\t* simplify-rtx.c (simplify_binary_operation_1): Likewise.\n+\t* tree-ssa-loop-ivopts.c (computation_cost): Likewise.\n+\t* tree-ssa-reassoc.c (optimize_range_tests_to_bit_test): Likewise.\n+\t* tree-switch-conversion.c (emit_case_bit_tests): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Delete \"code\" param,\n+\tadd \"mode\" param.  Use \"mode: in place of GET_MODE (x).  Pass mode\n+\tto rtx_cost calls.\n+\t* config/alpha/alpha.c (alpha_rtx_costs): Likewise.\n+\t* config/arc/arc.c (arc_rtx_costs): Likewise.\n+\t* config/arm/arm.c (arm_rtx_costs): Likewise.\n+\t* config/avr/avr.c (avr_rtx_costs, avr_rtx_costs_1): Likewise.\n+\t* config/bfin/bfin.c (bfin_rtx_costs): Likewise.\n+\t* config/c6x/c6x.c (c6x_rtx_costs): Likewise.\n+\t* config/cris/cris.c (cris_rtx_costs): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_rtx_costs): Likewise.\n+\t* config/frv/frv.c (frv_rtx_costs): Likewise.\n+\t* config/h8300/h8300.c (h8300_rtx_costs): Likewise.\n+\t* config/i386/i386.c (ix86_rtx_costs): Likewise.\n+\t* config/ia64/ia64.c (ia64_rtx_costs): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_rtx_costs): Likewise.\n+\t* config/lm32/lm32.c (lm32_rtx_costs): Likewise.\n+\t* config/m32c/m32c.c (m32c_rtx_costs): Likewise.\n+\t* config/m32r/m32r.c (m32r_rtx_costs): Likewise.\n+\t* config/m68k/m68k.c (m68k_rtx_costs): Likewise.\n+\t* config/mcore/mcore.c (mcore_rtx_costs): Likewise.\n+\t* config/mep/mep.c (mep_rtx_cost): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_rtx_costs): Likewise.\n+\t* config/mips/mips.c (mips_rtx_costs): Likewise.\n+\t* config/mmix/mmix.c (mmix_rtx_costs): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_rtx_costs): Likewise.\n+\t* config/msp430/msp430.c (msp430_rtx_costs): Likewise.\n+\t* config/nds32/nds32-cost.c (nds32_rtx_costs_impl): Likewise.\n+\t* config/nds32/nds32-protos.h (nds32_rtx_costs_impl): Likewise.\n+\t* config/nds32/nds32.c (nds32_rtx_costs): Likewise.\n+\t* config/nios2/nios2.c (nios2_rtx_costs): Likewise.\n+\t* config/pa/pa.c (hppa_rtx_costs): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_rtx_costs): Likewise.\n+\t* config/rl78/rl78.c (rl78_rtx_costs): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_rtx_costs): Likewise.\n+\t* config/s390/s390.c (s390_rtx_costs): Likewise.\n+\t* config/sh/sh.c (sh_rtx_costs): Likewise.\n+\t* config/sparc/sparc.c (sparc_rtx_costs): Likewise.\n+\t* config/spu/spu.c (spu_rtx_costs): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_rtx_costs): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_rtx_costs): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_rtx_costs): Likewise.\n+\t* config/v850/v850.c (v850_rtx_costs): Likewise.\n+\t* config/vax/vax.c (vax_rtx_costs): Likewise.\n+\t* config/visium/visium.c (visium_rtx_costs): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_rtx_costs): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_rtx_mult_cost): Change type of\n+\t\"code\" param, and pass as outer_code to first rtx_cost call.  Pass\n+\tmode to rtx_cost calls.\n+\t(aarch64_address_cost, aarch64_if_then_else_costs): Update rtx_cost\n+\tcalls.\n+\t(aarch64_rtx_costs_wrapper): Update.\n+\t* config/arm/arm.c (arm_rtx_costs_1, arm_size_rtx_costs,\n+\tarm_unspec_cost, arm_new_rtx_costs, arm_slowmul_rtx_costs): Update\n+\trtx_cost calls.\n+\t* config/avr/avr.c (avr_final_prescan_insn): Update set_src_cost\n+\tand rtx_cost calls.\n+\t(avr_operand_rtx_cost): Similarly.\n+\t(avr_rtx_costs_1): Correct mode passed to avr_operand_rtx_cost\n+\tfor subexpressions of ZERO_EXTEND, SIGN_EXTEND and COMPARE.\n+\t* config/mips/mips.c (mips_stack_address_p): Comment typo.\n+\t(mips_binary_cost): Update rtx_cost and set_src_cost calls.\n+\t(mips_rtx_costs): Use GET_MODE (x) to detect const_int.\n+\t* config/mn10300/mn10300.c (mn10300_address_cost): Pass Pmode to\n+\trtx_cost.\n+\t(mn10300_rtx_costs): Correct mode passed to mn10300_address_cost.\n+\t* config/rs6000/rs6000.c (rs6000_debug_rtx_costs): Update.\n+\t* config/sh/sh.c (and_xor_ior_costs): Update rtx_cost call.\n+\t* doc/tm.texi: Regenerate.\n+\n 2015-07-07  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-core.h: Include symtab.h."}, {"sha": "fdb6243af10f1960ed37e9bf910549ea62c90e1b", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -487,9 +487,9 @@ attempt_change (rtx new_addr, rtx inc_reg)\n   PUT_MODE (mem_tmp, mode);\n   XEXP (mem_tmp, 0) = new_addr;\n \n-  old_cost = (set_src_cost (mem, speed)\n+  old_cost = (set_src_cost (mem, mode, speed)\n \t      + set_rtx_cost (PATTERN (inc_insn.insn), speed));\n-  new_cost = set_src_cost (mem_tmp, speed);\n+  new_cost = set_src_cost (mem_tmp, mode, speed);\n \n   /* The first item of business is to see if this is profitable.  */\n   if (old_cost < new_cost)"}, {"sha": "a79825a44e8a3ba7ff246badc2dfde7c5ef51005", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -957,8 +957,9 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n \t\t     || (GET_CODE (args[i].value) == SUBREG\n \t\t\t && REG_P (SUBREG_REG (args[i].value)))))\n \t\t && args[i].mode != BLKmode\n-\t\t && set_src_cost (args[i].value, optimize_insn_for_speed_p ())\n-\t\t    > COSTS_N_INSNS (1)\n+\t\t && (set_src_cost (args[i].value, args[i].mode,\n+\t\t\t\t   optimize_insn_for_speed_p ())\n+\t\t     > COSTS_N_INSNS (1))\n \t\t && ((*reg_parm_seen\n \t\t      && targetm.small_register_classes_for_mode_p (args[i].mode))\n \t\t     || optimize))"}, {"sha": "9be230a51e24f2ae7cedd564e1b64123430190ca", "filename": "gcc/combine.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -7040,15 +7040,16 @@ expand_compound_operation (rtx x)\n \t\t     >> 1))\n \t       == 0)))\n     {\n-      rtx temp = gen_rtx_ZERO_EXTEND (GET_MODE (x), XEXP (x, 0));\n+      machine_mode mode = GET_MODE (x);\n+      rtx temp = gen_rtx_ZERO_EXTEND (mode, XEXP (x, 0));\n       rtx temp2 = expand_compound_operation (temp);\n \n       /* Make sure this is a profitable operation.  */\n-      if (set_src_cost (x, optimize_this_for_speed_p)\n-          > set_src_cost (temp2, optimize_this_for_speed_p))\n+      if (set_src_cost (x, mode, optimize_this_for_speed_p)\n+          > set_src_cost (temp2, mode, optimize_this_for_speed_p))\n        return temp2;\n-      else if (set_src_cost (x, optimize_this_for_speed_p)\n-               > set_src_cost (temp, optimize_this_for_speed_p))\n+      else if (set_src_cost (x, mode, optimize_this_for_speed_p)\n+               > set_src_cost (temp, mode, optimize_this_for_speed_p))\n        return temp;\n       else\n        return x;\n@@ -7474,8 +7475,8 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n-\t  if (set_src_cost (temp, optimize_this_for_speed_p)\n-\t      <= set_src_cost (temp1, optimize_this_for_speed_p))\n+\t  if (set_src_cost (temp, mode, optimize_this_for_speed_p)\n+\t      <= set_src_cost (temp1, mode, optimize_this_for_speed_p))\n \t    return temp;\n \t  return temp1;\n \t}\n@@ -7660,8 +7661,8 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n-\t  if (set_src_cost (temp1, optimize_this_for_speed_p)\n-\t      < set_src_cost (temp, optimize_this_for_speed_p))\n+\t  if (set_src_cost (temp1, pos_mode, optimize_this_for_speed_p)\n+\t      < set_src_cost (temp, pos_mode, optimize_this_for_speed_p))\n \t    temp = temp1;\n \t}\n       pos_rtx = temp;\n@@ -8442,8 +8443,8 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n \t      y = simplify_gen_binary (AND, GET_MODE (x), XEXP (x, 0),\n \t\t\t\t       gen_int_mode (cval, GET_MODE (x)));\n-\t      if (set_src_cost (y, optimize_this_for_speed_p)\n-\t          < set_src_cost (x, optimize_this_for_speed_p))\n+\t      if (set_src_cost (y, GET_MODE (x), optimize_this_for_speed_p)\n+\t          < set_src_cost (x, GET_MODE (x), optimize_this_for_speed_p))\n \t\tx = y;\n \t    }\n \n@@ -9636,8 +9637,8 @@ distribute_and_simplify_rtx (rtx x, int n)\n   tmp = apply_distributive_law (simplify_gen_binary (inner_code, mode,\n \t\t\t\t\t\t     new_op0, new_op1));\n   if (GET_CODE (tmp) != outer_code\n-      && (set_src_cost (tmp, optimize_this_for_speed_p)\n-\t  < set_src_cost (x, optimize_this_for_speed_p)))\n+      && (set_src_cost (tmp, mode, optimize_this_for_speed_p)\n+\t  < set_src_cost (x, mode, optimize_this_for_speed_p)))\n     return tmp;\n \n   return NULL_RTX;"}, {"sha": "cb00ad379a3f1bc998916685cc3691456b831201", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -5326,7 +5326,7 @@ aarch64_shift_p (enum rtx_code code)\n    operands where needed.  */\n \n static int\n-aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n+aarch64_rtx_mult_cost (rtx x, enum rtx_code code, int outer, bool speed)\n {\n   rtx op0, op1;\n   const struct cpu_cost_table *extra_cost\n@@ -5377,7 +5377,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \t  if (is_extend)\n \t    op0 = aarch64_strip_extend (op0);\n \n-\t  cost += rtx_cost (op0, GET_CODE (op0), 0, speed);\n+\t  cost += rtx_cost (op0, VOIDmode, code, 0, speed);\n \n \t  return cost;\n \t}\n@@ -5397,8 +5397,8 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \t  || (GET_CODE (op0) == SIGN_EXTEND\n \t      && GET_CODE (op1) == SIGN_EXTEND))\n \t{\n-\t  cost += rtx_cost (XEXP (op0, 0), MULT, 0, speed)\n-\t\t  + rtx_cost (XEXP (op1, 0), MULT, 1, speed);\n+\t  cost += rtx_cost (XEXP (op0, 0), VOIDmode, MULT, 0, speed);\n+\t  cost += rtx_cost (XEXP (op1, 0), VOIDmode, MULT, 1, speed);\n \n \t  if (speed)\n \t    {\n@@ -5415,8 +5415,8 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \n       /* This is either an integer multiply or a MADD.  In both cases\n \t we want to recurse and cost the operands.  */\n-      cost += rtx_cost (op0, MULT, 0, speed)\n-\t      + rtx_cost (op1, MULT, 1, speed);\n+      cost += rtx_cost (op0, mode, MULT, 0, speed);\n+      cost += rtx_cost (op1, mode, MULT, 1, speed);\n \n       if (speed)\n \t{\n@@ -5449,8 +5449,8 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \t    cost += extra_cost->fp[mode == DFmode].mult;\n \t}\n \n-      cost += rtx_cost (op0, MULT, 0, speed)\n-\t      + rtx_cost (op1, MULT, 1, speed);\n+      cost += rtx_cost (op0, mode, MULT, 0, speed);\n+      cost += rtx_cost (op1, mode, MULT, 1, speed);\n       return cost;\n     }\n }\n@@ -5474,7 +5474,7 @@ aarch64_address_cost (rtx x,\n \t  /* This is a CONST or SYMBOL ref which will be split\n \t     in a different way depending on the code model in use.\n \t     Cost it through the generic infrastructure.  */\n-\t  int cost_symbol_ref = rtx_cost (x, MEM, 1, speed);\n+\t  int cost_symbol_ref = rtx_cost (x, Pmode, MEM, 1, speed);\n \t  /* Divide through by the cost of one instruction to\n \t     bring it to the same units as the address costs.  */\n \t  cost_symbol_ref /= COSTS_N_INSNS (1);\n@@ -5697,11 +5697,11 @@ aarch64_if_then_else_costs (rtx op0, rtx op1, rtx op2, int *cost, bool speed)\n \t\t  /* TBZ/TBNZ/CBZ/CBNZ.  */\n \t\t  if (GET_CODE (inner) == ZERO_EXTRACT)\n \t\t    /* TBZ/TBNZ.  */\n-\t\t    *cost += rtx_cost (XEXP (inner, 0), ZERO_EXTRACT,\n-\t\t\t \t       0, speed);\n-\t\telse\n-\t\t  /* CBZ/CBNZ.  */\n-\t\t  *cost += rtx_cost (inner, cmpcode, 0, speed);\n+\t\t    *cost += rtx_cost (XEXP (inner, 0), VOIDmode,\n+\t\t\t\t       ZERO_EXTRACT, 0, speed);\n+\t\t  else\n+\t\t    /* CBZ/CBNZ.  */\n+\t\t    *cost += rtx_cost (inner, VOIDmode, cmpcode, 0, speed);\n \n \t        return true;\n \t      }\n@@ -5725,8 +5725,8 @@ aarch64_if_then_else_costs (rtx op0, rtx op1, rtx op2, int *cost, bool speed)\n           || (GET_CODE (op1) == PLUS && XEXP (op1, 1) == const1_rtx))\n \top1 = XEXP (op1, 0);\n \n-      *cost += rtx_cost (op1, IF_THEN_ELSE, 1, speed);\n-      *cost += rtx_cost (op2, IF_THEN_ELSE, 2, speed);\n+      *cost += rtx_cost (op1, VOIDmode, IF_THEN_ELSE, 1, speed);\n+      *cost += rtx_cost (op2, VOIDmode, IF_THEN_ELSE, 2, speed);\n       return true;\n     }\n \n@@ -5737,13 +5737,13 @@ aarch64_if_then_else_costs (rtx op0, rtx op1, rtx op2, int *cost, bool speed)\n /* Calculate the cost of calculating X, storing it in *COST.  Result\n    is true if the total cost of the operation has now been calculated.  */\n static bool\n-aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n+aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t\t   int param ATTRIBUTE_UNUSED, int *cost, bool speed)\n {\n   rtx op0, op1, op2;\n   const struct cpu_cost_table *extra_cost\n     = aarch64_tune_params.insn_extra_cost;\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n \n   /* By default, assume that everything has equivalent cost to the\n      cheapest instruction.  Any additional costs are applied as a delta\n@@ -5778,12 +5778,12 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t     0, speed));\n \t    }\n \n-\t  *cost += rtx_cost (op1, SET, 1, speed);\n+\t  *cost += rtx_cost (op1, mode, SET, 1, speed);\n \t  return true;\n \n \tcase SUBREG:\n \t  if (! REG_P (SUBREG_REG (op0)))\n-\t    *cost += rtx_cost (SUBREG_REG (op0), SET, 0, speed);\n+\t    *cost += rtx_cost (SUBREG_REG (op0), VOIDmode, SET, 0, speed);\n \n \t  /* Fall through.  */\n \tcase REG:\n@@ -5805,7 +5805,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t    }\n           else\n \t    /* Cost is just the cost of the RHS of the set.  */\n-\t    *cost += rtx_cost (op1, SET, 1, speed);\n+\t    *cost += rtx_cost (op1, mode, SET, 1, speed);\n \t  return true;\n \n \tcase ZERO_EXTRACT:\n@@ -5831,7 +5831,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n               /* BFM.  */\n \t      if (speed)\n \t\t*cost += extra_cost->alu.bfi;\n-              *cost += rtx_cost (op1, (enum rtx_code) code, 1, speed);\n+\t      *cost += rtx_cost (op1, VOIDmode, (enum rtx_code) code, 1, speed);\n             }\n \n \t  return true;\n@@ -5929,31 +5929,31 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  return false;\n \t}\n \n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-       {\n+      if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t{\n           if (GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMPARE\n               || GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMM_COMPARE)\n             {\n               /* CSETM.  */\n-              *cost += rtx_cost (XEXP (op0, 0), NEG, 0, speed);\n+\t      *cost += rtx_cost (XEXP (op0, 0), VOIDmode, NEG, 0, speed);\n               return true;\n             }\n \n \t  /* Cost this as SUB wzr, X.  */\n-          op0 = CONST0_RTX (GET_MODE (x));\n+          op0 = CONST0_RTX (mode);\n           op1 = XEXP (x, 0);\n           goto cost_minus;\n         }\n \n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n         {\n           /* Support (neg(fma...)) as a single instruction only if\n              sign of zeros is unimportant.  This matches the decision\n              making in aarch64.md.  */\n           if (GET_CODE (op0) == FMA && !HONOR_SIGNED_ZEROS (GET_MODE (op0)))\n             {\n \t      /* FNMADD.  */\n-              *cost = rtx_cost (op0, NEG, 0, speed);\n+\t      *cost = rtx_cost (op0, mode, NEG, 0, speed);\n               return true;\n             }\n \t  if (speed)\n@@ -5984,6 +5984,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  && GET_CODE (op0) == AND)\n \t{\n \t  x = op0;\n+\t  mode = GET_MODE (op0);\n \t  goto cost_logic;\n \t}\n \n@@ -5993,9 +5994,10 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t     needs encoding in the cost tables.  */\n \n           /* CC_ZESWPmode supports zero extend for free.  */\n-          if (GET_MODE (x) == CC_ZESWPmode && GET_CODE (op0) == ZERO_EXTEND)\n+          if (mode == CC_ZESWPmode && GET_CODE (op0) == ZERO_EXTEND)\n             op0 = XEXP (op0, 0);\n \n+\t  mode = GET_MODE (op0);\n           /* ANDS.  */\n           if (GET_CODE (op0) == AND)\n             {\n@@ -6023,8 +6025,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t      if (speed)\n \t\t*cost += extra_cost->alu.arith;\n \n-              *cost += rtx_cost (op0, COMPARE, 0, speed);\n-\t      *cost += rtx_cost (XEXP (op1, 0), NEG, 1, speed);\n+\t      *cost += rtx_cost (op0, mode, COMPARE, 0, speed);\n+\t      *cost += rtx_cost (XEXP (op1, 0), mode, NEG, 1, speed);\n               return true;\n             }\n \n@@ -6051,7 +6053,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n           if (CONST_DOUBLE_P (op1) && aarch64_float_const_zero_rtx_p (op1))\n             {\n-              *cost += rtx_cost (op0, COMPARE, 0, speed);\n+\t      *cost += rtx_cost (op0, VOIDmode, COMPARE, 0, speed);\n               /* FCMP supports constant 0.0 for no extra cost. */\n               return true;\n             }\n@@ -6080,7 +6082,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \top1 = XEXP (x, 1);\n \n cost_minus:\n-\t*cost += rtx_cost (op0, MINUS, 0, speed);\n+\t*cost += rtx_cost (op0, mode, MINUS, 0, speed);\n \n \t/* Detect valid immediates.  */\n \tif ((GET_MODE_CLASS (mode) == MODE_INT\n@@ -6101,9 +6103,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t    if (speed)\n \t      *cost += extra_cost->alu.extend_arith;\n \n-\t    *cost += rtx_cost (XEXP (XEXP (op1, 0), 0),\n-\t\t\t       (enum rtx_code) GET_CODE (op1),\n-\t\t\t       0, speed);\n+\t    *cost += rtx_cost (XEXP (XEXP (op1, 0), 0), VOIDmode,\n+\t\t\t       (enum rtx_code) GET_CODE (op1), 0, speed);\n \t    return true;\n \t  }\n \n@@ -6120,7 +6121,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t    return true;\n \t  }\n \n-\t*cost += rtx_cost (new_op1, MINUS, 1, speed);\n+\t*cost += rtx_cost (new_op1, VOIDmode, MINUS, 1, speed);\n \n \tif (speed)\n \t  {\n@@ -6155,34 +6156,33 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t    || GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMM_COMPARE)\n \t  {\n \t    /* CSINC.  */\n-\t    *cost += rtx_cost (XEXP (op0, 0), PLUS, 0, speed);\n-\t    *cost += rtx_cost (op1, PLUS, 1, speed);\n+\t    *cost += rtx_cost (XEXP (op0, 0), mode, PLUS, 0, speed);\n+\t    *cost += rtx_cost (op1, mode, PLUS, 1, speed);\n \t    return true;\n \t  }\n \n \tif (GET_MODE_CLASS (mode) == MODE_INT\n \t    && CONST_INT_P (op1)\n \t    && aarch64_uimm12_shift (INTVAL (op1)))\n \t  {\n-\t    *cost += rtx_cost (op0, PLUS, 0, speed);\n+\t    *cost += rtx_cost (op0, mode, PLUS, 0, speed);\n \n \t    if (speed)\n \t      /* ADD (immediate).  */\n \t      *cost += extra_cost->alu.arith;\n \t    return true;\n \t  }\n \n-\t*cost += rtx_cost (op1, PLUS, 1, speed);\n+\t*cost += rtx_cost (op1, mode, PLUS, 1, speed);\n \n \t/* Look for ADD (extended register).  */\n         if (aarch64_rtx_arith_op_extract_p (op0, mode))\n \t  {\n \t    if (speed)\n \t      *cost += extra_cost->alu.extend_arith;\n \n-\t    *cost += rtx_cost (XEXP (XEXP (op0, 0), 0),\n-\t\t\t       (enum rtx_code) GET_CODE (op0),\n-\t\t\t       0, speed);\n+\t    *cost += rtx_cost (XEXP (XEXP (op0, 0), 0), VOIDmode,\n+\t\t\t       (enum rtx_code) GET_CODE (op0), 0, speed);\n \t    return true;\n \t  }\n \n@@ -6198,7 +6198,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t    return true;\n \t  }\n \n-\t*cost += rtx_cost (new_op0, PLUS, 0, speed);\n+\t*cost += rtx_cost (new_op0, VOIDmode, PLUS, 0, speed);\n \n \tif (speed)\n \t  {\n@@ -6250,8 +6250,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n       if (aarch64_extr_rtx_p (x, &op0, &op1))\n         {\n-          *cost += rtx_cost (op0, IOR, 0, speed)\n-                   + rtx_cost (op1, IOR, 1, speed);\n+\t  *cost += rtx_cost (op0, mode, IOR, 0, speed);\n+\t  *cost += rtx_cost (op1, mode, IOR, 1, speed);\n           if (speed)\n             *cost += extra_cost->alu.shift;\n \n@@ -6279,20 +6279,20 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n                                INTVAL (op1)) != 0)\n         {\n           /* This is a UBFM/SBFM.  */\n-          *cost += rtx_cost (XEXP (op0, 0), ZERO_EXTRACT, 0, speed);\n+\t  *cost += rtx_cost (XEXP (op0, 0), mode, ZERO_EXTRACT, 0, speed);\n \t  if (speed)\n \t    *cost += extra_cost->alu.bfx;\n           return true;\n         }\n \n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+      if (GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n \t  /* We possibly get the immediate for free, this is not\n \t     modelled.  */\n \t  if (CONST_INT_P (op1)\n-\t      && aarch64_bitmask_imm (INTVAL (op1), GET_MODE (x)))\n+\t      && aarch64_bitmask_imm (INTVAL (op1), mode))\n \t    {\n-\t      *cost += rtx_cost (op0, (enum rtx_code) code, 0, speed);\n+\t      *cost += rtx_cost (op0, mode, (enum rtx_code) code, 0, speed);\n \n \t      if (speed)\n \t\t*cost += extra_cost->alu.logical;\n@@ -6327,8 +6327,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t\t}\n \n \t      /* In both cases we want to cost both operands.  */\n-\t      *cost += rtx_cost (new_op0, (enum rtx_code) code, 0, speed)\n-\t\t       + rtx_cost (op1, (enum rtx_code) code, 1, speed);\n+\t      *cost += rtx_cost (new_op0, mode, (enum rtx_code) code, 0, speed);\n+\t      *cost += rtx_cost (op1, mode, (enum rtx_code) code, 1, speed);\n \n \t      return true;\n \t    }\n@@ -6349,7 +6349,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       /* MVN-shifted-reg.  */\n       if (op0 != x)\n         {\n-          *cost += rtx_cost (op0, (enum rtx_code) code, 0, speed);\n+\t  *cost += rtx_cost (op0, mode, (enum rtx_code) code, 0, speed);\n \n           if (speed)\n             *cost += extra_cost->alu.log_shift;\n@@ -6365,8 +6365,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n           rtx newop1 = XEXP (op0, 1);\n           rtx op0_stripped = aarch64_strip_shift (newop0);\n \n-          *cost += rtx_cost (newop1, (enum rtx_code) code, 1, speed)\n-                   + rtx_cost (op0_stripped, XOR, 0, speed);\n+\t  *cost += rtx_cost (newop1, mode, (enum rtx_code) code, 1, speed);\n+\t  *cost += rtx_cost (op0_stripped, mode, XOR, 0, speed);\n \n           if (speed)\n             {\n@@ -6399,7 +6399,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  && GET_MODE (op0) == SImode\n \t  && outer == SET)\n \t{\n-\t  int op_cost = rtx_cost (XEXP (x, 0), ZERO_EXTEND, 0, speed);\n+\t  int op_cost = rtx_cost (op0, VOIDmode, ZERO_EXTEND, 0, speed);\n \n \t  if (!op_cost && speed)\n \t    /* MOV.  */\n@@ -6410,10 +6410,10 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n \t  return true;\n \t}\n-      else if (MEM_P (XEXP (x, 0)))\n+      else if (MEM_P (op0))\n \t{\n \t  /* All loads can zero extend to any size for free.  */\n-\t  *cost = rtx_cost (XEXP (x, 0), ZERO_EXTEND, param, speed);\n+\t  *cost = rtx_cost (op0, VOIDmode, ZERO_EXTEND, param, speed);\n \t  return true;\n \t}\n \n@@ -6483,7 +6483,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n               || GET_CODE (op0) == SIGN_EXTEND)\n             op0 = XEXP (op0, 0);\n \n-          *cost += rtx_cost (op0, ASHIFT, 0, speed);\n+\t  *cost += rtx_cost (op0, VOIDmode, ASHIFT, 0, speed);\n           return true;\n         }\n       else\n@@ -6522,7 +6522,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t\t*cost += extra_cost->alu.shift;\n \t    }\n \n-\t  *cost += rtx_cost (op0, (enum rtx_code) code, 0, speed);\n+\t  *cost += rtx_cost (op0, mode, (enum rtx_code) code, 0, speed);\n \t  return true;\n \t}\n       else\n@@ -6593,7 +6593,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n       /* We can trust that the immediates used will be correct (there\n \t are no by-register forms), so we need only cost op0.  */\n-      *cost += rtx_cost (XEXP (x, 0), (enum rtx_code) code, 0, speed);\n+      *cost += rtx_cost (XEXP (x, 0), VOIDmode, (enum rtx_code) code, 0, speed);\n       return true;\n \n     case MULT:\n@@ -6608,13 +6608,13 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t{\n \t  if (VECTOR_MODE_P (mode))\n \t    *cost += extra_cost->vect.alu;\n-\t  else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t    *cost += (extra_cost->mult[GET_MODE (x) == DImode].add\n-\t\t      + extra_cost->mult[GET_MODE (x) == DImode].idiv);\n-\t  else if (GET_MODE (x) == DFmode)\n+\t  else if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t    *cost += (extra_cost->mult[mode == DImode].add\n+\t\t      + extra_cost->mult[mode == DImode].idiv);\n+\t  else if (mode == DFmode)\n \t    *cost += (extra_cost->fp[1].mult\n \t\t      + extra_cost->fp[1].div);\n-\t  else if (GET_MODE (x) == SFmode)\n+\t  else if (mode == SFmode)\n \t    *cost += (extra_cost->fp[0].mult\n \t\t      + extra_cost->fp[0].div);\n \t}\n@@ -6697,9 +6697,9 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n       /* If the remaining parameters are not registers,\n          get the cost to put them into registers.  */\n-      *cost += rtx_cost (op0, FMA, 0, speed);\n-      *cost += rtx_cost (op1, FMA, 1, speed);\n-      *cost += rtx_cost (op2, FMA, 2, speed);\n+      *cost += rtx_cost (op0, mode, FMA, 0, speed);\n+      *cost += rtx_cost (op1, mode, FMA, 1, speed);\n+      *cost += rtx_cost (op2, mode, FMA, 2, speed);\n       return true;\n \n     case FLOAT:\n@@ -6758,7 +6758,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  else\n \t    *cost += extra_cost->fp[GET_MODE (x) == DFmode].toint;\n \t}\n-      *cost += rtx_cost (x, (enum rtx_code) code, 0, speed);\n+      *cost += rtx_cost (x, VOIDmode, (enum rtx_code) code, 0, speed);\n       return true;\n \n     case ABS:\n@@ -6775,8 +6775,8 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  /* FABD, which is analogous to FADD.  */\n \t  if (GET_CODE (op0) == MINUS)\n \t    {\n-\t      *cost += rtx_cost (XEXP (op0, 0), MINUS, 0, speed);\n-\t\t\t+ rtx_cost (XEXP (op0, 1), MINUS, 1, speed);\n+\t      *cost += rtx_cost (XEXP (op0, 0), mode, MINUS, 0, speed);\n+\t      *cost += rtx_cost (XEXP (op0, 1), mode, MINUS, 1, speed);\n \t      if (speed)\n \t\t*cost += extra_cost->fp[mode == DFmode].addsub;\n \n@@ -6857,10 +6857,10 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n           /* UMULH/SMULH.  */\n \t  if (speed)\n \t    *cost += extra_cost->mult[mode == DImode].extend;\n-          *cost += rtx_cost (XEXP (XEXP (XEXP (XEXP (x, 0), 0), 0), 0),\n-\t\t\t     MULT, 0, speed);\n-          *cost += rtx_cost (XEXP (XEXP (XEXP (XEXP (x, 0), 0), 1), 0),\n-\t\t\t     MULT, 1, speed);\n+\t  *cost += rtx_cost (XEXP (XEXP (XEXP (XEXP (x, 0), 0), 0), 0),\n+\t\t\t     mode, MULT, 0, speed);\n+\t  *cost += rtx_cost (XEXP (XEXP (XEXP (XEXP (x, 0), 0), 1), 0),\n+\t\t\t     mode, MULT, 1, speed);\n           return true;\n         }\n \n@@ -6880,10 +6880,10 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n    calculated for X.  This cost is stored in *COST.  Returns true\n    if the total cost of X was calculated.  */\n static bool\n-aarch64_rtx_costs_wrapper (rtx x, int code, int outer,\n+aarch64_rtx_costs_wrapper (rtx x, machine_mode mode, int outer,\n \t\t   int param, int *cost, bool speed)\n {\n-  bool result = aarch64_rtx_costs (x, code, outer, param, cost, speed);\n+  bool result = aarch64_rtx_costs (x, mode, outer, param, cost, speed);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "dbd4a82aee7fdd640ce3160fec1d95c087a1de60", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1360,10 +1360,10 @@ alpha_legitimize_reload_address (rtx x,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-alpha_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n+alpha_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno, int *total,\n \t\t bool speed)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n   const struct alpha_rtx_cost_data *cost_data;\n \n@@ -1428,9 +1428,9 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n       else if (GET_CODE (XEXP (x, 0)) == MULT\n \t       && const48_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n \t{\n-\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0),\n+\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n \t\t\t      (enum rtx_code) outer_code, opno, speed)\n-\t\t    + rtx_cost (XEXP (x, 1),\n+\t\t    + rtx_cost (XEXP (x, 1), mode,\n \t\t\t\t(enum rtx_code) outer_code, opno, speed)\n \t\t    + COSTS_N_INSNS (1));\n \t  return true;"}, {"sha": "ca2ac4d48c96e77b0886d63f948d0dd96e097b21", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -4108,9 +4108,11 @@ static void arc_file_start (void)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-arc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t       int *total, bool speed)\n+arc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t       int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n       /* Small integers are as cheap as registers.  */\n@@ -4202,7 +4204,8 @@ arc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  if (CONSTANT_P (XEXP (x, 0)))\n \t    {\n \t      *total += (COSTS_N_INSNS (2)\n-\t\t\t + rtx_cost (XEXP (x, 1), (enum rtx_code) code, 0, speed));\n+\t\t\t + rtx_cost (XEXP (x, 1), mode, (enum rtx_code) code,\n+\t\t\t\t     0, speed));\n \t      return true;\n \t    }\n \t  *total = COSTS_N_INSNS (1);\n@@ -4244,17 +4247,17 @@ arc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       if (GET_CODE (XEXP (x, 0)) == MULT\n \t  && _2_4_8_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n \t{\n-\t  *total += (rtx_cost (XEXP (x, 1), PLUS, 0, speed)\n-\t\t     + rtx_cost (XEXP (XEXP (x, 0), 0), PLUS, 1, speed));\n+\t  *total += (rtx_cost (XEXP (x, 1), mode, PLUS, 0, speed)\n+\t\t     + rtx_cost (XEXP (XEXP (x, 0), 0), mode, PLUS, 1, speed));\n \t  return true;\n \t}\n       return false;\n     case MINUS:\n       if (GET_CODE (XEXP (x, 1)) == MULT\n \t  && _2_4_8_operand (XEXP (XEXP (x, 1), 1), VOIDmode))\n \t{\n-\t  *total += (rtx_cost (XEXP (x, 0), PLUS, 0, speed)\n-\t\t     + rtx_cost (XEXP (XEXP (x, 1), 0), PLUS, 1, speed));\n+\t  *total += (rtx_cost (XEXP (x, 0), mode, PLUS, 0, speed)\n+\t\t     + rtx_cost (XEXP (XEXP (x, 1), 0), mode, PLUS, 1, speed));\n \t  return true;\n \t}\n       return false;\n@@ -4269,15 +4272,16 @@ arc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t    /* btst / bbit0 / bbit1:\n \t       Small integers and registers are free; everything else can\n \t       be put in a register.  */\n-\t    *total = (rtx_cost (XEXP (op0, 0), SET, 1, speed)\n-\t\t      + rtx_cost (XEXP (op0, 2), SET, 1, speed));\n+\t    mode = GET_MODE (XEXP (op0, 0));\n+\t    *total = (rtx_cost (XEXP (op0, 0), mode, SET, 1, speed)\n+\t\t      + rtx_cost (XEXP (op0, 2), mode, SET, 1, speed));\n \t    return true;\n \t  }\n \tif (GET_CODE (op0) == AND && op1 == const0_rtx\n \t    && satisfies_constraint_C1p (XEXP (op0, 1)))\n \t  {\n \t    /* bmsk.f */\n-\t    *total = rtx_cost (XEXP (op0, 0), SET, 1, speed);\n+\t    *total = rtx_cost (XEXP (op0, 0), VOIDmode, SET, 1, speed);\n \t    return true;\n \t  }\n \t/* add.f  */\n@@ -4286,8 +4290,9 @@ arc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t    /* op0 might be constant, the inside of op1 is rather\n \t       unlikely to be so.  So swapping the operands might lower\n \t       the cost.  */\n-\t    *total = (rtx_cost (op0, PLUS, 1, speed)\n-\t\t      + rtx_cost (XEXP (op1, 0), PLUS, 0, speed));\n+\t    mode = GET_MODE (op0);\n+\t    *total = (rtx_cost (op0, mode, PLUS, 1, speed)\n+\t\t      + rtx_cost (XEXP (op1, 0), mode, PLUS, 0, speed));\n \t  }\n \treturn false;\n       }\n@@ -4302,18 +4307,19 @@ arc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t     be put in a register.  */\n \t  rtx op0 = XEXP (x, 0);\n \n-\t  *total = (rtx_cost (XEXP (op0, 0), SET, 1, speed)\n-\t\t    + rtx_cost (XEXP (op0, 2), SET, 1, speed));\n+\t  mode = GET_MODE (XEXP (op0, 0));\n+\t  *total = (rtx_cost (XEXP (op0, 0), mode, SET, 1, speed)\n+\t\t    + rtx_cost (XEXP (op0, 2), mode, SET, 1, speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n     /* scc_insn expands into two insns.  */\n     case GTU: case GEU: case LEU:\n-      if (GET_MODE (x) == SImode)\n+      if (mode == SImode)\n \t*total += COSTS_N_INSNS (1);\n       return false;\n     case LTU: /* might use adc.  */\n-      if (GET_MODE (x) == SImode)\n+      if (mode == SImode)\n \t*total += COSTS_N_INSNS (1) - 1;\n       return false;\n     default:"}, {"sha": "1862507cc4f2ec4d842f5f35738675d34fbbbd1a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 194, "deletions": 166, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -181,7 +181,7 @@ static bool arm_slowmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, boo\n static bool arm_fastmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_xscale_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_9e_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n-static bool arm_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool arm_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int arm_address_cost (rtx, machine_mode, addr_space_t, bool);\n static int arm_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n static int arm_memory_move_cost (machine_mode, reg_class_t, bool);\n@@ -8318,7 +8318,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (REG_P (XEXP (x, 1)))\n \t*total = COSTS_N_INSNS (1); /* Need to subtract from 32 */\n       else if (!CONST_INT_P (XEXP (x, 1)))\n-\t*total = rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t*total = rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \n       /* Fall through */\n     case ROTATERT:\n@@ -8330,7 +8330,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n       /* Fall through */\n     case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n-      *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n       if (mode == DImode)\n \t{\n \t  *total += COSTS_N_INSNS (3);\n@@ -8353,14 +8353,14 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  if (CONST_INT_P (XEXP (x, 0))\n \t      && const_ok_for_arm (INTVAL (XEXP (x, 0))))\n \t    {\n-\t      *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t      *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t      return true;\n \t    }\n \n \t  if (CONST_INT_P (XEXP (x, 1))\n \t      && const_ok_for_arm (INTVAL (XEXP (x, 1))))\n \t    {\n-\t      *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n \t      return true;\n \t    }\n \n@@ -8377,14 +8377,14 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t      if (CONST_DOUBLE_P (XEXP (x, 0))\n \t\t  && arm_const_double_rtx (XEXP (x, 0)))\n \t\t{\n-\t\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t\t  return true;\n \t\t}\n \n \t      if (CONST_DOUBLE_P (XEXP (x, 1))\n \t\t  && arm_const_double_rtx (XEXP (x, 1)))\n \t\t{\n-\t\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n \t\t  return true;\n \t\t}\n \n@@ -8398,7 +8398,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (CONST_INT_P (XEXP (x, 0))\n \t  && const_ok_for_arm (INTVAL (XEXP (x, 0))))\n \t{\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t  return true;\n \t}\n \n@@ -8407,32 +8407,33 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  || subcode == LSHIFTRT\n \t  || subcode == ROTATE || subcode == ROTATERT)\n \t{\n-\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 1), 0), subcode, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 1), 0), mode, subcode, 0, speed);\n \t  return true;\n \t}\n \n       /* A shift as a part of RSB costs no more than RSB itself.  */\n       if (GET_CODE (XEXP (x, 0)) == MULT\n \t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n \t{\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), code, 0, speed);\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, code, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t  return true;\n \t}\n \n       if (subcode == MULT\n \t  && power_of_two_operand (XEXP (XEXP (x, 1), 1), SImode))\n \t{\n-\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 1), 0), subcode, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 1), 0), mode, subcode, 0, speed);\n \t  return true;\n \t}\n \n       if (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == RTX_COMPARE\n \t  || GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == RTX_COMM_COMPARE)\n \t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, speed);\n \t  if (REG_P (XEXP (XEXP (x, 1), 0))\n \t      && REGNO (XEXP (XEXP (x, 1), 0)) != CC_REGNUM)\n \t    *total += COSTS_N_INSNS (1);\n@@ -8448,9 +8449,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t      || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND))\n \t{\n \t  *total = COSTS_N_INSNS (1);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), GET_CODE (XEXP (x, 0)),\n-\t\t\t      0, speed);\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode,\n+\t\t\t      GET_CODE (XEXP (x, 0)), 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t  return true;\n \t}\n \n@@ -8474,7 +8475,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t      if (CONST_DOUBLE_P (XEXP (x, 1))\n \t\t  && arm_const_double_rtx (XEXP (x, 1)))\n \t\t{\n-\t\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n \t\t  return true;\n \t\t}\n \n@@ -8488,7 +8489,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMPARE\n \t  || GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_COMM_COMPARE)\n \t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 1), mode, code,\n+\t\t\t\t\t\t 1, speed);\n \t  if (REG_P (XEXP (XEXP (x, 0), 0))\n \t      && REGNO (XEXP (XEXP (x, 0), 0)) != CC_REGNUM)\n \t    *total += COSTS_N_INSNS (1);\n@@ -8515,7 +8517,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  if (CONST_INT_P (XEXP (x, 1))\n \t      && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n \t    {\n-\t      *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n \t      return true;\n \t    }\n \n@@ -8526,24 +8528,24 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n \t{\n-\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n \t  return true;\n \t}\n       subcode = GET_CODE (XEXP (x, 0));\n       if (subcode == ASHIFT || subcode == ASHIFTRT\n \t  || subcode == LSHIFTRT\n \t  || subcode == ROTATE || subcode == ROTATERT)\n \t{\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n \t  return true;\n \t}\n \n       if (subcode == MULT\n \t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n \t{\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n \t  return true;\n \t}\n \n@@ -8569,7 +8571,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  && (GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == ZERO_EXTEND\n \t      || GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == SIGN_EXTEND))\n \t{\n-\t  *total = rtx_cost (XEXP (XEXP (x, 0), 0), LSHIFTRT, 0, speed);\n+\t  *total = rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode, LSHIFTRT,\n+\t\t\t     0, speed);\n \t  return true;\n \t}\n       *total = COSTS_N_INSNS (2); /* Plus the cost of the MULT */\n@@ -8601,11 +8604,13 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t      || (subcode == MULT\n \t\t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode)))\n \t    {\n-\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode,\n+\t\t\t\t  0, speed);\n \t      /* Register shifts cost an extra cycle.  */\n \t      if (!CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n \t\t*total += COSTS_N_INSNS (1) + rtx_cost (XEXP (XEXP (x, 0), 1),\n-\t\t\t\t\t\t\tsubcode, 1, speed);\n+\t\t\t\t\t\t\tmode, subcode,\n+\t\t\t\t\t\t\t1, speed);\n \t      return true;\n \t    }\n \t}\n@@ -8626,14 +8631,15 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t    && REG_P (XEXP (operand, 0))\n \t    && REGNO (XEXP (operand, 0)) == CC_REGNUM))\n \t*total += COSTS_N_INSNS (1);\n-      *total += (rtx_cost (XEXP (x, 1), code, 1, speed)\n-\t\t + rtx_cost (XEXP (x, 2), code, 2, speed));\n+      *total += rtx_cost (XEXP (x, 1), VOIDmode, code, 1, speed);\n+      *total += rtx_cost (XEXP (x, 2), VOIDmode, code, 2, speed);\n       return true;\n \n     case NE:\n       if (mode == SImode && XEXP (x, 1) == const0_rtx)\n \t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, speed);\n \t  return true;\n \t}\n       goto scc_insn;\n@@ -8642,7 +8648,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if ((!REG_P (XEXP (x, 0)) || REGNO (XEXP (x, 0)) != CC_REGNUM)\n \t  && mode == SImode && XEXP (x, 1) == const0_rtx)\n \t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, speed);\n \t  return true;\n \t}\n       goto scc_insn;\n@@ -8651,7 +8658,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if ((!REG_P (XEXP (x, 0)) || REGNO (XEXP (x, 0)) != CC_REGNUM)\n \t  && mode == SImode && XEXP (x, 1) == const0_rtx)\n \t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, speed);\n \t  return true;\n \t}\n       goto scc_insn;\n@@ -8692,7 +8700,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && const_ok_for_op (INTVAL (XEXP (x, 1)), code))\n \t{\n-\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed);\n \t  return true;\n \t}\n \n@@ -8701,16 +8709,18 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  || subcode == LSHIFTRT\n \t  || subcode == ROTATE || subcode == ROTATERT)\n \t{\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n+\t  mode = GET_MODE (XEXP (x, 0));\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n \t  return true;\n \t}\n \n       if (subcode == MULT\n \t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n \t{\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), subcode, 0, speed);\n+\t  mode = GET_MODE (XEXP (x, 0));\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, subcode, 0, speed);\n \t  return true;\n \t}\n \n@@ -8720,10 +8730,10 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n     case UMAX:\n     case SMIN:\n     case SMAX:\n-      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, speed);\n+      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n       if (!CONST_INT_P (XEXP (x, 1))\n \t  || !const_ok_for_arm (INTVAL (XEXP (x, 1))))\n-\t*total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t*total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n       return true;\n \n     case ABS:\n@@ -8800,7 +8810,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n-      *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, speed);\n+      mode = GET_MODE (XEXP (x, 0));\n+      *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n       return true;\n \n     case CONST_INT:\n@@ -8825,7 +8836,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n     case LO_SUM:\n       *total = COSTS_N_INSNS (1);\n-      *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+      *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n       return true;\n \n     case CONST_DOUBLE:\n@@ -8843,7 +8854,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       if (TARGET_NEON && MEM_P (SET_DEST (x))\n \t  && GET_CODE (SET_SRC (x)) == VEC_SELECT)\n \t{\n-\t  *total = rtx_cost (SET_DEST (x), code, 0, speed);\n+\t  mode = GET_MODE (SET_DEST (x));\n+\t  *total = rtx_cost (SET_DEST (x), mode, code, 0, speed);\n \t  if (!neon_vector_mem_operand (SET_DEST (x), 2, true))\n \t    *total += COSTS_N_INSNS (1);\n \t  return true;\n@@ -8854,7 +8866,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \t  && MEM_P (XEXP (XEXP (SET_SRC (x), 0), 0)))\n \t{\n \t  rtx mem = XEXP (XEXP (SET_SRC (x), 0), 0);\n-\t  *total = rtx_cost (mem, code, 0, speed);\n+\t  mode = GET_MODE (SET_DEST (x));\n+\t  *total = rtx_cost (mem, mode, code, 0, speed);\n \t  if (!neon_vector_mem_operand (mem, 2, true))\n \t    *total += COSTS_N_INSNS (1);\n \t  return true;\n@@ -9077,7 +9090,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case ROTATE:\n       if (mode == SImode && REG_P (XEXP (x, 1)))\n \t{\n-\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code, 0, false);\n+\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, false);\n \t  return true;\n \t}\n       /* Fall through */\n@@ -9087,15 +9101,17 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n     case ASHIFTRT:\n       if (mode == DImode && CONST_INT_P (XEXP (x, 1)))\n \t{\n-\t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), code, 0, false);\n+\t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, false);\n \t  return true;\n \t}\n       else if (mode == SImode)\n \t{\n-\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code, 0, false);\n+\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), mode, code,\n+\t\t\t\t\t\t 0, false);\n \t  /* Slightly disparage register shifts, but not by much.  */\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n-\t    *total += 1 + rtx_cost (XEXP (x, 1), code, 1, false);\n+\t    *total += 1 + rtx_cost (XEXP (x, 1), mode, code, 1, false);\n \t  return true;\n \t}\n \n@@ -9147,8 +9163,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  && power_of_two_operand (XEXP (XEXP (x, 0), 1), SImode))\n \t{\n \t  *total = COSTS_N_INSNS (TARGET_THUMB2 ? 2 : 1);\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), code, 0, false);\n-\t  *total += rtx_cost (XEXP (x, 1), code, 1, false);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode, code, 0, false);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, false);\n \t  return true;\n \t}\n \n@@ -9326,7 +9342,7 @@ arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)\n \t*cost += (ARM_NUM_REGS (GET_MODE (x)) * extra_cost->ldst.store\n \t\t  + extra_cost->ldst.store_unaligned);\n \n-      *cost += rtx_cost (XVECEXP (x, 0, 0), UNSPEC, 0, speed_p);\n+      *cost += rtx_cost (XVECEXP (x, 0, 0), VOIDmode, UNSPEC, 0, speed_p);\n #ifdef NOT_YET\n       *cost += arm_address_cost (XEXP (XVECEXP (x, 0, 0), 0), GET_MODE (x),\n \t\t\t\t ADDR_SPACE_GENERIC, speed_p);\n@@ -9365,15 +9381,18 @@ arm_unspec_cost (rtx x, enum rtx_code /* outer_code */, bool speed_p, int *cost)\n \t        if (shift_reg)\t\t\t\t\t\t\\\n \t\t  {\t\t\t\t\t\t\t\\\n \t\t    if (speed_p)\t\t\t\t\t\\\n-\t\t      *cost += extra_cost->alu.arith_shift_reg;\t\\\n-\t\t    *cost += rtx_cost (shift_reg, ASHIFT, 1, speed_p);\t\\\n+\t\t      *cost += extra_cost->alu.arith_shift_reg;\t\t\\\n+\t\t    *cost += rtx_cost (shift_reg, GET_MODE (shift_reg),\t\\\n+\t\t\t\t       ASHIFT, 1, speed_p);\t\t\\\n \t\t  }\t\t\t\t\t\t\t\\\n \t        else if (speed_p)\t\t\t\t\t\\\n-\t\t  *cost += extra_cost->alu.arith_shift;\t\t\\\n+\t\t  *cost += extra_cost->alu.arith_shift;\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\t\t  *cost += (rtx_cost (shift_op, ASHIFT, 0, speed_p)\t\\\n+\t\t*cost += (rtx_cost (shift_op, GET_MODE (shift_op),\t\\\n+\t\t\t\t    ASHIFT, 0, speed_p)\t\t\t\\\n \t\t\t  + rtx_cost (XEXP (x, 1 - IDX),\t\t\\\n-\t\t\t              OP, 1, speed_p));\t\t\\\n+\t\t\t\t      GET_MODE (shift_op),\t\t\\\n+\t\t\t              OP, 1, speed_p));\t\t\t\\\n \t        return true;\t\t\t\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n@@ -9437,7 +9456,8 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  /* Handle CONST_INT here, since the value doesn't have a mode\n \t     and we would otherwise be unable to work out the true cost.  */\n-\t  *cost = rtx_cost (SET_DEST (x), SET, 0, speed_p);\n+\t  *cost = rtx_cost (SET_DEST (x), GET_MODE (SET_DEST (x)), SET,\n+\t\t\t    0, speed_p);\n \t  outer_code = SET;\n \t  /* Slightly lower the cost of setting a core reg to a constant.\n \t     This helps break up chains and allows for better scheduling.  */\n@@ -9544,7 +9564,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (mode == SImode && REG_P (XEXP (x, 1)))\n \t{\n \t  *cost = (COSTS_N_INSNS (2)\n-\t\t   + rtx_cost (XEXP (x, 0), code, 0, speed_p));\n+\t\t   + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.shift_reg;\n \t  return true;\n@@ -9557,19 +9577,19 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if (mode == DImode && CONST_INT_P (XEXP (x, 1)))\n \t{\n \t  *cost = (COSTS_N_INSNS (3)\n-\t\t   + rtx_cost (XEXP (x, 0), code, 0, speed_p));\n+\t\t   + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.shift;\n \t  return true;\n \t}\n       else if (mode == SImode)\n \t{\n \t  *cost = (COSTS_N_INSNS (1)\n-\t\t   + rtx_cost (XEXP (x, 0), code, 0, speed_p));\n+\t\t   + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n \t  /* Slightly disparage register shifts at -Os, but not by much.  */\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    *cost += (speed_p ? extra_cost->alu.shift_reg : 1\n-\t\t      + rtx_cost (XEXP (x, 1), code, 1, speed_p));\n+\t\t      + rtx_cost (XEXP (x, 1), mode, code, 1, speed_p));\n \t  return true;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_INT\n@@ -9578,12 +9598,12 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  if (code == ASHIFT)\n \t    {\n \t      *cost = (COSTS_N_INSNS (1)\n-\t\t       + rtx_cost (XEXP (x, 0), code, 0, speed_p));\n+\t\t       + rtx_cost (XEXP (x, 0), mode, code, 0, speed_p));\n \t      /* Slightly disparage register shifts at -Os, but not by\n \t         much.  */\n \t      if (!CONST_INT_P (XEXP (x, 1)))\n \t\t*cost += (speed_p ? extra_cost->alu.shift_reg : 1\n-\t\t\t  + rtx_cost (XEXP (x, 1), code, 1, speed_p));\n+\t\t\t  + rtx_cost (XEXP (x, 1), mode, code, 1, speed_p));\n \t    }\n \t  else if (code == LSHIFTRT || code == ASHIFTRT)\n \t    {\n@@ -9593,12 +9613,12 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  *cost = COSTS_N_INSNS (1);\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.bfx;\n-\t\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t\t}\n \t      else\n \t\t{\n \t\t  *cost = COSTS_N_INSNS (2);\n-\t\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t\t  if (speed_p)\n \t\t    {\n \t\t      if (CONST_INT_P (XEXP (x, 1)))\n@@ -9615,7 +9635,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  else /* Rotates.  */\n \t    {\n \t      *cost = COSTS_N_INSNS (3 + !CONST_INT_P (XEXP (x, 1)));\n-\t      *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t      if (speed_p)\n \t\t{\n \t\t  if (CONST_INT_P (XEXP (x, 1)))\n@@ -9705,9 +9725,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (GET_CODE (mul_op0) == NEG)\n \t\tmul_op0 = XEXP (mul_op0, 0);\n \n-\t      *cost += (rtx_cost (mul_op0, code, 0, speed_p)\n-\t\t\t+ rtx_cost (mul_op1, code, 0, speed_p)\n-\t\t\t+ rtx_cost (sub_op, code, 0, speed_p));\n+\t      *cost += (rtx_cost (mul_op0, mode, code, 0, speed_p)\n+\t\t\t+ rtx_cost (mul_op1, mode, code, 0, speed_p)\n+\t\t\t+ rtx_cost (sub_op, mode, code, 0, speed_p));\n \n \t      return true;\n \t    }\n@@ -9740,13 +9760,13 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t{\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.arith_shift_reg;\n-\t\t  *cost += rtx_cost (shift_by_reg, code, 0, speed_p);\n+\t\t  *cost += rtx_cost (shift_by_reg, mode, code, 0, speed_p);\n \t\t}\n \t      else if (speed_p)\n \t\t*cost += extra_cost->alu.arith_shift;\n \n-\t      *cost += (rtx_cost (shift_op, code, 0, speed_p)\n-\t\t\t+ rtx_cost (non_shift_op, code, 0, speed_p));\n+\t      *cost += rtx_cost (shift_op, mode, code, 0, speed_p);\n+\t      *cost += rtx_cost (non_shift_op, mode, code, 0, speed_p);\n \t      return true;\n \t    }\n \n@@ -9756,9 +9776,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      /* MLS.  */\n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[0].add;\n-\t      *cost += (rtx_cost (XEXP (x, 0), MINUS, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (XEXP (x, 1), 0), MULT, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (XEXP (x, 1), 1), MULT, 1, speed_p));\n+\t      *cost += rtx_cost (XEXP (x, 0), mode, MINUS, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (XEXP (x, 1), 0), mode, MULT, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (XEXP (x, 1), 1), mode, MULT, 1, speed_p);\n \t      return true;\n \t    }\n \n@@ -9770,7 +9790,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      *cost = COSTS_N_INSNS (insns);\n \t      if (speed_p)\n \t\t*cost += insns * extra_cost->alu.arith;\n-\t      *cost += rtx_cost (XEXP (x, 1), code, 1, speed_p);\n+\t      *cost += rtx_cost (XEXP (x, 1), mode, code, 1, speed_p);\n \t      return true;\n \t    }\n \t  else if (speed_p)\n@@ -9798,7 +9818,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n \t  if (CONST_INT_P (XEXP (x, 0)))\n \t    {\n-\t      *cost += rtx_cost (XEXP (x, 1), code, 1, speed_p);\n+\t      *cost += rtx_cost (XEXP (x, 1), mode, code, 1, speed_p);\n \t      return true;\n \t    }\n \n@@ -9817,20 +9837,21 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t*cost += 2 * extra_cost->alu.arith;\n \n \t      if (GET_CODE (op1) == ZERO_EXTEND)\n-\t\t*cost += rtx_cost (XEXP (op1, 0), ZERO_EXTEND, 0, speed_p);\n+\t\t*cost += rtx_cost (XEXP (op1, 0), VOIDmode, ZERO_EXTEND,\n+\t\t\t\t   0, speed_p);\n \t      else\n-\t\t*cost += rtx_cost (op1, MINUS, 1, speed_p);\n-\t      *cost += rtx_cost (XEXP (XEXP (x, 0), 0), ZERO_EXTEND,\n+\t\t*cost += rtx_cost (op1, mode, MINUS, 1, speed_p);\n+\t      *cost += rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode, ZERO_EXTEND,\n \t\t\t\t 0, speed_p);\n \t      return true;\n \t    }\n \t  else if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n \t    {\n \t      if (speed_p)\n \t\t*cost += extra_cost->alu.arith + extra_cost->alu.arith_shift;\n-\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), SIGN_EXTEND,\n+\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode, SIGN_EXTEND,\n \t\t\t\t  0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), MINUS, 1, speed_p));\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, MINUS, 1, speed_p));\n \t      return true;\n \t    }\n \t  else if (GET_CODE (XEXP (x, 1)) == ZERO_EXTEND\n@@ -9841,8 +9862,8 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t\t  + (GET_CODE (XEXP (x, 1)) == ZERO_EXTEND\n \t\t\t     ? extra_cost->alu.arith\n \t\t\t     : extra_cost->alu.arith_shift));\n-\t      *cost += (rtx_cost (XEXP (x, 0), MINUS, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (XEXP (x, 1), 0),\n+\t      *cost += (rtx_cost (XEXP (x, 0), mode, MINUS, 0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (XEXP (x, 1), 0), VOIDmode,\n \t\t\t\t    GET_CODE (XEXP (x, 1)), 0, speed_p));\n \t      return true;\n \t    }\n@@ -9873,9 +9894,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      mul_op1 = XEXP (XEXP (x, 0), 1);\n \t      add_op = XEXP (x, 1);\n \n-\t      *cost += (rtx_cost (mul_op0, code, 0, speed_p)\n-\t\t\t+ rtx_cost (mul_op1, code, 0, speed_p)\n-\t\t\t+ rtx_cost (add_op, code, 0, speed_p));\n+\t      *cost += (rtx_cost (mul_op0, mode, code, 0, speed_p)\n+\t\t\t+ rtx_cost (mul_op1, mode, code, 0, speed_p)\n+\t\t\t+ rtx_cost (add_op, mode, code, 0, speed_p));\n \n \t      return true;\n \t    }\n@@ -9912,7 +9933,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t*cost += insns * extra_cost->alu.arith;\n \t      /* Slightly penalize a narrow operation as the result may\n \t\t need widening.  */\n-\t      *cost += 1 + rtx_cost (XEXP (x, 0), PLUS, 0, speed_p);\n+\t      *cost += 1 + rtx_cost (XEXP (x, 0), mode, PLUS, 0, speed_p);\n \t      return true;\n \t    }\n \n@@ -9937,9 +9958,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      /* UXTA[BH] or SXTA[BH].  */\n \t      if (speed_p)\n \t\t*cost += extra_cost->alu.extend_arith;\n-\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), ZERO_EXTEND, 0,\n-\t\t\t\t  speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), PLUS, 0, speed_p));\n+\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode, ZERO_EXTEND,\n+\t\t\t\t  0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 0, speed_p));\n \t      return true;\n \t    }\n \n@@ -9951,13 +9972,13 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t{\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.arith_shift_reg;\n-\t\t  *cost += rtx_cost (shift_reg, ASHIFT, 1, speed_p);\n+\t\t  *cost += rtx_cost (shift_reg, mode, ASHIFT, 1, speed_p);\n \t\t}\n \t      else if (speed_p)\n \t\t*cost += extra_cost->alu.arith_shift;\n \n-\t      *cost += (rtx_cost (shift_op, ASHIFT, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), PLUS, 1, speed_p));\n+\t      *cost += (rtx_cost (shift_op, mode, ASHIFT, 0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n \t      return true;\n \t    }\n \t  if (GET_CODE (XEXP (x, 0)) == MULT)\n@@ -9984,19 +10005,19 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  /* SMLA[BT][BT].  */\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->mult[0].extend_add;\n-\t\t  *cost += (rtx_cost (XEXP (XEXP (mul_op, 0), 0),\n+\t\t  *cost += (rtx_cost (XEXP (XEXP (mul_op, 0), 0), mode,\n \t\t\t\t      SIGN_EXTEND, 0, speed_p)\n-\t\t\t    + rtx_cost (XEXP (XEXP (mul_op, 1), 0),\n+\t\t\t    + rtx_cost (XEXP (XEXP (mul_op, 1), 0), mode,\n \t\t\t\t\tSIGN_EXTEND, 0, speed_p)\n-\t\t\t    + rtx_cost (XEXP (x, 1), PLUS, 1, speed_p));\n+\t\t\t    + rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n \t\t  return true;\n \t\t}\n \n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[0].add;\n-\t      *cost += (rtx_cost (XEXP (mul_op, 0), MULT, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (mul_op, 1), MULT, 1, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), PLUS, 1, speed_p));\n+\t      *cost += (rtx_cost (XEXP (mul_op, 0), mode, MULT, 0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (mul_op, 1), mode, MULT, 1, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n \t      return true;\n \t    }\n \t  if (CONST_INT_P (XEXP (x, 1)))\n@@ -10007,7 +10028,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      *cost = COSTS_N_INSNS (insns);\n \t      if (speed_p)\n \t\t*cost += insns * extra_cost->alu.arith;\n-\t      *cost += rtx_cost (XEXP (x, 0), PLUS, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (x, 0), mode, PLUS, 0, speed_p);\n \t      return true;\n \t    }\n \t  else if (speed_p)\n@@ -10028,11 +10049,11 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[1].extend_add;\n-\t      *cost += (rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t      *cost += (rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0), mode,\n \t\t\t\t  ZERO_EXTEND, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (XEXP (XEXP (x, 0), 1), 0),\n+\t\t\t+ rtx_cost (XEXP (XEXP (XEXP (x, 0), 1), 0), mode,\n \t\t\t\t    ZERO_EXTEND, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), PLUS, 1, speed_p));\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n \t      return true;\n \t    }\n \n@@ -10047,9 +10068,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t\t     ? extra_cost->alu.arith\n \t\t\t     : extra_cost->alu.arith_shift));\n \n-\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), ZERO_EXTEND, 0,\n-\t\t\t\t  speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), PLUS, 1, speed_p));\n+\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode, ZERO_EXTEND,\n+\t\t\t\t  0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, PLUS, 1, speed_p));\n \t      return true;\n \t    }\n \n@@ -10093,13 +10114,13 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t{\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.log_shift_reg;\n-\t\t  *cost += rtx_cost (shift_reg, ASHIFT, 1, speed_p);\n+\t\t  *cost += rtx_cost (shift_reg, mode, ASHIFT, 1, speed_p);\n \t\t}\n \t      else if (speed_p)\n \t\t*cost += extra_cost->alu.log_shift;\n \n-\t      *cost += (rtx_cost (shift_op, ASHIFT, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), code, 1, speed_p));\n+\t      *cost += (rtx_cost (shift_op, mode, ASHIFT, 0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, code, 1, speed_p));\n \t      return true;\n \t    }\n \n@@ -10112,14 +10133,14 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      *cost = COSTS_N_INSNS (insns);\n \t      if (speed_p)\n \t\t*cost += insns * extra_cost->alu.logical;\n-\t      *cost += rtx_cost (op0, code, 0, speed_p);\n+\t      *cost += rtx_cost (op0, mode, code, 0, speed_p);\n \t      return true;\n \t    }\n \n \t  if (speed_p)\n \t    *cost += extra_cost->alu.logical;\n-\t  *cost += (rtx_cost (op0, code, 0, speed_p)\n-\t\t    + rtx_cost (XEXP (x, 1), code, 1, speed_p));\n+\t  *cost += (rtx_cost (op0, mode, code, 0, speed_p)\n+\t\t    + rtx_cost (XEXP (x, 1), mode, code, 1, speed_p));\n \t  return true;\n \t}\n \n@@ -10140,17 +10161,19 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (speed_p)\n \t\t*cost += 2 * extra_cost->alu.logical;\n \n-\t      *cost += (rtx_cost (XEXP (op0, 0), ZERO_EXTEND, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), code, 0, speed_p));\n+\t      *cost += (rtx_cost (XEXP (op0, 0), VOIDmode, ZERO_EXTEND,\n+\t\t\t\t  0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, code, 0, speed_p));\n \t      return true;\n \t    }\n \t  else if (GET_CODE (op0) == SIGN_EXTEND)\n \t    {\n \t      if (speed_p)\n \t\t*cost += extra_cost->alu.logical + extra_cost->alu.log_shift;\n \n-\t      *cost += (rtx_cost (XEXP (op0, 0), SIGN_EXTEND, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), code, 0, speed_p));\n+\t      *cost += (rtx_cost (XEXP (op0, 0), VOIDmode, SIGN_EXTEND,\n+\t\t\t\t  0, speed_p)\n+\t\t\t+ rtx_cost (XEXP (x, 1), mode, code, 0, speed_p));\n \t      return true;\n \t    }\n \n@@ -10178,8 +10201,8 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode != SFmode].mult;\n \n-\t  *cost += (rtx_cost (op0, MULT, 0, speed_p)\n-\t\t    + rtx_cost (XEXP (x, 1), MULT, 1, speed_p));\n+\t  *cost += (rtx_cost (op0, mode, MULT, 0, speed_p)\n+\t\t    + rtx_cost (XEXP (x, 1), mode, MULT, 1, speed_p));\n \t  return true;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -10209,8 +10232,8 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      /* SMUL[TB][TB].  */\n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[0].extend;\n-\t      *cost += (rtx_cost (XEXP (x, 0), SIGN_EXTEND, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (x, 1), SIGN_EXTEND, 0, speed_p));\n+\t      *cost += rtx_cost (XEXP (x, 0), mode, SIGN_EXTEND, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (x, 1), mode, SIGN_EXTEND, 1, speed_p);\n \t      return true;\n \t    }\n \t  if (speed_p)\n@@ -10229,9 +10252,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      *cost = COSTS_N_INSNS (1);\n \t      if (speed_p)\n \t\t*cost += extra_cost->mult[1].extend;\n-\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0),\n+\t      *cost += (rtx_cost (XEXP (XEXP (x, 0), 0), VOIDmode,\n \t\t\t\t  ZERO_EXTEND, 0, speed_p)\n-\t\t\t+ rtx_cost (XEXP (XEXP (x, 1), 0),\n+\t\t\t+ rtx_cost (XEXP (XEXP (x, 1), 0), VOIDmode,\n \t\t\t\t    ZERO_EXTEND, 0, speed_p));\n \t      return true;\n \t    }\n@@ -10269,7 +10292,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (speed_p)\n \t\t*cost += (extra_cost->alu.log_shift\n \t\t\t  + extra_cost->alu.arith_shift);\n-\t      *cost += rtx_cost (XEXP (XEXP (x, 0), 0), ABS, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (XEXP (x, 0), 0), mode, ABS, 0, speed_p);\n \t      return true;\n \t    }\n \n@@ -10284,11 +10307,12 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t    && REGNO (XEXP (XEXP (x, 0), 0)) == CC_REGNUM\n \t\t    && XEXP (XEXP (x, 0), 1) == const0_rtx))\n \t\t{\n+\t\t  mode = GET_MODE (XEXP (XEXP (x, 0), 0));\n \t\t  *cost += (COSTS_N_INSNS (1)\n-\t\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), COMPARE, 0,\n-\t\t\t\t\tspeed_p)\n-\t\t\t    + rtx_cost (XEXP (XEXP (x, 0), 1), COMPARE, 1,\n-\t\t\t\t\tspeed_p));\n+\t\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), mode, COMPARE,\n+\t\t\t\t\t0, speed_p)\n+\t\t\t    + rtx_cost (XEXP (XEXP (x, 0), 1), mode, COMPARE,\n+\t\t\t\t\t1, speed_p));\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.arith;\n \t\t}\n@@ -10337,11 +10361,11 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t{\n \t\t  if (speed_p)\n \t\t    *cost += extra_cost->alu.log_shift_reg;\n-\t\t  *cost += rtx_cost (shift_reg, ASHIFT, 1, speed_p);\n+\t\t  *cost += rtx_cost (shift_reg, mode, ASHIFT, 1, speed_p);\n \t\t}\n \t      else if (speed_p)\n \t\t*cost += extra_cost->alu.log_shift;\n-\t      *cost += rtx_cost (shift_op, ASHIFT, 0, speed_p);\n+\t      *cost += rtx_cost (shift_op, mode, ASHIFT, 0, speed_p);\n \t      return true;\n \t    }\n \n@@ -10367,10 +10391,10 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t    *cost = COSTS_N_INSNS (4);\n \t    return true;\n \t  }\n-\tint op1cost = rtx_cost (XEXP (x, 1), SET, 1, speed_p);\n-\tint op2cost = rtx_cost (XEXP (x, 2), SET, 1, speed_p);\n+\tint op1cost = rtx_cost (XEXP (x, 1), mode, SET, 1, speed_p);\n+\tint op2cost = rtx_cost (XEXP (x, 2), mode, SET, 1, speed_p);\n \n-\t*cost = rtx_cost (XEXP (x, 0), IF_THEN_ELSE, 0, speed_p);\n+\t*cost = rtx_cost (XEXP (x, 0), mode, IF_THEN_ELSE, 0, speed_p);\n \t/* Assume that if one arm of the if_then_else is a register,\n \t   that it will be tied with the result and eliminate the\n \t   conditional insn.  */\n@@ -10413,7 +10437,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n \t      if (XEXP (x, 1) == CONST0_RTX (op0mode))\n \t\t{\n-\t\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t\t  *cost += rtx_cost (XEXP (x, 0), op0mode, code, 0, speed_p);\n \t\t  return true;\n \t\t}\n \n@@ -10444,7 +10468,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t       || (GET_CODE (XEXP (x, 0)) == SUBREG\n \t\t\t   && REG_P (SUBREG_REG (XEXP (x, 0))))))\n \t\t{\n-\t\t  *cost = rtx_cost (XEXP (x, 0), COMPARE, 0, speed_p);\n+\t\t  *cost = rtx_cost (XEXP (x, 0), op0mode, COMPARE, 0, speed_p);\n \n \t\t  /* Multiply operations that set the flags are often\n \t\t     significantly more expensive.  */\n@@ -10469,14 +10493,15 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  *cost = COSTS_N_INSNS (1);\n \t\t  if (shift_reg != NULL)\n \t\t    {\n-\t\t      *cost += rtx_cost (shift_reg, ASHIFT, 1, speed_p);\n+\t\t      *cost += rtx_cost (shift_reg, op0mode, ASHIFT,\n+\t\t\t\t\t 1, speed_p);\n \t\t      if (speed_p)\n \t\t\t*cost += extra_cost->alu.arith_shift_reg;\n \t\t    }\n \t\t  else if (speed_p)\n \t\t    *cost += extra_cost->alu.arith_shift;\n-\t\t  *cost += (rtx_cost (shift_op, ASHIFT, 0, speed_p)\n-\t\t\t    + rtx_cost (XEXP (x, 1), COMPARE, 1, speed_p));\n+\t\t  *cost += rtx_cost (shift_op, op0mode, ASHIFT, 0, speed_p);\n+\t\t  *cost += rtx_cost (XEXP (x, 1), op0mode, COMPARE, 1, speed_p);\n \t\t  return true;\n \t\t}\n \n@@ -10486,7 +10511,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (CONST_INT_P (XEXP (x, 1))\n \t\t  && const_ok_for_op (INTVAL (XEXP (x, 1)), COMPARE))\n \t\t{\n-\t\t  *cost += rtx_cost (XEXP (x, 0), COMPARE, 0, speed_p);\n+\t\t  *cost += rtx_cost (XEXP (x, 0), op0mode, COMPARE, 0, speed_p);\n \t\t  return true;\n \t\t}\n \t      return false;\n@@ -10579,7 +10604,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t\t  *cost = COSTS_N_INSNS (3);\n \t\t  break;\n \t\t}\n-\t      *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t      *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t      return true;\n \t    }\n \t  else\n@@ -10588,7 +10613,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (CONST_INT_P (XEXP (x, 1))\n \t\t  && const_ok_for_op (INTVAL (XEXP (x, 1)), COMPARE))\n \t\t{\n-\t\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t\t  return true;\n \t\t}\n \n@@ -10639,7 +10664,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       if ((arm_arch4 || GET_MODE (XEXP (x, 0)) == SImode)\n \t  && MEM_P (XEXP (x, 0)))\n \t{\n-\t  *cost = rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost = rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \n \t  if (mode == DImode)\n \t    *cost += COSTS_N_INSNS (1);\n@@ -10663,15 +10688,15 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  /* We have SXTB/SXTH.  */\n \t  *cost = COSTS_N_INSNS (1);\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.extend;\n \t}\n       else if (GET_MODE (XEXP (x, 0)) != SImode)\n \t{\n \t  /* Needs two shifts.  */\n \t  *cost = COSTS_N_INSNS (2);\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.shift;\n \t}\n@@ -10692,7 +10717,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t   || GET_MODE (XEXP (x, 0)) == QImode)\n \t  && MEM_P (XEXP (x, 0)))\n \t{\n-\t  *cost = rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost = rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \n \t  if (mode == DImode)\n \t    *cost += COSTS_N_INSNS (1);  /* No speed penalty.  */\n@@ -10716,7 +10741,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t{\n \t  /* We have UXTB/UXTH.  */\n \t  *cost = COSTS_N_INSNS (1);\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.extend;\n \t}\n@@ -10727,7 +10752,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t     shift may merge with a subsequent insn as a shifter\n \t     op.  */\n \t  *cost = COSTS_N_INSNS (2);\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  if (speed_p)\n \t    *cost += 2 * extra_cost->alu.shift;\n \t}\n@@ -10871,7 +10896,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.log_shift;\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -10895,10 +10920,10 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->mult[1].extend;\n-\t  *cost += (rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0), ZERO_EXTEND, 0,\n-\t\t\t      speed_p)\n-\t\t    + rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 1), ZERO_EXTEND,\n-\t\t\t\t0, speed_p));\n+\t  *cost += (rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0), VOIDmode,\n+\t\t\t      ZERO_EXTEND, 0, speed_p)\n+\t\t    + rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 1), VOIDmode,\n+\t\t\t\tZERO_EXTEND, 0, speed_p));\n \t  return true;\n \t}\n       *cost = LIBCALL_COST (1);\n@@ -10926,14 +10951,14 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->alu.bfx;\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t  return true;\n \t}\n       /* Without UBFX/SBFX, need to resort to shift operations.  */\n       *cost = COSTS_N_INSNS (2);\n       if (speed_p)\n \t*cost += 2 * extra_cost->alu.shift;\n-      *cost += rtx_cost (XEXP (x, 0), ASHIFT, 0, speed_p);\n+      *cost += rtx_cost (XEXP (x, 0), mode, ASHIFT, 0, speed_p);\n       return true;\n \n     case FLOAT_EXTEND:\n@@ -10951,7 +10976,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t      if (speed_p)\n \t\t*cost += extra_cost->fp[0].widen;\n \t    }\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  return true;\n \t}\n \n@@ -10964,7 +10989,7 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  *cost = COSTS_N_INSNS (1);\n \t  if (speed_p)\n \t    *cost += extra_cost->fp[mode == DFmode].narrow;\n-\t  *cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t  *cost += rtx_cost (XEXP (x, 0), VOIDmode, code, 0, speed_p);\n \t  return true;\n \t  /* Vector modes?  */\n \t}\n@@ -10988,9 +11013,9 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n           if (GET_CODE (op2) == NEG)\n             op2 = XEXP (op2, 0);\n \n-          *cost += rtx_cost (op0, FMA, 0, speed_p);\n-          *cost += rtx_cost (op1, FMA, 1, speed_p);\n-          *cost += rtx_cost (op2, FMA, 2, speed_p);\n+          *cost += rtx_cost (op0, mode, FMA, 0, speed_p);\n+          *cost += rtx_cost (op1, mode, FMA, 1, speed_p);\n+          *cost += rtx_cost (op2, mode, FMA, 2, speed_p);\n \n           if (speed_p)\n             *cost += extra_cost->fp[mode ==DFmode].fma;\n@@ -11008,13 +11033,15 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  if (GET_MODE_CLASS (mode) == MODE_INT)\n \t    {\n \t      *cost = COSTS_N_INSNS (1);\n+\t      mode = GET_MODE (XEXP (x, 0));\n \t      if (speed_p)\n-\t\t*cost += extra_cost->fp[GET_MODE (XEXP (x, 0)) == DFmode].toint;\n+\t\t*cost += extra_cost->fp[mode == DFmode].toint;\n \t      /* Strip of the 'cost' of rounding towards zero.  */\n \t      if (GET_CODE (XEXP (x, 0)) == FIX)\n-\t\t*cost += rtx_cost (XEXP (XEXP (x, 0), 0), code, 0, speed_p);\n+\t\t*cost += rtx_cost (XEXP (XEXP (x, 0), 0), mode, code,\n+\t\t\t\t   0, speed_p);\n \t      else\n-\t\t*cost += rtx_cost (XEXP (x, 0), code, 0, speed_p);\n+\t\t*cost += rtx_cost (XEXP (x, 0), mode, code, 0, speed_p);\n \t      /* ??? Increase the cost to deal with transferring from\n \t\t FP -> CORE registers?  */\n \t      return true;\n@@ -11074,10 +11101,11 @@ arm_new_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n /* RTX costs when optimizing for size.  */\n static bool\n-arm_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t       int *total, bool speed)\n+arm_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n+\t       int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n   bool result;\n+  int code = GET_CODE (x);\n \n   if (TARGET_OLD_RTX_COSTS\n       || (!current_tune->insn_extra_cost && !TARGET_NEW_GENERIC_COSTS))\n@@ -11158,7 +11186,7 @@ arm_slowmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t    }\n \n \t  *total = COSTS_N_INSNS (cost);\n-\t  *total += rtx_cost (XEXP (x, 0), code, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n \t  return true;\n \t}\n "}, {"sha": "a4564612586f803f9c8efc02ccdf485c0b3302f4", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -169,7 +169,7 @@ static struct machine_function * avr_init_machine_status (void);\n \n /* Prototypes for hook implementors if needed before their implementation.  */\n \n-static bool avr_rtx_costs (rtx, int, int, int, int*, bool);\n+static bool avr_rtx_costs (rtx, machine_mode, int, int, int*, bool);\n \n \n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n@@ -2697,10 +2697,11 @@ avr_final_prescan_insn (rtx_insn *insn, rtx *operand ATTRIBUTE_UNUSED,\n \n       if (set)\n         fprintf (asm_out_file, \"/* DEBUG: cost = %d.  */\\n\",\n-                 set_src_cost (SET_SRC (set), optimize_insn_for_speed_p ()));\n+                 set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)),\n+\t\t\t       optimize_insn_for_speed_p ()));\n       else\n         fprintf (asm_out_file, \"/* DEBUG: pattern-cost = %d.  */\\n\",\n-                 rtx_cost (PATTERN (insn), INSN, 0,\n+                 rtx_cost (PATTERN (insn), VOIDmode, INSN, 0,\n                            optimize_insn_for_speed_p()));\n     }\n }\n@@ -9910,7 +9911,7 @@ avr_operand_rtx_cost (rtx x, machine_mode mode, enum rtx_code outer,\n     }\n \n   total = 0;\n-  avr_rtx_costs (x, code, outer, opno, &total, speed);\n+  avr_rtx_costs (x, mode, outer, opno, &total, speed);\n   return total;\n }\n \n@@ -9921,11 +9922,10 @@ avr_operand_rtx_cost (rtx x, machine_mode mode, enum rtx_code outer,\n    In either case, *TOTAL contains the cost result.  */\n \n static bool\n-avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n+avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n                  int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n-  enum rtx_code code = (enum rtx_code) codearg;\n-  machine_mode mode = GET_MODE (x);\n+  enum rtx_code code = GET_CODE (x);\n   HOST_WIDE_INT val;\n \n   switch (code)\n@@ -9986,13 +9986,15 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n     case ZERO_EXTEND:\n       *total = COSTS_N_INSNS (GET_MODE_SIZE (mode)\n \t\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (x, 0))));\n-      *total += avr_operand_rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+      *total += avr_operand_rtx_cost (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n+\t\t\t\t      code, 0, speed);\n       return true;\n \n     case SIGN_EXTEND:\n       *total = COSTS_N_INSNS (GET_MODE_SIZE (mode) + 2\n \t\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (x, 0))));\n-      *total += avr_operand_rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+      *total += avr_operand_rtx_cost (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n+\t\t\t\t      code, 0, speed);\n       return true;\n \n     case PLUS:\n@@ -10698,13 +10700,15 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \tcase QImode:\n \t  *total = COSTS_N_INSNS (1);\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-\t    *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+\t    *total += avr_operand_rtx_cost (XEXP (x, 1), QImode, code,\n+\t\t\t\t\t    1, speed);\n \t  break;\n \n         case HImode:\n \t  *total = COSTS_N_INSNS (2);\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-            *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+            *total += avr_operand_rtx_cost (XEXP (x, 1), HImode, code,\n+\t\t\t\t\t    1, speed);\n \t  else if (INTVAL (XEXP (x, 1)) != 0)\n \t    *total += COSTS_N_INSNS (1);\n           break;\n@@ -10718,15 +10722,17 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n         case SImode:\n           *total = COSTS_N_INSNS (4);\n           if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-            *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+            *total += avr_operand_rtx_cost (XEXP (x, 1), SImode, code,\n+\t\t\t\t\t    1, speed);\n \t  else if (INTVAL (XEXP (x, 1)) != 0)\n \t    *total += COSTS_N_INSNS (3);\n           break;\n \n \tdefault:\n \t  return false;\n \t}\n-      *total += avr_operand_rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+      *total += avr_operand_rtx_cost (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n+\t\t\t\t      code, 0, speed);\n       return true;\n \n     case TRUNCATE:\n@@ -10753,10 +10759,10 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n /* Implement `TARGET_RTX_COSTS'.  */\n \n static bool\n-avr_rtx_costs (rtx x, int codearg, int outer_code,\n+avr_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t       int opno, int *total, bool speed)\n {\n-  bool done = avr_rtx_costs_1 (x, codearg, outer_code,\n+  bool done = avr_rtx_costs_1 (x, mode, outer_code,\n                                opno, total, speed);\n \n   if (avr_log.rtx_costs)"}, {"sha": "ea3e6679cb309ce0756c2bd9f243cd5109d5c2b2", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2797,10 +2797,10 @@ bfin_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n }\n \n static bool\n-bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n-\t\tbool speed)\n+bfin_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n+\t\tint *total, bool speed)\n {\n-  enum rtx_code code = (enum rtx_code) code_i;\n+  enum rtx_code code = GET_CODE (x);\n   enum rtx_code outer_code = (enum rtx_code) outer_code_i;\n   int cost2 = COSTS_N_INSNS (1);\n   rtx op0, op1;\n@@ -2839,7 +2839,7 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n     case PLUS:\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n-      if (GET_MODE (x) == SImode)\n+      if (mode == SImode)\n \t{\n \t  if (GET_CODE (op0) == MULT\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n@@ -2848,35 +2848,36 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t      if (val == 2 || val == 4)\n \t\t{\n \t\t  *total = cost2;\n-\t\t  *total += rtx_cost (XEXP (op0, 0), outer_code, opno, speed);\n-\t\t  *total += rtx_cost (op1, outer_code, opno, speed);\n+\t\t  *total += rtx_cost (XEXP (op0, 0), mode, outer_code,\n+\t\t\t\t      opno, speed);\n+\t\t  *total += rtx_cost (op1, mode, outer_code, opno, speed);\n \t\t  return true;\n \t\t}\n \t    }\n \t  *total = cost2;\n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += set_src_cost (op0, speed);\n+\t    *total += set_src_cost (op0, mode, speed);\n #if 0 /* We'd like to do this for accuracy, but it biases the loop optimizer\n \t towards creating too many induction variables.  */\n \t  if (!reg_or_7bit_operand (op1, SImode))\n-\t    *total += set_src_cost (op1, speed);\n+\t    *total += set_src_cost (op1, mode, speed);\n #endif\n \t}\n-      else if (GET_MODE (x) == DImode)\n+      else if (mode == DImode)\n \t{\n \t  *total = 6 * cost2;\n \t  if (GET_CODE (op1) != CONST_INT\n \t      || !satisfies_constraint_Ks7 (op1))\n-\t    *total += rtx_cost (op1, PLUS, 1, speed);\n+\t    *total += rtx_cost (op1, mode, PLUS, 1, speed);\n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += rtx_cost (op0, PLUS, 0, speed);\n+\t    *total += rtx_cost (op0, mode, PLUS, 0, speed);\n \t}\n       return true;\n \n     case MINUS:\n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t*total = 6 * cost2;\n       else\n \t*total = cost2;\n@@ -2885,7 +2886,7 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n     case ASHIFT: \n     case ASHIFTRT:\n     case LSHIFTRT:\n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t*total = 6 * cost2;\n       else\n \t*total = cost2;\n@@ -2894,7 +2895,7 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n       op1 = XEXP (x, 1);\n       if (GET_CODE (op0) != REG\n \t  && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t*total += rtx_cost (op0, code, 0, speed);\n+\t*total += rtx_cost (op0, mode, code, 0, speed);\n \n       return true;\n \t  \n@@ -2919,26 +2920,26 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \n       if (GET_CODE (op0) != REG\n \t  && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t*total += rtx_cost (op0, code, 0, speed);\n+\t*total += rtx_cost (op0, mode, code, 0, speed);\n \n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t{\n \t  *total = 2 * cost2;\n \t  return true;\n \t}\n       *total = cost2;\n-      if (GET_MODE (x) != SImode)\n+      if (mode != SImode)\n \treturn true;\n \n       if (code == AND)\n \t{\n \t  if (! rhs_andsi3_operand (XEXP (x, 1), SImode))\n-\t    *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t    *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t}\n       else\n \t{\n \t  if (! regorlog2_operand (XEXP (x, 1), SImode))\n-\t    *total += rtx_cost (XEXP (x, 1), code, 1, speed);\n+\t    *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t}\n \n       return true;\n@@ -2978,10 +2979,10 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += rtx_cost (op0, MULT, 0, speed);\n+\t    *total += rtx_cost (op0, mode, MULT, 0, speed);\n \t  if (GET_CODE (op1) != REG\n \t      && (GET_CODE (op1) != SUBREG || GET_CODE (SUBREG_REG (op1)) != REG))\n-\t    *total += rtx_cost (op1, MULT, 1, speed);\n+\t    *total += rtx_cost (op1, mode, MULT, 1, speed);\n \t}\n       return true;\n "}, {"sha": "936161c3d166efa8ad2a66b745669c01e28b8d4b", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -6045,11 +6045,12 @@ shift_p (rtx x, enum rtx_code code, int amount)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n+c6x_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno, int *total,\n \t       bool speed)\n {\n   int cost2 = COSTS_N_INSNS (1);\n   rtx op0, op1;\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -6078,12 +6079,12 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \n     case TRUNCATE:\n       /* Recognize a mult_highpart operation.  */\n-      if ((GET_MODE (x) == HImode || GET_MODE (x) == SImode)\n+      if ((mode == HImode || mode == SImode)\n \t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && GET_MODE (XEXP (x, 0)) == GET_MODE_2XWIDER_MODE (GET_MODE (x))\n+\t  && GET_MODE (XEXP (x, 0)) == GET_MODE_2XWIDER_MODE (mode)\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (GET_MODE (x)))\n+\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode))\n \t{\n \t  rtx mul = XEXP (XEXP (x, 0), 0);\n \t  rtx op0 = XEXP (mul, 0);\n@@ -6093,15 +6094,16 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \n \t  if ((code0 == code1\n \t       && (code0 == SIGN_EXTEND || code0 == ZERO_EXTEND))\n-\t      || (GET_MODE (x) == HImode\n+\t      || (mode == HImode\n \t\t  && code0 == ZERO_EXTEND && code1 == SIGN_EXTEND))\n \t    {\n-\t      if (GET_MODE (x) == HImode)\n+\t      if (mode == HImode)\n \t\t*total = COSTS_N_INSNS (2);\n \t      else\n \t\t*total = COSTS_N_INSNS (12);\n-\t      *total += rtx_cost (XEXP (op0, 0), code0, 0, speed);\n-\t      *total += rtx_cost (XEXP (op1, 0), code1, 0, speed);\n+\t      mode = GET_MODE (XEXP (op0, 0));\n+\t      *total += rtx_cost (XEXP (op0, 0), mode, code0, 0, speed);\n+\t      *total += rtx_cost (XEXP (op1, 0), mode, code1, 0, speed);\n \t      return true;\n \t    }\n \t}\n@@ -6110,7 +6112,7 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t*total = COSTS_N_INSNS (CONSTANT_P (XEXP (x, 1)) ? 4 : 15);\n       else\n \t*total = COSTS_N_INSNS (1);\n@@ -6121,38 +6123,38 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n       *total = COSTS_N_INSNS (1);\n       op0 = code == PLUS ? XEXP (x, 0) : XEXP (x, 1);\n       op1 = code == PLUS ? XEXP (x, 1) : XEXP (x, 0);\n-      if (GET_MODE_SIZE (GET_MODE (x)) <= UNITS_PER_WORD\n-\t  && INTEGRAL_MODE_P (GET_MODE (x))\n+      if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t  && INTEGRAL_MODE_P (mode)\n \t  && GET_CODE (op0) == MULT\n \t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t  && (INTVAL (XEXP (op0, 1)) == 2\n \t      || INTVAL (XEXP (op0, 1)) == 4\n \t      || (code == PLUS && INTVAL (XEXP (op0, 1)) == 8)))\n \t{\n-\t  *total += rtx_cost (XEXP (op0, 0), ASHIFT, 0, speed);\n-\t  *total += rtx_cost (op1, (enum rtx_code) code, 1, speed);\n+\t  *total += rtx_cost (XEXP (op0, 0), mode, ASHIFT, 0, speed);\n+\t  *total += rtx_cost (op1, mode, (enum rtx_code) code, 1, speed);\n \t  return true;\n \t}\n       return false;\n \n     case MULT:\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n-      if (GET_MODE (x) == DFmode)\n+      if (mode == DFmode)\n \t{\n \t  if (TARGET_FP)\n \t    *total = COSTS_N_INSNS (speed ? 10 : 1);\n \t  else\n \t    *total = COSTS_N_INSNS (speed ? 200 : 4);\n \t}\n-      else if (GET_MODE (x) == SFmode)\n+      else if (mode == SFmode)\n \t{\n \t  if (TARGET_FP)\n \t    *total = COSTS_N_INSNS (speed ? 4 : 1);\n \t  else\n \t    *total = COSTS_N_INSNS (speed ? 100 : 4);\n \t}\n-      else if (GET_MODE (x) == DImode)\n+      else if (mode == DImode)\n \t{\n \t  if (TARGET_MPY32\n \t      && GET_CODE (op0) == GET_CODE (op1)\n@@ -6167,7 +6169,7 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \t    /* Maybe improve this laster.  */\n \t    *total = COSTS_N_INSNS (20);\n \t}\n-      else if (GET_MODE (x) == SImode)\n+      else if (mode == SImode)\n \t{\n \t  if (((GET_CODE (op0) == ZERO_EXTEND\n \t\t|| GET_CODE (op0) == SIGN_EXTEND\n@@ -6195,15 +6197,15 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \t  else\n \t    *total = COSTS_N_INSNS (6);\n \t}\n-      else if (GET_MODE (x) == HImode)\n+      else if (mode == HImode)\n \t*total = COSTS_N_INSNS (speed ? 2 : 1);\n \n       if (GET_CODE (op0) != REG\n \t  && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t*total += rtx_cost (op0, MULT, 0, speed);\n+\t*total += rtx_cost (op0, mode, MULT, 0, speed);\n       if (op1 && GET_CODE (op1) != REG\n \t  && (GET_CODE (op1) != SUBREG || GET_CODE (SUBREG_REG (op1)) != REG))\n-\t*total += rtx_cost (op1, MULT, 1, speed);\n+\t*total += rtx_cost (op1, mode, MULT, 1, speed);\n       return true;\n \n     case UDIV:\n@@ -6221,7 +6223,7 @@ c6x_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \t  && XEXP (op0, 1) == const0_rtx\n \t  && rtx_equal_p (XEXP (x, 1), XEXP (op0, 0)))\n \t{\n-\t  *total = rtx_cost (XEXP (x, 1), (enum rtx_code) outer_code,\n+\t  *total = rtx_cost (XEXP (x, 1), VOIDmode, (enum rtx_code) outer_code,\n \t\t\t     opno, speed);\n \t  return false;\n \t}"}, {"sha": "b7fa1e627ca1ec6df4198cc895003023f0ca151b", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -146,7 +146,7 @@ static reg_class_t cris_preferred_reload_class (rtx, reg_class_t);\n \n static int cris_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n static int cris_memory_move_cost (machine_mode, reg_class_t, bool);\n-static bool cris_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool cris_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int cris_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool cris_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n@@ -2097,9 +2097,11 @@ cris_expand_return (bool on_stack)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-cris_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n-\t\tbool speed)\n+cris_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno,\n+\t\tint *total, bool speed)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -2129,7 +2131,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n       return true;\n \n     case CONST_DOUBLE:\n-      if (x != CONST0_RTX (GET_MODE (x) == VOIDmode ? DImode : GET_MODE (x)))\n+      if (x != CONST0_RTX (mode == VOIDmode ? DImode : mode))\n \t*total = 12;\n       else\n         /* Make 0.0 cheap, else test-insns will not be used.  */\n@@ -2191,9 +2193,9 @@ cris_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \t  && !satisfies_constraint_I (XEXP (x, 1)))\n \t{\n \t  *total\n-\t    = (rtx_cost (XEXP (x, 0), (enum rtx_code) outer_code,\n+\t    = (rtx_cost (XEXP (x, 0), mode, (enum rtx_code) outer_code,\n \t\t\t opno, speed) + 2\n-\t       + 2 * GET_MODE_NUNITS (GET_MODE (XEXP (x, 0))));\n+\t       + 2 * GET_MODE_NUNITS (mode));\n \t  return true;\n \t}\n       return false;\n@@ -2204,7 +2206,8 @@ cris_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n       /* fall through */\n \n     case ZERO_EXTEND: case SIGN_EXTEND:\n-      *total = rtx_cost (XEXP (x, 0), (enum rtx_code) outer_code, opno, speed);\n+      *total = rtx_cost (XEXP (x, 0), VOIDmode, (enum rtx_code) outer_code,\n+\t\t\t opno, speed);\n       return true;\n \n     default:"}, {"sha": "692fc7476faf10815f5e7df080b5c43e44f63764", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -765,9 +765,12 @@ epiphany_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-epiphany_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+epiphany_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t    int opno ATTRIBUTE_UNUSED,\n \t\t    int *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n       /* Small integers in the right context are as cheap as registers.  */\n@@ -808,7 +811,7 @@ epiphany_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case COMPARE:\n-      switch (GET_MODE (x))\n+      switch (mode)\n \t{\n \t/* There are a number of single-insn combiner patterns that use\n \t   the flag side effects of arithmetic.  */"}, {"sha": "9be5d3f619c83dc06e5d57219390c07342fd3b6e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -378,8 +378,8 @@ static void frv_setup_incoming_varargs\t\t(cumulative_args_t,\n \t\t\t\t\t\t tree, int *, int);\n static rtx frv_expand_builtin_saveregs\t\t(void);\n static void frv_expand_builtin_va_start\t\t(tree, rtx);\n-static bool frv_rtx_costs\t\t\t(rtx, int, int, int, int*,\n-\t\t\t\t\t\t bool);\n+static bool frv_rtx_costs\t\t\t(rtx, machine_mode, int, int,\n+\t\t\t\t\t\t int*, bool);\n static int frv_register_move_cost\t\t(machine_mode,\n \t\t\t\t\t\t reg_class_t, reg_class_t);\n static int frv_memory_move_cost\t\t\t(machine_mode,\n@@ -9450,12 +9450,14 @@ frv_in_small_data_p (const_tree decl)\n \f\n static bool\n frv_rtx_costs (rtx x,\n-               int code ATTRIBUTE_UNUSED,\n-               int outer_code ATTRIBUTE_UNUSED,\n+               machine_mode mode,\n+               int outer_code,\n \t       int opno ATTRIBUTE_UNUSED,\n                int *total,\n \t       bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   if (outer_code == MEM)\n     {\n       /* Don't differentiate between memory addresses.  All the ones\n@@ -9493,16 +9495,16 @@ frv_rtx_costs (rtx x,\n     case NOT:\n     case NEG:\n     case COMPARE:\n-      if (GET_MODE (x) == SImode)\n+      if (mode == SImode)\n \t*total = COSTS_N_INSNS (1);\n-      else if (GET_MODE (x) == DImode)\n+      else if (mode == DImode)\n         *total = COSTS_N_INSNS (2);\n       else\n         *total = COSTS_N_INSNS (3);\n       return true;\n \n     case MULT:\n-      if (GET_MODE (x) == SImode)\n+      if (mode == SImode)\n         *total = COSTS_N_INSNS (2);\n       else\n         *total = COSTS_N_INSNS (6);\t/* guess */"}, {"sha": "0abb92c26818d4cac0cc5d28bd410aed2ec3ef9a", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1240,9 +1240,11 @@ h8300_shift_costs (rtx x)\n /* Worker function for TARGET_RTX_COSTS.  */\n \n static bool\n-h8300_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t\t int *total, bool speed)\n+h8300_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n+\t\t int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n+  int code = GET_CODE (x);\n+\n   if (TARGET_H8300SX && outer_code == MEM)\n     {\n       /* Estimate the number of execution states needed to calculate"}, {"sha": "112eb1c6ef710d357212b8b780d07cc457df1668", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -42241,13 +42241,12 @@ ix86_set_reg_reg_cost (machine_mode mode)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n-\t\tbool speed)\n+ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n+\t\tint *total, bool speed)\n {\n   rtx mask;\n-  enum rtx_code code = (enum rtx_code) code_i;\n+  enum rtx_code code = GET_CODE (x);\n   enum rtx_code outer_code = (enum rtx_code) outer_code_i;\n-  machine_mode mode = GET_MODE (x);\n   const struct processor_costs *cost = speed ? ix86_cost : &ix86_size_cost;\n \n   switch (code)\n@@ -42378,7 +42377,7 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t\t  if (CONSTANT_P (XEXP (x, 1)))\n \t\t    {\n \t\t      *total = (cost->fabs\n-\t\t\t\t+ rtx_cost (XEXP (x, 0), code, 0, speed)\n+\t\t\t\t+ rtx_cost (XEXP (x, 0), mode, code, 0, speed)\n \t\t\t\t+ (speed ? 2 : COSTS_N_BYTES (16)));\n \t\t      return true;\n \t\t    }\n@@ -42434,18 +42433,18 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n         /* ??? SSE scalar/vector cost should be used here.  */\n         /* ??? Bald assumption that fma has the same cost as fmul.  */\n         *total = cost->fmul;\n-\t*total += rtx_cost (XEXP (x, 1), FMA, 1, speed);\n+\t*total += rtx_cost (XEXP (x, 1), mode, FMA, 1, speed);\n \n         /* Negate in op0 or op2 is free: FMS, FNMA, FNMS.  */\n \tsub = XEXP (x, 0);\n \tif (GET_CODE (sub) == NEG)\n \t  sub = XEXP (sub, 0);\n-\t*total += rtx_cost (sub, FMA, 0, speed);\n+\t*total += rtx_cost (sub, mode, FMA, 0, speed);\n \n \tsub = XEXP (x, 2);\n \tif (GET_CODE (sub) == NEG)\n \t  sub = XEXP (sub, 0);\n-\t*total += rtx_cost (sub, FMA, 2, speed);\n+\t*total += rtx_cost (sub, mode, FMA, 2, speed);\n \treturn true;\n       }\n \n@@ -42535,8 +42534,8 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \n   \t  *total = (cost->mult_init[MODE_INDEX (mode)]\n \t\t    + nbits * cost->mult_bit\n-\t            + rtx_cost (op0, outer_code, opno, speed)\n-\t\t    + rtx_cost (op1, outer_code, opno, speed));\n+\t            + rtx_cost (op0, mode, outer_code, opno, speed)\n+\t\t    + rtx_cost (op1, mode, outer_code, opno, speed));\n \n           return true;\n \t}\n@@ -42570,11 +42569,12 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t      if (val == 2 || val == 4 || val == 8)\n \t\t{\n \t\t  *total = cost->lea;\n-\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 1),\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 1), mode,\n+\t\t\t\t      outer_code, opno, speed);\n+\t\t  *total += rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0), mode,\n \t\t\t\t      outer_code, opno, speed);\n-\t\t  *total += rtx_cost (XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t  *total += rtx_cost (XEXP (x, 1), mode,\n \t\t\t\t      outer_code, opno, speed);\n-\t\t  *total += rtx_cost (XEXP (x, 1), outer_code, opno, speed);\n \t\t  return true;\n \t\t}\n \t    }\n@@ -42585,20 +42585,22 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t      if (val == 2 || val == 4 || val == 8)\n \t\t{\n \t\t  *total = cost->lea;\n-\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0),\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n+\t\t\t\t      outer_code, opno, speed);\n+\t\t  *total += rtx_cost (XEXP (x, 1), mode,\n \t\t\t\t      outer_code, opno, speed);\n-\t\t  *total += rtx_cost (XEXP (x, 1), outer_code, opno, speed);\n \t\t  return true;\n \t\t}\n \t    }\n \t  else if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t    {\n \t      *total = cost->lea;\n-\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0),\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n+\t\t\t\t  outer_code, opno, speed);\n+\t      *total += rtx_cost (XEXP (XEXP (x, 0), 1), mode,\n \t\t\t\t  outer_code, opno, speed);\n-\t      *total += rtx_cost (XEXP (XEXP (x, 0), 1),\n+\t      *total += rtx_cost (XEXP (x, 1), mode,\n \t\t\t\t  outer_code, opno, speed);\n-\t      *total += rtx_cost (XEXP (x, 1), outer_code, opno, speed);\n \t      return true;\n \t    }\n \t}\n@@ -42631,9 +42633,9 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t{\n \t  *total = (cost->add * 2\n-\t\t    + (rtx_cost (XEXP (x, 0), outer_code, opno, speed)\n+\t\t    + (rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)\n \t\t       << (GET_MODE (XEXP (x, 0)) != DImode))\n-\t\t    + (rtx_cost (XEXP (x, 1), outer_code, opno, speed)\n+\t\t    + (rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed)\n \t               << (GET_MODE (XEXP (x, 1)) != DImode)));\n \t  return true;\n \t}\n@@ -42681,9 +42683,11 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n \t{\n \t  /* This kind of construct is implemented using test[bwl].\n \t     Treat it as if we had an AND.  */\n+\t  mode = GET_MODE (XEXP (XEXP (x, 0), 0));\n \t  *total = (cost->add\n-\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), outer_code, opno, speed)\n-\t\t    + rtx_cost (const1_rtx, outer_code, opno, speed));\n+\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), mode, outer_code,\n+\t\t\t\topno, speed)\n+\t\t    + rtx_cost (const1_rtx, mode, outer_code, opno, speed));\n \t  return true;\n \t}\n \n@@ -42739,7 +42743,7 @@ ix86_rtx_costs (rtx x, int code_i, int outer_code_i, int opno, int *total,\n       /* This is masked instruction, assume the same cost,\n \t as nonmasked variant.  */\n       if (TARGET_AVX512F && register_operand (mask, GET_MODE (mask)))\n-\t*total = rtx_cost (XEXP (x, 0), outer_code, opno, speed);\n+\t*total = rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed);\n       else\n \t*total = cost->fabs;\n       return true;"}, {"sha": "fef6839e0d29f9f9bd288c71f5fb3c40ec29bc7f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -233,7 +233,7 @@ static int ia64_register_move_cost (machine_mode, reg_class_t,\n                                     reg_class_t);\n static int ia64_memory_move_cost (machine_mode mode, reg_class_t,\n \t\t\t\t  bool);\n-static bool ia64_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool ia64_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int ia64_unspec_may_trap_p (const_rtx, unsigned);\n static void fix_range (const char *);\n static struct machine_function * ia64_init_machine_status (void);\n@@ -5590,9 +5590,12 @@ ia64_print_operand_punct_valid_p (unsigned char code)\n /* ??? This is incomplete.  */\n \n static bool\n-ia64_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+ia64_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -5636,17 +5639,17 @@ ia64_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n          which normally involves copies.  Plus there's the latency\n          of the multiply itself, and the latency of the instructions to\n          transfer integer regs to FP regs.  */\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n+      if (FLOAT_MODE_P (mode))\n \t*total = COSTS_N_INSNS (4);\n-      else if (GET_MODE_SIZE (GET_MODE (x)) > 2)\n+      else if (GET_MODE_SIZE (mode) > 2)\n         *total = COSTS_N_INSNS (10);\n       else\n \t*total = COSTS_N_INSNS (2);\n       return true;\n \n     case PLUS:\n     case MINUS:\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n+      if (FLOAT_MODE_P (mode))\n \t{\n \t  *total = COSTS_N_INSNS (4);\n \t  return true;"}, {"sha": "79087becd6b09f750b6d67df629b4fa8e1c10d2c", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -166,7 +166,7 @@ static bool iq2000_return_in_memory   (const_tree, const_tree);\n static void iq2000_setup_incoming_varargs (cumulative_args_t,\n \t\t\t\t\t   machine_mode, tree, int *,\n \t\t\t\t\t   int);\n-static bool iq2000_rtx_costs          (rtx, int, int, int, int *, bool);\n+static bool iq2000_rtx_costs          (rtx, machine_mode, int, int, int *, bool);\n static int  iq2000_address_cost       (rtx, machine_mode, addr_space_t,\n \t\t\t\t       bool);\n static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n@@ -3306,11 +3306,11 @@ iq2000_legitimize_address (rtx xinsn, rtx old_x ATTRIBUTE_UNUSED,\n \n \n static bool\n-iq2000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+iq2000_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t\t  int opno ATTRIBUTE_UNUSED, int * total,\n \t\t  bool speed ATTRIBUTE_UNUSED)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {"}, {"sha": "2402583f4857df37c9b7960cdcaaa81fdf694ca0", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -81,7 +81,7 @@ static bool lm32_in_small_data_p (const_tree);\n static void lm32_setup_incoming_varargs (cumulative_args_t cum,\n \t\t\t\t\t machine_mode mode, tree type,\n \t\t\t\t\t int *pretend_size, int no_rtl);\n-static bool lm32_rtx_costs (rtx x, int code, int outer_code, int opno,\n+static bool lm32_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno,\n \t\t\t    int *total, bool speed);\n static bool lm32_can_eliminate (const int, const int);\n static bool\n@@ -934,10 +934,10 @@ nonpic_symbol_mentioned_p (rtx x)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-lm32_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t\tint *total, bool speed)\n+lm32_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n   bool small_mode;\n \n   const int arithmetic_latency = 1;"}, {"sha": "40da261e44899d9d3db642892bebb8e855743700", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2222,9 +2222,11 @@ m32c_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m32c_rtx_costs\n static bool\n-m32c_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+m32c_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n   switch (code)\n     {\n     case REG:\n@@ -2292,7 +2294,7 @@ m32c_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \n     default:\n       /* Reasonable default.  */\n-      if (TARGET_A16 && GET_MODE(x) == SImode)\n+      if (TARGET_A16 && mode == SImode)\n \t*total += COSTS_N_INSNS (2);\n       break;\n     }"}, {"sha": "72cdfd8a5d570d6c81ca9b22b7e9a92f60837ae5", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -98,7 +98,7 @@ static bool m32r_function_value_regno_p (const unsigned int);\n static void m32r_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree, int *, int);\n static void init_idents (void);\n-static bool m32r_rtx_costs (rtx, int, int, int, int *, bool speed);\n+static bool m32r_rtx_costs (rtx, machine_mode, int, int, int *, bool speed);\n static int m32r_memory_move_cost (machine_mode, reg_class_t, bool);\n static bool m32r_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n@@ -1361,10 +1361,13 @@ m32r_memory_move_cost (machine_mode mode,\n }\n \n static bool\n-m32r_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+m32r_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n+\t\tint outer_code ATTRIBUTE_UNUSED,\n \t\tint opno ATTRIBUTE_UNUSED, int *total,\n \t\tbool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n       /* Small integers are as cheap as registers.  4 byte values can be"}, {"sha": "4bd20a5ff363baf759cf382b4c34c956bac43c90", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -165,7 +165,7 @@ static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static bool m68k_ok_for_sibcall_p (tree, tree);\n static bool m68k_tls_symbol_p (rtx);\n static rtx m68k_legitimize_address (rtx, rtx, machine_mode);\n-static bool m68k_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool m68k_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n #if M68K_HONOR_TARGET_STRICT_ALIGNMENT\n static bool m68k_return_in_memory (const_tree, const_tree);\n #endif\n@@ -2787,9 +2787,12 @@ const_int_cost (HOST_WIDE_INT i)\n }\n \n static bool\n-m68k_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+m68k_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -2846,7 +2849,7 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \n     case PLUS:\n       /* An lea costs about three times as much as a simple add.  */\n-      if (GET_MODE (x) == SImode\n+      if (mode == SImode\n \t  && GET_CODE (XEXP (x, 1)) == REG\n \t  && GET_CODE (XEXP (x, 0)) == MULT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n@@ -2902,9 +2905,9 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case MULT:\n       if ((GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n \t   || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n-\t  && GET_MODE (x) == SImode)\n+\t  && mode == SImode)\n         *total = COSTS_N_INSNS (MULW_COST);\n-      else if (GET_MODE (x) == QImode || GET_MODE (x) == HImode)\n+      else if (mode == QImode || mode == HImode)\n         *total = COSTS_N_INSNS (MULW_COST);\n       else\n         *total = COSTS_N_INSNS (MULL_COST);\n@@ -2914,7 +2917,7 @@ m68k_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case UDIV:\n     case MOD:\n     case UMOD:\n-      if (GET_MODE (x) == QImode || GET_MODE (x) == HImode)\n+      if (mode == QImode || mode == HImode)\n         *total = COSTS_N_INSNS (DIVW_COST);\t/* div.w */\n       else if (TARGET_CF_HWDIV)\n         *total = COSTS_N_INSNS (18);"}, {"sha": "1ba27d09714a1f6a8ffc392e5ae5b92b6629dd55", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -136,7 +136,7 @@ static const char *mcore_strip_name_encoding\t(const char *);\n static int        mcore_const_costs             (rtx, RTX_CODE);\n static int        mcore_and_cost                (rtx);\n static int        mcore_ior_cost                (rtx);\n-static bool       mcore_rtx_costs\t\t(rtx, int, int, int,\n+static bool       mcore_rtx_costs\t\t(rtx, machine_mode, int, int,\n \t\t\t\t\t\t int *, bool);\n static void       mcore_external_libcall\t(rtx);\n static bool       mcore_return_in_memory\t(const_tree, const_tree);\n@@ -528,9 +528,12 @@ mcore_ior_cost (rtx x)\n }\n \n static bool\n-mcore_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+mcore_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n+\t\t int opno ATTRIBUTE_UNUSED,\n \t\t int * total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:"}, {"sha": "2d343b302633d252a904fb47cd381c43b0242cba", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -231,7 +231,7 @@ static void mep_move_ready_insn (rtx_insn **, int, rtx_insn *);\n static int mep_sched_reorder (FILE *, int, rtx_insn **, int *, int);\n static rtx_insn *mep_make_bundle (rtx, rtx_insn *);\n static void mep_bundle_insns (rtx_insn *);\n-static bool mep_rtx_cost (rtx, int, int, int, int *, bool);\n+static bool mep_rtx_cost (rtx, machine_mode, int, int, int *, bool);\n static int mep_address_cost (rtx, machine_mode, addr_space_t, bool);\n static void mep_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\ttree, int *, int);\n@@ -7109,10 +7109,13 @@ mep_expand_binary_intrinsic (int ATTRIBUTE_UNUSED immediate,\n }\n \n static bool\n-mep_rtx_cost (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+mep_rtx_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n+\t      int outer_code ATTRIBUTE_UNUSED,\n \t      int opno ATTRIBUTE_UNUSED, int *total,\n \t      bool ATTRIBUTE_UNUSED speed_t)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:"}, {"sha": "da9005ee021ee4cbb5b556a927bb0fde4b9f9af2", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1231,11 +1231,11 @@ microblaze_expand_block_move (rtx dest, rtx src, rtx length, rtx align_rtx)\n }\n \n static bool\n-microblaze_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+microblaze_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t\t      int opno ATTRIBUTE_UNUSED, int *total,\n \t\t      bool speed ATTRIBUTE_UNUSED)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {"}, {"sha": "31756d702a975acdc142e6713d8cccd5f9194f17", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2415,7 +2415,7 @@ mips_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)\n   return mips_classify_address (&addr, x, mode, strict_p);\n }\n \n-/* Return true if X is a legitimate $sp-based address for mode MDOE.  */\n+/* Return true if X is a legitimate $sp-based address for mode MODE.  */\n \n bool\n mips_stack_address_p (rtx x, machine_mode mode)\n@@ -3708,8 +3708,8 @@ mips_binary_cost (rtx x, int single_cost, int double_cost, bool speed)\n   else\n     cost = single_cost;\n   return (cost\n-\t  + set_src_cost (XEXP (x, 0), speed)\n-\t  + rtx_cost (XEXP (x, 1), GET_CODE (x), 1, speed));\n+\t  + set_src_cost (XEXP (x, 0), GET_MODE (x), speed)\n+\t  + rtx_cost (XEXP (x, 1), GET_MODE (x), GET_CODE (x), 1, speed));\n }\n \n /* Return the cost of floating-point multiplications of mode MODE.  */\n@@ -3810,10 +3810,10 @@ mips_set_reg_reg_cost (machine_mode mode)\n /* Implement TARGET_RTX_COSTS.  */\n \n static bool\n-mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t\tint *total, bool speed)\n+mips_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n   int cost;\n   rtx addr;\n@@ -3912,7 +3912,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t     for a word or doubleword operation, so we cannot rely on\n \t     the result of mips_build_integer.  */\n \t  else if (!TARGET_MIPS16\n-\t\t   && (outer_code == SET || mode == VOIDmode))\n+\t\t   && (outer_code == SET || GET_MODE (x) == VOIDmode))\n \t    cost = 1;\n \t  *total = COSTS_N_INSNS (cost);\n \t  return true;\n@@ -3958,7 +3958,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  && UINTVAL (XEXP (x, 1)) == 0xffffffff)\n \t{\n \t  *total = (mips_zero_extend_cost (mode, XEXP (x, 0))\n-\t\t    + set_src_cost (XEXP (x, 0), speed));\n+\t\t    + set_src_cost (XEXP (x, 0), mode, speed));\n \t  return true;\n \t}\n       if (ISA_HAS_CINS && CONST_INT_P (XEXP (x, 1)))\n@@ -3968,7 +3968,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t      && CONST_INT_P (XEXP (op, 1))\n \t      && mask_low_and_shift_p (mode, XEXP (x, 1), XEXP (op, 1), 32))\n \t    {\n-\t      *total = COSTS_N_INSNS (1) + set_src_cost (XEXP (op, 0), speed);\n+\t      *total = COSTS_N_INSNS (1);\n+\t      *total += set_src_cost (XEXP (op, 0), mode, speed);\n \t      return true;\n \t    }\n \t}\n@@ -3980,8 +3981,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t{\n \t  cost = GET_MODE_SIZE (mode) > UNITS_PER_WORD ? 2 : 1;\n           *total = (COSTS_N_INSNS (cost)\n-\t\t    + set_src_cost (XEXP (XEXP (x, 0), 0), speed)\n-\t\t    + set_src_cost (XEXP (XEXP (x, 1), 0), speed));\n+\t\t    + set_src_cost (XEXP (XEXP (x, 0), 0), mode, speed)\n+\t\t    + set_src_cost (XEXP (XEXP (x, 1), 0), mode, speed));\n \t  return true;\n \t}\n \t    \n@@ -4017,7 +4018,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case LO_SUM:\n       /* Low-part immediates need an extended MIPS16 instruction.  */\n       *total = (COSTS_N_INSNS (TARGET_MIPS16 ? 2 : 1)\n-\t\t+ set_src_cost (XEXP (x, 0), speed));\n+\t\t+ set_src_cost (XEXP (x, 0), mode, speed));\n       return true;\n \n     case LT:\n@@ -4055,17 +4056,17 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  if (GET_CODE (op0) == MULT && GET_CODE (XEXP (op0, 0)) == NEG)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ set_src_cost (XEXP (XEXP (op0, 0), 0), speed)\n-\t\t\t+ set_src_cost (XEXP (op0, 1), speed)\n-\t\t\t+ set_src_cost (op1, speed));\n+\t\t\t+ set_src_cost (XEXP (XEXP (op0, 0), 0), mode, speed)\n+\t\t\t+ set_src_cost (XEXP (op0, 1), mode, speed)\n+\t\t\t+ set_src_cost (op1, mode, speed));\n \t      return true;\n \t    }\n \t  if (GET_CODE (op1) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ set_src_cost (op0, speed)\n-\t\t\t+ set_src_cost (XEXP (op1, 0), speed)\n-\t\t\t+ set_src_cost (XEXP (op1, 1), speed));\n+\t\t\t+ set_src_cost (op0, mode, speed)\n+\t\t\t+ set_src_cost (XEXP (op1, 0), mode, speed)\n+\t\t\t+ set_src_cost (XEXP (op1, 1), mode, speed));\n \t      return true;\n \t    }\n \t}\n@@ -4093,8 +4094,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  if (const_immlsa_operand (op2, mode))\n \t    {\n \t      *total = (COSTS_N_INSNS (1)\n-\t\t\t+ set_src_cost (XEXP (XEXP (x, 0), 0), speed)\n-\t\t\t+ set_src_cost (XEXP (x, 1), speed));\n+\t\t\t+ set_src_cost (XEXP (XEXP (x, 0), 0), mode, speed)\n+\t\t\t+ set_src_cost (XEXP (x, 1), mode, speed));\n \t      return true;\n \t    }\n \t}\n@@ -4117,9 +4118,9 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t      && GET_CODE (XEXP (op, 0)) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ set_src_cost (XEXP (XEXP (op, 0), 0), speed)\n-\t\t\t+ set_src_cost (XEXP (XEXP (op, 0), 1), speed)\n-\t\t\t+ set_src_cost (XEXP (op, 1), speed));\n+\t\t\t+ set_src_cost (XEXP (XEXP (op, 0), 0), mode, speed)\n+\t\t\t+ set_src_cost (XEXP (XEXP (op, 0), 1), mode, speed)\n+\t\t\t+ set_src_cost (XEXP (op, 1), mode, speed));\n \t      return true;\n \t    }\n \t}\n@@ -4161,10 +4162,10 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  if (outer_code == SQRT || GET_CODE (XEXP (x, 1)) == SQRT)\n \t    /* An rsqrt<mode>a or rsqrt<mode>b pattern.  Count the\n \t       division as being free.  */\n-\t    *total = set_src_cost (XEXP (x, 1), speed);\n+\t    *total = set_src_cost (XEXP (x, 1), mode, speed);\n \t  else\n \t    *total = (mips_fp_div_cost (mode)\n-\t\t      + set_src_cost (XEXP (x, 1), speed));\n+\t\t      + set_src_cost (XEXP (x, 1), mode, speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -4192,7 +4193,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t      && CONST_INT_P (XEXP (x, 1))\n \t      && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t    {\n-\t      *total = COSTS_N_INSNS (2) + set_src_cost (XEXP (x, 0), speed);\n+\t      *total = COSTS_N_INSNS (2);\n+\t      *total += set_src_cost (XEXP (x, 0), mode, speed);\n \t      return true;\n \t    }\n \t  *total = COSTS_N_INSNS (mips_idiv_insns ());\n@@ -4215,7 +4217,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  && GET_MODE (XEXP (x, 0)) == QImode\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS)\n \t{\n-\t  *total = set_src_cost (XEXP (XEXP (x, 0), 0), speed);\n+\t  *total = set_src_cost (XEXP (XEXP (x, 0), 0), VOIDmode, speed);\n \t  return true;\n \t}\n       *total = mips_zero_extend_cost (mode, XEXP (x, 0));\n@@ -4258,9 +4260,10 @@ mips_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t      if (ISA_HAS_R6DMUL\n \t\t  && GET_CODE (op) == ZERO_EXTEND\n \t\t  && GET_MODE (op) == DImode)\n-\t\t*total += rtx_cost (op, MULT, i, speed);\n+\t\t*total += rtx_cost (op, DImode, MULT, i, speed);\n \t      else\n-\t\t*total += rtx_cost (XEXP (op, 0), GET_CODE (op), 0, speed);\n+\t\t*total += rtx_cost (XEXP (op, 0), VOIDmode, GET_CODE (op),\n+\t\t\t\t    0, speed);\n \t    }\n \n \t  return true;"}, {"sha": "57f0659d462c0339fb6698182d77a3597684004a", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -149,7 +149,7 @@ static void mmix_setup_incoming_varargs\n   (cumulative_args_t, machine_mode, tree, int *, int);\n static void mmix_file_start (void);\n static void mmix_file_end (void);\n-static bool mmix_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool mmix_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int mmix_register_move_cost (machine_mode,\n \t\t\t\t    reg_class_t, reg_class_t);\n static rtx mmix_struct_value_rtx (tree, int);\n@@ -1174,7 +1174,7 @@ mmix_reversible_cc_mode (machine_mode mode)\n \n static bool\n mmix_rtx_costs (rtx x ATTRIBUTE_UNUSED,\n-\t\tint code ATTRIBUTE_UNUSED,\n+\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n \t\tint outer_code ATTRIBUTE_UNUSED,\n \t\tint opno ATTRIBUTE_UNUSED,\n \t\tint *total ATTRIBUTE_UNUSED,"}, {"sha": "7abc61dabf1a291d1857827823ef9e48cb653b1c", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2227,7 +2227,7 @@ mn10300_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n       return speed ? 2 : 6;\n \n     default:\n-      return rtx_cost (x, MEM, 0, speed);\n+      return rtx_cost (x, Pmode, MEM, 0, speed);\n     }\n }\n \n@@ -2341,13 +2341,14 @@ mn10300_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n    to represent cycles.  Size-relative costs are in bytes.  */\n \n static bool\n-mn10300_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t\t   int *ptotal, bool speed)\n+mn10300_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t   int opno ATTRIBUTE_UNUSED, int *ptotal, bool speed)\n {\n   /* This value is used for SYMBOL_REF etc where we want to pretend\n      we have a full 32-bit constant.  */\n   HOST_WIDE_INT i = 0x12345678;\n   int total;\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -2433,7 +2434,7 @@ mn10300_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  i = INTVAL (XEXP (x, 1));\n \t  if (i == 1 || i == 4)\n \t    {\n-\t      total = 1 + rtx_cost (XEXP (x, 0), PLUS, 0, speed);\n+\t      total = 1 + rtx_cost (XEXP (x, 0), mode, PLUS, 0, speed);\n \t      goto alldone;\n \t    }\n \t}\n@@ -2489,7 +2490,7 @@ mn10300_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       break;\n \n     case MEM:\n-      total = mn10300_address_cost (XEXP (x, 0), GET_MODE (x),\n+      total = mn10300_address_cost (XEXP (x, 0), mode,\n \t\t\t\t    MEM_ADDR_SPACE (x), speed);\n       if (speed)\n \ttotal = COSTS_N_INSNS (2 + total);"}, {"sha": "9d0e4a0e1287caf01c08e1c7366590dc041d577f", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1004,17 +1004,19 @@ msp430_legitimate_constant (machine_mode mode, rtx x)\n #undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS msp430_rtx_costs\n \n-static bool msp430_rtx_costs (rtx   x ATTRIBUTE_UNUSED,\n-\t\t\t      int   code,\n-\t\t\t      int   outer_code ATTRIBUTE_UNUSED,\n-\t\t\t      int   opno ATTRIBUTE_UNUSED,\n-\t\t\t      int * total,\n-\t\t\t      bool  speed ATTRIBUTE_UNUSED)\n+static bool msp430_rtx_costs (rtx\t   x ATTRIBUTE_UNUSED,\n+\t\t\t      machine_mode mode,\n+\t\t\t      int\t   outer_code ATTRIBUTE_UNUSED,\n+\t\t\t      int\t   opno ATTRIBUTE_UNUSED,\n+\t\t\t      int *\t   total,\n+\t\t\t      bool\t   speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case SIGN_EXTEND:\n-      if (GET_MODE (x) == SImode && outer_code == SET)\n+      if (mode == SImode && outer_code == SET)\n \t{\n \t  *total = COSTS_N_INSNS (4);\n \t  return true;"}, {"sha": "d25c41ab0c771fd9ab111397b0c0c5ecdf566815", "filename": "gcc/config/nds32/nds32-cost.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -64,12 +64,14 @@\n \n bool\n nds32_rtx_costs_impl (rtx x,\n-\t\t      int code,\n+\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      int outer_code,\n \t\t      int opno ATTRIBUTE_UNUSED,\n \t\t      int *total,\n \t\t      bool speed)\n {\n+  int code = GET_CODE (x);\n+\n   /* According to 'speed', goto suitable cost model section.  */\n   if (speed)\n     goto performance_cost;"}, {"sha": "199e70374589a7411988865bbce944ab89578cc7", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -144,7 +144,7 @@ extern bool nds32_isr_function_p (tree);\n \n /* Auxiliary functions for cost calculation.  */\n \n-extern bool nds32_rtx_costs_impl (rtx, int, int, int, int *, bool);\n+extern bool nds32_rtx_costs_impl (rtx, machine_mode, int, int, int *, bool);\n extern int nds32_address_cost_impl (rtx, machine_mode, addr_space_t, bool);\n \n /* ------------------------------------------------------------------------ */"}, {"sha": "56ba24a20d516ce0d83f12a2aa3f8e48c78d7d48", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2100,13 +2100,13 @@ nds32_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n    Refer to gcc/rtlanal.c for more information.  */\n static bool\n nds32_rtx_costs (rtx x,\n-\t\t int code,\n+\t\t machine_mode mode,\n \t\t int outer_code,\n \t\t int opno,\n \t\t int *total,\n \t\t bool speed)\n {\n-  return nds32_rtx_costs_impl (x, code, outer_code, opno, total, speed);\n+  return nds32_rtx_costs_impl (x, mode, outer_code, opno, total, speed);\n }\n \n static int"}, {"sha": "4b614db98910a8f6f7e162ac4fdeb27ca3fc11e6", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1090,10 +1090,13 @@ nios2_simple_const_p (const_rtx cst)\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n static bool\n-nios2_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+nios2_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t int outer_code ATTRIBUTE_UNUSED,\n \t\t int opno ATTRIBUTE_UNUSED,\n \t\t int *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n       case CONST_INT:"}, {"sha": "03ac6f220a2e4d08c2396628d8d3dccc968453f1", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -106,7 +106,7 @@ static void fix_range (const char *);\n static int hppa_register_move_cost (machine_mode mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static int hppa_address_cost (rtx, machine_mode mode, addr_space_t, bool);\n-static bool hppa_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool hppa_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static inline rtx force_mode (machine_mode, rtx);\n static void pa_reorg (void);\n static void pa_combine_instructions (void);\n@@ -1480,10 +1480,12 @@ hppa_address_cost (rtx X, machine_mode mode ATTRIBUTE_UNUSED,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-hppa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+hppa_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed ATTRIBUTE_UNUSED)\n {\n   int factor;\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -1515,14 +1517,14 @@ hppa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case MULT:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  *total = COSTS_N_INSNS (3);\n \t  return true;\n \t}\n \n       /* A mode size N times larger than SImode needs O(N*N) more insns.  */\n-      factor = GET_MODE_SIZE (GET_MODE (x)) / 4;\n+      factor = GET_MODE_SIZE (mode) / 4;\n       if (factor == 0)\n \tfactor = 1;\n \n@@ -1533,7 +1535,7 @@ hppa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case DIV:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  *total = COSTS_N_INSNS (14);\n \t  return true;\n@@ -1544,7 +1546,7 @@ hppa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case MOD:\n     case UMOD:\n       /* A mode size N times larger than SImode needs O(N*N) more insns.  */\n-      factor = GET_MODE_SIZE (GET_MODE (x)) / 4;\n+      factor = GET_MODE_SIZE (mode) / 4;\n       if (factor == 0)\n \tfactor = 1;\n \n@@ -1553,15 +1555,15 @@ hppa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \n     case PLUS: /* this includes shNadd insns */\n     case MINUS:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  *total = COSTS_N_INSNS (3);\n \t  return true;\n \t}\n \n       /* A size N times larger than UNITS_PER_WORD needs N times as\n \t many insns, taking N times as long.  */\n-      factor = GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD;\n+      factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n       if (factor == 0)\n \tfactor = 1;\n       *total = factor * COSTS_N_INSNS (1);"}, {"sha": "cba2b35d03acc194514c7910eeb3da105f734dce", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -158,7 +158,7 @@ decode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n static const char *singlemove_string (rtx *);\n static bool pdp11_assemble_integer (rtx, unsigned int, int);\n-static bool pdp11_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool pdp11_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static bool pdp11_return_in_memory (const_tree, const_tree);\n static rtx pdp11_function_value (const_tree, const_tree, bool);\n static rtx pdp11_libcall_value (machine_mode, const_rtx);\n@@ -910,10 +910,12 @@ pdp11_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n static bool\n-pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+pdp11_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t\t int opno ATTRIBUTE_UNUSED, int *total,\n \t\t bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -972,9 +974,9 @@ pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n       return false;\n \n     case SIGN_EXTEND:\n-      if (GET_MODE (x) == HImode)\n+      if (mode == HImode)\n       \t*total = COSTS_N_INSNS (1);\n-      else if (GET_MODE (x) == SImode)\n+      else if (mode == SImode)\n \t*total = COSTS_N_INSNS (6);\n       else\n \t*total = COSTS_N_INSNS (2);\n@@ -985,14 +987,14 @@ pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n     case ASHIFTRT:\n       if (optimize_size)\n         *total = COSTS_N_INSNS (1);\n-      else if (GET_MODE (x) ==  QImode)\n+      else if (mode ==  QImode)\n         {\n           if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n    \t    *total = COSTS_N_INSNS (8); /* worst case */\n           else\n \t    *total = COSTS_N_INSNS (INTVAL (XEXP (x, 1)));\n         }\n-      else if (GET_MODE (x) == HImode)\n+      else if (mode == HImode)\n         {\n           if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n             {\n@@ -1004,7 +1006,7 @@ pdp11_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n           else\n             *total = COSTS_N_INSNS (10); /* worst case */\n         }\n-      else if (GET_MODE (x) == SImode)\n+      else if (mode == SImode)\n         {\n           if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t    *total = COSTS_N_INSNS (2.5 + 0.5 * INTVAL (XEXP (x, 1)));"}, {"sha": "eb07ca3b6d92206126436d5b1a86cf4c55e4e780", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -4153,20 +4153,22 @@ rl78_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n #define TARGET_RTX_COSTS rl78_rtx_costs\n \n static bool\n-rl78_rtx_costs (rtx   x,\n-\t\tint   code,\n-\t\tint   outer_code ATTRIBUTE_UNUSED,\n-\t\tint   opno ATTRIBUTE_UNUSED,\n-\t\tint * total,\n-\t\tbool  speed ATTRIBUTE_UNUSED)\n+rl78_rtx_costs (rtx          x,\n+\t\tmachine_mode mode,\n+\t\tint          outer_code ATTRIBUTE_UNUSED,\n+\t\tint          opno ATTRIBUTE_UNUSED,\n+\t\tint *        total,\n+\t\tbool         speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   if (code == IF_THEN_ELSE)\n     {\n       *total = COSTS_N_INSNS (10);\n       return true;\n     }\n \n-  if (GET_MODE (x) == SImode)\n+  if (mode == SImode)\n     {\n       switch (code)\n \t{"}, {"sha": "23fc6863eca64021b583f26c855dc9fbff847a26", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1108,7 +1108,7 @@ static tree rs6000_handle_struct_attribute (tree *, tree, tree, int, bool *);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n static void rs6000_emit_set_long_const (rtx, HOST_WIDE_INT);\n static int rs6000_memory_move_cost (machine_mode, reg_class_t, bool);\n-static bool rs6000_debug_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool rs6000_debug_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int rs6000_debug_address_cost (rtx, machine_mode, addr_space_t,\n \t\t\t\t      bool);\n static int rs6000_debug_adjust_cost (rtx_insn *, rtx, rtx_insn *, int);\n@@ -30629,10 +30629,10 @@ rs6000_xcoff_encode_section_info (tree decl, rtx rtl, int first)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-rs6000_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n-\t\t  int *total, bool speed)\n+rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t  int opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -30953,16 +30953,16 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n /* Debug form of r6000_rtx_costs that is selected if -mdebug=cost.  */\n \n static bool\n-rs6000_debug_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n-\t\t\tbool speed)\n+rs6000_debug_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t\tint opno, int *total, bool speed)\n {\n-  bool ret = rs6000_rtx_costs (x, code, outer_code, opno, total, speed);\n+  bool ret = rs6000_rtx_costs (x, mode, outer_code, opno, total, speed);\n \n   fprintf (stderr,\n-\t   \"\\nrs6000_rtx_costs, return = %s, code = %s, outer_code = %s, \"\n+\t   \"\\nrs6000_rtx_costs, return = %s, mode = %s, outer_code = %s, \"\n \t   \"opno = %d, total = %d, speed = %s, x:\\n\",\n \t   ret ? \"complete\" : \"scan inner\",\n-\t   GET_RTX_NAME (code),\n+\t   GET_MODE_NAME (mode),\n \t   GET_RTX_NAME (outer_code),\n \t   opno,\n \t   *total,"}, {"sha": "e9e9bc968354d91cc9715a3604ce5854d1808d02", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -3301,13 +3301,14 @@ s390_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.\n-   CODE contains GET_CODE (x), OUTER_CODE contains the code\n-   of the superexpression of x.  */\n+   OUTER_CODE contains the code of the superexpression of x.  */\n \n static bool\n-s390_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED,\n \t\tint *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n   switch (code)\n     {\n     case CONST:\n@@ -3338,7 +3339,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return false;\n \n     case MULT:\n-      switch (GET_MODE (x))\n+      switch (mode)\n \t{\n \tcase SImode:\n \t  {\n@@ -3397,7 +3398,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return false;\n \n     case FMA:\n-      switch (GET_MODE (x))\n+      switch (mode)\n \t{\n \tcase DFmode:\n \t  *total = s390_cost->madbr;\n@@ -3411,32 +3412,32 @@ s390_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       /* Negate in the third argument is free: FMSUB.  */\n       if (GET_CODE (XEXP (x, 2)) == NEG)\n \t{\n-\t  *total += (rtx_cost (XEXP (x, 0), FMA, 0, speed)\n-\t\t     + rtx_cost (XEXP (x, 1), FMA, 1, speed)\n-\t\t     + rtx_cost (XEXP (XEXP (x, 2), 0), FMA, 2, speed));\n+\t  *total += (rtx_cost (XEXP (x, 0), mode, FMA, 0, speed)\n+\t\t     + rtx_cost (XEXP (x, 1), mode, FMA, 1, speed)\n+\t\t     + rtx_cost (XEXP (XEXP (x, 2), 0), mode, FMA, 2, speed));\n \t  return true;\n \t}\n       return false;\n \n     case UDIV:\n     case UMOD:\n-      if (GET_MODE (x) == TImode) \t       /* 128 bit division */\n+      if (mode == TImode) \t       /* 128 bit division */\n \t*total = s390_cost->dlgr;\n-      else if (GET_MODE (x) == DImode)\n+      else if (mode == DImode)\n \t{\n \t  rtx right = XEXP (x, 1);\n \t  if (GET_CODE (right) == ZERO_EXTEND) /* 64 by 32 bit division */\n \t    *total = s390_cost->dlr;\n \t  else \t                               /* 64 by 64 bit division */\n \t    *total = s390_cost->dlgr;\n \t}\n-      else if (GET_MODE (x) == SImode)         /* 32 bit division */\n+      else if (mode == SImode)         /* 32 bit division */\n \t*total = s390_cost->dlr;\n       return false;\n \n     case DIV:\n     case MOD:\n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t{\n \t  rtx right = XEXP (x, 1);\n \t  if (GET_CODE (right) == ZERO_EXTEND) /* 64 by 32 bit division */\n@@ -3447,26 +3448,26 @@ s390_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t  else \t                               /* 64 by 64 bit division */\n \t    *total = s390_cost->dsgr;\n \t}\n-      else if (GET_MODE (x) == SImode)         /* 32 bit division */\n+      else if (mode == SImode)         /* 32 bit division */\n \t*total = s390_cost->dlr;\n-      else if (GET_MODE (x) == SFmode)\n+      else if (mode == SFmode)\n \t{\n \t  *total = s390_cost->debr;\n \t}\n-      else if (GET_MODE (x) == DFmode)\n+      else if (mode == DFmode)\n \t{\n \t  *total = s390_cost->ddbr;\n \t}\n-      else if (GET_MODE (x) == TFmode)\n+      else if (mode == TFmode)\n \t{\n \t  *total = s390_cost->dxbr;\n \t}\n       return false;\n \n     case SQRT:\n-      if (GET_MODE (x) == SFmode)\n+      if (mode == SFmode)\n \t*total = s390_cost->sqebr;\n-      else if (GET_MODE (x) == DFmode)\n+      else if (mode == DFmode)\n \t*total = s390_cost->sqdbr;\n       else /* TFmode */\n \t*total = s390_cost->sqxbr;"}, {"sha": "71f3a5d7414fd9b5b3c92627a272aed2e2c9a563", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -275,7 +275,7 @@ static int addsubcosts (rtx);\n static int multcosts (rtx);\n static bool unspec_caller_rtx_p (rtx);\n static bool sh_cannot_copy_insn_p (rtx_insn *);\n-static bool sh_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool sh_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int sh_address_cost (rtx, machine_mode, addr_space_t, bool);\n static int sh_pr_n_sets (void);\n static rtx sh_allocate_initial_value (rtx);\n@@ -3280,7 +3280,7 @@ and_xor_ior_costs (rtx x, int code)\n \t  || satisfies_constraint_J16 (XEXP (x, 1)))\n \treturn 1;\n       else\n-\treturn 1 + rtx_cost (XEXP (x, 1), AND, 1, !optimize_size);\n+\treturn 1 + rtx_cost (XEXP (x, 1), GET_MODE (x), AND, 1, !optimize_size);\n     }\n \n   /* These constants are single cycle extu.[bw] instructions.  */\n@@ -3420,9 +3420,12 @@ multcosts (rtx x ATTRIBUTE_UNUSED)\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n static bool\n-sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+sh_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n+\t      int opno ATTRIBUTE_UNUSED,\n \t      int *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n       /* The lower-subreg pass decides whether to split multi-word regs"}, {"sha": "0ea5102d9bff9bf2bc08e805cfd83131fb7ccc54", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -588,7 +588,7 @@ static rtx sparc_tls_get_addr (void);\n static rtx sparc_tls_got (void);\n static int sparc_register_move_cost (machine_mode,\n \t\t\t\t     reg_class_t, reg_class_t);\n-static bool sparc_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool sparc_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static rtx sparc_function_value (const_tree, const_tree, bool);\n static rtx sparc_libcall_value (machine_mode, const_rtx);\n static bool sparc_function_value_regno_p (const unsigned int);\n@@ -10925,10 +10925,11 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n    ??? the latencies and then CSE will just use that.  */\n \n static bool\n-sparc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+sparc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t int opno ATTRIBUTE_UNUSED,\n \t\t int *total, bool speed ATTRIBUTE_UNUSED)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n \n   switch (code)\n@@ -10952,7 +10953,7 @@ sparc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case CONST_DOUBLE:\n-      if (GET_MODE (x) == VOIDmode\n+      if (mode == VOIDmode\n \t  && ((CONST_DOUBLE_HIGH (x) == 0\n \t       && CONST_DOUBLE_LOW (x) < 0x1000)\n \t      || (CONST_DOUBLE_HIGH (x) == -1\n@@ -11004,12 +11005,12 @@ sparc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \tsub = XEXP (x, 0);\n \tif (GET_CODE (sub) == NEG)\n \t  sub = XEXP (sub, 0);\n-\t*total += rtx_cost (sub, FMA, 0, speed);\n+\t*total += rtx_cost (sub, mode, FMA, 0, speed);\n \n \tsub = XEXP (x, 2);\n \tif (GET_CODE (sub) == NEG)\n \t  sub = XEXP (sub, 0);\n-\t*total += rtx_cost (sub, FMA, 2, speed);\n+\t*total += rtx_cost (sub, mode, FMA, 2, speed);\n \treturn true;\n       }\n \n@@ -11128,7 +11129,7 @@ sparc_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \n     case IOR:\n       /* Handle the NAND vector patterns.  */\n-      if (sparc_vector_mode_supported_p (GET_MODE (x))\n+      if (sparc_vector_mode_supported_p (mode)\n \t  && GET_CODE (XEXP (x, 0)) == NOT\n \t  && GET_CODE (XEXP (x, 1)) == NOT)\n \t{"}, {"sha": "2470728e6f8c72739d42d8f2b452f50b6bf46a3d", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -5235,11 +5235,11 @@ spu_asm_globalize_label (FILE * file, const char *name)\n }\n \n static bool\n-spu_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+spu_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t       int opno ATTRIBUTE_UNUSED, int *total,\n \t       bool speed ATTRIBUTE_UNUSED)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n   int cost = COSTS_N_INSNS (2);\n \n   /* Folding to a CONST_VECTOR will use extra space but there might"}, {"sha": "9d243f6f209447044653c2354f44490249e4e3bb", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -77,7 +77,6 @@ static void xstormy16_asm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \n static void xstormy16_init_builtins (void);\n static rtx xstormy16_expand_builtin (tree, rtx, rtx, machine_mode, int);\n-static bool xstormy16_rtx_costs (rtx, int, int, int, int *, bool);\n static int xstormy16_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool xstormy16_return_in_memory (const_tree, const_tree);\n \n@@ -88,10 +87,13 @@ static GTY(()) section *bss100_section;\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-xstormy16_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+xstormy16_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     int outer_code ATTRIBUTE_UNUSED,\n \t\t     int opno ATTRIBUTE_UNUSED, int *total,\n \t\t     bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:"}, {"sha": "8ceb41e4f506e1a73444492b4b53cee92fe1e64b", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -551,9 +551,11 @@ tilegx_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \n /* Implement TARGET_RTX_COSTS.  */\n static bool\n-tilegx_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n-\t\t  bool speed)\n+tilegx_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno,\n+\t\t  int *total, bool speed)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -620,9 +622,9 @@ tilegx_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n       if (GET_CODE (XEXP (x, 0)) == MULT\n \t  && cint_248_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n \t{\n-\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0),\n+\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n \t\t\t      (enum rtx_code) outer_code, opno, speed)\n-\t\t    + rtx_cost (XEXP (x, 1),\n+\t\t    + rtx_cost (XEXP (x, 1), mode,\n \t\t\t\t(enum rtx_code) outer_code, opno, speed)\n \t\t    + COSTS_N_INSNS (1));\n \t  return true;"}, {"sha": "e68d075717a1ead880beeadfbbb0071bf54ca341", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -493,9 +493,11 @@ tilepro_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n \n /* Implement TARGET_RTX_COSTS.  */\n static bool\n-tilepro_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n-\t\t   bool speed)\n+tilepro_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno,\n+\t\t   int *total, bool speed)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -562,9 +564,9 @@ tilepro_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n       if (GET_CODE (XEXP (x, 0)) == MULT\n \t  && cint_248_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n \t{\n-\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0),\n+\t  *total = (rtx_cost (XEXP (XEXP (x, 0), 0), mode,\n \t\t\t      (enum rtx_code) outer_code, opno, speed)\n-\t\t    + rtx_cost (XEXP (x, 1),\n+\t\t    + rtx_cost (XEXP (x, 1), mode,\n \t\t\t\t(enum rtx_code) outer_code, opno, speed)\n \t\t    + COSTS_N_INSNS (1));\n \t  return true;"}, {"sha": "77e0a5f85870df7afeacbd3014d6696865a6d500", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -354,13 +354,10 @@ const_costs (rtx r, enum rtx_code c)\n }\n \n static bool\n-v850_rtx_costs (rtx x,\n-                int codearg,\n-                int outer_code ATTRIBUTE_UNUSED,\n-\t\tint opno ATTRIBUTE_UNUSED,\n-                int * total, bool speed)\n+v850_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\tint opno ATTRIBUTE_UNUSED, int *total, bool speed)\n {\n-  enum rtx_code code = (enum rtx_code) codearg;\n+  enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -384,9 +381,7 @@ v850_rtx_costs (rtx x,\n \n     case MULT:\n       if (TARGET_V850E\n-\t  && (   GET_MODE (x) == SImode\n-\t      || GET_MODE (x) == HImode\n-\t      || GET_MODE (x) == QImode))\n+\t  && (mode == SImode || mode == HImode || mode == QImode))\n         {\n \t  if (GET_CODE (XEXP (x, 1)) == REG)\n \t    *total = 4;"}, {"sha": "72dfa62a54bea149b804ab1f244a15470c55ec82", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -67,7 +67,7 @@ static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT, tree);\n static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx, machine_mode, addr_space_t, bool);\n-static bool vax_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool vax_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static rtx vax_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n static void vax_function_arg_advance (cumulative_args_t, machine_mode,\n@@ -767,10 +767,11 @@ vax_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n    costs on a per cpu basis.  */\n \n static bool\n-vax_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+vax_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t       int opno ATTRIBUTE_UNUSED,\n \t       int *total, bool speed ATTRIBUTE_UNUSED)\n {\n-  machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n   int i = 0;\t\t\t\t   /* may be modified in switch */\n   const char *fmt = GET_RTX_FORMAT (code); /* may be modified in switch */\n \n@@ -810,7 +811,7 @@ vax_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case CONST_DOUBLE:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t*total = vax_float_literal (x) ? 5 : 8;\n       else\n \t*total = ((CONST_DOUBLE_HIGH (x) == 0\n@@ -998,7 +999,7 @@ vax_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t{\n \tcase CONST_INT:\n \t  if ((unsigned HOST_WIDE_INT)INTVAL (op) > 63\n-\t      && GET_MODE (x) != QImode)\n+\t      && mode != QImode)\n \t    *total += 1;\t/* 2 on VAX 2 */\n \t  break;\n \tcase CONST:"}, {"sha": "da48d10e0566fd5bbb3baa0da9d166b9cdcb0e05", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -186,7 +186,7 @@ static int visium_register_move_cost (enum machine_mode, reg_class_t,\n \n static int visium_memory_move_cost (enum machine_mode, reg_class_t, bool);\n \n-static bool visium_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool visium_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n \n static void visium_option_override (void);\n \n@@ -1883,11 +1883,11 @@ visium_memory_move_cost (enum machine_mode mode,\n /* Return the relative costs of expression X.  */\n \n static bool\n-visium_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n+visium_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t\t  int opno ATTRIBUTE_UNUSED, int *total,\n \t\t  bool speed ATTRIBUTE_UNUSED)\n {\n-  enum machine_mode mode = GET_MODE (x);\n+  int code = GET_CODE (x);\n \n   switch (code)\n     {"}, {"sha": "efcc2fbbba5a39445c1cb99448587f48d868ec8a", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -142,7 +142,7 @@ static unsigned int xtensa_multibss_section_type_flags (tree, const char *,\n \t\t\t\t\t\t\tint) ATTRIBUTE_UNUSED;\n static section *xtensa_select_rtx_section (machine_mode, rtx,\n \t\t\t\t\t   unsigned HOST_WIDE_INT);\n-static bool xtensa_rtx_costs (rtx, int, int, int, int *, bool);\n+static bool xtensa_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int xtensa_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t      reg_class_t);\n static int xtensa_memory_move_cost (machine_mode, reg_class_t, bool);\n@@ -3566,9 +3566,12 @@ xtensa_memory_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+xtensa_rtx_costs (rtx x, machine_mode mode, int outer_code,\n+\t\t  int opno ATTRIBUTE_UNUSED,\n \t\t  int *total, bool speed ATTRIBUTE_UNUSED)\n {\n+  int code = GET_CODE (x);\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -3638,9 +3641,9 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case MEM:\n       {\n \tint num_words =\n-\t  (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD) ?  2 : 1;\n+\t  (GET_MODE_SIZE (mode) > UNITS_PER_WORD) ?  2 : 1;\n \n-\tif (memory_address_p (GET_MODE (x), XEXP ((x), 0)))\n+\tif (memory_address_p (mode, XEXP ((x), 0)))\n \t  *total = COSTS_N_INSNS (num_words);\n \telse\n \t  *total = COSTS_N_INSNS (2*num_words);\n@@ -3657,13 +3660,13 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case NOT:\n-      *total = COSTS_N_INSNS ((GET_MODE (x) == DImode) ? 3 : 2);\n+      *total = COSTS_N_INSNS (mode == DImode ? 3 : 2);\n       return true;\n \n     case AND:\n     case IOR:\n     case XOR:\n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t*total = COSTS_N_INSNS (2);\n       else\n \t*total = COSTS_N_INSNS (1);\n@@ -3672,18 +3675,17 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n-      if (GET_MODE (x) == DImode)\n+      if (mode == DImode)\n \t*total = COSTS_N_INSNS (50);\n       else\n \t*total = COSTS_N_INSNS (1);\n       return true;\n \n     case ABS:\n       {\n-\tmachine_mode xmode = GET_MODE (x);\n-\tif (xmode == SFmode)\n+\tif (mode == SFmode)\n \t  *total = COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\n-\telse if (xmode == DFmode)\n+\telse if (mode == DFmode)\n \t  *total = COSTS_N_INSNS (50);\n \telse\n \t  *total = COSTS_N_INSNS (4);\n@@ -3693,28 +3695,26 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case PLUS:\n     case MINUS:\n       {\n-\tmachine_mode xmode = GET_MODE (x);\n-\tif (xmode == SFmode)\n+\tif (mode == SFmode)\n \t  *total = COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\n-\telse if (xmode == DFmode || xmode == DImode)\n+\telse if (mode == DFmode || mode == DImode)\n \t  *total = COSTS_N_INSNS (50);\n \telse\n \t  *total = COSTS_N_INSNS (1);\n \treturn true;\n       }\n \n     case NEG:\n-      *total = COSTS_N_INSNS ((GET_MODE (x) == DImode) ? 4 : 2);\n+      *total = COSTS_N_INSNS (mode == DImode ? 4 : 2);\n       return true;\n \n     case MULT:\n       {\n-\tmachine_mode xmode = GET_MODE (x);\n-\tif (xmode == SFmode)\n+\tif (mode == SFmode)\n \t  *total = COSTS_N_INSNS (TARGET_HARD_FLOAT ? 4 : 50);\n-\telse if (xmode == DFmode)\n+\telse if (mode == DFmode)\n \t  *total = COSTS_N_INSNS (50);\n-\telse if (xmode == DImode)\n+\telse if (mode == DImode)\n \t  *total = COSTS_N_INSNS (TARGET_MUL32_HIGH ? 10 : 50);\n \telse if (TARGET_MUL32)\n \t  *total = COSTS_N_INSNS (4);\n@@ -3730,13 +3730,12 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case DIV:\n     case MOD:\n       {\n-\tmachine_mode xmode = GET_MODE (x);\n-\tif (xmode == SFmode)\n+\tif (mode == SFmode)\n \t  {\n \t    *total = COSTS_N_INSNS (TARGET_HARD_FLOAT_DIV ? 8 : 50);\n \t    return true;\n \t  }\n-\telse if (xmode == DFmode)\n+\telse if (mode == DFmode)\n \t  {\n \t    *total = COSTS_N_INSNS (50);\n \t    return true;\n@@ -3747,8 +3746,7 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case UDIV:\n     case UMOD:\n       {\n-\tmachine_mode xmode = GET_MODE (x);\n-\tif (xmode == DImode)\n+\tif (mode == DImode)\n \t  *total = COSTS_N_INSNS (50);\n \telse if (TARGET_DIV32)\n \t  *total = COSTS_N_INSNS (32);\n@@ -3758,7 +3756,7 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       }\n \n     case SQRT:\n-      if (GET_MODE (x) == SFmode)\n+      if (mode == SFmode)\n \t*total = COSTS_N_INSNS (TARGET_HARD_FLOAT_SQRT ? 8 : 50);\n       else\n \t*total = COSTS_N_INSNS (50);"}, {"sha": "cf3f99ae69a470e71ab255cf0b100cd7abd8a2c0", "filename": "gcc/cprop.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -752,11 +752,12 @@ try_replace_reg (rtx from, rtx to, rtx_insn *insn)\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n   int old_cost = set ? set_rtx_cost (set, speed) : 0;\n \n-  if ((note != 0\n-      && REG_NOTE_KIND (note) == REG_EQUAL\n-      && (GET_CODE (XEXP (note, 0)) == CONST\n-\t  || CONSTANT_P (XEXP (note, 0))))\n-      || (set && CONSTANT_P (SET_SRC (set))))\n+  if (!set\n+      || CONSTANT_P (SET_SRC (set))\n+      || (note != 0\n+\t  && REG_NOTE_KIND (note) == REG_EQUAL\n+\t  && (GET_CODE (XEXP (note, 0)) == CONST\n+\t      || CONSTANT_P (XEXP (note, 0)))))\n     check_rtx_costs = false;\n \n   /* Usually we substitute easy stuff, so we won't copy everything.\n@@ -772,7 +773,7 @@ try_replace_reg (rtx from, rtx to, rtx_insn *insn)\n \n   if (check_rtx_costs\n       && CONSTANT_P (to)\n-      && (set_rtx_cost (set, speed) > old_cost))\n+      && set_rtx_cost (set, speed) > old_cost)\n     {\n       cancel_changes (0);\n       return false;"}, {"sha": "eefc7bc6656fa0b1251739e0d85b423d8193e43f", "filename": "gcc/cse.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -470,8 +470,10 @@ struct table_elt\n    || (HARD_REGISTER_NUM_P (N)\t\t\t\t\t\t\\\n        && FIXED_REGNO_P (N) && REGNO_REG_CLASS (N) != NO_REGS))\n \n-#define COST(X) (REG_P (X) ? 0 : notreg_cost (X, SET, 1))\n-#define COST_IN(X, OUTER, OPNO) (REG_P (X) ? 0 : notreg_cost (X, OUTER, OPNO))\n+#define COST(X, MODE)\t\t\t\t\t\t\t\\\n+  (REG_P (X) ? 0 : notreg_cost (X, MODE, SET, 1))\n+#define COST_IN(X, MODE, OUTER, OPNO)\t\t\t\t\t\\\n+  (REG_P (X) ? 0 : notreg_cost (X, MODE, OUTER, OPNO))\n \n /* Get the number of times this register has been updated in this\n    basic block.  */\n@@ -547,7 +549,7 @@ static bitmap cse_ebb_live_in, cse_ebb_live_out;\n static sbitmap cse_visited_basic_blocks;\n \n static bool fixed_base_plus_p (rtx x);\n-static int notreg_cost (rtx, enum rtx_code, int);\n+static int notreg_cost (rtx, machine_mode, enum rtx_code, int);\n static int preferable (int, int, int, int);\n static void new_basic_block (void);\n static void make_new_qty (unsigned int, machine_mode);\n@@ -724,19 +726,17 @@ preferable (int cost_a, int regcost_a, int cost_b, int regcost_b)\n    from COST macro to keep it simple.  */\n \n static int\n-notreg_cost (rtx x, enum rtx_code outer, int opno)\n+notreg_cost (rtx x, machine_mode mode, enum rtx_code outer, int opno)\n {\n   return ((GET_CODE (x) == SUBREG\n \t   && REG_P (SUBREG_REG (x))\n-\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n+\t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_INT\n-\t   && (GET_MODE_SIZE (GET_MODE (x))\n-\t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t   && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n \t   && subreg_lowpart_p (x)\n-\t   && TRULY_NOOP_TRUNCATION_MODES_P (GET_MODE (x),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (x))))\n+\t   && TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (SUBREG_REG (x))))\n \t  ? 0\n-\t  : rtx_cost (x, outer, opno, optimize_this_for_speed_p) * 2);\n+\t  : rtx_cost (x, mode, outer, opno, optimize_this_for_speed_p) * 2);\n }\n \n \f\n@@ -1240,7 +1240,7 @@ insert_const_anchor (HOST_WIDE_INT anchor, rtx reg, HOST_WIDE_INT offs,\n      don't prefer pseudos over hard regs so that we derive constants in\n      argument registers from other argument registers rather than from the\n      original pseudo that was used to synthesize the constant.  */\n-  insert_with_costs (exp, elt, hash, mode, COST (reg), 1);\n+  insert_with_costs (exp, elt, hash, mode, COST (reg, mode), 1);\n }\n \n /* The constant CST is equivalent to the register REG.  Create\n@@ -1721,8 +1721,8 @@ static struct table_elt *\n insert (rtx x, struct table_elt *classp, unsigned int hash,\n \tmachine_mode mode)\n {\n-  return\n-    insert_with_costs (x, classp, hash, mode, COST (x), approx_reg_cost (x));\n+  return insert_with_costs (x, classp, hash, mode,\n+\t\t\t    COST (x, mode), approx_reg_cost (x));\n }\n \n \f\n@@ -3257,7 +3257,8 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t   argument.  */\n \tif (const_arg != 0\n \t    && const_arg != folded_arg\n-\t    && COST_IN (const_arg, code, i) <= COST_IN (folded_arg, code, i)\n+\t    && (COST_IN (const_arg, mode_arg, code, i)\n+\t\t<= COST_IN (folded_arg, mode_arg, code, i))\n \n \t    /* It's not safe to substitute the operand of a conversion\n \t       operator with a constant, as the conversion's identity\n@@ -3384,7 +3385,7 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t\t  if (p != NULL)\n \t\t    {\n \t\t      cheapest_simplification = x;\n-\t\t      cheapest_cost = COST (x);\n+\t\t      cheapest_cost = COST (x, mode);\n \n \t\t      for (p = p->first_same_value; p != NULL; p = p->next_same_value)\n \t\t\t{\n@@ -3404,7 +3405,7 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t\t\t  if (simp_result == NULL)\n \t\t\t    continue;\n \n-\t\t\t  cost = COST (simp_result);\n+\t\t\t  cost = COST (simp_result, mode);\n \t\t\t  if (cost < cheapest_cost)\n \t\t\t    {\n \t\t\t      cheapest_cost = cost;\n@@ -4994,7 +4995,7 @@ cse_insn (rtx_insn *insn)\n \t    src_cost = src_regcost = -1;\n \t  else\n \t    {\n-\t      src_cost = COST (src);\n+\t      src_cost = COST (src, mode);\n \t      src_regcost = approx_reg_cost (src);\n \t    }\n \t}\n@@ -5005,7 +5006,7 @@ cse_insn (rtx_insn *insn)\n \t    src_eqv_cost = src_eqv_regcost = -1;\n \t  else\n \t    {\n-\t      src_eqv_cost = COST (src_eqv_here);\n+\t      src_eqv_cost = COST (src_eqv_here, mode);\n \t      src_eqv_regcost = approx_reg_cost (src_eqv_here);\n \t    }\n \t}\n@@ -5016,7 +5017,7 @@ cse_insn (rtx_insn *insn)\n \t    src_folded_cost = src_folded_regcost = -1;\n \t  else\n \t    {\n-\t      src_folded_cost = COST (src_folded);\n+\t      src_folded_cost = COST (src_folded, mode);\n \t      src_folded_regcost = approx_reg_cost (src_folded);\n \t    }\n \t}\n@@ -5027,7 +5028,7 @@ cse_insn (rtx_insn *insn)\n \t    src_related_cost = src_related_regcost = -1;\n \t  else\n \t    {\n-\t      src_related_cost = COST (src_related);\n+\t      src_related_cost = COST (src_related, mode);\n \t      src_related_regcost = approx_reg_cost (src_related);\n \n \t      /* If a const-anchor is used to synthesize a constant that\n@@ -5340,7 +5341,7 @@ cse_insn (rtx_insn *insn)\n \t\t  /* If we had a constant that is cheaper than what we are now\n \t\t     setting SRC to, use that constant.  We ignored it when we\n \t\t     thought we could make this into a no-op.  */\n-\t\t  if (src_const && COST (src_const) < COST (src)\n+\t\t  if (src_const && COST (src_const, mode) < COST (src, mode)\n \t\t      && validate_change (insn, &SET_SRC (sets[i].rtl),\n \t\t\t\t\t  src_const, 0))\n \t\t    src = src_const;"}, {"sha": "3dc51c00b9a35f21b6ceb4317f045cd7e2154ef6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -6357,7 +6357,7 @@ Define this macro if a non-short-circuit operation produced by\n @code{BRANCH_COST} is greater than or equal to the value 2.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, int @var{code}, int @var{outer_code}, int @var{opno}, int *@var{total}, bool @var{speed})\n+@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, machine_mode @var{mode}, int @var{outer_code}, int @var{opno}, int *@var{total}, bool @var{speed})\n This target hook describes the relative costs of RTL expressions.\n \n The cost may depend on the precise form of the expression, which is\n@@ -6368,8 +6368,8 @@ that @samp{GET_CODE (@var{y}) == @var{outer_code}} and such that\n either (a) @samp{XEXP (@var{y}, @var{opno}) == @var{x}} or\n (b) @samp{XVEC (@var{y}, @var{opno})} contains @var{x}.\n \n-@var{code} is @var{x}'s expression code---redundant, since it can be\n-obtained with @code{GET_CODE (@var{x})}.\n+@var{mode} is @var{x}'s machine mode, or for cases like @code{const_int} that\n+do not have a mode, the mode in which @var{x} is used.\n \n In implementing this hook, you can use the construct\n @code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast"}, {"sha": "1f1ec5366ff0d4ad77b9bbf34c5aec78fc953b39", "filename": "gcc/dojump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -201,8 +201,8 @@ prefer_and_bit_test (machine_mode mode, int bitnum)\n   XEXP (XEXP (shift_test, 0), 1) = GEN_INT (bitnum);\n \n   speed_p = optimize_insn_for_speed_p ();\n-  return (rtx_cost (and_test, IF_THEN_ELSE, 0, speed_p)\n-\t  <= rtx_cost (shift_test, IF_THEN_ELSE, 0, speed_p));\n+  return (rtx_cost (and_test, mode, IF_THEN_ELSE, 0, speed_p)\n+\t  <= rtx_cost (shift_test, mode, IF_THEN_ELSE, 0, speed_p));\n }\n \n /* Subroutine of do_jump, dealing with exploded comparisons of the type"}, {"sha": "89ba0c961a371c2e807592c222e07edda5097659", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1832,7 +1832,8 @@ find_shift_sequence (int access_size,\n \t\t  byte = subreg_lowpart_offset (read_mode, new_mode);\n \t\t  ret = simplify_subreg (read_mode, ret, new_mode, byte);\n \t\t  if (ret && CONSTANT_P (ret)\n-\t\t      && set_src_cost (ret, speed) <= COSTS_N_INSNS (1))\n+\t\t      && (set_src_cost (ret, read_mode, speed)\n+\t\t\t  <= COSTS_N_INSNS (1)))\n \t\t    return ret;\n \t\t}\n \t    }"}, {"sha": "b865382e0c3ef592ef2e932c4290505b3df3dbb8", "filename": "gcc/expmed.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -145,7 +145,8 @@ init_expmed_one_conv (struct init_expmed_rtl *all, machine_mode to_mode,\n   which = (to_size < from_size ? all->trunc : all->zext);\n \n   PUT_MODE (all->reg, from_mode);\n-  set_convert_cost (to_mode, from_mode, speed, set_src_cost (which, speed));\n+  set_convert_cost (to_mode, from_mode, speed,\n+\t\t    set_src_cost (which, to_mode, speed));\n }\n \n static void\n@@ -174,15 +175,15 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n   PUT_MODE (all->zext, mode);\n   PUT_MODE (all->trunc, mode);\n \n-  set_add_cost (speed, mode, set_src_cost (all->plus, speed));\n-  set_neg_cost (speed, mode, set_src_cost (all->neg, speed));\n-  set_mul_cost (speed, mode, set_src_cost (all->mult, speed));\n-  set_sdiv_cost (speed, mode, set_src_cost (all->sdiv, speed));\n-  set_udiv_cost (speed, mode, set_src_cost (all->udiv, speed));\n+  set_add_cost (speed, mode, set_src_cost (all->plus, mode, speed));\n+  set_neg_cost (speed, mode, set_src_cost (all->neg, mode, speed));\n+  set_mul_cost (speed, mode, set_src_cost (all->mult, mode, speed));\n+  set_sdiv_cost (speed, mode, set_src_cost (all->sdiv, mode, speed));\n+  set_udiv_cost (speed, mode, set_src_cost (all->udiv, mode, speed));\n \n-  set_sdiv_pow2_cheap (speed, mode, (set_src_cost (all->sdiv_32, speed)\n+  set_sdiv_pow2_cheap (speed, mode, (set_src_cost (all->sdiv_32, mode, speed)\n \t\t\t\t     <= 2 * add_cost (speed, mode)));\n-  set_smod_pow2_cheap (speed, mode, (set_src_cost (all->smod_32, speed)\n+  set_smod_pow2_cheap (speed, mode, (set_src_cost (all->smod_32, mode, speed)\n \t\t\t\t     <= 4 * add_cost (speed, mode)));\n \n   set_shift_cost (speed, mode, 0, 0);\n@@ -199,10 +200,13 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n       XEXP (all->shift, 1) = all->cint[m];\n       XEXP (all->shift_mult, 1) = all->pow2[m];\n \n-      set_shift_cost (speed, mode, m, set_src_cost (all->shift, speed));\n-      set_shiftadd_cost (speed, mode, m, set_src_cost (all->shift_add, speed));\n-      set_shiftsub0_cost (speed, mode, m, set_src_cost (all->shift_sub0, speed));\n-      set_shiftsub1_cost (speed, mode, m, set_src_cost (all->shift_sub1, speed));\n+      set_shift_cost (speed, mode, m, set_src_cost (all->shift, mode, speed));\n+      set_shiftadd_cost (speed, mode, m, set_src_cost (all->shift_add, mode,\n+\t\t\t\t\t\t       speed));\n+      set_shiftsub0_cost (speed, mode, m, set_src_cost (all->shift_sub0, mode,\n+\t\t\t\t\t\t\tspeed));\n+      set_shiftsub1_cost (speed, mode, m, set_src_cost (all->shift_sub1, mode,\n+\t\t\t\t\t\t\tspeed));\n     }\n \n   if (SCALAR_INT_MODE_P (mode))\n@@ -222,9 +226,9 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n \t  XEXP (all->wide_lshr, 1) = GEN_INT (mode_bitsize);\n \n \t  set_mul_widen_cost (speed, wider_mode,\n-\t\t\t      set_src_cost (all->wide_mult, speed));\n+\t\t\t      set_src_cost (all->wide_mult, wider_mode, speed));\n \t  set_mul_highpart_cost (speed, mode,\n-\t\t\t\t set_src_cost (all->wide_trunc, speed));\n+\t\t\t\t set_src_cost (all->wide_trunc, mode, speed));\n \t}\n     }\n }\n@@ -266,7 +270,7 @@ init_expmed (void)\n   for (speed = 0; speed < 2; speed++)\n     {\n       crtl->maybe_hot_insn_p = speed;\n-      set_zero_cost (speed, set_src_cost (const0_rtx, speed));\n+      set_zero_cost (speed, set_src_cost (const0_rtx, mode, speed));\n \n       for (mode = MIN_MODE_INT; mode <= MAX_MODE_INT;\n \t   mode = (machine_mode)(mode + 1))\n@@ -3207,7 +3211,8 @@ expand_mult (machine_mode mode, rtx op0, rtx op1, rtx target,\n \t     Exclude cost of op0 from max_cost to match the cost\n \t     calculation of the synth_mult.  */\n \t  coeff = -(unsigned HOST_WIDE_INT) coeff;\n-\t  max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed)\n+\t  max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1),\n+\t\t\t\t    mode, speed)\n \t\t      - neg_cost (speed, mode));\n \t  if (max_cost <= 0)\n \t    goto skip_synth;\n@@ -3232,7 +3237,7 @@ expand_mult (machine_mode mode, rtx op0, rtx op1, rtx target,\n \n       /* Exclude cost of op0 from max_cost to match the cost\n \t calculation of the synth_mult.  */\n-      max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed);\n+      max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), mode, speed);\n       if (choose_mult_variant (mode, coeff, &algorithm, &variant, max_cost))\n \treturn expand_mult_const (mode, op0, coeff, target,\n \t\t\t\t  &algorithm, variant);\n@@ -3273,7 +3278,8 @@ mult_by_coeff_cost (HOST_WIDE_INT coeff, machine_mode mode, bool speed)\n   enum mult_variant variant;\n \n   rtx fake_reg = gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n-  max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, fake_reg), speed);\n+  max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, fake_reg),\n+\t\t\t   mode, speed);\n   if (choose_mult_variant (mode, coeff, &algorithm, &variant, max_cost))\n     return algorithm.cost.cost;\n   else\n@@ -3699,7 +3705,7 @@ expand_smod_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n \t  temp = gen_rtx_LSHIFTRT (mode, result, shift);\n \t  if (optab_handler (lshr_optab, mode) == CODE_FOR_nothing\n-\t      || (set_src_cost (temp, optimize_insn_for_speed_p ())\n+\t      || (set_src_cost (temp, mode, optimize_insn_for_speed_p ())\n \t\t  > COSTS_N_INSNS (2)))\n \t    {\n \t      temp = expand_binop (mode, xor_optab, op0, signmask,\n@@ -5503,7 +5509,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n \t  /* For the reverse comparison, use either an addition or a XOR.  */\n           if (want_add\n-\t      && rtx_cost (GEN_INT (normalizep), PLUS, 1,\n+\t      && rtx_cost (GEN_INT (normalizep), mode, PLUS, 1,\n \t\t\t   optimize_insn_for_speed_p ()) == 0)\n \t    {\n \t      tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n@@ -5514,7 +5520,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t\t\t     target, 0, OPTAB_WIDEN);\n \t    }\n           else if (!want_add\n-\t           && rtx_cost (trueval, XOR, 1,\n+\t           && rtx_cost (trueval, mode, XOR, 1,\n \t\t\t        optimize_insn_for_speed_p ()) == 0)\n \t    {\n \t      tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n@@ -5606,7 +5612,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n       /* Again, for the reverse comparison, use either an addition or a XOR.  */\n       if (want_add\n-\t  && rtx_cost (GEN_INT (normalizep), PLUS, 1,\n+\t  && rtx_cost (GEN_INT (normalizep), mode, PLUS, 1,\n \t\t       optimize_insn_for_speed_p ()) == 0)\n \t{\n \t  tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,\n@@ -5617,7 +5623,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t\t\ttarget, 0, OPTAB_WIDEN);\n \t}\n       else if (!want_add\n-\t       && rtx_cost (trueval, XOR, 1,\n+\t       && rtx_cost (trueval, mode, XOR, 1,\n \t\t\t    optimize_insn_for_speed_p ()) == 0)\n \t{\n \t  tem = emit_store_flag_1 (subtarget, rcode, op0, op1, mode, 0,"}, {"sha": "4b860ddf7717dbf760654817a124545bf99241bd", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -3631,9 +3631,9 @@ compress_float_constant (rtx x, rtx y)\n   REAL_VALUE_FROM_CONST_DOUBLE (r, y);\n \n   if (targetm.legitimate_constant_p (dstmode, y))\n-    oldcost = set_src_cost (y, speed);\n+    oldcost = set_src_cost (y, orig_srcmode, speed);\n   else\n-    oldcost = set_src_cost (force_const_mem (dstmode, y), speed);\n+    oldcost = set_src_cost (force_const_mem (dstmode, y), dstmode, speed);\n \n   for (srcmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_srcmode));\n        srcmode != orig_srcmode;\n@@ -3662,7 +3662,7 @@ compress_float_constant (rtx x, rtx y)\n \t    continue;\n \t  /* This is valid, but may not be cheaper than the original. */\n \t  newcost = set_src_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y),\n-\t\t\t\t  speed);\n+\t\t\t\t  dstmode, speed);\n \t  if (oldcost < newcost)\n \t    continue;\n \t}\n@@ -3671,7 +3671,7 @@ compress_float_constant (rtx x, rtx y)\n \t  trunc_y = force_const_mem (srcmode, trunc_y);\n \t  /* This is valid, but may not be cheaper than the original. */\n \t  newcost = set_src_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y),\n-\t\t\t\t  speed);\n+\t\t\t\t  dstmode, speed);\n \t  if (oldcost < newcost)\n \t    continue;\n \t  trunc_y = validize_mem (trunc_y);"}, {"sha": "263b40682887026ba6d1f58e71619ecd114fa47a", "filename": "gcc/fwprop.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -405,7 +405,8 @@ should_replace_address (rtx old_rtx, rtx new_rtx, machine_mode mode,\n      eliminating the most insns without additional costs, and it\n      is the same that cse.c used to do.  */\n   if (gain == 0)\n-    gain = set_src_cost (new_rtx, speed) - set_src_cost (old_rtx, speed);\n+    gain = (set_src_cost (new_rtx, VOIDmode, speed)\n+\t    - set_src_cost (old_rtx, VOIDmode, speed));\n \n   return (gain > 0);\n }\n@@ -953,7 +954,7 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx_insn *def_insn,\n      multiple sets.  If so, assume the cost of the new instruction is\n      not greater than the old one.  */\n   if (set)\n-    old_cost = set_src_cost (SET_SRC (set), speed);\n+    old_cost = set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)), speed);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIn insn %d, replacing\\n \", INSN_UID (insn));\n@@ -974,7 +975,8 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx_insn *def_insn,\n \n   else if (DF_REF_TYPE (use) == DF_REF_REG_USE\n \t   && set\n-\t   && set_src_cost (SET_SRC (set), speed) > old_cost)\n+\t   && (set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)), speed)\n+\t       > old_cost))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Changes to insn %d not profitable\\n\","}, {"sha": "2f3d7f70d25c2aa603451e2e787068530e5a98ae", "filename": "gcc/gcse.c", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -466,7 +466,6 @@ static void hash_scan_insn (rtx_insn *, struct gcse_hash_table_d *);\n static void hash_scan_set (rtx, rtx_insn *, struct gcse_hash_table_d *);\n static void hash_scan_clobber (rtx, rtx_insn *, struct gcse_hash_table_d *);\n static void hash_scan_call (rtx, rtx_insn *, struct gcse_hash_table_d *);\n-static int want_to_gcse_p (rtx, int *);\n static int oprs_unchanged_p (const_rtx, const rtx_insn *, int);\n static int oprs_anticipatable_p (const_rtx, const rtx_insn *);\n static int oprs_available_p (const_rtx, const rtx_insn *);\n@@ -757,7 +756,7 @@ static basic_block current_bb;\n    GCSE.  */\n \n static int\n-want_to_gcse_p (rtx x, int *max_distance_ptr)\n+want_to_gcse_p (rtx x, machine_mode mode, int *max_distance_ptr)\n {\n #ifdef STACK_REGS\n   /* On register stack architectures, don't GCSE constants from the\n@@ -808,7 +807,7 @@ want_to_gcse_p (rtx x, int *max_distance_ptr)\n \n \t  gcc_assert (!optimize_function_for_speed_p (cfun)\n \t\t      && optimize_function_for_size_p (cfun));\n-\t  cost = set_src_cost (x, 0);\n+\t  cost = set_src_cost (x, mode, 0);\n \n \t  if (cost < COSTS_N_INSNS (GCSE_UNRESTRICTED_COST))\n \t    {\n@@ -1265,7 +1264,7 @@ hash_scan_set (rtx set, rtx_insn *insn, struct gcse_hash_table_d *table)\n       if (note != 0\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n \t  && !REG_P (src)\n-\t  && want_to_gcse_p (XEXP (note, 0), NULL))\n+\t  && want_to_gcse_p (XEXP (note, 0), GET_MODE (dest), NULL))\n \tsrc = XEXP (note, 0), set = gen_rtx_SET (dest, src);\n \n       /* Only record sets of pseudo-regs in the hash table.  */\n@@ -1279,7 +1278,7 @@ hash_scan_set (rtx set, rtx_insn *insn, struct gcse_hash_table_d *table)\n \t     can't do the same thing at the rtl level.  */\n \t  && !can_throw_internal (insn)\n \t  /* Is SET_SRC something we want to gcse?  */\n-\t  && want_to_gcse_p (src, &max_distance)\n+\t  && want_to_gcse_p (src, GET_MODE (dest), &max_distance)\n \t  /* Don't CSE a nop.  */\n \t  && ! set_noop_p (set)\n \t  /* Don't GCSE if it has attached REG_EQUIV note.\n@@ -1311,43 +1310,42 @@ hash_scan_set (rtx set, rtx_insn *insn, struct gcse_hash_table_d *table)\n      the REG stored in that memory. This makes it possible to remove\n      redundant loads from due to stores to the same location.  */\n   else if (flag_gcse_las && REG_P (src) && MEM_P (dest))\n-      {\n-        unsigned int regno = REGNO (src);\n-\tint max_distance = 0;\n-\n-\t/* Only record sets of pseudo-regs in the hash table.  */\n-        if (regno >= FIRST_PSEUDO_REGISTER\n-\t   /* Don't GCSE something if we can't do a reg/reg copy.  */\n-\t   && can_copy_p (GET_MODE (src))\n-\t   /* GCSE commonly inserts instruction after the insn.  We can't\n-\t      do that easily for EH edges so disable GCSE on these for now.  */\n-\t   && !can_throw_internal (insn)\n-\t   /* Is SET_DEST something we want to gcse?  */\n-\t   && want_to_gcse_p (dest, &max_distance)\n-\t   /* Don't CSE a nop.  */\n-\t   && ! set_noop_p (set)\n-\t   /* Don't GCSE if it has attached REG_EQUIV note.\n-\t      At this point this only function parameters should have\n-\t      REG_EQUIV notes and if the argument slot is used somewhere\n-\t      explicitly, it means address of parameter has been taken,\n-\t      so we should not extend the lifetime of the pseudo.  */\n-\t   && ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) == 0\n-\t       || ! MEM_P (XEXP (note, 0))))\n-             {\n-               /* Stores are never anticipatable.  */\n-               int antic_p = 0;\n-\t       /* An expression is not available if its operands are\n-\t          subsequently modified, including this insn.  It's also not\n-\t          available if this is a branch, because we can't insert\n-\t          a set after the branch.  */\n-               int avail_p = oprs_available_p (dest, insn)\n-\t\t\t     && ! JUMP_P (insn);\n-\n-\t       /* Record the memory expression (DEST) in the hash table.  */\n-\t       insert_expr_in_table (dest, GET_MODE (dest), insn,\n-\t\t\t\t     antic_p, avail_p, max_distance, table);\n-             }\n-      }\n+    {\n+      unsigned int regno = REGNO (src);\n+      int max_distance = 0;\n+\n+      /* Only record sets of pseudo-regs in the hash table.  */\n+      if (regno >= FIRST_PSEUDO_REGISTER\n+\t  /* Don't GCSE something if we can't do a reg/reg copy.  */\n+\t  && can_copy_p (GET_MODE (src))\n+\t  /* GCSE commonly inserts instruction after the insn.  We can't\n+\t     do that easily for EH edges so disable GCSE on these for now.  */\n+\t  && !can_throw_internal (insn)\n+\t  /* Is SET_DEST something we want to gcse?  */\n+\t  && want_to_gcse_p (dest, GET_MODE (dest), &max_distance)\n+\t  /* Don't CSE a nop.  */\n+\t  && ! set_noop_p (set)\n+\t  /* Don't GCSE if it has attached REG_EQUIV note.\n+\t     At this point this only function parameters should have\n+\t     REG_EQUIV notes and if the argument slot is used somewhere\n+\t     explicitly, it means address of parameter has been taken,\n+\t     so we should not extend the lifetime of the pseudo.  */\n+\t  && ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) == 0\n+\t      || ! MEM_P (XEXP (note, 0))))\n+\t{\n+\t  /* Stores are never anticipatable.  */\n+\t  int antic_p = 0;\n+\t  /* An expression is not available if its operands are\n+\t     subsequently modified, including this insn.  It's also not\n+\t     available if this is a branch, because we can't insert\n+\t     a set after the branch.  */\n+\t  int avail_p = oprs_available_p (dest, insn) && ! JUMP_P (insn);\n+\n+\t  /* Record the memory expression (DEST) in the hash table.  */\n+\t  insert_expr_in_table (dest, GET_MODE (dest), insn,\n+\t\t\t\tantic_p, avail_p, max_distance, table);\n+\t}\n+    }\n }\n \n static void"}, {"sha": "0fb9add92f21d9693b662f4937474dfa5a12c32f", "filename": "gcc/hooks.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -333,12 +333,12 @@ hook_bool_uintp_uintp_false (unsigned int *a ATTRIBUTE_UNUSED,\n }\n \n bool\n-hook_bool_rtx_int_int_int_intp_bool_false (rtx a ATTRIBUTE_UNUSED,\n-\t\t\t\t\t   int b ATTRIBUTE_UNUSED,\n-\t\t\t\t\t   int c ATTRIBUTE_UNUSED,\n-\t\t\t\t\t   int d ATTRIBUTE_UNUSED,\n-\t\t\t\t\t   int *e ATTRIBUTE_UNUSED,\n-\t\t\t\t\t   bool speed_p ATTRIBUTE_UNUSED)\n+hook_bool_rtx_mode_int_int_intp_bool_false (rtx a ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    machine_mode b ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    int c ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    int d ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    int *e ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    bool speed_p ATTRIBUTE_UNUSED)\n {\n   return false;\n }"}, {"sha": "c3d4bd34e8279362863395d227749af3a0dea120", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -55,8 +55,8 @@ extern bool hook_bool_rtx_insn_true (rtx_insn *);\n extern bool hook_bool_rtx_false (rtx);\n extern bool hook_bool_rtx_insn_int_false (rtx_insn *, int);\n extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n-extern bool hook_bool_rtx_int_int_int_intp_bool_false (rtx, int, int, int,\n-\t\t\t\t\t\t       int *, bool);\n+extern bool hook_bool_rtx_mode_int_int_intp_bool_false (rtx, machine_mode,\n+\t\t\t\t\t\t\tint, int, int *, bool);\n extern bool hook_bool_tree_tree_false (tree, tree);\n extern bool hook_bool_tree_tree_true (tree, tree);\n extern bool hook_bool_tree_bool_false (tree, bool);"}, {"sha": "31849eea445d4d1079b948fecac2fe58e48b13d5", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2228,7 +2228,7 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n      && (if_info->insn_b == NULL_RTX\n \t || BLOCK_FOR_INSN (if_info->insn_b) == if_info->test_bb));\n   if (!(t_unconditional\n-\t|| (set_src_cost (t, optimize_bb_for_speed_p (if_info->test_bb))\n+\t|| (set_src_cost (t, mode, optimize_bb_for_speed_p (if_info->test_bb))\n \t    < COSTS_N_INSNS (2))))\n     return FALSE;\n "}, {"sha": "25f7a4f8438a7712832f66f60d0b5b07c63bce0b", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -641,7 +641,7 @@ doloop_optimize (struct loop *loop)\n \n   max_cost\n     = COSTS_N_INSNS (PARAM_VALUE (PARAM_MAX_ITERATIONS_COMPUTATION_COST));\n-  if (set_src_cost (desc->niter_expr, optimize_loop_for_speed_p (loop))\n+  if (set_src_cost (desc->niter_expr, mode, optimize_loop_for_speed_p (loop))\n       > max_cost)\n     {\n       if (dump_file)"}, {"sha": "8799dacdebe2a8881aad488f9eac8a4278e16991", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -728,7 +728,8 @@ create_new_invariant (struct def *def, rtx_insn *insn, bitmap depends_on,\n     }\n   else\n     {\n-      inv->cost = set_src_cost (SET_SRC (set), speed);\n+      inv->cost = set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)),\n+\t\t\t\tspeed);\n       inv->cheap_address = false;\n     }\n "}, {"sha": "3500c4de715ada274466fd88b97116518cf6209e", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -137,7 +137,7 @@ shift_cost (bool speed_p, struct cost_rtxes *rtxes, enum rtx_code code,\n   PUT_MODE (rtxes->shift, mode);\n   PUT_MODE (rtxes->source, mode);\n   XEXP (rtxes->shift, 1) = GEN_INT (op1);\n-  return set_src_cost (rtxes->shift, speed_p);\n+  return set_src_cost (rtxes->shift, mode, speed_p);\n }\n \n /* For each X in the range [0, BITS_PER_WORD), set SPLITTING[X]\n@@ -241,7 +241,7 @@ compute_costs (bool speed_p, struct cost_rtxes *rtxes)\n       /* The only case here to check to see if moving the upper part with a\n \t zero is cheaper than doing the zext itself.  */\n       PUT_MODE (rtxes->source, word_mode);\n-      zext_cost = set_src_cost (rtxes->zext, speed_p);\n+      zext_cost = set_src_cost (rtxes->zext, twice_word_mode, speed_p);\n \n       if (LOG_COSTS)\n \tfprintf (stderr, \"%s %s: original cost %d, split cost %d + %d\\n\","}, {"sha": "1c76411c1420edc67e14ace15e020cdcdb65887c", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1361,8 +1361,8 @@ avoid_expensive_constant (machine_mode mode, optab binoptab,\n   if (mode != VOIDmode\n       && optimize\n       && CONSTANT_P (x)\n-      && (rtx_cost (x, optab_to_code (binoptab), opn, speed)\n-\t  > set_src_cost (x, speed)))\n+      && (rtx_cost (x, mode, optab_to_code (binoptab), opn, speed)\n+\t  > set_src_cost (x, mode, speed)))\n     {\n       if (CONST_INT_P (x))\n \t{\n@@ -4043,12 +4043,12 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n   /* If we are optimizing, force expensive constants into a register.  */\n   if (CONSTANT_P (x) && optimize\n-      && (rtx_cost (x, COMPARE, 0, optimize_insn_for_speed_p ())\n+      && (rtx_cost (x, mode, COMPARE, 0, optimize_insn_for_speed_p ())\n           > COSTS_N_INSNS (1)))\n     x = force_reg (mode, x);\n \n   if (CONSTANT_P (y) && optimize\n-      && (rtx_cost (y, COMPARE, 1, optimize_insn_for_speed_p ())\n+      && (rtx_cost (y, mode, COMPARE, 1, optimize_insn_for_speed_p ())\n           > COSTS_N_INSNS (1)))\n     y = force_reg (mode, y);\n \n@@ -8620,7 +8620,7 @@ lshift_cheap_p (bool speed_p)\n     {\n       rtx reg = gen_raw_REG (word_mode, 10000);\n       int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n-\t\t\t       speed_p);\n+\t\t\t       word_mode, speed_p);\n       cheap[speed_p] = cost < COSTS_N_INSNS (3);\n       init[speed_p] = true;\n     }"}, {"sha": "3db2c07224ad9f158b721e7b86084da46a661559", "filename": "gcc/postreload.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -292,7 +292,7 @@ reload_cse_simplify_set (rtx set, rtx_insn *insn)\n     old_cost = register_move_cost (GET_MODE (src),\n \t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n   else\n-    old_cost = set_src_cost (src, speed);\n+    old_cost = set_src_cost (src, GET_MODE (SET_DEST (set)), speed);\n \n   for (l = val->locs; l; l = l->next)\n     {\n@@ -327,15 +327,15 @@ reload_cse_simplify_set (rtx set, rtx_insn *insn)\n \t      this_rtx = immed_wide_int_const (result, word_mode);\n \t    }\n #endif\n-\t  this_cost = set_src_cost (this_rtx, speed);\n+\t  this_cost = set_src_cost (this_rtx, GET_MODE (SET_DEST (set)), speed);\n \t}\n       else if (REG_P (this_rtx))\n \t{\n #ifdef LOAD_EXTEND_OP\n \t  if (extend_op != UNKNOWN)\n \t    {\n \t      this_rtx = gen_rtx_fmt_e (extend_op, word_mode, this_rtx);\n-\t      this_cost = set_src_cost (this_rtx, speed);\n+\t      this_cost = set_src_cost (this_rtx, word_mode, speed);\n \t    }\n \t  else\n #endif\n@@ -578,10 +578,10 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \t\t      && TEST_BIT (preferred, j)\n \t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n \t\t      && (!CONST_INT_P (recog_data.operand[i])\n-\t\t\t  || (set_src_cost (recog_data.operand[i],\n+\t\t\t  || (set_src_cost (recog_data.operand[i], mode,\n \t\t\t\t\t    optimize_bb_for_speed_p\n \t\t\t\t\t     (BLOCK_FOR_INSN (insn)))\n-\t\t\t      > set_src_cost (testreg,\n+\t\t\t      > set_src_cost (testreg, mode,\n \t\t\t\t\t      optimize_bb_for_speed_p\n \t\t\t\t\t       (BLOCK_FOR_INSN (insn))))))\n \t\t    {\n@@ -914,12 +914,13 @@ try_replace_in_use (struct reg_use *use, rtx reg, rtx src)\n \t  && CONSTANT_P (XEXP (SET_SRC (new_set), 1)))\n \t{\n \t  rtx new_src;\n-\t  int old_cost = set_src_cost (SET_SRC (new_set), speed);\n+\t  machine_mode mode = GET_MODE (SET_DEST (new_set));\n+\t  int old_cost = set_src_cost (SET_SRC (new_set), mode, speed);\n \n \t  gcc_assert (rtx_equal_p (XEXP (SET_SRC (new_set), 0), reg));\n \t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg, src);\n \n-\t  if (set_src_cost (new_src, speed) <= old_cost\n+\t  if (set_src_cost (new_src, mode, speed) <= old_cost\n \t      && validate_change (use_insn, &SET_SRC (new_set),\n \t\t\t\t  new_src, 0))\n \t    return true;\n@@ -2017,7 +2018,7 @@ reload_cse_move2add (rtx_insn *first)\n \n \t\t\t  get_full_set_rtx_cost (set, &oldcst);\n \t\t\t  SET_SRC (set) = tem;\n-\t\t\t  get_full_set_src_cost (tem, &newcst);\n+\t\t\t  get_full_set_src_cost (tem, GET_MODE (reg), &newcst);\n \t\t\t  SET_SRC (set) = old_src;\n \t\t\t  costs_add_n_insns (&oldcst, 1);\n "}, {"sha": "cd607a0d48d2293c81b83566a4585ebd357f3e47", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -1640,7 +1640,9 @@ calculate_elim_costs_all_insns (void)\n \t\t    {\n \t\t      rtx t = eliminate_regs_1 (SET_SRC (set), VOIDmode, insn,\n \t\t\t\t\t\tfalse, true);\n-\t\t      int cost = set_src_cost (t, optimize_bb_for_speed_p (bb));\n+\t\t      machine_mode mode = GET_MODE (SET_DEST (set));\n+\t\t      int cost = set_src_cost (t, mode,\n+\t\t\t\t\t       optimize_bb_for_speed_p (bb));\n \t\t      int freq = REG_FREQ_FROM_BB (bb);\n \n \t\t      reg_equiv_init_cost[regno] = cost * freq;\n@@ -2512,7 +2514,8 @@ note_reg_elim_costly (const_rtx x, rtx insn)\n \t{\n \t  rtx t = reg_equiv_invariant (REGNO (x));\n \t  rtx new_rtx = eliminate_regs_1 (t, Pmode, insn, true, true);\n-\t  int cost = set_src_cost (new_rtx, optimize_bb_for_speed_p (elim_bb));\n+\t  int cost = set_src_cost (new_rtx, Pmode,\n+\t\t\t\t   optimize_bb_for_speed_p (elim_bb));\n \t  int freq = REG_FREQ_FROM_BB (elim_bb);\n \n \t  if (cost != 0)"}, {"sha": "4b2d85535f540425d090578cfe817b8564147339", "filename": "gcc/rtl.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2148,9 +2148,9 @@ wi::max_value (machine_mode mode, signop sgn)\n }\n \n extern void init_rtlanal (void);\n-extern int rtx_cost (rtx, enum rtx_code, int, bool);\n+extern int rtx_cost (rtx, machine_mode, enum rtx_code, int, bool);\n extern int address_cost (rtx, machine_mode, addr_space_t, bool);\n-extern void get_full_rtx_cost (rtx, enum rtx_code, int,\n+extern void get_full_rtx_cost (rtx, machine_mode, enum rtx_code, int,\n \t\t\t       struct full_rtx_costs *);\n extern unsigned int subreg_lsb (const_rtx);\n extern unsigned int subreg_lsb_1 (machine_mode, machine_mode,\n@@ -2179,43 +2179,6 @@ extern void update_address (struct address_info *);\n extern HOST_WIDE_INT get_index_scale (const struct address_info *);\n extern enum rtx_code get_index_code (const struct address_info *);\n \n-#ifndef GENERATOR_FILE\n-/* Return the cost of SET X.  SPEED_P is true if optimizing for speed\n-   rather than size.  */\n-\n-static inline int\n-set_rtx_cost (rtx x, bool speed_p)\n-{\n-  return rtx_cost (x, INSN, 4, speed_p);\n-}\n-\n-/* Like set_rtx_cost, but return both the speed and size costs in C.  */\n-\n-static inline void\n-get_full_set_rtx_cost (rtx x, struct full_rtx_costs *c)\n-{\n-  get_full_rtx_cost (x, INSN, 4, c);\n-}\n-\n-/* Return the cost of moving X into a register, relative to the cost\n-   of a register move.  SPEED_P is true if optimizing for speed rather\n-   than size.  */\n-\n-static inline int\n-set_src_cost (rtx x, bool speed_p)\n-{\n-  return rtx_cost (x, SET, 1, speed_p);\n-}\n-\n-/* Like set_src_cost, but return both the speed and size costs in C.  */\n-\n-static inline void\n-get_full_set_src_cost (rtx x, struct full_rtx_costs *c)\n-{\n-  get_full_rtx_cost (x, SET, 1, c);\n-}\n-#endif\n-\n /* 1 if RTX is a subreg containing a reg that is already known to be\n    sign- or zero-extended from the mode of the subreg to the mode of\n    the reg.  SUBREG_PROMOTED_UNSIGNED_P gives the signedness of the\n@@ -2647,6 +2610,43 @@ extern int currently_expanding_to_rtl;\n \n /* Generally useful functions.  */\n \n+#ifndef GENERATOR_FILE\n+/* Return the cost of SET X.  SPEED_P is true if optimizing for speed\n+   rather than size.  */\n+\n+static inline int\n+set_rtx_cost (rtx x, bool speed_p)\n+{\n+  return rtx_cost (x, VOIDmode, INSN, 4, speed_p);\n+}\n+\n+/* Like set_rtx_cost, but return both the speed and size costs in C.  */\n+\n+static inline void\n+get_full_set_rtx_cost (rtx x, struct full_rtx_costs *c)\n+{\n+  get_full_rtx_cost (x, VOIDmode, INSN, 4, c);\n+}\n+\n+/* Return the cost of moving X into a register, relative to the cost\n+   of a register move.  SPEED_P is true if optimizing for speed rather\n+   than size.  */\n+\n+static inline int\n+set_src_cost (rtx x, machine_mode mode, bool speed_p)\n+{\n+  return rtx_cost (x, mode, SET, 1, speed_p);\n+}\n+\n+/* Like set_src_cost, but return both the speed and size costs in C.  */\n+\n+static inline void\n+get_full_set_src_cost (rtx x, machine_mode mode, struct full_rtx_costs *c)\n+{\n+  get_full_rtx_cost (x, mode, SET, 1, c);\n+}\n+#endif\n+\n /* In explow.c */\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, machine_mode);\n extern rtx plus_constant (machine_mode, rtx, HOST_WIDE_INT, bool = false);"}, {"sha": "854d74183de4b6054d3f8c64cc1e13283838bbb0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -4026,7 +4026,8 @@ label_is_jump_target_p (const_rtx label, const rtx_insn *jump_insn)\n    be returned.  */\n \n int\n-rtx_cost (rtx x, enum rtx_code outer_code, int opno, bool speed)\n+rtx_cost (rtx x, machine_mode mode, enum rtx_code outer_code,\n+\t  int opno, bool speed)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -4037,9 +4038,12 @@ rtx_cost (rtx x, enum rtx_code outer_code, int opno, bool speed)\n   if (x == 0)\n     return 0;\n \n+  if (GET_MODE (x) != VOIDmode)\n+    mode = GET_MODE (x);\n+\n   /* A size N times larger than UNITS_PER_WORD likely needs N times as\n      many insns, taking N times as long.  */\n-  factor = GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD;\n+  factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n   if (factor == 0)\n     factor = 1;\n \n@@ -4069,7 +4073,8 @@ rtx_cost (rtx x, enum rtx_code outer_code, int opno, bool speed)\n     case SET:\n       /* A SET doesn't have a mode, so let's look at the SET_DEST to get\n \t the mode for the factor.  */\n-      factor = GET_MODE_SIZE (GET_MODE (SET_DEST (x))) / UNITS_PER_WORD;\n+      mode = GET_MODE (SET_DEST (x));\n+      factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n       if (factor == 0)\n \tfactor = 1;\n       /* Pass through.  */\n@@ -4086,12 +4091,12 @@ rtx_cost (rtx x, enum rtx_code outer_code, int opno, bool speed)\n       total = 0;\n       /* If we can't tie these modes, make this expensive.  The larger\n \t the mode, the more expensive it is.  */\n-      if (! MODES_TIEABLE_P (GET_MODE (x), GET_MODE (SUBREG_REG (x))))\n+      if (! MODES_TIEABLE_P (mode, GET_MODE (SUBREG_REG (x))))\n \treturn COSTS_N_INSNS (2 + factor);\n       break;\n \n     default:\n-      if (targetm.rtx_costs (x, code, outer_code, opno, &total, speed))\n+      if (targetm.rtx_costs (x, mode, outer_code, opno, &total, speed))\n \treturn total;\n       break;\n     }\n@@ -4102,10 +4107,10 @@ rtx_cost (rtx x, enum rtx_code outer_code, int opno, bool speed)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      total += rtx_cost (XEXP (x, i), code, i, speed);\n+      total += rtx_cost (XEXP (x, i), mode, code, i, speed);\n     else if (fmt[i] == 'E')\n       for (j = 0; j < XVECLEN (x, i); j++)\n-\ttotal += rtx_cost (XVECEXP (x, i, j), code, i, speed);\n+\ttotal += rtx_cost (XVECEXP (x, i, j), mode, code, i, speed);\n \n   return total;\n }\n@@ -4114,11 +4119,11 @@ rtx_cost (rtx x, enum rtx_code outer_code, int opno, bool speed)\n    costs for X, which is operand OPNO in an expression with code OUTER.  */\n \n void\n-get_full_rtx_cost (rtx x, enum rtx_code outer, int opno,\n+get_full_rtx_cost (rtx x, machine_mode mode, enum rtx_code outer, int opno,\n \t\t   struct full_rtx_costs *c)\n {\n-  c->speed = rtx_cost (x, outer, opno, true);\n-  c->size = rtx_cost (x, outer, opno, false);\n+  c->speed = rtx_cost (x, mode, outer, opno, true);\n+  c->size = rtx_cost (x, mode, outer, opno, false);\n }\n \n \f\n@@ -4146,7 +4151,7 @@ address_cost (rtx x, machine_mode mode, addr_space_t as, bool speed)\n int\n default_address_cost (rtx x, machine_mode, addr_space_t, bool speed)\n {\n-  return rtx_cost (x, MEM, 0, speed);\n+  return rtx_cost (x, Pmode, MEM, 0, speed);\n }\n \f\n \n@@ -5153,7 +5158,7 @@ insn_rtx_cost (rtx pat, bool speed)\n   else\n     return 0;\n \n-  cost = set_src_cost (SET_SRC (set), speed);\n+  cost = set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)), speed);\n   return cost > 0 ? cost : COSTS_N_INSNS (1);\n }\n "}, {"sha": "0901aafe25f722ecf2c9b4d1de34eac648403e0f", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2086,8 +2086,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t      coeff = immed_wide_int_const (coeff0 + coeff1, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n-\t      return set_src_cost (tem, speed) <= set_src_cost (orig, speed)\n-\t\t? tem : 0;\n+\t      return (set_src_cost (tem, mode, speed)\n+\t\t      <= set_src_cost (orig, mode, speed) ? tem : 0);\n \t    }\n \t}\n \n@@ -2261,8 +2261,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t      coeff = immed_wide_int_const (coeff0 + negcoeff1, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n-\t      return set_src_cost (tem, speed) <= set_src_cost (orig, speed)\n-\t\t? tem : 0;\n+\t      return (set_src_cost (tem, mode, speed)\n+\t\t      <= set_src_cost (orig, mode, speed) ? tem : 0);\n \t    }\n \t}\n "}, {"sha": "4edc209c46402212689ebfc28854cb07ff9d1f0e", "filename": "gcc/target.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -3390,7 +3390,7 @@ DEFHOOKPOD\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n-/* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n+/* Note that OUTER_CODE ought to be RTX_CODE, but that's\n    not necessarily defined at this point.  */\n DEFHOOK\n (rtx_costs,\n@@ -3404,8 +3404,8 @@ that @samp{GET_CODE (@var{y}) == @var{outer_code}} and such that\\n\\\n either (a) @samp{XEXP (@var{y}, @var{opno}) == @var{x}} or\\n\\\n (b) @samp{XVEC (@var{y}, @var{opno})} contains @var{x}.\\n\\\n \\n\\\n-@var{code} is @var{x}'s expression code---redundant, since it can be\\n\\\n-obtained with @code{GET_CODE (@var{x})}.\\n\\\n+@var{mode} is @var{x}'s machine mode, or for cases like @code{const_int} that\\n\\\n+do not have a mode, the mode in which @var{x} is used.\\n\\\n \\n\\\n In implementing this hook, you can use the construct\\n\\\n @code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast\\n\\\n@@ -3423,8 +3423,8 @@ size cost of an expression, again relative to @code{COSTS_N_INSNS}.\\n\\\n \\n\\\n The hook returns true when all subexpressions of @var{x} have been\\n\\\n processed, and false when @code{rtx_cost} should recurse.\",\n- bool, (rtx x, int code, int outer_code, int opno, int *total, bool speed),\n- hook_bool_rtx_int_int_int_intp_bool_false)\n+ bool, (rtx x, machine_mode mode, int outer_code, int opno, int *total, bool speed),\n+ hook_bool_rtx_mode_int_int_intp_bool_false)\n \n /* Compute the cost of X, used as an address.  Never called with\n    invalid addresses.  */"}, {"sha": "b022bd716b194d2024224c8f94b97451e02fa84f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -3272,7 +3272,7 @@ computation_cost (tree expr, bool speed)\n     cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type),\n \t\t\t  TYPE_ADDR_SPACE (type), speed);\n   else if (!REG_P (rslt))\n-    cost += set_src_cost (rslt, speed);\n+    cost += set_src_cost (rslt, TYPE_MODE (type), speed);\n \n   return cost;\n }"}, {"sha": "47a14bde2b28a3f544b61bc2bddc61796fbe7f0b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -2527,10 +2527,10 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t\t\t\t\t\t      GEN_INT (-m)), speed_p);\n \t      rtx r = immed_wide_int_const (mask, word_mode);\n \t      cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r),\n-\t\t\t\t\t speed_p);\n+\t\t\t\t\t word_mode, speed_p);\n \t      r = immed_wide_int_const (wi::lshift (mask, m), word_mode);\n \t      cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r),\n-\t\t\t\t\t speed_p);\n+\t\t\t\t\t word_mode, speed_p);\n \t      if (cost_diff > 0)\n \t\t{\n \t\t  mask = wi::lshift (mask, m);"}, {"sha": "81a93a2724b6aa458e2492e85b9a35b99210cb7f", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e548c9df071ecdb6f333601191a9396f2c17d1a7/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=e548c9df071ecdb6f333601191a9396f2c17d1a7", "patch": "@@ -363,9 +363,11 @@ emit_case_bit_tests (gswitch *swtch, tree index_expr,\n       for (i = 0; i < count; i++)\n \t{\n \t  rtx r = immed_wide_int_const (test[i].mask, word_mode);\n-\t  cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r), speed_p);\n+\t  cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r),\n+\t\t\t\t     word_mode, speed_p);\n \t  r = immed_wide_int_const (wi::lshift (test[i].mask, m), word_mode);\n-\t  cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r), speed_p);\n+\t  cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r),\n+\t\t\t\t     word_mode, speed_p);\n \t}\n       if (cost_diff > 0)\n \t{"}]}