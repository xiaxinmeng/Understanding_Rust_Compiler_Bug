{"sha": "41f9e675279abcc5fa9c669161ca0f18b9d02fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmOWU2NzUyNzlhYmNjNWZhOWM2NjkxNjFjYTBmMThiOWQwMmZkOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-24T20:45:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-24T20:45:37Z"}, "message": "runtime: Copy runtime_printf from other Go library.\n\nFrom-SVN: r187850", "tree": {"sha": "2e2c5c38c762ab77060394a05406ce80770fdb35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e2c5c38c762ab77060394a05406ce80770fdb35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41f9e675279abcc5fa9c669161ca0f18b9d02fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f9e675279abcc5fa9c669161ca0f18b9d02fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f9e675279abcc5fa9c669161ca0f18b9d02fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f9e675279abcc5fa9c669161ca0f18b9d02fd9/comments", "author": null, "committer": null, "parents": [{"sha": "86ba147f547e44230075efab78252c08bc8d8c2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ba147f547e44230075efab78252c08bc8d8c2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ba147f547e44230075efab78252c08bc8d8c2e"}], "stats": {"total": 310, "additions": 310, "deletions": 0}, "files": [{"sha": "3eafeb7fe16eaed2af1161eaa5605bf491c1c700", "filename": "libgo/runtime/print.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f9e675279abcc5fa9c669161ca0f18b9d02fd9/libgo%2Fruntime%2Fprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f9e675279abcc5fa9c669161ca0f18b9d02fd9/libgo%2Fruntime%2Fprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fprint.c?ref=41f9e675279abcc5fa9c669161ca0f18b9d02fd9", "patch": "@@ -0,0 +1,310 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stdarg.h>\n+#include \"runtime.h\"\n+\n+//static Lock debuglock;\n+\n+static void go_vprintf(const char*, va_list);\n+\n+// write to goroutine-local buffer if diverting output,\n+// or else standard error.\n+static void\n+gwrite(const void *v, int32 n)\n+{\n+\tG* g = runtime_g();\n+\n+\tif(g == nil || g->writebuf == nil) {\n+\t\truntime_write(2, v, n);\n+\t\treturn;\n+\t}\n+\t\n+\tif(g->writenbuf == 0)\n+\t\treturn;\n+\t\n+\tif(n > g->writenbuf)\n+\t\tn = g->writenbuf;\n+\truntime_memmove(g->writebuf, v, n);\n+\tg->writebuf += n;\n+\tg->writenbuf -= n;\n+}\n+\n+void\n+runtime_dump(byte *p, int32 n)\n+{\n+\tint32 i;\n+\n+\tfor(i=0; i<n; i++) {\n+\t\truntime_printpointer((byte*)(uintptr)(p[i]>>4));\n+\t\truntime_printpointer((byte*)(uintptr)(p[i]&0xf));\n+\t\tif((i&15) == 15)\n+\t\t\truntime_prints(\"\\n\");\n+\t\telse\n+\t\t\truntime_prints(\" \");\n+\t}\n+\tif(n & 15)\n+\t\truntime_prints(\"\\n\");\n+}\n+\n+void\n+runtime_prints(const char *s)\n+{\n+\tgwrite(s, runtime_findnull((const byte*)s));\n+}\n+\n+void\n+runtime_printf(const char *s, ...)\n+{\n+\tva_list va;\n+\n+\tva_start(va, s);\n+\tgo_vprintf(s, va);\n+\tva_end(va);\n+}\n+\n+// Very simple printf.  Only for debugging prints.\n+// Do not add to this without checking with Rob.\n+static void\n+go_vprintf(const char *s, va_list va)\n+{\n+\tconst char *p, *lp;\n+\n+\t//runtime_lock(&debuglock);\n+\n+\tlp = p = s;\n+\tfor(; *p; p++) {\n+\t\tif(*p != '%')\n+\t\t\tcontinue;\n+\t\tif(p > lp)\n+\t\t\tgwrite(lp, p-lp);\n+\t\tp++;\n+\t\tswitch(*p) {\n+\t\tcase 'a':\n+\t\t\truntime_printslice(va_arg(va, Slice));\n+\t\t\tbreak;\n+\t\tcase 'd':\n+\t\t\truntime_printint(va_arg(va, int32));\n+\t\t\tbreak;\n+\t\tcase 'D':\n+\t\t\truntime_printint(va_arg(va, int64));\n+\t\t\tbreak;\n+\t\tcase 'e':\n+\t\t\truntime_printeface(va_arg(va, Eface));\n+\t\t\tbreak;\n+\t\tcase 'f':\n+\t\t\truntime_printfloat(va_arg(va, float64));\n+\t\t\tbreak;\n+\t\tcase 'C':\n+\t\t\truntime_printcomplex(va_arg(va, __complex double));\n+\t\t\tbreak;\n+\t\tcase 'i':\n+\t\t\truntime_printiface(va_arg(va, Iface));\n+\t\t\tbreak;\n+\t\tcase 'p':\n+\t\t\truntime_printpointer(va_arg(va, void*));\n+\t\t\tbreak;\n+\t\tcase 's':\n+\t\t\truntime_prints(va_arg(va, char*));\n+\t\t\tbreak;\n+\t\tcase 'S':\n+\t\t\truntime_printstring(va_arg(va, String));\n+\t\t\tbreak;\n+\t\tcase 't':\n+\t\t\truntime_printbool(va_arg(va, int));\n+\t\t\tbreak;\n+\t\tcase 'U':\n+\t\t\truntime_printuint(va_arg(va, uint64));\n+\t\t\tbreak;\n+\t\tcase 'x':\n+\t\t\truntime_printhex(va_arg(va, uint32));\n+\t\t\tbreak;\n+\t\tcase 'X':\n+\t\t\truntime_printhex(va_arg(va, uint64));\n+\t\t\tbreak;\n+\t\t}\n+\t\tlp = p+1;\n+\t}\n+\tif(p > lp)\n+\t\tgwrite(lp, p-lp);\n+\n+\t//runtime_unlock(&debuglock);\n+}\n+\n+void\n+runtime_printpc(void *p __attribute__ ((unused)))\n+{\n+\truntime_prints(\"PC=\");\n+\truntime_printhex((uint64)runtime_getcallerpc(p));\n+}\n+\n+void\n+runtime_printbool(_Bool v)\n+{\n+\tif(v) {\n+\t\tgwrite(\"true\", 4);\n+\t\treturn;\n+\t}\n+\tgwrite(\"false\", 5);\n+}\n+\n+void\n+runtime_printfloat(double v)\n+{\n+\tbyte buf[20];\n+\tint32 e, s, i, n;\n+\tfloat64 h;\n+\n+\tif(runtime_isNaN(v)) {\n+\t\tgwrite(\"NaN\", 3);\n+\t\treturn;\n+\t}\n+\tif(runtime_isInf(v, 1)) {\n+\t\tgwrite(\"+Inf\", 4);\n+\t\treturn;\n+\t}\n+\tif(runtime_isInf(v, -1)) {\n+\t\tgwrite(\"-Inf\", 4);\n+\t\treturn;\n+\t}\n+\n+\tn = 7;\t// digits printed\n+\te = 0;\t// exp\n+\ts = 0;\t// sign\n+\tif(v != 0) {\n+\t\t// sign\n+\t\tif(v < 0) {\n+\t\t\tv = -v;\n+\t\t\ts = 1;\n+\t\t}\n+\n+\t\t// normalize\n+\t\twhile(v >= 10) {\n+\t\t\te++;\n+\t\t\tv /= 10;\n+\t\t}\n+\t\twhile(v < 1) {\n+\t\t\te--;\n+\t\t\tv *= 10;\n+\t\t}\n+\n+\t\t// round\n+\t\th = 5;\n+\t\tfor(i=0; i<n; i++)\n+\t\t\th /= 10;\n+\n+\t\tv += h;\n+\t\tif(v >= 10) {\n+\t\t\te++;\n+\t\t\tv /= 10;\n+\t\t}\n+\t}\n+\n+\t// format +d.dddd+edd\n+\tbuf[0] = '+';\n+\tif(s)\n+\t\tbuf[0] = '-';\n+\tfor(i=0; i<n; i++) {\n+\t\ts = v;\n+\t\tbuf[i+2] = s+'0';\n+\t\tv -= s;\n+\t\tv *= 10.;\n+\t}\n+\tbuf[1] = buf[2];\n+\tbuf[2] = '.';\n+\n+\tbuf[n+2] = 'e';\n+\tbuf[n+3] = '+';\n+\tif(e < 0) {\n+\t\te = -e;\n+\t\tbuf[n+3] = '-';\n+\t}\n+\n+\tbuf[n+4] = (e/100) + '0';\n+\tbuf[n+5] = (e/10)%10 + '0';\n+\tbuf[n+6] = (e%10) + '0';\n+\tgwrite(buf, n+7);\n+}\n+\n+void\n+runtime_printcomplex(__complex double v)\n+{\n+\tgwrite(\"(\", 1);\n+\truntime_printfloat(__builtin_creal(v));\n+\truntime_printfloat(__builtin_cimag(v));\n+\tgwrite(\"i)\", 2);\n+}\n+\n+void\n+runtime_printuint(uint64 v)\n+{\n+\tbyte buf[100];\n+\tint32 i;\n+\n+\tfor(i=nelem(buf)-1; i>0; i--) {\n+\t\tbuf[i] = v%10 + '0';\n+\t\tif(v < 10)\n+\t\t\tbreak;\n+\t\tv = v/10;\n+\t}\n+\tgwrite(buf+i, nelem(buf)-i);\n+}\n+\n+void\n+runtime_printint(int64 v)\n+{\n+\tif(v < 0) {\n+\t\tgwrite(\"-\", 1);\n+\t\tv = -v;\n+\t}\n+\truntime_printuint(v);\n+}\n+\n+void\n+runtime_printhex(uint64 v)\n+{\n+\tstatic const char *dig = \"0123456789abcdef\";\n+\tbyte buf[100];\n+\tint32 i;\n+\n+\ti=nelem(buf);\n+\tfor(; v>0; v/=16)\n+\t\tbuf[--i] = dig[v%16];\n+\tif(i == nelem(buf))\n+\t\tbuf[--i] = '0';\n+\tbuf[--i] = 'x';\n+\tbuf[--i] = '0';\n+\tgwrite(buf+i, nelem(buf)-i);\n+}\n+\n+void\n+runtime_printpointer(void *p)\n+{\n+\truntime_printhex((uint64)(uintptr)p);\n+}\n+\n+void\n+runtime_printstring(String v)\n+{\n+\t// extern uint32 runtime_maxstring;\n+\n+\t// if(v.len > runtime_maxstring) {\n+\t// \tgwrite(\"[invalid string]\", 16);\n+\t// \treturn;\n+\t// }\n+\tif(v.__length > 0)\n+\t\tgwrite(v.__data, v.__length);\n+}\n+\n+void\n+__go_print_space(void)\n+{\n+\tgwrite(\" \", 1);\n+}\n+\n+void\n+__go_print_nl(void)\n+{\n+\tgwrite(\"\\n\", 1);\n+}"}]}