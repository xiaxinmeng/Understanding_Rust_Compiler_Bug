{"sha": "7fb43006b28405ebf5309223e9d769b74008003e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZiNDMwMDZiMjg0MDVlYmY1MzA5MjIzZTlkNzY5Yjc0MDA4MDAzZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-01-25T19:09:40Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-01-25T19:09:40Z"}, "message": "re PR fortran/37577 ([meta-bug] change internal array descriptor format for better syntax, C interop TR, rank 15)\n\n2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37577\n\t* array.c (gfc_match_array_ref): If standard earlier than F2008\n\tit is an error if the reference dimension is greater than 7.\n\tlibgfortran.h : Increase GFC_MAX_DIMENSIONS to 15. Change the\n\tdtype masks and shifts accordingly.\n\t* trans-array.c (gfc_conv_descriptor_dtype): Use the dtype\n\ttype node to check the field.\n\t(gfc_conv_descriptor_dtype): Access the rank field of dtype.\n\t(duplicate_allocatable_coarray): Access the rank field of the\n\tdtype descriptor rather than the dtype itself.\n\t* trans-expr.c (get_scalar_to_descriptor_type): Store the type\n\tof 'scalar' on entry and use its TREE_TYPE if it is ARRAY_TYPE\n\t(ie. a character).\n\t(gfc_conv_procedure_call): Pass TREE_OPERAND (tmp,0) to\n\tget_scalar_to_descriptor_type if the actual expression is a\n\tconstant.\n\t(gfc_trans_structure_assign): Assign the rank directly to the\n\tdtype rank field.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_rank): Cast the result\n\tto default integer kind.\n\t(gfc_conv_intrinsic_sizeof): Obtain the element size from the\n\t'elem_len' field of the dtype.\n\t* trans-io.c (gfc_build_io_library_fndecls): Replace\n\tgfc_int4_type_node with dtype_type_node where necessary.\n\t(transfer_namelist_element): Use gfc_get_dtype_rank_type for\n\tscalars.\n\t* trans-types.c : Provide 'get_dtype_type_node' to acces the\n\tdtype_type_node and, if necessary, build it.\n\tThe maximum size of an array element is now determined by the\n\tmaximum value of size_t.\n\tUpdate the description of the array descriptor, including the\n\ttype def for the dtype_type.\n\t(gfc_get_dtype_rank_type): Build a constructor for the dtype.\n\tDistinguish RECORD_TYPEs that are BT_DERIVED or BT_CLASS.\n\t(gfc_get_array_descriptor_base): Change the type of the dtype\n\tfield to dtype_type_node.\n\t(gfc_get_array_descr_info): Get the offset to the rank field of\n\tthe dtype.\n\t* trans-types.h : Add a prototype for 'get_dtype_type_node ()'.\n\t* trans.h : Define the indices of the dtype fields.\n\n2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37577\n\t* gfortran.dg/coarray_18.f90: Allow dimension 15 for F2008.\n\t* gfortran.dg/coarray_lib_this_image_2.f90: Change 'array1' to\n\t'array01' in the tree dump comparison.\n\t* gfortran.dg/coarray_lib_token_4.f90: Likewise.\n\t* gfortran.dg/inline_sum_1.f90: Similar - allow two digits.\n\t* gfortran.dg/rank_1.f90: Allow dimension 15 for F2008.\n\n2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37577\n\t* caf/single.c (_gfortran_caf_failed_images): Access the 'type'\n\tand 'elem_len' fields of the dtype instead of the shifts.\n\t(_gfortran_caf_stopped_images): Likewise.\n\t* intrinsics/associated.c (associated): Compare the 'type' and\n\t'elem_len' fields instead of the dtype.\n\t* caf/date_and_time.c : Access the dtype fields rather using\n\tshifts and masks.\n\t* io/transfer.c (transfer_array ): Comment on item count.\n\t(set_nml_var,st_set_nml_var): Change dtype type and use fields.\n\t(st_set_nml_dtio_var): Likewise.\n\t* libgfortran.h : Change definition of GFC_ARRAY_DESCRIPTOR and\n\tadd a typedef for the dtype_type. Change the GFC_DTYPE_* macros\n\tto access the dtype fields.\n\nFrom-SVN: r257065", "tree": {"sha": "45de92d7d82dec6371a4d9bcbfb4845426c74cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45de92d7d82dec6371a4d9bcbfb4845426c74cba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fb43006b28405ebf5309223e9d769b74008003e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb43006b28405ebf5309223e9d769b74008003e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb43006b28405ebf5309223e9d769b74008003e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb43006b28405ebf5309223e9d769b74008003e/comments", "author": null, "committer": null, "parents": [{"sha": "09cf48c9de850797570dfafa6fa70d4caf9d6862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09cf48c9de850797570dfafa6fa70d4caf9d6862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09cf48c9de850797570dfafa6fa70d4caf9d6862"}], "stats": {"total": 382, "additions": 272, "deletions": 110}, "files": [{"sha": "d96ce8ec63a520cc22d9bc8fd42084a4c519328b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -1,3 +1,46 @@\n+2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37577\n+\t* array.c (gfc_match_array_ref): If standard earlier than F2008\n+\tit is an error if the reference dimension is greater than 7.\n+\tlibgfortran.h : Increase GFC_MAX_DIMENSIONS to 15. Change the\n+\tdtype masks and shifts accordingly.\n+\t* trans-array.c (gfc_conv_descriptor_dtype): Use the dtype\n+\ttype node to check the field.\n+\t(gfc_conv_descriptor_dtype): Access the rank field of dtype.\n+\t(duplicate_allocatable_coarray): Access the rank field of the\n+\tdtype descriptor rather than the dtype itself.\n+\t* trans-expr.c (get_scalar_to_descriptor_type): Store the type\n+\tof 'scalar' on entry and use its TREE_TYPE if it is ARRAY_TYPE\n+\t(ie. a character).\n+\t(gfc_conv_procedure_call): Pass TREE_OPERAND (tmp,0) to\n+\tget_scalar_to_descriptor_type if the actual expression is a\n+\tconstant.\n+\t(gfc_trans_structure_assign): Assign the rank directly to the\n+\tdtype rank field.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_rank): Cast the result\n+\tto default integer kind.\n+\t(gfc_conv_intrinsic_sizeof): Obtain the element size from the\n+\t'elem_len' field of the dtype.\n+\t* trans-io.c (gfc_build_io_library_fndecls): Replace\n+\tgfc_int4_type_node with dtype_type_node where necessary.\n+\t(transfer_namelist_element): Use gfc_get_dtype_rank_type for\n+\tscalars.\n+\t* trans-types.c : Provide 'get_dtype_type_node' to acces the\n+\tdtype_type_node and, if necessary, build it.\n+\tThe maximum size of an array element is now determined by the\n+\tmaximum value of size_t.\n+\tUpdate the description of the array descriptor, including the\n+\ttype def for the dtype_type.\n+\t(gfc_get_dtype_rank_type): Build a constructor for the dtype.\n+\tDistinguish RECORD_TYPEs that are BT_DERIVED or BT_CLASS.\n+\t(gfc_get_array_descriptor_base): Change the type of the dtype\n+\tfield to dtype_type_node.\n+\t(gfc_get_array_descr_info): Get the offset to the rank field of\n+\tthe dtype.\n+\t* trans-types.h : Add a prototype for 'get_dtype_type_node ()'.\n+\t* trans.h : Define the indices of the dtype fields.\n+\n 2018-23-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/83866"}, {"sha": "caa0b7fe65661290c8648aeac694dab90409f85f", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -197,6 +197,11 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n \t}\n     }\n \n+  if (ar->dimen >= 7\n+      && !gfc_notify_std (GFC_STD_F2008,\n+\t\t\t  \"Array reference at %C has more than 7 dimensions\"))\n+    return MATCH_ERROR;\n+\n   gfc_error (\"Array reference at %C cannot have more than %d dimensions\",\n \t     GFC_MAX_DIMENSIONS);\n   return MATCH_ERROR;"}, {"sha": "b7954a9dcd966bf9065805bb3eb8b7c857ef4c0f", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -150,15 +150,13 @@ typedef enum\n #define GFC_STDOUT_UNIT_NUMBER 6\n #define GFC_STDERR_UNIT_NUMBER 0\n \n+/* F2003 onward. For std < F2003, error caught in array.c(gfc_match_array_ref).  */\n+#define GFC_MAX_DIMENSIONS 15\n \n-/* FIXME: Increase to 15 for Fortran 2008. Also needs changes to\n-   GFC_DTYPE_RANK_MASK. See PR 36825.  */\n-#define GFC_MAX_DIMENSIONS 7\n-\n-#define GFC_DTYPE_RANK_MASK 0x07\n-#define GFC_DTYPE_TYPE_SHIFT 3\n-#define GFC_DTYPE_TYPE_MASK 0x38\n-#define GFC_DTYPE_SIZE_SHIFT 6\n+#define GFC_DTYPE_RANK_MASK 0x0F\n+#define GFC_DTYPE_TYPE_SHIFT 4\n+#define GFC_DTYPE_TYPE_MASK 0x70\n+#define GFC_DTYPE_SIZE_SHIFT 7\n \n /* Basic types.  BT_VOID is used by ISO C Binding so funcs like c_f_pointer\n    can take any arg with the pointer attribute as a param.  These are also"}, {"sha": "c16b8754fa3b3bf4dfc7e56491007b399a2b9945", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -239,7 +239,8 @@ gfc_conv_descriptor_dtype (tree desc)\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n-  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+  gcc_assert (field != NULL_TREE\n+\t      && TREE_TYPE (field) == get_dtype_type_node ());\n \n   return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t  desc, field, NULL_TREE);\n@@ -283,10 +284,11 @@ gfc_conv_descriptor_rank (tree desc)\n   tree dtype;\n \n   dtype = gfc_conv_descriptor_dtype (desc);\n-  tmp = build_int_cst (TREE_TYPE (dtype), GFC_DTYPE_RANK_MASK);\n-  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, TREE_TYPE (dtype),\n-\t\t\t dtype, tmp);\n-  return fold_convert (gfc_get_int_type (gfc_default_integer_kind), tmp);\n+  tmp = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (dtype)), GFC_DTYPE_RANK);\n+  gcc_assert (tmp!= NULL_TREE\n+\t      && TREE_TYPE (tmp) == signed_char_type_node);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t  dtype, tmp, NULL_TREE);\n }\n \n \n@@ -8205,7 +8207,7 @@ duplicate_allocatable_coarray (tree dest, tree dest_tok, tree src,\n   else\n     {\n       /* Set the rank or unitialized memory access may be reported.  */\n-      tmp = gfc_conv_descriptor_dtype (dest);\n+      tmp = gfc_conv_descriptor_rank (dest);\n       gfc_add_modify (&globalblock, tmp, build_int_cst (TREE_TYPE (tmp), rank));\n \n       if (rank)"}, {"sha": "f03aa18274d51d91d37476d2c1cafcdb56152ec5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -66,9 +66,10 @@ get_scalar_to_descriptor_type (tree scalar, symbol_attribute attr)\n tree\n gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n {\n-  tree desc, type;\n+  tree desc, type, etype;\n \n   type = get_scalar_to_descriptor_type (scalar, attr);\n+  etype = TREE_TYPE (scalar);\n   desc = gfc_create_var (type, \"desc\");\n   DECL_ARTIFICIAL (desc) = 1;\n \n@@ -81,8 +82,10 @@ gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n     }\n   if (!POINTER_TYPE_P (TREE_TYPE (scalar)))\n     scalar = gfc_build_addr_expr (NULL_TREE, scalar);\n+  else if (TREE_TYPE (etype) && TREE_CODE (TREE_TYPE (etype)) == ARRAY_TYPE)\n+    etype = TREE_TYPE (etype);\n   gfc_add_modify (&se->pre, gfc_conv_descriptor_dtype (desc),\n-\t\t  gfc_get_dtype (type));\n+\t\t  gfc_get_dtype_rank_type (0, etype));\n   gfc_conv_descriptor_data_set (&se->pre, desc, scalar);\n \n   /* Copy pointer address back - but only if it could have changed and\n@@ -5323,7 +5326,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    {\n \t\t      tmp = parmse.expr;\n \t\t      if (TREE_CODE (tmp) == ADDR_EXPR\n-\t\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (tmp, 0))))\n+\t\t\t   && (POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (tmp, 0)))\n+\t\t\t       || e->expr_type == EXPR_CONSTANT))\n \t\t\ttmp = TREE_OPERAND (tmp, 0);\n \t\t      parmse.expr = gfc_conv_scalar_to_descriptor (&parmse, tmp,\n \t\t\t\t\t\t\t\t   fsym->attr);\n@@ -7611,8 +7615,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)\n \t\trank = 1;\n \t      size = integer_zero_node;\n \t      desc = field;\n-\t      gfc_add_modify (&block, gfc_conv_descriptor_dtype (desc),\n-\t\t\t      build_int_cst (gfc_array_index_type, rank));\n+\t      gfc_add_modify (&block, gfc_conv_descriptor_rank (desc),\n+\t\t\t      build_int_cst (signed_char_type_node, rank));\n \t    }\n \t  else\n \t    {"}, {"sha": "af647c42668c3216078dbefea7bcccc2a86e8ed2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -2602,6 +2602,8 @@ gfc_conv_intrinsic_rank (gfc_se *se, gfc_expr *expr)\n   gfc_add_block_to_block (&se->post, &argse.post);\n \n   se->expr = gfc_conv_descriptor_rank (argse.expr);\n+  se->expr = fold_convert (gfc_get_int_type (gfc_default_integer_kind),\n+\t\t\t   se->expr);\n }\n \n \n@@ -6783,6 +6785,7 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n   tree lower;\n   tree upper;\n   tree byte_size;\n+  tree field;\n   int n;\n \n   gfc_init_se (&argse, NULL);\n@@ -6805,10 +6808,13 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n \t    ? GFC_DECL_SAVED_DESCRIPTOR (tmp) : tmp;\n       if (POINTER_TYPE_P (TREE_TYPE (tmp)))\n \ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n-      tmp = fold_convert (size_type_node, gfc_conv_descriptor_dtype (tmp));\n-      tmp = fold_build2_loc (input_location, RSHIFT_EXPR, TREE_TYPE (tmp), tmp,\n-\t\t\t     build_int_cst (TREE_TYPE (tmp),\n-\t\t\t\t\t    GFC_DTYPE_SIZE_SHIFT));\n+\n+      tmp = gfc_conv_descriptor_dtype (tmp);\n+      field = gfc_advance_chain (TYPE_FIELDS (get_dtype_type_node ()),\n+\t\t\t\t GFC_DTYPE_ELEM_LEN);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     tmp, field, NULL_TREE);\n+\n       byte_size = fold_convert (gfc_array_index_type, tmp);\n     }\n   else if (arg->ts.type == BT_CLASS)"}, {"sha": "021c788ba54099edc89b21b9d1a741c59e2c0232", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -478,12 +478,12 @@ gfc_build_io_library_fndecls (void)\n   iocall[IOCALL_SET_NML_VAL] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"st_set_nml_var\")), \".w.R\",\n \tvoid_type_node, 6, dt_parm_type, pvoid_type_node, pvoid_type_node,\n-\tgfc_int4_type_node, gfc_charlen_type_node, gfc_int4_type_node);\n+\tgfc_int4_type_node, gfc_charlen_type_node, get_dtype_type_node());\n \n   iocall[IOCALL_SET_NML_DTIO_VAL] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"st_set_nml_dtio_var\")), \".w.R\",\n \tvoid_type_node, 8, dt_parm_type, pvoid_type_node, pvoid_type_node,\n-\tgfc_int4_type_node, gfc_charlen_type_node, gfc_int4_type_node,\n+\tgfc_int4_type_node, gfc_charlen_type_node, get_dtype_type_node(),\n \tpvoid_type_node, pvoid_type_node);\n \n   iocall[IOCALL_SET_NML_VAL_DIM] = gfc_build_library_function_decl_with_spec (\n@@ -1662,7 +1662,6 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   tree dtio_proc = null_pointer_node;\n   tree vtable = null_pointer_node;\n   int n_dim;\n-  int itype;\n   int rank = 0;\n \n   gcc_assert (sym || c);\n@@ -1699,8 +1698,8 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n     }\n   else\n     {\n-      itype = ts->type;\n-      dtype = IARG (itype << GFC_DTYPE_TYPE_SHIFT);\n+      dt =  gfc_typenode_for_spec (ts);\n+      dtype = gfc_get_dtype_rank_type (0, dt);\n     }\n \n   /* Build up the arguments for the transfer call."}, {"sha": "fd25ce57c7fbdb6feeacafd417a847d3d0bce422", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -130,6 +130,47 @@ int gfc_size_kind;\n int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n \n+tree dtype_type_node = NULL_TREE;\n+\n+\n+/* Build the dtype_type_node if necessary.  */\n+tree get_dtype_type_node (void)\n+{\n+  tree field;\n+  tree dtype_node;\n+  tree *dtype_chain = NULL;\n+\n+  if (dtype_type_node == NULL_TREE)\n+    {\n+      dtype_node = make_node (RECORD_TYPE);\n+      TYPE_NAME (dtype_node) = get_identifier (\"dtype_type\");\n+      TYPE_NAMELESS (dtype_node) = 1;\n+      field = gfc_add_field_to_struct_1 (dtype_node,\n+\t\t\t\t\t get_identifier (\"elem_len\"),\n+\t\t\t\t\t size_type_node, &dtype_chain);\n+      TREE_NO_WARNING (field) = 1;\n+      field = gfc_add_field_to_struct_1 (dtype_node,\n+\t\t\t\t\t get_identifier (\"version\"),\n+\t\t\t\t\t integer_type_node, &dtype_chain);\n+      TREE_NO_WARNING (field) = 1;\n+      field = gfc_add_field_to_struct_1 (dtype_node,\n+\t\t\t\t\t get_identifier (\"rank\"),\n+\t\t\t\t\t signed_char_type_node, &dtype_chain);\n+      TREE_NO_WARNING (field) = 1;\n+      field = gfc_add_field_to_struct_1 (dtype_node,\n+\t\t\t\t\t get_identifier (\"type\"),\n+\t\t\t\t\t signed_char_type_node, &dtype_chain);\n+      TREE_NO_WARNING (field) = 1;\n+      field = gfc_add_field_to_struct_1 (dtype_node,\n+\t\t\t\t\t get_identifier (\"attribute\"),\n+\t\t\t\t\t short_integer_type_node, &dtype_chain);\n+      TREE_NO_WARNING (field) = 1;\n+      gfc_finish_type (dtype_node);\n+      TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (dtype_node)) = 1;\n+      dtype_type_node = dtype_node;\n+    }\n+  return dtype_type_node;\n+}\n \n bool\n gfc_check_any_c_kind (gfc_typespec *ts)\n@@ -1003,7 +1044,7 @@ gfc_init_types (void)\n      by the number of bits available to store this field in the array\n      descriptor.  */\n \n-  n = TYPE_PRECISION (gfc_array_index_type) - GFC_DTYPE_SIZE_SHIFT;\n+  n = TYPE_PRECISION (size_type_node);\n   gfc_max_array_element_size\n     = wide_int_to_tree (size_type_node,\n \t\t\twi::mask (n, UNSIGNED,\n@@ -1255,12 +1296,21 @@ gfc_get_element_type (tree type)\n \n     struct gfc_array_descriptor\n     {\n-      array *data\n+      array *data;\n       index offset;\n-      index dtype;\n+      struct dtype_type dtype;\n       struct descriptor_dimension dimension[N_DIM];\n     }\n \n+    struct dtype_type\n+    {\n+      size_t elem_len;\n+      int version;\n+      signed char rank;\n+      signed char type;\n+      signed short attribute;\n+    }\n+\n     struct descriptor_dimension\n     {\n       index stride;\n@@ -1277,11 +1327,6 @@ gfc_get_element_type (tree type)\n    are gfc_array_index_type and the data node is a pointer to the\n    data.  See below for the handling of character types.\n \n-   The dtype member is formatted as follows:\n-    rank = dtype & GFC_DTYPE_RANK_MASK // 3 bits\n-    type = (dtype & GFC_DTYPE_TYPE_MASK) >> GFC_DTYPE_TYPE_SHIFT // 3 bits\n-    size = dtype >> GFC_DTYPE_SIZE_SHIFT\n-\n    I originally used nested ARRAY_TYPE nodes to represent arrays, but\n    this generated poor code for assumed/deferred size arrays.  These\n    require use of PLACEHOLDER_EXPR/WITH_RECORD_EXPR, which isn't part\n@@ -1468,9 +1513,10 @@ gfc_get_dtype_rank_type (int rank, tree etype)\n {\n   tree size;\n   int n;\n-  HOST_WIDE_INT i;\n   tree tmp;\n   tree dtype;\n+  tree field;\n+  vec<constructor_elt, va_gc> *v = NULL;\n \n   switch (TREE_CODE (etype))\n     {\n@@ -1490,51 +1536,49 @@ gfc_get_dtype_rank_type (int rank, tree etype)\n       n = BT_COMPLEX;\n       break;\n \n-    /* We will never have arrays of arrays.  */\n     case RECORD_TYPE:\n-      n = BT_DERIVED;\n+      if (GFC_CLASS_TYPE_P (etype))\n+\tn = BT_CLASS;\n+      else\n+\tn = BT_DERIVED;\n       break;\n \n+    /* We will never have arrays of arrays.  */\n     case ARRAY_TYPE:\n       n = BT_CHARACTER;\n       break;\n \n     case POINTER_TYPE:\n       n = BT_ASSUMED;\n-      break;\n+    break;\n \n     default:\n       /* TODO: Don't do dtype for temporary descriptorless arrays.  */\n       /* We can strange array types for temporary arrays.  */\n       return gfc_index_zero_node;\n     }\n \n-  gcc_assert (rank <= GFC_DTYPE_RANK_MASK);\n   size = TYPE_SIZE_UNIT (etype);\n+  if (n == BT_CHARACTER && size == NULL_TREE)\n+    size = TYPE_SIZE_UNIT (TREE_TYPE (etype));\n \n-  i = rank | (n << GFC_DTYPE_TYPE_SHIFT);\n-  if (size && INTEGER_CST_P (size))\n-    {\n-      if (tree_int_cst_lt (gfc_max_array_element_size, size))\n-\tgfc_fatal_error (\"Array element size too big at %C\");\n+  tmp = get_dtype_type_node ();\n+  field = gfc_advance_chain (TYPE_FIELDS (tmp),\n+\t\t\t     GFC_DTYPE_ELEM_LEN);\n+  CONSTRUCTOR_APPEND_ELT (v, field,\n+\t\t\t  fold_convert (TREE_TYPE (field), size));\n \n-      i += TREE_INT_CST_LOW (size) << GFC_DTYPE_SIZE_SHIFT;\n-    }\n-  dtype = build_int_cst (gfc_array_index_type, i);\n+  field = gfc_advance_chain (TYPE_FIELDS (dtype_type_node),\n+\t\t\t     GFC_DTYPE_RANK);\n+  CONSTRUCTOR_APPEND_ELT (v, field,\n+\t\t\t  build_int_cst (TREE_TYPE (field), rank));\n \n-  if (size && !INTEGER_CST_P (size))\n-    {\n-      tmp = build_int_cst (gfc_array_index_type, GFC_DTYPE_SIZE_SHIFT);\n-      tmp  = fold_build2_loc (input_location, LSHIFT_EXPR,\n-\t\t\t      gfc_array_index_type,\n-\t\t\t      fold_convert (gfc_array_index_type, size), tmp);\n-      dtype = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       tmp, dtype);\n-    }\n-  /* If we don't know the size we leave it as zero.  This should never happen\n-     for anything that is actually used.  */\n-  /* TODO: Check this is actually true, particularly when repacking\n-     assumed size parameters.  */\n+  field = gfc_advance_chain (TYPE_FIELDS (dtype_type_node),\n+\t\t\t     GFC_DTYPE_TYPE);\n+  CONSTRUCTOR_APPEND_ELT (v, field,\n+\t\t\t  build_int_cst (TREE_TYPE (field), n));\n+\n+  dtype = build_constructor (tmp, v);\n \n   return dtype;\n }\n@@ -1820,7 +1864,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n   /* Add the dtype component.  */\n   decl = gfc_add_field_to_struct_1 (fat_type,\n \t\t\t\t    get_identifier (\"dtype\"),\n-\t\t\t\t    gfc_array_index_type, &chain);\n+\t\t\t\t    get_dtype_type_node (), &chain);\n   TREE_NO_WARNING (decl) = 1;\n \n   /* Add the span component.  */\n@@ -3232,6 +3276,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   tree etype, ptype, t, base_decl;\n   tree data_off, dim_off, dtype_off, dim_size, elem_size;\n   tree lower_suboff, upper_suboff, stride_suboff;\n+  tree dtype, field, rank_off;\n \n   if (! GFC_DESCRIPTOR_TYPE_P (type))\n     {\n@@ -3313,11 +3358,15 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n       t = base_decl;\n       if (!integer_zerop (dtype_off))\n \tt = fold_build_pointer_plus (t, dtype_off);\n+      dtype = TYPE_MAIN_VARIANT (get_dtype_type_node ());\n+      field = gfc_advance_chain (TYPE_FIELDS (dtype), GFC_DTYPE_RANK);\n+      rank_off = byte_position (field);\n+      if (!integer_zerop (dtype_off))\n+\tt = fold_build_pointer_plus (t, rank_off);\n+\n       t = build1 (NOP_EXPR, build_pointer_type (gfc_array_index_type), t);\n       t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n-      info->rank = build2 (BIT_AND_EXPR, gfc_array_index_type, t,\n-\t\t\t   build_int_cst (gfc_array_index_type,\n-\t\t\t\t\t  GFC_DTYPE_RANK_MASK));\n+      info->rank = t;\n       t = build0 (PLACEHOLDER_EXPR, TREE_TYPE (dim_off));\n       t = size_binop (MULT_EXPR, t, dim_size);\n       dim_off = build2 (PLUS_EXPR, TREE_TYPE (dim_off), t, dim_off);"}, {"sha": "197b173f0412c40b6ef3105b888fb41bcdf1c169", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -73,6 +73,7 @@ void gfc_init_kinds (void);\n void gfc_init_types (void);\n void gfc_init_c_interop_kinds (void);\n \n+tree get_dtype_type_node (void);\n tree gfc_get_int_type (int);\n tree gfc_get_real_type (int);\n tree gfc_get_complex_type (int);"}, {"sha": "35e1bd28379265b26a9f332a418fe12659140d44", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -914,6 +914,12 @@ extern GTY(()) tree gfor_fndecl_ieee_procedure_exit;\n /* gfortran-specific declaration information, the _CONT versions denote\n    arrays with CONTIGUOUS attribute.  */\n \n+#define GFC_DTYPE_ELEM_LEN 0\n+#define GFC_DTYPE_VERSION 1\n+#define GFC_DTYPE_RANK 2\n+#define GFC_DTYPE_TYPE 3\n+#define GFC_DTYPE_ATTRIBUTE 4\n+\n enum gfc_array_kind\n {\n   GFC_ARRAY_UNKNOWN,"}, {"sha": "ff91f1e670157626e47e8fc096f9146e190998d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -1,3 +1,13 @@\n+2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37577\n+\t* gfortran.dg/coarray_18.f90: Allow dimension 15 for F2008.\n+\t* gfortran.dg/coarray_lib_this_image_2.f90: Change 'array1' to\n+\t'array01' in the tree dump comparison.\n+\t* gfortran.dg/coarray_lib_token_4.f90: Likewise.\n+\t* gfortran.dg/inline_sum_1.f90: Similar - allow two digits.\n+\t* gfortran.dg/rank_1.f90: Allow dimension 15 for F2008.\n+\n 2018-01-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR middle-end/83055"}, {"sha": "1e80df986e8d9f6d51de556f4fd8846bf2148f7c", "filename": "gcc/testsuite/gfortran.dg/coarray_18.f90", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_18.f90?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -5,8 +5,7 @@\n ! dimensions (normal + codimensions).\n !\n ! Fortran 2008 allows (co)arrays with 15 ranks\n-! Currently, gfortran only supports 7, cf. PR 37577\n-! Thus, the program is valid Fortran 2008 ...\n+! Previously gfortran only supported 7, cf. PR 37577\n !\n ! See also general coarray PR 18918\n !\n@@ -19,14 +18,20 @@ program ar\n   integer :: ic(2)[*]\n   integer :: id(2,2)[2,*]\n   integer :: ie(2,2,2)[2,2,*]\n-  integer :: ig(2,2,2,2)[2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: ih(2,2,2,2,2)[2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: ij(2,2,2,2,2,2)[2,2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: ik(2,2,2,2,2,2,2)[2,2,2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: il[2,2,2,2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: im[2,2,2,2,2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: in[2,2,2,2,2,2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n-  integer :: io[2,2,2,2,2,2,2,2,2,2,*] ! { dg-error \"has more than 7 dimensions\" }\n+! Previously, these would give errors.\n+  integer :: ig(2,2,2,2)[2,2,2,*]\n+  integer :: ih(2,2,2,2,2)[2,2,2,2,*]\n+  integer :: ij(2,2,2,2,2,2)[2,2,2,2,2,*]\n+  integer :: ik(2,2,2,2,2,2,2)[2,2,2,2,2,2,*]\n+  integer :: il[2,2,2,2,2,2,2,*] \n+  integer :: im[2,2,2,2,2,2,2,2,*]\n+  integer :: in[2,2,2,2,2,2,2,2,2,*]\n+  integer :: io[2,2,2,2,2,2,2,2,2,2,*]\n+! Now with max dimensions 15.....\n+  integer :: ip(2,2,2,2,2,2,2,2)[2,2,2,2,2,2,2,*] ! { dg-error \"has more than 15 dimensions\" }\n+  integer :: iq[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,*] ! { dg-error \"has more than 15 dimensions\" }\n+! Check a non-coarray\n+  integer :: ir(2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2) ! { dg-error \"has more than 15 dimensions\" }\n    real :: x2(2,2,4)[2,*]\n    complex :: c2(4,2)[2,*]\n    double precision :: d2(1,5,9)[2,*]"}, {"sha": "7b44c73211bfef6c12a212a25ed77c57d6793895", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_this_image_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_this_image_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_this_image_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_this_image_2.f90?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -16,7 +16,7 @@ subroutine bar(x)\n   end subroutine bar\n end\n \n-! { dg-final { scan-tree-dump-times \"bar \\\\(struct array1_real\\\\(kind=4\\\\) & restrict x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"bar \\\\(struct array01_real\\\\(kind=4\\\\) & restrict x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"mylcobound = 5;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"parm...dim\\\\\\[1\\\\\\].lbound = 5;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"myucobound =\\[^\\n\\r\\]* parm...dim\\\\\\[1\\\\\\].lbound \\\\+ \\[^\\n\\r\\]*_gfortran_caf_num_images \\\\(0, -1\\\\).? \\\\+ -?\\[0-9\\]+\\\\);\" 1 \"original\" } }"}, {"sha": "b09552a7f0320d1830d8f07d00ddaab78bd6ab82", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_token_4.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_4.f90?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -35,9 +35,9 @@ end program test_caf\n \n ! { dg-final { scan-tree-dump-times \"expl \\\\(integer\\\\(kind=4\\\\).0:. . restrict z, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n !\n-! { dg-final { scan-tree-dump-times \"bar \\\\(struct array1_integer\\\\(kind=4\\\\) & restrict y, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"bar \\\\(struct array01_integer\\\\(kind=4\\\\) & restrict y, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n !\n-! { dg-final { scan-tree-dump-times \"foo \\\\(struct array1_integer\\\\(kind=4\\\\) & restrict x, struct array1_integer\\\\(kind=4\\\\) & restrict y, integer\\\\(kind=4\\\\) & restrict test, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo \\\\(struct array01_integer\\\\(kind=4\\\\) & restrict x, struct array01_integer\\\\(kind=4\\\\) & restrict y, integer\\\\(kind=4\\\\) & restrict test, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n !\n ! { dg-final { scan-tree-dump-times \"bar \\\\(&parm.\\[0-9\\]+, caf_token.\\[0-9\\]+, \\\\(\\\\(integer\\\\(kind=.\\\\)\\\\) parm.\\[0-9\\]+.data - \\\\(integer\\\\(kind=.\\\\)\\\\) x.\\[0-9\\]+\\\\) \\\\+ caf_offset.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n !"}, {"sha": "bff01bcbf319fd90a0c21b35c2761c4a2ba3e4db", "filename": "gcc/testsuite/gfortran.dg/inline_sum_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_1.f90?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -188,6 +188,6 @@ elemental subroutine tes (i, o)\n     o = i\n   end subroutine tes\n end\n-! { dg-final { scan-tree-dump-times \"struct array._integer\\\\(kind=4\\\\) atmp\" 13 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"struct array.._integer\\\\(kind=4\\\\) atmp\" 13 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"struct array\\[^\\\\n\\]*atmp\" 13 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_sum_\" 0 \"original\" } }"}, {"sha": "3467faded2bd637f658b9fd4eab011dded2158e1", "filename": "gcc/testsuite/gfortran.dg/rank_1.f90", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Frank_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/gcc%2Ftestsuite%2Fgfortran.dg%2Frank_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frank_1.f90?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -4,7 +4,6 @@\n ! Fortran < 2008 allows 7  dimensions\n ! Fortran   2008 allows 15 dimensions (including co-array ranks)\n !\n-! FIXME: Rank patch was reverted because of PR 36825.\n-integer :: a(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) ! { dg-error \"has more than 7 dimensions\" }\n-integer :: b(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) ! { dg-error \"has more than 7 dimensions\" }\n+integer :: a(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)\n+integer :: b(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) ! { dg-error \"has more than 15 dimensions\" }\n end"}, {"sha": "bd12b5d12bfc56fcbe2dec8d944f48e761bf231d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -1,3 +1,20 @@\n+2018-25-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37577\n+\t* caf/single.c (_gfortran_caf_failed_images): Access the 'type'\n+\tand 'elem_len' fields of the dtype instead of the shifts.\n+\t(_gfortran_caf_stopped_images): Likewise.\n+\t* intrinsics/associated.c (associated): Compare the 'type' and\n+\t'elem_len' fields instead of the dtype.\n+\t* caf/date_and_time.c : Access the dtype fields rather using\n+\tshifts and masks.\n+\t* io/transfer.c (transfer_array ): Comment on item count.\n+\t(set_nml_var,st_set_nml_var): Change dtype type and use fields.\n+\t(st_set_nml_dtio_var): Likewise.\n+\t* libgfortran.h : Change definition of GFC_ARRAY_DESCRIPTOR and\n+\tadd a typedef for the dtype_type. Change the GFC_DTYPE_* macros\n+\tto access the dtype fields.\n+\n 2018-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/54613"}, {"sha": "bead09a386f69043af6f89b83a34f31b8c82361e", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -332,8 +332,8 @@ _gfortran_caf_failed_images (gfc_descriptor_t *array,\n   int local_kind = kind != NULL ? *kind : 4;\n \n   array->base_addr = NULL;\n-  array->dtype = ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT)\n-\t\t  | (local_kind << GFC_DTYPE_SIZE_SHIFT));\n+  array->dtype.type = BT_INTEGER;\n+  array->dtype.elem_len = local_kind;\n    /* Setting lower_bound higher then upper_bound is what the compiler does to\n       indicate an empty array.  */\n   array->dim[0].lower_bound = 0;\n@@ -354,8 +354,8 @@ _gfortran_caf_stopped_images (gfc_descriptor_t *array,\n   int local_kind = kind != NULL ? *kind : 4;\n \n   array->base_addr = NULL;\n-  array->dtype =  ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT)\n-\t\t   | (local_kind << GFC_DTYPE_SIZE_SHIFT));\n+  array->dtype.type =  BT_INTEGER;\n+  array->dtype.elem_len =  local_kind;\n   /* Setting lower_bound higher then upper_bound is what the compiler does to\n      indicate an empty array.  */\n   array->dim[0].lower_bound = 0;"}, {"sha": "08a7412ba9721dca6c1657ddfc6adcd3999c3148", "filename": "libgfortran/intrinsics/associated.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fintrinsics%2Fassociated.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fintrinsics%2Fassociated.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fassociated.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -37,7 +37,9 @@ associated (const gfc_array_void *pointer, const gfc_array_void *target)\n     return 0;\n   if (GFC_DESCRIPTOR_DATA (pointer) != GFC_DESCRIPTOR_DATA (target))\n     return 0;\n-  if (GFC_DESCRIPTOR_DTYPE (pointer) != GFC_DESCRIPTOR_DTYPE (target))\n+  if (GFC_DESCRIPTOR_DTYPE (pointer).elem_len != GFC_DESCRIPTOR_DTYPE (target).elem_len)\n+    return 0;\n+  if (GFC_DESCRIPTOR_DTYPE (pointer).type != GFC_DESCRIPTOR_DTYPE (target).type)\n     return 0;\n \n   rank = GFC_DESCRIPTOR_RANK (pointer);"}, {"sha": "a493b448b6a376620eab24621bc88899578c82ca", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -270,10 +270,9 @@ secnds (GFC_REAL_4 *x)\n   /* Make the INTEGER*4 array for passing to date_and_time.  */\n   gfc_array_i4 *avalues = xmalloc (sizeof (gfc_array_i4));\n   avalues->base_addr = &values[0];\n-  GFC_DESCRIPTOR_DTYPE (avalues) = ((BT_REAL << GFC_DTYPE_TYPE_SHIFT)\n-\t\t\t\t        & GFC_DTYPE_TYPE_MASK) +\n-\t\t\t\t    (4 << GFC_DTYPE_SIZE_SHIFT);\n-\n+  GFC_DESCRIPTOR_DTYPE (avalues).type = BT_REAL;\n+  GFC_DESCRIPTOR_DTYPE (avalues).elem_len = 4;\n+  GFC_DESCRIPTOR_DTYPE (avalues).rank = 1;\n   GFC_DIMENSION_SET(avalues->dim[0], 0, 7, 1);\n \n   date_and_time (NULL, NULL, NULL, avalues, 0, 0, 0);"}, {"sha": "8bc828c02146f8183013627347bdc62c83f04c49", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -2406,13 +2406,16 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n   char *data;\n   bt iotype;\n \n+  /* Adjust item_count before emitting error message.  */\n+ \n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n   iotype = (bt) GFC_DESCRIPTOR_TYPE (desc);\n   size = iotype == BT_CHARACTER ? (index_type) charlen : GFC_DESCRIPTOR_SIZE (desc);\n \n   rank = GFC_DESCRIPTOR_RANK (desc);\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -4208,7 +4211,7 @@ st_wait (st_parameter_wait *wtp __attribute__((unused)))\n static void\n set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n \t     GFC_INTEGER_4 len, gfc_charlen_type string_length,\n-\t     GFC_INTEGER_4 dtype, void *dtio_sub, void *vtable)\n+\t     dtype_type dtype, void *dtio_sub, void *vtable)\n {\n   namelist_info *t1 = NULL;\n   namelist_info *nml;\n@@ -4227,9 +4230,9 @@ set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n   nml->len = (int) len;\n   nml->string_length = (index_type) string_length;\n \n-  nml->var_rank = (int) (dtype & GFC_DTYPE_RANK_MASK);\n-  nml->size = (index_type) (dtype >> GFC_DTYPE_SIZE_SHIFT);\n-  nml->type = (bt) ((dtype & GFC_DTYPE_TYPE_MASK) >> GFC_DTYPE_TYPE_SHIFT);\n+  nml->var_rank = (int) (dtype.rank);\n+  nml->size = (index_type) (dtype.elem_len);\n+  nml->type = (bt) (dtype.type);\n \n   if (nml->var_rank > 0)\n     {\n@@ -4259,13 +4262,13 @@ set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n }\n \n extern void st_set_nml_var (st_parameter_dt *dtp, void *, char *,\n-\t\t\t    GFC_INTEGER_4, gfc_charlen_type, GFC_INTEGER_4);\n+\t\t\t    GFC_INTEGER_4, gfc_charlen_type, dtype_type);\n export_proto(st_set_nml_var);\n \n void\n st_set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n \t\tGFC_INTEGER_4 len, gfc_charlen_type string_length,\n-\t\tGFC_INTEGER_4 dtype)\n+\t\tdtype_type dtype)\n {\n   set_nml_var (dtp, var_addr, var_name, len, string_length,\n \t       dtype, NULL, NULL);\n@@ -4275,15 +4278,15 @@ st_set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n /* Essentially the same as previous but carrying the dtio procedure\n    and the vtable as additional arguments.  */\n extern void st_set_nml_dtio_var (st_parameter_dt *dtp, void *, char *,\n-\t\t\t\t GFC_INTEGER_4, gfc_charlen_type, GFC_INTEGER_4,\n+\t\t\t\t GFC_INTEGER_4, gfc_charlen_type, dtype_type,\n \t\t\t\t void *, void *);\n export_proto(st_set_nml_dtio_var);\n \n \n void\n st_set_nml_dtio_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n \t\t     GFC_INTEGER_4 len, gfc_charlen_type string_length,\n-\t\t     GFC_INTEGER_4 dtype, void *dtio_sub, void *vtable)\n+\t\t     dtype_type dtype, void *dtio_sub, void *vtable)\n {\n   set_nml_var (dtp, var_addr, var_name, len, string_length,\n \t       dtype, dtio_sub, vtable);"}, {"sha": "80580a91082878cb973deedec194f9afa02bd837", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb43006b28405ebf5309223e9d769b74008003e/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=7fb43006b28405ebf5309223e9d769b74008003e", "patch": "@@ -327,14 +327,23 @@ typedef struct descriptor_dimension\n   index_type lower_bound;\n   index_type _ubound;\n }\n-\n descriptor_dimension;\n \n+typedef struct dtype_type\n+{\n+  size_t elem_len;\n+  int version;\n+  signed char rank;\n+  signed char type;\n+  signed short attribute;\n+}\n+dtype_type;\n+\n #define GFC_ARRAY_DESCRIPTOR(r, type) \\\n struct {\\\n   type *base_addr;\\\n   size_t offset;\\\n-  index_type dtype;\\\n+  dtype_type dtype;\\\n   index_type span;\\\n   descriptor_dimension dim[r];\\\n }\n@@ -375,10 +384,9 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_16) gfc_array_l16;\n typedef gfc_array_i1 gfc_array_s1;\n typedef gfc_array_i4 gfc_array_s4;\n \n-#define GFC_DESCRIPTOR_RANK(desc) ((desc)->dtype & GFC_DTYPE_RANK_MASK)\n-#define GFC_DESCRIPTOR_TYPE(desc) (((desc)->dtype & GFC_DTYPE_TYPE_MASK) \\\n-                                   >> GFC_DTYPE_TYPE_SHIFT)\n-#define GFC_DESCRIPTOR_SIZE(desc) ((desc)->dtype >> GFC_DTYPE_SIZE_SHIFT)\n+#define GFC_DESCRIPTOR_RANK(desc) ((desc)->dtype.rank)\n+#define GFC_DESCRIPTOR_TYPE(desc) ((desc)->dtype.type)\n+#define GFC_DESCRIPTOR_SIZE(desc) ((desc)->dtype.elem_len)\n #define GFC_DESCRIPTOR_DATA(desc) ((desc)->base_addr)\n #define GFC_DESCRIPTOR_DTYPE(desc) ((desc)->dtype)\n \n@@ -411,18 +419,24 @@ typedef gfc_array_i4 gfc_array_s4;\n #define GFC_DTYPE_SIZE_MASK (-((index_type) 1 << GFC_DTYPE_SIZE_SHIFT))\n #define GFC_DTYPE_TYPE_SIZE_MASK (GFC_DTYPE_SIZE_MASK | GFC_DTYPE_TYPE_MASK)\n \n-#define GFC_DTYPE_TYPE_SIZE(desc) ((desc)->dtype & GFC_DTYPE_TYPE_SIZE_MASK)\n+#define GFC_DTYPE_TYPE_SIZE(desc) (( ((desc)->dtype.type << GFC_DTYPE_TYPE_SHIFT) \\\n+    | ((desc)->dtype.elem_len << GFC_DTYPE_SIZE_SHIFT) ) & GFC_DTYPE_TYPE_SIZE_MASK)\n \n /* Macros to set size and type information.  */\n \n #define GFC_DTYPE_COPY(a,b) do { (a)->dtype = (b)->dtype; } while(0)\n #define GFC_DTYPE_COPY_SETRANK(a,b,n) \\\n   do { \\\n-  (a)->dtype = (((b)->dtype & ~GFC_DTYPE_RANK_MASK) | n ); \\\n+  (a)->dtype.rank = ((b)->dtype.rank | n ); \\\n   } while (0)\n \n-#define GFC_DTYPE_IS_UNSET(a) (unlikely((a)->dtype == 0))\n-#define GFC_DTYPE_CLEAR(a) do { (a)->dtype = 0; } while(0)\n+#define GFC_DTYPE_IS_UNSET(a) (unlikely((a)->dtype.elem_len == 0))\n+#define GFC_DTYPE_CLEAR(a) do { (a)->dtype.elem_len = 0; \\\n+\t\t\t\t(a)->dtype.version = 0; \\\n+\t\t\t\t(a)->dtype.rank = 0; \\\n+\t\t\t\t(a)->dtype.type = 0; \\\n+\t\t\t\t(a)->dtype.attribute = 0; \\\n+} while(0)\n \n #define GFC_DTYPE_INTEGER_1 ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\\n    | (sizeof(GFC_INTEGER_1) << GFC_DTYPE_SIZE_SHIFT))"}]}