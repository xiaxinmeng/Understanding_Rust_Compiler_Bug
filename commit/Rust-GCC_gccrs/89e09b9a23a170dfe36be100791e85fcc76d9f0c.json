{"sha": "89e09b9a23a170dfe36be100791e85fcc76d9f0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllMDliOWEyM2ExNzBkZmUzNmJlMTAwNzkxZTg1ZmNjNzZkOWYwYw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-07T15:43:16Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-07T15:43:16Z"}, "message": "constants.c (find_methodref_index): When the class is an interface...\n\nd\n\t* constants.c (find_methodref_index):  When the class is an interface,\n\tgenerate CONSTANT_InterfaceMethodref instead of a CONSTANT_MethodRef.\n\t* decl.c (finit_identifier_node):  Use \"$finit$\", rather than\n\t\"<finit>\" (which Sun's verifier rejects).\n\t* parse.y (maybe_generate_finit):  Leave out meaningless final flag.\n\t(generate_field_initialization_code):  Removed.\n\t(fix_constructors)  Don't add call to $finit$ here (wrong order).\n\t(patch_method_invocation):  Add $finit$ call here.\n\t* java-tree.h (CALL_USING_SUPER):  New macro.\n\t* parse.y (patch_invoke):  Remove im local variable.\n \t(patch_method_invocation, patch_invoke):  Don't pass super parameter.\n\t(patch_invoke):  Use CALL_USING_SUPER instead of from_super parameter.\n\t(resolve_qualified_expression_name):  Maybe set CALL_USING_SUPER.\n\t* jcf-write.c (get_access_flags):  Fix typo ACC_PUBLIC -> ACC_FINAL.\n\t* parse.y (java_complete_tree):  Don't complain about unreachable\n\tstatement if it is empty_stmt_node.\n\t* jcf-write.c (find_constant_wide):  New function.\n\t(push_long_const):  Use find_constant_wide.\n\t* jcf-write.c (generate_bytecode_insn):  Fix bug in switch handling.\n\t(generate_bytecode_insn):  Use correct dup variant for MODIFY_EXPR.\n\tAdd \"redundant\" NOTE_PUSH/NOTE_POP uses so code_SP_max gets set.\n\tEmit invokeinterface when calling an interface method.\n\tEmit invokespecial also when calling super or private methods.\n\t* jcf-write.c (generate_classfile):  Emit ConstantValue attributes.\n\nFrom-SVN: r24163", "tree": {"sha": "e4c252113488adbcce0e63a34636ea556e94689b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4c252113488adbcce0e63a34636ea556e94689b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e09b9a23a170dfe36be100791e85fcc76d9f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e09b9a23a170dfe36be100791e85fcc76d9f0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e09b9a23a170dfe36be100791e85fcc76d9f0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e09b9a23a170dfe36be100791e85fcc76d9f0c/comments", "author": null, "committer": null, "parents": [{"sha": "23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a7b8f510d58b076bfdbe8dc9fac8d29fd94c35"}], "stats": {"total": 89, "additions": 39, "deletions": 50}, "files": [{"sha": "b5cc1e7e1e852ff4c99e424e66212ab3242b43bd", "filename": "gcc/java/parse.y", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e09b9a23a170dfe36be100791e85fcc76d9f0c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e09b9a23a170dfe36be100791e85fcc76d9f0c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=89e09b9a23a170dfe36be100791e85fcc76d9f0c", "patch": "@@ -114,7 +114,7 @@ static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n static int check_class_interface_creation PROTO ((int, int, tree, \n \t\t\t\t\t\t  tree, tree, tree));\n static tree patch_method_invocation PROTO ((tree, tree, tree, \n-\t\t\t\t\t    int *, tree *, int));\n+\t\t\t\t\t    int *, tree *));\n static int breakdown_qualified PROTO ((tree *, tree *, tree));\n static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));\n@@ -123,7 +123,7 @@ static tree find_applicable_accessible_methods_list PROTO ((int, tree,\n \t\t\t\t\t\t\t    tree, tree));\n static tree find_most_specific_methods_list PROTO ((tree));\n static int argument_types_convertible PROTO ((tree, tree));\n-static tree patch_invoke PROTO ((tree, tree, tree, int));\n+static tree patch_invoke PROTO ((tree, tree, tree));\n static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n static tree obtain_incomplete_type PROTO ((tree));\n@@ -224,7 +224,6 @@ static int verify_constructor_super PROTO (());\n static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n static void start_artificial_method_body PROTO ((tree));\n static void end_artificial_method_body PROTO ((tree));\n-static tree generate_field_initialization_code PROTO ((tree));\n static int check_method_redefinition PROTO ((tree, tree));\n static int reset_method_name PROTO ((tree));\n static void java_check_regular_methods PROTO ((tree));\n@@ -3152,7 +3151,7 @@ register_fields (flags, type, variable_list)\n   lineno = saved_lineno;\n }\n \n-/* Generate the method <finit> that initializes fields initialized\n+/* Generate the method $finit$ that initializes fields initialized\n    upon declaration.  */\n \n static void\n@@ -3164,7 +3163,7 @@ maybe_generate_finit ()\n     return;\n \n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n-\t\t\t\t    ACC_PRIVATE|ACC_FINAL, void_type_node,\n+\t\t\t\t    ACC_PRIVATE, void_type_node,\n \t\t\t\t    finit_identifier_node, end_params_node);\n   start_artificial_method_body (mdecl);\n \n@@ -4369,7 +4368,7 @@ check_method_redefinition (class, method)\n   tree redef, name;\n   tree cl = DECL_NAME (method);\n   tree sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n-  /* decl name of artificial <clinit> and <finit> doesn't need to be fixed and\n+  /* decl name of artificial <clinit> and $finit$ doesn't need to be fixed and\n      checked */\n \n   /* Reset the method name before running the check. If it returns 1,\n@@ -5674,11 +5673,12 @@ fix_constructors (mdecl)\n   tree body = DECL_FUNCTION_BODY (mdecl);\n   tree field_init;\n \n-  /* The constructor body must be crafted by hand. It's the\n-     constructor we defined when we realize we didn't have the\n-     CLASSNAME() constructor */\n   if (!body)\n     {\n+      /* The constructor body must be crafted by hand. It's the\n+\t constructor we defined when we realize we didn't have the\n+\t CLASSNAME() constructor */\n+\n       tree compound;\n \n       /* It is an error for the compiler to generate a default\n@@ -5699,11 +5699,6 @@ fix_constructors (mdecl)\n \t compiling java.lang.Object. build_super_invocation takes care\n \t of that. */\n       compound = java_method_add_stmt (mdecl, build_super_invocation ());\n-      \n-      /* Takes care of non static field initialization */\n-      field_init = generate_field_initialization_code (current_class);\n-      if (field_init)\n-\tcompound = java_method_add_stmt (mdecl, field_init);\n \n       end_artificial_method_body (mdecl);\n     }\n@@ -5737,11 +5732,6 @@ fix_constructors (mdecl)\n \tcompound = add_stmt_to_compound (compound, NULL_TREE,\n \t\t\t\t\t build_super_invocation ());\n       \n-      /* Also fix its initialized fields initialization */\n-      field_init = generate_field_initialization_code (current_class);\n-      if (field_init)\n-\tcompound = add_stmt_to_compound (compound, NULL_TREE, field_init);\n-      \n       /* Fix the constructor main block if we're adding extra stmts */\n       if (compound)\n \t{\n@@ -5776,23 +5766,6 @@ verify_constructor_super ()\n   return 1;\n }\n \n-/* Generate the code used to initialize field declared with an\n-   initialization statement. For now, it returns a call the the\n-   artificial function <finit>, if required. Always returns NULL if\n-   nothing needs to be generated. */\n-\n-static tree\n-generate_field_initialization_code (class)\n-     tree class;\n-{\n-  if (CLASS_HAS_FINIT_P (class))\n-    return build_method_invocation (build_expr_wfl (finit_identifier_node, \n-\t\t\t\t\t\t    input_filename, 0, 0), \n-\t\t\t\t    NULL_TREE);\n-  else\n-    return NULL_TREE;\n-}\n-\n /* Expand finals.  */\n \n void\n@@ -6132,9 +6105,10 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  /* And code for the function call */\n \t  if (complete_function_arguments (qual_wfl))\n \t    return 1;\n+\t  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)\n+\t    CALL_USING_SUPER (qual_wfl) = 1;\n \t  *where_found = \n-\t    patch_method_invocation (qual_wfl, decl, type,\n-\t\t\t\t     &is_static, NULL, from_super);\n+\t    patch_method_invocation (qual_wfl, decl, type, &is_static, NULL);\n \t  if (*where_found == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (*where_found);\n@@ -6559,17 +6533,17 @@ maybe_access_field (decl, where, type)\n    used. IS_STATIC is set to 1 if the invoked function is static. */\n \n static tree\n-patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n+patch_method_invocation (patch, primary, where, is_static, ret_decl)\n      tree patch, primary, where;\n      int *is_static;\n      tree *ret_decl;\n-     int super;\n {\n   tree wfl = TREE_OPERAND (patch, 0);\n   tree args = TREE_OPERAND (patch, 1);\n   tree name = EXPR_WFL_NODE (wfl);\n   tree list;\n   int is_static_flag = 0;\n+  int is_super_init = 0;\n   \n   /* Should be overriden if everything goes well. Otherwise, if\n      something fails, it should keep this value. It stop the\n@@ -6690,6 +6664,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  else if (EXPR_WFL_NODE (TREE_OPERAND (patch, 0)) ==\n \t\t   super_identifier_node)\n \t    {\n+\t      is_super_init = 1;\n \t      if (CLASSTYPE_SUPER (current_class))\n \t\tclass_to_search = \n \t\t  DECL_NAME (TYPE_NAME (CLASSTYPE_SUPER (current_class)));\n@@ -6808,7 +6783,22 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n      EH checking */\n   if (ret_decl)\n     *ret_decl = list;\n-  return patch_invoke (patch, list, args, super);\n+  patch = patch_invoke (patch, list, args);\n+  if (is_super_init && CLASS_HAS_FINIT_P (current_class))\n+    {\n+      /* Generate the code used to initialize fields declared with an\n+\t initialization statement. For now, it returns a call the the\n+\t artificial function $finit$, if required. */\n+\n+      tree finit_call =\n+\tbuild_method_invocation (build_expr_wfl (finit_identifier_node,  \n+\t\t\t\t\t\t input_filename, 0, 0),  \n+\t\t\t\t NULL_TREE);\n+      patch = build (COMPOUND_EXPR, void_type_node, patch,\n+\t\t     java_complete_tree (finit_call));\n+      CAN_COMPLETE_NORMALLY (patch) = 1;\n+    }\n+  return patch;\n }\n \n /* Check that we're not trying to do a static reference to a method in\n@@ -6836,11 +6826,9 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n    mode.  */\n \n static tree\n-patch_invoke (patch, method, args, from_super)\n+patch_invoke (patch, method, args)\n      tree patch, method, args;\n-     int from_super;\n {\n-  int im;\n   tree dtable, func;\n   tree original_call, t, ta;\n \n@@ -6861,7 +6849,7 @@ patch_invoke (patch, method, args, from_super)\n   else\n     {\n       tree signature = build_java_signature (TREE_TYPE (method));\n-      switch ((im = invocation_mode (method, from_super)))\n+      switch (invocation_mode (method, CALL_USING_SUPER (patch)))\n \t{\n \tcase INVOKE_VIRTUAL:\n \t  dtable = invoke_build_dtable (0, args);\n@@ -6881,8 +6869,7 @@ patch_invoke (patch, method, args, from_super)\n \t  break;\n \n \tdefault:\n-\t  fatal (\"Unknown invocation mode `%d' - build_invoke\", im);\n-\t  return NULL_TREE;\n+\t  fatal (\"internal error - unknown invocation_mode result\");\n \t}\n \n       /* Ensure self_type is initialized, (invokestatic). FIXME */\n@@ -7439,7 +7426,8 @@ java_complete_tree (node)\n \t\t\tbreak;\n \t\t    }\n \t\t  if (TREE_CODE (wfl_op2) != CASE_EXPR\n-\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n+\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR\n+\t\t      && wfl_op2 != empty_stmt_node)\n \t\t    unreachable_stmt_error (*ptr);\n \t\t}\n \t      ptr = next;\n@@ -7608,7 +7596,8 @@ java_complete_tree (node)\n     case COMPOUND_EXPR:\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 0) = nn = java_complete_tree (TREE_OPERAND (node, 0));\n-      if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK)\n+      if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK\n+\t  && TREE_OPERAND (node, 1) != empty_stmt_node)\n \t{\n \t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n \t  parse_error_context (wfl_operator, \"Unreachable statement\");\n@@ -7689,7 +7678,7 @@ java_complete_tree (node)\n \t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n \n \t  node = patch_method_invocation (node, NULL_TREE, \n-\t\t\t\t\t  NULL_TREE, 0, &decl, 0);\n+\t\t\t\t\t  NULL_TREE, 0, &decl);\n \t  if (node == error_mark_node)\n \t    return error_mark_node;\n "}]}