{"sha": "3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "node_id": "C_kwDOANBUbNoAKDNkYTc3ZjIxN2M4YjIwODllY2JhM2ViMjAxZTcyN2MzZmNkY2QxOWQ", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2022-07-28T15:07:22Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2023-02-22T13:57:11Z"}, "message": "vect: inbranch SIMD clones\n\nThere has been support for generating \"inbranch\" SIMD clones for a long time,\nbut nothing actually uses them (as far as I can see).\n\nThis patch add supports for a sub-set of possible cases (those using\nmask_mode == VOIDmode).  The other cases fail to vectorize, just as before,\nso there should be no regressions.\n\nThe sub-set of support should cover all cases needed by amdgcn, at present.\n\ngcc/ChangeLog:\n\n\t* internal-fn.cc (expand_MASK_CALL): New.\n\t* internal-fn.def (MASK_CALL): New.\n\t* internal-fn.h (expand_MASK_CALL): New prototype.\n\t* omp-simd-clone.cc (simd_clone_adjust_argument_types): Set vector_type\n\tfor mask arguments also.\n\t* tree-if-conv.cc: Include cgraph.h.\n\t(if_convertible_stmt_p): Do if conversions for calls to SIMD calls.\n\t(predicate_statements): Convert functions to IFN_MASK_CALL.\n\t* tree-vect-loop.cc (vect_get_datarefs_in_loop): Recognise\n\tIFN_MASK_CALL as a SIMD function call.\n\t* tree-vect-stmts.cc (vectorizable_simd_clone_call): Handle\n\tIFN_MASK_CALL as an inbranch SIMD function call.\n\tGenerate the mask vector arguments.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/vect/vect-simd-clone-16.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-16b.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-16c.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-16d.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-16e.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-16f.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-17.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-17b.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-17c.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-17d.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-17e.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-17f.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-18.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-18b.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-18c.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-18d.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-18e.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-18f.c: New test.", "tree": {"sha": "2f3fb8460f25af2a5bf8a8bc9e8fe19f8b5b41f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f3fb8460f25af2a5bf8a8bc9e8fe19f8b5b41f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c878c6586dee353e685364910e02ad1a611d4634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c878c6586dee353e685364910e02ad1a611d4634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c878c6586dee353e685364910e02ad1a611d4634"}], "stats": {"total": 714, "additions": 682, "deletions": 32}, "files": [{"sha": "6e81dc05e0e0714256759b0594816df451415a2d", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -4521,3 +4521,10 @@ void\n expand_ASSUME (internal_fn, gcall *)\n {\n }\n+\n+void\n+expand_MASK_CALL (internal_fn, gcall *)\n+{\n+  /* This IFN should only exist between ifcvt and vect passes.  */\n+  gcc_unreachable ();\n+}"}, {"sha": "7fe742c2ae713e7152ab05cfdfba86e4e0aa3456", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -461,6 +461,9 @@ DEF_INTERNAL_FN (SPACESHIP, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ASSUME, ECF_CONST | ECF_LEAF | ECF_NOTHROW\n \t\t\t | ECF_LOOPING_CONST_OR_PURE, NULL)\n \n+/* For if-conversion of inbranch SIMD clones.  */\n+DEF_INTERNAL_FN (MASK_CALL, ECF_NOVOPS, NULL)\n+\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_FLT_FLOATN_FN"}, {"sha": "08922ed4254898f5fffca3f33973e96ed9ce772f", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -244,6 +244,7 @@ extern void expand_SHUFFLEVECTOR (internal_fn, gcall *);\n extern void expand_SPACESHIP (internal_fn, gcall *);\n extern void expand_TRAP (internal_fn, gcall *);\n extern void expand_ASSUME (internal_fn, gcall *);\n+extern void expand_MASK_CALL (internal_fn, gcall *);\n \n extern bool vectorized_internal_fn_supported_p (internal_fn, tree);\n "}, {"sha": "03ff86e7d188cd8eb30d5d971c5c9bbc7d64543f", "filename": "gcc/omp-simd-clone.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Fomp-simd-clone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Fomp-simd-clone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.cc?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -942,6 +942,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t}\n       sc->args[i].orig_type = base_type;\n       sc->args[i].arg_type = SIMD_CLONE_ARG_TYPE_MASK;\n+      sc->args[i].vector_type = adj.type;\n     }\n \n   if (node->definition)"}, {"sha": "ce9a6dad1b7882665a2e97e1eb327268f0fbe8e2", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+/* Test that simd inbranch clones work correctly.  */\n+\n+#ifndef TYPE\n+#define TYPE int\n+#endif\n+\n+/* A simple function that will be cloned.  */\n+#pragma omp declare simd\n+TYPE __attribute__((noinline))\n+foo (TYPE a)\n+{\n+  return a + 1;\n+}\n+\n+/* Check that \"inbranch\" clones are called correctly.  */\n+\n+void __attribute__((noipa))\n+masked (TYPE * __restrict a, TYPE * __restrict b, int size)\n+{\n+  #pragma omp simd\n+  for (int i = 0; i < size; i++)\n+    b[i] = a[i]<1 ? foo(a[i]) : a[i];\n+}\n+\n+/* Check that \"inbranch\" works when there might be unrolling.  */\n+\n+void __attribute__((noipa))\n+masked_fixed (TYPE * __restrict a, TYPE * __restrict b)\n+{\n+  #pragma omp simd\n+  for (int i = 0; i < 128; i++)\n+    b[i] = a[i]<1 ? foo(a[i]) : a[i];\n+}\n+\n+/* Validate the outputs.  */\n+\n+void\n+check_masked (TYPE *b, int size)\n+{\n+  for (int i = 0; i < size; i++)\n+    if (((TYPE)i < 1 && b[i] != (TYPE)(i + 1))\n+\t|| ((TYPE)i >= 1 && b[i] != (TYPE)i))\n+      {\n+\t__builtin_printf (\"error at %d\\n\", i);\n+\t__builtin_exit (1);\n+      }\n+}\n+\n+int\n+main ()\n+{\n+  TYPE a[1024];\n+  TYPE b[1024];\n+\n+  for (int i = 0; i < 1024; i++)\n+    a[i] = i;\n+\n+  masked_fixed (a, b);\n+  check_masked (b, 128);\n+\n+  /* Test various sizes to cover machines with different vectorization\n+     factors.  */\n+  for (int size = 8; size <= 1024; size *= 2)\n+    {\n+      masked (a, b, size);\n+      check_masked (b, size);\n+    }\n+\n+  /* Test sizes that might exercise the partial vector code-path.  */\n+  for (int size = 8; size <= 1024; size *= 2)\n+    {\n+      masked (a, b, size-4);\n+      check_masked (b, size-4);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! aarch64*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target aarch64*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "af543b6573de28354f5f11088e73ac7770a33587", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16b.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16b.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE float\n+#include \"vect-simd-clone-16.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { avx_runtime || aarch64*-*-* } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime || aarch64*-*-* } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "677548a943923fb9e82e2cdf992de2f61fa27cce", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16c.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16c.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE short\n+#include \"vect-simd-clone-16.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { x86_64*-*-* || { i686*-*-* || aarch64*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { aarch64*-*-* } } } } */\n+\n+/* x86_64 fails to use in-branch clones for TYPE=short.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 0 \"vect\" { target x86_64*-*-* i686*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "a9ae9932b309c90b2f57089a1d188ca4815c5800", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16d.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16d.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE char\n+#include \"vect-simd-clone-16.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { x86_64*-*-* || { i686*-*-* || aarch64*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { aarch64*-*-* } } } } */\n+\n+/* x86_64 fails to use in-branch clones for TYPE=char.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 0 \"vect\" { target x86_64*-*-* i686*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "c8b482bf2e70a211f250724ba71148681731070f", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16e.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16e.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE double\n+#include \"vect-simd-clone-16.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.\n+   Some targets use pairs of vectors and do twice the calls.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx_runtime } && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "f42ac082678b2ce7b69ee5117653c30c21d47b52", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-16f.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-16f.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE __INT64_TYPE__\n+#include \"vect-simd-clone-16.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use pairs of vectors and do twice the calls.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { i686*-*-* && { ! lp64 } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "756225e4306f16c745e7ec6b119804e803084ffe", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+/* Test that simd inbranch clones work correctly.  */\n+\n+#ifndef TYPE\n+#define TYPE int\n+#endif\n+\n+/* A simple function that will be cloned.  */\n+#pragma omp declare simd uniform(b)\n+TYPE __attribute__((noinline))\n+foo (TYPE a, TYPE b)\n+{\n+  return a + b;\n+}\n+\n+/* Check that \"inbranch\" clones are called correctly.  */\n+\n+void __attribute__((noipa))\n+masked (TYPE * __restrict a, TYPE * __restrict b, int size)\n+{\n+  #pragma omp simd\n+  for (int i = 0; i < size; i++)\n+    b[i] = a[i]<1 ? foo(a[i], 1) : a[i];\n+}\n+\n+/* Check that \"inbranch\" works when there might be unrolling.  */\n+\n+void __attribute__((noipa))\n+masked_fixed (TYPE * __restrict a, TYPE * __restrict b)\n+{\n+  #pragma omp simd\n+  for (int i = 0; i < 128; i++)\n+    b[i] = a[i]<1 ? foo(a[i], 1) : a[i];\n+}\n+\n+/* Validate the outputs.  */\n+\n+void\n+check_masked (TYPE *b, int size)\n+{\n+  for (int i = 0; i < size; i++)\n+    if (((TYPE)i < 1 && b[i] != (TYPE)(i + 1))\n+\t|| ((TYPE)i >= 1 && b[i] != (TYPE)i))\n+      {\n+\t__builtin_printf (\"error at %d\\n\", i);\n+\t__builtin_exit (1);\n+      }\n+}\n+\n+int\n+main ()\n+{\n+  TYPE a[1024];\n+  TYPE b[1024];\n+\n+  for (int i = 0; i < 1024; i++)\n+    a[i] = i;\n+\n+  masked_fixed (a, b);\n+  check_masked (b, 128);\n+\n+  /* Test various sizes to cover machines with different vectorization\n+     factors.  */\n+  for (int size = 8; size <= 1024; size *= 2)\n+    {\n+      masked (a, b, size);\n+      check_masked (b, size);\n+    }\n+\n+  /* Test sizes that might exercise the partial vector code-path.  */\n+  for (int size = 8; size <= 1024; size *= 2)\n+    {\n+      masked (a, b, size-4);\n+      check_masked (b, size-4);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! aarch64*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target aarch64*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "8731c26864480dbef2e565131e488cb5e5c4a93b", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17b.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17b.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE float\n+#include \"vect-simd-clone-17.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { avx_runtime || aarch64*-*-* } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime || aarch64*-*-* } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "6683d1a9cbf3547813bbdc9a3ded17c8ef6d0ed6", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17c.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17c.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE short\n+#include \"vect-simd-clone-17.c\"\n+ \n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { x86_64*-*-* || { i686*-*-* || aarch64*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { aarch64*-*-* } } } } */\n+\n+/* x86_64 fails to use in-branch clones for TYPE=short.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 0 \"vect\" { target x86_64*-*-* i686*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "d38bde6d85ea02c917bdb6a2ff094e14b39217bf", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17d.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17d.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE char\n+#include \"vect-simd-clone-17.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { x86_64*-*-* || { i686*-*-* || aarch64*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { aarch64*-*-* } } } } */\n+\n+/* x86_64 fails to use in-branch clones for TYPE=char.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 0 \"vect\" { target x86_64*-*-* i686*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "f2a428c62c1cd10eb0e9d79d39edeadfda8b8fd1", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17e.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17e.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE double\n+#include \"vect-simd-clone-17.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.\n+   Some targets use pairs of vectors and do twice the calls.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx_runtime } && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "cd05dec9632a130cbc917369278c452c3ac90b58", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-17f.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-17f.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE __INT64_TYPE__\n+#include \"vect-simd-clone-17.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use pairs of vectors and do twice the calls.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { i686*-*-* && { ! lp64 } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "febf9fdf85ee0be63f242311f402bf377386a1e7", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+/* Test that simd inbranch clones work correctly.  */\n+\n+#ifndef TYPE\n+#define TYPE int\n+#endif\n+\n+/* A simple function that will be cloned.  */\n+#pragma omp declare simd uniform(b)\n+TYPE __attribute__((noinline))\n+foo (TYPE b, TYPE a)\n+{\n+  return a + b;\n+}\n+\n+/* Check that \"inbranch\" clones are called correctly.  */\n+\n+void __attribute__((noipa))\n+masked (TYPE * __restrict a, TYPE * __restrict b, int size)\n+{\n+  #pragma omp simd\n+  for (int i = 0; i < size; i++)\n+    b[i] = a[i]<1 ? foo(1, a[i]) : a[i];\n+}\n+\n+/* Check that \"inbranch\" works when there might be unrolling.  */\n+\n+void __attribute__((noipa))\n+masked_fixed (TYPE * __restrict a, TYPE * __restrict b)\n+{\n+  #pragma omp simd\n+  for (int i = 0; i < 128; i++)\n+    b[i] = a[i]<1 ? foo(1, a[i]) : a[i];\n+}\n+\n+/* Validate the outputs.  */\n+\n+void\n+check_masked (TYPE *b, int size)\n+{\n+  for (int i = 0; i < size; i++)\n+    if (((TYPE)i < 1 && b[i] != (TYPE)(i + 1))\n+\t|| ((TYPE)i >= 1 && b[i] != (TYPE)i))\n+      {\n+\t__builtin_printf (\"error at %d\\n\", i);\n+\t__builtin_exit (1);\n+      }\n+}\n+\n+int\n+main ()\n+{\n+  TYPE a[1024];\n+  TYPE b[1024];\n+\n+  for (int i = 0; i < 1024; i++)\n+    a[i] = i;\n+\n+  masked_fixed (a, b);\n+  check_masked (b, 128);\n+\n+  /* Test various sizes to cover machines with different vectorization\n+     factors.  */\n+  for (int size = 8; size <= 1024; size *= 2)\n+    {\n+      masked (a, b, size);\n+      check_masked (b, size);\n+    }\n+\n+  /* Test sizes that might exercise the partial vector code-path.  */\n+  for (int size = 8; size <= 1024; size *= 2)\n+    {\n+      masked (a, b, size-4);\n+      check_masked (b, size-4);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! aarch64*-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target aarch64*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "120993e517a8e7b565b459d1d89c9cb6aa7c4dd0", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18b.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18b.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE float\n+#include \"vect-simd-clone-18.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { avx_runtime || aarch64*-*-* } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime || aarch64*-*-* } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "0d1fc6de4e4ab6e23e3a1b8ac781b595af74b9a0", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18c.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18c.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE short\n+#include \"vect-simd-clone-18.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { x86_64*-*-* || { i686*-*-* || aarch64*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { aarch64*-*-* } } } } */\n+\n+/* x86_64 fails to use in-branch clones for TYPE=short.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 0 \"vect\" { target x86_64*-*-* i686*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "1e6c028fc473519ffde282a8ddff9136f26771d5", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18d.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18d.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE char\n+#include \"vect-simd-clone-18.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { x86_64*-*-* || { i686*-*-* || aarch64*-*-* } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { aarch64*-*-* } } } } */\n+\n+/* x86_64 fails to use in-branch clones for TYPE=char.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 0 \"vect\" { target x86_64*-*-* i686*-*-* } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "9d20e52cb9a44bd1d2a5e07e01d70850623545f4", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18e.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18e.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE double\n+#include \"vect-simd-clone-18.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use another call for the epilogue loops.\n+   Some targets use pairs of vectors and do twice the calls.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { { ! avx_runtime } && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 3 \"vect\" { target { avx_runtime && { ! { i686*-*-* && { ! lp64 } } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "09ee7ff60fdb19c4d460a08494b5e354b413ba1d", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-18f.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-18f.c?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-require-effective-target vect_simd_clones } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#define TYPE __INT64_TYPE__\n+#include \"vect-simd-clone-18.c\"\n+\n+/* Ensure the the in-branch simd clones are used on targets that support them.\n+   Some targets use pairs of vectors and do twice the calls.  */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 2 \"vect\" { target { ! { i686*-*-* && { ! lp64 } } } } } } */\n+/* { dg-final { scan-tree-dump-times {[\\n\\r] [^\\n]* = foo\\.simdclone} 4 \"vect\" { target { i686*-*-* && { ! lp64 } } } } } */\n+\n+/* The LTO test produces two dump files and we scan the wrong one.  */\n+/* { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } } */"}, {"sha": "a7a8406374da420fc0425cc9fb5d633f5bce6262", "filename": "gcc/tree-if-conv.cc", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftree-if-conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftree-if-conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.cc?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -123,6 +123,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-dse.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-eh.h\"\n+#include \"cgraph.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -1063,7 +1064,8 @@ if_convertible_gimple_assign_stmt_p (gimple *stmt,\n    A statement is if-convertible if:\n    - it is an if-convertible GIMPLE_ASSIGN,\n    - it is a GIMPLE_LABEL or a GIMPLE_COND,\n-   - it is builtins call.  */\n+   - it is builtins call,\n+   - it is a call to a function with a SIMD clone.  */\n \n static bool\n if_convertible_stmt_p (gimple *stmt, vec<data_reference_p> refs)\n@@ -1083,13 +1085,23 @@ if_convertible_stmt_p (gimple *stmt, vec<data_reference_p> refs)\n \ttree fndecl = gimple_call_fndecl (stmt);\n \tif (fndecl)\n \t  {\n+\t    /* We can vectorize some builtins and functions with SIMD\n+\t       \"inbranch\" clones.  */\n \t    int flags = gimple_call_flags (stmt);\n+\t    struct cgraph_node *node = cgraph_node::get (fndecl);\n \t    if ((flags & ECF_CONST)\n \t\t&& !(flags & ECF_LOOPING_CONST_OR_PURE)\n-\t\t/* We can only vectorize some builtins at the moment,\n-\t\t   so restrict if-conversion to those.  */\n \t\t&& fndecl_built_in_p (fndecl))\n \t      return true;\n+\t    if (node && node->simd_clones != NULL)\n+\t      /* Ensure that at least one clone can be \"inbranch\".  */\n+\t      for (struct cgraph_node *n = node->simd_clones; n != NULL;\n+\t\t   n = n->simdclone->next_clone)\n+\t\tif (n->simdclone->inbranch)\n+\t\t  {\n+\t\t    need_to_predicate = true;\n+\t\t    return true;\n+\t\t  }\n \t  }\n \treturn false;\n       }\n@@ -2613,6 +2625,29 @@ predicate_statements (loop_p loop)\n \t      gimple_assign_set_rhs1 (stmt, ifc_temp_var (type, rhs, &gsi));\n \t      update_stmt (stmt);\n \t    }\n+\n+\t  /* Convert functions that have a SIMD clone to IFN_MASK_CALL.  This\n+\t     will cause the vectorizer to match the \"in branch\" clone variants,\n+\t     and serves to build the mask vector in a natural way.  */\n+\t  gcall *call = dyn_cast <gcall *> (gsi_stmt (gsi));\n+\t  if (call && !gimple_call_internal_p (call))\n+\t    {\n+\t      tree orig_fn = gimple_call_fn (call);\n+\t      int orig_nargs = gimple_call_num_args (call);\n+\t      auto_vec<tree> args;\n+\t      args.safe_push (orig_fn);\n+\t      for (int i = 0; i < orig_nargs; i++)\n+\t\targs.safe_push (gimple_call_arg (call, i));\n+\t      args.safe_push (cond);\n+\n+\t      /* Replace the call with a IFN_MASK_CALL that has the extra\n+\t\t condition parameter. */\n+\t      gcall *new_call = gimple_build_call_internal_vec (IFN_MASK_CALL,\n+\t\t\t\t\t\t\t\targs);\n+\t      gimple_call_set_lhs (new_call, gimple_call_lhs (call));\n+\t      gsi_replace (&gsi, new_call, true);\n+\t    }\n+\n \t  lhs = gimple_get_lhs (gsi_stmt (gsi));\n \t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t    ssa_names.add (lhs);"}, {"sha": "ab7af0ea3b8b5029433913f6ba8d9c8511e723c1", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -2125,6 +2125,14 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n \t    if (is_gimple_call (stmt) && loop->safelen)\n \t      {\n \t\ttree fndecl = gimple_call_fndecl (stmt), op;\n+\t\tif (fndecl == NULL_TREE\n+\t\t    && gimple_call_internal_p (stmt, IFN_MASK_CALL))\n+\t\t  {\n+\t\t    fndecl = gimple_call_arg (stmt, 0);\n+\t\t    gcc_checking_assert (TREE_CODE (fndecl) == ADDR_EXPR);\n+\t\t    fndecl = TREE_OPERAND (fndecl, 0);\n+\t\t    gcc_checking_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+\t\t  }\n \t\tif (fndecl != NULL_TREE)\n \t\t  {\n \t\t    cgraph_node *node = cgraph_node::get (fndecl);"}, {"sha": "9e5ffbe252e66e706a1dbe80705faa9c54ea61f9", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 123, "deletions": 29, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da77f217c8b2089ecba3eb201e727c3fcdcd19d/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=3da77f217c8b2089ecba3eb201e727c3fcdcd19d", "patch": "@@ -4004,13 +4004,23 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n   size_t i, nargs;\n   tree lhs, rtype, ratype;\n   vec<constructor_elt, va_gc> *ret_ctor_elts = NULL;\n+  int arg_offset = 0;\n \n   /* Is STMT a vectorizable call?   */\n   gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt);\n   if (!stmt)\n     return false;\n \n   fndecl = gimple_call_fndecl (stmt);\n+  if (fndecl == NULL_TREE\n+      && gimple_call_internal_p (stmt, IFN_MASK_CALL))\n+    {\n+      fndecl = gimple_call_arg (stmt, 0);\n+      gcc_checking_assert (TREE_CODE (fndecl) == ADDR_EXPR);\n+      fndecl = TREE_OPERAND (fndecl, 0);\n+      gcc_checking_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+      arg_offset = 1;\n+    }\n   if (fndecl == NULL_TREE)\n     return false;\n \n@@ -4041,7 +4051,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n     return false;\n \n   /* Process function arguments.  */\n-  nargs = gimple_call_num_args (stmt);\n+  nargs = gimple_call_num_args (stmt) - arg_offset;\n \n   /* Bail out if the function has zero arguments.  */\n   if (nargs == 0)\n@@ -4059,7 +4069,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n       thisarginfo.op = NULL_TREE;\n       thisarginfo.simd_lane_linear = false;\n \n-      op = gimple_call_arg (stmt, i);\n+      op = gimple_call_arg (stmt, i + arg_offset);\n       if (!vect_is_simple_use (op, vinfo, &thisarginfo.dt,\n \t\t\t       &thisarginfo.vectype)\n \t  || thisarginfo.dt == vect_uninitialized_def)\n@@ -4074,16 +4084,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t  || thisarginfo.dt == vect_external_def)\n \tgcc_assert (thisarginfo.vectype == NULL_TREE);\n       else\n-\t{\n-\t  gcc_assert (thisarginfo.vectype != NULL_TREE);\n-\t  if (VECTOR_BOOLEAN_TYPE_P (thisarginfo.vectype))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"vector mask arguments are not supported\\n\");\n-\t      return false;\n-\t    }\n-\t}\n+\tgcc_assert (thisarginfo.vectype != NULL_TREE);\n \n       /* For linear arguments, the analyze phase should have saved\n \t the base and step in STMT_VINFO_SIMD_CLONE_INFO.  */\n@@ -4176,17 +4177,14 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \tif (target_badness < 0)\n \t  continue;\n \tthis_badness += target_badness * 512;\n-\t/* FORNOW: Have to add code to add the mask argument.  */\n-\tif (n->simdclone->inbranch)\n-\t  continue;\n \tfor (i = 0; i < nargs; i++)\n \t  {\n \t    switch (n->simdclone->args[i].arg_type)\n \t      {\n \t      case SIMD_CLONE_ARG_TYPE_VECTOR:\n \t\tif (!useless_type_conversion_p\n \t\t\t(n->simdclone->args[i].orig_type,\n-\t\t\t TREE_TYPE (gimple_call_arg (stmt, i))))\n+\t\t\t TREE_TYPE (gimple_call_arg (stmt, i + arg_offset))))\n \t\t  i = -1;\n \t\telse if (arginfo[i].dt == vect_constant_def\n \t\t\t || arginfo[i].dt == vect_external_def\n@@ -4216,7 +4214,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\ti = -1;\n \t\tbreak;\n \t      case SIMD_CLONE_ARG_TYPE_MASK:\n-\t\tgcc_unreachable ();\n+\t\tbreak;\n \t      }\n \t    if (i == (size_t) -1)\n \t      break;\n@@ -4242,18 +4240,55 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n     return false;\n \n   for (i = 0; i < nargs; i++)\n-    if ((arginfo[i].dt == vect_constant_def\n-\t || arginfo[i].dt == vect_external_def)\n-\t&& bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n-      {\n-\ttree arg_type = TREE_TYPE (gimple_call_arg (stmt, i));\n-\targinfo[i].vectype = get_vectype_for_scalar_type (vinfo, arg_type,\n-\t\t\t\t\t\t\t  slp_node);\n-\tif (arginfo[i].vectype == NULL\n-\t    || !constant_multiple_p (bestn->simdclone->simdlen,\n-\t\t\t\t     simd_clone_subparts (arginfo[i].vectype)))\n+    {\n+      if ((arginfo[i].dt == vect_constant_def\n+\t   || arginfo[i].dt == vect_external_def)\n+\t  && bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n+\t{\n+\t  tree arg_type = TREE_TYPE (gimple_call_arg (stmt, i + arg_offset));\n+\t  arginfo[i].vectype = get_vectype_for_scalar_type (vinfo, arg_type,\n+\t\t\t\t\t\t\t    slp_node);\n+\t  if (arginfo[i].vectype == NULL\n+\t      || !constant_multiple_p (bestn->simdclone->simdlen,\n+\t\t\t\t       simd_clone_subparts (arginfo[i].vectype)))\n+\t    return false;\n+\t}\n+\n+      if (bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR\n+\t  && VECTOR_BOOLEAN_TYPE_P (bestn->simdclone->args[i].vector_type))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"vector mask arguments are not supported.\\n\");\n \t  return false;\n-      }\n+\t}\n+\n+      if (bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_MASK\n+\t  && bestn->simdclone->mask_mode == VOIDmode\n+\t  && (simd_clone_subparts (bestn->simdclone->args[i].vector_type)\n+\t      != simd_clone_subparts (arginfo[i].vectype)))\n+\t{\n+\t  /* FORNOW we only have partial support for vector-type masks that\n+\t     can't hold all of simdlen. */\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t     vect_location,\n+\t\t\t     \"in-branch vector clones are not yet\"\n+\t\t\t     \" supported for mismatched vector sizes.\\n\");\n+\t  return false;\n+\t}\n+      if (bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_MASK\n+\t  && bestn->simdclone->mask_mode != VOIDmode)\n+\t{\n+\t  /* FORNOW don't support integer-type masks.  */\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t     vect_location,\n+\t\t\t     \"in-branch vector clones are not yet\"\n+\t\t\t     \" supported for integer mask modes.\\n\");\n+\t  return false;\n+\t}\n+    }\n \n   fndecl = bestn->decl;\n   nunits = bestn->simdclone->simdlen;\n@@ -4343,7 +4378,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t{\n \t  unsigned int k, l, m, o;\n \t  tree atype;\n-\t  op = gimple_call_arg (stmt, i);\n+\t  op = gimple_call_arg (stmt, i + arg_offset);\n \t  switch (bestn->simdclone->args[i].arg_type)\n \t    {\n \t    case SIMD_CLONE_ARG_TYPE_VECTOR:\n@@ -4442,6 +4477,65 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t    }\n \t\t}\n \t      break;\n+\t    case SIMD_CLONE_ARG_TYPE_MASK:\n+\t      atype = bestn->simdclone->args[i].vector_type;\n+\t      if (bestn->simdclone->mask_mode != VOIDmode)\n+\t\t{\n+\t\t  /* FORNOW: this is disabled above.  */\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree elt_type = TREE_TYPE (atype);\n+\t\t  tree one = fold_convert (elt_type, integer_one_node);\n+\t\t  tree zero = fold_convert (elt_type, integer_zero_node);\n+\t\t  o = vector_unroll_factor (nunits,\n+\t\t\t\t\t    simd_clone_subparts (atype));\n+\t\t  for (m = j * o; m < (j + 1) * o; m++)\n+\t\t    {\n+\t\t      if (simd_clone_subparts (atype)\n+\t\t\t  < simd_clone_subparts (arginfo[i].vectype))\n+\t\t\t{\n+\t\t\t  /* The mask type has fewer elements than simdlen.  */\n+\n+\t\t\t  /* FORNOW */\n+\t\t\t  gcc_unreachable ();\n+\t\t\t}\n+\t\t      else if (simd_clone_subparts (atype)\n+\t\t\t       == simd_clone_subparts (arginfo[i].vectype))\n+\t\t\t{\n+\t\t\t  /* The SIMD clone function has the same number of\n+\t\t\t     elements as the current function.  */\n+\t\t\t  if (m == 0)\n+\t\t\t    {\n+\t\t\t      vect_get_vec_defs_for_operand (vinfo, stmt_info,\n+\t\t\t\t\t\t\t     o * ncopies,\n+\t\t\t\t\t\t\t     op,\n+\t\t\t\t\t\t\t     &vec_oprnds[i]);\n+\t\t\t      vec_oprnds_i[i] = 0;\n+\t\t\t    }\n+\t\t\t  vec_oprnd0 = vec_oprnds[i][vec_oprnds_i[i]++];\n+\t\t\t  vec_oprnd0\n+\t\t\t    = build3 (VEC_COND_EXPR, atype, vec_oprnd0,\n+\t\t\t\t      build_vector_from_val (atype, one),\n+\t\t\t\t      build_vector_from_val (atype, zero));\n+\t\t\t  gassign *new_stmt\n+\t\t\t    = gimple_build_assign (make_ssa_name (atype),\n+\t\t\t\t\t\t   vec_oprnd0);\n+\t\t\t  vect_finish_stmt_generation (vinfo, stmt_info,\n+\t\t\t\t\t\t       new_stmt, gsi);\n+\t\t\t  vargs.safe_push (gimple_assign_lhs (new_stmt));\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* The mask type has more elements than simdlen.  */\n+\n+\t\t\t  /* FORNOW */\n+\t\t\t  gcc_unreachable ();\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      break;\n \t    case SIMD_CLONE_ARG_TYPE_UNIFORM:\n \t      vargs.safe_push (op);\n \t      break;"}]}