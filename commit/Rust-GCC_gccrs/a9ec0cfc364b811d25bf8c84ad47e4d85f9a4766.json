{"sha": "a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTllYzBjZmMzNjRiODExZDI1YmY4Yzg0YWQ0N2U0ZDg1ZjlhNDc2Ng==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-02T17:51:26Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-01-02T17:51:26Z"}, "message": "re PR fortran/45689 ([F03] Missing transformational intrinsic in the trans_func_f2003 list)\n\n2018-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45689\n\tPR fortran/83650\n\t* simplify.c (gfc_simplify_cshift): Re-implement to allow full\n\trange of arguments.\n\n2018-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45689\n\tPR fortran/83650\n\t* gfortran.dg/simplify_cshift_1.f90: Correct erroneous case.\n\t* gfortran.dg/simplify_cshift_4.f90: New test.\n\nFrom-SVN: r256084", "tree": {"sha": "f85626cd23b0a0a2f8d94cfcf241270a82d28529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f85626cd23b0a0a2f8d94cfcf241270a82d28529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/comments", "author": null, "committer": null, "parents": [{"sha": "7616c40b3fd1ca99ab076b80301df2703345afa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7616c40b3fd1ca99ab076b80301df2703345afa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7616c40b3fd1ca99ab076b80301df2703345afa2"}], "stats": {"total": 287, "additions": 229, "deletions": 58}, "files": [{"sha": "61b41675413476ad50cbb79d376f22132c38d8e9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "patch": "@@ -1,3 +1,10 @@\n+2018-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45689\n+\tPR fortran/83650\n+\t* simplify.c (gfc_simplify_cshift): Re-implement to allow full\n+\trange of arguments.\n+\n 2018-01-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/83076"}, {"sha": "22a486418f71775474d604a0d52e534d9ee2e0e5", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 176, "deletions": 56, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "patch": "@@ -1950,92 +1950,212 @@ gfc_simplify_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n     simplify_transformation_to_array (result, mask, dim, mask, gfc_count, NULL);\n }\n \n+/* Simplification routine for cshift. This works by copying the array\n+   expressions into a one-dimensional array, shuffling the values into another\n+   one-dimensional array and creating the new array expression from this.  The\n+   shuffling part is basically taken from the library routine.  */\n \n gfc_expr *\n gfc_simplify_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n {\n-  gfc_expr *a, *result;\n-  int dm;\n+  gfc_expr *result;\n+  int which;\n+  gfc_expr **arrayvec, **resultvec;\n+  gfc_expr **rptr, **sptr;\n+  mpz_t size;\n+  size_t arraysize, shiftsize, i;\n+  gfc_constructor *array_ctor, *shift_ctor;\n+  ssize_t *shiftvec, *hptr;\n+  ssize_t shift_val, len;\n+  ssize_t count[GFC_MAX_DIMENSIONS], extent[GFC_MAX_DIMENSIONS],\n+    hs_ex[GFC_MAX_DIMENSIONS],\n+    hstride[GFC_MAX_DIMENSIONS], sstride[GFC_MAX_DIMENSIONS],\n+    a_extent[GFC_MAX_DIMENSIONS], a_stride[GFC_MAX_DIMENSIONS],\n+    h_extent[GFC_MAX_DIMENSIONS],\n+    ss_ex[GFC_MAX_DIMENSIONS];\n+  ssize_t rsoffset;\n+  int d, n;\n+  bool continue_loop;\n+  gfc_expr **src, **dest;\n+\n+  if (!is_constant_array_expr (array))\n+    return NULL;\n+\n+  if (shift->rank > 0)\n+    gfc_simplify_expr (shift, 1);\n \n-  /* DIM is only useful for rank > 1, but deal with it here as one can\n-     set DIM = 1 for rank = 1.  */\n+  if (!gfc_is_constant_expr (shift))\n+    return NULL;\n+\n+  /* Make dim zero-based.  */\n   if (dim)\n     {\n       if (!gfc_is_constant_expr (dim))\n \treturn NULL;\n-      dm = mpz_get_si (dim->value.integer);\n+      which = mpz_get_si (dim->value.integer) - 1;\n     }\n   else\n-    dm = 1;\n+    which = 0;\n \n-  /* Copy array into 'a', simplify it, and then test for a constant array.  */\n-  a = gfc_copy_expr (array);\n-  gfc_simplify_expr (a, 0);\n-  if (!is_constant_array_expr (a))\n-    {\n-      gfc_free_expr (a);\n-      return NULL;\n-    }\n+  gfc_array_size (array, &size);\n+  arraysize = mpz_get_ui (size);\n+  mpz_clear (size);\n \n-  if (a->rank == 1)\n-    {\n-      gfc_constructor *ca, *cr;\n-      mpz_t size;\n-      int i, j, shft, sz;\n+  result = gfc_get_array_expr (array->ts.type, array->ts.kind, &array->where);\n+  result->shape = gfc_copy_shape (array->shape, array->rank);\n+  result->rank = array->rank;\n+  result->ts.u.derived = array->ts.u.derived;\n \n-      if (!gfc_is_constant_expr (shift))\n-\t{\n-\t  gfc_free_expr (a);\n-\t  return NULL;\n-\t}\n+  if (arraysize == 0)\n+    return result;\n \n-      shft = mpz_get_si (shift->value.integer);\n+  arrayvec = XCNEWVEC (gfc_expr *, arraysize);\n+  array_ctor = gfc_constructor_first (array->value.constructor);\n+  for (i = 0; i < arraysize; i++)\n+    {\n+      arrayvec[i] = array_ctor->expr;\n+      array_ctor = gfc_constructor_next (array_ctor);\n+    }\n \n-      /*  Case (i):  If ARRAY has rank one, element i of the result is\n-\t  ARRAY (1 + MODULO (i + SHIFT - 1, SIZE (ARRAY))).  */\n+  resultvec = XCNEWVEC (gfc_expr *, arraysize);\n \n-      mpz_init (size);\n-      gfc_array_size (a, &size);\n-      sz = mpz_get_si (size);\n-      mpz_clear (size);\n+  extent[0] = 1;\n+  count[0] = 0;\n \n-      /* Adjust shft to deal with right or left shifts. */\n-      shft = shft < 0 ? 1 - shft : shft;\n+  for (d=0; d < array->rank; d++)\n+    {\n+      a_extent[d] = mpz_get_si (array->shape[d]);\n+      a_stride[d] = d == 0 ? 1 : a_stride[d-1] * a_extent[d-1];\n+    }\n \n-      /* Special case: Shift to the original order!  */\n-      if (sz == 0 || shft % sz == 0)\n-\treturn a;\n+  if (shift->rank > 0)\n+    {\n+      gfc_array_size (shift, &size);\n+      shiftsize = mpz_get_ui (size);\n+      mpz_clear (size);\n+      shiftvec = XCNEWVEC (ssize_t, shiftsize);\n+      shift_ctor = gfc_constructor_first (shift->value.constructor);\n+      for (d = 0; d < shift->rank; d++)\n+\t{\n+\t  h_extent[d] = mpz_get_si (shift->shape[d]);\n+\t  hstride[d] = d == 0 ? 1 : hstride[d-1] * h_extent[d-1];\n+\t}\n+    }\n+  else\n+    shiftvec = NULL;\n+  \n+  /* Shut up compiler */\n+  len = 1;\n+  rsoffset = 1;\n \n-      result = gfc_copy_expr (a);\n-      cr = gfc_constructor_first (result->value.constructor);\n-      for (i = 0; i < sz; i++, cr = gfc_constructor_next (cr))\n+  n = 0;\n+  for (d=0; d < array->rank; d++)\n+    {\n+      if (d == which)\n+\t{\n+\t  rsoffset = a_stride[d];\n+\t  len = a_extent[d];\n+\t}\n+      else\n \t{\n-\t  j = (i + shft) % sz;\n-\t  ca = gfc_constructor_first (a->value.constructor);\n-\t  while (j-- > 0)\n-\t    ca = gfc_constructor_next (ca);\n-\t  cr->expr = gfc_copy_expr (ca->expr);\n+\t  count[n] = 0;\n+\t  extent[n] = a_extent[d];\n+\t  sstride[n] = a_stride[d];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  if (shiftvec)\n+\t    hs_ex[n] = hstride[n] * extent[n];\n+\t  n++;\n \t}\n+    }\n \n-      gfc_free_expr (a);\n-      return result;\n+  if (shiftvec)\n+    {\n+      for (i = 0; i < shiftsize; i++)\n+\t{\n+\t  ssize_t val;\n+\t  val = mpz_get_si (shift_ctor->expr->value.integer);\n+\t  val = val % len;\n+\t  if (val < 0)\n+\t    val += len;\n+\t  shiftvec[i] = val;\n+\t  shift_ctor = gfc_constructor_next (shift_ctor);\n+\t}\n+      shift_val = 0;\n     }\n   else\n     {\n-      /* FIXME: Deal with rank > 1 arrays.  For now, don't leak memory.  */\n+      shift_val = mpz_get_si (shift->value.integer);\n+      shift_val = shift_val % len;\n+      if (shift_val < 0)\n+\tshift_val += len;\n+    }\n \n-      /* GCC bootstrap is too stupid to realize that the above code for dm\n-\t is correct.  First, dim can be specified for a rank 1 array.  It is\n-\t not needed in this nor used here.  Second, the code is simply waiting\n-\t for someone to implement rank > 1 simplification.   For now, add a\n-\t pessimization to the code that has a zero valid reason to be here.  */\n-      if (dm > array->rank)\n-\tgcc_unreachable ();\n+  continue_loop = true;\n+  d = array->rank;\n+  rptr = resultvec;\n+  sptr = arrayvec;\n+  hptr = shiftvec;\n \n-      gfc_free_expr (a);\n+  while (continue_loop)\n+    {\n+      ssize_t sh;\n+      if (shiftvec)\n+\tsh = *hptr;\n+      else\n+\tsh = shift_val;\n+\n+      src = &sptr[sh * rsoffset];\n+      dest = rptr;\n+      for (n = 0; n < len - sh; n++)\n+\t{\n+\t  *dest = *src;\n+\t  dest += rsoffset;\n+\t  src += rsoffset;\n+\t}\n+      src = sptr;\n+      for ( n = 0; n < sh; n++)\n+\t{\n+\t  *dest = *src;\n+\t  dest += rsoffset;\n+\t  src += rsoffset;\n+\t}\n+      rptr += sstride[0];\n+      sptr += sstride[0];\n+      if (shiftvec)\n+\thptr += hstride[0];\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  rptr -= ss_ex[n];\n+\t  sptr -= ss_ex[n];\n+\t  if (shiftvec)\n+\t    hptr -= hs_ex[n];\n+\t  n++;\n+\t  if (n >= d - 1)\n+\t    {\n+\t      continue_loop = false;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      rptr += sstride[n];\n+\t      sptr += sstride[n];\n+\t      if (shiftvec)\n+\t\thptr += hstride[n];\n+\t    }\n+\t}\n     }\n \n-  return NULL;\n+  for (i = 0; i < arraysize; i++)\n+    {\n+      gfc_constructor_append_expr (&result->value.constructor,\n+\t\t\t\t   gfc_copy_expr (resultvec[i]),\n+\t\t\t\t   NULL);\n+    }\n+  return result;\n }\n \n "}, {"sha": "b77e73f8bbc8f9c7a1156f1e853e502316ee2690", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "patch": "@@ -1,3 +1,10 @@\n+2018-01-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45689\n+\tPR fortran/83650\n+\t* gfortran.dg/simplify_cshift_1.f90: Correct erroneous case.\n+\t* gfortran.dg/simplify_cshift_4.f90: New test.\n+\n 2018-01-02  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/81860"}, {"sha": "4bc8374eea70f9924818281cecf2b8956db33d9c", "filename": "gcc/testsuite/gfortran.dg/simplify_cshift_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_1.f90?ref=a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "patch": "@@ -23,12 +23,12 @@ program foo\n    v = cshift(c, 2)\n    if (any(b /= v)) call abort\n \n-   ! Special cases shift = 0, size(a), 1-size(a)\n+   ! Special cases shift = 0, size(a), -size(a)\n    b = cshift([1, 2, 3, 4, 5], 0)\n    if (any(b /= a)) call abort\n    b = cshift([1, 2, 3, 4, 5], size(a))\n    if (any(b /= a)) call abort\n-   b = cshift([1, 2, 3, 4, 5], 1-size(a))\n+   b = cshift([1, 2, 3, 4, 5], -size(a))\n    if (any(b /= a)) call abort\n \n    ! simplification of array arg."}, {"sha": "bbbe2a53941e9cd4d0f71395a56e14f82b0925f7", "filename": "gcc/testsuite/gfortran.dg/simplify_cshift_4.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_cshift_4.f90?ref=a9ec0cfc364b811d25bf8c84ad47e4d85f9a4766", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do  run }\n+program main\n+  implicit none\n+  integer :: i\n+  integer, parameter, dimension(3,3) :: a = &\n+       reshape([1,2,3,4,5,6,7,8,9], shape(a))\n+  integer, dimension(3,3) :: b\n+  integer, parameter, dimension(3,4,5) :: c = &\n+       reshape([(i**2,i=1,3*4*5)],shape(c))\n+  integer, dimension(3,4,5) :: d\n+  integer, dimension(4,5), parameter :: sh1 =&\n+       reshape([(i**3-12*i**2,i=1,4*5)],shape(sh1))\n+  integer, dimension(3,5), parameter :: sh2 = &\n+       reshape([(i**3-7*i**2,i=1,3*5)], shape(sh2))\n+  integer, dimension(3,4), parameter :: sh3 = &\n+       reshape([(i**3-3*i**2,i=1,3*4)], shape(sh3))\n+  integer, parameter, dimension(3,4,5) :: c1 = cshift(c,shift=sh1,dim=1)\n+  integer, parameter, dimension(3,4,5) :: c2 = cshift(c,shift=sh2,dim=2)\n+  integer, parameter, dimension(3,4,5) :: c3 = cshift(c,shift=sh3,dim=3)\n+\n+  b = a\n+  if (any(cshift(a,1) /= cshift(b,1))) call abort\n+  if (any(cshift(a,2) /= cshift(b,2))) call abort\n+  if (any(cshift(a,1,dim=2) /= cshift(b,1,dim=2))) call abort\n+  d = c\n+  if (any(cshift(c,1) /= cshift(d,1))) call abort\n+  if (any(cshift(c,2) /= cshift(d,2))) call abort\n+  if (any(cshift(c,3) /= cshift(d,3))) call abort\n+\n+  if (any(cshift(c,1,dim=2) /= cshift(d,1,dim=2))) call abort\n+  if (any(cshift(c,2,dim=2) /= cshift(d,2,dim=2))) call abort\n+  if (any(cshift(c,3,dim=3) /= cshift(d,3,dim=3))) call abort\n+\n+  if (any(cshift(d,shift=sh1,dim=1) /= c1)) call abort\n+  if (any(cshift(d,shift=sh2,dim=2) /= c2)) call abort\n+  if (any(cshift(d,shift=sh3,dim=3) /= c3)) call abort\n+end program main"}]}