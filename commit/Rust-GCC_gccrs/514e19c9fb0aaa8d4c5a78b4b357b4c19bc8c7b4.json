{"sha": "514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE0ZTE5YzlmYjBhYWE4ZDRjNWE3OGI0YjM1N2I0YzE5YmM4YzdiNA==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2003-02-22T14:16:29Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2003-02-22T14:16:29Z"}, "message": "New docs for Thread.java, and little tweaks identified by japi.\n\nFrom-SVN: r63284", "tree": {"sha": "99c6867f562957d85d0abe145f1a4541bd5d5b45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99c6867f562957d85d0abe145f1a4541bd5d5b45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "764c44147905290d394e056a99af320168696adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764c44147905290d394e056a99af320168696adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/764c44147905290d394e056a99af320168696adc"}], "stats": {"total": 576, "additions": 562, "deletions": 14}, "files": [{"sha": "c35bdf2bdb034a12d7561af876e6e096cea8983b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "patch": "@@ -1,3 +1,11 @@\n+2002-02-21  Anthony Green  <green@redhat.com>\n+\n+\t* java/lang/Thread.java (Thread): New constructor taking stack\n+\tsize parameter (ignored for now).\n+\t* Many methods: Merged GNU Classpath documentation.\n+\n+\t* java/lang/Class.java (finalize): throws a Throwable.\n+\n 2003-02-21  Mark Wielaard  <mark@klomp.org>\n \n \t* java/util/zip/ZipEntry.java (setComment): Don't check length when"}, {"sha": "44f5b5ab52938fc8f2d85934262c462089b60167", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "patch": "@@ -1,6 +1,6 @@\n // Class.java - Representation of a Java class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -346,7 +346,7 @@ private void checkMemberAccess (int flags)\n   private native void initializeClass ();\n \n   // finalization\n-  protected native void finalize ();\n+  protected native void finalize () throws Throwable;\n \n   /**\n    * Strip the last portion of the name (after the last dot)."}, {"sha": "33b0f450fa520f515cc40a073c3a6df83ec5071a", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 552, "deletions": 12, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=514e19c9fb0aaa8d4c5a78b4b357b4c19bc8c7b4", "patch": "@@ -1,6 +1,6 @@\n // Thread.java - Thread class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -12,109 +12,303 @@\n \n import gnu.gcj.RawData;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date August 24, 1998 \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete to version 1.3, with caveats. We do not \n+ * Status:  Believed complete to version 1.4, with caveats. We do not \n  *          implement the deprecated (and dangerous) stop, suspend, and resume\n  *          methods. Security implementation is not complete.\n  */\n \n+/**\n+ * Thread represents a single thread of execution in the VM. When an\n+ * application VM starts up, it creates a non-daemon Thread which calls the\n+ * main() method of a particular class.  There may be other Threads running,\n+ * such as the garbage collection thread.\n+ *\n+ * <p>Threads have names to identify them.  These names are not necessarily\n+ * unique. Every Thread has a priority, as well, which tells the VM which\n+ * Threads should get more running time. New threads inherit the priority\n+ * and daemon status of the parent thread, by default.\n+ *\n+ * <p>There are two methods of creating a Thread: you may subclass Thread and\n+ * implement the <code>run()</code> method, at which point you may start the\n+ * Thread by calling its <code>start()</code> method, or you may implement\n+ * <code>Runnable</code> in the class you want to use and then call new\n+ * <code>Thread(your_obj).start()</code>.\n+ *\n+ * <p>The virtual machine runs until all non-daemon threads have died (either\n+ * by returning from the run() method as invoked by start(), or by throwing\n+ * an uncaught exception); or until <code>System.exit</code> is called with\n+ * adequate permissions.\n+ *\n+ * <p>It is unclear at what point a Thread should be added to a ThreadGroup,\n+ * and at what point it should be removed. Should it be inserted when it\n+ * starts, or when it is created?  Should it be removed when it is suspended\n+ * or interrupted?  The only thing that is clear is that the Thread should be\n+ * removed when it is stopped.\n+ *\n+ * @author Tom Tromey\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see Runnable\n+ * @see Runtime#exit(int)\n+ * @see #run()\n+ * @see #start()\n+ * @see ThreadLocal\n+ * @since 1.0\n+ * @status updated to 1.4\n+ */\n public class Thread implements Runnable\n {\n+  /** The maximum priority for a Thread. */\n   public final static int MAX_PRIORITY = 10;\n+\n+  /** The minimum priority for a Thread. */\n   public final static int MIN_PRIORITY = 1;\n+\n+  /** The priority a Thread gets by default. */\n   public final static int NORM_PRIORITY = 5;\n \n+  /**\n+   * Get the number of active threads in the current Thread's ThreadGroup.\n+   * This implementation calls\n+   * <code>currentThread().getThreadGroup().activeCount()</code>.\n+   *\n+   * @return the number of active threads in the current ThreadGroup\n+   * @see ThreadGroup#activeCount()\n+   */\n   public static int activeCount ()\n   {\n     return currentThread().getThreadGroup().activeCount();\n   }\n \n+  /**\n+   * Check whether the current Thread is allowed to modify this Thread. This\n+   * passes the check on to <code>SecurityManager.checkAccess(this)</code>.\n+   *\n+   * @throws SecurityException if the current Thread cannot modify this Thread\n+   * @see SecurityManager#checkAccess(Thread)\n+   */\n   public final void checkAccess ()\n   {\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkAccess(this);\n   }\n \n+  /**\n+   * Count the number of stack frames in this Thread.  The Thread in question\n+   * must be suspended when this occurs.\n+   *\n+   * @return the number of stack frames in this Thread\n+   * @throws IllegalThreadStateException if this Thread is not suspended\n+   * @deprecated pointless, since suspend is deprecated\n+   */\n   public native int countStackFrames ();\n+\n+  /**\n+   * Get the currently executing Thread.\n+   *\n+   * @return the currently executing Thread\n+   */\n   public static native Thread currentThread ();\n+\n+  /**\n+   * Originally intended to destroy this thread, this method was never\n+   * implemented by Sun, and is hence a no-op.\n+   */\n   public native void destroy ();\n   \n+  /**\n+   * Print a stack trace of the current thread to stderr using the same\n+   * format as Throwable's printStackTrace() method.\n+   *\n+   * @see Throwable#printStackTrace()\n+   */\n   public static void dumpStack ()\n   {\n     (new Exception (\"Stack trace\")).printStackTrace ();\n   }\n \n+  /**\n+   * Copy every active thread in the current Thread's ThreadGroup into the\n+   * array. Extra threads are silently ignored. This implementation calls\n+   * <code>getThreadGroup().enumerate(array)</code>, which may have a\n+   * security check, <code>checkAccess(group)</code>.\n+   *\n+   * @param array the array to place the Threads into\n+   * @return the number of Threads placed into the array\n+   * @throws NullPointerException if array is null\n+   * @throws SecurityException if you cannot access the ThreadGroup\n+   * @see ThreadGroup#enumerate(Thread[])\n+   * @see #activeCount()\n+   * @see SecurityManager#checkAccess(ThreadGroup)\n+   */\n   public static int enumerate (Thread[] threads)\n   {\n     return currentThread().group.enumerate(threads);\n   }\n-\n+  \n+  /**\n+   * Get this Thread's name.\n+   *\n+   * @return this Thread's name\n+   */\n   public final String getName ()\n   {\n     return name;\n   }\n \n+  /**\n+   * Get this Thread's priority.\n+   *\n+   * @return the Thread's priority\n+   */\n   public final int getPriority ()\n   {\n     return priority;\n   }\n \n+  /**\n+   * Get the ThreadGroup this Thread belongs to. If the thread has died, this\n+   * returns null.\n+   *\n+   * @return this Thread's ThreadGroup\n+   */\n   public final ThreadGroup getThreadGroup ()\n   {\n     return group;\n   }\n \n+  /**\n+   * Interrupt this Thread. First, there is a security check,\n+   * <code>checkAccess</code>. Then, depending on the current state of the\n+   * thread, various actions take place:\n+   *\n+   * <p>If the thread is waiting because of {@link #wait()},\n+   * {@link #sleep(long)}, or {@link #join()}, its <i>interrupt status</i>\n+   * will be cleared, and an InterruptedException will be thrown. Notice that\n+   * this case is only possible if an external thread called interrupt().\n+   *\n+   * <p>If the thread is blocked in an interruptible I/O operation, in\n+   * {@link java.nio.channels.InterruptibleChannel}, the <i>interrupt\n+   * status</i> will be set, and ClosedByInterruptException will be thrown.\n+   *\n+   * <p>If the thread is blocked on a {@link java.nio.channels.Selector}, the\n+   * <i>interrupt status</i> will be set, and the selection will return, with\n+   * a possible non-zero value, as though by the wakeup() method.\n+   *\n+   * <p>Otherwise, the interrupt status will be set.\n+   *\n+   * @throws SecurityException if you cannot modify this Thread\n+   */\n   public native void interrupt ();\n \n+  /**\n+   * Determine whether the current Thread has been interrupted, and clear\n+   * the <i>interrupted status</i> in the process.\n+   *\n+   * @return whether the current Thread has been interrupted\n+   * @see #isInterrupted()\n+   */\n   public static boolean interrupted ()\n   {\n     return currentThread().isInterrupted (true);\n   }\n \n-  // Check the threads interrupted status. Note that this does not clear the\n-  // thread's interrupted status (per JDK 1.2 online API documentation).\n+  /**\n+   * Determine whether the given Thread has been interrupted, but leave\n+   * the <i>interrupted status</i> alone in the process.\n+   *\n+   * @return whether the current Thread has been interrupted\n+   * @see #interrupted()\n+   */\n   public boolean isInterrupted ()\n   {\n     return interrupt_flag;\n   }\n \n+  /**\n+   * Determine whether this Thread is alive. A thread which is alive has\n+   * started and not yet died.\n+   *\n+   * @return whether this Thread is alive\n+   */\n   public final boolean isAlive ()\n   {\n     return alive_flag;\n   }\n \n+  /**\n+   * Tell whether this is a daemon Thread or not.\n+   *\n+   * @return whether this is a daemon Thread or not\n+   * @see #setDaemon(boolean)\n+   */\n   public final boolean isDaemon ()\n   {\n     return daemon_flag;\n   }\n \n+  /**\n+   * Wait forever for the Thread in question to die.\n+   *\n+   * @throws InterruptedException if the Thread is interrupted; it's\n+   *         <i>interrupted status</i> will be cleared\n+   */\n   public final void join () throws InterruptedException\n   {\n     join (0, 0);\n   }\n \n+  /**\n+   * Wait the specified amount of time for the Thread in question to die.\n+   *\n+   * @param ms the number of milliseconds to wait, or 0 for forever\n+   * @throws InterruptedException if the Thread is interrupted; it's\n+   *         <i>interrupted status</i> will be cleared\n+   */\n   public final void join (long timeout) throws InterruptedException\n   {\n     join (timeout, 0);\n   }\n \n+  /**\n+   * Wait the specified amount of time for the Thread in question to die.\n+   *\n+   * <p>Note that 1,000,000 nanoseconds == 1 millisecond, but most VMs do\n+   * not offer that fine a grain of timing resolution. Besides, there is\n+   * no guarantee that this thread can start up immediately when time expires,\n+   * because some other thread may be active.  So don't expect real-time\n+   * performance.\n+   *\n+   * @param ms the number of milliseconds to wait, or 0 for forever\n+   * @param ns the number of extra nanoseconds to sleep (0-999999)\n+   * @throws InterruptedException if the Thread is interrupted; it's\n+   *         <i>interrupted status</i> will be cleared\n+   * @throws IllegalArgumentException if ns is invalid\n+   * @XXX A ThreadListener would be nice, to make this efficient.\n+   */\n   public final native void join (long timeout, int nanos)\n     throws InterruptedException;\n \n+  /**\n+   * Resume a suspended thread.\n+   *\n+   * @see #resume()\n+   */\n   public final native void resume ();\n \n   private final native void finish_ ();\n \n-  // Check the thread's interrupted status. If clear_flag is true, the \n-  // thread's interrupted status is also cleared.\n+  /**\n+   * Determine whether the given Thread has been interrupted, but leave\n+   * the <i>interrupted status</i> alone in the process.\n+   *\n+   * @return whether the current Thread has been interrupted\n+   * @see #interrupted()\n+   */\n   private boolean isInterrupted (boolean clear_flag)\n   {\n     boolean r = interrupt_flag;\n@@ -128,12 +322,31 @@ private boolean isInterrupted (boolean clear_flag)\n     return r;\n   }\n   \n+  /**\n+   * The method of Thread that will be run if there is no Runnable object\n+   * associated with the Thread. Thread's implementation does nothing at all.\n+   *\n+   * @see #start()\n+   * @see #Thread(ThreadGroup, Runnable, String)\n+   */\n   public void run ()\n   {\n     if (runnable != null)\n       runnable.run();\n   }\n \n+  /**\n+   * Set the daemon status of this Thread.  If this is a daemon Thread, then\n+   * the VM may exit even if it is still running.  This may only be called\n+   * before the Thread starts running. There may be a security check,\n+   * <code>checkAccess</code>.\n+   *\n+   * @param daemon whether this should be a daemon thread or not\n+   * @throws SecurityException if you cannot modify this Thread\n+   * @throws IllegalThreadStateException if the Thread is active\n+   * @see #isDaemon()\n+   * @see #checkAccess()\n+   */\n   public final void setDaemon (boolean status)\n   {\n     checkAccess ();\n@@ -142,6 +355,20 @@ public final void setDaemon (boolean status)\n     daemon_flag = status;\n   }\n \n+  /**\n+   * Returns the context classloader of this Thread. The context\n+   * classloader can be used by code that want to load classes depending\n+   * on the current thread. Normally classes are loaded depending on\n+   * the classloader of the current class. There may be a security check\n+   * for <code>RuntimePermission(\"getClassLoader\")</code> if the caller's\n+   * class loader is not null or an ancestor of this thread's context class\n+   * loader.\n+   *\n+   * @return the context class loader\n+   * @throws SecurityException when permission is denied\n+   * @see setContextClassLoader(ClassLoader)\n+   * @since 1.2\n+   */\n   public synchronized ClassLoader getContextClassLoader()\n   {\n     if (context_class_loader == null)\n@@ -168,6 +395,20 @@ public synchronized ClassLoader getContextClassLoader()\n     return context_class_loader;\n   }\n \n+  /**\n+   * Returns the context classloader of this Thread. The context\n+   * classloader can be used by code that want to load classes depending\n+   * on the current thread. Normally classes are loaded depending on\n+   * the classloader of the current class. There may be a security check\n+   * for <code>RuntimePermission(\"getClassLoader\")</code> if the caller's\n+   * class loader is not null or an ancestor of this thread's context class\n+   * loader.\n+   *\n+   * @return the context class loader\n+   * @throws SecurityException when permission is denied\n+   * @see setContextClassLoader(ClassLoader)\n+   * @since 1.2\n+   */\n   public synchronized void setContextClassLoader(ClassLoader cl)\n   {\n     SecurityManager s = System.getSecurityManager ();\n@@ -176,6 +417,14 @@ public synchronized void setContextClassLoader(ClassLoader cl)\n     context_class_loader = cl;\n   }\n \n+  /**\n+   * Set this Thread's name.  There may be a security check,\n+   * <code>checkAccess</code>.\n+   *\n+   * @param name the new name for this Thread\n+   * @throws NullPointerException if name is null\n+   * @throws SecurityException if you cannot modify this Thread\n+   */\n   public final void setName (String n)\n   {\n     checkAccess ();\n@@ -186,31 +435,181 @@ public final void setName (String n)\n     name = n;\n   }\n \n+  /**\n+   * Set this Thread's priority. There may be a security check,\n+   * <code>checkAccess</code>, then the priority is set to the smaller of\n+   * priority and the ThreadGroup maximum priority.\n+   *\n+   * @param priority the new priority for this Thread\n+   * @throws IllegalArgumentException if priority exceeds MIN_PRIORITY or\n+   *         MAX_PRIORITY\n+   * @throws SecurityException if you cannot modify this Thread\n+   * @see #getPriority()\n+   * @see #checkAccess()\n+   * @see ThreadGroup#getMaxPriority()\n+   * @see #MIN_PRIORITY\n+   * @see #MAX_PRIORITY\n+   */\n   public final native void setPriority (int newPriority);\n \n+  /**\n+   * Suspend the current Thread's execution for the specified amount of\n+   * time. The Thread will not lose any locks it has during this time. There\n+   * are no guarantees which thread will be next to run, but most VMs will\n+   * choose the highest priority thread that has been waiting longest.\n+   *\n+   * @param ms the number of milliseconds to sleep, or 0 for forever\n+   * @throws InterruptedException if the Thread is interrupted; it's\n+   *         <i>interrupted status</i> will be cleared\n+   * @see #notify()\n+   * @see #wait(long)\n+   */\n   public static void sleep (long timeout) throws InterruptedException\n   {\n     sleep (timeout, 0);\n   }\n \n+  /**\n+   * Suspend the current Thread's execution for the specified amount of\n+   * time. The Thread will not lose any locks it has during this time. There\n+   * are no guarantees which thread will be next to run, but most VMs will\n+   * choose the highest priority thread that has been waiting longest.\n+   *\n+   * <p>Note that 1,000,000 nanoseconds == 1 millisecond, but most VMs do\n+   * not offer that fine a grain of timing resolution. Besides, there is\n+   * no guarantee that this thread can start up immediately when time expires,\n+   * because some other thread may be active.  So don't expect real-time\n+   * performance.\n+   *\n+   * @param ms the number of milliseconds to sleep, or 0 for forever\n+   * @param ns the number of extra nanoseconds to sleep (0-999999)\n+   * @throws InterruptedException if the Thread is interrupted; it's\n+   *         <i>interrupted status</i> will be cleared\n+   * @throws IllegalArgumentException if ns is invalid\n+   * @see #notify()\n+   * @see #wait(long, int)\n+   */\n   public static native void sleep (long timeout, int nanos)\n     throws InterruptedException;\n+\n+  /**\n+   * Start this Thread, calling the run() method of the Runnable this Thread\n+   * was created with, or else the run() method of the Thread itself. This\n+   * is the only way to start a new thread; calling run by yourself will just\n+   * stay in the same thread. The virtual machine will remove the thread from\n+   * its thread group when the run() method completes.\n+   *\n+   * @throws IllegalThreadStateException if the thread has already started\n+   * @see #run()\n+   */\n   public native void start ();\n \n+  /**\n+   * Cause this Thread to stop abnormally because of the throw of a ThreadDeath\n+   * error. If you stop a Thread that has not yet started, it will stop\n+   * immediately when it is actually started.\n+   *\n+   * <p>This is inherently unsafe, as it can interrupt synchronized blocks and\n+   * leave data in bad states.  Hence, there is a security check:\n+   * <code>checkAccess(this)</code>, plus another one if the current thread\n+   * is not this: <code>RuntimePermission(\"stopThread\")</code>. If you must\n+   * catch a ThreadDeath, be sure to rethrow it after you have cleaned up.\n+   * ThreadDeath is the only exception which does not print a stack trace when\n+   * the thread dies.\n+   *\n+   * @throws SecurityException if you cannot stop the Thread\n+   * @see #interrupt()\n+   * @see #checkAccess()\n+   * @see #start()\n+   * @see ThreadDeath\n+   * @see ThreadGroup#uncaughtException(Thread, Throwable)\n+   * @see SecurityManager#checkAccess(Thread)\n+   * @see SecurityManager#checkPermission(Permission)\n+   * @deprecated unsafe operation, try not to use\n+   */\n   public final void stop ()\n   {\n     // Argument doesn't matter, because this is no longer\n     // supported.\n     stop (null);\n   }\n \n+  /**\n+   * Cause this Thread to stop abnormally and throw the specified exception.\n+   * If you stop a Thread that has not yet started, it will stop immediately\n+   * when it is actually started. <b>WARNING</b>This bypasses Java security,\n+   * and can throw a checked exception which the call stack is unprepared to\n+   * handle. Do not abuse this power.\n+   *\n+   * <p>This is inherently unsafe, as it can interrupt synchronized blocks and\n+   * leave data in bad states.  Hence, there is a security check:\n+   * <code>checkAccess(this)</code>, plus another one if the current thread\n+   * is not this: <code>RuntimePermission(\"stopThread\")</code>. If you must\n+   * catch a ThreadDeath, be sure to rethrow it after you have cleaned up.\n+   * ThreadDeath is the only exception which does not print a stack trace when\n+   * the thread dies.\n+   *\n+   * @param t the Throwable to throw when the Thread dies\n+   * @throws SecurityException if you cannot stop the Thread\n+   * @throws NullPointerException in the calling thread, if t is null\n+   * @see #interrupt()\n+   * @see #checkAccess()\n+   * @see #start()\n+   * @see ThreadDeath\n+   * @see ThreadGroup#uncaughtException(Thread, Throwable)\n+   * @see SecurityManager#checkAccess(Thread)\n+   * @see SecurityManager#checkPermission(Permission)\n+   * @deprecated unsafe operation, try not to use\n+   */\n   public final native void stop (Throwable e);\n+\n+  /**\n+   * Suspend this Thread.  It will not come back, ever, unless it is resumed.\n+   *\n+   * <p>This is inherently unsafe, as the suspended thread still holds locks,\n+   * and can potentially deadlock your program.  Hence, there is a security\n+   * check: <code>checkAccess</code>.\n+   *\n+   * @throws SecurityException if you cannot suspend the Thread\n+   * @see #checkAccess()\n+   * @see #resume()\n+   * @deprecated unsafe operation, try not to use\n+   */\n   public final native void suspend ();\n \n   private final native void initialize_native ();\n \n   private final native static String gen_name ();\n \n+  /**\n+   * Allocate a new Thread object, with the specified ThreadGroup and name, and\n+   * using the specified Runnable object's <code>run()</code> method to\n+   * execute.  If the Runnable object is null, <code>this</code> (which is\n+   * a Runnable) is used instead.\n+   *\n+   * <p>If the ThreadGroup is null, the security manager is checked. If a\n+   * manager exists and returns a non-null object for\n+   * <code>getThreadGroup</code>, that group is used; otherwise the group\n+   * of the creating thread is used. Note that the security manager calls\n+   * <code>checkAccess</code> if the ThreadGroup is not null.\n+   *\n+   * <p>The new Thread will inherit its creator's priority and daemon status.\n+   * These can be changed with <code>setPriority</code> and\n+   * <code>setDaemon</code>.\n+   *\n+   * @param group the group to put the Thread into\n+   * @param target the Runnable object to execute\n+   * @param name the name for the Thread\n+   * @throws NullPointerException if name is null\n+   * @throws SecurityException if this thread cannot access <code>group</code>\n+   * @throws IllegalThreadStateException if group is destroyed\n+   * @see Runnable#run()\n+   * @see #run()\n+   * @see #setDaemon(boolean)\n+   * @see #setPriority(int)\n+   * @see SecurityManager#checkAccess(ThreadGroup)\n+   * @see ThreadGroup#checkAccess()\n+   */\n   public Thread (ThreadGroup g, Runnable r, String n)\n   {\n     this (currentThread (), g, r, n);\n@@ -221,6 +620,37 @@ public Thread (ThreadGroup g, Runnable r, String n)\n       throw new NullPointerException ();\n   }\n \n+  /**\n+   * Allocate a new Thread object, as if by\n+   * <code>Thread(group, null, name)</code>, and give it the specified stack\n+   * size, in bytes. The stack size is <b>highly platform independent</b>,\n+   * and the virtual machine is free to round up or down, or ignore it\n+   * completely.  A higher value might let you go longer before a\n+   * <code>StackOverflowError</code>, while a lower value might let you go\n+   * longer before an <code>OutOfMemoryError</code>.  Or, it may do absolutely\n+   * nothing! So be careful, and expect to need to tune this value if your\n+   * virtual machine even supports it.\n+   *\n+   * @param group the group to put the Thread into\n+   * @param target the Runnable object to execute\n+   * @param name the name for the Thread\n+   * @param size the stack size, in bytes; 0 to be ignored\n+   * @throws NullPointerException if name is null\n+   * @throws SecurityException if this thread cannot access <code>group</code>\n+   * @throws IllegalThreadStateException if group is destroyed\n+   * @since 1.4\n+   */\n+  public Thread (ThreadGroup g, Runnable r, String n, long size)\n+  {\n+    // Just ignore stackSize for now.\n+    this (currentThread (), g, r, n);\n+\n+    // The Class Libraries book says ``threadName cannot be null''.  I\n+    // take this to mean NullPointerException.\n+    if (n == null)\n+      throw new NullPointerException ();\n+  }\n+\n   private Thread (Thread current, ThreadGroup g, Runnable r, String n)\n   {\n     if (g == null)\n@@ -264,42 +694,152 @@ private Thread (Thread current, ThreadGroup g, Runnable r, String n)\n     initialize_native ();\n   }\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, null,</code>\n+   * <i>gname</i><code>)</code>, where <b><i>gname</i></b> is\n+   * a newly generated name. Automatically generated names are of the\n+   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n+   * <p>\n+   * Threads created this way must have overridden their\n+   * <code>run()</code> method to actually do anything.  An example\n+   * illustrating this method being used follows:\n+   * <p><blockquote><pre>\n+   *     import java.lang.*;\n+   *\n+   *     class plain01 implements Runnable {\n+   *         String name;\n+   *         plain01() {\n+   *             name = null;\n+   *         }\n+   *         plain01(String s) {\n+   *             name = s;\n+   *         }\n+   *         public void run() {\n+   *             if (name == null)\n+   *                 System.out.println(\"A new thread created\");\n+   *             else\n+   *                 System.out.println(\"A new thread with name \" + name +\n+   *                                    \" created\");\n+   *         }\n+   *     }\n+   *     class threadtest01 {\n+   *         public static void main(String args[] ) {\n+   *             int failed = 0 ;\n+   *\n+   *             <b>Thread t1 = new Thread();</b>\n+   *             if (t1 != null)\n+   *                 System.out.println(\"new Thread() succeed\");\n+   *             else {\n+   *                 System.out.println(\"new Thread() failed\");\n+   *                 failed++;\n+   *             }\n+   *         }\n+   *     }\n+   * </pre></blockquote>\n+   *\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n   public Thread ()\n   {\n     this (null, null, gen_name ());\n   }\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, target,</code>\n+   * <i>gname</i><code>)</code>, where <i>gname</i> is\n+   * a newly generated name. Automatically generated names are of the\n+   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n+   *\n+   * @param   target   the object whose <code>run</code> method is called.\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n   public Thread (Runnable r)\n   {\n     this (null, r, gen_name ());\n   }\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, null, name)</code>.\n+   *\n+   * @param   name   the name of the new thread.\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n   public Thread (String n)\n   {\n     this (null, null, n);\n   }\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(group, target,</code>\n+   * <i>gname</i><code>)</code>, where <i>gname</i> is\n+   * a newly generated name. Automatically generated names are of the\n+   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n+   *\n+   * @param      group    the thread group.\n+   * @param      target   the object whose <code>run</code> method is called.\n+   * @exception  SecurityException  if the current thread cannot create a\n+   *             thread in the specified thread group.\n+   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *             java.lang.Runnable, java.lang.String)\n+   */\n   public Thread (ThreadGroup g, Runnable r)\n   {\n     this (g, r, gen_name ());\n   }\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(group, null, name)</code>\n+   *\n+   * @param      group   the thread group.\n+   * @param      name    the name of the new thread.\n+   * @exception  SecurityException  if the current thread cannot create a\n+   *               thread in the specified thread group.\n+   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n   public Thread (ThreadGroup g, String n)\n   {\n     this (g, null, n);\n   }\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, target, name)</code>.\n+   *\n+   * @param   target   the object whose <code>run</code> method is called.\n+   * @param   name     the name of the new thread.\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n   public Thread (Runnable r, String n)\n   {\n     this (null, r, n);\n   }\n \n+  /**\n+   * Returns a string representation of this thread, including the\n+   * thread's name, priority, and thread group.\n+   *\n+   * @return  a string representation of this thread.\n+   */\n   public String toString ()\n   {\n     return \"Thread[\" + name + \",\" + priority + \",\" + \n       (group == null ? \"\" : group.getName()) + \"]\";\n   }\n \n+  /**\n+   * Causes the currently executing thread object to temporarily pause\n+   * and allow other threads to execute.\n+   */\n   public static native void yield ();\n \n   // Private data."}]}