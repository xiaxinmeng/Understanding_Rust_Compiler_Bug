{"sha": "019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE5Mjc1YTJjYTA5ZDJiNGYyYjhkZjkxNjRiMWU4MDcyYjgwYzBkOA==", "commit": {"author": {"name": "Jan Beulich", "email": "jbeulich@novell.com", "date": "2005-06-20T06:45:27Z"}, "committer": {"name": "Jan Beulich", "email": "jbeulich@gcc.gnu.org", "date": "2005-06-20T06:45:27Z"}, "message": "netware-libgcc.def: Update copyright.\n\ngcc/\n2005-06-20  Jan Beulich  <jbeulich@novell.com>\n\n\t* config/i386/netware-libgcc.def: Update copyright.\n\t* config/i386/netware-libgcc.exp (__divdc3, __divsc3, __divxc3,\n\t__muldc3, __mulsc3, __mulxc3, __powidf2, __powisf2, __powixf2): Add.\n\t* config/i386/netware.c (gen_stdcall_decoration,\n\tgen_fastd_decoration): Merge into ...\n\t(gen_stdcall_or_fastcall_decoration): ... this. Adjust to match\n\tWinNT's changes.\n\t(gen_regparm_prefix): Adjust to match i386_nlm_encode_section_info.\n\t(i386_nlm_encode_section_info): Adjust to match WinNT's changes.\n\t* config/i386/t-nwld (SHLIB_LINK): Also create libgcc.imp alias of\n\tlibgcc_s.imp. Use 'expr' rather than $(()) shell expressions.\n\t* gthr-nks.h (__gthread_objc_mutex_allocate): Kill another dubious\n\tuse of NX_MUTEX_RECURSIVE.\n\ngcc/testsuite/\n2005-06-20  Jan Beulich  <jbeulich@novell.com>\n\n\t* g++.old-deja/g++.jason/thunk2.C: On NetWare, also account for\n\tunsupportable relocations.\n\t* g++.old-deja/g++.other/store-expr1.C: Likewise.\n\t* gcc.dg/20050321-2.c: xfail for NetWare.\n\nFrom-SVN: r101203", "tree": {"sha": "b0ae8a378c02cd5ad47248778b5d76adebef2901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ae8a378c02cd5ad47248778b5d76adebef2901"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/comments", "author": null, "committer": null, "parents": [{"sha": "574932784c71f152d36548edd50388def8cfca57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574932784c71f152d36548edd50388def8cfca57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574932784c71f152d36548edd50388def8cfca57"}], "stats": {"total": 234, "additions": 126, "deletions": 108}, "files": [{"sha": "92c4299a1d550399d6107e1ddf762ba2219b5f05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -1,3 +1,19 @@\n+2005-06-20  Jan Beulich  <jbeulich@novell.com>\n+\n+\t* config/i386/netware-libgcc.def: Update copyright.\n+\t* config/i386/netware-libgcc.exp (__divdc3, __divsc3, __divxc3,\n+\t__muldc3, __mulsc3, __mulxc3, __powidf2, __powisf2, __powixf2): Add.\n+\t* config/i386/netware.c (gen_stdcall_decoration,\n+\tgen_fastd_decoration): Merge into ...\n+\t(gen_stdcall_or_fastcall_decoration): ... this. Adjust to match\n+\tWinNT's changes.\n+\t(gen_regparm_prefix): Adjust to match i386_nlm_encode_section_info.\n+\t(i386_nlm_encode_section_info): Adjust to match WinNT's changes.\n+\t* config/i386/t-nwld (SHLIB_LINK): Also create libgcc.imp alias of\n+\tlibgcc_s.imp. Use 'expr' rather than $(()) shell expressions.\n+\t* gthr-nks.h (__gthread_objc_mutex_allocate): Kill another dubious\n+\tuse of NX_MUTEX_RECURSIVE.\n+\n 2005-06-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (swap_tree_comparison): Add support for unordered"}, {"sha": "a545631b111474b0e394edfba30b51be1f80d441", "filename": "gcc/config/i386/netware-libgcc.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Fnetware-libgcc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Fnetware-libgcc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetware-libgcc.def?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -1,2 +1,2 @@\n description \"gcc runtime and intrinsics support\"\n-copyright \"Copyright (C) 1989-2004  Free Software Foundation, Inc.\"\n+copyright \"Copyright (C) 1989-2005  Free Software Foundation, Inc.\""}, {"sha": "a3498c0e7206100f2a47f98772fea017dc3c1456", "filename": "gcc/config/i386/netware-libgcc.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Fnetware-libgcc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Fnetware-libgcc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetware-libgcc.exp?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -13,7 +13,11 @@\n \t__deregister_frame,\n \t__deregister_frame_info,\n \t__deregister_frame_info_bases,\n+\t__divdc3,\n #\t__divdi3,\n+\t__divsc3,\n+#\t__divtc3,\n+\t__divxc3,\n \t__ffsdi2,\n \t__ffssi2,\n \t__fixunsdfdi,\n@@ -24,15 +28,23 @@\n \t__gcc_personality_v0,\n #\t__lshrdi3,\n #\t__moddi3,\n+\t__muldc3,\n #\t__muldi3,\n+\t__mulsc3,\n+#\t__multc3,\n \t__mulvdi3,\n \t__mulvsi3,\n+\t__mulxc3,\n \t__negvdi2,\n \t__negvsi2,\n \t__paritydi2,\n \t__paritysi2,\n \t__popcountdi2,\n \t__popcountsi2,\n+\t__powidf2\n+\t__powisf2\n+#\t__powitf2\n+\t__powixf2\n \t__register_frame,\n \t__register_frame_info,\n \t__register_frame_info_bases,"}, {"sha": "f6ab99fc299a0b0cbf1604d0a1381d62d94cdb4e", "filename": "gcc/config/i386/netware.c", "status": "modified", "additions": 83, "deletions": 102, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Fnetware.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Fnetware.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetware.c?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -38,122 +38,96 @@ Boston, MA 02111-1307, USA.  */\n    underscore prefix and a suffix consisting of an atsign (@) followed\n    by the number of bytes of arguments */\n \n-static const char *\n-gen_stdcall_decoration (tree decl)\n+static tree\n+gen_stdcall_or_fastcall_decoration (tree decl, char prefix)\n {\n   unsigned total = 0;\n   /* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead\n      of DECL_ASSEMBLER_NAME.  */\n   const char *asmname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   char *newsym;\n+  tree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n-  if (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n-    if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (decl))))\n-        == void_type_node)\n-      {\n-\ttree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\n-\t/* Quit if we hit an incomplete type.  Error is reported\n-\t   by convert_arguments in c-typeck.c or cp/typeck.c.  */\n-\twhile (TREE_VALUE (formal_type) != void_type_node\n-\t       && COMPLETE_TYPE_P (TREE_VALUE (formal_type)))\t\n-\t  {\n-\t    unsigned parm_size\n-\t      = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));\n-\t    /* Must round up to include padding.  This is done the same\n-\t       way as in store_one_arg.  */\n-\t    parm_size = ((parm_size + PARM_BOUNDARY - 1)\n-\t\t\t / PARM_BOUNDARY * PARM_BOUNDARY);\n-\t    total += parm_size;\n-\t    formal_type = TREE_CHAIN (formal_type);\n-\t  }\n-      }\n-\n-  newsym = alloca (1 + strlen (asmname) + 1 + 10 + 1);\n-  return IDENTIFIER_POINTER (get_identifier_with_length (newsym,\n-\tsprintf (newsym, \"_%s@%u\", asmname, total / BITS_PER_UNIT)));\n-}\n-\n-/* Return string which is the former assembler name modified with a\n-   prefix consisting of FASTCALL_PREFIX and a suffix consisting of an\n-   atsign (@) followed by the number of bytes of arguments.  */\n-\n-static const char *\n-gen_fastcall_decoration (tree decl)\n-{\n-  unsigned total = 0;\n-  const char *asmname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  char *newsym;\n-\n-  if (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n-    if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (decl))))\n-        == void_type_node)\n-      {\n-\ttree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\n-\t/* Quit if we hit an incomplete type.  Error is reported\n-\t   by convert_arguments in c-typeck.c or cp/typeck.c.  */\n-\twhile (TREE_VALUE (formal_type) != void_type_node\n-\t       && COMPLETE_TYPE_P (TREE_VALUE (formal_type)))\t\n-\t  {\n-\t    int parm_size\n-\t      = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));\n-\t    /* Must round up to include padding.  This is done the same\n-\t       way as in store_one_arg.  */\n-\t    parm_size = ((parm_size + PARM_BOUNDARY - 1)\n-\t\t\t / PARM_BOUNDARY * PARM_BOUNDARY);\n-\t    total += parm_size;\n-\t    formal_type = TREE_CHAIN (formal_type);\n-\t  }\n-      }\n+  if (formal_type != NULL_TREE)\n+    {\n+      /* These attributes are ignored for variadic functions in\n+\t i386.c:ix86_return_pops_args. For compatibility with MS\n+\t compiler do not add @0 suffix here.  */ \n+      if (TREE_VALUE (tree_last (formal_type)) != void_type_node)\n+\treturn NULL_TREE;\n+\n+      /* Quit if we hit an incomplete type.  Error is reported\n+\t by convert_arguments in c-typeck.c or cp/typeck.c.  */\n+      while (TREE_VALUE (formal_type) != void_type_node\n+\t     && COMPLETE_TYPE_P (TREE_VALUE (formal_type)))\t\n+\t{\n+\t  unsigned parm_size\n+\t    = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));\n+\n+\t  /* Must round up to include padding.  This is done the same\n+\t     way as in store_one_arg.  */\n+\t  parm_size = ((parm_size + PARM_BOUNDARY - 1)\n+\t\t       / PARM_BOUNDARY * PARM_BOUNDARY);\n+\t  total += parm_size;\n+\t  formal_type = TREE_CHAIN (formal_type);\n+\t}\n+    }\n \n   newsym = alloca (1 + strlen (asmname) + 1 + 10 + 1);\n-  return IDENTIFIER_POINTER (get_identifier_with_length (newsym,\n-\tsprintf (newsym, \"%c%s@%d\", FASTCALL_PREFIX, asmname,\n-\t\t total / BITS_PER_UNIT)));\n+  return get_identifier_with_length (newsym,\n+\t\t\t\t     sprintf (newsym,\n+\t\t\t\t\t      \"%c%s@%u\",\n+\t\t\t\t\t      prefix,\n+\t\t\t\t\t      asmname,\n+\t\t\t\t\t      total / BITS_PER_UNIT));\n }\n \n /* Return string which is the former assembler name modified with an \n    _n@ prefix where n represents the number of arguments passed in\n    registers */\n \n-static const char *\n+static tree\n gen_regparm_prefix (tree decl, unsigned nregs)\n {\n   unsigned total = 0;\n   /* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead\n      of DECL_ASSEMBLER_NAME.  */\n   const char *asmname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   char *newsym;\n+  tree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n-  if (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n-    if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (decl))))\n-        == void_type_node)\n-      {\n-\ttree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\n-\t/* Quit if we hit an incomplete type.  Error is reported\n-\t   by convert_arguments in c-typeck.c or cp/typeck.c.  */\n-\twhile (TREE_VALUE (formal_type) != void_type_node\n-\t       && COMPLETE_TYPE_P (TREE_VALUE (formal_type)))\t\n-\t  {\n-\t    unsigned parm_size\n-\t      = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));\n-\t    /* Must round up to include padding.  This is done the same\n-\t       way as in store_one_arg.  */\n-\t    parm_size = ((parm_size + PARM_BOUNDARY - 1)\n-\t\t\t / PARM_BOUNDARY * PARM_BOUNDARY);\n-\t    total += parm_size;\n-\t    formal_type = TREE_CHAIN (formal_type);\n-\t  }\n-      }\n+  if (formal_type != NULL_TREE)\n+    {\n+      /* This attribute is ignored for variadic functions.  */ \n+      if (TREE_VALUE (tree_last (formal_type)) != void_type_node)\n+\treturn NULL_TREE;\n+\n+      /* Quit if we hit an incomplete type.  Error is reported\n+\t by convert_arguments in c-typeck.c or cp/typeck.c.  */\n+      while (TREE_VALUE (formal_type) != void_type_node\n+\t     && COMPLETE_TYPE_P (TREE_VALUE (formal_type)))\t\n+\t{\n+\t  unsigned parm_size\n+\t    = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));\n+\n+\t  /* Must round up to include padding.  This is done the same\n+\t     way as in store_one_arg.  */\n+\t  parm_size = ((parm_size + PARM_BOUNDARY - 1)\n+\t\t       / PARM_BOUNDARY * PARM_BOUNDARY);\n+\t  total += parm_size;\n+\t  formal_type = TREE_CHAIN (formal_type);\n+\t}\n+    }\n \n   if (nregs > total / BITS_PER_WORD)\n     nregs = total / BITS_PER_WORD;\n   gcc_assert (nregs <= 9);\n-  newsym = alloca (2 + strlen (asmname) + 1 + 1);\n-  return IDENTIFIER_POINTER (get_identifier_with_length (newsym,\n-\tsprintf (newsym, \"_%u@%s\", nregs, asmname)));\n+  newsym = alloca (3 + strlen (asmname) + 1);\n+  return get_identifier_with_length (newsym,\n+\t\t\t\t     sprintf (newsym,\n+\t\t\t\t\t      \"_%u@%s\",\n+\t\t\t\t\t      nregs,\n+\t\t\t\t\t      asmname));\n }\n \n void\n@@ -163,24 +137,31 @@ i386_nlm_encode_section_info (tree decl, rtx rtl, int first)\n \n   if (first\n       && TREE_CODE (decl) == FUNCTION_DECL\n-      && *IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)) != '*')\n+      && *IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)) != '*'\n+      && !strchr (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), '@'))\n     {\n       tree type_attributes = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n-      rtx rtlname = XEXP (rtl, 0);\n-      if (GET_CODE (rtlname) == MEM)\n-\trtlname = XEXP (rtlname, 0);\n+      tree newid;\n+\n       if (lookup_attribute (\"stdcall\", type_attributes))\n-\tXSTR (rtlname, 0) = gen_stdcall_decoration (decl);\n+\tnewid = gen_stdcall_or_fastcall_decoration (decl, '_');\n       else if (lookup_attribute (\"fastcall\", type_attributes))\n-\tXSTR (rtlname, 0) = gen_fastcall_decoration (decl);\n-      else\n+\tnewid = gen_stdcall_or_fastcall_decoration (decl, FASTCALL_PREFIX);\n+      else if ((newid = lookup_attribute (\"regparm\", type_attributes)) != NULL_TREE)\n+\tnewid = gen_regparm_prefix (decl,\n+\t\t      TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (newid))));\n+      if (newid != NULL_TREE) \t\n \t{\n-\t  tree attr = lookup_attribute (\"regparm\", type_attributes);\n-\n-\t  if (attr)\n-\t    XSTR (rtlname, 0) =\n-\t      gen_regparm_prefix (decl,\n-\t\t      TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr))));\n+\t  rtx rtlname = XEXP (rtl, 0);\n+\n+\t  if (GET_CODE (rtlname) == MEM)\n+\t    rtlname = XEXP (rtlname, 0);\n+\t  XSTR (rtlname, 0) = IDENTIFIER_POINTER (newid);\n+\t  /* These attributes must be present on first declaration,\n+\t     change_decl_assembler_name will warn if they are added\n+\t     later and the decl has been referenced, but duplicate_decls\n+\t     should catch the mismatch before this is called.  */ \n+\t  change_decl_assembler_name (decl, newid);\n \t}\n     }\n }"}, {"sha": "fbca0dfe933585d942e0dbced5d56230b8d8f1f3", "filename": "gcc/config/i386/t-nwld", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Ft-nwld", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fconfig%2Fi386%2Ft-nwld", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-nwld?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -40,7 +40,7 @@ SHLIB_LINK = set -e; \\\n \techo \"name $(SHLIB_NAME)\" >>@shlib_base_name@.def; \\\n \techo \"version $(version)\" | sed \"s!\\.!,!g\" >>@shlib_base_name@.def; \\\n \ttouch libgcc/build; \\\n-\techo \"build $$$$(($$$$(<libgcc/build)+0))\" >>@shlib_base_name@.def; \\\n+\techo \"build $$$$(expr $$$$(<libgcc/build)+0)\" >>@shlib_base_name@.def; \\\n \techo \"export @$(SHLIB_MAP)\" >>@shlib_base_name@.def; \\\n \tif mpkxdc -n -p @shlib_base_name@.xdc; \\\n \t\tthen echo \"xdcdata @shlib_base_name@.xdc\" >>@shlib_base_name@.def; \\\n@@ -50,7 +50,8 @@ SHLIB_LINK = set -e; \\\n \t\t$(SHLIB_SRC) -posix -static-libgcc -lnetware \\\n \t\t-Wl,--Map,--map-info,full,--strip-all,--def-file,@shlib_base_name@.def; \\\n \trm -f @shlib_base_name@.imp; $(LN_S) $(SHLIB_MAP) @shlib_base_name@.imp; \\\n-\techo $$$$(($$$$(<libgcc/build)+1)) >libgcc/build\n+\trm -f libgcc.imp; $(LN_S) @shlib_base_name@.imp libgcc.imp; \\\n+\texpr $$$$(<libgcc/build)+1 >libgcc/build\n \n # $(slibdir) double quoted to protect it from expansion while building\n # libgcc.mk.  We want this delayed until actual install time."}, {"sha": "a9ac854c715733c2dd7d7e76958bd111033828f6", "filename": "gcc/gthr-nks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fgthr-nks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Fgthr-nks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-nks.h?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -178,7 +178,7 @@ __gthread_objc_mutex_allocate (objc_mutex_t mutex)\n {\n   static const NX_LOCK_INFO_ALLOC (info, \"GNU ObjC\", 0);\n \n-  if ((mutex->backend = NXMutexAlloc (NX_MUTEX_RECURSIVE/*???*/, 0, &info)) == NULL)\n+  if ((mutex->backend = NXMutexAlloc (0, 0, &info)) == NULL)\n     return 0;\n   return -1;\n }"}, {"sha": "baeae2779a666133aa60a8561e913cfbe86f54c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -1,3 +1,10 @@\n+2005-06-20  Jan Beulich  <jbeulich@novell.com>\n+\n+\t* g++.old-deja/g++.jason/thunk2.C: On NetWare, also account for\n+\tunsupportable relocations.\n+\t* g++.old-deja/g++.other/store-expr1.C: Likewise.\n+\t* gcc.dg/20050321-2.c: xfail for NetWare.\n+\n 2005-06-20  Andreas Jaeger  <aj@suse.de>\n \n \t* gcc.target/i386/sseregparm-1.c, gcc.target/i386/sseregparm-2.c,"}, {"sha": "12c6449e9384b50cf00bf05e25a2c90822b049b4", "filename": "gcc/testsuite/g++.old-deja/g++.jason/thunk2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fthunk2.C?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -1,6 +1,6 @@\n // { dg-do run }\n // { dg-options \"-fPIC\" }\n-// { dg-bogus \"\\[Uu\\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\\[_.A-Za-z\\]\\[_.0-9A-Za-z\\]*@(PLT|GOT|GOTOFF))\" \"PIC unsupported\" { xfail *-*-netware* } 0 }\n+// { dg-bogus \"\\[Uu\\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\\[_.A-Za-z\\]\\[_.0-9A-Za-z\\]*@(PLT|GOT|GOTOFF))|\\[Bb\\]ad fixup at .DATA.:\" \"PIC unsupported\" { xfail *-*-netware* } 0 }\n // Test that non-variadic function calls using thunks and PIC work right.\n \n struct A {"}, {"sha": "c1b19536be84bf91c689032cb752773c368fed8c", "filename": "gcc/testsuite/g++.old-deja/g++.other/store-expr1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstore-expr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstore-expr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstore-expr1.C?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -1,7 +1,7 @@\n // { dg-do run { target i?86-*-* x86_64-*-* } }\n // { dg-require-effective-target ilp32 }\n // { dg-options \"-mtune=i686 -O2 -fpic\" }\n-// { dg-bogus \"\\[Uu\\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\\[_.A-Za-z\\]\\[_.0-9A-Za-z\\]*@(PLT|GOT|GOTOFF))\" \"PIC unsupported\" { xfail *-*-netware* } 0 }\n+// { dg-bogus \"\\[Uu\\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\\[_.A-Za-z\\]\\[_.0-9A-Za-z\\]*@(PLT|GOT|GOTOFF))|\\[Bb\\]ad fixup at .DATA.:\" \"PIC unsupported\" { xfail *-*-netware* } 0 }\n class G {};\n \n struct N {"}, {"sha": "06d87cc225bba6a0dc10d7d1ec28300ac6a24a29", "filename": "gcc/testsuite/gcc.dg/20050321-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2Fgcc.dg%2F20050321-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/019275a2ca09d2b4f2b8df9164b1e8072b80c0d8/gcc%2Ftestsuite%2Fgcc.dg%2F20050321-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20050321-2.c?ref=019275a2ca09d2b4f2b8df9164b1e8072b80c0d8", "patch": "@@ -5,6 +5,7 @@\n    figure out branch to lab is too far.  */\n /* { dg-do link { target fpic } } */\n /* { dg-options \"-g1 -fpic\" } */\n+/* { dg-bogus \"\\[Uu\\]nresolved symbol .(_GLOBAL_OFFSET_TABLE_|\\[_.A-Za-z\\]\\[_.0-9A-Za-z\\]*@(PLT|GOT|GOTOFF))\" \"PIC unsupported\" { xfail *-*-netware* } 0 } */\n \n #define A(n) \\\n   case n##1: return n##1 * 131 + 63;\t\\"}]}