{"sha": "ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyOWIxMmNmYmI0OTc5YTg5YjNjYmFkYmY0ODVhNzdjOGZkOGZjZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-12-14T00:52:46Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-12-14T00:52:46Z"}, "message": "PR middle-end/91582 - missing heap overflow detection for strcpy\n\nPR middle-end/91582 - missing heap overflow detection for strcpy\nPR middle-end/92868 - ICE: tree check: expected integer_cst, have ssa_name\n\ngcc/ChangeLog:\n\n\tPR middle-end/91582\n\tPR middle-end/92868\n\t* builtins.c (addr_decl_size): New function.\n\t(gimple_call_alloc_size): Add arguments.\n\t(compute_objsize): Add an argument.  Set *PDECL even for allocated\n\tobjects.\n\tCorrect checking for negative wide_int.\n\tCorrect handling of negative outer offsets into unknown regions\n\tor with unknown inner offsets.\n\tExtend offsets to at most sizetype precision.\n\tOnly handle constant subobject sizes.\n\t* builtins.h (gimple_call_alloc_size): Add arguments.\n\t* tree.c (component_ref_size): Always return sizetype.\n\t* tree-ssa-strlen.c (strinfo::alloc): New member.\n\t(get_addr_stridx): Add argument.\n\t(get_stridx): Use ptrdiff_t.  Add argument.\n\t(new_strinfo): Set new member.\n\t(get_string_length): Handle alloca and VLA.\n\t(dump_strlen_info): Dump more state.\n\t(maybe_invalidate): Print more info.  Decrease indentation.\n\t(unshare_strinfo): Set new member.\n\t(valid_builtin_call): Handle alloca and VLA.\n\t(maybe_warn_overflow): Check and set no-warning bit.  Improve\n\thandling of offsets.  Print allocated objects.\n\t(handle_builtin_strlen): Handle strinfo records with null lengths.\n\t(handle_builtin_strcpy): Add argument.  Call maybe_warn_overflow.\n\t(is_strlen_related_p): Handle dynamically allocated objects.\n\t(get_range): Add argument.\n\t(handle_builtin_malloc): Rename...\n\t(handle_alloc): ...to this and handle all allocation functions.\n\t(handle_builtin_memset): Call maybe_warn_overflow.\n\t(count_nonzero_bytes): Handle more MEM_REF forms.\n\t(strlen_check_and_optimize_call): Call handle_alloc_call.  Pass\n\targuments to more callees.\n\t(handle_integral_assign): Add argument.  Create strinfo entries\n\tfor MEM_REF assignments.\n\t(check_and_optimize_stmt): Handle more MEM_REF forms.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/91582\n\t* c-c++-common/Wrestrict.c: Adjust expected warnings.\n\t* gcc/testsuite/c-c++-common/Wstringop-truncation-4.c: Enable more\n\twarnings.\n\t* gcc/testsuite/c-c++-common/Wstringop-truncation.c: Remove an xfail.\n\t* gcc.dg/Warray-bounds-46.c: Disable -Wstringop-overflow.\n\t* gcc.dg/Warray-bounds-47.c: Same.\n\t* gcc.dg/Warray-bounds-52.c: New test.\n\t* gcc.dg/Wstringop-overflow-27.c: New test.\n\t* gcc.dg/Wstringop-overflow-28.c: New test.\n\t* gcc.dg/Wstringop-overflow-29.c: New test.\n\t* gcc.dg/attr-alloc_size.c (test): Disable -Warray-bounds.\n\t* gcc.dg/attr-copy-2.c: Adjust expected warnings.\n\t* gcc.dg/builtin-stringop-chk-5.c: Adjust text of expected messages.\n\t* gcc.dg/strlenopt-86.c: Relax test.\n\t* gcc.target/i386/pr82002-1.c: Prune expected warnings.\n\nFrom-SVN: r279392", "tree": {"sha": "93fd1dc052be8520f98f160111e843d5a497aaf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93fd1dc052be8520f98f160111e843d5a497aaf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e78b9a6fcaf4ec0e89f8d9bb746747ec4df0eee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78b9a6fcaf4ec0e89f8d9bb746747ec4df0eee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78b9a6fcaf4ec0e89f8d9bb746747ec4df0eee9"}], "stats": {"total": 1935, "additions": 1543, "deletions": 392}, "files": [{"sha": "5073ffaf3b9d1fa1fc1259757c936c9c61889e34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -1,3 +1,43 @@\n+2019-12-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91582\n+\tPR middle-end/92868\n+\t* builtins.c (addr_decl_size): New function.\n+\t(gimple_call_alloc_size): Add arguments.\n+\t(compute_objsize): Add an argument.  Set *PDECL even for allocated\n+\tobjects.\n+\tCorrect checking for negative wide_int.\n+\tCorrect handling of negative outer offsets into unknown regions\n+\tor with unknown inner offsets.\n+\tExtend offsets to at most sizetype precision.\n+\tOnly handle constant subobject sizes.\n+\t* builtins.h (gimple_call_alloc_size): Add arguments.\n+\t* tree.c (component_ref_size): Always return sizetype.\n+\t* tree-ssa-strlen.c (strinfo::alloc): New member.\n+\t(get_addr_stridx): Add argument.\n+\t(get_stridx): Use ptrdiff_t.  Add argument.\n+\t(new_strinfo): Set new member.\n+\t(get_string_length): Handle alloca and VLA.\n+\t(dump_strlen_info): Dump more state.\n+\t(maybe_invalidate): Print more info.  Decrease indentation.\n+\t(unshare_strinfo): Set new member.\n+\t(valid_builtin_call): Handle alloca and VLA.\n+\t(maybe_warn_overflow): Check and set no-warning bit.  Improve\n+\thandling of offsets.  Print allocated objects.\n+\t(handle_builtin_strlen): Handle strinfo records with null lengths.\n+\t(handle_builtin_strcpy): Add argument.  Call maybe_warn_overflow.\n+\t(is_strlen_related_p): Handle dynamically allocated objects.\n+\t(get_range): Add argument.\n+\t(handle_builtin_malloc): Rename...\n+\t(handle_alloc): ...to this and handle all allocation functions.\n+\t(handle_builtin_memset): Call maybe_warn_overflow.\n+\t(count_nonzero_bytes): Handle more MEM_REF forms.\n+\t(strlen_check_and_optimize_call): Call handle_alloc_call.  Pass\n+\targuments to more callees.\n+\t(handle_integral_assign): Add argument.  Create strinfo entries\n+\tfor MEM_REF assignments.\n+\t(check_and_optimize_stmt): Handle more MEM_REF forms.\n+\n 2019-12-13  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/rs6000/darwin.h (DARWIN_DYLIB1_SPEC): New."}, {"sha": "3e89f2a7f26ffa7318848ad5b6a46b79a5445144", "filename": "gcc/builtins.c", "status": "modified", "additions": 158, "deletions": 101, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"varasm.h\"\n #include \"tree-object-size.h\"\n+#include \"tree-ssa-strlen.h\"\n #include \"realmpfr.h\"\n #include \"cfgrtl.h\"\n #include \"except.h\"\n@@ -3696,11 +3697,13 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   return true;\n }\n \n-/* If STMT is a call to an allocation function, returns the size\n-   of the object allocated by the call.  */\n+/* If STMT is a call to an allocation function, returns the constant\n+   size of the object allocated by the call represented as sizetype.\n+   If nonnull, sets RNG1[] to the range of the size.  */\n \n tree\n-gimple_call_alloc_size (gimple *stmt)\n+gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n+\t\t\tconst vr_values *rvals /* = NULL */)\n {\n   if (!stmt)\n     return NULL_TREE;\n@@ -3747,11 +3750,12 @@ gimple_call_alloc_size (gimple *stmt)\n \n   tree size = gimple_call_arg (stmt, argidx1);\n \n-  wide_int rng1[2];\n-  if (TREE_CODE (size) == INTEGER_CST)\n-    rng1[0] = rng1[1] = wi::to_wide (size);\n-  else if (TREE_CODE (size) != SSA_NAME\n-\t   || get_range_info (size, rng1, rng1 + 1) != VR_RANGE)\n+  wide_int rng1_buf[2];\n+  /* If RNG1 is not set, use the buffer.  */\n+  if (!rng1)\n+    rng1 = rng1_buf;\n+\n+  if (!get_range (size, rng1, rvals))\n     return NULL_TREE;\n \n   if (argidx2 > nargs && TREE_CODE (size) == INTEGER_CST)\n@@ -3761,20 +3765,18 @@ gimple_call_alloc_size (gimple *stmt)\n      of the upper bounds as a constant.  Ignore anti-ranges.  */\n   tree n = argidx2 < nargs ? gimple_call_arg (stmt, argidx2) : integer_one_node;\n   wide_int rng2[2];\n-  if (TREE_CODE (n) == INTEGER_CST)\n-    rng2[0] = rng2[1] = wi::to_wide (n);\n-  else if (TREE_CODE (n) != SSA_NAME\n-\t   || get_range_info (n, rng2, rng2 + 1) != VR_RANGE)\n+  if (!get_range (n, rng2, rvals))\n     return NULL_TREE;\n \n-  /* Extend to the maximum precsion to avoid overflow.  */\n+  /* Extend to the maximum precision to avoid overflow.  */\n   const int prec = ADDR_MAX_PRECISION;\n   rng1[0] = wide_int::from (rng1[0], prec, UNSIGNED);\n   rng1[1] = wide_int::from (rng1[1], prec, UNSIGNED);\n   rng2[0] = wide_int::from (rng2[0], prec, UNSIGNED);\n   rng2[1] = wide_int::from (rng2[1], prec, UNSIGNED);\n \n-  /* Return the lesser of SIZE_MAX and the product of the upper bounds.  */\n+  /* Compute products of both bounds for the caller but return the lesser\n+     of SIZE_MAX and the product of the upper bounds as a constant.  */\n   rng1[0] = rng1[0] * rng2[0];\n   rng1[1] = rng1[1] * rng2[1];\n   tree size_max = TYPE_MAX_VALUE (sizetype);\n@@ -3787,36 +3789,76 @@ gimple_call_alloc_size (gimple *stmt)\n   return wide_int_to_tree (sizetype, rng1[1]);\n }\n \n+/* Helper for compute_objsize.  Returns the constant size of the DEST\n+   if it refers to a variable or field and sets *PDECL to the DECL and\n+   *POFF to zero.  Otherwise returns null for other nodes.  */\n+\n+static tree\n+addr_decl_size (tree dest, tree *pdecl, tree *poff)\n+{\n+  if (TREE_CODE (dest) == ADDR_EXPR)\n+    dest = TREE_OPERAND (dest, 0);\n+\n+  if (DECL_P (dest))\n+    {\n+      *pdecl = dest;\n+      *poff = integer_zero_node;\n+      if (tree size = DECL_SIZE_UNIT (dest))\n+\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (dest) == COMPONENT_REF)\n+    {\n+      *pdecl = TREE_OPERAND (dest, 1);\n+      *poff = integer_zero_node;\n+      /* Only return constant sizes for now while callers depend on it.  */\n+      if (tree size = component_ref_size (dest))\n+\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Helper to compute the size of the object referenced by the DEST\n    expression which must have pointer type, using Object Size type\n-   OSTYPE (only the least significant 2 bits are used).  Return\n-   an estimate of the size of the object if successful or NULL when\n-   the size cannot be determined.  When the referenced object involves\n-   a non-constant offset in some range the returned value represents\n-   the largest size given the smallest non-negative offset in the\n-   range.  If nonnull, set *PDECL to the decl of the referenced\n-   subobject if it can be determined, or to null otherwise.  Likewise,\n-   when POFF is nonnull *POFF is set to the offset into *PDECL.\n+   OSTYPE (only the least significant 2 bits are used).\n+   Returns an estimate of the size of the object represented as\n+   a sizetype constant if successful or NULL when the size cannot\n+   be determined.\n+   When the referenced object involves a non-constant offset in some\n+   range the returned value represents the largest size given the\n+   smallest non-negative offset in the range.\n+   If nonnull, sets *PDECL to the decl of the referenced subobject\n+   if it can be determined, or to null otherwise.  Likewise, when\n+   POFF is nonnull *POFF is set to the offset into *PDECL.\n+\n    The function is intended for diagnostics and should not be used\n    to influence code generation or optimization.  */\n \n tree\n compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n-\t\t tree *poff /* = NULL */)\n+\t\t tree *poff /* = NULL */, const vr_values *rvals /* = NULL */)\n {\n   tree dummy_decl = NULL_TREE;\n   if (!pdecl)\n     pdecl = &dummy_decl;\n \n-  tree dummy_off = size_zero_node;\n+  tree dummy_off = NULL_TREE;\n   if (!poff)\n     poff = &dummy_off;\n \n-  unsigned HOST_WIDE_INT size;\n-\n   /* Only the two least significant bits are meaningful.  */\n   ostype &= 3;\n \n+  if (ostype)\n+    /* Except for overly permissive calls to memcpy and other raw\n+       memory functions with zero OSTYPE, detect the size from simple\n+       DECLs first to more reliably than compute_builtin_object_size\n+       set *PDECL and *POFF.  */\n+    if (tree size = addr_decl_size (dest, pdecl, poff))\n+      return size;\n+\n+  unsigned HOST_WIDE_INT size;\n   if (compute_builtin_object_size (dest, ostype, &size, pdecl, poff))\n     return build_int_cst (sizetype, size);\n \n@@ -3826,8 +3868,15 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n       if (is_gimple_call (stmt))\n \t{\n \t  /* If STMT is a call to an allocation function get the size\n-\t     from its argument(s).  */\n-\t  return gimple_call_alloc_size (stmt);\n+\t     from its argument(s).  If successful, also set *PDECL to\n+\t     DEST for the caller to include in diagnostics.  */\n+\t  if (tree size = gimple_call_alloc_size (stmt))\n+\t    {\n+\t      *pdecl = dest;\n+\t      *poff = integer_zero_node;\n+\t      return size;\n+\t    }\n+\t  return NULL_TREE;\n \t}\n \n       if (!is_gimple_assign (stmt))\n@@ -3853,17 +3902,21 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t\t  /* Ignore negative offsets for now.  For others,\n \t\t     use the lower bound as the most optimistic\n \t\t     estimate of the (remaining) size.  */\n-\t\t  if (wi::sign_mask (wioff))\n+\t\t  if (wi::neg_p (wioff))\n \t\t    ;\n-\t\t  else if (wi::ltu_p (wioff, wisiz))\n-\t\t    {\n-\t\t      *poff = size_binop (PLUS_EXPR, *poff, off);\n-\t\t      return wide_int_to_tree (TREE_TYPE (size),\n-\t\t\t\t\t       wi::sub (wisiz, wioff));\n-\t\t    }\n \t\t  else\n \t\t    {\n-\t\t      *poff = size_binop (PLUS_EXPR, *poff, off);\n+\t\t      if (*poff)\n+\t\t\t{\n+\t\t\t  *poff = fold_convert (ptrdiff_type_node, *poff);\n+\t\t\t  off = fold_convert (ptrdiff_type_node, *poff);\n+\t\t\t  *poff = size_binop (PLUS_EXPR, *poff, off);\n+\t\t\t}\n+\t\t      else\n+\t\t\t*poff = off;\n+\t\t      if (wi::ltu_p (wioff, wisiz))\n+\t\t\treturn wide_int_to_tree (TREE_TYPE (size),\n+\t\t\t\t\t\t wi::sub (wisiz, wioff));\n \t\t      return size_zero_node;\n \t\t    }\n \t\t}\n@@ -3875,32 +3928,29 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t      enum value_range_kind rng = get_range_info (off, &min, &max);\n \n \t      if (rng == VR_RANGE)\n-\t\t{\n-\t\t  if (tree size = compute_objsize (dest, ostype, pdecl))\n-\t\t    {\n-\t\t      wide_int wisiz = wi::to_wide (size);\n-\n-\t\t      /* Ignore negative offsets for now.  For others,\n-\t\t\t use the lower bound as the most optimistic\n-\t\t\t estimate of the (remaining)size.  */\n-\t\t      if (wi::sign_mask (min)\n-\t\t\t  || wi::sign_mask (max))\n-\t\t\t;\n-\t\t      else if (wi::ltu_p (min, wisiz))\n-\t\t\t{\n-\t\t\t  *poff = size_binop (PLUS_EXPR, *poff,\n-\t\t\t\t\t      wide_int_to_tree (sizetype, min));\n+\t\tif (tree size = compute_objsize (dest, ostype, pdecl, poff))\n+\t\t  {\n+\t\t    wide_int wisiz = wi::to_wide (size);\n+\n+\t\t    /* Ignore negative offsets for now.  For others,\n+\t\t       use the lower bound as the most optimistic\n+\t\t       estimate of the (remaining)size.  */\n+\t\t    if (wi::neg_p (min) || wi::neg_p (max))\n+\t\t      ;\n+\t\t    else\n+\t\t      {\n+\t\t\t/* FIXME: For now, since the offset is non-constant,\n+\t\t\t   clear *POFF to keep it from being \"misused.\"\n+\t\t\t   Eventually *POFF will need to become a range that\n+\t\t\t   can be properly added to the outer offset if it\n+\t\t\t   too is one.  */\n+\t\t\t*poff = NULL_TREE;\n+\t\t\tif (wi::ltu_p (min, wisiz))\n \t\t\t  return wide_int_to_tree (TREE_TYPE (size),\n \t\t\t\t\t\t   wi::sub (wisiz, min));\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  *poff = size_binop (PLUS_EXPR, *poff,\n-\t\t\t\t\t      wide_int_to_tree (sizetype, min));\n-\t\t\t  return size_zero_node;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t\t\treturn size_zero_node;\n+\t\t      }\n+\t\t  }\n \t    }\n \t}\n       else if (code != ADDR_EXPR)\n@@ -3926,10 +3976,25 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t      && *poff && integer_zerop (*poff))\n \t    return size_zero_node;\n \n-\t  /* A valid offset into a declared object cannot be negative.  */\n-\t  if (tree_int_cst_sgn (*poff) < 0)\n+\t  /* A valid offset into a declared object cannot be negative.\n+\t     A zero size with a zero \"inner\" offset is still zero size\n+\t     regardless of the \"other\" offset OFF.  */\n+\t  if (*poff\n+\t      && ((integer_zerop (*poff) && integer_zerop (size))\n+\t\t  || (TREE_CODE (*poff) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (*poff) < 0)))\n \t    return size_zero_node;\n \n+\t  wide_int offrng[2];\n+\t  if (!get_range (off, offrng, rvals))\n+\t    return NULL_TREE;\n+\n+\t  /* Convert to the same precision to keep wide_int from \"helpfully\"\n+\t     crashing whenever it sees other arguments.  */\n+\t  const unsigned sizprec = TYPE_PRECISION (sizetype);\n+\t  offrng[0] = wide_int::from (offrng[0], sizprec, SIGNED);\n+\t  offrng[1] = wide_int::from (offrng[1], sizprec, SIGNED);\n+\n \t  /* Adjust SIZE either up or down by the sum of *POFF and OFF\n \t     above.  */\n \t  if (TREE_CODE (dest) == ARRAY_REF)\n@@ -3938,29 +4003,35 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t      tree eltype = TREE_TYPE (dest);\n \t      tree tpsize = TYPE_SIZE_UNIT (eltype);\n \t      if (tpsize && TREE_CODE (tpsize) == INTEGER_CST)\n-\t\toff = fold_build2 (MULT_EXPR, size_type_node, off, tpsize);\n+\t\t{\n+\t\t  wide_int wsz = wi::to_wide (tpsize, offrng->get_precision ());\n+\t\t  offrng[0] *= wsz;\n+\t\t  offrng[1] *= wsz;\n+\t\t}\n \t      else\n \t\treturn NULL_TREE;\n \t    }\n \n-\t  wide_int offrng[2];\n-\t  if (TREE_CODE (off) == INTEGER_CST)\n-\t    offrng[0] = offrng[1] = wi::to_wide (off);\n-\t  else if (TREE_CODE (off) == SSA_NAME)\n+\t  wide_int wisize = wi::to_wide (size);\n+\n+\t  if (!*poff)\n \t    {\n-\t      wide_int min, max;\n-\t      enum value_range_kind rng\n-\t\t= get_range_info (off, offrng, offrng + 1);\n-\t      if (rng != VR_RANGE)\n-\t\treturn NULL_TREE;\n+\t      /* If the \"inner\" offset is unknown and the \"outer\" offset\n+\t\t is either negative or less than SIZE, return the size\n+\t\t minus the offset.  This may be overly optimistic in\n+\t\t the first case if the inner offset happens to be less\n+\t\t than the absolute value of the outer offset.  */\n+\t      if (wi::neg_p (offrng[0]))\n+\t\treturn size;\n+\t      if (wi::ltu_p (offrng[0], wisize))\n+\t\treturn build_int_cst (sizetype, (wisize - offrng[0]).to_uhwi ());\n+\t      return size_zero_node;\n \t    }\n-\t  else\n-\t    return NULL_TREE;\n \n \t  /* Convert to the same precision to keep wide_int from \"helpfuly\"\n \t     crashing whenever it sees other argumments.  */\n-\t  offrng[0] = wide_int::from (offrng[0], ADDR_MAX_BITSIZE, SIGNED);\n-\t  offrng[1] = wide_int::from (offrng[1], ADDR_MAX_BITSIZE, SIGNED);\n+\t  offrng[0] = wide_int::from (offrng[0], sizprec, SIGNED);\n+\t  offrng[1] = wide_int::from (offrng[1], sizprec, SIGNED);\n \n \t  tree dstoff = *poff;\n \t  if (integer_zerop (*poff))\n@@ -3972,14 +4043,14 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t      *poff = size_binop (PLUS_EXPR, *poff, off);\n \t    }\n \n-\t  if (wi::sign_mask (offrng[0]) >= 0)\n+\t  if (!wi::neg_p (offrng[0]))\n \t    {\n \t      if (TREE_CODE (size) != INTEGER_CST)\n \t\treturn NULL_TREE;\n \n \t      /* Return the difference between the size and the offset\n \t\t or zero if the offset is greater.  */\n-\t      wide_int wisize = wi::to_wide (size, ADDR_MAX_BITSIZE);\n+\t      wide_int wisize = wi::to_wide (size, sizprec);\n \t      if (wi::ltu_p (wisize, offrng[0]))\n \t\treturn size_zero_node;\n \n@@ -3999,39 +4070,25 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t  else\n \t    return NULL_TREE;\n \n-\t  dstoffrng[0] = wide_int::from (dstoffrng[0], ADDR_MAX_BITSIZE, SIGNED);\n-\t  dstoffrng[1] = wide_int::from (dstoffrng[1], ADDR_MAX_BITSIZE, SIGNED);\n+\t  dstoffrng[0] = wide_int::from (dstoffrng[0], sizprec, SIGNED);\n+\t  dstoffrng[1] = wide_int::from (dstoffrng[1], sizprec, SIGNED);\n \n-\t  wide_int declsize = wi::to_wide (size);\n-\t  if (wi::sign_mask (dstoffrng[0]) > 0)\n-\t    declsize += dstoffrng[0];\n+\t  if (!wi::neg_p (dstoffrng[0]))\n+\t    wisize += dstoffrng[0];\n \n \t  offrng[1] += dstoffrng[1];\n-\t  if (wi::sign_mask (offrng[1]) < 0)\n+\t  if (wi::neg_p (offrng[1]))\n \t    return size_zero_node;\n \n-\t  return wide_int_to_tree (sizetype, declsize);\n+\t  return wide_int_to_tree (sizetype, wisize);\n \t}\n \n       return NULL_TREE;\n     }\n \n-  if (TREE_CODE (dest) == COMPONENT_REF)\n-    {\n-      *pdecl = TREE_OPERAND (dest, 1);\n-      return component_ref_size (dest);\n-    }\n-\n-  if (TREE_CODE (dest) != ADDR_EXPR)\n-    return NULL_TREE;\n-\n-  tree ref = TREE_OPERAND (dest, 0);\n-  if (DECL_P (ref))\n-    {\n-      *pdecl = ref;\n-      if (tree size = DECL_SIZE_UNIT (ref))\n-\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n-    }\n+  /* Try simple DECLs not handled above.  */\n+  if (tree size = addr_decl_size (dest, pdecl, poff))\n+    return size;\n \n   tree type = TREE_TYPE (dest);\n   if (TREE_CODE (type) == POINTER_TYPE)"}, {"sha": "2736f161b6bccaa8c3a87f01e8c01f3ed25ede0d", "filename": "gcc/builtins.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -133,8 +133,12 @@ extern tree fold_call_stmt (gcall *, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n-extern tree gimple_call_alloc_size (gimple *);\n-extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL);\n+\n+class vr_values;\n+tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n+\t\t\t     const vr_values * = NULL);\n+extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n+\t\t\t     const vr_values * = NULL);\n \n extern bool readonly_data_expr (tree exp);\n extern bool init_target_chars (void);"}, {"sha": "e182244b2081c3f9da5ed7386e2d9a87fb2310f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -1,3 +1,22 @@\n+2019-12-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91582\n+\t* c-c++-common/Wrestrict.c: Adjust expected warnings.\n+\t* c-c++-common/Wstringop-truncation-4.c: Enable more\n+\twarnings.\n+\t* c-c++-common/Wstringop-truncation.c: Remove an xfail.\n+\t* gcc.dg/Warray-bounds-46.c: Disable -Wstringop-overflow.\n+\t* gcc.dg/Warray-bounds-47.c: Same.\n+\t* gcc.dg/Warray-bounds-52.c: New test.\n+\t* gcc.dg/Wstringop-overflow-27.c: New test.\n+\t* gcc.dg/Wstringop-overflow-28.c: New test.\n+\t* gcc.dg/Wstringop-overflow-29.c: New test.\n+\t* gcc.dg/attr-alloc_size.c (test): Disable -Warray-bounds.\n+\t* gcc.dg/attr-copy-2.c: Adjust expected warnings.\n+\t* gcc.dg/builtin-stringop-chk-5.c: Adjust text of expected messages.\n+\t* gcc.dg/strlenopt-86.c: Relax test.\n+\t* gcc.target/i386/pr82002-1.c: Prune expected warnings.\n+\n 2019-12-13  Roman Zhuykov  <zhroma@ispras.ru>\n \n \tPR rtl-optimization/92591"}, {"sha": "1903f502abda7942a94f760ecabcd3898aabfe51", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -731,10 +731,16 @@ void test_strcpy_range (void)\n \n   r = SR (3, DIFF_MAX - 3);\n   T (8, \"01\",  a + r, a);\n-  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[3, \\[0-9\\]+] and 0 may overlap 1 byte at offset 3\" \"strcpy\" } */\n+\n+  /* The accesses below might trigger either\n+       -Wrestrict: accessing 4 bytes at offsets [3, \\[0-9\\]+] and 0 may overlap 1 byte at offset 3\n+     or\n+       -Wstringop-overflow: writing 4 bytes into a region of size 0\n+     Either of the two is appropriate.  */\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"\\\\\\[-Wrestrict|-Wstringop-overflow\" } */\n \n   r = SR (DIFF_MAX - 2, DIFF_MAX - 1);\n-  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and 0 overlaps\" \"strcpy\" } */\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"\\\\\\[-Wrestrict|-Wstringop-overflow\" } */\n \n   /* Exercise the full range of ptrdiff_t.  */\n   r = signed_value ();"}, {"sha": "6ed6a28a7af2c5dfb6cc68ddd0aab61afe3dcd7e", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation-4.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation-4.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -21,9 +21,13 @@ struct Arrays\n \n void test_arrays (struct Arrays *p, const char *s)\n {\n+  /* Expect accesses to all three arrays to trigger the warning,\n+     including the trailing one.  The size argument is a good\n+     enough indication that it is not being used as a \"legacy\"\n+     flexible array member.  */\n   strncpy (p->a, s, sizeof p->a);           /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n   strncpy ((char*)p->b, s, sizeof p->b);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n-  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n }\n \n struct Pointers\n@@ -49,9 +53,11 @@ struct ConstArrays\n \n void test_const_arrays (struct ConstArrays *p, const char *s)\n {\n+  /* Expect accesses to all three arrays to trigger the warning,\n+     including the trailing one.  */\n   strncpy ((char*)p->a, s, sizeof p->a);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n   strncpy ((char*)p->b, s, sizeof p->b);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n-  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n }\n \n struct ConstPointers\n@@ -77,9 +83,11 @@ struct VolatileArrays\n \n void test_volatile_arrays (struct VolatileArrays *p, const char *s)\n {\n+  /* Expect accesses to all three arrays to trigger the warning,\n+     including the trailing one.  */\n   strncpy ((char*)p->a, s, sizeof p->a);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n   strncpy ((char*)p->b, s, sizeof p->b);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n-  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n }\n \n struct VolatilePointers\n@@ -105,9 +113,11 @@ struct ConstVolatileArrays\n \n void test_const_volatile_arrays (struct ConstVolatileArrays *p, const char *s)\n {\n+  /* Expect accesses to all three arrays to trigger the warning,\n+     including the trailing one.  */\n   strncpy ((char*)p->a, s, sizeof p->a);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n   strncpy ((char*)p->b, s, sizeof p->b);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n-  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+  strncpy ((char*)p->c, s, sizeof p->c);    /* { dg-warning \"\\\\\\[-Wstringop-truncation\" } */\n }\n \n struct ConstVolatilePointers"}, {"sha": "5e43405fde8340b64393d1d4248de838851da36d", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -300,8 +300,7 @@ void test_strncpy_array (Dest *pd, int i, const char* s)\n   CPY (pd->a5, s, 5);               /* { dg-warning \"specified bound 5 equals destination size\" } */\n   CPY (pd->a5, s, sizeof pd->a5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n \n-  /* The following is not yet handled.  */\n-  CPY (pd->a5 + i, s, sizeof pd->a5);   /* { dg-warning \"specified bound 5 equals destination size\" \"member array\" { xfail *-*-* } } */\n+  CPY (pd->a5 + i, s, sizeof pd->a5);   /* { dg-warning \"specified bound 5 equals destination size\" \"member array\" } */\n \n   /* Verify that a copy that nul-terminates is not diagnosed.  */\n   CPY (pd->a5, \"1234\", sizeof pd->a5);"}, {"sha": "da9ad6fd6a29a6a24c9327bc0a71c2414998ac7c", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-3.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -12,7 +12,7 @@ void sink (void*);\n struct Ax\n {\n   char n;\n-  char a[];                     // { dg-message \"at offset \\[0-2\\] to object 'Ax::a' declared here\" }\n+  char a[];                     // { dg-message \"at offset \\[0-2\\] to object 'Ax::a' declared here\" \"note: flexarray\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -93,7 +93,7 @@ NOIPA void gaxx ()\n struct A0\n {\n   char n;\n-  char a[0];                    // { dg-message \"at offset \\[0-2\\] to object 'A0::a' with size 0 declared here\" }\n+  char a[0];                    // { dg-message \"at offset \\[0-2\\] to object 'A0::a' with size 0 declared here\" \"note: trailing zero-length array\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -160,7 +160,7 @@ NOIPA void ga0x ()\n struct A1\n {\n   char n;\n-  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1::a' with size 1 declared here\" }\n+  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1::a' with size 1 declared here\" \"note: trailing one-element array\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -234,7 +234,7 @@ NOIPA void ga1x ()\n struct A1i\n {\n   char n;\n-  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1i::a' with size 1 declared here\" }\n+  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1i::a' with size 1 declared here\" \"note: interior one-element array\" }\n   char x;\n };\n \n@@ -307,7 +307,7 @@ NOIPA void ga1ix ()\n struct Bx\n {\n   char n;\n-  char a[];                     // { dg-message \"at offset 0 to object 'Bx::a' declared here\" }\n+  char a[];                     // { dg-message \"at offset 0 to object 'Bx::a' declared here\" \"note: flexarray class member\" }\n \n   // Verify the warning for a constant.\n   Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -332,7 +332,7 @@ NOIPA void gbxi (int i)\n struct B0\n {\n   char n;\n-  char a[0];                    // { dg-message \"at offset 0 to object 'B0::a' with size 0 declared here\" }\n+  char a[0];                    // { dg-message \"at offset 0 to object 'B0::a' with size 0 declared here\" \"note: zero-length trailing array class member\" }\n \n   B0 () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n@@ -348,7 +348,7 @@ NOIPA void gb0 (void)\n struct B1\n {\n   char n;\n-  char a[1];                    // { dg-message \"at offset 1 to object 'B1::a' with size 1 declared here\" }\n+  char a[1];                    // { dg-message \"at offset 1 to object 'B1::a' with size 1 declared here\" \"note: one-element trailing array class member\" }\n \n   B1 () { a[1] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n@@ -362,7 +362,7 @@ NOIPA void gb1 (void)\n \n struct B123\n {\n-  char a[123];                  // { dg-message \"at offset 123 to object 'B123::a' with size 123 declared here\" }\n+  char a[123];                  // { dg-message \"at offset 123 to object 'B123::a' with size 123 declared here\" \"note: large trailing array class member\" }\n \n   B123 () { a[123] = 0; }       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n@@ -376,7 +376,7 @@ NOIPA void gb123 (void)\n \n struct B234\n {\n-  char a[234];                  // { dg-message \"at offset 234 to object 'B234::a' with size 234 declared here\" }\n+  char a[234];                  // { dg-message \"at offset 234 to object 'B234::a' with size 234 declared here\" \"note: large trailing array class member\" }\n \n   B234 (int i) { a[i] = 0; }    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };"}, {"sha": "74e78cbdbe8348bca6387463a767e3aeabb0a0cd", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-46.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -3,7 +3,7 @@\n    Test to verify that past-the-end accesses by string functions to member\n    arrays by-reference objects are diagnosed.\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -Wno-unused-local-typedefs -ftrack-macro-expansion=0\" }  */\n+   { dg-options \"-O2 -Wall -Wno-unused-local-typedefs -Wno-stringop-overflow -ftrack-macro-expansion=0\" }  */\n \n #define SA(expr) typedef int StaticAssert [2 * !!(expr) - 1]\n "}, {"sha": "848ef3651633974865ed77ef2fb10cfc31159597", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-47.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-47.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -1,7 +1,7 @@\n /* PR middle-end/91830 - Bogus -Warray-bounds on strcpy into a member\n    of a subobject compiling binutils\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+   { dg-options \"-O2 -Wall -Wno-stringop-overflow -ftrack-macro-expansion=0\" } */\n \n extern char* strcpy (char*, const char*);\n extern void sink (void*);"}, {"sha": "1a7d76fcc2a4f4799cbb23c881ff573919f70f36", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-52.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -0,0 +1,97 @@\n+/* PR middle-end/92341 - missing -Warray-bounds indexing past the end\n+   of a compound literal\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX    __INT_MAX__\n+#define INT_MIN    (-__INT_MAX__ - 1)\n+\n+void sink (int, ...);\n+\n+\n+#define T(...) sink (__LINE__, (__VA_ARGS__))\n+\n+\n+void direct_idx_cst (void)\n+{\n+  T ((int[]){ }[-1]);           // { dg-warning \"array subscript -1 is outside array bounds of 'int\\\\\\[0]'\" }\n+  T ((int[]){ }[0]);            // { dg-warning \"array subscript 0 is outside array bounds of 'int\\\\\\[0]'\" }\n+  T ((int[]){ }[1]);            // { dg-warning \"array subscript 1 is outside array bounds of 'int\\\\\\[0]'\" }\n+\n+  T ((int[]){ 1 }[-1]);         // { dg-warning \"array subscript -1 is below array bounds of 'int\\\\\\[1]'\" }\n+  T ((int[]){ 1 }[0]);\n+  T ((int[]){ 1 }[1]);          // { dg-warning \"array subscript 1 is above array bounds of 'int\\\\\\[1]'\" }\n+  T ((int[]){ 1 }[INT_MIN]);    // { dg-warning \"array subscript -\\[0-9\\]+ is below array bounds of 'int\\\\\\[1]'\" }\n+  T ((int[]){ 1 }[INT_MAX]);    // { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of 'int\\\\\\[1]'\" }\n+  T ((int[]){ 1 }[SIZE_MAX]);   // { dg-warning \"array subscript \\[0-9\\]+ is above array bounds of 'int\\\\\\[1]'\" }\n+}\n+\n+\n+void direct_idx_var (int i)\n+{\n+  T ((char[]){ }[i]);           // { dg-warning \"array subscript i is outside array bounds of 'char\\\\\\[0]'\" }\n+  T ((int[]){ }[i]);            // { dg-warning \"array subscript i is outside array bounds of 'int\\\\\\[0]'\" }\n+}\n+\n+\n+void direct_idx_range (void)\n+{\n+  ptrdiff_t i = SR (-2, -1);\n+\n+  T ((int[]){ 1 }[i]);          // { dg-warning \"array subscript \\[ \\n\\r]+ is outside array bounds of 'int\\\\\\[0]'\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+\n+#undef T\n+#define T(idx, ...) do {\t\t\t\\\n+    int *p = (__VA_ARGS__);\t\t\t\\\n+    sink (p[idx]);\t\t\t\t\\\n+  } while (0)\n+\n+void ptr_idx_cst (void)\n+{\n+  T (-1, (int[]){ });           // { dg-warning \"array subscript -1 is outside array bounds of 'int\\\\\\[0]'\" }\n+  T ( 0, (int[]){ });           // { dg-warning \"array subscript 0 is outside array bounds of 'int\\\\\\[0]'\" }\n+  T (+1, (int[]){ });           // { dg-warning \"array subscript 1 is outside array bounds of 'int\\\\\\[0]'\" }\n+\n+  T (-1, (int[]){ 1 });         // { dg-warning \"array subscript -1 is outside array bounds of 'int\\\\\\[1]'\" }\n+  T ( 0, (int[]){ 1 });\n+  T (+1, (int[]){ 1 });         // { dg-warning \"array subscript 1 is outside array bounds of 'int\\\\\\[1]'\" }\n+  T (INT_MIN, (int[]){ 1 });    // { dg-warning \"array subscript -\\[0-9\\]+ is outside array bounds of 'int\\\\\\[1]'\" \"lp64\" { xfail ilp32 } }\n+  T (INT_MAX, (int[]){ 1 });    // { dg-warning \"array subscript \\[0-9\\]+ is outside array bounds of 'int\\\\\\[1]'\" \"lp64\" { target lp64 } }\n+                                // { dg-warning \"array subscript -1 is outside array bounds of 'int\\\\\\[1]'\" \"ilp32\" { target ilp32 } .-1 }\n+  T (SIZE_MAX, (int[]){ 1 });   // { dg-warning \"array subscript -?\\[0-9\\]+ is outside array bounds of 'int\\\\\\[1]'\" }\n+}\n+\n+\n+void ptr_idx_var (int i)\n+{\n+  T (i, (int[]){ });            // { dg-warning \"array subscript \\[^\\n\\r\\]+ is outside array bounds of 'int\\\\\\[0]'\" }\n+  T (i, (int[]){ 1 });\n+  T (i, (int[]){ i, 1 });\n+}\n+\n+void ptr_idx_range (void)\n+{\n+  ptrdiff_t i = SR (-2, -1);\n+\n+  T (i, (int[]){ });            // { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of 'int\\\\\\[0]'\" }\n+  T (i, (int[]){ 1 });          // { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of 'int\\\\\\[1]'\" }\n+  T (i, (int[]){ i });          // { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of 'int\\\\\\[1]'\" }\n+\n+  i = SR (0, 1);\n+\n+  T (i, (int[]){ });            // { dg-warning \"array subscript \\\\\\[0, 1] is outside array bounds of 'int\\\\\\[0]'\" }\n+  T (i, (int[]){ 1 });\n+\n+  i = SR (1, 2);\n+  T (i, (int[]){ 1 });          // { dg-warning \"array subscript \\\\\\[1, 2] is outside array bounds of 'int\\\\\\[1]'\" }\n+\n+  i = SR (2, 3);\n+  T (i, (int[]){ 1, 2, 3 });\n+\n+  i = SR (3, 4);\n+  T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of 'int\\\\\\[3]'\" }\n+}"}, {"sha": "249ce2b6ad5572ce6945b32ffa3335e6ef6acfc5", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-27.c", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-27.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -0,0 +1,293 @@\n+/* PR middle-end/91582 - missing heap overflow detection for strcpy\n+   PR middle-end/85484 - missing -Wstringop-overflow for strcpy with\n+   a string of non-const length\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* calloc (size_t, size_t);\n+extern void* malloc (size_t);\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memset (void*, int, size_t);\n+extern char* strcpy (char*, const char*);\n+extern size_t strlen (const char*);\n+\n+void sink (void*);\n+\n+\n+void test_memcpy_nowarn (const void *s, int i, size_t n)\n+{\n+  sink (memcpy (calloc (1, 1), s, 1));\n+  sink (memcpy (calloc (1, 2), s, 1));\n+  sink (memcpy (calloc (2, 1), s, 1));\n+  sink (memcpy (calloc (3, 1), s, 2));\n+  sink (memcpy (calloc (3, 1), \"12\", 2));\n+  sink (memcpy (calloc (3, 1), s, 3));\n+  sink (memcpy (calloc (3, 1), \"12\", 3));\n+  sink (memcpy (calloc (i, 1), s, 1));\n+  sink (memcpy (calloc (n, 1), s, 1));\n+  sink (memcpy (calloc (1, n), \"\", 1));\n+  sink (memcpy (calloc (1, i), \"\", 1));\n+  sink (memcpy (calloc (i, 1), \"123\", 3));\n+  sink (memcpy (calloc (n, 1), \"123\", 3));\n+  sink (memcpy (calloc (1, i), \"123456\", 7));\n+  sink (memcpy (calloc (1, n), \"123456\", 7));\n+  sink (memcpy (calloc (n, 1), s, 12345));\n+  sink (memcpy (calloc (1, n), s, n - 1));\n+  sink (memcpy (calloc (n, 1), s, n));\n+\n+  sink (memcpy ((char*)calloc (1, 1) + i, \"123\", 1));\n+  sink (memcpy ((char*)calloc (n, 1) + i, \"123\", n));\n+\n+  sink (memcpy ((char*)calloc (1, 1) + i, s, 1));\n+  sink (memcpy ((char*)calloc (n, 1) + i, s, n));\n+\n+  sink (memcpy (malloc (1), s, 1));\n+  sink (memcpy (malloc (2), s, 1));\n+  sink (memcpy (malloc (3), s, 2));\n+  sink (memcpy (malloc (3), \"12\", 2));\n+  sink (memcpy (malloc (3), s, 3));\n+  sink (memcpy (malloc (3), \"12\", 3));\n+  sink (memcpy (malloc (n), s, 1));\n+  sink (memcpy (malloc (n), \"\", 1));\n+  sink (memcpy (malloc (n), \"123\", 3));\n+  sink (memcpy (malloc (n), \"123456\", 7));\n+  sink (memcpy (malloc (n), s, 12345));\n+  sink (memcpy (malloc (n), s, n - 1));\n+  sink (memcpy (malloc (n), s, n));\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4 };\n+    void *p = (char*)malloc (sizeof a);\n+    memcpy (p, a, sizeof a);\n+    sink (p);\n+  }\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4, 5 };\n+    size_t nelts = sizeof a / sizeof *a;\n+    int vla[nelts];\n+    memcpy (vla, a, nelts * sizeof *vla);\n+    sink (vla);\n+  }\n+}\n+\n+\n+void test_memcpy_warn (const int *s, size_t n)\n+{\n+  {\n+    void *p = (char*)malloc (0);\n+    memcpy (p, s, 1);                    // { dg-warning \"writing 1 byte into a region of size 0\" }\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = (char*)malloc (1);\n+    memcpy (p, s, 2);                    // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = (char*)malloc (2);\n+    memcpy (p, s, 3);                    // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = (char*)malloc (3);\n+    memcpy (p, s, 4);                    // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+    sink (p);\n+  }\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4 };\n+    void *p = (char*)malloc (sizeof *a);\n+    memcpy (p, a, sizeof a);              // { dg-warning \"\" }\n+    sink (p);\n+  }\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4, 5 };\n+    size_t nelts = sizeof a / sizeof *a;\n+    char vla[nelts];\n+    memcpy (vla, a, nelts * sizeof *a);   // { dg-warning \"\" }\n+    sink (vla);\n+  }\n+\n+  {\n+    void *p = malloc (n);\n+    memcpy (p, s, n * sizeof *s);         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+}\n+\n+void test_memset_nowarn (int x, size_t n)\n+{\n+  sink (memset (calloc (1, 1), x, 1));\n+  sink (memset (calloc (1, 2), x, 1));\n+  sink (memset (calloc (2, 1), x, 1));\n+  sink (memset (calloc (3, 1), x, 2));\n+  sink (memset (calloc (3, 1), x, 3));\n+  sink (memset (calloc (n, 1), x, 1));\n+  sink (memset (calloc (n, 1), x, 12345));\n+  sink (memset (calloc (1, n), x, n - 1));\n+  sink (memset (calloc (n, 1), x, n));\n+\n+  sink (memset (malloc (1), x, 1));\n+  sink (memset (malloc (2), x, 1));\n+  sink (memset (malloc (3), x, 2));\n+  sink (memset (malloc (3), x, 3));\n+  sink (memset (malloc (n), x, 1));\n+  sink (memset (malloc (n), x, 12345));\n+  sink (memset (malloc (n), x, n - 1));\n+  sink (memset (malloc (n), x, n));\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4 };\n+    void *p = (char*)malloc (sizeof a);\n+    memset (p, x, sizeof a);\n+    sink (p);\n+  }\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4, 5 };\n+    size_t nelts = sizeof a / sizeof *a;\n+    int vla[nelts];\n+    memset (vla, x, nelts * sizeof *vla);\n+    sink (vla);\n+  }\n+}\n+\n+\n+void test_memset_warn (int x, size_t n)\n+{\n+  {\n+    void *p = (char*)malloc (0);\n+    memset (p, x, 1);                    // { dg-warning \"writing 1 byte into a region of size 0\" }\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = (char*)malloc (1);\n+    memset (p, x, 2);                    // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = (char*)malloc (2);\n+    memset (p, x, 3);                    // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = (char*)malloc (3);\n+    memset (p, x, 4);                    // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+    sink (p);\n+  }\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4 };\n+    void *p = (char*)malloc (sizeof *a);\n+    memset (p, 0, sizeof a);              // { dg-warning \"\" }\n+    sink (p);\n+  }\n+\n+  {\n+    const int a[] = { 1, 2, 3, 4, 5 };\n+    size_t nelts = sizeof a / sizeof *a;\n+    char vla[nelts];\n+    memset (vla, 0, nelts * sizeof *a);   // { dg-warning \"\" }\n+    sink (vla);\n+  }\n+\n+  {\n+    void *p = malloc (n);\n+    memset (p, x, n * sizeof (int));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail *-*-* } }\n+    sink (p);\n+  }\n+}\n+\n+\n+void test_strcpy_nowarn (const char *s)\n+{\n+  {\n+    const char a[] = \"12\";\n+    int n = strlen (a);\n+    char *t = (char*)calloc (2, n);\n+    strcpy (t, a);\n+    sink (t);\n+  }\n+\n+  {\n+    const char a[] = \"123\";\n+    unsigned n = strlen (a) + 1;\n+    char *t = (char*)calloc (n, 1);\n+    strcpy (t, a);\n+    sink (t);\n+  }\n+\n+  {\n+    const char a[] = \"1234\";\n+    size_t n = strlen (a) * 2;\n+    char *t = (char*)malloc (n);\n+    strcpy (t, a);\n+    sink (t);\n+  }\n+\n+  {\n+    const char a[] = \"1234\";\n+    size_t len = strlen (a) + 1;\n+    char vla[len];\n+    strcpy (vla, a);\n+    sink (vla);\n+  }\n+\n+  {\n+    size_t n = strlen (s) + 1;\n+    char *t = (char*)malloc (n);\n+    strcpy (t, s);\n+    sink (t);\n+  }\n+}\n+\n+\n+void test_strcpy_warn (const char *s)\n+{\n+  {\n+    const char a[] = \"123\";\n+    /* Verify that using signed int for the strlen result works (i.e.,\n+       that the conversion from signed int to size_t doesn't prevent\n+       the detection.  */\n+    int n = strlen (a);\n+    char *t = (char*)calloc (n, 1);     // { dg-message \"at offset 0 to an object with size 3 allocated by 'calloc' here\" \"calloc note\" { xfail *-*-* } }\n+                                        // { dg-message \"at offset 0 to an object with size at most 3 allocated by 'calloc' here\" \"calloc note\" { target *-*-* } .-1 }\n+    strcpy (t, a);                      // { dg-warning \"writing 4 bytes into a region of size (between 0 and )?3 \" }\n+\n+    sink (t);\n+  }\n+\n+  {\n+    const char a[] = \"1234\";\n+    size_t n = strlen (a);\n+    char *t = (char*)malloc (n);        // { dg-message \"at offset 0 to an object with size 4 allocated by 'malloc' here\" \"malloc note\" { xfail *-*-* } }\n+                                        // { dg-message \"at offset 0 to an object with size at most 4 allocated by 'malloc' here\" \"malloc note\" { target *-*-* } .-1 }\n+    strcpy (t, a);                      // { dg-warning \"writing 5 bytes into a region of size (between 0 and )?4 \" }\n+    sink (t);\n+  }\n+\n+  // Exercise PR middle-end/85484.\n+  {\n+    size_t len = strlen (s);\n+    char vla[len];                      // { dg-message \"at offset 0 to an object declared here\" \"vla note\" }\n+    strcpy (vla, s);                    // { dg-warning \"writing one too many bytes into a region of a size that depends on 'strlen'\" }\n+    sink (vla);\n+  }\n+\n+  {\n+    size_t n = strlen (s);\n+    char *t = (char*)malloc (n);        // { dg-message \"at offset 0 to an object allocated by 'malloc' here\" \"malloc note\" }\n+    strcpy (t, s);                      // { dg-warning \"writing one too many bytes into a region of a size that depends on 'strlen'\" }\n+    sink (t);\n+  }\n+}"}, {"sha": "8844b9f5e7107352dc233b92d66b769153ef9887", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-28.c", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -0,0 +1,236 @@\n+/* PR middle-end/91582 - missing heap overflow detection for strcpy\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX     __INT_MAX__\n+#define INT_MIN     (-INT_MAX - 1)\n+\n+#define ATTR(...)   __attribute__ ((__VA_ARGS__))\n+#define NOIPA       ATTR (noipa)\n+\n+extern void* alloca (size_t);\n+extern void* calloc (size_t, size_t);\n+extern void* malloc (size_t);\n+\n+extern ATTR (alloc_size (1), malloc) char* alloc1 (size_t);\n+extern ATTR (alloc_size (1, 2), malloc) char* alloc2 (size_t, size_t);\n+\n+extern char* strcpy (char*, const char*);\n+\n+void sink (void*, ...);\n+\n+\n+/* Verify warning in stores to an object of variable size N in a known\n+   range, at an offset (N + I) with a constant I.  */\n+\n+void same_size_and_offset_idx_cst (void)\n+{\n+#define T(size, off, idx) do {\t\t\t\\\n+    size_t n_ = size;\t\t\t\t\\\n+    ptrdiff_t i_ = idx;\t\t\t\t\\\n+    char *p_ = alloc1 (n_);\t\t\t\\\n+    p_ += off;\t\t\t\t\t\\\n+    p_[i_] = 0;\t\t\t\t\t\\\n+    sink (p_);\t\t\t\t\t\\\n+  } while (0)\n+\n+  {\n+    const size_t n = UR (2, 3);\n+\n+    T (n, n, -4);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[-2, -1] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+    T (n, n, -3);\n+    T (n, n, -2);\n+    T (n, n, -1);\n+    T (n, n,  0);\n+    T (n, n,  1);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[3, 4] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    const size_t n = UR (3, 4);\n+\n+    T (n, n, -5);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[-2, -1] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+    T (n, n, -4);\n+    T (n, n, -3);\n+    T (n, n, -2);\n+    T (n, n, -1);\n+    T (n, n,  0);\n+    T (n, n,  1);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[4, 5] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    const size_t n = UR (5, SIZE_MAX - 2);\n+    T (n, n, -1);\n+    T (n, n, -1);\n+    T (n, n, -1);\n+    T (n, n, -1);\n+  }\n+}\n+\n+\n+/* Verify warning in stores to an object of variable size N in a known\n+   range, at an offset (M + I) with a variable M in some range and\n+   constant I.  */\n+\n+void different_size_and_offset_idx_cst (void)\n+{\n+  {\n+    const size_t n = UR (2, 3);\n+    const size_t i = UR (1, 2);\n+\n+    T (n, i, -4);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[-3, -2] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+    T (n, i, -3);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[-2, -1] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+    T (n, i, -2);\n+    T (n, i, -1);\n+    T (n, i,  0);\n+    T (n, i,  1);\n+    T (n, i,  2);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[3, 4] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    const size_t n = UR (3, 4);\n+    const size_t i = UR (2, 5);\n+\n+    T (n, i, -6);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[-4, -1] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+\n+    /* The offsets -5 and -4 are both necessarily invalid even if the sum\n+       (i - 5) and (i - 4) are (or could be) in bounds because they imply\n+       that the intermediate offset (p + i) is out of bounds.  */\n+    T (n, i, -5);   // { dg-warning \"\" \"intermediate offset\" { xfail *-*-* } }\n+    T (n, i, -4);   // { dg-warning \"\" \"intermediate offset\" { xfail *-*-* } }\n+    T (n, i, -3);\n+    T (n, i, -2);\n+    T (n, i, -1);\n+    T (n, i,  0);\n+    T (n, i,  1);\n+    T (n, i,  2);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n+                    // { dg-message \"at offset \\\\\\[4, 7] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+/* Verify warning in stores to an object of variable size N in a known\n+   range, at an offset (M + I) with a variable M in some range and\n+   constant I.  */\n+void different_size_and_offset_idx_var (void)\n+{\n+  {\n+    const size_t n = UR (3, 4);\n+    const size_t i = UR (1, 2);\n+\n+    T (n, i, SR (DIFF_MIN, 0));\n+    T (n, i, SR (      -3, 0));\n+    T (n, i, SR (      -1, 0));\n+    T (n, i, SR (       0, 1));\n+    T (n, i, SR (       1, 2));\n+    T (n, i, SR (       2, 3));\n+    /* The warning is issued below but the offset and the size in\n+       the note are wrong.  See the FIXME in compute_objsize().  */\n+    T (n, i, SR (       3, 4));    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+                                   // { dg-message \"at offset 4 to an object with size between 3 and 4 allocated by 'alloc1'\" \"pr92940 note: offset addition\" { xfail *-*-* } .-1 }\n+                                   // { dg-message \"at offset . to an object with size . allocated by 'alloc1'\" \"note: offset addition\" { target *-*-* } .-2 }\n+ }\n+}\n+\n+\n+void ptr_add_2 (int n, int i0, int i1)\n+{\n+  if (n < 1 || 2 < n) n = 2;\n+\n+  if (i0 < 0 || 1 < i0) i0 = 0;\n+  if (i1 < 1 || 2 < i1) i1 = 1;\n+\n+  char *p = (char*)__builtin_malloc (n);\n+  char *q = p;\n+\n+  q += i0;\n+  q[0] = 0;   // p[0]\n+  q += i1;\n+  q[0] = 1;   // p[1]\n+  q[1] = 2;   // p[2]     // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  sink (p, q);\n+}\n+\n+void ptr_add_3 (int n, int i0, int i1, int i2)\n+{\n+  if (n < 3 || 4 < n) n = 3;\n+\n+  if (i0 < 0 || 1 < i0) i0 = 0;\n+  if (i1 < 1 || 2 < i1) i1 = 1;\n+  if (i2 < 2 || 3 < i2) i2 = 2;\n+\n+  char *p = (char*)__builtin_malloc (n);\n+  char *q = p;\n+\n+  q += i0;\n+  q[0] = 0;   // p[0]\n+  q += i1;\n+  q[0] = 1;   // p[1]\n+  q[1] = 2;   // p[2]\n+  q += i2;\n+  q[0] = 3;   // p[3]\n+  q[1] = 4;   // p[4]     // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  sink (p, q);\n+}\n+\n+void ptr_add_4 (int n, int i0, int i1, int i2, int i3)\n+{\n+  if (n < 7 || 8 < n) n = 7;\n+\n+  if (i0 < 0 || 1 < i0) i0 = 0;\n+  if (i1 < 1 || 2 < i1) i1 = 1;\n+  if (i2 < 2 || 3 < i2) i2 = 2;\n+  if (i3 < 3 || 4 < i3) i3 = 3;\n+\n+  char *p = (char*)__builtin_malloc (n);\n+  char *q = p;\n+\n+  q += i0;\n+  q[0] = 0;   // p[0]\n+  q += i1;\n+  q[0] = 1;   // p[1]\n+  q[1] = 2;   // p[2]\n+  q += i2;\n+  q[0] = 3;   // p[3]\n+  q[1] = 4;   // p[4]\n+  q[2] = 5;   // p[5]\n+  q += i3;\n+  q[0] = 6;   // p[6]\n+  q[1] = 7;   // p[7]\n+  q[2] = 8;   // p[8]     // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  sink (p, q);\n+}\n+\n+void ptr_sub_from_end (int n, int i0, int i1, int i2, int i3)\n+{\n+  if (n < 1 || 2 < n) n = 2;\n+\n+  char *p = (char*)__builtin_malloc (n);\n+  char *q = p;\n+\n+  // The following isn't diagnosed due to a bug/limitation.\n+  q += n;      //  N=1     N=2\n+  q[-1] = 0;   // p[0]    p[1]\n+  q[-2] = 1;   // p[-1]   p[0]\n+  q[-3] = 2;   // p[-2]   p[-1]   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92939: negative offset from end\" { xfail *-*-* } }\n+\n+  /* The following isn't diagnosed because the warning doesn't recognize\n+     the index below as necessarily having the same value as the size\n+     argument to malloc.  All it considers is the range.  */\n+  q[0] = 2;                       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92937: store just past the end\" { xfail *-*-* } }\n+  q[1] = 3;                       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  sink (p, q);\n+}"}, {"sha": "c011d05e89fdd6d759ff198966bcb401152332aa", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-29.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-29.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -0,0 +1,66 @@\n+/* PR middle-end/91582 - missing heap overflow detection for strcpy\n+   Verify calls via function pointers.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+typedef __attribute__ ((alloc_size (1))) char* allocfn_t (unsigned);\n+\n+extern allocfn_t allocfn;\n+\n+void sink (void*);\n+\n+void direct_call (void)\n+{\n+  char *q = allocfn (0);            // { dg-message \"at offset 0 to an object with size 0 allocated by 'allocfn'\" }\n+  q[0] = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (q);\n+}\n+\n+\n+void local_ptr_call (void)\n+{\n+  allocfn_t *ptr = allocfn;\n+  char *q = ptr (1);                // { dg-message \"at offset -1 to an object with size 1 allocated by 'allocfn'\" }\n+  q[0] = 0;\n+  q[-1] = 0;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (q);\n+}\n+\n+\n+void global_ptr_call (void)\n+{\n+  extern allocfn_t *ptralloc;\n+\n+  allocfn_t *ptr = ptralloc;\n+  char *q = ptr (2);               // { dg-message \"at offset 3 to an object with size 2 allocated by 'ptralloc'\" }\n+  q[0] = 0;\n+  q[1] = 1;\n+  q[3] = 3;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (q);\n+}\n+\n+void global_ptr_array_call (void)\n+{\n+  extern allocfn_t * (arralloc[]);\n+\n+  allocfn_t *ptr = arralloc[0];\n+  char *q = ptr (2);               // { dg-message \"at offset 3 to an object with size 2 allocated by 'ptr'\" }\n+  q[0] = 1;\n+  q[1] = 2;\n+  q[3] = 3;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (q);\n+}\n+\n+\n+struct S { allocfn_t *ptralloc; };\n+\n+void member_ptr_call (struct S *p)\n+{\n+  char *q = p->ptralloc (3);       // { dg-message \"at offset 5 to an object with size 3 allocated by 'ptralloc' here\" }\n+  q[0] = 0;\n+  q[1] = 1;\n+  q[2] = 2;\n+  q[5] = 0;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (q);\n+}\n+"}, {"sha": "4c0cd9a14c477eb0ec7f80256aaf2b21fb6044ac", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -22,15 +22,15 @@ test (void)\n   strcpy (p, \"Hello\");\n   p = malloc1 (6);\n   strcpy (p, \"Hello\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"strcpy\" } */\n   p = malloc2 (__INT_MAX__ >= 1700000 ? 424242 : __INT_MAX__ / 4, 6);\n   strcpy (p, \"World\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"strcpy\" } */\n   p = calloc1 (2, 5);\n   strcpy (p, \"World\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"strcpy\" } */\n   p = calloc2 (2, __INT_MAX__ >= 1700000 ? 424242 : __INT_MAX__ / 4, 5);\n   strcpy (p, \"World\");\n-  strcpy (p, \"Hello World\"); /* { dg-warning \"writing\" \"strcpy\" } */\n+  strcpy (p, \"Hello World\"); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"strcpy\" } */\n }\n "}, {"sha": "ffc7208f4a7369b5e795322b4019c03c8fc9b731", "filename": "gcc/testsuite/gcc.dg/attr-copy-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -99,7 +99,7 @@ void* xref12 (int);\n void* call_xref12 (void)\n {\n   void *p = xref12 (3);\n-  __builtin___strcpy_chk (p, \"123\", __builtin_object_size (p, 0));   /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  __builtin___strcpy_chk (p, \"123\", __builtin_object_size (p, 0));   /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n   return p;\n }\n \n@@ -197,7 +197,7 @@ void* falias_malloc (void);\n void* call_falias_malloc (void)\n {\n   char *p = falias_malloc ();\n-  __builtin___strcpy_chk (p, \"123\", __builtin_object_size (p, 0));   /* { dg-warning \"\\\\\\[-Wstringop-overflow=]\" } */\n+  __builtin___strcpy_chk (p, \"123\", __builtin_object_size (p, 0));   /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n   return p;\n }\n "}, {"sha": "87dd6ac4e89c5812c847c4cf1098d0616976e7cd", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -110,7 +110,7 @@ void test_memop_warn_alloc (const void *src)\n \n   struct A *a = __builtin_malloc (sizeof *a * 2);\n \n-  memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" } */\n+  memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 \" \"memcpy into allocated\" } */\n   escape (a, src);\n \n   /* At -Wstringop-overflow=1 the destination is considered to be\n@@ -127,7 +127,7 @@ void test_memop_warn_alloc (const void *src)\n \n   struct B *b = __builtin_malloc (sizeof *b * 2);\n \n-  memcpy (&b[0], src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 8 overflows the destination\" \"memcpy into allocated\" } */\n+  memcpy (&b[0], src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 8 \" \"memcpy into allocated\" } */\n   escape (b);\n \n   /* The following idiom of clearing multiple members of a struct is"}, {"sha": "d2029443556843d51b5be585927e9fdf9f128834", "filename": "gcc/testsuite/gcc.dg/strlenopt-86.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-86.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-86.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-86.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -9,11 +9,11 @@\n unsigned n0, n1;\n \n void*\n-keep_strlen_calloc_store_cst_memset (unsigned a, unsigned b)\n+keep_strlen_calloc_store_cst_memset (int i, unsigned a, unsigned b)\n {\n   char *p = __builtin_calloc (a, 1);\n \n-  p[1] = 'x';\n+  p[i] = 'x';\n \n   __builtin_memset (p, 0, b);\n \n@@ -23,11 +23,11 @@ keep_strlen_calloc_store_cst_memset (unsigned a, unsigned b)\n }\n \n void*\n-keep_strlen_calloc_store_var_memset (int x, unsigned a, unsigned b)\n+keep_strlen_calloc_store_var_memset (int i, int x, unsigned a, unsigned b)\n {\n   char *p = __builtin_calloc (a, 1);\n \n-  p[1] = x;\n+  p[i] = x;\n \n   __builtin_memset (p, 0, b);\n \n@@ -37,11 +37,11 @@ keep_strlen_calloc_store_var_memset (int x, unsigned a, unsigned b)\n }\n \n void*\n-keep_strlen_calloc_store_memset_2 (int x, unsigned a, unsigned b, unsigned c)\n+keep_strlen_calloc_store_memset_2 (int i, int x, unsigned a, unsigned b, unsigned c)\n {\n   char *p = __builtin_calloc (a, 1);\n \n-  p[1] = x;\n+  p[i] = x;\n   __builtin_memset (p, 0, b);\n \n   n0 = __builtin_strlen (p);"}, {"sha": "b4d4bd3d12599a8a2172edc61ab34fa3f662a0b4", "filename": "gcc/testsuite/gcc.target/i386/pr82002-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-1.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -10,3 +10,5 @@ b ()\n   a (c);\n   a (c);\n }\n+\n+// { dg-prune-output \"\\\\\\[-Wstringop-overflow\" }"}, {"sha": "6ef07411e32aef3d424afe02b03d3ef40f872431", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 571, "deletions": 251, "changes": 822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -84,14 +84,20 @@ struct strinfo\n   tree nonzero_chars;\n   /* Any of the corresponding pointers for querying alias oracle.  */\n   tree ptr;\n-  /* This is used for two things:\n+  /* STMT is used for two things:\n \n      - To record the statement that should be used for delayed length\n        computations.  We maintain the invariant that all related strinfos\n        have delayed lengths or none do.\n \n-     - To record the malloc or calloc call that produced this result.  */\n+     - To record the malloc or calloc call that produced this result\n+       to optimize away malloc/memset sequences.  STMT is reset after\n+       a calloc-allocated object has been stored a non-zero value into.  */\n   gimple *stmt;\n+  /* Set to the dynamic allocation statement for the object (alloca,\n+     calloc, malloc, or VLA).  Unlike STMT, once set for a strinfo\n+     object, ALLOC doesn't change.  */\n+  gimple *alloc;\n   /* Pointer to '\\0' if known, if NULL, it can be computed as\n      ptr + length.  */\n   tree endptr;\n@@ -189,20 +195,21 @@ static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n static void handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *);\n \n /* Sets MINMAX to either the constant value or the range VAL is in\n-   and returns true on success.  When nonnull, uses RVALS to get\n-   VAL's range.  Otherwise uses get_range_info.  */\n+   and returns either the constant value or VAL on success or null\n+   when the range couldn't be determined.  Uses RVALS when nonnull\n+   to determine the range, otherwise get_range_info.  */\n \n-static bool\n-get_range (tree val, wide_int minmax[2], const vr_values *rvals = NULL)\n+tree\n+get_range (tree val, wide_int minmax[2], const vr_values *rvals /* = NULL */)\n {\n-  if (tree_fits_uhwi_p (val))\n+  if (TREE_CODE (val) == INTEGER_CST)\n     {\n       minmax[0] = minmax[1] = wi::to_wide (val);\n-      return true;\n+      return val;\n     }\n \n   if (TREE_CODE (val) != SSA_NAME)\n-    return false;\n+    return NULL_TREE;\n \n   if (rvals)\n     {\n@@ -215,20 +222,20 @@ get_range (tree val, wide_int minmax[2], const vr_values *rvals = NULL)\n \t= (CONST_CAST (class vr_values *, rvals)->get_value_range (val));\n       value_range_kind rng = vr->kind ();\n       if (rng != VR_RANGE || !range_int_cst_p (vr))\n-\treturn false;\n+\treturn NULL_TREE;\n \n       minmax[0] = wi::to_wide (vr->min ());\n       minmax[1] = wi::to_wide (vr->max ());\n-      return true;\n+      return val;\n     }\n \n   value_range_kind rng = get_range_info (val, minmax, minmax + 1);\n   if (rng == VR_RANGE)\n-    return true;\n+    return val;\n \n   /* Do not handle anti-ranges and instead make use of the on-demand\n      VRP if/when it becomes available (hopefully in GCC 11).  */\n-  return false;\n+  return NULL_TREE;\n }\n \n /* Return:\n@@ -320,7 +327,7 @@ get_next_strinfo (strinfo *si)\n /* Helper function for get_stridx.  Return the strinfo index of the address\n    of EXP, which is available in PTR if nonnull.  If OFFSET_OUT, it is\n    OK to return the index for some X <= &EXP and store &EXP - X in\n-   *OFFSET_OUT.  */\n+   *OFFSET_OUT.  When nonnull uses RVALS to determine range information.  */\n \n static int\n get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n@@ -380,13 +387,14 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n    to a known strinfo with an offset and OFFRNG is non-null, sets\n    both elements of the OFFRNG array to the range of the offset and\n    returns the index of the known strinfo.  In this case the result\n-   must not be used in for functions that modify the string.  */\n+   must not be used in for functions that modify the string.\n+   When nonnull, uses RVALS to determine range information.  */\n \n static int\n-get_stridx (tree exp, wide_int offrng[2] = NULL)\n+get_stridx (tree exp, wide_int offrng[2] = NULL, const vr_values *rvals = NULL)\n {\n   if (offrng)\n-    offrng[0] = offrng[1] = wi::zero (TYPE_PRECISION (sizetype));\n+    offrng[0] = offrng[1] = wi::zero (TYPE_PRECISION (ptrdiff_type_node));\n \n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n@@ -465,7 +473,7 @@ get_stridx (tree exp, wide_int offrng[2] = NULL)\n \t\t       return the index corresponding to the SSA_NAME.\n \t\t       Do this irrespective of the whether the offset\n \t\t       is known.  */\n-\t\t    if (get_range (off, offrng))\n+\t\t    if (get_range (off, offrng, rvals))\n \t\t      {\n \t\t\t/* When the offset range is known, increment it\n \t\t\t   it by the constant offset computed in prior\n@@ -672,6 +680,7 @@ new_strinfo (tree ptr, int idx, tree nonzero_chars, bool full_string_p)\n   si->nonzero_chars = nonzero_chars;\n   si->ptr = ptr;\n   si->stmt = NULL;\n+  si->alloc = NULL;\n   si->endptr = NULL_TREE;\n   si->refcount = 1;\n   si->idx = idx;\n@@ -838,6 +847,8 @@ get_string_length (strinfo *si)\n \t    if (chainsi->nonzero_chars == NULL)\n \t      set_endptr_and_length (loc, chainsi, lhs);\n \t  break;\n+\tcase BUILT_IN_ALLOCA:\n+\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n \tcase BUILT_IN_MALLOC:\n \t  break;\n \t/* BUILT_IN_CALLOC always has si->nonzero_chars set.  */\n@@ -885,45 +896,57 @@ dump_strlen_info (FILE *fp, gimple *stmt, const vr_values *rvals)\n \t\t  fprintf (fp, \", ptr = \");\n \t\t  print_generic_expr (fp, si->ptr);\n \t\t}\n-\t      fprintf (fp, \", nonzero_chars = \");\n-\t      print_generic_expr (fp, si->nonzero_chars);\n-\t      if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n+\n+\t      if (si->nonzero_chars)\n \t\t{\n-\t\t  value_range_kind rng = VR_UNDEFINED;\n-\t\t  wide_int min, max;\n-\t\t  if (rvals)\n+\t\t  fprintf (fp, \", nonzero_chars = \");\n+\t\t  print_generic_expr (fp, si->nonzero_chars);\n+\t\t  if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t\t    {\n-\t\t      const value_range_equiv *vr\n-\t\t\t= CONST_CAST (class vr_values *, rvals)\n-\t\t\t->get_value_range (si->nonzero_chars);\n-\t\t      rng = vr->kind ();\n-\t\t      if (range_int_cst_p (vr))\n+\t\t      value_range_kind rng = VR_UNDEFINED;\n+\t\t      wide_int min, max;\n+\t\t      if (rvals)\n \t\t\t{\n-\t\t\t  min = wi::to_wide (vr->min ());\n-\t\t\t  max = wi::to_wide (vr->max ());\n+\t\t\t  const value_range *vr\n+\t\t\t    = CONST_CAST (class vr_values *, rvals)\n+\t\t\t    ->get_value_range (si->nonzero_chars);\n+\t\t\t  rng = vr->kind ();\n+\t\t\t  if (range_int_cst_p (vr))\n+\t\t\t    {\n+\t\t\t      min = wi::to_wide (vr->min ());\n+\t\t\t      max = wi::to_wide (vr->max ());\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    rng = VR_UNDEFINED;\n \t\t\t}\n \t\t      else\n-\t\t\trng = VR_UNDEFINED;\n-\t\t    }\n-\t\t  else\n-\t\t    rng = get_range_info (si->nonzero_chars, &min, &max);\n+\t\t\trng = get_range_info (si->nonzero_chars, &min, &max);\n \n-\t\t  if (rng == VR_RANGE || rng == VR_ANTI_RANGE)\n-\t\t    {\n-\t\t      fprintf (fp, \" %s[%llu, %llu]\",\n-\t\t\t       rng == VR_RANGE ? \"\" : \"~\",\n-\t\t\t       (long long) min.to_uhwi (),\n-\t\t\t       (long long) max.to_uhwi ());\n+\t\t      if (rng == VR_RANGE || rng == VR_ANTI_RANGE)\n+\t\t\t{\n+\t\t\t  fprintf (fp, \" %s[%llu, %llu]\",\n+\t\t\t\t   rng == VR_RANGE ? \"\" : \"~\",\n+\t\t\t\t   (long long) min.to_uhwi (),\n+\t\t\t\t   (long long) max.to_uhwi ());\n+\t\t\t}\n \t\t    }\n \t\t}\n-\t      fprintf (fp, \" , refcount = %i\", si->refcount);\n+\n+\t      fprintf (fp, \", refcount = %i\", si->refcount);\n \t      if (si->stmt)\n \t\t{\n \t\t  fprintf (fp, \", stmt = \");\n \t\t  print_gimple_expr (fp, si->stmt, 0);\n \t\t}\n+\t      if (si->alloc)\n+\t\t{\n+\t\t  fprintf (fp, \", alloc = \");\n+\t\t  print_gimple_expr (fp, si->alloc, 0);\n+\t\t}\n \t      if (si->writable)\n \t\tfprintf (fp, \", writable\");\n+\t      if (si->dont_invalidate)\n+\t\tfprintf (fp, \", dont_invalidate\");\n \t      if (si->full_string_p)\n \t\tfprintf (fp, \", full_string_p\");\n \t      if (strinfo *next = get_next_strinfo (si))\n@@ -1197,80 +1220,87 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n     BITMAP_FREE (visited);\n }\n \n-/* Invalidate string length information for strings whose length\n-   might change due to stores in stmt, except those marked DON'T\n-   INVALIDATE.  For string-modifying statements, ZERO_WRITE is\n-   set when the statement wrote only zeros.  */\n+/* Invalidate string length information for strings whose length might\n+   change due to stores in STMT, except those marked DONT_INVALIDATE.\n+   For string-modifying statements, ZERO_WRITE is set when the statement\n+   wrote only zeros.\n+   Returns true if any STRIDX_TO_STRINFO entries were considered\n+   for invalidation.  */\n \n static bool\n maybe_invalidate (gimple *stmt, bool zero_write = false)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  %s()\\n\", __func__);\n+    {\n+      fprintf (dump_file, \"%s called for \", __func__);\n+      print_gimple_stmt (dump_file, stmt, TDF_LINENO);\n+    }\n \n   strinfo *si;\n-  unsigned int i;\n   bool nonempty = false;\n \n-  for (i = 1; vec_safe_iterate (stridx_to_strinfo, i, &si); ++i)\n-    if (si != NULL)\n-      {\n-\tif (!si->dont_invalidate)\n-\t  {\n-\t    ao_ref r;\n-\t    tree size = NULL_TREE;\n-\t    if (si->nonzero_chars)\n-\t      {\n-\t\t/* Include the terminating nul in the size of the string\n-\t\t   to consider when determining possible clobber.  */\n-\t\ttree type = TREE_TYPE (si->nonzero_chars);\n-\t\tsize = fold_build2 (PLUS_EXPR, type, si->nonzero_chars,\n-\t\t\t\t    build_int_cst (type, 1));\n-\t      }\n-\t    ao_ref_init_from_ptr_and_size (&r, si->ptr, size);\n-\t    if (stmt_may_clobber_ref_p_1 (stmt, &r))\n-\t      {\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  {\n-\t\t    if (size && tree_fits_uhwi_p (size))\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"  statement may clobber string \"\n-\t\t\t       HOST_WIDE_INT_PRINT_UNSIGNED \" long\\n\",\n-\t\t\t       tree_to_uhwi (size));\n-\t\t    else\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"  statement may clobber string\\n\");\n-\t\t  }\n+  for (unsigned i = 1; vec_safe_iterate (stridx_to_strinfo, i, &si); ++i)\n+    {\n+      if (si == NULL || !POINTER_TYPE_P (TREE_TYPE (si->ptr)))\n+\tcontinue;\n \n-\t\tset_strinfo (i, NULL);\n-\t\tfree_strinfo (si);\n-\t\tcontinue;\n-\t      }\n+      nonempty = true;\n \n-\t    if (size\n-\t\t&& !zero_write\n-\t\t&& si->stmt\n-\t\t&& is_gimple_call (si->stmt)\n-\t\t&& (DECL_FUNCTION_CODE (gimple_call_fndecl (si->stmt))\n-\t\t    == BUILT_IN_CALLOC))\n-\t      {\n-\t\t/* If the clobber test above considered the length of\n-\t\t   the string (including the nul), then for (potentially)\n-\t\t   non-zero writes that might modify storage allocated by\n-\t\t   calloc consider the whole object and if it might be\n-\t\t   clobbered by the statement reset the allocation\n-\t\t   statement.  */\n-\t\tao_ref_init_from_ptr_and_size (&r, si->ptr, NULL_TREE);\n-\t\tif (stmt_may_clobber_ref_p_1 (stmt, &r))\n-\t\t  si->stmt = NULL;\n-\t      }\n-\t  }\n-\tsi->dont_invalidate = false;\n-\tnonempty = true;\n-      }\n+      /* Unconditionally reset DONT_INVALIDATE.  */\n+      bool dont_invalidate = si->dont_invalidate;\n+      si->dont_invalidate = false;\n+\n+      if (dont_invalidate)\n+\tcontinue;\n+\n+      ao_ref r;\n+      tree size = NULL_TREE;\n+      if (si->nonzero_chars)\n+\t{\n+\t  /* Include the terminating nul in the size of the string\n+\t     to consider when determining possible clobber.  */\n+\t  tree type = TREE_TYPE (si->nonzero_chars);\n+\t  size = fold_build2 (PLUS_EXPR, type, si->nonzero_chars,\n+\t\t\t      build_int_cst (type, 1));\n+\t}\n+      ao_ref_init_from_ptr_and_size (&r, si->ptr, size);\n+      if (stmt_may_clobber_ref_p_1 (stmt, &r))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fputs (\"  statement may clobber object \", dump_file);\n+\t      print_generic_expr (dump_file, si->ptr);\n+\t      if (size && tree_fits_uhwi_p (size))\n+\t\tfprintf (dump_file, \" \" HOST_WIDE_INT_PRINT_UNSIGNED\n+\t\t\t \" bytes in size\", tree_to_uhwi (size));\n+\t      fputc ('\\n', dump_file);\n+\t    }\n+\n+\t  set_strinfo (i, NULL);\n+\t  free_strinfo (si);\n+\t  continue;\n+\t}\n+\n+      if (size\n+\t  && !zero_write\n+\t  && si->stmt\n+\t  && is_gimple_call (si->stmt)\n+\t  && (DECL_FUNCTION_CODE (gimple_call_fndecl (si->stmt))\n+\t      == BUILT_IN_CALLOC))\n+\t{\n+\t  /* If the clobber test above considered the length of\n+\t     the string (including the nul), then for (potentially)\n+\t     non-zero writes that might modify storage allocated by\n+\t     calloc consider the whole object and if it might be\n+\t     clobbered by the statement reset the statement.  */\n+\t  ao_ref_init_from_ptr_and_size (&r, si->ptr, NULL_TREE);\n+\t  if (stmt_may_clobber_ref_p_1 (stmt, &r))\n+\t    si->stmt = NULL;\n+\t}\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"  %s() ==> %i\\n\", __func__, nonempty);\n+    fprintf (dump_file, \"%s returns %i\\n\", __func__, nonempty);\n \n   return nonempty;\n }\n@@ -1289,6 +1319,7 @@ unshare_strinfo (strinfo *si)\n \n   nsi = new_strinfo (si->ptr, si->idx, si->nonzero_chars, si->full_string_p);\n   nsi->stmt = si->stmt;\n+  nsi->alloc = si->alloc;\n   nsi->endptr = si->endptr;\n   nsi->first = si->first;\n   nsi->prev = si->prev;\n@@ -1582,6 +1613,8 @@ valid_builtin_call (gimple *stmt)\n \treturn false;\n       break;\n \n+    case BUILT_IN_ALLOCA:\n+    case BUILT_IN_ALLOCA_WITH_ALIGN:\n     case BUILT_IN_CALLOC:\n     case BUILT_IN_MALLOC:\n     case BUILT_IN_MEMCPY:\n@@ -1858,92 +1891,159 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n }\n \n /* Diagnose buffer overflow by a STMT writing LEN + PLUS_ONE bytes,\n-   into an object designated by the LHS of STMT otherise.  */\n+   either into a region allocated for the object SI when non-null,\n+   or into an object designated by the LHS of STMT otherwise.\n+   When nonnull uses RVALS to determine range information.\n+   RAWMEM may be set by memcpy and other raw memory functions\n+   to allow accesses across subobject boundaries.  */\n \n static void\n maybe_warn_overflow (gimple *stmt, tree len,\n \t\t     const vr_values *rvals = NULL,\n-\t\t     strinfo *si = NULL, bool plus_one = false)\n+\t\t     strinfo *si = NULL, bool plus_one = false,\n+\t\t     bool rawmem = false)\n {\n   if (!len || gimple_no_warning_p (stmt))\n     return;\n \n+  /* The DECL of the function performing the write if it is done\n+     by one.  */\n   tree writefn = NULL_TREE;\n-  tree destdecl = NULL_TREE;\n-  tree destsize = NULL_TREE;\n+  /* The destination expression involved in the store STMT.  */\n   tree dest = NULL_TREE;\n \n-  /* The offset into the destination object set by compute_objsize\n-     but already reflected in DESTSIZE.  */\n-  tree destoff = NULL_TREE;\n-\n   if (is_gimple_assign (stmt))\n-    {\n-      dest = gimple_assign_lhs (stmt);\n-      if (TREE_NO_WARNING (dest))\n-\treturn;\n-\n-      /* For assignments try to determine the size of the destination\n-\t first.  Set DESTOFF to the the offset on success.  */\n-      tree off = size_zero_node;\n-      destsize = compute_objsize (dest, 1, &destdecl, &off);\n-      if (destsize)\n-\tdestoff = off;\n-    }\n+    dest = gimple_assign_lhs (stmt);\n   else if (is_gimple_call (stmt))\n     {\n-      writefn = gimple_call_fndecl (stmt);\n       dest = gimple_call_arg (stmt, 0);\n+      writefn = gimple_call_fndecl (stmt);\n     }\n \n+  if (TREE_NO_WARNING (dest))\n+    return;\n+\n   /* The offset into the destination object computed below and not\n-     reflected in DESTSIZE.  Either DESTOFF is set above or OFFRNG\n-     below.  */\n+     reflected in DESTSIZE.  */\n   wide_int offrng[2];\n-  offrng[0] = wi::zero (TYPE_PRECISION (sizetype));\n-  offrng[1] = offrng[0];\n+  const int off_prec = TYPE_PRECISION (ptrdiff_type_node);\n+  offrng[0] = offrng[1] = wi::zero (off_prec);\n \n-  if (!destsize && !si && dest)\n+  if (!si)\n     {\n-      /* For both assignments and calls, if no destination STRINFO was\n-\t provided, try to get it from the DEST.  */\n+      /* If no destination STRINFO was provided try to get it from\n+\t the DEST argument.  */\n       tree ref = dest;\n-      tree off = NULL_TREE;\n       if (TREE_CODE (ref) == ARRAY_REF)\n \t{\n \t  /* Handle stores to VLAs (represented as\n \t     ARRAY_REF (MEM_REF (vlaptr, 0), N].  */\n-\t  off = TREE_OPERAND (ref, 1);\n+\t  tree off = TREE_OPERAND (ref, 1);\n \t  ref = TREE_OPERAND (ref, 0);\n+\t  if (get_range (off, offrng, rvals))\n+\t    {\n+\t      offrng[0] = offrng[0].from (offrng[0], off_prec, SIGNED);\n+\t      offrng[1] = offrng[1].from (offrng[1], off_prec, SIGNED);\n+\t    }\n+\t  else\n+\t    {\n+\t      offrng[0] = wi::to_wide (TYPE_MIN_VALUE (ptrdiff_type_node));\n+\t      offrng[1] = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\t    }\n \t}\n \n       if (TREE_CODE (ref) == MEM_REF)\n \t{\n \t  tree mem_off = TREE_OPERAND (ref, 1);\n-\t  if (off)\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t  wide_int memoffrng[2];\n+\t  if (get_range (mem_off, memoffrng, rvals))\n \t    {\n-\t      if (!integer_zerop (mem_off))\n-\t\treturn;\n+\t      offrng[0] += memoffrng[0];\n+\t      offrng[1] += memoffrng[1];\n \t    }\n \t  else\n-\t    off = mem_off;\n-\t  ref = TREE_OPERAND (ref, 0);\n+\t    {\n+\t      offrng[0] = wi::to_wide (TYPE_MIN_VALUE (ptrdiff_type_node));\n+\t      offrng[1] = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\t    }\n \t}\n \n-      if (int idx = get_stridx (ref, offrng))\n+      wide_int stroffrng[2];\n+      if (int idx = get_stridx (ref, stroffrng, rvals))\n \t{\n \t  si = get_strinfo (idx);\n-\t  if (off && TREE_CODE (off) == INTEGER_CST)\n+\t  offrng[0] += stroffrng[0];\n+\t  offrng[1] += stroffrng[1];\n+\t}\n+    }\n+\n+  /* The allocation call if the destination object was allocated\n+     by one.  */\n+  gimple *alloc_call = NULL;\n+  /* The DECL of the destination object if known and not dynamically\n+     allocated.  */\n+  tree destdecl = NULL_TREE;\n+  /* The offset into the destination object set by compute_objsize\n+     but already reflected in DESTSIZE.  */\n+  tree destoff = NULL_TREE;\n+  /* The size of the destination region (which is smaller than\n+     the destination object for stores at a non-zero offset).  */\n+  tree destsize = NULL_TREE;\n+\n+  /* Compute the range of sizes of the destination object.  The range\n+     is constant for declared objects but may be a range for allocated\n+     objects.  */\n+  const int siz_prec = TYPE_PRECISION (size_type_node);\n+  wide_int sizrng[2];\n+  if (si)\n+    {\n+      destsize = gimple_call_alloc_size (si->alloc, sizrng, rvals);\n+      alloc_call = si->alloc;\n+    }\n+  else\n+    offrng[0] = offrng[1] = wi::zero (off_prec);\n+\n+  if (!destsize)\n+    {\n+      /* If there is no STRINFO for DEST, fall back on compute_objsize.  */\n+      tree off = NULL_TREE;\n+      destsize = compute_objsize (dest, rawmem ? 0 : 1, &destdecl, &off, rvals);\n+      if (destsize)\n+\t{\n+\t  /* Remember OFF but clear OFFRNG that may have been set above.  */\n+\t  destoff = off;\n+\t  offrng[0] = offrng[1] = wi::zero (off_prec);\n+\n+\t  if (destdecl && TREE_CODE (destdecl) == SSA_NAME)\n \t    {\n-\t      wide_int wioff = wi::to_wide (off, offrng->get_precision ());\n-\t      offrng[0] += wioff;\n-\t      offrng[1] += wioff;\n+\t      gimple *stmt = SSA_NAME_DEF_STMT (destdecl);\n+\t      if (is_gimple_call (stmt))\n+\t\talloc_call = stmt;\n+\t      destdecl = NULL_TREE;\n+\t    }\n+\n+\t  if (!get_range (destsize, sizrng, rvals))\n+\t    {\n+\t      /* On failure, rather than failing, set the maximum range\n+\t\t so that overflow in allocated objects whose size depends\n+\t\t on the strlen of the source can still be diagnosed\n+\t\t below.  */\n+\t      sizrng[0] = wi::zero (siz_prec);\n+\t      sizrng[1] = wi::to_wide (TYPE_MAX_VALUE (sizetype));\n \t    }\n \t}\n-      else\n-\treturn;\n     }\n \n+  if (!destsize)\n+    {\n+      sizrng[0] = wi::zero (siz_prec);\n+      sizrng[1] = wi::to_wide (TYPE_MAX_VALUE (sizetype));\n+    };\n+\n+  sizrng[0] = sizrng[0].from (sizrng[0], siz_prec, UNSIGNED);\n+  sizrng[1] = sizrng[1].from (sizrng[1], siz_prec, UNSIGNED);\n+\n   /* Return early if the DESTSIZE size expression is the same as LEN\n      and the offset into the destination is zero.  This might happen\n      in the case of a pair of malloc and memset calls to allocate\n@@ -1961,37 +2061,43 @@ maybe_warn_overflow (gimple *stmt, tree len,\n       lenrng[1] += 1;\n     }\n \n-  /* Compute the range of sizes of the destination object.  The range\n-     is constant for declared objects but may be a range for allocated\n-     objects.  */\n-  wide_int sizrng[2];\n-  if (!destsize || !get_range (destsize, sizrng, rvals))\n-    {\n-      /* On failure, rather than bailing outright, use the maximum range\n-\t so that overflow in allocated objects whose size depends on\n-\t the strlen of the source can still be diagnosed below.  */\n-      sizrng[0] = wi::zero (lenrng->get_precision ());\n-      sizrng[1] = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n-    }\n-\n-  /* The size of the remaining space in the destination computed as\n-     the size of the latter minus the offset into it.  */\n+  /* The size of the remaining space in the destination computed\n+     as the size of the latter minus the offset into it.  */\n   wide_int spcrng[2] = { sizrng[0], sizrng[1] };\n-  if (wi::sign_mask (offrng[0]))\n+  if (wi::neg_p (offrng[0]) && wi::neg_p (offrng[1]))\n     {\n-      /* FIXME: Handle negative offsets into allocated objects.  */\n-      if (destdecl)\n-\tspcrng[0] = spcrng[1] = wi::zero (spcrng->get_precision ());\n-      else\n+      /* When the offset is negative and the size of the destination\n+\t object unknown there is little to do.\n+\t FIXME: Detect offsets that are necessarily invalid regardless\n+\t of the size of the object.  */\n+      if (!destsize)\n \treturn;\n+\n+      /* The remaining space is necessarily zero.  */\n+      spcrng[0] = spcrng[1] = wi::zero (spcrng->get_precision ());\n+    }\n+  else if (wi::neg_p (offrng[0]))\n+    {\n+      /* When the lower bound of the offset is negative but the upper\n+\t bound is not, reduce the upper bound of the remaining space\n+\t by the upper bound of the offset but leave the lower bound\n+\t unchanged.  If that makes the upper bound of the space less\n+\t than the lower bound swap the two.  */\n+      spcrng[1] -= wi::ltu_p (offrng[1], spcrng[1]) ? offrng[1] : spcrng[1];\n+      if (wi::ltu_p (spcrng[1], spcrng[0]))\n+\tstd::swap (spcrng[1], spcrng[0]);\n     }\n   else\n     {\n+      /* When the offset is positive reduce the remaining space by\n+\t the lower bound of the offset or clear it if the offset is\n+\t greater.  */\n       spcrng[0] -= wi::ltu_p (offrng[0], spcrng[0]) ? offrng[0] : spcrng[0];\n       spcrng[1] -= wi::ltu_p (offrng[0], spcrng[1]) ? offrng[0] : spcrng[1];\n     }\n \n-  if (wi::leu_p (lenrng[0], spcrng[0]))\n+  if (wi::leu_p (lenrng[0], spcrng[0])\n+      && wi::leu_p (lenrng[1], spcrng[1]))\n     return;\n \n   if (lenrng[0] == spcrng[1]\n@@ -2092,6 +2198,8 @@ maybe_warn_overflow (gimple *stmt, tree len,\n   if (!warned)\n     return;\n \n+  gimple_set_no_warning (stmt, true);\n+\n   /* If DESTOFF is not null, use it to format the offset value/range.  */\n   if (destoff)\n     get_range (destoff, offrng);\n@@ -2117,17 +2225,91 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t\toffstr, destdecl);\n       return;\n     }\n+\n+  if (!alloc_call)\n+    return;\n+\n+  tree allocfn = gimple_call_fndecl (alloc_call);\n+  if (!allocfn)\n+    {\n+      /* For an ALLOC_CALL via a function pointer make a small effort\n+\t to determine the destination of the pointer.  */\n+      allocfn = gimple_call_fn (alloc_call);\n+      if (TREE_CODE (allocfn) == SSA_NAME)\n+\t{\n+\t  gimple *def = SSA_NAME_DEF_STMT (allocfn);\n+\t  if (gimple_assign_single_p (def))\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (def);\n+\t      if (DECL_P (rhs))\n+\t\tallocfn = rhs;\n+\t      else if (TREE_CODE (rhs) == COMPONENT_REF)\n+\t\tallocfn = TREE_OPERAND (rhs, 1);\n+\t    }\n+\t}\n+    }\n+\n+  if (gimple_call_builtin_p (alloc_call, BUILT_IN_ALLOCA_WITH_ALIGN))\n+    {\n+      if (sizrng[0] == sizrng[1])\n+\tinform (gimple_location (alloc_call),\n+\t\t\"at offset %s to an object with size %wu declared here\",\n+\t\toffstr, sizrng[0].to_uhwi ());\n+      else if (sizrng[0] == 0)\n+\t{\n+\t  /* Avoid printing impossible sizes.  */\n+\t  if (wi::ltu_p (sizrng[1],\n+\t\t\t wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node)) - 2))\n+\t    inform (gimple_location (alloc_call),\n+\t\t    \"at offset %s to an object with size at most %wu \"\n+\t\t    \"declared here\",\n+\t\t    offstr, sizrng[1].to_uhwi ());\n+\t  else\n+\t    inform (gimple_location (alloc_call),\n+\t\t    \"at offset %s to an object declared here\", offstr);\n+\t}\n+      else\n+\tinform (gimple_location (alloc_call),\n+\t\t\"at offset %s to an object with size between %wu and %wu \"\n+\t\t\"declared here\",\n+\t\toffstr, sizrng[0].to_uhwi (), sizrng[1].to_uhwi ());\n+      return;\n+    }\n+\n+  if (sizrng[0] == sizrng[1])\n+    inform (gimple_location (alloc_call),\n+\t    \"at offset %s to an object with size %wu allocated by %qE here\",\n+\t    offstr, sizrng[0].to_uhwi (), allocfn);\n+  else if (sizrng[0] == 0)\n+    {\n+      /* Avoid printing impossible sizes.  */\n+      if (wi::ltu_p (sizrng[1],\n+\t\t     wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node)) - 2))\n+\tinform (gimple_location (alloc_call),\n+\t\t\"at offset %s to an object with size at most %wu allocated \"\n+\t\t\"by %qD here\",\n+\t\toffstr, sizrng[1].to_uhwi (), allocfn);\n+      else\n+\tinform (gimple_location (alloc_call),\n+\t\t\"at offset %s to an object allocated by %qE here\",\n+\t\toffstr, allocfn);\n+    }\n+  else\n+    inform (gimple_location (alloc_call),\n+\t    \"at offset %s to an object with size between %wu and %wu \"\n+\t    \"allocated by %qE here\",\n+\t    offstr, sizrng[0].to_uhwi (), sizrng[1].to_uhwi (), allocfn);\n }\n \n /* Convenience wrapper for the above.  */\n \n static inline void\n maybe_warn_overflow (gimple *stmt, unsigned HOST_WIDE_INT len,\n-\t\t     const vr_values *rvals = NULL,\n-\t\t     strinfo *si = NULL, bool plus_one = false)\n+\t\t     const vr_values *rvals = NULL, strinfo *si = NULL,\n+\t\t     bool plus_one = false, bool rawmem = false)\n {\n   maybe_warn_overflow (stmt, build_int_cst (size_type_node, len), rvals,\n-\t\t       si, plus_one);\n+\t\t       si, plus_one, rawmem);\n }\n \n /* Handle a strlen call.  If strlen of the argument is known, replace\n@@ -2243,7 +2425,7 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      tree old = si->nonzero_chars;\n \t      si->nonzero_chars = lhs;\n \t      si->full_string_p = true;\n-\t      if (TREE_CODE (old) == INTEGER_CST)\n+\t      if (old && TREE_CODE (old) == INTEGER_CST)\n \t\t{\n \t\t  old = fold_convert_loc (loc, TREE_TYPE (lhs), old);\n \t\t  tree adj = fold_build2_loc (loc, MINUS_EXPR,\n@@ -2422,10 +2604,11 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n /* Handle a strcpy-like ({st{r,p}cpy,__st{r,p}cpy_chk}) call.\n    If strlen of the second argument is known, strlen of the first argument\n    is the same after this call.  Furthermore, attempt to convert it to\n-   memcpy.  */\n+   memcpy.  Uses RVALS to determine range information.  */\n \n static void\n-handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n+\t\t       const vr_values *rvals)\n {\n   int idx, didx;\n   tree src, dst, srclen, len, lhs, type, fn, oldlen;\n@@ -2459,6 +2642,11 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   else if (idx < 0)\n     srclen = build_int_cst (size_type_node, ~idx);\n \n+  maybe_warn_overflow (stmt, srclen, rvals, olddsi, true);\n+\n+  if (olddsi != NULL)\n+    adjust_last_stmt (olddsi, stmt, false);\n+\n   loc = gimple_location (stmt);\n   if (srclen == NULL_TREE)\n     switch (bcode)\n@@ -2709,26 +2897,58 @@ is_strlen_related_p (tree src, tree len)\n   if (TREE_CODE (len) != SSA_NAME)\n     return false;\n \n-  gimple *def_stmt = SSA_NAME_DEF_STMT (len);\n-  if (!def_stmt)\n+  if (TREE_CODE (src) == SSA_NAME)\n+    {\n+      gimple *srcdef = SSA_NAME_DEF_STMT (src);\n+      if (is_gimple_assign (srcdef))\n+\t{\n+\t  /* Handle bitwise AND used in conversions from wider size_t\n+\t     to narrower unsigned types.  */\n+\t  tree_code code = gimple_assign_rhs_code (srcdef);\n+\t  if (code == BIT_AND_EXPR\n+\t      || code == NOP_EXPR)\n+\t    return is_strlen_related_p (gimple_assign_rhs1 (srcdef), len);\n+\n+\t  return false;\n+\t}\n+\n+      if (gimple_call_builtin_p (srcdef, BUILT_IN_NORMAL))\n+\t{\n+\t  /* If SRC is the result of a call to an allocation function\n+\t     or strlen, use the function's argument instead.  */\n+\t  tree func = gimple_call_fndecl (srcdef);\n+\t  built_in_function code = DECL_FUNCTION_CODE (func);\n+\t  if (code == BUILT_IN_ALLOCA\n+\t      || code == BUILT_IN_ALLOCA_WITH_ALIGN\n+\t      || code == BUILT_IN_MALLOC\n+\t      || code == BUILT_IN_STRLEN)\n+\t    return is_strlen_related_p (gimple_call_arg (srcdef, 0), len);\n+\n+\t  /* FIXME: Handle other functions with attribute alloc_size.  */\n+\t  return false;\n+\t}\n+    }\n+\n+  gimple *lendef = SSA_NAME_DEF_STMT (len);\n+  if (!lendef)\n     return false;\n \n-  if (is_gimple_call (def_stmt))\n+  if (is_gimple_call (lendef))\n     {\n-      tree func = gimple_call_fndecl (def_stmt);\n-      if (!valid_builtin_call (def_stmt)\n+      tree func = gimple_call_fndecl (lendef);\n+      if (!valid_builtin_call (lendef)\n \t  || DECL_FUNCTION_CODE (func) != BUILT_IN_STRLEN)\n \treturn false;\n \n-      tree arg = gimple_call_arg (def_stmt, 0);\n+      tree arg = gimple_call_arg (lendef, 0);\n       return is_strlen_related_p (src, arg);\n     }\n \n-  if (!is_gimple_assign (def_stmt))\n+  if (!is_gimple_assign (lendef))\n     return false;\n \n-  tree_code code = gimple_assign_rhs_code (def_stmt);\n-  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+  tree_code code = gimple_assign_rhs_code (lendef);\n+  tree rhs1 = gimple_assign_rhs1 (lendef);\n   tree rhstype = TREE_TYPE (rhs1);\n \n   if ((TREE_CODE (rhstype) == POINTER_TYPE && code == POINTER_PLUS_EXPR)\n@@ -2741,7 +2961,7 @@ is_strlen_related_p (tree src, tree len)\n       return is_strlen_related_p (src, rhs1);\n     }\n \n-  if (tree rhs2 = gimple_assign_rhs2 (def_stmt))\n+  if (tree rhs2 = gimple_assign_rhs2 (lendef))\n     {\n       /* Integer subtraction is considered strlen-related when both\n \t arguments are integers and second one is strlen-related.  */\n@@ -3187,34 +3407,37 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n /* Handle a memcpy-like ({mem{,p}cpy,__mem{,p}cpy_chk}) call.\n    If strlen of the second argument is known and length of the third argument\n    is that plus one, strlen of the first argument is the same after this\n-   call.  */\n+   call.  Uses RVALS to determine range information.  */\n \n static void\n-handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n+\t\t       const vr_values *rvals)\n {\n-  int idx, didx;\n-  tree src, dst, len, lhs, oldlen, newlen;\n+  tree lhs, oldlen, newlen;\n   gimple *stmt = gsi_stmt (*gsi);\n-  strinfo *si, *dsi, *olddsi;\n+  strinfo *si, *dsi;\n \n-  len = gimple_call_arg (stmt, 2);\n-  src = gimple_call_arg (stmt, 1);\n-  dst = gimple_call_arg (stmt, 0);\n-  idx = get_stridx (src);\n-  if (idx == 0)\n-    return;\n+  tree len = gimple_call_arg (stmt, 2);\n+  tree src = gimple_call_arg (stmt, 1);\n+  tree dst = gimple_call_arg (stmt, 0);\n \n-  didx = get_stridx (dst);\n-  olddsi = NULL;\n+  int didx = get_stridx (dst);\n+  strinfo *olddsi = NULL;\n   if (didx > 0)\n     olddsi = get_strinfo (didx);\n   else if (didx < 0)\n     return;\n \n   if (olddsi != NULL\n-      && tree_fits_uhwi_p (len)\n       && !integer_zerop (len))\n-    adjust_last_stmt (olddsi, stmt, false);\n+    {\n+      maybe_warn_overflow (stmt, len, rvals, olddsi, false, true);\n+      adjust_last_stmt (olddsi, stmt, false);\n+    }\n+\n+  int idx = get_stridx (src);\n+  if (idx == 0)\n+    return;\n \n   bool full_string_p;\n   if (idx > 0)\n@@ -3611,10 +3834,11 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     gimple_set_no_warning (stmt, true);\n }\n \n-/* Handle a call to malloc or calloc.  */\n+/* Handle a call to an allocation function like alloca, malloc or calloc,\n+   or an ordinary allocation function declared with attribute alloc_size.  */\n \n static void\n-handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+handle_alloc_call (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n@@ -3628,59 +3852,89 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     length = build_int_cst (size_type_node, 0);\n   strinfo *si = new_strinfo (lhs, idx, length, length != NULL_TREE);\n   if (bcode == BUILT_IN_CALLOC)\n-    si->endptr = lhs;\n+    {\n+      /* Only set STMT for calloc and malloc.  */\n+      si->stmt = stmt;\n+      /* Only set ENDPTR for calloc.  */\n+      si->endptr = lhs;\n+    }\n+  else if (bcode == BUILT_IN_MALLOC)\n+    si->stmt = stmt;\n+\n+  /* Set ALLOC is set for all allocation functions.  */\n+  si->alloc = stmt;\n   set_strinfo (idx, si);\n   si->writable = true;\n-  si->stmt = stmt;\n   si->dont_invalidate = true;\n }\n \n /* Handle a call to memset.\n    After a call to calloc, memset(,0,) is unnecessary.\n    memset(malloc(n),0,n) is calloc(n,1).\n-   return true when the call is transformed, false otherwise.  */\n+   return true when the call is transformed, false otherwise.\n+   When nonnull uses RVALS to determine range information.  */\n \n static bool\n-handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write)\n+handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n+\t\t       const vr_values *rvals)\n {\n-  gimple *stmt2 = gsi_stmt (*gsi);\n-  if (!integer_zerop (gimple_call_arg (stmt2, 1)))\n-    return false;\n-\n-  /* Let the caller know the memset call cleared the destination.  */\n-  *zero_write = true;\n-\n-  tree ptr = gimple_call_arg (stmt2, 0);\n-  int idx1 = get_stridx (ptr);\n+  gimple *memset_stmt = gsi_stmt (*gsi);\n+  tree ptr = gimple_call_arg (memset_stmt, 0);\n+  /* Set to the non-constant offset added to PTR.  */\n+  wide_int offrng[2];\n+  int idx1 = get_stridx (ptr, offrng, rvals);\n   if (idx1 <= 0)\n     return false;\n   strinfo *si1 = get_strinfo (idx1);\n   if (!si1)\n     return false;\n-  gimple *stmt1 = si1->stmt;\n-  if (!stmt1 || !is_gimple_call (stmt1))\n+  gimple *alloc_stmt = si1->alloc;\n+  if (!alloc_stmt || !is_gimple_call (alloc_stmt))\n+    return false;\n+  tree callee1 = gimple_call_fndecl (alloc_stmt);\n+  if (!valid_builtin_call (alloc_stmt))\n+    return false;\n+  tree alloc_size = gimple_call_arg (alloc_stmt, 0);\n+  tree memset_size = gimple_call_arg (memset_stmt, 2);\n+\n+  /* Check for overflow.  */\n+  maybe_warn_overflow (memset_stmt, memset_size, rvals, NULL, false, true);\n+\n+  /* Bail when there is no statement associated with the destination\n+     (the statement may be null even when SI1->ALLOC is not).  */\n+  if (!si1->stmt)\n     return false;\n-  tree callee1 = gimple_call_fndecl (stmt1);\n-  if (!valid_builtin_call (stmt1))\n+\n+  /* Avoid optimizing if store is at a variable offset from the beginning\n+     of the allocated object.  */\n+  if (offrng[0] != 0 || offrng[0] != offrng[1])\n     return false;\n+\n+  /* Bail when the call writes a non-zero value.  */\n+  if (!integer_zerop (gimple_call_arg (memset_stmt, 1)))\n+    return false;\n+\n+  /* Let the caller know the memset call cleared the destination.  */\n+  *zero_write = true;\n+\n   enum built_in_function code1 = DECL_FUNCTION_CODE (callee1);\n-  tree size = gimple_call_arg (stmt2, 2);\n   if (code1 == BUILT_IN_CALLOC)\n-    /* Not touching stmt1 */ ;\n+    /* Not touching alloc_stmt */ ;\n   else if (code1 == BUILT_IN_MALLOC\n-\t   && operand_equal_p (gimple_call_arg (stmt1, 0), size, 0))\n+\t   && operand_equal_p (memset_size, alloc_size, 0))\n     {\n-      gimple_stmt_iterator gsi1 = gsi_for_stmt (stmt1);\n+      /* Replace the malloc + memset calls with calloc.  */\n+      gimple_stmt_iterator gsi1 = gsi_for_stmt (si1->stmt);\n       update_gimple_call (&gsi1, builtin_decl_implicit (BUILT_IN_CALLOC), 2,\n-\t\t\t  size, build_one_cst (size_type_node));\n+\t\t\t  alloc_size, build_one_cst (size_type_node));\n       si1->nonzero_chars = build_int_cst (size_type_node, 0);\n       si1->full_string_p = true;\n       si1->stmt = gsi_stmt (gsi1);\n     }\n   else\n     return false;\n-  tree lhs = gimple_call_lhs (stmt2);\n-  unlink_stmt_vdef (stmt2);\n+  tree lhs = gimple_call_lhs (memset_stmt);\n+  unlink_stmt_vdef (memset_stmt);\n   if (lhs)\n     {\n       gimple *assign = gimple_build_assign (lhs, ptr);\n@@ -3689,7 +3943,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write)\n   else\n     {\n       gsi_remove (gsi, true);\n-      release_defs (stmt2);\n+      release_defs (memset_stmt);\n     }\n \n   return true;\n@@ -4391,7 +4645,8 @@ int ssa_name_limit_t::next_ssa_name (tree ssa_name)\n    OFFSET and NBYTES are the offset into the representation and\n    the size of the access to it determined from a MEM_REF or zero\n    for other expressions.\n-   Avoid recursing deeper than the limits in SNLIM allow.\n+   Uses RVALS to determine range information.\n+   Avoids recursing deeper than the limits in SNLIM allow.\n    Returns true on success and false otherwise.  */\n \n static bool\n@@ -4438,6 +4693,29 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n       if (maxlen + 1 < nbytes)\n \treturn false;\n \n+      if (!nbytes\n+\t  && TREE_CODE (si->ptr) == SSA_NAME\n+\t  && !POINTER_TYPE_P (TREE_TYPE (si->ptr)))\n+\t{\n+\t  /* SI->PTR is an SSA_NAME with a DEF_STMT like\n+\t       _1 = MEM <unsigned int> [(char * {ref-all})s_4(D)];  */\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (exp);\n+\t  if (gimple_assign_single_p (stmt)\n+\t      && gimple_assign_rhs_code (stmt) == MEM_REF)\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      if (tree refsize = TYPE_SIZE_UNIT (TREE_TYPE (rhs)))\n+\t\tif (tree_fits_uhwi_p (refsize))\n+\t\t  {\n+\t\t    nbytes = tree_to_uhwi (refsize);\n+\t\t    maxlen = nbytes;\n+\t\t  }\n+\t    }\n+\n+\t  if (!nbytes)\n+\t    return false;\n+\t}\n+\n       if (nbytes <= minlen)\n \t*nulterm = false;\n \n@@ -4454,7 +4732,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \tlenrange[1] = maxlen;\n \n       if (lenrange[2] < nbytes)\n-\t(lenrange[2] = nbytes);\n+\tlenrange[2] = nbytes;\n \n       /* Since only the length of the string are known and not its contents,\n \t clear ALLNUL and ALLNONNUL purely on the basis of the length.  */\n@@ -4672,7 +4950,8 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n    the next statement in the basic block and false otherwise.  */\n \n static bool\n-handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rvals)\n+handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n+\t      const vr_values *rvals)\n {\n   int idx = -1;\n   strinfo *si = NULL;\n@@ -5076,16 +5355,23 @@ is_char_type (tree type)\n }\n \n /* Check the built-in call at GSI for validity and optimize it.\n+   Uses RVALS to determine range information.\n    Return true to let the caller advance *GSI to the next statement\n    in the basic block and false otherwise.  */\n \n static bool\n-strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n-\t\t\t\tbool *zero_write,\n+strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n \t\t\t\tconst vr_values *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n+  if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      tree fntype = gimple_call_fntype (stmt);\n+      if (fntype && lookup_attribute (\"alloc_size\", TYPE_ATTRIBUTES (fntype)))\n+\thandle_alloc_call (BUILT_IN_NONE, gsi);\n+    }\n+\n   /* When not optimizing we must be checking printf calls which\n      we do even for user-defined functions when they are declared\n      with attribute format.  */\n@@ -5108,7 +5394,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY:\n     case BUILT_IN_STPCPY_CHK:\n-      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi);\n+      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi, rvals);\n       break;\n \n     case BUILT_IN_STRNCAT:\n@@ -5127,18 +5413,20 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMPCPY:\n     case BUILT_IN_MEMPCPY_CHK:\n-      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi);\n+      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi, rvals);\n       break;\n     case BUILT_IN_STRCAT:\n     case BUILT_IN_STRCAT_CHK:\n       handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi);\n       break;\n+    case BUILT_IN_ALLOCA:\n+    case BUILT_IN_ALLOCA_WITH_ALIGN:\n     case BUILT_IN_MALLOC:\n     case BUILT_IN_CALLOC:\n-      handle_builtin_malloc (DECL_FUNCTION_CODE (callee), gsi);\n+      handle_alloc_call (DECL_FUNCTION_CODE (callee), gsi);\n       break;\n     case BUILT_IN_MEMSET:\n-      if (handle_builtin_memset (gsi, zero_write))\n+      if (handle_builtin_memset (gsi, zero_write, rvals))\n \treturn false;\n       break;\n     case BUILT_IN_MEMCMP:\n@@ -5163,7 +5451,8 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n    If GSI's basic block needs clean-up of EH, set *CLEANUP_EH to true.  */\n \n static void\n-handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n+handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n+\t\t\tconst vr_values *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -5266,6 +5555,31 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n \t    }\n \t}\n     }\n+  else if (code == MEM_REF && TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      if (int idx = new_stridx (lhs))\n+\t{\n+\t  /* Record multi-byte assignments from MEM_REFs.  */\n+\t  bool storing_all_nonzero_p;\n+\t  bool storing_all_zeros_p;\n+\t  bool full_string_p;\n+\t  unsigned lenrange[] = { UINT_MAX, 0, 0 };\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\t  const bool ranges_valid\n+\t    = count_nonzero_bytes (rhs, lenrange, &full_string_p,\n+\t\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p,\n+\t\t\t\t   rvals);\n+\t  if (ranges_valid)\n+\t    {\n+\t      tree length = build_int_cst (sizetype, lenrange[0]);\n+\t      strinfo *si = new_strinfo (lhs, idx, length, full_string_p);\n+\t      set_strinfo (idx, si);\n+\t      si->writable = true;\n+\t      si->dont_invalidate = true;\n+\t      maybe_warn_overflow (stmt, lenrange[2], rvals);\n+\t    }\n+\t}\n+    }\n \n   if (strlen_to_stridx)\n     {\n@@ -5318,29 +5632,35 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t}\n       else if (TREE_CODE (lhs) == SSA_NAME && INTEGRAL_TYPE_P (lhs_type))\n \t/* Handle assignment to a character.  */\n-\thandle_integral_assign (gsi, cleanup_eh);\n+\thandle_integral_assign (gsi, cleanup_eh, rvals);\n       else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n \t{\n \t  tree type = TREE_TYPE (lhs);\n \t  if (TREE_CODE (type) == ARRAY_TYPE)\n \t    type = TREE_TYPE (type);\n \n-\t  bool is_char_store = is_char_type (type);\n-\t  if (!is_char_store && TREE_CODE (lhs) == MEM_REF)\n-\t    {\n-\t      /* To consider stores into char objects via integer types\n-\t\t other than char but not those to non-character objects,\n-\t\t determine the type of the destination rather than just\n-\t\t the type of the access.  */\n-\t      tree ref = TREE_OPERAND (lhs, 0);\n-\t      type = TREE_TYPE (ref);\n-\t      if (TREE_CODE (type) == POINTER_TYPE)\n-\t\ttype = TREE_TYPE (type);\n-\t      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t\ttype = TREE_TYPE (type);\n-\t      if (is_char_type (type))\n-\t\tis_char_store = true;\n-\t    }\n+\tbool is_char_store = is_char_type (type);\n+\tif (!is_char_store && TREE_CODE (lhs) == MEM_REF)\n+\t  {\n+\t    /* To consider stores into char objects via integer types\n+\t       other than char but not those to non-character objects,\n+\t       determine the type of the destination rather than just\n+\t       the type of the access.  */\n+\t    for (int i = 0; i != 2; ++i)\n+\t      {\n+\t\ttree ref = TREE_OPERAND (lhs, i);\n+\t\ttype = TREE_TYPE (ref);\n+\t\tif (TREE_CODE (type) == POINTER_TYPE)\n+\t\t  type = TREE_TYPE (type);\n+\t\tif (TREE_CODE (type) == ARRAY_TYPE)\n+\t\t  type = TREE_TYPE (type);\n+\t\tif (is_char_type (type))\n+\t\t  {\n+\t\t    is_char_store = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n \n \t  /* Handle a single or multibyte assignment.  */\n \t  if (is_char_store && !handle_store (gsi, &zero_write, rvals))"}, {"sha": "46f2c0a39967e8f64e6b69bafa7f065d688fdc30", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -25,8 +25,10 @@ extern bool is_strlen_related_p (tree, tree);\n extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree);\n extern tree set_strlen_range (tree, wide_int, wide_int, tree = NULL_TREE);\n \n-struct c_strlen_data;\n class vr_values;\n+extern tree get_range (tree, wide_int[2], const vr_values * = NULL);\n+\n+struct c_strlen_data;\n extern void get_range_strlen_dynamic (tree , c_strlen_data *, const vr_values *);\n \n /* APIs internal to strlen pass.  Defined in in gimple-ssa-sprintf.c.  */"}, {"sha": "f7033b43f9f4b28e33e99fcc324d4524b70cf98d", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ef29b12cfbb4979a89b3cbadbf485a77c8fd8fce", "patch": "@@ -13583,8 +13583,8 @@ get_initializer_for (tree init, tree decl)\n    determine the size of an initialized flexible array member.\n    If non-null, *INTERIOR_ZERO_LENGTH is set when REF refers to\n    an interior zero-length array.\n-   Returns the size (which might be zero for an object with\n-   an uninitialized flexible array member) or null if the size\n+   Returns the size as sizetype (which might be zero for an object\n+   with an uninitialized flexible array member) or null if the size\n    cannot be determined.  */\n \n tree\n@@ -13733,7 +13733,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t  memsz64 -= baseoff;\n \t  return wide_int_to_tree (TREE_TYPE (memsize), memsz64);\n \t}\n-      return integer_zero_node;\n+      return size_zero_node;\n     }\n \n   /* Return \"don't know\" for an external non-array object since its\n@@ -13744,7 +13744,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t  && DECL_EXTERNAL (base)\n \t  && (!typematch\n \t      || TREE_CODE (basetype) != ARRAY_TYPE)\n-\t  ? NULL_TREE : integer_zero_node);\n+\t  ? NULL_TREE : size_zero_node);\n }\n \n /* Return the machine mode of T.  For vectors, returns the mode of the"}]}