{"sha": "5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQxZGNhYTJjMzg0NmIyZTE4OWFiMTkwZTUzYzA3ZDEzZDU1NjczYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2006-01-15T02:49:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2006-01-15T02:49:17Z"}, "message": "ifcvt.c (noce_init_if_info): New static function, broken out of noce_process_if_block.\n\n./:\t* ifcvt.c (noce_init_if_info): New static function, broken out of\n\tnoce_process_if_block.\n\t(noce_process_if_block): Call noce_init_if_info.\n\t(check_cond_move_block): New static function.\n\t(cond_move_process_if_block): New static function.\n\t(process_if_block): Call cond_move_process_if_block.\ntestsuite/:\n\t* gcc.target/i386/cmov6.c: New test.\n\nFrom-SVN: r109717", "tree": {"sha": "0f3b6840427ac80db771374ab36bf699a7b5f066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f3b6840427ac80db771374ab36bf699a7b5f066"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c514720e453223a2a57838a2f90e9692ba2b1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c514720e453223a2a57838a2f90e9692ba2b1df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c514720e453223a2a57838a2f90e9692ba2b1df"}], "stats": {"total": 345, "additions": 317, "deletions": 28}, "files": [{"sha": "f6a9c931c445682416490c2284c46128ee1133c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "patch": "@@ -1,3 +1,12 @@\n+2006-01-14  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* ifcvt.c (noce_init_if_info): New static function, broken out of\n+\tnoce_process_if_block.\n+\t(noce_process_if_block): Call noce_init_if_info.\n+\t(check_cond_move_block): New static function.\n+\t(cond_move_process_if_block): New static function.\n+\t(process_if_block): Call cond_move_process_if_block.\n+\n 2006-01-15  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* cselib.c (hash_table): Rename to cselib_hash_table."}, {"sha": "d72b86d976e369519b5d36e6420a25483d6760db", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 282, "deletions": 28, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "patch": "@@ -2016,6 +2016,52 @@ noce_get_condition (rtx jump, rtx *earliest)\n \t\t\t\t NULL_RTX, false, true);\n }\n \n+/* Initialize for a simple IF-THEN or IF-THEN-ELSE block.  We will not\n+   be using conditional execution.  Set some fields of IF_INFO based\n+   on CE_INFO: test_bb, cond, jump, cond_earliest.  Return TRUE if\n+   things look OK.  */\n+\n+static int\n+noce_init_if_info (struct ce_if_block *ce_info, struct noce_if_info *if_info)\n+{\n+  basic_block test_bb = ce_info->test_bb;\n+  rtx cond, jump;\n+\n+  /* If test is comprised of && or || elements, don't handle it unless\n+     it is the special case of && elements without an ELSE block.  */\n+  if (ce_info->num_multiple_test_blocks)\n+    {\n+      if (ce_info->else_bb || !ce_info->and_and_p)\n+\treturn FALSE;\n+\n+      ce_info->test_bb = test_bb = ce_info->last_test_bb;\n+      ce_info->num_multiple_test_blocks = 0;\n+      ce_info->num_and_and_blocks = 0;\n+      ce_info->num_or_or_blocks = 0;\n+    }\n+\n+  /* If this is not a standard conditional jump, we can't parse it.  */\n+  jump = BB_END (test_bb);\n+  cond = noce_get_condition (jump, &if_info->cond_earliest);\n+  if (!cond)\n+    return FALSE;\n+\n+  /* If the conditional jump is more than just a conditional\n+     jump, then we can not do if-conversion on this block.  */\n+  if (! onlyjump_p (jump))\n+    return FALSE;\n+\n+  /* We must be comparing objects whose modes imply the size.  */\n+  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n+    return FALSE;\n+\n+  if_info->test_bb = test_bb;\n+  if_info->cond = cond;\n+  if_info->jump = jump;\n+\n+  return TRUE;\n+}\n+\n /* Return true if OP is ok for if-then-else processing.  */\n \n static int\n@@ -2111,33 +2157,11 @@ noce_process_if_block (struct ce_if_block * ce_info)\n \n      ??? For future expansion, look for multiple X in such patterns.  */\n \n-  /* If test is comprised of && or || elements, don't handle it unless it is\n-     the special case of && elements without an ELSE block.  */\n-  if (ce_info->num_multiple_test_blocks)\n-    {\n-      if (else_bb || ! ce_info->and_and_p)\n-\treturn FALSE;\n-\n-      ce_info->test_bb = test_bb = ce_info->last_test_bb;\n-      ce_info->num_multiple_test_blocks = 0;\n-      ce_info->num_and_and_blocks = 0;\n-      ce_info->num_or_or_blocks = 0;\n-    }\n-\n-  /* If this is not a standard conditional jump, we can't parse it.  */\n-  jump = BB_END (test_bb);\n-  cond = noce_get_condition (jump, &if_info.cond_earliest);\n-  if (! cond)\n-    return FALSE;\n-\n-  /* If the conditional jump is more than just a conditional\n-     jump, then we can not do if-conversion on this block.  */\n-  if (! onlyjump_p (jump))\n+  if (!noce_init_if_info (ce_info, &if_info))\n     return FALSE;\n \n-  /* We must be comparing objects whose modes imply the size.  */\n-  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n-    return FALSE;\n+  cond = if_info.cond;\n+  jump = if_info.jump;\n \n   /* Look for one of the potential sets.  */\n   insn_a = first_active_insn (then_bb);\n@@ -2216,9 +2240,6 @@ noce_process_if_block (struct ce_if_block * ce_info)\n     return FALSE;\n \n   /* Set up the info block for our subroutines.  */\n-  if_info.test_bb = test_bb;\n-  if_info.cond = cond;\n-  if_info.jump = jump;\n   if_info.insn_a = insn_a;\n   if_info.insn_b = insn_b;\n   if_info.x = x;\n@@ -2340,6 +2361,235 @@ noce_process_if_block (struct ce_if_block * ce_info)\n \n   return TRUE;\n }\n+\n+/* Check whether a block is suitable for conditional move conversion.\n+   Every insn must be a simple set of a register to a constant or a\n+   register.  For each assignment, store the value in the array VALS,\n+   indexed by register number.  COND is the condition we will\n+   test.  */\n+\n+static int\n+check_cond_move_block (basic_block bb, rtx *vals, rtx cond)\n+{\n+  rtx insn;\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      rtx set, dest, src;\n+\n+      if (!INSN_P (insn) || JUMP_P (insn))\n+\tcontinue;\n+      set = single_set (insn);\n+      if (!set)\n+\treturn FALSE;\n+\n+      dest = SET_DEST (set);\n+      src = SET_SRC (set);\n+      if (!REG_P (dest)\n+\t  || (SMALL_REGISTER_CLASSES && HARD_REGISTER_P (dest)))\n+\treturn false;\n+\n+      if (!CONSTANT_P (src) && !register_operand (src, VOIDmode))\n+\treturn FALSE;\n+\n+      if (side_effects_p (src) || side_effects_p (dest))\n+\treturn FALSE;\n+\n+      if (may_trap_p (src) || may_trap_p (dest))\n+\treturn FALSE;\n+\n+      /* Don't try to handle this if the destination register was\n+\t modified earlier in the block.  */\n+      if (vals[REGNO (dest)] != NULL)\n+\treturn FALSE;\n+\n+      /* Don't try to handle this if the condition uses the\n+\t destination register.  */\n+      if (reg_overlap_mentioned_p (dest, cond))\n+\treturn FALSE;\n+\n+      vals[REGNO (dest)] = src;\n+\n+      /* Don't try to handle this if the source register is modified\n+\t later in the block.  */\n+      if (!CONSTANT_P (src)\n+\t  && modified_between_p (src, insn, NEXT_INSN (BB_END (bb))))\n+\treturn FALSE;\n+    }\n+\n+  return TRUE;\n+}\n+\n+/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n+   using only conditional moves.  Return TRUE if we were successful at\n+   converting the block.  */\n+\n+static int\n+cond_move_process_if_block (struct ce_if_block *ce_info)\n+{\n+  basic_block then_bb = ce_info->then_bb;\n+  basic_block else_bb = ce_info->else_bb;\n+  struct noce_if_info if_info;\n+  rtx jump, cond, insn, seq, cond_arg0, cond_arg1, loc_insn;\n+  int max_reg, size, c, i;\n+  rtx *then_vals;\n+  rtx *else_vals;\n+  enum rtx_code code;\n+\n+  if (!HAVE_conditional_move || no_new_pseudos)\n+    return FALSE;\n+\n+  memset (&if_info, 0, sizeof if_info);\n+\n+  if (!noce_init_if_info (ce_info, &if_info))\n+    return FALSE;\n+\n+  cond = if_info.cond;\n+  jump = if_info.jump;\n+\n+  /* Build a mapping for each block to the value used for each\n+     register.  */\n+  max_reg = max_reg_num ();\n+  size = (max_reg + 1) * sizeof (rtx);\n+  then_vals = (rtx *) alloca (size);\n+  else_vals = (rtx *) alloca (size);\n+  memset (then_vals, 0, size);\n+  memset (else_vals, 0, size);\n+\n+  /* Make sure the blocks are suitable.  */\n+  if (!check_cond_move_block (then_bb, then_vals, cond)\n+      || (else_bb && !check_cond_move_block (else_bb, else_vals, cond)))\n+    return FALSE;\n+\n+  /* Make sure the blocks can be used together.  If the same register\n+     is set in both blocks, and is not set to a constant in both\n+     cases, then both blocks must set it to the same register.  We\n+     have already verified that if it is set to a register, that the\n+     source register does not change after the assignment.  Also count\n+     the number of registers set in only one of the blocks.  */\n+  c = 0;\n+  for (i = 0; i <= max_reg; ++i)\n+    {\n+      if (!then_vals[i] && !else_vals[i])\n+\tcontinue;\n+\n+      if (!then_vals[i] || !else_vals[i])\n+\t++c;\n+      else\n+\t{\n+\t  if (!CONSTANT_P (then_vals[i])\n+\t      && !CONSTANT_P (else_vals[i])\n+\t      && !rtx_equal_p (then_vals[i], else_vals[i]))\n+\t    return FALSE;\n+\t}\n+    }\n+\n+  /* Make sure it is reasonable to convert this block.  What matters\n+     is the number of assignments currently made in only one of the\n+     branches, since if we convert we are going to always execute\n+     them.  */\n+  if (c > MAX_CONDITIONAL_EXECUTE)\n+    return FALSE;\n+\n+  /* Emit the conditional moves.  First do the then block, then do\n+     anything left in the else blocks.  */\n+\n+  code = GET_CODE (cond);\n+  cond_arg0 = XEXP (cond, 0);\n+  cond_arg1 = XEXP (cond, 1);\n+\n+  start_sequence ();\n+\n+  FOR_BB_INSNS (then_bb, insn)\n+    {\n+      rtx set, target, dest, t, e;\n+      unsigned int regno;\n+\n+      if (!INSN_P (insn) || JUMP_P (insn))\n+\tcontinue;\n+      set = single_set (insn);\n+      gcc_assert (set && REG_P (SET_DEST (set)));\n+\n+      dest = SET_DEST (set);\n+      regno = REGNO (dest);\n+      t = then_vals[regno];\n+      e = else_vals[regno];\n+      gcc_assert (t);\n+      if (!e)\n+\te = dest;\n+      target = noce_emit_cmove (&if_info, dest, code, cond_arg0, cond_arg1,\n+\t\t\t\tt, e);\n+      if (!target)\n+\t{\n+\t  end_sequence ();\n+\t  return FALSE;\n+\t}\n+\n+      if (target != dest)\n+\tnoce_emit_move_insn (dest, target);\n+    }\n+\n+  if (else_bb)\n+    {\n+      FOR_BB_INSNS (else_bb, insn)\n+\t{\n+\t  rtx set, target, dest;\n+\t  unsigned int regno;\n+\n+\t  if (!INSN_P (insn) || JUMP_P (insn))\n+\t    continue;\n+\t  set = single_set (insn);\n+\t  gcc_assert (set && REG_P (SET_DEST (set)));\n+\n+\t  dest = SET_DEST (set);\n+\t  regno = REGNO (dest);\n+\n+\t  /* If this register was set in the then block, we already\n+\t     handled this case above.  */\n+\t  if (then_vals[regno])\n+\t    continue;\n+\t  gcc_assert (else_vals[regno]);\n+\n+\t  target = noce_emit_cmove (&if_info, dest, code, cond_arg0, cond_arg1,\n+\t\t\t\t    dest, else_vals[regno]);\n+\t  if (!target)\n+\t    {\n+\t      end_sequence ();\n+\t      return FALSE;\n+\t    }\n+\n+\t  if (target != dest)\n+\t    noce_emit_move_insn (dest, target);\n+\t}\n+    }\n+\n+  seq = end_ifcvt_sequence (&if_info);\n+  if (!seq)\n+    return FALSE;\n+\n+  loc_insn = first_active_insn (then_bb);\n+  if (!loc_insn)\n+    {\n+      loc_insn = first_active_insn (else_bb);\n+      gcc_assert (loc_insn);\n+    }\n+  emit_insn_before_setloc (seq, jump, INSN_LOCATOR (loc_insn));\n+\n+  FOR_BB_INSNS (then_bb, insn)\n+    if (INSN_P (insn) && !JUMP_P (insn))\n+      delete_insn (insn);\n+  if (else_bb)\n+    {\n+      FOR_BB_INSNS (else_bb, insn)\n+\tif (INSN_P (insn) && !JUMP_P (insn))\n+\t  delete_insn (insn);\n+    }\n+  delete_insn (jump);\n+\n+  merge_if_block (ce_info);\n+\n+  return TRUE;\n+}\n \f\n /* Attempt to convert an IF-THEN or IF-THEN-ELSE block into\n    straight line code.  Return true if successful.  */\n@@ -2351,6 +2601,10 @@ process_if_block (struct ce_if_block * ce_info)\n       && noce_process_if_block (ce_info))\n     return TRUE;\n \n+  if (HAVE_conditional_move\n+      && cond_move_process_if_block (ce_info))\n+    return TRUE;\n+\n   if (HAVE_conditional_execution && reload_completed)\n     {\n       /* If we have && and || tests, try to first handle combining the && and"}, {"sha": "d776ab5ee0c4909c0b4b91b5427e5491f7d40fb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "patch": "@@ -1,3 +1,7 @@\n+2006-01-14  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* gcc.target/i386/cmov6.c: New test.\n+\n 2006-01-14  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/25663"}, {"sha": "177a0cee02f2045231a39a3023f7e838914fa4d2", "filename": "gcc/testsuite/gcc.target/i386/cmov6.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmov6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d1dcaa2c3846b2e189ab190e53c07d13d55673c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmov6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmov6.c?ref=5d1dcaa2c3846b2e189ab190e53c07d13d55673c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -march=i686\" } */\n+/* { dg-final { scan-assembler \"cmov\\[^6\\]\" } } */\n+\n+/* Verify that blocks are converted to conditional moves.  */\n+extern int bar (int, int);\n+int foo (int c, int d, int e)\n+{\n+  int a, b;\n+\n+  if (c)\n+    {\n+      a = 10;\n+      b = d;\n+    }\n+  else\n+    {\n+      a = e;\n+      b = 20;\n+    }\n+  return bar (a, b);\n+}"}]}