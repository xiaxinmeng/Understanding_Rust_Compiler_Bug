{"sha": "acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNiOGYyMTIzZDVhNjI3ZTZjNWRhZDJlNzhmZDU3ZDJiZDZjNmZiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-30T00:47:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-30T00:47:49Z"}, "message": "function.h (struct function): Add saved blocks/unexpanded var list.\n\n\n\t* function.h (struct function): Add saved blocks/unexpanded var list.\n\t* gimple-low.c (record_vars): Insert only VAR_DECLs.\n\t* tree-inline.c (add_lexical_block): Declare; do not clear sublocks.\n\t(remap_decl): Do not declare vars.\n\t(remap_block): Do not care inserting blocks.\n\t(remap_blocks): New function.\n\t(copy_body_r): Update debug info.\n\t(expand_call_inline): Duplicate callee block tree into caller;\n\tcopy all the unexpanded_var_list.\n\t(save_body): Save unexpanded_var_list and blocks.\n\t* tree-optimize.c (tree_rest_of_optimization): Restore\n\tblocks/unexpanded_var_list.\n\nFrom-SVN: r101449", "tree": {"sha": "61f3a41e0903263a69773a750d50202e1e71289e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61f3a41e0903263a69773a750d50202e1e71289e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/comments", "author": null, "committer": null, "parents": [{"sha": "0abb14c01353a5f52ee2a5fee73ed0862d306af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abb14c01353a5f52ee2a5fee73ed0862d306af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0abb14c01353a5f52ee2a5fee73ed0862d306af0"}], "stats": {"total": 141, "additions": 100, "deletions": 41}, "files": [{"sha": "9a91b2a94c90a9075c083adf7c49365af27341e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "patch": "@@ -1,3 +1,18 @@\n+2005-06-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* function.h (struct function): Add saved blocks/unexpanded var list.\n+\t* gimple-low.c (record_vars): Insert only VAR_DECLs.\n+\t* tree-inline.c (add_lexical_block): Declare; do not clear sublocks.\n+\t(remap_decl): Do not declare vars.\n+\t(remap_block): Do not care inserting blocks.\n+\t(remap_blocks): New function.\n+\t(copy_body_r): Update debug info.\n+\t(expand_call_inline): Duplicate callee block tree into caller;\n+\tcopy all the unexpanded_var_list.\n+\t(save_body): Save unexpanded_var_list and blocks.\n+\t* tree-optimize.c (tree_rest_of_optimization): Restore\n+\tblocks/unexpanded_var_list.\n+\n 2005-06-29  Richard Henderson  <rth@redhat.com>\n \n \t* config/ia64/ia64.c (ia64_expand_vecint_minmax): Use us_minus and"}, {"sha": "11b97c1fc2b69cdeaaba3f0fdd985d17fb63e367", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "patch": "@@ -178,6 +178,8 @@ struct function GTY(())\n      inlining */\n   tree saved_args;\n   tree saved_static_chain_decl;\n+  tree saved_blocks;\n+  tree saved_unexpanded_var_list;\n \n   /* For function.c.  */\n "}, {"sha": "3bece1ac0d209dc082bb5b5d4dbd826da539ce7a", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "patch": "@@ -516,11 +516,13 @@ record_vars (tree vars)\n     {\n       tree var = vars;\n \n+      /* BIND_EXPRs contains also function/type/constant declarations\n+         we don't need to care about.  */\n+      if (TREE_CODE (var) != VAR_DECL)\n+\tcontinue;\n       /* Nothing to do in this case.  */\n       if (DECL_EXTERNAL (var))\n \tcontinue;\n-      if (TREE_CODE (var) == FUNCTION_DECL)\n-\tcontinue;\n \n       /* Record the variable.  */\n       cfun->unexpanded_var_list = tree_cons (NULL_TREE, var,"}, {"sha": "94f9371fa61543c7c860643bc7a1c494de043785", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 75, "deletions": 39, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "patch": "@@ -159,6 +159,7 @@ static void declare_inline_vars (tree, tree);\n static void remap_save_expr (tree *, void *, int *);\n \n static inline bool inlining_p (inline_data *id);\n+static void add_lexical_block (tree current_block, tree new_block);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n    that the trees should be variables, it is used for more than that.  */\n@@ -246,13 +247,6 @@ remap_decl (tree decl, inline_data *id)\n \t}\n #endif\n \n-      /* If we are inlining and this is a variable (not a label), declare the\n-\t remapped variable in the callers' body.  */\n-      if (inlining_p (id)\n-\t  && (TREE_CODE (t) == VAR_DECL\n-\t      || TREE_CODE (t) == PARM_DECL))\n-\tdeclare_inline_vars (id->block, t);\n-\n       /* Remember it, so that if we encounter this local entity\n \t again we can reuse this copy.  */\n       insert_decl_map (id, decl, t);\n@@ -436,32 +430,32 @@ remap_block (tree *block, inline_data *id)\n   BLOCK_VARS (new_block) = remap_decls (BLOCK_VARS (old_block), id);\n \n   fn = id->caller;\n-#if 1\n-  /* FIXME!  It shouldn't be so hard to manage blocks.  Rebuilding them in\n-     rest_of_compilation is a good start.  */\n   if (id->cloning_p)\n     /* We're building a clone; DECL_INITIAL is still\n        error_mark_node, and current_binding_level is the parm\n        binding level.  */\n     lang_hooks.decls.insert_block (new_block);\n-  else\n-    {\n-      /* Attach this new block after the DECL_INITIAL block for the\n-\t function into which this block is being inlined.  In\n-\t rest_of_compilation we will straighten out the BLOCK tree.  */\n-      tree *first_block;\n-      if (DECL_INITIAL (fn))\n-\tfirst_block = &BLOCK_CHAIN (DECL_INITIAL (fn));\n-      else\n-\tfirst_block = &DECL_INITIAL (fn);\n-      BLOCK_CHAIN (new_block) = *first_block;\n-      *first_block = new_block;\n-    }\n-#endif\n   /* Remember the remapped block.  */\n   insert_decl_map (id, old_block, new_block);\n }\n \n+/* Copy the whole block tree and root it in id->block.  */\n+static tree\n+remap_blocks (tree block, inline_data *id)\n+{\n+  tree t;\n+  tree new = block;\n+\n+  if (!block)\n+    return NULL;\n+\n+  remap_block (&new, id);\n+  gcc_assert (new != block);\n+  for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n+    add_lexical_block (new, remap_blocks (t, id));\n+  return new;\n+}\n+\n static void\n copy_statement_list (tree *tp)\n {\n@@ -503,6 +497,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n {\n   inline_data *id = (inline_data *) data;\n   tree fn = id->callee;\n+  tree new_block;\n \n   /* Begin by recognizing trees that we'll completely rewrite for the\n      inlining context.  Our output for these trees is completely\n@@ -647,9 +642,23 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       /* Here is the \"usual case\".  Copy this tree node, and then\n \t tweak some special cases.  */\n       copy_tree_r (tp, walk_subtrees, NULL);\n-      if (id->block\n-\t  && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n-\tTREE_BLOCK (*tp) = id->block;\n+\n+      /* If EXPR has block defined, map it to newly constructed block.\n+         When inlining we want EXPRs without block appear in the block\n+\t of function call.  */\n+      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n+\t{\n+\t  new_block = id->block;\n+\t  if (TREE_BLOCK (*tp))\n+\t    {\n+\t      splay_tree_node n;\n+\t      n = splay_tree_lookup (id->decl_map,\n+\t\t\t\t     (splay_tree_key) TREE_BLOCK (*tp));\n+\t      gcc_assert (n);\n+\t      new_block = (tree) n->value;\n+\t    }\n+\t  TREE_BLOCK (*tp) = new_block;\n+\t}\n \n       if (TREE_CODE (*tp) == RESX_EXPR && id->eh_region_offset)\n \tTREE_OPERAND (*tp, 0) =\n@@ -1870,7 +1879,6 @@ add_lexical_block (tree current_block, tree new_block)\n     ;\n   *blk_p = new_block;\n   BLOCK_SUPERCONTEXT (new_block) = current_block;\n-  BLOCK_SUBBLOCKS (new_block) = NULL_TREE;\n }\n \n /* If *TP is a CALL_EXPR, replace it with its inline expansion.  */\n@@ -2035,6 +2043,11 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   /* Record the function we are about to inline.  */\n   id->callee = fn;\n \n+  if (DECL_STRUCT_FUNCTION (fn)->saved_blocks)\n+    add_lexical_block (id->block, remap_blocks (DECL_STRUCT_FUNCTION (fn)->saved_blocks, id));\n+  else if (DECL_INITIAL (fn))\n+    add_lexical_block (id->block, remap_blocks (DECL_INITIAL (fn), id));\n+\n   /* Return statements in the function body will be replaced by jumps\n      to the RET_LABEL.  */\n \n@@ -2088,6 +2101,21 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   copy_body (id, bb->count, bb->frequency, bb, return_block);\n   id->current_node = old_node;\n \n+  /* Add local vars in this inlined callee to caller.  */\n+  t_step = id->callee_cfun->unexpanded_var_list;\n+  if (id->callee_cfun->saved_unexpanded_var_list)\n+    t_step = id->callee_cfun->saved_unexpanded_var_list;\n+  for (; t_step; t_step = TREE_CHAIN (t_step))\n+    {\n+      var = TREE_VALUE (t_step);\n+      if (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n+\tcfun->unexpanded_var_list = tree_cons (NULL_TREE, var,\n+\t\t\t\t\t       cfun->unexpanded_var_list);\n+      else\n+\tcfun->unexpanded_var_list = tree_cons (NULL_TREE, remap_decl (var, id),\n+\t\t\t\t\t       cfun->unexpanded_var_list);\n+    }\n+\n   /* Clean up.  */\n   splay_tree_delete (id->decl_map);\n   id->decl_map = st;\n@@ -2125,16 +2153,6 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   /* Declare the 'auto' variables added with this inlined body.  */\n   record_vars (BLOCK_VARS (id->block));\n   id->block = NULL_TREE;\n-\n-  /* Add local static vars in this inlined callee to caller.  */\n-  for (t_step = id->callee_cfun->unexpanded_var_list;\n-       t_step;\n-       t_step = TREE_CHAIN (t_step))\n-    {\n-      var = TREE_VALUE (t_step);\n-      if (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n-\trecord_vars (var);\n-    }\n   successfully_inlined = TRUE;\n \n  egress:\n@@ -2273,6 +2291,7 @@ save_body (tree fn, tree *arg_copy, tree *sc_copy)\n   inline_data id;\n   tree newdecl, *parg;\n   basic_block fn_entry_block;\n+  tree t_step;\n \n   memset (&id, 0, sizeof (id));\n   id.callee = fn;\n@@ -2311,11 +2330,28 @@ save_body (tree fn, tree *arg_copy, tree *sc_copy)\n \n   insert_decl_map (&id, DECL_RESULT (fn), DECL_RESULT (fn));\n \n+  DECL_STRUCT_FUNCTION (fn)->saved_blocks\n+    = remap_blocks (DECL_INITIAL (fn), &id);\n+  for (t_step = id.callee_cfun->unexpanded_var_list;\n+       t_step;\n+       t_step = TREE_CHAIN (t_step))\n+    {\n+      tree var = TREE_VALUE (t_step);\n+      if (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n+\tcfun->saved_unexpanded_var_list\n+\t  = tree_cons (NULL_TREE, var, cfun->saved_unexpanded_var_list);\n+      else \n+\tcfun->saved_unexpanded_var_list\n+\t  = tree_cons (NULL_TREE, remap_decl (var, &id),\n+\t\t       cfun->saved_unexpanded_var_list);\n+    }\n+\n   /* Actually copy the body, including a new (struct function *) and CFG.\n      EH info is also duplicated so its labels point into the copied\n      CFG, not the original.  */\n   fn_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fn));\n-  newdecl = copy_body (&id, fn_entry_block->count, fn_entry_block->frequency, NULL, NULL);\n+  newdecl = copy_body (&id, fn_entry_block->count, fn_entry_block->frequency,\n+\t\t       NULL, NULL);\n   DECL_STRUCT_FUNCTION (fn)->saved_cfg = DECL_STRUCT_FUNCTION (newdecl)->cfg;\n   DECL_STRUCT_FUNCTION (fn)->saved_eh = DECL_STRUCT_FUNCTION (newdecl)->eh;\n "}, {"sha": "4add52bdf17eecfa6f6681e773309316846d54b1", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=acb8f2123d5a627e6c5dad2e78fd57d2bd6c6fb1", "patch": "@@ -924,9 +924,13 @@ tree_rest_of_compilation (tree fndecl)\n       DECL_ARGUMENTS (fndecl) = cfun->saved_args;\n       cfun->cfg = cfun->saved_cfg;\n       cfun->eh = cfun->saved_eh;\n+      DECL_INITIAL (fndecl) = cfun->saved_blocks;\n+      cfun->unexpanded_var_list = cfun->saved_unexpanded_var_list;\n       cfun->saved_cfg = NULL;\n       cfun->saved_eh = NULL;\n       cfun->saved_args = NULL_TREE;\n+      cfun->saved_blocks = NULL_TREE;\n+      cfun->saved_unexpanded_var_list = NULL_TREE;\n       cfun->static_chain_decl = cfun->saved_static_chain_decl;\n       cfun->saved_static_chain_decl = NULL;\n       /* When not in unit-at-a-time mode, we must preserve out of line copy"}]}