{"sha": "acb37d2924de4cd0195f41225e50ae9c46553cca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNiMzdkMjkyNGRlNGNkMDE5NWY0MTIyNWU1MGFlOWM0NjU1M2NjYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-09-04T18:47:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-09-04T18:47:35Z"}, "message": "re PR middle-end/37243 (IRA causes wrong code generation)\n\ngcc/\n\tPR middle-end/37243\n\t* ira-build.c (form_loop_tree): Reverse BB walk.\n\t(create_bb_allocnos): Likewise.\n\t* ira-lives.c (make_regno_born_and_dead, regs_set): Delete.\n\t(mark_reg_store): Rename to...\n\t(mark_ref_live): ...this and take a df_ref argument instead of\n\tnote_stores arguments.  Assert that we have a register.\n\t(mark_reg_clobber): Delete.\n\t(def_conflicts_with_inputs_p): New function.\n\t(mark_reg_conflicts): Delete.\n\t(mark_reg_death): Rename to...\n\t(mark_ref_dead): ...this and take a df_ref argument instead of\n\ta register.  Assert that we have a register.\n\t(process_bb_node_lives): Hoist frequency calculation out of\n\tinstruction walk.  Convert from a forwards scan to a backwards scan.\n\tUse DF_REF_USES and DF_REF_DEFS instead of register notes and\n\tnote_stores.  Remove EH_RETURN_DATA_REGNO and regs_set handling.\n\t(create_allocno_live_ranges): Don't create regs_set.\n\nFrom-SVN: r139993", "tree": {"sha": "0390c7f4a5b7e1f97a36d75b74ddad1cb441e93a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0390c7f4a5b7e1f97a36d75b74ddad1cb441e93a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acb37d2924de4cd0195f41225e50ae9c46553cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb37d2924de4cd0195f41225e50ae9c46553cca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb37d2924de4cd0195f41225e50ae9c46553cca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb37d2924de4cd0195f41225e50ae9c46553cca/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0c68ce9d288764b1706c1675804a308632d2919", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c68ce9d288764b1706c1675804a308632d2919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c68ce9d288764b1706c1675804a308632d2919"}], "stats": {"total": 374, "additions": 172, "deletions": 202}, "files": [{"sha": "e4e254c106db420e59e580ed35737fa0d99af78a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb37d2924de4cd0195f41225e50ae9c46553cca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb37d2924de4cd0195f41225e50ae9c46553cca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acb37d2924de4cd0195f41225e50ae9c46553cca", "patch": "@@ -1,3 +1,24 @@\n+2008-09-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR middle-end/37243\n+\t* ira-build.c (form_loop_tree): Reverse BB walk.\n+\t(create_bb_allocnos): Likewise.\n+\t* ira-lives.c (make_regno_born_and_dead, regs_set): Delete.\n+\t(mark_reg_store): Rename to...\n+\t(mark_ref_live): ...this and take a df_ref argument instead of\n+\tnote_stores arguments.  Assert that we have a register.\n+\t(mark_reg_clobber): Delete.\n+\t(def_conflicts_with_inputs_p): New function.\n+\t(mark_reg_conflicts): Delete.\n+\t(mark_reg_death): Rename to...\n+\t(mark_ref_dead): ...this and take a df_ref argument instead of\n+\ta register.  Assert that we have a register.\n+\t(process_bb_node_lives): Hoist frequency calculation out of\n+\tinstruction walk.  Convert from a forwards scan to a backwards scan.\n+\tUse DF_REF_USES and DF_REF_DEFS instead of register notes and\n+\tnote_stores.  Remove EH_RETURN_DATA_REGNO and regs_set handling.\n+\t(create_allocno_live_ranges): Don't create regs_set.\n+\n 2008-09-04  Ian Lance Taylor  <iant@google.com>\n \n \t* rtl.h (LABEL_REF_NONLOCAL_P): Don't check for REG_LABEL_OPERAND"}, {"sha": "6bd49c0cd1b8ace9ef32db6ea687e906946d6a57", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb37d2924de4cd0195f41225e50ae9c46553cca/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb37d2924de4cd0195f41225e50ae9c46553cca/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=acb37d2924de4cd0195f41225e50ae9c46553cca", "patch": "@@ -310,7 +310,7 @@ form_loop_tree (void)\n \t ira_loop_nodes[i].children = NULL;\n \t ira_loop_nodes[i].subloops = NULL;\n        }\n-  FOR_EACH_BB_REVERSE (bb)\n+  FOR_EACH_BB (bb)\n     {\n       bb_node = &ira_bb_nodes[bb->index];\n       bb_node->bb = bb;\n@@ -1343,7 +1343,7 @@ create_bb_allocnos (ira_loop_tree_node_t bb_node)\n \n   curr_bb = bb = bb_node->bb;\n   ira_assert (bb != NULL);\n-  FOR_BB_INSNS (bb, insn)\n+  FOR_BB_INSNS_REVERSE (bb, insn)\n     if (INSN_P (insn))\n       create_insn_allocnos (PATTERN (insn), false);\n   /* It might be a allocno living through from one subloop to"}, {"sha": "73cc06235135ff42a2b4c921fb2bacf0fb97d8a6", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 149, "deletions": 200, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb37d2924de4cd0195f41225e50ae9c46553cca/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb37d2924de4cd0195f41225e50ae9c46553cca/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=acb37d2924de4cd0195f41225e50ae9c46553cca", "patch": "@@ -149,15 +149,6 @@ make_regno_dead (int regno)\n   update_allocno_pressure_excess_length (a);\n }\n \n-/* Process the birth and, right after then, death of register\n-   REGNO.  */\n-static void\n-make_regno_born_and_dead (int regno)\n-{\n-  make_regno_born (regno);\n-  make_regno_dead (regno);\n-}\n-\n /* The current register pressures for each cover class for the current\n    basic block.  */\n static int curr_reg_pressure[N_REG_CLASSES];\n@@ -218,40 +209,21 @@ clear_allocno_live (ira_allocno_t a)\n   sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n }\n \n-/* Record all regs that are set in any one insn.  Communication from\n-   mark_reg_{store,clobber}.  */\n-static VEC(rtx, heap) *regs_set;\n-\n-/* Handle the case where REG is set by the insn being scanned, during\n-   the scan to build live ranges and calculate reg pressure info.\n+/* Mark the register referenced by use or def REF as live\n    Store a 1 in hard_regs_live or allocnos_live for this register or\n    the corresponding allocno, record how many consecutive hardware\n-   registers it actually needs.\n-\n-   Note that even if REG does not remain alive after this insn, we\n-   must mark it here as live, to ensure a conflict between REG and any\n-   other reg allocnos set in this insn that really do live.  This is\n-   because those other allocnos could be considered after this.\n+   registers it actually needs.  */\n \n-   REG might actually be something other than a register; if so, we do\n-   nothing.\n-\n-   SETTER is 0 if this register was modified by an auto-increment\n-   (i.e., a REG_INC note was found for it).  */\n static void\n-mark_reg_store (rtx reg, const_rtx setter ATTRIBUTE_UNUSED,\n-\t\tvoid *data ATTRIBUTE_UNUSED)\n+mark_ref_live (struct df_ref *ref)\n {\n+  rtx reg;\n   int regno;\n \n+  reg = DF_REF_REG (ref);\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n-\n-  if (! REG_P (reg))\n-    return;\n-\n-  VEC_safe_push (rtx, heap, regs_set, reg);\n-\n+  gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n   if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -297,54 +269,35 @@ mark_reg_store (rtx reg, const_rtx setter ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Like mark_reg_store except notice just CLOBBERs; ignore SETs.  */\n-static void\n-mark_reg_clobber (rtx reg, const_rtx setter, void *data)\n+/* Return true if the definition described by DEF conflicts with the\n+   instruction's inputs.  */\n+static bool\n+def_conflicts_with_inputs_p (struct df_ref *def)\n {\n-  if (GET_CODE (setter) == CLOBBER)\n-    mark_reg_store (reg, setter, data);\n+  /* Conservatively assume that the condition is true for all clobbers.  */\n+  return DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER);\n }\n \n-/* Record that hard register REG (if it is a hard register) has\n-   conflicts with all the allocno currently live or the corresponding\n-   allocno lives at just the current program point.  Do not mark REG\n-   (or the allocno) itself as live.  */\n+/* Mark the register referenced by definition DEF as dead, if the\n+   definition is a total one.  Store a 0 in hard_regs_live or\n+   allocnos_live for the register.  */\n static void\n-mark_reg_conflicts (rtx reg)\n+mark_ref_dead (struct df_ref *def)\n {\n+  unsigned int i;\n+  rtx reg;\n   int regno;\n \n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (! REG_P (reg))\n+  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n+      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n     return;\n \n+  reg = DF_REF_REG (def);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    make_regno_born_and_dead (regno);\n-  else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n-    {\n-      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-\n-      while (regno < last)\n-\t{\n-\t  make_regno_born_and_dead (regno);\n-\t  regno++;\n-\t}\n-    }\n-}\n-\n-/* Mark REG (or the corresponding allocno) as being dead (following\n-   the insn being scanned now).  Store a 0 in hard_regs_live or\n-   allocnos_live for the register.  */\n-static void\n-mark_reg_death (rtx reg)\n-{\n-  unsigned int i;\n-  int regno = REGNO (reg);\n-\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n@@ -618,14 +571,14 @@ process_single_reg_class_operands (bool in_p, int freq)\n static void\n process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n {\n-  int i;\n+  int i, freq;\n   unsigned int j;\n   basic_block bb;\n   rtx insn;\n   edge e;\n   edge_iterator ei;\n   bitmap_iterator bi;\n-  bitmap reg_live_in;\n+  bitmap reg_live_out;\n   unsigned int px;\n \n   bb = loop_tree_node->bb;\n@@ -637,9 +590,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  high_pressure_start_point[ira_reg_class_cover[i]] = -1;\n \t}\n       curr_bb_node = loop_tree_node;\n-      reg_live_in = DF_LR_IN (bb);\n+      reg_live_out = DF_LR_OUT (bb);\n       sparseset_clear (allocnos_live);\n-      REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_in);\n+      REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n       AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n       AND_COMPL_HARD_REG_SET (hard_regs_live, ira_no_alloc_regs);\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -659,7 +612,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t    ira_assert (curr_reg_pressure[cover_class]\n \t\t\t<= ira_available_class_regs[cover_class]);\n \t  }\n-      EXECUTE_IF_SET_IN_BITMAP (reg_live_in, FIRST_PSEUDO_REGISTER, j, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n \t{\n \t  ira_allocno_t a = ira_curr_regno_allocno_map[j];\n \t  \n@@ -670,87 +623,91 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  make_regno_born (j);\n \t}\n       \n-#ifdef EH_RETURN_DATA_REGNO\n-      if (bb_has_eh_pred (bb))\n-\t{\n-\t  for (j = 0; ; ++j)\n-\t    {\n-\t      unsigned int regno = EH_RETURN_DATA_REGNO (j);\n-\t      \n-\t      if (regno == INVALID_REGNUM)\n-\t\tbreak;\n-\t      make_regno_born_and_dead (regno);\n-\t    }\n-\t}\n-#endif\n-      \n-      /* Allocnos can't go in stack regs at the start of a basic block\n-\t that is reached by an abnormal edge. Likewise for call\n-\t clobbered regs, because caller-save, fixup_abnormal_edges and\n-\t possibly the table driven EH machinery are not quite ready to\n-\t handle such allocnos live across such edges.  */\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (e->flags & EDGE_ABNORMAL)\n-\t  break;\n-      \n-      if (e != NULL)\n-\t{\n-#ifdef STACK_REGS\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, px)\n-\t    {\n-\t      ALLOCNO_NO_STACK_REG_P (ira_allocnos[px]) = true;\n-\t      ALLOCNO_TOTAL_NO_STACK_REG_P (ira_allocnos[px]) = true;\n-\t    }\n-\t  for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n-\t    make_regno_born_and_dead (px);\n-#endif\n-\t  /* No need to record conflicts for call clobbered regs if we\n-\t     have nonlocal labels around, as we don't ever try to\n-\t     allocate such regs in this case.  */\n-\t  if (!cfun->has_nonlocal_label)\n-\t    for (px = 0; px < FIRST_PSEUDO_REGISTER; px++)\n-\t      if (call_used_regs[px])\n-\t\tmake_regno_born_and_dead (px);\n-\t}\n-  \n+      freq = REG_FREQ_FROM_BB (bb);\n+      if (freq == 0)\n+\tfreq = 1;\n+\n       /* Scan the code of this basic block, noting which allocnos and\n-\t hard regs are born or die.  */\n-      FOR_BB_INSNS (bb, insn)\n+\t hard regs are born or die.\n+\n+\t Note that this loop treats uninitialized values as live until\n+\t the beginning of the block.  For example, if an instruction\n+\t uses (reg:DI foo), and only (subreg:SI (reg:DI foo) 0) is ever\n+\t set, FOO will remain live until the beginning of the block.\n+\t Likewise if FOO is not set at all.  This is unnecessarily\n+\t pessimistic, but it probably doesn't matter much in practice.  */\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n-\t  rtx link;\n-\t  int freq;\n+\t  struct df_ref **def_rec, **use_rec;\n+\t  bool call_p;\n \t  \n \t  if (! INSN_P (insn))\n \t    continue;\n \t  \n-\t  freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));\n-\t  if (freq == 0)\n-\t    freq = 1;\n-\n \t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \t    fprintf (ira_dump_file, \"   Insn %u(l%d): point = %d\\n\",\n \t\t     INSN_UID (insn), loop_tree_node->parent->loop->num,\n \t\t     curr_point);\n \n-\t  /* Check regs_set is an empty set.  */\n-\t  gcc_assert (VEC_empty (rtx, regs_set));\n-      \n-\t  /* Mark any allocnos clobbered by INSN as live, so they\n-\t     conflict with the inputs.  */\n-\t  note_stores (PATTERN (insn), mark_reg_clobber, NULL);\n+\t  /* Mark each defined value as live.  We need to do this for\n+\t     unused values because they still conflict with quantities\n+\t     that are live at the time of the definition.\n+\n+\t     Ignore DF_REF_MAY_CLOBBERs on a call instruction.  Such\n+\t     references represent the effect of the called function\n+\t     on a call-clobbered register.  Marking the register as\n+\t     live would stop us from allocating it to a call-crossing\n+\t     allocno.  */\n+\t  call_p = CALL_P (insn);\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    if (!call_p || !DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MAY_CLOBBER))\n+\t      mark_ref_live (*def_rec);\n+\n+\t  /* If INSN has multiple outputs, then any value used in one\n+\t     of the outputs conflicts with the other outputs.  Model this\n+\t     by making the used value live during the output phase.\n+\n+\t     It is unsafe to use !single_set here since it will ignore\n+\t     an unused output.  Just because an output is unused does\n+\t     not mean the compiler can assume the side effect will not\n+\t     occur.  Consider if ALLOCNO appears in the address of an\n+\t     output and we reload the output.  If we allocate ALLOCNO\n+\t     to the same hard register as an unused output we could\n+\t     set the hard register before the output reload insn.  */\n+\t  if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n+\t    for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t      {\n+\t\tint i;\n+\t\trtx reg;\n+\n+\t\treg = DF_REF_REG (*use_rec);\n+\t\tfor (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t\t  {\n+\t\t    rtx set;\n+\n+\t\t    set = XVECEXP (PATTERN (insn), 0, i);\n+\t\t    if (GET_CODE (set) == SET\n+\t\t\t&& reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\t\t      {\n+\t\t\t/* After the previous loop, this is a no-op if\n+\t\t\t   REG is contained within SET_DEST (SET).  */\n+\t\t\tmark_ref_live (*use_rec);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n \t  \n \t  extract_insn (insn);\n-\t  process_single_reg_class_operands (true, freq);\n-\t  \n-\t  /* Mark any allocnos dead after INSN as dead now.  */\n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n-\t      mark_reg_death (XEXP (link, 0));\n+\t  process_single_reg_class_operands (false, freq);\n \t  \n-\t  curr_point++;\n+\t  /* See which defined values die here.  */\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    if (!call_p || !DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MAY_CLOBBER))\n+\t      mark_ref_dead (*def_rec);\n \n-\t  if (CALL_P (insn))\n+\t  if (call_p)\n \t    {\n+\t      /* The current set of live allocnos are live across the call.  */\n \t      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n \t        {\n \t\t  ira_allocno_t a = ira_allocnos[i];\n@@ -767,67 +724,62 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t}\n \t    }\n \t  \n-\t  /* Mark any allocnos set in INSN as live.  Clobbers are\n-\t     processed again, so they will conflict with the reg\n-\t     allocnos that are set.  */\n-\t  note_stores (PATTERN (insn), mark_reg_store, NULL);\n-\t  \n-#ifdef AUTO_INC_DEC\n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    if (REG_NOTE_KIND (link) == REG_INC)\n-\t      mark_reg_store (XEXP (link, 0), NULL_RTX, NULL);\n-#endif\n-\t  \n-\t  /* If INSN has multiple outputs, then any allocno that dies\n-\t     here and is used inside of an output must conflict with\n-\t     the other outputs.\n-\t     \n-\t     It is unsafe to use !single_set here since it will ignore\n-\t     an unused output.  Just because an output is unused does\n-\t     not mean the compiler can assume the side effect will not\n-\t     occur.  Consider if ALLOCNO appears in the address of an\n-\t     output and we reload the output.  If we allocate ALLOCNO\n-\t     to the same hard register as an unused output we could\n-\t     set the hard register before the output reload insn.  */\n-\t  if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n-\t    for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t      if (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\t{\n-\t\t  int i;\n-\t\t  int used_in_output = 0;\n-\t\t  rtx reg = XEXP (link, 0);\n-\t\t  \n-\t\t  for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t\t    {\n-\t\t      rtx set = XVECEXP (PATTERN (insn), 0, i);\n-\t\t      \n-\t\t      if (GET_CODE (set) == SET\n-\t\t\t  && ! REG_P (SET_DEST (set))\n-\t\t\t  && ! rtx_equal_p (reg, SET_DEST (set))\n-\t\t\t  && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\t\t\tused_in_output = 1;\n-\t\t    }\n-\t\t  if (used_in_output)\n-\t\t    mark_reg_conflicts (reg);\n-\t\t}\n-\t  \n-\t  process_single_reg_class_operands (false, freq);\n+\t  curr_point++;\n+\n+\t  /* Mark each used value as live.  */\n+\t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t    mark_ref_live (*use_rec);\n+\n+\t  /* If any defined values conflict with the inputs, mark those\n+\t     defined values as live.  */\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    if (def_conflicts_with_inputs_p (*def_rec))\n+\t      mark_ref_live (*def_rec);\n+\n+\t  process_single_reg_class_operands (true, freq);\n \t  \n-\t  /* Mark any allocnos set in INSN and then never used.  */\n-\t  while (! VEC_empty (rtx, regs_set))\n-\t    {\n-\t      rtx reg = VEC_pop (rtx, regs_set);\n-\t      rtx note = find_regno_note (insn, REG_UNUSED, REGNO (reg));\n+\t  /* See which of the defined values we marked as live are dead\n+\t     before the instruction.  */\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    if (def_conflicts_with_inputs_p (*def_rec))\n+\t      mark_ref_dead (*def_rec);\n \n-\t      if (note)\n-\t\tmark_reg_death (XEXP (note, 0));\n-\t    }\n \t  curr_point++;\n \t}\n+\n+      /* Allocnos can't go in stack regs at the start of a basic block\n+\t that is reached by an abnormal edge. Likewise for call\n+\t clobbered regs, because caller-save, fixup_abnormal_edges and\n+\t possibly the table driven EH machinery are not quite ready to\n+\t handle such allocnos live across such edges.  */\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  break;\n+\n+      if (e != NULL)\n+\t{\n+#ifdef STACK_REGS\n+\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, px)\n+\t    {\n+\t      ALLOCNO_NO_STACK_REG_P (ira_allocnos[px]) = true;\n+\t      ALLOCNO_TOTAL_NO_STACK_REG_P (ira_allocnos[px]) = true;\n+\t    }\n+\t  for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n+\t    make_regno_born (px);\n+#endif\n+\t  /* No need to record conflicts for call clobbered regs if we\n+\t     have nonlocal labels around, as we don't ever try to\n+\t     allocate such regs in this case.  */\n+\t  if (!cfun->has_nonlocal_label)\n+\t    for (px = 0; px < FIRST_PSEUDO_REGISTER; px++)\n+\t      if (call_used_regs[px])\n+\t\tmake_regno_born (px);\n+\t}\n+\n       EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-       {\n-\t make_regno_dead (ALLOCNO_REGNO (ira_allocnos[i]));\n-       }\n+\t{\n+\t  make_regno_dead (ALLOCNO_REGNO (ira_allocnos[i]));\n+\t}\n \n       curr_point++;\n \n@@ -944,9 +896,6 @@ void\n ira_create_allocno_live_ranges (void)\n {\n   allocnos_live = sparseset_alloc (ira_allocnos_num);\n-  /* Make a vector that mark_reg_{store,clobber} will store in.  */\n-  if (!regs_set)\n-    regs_set = VEC_alloc (rtx, heap, 10);\n   curr_point = 0;\n   ira_traverse_loop_tree (true, ira_loop_tree_root, NULL,\n \t\t\t  process_bb_node_lives);"}]}