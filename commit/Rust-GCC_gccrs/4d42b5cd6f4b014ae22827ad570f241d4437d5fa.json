{"sha": "4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ0MmI1Y2Q2ZjRiMDE0YWUyMjgyN2FkNTcwZjI0MWQ0NDM3ZDVmYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-09-16T16:53:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-09-16T16:53:35Z"}, "message": "gfortran.h (walk_code_fn_t, [...]): New types.\n\n\t* gfortran.h (walk_code_fn_t, walk_expr_fn_t): New types.\n\t(gfc_expr_walker, gfc_code_walker): New prototypes.\n\t* frontend-passes.c (gfc_expr_walker, gfc_code_walker): New functions.\n\t(WALK_SUBEXPR, WALK_SUBEXPR_TAIL, WALK_SUBCODE): Define.\n\t(optimize_namespace): Use gfc_code_walker.\n\t(optimize_code, optimize_expr): Rewritten as gfc_code_walker hooks.\n\t(optimize_expr_0, optimize_code_node,\n\toptimize_actual_arglist): Removed.\n\t(optimize_assignment): Don't call optimize_expr_0.\n\nFrom-SVN: r164342", "tree": {"sha": "ff17985e2f0017ae579952341a586002328cafb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff17985e2f0017ae579952341a586002328cafb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "815248b197b3d1c5dbeebf2d55bca0af899bdebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815248b197b3d1c5dbeebf2d55bca0af899bdebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815248b197b3d1c5dbeebf2d55bca0af899bdebb"}], "stats": {"total": 535, "additions": 284, "deletions": 251}, "files": [{"sha": "3f97c4c332d1cfe8778ee2b5da12715c563a38ce", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "patch": "@@ -1,3 +1,15 @@\n+2010-09-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.h (walk_code_fn_t, walk_expr_fn_t): New types.\n+\t(gfc_expr_walker, gfc_code_walker): New prototypes.\n+\t* frontend-passes.c (gfc_expr_walker, gfc_code_walker): New functions.\n+\t(WALK_SUBEXPR, WALK_SUBEXPR_TAIL, WALK_SUBCODE): Define.\n+\t(optimize_namespace): Use gfc_code_walker.\n+\t(optimize_code, optimize_expr): Rewritten as gfc_code_walker hooks.\n+\t(optimize_expr_0, optimize_code_node,\n+\toptimize_actual_arglist): Removed.\n+\t(optimize_assignment): Don't call optimize_expr_0.\n+\n 2010-09-16  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/45674"}, {"sha": "b6a74fd2ccecf1dcc1d179c76284c7c83eb1c435", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 266, "deletions": 251, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "patch": "@@ -30,13 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n static void strip_function_call (gfc_expr *);\n static void optimize_namespace (gfc_namespace *);\n static void optimize_assignment (gfc_code *);\n-static void optimize_expr_0 (gfc_expr *);\n-static bool optimize_expr (gfc_expr *);\n static bool optimize_op (gfc_expr *);\n static bool optimize_equality (gfc_expr *, bool);\n-static void optimize_code (gfc_code *);\n-static void optimize_code_node (gfc_code *);\n-static void optimize_actual_arglist (gfc_actual_arglist *);\n \n /* Entry point - run all passes for a namespace.  So far, only an\n    optimization pass is run.  */\n@@ -48,195 +43,39 @@ gfc_run_passes (gfc_namespace *ns)\n     optimize_namespace (ns);\n }\n \n-/* Optimize a namespace, including all contained namespaces.  */\n+/* Callback for each gfc_code node invoked through gfc_code_walker\n+   from optimize_namespace.  */\n \n-static void\n-optimize_namespace (gfc_namespace *ns)\n+static int\n+optimize_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t       void *data ATTRIBUTE_UNUSED)\n {\n-  optimize_code (ns->code);\n-\n-  for (ns = ns->contained; ns; ns = ns->sibling)\n-    optimize_namespace (ns);\n+  if ((*c)->op == EXEC_ASSIGN)\n+    optimize_assignment (*c);\n+  return 0;\n }\n \n-static void\n-optimize_code (gfc_code *c)\n+/* Callback for each gfc_expr node invoked through gfc_code_walker\n+   from optimize_namespace.  */\n+\n+static int\n+optimize_expr (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t       void *data ATTRIBUTE_UNUSED)\n {\n-  for (; c; c = c->next)\n-    optimize_code_node (c);\n+  if ((*e)->expr_type == EXPR_OP && optimize_op (*e))\n+    gfc_simplify_expr (*e, 0);\n+  return 0;\n }\n \n-\n-/* Do the optimizations for a code node.  */\n+/* Optimize a namespace, including all contained namespaces.  */\n \n static void\n-optimize_code_node (gfc_code *c)\n+optimize_namespace (gfc_namespace *ns)\n {\n+  gfc_code_walker (&ns->code, optimize_code, optimize_expr, NULL);\n \n-  gfc_forall_iterator *fa;\n-  gfc_code *d;\n-  gfc_alloc *a;\n-\n-  switch (c->op)\n-    {\n-    case EXEC_ASSIGN:\n-      optimize_assignment (c);\n-      break;\n-\n-    case EXEC_CALL:\n-    case EXEC_ASSIGN_CALL:\n-    case EXEC_CALL_PPC:\n-      optimize_actual_arglist (c->ext.actual);\n-      break;\n-\n-    case EXEC_ARITHMETIC_IF:\n-      optimize_expr_0 (c->expr1);\n-      break;\n-\n-    case EXEC_PAUSE:\n-    case EXEC_RETURN:\n-    case EXEC_ERROR_STOP:\n-    case EXEC_STOP:\n-    case EXEC_COMPCALL:\n-      optimize_expr_0 (c->expr1);\n-      break;\n-\n-    case EXEC_SYNC_ALL:\n-    case EXEC_SYNC_MEMORY:\n-    case EXEC_SYNC_IMAGES:\n-      optimize_expr_0 (c->expr2);\n-      break;\n-\n-    case EXEC_IF:\n-      d = c->block;\n-      optimize_expr_0 (d->expr1);\n-      optimize_code (d->next);\n-\n-      for (d = d->block; d; d = d->block)\n-\t{\n-\t  optimize_expr_0 (d->expr1);\n-\n-\t  optimize_code (d->next);\n-\t}\n-\n-\n-      break;\n-\n-    case EXEC_SELECT:\n-    case EXEC_SELECT_TYPE:\n-      d = c->block;\n-\n-      optimize_expr_0 (c->expr1);\n-\n-      for (; d; d = d->block)\n-\toptimize_code (d->next);\n-\n-      break;\n-\n-    case EXEC_WHERE:\n-      d = c->block;\n-      optimize_expr_0 (d->expr1);\n-      optimize_code (d->next);\n-\n-      for (d = d->block; d; d = d->block)\n-\t{\n-\t  optimize_expr_0 (d->expr1);\n-\t  optimize_code (d->next);\n-\t}\n-      break;\n-\n-    case EXEC_FORALL:\n-\n-      for (fa = c->ext.forall_iterator; fa; fa = fa->next)\n-\t{\n-\t  optimize_expr_0 (fa->start);\n-\t  optimize_expr_0 (fa->end);\n-\t  optimize_expr_0 (fa->stride);\n-\t}\n-\n-      if (c->expr1 != NULL)\n-\t  optimize_expr_0 (c->expr1);\n-\n-      optimize_code (c->block->next);\n-\n-      break;\n-\n-    case EXEC_CRITICAL:\n-      optimize_code (c->block->next);\n-      break;\n-\n-    case EXEC_DO:\n-      optimize_expr_0 (c->ext.iterator->start);\n-      optimize_expr_0 (c->ext.iterator->end);\n-      optimize_expr_0 (c->ext.iterator->step);\n-      optimize_code (c->block->next);\n-\n-      break;\n-\n-    case EXEC_DO_WHILE:\n-      optimize_expr_0 (c->expr1);\n-      optimize_code (c->block->next);\n-      break;\n-\n-\n-    case EXEC_ALLOCATE:\n-      for (a = c->ext.alloc.list; a; a = a->next)\n-\t  optimize_expr_0 (a->expr);\n-      break;\n-\n-      /* Todo:  Some of these may need to be optimized, as well.  */\n-    case EXEC_WRITE:\n-    case EXEC_READ:\n-    case EXEC_OPEN:\n-    case EXEC_INQUIRE:\n-    case EXEC_REWIND:\n-    case EXEC_ENDFILE:\n-    case EXEC_BACKSPACE:\n-    case EXEC_CLOSE:\n-    case EXEC_WAIT:\n-    case EXEC_TRANSFER:\n-    case EXEC_FLUSH:\n-    case EXEC_IOLENGTH:\n-    case EXEC_END_PROCEDURE:\n-    case EXEC_NOP:\n-    case EXEC_CONTINUE:\n-    case EXEC_ENTRY:\n-    case EXEC_INIT_ASSIGN:\n-    case EXEC_LABEL_ASSIGN:\n-    case EXEC_POINTER_ASSIGN:\n-    case EXEC_GOTO:\n-    case EXEC_CYCLE:\n-    case EXEC_EXIT:\n-    case EXEC_BLOCK:\n-    case EXEC_END_BLOCK:\n-    case EXEC_OMP_ATOMIC:\n-    case EXEC_OMP_BARRIER:\n-    case EXEC_OMP_CRITICAL:\n-    case EXEC_OMP_FLUSH:\n-    case EXEC_OMP_DO:\n-    case EXEC_OMP_MASTER:\n-    case EXEC_OMP_ORDERED:\n-    case EXEC_OMP_PARALLEL:\n-    case EXEC_OMP_PARALLEL_DO:\n-    case EXEC_OMP_PARALLEL_SECTIONS:\n-    case EXEC_OMP_PARALLEL_WORKSHARE:\n-    case EXEC_OMP_SECTIONS:\n-    case EXEC_OMP_SINGLE:\n-    case EXEC_OMP_TASK:\n-    case EXEC_OMP_TASKWAIT:\n-    case EXEC_OMP_WORKSHARE:\n-    case EXEC_OMP_END_NOWAIT:\n-    case EXEC_OMP_END_SINGLE:\n-    case EXEC_DEALLOCATE:\n-    case EXEC_DT_END:\n-      for (d = c->block; d; d = d->block)\n-\toptimize_code (d->next);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-\n-    }\n+  for (ns = ns->contained; ns; ns = ns->sibling)\n+    optimize_namespace (ns);\n }\n \n /* Replace code like\n@@ -336,15 +175,6 @@ optimize_assignment (gfc_code * c)\n \n   if (lhs->rank > 0 && gfc_check_dependency (lhs, rhs, true) == 0)\n     optimize_binop_array_assignment (c, &rhs, false);\n-\n-  /* If we insert a statement after the current one, the surrounding loop in\n-     optimize_code will call optimize_assignment on the inserted statement\n-     anyway, so there is no need to call optimize_assignment again.  */\n-\n-  /* All direct optimizations have been done.  Now it's time\n-     to optimize the rhs.  */\n-\n-  optimize_expr_0 (rhs);\n }\n \n \n@@ -375,58 +205,12 @@ strip_function_call (gfc_expr *e)\n \n }\n \n-/* Top-level optimization of expressions.  Calls gfc_simplify_expr if\n-   optimize_expr succeeds in doing something.\n-   TODO: Optimization of multiple function occurrence to come here.  */\n-\n-static void\n-optimize_expr_0 (gfc_expr * e)\n-{\n-  if (optimize_expr (e))\n-    gfc_simplify_expr (e, 0);\n-\n-  return;\n-}\n-\n-/* Recursive optimization of expressions.\n- TODO:  Make this handle many more things.  */\n-\n-static bool\n-optimize_expr (gfc_expr *e)\n-{\n-  bool ret;\n-\n-  if (e == NULL)\n-    return false;\n-\n-  ret = false;\n-\n-  switch (e->expr_type)\n-    {\n-    case EXPR_OP:\n-      return optimize_op (e);\n-      break;\n-\n-    case EXPR_FUNCTION:\n-      optimize_actual_arglist (e->value.function.actual);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return ret;\n-}\n-\n /* Recursive optimization of operators.  */\n \n static bool\n optimize_op (gfc_expr *e)\n {\n-\n-  gfc_intrinsic_op op;\n-\n-  op = e->value.op.op;\n+  gfc_intrinsic_op op = e->value.op.op;\n \n   switch (op)\n     {\n@@ -437,7 +221,6 @@ optimize_op (gfc_expr *e)\n     case INTRINSIC_LE:\n     case INTRINSIC_LE_OS:\n       return optimize_equality (e, true);\n-      break;\n \n     case INTRINSIC_NE:\n     case INTRINSIC_NE_OS:\n@@ -446,7 +229,6 @@ optimize_op (gfc_expr *e)\n     case INTRINSIC_LT:\n     case INTRINSIC_LT_OS:\n       return optimize_equality (e, false);\n-      break;\n \n     default:\n       break;\n@@ -460,7 +242,6 @@ optimize_op (gfc_expr *e)\n static bool\n optimize_equality (gfc_expr *e, bool equal)\n {\n-\n   gfc_expr *op1, *op2;\n   bool change;\n \n@@ -519,18 +300,252 @@ optimize_equality (gfc_expr *e, bool equal)\n   return false;\n }\n \n-/* Optimize a call list.  Right now, this just goes through the actual\n-   arg list and optimizes each expression in turn.  */\n+#define WALK_SUBEXPR(NODE) \\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = gfc_expr_walker (&(NODE), exprfn, data);\t\\\n+      if (result)\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+#define WALK_SUBEXPR_TAIL(NODE) e = &(NODE); continue\n \n-static void\n-optimize_actual_arglist (gfc_actual_arglist *a)\n+/* Walk expression *E, calling EXPRFN on each expression in it.  */\n+\n+int\n+gfc_expr_walker (gfc_expr **e, walk_expr_fn_t exprfn, void *data)\n {\n+  while (*e)\n+    {\n+      int walk_subtrees = 1;\n+      gfc_actual_arglist *a;\n+      int result = exprfn (e, &walk_subtrees, data);\n+      if (result)\n+\treturn result;\n+      if (walk_subtrees)\n+\tswitch ((*e)->expr_type)\n+\t  {\n+\t  case EXPR_OP:\n+\t    WALK_SUBEXPR ((*e)->value.op.op1);\n+\t    WALK_SUBEXPR_TAIL ((*e)->value.op.op2);\n+\t    break;\n+\t  case EXPR_FUNCTION:\n+\t    for (a = (*e)->value.function.actual; a; a = a->next)\n+\t      WALK_SUBEXPR (a->expr);\n+\t    break;\n+\t  case EXPR_COMPCALL:\n+\t  case EXPR_PPC:\n+\t    WALK_SUBEXPR ((*e)->value.compcall.base_object);\n+\t    for (a = (*e)->value.compcall.actual; a; a = a->next)\n+\t      WALK_SUBEXPR (a->expr);\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+      return 0;\n+    }\n+  return 0;\n+}\n \n-  for (; a; a = a->next)\n+#define WALK_SUBCODE(NODE) \\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      result = gfc_code_walker (&(NODE), codefn, exprfn, data);\t\\\n+      if (result)\t\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Walk code *C, calling CODEFN on each gfc_code node in it and calling EXPRFN\n+   on each expression in it.  If any of the hooks returns non-zero, that\n+   value is immediately returned.  If the hook sets *WALK_SUBTREES to 0,\n+   no subcodes or subexpressions are traversed.  */\n+\n+int\n+gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n+\t\t void *data)\n+{\n+  for (; *c; c = &(*c)->next)\n     {\n-      if (a->expr != NULL)\n-\toptimize_expr_0 (a->expr);\n+      int walk_subtrees = 1;\n+      int result = codefn (c, &walk_subtrees, data);\n+      if (result)\n+\treturn result;\n+      if (walk_subtrees)\n+\t{\n+\t  gfc_code *b;\n+\t  switch ((*c)->op)\n+\t    {\n+\t    case EXEC_DO:\n+\t      WALK_SUBEXPR ((*c)->ext.iterator->var);\n+\t      WALK_SUBEXPR ((*c)->ext.iterator->start);\n+\t      WALK_SUBEXPR ((*c)->ext.iterator->end);\n+\t      WALK_SUBEXPR ((*c)->ext.iterator->step);\n+\t      break;\n+\t    case EXEC_SELECT:\n+\t      WALK_SUBEXPR ((*c)->expr1);\n+\t      for (b = (*c)->block; b; b = b->block)\n+\t\t{\n+\t\t  gfc_case *cp;\n+\t\t  for (cp = b->ext.case_list; cp; cp = cp->next)\n+\t\t    {\n+\t\t      WALK_SUBEXPR (cp->low);\n+\t\t      WALK_SUBEXPR (cp->high);\n+\t\t    }\n+\t\t  WALK_SUBCODE (b->next);\n+\t\t}\n+\t      continue;\n+\t    case EXEC_ALLOCATE:\n+\t    case EXEC_DEALLOCATE:\n+\t      {\n+\t\tgfc_alloc *a;\n+\t\tfor (a = (*c)->ext.alloc.list; a; a = a->next)\n+\t\t  WALK_SUBEXPR (a->expr);\n+\t\tbreak;\n+\t      }\n+\t    case EXEC_FORALL:\n+\t      {\n+\t\tgfc_forall_iterator *fa;\n+\t\tfor (fa = (*c)->ext.forall_iterator; fa; fa = fa->next)\n+\t\t  {\n+\t\t    WALK_SUBEXPR (fa->var);\n+\t\t    WALK_SUBEXPR (fa->start);\n+\t\t    WALK_SUBEXPR (fa->end);\n+\t\t    WALK_SUBEXPR (fa->stride);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    case EXEC_OPEN:\n+\t      WALK_SUBEXPR ((*c)->ext.open->unit);\n+\t      WALK_SUBEXPR ((*c)->ext.open->file);\n+\t      WALK_SUBEXPR ((*c)->ext.open->status);\n+\t      WALK_SUBEXPR ((*c)->ext.open->access);\n+\t      WALK_SUBEXPR ((*c)->ext.open->form);\n+\t      WALK_SUBEXPR ((*c)->ext.open->recl);\n+\t      WALK_SUBEXPR ((*c)->ext.open->blank);\n+\t      WALK_SUBEXPR ((*c)->ext.open->position);\n+\t      WALK_SUBEXPR ((*c)->ext.open->action);\n+\t      WALK_SUBEXPR ((*c)->ext.open->delim);\n+\t      WALK_SUBEXPR ((*c)->ext.open->pad);\n+\t      WALK_SUBEXPR ((*c)->ext.open->iostat);\n+\t      WALK_SUBEXPR ((*c)->ext.open->iomsg);\n+\t      WALK_SUBEXPR ((*c)->ext.open->convert);\n+\t      WALK_SUBEXPR ((*c)->ext.open->decimal);\n+\t      WALK_SUBEXPR ((*c)->ext.open->encoding);\n+\t      WALK_SUBEXPR ((*c)->ext.open->round);\n+\t      WALK_SUBEXPR ((*c)->ext.open->sign);\n+\t      WALK_SUBEXPR ((*c)->ext.open->asynchronous);\n+\t      WALK_SUBEXPR ((*c)->ext.open->id);\n+\t      WALK_SUBEXPR ((*c)->ext.open->newunit);\n+\t      break;\n+\t    case EXEC_CLOSE:\n+\t      WALK_SUBEXPR ((*c)->ext.close->unit);\n+\t      WALK_SUBEXPR ((*c)->ext.close->status);\n+\t      WALK_SUBEXPR ((*c)->ext.close->iostat);\n+\t      WALK_SUBEXPR ((*c)->ext.close->iomsg);\n+\t      break;\n+\t    case EXEC_BACKSPACE:\n+\t    case EXEC_ENDFILE:\n+\t    case EXEC_REWIND:\n+\t    case EXEC_FLUSH:\n+\t      WALK_SUBEXPR ((*c)->ext.filepos->unit);\n+\t      WALK_SUBEXPR ((*c)->ext.filepos->iostat);\n+\t      WALK_SUBEXPR ((*c)->ext.filepos->iomsg);\n+\t      break;\n+\t    case EXEC_INQUIRE:\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->unit);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->file);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->iomsg);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->iostat);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->exist);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->opened);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->number);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->named);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->name);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->access);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->sequential);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->direct);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->form);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->formatted);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->unformatted);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->recl);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->nextrec);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->blank);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->position);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->action);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->read);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->write);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->readwrite);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->delim);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->encoding);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->pad);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->iolength);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->convert);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->strm_pos);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->asynchronous);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->decimal);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->pending);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->id);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->sign);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->size);\n+\t      WALK_SUBEXPR ((*c)->ext.inquire->round);\n+\t      break;\n+\t    case EXEC_WAIT:\n+\t      WALK_SUBEXPR ((*c)->ext.wait->unit);\n+\t      WALK_SUBEXPR ((*c)->ext.wait->iostat);\n+\t      WALK_SUBEXPR ((*c)->ext.wait->iomsg);\n+\t      WALK_SUBEXPR ((*c)->ext.wait->id);\n+\t      break;\n+\t    case EXEC_READ:\n+\t    case EXEC_WRITE:\n+\t      WALK_SUBEXPR ((*c)->ext.dt->io_unit);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->format_expr);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->rec);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->advance);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->iostat);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->size);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->iomsg);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->id);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->pos);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->asynchronous);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->blank);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->decimal);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->delim);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->pad);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->round);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->sign);\n+\t      WALK_SUBEXPR ((*c)->ext.dt->extra_comma);\n+\t      break;\n+\t    case EXEC_OMP_DO:\n+\t    case EXEC_OMP_PARALLEL:\n+\t    case EXEC_OMP_PARALLEL_DO:\n+\t    case EXEC_OMP_PARALLEL_SECTIONS:\n+\t    case EXEC_OMP_PARALLEL_WORKSHARE:\n+\t    case EXEC_OMP_SECTIONS:\n+\t    case EXEC_OMP_SINGLE:\n+\t    case EXEC_OMP_WORKSHARE:\n+\t    case EXEC_OMP_END_SINGLE:\n+\t    case EXEC_OMP_TASK:\n+\t      if ((*c)->ext.omp_clauses)\n+\t\t{\n+\t\t  WALK_SUBEXPR ((*c)->ext.omp_clauses->if_expr);\n+\t\t  WALK_SUBEXPR ((*c)->ext.omp_clauses->num_threads);\n+\t\t  WALK_SUBEXPR ((*c)->ext.omp_clauses->chunk_size);\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t  WALK_SUBEXPR ((*c)->expr1);\n+\t  WALK_SUBEXPR ((*c)->expr2);\n+\t  WALK_SUBEXPR ((*c)->expr3);\n+\t  for (b = (*c)->block; b; b = b->block)\n+\t    {\n+\t      WALK_SUBEXPR (b->expr1);\n+\t      WALK_SUBEXPR (b->expr2);\n+\t      WALK_SUBCODE (b->next);\n+\t    }\n+\t}\n     }\n-  \n-  return;\n+  return 0;\n }"}, {"sha": "947f1ff766e18fab584d633c1ffc4d563c2cecea", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d42b5cd6f4b014ae22827ad570f241d4437d5fa/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4d42b5cd6f4b014ae22827ad570f241d4437d5fa", "patch": "@@ -2886,4 +2886,10 @@ gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n \n void gfc_run_passes (gfc_namespace *);\n \n+typedef int (*walk_code_fn_t) (gfc_code **, int *, void *);\n+typedef int (*walk_expr_fn_t) (gfc_expr **, int *, void *);\n+\n+int gfc_expr_walker (gfc_expr **, walk_expr_fn_t, void *);\n+int gfc_code_walker (gfc_code **, walk_code_fn_t, walk_expr_fn_t, void *);\n+\n #endif /* GCC_GFORTRAN_H  */"}]}