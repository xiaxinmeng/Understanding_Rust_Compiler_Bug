{"sha": "f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzOTU2MWNjZTI3ZDliNjYyYjBhM2IyMmQzZGQ2YWE1NmFlMTg1NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-06-20T02:40:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-06-20T02:40:37Z"}, "message": "re PR c++/9649 (ICE in finish_member_declaration at cp/semantics.c:1850 when redeclaring a static member variable)\n\n\tPR c++/9649\n\t* cp-tree.h (pushdecl_class_level): Change prototype.\n\t(push_class_level_binding): Likewise.\n\t* decl.c (add_binding): Reject duplicate static data members.\n\t(pushdecl_class_level): Return a value indicating whether or not\n\tthe binding was valid.\n\t(push_class_level_binding): Likewise.\n\t* semantics.c (finish_member_declaration): Don't keep invalid\n\tdeclarations.\n\n\tPR c++/9649\n\t* g++.dg/template/static4.C: New test.\n\t* g++.old-deja/g++.other/anon7.C: Remove spurious error messages.\n\nFrom-SVN: r68240", "tree": {"sha": "f39921e4f96d4b307cb115c1a2e04b29f5a15ee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f39921e4f96d4b307cb115c1a2e04b29f5a15ee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/comments", "author": null, "committer": null, "parents": [{"sha": "170b020fe4be4eadea27d389257778d952fb5a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170b020fe4be4eadea27d389257778d952fb5a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170b020fe4be4eadea27d389257778d952fb5a13"}], "stats": {"total": 86, "additions": 61, "deletions": 25}, "files": [{"sha": "ba7bc03346a4c82081e4356f38d4e3e7af555d99", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -1,5 +1,15 @@\n 2003-06-19  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/9649\n+\t* cp-tree.h (pushdecl_class_level): Change prototype.\n+\t(push_class_level_binding): Likewise.\n+\t* decl.c (add_binding): Reject duplicate static data members.\n+\t(pushdecl_class_level): Return a value indicating whether or not\n+\tthe binding was valid.\n+\t(push_class_level_binding): Likewise.\n+\t* semantics.c (finish_member_declaration): Don't keep invalid\n+\tdeclarations.\n+\n \tPR c++/11041\n \t* call.c (initialize_reference): Do not use cp_finish_decl to emit\n \ttemporary variables."}, {"sha": "6bc6f6f2f38605eed31df1abfc6150ea8c989c4e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -3638,11 +3638,11 @@ extern int decls_match\t\t\t\t(tree, tree);\n extern int duplicate_decls\t\t\t(tree, tree);\n extern tree pushdecl_top_level\t\t\t(tree);\n extern tree pushdecl_top_level_and_finish       (tree, tree);\n-extern void pushdecl_class_level\t\t(tree);\n+extern bool pushdecl_class_level\t\t(tree);\n extern tree pushdecl_namespace_level            (tree);\n extern tree push_using_decl                     (tree, tree);\n extern tree push_using_directive                (tree);\n-extern void push_class_level_binding\t\t(tree, tree);\n+extern bool push_class_level_binding\t\t(tree, tree);\n extern tree implicitly_declare\t\t\t(tree);\n extern tree declare_local_label                 (tree);\n extern tree define_label\t\t\t(const char *, int, tree);"}, {"sha": "d73c0d08f996f0f3cf9532da22b5387b376af242", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -964,11 +964,18 @@ add_binding (tree id, tree decl)\n \t type to which it already refers.  */\n     ok = 0;\n   /* There can be two block-scope declarations of the same variable,\n-     so long as they are `extern' declarations.  */\n+     so long as they are `extern' declarations.  However, there cannot\n+     be two declarations of the same static data member:\n+\n+       [class.mem]\n+\n+       A member shall not be declared twice in the\n+       member-specification.  */\n   else if (TREE_CODE (decl) == VAR_DECL\n \t   && TREE_CODE (BINDING_VALUE (binding)) == VAR_DECL\n \t   && DECL_EXTERNAL (decl)\n-\t   && DECL_EXTERNAL (BINDING_VALUE (binding)))\n+\t   && DECL_EXTERNAL (BINDING_VALUE (binding))\n+\t   && !DECL_CLASS_SCOPE_P (decl))\n     {\n       duplicate_decls (decl, BINDING_VALUE (binding));\n       ok = 0;\n@@ -4179,10 +4186,11 @@ pushdecl_top_level_and_finish (tree x, tree init)\n \n /* Make the declaration of X appear in CLASS scope.  */\n \n-void\n+bool\n pushdecl_class_level (tree x)\n {\n   tree name;\n+  bool is_valid = true;\n \n   timevar_push (TV_NAME_LOOKUP);\n   /* Get the name of X.  */\n@@ -4193,7 +4201,7 @@ pushdecl_class_level (tree x)\n \n   if (name)\n     {\n-      push_class_level_binding (name, x);\n+      is_valid = push_class_level_binding (name, x);\n       if (TREE_CODE (x) == TYPE_DECL)\n \tset_identifier_type_value (name, TREE_TYPE (x));\n     }\n@@ -4205,9 +4213,16 @@ pushdecl_class_level (tree x)\n       tree f;\n \n       for (f = TYPE_FIELDS (TREE_TYPE (x)); f; f = TREE_CHAIN (f))\n-\tpushdecl_class_level (f);\n+\t{\n+\t  push_srcloc (DECL_SOURCE_FILE (f), DECL_SOURCE_LINE (f));\n+\t  if (!pushdecl_class_level (f))\n+\t    is_valid = false;\n+\t  pop_srcloc ();\n+\t}\n     }\n   timevar_pop (TV_NAME_LOOKUP);\n+\n+  return is_valid;\n }\n \n /* Enter DECL into the symbol table, if that's appropriate.  Returns\n@@ -4239,21 +4254,19 @@ maybe_push_decl (tree decl)\n     return pushdecl (decl);\n }\n \n-/* Make the declaration(s) of X appear in CLASS scope\n-   under the name NAME.  */\n+/* Make the declaration(s) of X appear in CLASS scope under the name\n+   NAME.  Returns true if the binding is valid.  */\n \n-void\n+bool\n push_class_level_binding (tree name, tree x)\n {\n   cxx_binding *binding;\n+\n   timevar_push (TV_NAME_LOOKUP);\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n   /* Make sure that this new member does not have the same name\n      as a template parameter.  */\n@@ -4303,8 +4316,7 @@ push_class_level_binding (tree name, tree x)\n \t    INHERITED_VALUE_BINDING_P (binding) = 0;\n \t    TREE_TYPE (shadow) = x;\n \t    IDENTIFIER_CLASS_VALUE (name) = x;\n-\t    timevar_pop (TV_NAME_LOOKUP);\n-\t    return;\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \t  }\n     }\n \n@@ -4318,8 +4330,10 @@ push_class_level_binding (tree name, tree x)\n       /* Record the value we are binding NAME to so that we can know\n \t what to pop later.  */\n       TREE_TYPE (class_binding_level->class_shadowed) = x;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n     }\n-  timevar_pop (TV_NAME_LOOKUP);\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n }\n \n /* Insert another USING_DECL into the current binding level, returning"}, {"sha": "a95c9575e6bc10347291bc6fb707a095d07c5585", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -1862,8 +1862,6 @@ finish_member_declaration (tree decl)\n   if (DECL_LANG_SPECIFIC (decl) && DECL_LANGUAGE (decl) == lang_c)\n     SET_DECL_LANGUAGE (decl, lang_cplusplus);\n \n-  maybe_add_class_template_decl_list (current_class_type, decl, /*friend_p=*/0);\n-\n   /* Put functions on the TYPE_METHODS list and everything else on the\n      TYPE_FIELDS list.  Note that these are built up in reverse order.\n      We reverse them (to obtain declaration order) in finish_struct.  */\n@@ -1876,8 +1874,12 @@ finish_member_declaration (tree decl)\n \n       TREE_CHAIN (decl) = TYPE_METHODS (current_class_type);\n       TYPE_METHODS (current_class_type) = decl;\n+\n+      maybe_add_class_template_decl_list (current_class_type, decl, \n+\t\t\t\t\t  /*friend_p=*/0);\n     }\n-  else\n+  /* Enter the DECL into the scope of the class.  */\n+  else if (TREE_CODE (decl) == USING_DECL || pushdecl_class_level (decl))\n     {\n       /* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields\n \t go at the beginning.  The reason is that lookup_field_1\n@@ -1905,9 +1907,8 @@ finish_member_declaration (tree decl)\n \t  TYPE_FIELDS (current_class_type) = decl;\n \t}\n \n-      /* Enter the DECL into the scope of the class.  */\n-      if (TREE_CODE (decl) != USING_DECL)\n-\tpushdecl_class_level (decl);\n+      maybe_add_class_template_decl_list (current_class_type, decl, \n+\t\t\t\t\t  /*friend_p=*/0);\n     }\n }\n "}, {"sha": "2b4942c81022db129acb71a269372d844daa67d7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -1,5 +1,9 @@\n 2003-06-19  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/9649\n+\t* g++.dg/template/static4.C: New test.\n+\t* g++.old-deja/g++.other/anon7.C: Remove spurious error messages.\n+\n \tPR c++/11041\n \t* g++.dg/init/ref7.C: New test.\n "}, {"sha": "c5486326cddcc8672789454130ad478fade85a8c", "filename": "gcc/testsuite/g++.dg/template/static4.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic4.C?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -0,0 +1,7 @@\n+template <class R>\n+struct A {\n+  static int _test; // { dg-error \"\" }\n+  static int _test; // { dg-error \"\" }\n+};\n+template <class R> int A<R>::_test = 0;\n+struct B : public A <int> { };"}, {"sha": "ebc378005cd7686f23691aefc612ffe8204b5aef", "filename": "gcc/testsuite/g++.old-deja/g++.other/anon7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f139561cce27d9b662b0a3b22d3dd6aa56ae1854/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon7.C?ref=f139561cce27d9b662b0a3b22d3dd6aa56ae1854", "patch": "@@ -11,7 +11,7 @@ struct B {\n   int b;\t// { dg-error \"\" } conflicts with previous declaration\n   union {\n     int b;\t// { dg-error \"\" } duplicate member\n-  };\t\t// { dg-error \"\" } declaration of\n+  };\n };\n \n struct C {\n@@ -20,5 +20,5 @@ struct C {\n   };\n   union {\n     int c;\t// { dg-error \"\" } duplicate member\n-  };\t\t// { dg-error \"\" } declaration of\n+  };\n };"}]}