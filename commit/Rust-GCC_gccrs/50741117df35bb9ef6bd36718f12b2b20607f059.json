{"sha": "50741117df35bb9ef6bd36718f12b2b20607f059", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3NDExMTdkZjM1YmI5ZWY2YmQzNjcxOGYxMmIyYjIwNjA3ZjA1OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-03-07T20:08:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-03-07T20:08:17Z"}, "message": "gigi.h (rest_of_type_decl_compilation): Delete.\n\n\t* gcc-interface/gigi.h (rest_of_type_decl_compilation): Delete.\n\t* gcc-interface/decl.c (defer_finalize_level): Likewise.\n\t(defer_finalize_list): Likewise.\n\t(gnat_to_gnu_entity): Delete references to above variables and do not\n\tcall rest_of_type_decl_compilation.\n\t(rest_of_type_decl_compilation): Delete.\n\t(rest_of_type_decl_compilation_no_defer): Likewise.\n\t* gcc-interface/utils.c (rest_of_record_type_compilation): Do not call\n\trest_of_type_decl_compilation.\n\t(create_type_decl): Likewise.\n\t(update_pointer_to): Likewise.\n\nFrom-SVN: r185075", "tree": {"sha": "d84360677e0df6b7e80712f191011a473669a819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d84360677e0df6b7e80712f191011a473669a819"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50741117df35bb9ef6bd36718f12b2b20607f059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50741117df35bb9ef6bd36718f12b2b20607f059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50741117df35bb9ef6bd36718f12b2b20607f059", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50741117df35bb9ef6bd36718f12b2b20607f059/comments", "author": null, "committer": null, "parents": [{"sha": "ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6c2c5316fe5bebf9bd5b59bc6ea88a01aaad39"}], "stats": {"total": 118, "additions": 16, "deletions": 102}, "files": [{"sha": "636d6cc4e340502ef50bf94a7f17dce271a18523", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=50741117df35bb9ef6bd36718f12b2b20607f059", "patch": "@@ -1,3 +1,17 @@\n+2012-03-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (rest_of_type_decl_compilation): Delete.\n+\t* gcc-interface/decl.c (defer_finalize_level): Likewise.\n+\t(defer_finalize_list): Likewise.\n+\t(gnat_to_gnu_entity): Delete references to above variables and do not\n+\tcall rest_of_type_decl_compilation.\n+\t(rest_of_type_decl_compilation): Delete.\n+\t(rest_of_type_decl_compilation_no_defer): Likewise.\n+\t* gcc-interface/utils.c (rest_of_record_type_compilation): Do not call\n+\trest_of_type_decl_compilation.\n+\t(create_type_decl): Likewise.\n+\t(update_pointer_to): Likewise.\n+\n 2012-03-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Identifier_to_gnu): Don't unshare initializer."}, {"sha": "017278911a33a097542ef8505533745dcacfbdd9", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=50741117df35bb9ef6bd36718f12b2b20607f059", "patch": "@@ -97,11 +97,6 @@ static struct incomplete *defer_incomplete_list;\n    end of the spec.  */\n static struct incomplete *defer_limited_with;\n \n-/* These variables are used to defer finalizing types.  The element of the\n-   list is the TYPE_DECL associated with the type.  */\n-static int defer_finalize_level = 0;\n-static VEC (tree,heap) *defer_finalize_list;\n-\n typedef struct subst_pair_d {\n   tree discriminant;\n   tree replacement;\n@@ -181,7 +176,6 @@ static tree get_rep_part (tree);\n static tree create_variant_part_from (tree, VEC(variant_desc,heap) *, tree,\n \t\t\t\t      tree, VEC(subst_pair,heap) *);\n static void copy_and_substitute_in_size (tree, tree, VEC(subst_pair,heap) *);\n-static void rest_of_type_decl_compilation_no_defer (tree);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n    to pass around calls performing profile compatibility checks.  */\n@@ -3880,10 +3874,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       care of those situations.  */\n \t    if (defer_incomplete_level == 0 && !is_from_limited_with)\n \t      {\n-\t\tdefer_finalize_level++;\n \t\tupdate_pointer_to (TYPE_MAIN_VARIANT (gnu_old_desig_type),\n \t\t\t\t   gnat_to_gnu_type (gnat_desig_equiv));\n-\t\tdefer_finalize_level--;\n \t      }\n \t    else\n \t      {\n@@ -5112,11 +5104,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Enumeration types have specific RM bounds.  */\n \t  SET_TYPE_RM_MIN_VALUE (gnu_scalar_type, gnu_low_bound);\n \t  SET_TYPE_RM_MAX_VALUE (gnu_scalar_type, gnu_high_bound);\n-\n-\t  /* Write full debugging information.  */\n-\t  rest_of_type_decl_compilation (gnu_decl);\n \t}\n-\n       else\n \t{\n \t  /* Floating-point types don't have specific RM bounds.  */\n@@ -5139,11 +5127,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       p = defer_incomplete_list;\n       defer_incomplete_list = NULL;\n \n-      /* For finalization, however, all types must be complete so we\n-\t cannot do the same because deferred incomplete types may end up\n-\t referencing each other.  Process them all recursively first.  */\n-      defer_finalize_level++;\n-\n       for (; p; p = next)\n \t{\n \t  next = p->next;\n@@ -5153,23 +5136,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       gnat_to_gnu_type (p->full_type));\n \t  free (p);\n \t}\n-\n-      defer_finalize_level--;\n-    }\n-\n-  /* If all the deferred incomplete types have been processed, we can proceed\n-     with the finalization of the deferred types.  */\n-  if (defer_incomplete_level == 0\n-      && defer_finalize_level == 0\n-      && defer_finalize_list)\n-    {\n-      unsigned int i;\n-      tree t;\n-\n-      FOR_EACH_VEC_ELT (tree, defer_finalize_list, i, t)\n-\trest_of_type_decl_compilation_no_defer (t);\n-\n-      VEC_free (tree, heap, defer_finalize_list);\n     }\n \n   /* If we are not defining this type, see if it's on one of the lists of\n@@ -5290,45 +5256,6 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n     create_subprog_decl (gnu_entity_name, gnu_ext_name, void_ftype, NULL_TREE,\n \t\t\t false, true, true, true, attr_list, gnat_entity);\n }\n-\f\n-/* Wrap up compilation of DECL, a TYPE_DECL, possibly deferring it.\n-   Every TYPE_DECL generated for a type definition must be passed\n-   to this function once everything else has been done for it.  */\n-\n-void\n-rest_of_type_decl_compilation (tree decl)\n-{\n-  /* We need to defer finalizing the type if incomplete types\n-     are being deferred or if they are being processed.  */\n-  if (defer_incomplete_level != 0 || defer_finalize_level != 0)\n-    VEC_safe_push (tree, heap, defer_finalize_list, decl);\n-  else\n-    rest_of_type_decl_compilation_no_defer (decl);\n-}\n-\n-/* Same as above but without deferring the compilation.  This\n-   function should not be invoked directly on a TYPE_DECL.  */\n-\n-static void\n-rest_of_type_decl_compilation_no_defer (tree decl)\n-{\n-  const int toplev = global_bindings_p ();\n-  tree t = TREE_TYPE (decl);\n-\n-  rest_of_decl_compilation (decl, toplev, 0);\n-\n-  /* Now process all the variants.  This is needed for STABS.  */\n-  for (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n-    {\n-      if (t == TREE_TYPE (decl))\n-\tcontinue;\n-\n-      if (!TYPE_STUB_DECL (t))\n-\tTYPE_STUB_DECL (t) = create_type_stub_decl (DECL_NAME (decl), t);\n-\n-      rest_of_type_compilation (t, toplev);\n-    }\n-}\n \n /* Finalize the processing of From_With_Type incomplete types.  */\n "}, {"sha": "5e6495ad27cff50bab2ccdcbe5f08342d1270edd", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=50741117df35bb9ef6bd36718f12b2b20607f059", "patch": "@@ -51,9 +51,6 @@ extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n    the GCC type corresponding to that entity.  */\n extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n \n-/* Wrap up compilation of T, a TYPE_DECL, possibly deferring it.  */\n-extern void rest_of_type_decl_compilation (tree t);\n-\n /* Start a new statement group chained to the previous group.  */\n extern void start_stmt_group (void);\n "}, {"sha": "a2191c0a9fbd526e9887299bbe62c04c54dc9468", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50741117df35bb9ef6bd36718f12b2b20607f059/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=50741117df35bb9ef6bd36718f12b2b20607f059", "patch": "@@ -1056,15 +1056,8 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_FIELDS (new_record_type)\n \t= nreverse (TYPE_FIELDS (new_record_type));\n \n-      /* We used to explicitly invoke rest_of_type_decl_compilation on the\n-\t parallel type for the sake of STABS.  We don't do it any more, so\n-\t as to ensure that the parallel type be processed after the type\n-\t by the debug back-end and, thus, prevent it from interfering with\n-\t the processing of a recursive type.  */\n       add_parallel_type (TYPE_STUB_DECL (record_type), new_record_type);\n     }\n-\n-  rest_of_type_decl_compilation (TYPE_STUB_DECL (record_type));\n }\n \n /* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n@@ -1354,21 +1347,10 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n   if (!named)\n     TYPE_STUB_DECL (type) = type_decl;\n \n-  /* Pass the type declaration to the debug back-end unless this is an\n-     UNCONSTRAINED_ARRAY_TYPE that the back-end does not support, or a\n-     type for which debugging information was not requested, or else an\n-     ENUMERAL_TYPE or RECORD_TYPE (except for fat pointers) which are\n-     handled separately.  And do not pass dummy types either.  */\n+  /* Do not generate debug info for UNCONSTRAINED_ARRAY_TYPE that the\n+     back-end doesn't support, and for others if we don't need to.  */\n   if (code == UNCONSTRAINED_ARRAY_TYPE || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n-  else if (code != ENUMERAL_TYPE\n-\t   && (code != RECORD_TYPE || TYPE_FAT_POINTER_P (type))\n-\t   && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n-\t\t&& TYPE_IS_DUMMY_P (TREE_TYPE (type)))\n-\t   && !(code == RECORD_TYPE\n-\t\t&& TYPE_IS_DUMMY_P\n-\t\t   (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (type))))))\n-    rest_of_type_decl_compilation (type_decl);\n \n   return type_decl;\n }\n@@ -3531,12 +3513,6 @@ update_pointer_to (tree old_type, tree new_type)\n \t      TREE_TYPE (TREE_OPERAND (TYPE_NULL_BOUNDS (t), 0)) = new_type;\n \t  }\n \n-      /* If we have adjusted named types, finalize them.  This is necessary\n-\t since we had forced a DWARF typedef for them in gnat_pushdecl.  */\n-      for (ptr = TYPE_POINTER_TO (old_type); ptr; ptr = TYPE_NEXT_PTR_TO (ptr))\n-\tif (TYPE_NAME (ptr) && TREE_CODE (TYPE_NAME (ptr)) == TYPE_DECL)\n-\t  rest_of_type_decl_compilation (TYPE_NAME (ptr));\n-\n       /* Chain REF and its variants at the end.  */\n       new_ref = TYPE_REFERENCE_TO (new_type);\n       if (new_ref)"}]}