{"sha": "0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQxYjRlZGM1ZmZmODM0ZThmOTI0YjIwZGQwMjFkZWQ3YTIxZDJkMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-24T13:33:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-31T20:07:46Z"}, "message": "analyzer: fix ICE on RANGE_EXPR in CONSTRUCTORs [PR96763]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/96763\n\t* store.cc (binding_map::apply_ctor_to_region): Handle RANGE_EXPR\n\tby calling a new binding_map::apply_ctor_val_to_range subroutine.\n\tSplit out the existing non-CONSTRUCTOR-handling code to a new\n\tapply_ctor_pair_to_child_region subroutine.\n\t(binding_map::apply_ctor_val_to_range): New.\n\t(binding_map::apply_ctor_pair_to_child_region): New, split out\n\tfrom binding_map::apply_ctor_to_region as noted above.\n\t* store.h (binding_map::apply_ctor_val_to_range): New decl.\n\t(binding_map::apply_ctor_pair_to_child_region): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/96763\n\t* g++.dg/analyzer/pr96763.C: New test.", "tree": {"sha": "65926af7487d5485acfedf8ed468b9b52073f5fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65926af7487d5485acfedf8ed468b9b52073f5fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdb93224c56189a129e97c556fe6b78e1b15a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecdb93224c56189a129e97c556fe6b78e1b15a63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecdb93224c56189a129e97c556fe6b78e1b15a63"}], "stats": {"total": 150, "additions": 115, "deletions": 35}, "files": [{"sha": "8890a69a6f80b93fb97e006fcc5ee75faa3d20fb", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 94, "deletions": 35, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "patch": "@@ -419,43 +419,102 @@ binding_map::apply_ctor_to_region (const region *parent_reg, tree ctor,\n     {\n       if (!index)\n \tindex = build_int_cst (integer_type_node, ix);\n-      const region *child_reg\n-\t= get_subregion_within_ctor (parent_reg, index, mgr);\n-      if (TREE_CODE (val) == CONSTRUCTOR)\n-\tapply_ctor_to_region (child_reg, val, mgr);\n-      else\n+      else if (TREE_CODE (index) == RANGE_EXPR)\n \t{\n-\t  const svalue *sval = get_svalue_for_ctor_val (val, mgr);\n-\t  const binding_key *k\n-\t    = binding_key::make (mgr->get_store_manager (), child_reg,\n-\t\t\t\t BK_direct);\n-\t  /* Handle the case where we have an unknown size for child_reg\n-\t     (e.g. due to it being a trailing field with incomplete array\n-\t     type.  */\n-\t  if (!k->concrete_p ())\n-\t    {\n-\t      /* Assume that sval has a well-defined size for this case.  */\n-\t      tree sval_type = sval->get_type ();\n-\t      gcc_assert (sval_type);\n-\t      HOST_WIDE_INT sval_byte_size = int_size_in_bytes (sval_type);\n-\t      gcc_assert (sval_byte_size != -1);\n-\t      bit_size_t sval_bit_size = sval_byte_size * BITS_PER_UNIT;\n-\t      /* Get offset of child relative to base region.  */\n-\t      region_offset child_base_offset = child_reg->get_offset ();\n-\t      gcc_assert (!child_base_offset.symbolic_p ());\n-\t      /* Convert to an offset relative to the parent region.  */\n-\t      region_offset parent_base_offset = parent_reg->get_offset ();\n-\t      gcc_assert (!parent_base_offset.symbolic_p ());\n-\t      bit_offset_t child_parent_offset\n-\t\t= (child_base_offset.get_bit_offset ()\n-\t\t   - parent_base_offset.get_bit_offset ());\n-\t      /* Create a concrete key for the child within the parent.  */\n-\t      k = mgr->get_store_manager ()->get_concrete_binding\n-\t\t(child_parent_offset, sval_bit_size, BK_direct);\n-\t    }\n-\t  gcc_assert (k->concrete_p ());\n-\t  put (k, sval);\n+\t  tree min_index = TREE_OPERAND (index, 0);\n+\t  tree max_index = TREE_OPERAND (index, 1);\n+\t  apply_ctor_val_to_range (parent_reg, mgr, min_index, max_index, val);\n+\t  continue;\n+\t}\n+      apply_ctor_pair_to_child_region (parent_reg, mgr, index, val);\n+    }\n+}\n+\n+/* Bind the value VAL into the range of elements within PARENT_REF\n+   from MIN_INDEX to MAX_INDEX (including endpoints).\n+   For use in handling RANGE_EXPR within a CONSTRUCTOR.  */\n+\n+void\n+binding_map::apply_ctor_val_to_range (const region *parent_reg,\n+\t\t\t\t      region_model_manager *mgr,\n+\t\t\t\t      tree min_index, tree max_index,\n+\t\t\t\t      tree val)\n+{\n+  gcc_assert (TREE_CODE (min_index) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (max_index) == INTEGER_CST);\n+\n+  /* Generate a binding key for the range.  */\n+  const region *min_element\n+    = get_subregion_within_ctor (parent_reg, min_index, mgr);\n+  const region *max_element\n+    = get_subregion_within_ctor (parent_reg, max_index, mgr);\n+  region_offset min_offset = min_element->get_offset ();\n+  bit_offset_t start_bit_offset = min_offset.get_bit_offset ();\n+  store_manager *smgr = mgr->get_store_manager ();\n+  const binding_key *max_element_key\n+    = binding_key::make (smgr, max_element, BK_direct);\n+  gcc_assert (max_element_key->concrete_p ());\n+  const concrete_binding *max_element_ckey\n+    = max_element_key->dyn_cast_concrete_binding ();\n+  bit_size_t range_size_in_bits\n+    = max_element_ckey->get_next_bit_offset () - start_bit_offset;\n+  const concrete_binding *range_key\n+    = smgr->get_concrete_binding (start_bit_offset, range_size_in_bits,\n+\t\t\t\t  BK_direct);\n+  gcc_assert (range_key->concrete_p ());\n+\n+  /* Get the value.  */\n+  gcc_assert (TREE_CODE (val) != CONSTRUCTOR);\n+  const svalue *sval = get_svalue_for_ctor_val (val, mgr);\n+\n+  /* Bind the value to the range.  */\n+  put (range_key, sval);\n+}\n+\n+/* Bind the value VAL into INDEX within PARENT_REF.\n+   For use in handling a pair of entries within a CONSTRUCTOR.  */\n+\n+void\n+binding_map::apply_ctor_pair_to_child_region (const region *parent_reg,\n+\t\t\t\t\t      region_model_manager *mgr,\n+\t\t\t\t\t      tree index, tree val)\n+{\n+  const region *child_reg\n+    = get_subregion_within_ctor (parent_reg, index, mgr);\n+  if (TREE_CODE (val) == CONSTRUCTOR)\n+    apply_ctor_to_region (child_reg, val, mgr);\n+  else\n+    {\n+      const svalue *sval = get_svalue_for_ctor_val (val, mgr);\n+      const binding_key *k\n+\t= binding_key::make (mgr->get_store_manager (), child_reg,\n+\t\t\t     BK_direct);\n+      /* Handle the case where we have an unknown size for child_reg\n+\t (e.g. due to it being a trailing field with incomplete array\n+\t type.  */\n+      if (!k->concrete_p ())\n+\t{\n+\t  /* Assume that sval has a well-defined size for this case.  */\n+\t  tree sval_type = sval->get_type ();\n+\t  gcc_assert (sval_type);\n+\t  HOST_WIDE_INT sval_byte_size = int_size_in_bytes (sval_type);\n+\t  gcc_assert (sval_byte_size != -1);\n+\t  bit_size_t sval_bit_size = sval_byte_size * BITS_PER_UNIT;\n+\t  /* Get offset of child relative to base region.  */\n+\t  region_offset child_base_offset = child_reg->get_offset ();\n+\t  gcc_assert (!child_base_offset.symbolic_p ());\n+\t  /* Convert to an offset relative to the parent region.  */\n+\t  region_offset parent_base_offset = parent_reg->get_offset ();\n+\t  gcc_assert (!parent_base_offset.symbolic_p ());\n+\t  bit_offset_t child_parent_offset\n+\t    = (child_base_offset.get_bit_offset ()\n+\t       - parent_base_offset.get_bit_offset ());\n+\t  /* Create a concrete key for the child within the parent.  */\n+\t  k = mgr->get_store_manager ()->get_concrete_binding\n+\t    (child_parent_offset, sval_bit_size, BK_direct);\n \t}\n+      gcc_assert (k->concrete_p ());\n+      put (k, sval);\n     }\n }\n "}, {"sha": "0ac93179dc6fa4686e13dc3592889c8091835da9", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "patch": "@@ -344,6 +344,14 @@ class binding_map\n \t\t\t     region_model_manager *mgr);\n \n private:\n+  void apply_ctor_val_to_range (const region *parent_reg,\n+\t\t\t\tregion_model_manager *mgr,\n+\t\t\t\ttree min_index, tree max_index,\n+\t\t\t\ttree val);\n+  void apply_ctor_pair_to_child_region (const region *parent_reg,\n+\t\t\t\t\tregion_model_manager *mgr,\n+\t\t\t\t\ttree index, tree val);\n+\n   map_t m_map;\n };\n "}, {"sha": "1b29e30a8f818134ae6ea71c48069a7cfd0c1499", "filename": "gcc/testsuite/g++.dg/analyzer/pr96763.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr96763.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d1b4edc5fff834e8f924b20dd021ded7a21d2d2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr96763.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr96763.C?ref=0d1b4edc5fff834e8f924b20dd021ded7a21d2d2", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct c0;\n+\n+struct md {\n+  int c0::*jj[2];\n+};\n+\n+void\n+n0 ()\n+{\n+  md{};\n+}"}]}