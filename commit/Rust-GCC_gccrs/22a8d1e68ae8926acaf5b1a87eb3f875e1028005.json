{"sha": "22a8d1e68ae8926acaf5b1a87eb3f875e1028005", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhOGQxZTY4YWU4OTI2YWNhZjViMWE4N2ViM2Y4NzVlMTAyODAwNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-03T02:04:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-03T02:04:20Z"}, "message": "ipa-reference.c (ipa_reference_local_vars_info_d): Remove calls_read_all and calls_write_all.\n\n\t* ipa-reference.c (ipa_reference_local_vars_info_d): Remove\n\tcalls_read_all and calls_write_all.\n\t(get_reference_optimization_summary): Fix formatting.\n\t(is_proper_for_analysis): Check that decl is not readonly.\n\t(propagate_bits): Check CONST/PURE/noreturn flags.\n\t(ipa_init): Move all_module_statics to optimization_summary_obstack.\n\t(analyze_function): Ignore indirect edges.\n\t(copy_global_bitmap): For all module statics, do nothing.\n\t(generate_summary): Do not print calls_read_all/calls_write_all.\n\t(read_write_all_from_decl): Take node as argument; check\n\tcgraph_node_cannot_return.\n\t(propagate): Reorganize read_all/write_all computation;\n\tcheck indirect edges; check ecf flags; use all_module_statics\n\tin the results; do not free all_module_statics.\n\t(stream_out_bitmap): Handle all_module_statics.\n\t(ipa_reference_write_optimization_summary): Likewise; use\n\tvarpool/cgraph encoders to get boundaries.\n\t(ipa_reference_read_optimization_summary): Read in all_module_statics;\n\tuse it when possible.\n\nFrom-SVN: r160204", "tree": {"sha": "81892a998164b354d20e66f69a7900cd6791aefd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81892a998164b354d20e66f69a7900cd6791aefd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22a8d1e68ae8926acaf5b1a87eb3f875e1028005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a8d1e68ae8926acaf5b1a87eb3f875e1028005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a8d1e68ae8926acaf5b1a87eb3f875e1028005", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a8d1e68ae8926acaf5b1a87eb3f875e1028005/comments", "author": null, "committer": null, "parents": [{"sha": "2aaef41ac647fc9ad756aba1d78cc9cf28ffcb99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aaef41ac647fc9ad756aba1d78cc9cf28ffcb99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aaef41ac647fc9ad756aba1d78cc9cf28ffcb99"}], "stats": {"total": 350, "additions": 221, "deletions": 129}, "files": [{"sha": "f94504366f28ee36957f54d219edd4e707116c33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a8d1e68ae8926acaf5b1a87eb3f875e1028005/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a8d1e68ae8926acaf5b1a87eb3f875e1028005/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22a8d1e68ae8926acaf5b1a87eb3f875e1028005", "patch": "@@ -1,3 +1,25 @@\n+2010-06-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-reference.c (ipa_reference_local_vars_info_d): Remove\n+\tcalls_read_all and calls_write_all.\n+\t(get_reference_optimization_summary): Fix formatting.\n+\t(is_proper_for_analysis): Check that decl is not readonly.\n+\t(propagate_bits): Check CONST/PURE/noreturn flags.\n+\t(ipa_init): Move all_module_statics to optimization_summary_obstack.\n+\t(analyze_function): Ignore indirect edges.\n+\t(copy_global_bitmap): For all module statics, do nothing.\n+\t(generate_summary): Do not print calls_read_all/calls_write_all.\n+\t(read_write_all_from_decl): Take node as argument; check\n+\tcgraph_node_cannot_return.\n+\t(propagate): Reorganize read_all/write_all computation;\n+\tcheck indirect edges; check ecf flags; use all_module_statics\n+\tin the results; do not free all_module_statics.\n+\t(stream_out_bitmap): Handle all_module_statics.\n+\t(ipa_reference_write_optimization_summary): Likewise; use\n+\tvarpool/cgraph encoders to get boundaries.\n+\t(ipa_reference_read_optimization_summary): Read in all_module_statics;\n+\tuse it when possible.\n+\n 2010-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/44218"}, {"sha": "8ca06791c230b387d7532c2416cac74d97d6f76d", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 199, "deletions": 129, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a8d1e68ae8926acaf5b1a87eb3f875e1028005/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a8d1e68ae8926acaf5b1a87eb3f875e1028005/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=22a8d1e68ae8926acaf5b1a87eb3f875e1028005", "patch": "@@ -74,14 +74,6 @@ struct ipa_reference_local_vars_info_d\n {\n   bitmap statics_read;\n   bitmap statics_written;\n-\n-  /* Set when this function calls another function external to the\n-     compilation unit or if the function has a asm clobber of memory.\n-     In general, such calls are modeled as reading and writing all\n-     variables (both bits on) but sometime there are attributes on the\n-     called function so we can do better.  */\n-  bool calls_read_all;\n-  bool calls_write_all;\n };\n \n /* Statics that are read and written by some set of functions. The\n@@ -160,7 +152,7 @@ get_reference_optimization_summary (struct cgraph_node *node)\n {\n   if (!ipa_reference_opt_sum_vector\n       || (VEC_length (ipa_reference_optimization_summary_t,\n-\t\t     ipa_reference_opt_sum_vector)\n+\t\t      ipa_reference_opt_sum_vector)\n \t  <= (unsigned int) node->uid))\n     return NULL;\n   return VEC_index (ipa_reference_optimization_summary_t, ipa_reference_opt_sum_vector,\n@@ -254,6 +246,7 @@ is_proper_for_analysis (tree t)\n   /* We handle only variables whose address is never taken.  */\n   if (TREE_ADDRESSABLE (t))\n     return false;\n+\n   /* If the variable has the \"used\" attribute, treat it as if it had a\n      been touched by the devil.  */\n   if (DECL_PRESERVE_P (t))\n@@ -264,6 +257,11 @@ is_proper_for_analysis (tree t)\n   if (TREE_THIS_VOLATILE (t))\n     return false;\n \n+  /* We do not need to analyze readonly vars, we already know they do not\n+     alias.  */\n+  if (TREE_READONLY (t))\n+    return false;\n+\n   /* We cannot touch decls where the type needs constructing.  */\n   if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (t)))\n     return false;\n@@ -305,6 +303,7 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n       /* Only look into nodes we can propagate something.  */\n       if (cgraph_function_body_availability (e->callee) > AVAIL_OVERWRITABLE)\n \t{\n+\t  int flags = flags_from_decl_or_type (e->callee->decl);\n \t  if (get_reference_vars_info (y))\n \t    {\n \t      ipa_reference_vars_info_t y_info\n@@ -315,6 +314,11 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n \t      if (!y_global->statics_read)\n \t\tcontinue;\n \n+\t      /* If function is declared const, it reads no memory even if it\n+\t\t seems so to local analysis.  */\n+\t      if (flags & ECF_CONST)\n+\t\tcontinue;\n+\n \t      if (x_global->statics_read\n \t\t  != all_module_statics)\n \t\t{\n@@ -333,6 +337,13 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n \t\t\t\t     y_global->statics_read);\n \t\t}\n \n+\t      /* If function is declared pure, it has no stores even if it\n+\t\t seems so to local analysis; If we can not return from here,\n+\t\t we can safely ignore the call.  */\n+\t      if ((flags & ECF_PURE)\n+\t\t  || cgraph_edge_cannot_lead_to_return (e))\n+\t\tcontinue;\n+\n \t      if (x_global->statics_written\n \t\t  != all_module_statics)\n \t\t{\n@@ -374,7 +385,7 @@ ipa_init (void)\n \n   bitmap_obstack_initialize (&local_info_obstack);\n   bitmap_obstack_initialize (&optimization_summary_obstack);\n-  all_module_statics = BITMAP_ALLOC (&local_info_obstack);\n+  all_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n \n   node_removal_hook_holder =\n       cgraph_add_node_removal_hook (&remove_node_data, NULL);\n@@ -411,20 +422,8 @@ analyze_function (struct cgraph_node *fn)\n   struct ipa_ref *ref;\n   int i;\n   tree var;\n-  struct cgraph_edge *ie;\n \n   local = init_function_info (fn);\n-  /* Process indirect calls.  All direct calles are handled at propagation\n-     time.  */\n-  for (ie = fn->indirect_calls; ie; ie = ie->next_callee)\n-    if (!(ie->indirect_info->ecf_flags & ECF_CONST))\n-      {\n-        local->calls_read_all = true;\n-        if (!(ie->indirect_info->ecf_flags & ECF_PURE)\n-\t    && ((ie->indirect_info->ecf_flags & (ECF_NOTHROW | ECF_NORETURN))\n-\t\t!=  (ECF_NOTHROW | ECF_NORETURN)))\n-\t  local->calls_write_all = true;\n-      }\n   for (i = 0; ipa_ref_list_reference_iterate (&fn->ref_list, i, ref); i++)\n     {\n       if (ref->refered_type != IPA_REF_VARPOOL)\n@@ -443,22 +442,13 @@ analyze_function (struct cgraph_node *fn)\n           bitmap_set_bit (local->statics_written, DECL_UID (var));\n \t  break;\n \tcase IPA_REF_ADDR:\n+\t  gcc_unreachable ();\n \t  break;\n \t}\n     }\n \n-  if ((flags_from_decl_or_type (fn->decl) & (ECF_NOTHROW | ECF_NORETURN))\n-      == (ECF_NOTHROW | ECF_NORETURN))\n-    {\n-      local->calls_write_all = false;\n-      bitmap_clear (local->statics_written);\n-    }\n-\n-  /* Free bitmaps of direct references if we can not use them anyway.  */\n-  if (local->calls_write_all)\n-    BITMAP_FREE (local->statics_written);\n-  if (local->calls_read_all)\n-    BITMAP_FREE (local->statics_read);\n+  if (cgraph_node_cannot_return (fn))\n+    bitmap_clear (local->statics_written);\n }\n \n static bitmap\n@@ -467,6 +457,8 @@ copy_global_bitmap (bitmap src)\n   bitmap dst;\n   if (!src)\n     return NULL;\n+  if (src == all_module_statics)\n+    return all_module_statics;\n   dst = BITMAP_ALLOC (&optimization_summary_obstack);\n   bitmap_copy (dst, src);\n   return dst;\n@@ -568,33 +560,28 @@ generate_summary (void)\n \t        fprintf(dump_file, \"%s \",\n \t\t        get_static_name (index));\n \t      }\n-\t  if (l->calls_read_all)\n-\t     fprintf (dump_file, \"\\n  calls read all: \");\n-\t  if (l->calls_write_all)\n-\t     fprintf (dump_file, \"\\n  calls read all: \");\n \t}\n }\n \f\n-/* Set READ_ALL/WRITE_ALL based on DECL flags.  */\n+/* Set READ_ALL/WRITE_ALL based on decl flags of NODE.  */\n \n static void\n-read_write_all_from_decl (tree decl, bool * read_all, bool * write_all)\n+read_write_all_from_decl (struct cgraph_node *node, bool * read_all,\n+\t\t\t  bool * write_all)\n {\n+  tree decl = node->decl;\n   int flags = flags_from_decl_or_type (decl);\n   if (flags & ECF_CONST)\n     ;\n-  else if (flags & ECF_PURE)\n+  else if ((flags & ECF_PURE)\n+\t   || cgraph_node_cannot_return (node))\n     *read_all = true;\n   else\n     {\n        /* TODO: To be able to produce sane results, we should also handle\n \t  common builtins, in particular throw.  */\n       *read_all = true;\n-      /* When function does not return, it is safe to ignore anythign it writes\n-\t to, because the effect will never happen.  */\n-      if ((flags & (ECF_NOTHROW | ECF_NORETURN))\n-\t  != (ECF_NOTHROW | ECF_NORETURN))\n-        *write_all = true;\n+      *write_all = true;\n     }\n }\n \n@@ -630,55 +617,62 @@ propagate (void)\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g;\n       ipa_reference_local_vars_info_t node_l;\n-      struct cgraph_edge *e;\n+      struct cgraph_edge *e, *ie;\n \n       bool read_all;\n       bool write_all;\n       struct ipa_dfs_info * w_info;\n \n       node = order[i];\n       node_info = get_reference_vars_info (node);\n-      if (!node_info)\n-\t{\n-\t  dump_cgraph_node (stderr, node);\n-\t  dump_cgraph (stderr);\n-\t  gcc_unreachable ();\n-\t}\n+      gcc_assert (node_info);\n \n       node_l = &node_info->local;\n       node_g = &node_info->global;\n \n-      read_all = node_l->calls_read_all;\n-      write_all = node_l->calls_write_all;\n+      read_all = false;\n+      write_all = false;\n \n       /* When function is overwrittable, we can not assume anything.  */\n       if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n-        read_write_all_from_decl (node->decl, &read_all, &write_all);\n+        read_write_all_from_decl (node, &read_all, &write_all);\n \n       for (e = node->callees; e; e = e->next_callee)\n         if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n-          read_write_all_from_decl (e->callee->decl, &read_all, &write_all);\n+          read_write_all_from_decl (e->callee, &read_all, &write_all);\n+\n+      for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n+\tif (!(ie->indirect_info->ecf_flags & ECF_CONST))\n+\t  {\n+\t    read_all = true;\n+\t    if (!cgraph_edge_cannot_lead_to_return (ie)\n+\t\t&& !(ie->indirect_info->ecf_flags & ECF_PURE))\n+\t      write_all = true;\n+\t  }\n \n \n-      /* If any node in a cycle is calls_read_all or calls_write_all\n+      /* If any node in a cycle is read_all or write_all\n \t they all are. */\n       w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n-      while (w)\n+      while (w && (!read_all || !write_all))\n \t{\n-\t  ipa_reference_local_vars_info_t w_l =\n-\t    &get_reference_vars_info (w)->local;\n-\n \t  /* When function is overwrittable, we can not assume anything.  */\n \t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n-\t    read_write_all_from_decl (w->decl, &read_all, &write_all);\n+\t    read_write_all_from_decl (w, &read_all, &write_all);\n \n \t  for (e = w->callees; e; e = e->next_callee)\n \t    if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n-\t      read_write_all_from_decl (e->callee->decl, &read_all, &write_all);\n+\t      read_write_all_from_decl (e->callee, &read_all, &write_all);\n \n-\t  read_all |= w_l->calls_read_all;\n-\t  write_all |= w_l->calls_write_all;\n+\t  for (ie = w->indirect_calls; ie; ie = ie->next_callee)\n+\t    if (!(ie->indirect_info->ecf_flags & ECF_CONST))\n+\t      {\n+\t\tread_all = true;\n+\t\tif (!cgraph_edge_cannot_lead_to_return (ie)\n+\t\t    && !(ie->indirect_info->ecf_flags & ECF_PURE))\n+\t\t  write_all = true;\n+\t      }\n \n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n@@ -706,20 +700,23 @@ propagate (void)\n       propagate_bits (node_g, node);\n       w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n-      while (w)\n+      while (w && (!read_all || !write_all))\n \t{\n \t  ipa_reference_vars_info_t w_ri =\n \t    get_reference_vars_info (w);\n \t  ipa_reference_local_vars_info_t w_l = &w_ri->local;\n+\t  int flags = flags_from_decl_or_type (w->decl);\n \n \t  /* These global bitmaps are initialized from the local info\n \t     of all of the nodes in the region.  However there is no\n \t     need to do any work if the bitmaps were set to\n \t     all_module_statics.  */\n-\t  if (!read_all)\n+\t  if (!read_all && !(flags & ECF_CONST))\n \t    bitmap_ior_into (node_g->statics_read,\n \t\t\t     w_l->statics_read);\n-\t  if (!write_all)\n+\t  if (!write_all\n+\t      && !(flags & ECF_PURE)\n+\t      && !cgraph_node_cannot_return (w))\n \t    bitmap_ior_into (node_g->statics_written,\n \t\t\t     w_l->statics_written);\n \t  propagate_bits (node_g, w);\n@@ -850,19 +847,30 @@ propagate (void)\n \t  set_reference_optimization_summary (node, opt);\n \n \t  /* Create the complimentary sets.  */\n-\t  opt->statics_not_read = BITMAP_ALLOC (&optimization_summary_obstack);\n-\t  opt->statics_not_written = BITMAP_ALLOC (&optimization_summary_obstack);\n-\n-\t  if (node_g->statics_read != all_module_statics)\n-\t    bitmap_and_compl (opt->statics_not_read,\n-\t\t\t      all_module_statics,\n-\t\t\t      node_g->statics_read);\n-\n-\t  if (node_g->statics_written\n-\t      != all_module_statics)\n-\t    bitmap_and_compl (opt->statics_not_written,\n-\t\t\t      all_module_statics,\n-\t\t\t      node_g->statics_written);\n+\n+\t  if (bitmap_empty_p (node_g->statics_read))\n+\t    opt->statics_not_read = all_module_statics;\n+\t  else\n+\t    {\n+\t      opt->statics_not_read\n+\t\t = BITMAP_ALLOC (&optimization_summary_obstack);\n+\t      if (node_g->statics_read != all_module_statics)\n+\t\tbitmap_and_compl (opt->statics_not_read,\n+\t\t\t\t  all_module_statics,\n+\t\t\t\t  node_g->statics_read);\n+\t    }\n+\n+\t  if (bitmap_empty_p (node_g->statics_written))\n+\t    opt->statics_not_written = all_module_statics;\n+\t  else\n+\t    {\n+\t      opt->statics_not_written\n+\t        = BITMAP_ALLOC (&optimization_summary_obstack);\n+\t      if (node_g->statics_written != all_module_statics)\n+\t\tbitmap_and_compl (opt->statics_not_written,\n+\t\t\t\t  all_module_statics,\n+\t\t\t\t  node_g->statics_written);\n+\t    }\n \t}\n       if (node_info)\n \tfree (node_info);\n@@ -881,7 +889,6 @@ propagate (void)\n   if (dump_file)\n     splay_tree_delete (reference_vars_to_consider);\n   reference_vars_to_consider = NULL;\n-  all_module_statics = NULL;\n   return 0;\n }\n \n@@ -920,18 +927,32 @@ write_node_summary_p (struct cgraph_node *node,\n   return true;\n }\n \n-/* Stream out BITS&LTRANS_STATICS as list of decls to OB.  */\n+/* Stream out BITS&LTRANS_STATICS as list of decls to OB.\n+   LTRANS_STATICS_BITCOUNT specify number of bits in LTRANS_STATICS\n+   or -1.  When it is positive, just output -1 when\n+   BITS&LTRANS_STATICS == BITS&LTRANS_STATICS.  */\n \n static void\n stream_out_bitmap (struct lto_simple_output_block *ob,\n-\t\t   bitmap bits, bitmap ltrans_statics)\n+\t\t   bitmap bits, bitmap ltrans_statics,\n+\t\t   int ltrans_statics_bitcount)\n {\n-  unsigned int count = 0;\n+  int count = 0;\n   unsigned int index;\n   bitmap_iterator bi;\n+  if (bits == all_module_statics)\n+    {\n+      lto_output_sleb128_stream (ob->main_stream, -1);\n+      return;\n+    }\n   EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n     count ++;\n-  lto_output_uleb128_stream (ob->main_stream, count);\n+  if (count == ltrans_statics_bitcount)\n+    {\n+      lto_output_sleb128_stream (ob->main_stream, -1);\n+      return;\n+    }\n+  lto_output_sleb128_stream (ob->main_stream, count);\n   if (!count)\n     return;\n   EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n@@ -948,47 +969,65 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \t\t\t\t\t  varpool_node_set vset)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *vnode;\n   struct lto_simple_output_block *ob\n     = lto_create_simple_output_block (LTO_section_ipa_reference);\n   unsigned int count = 0;\n+  int ltrans_statics_bitcount = 0;\n   lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n+  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n   bitmap ltrans_statics = BITMAP_ALLOC (NULL);\n+  int i;\n \n   reference_vars_to_consider = splay_tree_new (splay_tree_compare_ints, 0, 0);\n \n   /* See what variables we are interested in.  */\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    if (!vnode->externally_visible\n-\t&& vnode->analyzed\n-\t&& is_proper_for_analysis (vnode->decl)\n-\t&& referenced_from_this_partition_p (&vnode->ref_list, set, vset))\n-      {\n-\ttree decl = vnode->decl;\n-\tbitmap_set_bit (ltrans_statics, DECL_UID (decl));\n-\tsplay_tree_insert (reference_vars_to_consider,\n-\t\t\t   DECL_UID (decl), (splay_tree_value)decl);\n-      }\n+  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+    {\n+      struct varpool_node *vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n+      if (!vnode->externally_visible\n+\t  && vnode->analyzed\n+\t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->decl))\n+\t  && referenced_from_this_partition_p (&vnode->ref_list, set, vset))\n+\t{\n+\t  tree decl = vnode->decl;\n+\t  bitmap_set_bit (ltrans_statics, DECL_UID (decl));\n+\t  splay_tree_insert (reference_vars_to_consider,\n+\t\t\t     DECL_UID (decl), (splay_tree_value)decl);\n+\t  ltrans_statics_bitcount ++;\n+\t}\n+    }\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (write_node_summary_p (node, set, vset, ltrans_statics))\n-\tcount++;\n+\n+  if (ltrans_statics_bitcount)\n+    for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+      if (write_node_summary_p (lto_cgraph_encoder_deref (encoder, i),\n+\t\t\t\tset, vset, ltrans_statics))\n+\t  count++;\n \n   lto_output_uleb128_stream (ob->main_stream, count);\n+  if (count)\n+    stream_out_bitmap (ob, ltrans_statics, ltrans_statics,\n+\t\t       -1);\n \n   /* Process all of the functions.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (write_node_summary_p (node, set, vset, ltrans_statics))\n+  if (ltrans_statics_bitcount)\n+    for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n       {\n-\tipa_reference_optimization_summary_t info;\n-\tint node_ref;\n-\n-\tinfo = get_reference_optimization_summary (node);\n-\tnode_ref = lto_cgraph_encoder_encode (encoder, node);\n-\tlto_output_uleb128_stream (ob->main_stream, node_ref);\n-\n-\tstream_out_bitmap (ob, info->statics_not_read, ltrans_statics);\n-\tstream_out_bitmap (ob, info->statics_not_written, ltrans_statics);\n+\tnode = lto_cgraph_encoder_deref (encoder, i);\n+\tif (write_node_summary_p (node, set, vset, ltrans_statics))\n+\t  {\n+\t    ipa_reference_optimization_summary_t info;\n+\t    int node_ref;\n+\n+\t    info = get_reference_optimization_summary (node);\n+\t    node_ref = lto_cgraph_encoder_encode (encoder, node);\n+\t    lto_output_uleb128_stream (ob->main_stream, node_ref);\n+\n+\t    stream_out_bitmap (ob, info->statics_not_read, ltrans_statics,\n+\t\t\t       ltrans_statics_bitcount);\n+\t    stream_out_bitmap (ob, info->statics_not_written, ltrans_statics,\n+\t\t\t       ltrans_statics_bitcount);\n+\t  }\n       }\n   BITMAP_FREE (ltrans_statics);\n   lto_destroy_simple_output_block (ob);\n@@ -1010,6 +1049,7 @@ ipa_reference_read_optimization_summary (void)\n       cgraph_add_node_removal_hook (&remove_node_data, NULL);\n   node_duplication_hook_holder =\n       cgraph_add_node_duplication_hook (&duplicate_node_data, NULL);\n+  all_module_statics = BITMAP_ALLOC (&optimization_summary_obstack);\n \n   while ((file_data = file_data_vec[j++]))\n     {\n@@ -1023,6 +1063,22 @@ ipa_reference_read_optimization_summary (void)\n \t{\n \t  unsigned int i;\n \t  unsigned int f_count = lto_input_uleb128 (ib);\n+\t  int b_count;\n+\t  if (!f_count)\n+\t    continue;\n+\t  b_count = lto_input_sleb128 (ib);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"all module statics:\");\n+\t  for (i = 0; i < (unsigned int)b_count; i++)\n+\t    {\n+\t      unsigned int var_index = lto_input_uleb128 (ib);\n+\t      tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t     var_index);\n+\t      bitmap_set_bit (all_module_statics, DECL_UID (v_decl));\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" %s\",\n+\t\t\t lang_hooks.decl_printable_name (v_decl, 2));\n+\t    }\n \n \t  for (i = 0; i < f_count; i++)\n \t    {\n@@ -1045,33 +1101,47 @@ ipa_reference_read_optimization_summary (void)\n \t\t\t cgraph_node_name (node), node->uid);\n \n \t      /* Set the statics not read.  */\n-\t      v_count = lto_input_uleb128 (ib);\n-\t      for (j = 0; j < (unsigned int)v_count; j++)\n+\t      v_count = lto_input_sleb128 (ib);\n+\t      if (v_count == -1)\n \t\t{\n-\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n-\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t\t\t var_index);\n-\t\t  bitmap_set_bit (info->statics_not_read, DECL_UID (v_decl));\n+\t\t  info->statics_not_read = all_module_statics;\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \" %s\",\n-\t\t\t     lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t    fprintf (dump_file, \" all module statics\");\n \t\t}\n+\t      else\n+\t\tfor (j = 0; j < (unsigned int)v_count; j++)\n+\t\t  {\n+\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t   var_index);\n+\t\t    bitmap_set_bit (info->statics_not_read, DECL_UID (v_decl));\n+\t\t    if (dump_file)\n+\t\t      fprintf (dump_file, \" %s\",\n+\t\t\t       lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t  }\n \n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"\\n  static not written:\");\n \t      /* Set the statics not written.  */\n-\t      v_count = lto_input_uleb128 (ib);\n-\t      for (j = 0; j < (unsigned int)v_count; j++)\n+\t      v_count = lto_input_sleb128 (ib);\n+\t      if (v_count == -1)\n \t\t{\n-\t\t  unsigned int var_index = lto_input_uleb128 (ib);\n-\t\t  tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n-\t\t\t\t\t\t\t\t var_index);\n-\t\t  bitmap_set_bit (info->statics_not_written, DECL_UID (v_decl));\n+\t\t  info->statics_not_written = all_module_statics;\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \" %s\",\n-\t\t\t     lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t    fprintf (dump_file, \" all module statics\");\n \t\t}\n+\t      else\n+\t\tfor (j = 0; j < (unsigned int)v_count; j++)\n+\t\t  {\n+\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n+\t\t\t\t\t\t\t\t   var_index);\n+\t\t    bitmap_set_bit (info->statics_not_written, DECL_UID (v_decl));\n+\t\t    if (dump_file)\n+\t\t      fprintf (dump_file, \" %s\",\n+\t\t\t       lang_hooks.decl_printable_name (v_decl, 2));\n+\t\t  }\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"\\n\");\n \t    }"}]}