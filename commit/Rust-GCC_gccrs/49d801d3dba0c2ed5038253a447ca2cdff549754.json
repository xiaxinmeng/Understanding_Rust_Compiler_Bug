{"sha": "49d801d3dba0c2ed5038253a447ca2cdff549754", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlkODAxZDNkYmEwYzJlZDUwMzgyNTNhNDQ3Y2EyY2RmZjU0OTc1NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-11-14T13:51:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-11-14T13:51:10Z"}, "message": "dbxout.c (dbxout_symbol_location): Update call of alter_subreg.\n\n\t* dbxout.c (dbxout_symbol_location): Update call of alter_subreg.\n\t* final.c (walk_alter_subreg): Take pointer; update call of alter_subreg.\n\t(final_scan_insn): Update call of alter_subreg.\n\t(cleanup_subreg_operands): Likewise.\n\t(alter_subreg): Rewrite using simplify_subreg.\n\t(output_address, output_operand): Update call of alter_subreg.\n\t* output.h (alter_subreg): Update prototype.\n\t* sdbout.c (sdbout_symbol): Update call of alter_subreg.\n\t* simplify-rtx.c (simplify_subreg): Copy ORIGINAL_REGNO.\n\t* Makefile.in (final.o): Add depdendancy on expr.h\n\nFrom-SVN: r47013", "tree": {"sha": "0f25f70b0a282f4cb777692ce7091aecdedb8e2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f25f70b0a282f4cb777692ce7091aecdedb8e2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49d801d3dba0c2ed5038253a447ca2cdff549754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d801d3dba0c2ed5038253a447ca2cdff549754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d801d3dba0c2ed5038253a447ca2cdff549754", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d801d3dba0c2ed5038253a447ca2cdff549754/comments", "author": null, "committer": null, "parents": [{"sha": "373bd0fac976b237f52a957e37597b0138ad1eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/373bd0fac976b237f52a957e37597b0138ad1eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/373bd0fac976b237f52a957e37597b0138ad1eab"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "d22a17a925709fc5e5ec8ddcf646526166cb4e28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -1,3 +1,16 @@\n+Wed Nov 14 14:17:05 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* dbxout.c (dbxout_symbol_location): Update call of alter_subreg.\n+\t* final.c (walk_alter_subreg): Take pointer; update call of alter_subreg.\n+\t(final_scan_insn): Update call of alter_subreg.\n+\t(cleanup_subreg_operands): Likewise.\n+\t(alter_subreg): Rewrite using simplify_subreg.\n+\t(output_address, output_operand): Update call of alter_subreg.\n+\t* output.h (alter_subreg): Update prototype.\n+\t* sdbout.c (sdbout_symbol): Update call of alter_subreg.\n+\t* simplify-rtx.c (simplify_subreg): Copy ORIGINAL_REGNO.\n+\t* Makefile.in (final.o): Add depdendancy on expr.h\n+\n Wed Nov 14 06:37:54 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* c-lang.c (finish_file): Make I unsigned to eliminate warning."}, {"sha": "6231c440c96c6be9a68811ba7f36dfd0ae868d4f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -1575,7 +1575,7 @@ sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) sched-int.h \\\n final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n    real.h output.h hard-reg-set.h except.h debug.h xcoffout.h \\\n-   toplev.h reload.h dwarf2out.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H)\n+   toplev.h reload.h dwarf2out.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h flags.h insn-config.h \\\n    $(INSN_ATTR_H) real.h toplev.h output.h reload.h $(TM_P_H)"}, {"sha": "344ebbefeae8ac4371e710d98adf49b0c24379dc", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -2107,7 +2107,7 @@ dbxout_symbol_location (decl, type, suffix, home)\n \t  if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n \t    return 0;\n \t}\n-      home = alter_subreg (home);\n+      home = alter_subreg (&home);\n     }\n   if (GET_CODE (home) == REG)\n     {"}, {"sha": "733503e942480c9497887243f8b251cf447c8ec6", "filename": "gcc/final.c", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -67,6 +67,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"target.h\"\n #include \"debug.h\"\n+#include \"expr.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -242,7 +243,7 @@ static void profile_after_prologue PARAMS ((FILE *));\n static void add_bb\t\tPARAMS ((FILE *));\n static int add_bb_string\tPARAMS ((const char *, int));\n static void notice_source_line\tPARAMS ((rtx));\n-static rtx walk_alter_subreg\tPARAMS ((rtx));\n+static rtx walk_alter_subreg\tPARAMS ((rtx *));\n static void output_asm_name\tPARAMS ((void));\n static tree get_decl_from_op\tPARAMS ((rtx, int *));\n static void output_asm_operand_names PARAMS ((rtx *, int *, int));\n@@ -2634,15 +2635,15 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t\t&& insn != last_ignored_compare)\n \t      {\n \t\tif (GET_CODE (SET_SRC (set)) == SUBREG)\n-\t\t  SET_SRC (set) = alter_subreg (SET_SRC (set));\n+\t\t  SET_SRC (set) = alter_subreg (&SET_SRC (set));\n \t\telse if (GET_CODE (SET_SRC (set)) == COMPARE)\n \t\t  {\n \t\t    if (GET_CODE (XEXP (SET_SRC (set), 0)) == SUBREG)\n \t\t      XEXP (SET_SRC (set), 0)\n-\t\t\t= alter_subreg (XEXP (SET_SRC (set), 0));\n+\t\t\t= alter_subreg (&XEXP (SET_SRC (set), 0));\n \t\t    if (GET_CODE (XEXP (SET_SRC (set), 1)) == SUBREG)\n \t\t      XEXP (SET_SRC (set), 1)\n-\t\t\t= alter_subreg (XEXP (SET_SRC (set), 1));\n+\t\t\t= alter_subreg (&XEXP (SET_SRC (set), 1));\n \t\t  }\n \t\tif ((cc_status.value1 != 0\n \t\t     && rtx_equal_p (SET_SRC (set), cc_status.value1))\n@@ -3004,88 +3005,64 @@ cleanup_subreg_operands (insn)\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-\trecog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n+\trecog_data.operand[i] = alter_subreg (recog_data.operand_loc[i]);\n       else if (GET_CODE (recog_data.operand[i]) == PLUS\n \t       || GET_CODE (recog_data.operand[i]) == MULT\n \t       || GET_CODE (recog_data.operand[i]) == MEM)\n-\trecog_data.operand[i] = walk_alter_subreg (recog_data.operand[i]);\n+\trecog_data.operand[i] = walk_alter_subreg (recog_data.operand_loc[i]);\n     }\n \n   for (i = 0; i < recog_data.n_dups; i++)\n     {\n       if (GET_CODE (*recog_data.dup_loc[i]) == SUBREG)\n-\t*recog_data.dup_loc[i] = alter_subreg (*recog_data.dup_loc[i]);\n+\t*recog_data.dup_loc[i] = alter_subreg (recog_data.dup_loc[i]);\n       else if (GET_CODE (*recog_data.dup_loc[i]) == PLUS\n \t       || GET_CODE (*recog_data.dup_loc[i]) == MULT\n \t       || GET_CODE (*recog_data.dup_loc[i]) == MEM)\n-\t*recog_data.dup_loc[i] = walk_alter_subreg (*recog_data.dup_loc[i]);\n+\t*recog_data.dup_loc[i] = walk_alter_subreg (recog_data.dup_loc[i]);\n     }\n }\n \n /* If X is a SUBREG, replace it with a REG or a MEM,\n    based on the thing it is a subreg of.  */\n \n rtx\n-alter_subreg (x)\n-     rtx x;\n+alter_subreg (xp)\n+     rtx *xp;\n {\n+  rtx x = *xp;\n   rtx y = SUBREG_REG (x);\n \n-  if (GET_CODE (y) == SUBREG)\n-    y = alter_subreg (y);\n-\n-  /* If reload is operating, we may be replacing inside this SUBREG.\n-     Check for that and make a new one if so.  */\n-  if (reload_in_progress && find_replacement (&SUBREG_REG (x)) != 0)\n-    x = copy_rtx (x);\n-\n-  if (GET_CODE (y) == REG)\n-    {\n-      int regno = subreg_hard_regno (x, 1);\n-\n-      PUT_CODE (x, REG);\n-      REGNO (x) = regno;\n-      ORIGINAL_REGNO (x) = ORIGINAL_REGNO (y);\n-      /* This field has a different meaning for REGs and SUBREGs.  Make sure\n-\t to clear it!  */\n-      x->used = 0;\n-    }\n-  else if (GET_CODE (y) == MEM)\n-    {\n-      HOST_WIDE_INT offset = SUBREG_BYTE (x);\n-\n-      /* Catch these instead of generating incorrect code.  */\n-      if ((offset % GET_MODE_SIZE (GET_MODE (x))) != 0)\n-\tabort ();\n-\n-      PUT_CODE (x, MEM);\n-      MEM_COPY_ATTRIBUTES (x, y);\n-      XEXP (x, 0) = plus_constant (XEXP (y, 0), offset);\n-    }\n-\n-  return x;\n+  /* simplify_subreg does not remove subreg from volatile references.\n+     We are required to.  */\n+  if (GET_CODE (y) == MEM)\n+    *xp = adjust_address (y, GET_MODE (x), SUBREG_BYTE (x));\n+  else\n+    *xp = simplify_subreg (GET_MODE (x), y, GET_MODE (y), SUBREG_BYTE (x));\n+  return *xp;\n }\n \n /* Do alter_subreg on all the SUBREGs contained in X.  */\n \n static rtx\n-walk_alter_subreg (x)\n-     rtx x;\n+walk_alter_subreg (xp)\n+     rtx *xp;\n {\n+  rtx x = *xp;\n   switch (GET_CODE (x))\n     {\n     case PLUS:\n     case MULT:\n-      XEXP (x, 0) = walk_alter_subreg (XEXP (x, 0));\n-      XEXP (x, 1) = walk_alter_subreg (XEXP (x, 1));\n+      XEXP (x, 0) = walk_alter_subreg (&XEXP (x, 0));\n+      XEXP (x, 1) = walk_alter_subreg (&XEXP (x, 1));\n       break;\n \n     case MEM:\n-      XEXP (x, 0) = walk_alter_subreg (XEXP (x, 0));\n+      XEXP (x, 0) = walk_alter_subreg (&XEXP (x, 0));\n       break;\n \n     case SUBREG:\n-      return alter_subreg (x);\n+      return alter_subreg (xp);\n \n     default:\n       break;\n@@ -3624,7 +3601,7 @@ output_operand (x, code)\n      int code ATTRIBUTE_UNUSED;\n {\n   if (x && GET_CODE (x) == SUBREG)\n-    x = alter_subreg (x);\n+    x = alter_subreg (&x);\n \n   /* If X is a pseudo-register, abort now rather than writing trash to the\n      assembler file.  */\n@@ -3643,7 +3620,7 @@ void\n output_address (x)\n      rtx x;\n {\n-  walk_alter_subreg (x);\n+  walk_alter_subreg (&x);\n   PRINT_OPERAND_ADDRESS (asm_out_file, x);\n }\n \f"}, {"sha": "793798809ca8bcabf7c31331609b5411afa0295e", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -77,7 +77,7 @@ extern rtx final_scan_insn\tPARAMS ((rtx, FILE *, int, int, int));\n \n /* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n    subreg of.  */\n-extern rtx alter_subreg PARAMS ((rtx));\n+extern rtx alter_subreg PARAMS ((rtx *));\n \n /* Report inconsistency between the assembler template and the operands.\n    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */"}, {"sha": "ab0a0d89849c19a32251b7ad4fc9b27984011f3d", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -809,7 +809,7 @@ sdbout_symbol (decl, local)\n \t      if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n \t\treturn;\n \t    }\n-\t  regno = REGNO (alter_subreg (DECL_RTL (decl)));\n+\t  regno = REGNO (alter_subreg (&DECL_RTL (decl)));\n \t  value = DECL_RTL (decl);\n \t}\n       /* Don't output anything if an auto variable"}, {"sha": "0f11556251d3dd515b5946bda3850e73809e78a6", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d801d3dba0c2ed5038253a447ca2cdff549754/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=49d801d3dba0c2ed5038253a447ca2cdff549754", "patch": "@@ -2587,7 +2587,18 @@ simplify_subreg (outermode, op, innermode, byte)\n \t arguments are passed on 32-bit Sparc and should be fixed.  */\n       if (HARD_REGNO_MODE_OK (final_regno, outermode)\n \t  || ! HARD_REGNO_MODE_OK (REGNO (op), innermode))\n-\treturn gen_rtx_REG (outermode, final_regno);\n+\t{\n+\t  rtx x = gen_rtx_REG (outermode, final_regno);\n+\n+\t  /* Propagate original regno.  We don't have any way to specify\n+\t     the offset inside orignal regno, so do so only for lowpart.\n+\t     The information is used only by alias analysis that can not\n+\t     grog partial register anyway.  */\n+\n+\t  if (subreg_lowpart_offset (outermode, innermode) == byte)\n+\t    ORIGINAL_REGNO (x) = ORIGINAL_REGNO (op);\n+\t  return x;\n+\t}\n     }\n \n   /* If we have a SUBREG of a register that we are replacing and we are"}]}