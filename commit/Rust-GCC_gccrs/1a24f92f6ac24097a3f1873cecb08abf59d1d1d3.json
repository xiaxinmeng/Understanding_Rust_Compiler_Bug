{"sha": "1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEyNGY5MmY2YWMyNDA5N2EzZjE4NzNjZWNiMDhhYmY1OWQxZDFkMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2004-08-11T17:50:47Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2004-08-11T17:50:47Z"}, "message": "tree-flow-inline.h (get_def_ops, [...]): Add operand structure reference.\n\n\n2004-08-11  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-flow-inline.h (get_def_ops, get_use_ops, get_v_may_def_ops,\n\tget_vuse_ops,get_v_must_def_ops): Add operand structure reference.\n\t(get_v_may_def_result_ptr, get_v_may_def_op_ptr): New access struct.\n\t(start_ssa_stmt_operands): Delete.\n\t* tree-flow.h (struct stmt_ann_d): Replace operand vectors with new\n\tstruct stmt_operands_d.\n\t(build_ssa_operands): New extern entry point.\n\t* tree-ssa-dom.c (record_equivalences_from_stmt): Remove operand\n\tbuilding code, replace with create_ssa_artficial_load_stmt().\n\t* tree-ssa-operands.c (struct voperands_d): Delete.\n\t(allocate_v_may_def_optype): Allocate v_may_def_operand_type_t vector.\n\t(allocate_v_must_def_optype): Use sizeof (tree), not sizeof (tree *).\n\t(free_uses, free_defs, free_vuses, free_v_may_defs,\n\tfree_v_must_defs): Remove dealloc parameter.\n\t(remove_vuses, remove_v_may_def, remove_v_must_defs): Delete.\n\t(finalize_ssa_defs, finalize_ssa_uses, finalize_ssa_v_may_defs,\n\tfinalize_ssa_vuses, finalize_ssa_v_must_defs): Perform all operand\n\tvector comparisons, ssa_name reuse, and allocations here.\n\t(verify_start_operands): Delete.\n\t(finalize_ssa_stmt_operands): Set new operands by calling finalize\n\troutines.\n\t(start_ssa_stmt_operands): Move from tree-flow-inline.h.\n\t(append_def, append_usei): Simplify to simple accumulation.\n\t(append_v_may_def, append_vuse, append_v_must_def): Simplify to avoiding\n\tduplicates and simple accumulation.\n\t(free_ssa_operands): Free vectors in a stmt_operand structure.\n\t(build_ssa_operands): New. Create a new stmt_operand structure from\n\ta stmt and an old set of stmt_operands.\n\t(get_stmt_operands): Simplify and call build_ssa_operands.\n\t(get_expr_operands, get_asm_expr_operands, get_indirect_ref_operands,\n\tget_call_expr_operands, add_stmt_operand, add_call_clobber_ops,\n\tadd_call_read_ops): Don't pass prev_vops around anymore.\n\t(note_addressable): Return if no stmt annotation.\n\t(copy_virtual_operands): Access v_may_def operands through a struct.\n\t(create_ssa_artficial_load_stmt): New.  Create a load stmt for DOM's\n\thash tables without treating the stmt as a real stmt.\n\t* tree-ssa-operands.h (struct v_may_def_operand_type): New.  Access\n\tv_may_def def and use through a struct instead of 2 array elements.\n\t(struct v_may_def_optype_d): Use v_may_def_operand_type.\n\t(struct stmt_operands_d): New.  Struct for storing all operand vectors.\n\nFrom-SVN: r85807", "tree": {"sha": "1be60ac2481dad8bdd3382083d1b9056fea5fdac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1be60ac2481dad8bdd3382083d1b9056fea5fdac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/comments", "author": null, "committer": null, "parents": [{"sha": "3ec0f302092e35b9c52cc2156c548ed04fc84b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec0f302092e35b9c52cc2156c548ed04fc84b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec0f302092e35b9c52cc2156c548ed04fc84b21"}], "stats": {"total": 1289, "additions": 741, "deletions": 548}, "files": [{"sha": "a67eae2769a0ec2f5e60fd65dee683dc769d60f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "patch": "@@ -1,3 +1,46 @@\n+2004-08-11  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-flow-inline.h (get_def_ops, get_use_ops, get_v_may_def_ops,\n+\tget_vuse_ops,get_v_must_def_ops): Add operand structure reference.\n+\t(get_v_may_def_result_ptr, get_v_may_def_op_ptr): New access struct.\n+\t(start_ssa_stmt_operands): Delete.\n+\t* tree-flow.h (struct stmt_ann_d): Replace operand vectors with new \n+\tstruct stmt_operands_d.\n+\t(build_ssa_operands): New extern entry point.\n+\t* tree-ssa-dom.c (record_equivalences_from_stmt): Remove operand \n+\tbuilding code, replace with create_ssa_artficial_load_stmt().\n+\t* tree-ssa-operands.c (struct voperands_d): Delete.\n+\t(allocate_v_may_def_optype): Allocate v_may_def_operand_type_t vector.\n+\t(allocate_v_must_def_optype): Use sizeof (tree), not sizeof (tree *).\n+\t(free_uses, free_defs, free_vuses, free_v_may_defs, \n+\tfree_v_must_defs): Remove dealloc parameter.\n+\t(remove_vuses, remove_v_may_def, remove_v_must_defs): Delete.\n+\t(finalize_ssa_defs, finalize_ssa_uses, finalize_ssa_v_may_defs,\n+\tfinalize_ssa_vuses, finalize_ssa_v_must_defs): Perform all operand\n+\tvector comparisons, ssa_name reuse, and allocations here.\n+\t(verify_start_operands): Delete.\n+\t(finalize_ssa_stmt_operands): Set new operands by calling finalize\n+\troutines.\n+\t(start_ssa_stmt_operands): Move from tree-flow-inline.h.\n+\t(append_def, append_usei): Simplify to simple accumulation.\n+\t(append_v_may_def, append_vuse, append_v_must_def): Simplify to avoiding\n+\tduplicates and simple accumulation.\n+\t(free_ssa_operands): Free vectors in a stmt_operand structure.\n+\t(build_ssa_operands): New. Create a new stmt_operand structure from\n+\ta stmt and an old set of stmt_operands.  \n+\t(get_stmt_operands): Simplify and call build_ssa_operands.\n+\t(get_expr_operands, get_asm_expr_operands, get_indirect_ref_operands,\n+\tget_call_expr_operands, add_stmt_operand, add_call_clobber_ops,\n+\tadd_call_read_ops): Don't pass prev_vops around anymore.\n+\t(note_addressable): Return if no stmt annotation.\n+\t(copy_virtual_operands): Access v_may_def operands through a struct.\n+\t(create_ssa_artficial_load_stmt): New.  Create a load stmt for DOM's\n+\thash tables without treating the stmt as a real stmt.\n+\t* tree-ssa-operands.h (struct v_may_def_operand_type): New.  Access\n+\tv_may_def def and use through a struct instead of 2 array elements.\n+\t(struct v_may_def_optype_d): Use v_may_def_operand_type.\n+\t(struct stmt_operands_d): New.  Struct for storing all operand vectors.\n+\n 2004-08-11  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/arm.c (arm_is_longcall_p): Update comment describing"}, {"sha": "d3e0a32dbad0eb18dff704038199df1ea15dd446", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "patch": "@@ -169,15 +169,15 @@ stmt_modified_p (tree t)\n static inline def_optype\n get_def_ops (stmt_ann_t ann)\n {\n-  return ann ? ann->def_ops : NULL;\n+  return ann ? ann->operands.def_ops : NULL;\n }\n \n /* Return the uses present in ANN, a statement annotation.\n    Return NULL if this annotation contains no uses.  */\n static inline use_optype\n get_use_ops (stmt_ann_t ann)\n {\n-  return ann ? ann->use_ops : NULL;\n+  return ann ? ann->operands.use_ops : NULL;\n }\n \n /* Return the virtual may-defs present in ANN, a statement\n@@ -186,23 +186,23 @@ get_use_ops (stmt_ann_t ann)\n static inline v_may_def_optype\n get_v_may_def_ops (stmt_ann_t ann)\n {\n-  return ann ? ann->v_may_def_ops : NULL;\n+  return ann ? ann->operands.v_may_def_ops : NULL;\n }\n \n /* Return the virtual uses present in ANN, a statement annotation.\n    Return NULL if this annotation contains no virtual uses.  */\n static inline vuse_optype\n get_vuse_ops (stmt_ann_t ann)\n {\n-  return ann ? ann->vuse_ops : NULL;\n+  return ann ? ann->operands.vuse_ops : NULL;\n }\n \n /* Return the virtual must-defs present in ANN, a statement\n    annotation.  Return NULL if this annotation contains no must-defs.*/\n static inline v_must_def_optype\n get_v_must_def_ops (stmt_ann_t ann)\n {\n-  return ann ? ann->v_must_def_ops : NULL;\n+  return ann ? ann->operands.v_must_def_ops : NULL;\n }\n \n /* Return the tree pointer to by USE.  */ \n@@ -252,7 +252,7 @@ get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n   if (index >= v_may_defs->num_v_may_defs)\n     abort();\n #endif\n-  op.def = &(v_may_defs->v_may_defs[index * 2]);\n+  op.def = &(v_may_defs->v_may_defs[index].def);\n   return op;\n }\n \n@@ -266,7 +266,7 @@ get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n   if (index >= v_may_defs->num_v_may_defs)\n     abort();\n #endif\n-  op.use = &(v_may_defs->v_may_defs[index * 2 + 1]);\n+  op.use = &(v_may_defs->v_may_defs[index].use);\n   return op;\n }\n \n@@ -315,15 +315,6 @@ get_phi_arg_def_ptr (tree phi, int i)\n   return op;\n }\n  \n-/* Mark the beginning of changes to the SSA operands for STMT.  */\n-static inline void\n-start_ssa_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n-{\n-#ifdef ENABLE_CHECKING\n-  verify_start_operands (stmt);\n-#endif\n-}\n-\n /* Return the bitmap of addresses taken by STMT, or NULL if it takes\n    no addresses.  */\n static inline bitmap"}, {"sha": "1faa91a9199cae9379576da3acd9ccf07834bf21", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "patch": "@@ -266,14 +266,7 @@ struct stmt_ann_d GTY(())\n   /* Basic block that contains this statement.  */\n   basic_block GTY ((skip (\"\"))) bb;\n \n-  /* Statement operands.  */\n-  struct def_optype_d * GTY (()) def_ops;\n-  struct use_optype_d * GTY (()) use_ops;\n-\n-  /* Virtual operands (V_MAY_DEF, VUSE, and V_MUST_DEF).  */\n-  struct v_may_def_optype_d * GTY (()) v_may_def_ops;\n-  struct vuse_optype_d * GTY (()) vuse_ops;\n-  struct v_must_def_optype_d * GTY (()) v_must_def_ops;\n+  struct stmt_operands_d operands;\n \n   /* Dataflow information.  */\n   dataflow_t df;\n@@ -690,6 +683,10 @@ void vn_delete (void);\n /* In tree-sra.c  */\n void insert_edge_copies (tree stmt, basic_block bb);\n \n+/* In tree-ssa-operands.c  */\n+extern void build_ssa_operands (tree, stmt_ann_t, stmt_operands_p, \n+\t\t\t\tstmt_operands_p);\n+\n #include \"tree-flow-inline.h\"\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "d0eb6753da7fce603f1163e023414582b2b3de26", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "patch": "@@ -2564,7 +2564,6 @@ record_equivalences_from_stmt (tree stmt,\n     {\n       tree rhs = TREE_OPERAND (stmt, 1);\n       tree new;\n-      size_t j;\n \n       /* FIXME: If the LHS of the assignment is a bitfield and the RHS\n          is a constant, we need to adjust the constant to fit into the\n@@ -2589,39 +2588,10 @@ record_equivalences_from_stmt (tree stmt,\n \n       if (rhs)\n \t{\n-\t  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  v_must_def_optype v_must_defs = V_MUST_DEF_OPS (ann);\n-\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n \t  new = build (MODIFY_EXPR, TREE_TYPE (stmt), rhs, lhs);\n \n-\t  /* Get an annotation and set up the real operands.  */\n-\t  get_stmt_ann (new);\n-\t  get_stmt_operands (new);\n-\n-\t  /* Clear out the virtual operands on the new statement, we are\n-\t     going to set them explicitly below.  */\n-\t  remove_vuses (new);\n-\t  remove_v_may_defs (new);\n-\t  remove_v_must_defs (new);\n-\n-\t  start_ssa_stmt_operands (new);\n-\t  /* For each VDEF on the original statement, we want to create a\n-\t     VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n-\t     statement.  */\n-\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n-\t    {\n-\t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n-\t      add_vuse (op, new);\n-\t    }\n-\t    \n-\t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n-\t    {\n-\t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n-\t      add_vuse (op, new);\n-\t    }\n-\n-\t  finalize_ssa_stmt_operands (new);\n+\t  create_ssa_artficial_load_stmt (&(ann->operands), new);\n \n \t  /* Finally enter the statement into the available expression\n \t     table.  */"}, {"sha": "fe291d09d761ad2ef7a9d6a640869ea214e10c63", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 660, "deletions": 486, "changes": 1146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "patch": "@@ -32,6 +32,53 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"timevar.h\"\n \n+\n+/* This file contains the code required to mnage the operands cache of the \n+   SSA optimizer.  For every stmt, we maintain an operand cache in the stmt \n+   annotation.  This cache contains operands that will be of interets to \n+   optimizers and other passes wishing to manipulate the IL. \n+\n+   The operand type are broken up into REAL and VIRTUAL operands.  The real \n+   operands are represented as pointers into the stmt's operand tree.  Thus \n+   any manipulation of the real operands will be reflected in the actual tree.\n+   Virtual operands are represented solely in the cache, although the base \n+   variable for the SSA_NAME may, or may not occur in the stmt's tree.  \n+   Manipulation of the virtual operands will not be reflected in the stmt tree.\n+\n+   The routines in this file are concerned with creating this operand cache \n+   from a stmt tree.\n+\n+   get_stmt_operands() in the primary entry point. \n+\n+   The operand tree is the parsed by the various get_* routines which look \n+   through the stmt tree for the occurence of operands which may be of \n+   interest, and calls are made to the append_* routines whenever one is \n+   found.  There are 5 of these routines, each representing one of the \n+   5 types of operands. Defs, Uses, Virtual Uses, Virtual May Defs, and \n+   Virtual Must Defs.\n+\n+   The append_* routines check for duplication, and simply keep a list of \n+   unique objects for each operand type in the build_* extendable vectors.\n+\n+   Once the stmt tree is completely parsed, the finalize_ssa_operands() \n+   routine is called, which proceeds to perform the finalization routine \n+   on each of the 5 operand vectors which have been built up.\n+\n+   If the stmt had a previous operand cache, the finalization routines \n+   attempt to match up the new operands with the old ones.  If its a perfect \n+   match, the old vector is simply reused.  If it isn't a perfect match, then \n+   a new vector is created and the new operands are placed there.  For \n+   virtual operands, if the previous cache had SSA_NAME version of a \n+   variable, and that same variable occurs in the same operands cache, then \n+   the new cache vector will also get the same SSA_NAME.\n+\n+  ie, if a stmt had a VUSE of 'a_5', and 'a' occurs in the new operand \n+  vector for VUSE, then the new vector will also be modified such that \n+  it contains 'a_5' rather than 'a'.\n+\n+*/\n+\n+\n /* Flags to describe operand properties in get_stmt_operands and helpers.  */\n \n /* By default, operands are loaded.  */\n@@ -68,30 +115,24 @@ static GTY (()) varray_type build_vuses;\n static GTY (()) varray_type build_v_must_defs;\n \n #ifdef ENABLE_CHECKING\n+/* Used to make sure operand construction is working on the proper stmt.  */\n tree check_build_stmt;\n #endif\n \n-typedef struct voperands_d \n-{\n-  v_may_def_optype v_may_def_ops;\n-  vuse_optype vuse_ops;\n-  v_must_def_optype v_must_def_ops;\n-} *voperands_t;\n-\n static void note_addressable (tree, stmt_ann_t);\n-static void get_expr_operands (tree, tree *, int, voperands_t);\n-static void get_asm_expr_operands (tree, voperands_t);\n-static void get_indirect_ref_operands (tree, tree, int, voperands_t);\n-static void get_call_expr_operands (tree, tree, voperands_t);\n-static inline void append_def (tree *, tree);\n-static inline void append_use (tree *, tree);\n-static void append_v_may_def (tree, tree, voperands_t);\n-static void append_v_must_def (tree, tree, voperands_t);\n-static void add_call_clobber_ops (tree, voperands_t);\n-static void add_call_read_ops (tree, voperands_t);\n-static void add_stmt_operand (tree *, tree, int, voperands_t);\n-\n-/* Return a vector of contiguous memory of a specified size.  */\n+static void get_expr_operands (tree, tree *, int);\n+static void get_asm_expr_operands (tree);\n+static void get_indirect_ref_operands (tree, tree, int);\n+static void get_call_expr_operands (tree, tree);\n+static inline void append_def (tree *);\n+static inline void append_use (tree *);\n+static void append_v_may_def (tree);\n+static void append_v_must_def (tree);\n+static void add_call_clobber_ops (tree);\n+static void add_call_read_ops (tree);\n+static void add_stmt_operand (tree *, tree, int);\n+\n+/* Return a vector of contiguous memory for NUM def operands.  */\n \n static inline def_optype\n allocate_def_optype (unsigned num)\n@@ -104,6 +145,9 @@ allocate_def_optype (unsigned num)\n   return def_ops;\n }\n \n+\n+/* Return a vector of contiguous memory for NUM use operands.  */\n+\n static inline use_optype\n allocate_use_optype (unsigned num)\n {\n@@ -115,17 +159,24 @@ allocate_use_optype (unsigned num)\n   return use_ops;\n }\n \n+\n+/* Return a vector of contiguous memory for NUM v_may_def operands.  */\n+\n static inline v_may_def_optype\n allocate_v_may_def_optype (unsigned num)\n {\n   v_may_def_optype v_may_def_ops;\n   unsigned size;\n-  size = sizeof (struct v_may_def_optype_d) + sizeof (tree) * ((num * 2) - 1);\n+  size = sizeof (struct v_may_def_optype_d) \n+\t   + sizeof (v_may_def_operand_type_t) * (num - 1);\n   v_may_def_ops =  ggc_alloc (size);\n   v_may_def_ops->num_v_may_defs = num;\n   return v_may_def_ops;\n }\n \n+\n+/* Return a vector of contiguous memory for NUM v_use operands.  */\n+\n static inline vuse_optype\n allocate_vuse_optype (unsigned num)\n {\n@@ -137,101 +188,87 @@ allocate_vuse_optype (unsigned num)\n   return vuse_ops;\n }\n \n+\n+/* Return a vector of contiguous memory for NUM v_must_def operands.  */\n+\n static inline v_must_def_optype\n allocate_v_must_def_optype (unsigned num)\n {\n   v_must_def_optype v_must_def_ops;\n   unsigned size;\n-  size = sizeof (struct v_must_def_optype_d) + sizeof (tree *) * (num - 1);\n+  size = sizeof (struct v_must_def_optype_d) + sizeof (tree) * (num - 1);\n   v_must_def_ops =  ggc_alloc (size);\n   v_must_def_ops->num_v_must_defs = num;\n   return v_must_def_ops;\n }\n \n+\n+/* Free memory for USES.  */\n+\n static inline void\n-free_uses (use_optype *uses, bool dealloc)\n+free_uses (use_optype *uses)\n {\n   if (*uses)\n     {\n-      if (dealloc)\n-\tggc_free (*uses);\n+      ggc_free (*uses);\n       *uses = NULL;\n     }\n }\n \n+\n+/* Free memory for DEFS.  */\n+\n static inline void\n-free_defs (def_optype *defs, bool dealloc)\n+free_defs (def_optype *defs)\n {\n   if (*defs)\n     {\n-      if (dealloc)\n-\tggc_free (*defs);\n+      ggc_free (*defs);\n       *defs = NULL;\n     }\n }\n \n+\n+/* Free memory for VUSES.  */\n+\n static inline void\n-free_vuses (vuse_optype *vuses, bool dealloc)\n+free_vuses (vuse_optype *vuses)\n {\n   if (*vuses)\n     {\n-      if (dealloc)\n-\tggc_free (*vuses);\n+      ggc_free (*vuses);\n       *vuses = NULL;\n     }\n }\n \n+\n+/* Free memory for V_MAY_DEFS.  */\n+\n static inline void\n-free_v_may_defs (v_may_def_optype *v_may_defs, bool dealloc)\n+free_v_may_defs (v_may_def_optype *v_may_defs)\n {\n   if (*v_may_defs)\n     {\n-      if (dealloc)\n-\tggc_free (*v_may_defs);\n+      ggc_free (*v_may_defs);\n       *v_may_defs = NULL;\n     }\n }\n \n+\n+/* Free memory for V_MUST_DEFS.  */\n+\n static inline void\n-free_v_must_defs (v_must_def_optype *v_must_defs, bool dealloc)\n+free_v_must_defs (v_must_def_optype *v_must_defs)\n {\n   if (*v_must_defs)\n     {\n-      if (dealloc)\n-\tggc_free (*v_must_defs);\n+      ggc_free (*v_must_defs);\n       *v_must_defs = NULL;\n     }\n }\n \n-void\n-remove_vuses (tree stmt)\n-{\n-  stmt_ann_t ann;\n-\n-  ann = stmt_ann (stmt);\n-  if (ann)\n-    free_vuses (&(ann->vuse_ops), true);\n-}\n-\n-void\n-remove_v_may_defs (tree stmt)\n-{\n-  stmt_ann_t ann;\n \n-  ann = stmt_ann (stmt);\n-  if (ann)\n-    free_v_may_defs (&(ann->v_may_def_ops), true);\n-}\n-\n-void\n-remove_v_must_defs (tree stmt)\n-{\n-  stmt_ann_t ann;\n-\n-  ann = stmt_ann (stmt);\n-  if (ann)\n-    free_v_must_defs (&(ann->v_must_def_ops), true);\n-}\n+/* Initialize the operand cache routines.  */\n \n void\n init_ssa_operands (void)\n@@ -243,47 +280,85 @@ init_ssa_operands (void)\n   VARRAY_TREE_INIT (build_v_must_defs, 10, \"build v_must_defs\");\n }\n \n+\n+/* Dispose of anything required by the operand routines.  */\n+\n void\n fini_ssa_operands (void)\n {\n }\n \n-static void\n-finalize_ssa_defs (tree stmt)\n+\n+/* All the finalize_ssa_* routines do the work required to turn the build_\n+   VARRAY into an operand_vector of the appropriate type.  The original vector,\n+   if any, is passed in for comparison and virtual SSA_NAME reuse.  If the\n+   old vector is reused, the pointer passed in is set to NULL so that \n+   the memory is not freed when the old operands are freed.  */\n+\n+/* Return a new def operand vector for STMT, comparing to OLD_OPS_P.  */\n+\n+static def_optype\n+finalize_ssa_defs (def_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n {\n   unsigned num, x;\n-  stmt_ann_t ann;\n-  def_optype def_ops;\n+  def_optype def_ops, old_ops;\n+  bool build_diff;\n \n   num = VARRAY_ACTIVE_SIZE (build_defs);\n   if (num == 0)\n-    return;\n+    return NULL;\n \n #ifdef ENABLE_CHECKING\n   /* There should only be a single real definition per assignment.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR && num > 1)\n     abort ();\n #endif\n \n-  def_ops = allocate_def_optype (num);\n-  for (x = 0; x < num ; x++)\n-    def_ops->defs[x].def = VARRAY_TREE_PTR (build_defs, x);\n+  old_ops = *old_ops_p;\n+\n+  /* Compare old vector and new array.  */\n+  build_diff = true;\n+  if (old_ops && old_ops->num_defs == num)\n+    {\n+      build_diff = false;\n+      for (x = 0; x < num; x++)\n+        if (old_ops->defs[x].def != VARRAY_TREE_PTR (build_defs, x))\n+\t  {\n+\t    build_diff = true;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (!build_diff)\n+    {\n+      def_ops = old_ops;\n+      *old_ops_p = NULL;\n+    }\n+  else\n+    {\n+      def_ops = allocate_def_optype (num);\n+      for (x = 0; x < num ; x++)\n+\tdef_ops->defs[x].def = VARRAY_TREE_PTR (build_defs, x);\n+    }\n+\n   VARRAY_POP_ALL (build_defs);\n \n-  ann = stmt_ann (stmt);\n-  ann->def_ops = def_ops;\n+  return def_ops;\n }\n \n-static void\n-finalize_ssa_uses (tree stmt)\n+\n+/* Return a new use operand vector for STMT, comparing to OLD_OPS_P.  */\n+\n+static use_optype\n+finalize_ssa_uses (use_optype *old_ops_p, tree stmt ATTRIBUTE_UNUSED)\n {\n   unsigned num, x;\n-  use_optype use_ops;\n-  stmt_ann_t ann;\n+  use_optype use_ops, old_ops;\n+  bool build_diff;\n \n   num = VARRAY_ACTIVE_SIZE (build_uses);\n   if (num == 0)\n-    return;\n+    return NULL;\n \n #ifdef ENABLE_CHECKING\n   {\n@@ -297,61 +372,127 @@ finalize_ssa_uses (tree stmt)\n \tabort ();\n   }\n #endif\n+  old_ops = *old_ops_p;\n \n-  use_ops = allocate_use_optype (num);\n-  for (x = 0; x < num ; x++)\n-    use_ops->uses[x].use = VARRAY_TREE_PTR (build_uses, x);\n+  /* Check if the old vector and the new array are the same.  */\n+  build_diff = true;\n+  if (old_ops && old_ops->num_uses == num)\n+    {\n+      build_diff = false;\n+      for (x = 0; x < num; x++)\n+        if (old_ops->uses[x].use != VARRAY_TREE_PTR (build_uses, x))\n+\t  {\n+\t    build_diff = true;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (!build_diff)\n+    {\n+      use_ops = old_ops;\n+      *old_ops_p = NULL;\n+    }\n+  else\n+    {\n+      use_ops = allocate_use_optype (num);\n+      for (x = 0; x < num ; x++)\n+\tuse_ops->uses[x].use = VARRAY_TREE_PTR (build_uses, x);\n+    }\n   VARRAY_POP_ALL (build_uses);\n \n-  ann = stmt_ann (stmt);\n-  ann->use_ops = use_ops;\n+  return use_ops;\n }\n \n-static void\n-finalize_ssa_v_may_defs (tree stmt)\n+\n+/* Return a new v_may_def operand vector for STMT, comparing to OLD_OPS_P.  */\n+\n+static v_may_def_optype\n+finalize_ssa_v_may_defs (v_may_def_optype *old_ops_p)\n {\n-  unsigned num, x;\n-  v_may_def_optype v_may_def_ops;\n-  stmt_ann_t ann;\n+  unsigned num, x, i, old_num;\n+  v_may_def_optype v_may_def_ops, old_ops;\n+  tree result, var;\n+  bool build_diff;\n \n   num = VARRAY_ACTIVE_SIZE (build_v_may_defs);\n   if (num == 0)\n-    return;\n+    return NULL;\n \n-#ifdef ENABLE_CHECKING\n-  /* V_MAY_DEFs must be entered in pairs of result/uses.  */\n-  if (num % 2 != 0)\n-    abort();\n-#endif\n+  old_ops = *old_ops_p;\n \n-  v_may_def_ops = allocate_v_may_def_optype (num / 2);\n-  for (x = 0; x < num; x++)\n-    v_may_def_ops->v_may_defs[x] = VARRAY_TREE (build_v_may_defs, x);\n-  VARRAY_CLEAR (build_v_may_defs);\n+  /* Check if the old vector and the new array are the same.  */\n+  build_diff = true;\n+  if (old_ops && old_ops->num_v_may_defs == num)\n+    {\n+      old_num = num;\n+      build_diff = false;\n+      for (x = 0; x < num; x++)\n+        {\n+\t  var = old_ops->v_may_defs[x].def;\n+\t  if (TREE_CODE (var) == SSA_NAME)\n+\t    var = SSA_NAME_VAR (var);\n+\t  if (var != VARRAY_TREE (build_v_may_defs, x))\n+\t    {\n+\t      build_diff = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    old_num = (old_ops ? old_ops->num_v_may_defs : 0);\n \n-  ann = stmt_ann (stmt);\n-  ann->v_may_def_ops = v_may_def_ops;\n+  if (!build_diff)\n+    {\n+      v_may_def_ops = old_ops;\n+      *old_ops_p = NULL;\n+    }\n+  else\n+    {\n+      v_may_def_ops = allocate_v_may_def_optype (num);\n+      for (x = 0; x < num; x++)\n+        {\n+\t  var = VARRAY_TREE (build_v_may_defs, x);\n+\t  /* Look for VAR in the old operands vector.  */\n+\t  for (i = 0; i < old_num; i++)\n+\t    {\n+\t      result = old_ops->v_may_defs[i].def;\n+\t      if (TREE_CODE (result) == SSA_NAME)\n+\t\tresult = SSA_NAME_VAR (result);\n+\t      if (result == var)\n+\t        {\n+\t\t  v_may_def_ops->v_may_defs[x] = old_ops->v_may_defs[i];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (i == old_num)\n+\t    {\n+\t      v_may_def_ops->v_may_defs[x].def = var;\n+\t      v_may_def_ops->v_may_defs[x].use = var;\n+\t    }\n+\t}\n+    }\n+\n+  /* Empty the V_MAY_DEF build vector after VUSES have been processed.  */\n+\n+  return v_may_def_ops;\n }\n \n-static inline void\n-finalize_ssa_vuses (tree stmt)\n-{\n-  unsigned num, x;\n-  stmt_ann_t ann;\n-  vuse_optype vuse_ops;\n-  v_may_def_optype v_may_defs;\n \n-#ifdef ENABLE_CHECKING\n-  if (VARRAY_ACTIVE_SIZE (build_v_may_defs) > 0)\n-    {\n-      fprintf (stderr, \"Please finalize V_MAY_DEFs before finalize VUSES.\\n\");\n-      abort ();\n-    }\n-#endif\n+/* Return a new vuse operand vector, comparing to OLD_OPS_P.  */\n+\n+static vuse_optype\n+finalize_ssa_vuses (vuse_optype *old_ops_p)\n+{\n+  unsigned num, x, i, num_v_may_defs, old_num;\n+  vuse_optype vuse_ops, old_ops;\n+  bool build_diff;\n \n   num = VARRAY_ACTIVE_SIZE (build_vuses);\n   if (num == 0)\n-    return;\n+    {\n+      VARRAY_POP_ALL (build_v_may_defs);\n+      return NULL;\n+    }\n \n   /* Remove superfluous VUSE operands.  If the statement already has a\n    V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is not\n@@ -365,42 +506,26 @@ finalize_ssa_vuses (tree stmt)\n   The VUSE <a_2> is superfluous because it is implied by the V_MAY_DEF\n   operation.  */\n \n-  ann = stmt_ann (stmt);\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  if (NUM_V_MAY_DEFS (v_may_defs) > 0)\n+  num_v_may_defs = VARRAY_ACTIVE_SIZE (build_v_may_defs);\n+\n+  if (num_v_may_defs > 0)\n     {\n       size_t i, j;\n+      tree vuse;\n       for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vuses); i++)\n \t{\n-\t  bool found = false;\n-\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n+\t  vuse = VARRAY_TREE (build_vuses, i);\n+\t  for (j = 0; j < num_v_may_defs; j++)\n \t    {\n-\t      tree vuse_var, v_may_def_var;\n-\t      tree vuse = VARRAY_TREE (build_vuses, i);\n-\t      tree v_may_def = V_MAY_DEF_OP (v_may_defs, j);\n-\n-\t      if (TREE_CODE (vuse) == SSA_NAME)\n-\t\tvuse_var = SSA_NAME_VAR (vuse);\n-\t      else\n-\t\tvuse_var = vuse;\n-\n-\t      if (TREE_CODE (v_may_def) == SSA_NAME)\n-\t\tv_may_def_var = SSA_NAME_VAR (v_may_def);\n-\t      else\n-\t\tv_may_def_var = v_may_def;\n-\n-\t    if (vuse_var == v_may_def_var)\n-\t      {\n-\t\tfound = true;\n+\t      if (vuse == VARRAY_TREE (build_v_may_defs, j))\n \t\tbreak;\n-\t      }\n \t    }\n \n \t  /* If we found a useless VUSE operand, remove it from the\n \t     operand array by replacing it with the last active element\n \t     in the operand array (unless the useless VUSE was the\n \t     last operand, in which case we simply remove it.  */\n-\t  if (found)\n+\t  if (j != num_v_may_defs)\n \t    {\n \t      if (i != VARRAY_ACTIVE_SIZE (build_vuses) - 1)\n \t\t{\n@@ -421,63 +546,167 @@ finalize_ssa_vuses (tree stmt)\n   num = VARRAY_ACTIVE_SIZE (build_vuses);\n   /* We could have reduced the size to zero now, however.  */\n   if (num == 0)\n-    return;\n+    {\n+      VARRAY_POP_ALL (build_v_may_defs);\n+      return NULL;\n+    }\n+\n+  old_ops = *old_ops_p;\n+\n+  /* Determine whether vuses is the same as the old vector.  */\n+  build_diff = true;\n+  if (old_ops && old_ops->num_vuses == num)\n+    {\n+      old_num = num;\n+      build_diff = false;\n+      for (x = 0; x < num ; x++)\n+        {\n+\t  tree v;\n+\t  v = old_ops->vuses[x];\n+\t  if (TREE_CODE (v) == SSA_NAME)\n+\t    v = SSA_NAME_VAR (v);\n+\t  if (v != VARRAY_TREE (build_vuses, x))\n+\t    {\n+\t      build_diff = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    old_num = (old_ops ? old_ops->num_vuses : 0);\n \n-  vuse_ops = allocate_vuse_optype (num);\n-  for (x = 0; x < num; x++)\n-    vuse_ops->vuses[x] = VARRAY_TREE (build_vuses, x);\n-  VARRAY_CLEAR (build_vuses);\n-  ann->vuse_ops = vuse_ops;\n+  if (!build_diff)\n+    {\n+      vuse_ops = old_ops;\n+      *old_ops_p = NULL;\n+    }\n+  else\n+    {\n+      vuse_ops = allocate_vuse_optype (num);\n+      for (x = 0; x < num; x++)\n+        {\n+\t  tree result, var = VARRAY_TREE (build_vuses, x);\n+\t  /* Look for VAR in the old vector, and use that SSA_NAME.  */\n+\t  for (i = 0; i < old_num; i++)\n+\t    {\n+\t      result = old_ops->vuses[i];\n+\t      if (TREE_CODE (result) == SSA_NAME)\n+\t\tresult = SSA_NAME_VAR (result);\n+\t      if (result == var)\n+\t        {\n+\t\t  vuse_ops->vuses[x] = old_ops->vuses[i];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (i == old_num)\n+\t    vuse_ops->vuses[x] = var;\n+\t}\n+    }\n+\n+  /* The v_may_def build vector wasn't freed because we needed it here.\n+     Free it now with the vuses build vector.  */\n+  VARRAY_POP_ALL (build_vuses);\n+  VARRAY_POP_ALL (build_v_may_defs);\n+\n+  return vuse_ops;\n }\n \n-static void\n-finalize_ssa_v_must_defs (tree stmt)\n+\n+/* Return a new v_must_def operand vector for STMT, comparing to OLD_OPS_P.  */\n+\n+static v_must_def_optype\n+finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p, \n+\t\t\t  tree stmt ATTRIBUTE_UNUSED)\n {\n-  unsigned num, x;\n-  stmt_ann_t ann;\n-  v_must_def_optype v_must_def_ops;\n+  unsigned num, x, i, old_num = 0;\n+  v_must_def_optype v_must_def_ops, old_ops;\n+  bool build_diff;\n \n   num = VARRAY_ACTIVE_SIZE (build_v_must_defs);\n   if (num == 0)\n-    return;\n+    return NULL;\n \n #ifdef ENABLE_CHECKING\n   /* There should only be a single V_MUST_DEF per assignment.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR && num > 1)\n     abort ();\n #endif\n \n-  v_must_def_ops = allocate_v_must_def_optype (num);\n-  for (x = 0; x < num ; x++)\n-    v_must_def_ops->v_must_defs[x] = VARRAY_TREE (build_v_must_defs, x);\n+  old_ops = *old_ops_p;\n+\n+  /* Check if the old vector and the new array are the same.  */\n+  build_diff = true;\n+  if (old_ops && old_ops->num_v_must_defs == num)\n+    {\n+      old_num = num;\n+      build_diff = false;\n+      for (x = 0; x < num; x++)\n+        {\n+\t  tree var = old_ops->v_must_defs[x];\n+\t  if (TREE_CODE (var) == SSA_NAME)\n+\t    var = SSA_NAME_VAR (var);\n+\t  if (var != VARRAY_TREE (build_v_must_defs, x))\n+\t    {\n+\t      build_diff = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    old_num = (old_ops ? old_ops->num_v_must_defs : 0);\n+\n+  if (!build_diff)\n+    {\n+      v_must_def_ops = old_ops;\n+      *old_ops_p = NULL;\n+    }\n+  else\n+    {\n+      v_must_def_ops = allocate_v_must_def_optype (num);\n+      for (x = 0; x < num ; x++)\n+\t{\n+\t  tree result, var = VARRAY_TREE (build_v_must_defs, x);\n+\t  /* Look for VAR in the original vector.  */\n+\t  for (i = 0; i < old_num; i++)\n+\t    {\n+\t      result = old_ops->v_must_defs[i];\n+\t      if (TREE_CODE (result) == SSA_NAME)\n+\t\tresult = SSA_NAME_VAR (result);\n+\t      if (result == var)\n+\t        {\n+\t\t  v_must_def_ops->v_must_defs[x] = old_ops->v_must_defs[i];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (i == old_num)\n+\t    v_must_def_ops->v_must_defs[x] = var;\n+\t}\n+    }\n   VARRAY_POP_ALL (build_v_must_defs);\n \n-  ann = stmt_ann (stmt);\n-  ann->v_must_def_ops = v_must_def_ops;\n+  return v_must_def_ops;\n }\n \n-extern void\n-finalize_ssa_stmt_operands (tree stmt)\n-{\n-#ifdef ENABLE_CHECKING\n-  if (check_build_stmt == NULL)\n-    abort();\n-#endif\n \n-  finalize_ssa_defs (stmt);\n-  finalize_ssa_uses (stmt);\n-  finalize_ssa_v_must_defs (stmt);\n-  finalize_ssa_v_may_defs (stmt);\n-  finalize_ssa_vuses (stmt);\n+/* Finalize all the build vectors, fill the new ones into INFO.  */\n \n-#ifdef ENABLE_CHECKING\n-  check_build_stmt = NULL;\n-#endif\n+static inline void\n+finalize_ssa_stmt_operands (tree stmt, stmt_operands_p old_ops, \n+\t\t\t    stmt_operands_p new_ops)\n+{\n+  new_ops->def_ops = finalize_ssa_defs (&(old_ops->def_ops), stmt);\n+  new_ops->use_ops = finalize_ssa_uses (&(old_ops->use_ops), stmt);\n+  new_ops->v_must_def_ops \n+    = finalize_ssa_v_must_defs (&(old_ops->v_must_def_ops), stmt);\n+  new_ops->v_may_def_ops = finalize_ssa_v_may_defs (&(old_ops->v_may_def_ops));\n+  new_ops->vuse_ops = finalize_ssa_vuses (&(old_ops->vuse_ops));\n }\n \n \n-extern void\n-verify_start_operands (tree stmt ATTRIBUTE_UNUSED)\n+/* Start the process of building up operands vectors in INFO.  */\n+\n+static inline void\n+start_ssa_stmt_operands (void)\n {\n #ifdef ENABLE_CHECKING\n   if (VARRAY_ACTIVE_SIZE (build_defs) > 0 \n@@ -486,276 +715,121 @@ verify_start_operands (tree stmt ATTRIBUTE_UNUSED)\n       || VARRAY_ACTIVE_SIZE (build_v_may_defs) > 0\n       || VARRAY_ACTIVE_SIZE (build_v_must_defs) > 0)\n     abort ();\n-  if (check_build_stmt != NULL)\n-    abort();\n-  check_build_stmt = stmt;\n #endif\n }\n \n \n-/* Add DEF_P to the list of pointers to operands defined by STMT.  */\n+/* Add DEF_P to the list of pointers to operands.  */\n \n static inline void\n-append_def (tree *def_p, tree stmt ATTRIBUTE_UNUSED)\n+append_def (tree *def_p)\n {\n-#ifdef ENABLE_CHECKING\n-  if (check_build_stmt != stmt)\n-    abort();\n-#endif\n   VARRAY_PUSH_TREE_PTR (build_defs, def_p);\n }\n \n \n-/* Add USE_P to the list of pointers to operands used by STMT.  */\n+/* Add USE_P to the list of pointers to operands.  */\n \n static inline void\n-append_use (tree *use_p, tree stmt ATTRIBUTE_UNUSED)\n+append_use (tree *use_p)\n {\n-#ifdef ENABLE_CHECKING\n-  if (check_build_stmt != stmt)\n-    abort();\n-#endif\n   VARRAY_PUSH_TREE_PTR (build_uses, use_p);\n }\n \n \n-/* Add a new virtual def for variable VAR to statement STMT.  If PREV_VOPS\n-   is not NULL, the existing entries are preserved and no new entries are\n-   added here.  This is done to preserve the SSA numbering of virtual\n-   operands.  */\n+/* Add a new virtual may def for variable VAR to the build array.  */\n \n-static void\n-append_v_may_def (tree var, tree stmt, voperands_t prev_vops)\n+static inline void\n+append_v_may_def (tree var)\n {\n-  stmt_ann_t ann;\n-  size_t i;\n-  tree result, source;\n-\n-#ifdef ENABLE_CHECKING\n-  if (check_build_stmt != stmt)\n-    abort();\n-#endif\n-\n-  ann = stmt_ann (stmt);\n+  unsigned i;\n \n   /* Don't allow duplicate entries.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_may_defs); i++)\n+    if (var == VARRAY_TREE (build_v_may_defs, i))\n+      return;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_may_defs); i += 2)\n-    {\n-      tree result = VARRAY_TREE (build_v_may_defs, i);\n-      if (var == result\n-\t  || (TREE_CODE (result) == SSA_NAME\n-\t      && var == SSA_NAME_VAR (result)))\n-\treturn;\n-    }\n-\n-  /* If the statement already had virtual definitions, see if any of the\n-     existing V_MAY_DEFs matches VAR.  If so, re-use it, otherwise add a new\n-     V_MAY_DEF for VAR.  */\n-  result = NULL_TREE;\n-  source = NULL_TREE;\n-  if (prev_vops)\n-    for (i = 0; i < NUM_V_MAY_DEFS (prev_vops->v_may_def_ops); i++)\n-      {\n-\tresult = V_MAY_DEF_RESULT (prev_vops->v_may_def_ops, i);\n-\tif (result == var\n-\t    || (TREE_CODE (result) == SSA_NAME\n-\t\t&& SSA_NAME_VAR (result) == var))\n-\t  {\n-\t    source = V_MAY_DEF_OP (prev_vops->v_may_def_ops, i);\n-\t    break;\n-\t  }\n-      }\n-\n-  /* If no previous V_MAY_DEF operand was found for VAR, create one now.  */\n-  if (source == NULL_TREE)\n-    {\n-      result = var;\n-      source = var;\n-    }\n-\n-  VARRAY_PUSH_TREE (build_v_may_defs, result);\n-  VARRAY_PUSH_TREE (build_v_may_defs, source);\n+  VARRAY_PUSH_TREE (build_v_may_defs, var);\n }\n \n \n-/* Add VAR to the list of virtual uses for STMT.  If PREV_VOPS\n-   is not NULL, the existing entries are preserved and no new entries are\n-   added here.  This is done to preserve the SSA numbering of virtual\n-   operands.  */\n+/* Add VAR to the list of virtual uses.  */\n \n-static void\n-append_vuse (tree var, tree stmt, voperands_t prev_vops)\n+static inline void\n+append_vuse (tree var)\n {\n-  stmt_ann_t ann;\n   size_t i;\n-  bool found;\n-  tree vuse;\n-\n-#ifdef ENABLE_CHECKING\n-  if (check_build_stmt != stmt)\n-    abort();\n-#endif\n-\n-  ann = stmt_ann (stmt);\n \n   /* Don't allow duplicate entries.  */\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vuses); i++)\n-    {\n-      tree vuse_var = VARRAY_TREE (build_vuses, i);\n-      if (var == vuse_var\n-\t  || (TREE_CODE (vuse_var) == SSA_NAME\n-\t      && var == SSA_NAME_VAR (vuse_var)))\n-\treturn;\n-    }\n-\n-  /* If the statement already had virtual uses, see if any of the\n-     existing VUSEs matches VAR.  If so, re-use it, otherwise add a new\n-     VUSE for VAR.  */\n-  found = false;\n-  vuse = NULL_TREE;\n-  if (prev_vops)\n-    for (i = 0; i < NUM_VUSES (prev_vops->vuse_ops); i++)\n-      {\n-\tvuse = VUSE_OP (prev_vops->vuse_ops, i);\n-\tif (vuse == var\n-\t    || (TREE_CODE (vuse) == SSA_NAME\n-\t\t&& SSA_NAME_VAR (vuse) == var))\n-\t  {\n-\t    found = true;\n-\t    break;\n-\t  }\n-      }\n-\n-  /* If VAR existed already in PREV_VOPS, re-use it.  */\n-  if (found)\n-    var = vuse;\n+    if (var == VARRAY_TREE (build_vuses, i))\n+      return;\n \n   VARRAY_PUSH_TREE (build_vuses, var);\n }\n \n-/* Add VAR to the list of virtual must definitions for STMT.  If PREV_VOPS\n-   is not NULL, the existing entries are preserved and no new entries are\n-   added here.  This is done to preserve the SSA numbering of virtual\n-   operands.  */\n \n-static void\n-append_v_must_def (tree var, tree stmt, voperands_t prev_vops)\n-{\n-  stmt_ann_t ann;\n-  size_t i;\n-  bool found;\n-  tree v_must_def;\n+/* Add VAR to the list of virtual must definitions for INFO.  */\n \n-#ifdef ENABLE_CHECKING\n-  if (check_build_stmt != stmt)\n-    abort();\n-#endif\n-\n-  ann = stmt_ann (stmt);\n+static inline void\n+append_v_must_def (tree var)\n+{\n+  unsigned i;\n \n   /* Don't allow duplicate entries.  */\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_must_defs); i++)\n-    {\n-      tree v_must_def_var = VARRAY_TREE (build_v_must_defs, i);\n-      if (var == v_must_def_var\n-\t  || (TREE_CODE (v_must_def_var) == SSA_NAME\n-\t      && var == SSA_NAME_VAR (v_must_def_var)))\n-\treturn;\n-    }\n-\n-  /* If the statement already had virtual must defs, see if any of the\n-     existing V_MUST_DEFs matches VAR.  If so, re-use it, otherwise add a new\n-     V_MUST_DEF for VAR.  */\n-  found = false;\n-  v_must_def = NULL_TREE;\n-  if (prev_vops)\n-    for (i = 0; i < NUM_V_MUST_DEFS (prev_vops->v_must_def_ops); i++)\n-      {\n-\tv_must_def = V_MUST_DEF_OP (prev_vops->v_must_def_ops, i);\n-\tif (v_must_def == var\n-\t    || (TREE_CODE (v_must_def) == SSA_NAME\n-\t\t&& SSA_NAME_VAR (v_must_def) == var))\n-\t  {\n-\t    found = true;\n-\t    break;\n-\t  }\n-      }\n-\n-  /* If VAR existed already in PREV_VOPS, re-use it.  */\n-  if (found)\n-    var = v_must_def;\n+    if (var == VARRAY_TREE (build_v_must_defs, i))\n+      return;\n \n   VARRAY_PUSH_TREE (build_v_must_defs, var);\n }\n \n+/* Create an operands cache for STMT, returning it in NEW_OPS. OLD_OPS are the\n+   original operands, and if ANN is non-null, appropriate stmt flags are set\n+   in the stmt's annotation.  Note that some fields in old_ops may \n+   change to NULL, although none of the memory they originally pointed to \n+   will be destroyed.  It is appropriate to call free_stmt_operands() on \n+   the value returned in old_ops.\n \n-/* External entry point which by-passes the previous vops mechanism.  */\n-void\n-add_vuse (tree var, tree stmt)\n-{\n-  append_vuse (var, stmt, NULL);\n-}\n+   The rationale for this: Certain optimizations wish to exmaine the difference\n+   between new_ops and old_ops after processing.  If a set of operands don't\n+   change, new_ops will simply assume the pointer in old_ops, and the old_ops\n+   pointer will be set to NULL, indicating no memory needs to be cleared.  \n+   Usage might appear something like:\n \n-\n-/* Get the operands of statement STMT.  Note that repeated calls to\n-   get_stmt_operands for the same statement will do nothing until the\n-   statement is marked modified by a call to modify_stmt().  */\n+       old_ops_copy = old_ops = stmt_ann(stmt)->operands;\n+       build_ssa_operands (stmt, NULL, &old_ops, &new_ops);\n+          <* compare old_ops_copy and new_ops *>\n+       free_ssa_operands (old_ops);\t\t\t\t\t*/\n \n void\n-get_stmt_operands (tree stmt)\n+build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops, \n+\t\t    stmt_operands_p new_ops)\n {\n   enum tree_code code;\n-  stmt_ann_t ann;\n-  struct voperands_d prev_vops;\n-\n-#if defined ENABLE_CHECKING\n-  /* The optimizers cannot handle statements that are nothing but a\n-     _DECL.  This indicates a bug in the gimplifier.  */\n-  if (SSA_VAR_P (stmt))\n-    abort ();\n-#endif\n-\n-  /* Ignore error statements.  */\n-  if (TREE_CODE (stmt) == ERROR_MARK)\n-    return;\n-\n-  ann = get_stmt_ann (stmt);\n-\n-  /* If the statement has not been modified, the operands are still valid.  */\n-  if (!ann->modified)\n-    return;\n-\n-  timevar_push (TV_TREE_OPS);\n-\n+  tree_ann_t saved_ann = stmt->common.ann;\n+  \n+  /* Replace stmt's annotation with the one passed in for the duration\n+     of the operand building process.  This allows \"fake\" stmts to be built\n+     and not be included in other data structures which can be built here.  */\n+  stmt->common.ann = (tree_ann_t) ann;\n+  \n   /* Initially assume that the statement has no volatile operands, nor\n      makes aliased loads or stores.  */\n-  ann->has_volatile_ops = false;\n-  ann->makes_aliased_stores = false;\n-  ann->makes_aliased_loads = false;\n-\n-  /* Remove any existing operands as they will be scanned again.  */\n-  free_defs (&(ann->def_ops), true);\n-  free_uses (&(ann->use_ops), true);\n-\n-  /* Before removing existing virtual operands, save them in PREV_VOPS so \n-     that we can re-use their SSA versions.  */\n-  prev_vops.v_may_def_ops = V_MAY_DEF_OPS (ann);\n-  prev_vops.vuse_ops = VUSE_OPS (ann);\n-  prev_vops.v_must_def_ops = V_MUST_DEF_OPS (ann);\n-\n-  /* Don't free the previous values to memory since we're still using them.  */\n-  free_v_may_defs (&(ann->v_may_def_ops), false);\n-  free_vuses (&(ann->vuse_ops), false);\n-  free_v_must_defs (&(ann->v_must_def_ops), false);\n+  if (ann)\n+    {\n+      ann->has_volatile_ops = false;\n+      ann->makes_aliased_stores = false;\n+      ann->makes_aliased_loads = false;\n+    }\n \n-  start_ssa_stmt_operands (stmt);\n+  start_ssa_stmt_operands ();\n \n   code = TREE_CODE (stmt);\n   switch (code)\n     {\n     case MODIFY_EXPR:\n-      get_expr_operands (stmt, &TREE_OPERAND (stmt, 1), opf_none, &prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (stmt, 1), opf_none);\n       if (TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_REF \n \t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_RANGE_REF\n \t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == COMPONENT_REF\n@@ -765,35 +839,34 @@ get_stmt_operands (tree stmt)\n \t     modified in that case.  FIXME we should represent somehow\n \t     that it is killed on the fallthrough path.  */\n \t  || tree_could_throw_p (TREE_OPERAND (stmt, 1)))\n-        get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_is_def, \n-\t                   &prev_vops);\n+        get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_is_def);\n       else\n         get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), \n-\t                   opf_is_def | opf_kill_def, &prev_vops);\n+\t                   opf_is_def | opf_kill_def);\n       break;\n \n     case COND_EXPR:\n-      get_expr_operands (stmt, &COND_EXPR_COND (stmt), opf_none, &prev_vops);\n+      get_expr_operands (stmt, &COND_EXPR_COND (stmt), opf_none);\n       break;\n \n     case SWITCH_EXPR:\n-      get_expr_operands (stmt, &SWITCH_COND (stmt), opf_none, &prev_vops);\n+      get_expr_operands (stmt, &SWITCH_COND (stmt), opf_none);\n       break;\n \n     case ASM_EXPR:\n-      get_asm_expr_operands (stmt, &prev_vops);\n+      get_asm_expr_operands (stmt);\n       break;\n \n     case RETURN_EXPR:\n-      get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_none, &prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_none);\n       break;\n \n     case GOTO_EXPR:\n-      get_expr_operands (stmt, &GOTO_DESTINATION (stmt), opf_none, &prev_vops);\n+      get_expr_operands (stmt, &GOTO_DESTINATION (stmt), opf_none);\n       break;\n \n     case LABEL_EXPR:\n-      get_expr_operands (stmt, &LABEL_EXPR_LABEL (stmt), opf_none, &prev_vops);\n+      get_expr_operands (stmt, &LABEL_EXPR_LABEL (stmt), opf_none);\n       break;\n \n       /* These nodes contain no variable references.  */\n@@ -812,16 +885,67 @@ get_stmt_operands (tree stmt)\n \t append_use.  This default will handle statements like empty\n \t statements, or CALL_EXPRs that may appear on the RHS of a statement\n \t or as statements themselves.  */\n-      get_expr_operands (stmt, &stmt, opf_none, &prev_vops);\n+      get_expr_operands (stmt, &stmt, opf_none);\n       break;\n     }\n \n-  finalize_ssa_stmt_operands (stmt);\n+  finalize_ssa_stmt_operands (stmt, old_ops, new_ops);\n+  stmt->common.ann = saved_ann;\n+}\n+\n+\n+/* Free any operands vectors in OPS.  */\n+\n+static void \n+free_ssa_operands (stmt_operands_p ops)\n+{\n+  if (ops->def_ops)\n+    free_defs (&(ops->def_ops));\n+  if (ops->use_ops)\n+    free_uses (&(ops->use_ops));\n+  if (ops->vuse_ops)\n+    free_vuses (&(ops->vuse_ops));\n+  if (ops->v_may_def_ops)\n+    free_v_may_defs (&(ops->v_may_def_ops));\n+  if (ops->v_must_def_ops)\n+    free_v_must_defs (&(ops->v_must_def_ops));\n+}\n+\n+\n+/* Get the operands of statement STMT.  Note that repeated calls to\n+   get_stmt_operands for the same statement will do nothing until the\n+   statement is marked modified by a call to modify_stmt().  */\n+\n+void\n+get_stmt_operands (tree stmt)\n+{\n+  stmt_ann_t ann;\n+  stmt_operands_t old_operands;\n+\n+#if defined ENABLE_CHECKING\n+  /* The optimizers cannot handle statements that are nothing but a\n+     _DECL.  This indicates a bug in the gimplifier.  */\n+  if (SSA_VAR_P (stmt))\n+    abort ();\n+#endif\n+\n+  /* Ignore error statements.  */\n+  if (TREE_CODE (stmt) == ERROR_MARK)\n+    return;\n+\n+  ann = get_stmt_ann (stmt);\n+\n+  /* If the statement has not been modified, the operands are still valid.  */\n+  if (!ann->modified)\n+    return;\n+\n+  timevar_push (TV_TREE_OPS);\n+\n+  old_operands = ann->operands;\n+  memset (&(ann->operands), 0, sizeof (stmt_operands_t));\n \n-  /* Now free the previous virtual ops to memory.  */\n-  free_v_may_defs (&(prev_vops.v_may_def_ops), true);\n-  free_vuses (&(prev_vops.vuse_ops), true);\n-  free_v_must_defs (&(prev_vops.v_must_def_ops), true);\n+  build_ssa_operands (stmt, ann, &old_operands, &(ann->operands));\n+  free_ssa_operands (&old_operands);\n \n   /* Clear the modified bit for STMT.  Subsequent calls to\n      get_stmt_operands for this statement will do nothing until the\n@@ -832,12 +956,12 @@ get_stmt_operands (tree stmt)\n }\n \n \n-/* Recursively scan the expression pointed by EXPR_P in statement STMT.\n-   FLAGS is one of the OPF_* constants modifying how to interpret the\n-   operands found.  PREV_VOPS is as in append_v_may_def and append_vuse.  */\n+/* Recursively scan the expression pointed by EXPR_P in statement referred to\n+   by INFO.  FLAGS is one of the OPF_* constants modifying how to interpret the\n+   operands found.  */\n \n static void\n-get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n+get_expr_operands (tree stmt, tree *expr_p, int flags)\n {\n   enum tree_code code;\n   char class;\n@@ -855,9 +979,9 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       /* We could have the address of a component, array member,\n \t etc which has interesting variable references.  */\n       /* Taking the address of a variable does not represent a\n-\t reference to it, but the fact that STMT takes its address will be\n+\t reference to it, but the fact that the stmt takes its address will be\n \t of interest to some passes (e.g. alias resolution).  */\n-      add_stmt_operand (expr_p, stmt, 0, NULL);\n+      add_stmt_operand (expr_p, stmt, 0);\n \n       /* If the address is invariant, there may be no interesting variable\n \t references inside.  */\n@@ -870,7 +994,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \t does not allow non-registers as array indices).  */\n       flags |= opf_no_vops;\n \n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case SSA_NAME:\n@@ -879,11 +1003,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n     case RESULT_DECL:\n       /* If we found a variable, add it to DEFS or USES depending\n \t on the operand flags.  */\n-      add_stmt_operand (expr_p, stmt, flags, prev_vops);\n+      add_stmt_operand (expr_p, stmt, flags);\n       return;\n \n     case INDIRECT_REF:\n-      get_indirect_ref_operands (stmt, expr, flags, prev_vops);\n+      get_indirect_ref_operands (stmt, expr, flags);\n       return;\n \n     case ARRAY_REF:\n@@ -896,13 +1020,13 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \t according to the value of IS_DEF.  Recurse if the LHS of the\n \t ARRAY_REF node is not a regular variable.  */\n       if (SSA_VAR_P (TREE_OPERAND (expr, 0)))\n-\tadd_stmt_operand (expr_p, stmt, flags, prev_vops);\n+\tadd_stmt_operand (expr_p, stmt, flags);\n       else\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n \n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none, prev_vops);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none, prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none);\n       return;\n \n     case COMPONENT_REF:\n@@ -924,31 +1048,31 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       /* If the LHS of the compound reference is not a regular variable,\n \t recurse to keep looking for more operands in the subexpression.  */\n       if (SSA_VAR_P (TREE_OPERAND (expr, 0)))\n-\tadd_stmt_operand (expr_p, stmt, flags, prev_vops);\n+\tadd_stmt_operand (expr_p, stmt, flags);\n       else\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n \n       if (code == COMPONENT_REF)\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n       return;\n \n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR is a pass-through reference to its first argument,\n \t and an rvalue reference to its second argument.  */\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none, prev_vops);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case CALL_EXPR:\n-      get_call_expr_operands (stmt, expr, prev_vops);\n+      get_call_expr_operands (stmt, expr);\n       return;\n \n     case MODIFY_EXPR:\n       {\n \tint subflags;\n \ttree op;\n \n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n \n \top = TREE_OPERAND (expr, 0);\n \tif (TREE_CODE (op) == WITH_SIZE_EXPR)\n@@ -962,7 +1086,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \telse\n \t  subflags = opf_is_def | opf_kill_def;\n \n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), subflags, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), subflags);\n \treturn;\n       }\n \n@@ -973,7 +1097,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \n \ttree t;\n \tfor (t = TREE_OPERAND (expr, 0); t ; t = TREE_CHAIN (t))\n-\t  get_expr_operands (stmt, &TREE_VALUE (t), opf_none, prev_vops);\n+\t  get_expr_operands (stmt, &TREE_VALUE (t), opf_none);\n \n \treturn;\n       }\n@@ -982,7 +1106,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n     case BIT_FIELD_REF:\n     case VIEW_CONVERT_EXPR:\n     do_unary:\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case TRUTH_AND_EXPR:\n@@ -1023,8 +1147,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \t      }\n \t  }\n \n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n \treturn;\n       }\n \n@@ -1053,20 +1177,19 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n }\n \n \n-/* Scan operands in ASM_EXPR STMT.  PREV_VOPS is as in append_v_may_def and\n-   append_vuse.  */\n+/* Scan operands in the ASM_EXPR stmt refered to in INFO.  */\n \n static void\n-get_asm_expr_operands (tree stmt, voperands_t prev_vops)\n+get_asm_expr_operands (tree stmt)\n {\n+  stmt_ann_t s_ann = stmt_ann (stmt);\n   int noutputs = list_length (ASM_OUTPUTS (stmt));\n   const char **oconstraints\n     = (const char **) alloca ((noutputs) * sizeof (const char *));\n   int i;\n   tree link;\n   const char *constraint;\n   bool allows_mem, allows_reg, is_inout;\n-  stmt_ann_t s_ann = stmt_ann (stmt);\n \n   for (i=0, link = ASM_OUTPUTS (stmt); link; ++i, link = TREE_CHAIN (link))\n     {\n@@ -1090,7 +1213,7 @@ get_asm_expr_operands (tree stmt, voperands_t prev_vops)\n \t    note_addressable (t, s_ann);\n \t}\n \n-      get_expr_operands (stmt, &TREE_VALUE (link), opf_is_def, prev_vops);\n+      get_expr_operands (stmt, &TREE_VALUE (link), opf_is_def);\n     }\n \n   for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n@@ -1109,7 +1232,7 @@ get_asm_expr_operands (tree stmt, voperands_t prev_vops)\n \t    note_addressable (t, s_ann);\n \t}\n \n-      get_expr_operands (stmt, &TREE_VALUE (link), 0, prev_vops);\n+      get_expr_operands (stmt, &TREE_VALUE (link), 0);\n     }\n \n \n@@ -1122,19 +1245,19 @@ get_asm_expr_operands (tree stmt, voperands_t prev_vops)\n \t/* Clobber all call-clobbered variables (or .GLOBAL_VAR if we\n \t   decided to group them).  */\n \tif (global_var)\n-\t  add_stmt_operand (&global_var, stmt, opf_is_def, prev_vops);\n+\t  add_stmt_operand (&global_var, stmt, opf_is_def);\n \telse\n \t  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n \t      {\n \t\ttree var = referenced_var (i);\n-\t\tadd_stmt_operand (&var, stmt, opf_is_def, prev_vops);\n+\t\tadd_stmt_operand (&var, stmt, opf_is_def);\n \t      });\n \n \t/* Now clobber all addressables.  */\n \tEXECUTE_IF_SET_IN_BITMAP (addressable_vars, 0, i,\n \t    {\n \t      tree var = referenced_var (i);\n-\t      add_stmt_operand (&var, stmt, opf_is_def, prev_vops);\n+\t      add_stmt_operand (&var, stmt, opf_is_def);\n \t    });\n \n \tbreak;\n@@ -1144,11 +1267,12 @@ get_asm_expr_operands (tree stmt, voperands_t prev_vops)\n /* A subroutine of get_expr_operands to handle INDIRECT_REF.  */\n \n static void\n-get_indirect_ref_operands (tree stmt, tree expr, int flags,\n-\t\t\t   voperands_t prev_vops)\n+get_indirect_ref_operands (tree stmt, tree expr, int flags)\n {\n   tree *pptr = &TREE_OPERAND (expr, 0);\n   tree ptr = *pptr;\n+  stmt_ann_t ann = stmt_ann (stmt);\n+\n \n   if (SSA_VAR_P (ptr))\n     {\n@@ -1160,7 +1284,7 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n \t  && pi->name_mem_tag)\n \t{\n \t  /* PTR has its own memory tag.  Use it.  */\n-\t  add_stmt_operand (&pi->name_mem_tag, stmt, flags, prev_vops);\n+\t  add_stmt_operand (&pi->name_mem_tag, stmt, flags);\n \t}\n       else\n \t{\n@@ -1187,7 +1311,7 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n \t    ptr = SSA_NAME_VAR (ptr);\n \t  ann = var_ann (ptr);\n \t  if (ann->type_mem_tag)\n-\t    add_stmt_operand (&ann->type_mem_tag, stmt, flags, prev_vops);\n+\t    add_stmt_operand (&ann->type_mem_tag, stmt, flags);\n \t}\n     }\n \n@@ -1196,7 +1320,8 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n      optimizations from messing things up.  */\n   else if (TREE_CODE (ptr) == INTEGER_CST)\n     {\n-      stmt_ann (stmt)->has_volatile_ops = true;\n+      if (ann)\n+\tann->has_volatile_ops = true;\n       return;\n     }\n \n@@ -1211,11 +1336,11 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n     {\n       /* Make sure we know the object is addressable.  */\n       pptr = &TREE_OPERAND (ptr, 0);\n-      add_stmt_operand (pptr, stmt, 0, NULL);\n+      add_stmt_operand (pptr, stmt, 0);\n \n       /* Mark the object itself with a VUSE.  */\n       pptr = &TREE_OPERAND (*pptr, 0);\n-      get_expr_operands (stmt, pptr, flags, prev_vops);\n+      get_expr_operands (stmt, pptr, flags);\n       return;\n     }\n \n@@ -1224,24 +1349,24 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n     abort ();\n \n   /* Add a USE operand for the base pointer.  */\n-  get_expr_operands (stmt, pptr, opf_none, prev_vops);\n+  get_expr_operands (stmt, pptr, opf_none);\n }\n \n /* A subroutine of get_expr_operands to handle CALL_EXPR.  */\n \n static void\n-get_call_expr_operands (tree stmt, tree expr, voperands_t prev_vops)\n+get_call_expr_operands (tree stmt, tree expr)\n {\n   tree op;\n   int call_flags = call_expr_flags (expr);\n \n   /* Find uses in the called function.  */\n-  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_none, prev_vops);\n+  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_none);\n \n   for (op = TREE_OPERAND (expr, 1); op; op = TREE_CHAIN (op))\n-    get_expr_operands (stmt, &TREE_VALUE (op), opf_none, prev_vops);\n+    get_expr_operands (stmt, &TREE_VALUE (op), opf_none);\n \n-  get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n+  get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n \n   if (bitmap_first_set_bit (call_clobbered_vars) >= 0)\n     {\n@@ -1250,34 +1375,29 @@ get_call_expr_operands (tree stmt, tree expr, voperands_t prev_vops)\n \t there is no point in recording that.  */ \n       if (!(call_flags\n \t    & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n-\tadd_call_clobber_ops (stmt, prev_vops);\n+\tadd_call_clobber_ops (stmt);\n       else if (!(call_flags & (ECF_CONST | ECF_NORETURN)))\n-\tadd_call_read_ops (stmt, prev_vops);\n+\tadd_call_read_ops (stmt);\n     }\n }\n \n \n-/* Add *VAR_P to the appropriate operand array of STMT.  FLAGS is as in\n+/* Add *VAR_P to the appropriate operand array for INFO.  FLAGS is as in\n    get_expr_operands.  If *VAR_P is a GIMPLE register, it will be added to\n    the statement's real operands, otherwise it is added to virtual\n-   operands.\n-\n-   PREV_VOPS is used when adding virtual operands to statements that\n-      already had them (See append_v_may_def and append_vuse).  */\n+   operands.  */\n \n static void\n-add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n+add_stmt_operand (tree *var_p, tree stmt, int flags)\n {\n   bool is_real_op;\n   tree var, sym;\n-  stmt_ann_t s_ann;\n+  stmt_ann_t s_ann = stmt_ann (stmt);\n   var_ann_t v_ann;\n \n   var = *var_p;\n   STRIP_NOPS (var);\n \n-  s_ann = stmt_ann (stmt);\n-\n   /* If the operand is an ADDR_EXPR, add its operand to the list of\n      variables that have had their address taken in this statement.  */\n   if (TREE_CODE (var) == ADDR_EXPR)\n@@ -1303,17 +1423,18 @@ add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n   /* Don't expose volatile variables to the optimizers.  */\n   if (TREE_THIS_VOLATILE (sym))\n     {\n-      s_ann->has_volatile_ops = true;\n+      if (s_ann)\n+\ts_ann->has_volatile_ops = true;\n       return;\n     }\n \n   if (is_real_op)\n     {\n       /* The variable is a GIMPLE register.  Add it to real operands.  */\n       if (flags & opf_is_def)\n-\tappend_def (var_p, stmt);\n+\tappend_def (var_p);\n       else\n-\tappend_use (var_p, stmt);\n+\tappend_use (var_p);\n     }\n   else\n     {\n@@ -1336,23 +1457,24 @@ add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n \t      if (v_ann->is_alias_tag)\n \t        {\n \t\t  /* Alias tagged vars get regular V_MAY_DEF  */\n-\t\t  s_ann->makes_aliased_stores = 1;\n-\t\t  append_v_may_def (var, stmt, prev_vops);\n+\t\t  if (s_ann)\n+\t\t    s_ann->makes_aliased_stores = 1;\n+\t\t  append_v_may_def (var);\n \t\t}\n \t      else if ((flags & opf_kill_def) \n \t                && v_ann->mem_tag_kind == NOT_A_TAG)\n \t        /* V_MUST_DEF for non-aliased non-GIMPLE register \n \t\t   variable definitions. Avoid memory tags.  */\n-\t        append_v_must_def (var, stmt, prev_vops);\n+\t        append_v_must_def (var);\n \t      else\n \t        /* Call-clobbered variables & memory tags get \n \t\t   V_MAY_DEF  */\n-\t\tappend_v_may_def (var, stmt, prev_vops);\n+\t\tappend_v_may_def (var);\n \t    }\n \t  else\n \t    {\n-\t      append_vuse (var, stmt, prev_vops);\n-\t      if (v_ann->is_alias_tag)\n+\t      append_vuse (var);\n+\t      if (s_ann && v_ann->is_alias_tag)\n \t\ts_ann->makes_aliased_loads = 1;\n \t    }\n \t}\n@@ -1374,33 +1496,39 @@ add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n \t\t references to the members of the variable's alias set.\n \t\t This fixes the bug in gcc.c-torture/execute/20020503-1.c.  */\n \t      if (v_ann->is_alias_tag)\n-\t\tappend_v_may_def (var, stmt, prev_vops);\n+\t\tappend_v_may_def (var);\n \n \t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\tappend_v_may_def (VARRAY_TREE (aliases, i), stmt, prev_vops);\n+\t\tappend_v_may_def (VARRAY_TREE (aliases, i));\n \n-\t      s_ann->makes_aliased_stores = 1;\n+\t      if (s_ann)\n+\t\ts_ann->makes_aliased_stores = 1;\n \t    }\n \t  else\n \t    {\n \t      if (v_ann->is_alias_tag)\n-\t\tappend_vuse (var, stmt, prev_vops);\n+\t\tappend_vuse (var);\n \n \t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\tappend_vuse (VARRAY_TREE (aliases, i), stmt, prev_vops);\n+\t\tappend_vuse (VARRAY_TREE (aliases, i));\n \n-\t      s_ann->makes_aliased_loads = 1;\n+\t      if (s_ann)\n+\t\ts_ann->makes_aliased_loads = 1;\n \t    }\n \t}\n     }\n }\n \n+\n /* Record that VAR had its address taken in the statement with annotations\n    S_ANN.  */\n \n static void\n note_addressable (tree var, stmt_ann_t s_ann)\n {\n+  if (!s_ann)\n+    return;\n+\n   var = get_base_address (var);\n   if (var && SSA_VAR_P (var))\n     {\n@@ -1415,18 +1543,19 @@ note_addressable (tree var, stmt_ann_t s_ann)\n    clobbered variables in the function.  */\n \n static void\n-add_call_clobber_ops (tree stmt, voperands_t prev_vops)\n+add_call_clobber_ops (tree stmt)\n {\n   /* Functions that are not const, pure or never return may clobber\n      call-clobbered variables.  */\n-  stmt_ann (stmt)->makes_clobbering_call = true;\n+  if (stmt_ann (stmt))\n+    stmt_ann (stmt)->makes_clobbering_call = true;\n \n   /* If we had created .GLOBAL_VAR earlier, use it.  Otherwise, add \n      a V_MAY_DEF operand for every call clobbered variable.  See \n      compute_may_aliases for the heuristic used to decide whether \n      to create .GLOBAL_VAR or not.  */\n   if (global_var)\n-    add_stmt_operand (&global_var, stmt, opf_is_def, prev_vops);\n+    add_stmt_operand (&global_var, stmt, opf_is_def);\n   else\n     {\n       size_t i;\n@@ -1438,9 +1567,9 @@ add_call_clobber_ops (tree stmt, voperands_t prev_vops)\n \t  /* If VAR is read-only, don't add a V_MAY_DEF, just a \n \t     VUSE operand.  */\n \t  if (!TREE_READONLY (var))\n-\t    add_stmt_operand (&var, stmt, opf_is_def, prev_vops);\n+\t    add_stmt_operand (&var, stmt, opf_is_def);\n \t  else\n-\t    add_stmt_operand (&var, stmt, opf_none, prev_vops);\n+\t    add_stmt_operand (&var, stmt, opf_none);\n \t});\n     }\n }\n@@ -1450,22 +1579,22 @@ add_call_clobber_ops (tree stmt, voperands_t prev_vops)\n    function.  */\n \n static void\n-add_call_read_ops (tree stmt, voperands_t prev_vops)\n+add_call_read_ops (tree stmt)\n {\n   /* Otherwise, if the function is not pure, it may reference memory.  Add\n      a VUSE for .GLOBAL_VAR if it has been created.  Otherwise, add a VUSE\n      for each call-clobbered variable.  See add_referenced_var for the\n      heuristic used to decide whether to create .GLOBAL_VAR.  */\n   if (global_var)\n-    add_stmt_operand (&global_var, stmt, opf_none, prev_vops);\n+    add_stmt_operand (&global_var, stmt, opf_none);\n   else\n     {\n       size_t i;\n \n       EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n \t{\n \t  tree var = referenced_var (i);\n-\t  add_stmt_operand (&var, stmt, opf_none, prev_vops);\n+\t  add_stmt_operand (&var, stmt, opf_none);\n \t});\n     }\n }\n@@ -1475,13 +1604,13 @@ add_call_read_ops (tree stmt, voperands_t prev_vops)\n void\n copy_virtual_operands (tree dst, tree src)\n {\n+  unsigned i;\n   vuse_optype vuses = STMT_VUSE_OPS (src);\n   v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (src);\n   v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (src);\n-  vuse_optype *vuses_new = &stmt_ann (dst)->vuse_ops;\n-  v_may_def_optype *v_may_defs_new = &stmt_ann (dst)->v_may_def_ops;\n-  v_must_def_optype *v_must_defs_new = &stmt_ann (dst)->v_must_def_ops;\n-  unsigned i;\n+  vuse_optype *vuses_new = &stmt_ann (dst)->operands.vuse_ops;\n+  v_may_def_optype *v_may_defs_new = &stmt_ann (dst)->operands.v_may_def_ops;\n+  v_must_def_optype *v_must_defs_new = &stmt_ann (dst)->operands.v_must_def_ops;\n \n   if (vuses)\n     {\n@@ -1509,4 +1638,49 @@ copy_virtual_operands (tree dst, tree src)\n     }\n }\n \n+\n+/* Specifically for use in DOM's expression analysis.  Given a store, we\n+   create an artifical stmt which looks like a load from the store, this can\n+   be used to eliminate redundant loads.  OLD_OPS are the operands from the \n+   store stmt, and NEW_STMT is the new load which reperesent a load of the\n+   values stored.  */\n+\n+void\n+create_ssa_artficial_load_stmt (stmt_operands_p old_ops, tree new_stmt)\n+{\n+  stmt_ann_t ann;\n+  tree op;\n+  stmt_operands_t tmp;\n+  unsigned j;\n+\n+  memset (&tmp, 0, sizeof (stmt_operands_t));\n+  ann = get_stmt_ann (new_stmt);\n+\n+  /* Free operands just in case is was an existing stmt.  */\n+  free_ssa_operands (&(ann->operands));\n+\n+  build_ssa_operands (new_stmt, NULL, &tmp, &(ann->operands));\n+  free_vuses (&(ann->operands.vuse_ops));\n+  free_v_may_defs (&(ann->operands.v_may_def_ops));\n+  free_v_must_defs (&(ann->operands.v_must_def_ops));\n+\n+  /* For each VDEF on the original statement, we want to create a\n+     VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n+     statement.  */\n+  for (j = 0; j < NUM_V_MAY_DEFS (old_ops->v_may_def_ops); j++)\n+    {\n+      op = V_MAY_DEF_RESULT (old_ops->v_may_def_ops, j);\n+      append_vuse (op);\n+    }\n+    \n+  for (j = 0; j < NUM_V_MUST_DEFS (old_ops->v_must_def_ops); j++)\n+    {\n+      op = V_MUST_DEF_OP (old_ops->v_must_def_ops, j);\n+      append_vuse (op);\n+    }\n+\n+  /* Now set the vuses for this new stmt.  */\n+  ann->operands.vuse_ops = finalize_ssa_vuses (&(tmp.vuse_ops));\n+}\n+\n #include \"gt-tree-ssa-operands.h\""}, {"sha": "72aa001a29d8d88088f9c74ab6baa0ea84374f48", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a24f92f6ac24097a3f1873cecb08abf59d1d1d3/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=1a24f92f6ac24097a3f1873cecb08abf59d1d1d3", "patch": "@@ -55,11 +55,19 @@ typedef struct use_optype_d GTY(())\n \n typedef use_optype_t *use_optype;\n \n+/* Operand type which stores a def and a use tree.  */\n+typedef struct v_may_def_operand_type GTY(())\n+{\n+  tree def;\n+  tree use;\n+} v_may_def_operand_type_t;\n+\n /* This represents the MAY_DEFS for a stmt.  */\n typedef struct v_may_def_optype_d GTY(())\n {\n   unsigned num_v_may_defs; \n-  tree GTY((length (\"%h.num_v_may_defs * 2\"))) v_may_defs[1];\n+  struct v_may_def_operand_type GTY((length (\"%h.num_v_may_defs\")))\n+\t\t\t\t\t\t\t      v_may_defs[1];\n } v_may_def_optype_t;\n \n typedef v_may_def_optype_t *v_may_def_optype;\n@@ -82,6 +90,21 @@ typedef struct v_must_def_optype_d GTY(())\n \n typedef v_must_def_optype_t *v_must_def_optype;\n \n+/* This represents the operand cache fora stmt.  */\n+typedef struct stmt_operands_d GTY(())\n+{\n+  /* Statement operands.  */\n+  struct def_optype_d * GTY (()) def_ops;\n+  struct use_optype_d * GTY (()) use_ops;\n+\n+  /* Virtual operands (V_MAY_DEF, VUSE, and V_MUST_DEF).  */\n+  struct v_may_def_optype_d * GTY (()) v_may_def_ops;\n+  struct vuse_optype_d * GTY (()) vuse_ops;\n+  struct v_must_def_optype_d * GTY (()) v_must_def_ops;\n+} stmt_operands_t;\n+\n+typedef stmt_operands_t *stmt_operands_p;\n+\n #define USE_FROM_PTR(OP)\tget_use_from_ptr (OP)\n #define DEF_FROM_PTR(OP)\tget_def_from_ptr (OP)\n #define SET_USE(OP, V)\t\t((*((OP).use)) = (V))\n@@ -157,13 +180,8 @@ typedef v_must_def_optype_t *v_must_def_optype;\n \n extern void init_ssa_operands (void);\n extern void fini_ssa_operands (void);\n-extern void verify_start_operands (tree);\n-extern void finalize_ssa_stmt_operands (tree);\n-void add_vuse (tree, tree);\n extern void get_stmt_operands (tree);\n-extern void remove_vuses (tree);\n-extern void remove_v_may_defs (tree);\n-extern void remove_v_must_defs (tree);\n extern void copy_virtual_operands (tree, tree);\n+extern void create_ssa_artficial_load_stmt (stmt_operands_p, tree);\n \n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}]}