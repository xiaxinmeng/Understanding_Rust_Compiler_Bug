{"sha": "68c989b06ffec3e3c2af0c54c97f1f049876faa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhjOTg5YjA2ZmZlYzNlM2MyYWYwYzU0Yzk3ZjFmMDQ5ODc2ZmFhOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-29T18:51:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-29T18:51:30Z"}, "message": "Moved to gcc-interface.\n\nFrom-SVN: r138260", "tree": {"sha": "9f03a1a76be106e6602a2161a6abf9c0787154e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f03a1a76be106e6602a2161a6abf9c0787154e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68c989b06ffec3e3c2af0c54c97f1f049876faa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c989b06ffec3e3c2af0c54c97f1f049876faa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68c989b06ffec3e3c2af0c54c97f1f049876faa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c989b06ffec3e3c2af0c54c97f1f049876faa8/comments", "author": null, "committer": null, "parents": [{"sha": "54dfd46bffb35c49935053bd9bc2997f77e26902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54dfd46bffb35c49935053bd9bc2997f77e26902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54dfd46bffb35c49935053bd9bc2997f77e26902"}], "stats": {"total": 24678, "additions": 0, "deletions": 24678}, "files": [{"sha": "0a1949f6710ce097b564bfb7a5c0560cdbd14bee", "filename": "gcc/ada/ada-tree.def", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,81 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                       GNAT-SPECIFIC GCC TREE CODES                       *\n- *                                                                          *\n- *                              Specification                               *\n- *                                                                          *\n- *            Copyright (C) 1992-2007, Free Software Foundation, Inc.       *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have received a copy of the GNU General   *\n- * Public License along with GCC; see the file COPYING3.  If not see        *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* A type that is an unconstrained array itself.  This node is never passed\n-   to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n-   is the type of a record containing the template and data.  */\n-\n-DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", tcc_type, 0)\n-\n-/* A reference to an unconstrained array.  This node only exists as an\n-   intermediate node during the translation of a GNAT tree to a GCC tree;\n-   it is never passed to GCC.  The only field used is operand 0, which\n-   is the fat pointer object.  */\n-\n-DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n-\t    tcc_reference, 1)\n-\n-/* An expression that returns an RTL suitable for its type.  Operand 0\n-   is an expression to be evaluated for side effects only.  */\n-DEFTREECODE (NULL_EXPR, \"null_expr\", tcc_expression, 1)\n-\n-/* Same as ADDR_EXPR, except that if the operand represents a bit field,\n-   return the address of the byte containing the bit.  This is used\n-   for the 'Address attribute and never shows up in the tree.  */\n-DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", tcc_reference, 1)\n-\n-/* Here are the tree codes for the statement types known to Ada.  These\n-   must be at the end of this file to allow IS_ADA_STMT to work.  */\n-\n-/* This is how record_code_position and insert_code_for work.  The former\n-   makes this tree node, whose operand is a statement.  The latter inserts\n-   the actual statements into this node.  Gimplification consists of\n-   just returning the inner statement.  */\n-DEFTREECODE (STMT_STMT, \"stmt_stmt\", tcc_statement, 1)\n-\n-/* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n-   loop at the top and bottom, respectively.  LOOP_STMT_UPDATE is the statement\n-   to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n-   statements in the body of the loop.  LOOP_STMT_LABEL points to the LABEL_DECL\n-   of the end label of the loop.  */\n-DEFTREECODE (LOOP_STMT, \"loop_stmt\", tcc_statement, 5)\n-\n-/* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n-   true, will cause the loop to be exited.  If no condition is specified,\n-   the loop is unconditionally exited.  EXIT_STMT_LABEL is the end label\n-   corresponding to the loop to exit.  */\n-DEFTREECODE (EXIT_STMT, \"exit_stmt\", tcc_statement, 2)\n-\n-/* A exception region.  REGION_STMT_BODY is the statement to be executed\n-   inside the region.  REGION_STMT_HANDLE is a statement that represents\n-   the exception handlers (usually a BLOCK_STMT of HANDLE_STMTs).\n-   REGION_STMT_BLOCK is the BLOCK node for the declarative region, if any.  */\n-DEFTREECODE (REGION_STMT, \"region_stmt\", tcc_statement, 3)\n-\n-/* An exception handler.  HANDLER_STMT_ARG is the value to pass to \n-   expand_start_catch, HANDLER_STMT_LIST is the list of statements for the\n-   handler itself, and HANDLER_STMT_BLOCK is the BLOCK node for this\n-   binding. */\n-DEFTREECODE (HANDLER_STMT, \"handler_stmt\", tcc_statement, 3)"}, {"sha": "9c31e46f2672a7e36baba2e99269f57f5a5488c4", "filename": "gcc/ada/ada-tree.h", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,321 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                             A D A - T R E E                              *\n- *                                                                          *\n- *                              C Header File                               *\n- *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have received a copy of the GNU General   *\n- * Public License along with GCC; see the file COPYING3.  If not see        *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n-union lang_tree_node\n-  GTY((desc (\"0\"),\n-       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.t)\")))\n-{\n-  union tree_node GTY((tag (\"0\"))) t;\n-};\n-struct lang_decl GTY(()) {tree t; };\n-struct lang_type GTY(()) {tree t; };\n-\n-/* Define macros to get and set the tree in TYPE_ and DECL_LANG_SPECIFIC.  */\n-#define GET_TYPE_LANG_SPECIFIC(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n-#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\\\n- (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n-  = (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n-     ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type)))   \\\n- ->t = X;\n-\n-#define GET_DECL_LANG_SPECIFIC(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n-#define SET_DECL_LANG_SPECIFIC(NODE, VALUE)\t\\\n- (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-  = (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-     ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl)))   \\\n- ->t = VALUE;\n-\n-/* Flags added to GCC type nodes.  */\n-\n-/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is a\n-   record being used as a fat pointer (only true for RECORD_TYPE).  */\n-#define TYPE_IS_FAT_POINTER_P(NODE) \\\n-  TYPE_LANG_FLAG_0 (RECORD_OR_UNION_CHECK (NODE))\n-\n-#define TYPE_FAT_POINTER_P(NODE)  \\\n-  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_IS_FAT_POINTER_P (NODE))\n-\n-/* For integral types and array types, nonzero if this is a packed array type\n-   used for bit-packed types.  Such types should not be extended to a larger\n-   size or validated against a specified size.  */\n-#define TYPE_PACKED_ARRAY_TYPE_P(NODE) TYPE_LANG_FLAG_0 (NODE)\n-\n-#define TYPE_IS_PACKED_ARRAY_TYPE_P(NODE) \\\n-  ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \\\n-   && TYPE_PACKED_ARRAY_TYPE_P (NODE))\n-\n-/* For INTEGER_TYPE, nonzero if this is a modular type with a modulus that\n-   is not equal to two to the power of its mode's size.  */\n-#define TYPE_MODULAR_P(NODE) TYPE_LANG_FLAG_1 (INTEGER_TYPE_CHECK (NODE))\n-\n-/* For ARRAY_TYPE, nonzero if this type corresponds to a dimension of\n-   an Ada array other than the first.  */\n-#define TYPE_MULTI_ARRAY_P(NODE)  TYPE_LANG_FLAG_1 (ARRAY_TYPE_CHECK (NODE))\n-\n-/* For FUNCTION_TYPE, nonzero if this denotes a function returning an\n-   unconstrained array or record.  */\n-#define TYPE_RETURNS_UNCONSTRAINED_P(NODE) \\\n-  TYPE_LANG_FLAG_1 (FUNCTION_TYPE_CHECK (NODE))\n-\n-/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n-   a justified modular type (will only be true for RECORD_TYPE).  */\n-#define TYPE_JUSTIFIED_MODULAR_P(NODE) \\\n-  TYPE_LANG_FLAG_1 (RECORD_OR_UNION_CHECK (NODE))\n-\n-/* Nonzero in an arithmetic subtype if this is a subtype not known to the\n-   front-end.  */\n-#define TYPE_EXTRA_SUBTYPE_P(NODE) TYPE_LANG_FLAG_2 (NODE)\n-\n-/* Nonzero for composite types if this is a by-reference type.  */\n-#define TYPE_BY_REFERENCE_P(NODE) TYPE_LANG_FLAG_2 (NODE)\n-\n-/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n-   type for an object whose type includes its template in addition to\n-   its value (only true for RECORD_TYPE).  */\n-#define TYPE_CONTAINS_TEMPLATE_P(NODE) \\\n-  TYPE_LANG_FLAG_3 (RECORD_OR_UNION_CHECK (NODE))\n-\n-/* For INTEGER_TYPE, nonzero if this really represents a VAX\n-   floating-point type.  */\n-#define TYPE_VAX_FLOATING_POINT_P(NODE)  \\\n-  TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n-\n-/* True if NODE is a thin pointer.  */\n-#define TYPE_THIN_POINTER_P(NODE)\t\t\t\\\n-  (POINTER_TYPE_P (NODE)\t\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) == RECORD_TYPE\t\\\n-   && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (NODE)))\n-\n-/* True if TYPE is either a fat or thin pointer to an unconstrained\n-   array.  */\n-#define TYPE_FAT_OR_THIN_POINTER_P(NODE) \\\n-  (TYPE_FAT_POINTER_P (NODE) || TYPE_THIN_POINTER_P (NODE))\n-\n-/* For INTEGER_TYPEs, nonzero if the type has a biased representation.  */\n-#define TYPE_BIASED_REPRESENTATION_P(NODE) \\\n-  TYPE_LANG_FLAG_4 (INTEGER_TYPE_CHECK (NODE))\n-\n-/* For ARRAY_TYPEs, nonzero if the array type has Convention_Fortran.  */\n-#define TYPE_CONVENTION_FORTRAN_P(NODE) \\\n-  TYPE_LANG_FLAG_4 (ARRAY_TYPE_CHECK (NODE))\n-\n-/* For FUNCTION_TYPEs, nonzero if the function returns by reference.  */\n-#define TYPE_RETURNS_BY_REF_P(NODE) \\\n-  TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))\n-\n-/* For VOID_TYPE, ENUMERAL_TYPE, UNION_TYPE, and RECORD_TYPE, nonzero if this\n-   is a dummy type, made to correspond to a private or incomplete type.  */\n-#define TYPE_DUMMY_P(NODE) TYPE_LANG_FLAG_4 (NODE)\n-\n-/* True if TYPE is such a dummy type.  */\n-#define TYPE_IS_DUMMY_P(NODE) \\\n-  ((TREE_CODE (NODE) == VOID_TYPE || TREE_CODE (NODE) == RECORD_TYPE\t\\\n-    || TREE_CODE (NODE) == UNION_TYPE || TREE_CODE (NODE) == ENUMERAL_TYPE) \\\n-   && TYPE_DUMMY_P (NODE))\n-\n-/* For FUNCTION_TYPEs, nonzero if function returns by being passed a pointer\n-   to a place to store its result.  */\n-#define TYPE_RETURNS_BY_TARGET_PTR_P(NODE) \\\n-  TYPE_LANG_FLAG_5 (FUNCTION_TYPE_CHECK (NODE))\n-\n-/* For an INTEGER_TYPE, nonzero if TYPE_ACTUAL_BOUNDS is present.  */\n-#define TYPE_HAS_ACTUAL_BOUNDS_P(NODE) \\\n-  TYPE_LANG_FLAG_5 (INTEGER_TYPE_CHECK (NODE))\n-\n-/* For a RECORD_TYPE, nonzero if this was made just to supply needed\n-   padding or alignment.  */\n-#define TYPE_IS_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n-\n-/* True if TYPE can alias any other types.  */\n-#define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n-\n-/* This field is only defined for FUNCTION_TYPE nodes. If the Ada\n-   subprogram contains no parameters passed by copy in/copy out then this\n-   field is 0. Otherwise it points to a list of nodes used to specify the\n-   return values of the out (or in out) parameters that qualify to be passed\n-   by copy in copy out.  It is a CONSTRUCTOR.  For a full description of the\n-   cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n-#define TYPE_CI_CO_LIST(NODE)  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n-\n-/* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n-   modulus. */\n-#define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_MODULUS(NODE, X)  \\\n-  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n-\n-/* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n-   the type corresponding to the Ada index type.  */\n-#define TYPE_INDEX_TYPE(NODE) \\\n-  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_INDEX_TYPE(NODE, X) \\\n-  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n-\n-/* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n-   Digits_Value.  */\n-#define TYPE_DIGITS_VALUE(NODE) \\\n-  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n-#define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n-  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n-\n-/* For numeric types, stores the RM_Size of the type.  */\n-#define TYPE_RM_SIZE_NUM(NODE)\tTYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n-\n-#define TYPE_RM_SIZE(NODE)\t\t\t\t\t\\\n-  (INTEGRAL_TYPE_P (NODE) || TREE_CODE (NODE) == REAL_TYPE\t\\\n-   ? TYPE_RM_SIZE_NUM (NODE) : 0)\n-\n-/* For a RECORD_TYPE that is a fat pointer, point to the type for the\n-   unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n-   to by a thin pointer.  */\n-#define TYPE_UNCONSTRAINED_ARRAY(NODE)  \\\n-  GET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))\n-#define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X)  \\\n-  SET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE), X)\n-\n-/* For other RECORD_TYPEs and all UNION_TYPEs and QUAL_UNION_TYPEs, the Ada\n-   size of the object.  This differs from the GCC size in that it does not\n-   include any rounding up to the alignment of the type.  */\n-#define TYPE_ADA_SIZE(NODE)   \\\n-  GET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE))\n-#define SET_TYPE_ADA_SIZE(NODE, X) \\\n-  SET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE), X)\n-\n-/* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n-   the index type that should be used when the actual bounds are required for\n-   a template.  This is used in the case of packed arrays.  */\n-#define TYPE_ACTUAL_BOUNDS(NODE)   \\\n-  GET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n-#define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n-  SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n-\n-/* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n-   the template and object.\n-\n-   ??? We also put this on an ENUMERAL_TYPE that's dummy.  Technically,\n-   this is a conflict on the minval field, but there doesn't seem to be\n-   simple fix, so we'll live with this kludge for now.  */\n-#define TYPE_OBJECT_RECORD_TYPE(NODE) \\\n-  (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)->type.minval)\n-\n-/* Nonzero in a FUNCTION_DECL that represents a stubbed function\n-   discriminant.  */\n-#define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n-\n-/* Nonzero in a VAR_DECL if it is guaranteed to be constant after having\n-   been elaborated and TREE_READONLY is not set on it.  */\n-#define DECL_READONLY_ONCE_ELAB(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n-\n-/* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n-   is needed to access the object.  */\n-#define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n-\n-/* Nonzero in a FIELD_DECL that is a dummy built for some internal reason.  */\n-#define DECL_INTERNAL_P(NODE) DECL_LANG_FLAG_3 (FIELD_DECL_CHECK (NODE))\n-\n-/* Nonzero if this decl is a PARM_DECL for an Ada array being passed to a\n-   foreign convention subprogram.  */\n-#define DECL_BY_COMPONENT_PTR_P(NODE) DECL_LANG_FLAG_3 (PARM_DECL_CHECK (NODE))\n-\n-/* Nonzero in a FUNCTION_DECL that corresponds to an elaboration procedure.  */\n-#define DECL_ELABORATION_PROC_P(NODE) \\\n-  DECL_LANG_FLAG_3 (FUNCTION_DECL_CHECK (NODE))\n-\n-/* Nonzero if this is a decl for a pointer that points to something which\n-   is readonly.  Used mostly for fat pointers.  */\n-#define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n-\n-/* Nonzero in a FIELD_DECL if there was a record rep clause.  */\n-#define DECL_HAS_REP_P(NODE) DECL_LANG_FLAG_5 (FIELD_DECL_CHECK (NODE))\n-\n-/* Nonzero in a PARM_DECL if we are to pass by descriptor.  */\n-#define DECL_BY_DESCRIPTOR_P(NODE) DECL_LANG_FLAG_5 (PARM_DECL_CHECK (NODE))\n-\n-/* Nonzero in a VAR_DECL if it is a pointer renaming a global object.  */\n-#define DECL_RENAMING_GLOBAL_P(NODE) DECL_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n-\n-/* In a CONST_DECL, points to a VAR_DECL that is allocatable to\n-   memory.  Used when a scalar constant is aliased or has its\n-   address taken.  */\n-#define DECL_CONST_CORRESPONDING_VAR(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))\n-#define SET_DECL_CONST_CORRESPONDING_VAR(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE), X)\n-\n-/* In a FIELD_DECL, points to the FIELD_DECL that was the ultimate\n-   source of the decl.  */\n-#define DECL_ORIGINAL_FIELD(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))\n-#define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE), X)\n-\n-/* In a VAR_DECL, points to the object being renamed if the VAR_DECL is a\n-   renaming pointer, otherwise 0.  Note that this object is guaranteed to\n-   be protected against multiple evaluations.  */\n-#define DECL_RENAMED_OBJECT(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n-#define SET_DECL_RENAMED_OBJECT(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n-\n-/* In a TYPE_DECL, points to the parallel type if any, otherwise 0.  */\n-#define DECL_PARALLEL_TYPE(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))\n-#define SET_DECL_PARALLEL_TYPE(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE), X)\n-\n-/* In a FUNCTION_DECL, points to the stub associated with the function\n-   if any, otherwise 0.  */\n-#define DECL_FUNCTION_STUB(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\n-#define SET_DECL_FUNCTION_STUB(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE), X)\n-\n-/* In a FIELD_DECL corresponding to a discriminant, contains the\n-   discriminant number.  */\n-#define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n-\n-/* Define fields and macros for statements.\n-\n-   Start by defining which tree codes are used for statements.  */\n-#define IS_STMT(NODE)\t\t(STATEMENT_CLASS_P (NODE))\n-#define IS_ADA_STMT(NODE)\t(IS_STMT (NODE)\t\t\t\t\\\n-\t\t\t\t && TREE_CODE (NODE) >= STMT_STMT)\n-\n-#define STMT_STMT_STMT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n-#define LOOP_STMT_TOP_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n-#define LOOP_STMT_BOT_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)\n-#define LOOP_STMT_UPDATE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n-#define LOOP_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n-#define LOOP_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n-#define EXIT_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n-#define EXIT_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n-#define REGION_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 0)\n-#define REGION_STMT_HANDLE(NODE) TREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 1)\n-#define REGION_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 2)\n-#define HANDLER_STMT_ARG(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 0)\n-#define HANDLER_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 1)\n-#define HANDLER_STMT_BLOCK(NODE) TREE_OPERAND_CHECK_CODE(NODE, HANDLER_STMT, 2)"}, {"sha": "5f2191fdec959d4849bfbc7d4666f03515d3c5ae", "filename": "gcc/ada/ada.h", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fada.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fada.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada.h?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,80 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                                  A D A                                   *\n- *                                                                          *\n- *                              C Header File                               *\n- *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have  received  a copy of the GNU General *\n- * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n- * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n- * Boston, MA 02110-1301, USA.                                              *\n- *                                                                          *\n- * As a  special  exception,  if you  link  this file  with other  files to *\n- * produce an executable,  this file does not by itself cause the resulting *\n- * executable to be covered by the GNU General Public License. This except- *\n- * ion does not  however invalidate  any other reasons  why the  executable *\n- * file might be covered by the  GNU Public License.                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* This file contains some standard macros for performing Ada-like\n-   operations. These are used to aid in the translation of other headers. */\n-\n-#ifndef GCC_ADA_H\n-#define GCC_ADA_H\n-\n-/* Inlined functions in header are preceded by INLINE, which is normally set\n-   to extern inline for GCC, but may be set to static for use in standard\n-   ANSI-C.  */\n-\n-#ifndef INLINE\n-#ifdef __GNUC__\n-#define INLINE static inline\n-#else\n-#define INLINE static\n-#endif\n-#endif\n-\n-/* Define a macro to concatenate two strings.  Write it for ANSI C and\n-   for traditional C.  */\n-\n-#ifdef __STDC__\n-#define CAT(A,B) A##B\n-#else\n-#define _ECHO(A) A\n-#define CAT(A,B) ECHO(A)B\n-#endif\n-\n-/* The following macro definition simulates the effect of a declaration of\n-   a subtype, where the first two parameters give the name of the type and\n-   subtype, and the third and fourth parameters give the subtype range. The\n-   effect is to compile a typedef defining the subtype as a synonym for the\n-   type, together with two constants defining the end points.  */\n-\n-#define SUBTYPE(SUBTYPE,TYPE,FIRST,LAST)\t\\\n-  typedef TYPE SUBTYPE;\t\t\t\t\\\n-  enum { CAT (SUBTYPE,__First) = FIRST,\t\t\\\n-         CAT (SUBTYPE,__Last) = LAST };\n-\n-/* The following definitions provide the equivalent of the Ada IN and NOT IN\n-   operators, assuming that the subtype involved has been defined using the\n-   SUBTYPE macro defined above.  */\n-\n-#define IN(VALUE,SUBTYPE) \\\n-  (((VALUE) >= (SUBTYPE) CAT (SUBTYPE,__First)) \\\n-   && ((VALUE) <= (SUBTYPE) CAT (SUBTYPE,__Last)))\n-\n-#endif"}, {"sha": "90ea342f6b5fd7e1c5c6a22833a85142ca2c50aa", "filename": "gcc/ada/cuintp.c", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,142 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                        GNAT COMPILER COMPONENTS                          *\n- *                                                                          *\n- *                               C U I N T P                                *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have received a copy of the GNU General   *\n- * Public License along with GCC; see the file COPYING3.  If not see        *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* This file corresponds to the Ada package body Uintp. It was created\n-   manually from the files uintp.ads and uintp.adb. */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"ada.h\"\n-#include \"types.h\"\n-#include \"uintp.h\"\n-#include \"atree.h\"\n-#include \"elists.h\"\n-#include \"nlists.h\"\n-#include \"stringt.h\"\n-#include \"fe.h\"\n-#include \"gigi.h\"\n-#include \"ada-tree.h\"\n-\n-/* Universal integers are represented by the Uint type which is an index into\n-   the Uints_Ptr table containing Uint_Entry values.  A Uint_Entry contains an\n-   index and length for getting the \"digits\" of the universal integer from the\n-   Udigits_Ptr table.\n-\n-   For efficiency, this method is used only for integer values larger than the\n-   constant Uint_Bias.  If a Uint is less than this constant, then it contains\n-   the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n-   that a Uint value of Uint_Bias indexes the first element.\n-\n-   First define a utility function that operates like build_int_cst for\n-   integral types and does a conversion to floating-point for real types.  */\n-\n-static tree\n-build_cst_from_int (tree type, HOST_WIDE_INT low)\n-{\n-  if (TREE_CODE (type) == REAL_TYPE)\n-    return convert (type, build_int_cst (NULL_TREE, low));\n-  else\n-    return build_int_cst_type (type, low);\n-}\n-\n-/* Similar to UI_To_Int, but return a GCC INTEGER_CST or REAL_CST node,\n-   depending on whether TYPE is an integral or real type.  Overflow is tested\n-   by the constant-folding used to build the node.  TYPE is the GCC type of\n-   the resulting node.  */\n-\n-tree\n-UI_To_gnu (Uint Input, tree type)\n-{\n-  tree gnu_ret;\n-\n-  /* We might have a TYPE with biased representation and be passed an\n-     unbiased value that doesn't fit.  We always use an unbiased type able\n-     to hold any such possible value for intermediate computations, and\n-     then rely on a conversion back to TYPE to perform the bias adjustment\n-     when need be.  */\n-\n-  int biased_type_p\n-    = (TREE_CODE (type) == INTEGER_TYPE\n-       && TYPE_BIASED_REPRESENTATION_P (type));\n-\n-  tree comp_type = biased_type_p ? get_base_type (type) : type;\n-\n-  if (Input <= Uint_Direct_Last)\n-    gnu_ret = build_cst_from_int (comp_type, Input - Uint_Direct_Bias);\n-  else\n-    {\n-      Int Idx = Uints_Ptr[Input].Loc;\n-      Pos Length = Uints_Ptr[Input].Length;\n-      Int First = Udigits_Ptr[Idx];\n-      tree gnu_base;\n-\n-      gcc_assert (Length > 0);\n-\n-      /* The computations we perform below always require a type at least as\n-\t large as an integer not to overflow.  REAL types are always fine, but\n-\t INTEGER or ENUMERAL types we are handed may be too short.  We use a\n-\t base integer type node for the computations in this case and will\n-\t convert the final result back to the incoming type later on.\n-\t The base integer precision must be superior than 16.  */\n-\n-      if (TREE_CODE (comp_type) != REAL_TYPE\n-\t  && TYPE_PRECISION (comp_type) < TYPE_PRECISION (long_integer_type_node))\n-\t{\n-\t  comp_type = long_integer_type_node;\n-\t  gcc_assert (TYPE_PRECISION (comp_type) > 16);\n-\t}\n-\n-      gnu_base = build_cst_from_int (comp_type, Base);\n-\n-      gnu_ret = build_cst_from_int (comp_type, First);\n-      if (First < 0)\n-\tfor (Idx++, Length--; Length; Idx++, Length--)\n-\t  gnu_ret = fold_build2 (MINUS_EXPR, comp_type,\n-\t\t\t\t fold_build2 (MULT_EXPR, comp_type,\n-\t\t\t\t\t      gnu_ret, gnu_base),\n-\t\t\t\t build_cst_from_int (comp_type,\n-\t\t\t\t\t\t     Udigits_Ptr[Idx]));\n-      else\n-\tfor (Idx++, Length--; Length; Idx++, Length--)\n-\t  gnu_ret = fold_build2 (PLUS_EXPR, comp_type,\n-\t\t\t\t fold_build2 (MULT_EXPR, comp_type,\n-\t\t\t\t\t      gnu_ret, gnu_base),\n-\t\t\t\t build_cst_from_int (comp_type,\n-\t\t\t\t\t\t     Udigits_Ptr[Idx]));\n-    }\n-\n-  gnu_ret = convert (type, gnu_ret);\n-\n-  /* We don't need any NOP_EXPR or NON_LVALUE_EXPR on GNU_RET.  */\n-  while ((TREE_CODE (gnu_ret) == NOP_EXPR\n-\t  || TREE_CODE (gnu_ret) == NON_LVALUE_EXPR)\n-\t && TREE_TYPE (TREE_OPERAND (gnu_ret, 0)) == TREE_TYPE (gnu_ret))\n-    gnu_ret = TREE_OPERAND (gnu_ret, 0);\n-\n-  return gnu_ret;\n-}"}, {"sha": "ebc2e5edd1409bf414fddc0083c13ae7d5b29404", "filename": "gcc/ada/decl.c", "status": "removed", "additions": 0, "deletions": 7648, "changes": 7648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902"}, {"sha": "28c7db5f70227ca186b216b8d49dac790ff3bb79", "filename": "gcc/ada/deftarg.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fdeftarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fdeftarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdeftarg.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,40 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                             D E F T A R G                                *\n- *                                                                          *\n- *                                  Body                                    *\n- *                                                                          *\n- *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have  received  a copy of the GNU General *\n- * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n- * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n- * Boston, MA 02110-1301, USA.                                              *\n- *                                                                          *\n- * As a  special  exception,  if you  link  this file  with other  files to *\n- * produce an executable,  this file does not by itself cause the resulting *\n- * executable to be covered by the GNU General Public License. This except- *\n- * ion does not  however invalidate  any other reasons  why the  executable *\n- * file might be covered by the  GNU Public License.                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* Include a default definition for TARGET_FLAGS for gnatpsta.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-int target_flags = TARGET_DEFAULT;"}, {"sha": "aaf5e7f8d8f433207d869e4cffdb5ea2a4ff5c4d", "filename": "gcc/ada/gigi.h", "status": "removed", "additions": 0, "deletions": 905, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,905 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                                 G I G I                                  *\n- *                                                                          *\n- *                              C Header File                               *\n- *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have  received  a copy of the GNU General *\n- * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n- * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n- * Boston, MA 02110-1301, USA.                                              *\n- *                                                                          *\n- * As a  special  exception,  if you  link  this file  with other  files to *\n- * produce an executable,  this file does not by itself cause the resulting *\n- * executable to be covered by the GNU General Public License. This except- *\n- * ion does not  however invalidate  any other reasons  why the  executable *\n- * file might be covered by the  GNU Public License.                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* Declare all functions and types used by gigi.  */\n-\n-/* The largest alignment, in bits, that is needed for using the widest\n-   move instruction.  */\n-extern unsigned int largest_move_alignment;\n-\n-/* Compute the alignment of the largest mode that can be used for copying\n-   objects.  */\n-extern void gnat_compute_largest_alignment (void);\n-\n-/* GNU_TYPE is a type. Determine if it should be passed by reference by\n-   default.  */\n-extern bool default_pass_by_ref (tree gnu_type);\n-\n-/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n-   if it should be passed by reference.  */\n-extern bool must_pass_by_ref (tree gnu_type);\n-\n-/* Initialize DUMMY_NODE_TABLE.  */\n-extern void init_dummy_type (void);\n-\n-/* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n-   GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n-   refer to an Ada type.  */\n-extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n-\n-/* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n-   entity, this routine returns the equivalent GCC tree for that entity\n-   (an ..._DECL node) and associates the ..._DECL node with the input GNAT\n-   defining identifier.\n-\n-   If GNAT_ENTITY is a variable or a constant declaration, GNU_EXPR gives its\n-   initial value (in GCC tree form). This is optional for variables.\n-   For renamed entities, GNU_EXPR gives the object being renamed.\n-\n-   DEFINITION is nonzero if this call is intended for a definition.  This is\n-   used for separate compilation where it necessary to know whether an\n-   external declaration or a definition should be created if the GCC equivalent\n-   was not created previously.  The value of 1 is normally used for a nonzero\n-   DEFINITION, but a value of 2 is used in special circumstances, defined in\n-   the code.  */\n-extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n-                                int definition);\n-\n-/* Similar, but if the returned value is a COMPONENT_REF, return the\n-   FIELD_DECL.  */\n-extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n-\n-/* Wrap up compilation of T, a TYPE_DECL, possibly deferring it.  */\n-extern void rest_of_type_decl_compilation (tree t);\n-\n-/* Start a new statement group chained to the previous group.  */\n-extern void start_stmt_group (void);\n-\n-/* Add GNU_STMT to the current BLOCK_STMT node.  */\n-extern void add_stmt (tree gnu_stmt);\n-\n-/* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n-extern void add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node);\n-\n-/* Return code corresponding to the current code group.  It is normally\n-   a STATEMENT_LIST, but may also be a BIND_EXPR or TRY_FINALLY_EXPR if\n-   BLOCK or cleanups were set.  */\n-extern tree end_stmt_group (void);\n-\n-/* Set the BLOCK node corresponding to the current code group to GNU_BLOCK.  */\n-extern void set_block_for_group (tree);\n-\n-/* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n-   Get SLOC from GNAT_ENTITY.  */\n-extern void add_decl_expr (tree gnu_decl, Entity_Id gnat_entity);\n-\n-/* Mark nodes rooted at *TP with TREE_VISITED and types as having their\n-   sized gimplified.  We use this to indicate all variable sizes and\n-   positions in global types may not be shared by any subprogram.  */\n-extern void mark_visited (tree *);\n-\n-/* Finalize any From_With_Type incomplete types.  We do this after processing\n-   our compilation unit and after processing its spec, if this is a body.  */\n-extern void finalize_from_with_types (void);\n-\n-/* Return the equivalent type to be used for GNAT_ENTITY, if it's a\n-   kind of type (such E_Task_Type) that has a different type which Gigi\n-   uses for its representation.  If the type does not have a special type\n-   for its representation, return GNAT_ENTITY.  If a type is supposed to\n-   exist, but does not, abort unless annotating types, in which case\n-   return Empty.   If GNAT_ENTITY is Empty, return Empty.  */\n-extern Entity_Id Gigi_Equivalent_Type (Entity_Id);\n-\n-/* Given GNAT_ENTITY, elaborate all expressions that are required to\n-   be elaborated at the point of its definition, but do nothing else.  */\n-extern void elaborate_entity (Entity_Id gnat_entity);\n-\n-/* Mark GNAT_ENTITY as going out of scope at this point.  Recursively mark\n-   any entities on its entity chain similarly.  */\n-extern void mark_out_of_scope (Entity_Id gnat_entity);\n-\n-/* Make a dummy type corresponding to GNAT_TYPE.  */\n-extern tree make_dummy_type (Entity_Id gnat_type);\n-\n-/* Get the unpadded version of a GNAT type.  */\n-extern tree get_unpadded_type (Entity_Id gnat_entity);\n-\n-/* Called when we need to protect a variable object using a save_expr.  */\n-extern tree maybe_variable (tree gnu_operand);\n-\n-/* Create a record type that contains a SIZE bytes long field of TYPE with a\n-    starting bit position so that it is aligned to ALIGN bits, and leaving at\n-    least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n-    record is guaranteed to get.  */\n-extern tree make_aligning_type (tree type, unsigned int align, tree size,\n-\t\t\t\tunsigned int base_align, int room);\n-\n-/* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n-   if needed.  We have already verified that SIZE and TYPE are large enough.\n-\n-   GNAT_ENTITY and NAME_TRAILER are used to name the resulting record and\n-   to issue a warning.\n-\n-   IS_USER_TYPE is true if we must be sure we complete the original type.\n-\n-   DEFINITION is true if this type is being defined.\n-\n-   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be\n-   set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n-   type.  */\n-extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n-                            Entity_Id gnat_entity, const char *name_trailer,\n-\t\t\t    bool is_user_type, bool definition,\n-                            bool same_rm_size);\n-\n-/* Given a GNU tree and a GNAT list of choices, generate an expression to test\n-   the value passed against the list of choices.  */\n-extern tree choices_to_gnu (tree operand, Node_Id choices);\n-\n-/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n-   type with all size expressions that contain F updated by replacing F\n-   with R.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n-   nothing has changed.  */\n-extern tree substitute_in_type (tree t, tree f, tree r);\n-\n-/* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n-   needed to represent the object.  */\n-extern tree rm_size (tree gnu_type);\n-\n-/* Given GNU_ID, an IDENTIFIER_NODE containing a name, and SUFFIX, a\n-   string, return a new IDENTIFIER_NODE that is the concatenation of\n-   the name in GNU_ID and SUFFIX.  */\n-extern tree concat_id_with_name (tree gnu_id, const char *suffix);\n-\n-/* Return the name to be used for GNAT_ENTITY.  If a type, create a\n-   fully-qualified name, possibly with type information encoding.\n-   Otherwise, return the name.  */\n-extern tree get_entity_name (Entity_Id gnat_entity);\n-\n-/* Return a name for GNAT_ENTITY concatenated with two underscores and\n-   SUFFIX.  */\n-extern tree create_concat_name (Entity_Id gnat_entity, const char *suffix);\n-\n-/* If true, then gigi is being called on an analyzed but unexpanded tree, and\n-   the only purpose of the call is to properly annotate types with\n-   representation information.  */\n-extern bool type_annotate_only;\n-\n-/* Current file name without path */\n-extern const char *ref_filename;\n-\n-/* This structure must be kept synchronized with Call_Back_End.  */\n-struct File_Info_Type\n-{\n-  File_Name_Type File_Name;\n-  Nat Num_Source_Lines;\n-};\n-\n-/* This is the main program of the back-end.  It sets up all the table\n-   structures and then generates code.\n-\n-   ??? Needs parameter descriptions  */\n-\n-extern void gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n-                  struct Node *nodes_ptr, Node_Id *next_node_ptr,\n-                  Node_Id *prev_node_ptr, struct Elist_Header *elists_ptr,\n-                  struct Elmt_Item *elmts_ptr,\n-                  struct String_Entry *strings_ptr,\n-                  Char_Code *strings_chars_ptr,\n-                  struct List_Header *list_headers_ptr,\n-                  Nat number_file,\n-                  struct File_Info_Type *file_info_ptr,\n-                  Entity_Id standard_integer,\n-                  Entity_Id standard_long_long_float,\n-                  Entity_Id standard_exception_type,\n-                  Int gigi_operating_mode);\n-\n-/* GNAT_NODE is the root of some GNAT tree.  Return the root of the\n-   GCC tree corresponding to that GNAT tree.  Normally, no code is generated;\n-   we just return an equivalent tree which is used elsewhere to generate\n-   code.  */\n-extern tree gnat_to_gnu (Node_Id gnat_node);\n-\n-/* GNU_STMT is a statement.  We generate code for that statement.  */\n-extern void gnat_expand_stmt (tree gnu_stmt);\n-\n-/* ??? missing documentation */\n-extern int gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n-                               gimple_seq *post_p ATTRIBUTE_UNUSED);\n-\n-/* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n-   a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n-   make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n-extern void process_type (Entity_Id gnat_entity);\n-\n-/* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n-   location and false if it doesn't.  In the former case, set the Gigi global\n-   variable REF_FILENAME to the simple debug file name as given by sinput.  */\n-extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus);\n-\n-/* Post an error message.  MSG is the error message, properly annotated.\n-   NODE is the node at which to post the error and the node to use for the\n-   \"&\" substitution.  */\n-extern void post_error (const char *, Node_Id);\n-\n-/* Similar, but NODE is the node at which to post the error and ENT\n-   is the node to use for the \"&\" substitution.  */\n-extern void post_error_ne (const char *msg, Node_Id node, Entity_Id ent);\n-\n-/* Similar, but NODE is the node at which to post the error, ENT is the node\n-   to use for the \"&\" substitution, and N is the number to use for the ^.  */\n-extern void post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent,\n-                               int n);\n-\n-/* Similar to post_error_ne_num, but T is a GCC tree representing the number\n-   to write.  If the tree represents a constant that fits within a\n-   host integer, the text inside curly brackets in MSG will be output\n-   (presumably including a '^').  Otherwise that text will not be output\n-   and the text inside square brackets will be output instead.  */\n-extern void post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent,\n-                                tree t);\n-\n-/* Similar to post_error_ne_tree, except that NUM is a second\n-   integer to write in the message.  */\n-extern void post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent,\n-                                  tree t, int num);\n-\n-/* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n-extern tree protect_multiple_eval (tree exp);\n-\n-/* Return a label to branch to for the exception type in KIND or NULL_TREE\n-   if none.  */\n-extern tree get_exception_label (char);\n-\n-/* Current node being treated, in case gigi_abort or Check_Elaboration_Code\n-   called.  */\n-extern Node_Id error_gnat_node;\n-\n-/* This is equivalent to stabilize_reference in tree.c, but we know how to\n-   handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  We set SUCCESS to true unless we walk\n-   through something we don't know how to stabilize.  */\n-extern tree maybe_stabilize_reference (tree ref, bool force, bool *success);\n-\n-/* Highest number in the front-end node table.  */\n-extern int max_gnat_nodes;\n-\n-/* If nonzero, pretend we are allocating at global level.  */\n-extern int force_global;\n-\n-/* Standard data type sizes.  Most of these are not used.  */\n-\n-#ifndef CHAR_TYPE_SIZE\n-#define CHAR_TYPE_SIZE BITS_PER_UNIT\n-#endif\n-\n-#ifndef SHORT_TYPE_SIZE\n-#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n-#endif\n-\n-#ifndef INT_TYPE_SIZE\n-#define INT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef LONG_TYPE_SIZE\n-#define LONG_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef LONG_LONG_TYPE_SIZE\n-#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n-#ifndef FLOAT_TYPE_SIZE\n-#define FLOAT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef DOUBLE_TYPE_SIZE\n-#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n-#ifndef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n-/* The choice of SIZE_TYPE here is very problematic.  We need a signed\n-   type whose bit width is Pmode.  Assume \"long\" is such a type here.  */\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"long int\"\n-\f\n-/* Data structures used to represent attributes.  */\n-\n-enum attr_type\n-{\n-  ATTR_MACHINE_ATTRIBUTE,\n-  ATTR_LINK_ALIAS,\n-  ATTR_LINK_SECTION,\n-  ATTR_LINK_CONSTRUCTOR,\n-  ATTR_LINK_DESTRUCTOR,\n-  ATTR_WEAK_EXTERNAL\n-};\n-\n-struct attrib\n-{\n-  struct attrib *next;\n-  enum attr_type type;\n-  tree name;\n-  tree args;\n-  Node_Id error_point;\n-};\n-\n-/* Table of machine-independent internal attributes.  */\n-extern const struct attribute_spec gnat_internal_attribute_table[];\n-\n-/* Define the entries in the standard data array.  */\n-enum standard_datatypes\n-{\n-/* Various standard data types and nodes.  */\n-  ADT_longest_float_type,\n-  ADT_void_type_decl,\n-\n-  /* The type of an exception.  */\n-  ADT_except_type,\n-\n-  /* Type declaration node  <==> typedef void *T */\n-  ADT_ptr_void_type,\n-\n-  /* Function type declaration -- void T() */\n-  ADT_void_ftype,\n-\n-  /* Type declaration node  <==> typedef void *T() */\n-  ADT_ptr_void_ftype,\n-\n-  /* Type declaration node  <==> typedef virtual void *T() */\n-  ADT_fdesc_type,\n-\n-  /* Null pointer for above type */\n-  ADT_null_fdesc,\n-\n-  /* Function declaration nodes for run-time functions for allocating memory.\n-     Ada allocators cause calls to these functions to be generated.  Malloc32\n-     is used only on 64bit systems needing to allocate 32bit memory. */\n-  ADT_malloc_decl,\n-  ADT_malloc32_decl,\n-\n-  /* Likewise for freeing memory.  */\n-  ADT_free_decl,\n-\n-  /* Types and decls used by our temporary exception mechanism.  See\n-     init_gigi_decls for details.  */\n-  ADT_jmpbuf_type,\n-  ADT_jmpbuf_ptr_type,\n-  ADT_get_jmpbuf_decl,\n-  ADT_set_jmpbuf_decl,\n-  ADT_get_excptr_decl,\n-  ADT_setjmp_decl,\n-  ADT_longjmp_decl,\n-  ADT_update_setjmp_buf_decl,\n-  ADT_raise_nodefer_decl,\n-  ADT_begin_handler_decl,\n-  ADT_end_handler_decl,\n-  ADT_others_decl,\n-  ADT_all_others_decl,\n-  ADT_LAST};\n-\n-extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n-extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n-\n-#define longest_float_type_node gnat_std_decls[(int) ADT_longest_float_type]\n-#define void_type_decl_node gnat_std_decls[(int) ADT_void_type_decl]\n-#define except_type_node gnat_std_decls[(int) ADT_except_type]\n-#define ptr_void_type_node gnat_std_decls[(int) ADT_ptr_void_type]\n-#define void_ftype gnat_std_decls[(int) ADT_void_ftype]\n-#define ptr_void_ftype gnat_std_decls[(int) ADT_ptr_void_ftype]\n-#define fdesc_type_node gnat_std_decls[(int) ADT_fdesc_type]\n-#define null_fdesc_node gnat_std_decls[(int) ADT_null_fdesc]\n-#define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n-#define malloc32_decl gnat_std_decls[(int) ADT_malloc32_decl]\n-#define free_decl gnat_std_decls[(int) ADT_free_decl]\n-#define jmpbuf_type gnat_std_decls[(int) ADT_jmpbuf_type]\n-#define jmpbuf_ptr_type gnat_std_decls[(int) ADT_jmpbuf_ptr_type]\n-#define get_jmpbuf_decl gnat_std_decls[(int) ADT_get_jmpbuf_decl]\n-#define set_jmpbuf_decl gnat_std_decls[(int) ADT_set_jmpbuf_decl]\n-#define get_excptr_decl gnat_std_decls[(int) ADT_get_excptr_decl]\n-#define setjmp_decl gnat_std_decls[(int) ADT_setjmp_decl]\n-#define longjmp_decl gnat_std_decls[(int) ADT_longjmp_decl]\n-#define update_setjmp_buf_decl gnat_std_decls[(int) ADT_update_setjmp_buf_decl]\n-#define raise_nodefer_decl gnat_std_decls[(int) ADT_raise_nodefer_decl]\n-#define begin_handler_decl gnat_std_decls[(int) ADT_begin_handler_decl]\n-#define others_decl gnat_std_decls[(int) ADT_others_decl]\n-#define all_others_decl gnat_std_decls[(int) ADT_all_others_decl]\n-#define end_handler_decl gnat_std_decls[(int) ADT_end_handler_decl]\n-\n-/* Routines expected by the gcc back-end. They must have exactly the same\n-   prototype and names as below.  */\n-\n-/* Returns nonzero if we are currently in the global binding level.  */\n-extern int global_bindings_p (void);\n-\n-/* Enter and exit a new binding level. */\n-extern void gnat_pushlevel (void);\n-extern void gnat_poplevel (void);\n-\n-/* Set SUPERCONTEXT of the BLOCK for the current binding level to FNDECL\n-   and point FNDECL to this BLOCK.  */\n-extern void set_current_block_context (tree fndecl);\n-\n-/* Set the jmpbuf_decl for the current binding level to DECL.  */\n-extern void set_block_jmpbuf_decl (tree decl);\n-\n-/* Get the setjmp_decl, if any, for the current binding level.  */\n-extern tree get_block_jmpbuf_decl (void);\n-\n-/* Records a ..._DECL node DECL as belonging to the current lexical scope\n-   and uses GNAT_NODE for location information.  */\n-extern void gnat_pushdecl (tree decl, Node_Id gnat_node);\n-\n-extern void gnat_init_decl_processing (void);\n-extern void init_gigi_decls (tree long_long_float_type, tree exception_type);\n-extern void gnat_init_gcc_eh (void);\n-\n-/* Return an integer type with the number of bits of precision given by\n-   PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n-   it is a signed type.  */\n-extern tree gnat_type_for_size (unsigned precision, int unsignedp);\n-\n-/* Return a data type that has machine mode MODE.  UNSIGNEDP selects\n-   an unsigned type; otherwise a signed type is returned.  */\n-extern tree gnat_type_for_mode (enum machine_mode mode, int unsignedp);\n-\n-/* Emit debug info for all global variable declarations.  */\n-extern void gnat_write_global_declarations (void);\n-\n-/* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_unsigned_type (tree type_node);\n-\n-/* Return the signed version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_signed_type (tree type_node);\n-\n-/* Return 1 if the types T1 and T2 are compatible, i.e. if they can be\n-   transparently converted to each other.  */\n-extern int gnat_types_compatible_p (tree t1, tree t2);\n-\n-/* Create an expression whose value is that of EXPR,\n-   converted to type TYPE.  The TREE_TYPE of the value\n-   is always TYPE.  This function implements all reasonable\n-   conversions; callers should filter out those that are\n-   not permitted by the language being compiled.  */\n-extern tree convert (tree type, tree expr);\n-\n-/* Routines created solely for the tree translator's sake. Their prototypes\n-   can be changed as desired.  */\n-\n-/* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n-   GNU_DECL is the GCC tree which is to be associated with\n-   GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n-   If NO_CHECK is nonzero, the latter check is suppressed.\n-   If GNU_DECL is zero, a previous association is to be reset.  */\n-extern void save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl,\n-                           bool no_check);\n-\n-/* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n-   Return the ..._DECL node that was associated with it.  If there is no tree\n-   node associated with GNAT_ENTITY, abort.  */\n-extern tree get_gnu_tree (Entity_Id gnat_entity);\n-\n-/* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n-extern bool present_gnu_tree (Entity_Id gnat_entity);\n-\n-/* Initialize tables for above routines.  */\n-extern void init_gnat_to_gnu (void);\n-\n-/* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n-   finish constructing the record or union type.  If REP_LEVEL is zero, this\n-   record has no representation clause and so will be entirely laid out here.\n-   If REP_LEVEL is one, this record has a representation clause and has been\n-   laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n-   this record is derived from a parent record and thus inherits its layout;\n-   only make a pass on the fields to finalize them.  If DO_NOT_FINALIZE is\n-   true, the record type is expected to be modified afterwards so it will\n-   not be sent to the back-end for finalization.  */\n-extern void finish_record_type (tree record_type, tree fieldlist,\n-                                int rep_level, bool do_not_finalize);\n-\n-/* Wrap up compilation of RECORD_TYPE, i.e. most notably output all\n-   the debug information associated with it.  It need not be invoked\n-   directly in most cases since finish_record_type takes care of doing\n-   so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n-extern void rest_of_record_type_compilation (tree record_type);\n-\n-/* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n-extern void add_parallel_type (tree decl, tree parallel_type);\n-\n-/* Return the parallel type associated to a type, if any.  */\n-extern tree get_parallel_type (tree type);\n-\n-/* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n-   subprogram. If it is void_type_node, then we are dealing with a procedure,\n-   otherwise we are dealing with a function. PARAM_DECL_LIST is a list of\n-   PARM_DECL nodes that are the subprogram arguments.  CICO_LIST is the\n-   copy-in/copy-out list to be stored into TYPE_CI_CO_LIST.\n-   RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n-   object.  RETURNS_BY_REF is true if the function returns by reference.\n-   RETURNS_BY_TARGET_PTR is true if the function is to be passed (as its\n-   first parameter) the address of the place to copy its result.  */\n-extern tree create_subprog_type (tree return_type, tree param_decl_list,\n-                                 tree cico_list, bool returns_unconstrained,\n-                                 bool returns_by_ref,\n-                                 bool returns_by_target_ptr);\n-\n-/* Return a copy of TYPE, but safe to modify in any way.  */\n-extern tree copy_type (tree type);\n-\n-/* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n-   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position of\n-   the decl.  */\n-extern tree create_index_type (tree min, tree max, tree index,\n-\t\t\t       Node_Id gnat_node);\n-\n-/* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n-   string) and TYPE is a ..._TYPE node giving its data type.\n-   ARTIFICIAL_P is true if this is a declaration that was generated\n-   by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n-   information about this type.  GNAT_NODE is used for the position of\n-   the decl.  */\n-extern tree create_type_decl (tree type_name, tree type,\n-                              struct attrib *attr_list,\n-                              bool artificial_p, bool debug_info_p,\n-\t\t\t      Node_Id gnat_node);\n-\n-/* Return a VAR_DECL or CONST_DECL node.\n-\n-   VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n-   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  VAR_INIT is\n-   the GCC tree for an optional initial expression; NULL_TREE if none.\n-\n-   CONST_FLAG is true if this variable is constant, in which case we might\n-   return a CONST_DECL node unless CONST_DECL_ALLOWED_P is false.\n-\n-   PUBLIC_FLAG is true if this definition is to be made visible outside of\n-   the current compilation unit. This flag should be set when processing the\n-   variable definitions in a package specification.\n-\n-   EXTERN_FLAG is nonzero when processing an external variable declaration (as\n-   opposed to a definition: no storage is to be allocated for the variable).\n-\n-   STATIC_FLAG is only relevant when not at top level.  In that case\n-   it indicates whether to always allocate storage to the variable.\n-\n-   GNAT_NODE is used for the position of the decl.  */\n-tree\n-create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n-\t\t   bool const_flag, bool public_flag, bool extern_flag,\n-\t\t   bool static_flag, bool const_decl_allowed_p,\n-\t\t   struct attrib *attr_list, Node_Id gnat_node);\n-\n-/* Wrapper around create_var_decl_1 for cases where we don't care whether\n-   a VAR or a CONST decl node is created.  */\n-#define create_var_decl(var_name, asm_name, type, var_init,\t\\\n-\t\t\tconst_flag, public_flag, extern_flag,\t\\\n-\t\t\tstatic_flag, attr_list, gnat_node)\t\\\n-  create_var_decl_1 (var_name, asm_name, type, var_init,\t\\\n-\t\t     const_flag, public_flag, extern_flag,\t\\\n-\t\t     static_flag, true, attr_list, gnat_node)\n-\n-/* Wrapper around create_var_decl_1 for cases where a VAR_DECL node is\n-   required.  The primary intent is for DECL_CONST_CORRESPONDING_VARs, which\n-   must be VAR_DECLs and on which we want TREE_READONLY set to have them\n-   possibly assigned to a readonly data section.  */\n-#define create_true_var_decl(var_name, asm_name, type, var_init,\t\\\n-\t\t\t     const_flag, public_flag, extern_flag,\t\\\n-\t\t\t     static_flag, attr_list, gnat_node)\t\t\\\n-  create_var_decl_1 (var_name, asm_name, type, var_init,\t\t\\\n-\t\t     const_flag, public_flag, extern_flag,\t\t\\\n-\t\t     static_flag, false, attr_list, gnat_node)\n-\n-/* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n-extern void process_attributes (tree decl, struct attrib *attr_list);\n-\n-/* Record a global renaming pointer.  */\n-void record_global_renaming_pointer (tree);\n-\n-/* Invalidate the global renaming pointers.   */\n-void invalidate_global_renaming_pointers (void);\n-\n-/* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n-   type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n-   this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n-   it is the specified size for this field.  If POS is nonzero, it is the bit\n-   position.  If ADDRESSABLE is nonzero, it means we are allowed to take\n-   the address of this field for aliasing purposes.  */\n-extern tree create_field_decl (tree field_name, tree field_type,\n-                               tree record_type, int packed, tree size,\n-                               tree pos, int addressable);\n-\n-/* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n-   PARAM_TYPE is its type.  READONLY is true if the parameter is\n-   readonly (either an In parameter or an address of a pass-by-ref\n-   parameter). */\n-extern tree create_param_decl (tree param_name, tree param_type,\n-                               bool readonly);\n-\n-/* Returns a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n-   ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n-   node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n-   PARM_DECL nodes chained through the TREE_CHAIN field).\n-\n-   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, and ATTR_LIST are used to set the\n-   appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */\n-extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n-                                 tree subprog_type, tree param_decl_list,\n-                                 bool inlinee_flag, bool public_flag,\n-                                 bool extern_flag,\n-\t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n-\n-/* Returns a LABEL_DECL node for LABEL_NAME.  */\n-extern tree create_label_decl (tree label_name);\n-\n-/* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n-   body. This routine needs to be invoked before processing the declarations\n-   appearing in the subprogram.  */\n-extern void begin_subprog_body (tree subprog_decl);\n-\n-/* Finish the definition of the current subprogram BODY and compile it all the\n-   way to assembler language output.  ELAB_P tells if this is called for an\n-   elaboration routine, to be entirely discarded if empty.  */\n-extern void end_subprog_body (tree body, bool elab_p);\n-\n-/* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n-   EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs.\n-   Return a constructor for the template.  */\n-extern tree build_template (tree template_type, tree array_type, tree expr);\n-\n-/* Build a VMS descriptor from a Mechanism_Type, which must specify\n-   a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n-   in the type contains in its DECL_INITIAL the expression to use when\n-   a constructor is made for the type.  GNAT_ENTITY is a gnat node used\n-   to print out an error message if the mechanism cannot be applied to\n-   an object of that type and also for the name.  */\n-extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n-                                  Entity_Id gnat_entity);\n-\n-/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n-   and the GNAT node GNAT_SUBPROG.  */\n-extern void build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog);\n-\n-/* Build a type to be used to represent an aliased object whose nominal\n-   type is an unconstrained array.  This consists of a RECORD_TYPE containing\n-   a field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an\n-   ARRAY_TYPE.  If ARRAY_TYPE is that of the unconstrained array, this\n-   is used to represent an arbitrary unconstrained object.  Use NAME\n-   as the name of the record.  */\n-extern tree build_unc_object_type (tree template_type, tree object_type,\n-                                   tree name);\n-\n-/* Same as build_unc_object_type, but taking a thin or fat pointer type\n-   instead of the template type. */\n-extern tree build_unc_object_type_from_ptr (tree thin_fat_ptr_type,\n-\t\t\t\t\t    tree object_type, tree name);\n-\n-/* Shift the component offsets within an unconstrained object TYPE to make it\n-   suitable for use as a designated type for thin pointers.  */\n-extern void shift_unc_components_for_thin_pointers (tree type);\n-\n-/* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n-   the normal case this is just two adjustments, but we have more to do\n-   if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n-extern void update_pointer_to (tree old_type, tree new_type);\n-\n-/* EXP is an expression for the size of an object.  If this size contains\n-   discriminant references, replace them with the maximum (if MAX_P) or\n-   minimum (if !MAX_P) possible value of the discriminant.  */\n-extern tree max_size (tree exp, bool max_p);\n-\n-/* Remove all conversions that are done in EXP.  This includes converting\n-   from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n-   is true, always return the address of the containing object even if\n-   the address is not bit-aligned.  */\n-extern tree remove_conversions (tree exp, bool true_address);\n-\n-/* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n-   refers to the underlying array.  If its type has TYPE_CONTAINS_TEMPLATE_P,\n-   likewise return an expression pointing to the underlying array.  */\n-extern tree maybe_unconstrained_array (tree exp);\n-\n-/* Return an expression that does an unchecked conversion of EXPR to TYPE.\n-   If NOTRUNC_P is true, truncation operations should be suppressed.  */\n-extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n-\n-/* Return the appropriate GCC tree code for the specified GNAT type,\n-   the latter being a record type as predicated by Is_Record_Type.  */\n-extern enum tree_code tree_code_for_record_type (Entity_Id);\n-\n-/* Return true if GNU_TYPE is suitable as the type of a non-aliased\n-   component of an aggregate type.  */\n-extern bool type_for_nonaliased_component_p (tree);\n-\n-/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n-   operation.\n-\n-   This preparation consists of taking the ordinary\n-   representation of an expression EXPR and producing a valid tree\n-   boolean expression describing whether EXPR is nonzero.  We could\n-   simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n-   but we optimize comparisons, &&, ||, and !.\n-\n-   The resulting type should always be the same as the input type.\n-   This function is simpler than the corresponding C version since\n-   the only possible operands will be things of Boolean type.  */\n-extern tree gnat_truthvalue_conversion (tree expr);\n-\n-/* Return the base type of TYPE.  */\n-extern tree get_base_type (tree type);\n-\n-/* EXP is a GCC tree representing an address.  See if we can find how\n-   strictly the object at that address is aligned.   Return that alignment\n-   strictly the object at that address is aligned.   Return that alignment\n-   in bits.  If we don't know anything about the alignment, return 0.  */\n-extern unsigned int known_alignment (tree exp);\n-\n-/* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n-   of 2. */\n-extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n-\n-/* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n-   desired for the result.  Usually the operation is to be performed\n-   in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n-   in which case the type to be used will be derived from the operands.  */\n-extern tree build_binary_op (enum tree_code op_code, tree retult_type,\n-                             tree left_operand, tree right_operand);\n-\n-/* Similar, but make unary operation.   */\n-extern tree build_unary_op (enum tree_code op_code, tree result_type,\n-                            tree operand);\n-\n-/* Similar, but for COND_EXPR.  */\n-extern tree build_cond_expr (tree result_type, tree condition_operand,\n-                             tree true_operand, tree false_operand);\n-\n-/* Similar, but for RETURN_EXPR.  */\n-extern tree build_return_expr (tree result_decl, tree ret_val);\n-\n-/* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n-   the CALL_EXPR.  */\n-extern tree build_call_1_expr (tree fundecl, tree arg);\n-\n-/* Build a CALL_EXPR to call FUNDECL with two argument, ARG1 & ARG2.  Return\n-   the CALL_EXPR.  */\n-extern tree build_call_2_expr (tree fundecl, tree arg1, tree arg2);\n-\n-/* Likewise to call FUNDECL with no arguments.  */\n-extern tree build_call_0_expr (tree fundecl);\n-\n-/* Call a function that raises an exception and pass the line number and file\n-   name, if requested.  MSG says which exception function to call.\n-\n-   GNAT_NODE is the gnat node conveying the source location for which the\n-   error should be signaled, or Empty in which case the error is signaled on\n-   the current ref_file_name/input_line.\n-\n-   KIND says which kind of exception this is for\n-    (N_Raise_{Constraint,Storage,Program}_Error).  */\n-extern tree build_call_raise (int msg, Node_Id gnat_node, char kind);\n-\n-/* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n-   same as build_constructor in the language-independent tree.c.  */\n-extern tree gnat_build_constructor (tree type, tree list);\n-\n-/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n-   an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n-   for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n-extern tree build_component_ref (tree record_variable, tree component,\n-                                 tree field, bool no_fold_p);\n-\n-/* Build a GCC tree to call an allocation or deallocation function.\n-   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n-   generate an allocator.\n-\n-   GNU_SIZE is the size of the object and ALIGN is the alignment.\n-   GNAT_PROC, if present is a procedure to call and GNAT_POOL is the\n-   storage pool to use.  If not preset, malloc and free will be used.  */\n-extern tree build_call_alloc_dealloc (tree gnu_obj, tree gnu_size,\n-                                      unsigned align, Entity_Id gnat_proc,\n-\t\t\t\t      Entity_Id gnat_pool, Node_Id gnat_node);\n-\n-/* Build a GCC tree to correspond to allocating an object of TYPE whose\n-   initial value if INIT, if INIT is nonzero.  Convert the expression to\n-   RESULT_TYPE, which must be some type of pointer.  Return the tree.\n-   GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n-   the storage pool to use.  GNAT_NODE is used to provide an error\n-   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n-   true, ignore the type of INIT for the purpose of determining the size;\n-   this will cause the maximum size to be allocated if TYPE is of\n-   self-referential size.  */\n-extern tree build_allocator (tree type, tree init, tree result_type,\n-                             Entity_Id gnat_proc, Entity_Id gnat_pool,\n-                             Node_Id gnat_node, bool);\n-\n-/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record.  */\n-\n-extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal);\n-\n-/* Indicate that we need to make the address of EXPR_NODE and it therefore\n-   should not be allocated in a register.  Return true if successful.  */\n-extern bool gnat_mark_addressable (tree expr_node);\n-\n-/* Implementation of the builtin_function langhook.  */\n-extern tree gnat_builtin_function (tree decl);\n-\n-/* Search the chain of currently reachable declarations for a builtin\n-   FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n-   Return the first node found, if any, or NULL_TREE otherwise.  */\n-extern tree builtin_decl_for (tree name);\n-\n-/* This function is called by the front end to enumerate all the supported\n-   modes for the machine.  We pass a function which is called back with\n-   the following integer parameters:\n-\n-   FLOAT_P\tnonzero if this represents a floating-point mode\n-   COMPLEX_P\tnonzero is this represents a complex mode\n-   COUNT\tcount of number of items, nonzero for vector mode\n-   PRECISION\tnumber of bits in data representation\n-   MANTISSA\tnumber of bits in mantissa, if FP and known, else zero.\n-   SIZE\t\tnumber of bits used to store data\n-   ALIGN\tnumber of bits to which mode is aligned.  */\n-extern void enumerate_modes (void (*f) (int, int, int, int, int, int,\n-\t\t\t\t\tunsigned int));\n-\n-/* These are temporary function to deal with recent GCC changes related to\n-   FP type sizes and precisions.  */\n-extern int fp_prec_to_size (int prec);\n-extern int fp_size_to_prec (int size);\n-\n-/* These functions return the basic data type sizes and related parameters\n-   about the target machine.  */\n-\n-extern Pos get_target_bits_per_unit (void);\n-extern Pos get_target_bits_per_word (void);\n-extern Pos get_target_char_size (void);\n-extern Pos get_target_wchar_t_size (void);\n-extern Pos get_target_short_size (void);\n-extern Pos get_target_int_size (void);\n-extern Pos get_target_long_size (void);\n-extern Pos get_target_long_long_size (void);\n-extern Pos get_target_float_size (void);\n-extern Pos get_target_double_size (void);\n-extern Pos get_target_long_double_size (void);\n-extern Pos get_target_pointer_size (void);\n-extern Pos get_target_maximum_alignment (void);\n-extern Pos get_target_default_allocator_alignment (void);\n-extern Pos get_target_maximum_default_alignment (void);\n-extern Pos get_target_maximum_allowed_alignment (void);\n-extern Nat get_float_words_be (void);\n-extern Nat get_words_be (void);\n-extern Nat get_bytes_be (void);\n-extern Nat get_bits_be (void);\n-extern Nat get_strict_alignment (void);"}, {"sha": "65326d4c5b2d95b30debe5aaf4fa762ca5f2e27e", "filename": "gcc/ada/lang-specs.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-specs.h?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,48 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                            L A N G - S P E C S                           *\n- *                                                                          *\n- *                              C Header File                               *\n- *                                                                          *\n- *           Copyright (C) 1992-2008, Free Software Foundation, Inc.        *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have received a copy of the GNU General   *\n- * Public License along with GCC; see the file COPYING3.  If not see        *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* This is the contribution to the `default_compilers' array in gcc.c for\n-   GNAT.  */\n-\n-  {\".ads\", \"@ada\", 0, 0, 0},\n-  {\".adb\", \"@ada\", 0, 0, 0},\n-  {\"@ada\",\n-   \"\\\n- %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n- %{!S:%{!c:%e-c or -S required for Ada}}\\\n- gnat1 %{I*} %{k8:-gnatk8} %{Wall:-gnatwa} %{w:-gnatws} %{!Q:-quiet}\\\n-    %{nostdinc*} %{nostdlib*}\\\n-    -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}}\\\n-    %{O*} %{W*} %{w} %{p} %{pg:-p} %{a} %{f*} %{d*} %{g*&m*} \"\n-#if defined(TARGET_VXWORKS_RTP)\n-   \"%{fRTS=rtp:-mrtp} \"\n-#endif\n-#if CONFIG_DUAL_EXCEPTIONS\n-   \"%{fRTS=sjlj:-fsjlj} \"\n-#endif\n-   \"%1 %{!S:%{o*:%w%*-gnatO}} \\\n-    %i %{S:%W{o*}%{!o*:-o %b.s}} \\\n-    %{gnatc*|gnats*: -o %j} %{-param*} \\\n-    %{!gnatc*:%{!gnats*:%(invoke_as)}}\", 0, 0, 0},"}, {"sha": "d10fc3ac08748776065f68d0b92e8805b43c70ee", "filename": "gcc/ada/lang.opt", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang.opt?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,102 +0,0 @@\n-; Options for the Ada front end.\n-; Copyright (C) 2003, 2007 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-; \n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-; \n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-\n-; See the GCC internals manual for a description of this file's format.\n-\n-; Please try to keep this file in ASCII collating order.\n-\n-Language\n-Ada\n-\n-I\n-Ada Joined Separate\n-; Documented for C\n-\n-Wall\n-Ada\n-; Documented for C\n-\n-Wmissing-prototypes\n-Ada\n-; Documented for C\n-\n-Wstrict-prototypes\n-Ada\n-; Documented for C\n-\n-Wwrite-strings\n-Ada\n-; Documented for C\n-\n-Wlong-long\n-Ada\n-; Documented for C\n-\n-Wvariadic-macros\n-Ada\n-; Documented for C\n-\n-Wold-style-definition\n-Ada\n-; Documented for C\n-\n-Wmissing-format-attribute\n-Ada\n-; Documented for C\n-\n-Woverlength-strings\n-Ada\n-; Documented for C\n-\n-nostdinc\n-Ada RejectNegative\n-; Don't look for source files\n-\n-nostdlib\n-Ada\n-; Don't look for object files\n-\n-feliminate-unused-debug-types\n-Ada\n-; Effect documented for C - intercepted for Ada to force the associated flag\n-; not to be set by default, as it currently eliminates unreferenced parallel\n-; types we need for encoding descriptions to the debugger.\n-\n-fRTS=\n-Ada Joined RejectNegative\n-; Selects the runtime\n-\n-gdwarf+\n-Ada\n-; Explicit request for dwarf debug info with GNAT specific extensions.\n-\n-gant\n-Ada Joined Undocumented\n-; Catches typos\n-\n-gnatO\n-Ada Separate\n-; Sets name of output ALI file (internal switch)\n-\n-gnat\n-Ada Joined\n--gnat<options>\tSpecify options to GNAT\n-\n-; This comment is to ensure we retain the blank line above."}, {"sha": "02397d7f44532dd7e4dcd7a5e4e15fa9e48a2009", "filename": "gcc/ada/misc.c", "status": "removed", "additions": 0, "deletions": 876, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,876 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                                 M I S C                                  *\n- *                                                                          *\n- *                           C Implementation File                          *\n- *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have  received  a copy of the GNU General *\n- * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n- * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n- * Boston, MA 02110-1301, USA.                                              *\n- *                                                                          *\n- * As a  special  exception,  if you  link  this file  with other  files to *\n- * produce an executable,  this file does not by itself cause the resulting *\n- * executable to be covered by the GNU General Public License. This except- *\n- * ion does not  however invalidate  any other reasons  why the  executable *\n- * file might be covered by the  GNU Public License.                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* This file contains parts of the compiler that are required for interfacing\n-   with GCC but otherwise do nothing and parts of Gigi that need to know\n-   about RTL.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"real.h\"\n-#include \"rtl.h\"\n-#include \"diagnostic.h\"\n-#include \"expr.h\"\n-#include \"libfuncs.h\"\n-#include \"ggc.h\"\n-#include \"flags.h\"\n-#include \"debug.h\"\n-#include \"cgraph.h\"\n-#include \"tree-inline.h\"\n-#include \"insn-codes.h\"\n-#include \"insn-flags.h\"\n-#include \"insn-config.h\"\n-#include \"optabs.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"output.h\"\n-#include \"except.h\"\n-#include \"tm_p.h\"\n-#include \"langhooks.h\"\n-#include \"langhooks-def.h\"\n-#include \"target.h\"\n-\n-#include \"ada.h\"\n-#include \"types.h\"\n-#include \"atree.h\"\n-#include \"elists.h\"\n-#include \"namet.h\"\n-#include \"nlists.h\"\n-#include \"stringt.h\"\n-#include \"uintp.h\"\n-#include \"fe.h\"\n-#include \"sinfo.h\"\n-#include \"einfo.h\"\n-#include \"ada-tree.h\"\n-#include \"gigi.h\"\n-#include \"adadecode.h\"\n-#include \"opts.h\"\n-#include \"options.h\"\n-\n-extern FILE *asm_out_file;\n-\n-/* The largest alignment, in bits, that is needed for using the widest\n-   move instruction.  */\n-unsigned int largest_move_alignment;\n-\n-static bool gnat_init\t\t\t(void);\n-static void gnat_finish_incomplete_decl\t(tree);\n-static unsigned int gnat_init_options\t(unsigned int, const char **);\n-static int gnat_handle_option\t\t(size_t, const char *, int);\n-static bool gnat_post_options\t\t(const char **);\n-static alias_set_type gnat_get_alias_set (tree);\n-static void gnat_print_decl\t\t(FILE *, tree, int);\n-static void gnat_print_type\t\t(FILE *, tree, int);\n-static const char *gnat_printable_name\t(tree, int);\n-static const char *gnat_dwarf_name\t(tree, int);\n-static tree gnat_return_tree\t\t(tree);\n-static int gnat_eh_type_covers\t\t(tree, tree);\n-static void gnat_parse_file\t\t(int);\n-static rtx gnat_expand_expr\t\t(tree, rtx, enum machine_mode, int,\n-\t\t\t\t\t rtx *);\n-static void internal_error_function\t(const char *, va_list *);\n-static tree gnat_type_max_size\t\t(const_tree);\n-\n-/* Definitions for our language-specific hooks.  */\n-\n-#undef  LANG_HOOKS_NAME\n-#define LANG_HOOKS_NAME\t\t\t\"GNU Ada\"\n-#undef  LANG_HOOKS_IDENTIFIER_SIZE\n-#define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct tree_identifier)\n-#undef  LANG_HOOKS_INIT\n-#define LANG_HOOKS_INIT\t\t\tgnat_init\n-#undef  LANG_HOOKS_INIT_OPTIONS\n-#define LANG_HOOKS_INIT_OPTIONS\t\tgnat_init_options\n-#undef  LANG_HOOKS_HANDLE_OPTION\n-#define LANG_HOOKS_HANDLE_OPTION\tgnat_handle_option\n-#undef  LANG_HOOKS_POST_OPTIONS\n-#define LANG_HOOKS_POST_OPTIONS\t\tgnat_post_options\n-#undef  LANG_HOOKS_PARSE_FILE\n-#define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n-#undef  LANG_HOOKS_HASH_TYPES\n-#define LANG_HOOKS_HASH_TYPES\t\tfalse\n-#undef  LANG_HOOKS_GETDECLS\n-#define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n-#undef  LANG_HOOKS_PUSHDECL\n-#define LANG_HOOKS_PUSHDECL\t\tgnat_return_tree\n-#undef  LANG_HOOKS_WRITE_GLOBALS\n-#define LANG_HOOKS_WRITE_GLOBALS\tgnat_write_global_declarations\n-#undef  LANG_HOOKS_FINISH_INCOMPLETE_DECL\n-#define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n-#undef  LANG_HOOKS_GET_ALIAS_SET\n-#define LANG_HOOKS_GET_ALIAS_SET\tgnat_get_alias_set\n-#undef  LANG_HOOKS_EXPAND_EXPR\n-#define LANG_HOOKS_EXPAND_EXPR\t\tgnat_expand_expr\n-#undef  LANG_HOOKS_MARK_ADDRESSABLE\n-#define LANG_HOOKS_MARK_ADDRESSABLE\tgnat_mark_addressable\n-#undef  LANG_HOOKS_PRINT_DECL\n-#define LANG_HOOKS_PRINT_DECL\t\tgnat_print_decl\n-#undef  LANG_HOOKS_PRINT_TYPE\n-#define LANG_HOOKS_PRINT_TYPE\t\tgnat_print_type\n-#undef  LANG_HOOKS_TYPE_MAX_SIZE\n-#define LANG_HOOKS_TYPE_MAX_SIZE\tgnat_type_max_size\n-#undef  LANG_HOOKS_DECL_PRINTABLE_NAME\n-#define LANG_HOOKS_DECL_PRINTABLE_NAME\tgnat_printable_name\n-#undef  LANG_HOOKS_DWARF_NAME\n-#define LANG_HOOKS_DWARF_NAME\t\tgnat_dwarf_name\n-#undef  LANG_HOOKS_GIMPLIFY_EXPR\n-#define LANG_HOOKS_GIMPLIFY_EXPR\tgnat_gimplify_expr\n-#undef  LANG_HOOKS_TYPE_FOR_MODE\n-#define LANG_HOOKS_TYPE_FOR_MODE\tgnat_type_for_mode\n-#undef  LANG_HOOKS_TYPE_FOR_SIZE\n-#define LANG_HOOKS_TYPE_FOR_SIZE\tgnat_type_for_size\n-#undef  LANG_HOOKS_TYPES_COMPATIBLE_P\n-#define LANG_HOOKS_TYPES_COMPATIBLE_P\tgnat_types_compatible_p\n-#undef  LANG_HOOKS_ATTRIBUTE_TABLE\n-#define LANG_HOOKS_ATTRIBUTE_TABLE\tgnat_internal_attribute_table\n-#undef  LANG_HOOKS_BUILTIN_FUNCTION\n-#define LANG_HOOKS_BUILTIN_FUNCTION        gnat_builtin_function\n-\n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n-\n-/* How much we want of our DWARF extensions.  Some of our dwarf+ extensions\n-   are incompatible with regular GDB versions, so we must make sure to only\n-   produce them on explicit request.  This is eventually reflected into the\n-   use_gnu_debug_info_extensions common flag for later processing.  */\n-\n-static int gnat_dwarf_extensions = 0;\n-\n-/* Command-line argc and argv.\n-   These variables are global, since they are imported and used in\n-   back_end.adb  */\n-\n-unsigned int save_argc;\n-const char **save_argv;\n-\n-/* gnat standard argc argv */\n-\n-extern int gnat_argc;\n-extern char **gnat_argv;\n-\n-\f\n-/* Declare functions we use as part of startup.  */\n-extern void __gnat_initialize           (void *);\n-extern void __gnat_install_SEH_handler  (void *);\n-extern void adainit\t\t        (void);\n-extern void _ada_gnat1drv\t        (void);\n-\n-/* The parser for the language.  For us, we process the GNAT tree.  */\n-\n-static void\n-gnat_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n-{\n-  int seh[2];\n-\n-  /* Call the target specific initializations.  */\n-  __gnat_initialize (NULL);\n-\n-  /* ??? Call the SEH initialization routine.  This is to workaround\n-  a bootstrap path problem.  The call below should be removed at some\n-  point and the SEH pointer passed to __gnat_initialize() above.  */\n-  __gnat_install_SEH_handler((void *)seh);\n-\n-  /* Call the front-end elaboration procedures.  */\n-  adainit ();\n-\n-  /* Call the front end.  */\n-  _ada_gnat1drv ();\n-\n-  /* We always have a single compilation unit in Ada.  */\n-  cgraph_finalize_compilation_unit ();\n-}\n-\n-/* Decode all the language specific options that cannot be decoded by GCC.\n-   The option decoding phase of GCC calls this routine on the flags that\n-   it cannot decode.  This routine returns the number of consecutive arguments\n-   from ARGV that it successfully decoded; 0 indicates failure.  */\n-\n-static int\n-gnat_handle_option (size_t scode, const char *arg, int value)\n-{\n-  const struct cl_option *option = &cl_options[scode];\n-  enum opt_code code = (enum opt_code) scode;\n-  char *q;\n-\n-  if (arg == NULL && (option->flags & (CL_JOINED | CL_SEPARATE)))\n-    {\n-      error (\"missing argument to \\\"-%s\\\"\", option->opt_text);\n-      return 1;\n-    }\n-\n-  switch (code)\n-    {\n-    case OPT_I:\n-      q = XNEWVEC (char, sizeof(\"-I\") + strlen (arg));\n-      strcpy (q, \"-I\");\n-      strcat (q, arg);\n-      gnat_argv[gnat_argc] = q;\n-      gnat_argc++;\n-      break;\n-\n-    case OPT_Wall:\n-      set_Wunused (value);\n-\n-      /* We save the value of warn_uninitialized, since if they put\n-\t -Wuninitialized on the command line, we need to generate a\n-\t warning about not using it without also specifying -O.  */\n-      if (warn_uninitialized != 1)\n-\twarn_uninitialized = (value ? 2 : 0);\n-      break;\n-\n-      /* These are used in the GCC Makefile.  */\n-    case OPT_Wmissing_prototypes:\n-    case OPT_Wstrict_prototypes:\n-    case OPT_Wwrite_strings:\n-    case OPT_Wlong_long:\n-    case OPT_Wvariadic_macros:\n-    case OPT_Wold_style_definition:\n-    case OPT_Wmissing_format_attribute:\n-    case OPT_Woverlength_strings:\n-      break;\n-\n-      /* This is handled by the front-end.  */\n-    case OPT_nostdinc:\n-      break;\n-\n-    case OPT_nostdlib:\n-      gnat_argv[gnat_argc] = xstrdup (\"-nostdlib\");\n-      gnat_argc++;\n-      break;\n-\n-    case OPT_feliminate_unused_debug_types:\n-      /* We arrange for post_option to be able to only set the corresponding\n-\t flag to 1 when explicitly requested by the user.  We expect the\n-\t default flag value to be either 0 or positive, and expose a positive\n-\t -f as a negative value to post_option.  */\n-      flag_eliminate_unused_debug_types = -value;\n-      break;\n-\n-    case OPT_fRTS_:\n-      gnat_argv[gnat_argc] = xstrdup (\"-fRTS\");\n-      gnat_argc++;\n-      break;\n-\n-    case OPT_gant:\n-      warning (0, \"%<-gnat%> misspelled as %<-gant%>\");\n-\n-      /* ... fall through ... */\n-\n-    case OPT_gnat:\n-      /* Recopy the switches without the 'gnat' prefix.  */\n-      gnat_argv[gnat_argc] = XNEWVEC (char, strlen (arg) + 2);\n-      gnat_argv[gnat_argc][0] = '-';\n-      strcpy (gnat_argv[gnat_argc] + 1, arg);\n-      gnat_argc++;\n-      break;\n-\n-    case OPT_gnatO:\n-      gnat_argv[gnat_argc] = xstrdup (\"-O\");\n-      gnat_argc++;\n-      gnat_argv[gnat_argc] = xstrdup (arg);\n-      gnat_argc++;\n-      break;\n-\n-    case OPT_gdwarf_:\n-      gnat_dwarf_extensions ++;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return 1;\n-}\n-\n-/* Initialize for option processing.  */\n-\n-static unsigned int\n-gnat_init_options (unsigned int argc, const char **argv)\n-{\n-  /* Initialize gnat_argv with save_argv size.  */\n-  gnat_argv = (char **) xmalloc ((argc + 1) * sizeof (argv[0]));\n-  gnat_argv[0] = xstrdup (argv[0]);     /* name of the command */\n-  gnat_argc = 1;\n-\n-  save_argc = argc;\n-  save_argv = argv;\n-\n-  /* Uninitialized really means uninitialized in Ada.  */\n-  flag_zero_initialized_in_bss = 0;\n-\n-  return CL_Ada;\n-}\n-\n-/* Post-switch processing.  */\n-\n-bool\n-gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n-{\n-  /* ??? The warning machinery is outsmarted by Ada.  */\n-  warn_unused_parameter = 0;\n-\n-  /* Force eliminate_unused_debug_types to 0 unless an explicit positive\n-     -f has been passed.  This forces the default to 0 for Ada, which might\n-     differ from the common default.  */\n-  if (flag_eliminate_unused_debug_types < 0)\n-    flag_eliminate_unused_debug_types = 1;\n-  else\n-    flag_eliminate_unused_debug_types = 0;\n-\n-  /* Reflect the explicit request of DWARF extensions into the common\n-     flag for use by later passes.  */\n-  if (write_symbols == DWARF2_DEBUG)\n-    use_gnu_debug_info_extensions = gnat_dwarf_extensions > 0;\n-\n-  return false;\n-}\n-\n-/* Here is the function to handle the compiler error processing in GCC.  */\n-\n-static void\n-internal_error_function (const char *msgid, va_list *ap)\n-{\n-  text_info tinfo;\n-  char *buffer, *p, *loc;\n-  String_Template temp, temp_loc;\n-  Fat_Pointer fp, fp_loc;\n-  expanded_location s;\n-\n-  /* Reset the pretty-printer.  */\n-  pp_clear_output_area (global_dc->printer);\n-\n-  /* Format the message into the pretty-printer.  */\n-  tinfo.format_spec = msgid;\n-  tinfo.args_ptr = ap;\n-  tinfo.err_no = errno;\n-  pp_format_verbatim (global_dc->printer, &tinfo);\n-\n-  /* Extract a (writable) pointer to the formatted text.  */\n-  buffer = (char*) pp_formatted_text (global_dc->printer);\n-\n-  /* Go up to the first newline.  */\n-  for (p = buffer; *p; p++)\n-    if (*p == '\\n')\n-      {\n-\t*p = '\\0';\n-\tbreak;\n-      }\n-\n-  temp.Low_Bound = 1;\n-  temp.High_Bound = p - buffer;\n-  fp.Bounds = &temp;\n-  fp.Array = buffer;\n-\n-  s = expand_location (input_location);\n-  if (flag_show_column && s.column != 0)\n-    asprintf (&loc, \"%s:%d:%d\", s.file, s.line, s.column);\n-  else\n-    asprintf (&loc, \"%s:%d\", s.file, s.line);\n-  temp_loc.Low_Bound = 1;\n-  temp_loc.High_Bound = strlen (loc);\n-  fp_loc.Bounds = &temp_loc;\n-  fp_loc.Array = loc;\n-\n-  Current_Error_Node = error_gnat_node;\n-  Compiler_Abort (fp, -1, fp_loc);\n-}\n-\n-/* Perform all the initialization steps that are language-specific.  */\n-\n-static bool\n-gnat_init (void)\n-{\n-  /* Performs whatever initialization steps needed by the language-dependent\n-     lexical analyzer.  */\n-  gnat_init_decl_processing ();\n-\n-  /* Add the input filename as the last argument.  */\n-  gnat_argv[gnat_argc] = (char *) main_input_filename;\n-  gnat_argc++;\n-  gnat_argv[gnat_argc] = 0;\n-\n-  global_dc->internal_error = &internal_error_function;\n-\n-  /* Show that REFERENCE_TYPEs are internal and should be Pmode.  */\n-  internal_reference_types ();\n-\n-  return true;\n-}\n-\n-/* This function is called indirectly from toplev.c to handle incomplete\n-   declarations, i.e. VAR_DECL nodes whose DECL_SIZE is zero.  To be precise,\n-   compile_file in toplev.c makes an indirect call through the function pointer\n-   incomplete_decl_finalize_hook which is initialized to this routine in\n-   init_decl_processing.  */\n-\n-static void\n-gnat_finish_incomplete_decl (tree dont_care ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-}\n-\f\n-/* Compute the alignment of the largest mode that can be used for copying\n-   objects.  */\n-\n-void\n-gnat_compute_largest_alignment (void)\n-{\n-  enum machine_mode mode;\n-\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing)\n-      largest_move_alignment = MIN (BIGGEST_ALIGNMENT,\n-\t\t\t\t    MAX (largest_move_alignment,\n-\t\t\t\t\t GET_MODE_ALIGNMENT (mode)));\n-}\n-\n-/* If we are using the GCC mechanism to process exception handling, we\n-   have to register the personality routine for Ada and to initialize\n-   various language dependent hooks.  */\n-\n-void\n-gnat_init_gcc_eh (void)\n-{\n-#ifdef DWARF2_UNWIND_INFO\n-  /* lang_dependent_init already called dwarf2out_frame_init if true.  */\n-  int dwarf2out_frame_initialized = dwarf2out_do_frame ();\n-#endif\n-\n-  /* We shouldn't do anything if the No_Exceptions_Handler pragma is set,\n-     though. This could for instance lead to the emission of tables with\n-     references to symbols (such as the Ada eh personality routine) within\n-     libraries we won't link against.  */\n-  if (No_Exception_Handlers_Set ())\n-    return;\n-\n-  /* Tell GCC we are handling cleanup actions through exception propagation.\n-     This opens possibilities that we don't take advantage of yet, but is\n-     nonetheless necessary to ensure that fixup code gets assigned to the\n-     right exception regions.  */\n-  using_eh_for_cleanups ();\n-\n-  eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n-\t\t\t\t\t     ? \"__gnat_eh_personality_sj\"\n-\t\t\t\t\t     : \"__gnat_eh_personality\");\n-  lang_eh_type_covers = gnat_eh_type_covers;\n-  lang_eh_runtime_type = gnat_return_tree;\n-  default_init_unwind_resume_libfunc ();\n-\n-  /* Turn on -fexceptions and -fnon-call-exceptions. The first one triggers\n-     the generation of the necessary exception runtime tables. The second one\n-     is useful for two reasons: 1/ we map some asynchronous signals like SEGV\n-     to exceptions, so we need to ensure that the insns which can lead to such\n-     signals are correctly attached to the exception region they pertain to,\n-     2/ Some calls to pure subprograms are handled as libcall blocks and then\n-     marked as \"cannot trap\" if the flag is not set (see emit_libcall_block).\n-     We should not let this be since it is possible for such calls to actually\n-     raise in Ada.  */\n-  flag_exceptions = 1;\n-  flag_non_call_exceptions = 1;\n-\n-  init_eh ();\n-#ifdef DWARF2_UNWIND_INFO\n-  if (!dwarf2out_frame_initialized && dwarf2out_do_frame ())\n-    dwarf2out_frame_init ();\n-#endif\n-}\n-\n-/* Language hooks, first one to print language-specific items in a DECL.  */\n-\n-static void\n-gnat_print_decl (FILE *file, tree node, int indent)\n-{\n-  switch (TREE_CODE (node))\n-    {\n-    case CONST_DECL:\n-      print_node (file, \"const_corresponding_var\",\n-\t\t  DECL_CONST_CORRESPONDING_VAR (node), indent + 4);\n-      break;\n-\n-    case FIELD_DECL:\n-      print_node (file, \"original_field\", DECL_ORIGINAL_FIELD (node),\n-\t\t  indent + 4);\n-      break;\n-\n-    case VAR_DECL:\n-      print_node (file, \"renamed_object\", DECL_RENAMED_OBJECT (node),\n-\t\t  indent + 4);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-static void\n-gnat_print_type (FILE *file, tree node, int indent)\n-{\n-  switch (TREE_CODE (node))\n-    {\n-    case FUNCTION_TYPE:\n-      print_node (file, \"ci_co_list\", TYPE_CI_CO_LIST (node), indent + 4);\n-      break;\n-\n-    case ENUMERAL_TYPE:\n-      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n-      break;\n-\n-    case INTEGER_TYPE:\n-      if (TYPE_MODULAR_P (node))\n-\tprint_node (file, \"modulus\", TYPE_MODULUS (node), indent + 4);\n-      else if (TYPE_HAS_ACTUAL_BOUNDS_P (node))\n-\tprint_node (file, \"actual bounds\", TYPE_ACTUAL_BOUNDS (node),\n-\t\t    indent + 4);\n-      else if (TYPE_VAX_FLOATING_POINT_P (node))\n-\t;\n-      else\n-\tprint_node (file, \"index type\", TYPE_INDEX_TYPE (node), indent + 4);\n-\n-      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n-      break;\n-\n-    case ARRAY_TYPE:\n-      print_node (file,\"actual bounds\", TYPE_ACTUAL_BOUNDS (node), indent + 4);\n-      break;\n-\n-    case RECORD_TYPE:\n-      if (TYPE_IS_FAT_POINTER_P (node) || TYPE_CONTAINS_TEMPLATE_P (node))\n-\tprint_node (file, \"unconstrained array\",\n-\t\t    TYPE_UNCONSTRAINED_ARRAY (node), indent + 4);\n-      else\n-\tprint_node (file, \"Ada size\", TYPE_ADA_SIZE (node), indent + 4);\n-      break;\n-\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      print_node (file, \"Ada size\", TYPE_ADA_SIZE (node), indent + 4);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-static const char *\n-gnat_dwarf_name (tree t, int verbosity ATTRIBUTE_UNUSED)\n-{\n-  gcc_assert (DECL_P (t));\n-\n-  return (const char *) IDENTIFIER_POINTER (DECL_NAME (t));\n-}\n-\n-static const char *\n-gnat_printable_name (tree decl, int verbosity)\n-{\n-  const char *coded_name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-  char *ada_name = (char *) ggc_alloc (strlen (coded_name) * 2 + 60);\n-\n-  __gnat_decode (coded_name, ada_name, 0);\n-\n-  if (verbosity == 2)\n-    {\n-      Set_Identifier_Casing (ada_name, (char *) DECL_SOURCE_FILE (decl));\n-      ada_name = Name_Buffer;\n-    }\n-\n-  return (const char *) ada_name;\n-}\n-\n-/* Expands GNAT-specific GCC tree nodes.  The only ones we support\n-   here are  and NULL_EXPR.  */\n-\n-static rtx\n-gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n-\t\t  int modifier, rtx *alt_rtl)\n-{\n-  tree type = TREE_TYPE (exp);\n-  tree new;\n-\n-  /* Update EXP to be the new expression to expand.  */\n-  switch (TREE_CODE (exp))\n-    {\n-#if 0\n-    case ALLOCATE_EXPR:\n-      return\n-\tallocate_dynamic_stack_space\n-\t  (expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, TYPE_MODE (sizetype),\n-\t\t\tEXPAND_NORMAL),\n-\t   NULL_RTX, tree_low_cst (TREE_OPERAND (exp, 1), 1));\n-#endif\n-\n-    case UNCONSTRAINED_ARRAY_REF:\n-      /* If we are evaluating just for side-effects, just evaluate our\n-\t operand.  Otherwise, abort since this code should never appear\n-\t in a tree to be evaluated (objects aren't unconstrained).  */\n-      if (target == const0_rtx || TREE_CODE (type) == VOID_TYPE)\n-\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n-\t\t\t    VOIDmode, modifier);\n-\n-      /* ... fall through ... */\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return expand_expr_real (new, target, tmode, modifier, alt_rtl);\n-}\n-\n-/* Do nothing (return the tree node passed).  */\n-\n-static tree\n-gnat_return_tree (tree t)\n-{\n-  return t;\n-}\n-\n-/* Return true if type A catches type B. Callback for flow analysis from\n-   the exception handling part of the back-end.  */\n-\n-static int\n-gnat_eh_type_covers (tree a, tree b)\n-{\n-  /* a catches b if they represent the same exception id or if a\n-     is an \"others\".\n-\n-     ??? integer_zero_node for \"others\" is hardwired in too many places\n-     currently.  */\n-  return (a == b || a == integer_zero_node);\n-}\n-\f\n-/* Get the alias set corresponding to a type or expression.  */\n-\n-static alias_set_type\n-gnat_get_alias_set (tree type)\n-{\n-  /* If this is a padding type, use the type of the first field.  */\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (type))\n-    return get_alias_set (TREE_TYPE (TYPE_FIELDS (type)));\n-\n-  /* If the type is an unconstrained array, use the type of the\n-     self-referential array we make.  */\n-  else if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n-    return\n-      get_alias_set (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))));\n-\n-  /* If the type can alias any other types, return the alias set 0.  */\n-  else if (TYPE_P (type)\n-\t   && TYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (type)))\n-    return 0;\n-\n-  return -1;\n-}\n-\n-/* GNU_TYPE is a type.  Return its maximum size in bytes, if known,\n-   as a constant when possible.  */\n-\n-static tree\n-gnat_type_max_size (const_tree gnu_type)\n-{\n-  /* First see what we can get from TYPE_SIZE_UNIT, which might not\n-     be constant even for simple expressions if it has already been\n-     elaborated and possibly replaced by a VAR_DECL.  */\n-  tree max_unitsize = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n-\n-  /* If we don't have a constant, see what we can get from TYPE_ADA_SIZE,\n-     which should stay untouched.  */\n-  if (!host_integerp (max_unitsize, 1)\n-      && (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t  || TREE_CODE (gnu_type) == UNION_TYPE\n-\t  || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n-      && TYPE_ADA_SIZE (gnu_type))\n-    {\n-      tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n-\n-      /* If we have succeeded in finding a constant, round it up to the\n-\t type's alignment and return the result in units.  */\n-      if (host_integerp (max_adasize, 1))\n-\tmax_unitsize\n-\t  = size_binop (CEIL_DIV_EXPR,\n-\t\t\tround_up (max_adasize, TYPE_ALIGN (gnu_type)),\n-\t\t\tbitsize_unit_node);\n-    }\n-\n-  return max_unitsize;\n-}\n-\n-/* GNU_TYPE is a type. Determine if it should be passed by reference by\n-   default.  */\n-\n-bool\n-default_pass_by_ref (tree gnu_type)\n-{\n-  /* We pass aggregates by reference if they are sufficiently large.  The\n-     choice of constant here is somewhat arbitrary.  We also pass by\n-     reference if the target machine would either pass or return by\n-     reference.  Strictly speaking, we need only check the return if this\n-     is an In Out parameter, but it's probably best to err on the side of\n-     passing more things by reference.  */\n-\n-  if (pass_by_reference (NULL, TYPE_MODE (gnu_type), gnu_type, 1))\n-    return true;\n-\n-  if (targetm.calls.return_in_memory (gnu_type, NULL_TREE))\n-    return true;\n-\n-  if (AGGREGATE_TYPE_P (gnu_type)\n-      && (!host_integerp (TYPE_SIZE (gnu_type), 1)\n-\t  || 0 < compare_tree_int (TYPE_SIZE (gnu_type),\n-\t\t\t\t   8 * TYPE_ALIGN (gnu_type))))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type if\n-   it should be passed by reference. */\n-\n-bool\n-must_pass_by_ref (tree gnu_type)\n-{\n-  /* We pass only unconstrained objects, those required by the language\n-     to be passed by reference, and objects of variable size.  The latter\n-     is more efficient, avoids problems with variable size temporaries,\n-     and does not produce compatibility problems with C, since C does\n-     not have such objects.  */\n-  return (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n-\t  || (AGGREGATE_TYPE_P (gnu_type) && TYPE_BY_REFERENCE_P (gnu_type))\n-\t  || (TYPE_SIZE (gnu_type)\n-\t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n-}\n-\n-/* This function is called by the front end to enumerate all the supported\n-   modes for the machine.  We pass a function which is called back with\n-   the following integer parameters:\n-\n-   FLOAT_P\tnonzero if this represents a floating-point mode\n-   COMPLEX_P\tnonzero is this represents a complex mode\n-   COUNT\tcount of number of items, nonzero for vector mode\n-   PRECISION\tnumber of bits in data representation\n-   MANTISSA\tnumber of bits in mantissa, if FP and known, else zero.\n-   SIZE\t\tnumber of bits used to store data\n-   ALIGN\tnumber of bits to which mode is aligned.  */\n-\n-void\n-enumerate_modes (void (*f) (int, int, int, int, int, int, unsigned int))\n-{\n-  enum machine_mode i;\n-\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    {\n-      enum machine_mode j;\n-      bool float_p = 0;\n-      bool complex_p = 0;\n-      bool vector_p = 0;\n-      bool skip_p = 0;\n-      int mantissa = 0;\n-      enum machine_mode inner_mode = i;\n-\n-      switch (GET_MODE_CLASS (i))\n-\t{\n-\tcase MODE_INT:\n-\t  break;\n-\tcase MODE_FLOAT:\n-\t  float_p = 1;\n-\t  break;\n-\tcase MODE_COMPLEX_INT:\n-\t  complex_p = 1;\n-\t  inner_mode = GET_MODE_INNER (i);\n-\t  break;\n-\tcase MODE_COMPLEX_FLOAT:\n-\t  float_p = 1;\n-\t  complex_p = 1;\n-\t  inner_mode = GET_MODE_INNER (i);\n-\t  break;\n-\tcase MODE_VECTOR_INT:\n-\t  vector_p = 1;\n-\t  inner_mode = GET_MODE_INNER (i);\n-\t  break;\n-\tcase MODE_VECTOR_FLOAT:\n-\t  float_p = 1;\n-\t  vector_p = 1;\n-\t  inner_mode = GET_MODE_INNER (i);\n-\t  break;\n-\tdefault:\n-\t  skip_p = 1;\n-\t}\n-\n-      /* Skip this mode if it's one the front end doesn't need to know about\n-\t (e.g., the CC modes) or if there is no add insn for that mode (or\n-\t any wider mode), meaning it is not supported by the hardware.  If\n-\t this a complex or vector mode, we care about the inner mode.  */\n-      for (j = inner_mode; j != VOIDmode; j = GET_MODE_WIDER_MODE (j))\n-\tif (optab_handler (add_optab, j)->insn_code != CODE_FOR_nothing)\n-\t  break;\n-\n-      if (float_p)\n-\t{\n-\t  const struct real_format *fmt = REAL_MODE_FORMAT (inner_mode);\n-\n-\t  mantissa = fmt->p;\n-\t}\n-\n-      if (!skip_p && j != VOIDmode)\n-\t(*f) (float_p, complex_p, vector_p ? GET_MODE_NUNITS (i) : 0,\n-\t      GET_MODE_BITSIZE (i), mantissa,\n-\t      GET_MODE_SIZE (i) * BITS_PER_UNIT, GET_MODE_ALIGNMENT (i));\n-    }\n-}\n-\n-int\n-fp_prec_to_size (int prec)\n-{\n-  enum machine_mode mode;\n-\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_PRECISION (mode) == prec)\n-      return GET_MODE_BITSIZE (mode);\n-\n-  gcc_unreachable ();\n-}\n-\n-int\n-fp_size_to_prec (int size)\n-{\n-  enum machine_mode mode;\n-\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_BITSIZE (mode) == size)\n-      return GET_MODE_PRECISION (mode);\n-\n-  gcc_unreachable ();\n-}"}, {"sha": "c4e3299667dabe533c0bda7758ff471dfc3de1cf", "filename": "gcc/ada/targtyps.c", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargtyps.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,230 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                            T A R G T Y P S                               *\n- *                                                                          *\n- *                                  Body                                    *\n- *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have  received  a copy of the GNU General *\n- * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n- * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n- * Boston, MA 02110-1301, USA.                                              *\n- *                                                                          *\n- * As a  special  exception,  if you  link  this file  with other  files to *\n- * produce an executable,  this file does not by itself cause the resulting *\n- * executable to be covered by the GNU General Public License. This except- *\n- * ion does not  however invalidate  any other reasons  why the  executable *\n- * file might be covered by the  GNU Public License.                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/* Functions for retrieving target types. See Ada package Get_Targ */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"real.h\"\n-#include \"rtl.h\"\n-#include \"ada.h\"\n-#include \"types.h\"\n-#include \"atree.h\"\n-#include \"elists.h\"\n-#include \"namet.h\"\n-#include \"nlists.h\"\n-#include \"snames.h\"\n-#include \"stringt.h\"\n-#include \"uintp.h\"\n-#include \"urealp.h\"\n-#include \"fe.h\"\n-#include \"sinfo.h\"\n-#include \"einfo.h\"\n-#include \"ada-tree.h\"\n-#include \"gigi.h\"\n-\n-/* If we don't have a specific size for Ada's equivalent of `long', use that\n-   of C.  */\n-#ifndef ADA_LONG_TYPE_SIZE\n-#define ADA_LONG_TYPE_SIZE LONG_TYPE_SIZE\n-#endif\n-\n-#ifndef WIDEST_HARDWARE_FP_SIZE\n-#define WIDEST_HARDWARE_FP_SIZE LONG_DOUBLE_TYPE_SIZE\n-#endif\n-\n-/* The following provide a functional interface for the front end Ada code\n-   to determine the sizes that are used for various C types. */\n-\n-Pos\n-get_target_bits_per_unit (void)\n-{\n-  return BITS_PER_UNIT;\n-}\n-\n-Pos\n-get_target_bits_per_word (void)\n-{\n-  return BITS_PER_WORD;\n-}\n-\n-Pos\n-get_target_char_size (void)\n-{\n-  return CHAR_TYPE_SIZE;\n-}\n-\n-Pos\n-get_target_wchar_t_size (void)\n-{\n-  /* We never want wide characters less than \"short\" in Ada.  */\n-  return MAX (SHORT_TYPE_SIZE, WCHAR_TYPE_SIZE);\n-}\n-\n-Pos\n-get_target_short_size (void)\n-{\n-  return SHORT_TYPE_SIZE;\n-}\n-\n-Pos\n-get_target_int_size (void)\n-{\n-  return INT_TYPE_SIZE;\n-}\n-\n-Pos\n-get_target_long_size (void)\n-{\n-  return ADA_LONG_TYPE_SIZE;\n-}\n-\n-Pos\n-get_target_long_long_size (void)\n-{\n-  return LONG_LONG_TYPE_SIZE;\n-}\n-\n-Pos\n-get_target_float_size (void)\n-{\n-  return fp_prec_to_size (FLOAT_TYPE_SIZE);\n-}\n-\n-Pos\n-get_target_double_size (void)\n-{\n-  return fp_prec_to_size (DOUBLE_TYPE_SIZE);\n-}\n-\n-Pos\n-get_target_long_double_size (void)\n-{\n-  return fp_prec_to_size (WIDEST_HARDWARE_FP_SIZE);\n-}\n-\n-\n-Pos\n-get_target_pointer_size (void)\n-{\n-  return POINTER_SIZE;\n-}\n-\n-/* Alignment related values, mapped to attributes for functional and\n-   documentation purposes.  */\n-\n-/* Standard'Maximum_Default_Alignment.  Maximum alignment that the compiler\n-   might choose by default for a type or object.\n-\n-   Stricter alignment requests trigger gigi's aligning_type circuitry for\n-   stack objects or objects allocated by the default allocator.  */\n-\n-Pos\n-get_target_maximum_default_alignment (void)\n-{\n-  return BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n-}\n-\n-/* Standard'Default_Allocator_Alignment.  Alignment guaranteed to be honored\n-   by the default allocator (System.Memory.Alloc or malloc if we have no\n-   run-time library at hand).\n-\n-   Stricter alignment requests trigger gigi's aligning_type circuitry for\n-   objects allocated by the default allocator.  */\n-\n-Pos\n-get_target_default_allocator_alignment (void)\n-{\n-  /* ??? Need a way to get info about __gnat_malloc from here (whether\n-     it is handy and what alignment it honors).  */\n-\n-  return MALLOC_ABI_ALIGNMENT / BITS_PER_UNIT;\n-}\n-\n-/* Standard'Maximum_Allowed_Alignment.  Maximum alignment that we may\n-   accept for any type or object.  */\n-\n-#ifndef MAX_OFILE_ALIGNMENT\n-#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n-#endif\n-\n-Pos\n-get_target_maximum_allowed_alignment (void)\n-{\n-  return MAX_OFILE_ALIGNMENT / BITS_PER_UNIT;\n-}\n-\n-/* Standard'Maximum_Alignment.  The single attribute initially made\n-   available, now a synonym of Standard'Maximum_Default_Alignment.  */\n-\n-Pos\n-get_target_maximum_alignment (void)\n-{\n-  return get_target_maximum_default_alignment ();\n-}\n-\n-#ifndef FLOAT_WORDS_BIG_ENDIAN\n-#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n-#endif\n-\n-Nat\n-get_float_words_be (void)\n-{\n-  return FLOAT_WORDS_BIG_ENDIAN;\n-}\n-\n-Nat\n-get_words_be (void)\n-{\n-  return WORDS_BIG_ENDIAN;\n-}\n-\n-Nat\n-get_bytes_be (void)\n-{\n-  return BYTES_BIG_ENDIAN;\n-}\n-\n-Nat\n-get_bits_be (void)\n-{\n-  return BITS_BIG_ENDIAN;\n-}\n-\n-Nat\n-get_strict_alignment (void)\n-{\n-  return STRICT_ALIGNMENT;\n-}"}, {"sha": "88f9a20a3e6c8895958ce0821ce7c8db2419653a", "filename": "gcc/ada/trans.c", "status": "removed", "additions": 0, "deletions": 7091, "changes": 7091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902"}, {"sha": "cde8d4dd2f3c4fcf779a541c3b5715be309edf51", "filename": "gcc/ada/utils.c", "status": "removed", "additions": 0, "deletions": 4895, "changes": 4895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902"}, {"sha": "300fbd37d01d21517512d2a89f0365cc2a27f708", "filename": "gcc/ada/utils2.c", "status": "removed", "additions": 0, "deletions": 2219, "changes": 2219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54dfd46bffb35c49935053bd9bc2997f77e26902/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=54dfd46bffb35c49935053bd9bc2997f77e26902", "patch": "@@ -1,2219 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                               U T I L S 2                                *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n- * for  more details.  You should have received a copy of the GNU General   *\n- * Public License along with GCC; see the file COPYING3.  If not see        *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"ggc.h\"\n-#include \"flags.h\"\n-#include \"output.h\"\n-#include \"ada.h\"\n-#include \"types.h\"\n-#include \"atree.h\"\n-#include \"stringt.h\"\n-#include \"namet.h\"\n-#include \"uintp.h\"\n-#include \"fe.h\"\n-#include \"elists.h\"\n-#include \"nlists.h\"\n-#include \"sinfo.h\"\n-#include \"einfo.h\"\n-#include \"ada-tree.h\"\n-#include \"gigi.h\"\n-\n-static tree find_common_type (tree, tree);\n-static bool contains_save_expr_p (tree);\n-static tree contains_null_expr (tree);\n-static tree compare_arrays (tree, tree, tree);\n-static tree nonbinary_modular_operation (enum tree_code, tree, tree, tree);\n-static tree build_simple_component_ref (tree, tree, tree, bool);\n-\f\n-/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n-   operation.\n-\n-   This preparation consists of taking the ordinary representation of\n-   an expression expr and producing a valid tree boolean expression\n-   describing whether expr is nonzero. We could simply always do\n-\n-      build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n-\n-   but we optimize comparisons, &&, ||, and !.\n-\n-   The resulting type should always be the same as the input type.\n-   This function is simpler than the corresponding C version since\n-   the only possible operands will be things of Boolean type.  */\n-\n-tree\n-gnat_truthvalue_conversion (tree expr)\n-{\n-  tree type = TREE_TYPE (expr);\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case EQ_EXPR:  case NE_EXPR: case LE_EXPR: case GE_EXPR:\n-    case LT_EXPR:  case GT_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case ERROR_MARK:\n-      return expr;\n-\n-    case INTEGER_CST:\n-      return (integer_zerop (expr)\n-\t      ? build_int_cst (type, 0)\n-\t      : build_int_cst (type, 1));\n-\n-    case REAL_CST:\n-      return (real_zerop (expr)\n-\t      ? fold_convert (type, integer_zero_node)\n-\t      : fold_convert (type, integer_one_node));\n-\n-    case COND_EXPR:\n-      /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      {\n-\ttree arg1 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 1));\n-\ttree arg2 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 2));\n-\treturn fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t\t    arg1, arg2);\n-      }\n-\n-    default:\n-      return build_binary_op (NE_EXPR, type, expr,\n-\t\t\t      fold_convert (type, integer_zero_node));\n-    }\n-}\n-\f\n-/* Return the base type of TYPE.  */\n-\n-tree\n-get_base_type (tree type)\n-{\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_JUSTIFIED_MODULAR_P (type))\n-    type = TREE_TYPE (TYPE_FIELDS (type));\n-\n-  while (TREE_TYPE (type)\n-\t && (TREE_CODE (type) == INTEGER_TYPE\n-\t     || TREE_CODE (type) == REAL_TYPE))\n-    type = TREE_TYPE (type);\n-\n-  return type;\n-}\n-\f\n-/* EXP is a GCC tree representing an address.  See if we can find how\n-   strictly the object at that address is aligned.   Return that alignment\n-   in bits.  If we don't know anything about the alignment, return 0.  */\n-\n-unsigned int\n-known_alignment (tree exp)\n-{\n-  unsigned int this_alignment;\n-  unsigned int lhs, rhs;\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    CASE_CONVERT:\n-    case VIEW_CONVERT_EXPR:\n-    case NON_LVALUE_EXPR:\n-      /* Conversions between pointers and integers don't change the alignment\n-\t of the underlying object.  */\n-      this_alignment = known_alignment (TREE_OPERAND (exp, 0));\n-      break;\n-\n-    case COMPOUND_EXPR:\n-      /* The value of a COMPOUND_EXPR is that of it's second operand.  */\n-      this_alignment = known_alignment (TREE_OPERAND (exp, 1));\n-      break;\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      /* If two address are added, the alignment of the result is the\n-\t minimum of the two alignments.  */\n-      lhs = known_alignment (TREE_OPERAND (exp, 0));\n-      rhs = known_alignment (TREE_OPERAND (exp, 1));\n-      this_alignment = MIN (lhs, rhs);\n-      break;\n-\n-    case POINTER_PLUS_EXPR:\n-      lhs = known_alignment (TREE_OPERAND (exp, 0));\n-      rhs = known_alignment (TREE_OPERAND (exp, 1));\n-      /* If we don't know the alignment of the offset, we assume that\n-\t of the base.  */\n-      if (rhs == 0)\n-\tthis_alignment = lhs;\n-      else\n-\tthis_alignment = MIN (lhs, rhs);\n-      break;\n-\n-    case COND_EXPR:\n-      /* If there is a choice between two values, use the smallest one.  */\n-      lhs = known_alignment (TREE_OPERAND (exp, 1));\n-      rhs = known_alignment (TREE_OPERAND (exp, 2));\n-      this_alignment = MIN (lhs, rhs);\n-      break;\n-\n-    case INTEGER_CST:\n-      {\n-\tunsigned HOST_WIDE_INT c = TREE_INT_CST_LOW (exp);\n-\t/* The first part of this represents the lowest bit in the constant,\n-\t   but it is originally in bytes, not bits.  */\n-\tthis_alignment = MIN (BITS_PER_UNIT * (c & -c), BIGGEST_ALIGNMENT);\n-      }\n-      break;\n-\n-    case MULT_EXPR:\n-      /* If we know the alignment of just one side, use it.  Otherwise,\n-\t use the product of the alignments.  */\n-      lhs = known_alignment (TREE_OPERAND (exp, 0));\n-      rhs = known_alignment (TREE_OPERAND (exp, 1));\n-\n-      if (lhs == 0)\n-\tthis_alignment = rhs;\n-      else if (rhs == 0)\n-\tthis_alignment = lhs;\n-      else\n-\tthis_alignment = MIN (lhs * rhs, BIGGEST_ALIGNMENT);\n-      break;\n-\n-    case BIT_AND_EXPR:\n-      /* A bit-and expression is as aligned as the maximum alignment of the\n-\t operands.  We typically get here for a complex lhs and a constant\n-\t negative power of two on the rhs to force an explicit alignment, so\n-\t don't bother looking at the lhs.  */\n-      this_alignment = known_alignment (TREE_OPERAND (exp, 1));\n-      break;\n-\n-    case ADDR_EXPR:\n-      this_alignment = expr_align (TREE_OPERAND (exp, 0));\n-      break;\n-\n-    default:\n-      /* For other pointer expressions, we assume that the pointed-to object\n-\t is at least as aligned as the pointed-to type.  Beware that we can\n-\t have a dummy type here (e.g. a Taft Amendment type), for which the\n-\t alignment is meaningless and should be ignored.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (exp))\n-\t  && !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n-\tthis_alignment = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n-      else\n-\tthis_alignment = 0;\n-      break;\n-    }\n-\n-  return this_alignment;\n-}\n-\f\n-/* We have a comparison or assignment operation on two types, T1 and T2, which\n-   are either both array types or both record types.  T1 is assumed to be for\n-   the left hand side operand, and T2 for the right hand side.  Return the\n-   type that both operands should be converted to for the operation, if any.\n-   Otherwise return zero.  */\n-\n-static tree\n-find_common_type (tree t1, tree t2)\n-{\n-  /* ??? As of today, various constructs lead here with types of different\n-     sizes even when both constants (e.g. tagged types, packable vs regular\n-     component types, padded vs unpadded types, ...).  While some of these\n-     would better be handled upstream (types should be made consistent before\n-     calling into build_binary_op), some others are really expected and we\n-     have to be careful.  */\n-\n-  /* We must prevent writing more than what the target may hold if this is for\n-     an assignment and the case of tagged types is handled in build_binary_op\n-     so use the lhs type if it is known to be smaller, or of constant size and\n-     the rhs type is not, whatever the modes.  We also force t1 in case of\n-     constant size equality to minimize occurrences of view conversions on the\n-     lhs of assignments.  */\n-  if (TREE_CONSTANT (TYPE_SIZE (t1))\n-      && (!TREE_CONSTANT (TYPE_SIZE (t2))\n-          || !tree_int_cst_lt (TYPE_SIZE (t2), TYPE_SIZE (t1))))\n-    return t1;\n-\n-  /* Otherwise, if the lhs type is non-BLKmode, use it.  Note that we know\n-     that we will not have any alignment problems since, if we did, the\n-     non-BLKmode type could not have been used.  */\n-  if (TYPE_MODE (t1) != BLKmode)\n-    return t1;\n-\n-  /* If the rhs type is of constant size, use it whatever the modes.  At\n-     this point it is known to be smaller, or of constant size and the\n-     lhs type is not.  */\n-  if (TREE_CONSTANT (TYPE_SIZE (t2)))\n-    return t2;\n-\n-  /* Otherwise, if the rhs type is non-BLKmode, use it.  */\n-  if (TYPE_MODE (t2) != BLKmode)\n-    return t2;\n-\n-  /* In this case, both types have variable size and BLKmode.  It's\n-     probably best to leave the \"type mismatch\" because changing it\n-     could cause a bad self-referential reference.  */\n-  return NULL_TREE;\n-}\n-\f\n-/* See if EXP contains a SAVE_EXPR in a position where we would\n-   normally put it.\n-\n-   ??? This is a real kludge, but is probably the best approach short\n-   of some very general solution.  */\n-\n-static bool\n-contains_save_expr_p (tree exp)\n-{\n-  switch (TREE_CODE (exp))\n-    {\n-    case SAVE_EXPR:\n-      return true;\n-\n-    case ADDR_EXPR:  case INDIRECT_REF:\n-    case COMPONENT_REF:\n-    CASE_CONVERT: case VIEW_CONVERT_EXPR:\n-      return contains_save_expr_p (TREE_OPERAND (exp, 0));\n-\n-    case CONSTRUCTOR:\n-      {\n-\ttree value;\n-\tunsigned HOST_WIDE_INT ix;\n-\n-\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), ix, value)\n-\t  if (contains_save_expr_p (value))\n-\t    return true;\n-\treturn false;\n-      }\n-\n-    default:\n-      return false;\n-    }\n-}\n-\f\n-/* See if EXP contains a NULL_EXPR in an expression we use for sizes. Return\n-   it if so.  This is used to detect types whose sizes involve computations\n-   that are known to raise Constraint_Error.  */\n-\n-static tree\n-contains_null_expr (tree exp)\n-{\n-  tree tem;\n-\n-  if (TREE_CODE (exp) == NULL_EXPR)\n-    return exp;\n-\n-  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n-    {\n-    case tcc_unary:\n-      return contains_null_expr (TREE_OPERAND (exp, 0));\n-\n-    case tcc_comparison:\n-    case tcc_binary:\n-      tem = contains_null_expr (TREE_OPERAND (exp, 0));\n-      if (tem)\n-\treturn tem;\n-\n-      return contains_null_expr (TREE_OPERAND (exp, 1));\n-\n-    case tcc_expression:\n-      switch (TREE_CODE (exp))\n-\t{\n-\tcase SAVE_EXPR:\n-\t  return contains_null_expr (TREE_OPERAND (exp, 0));\n-\n-\tcase COND_EXPR:\n-\t  tem = contains_null_expr (TREE_OPERAND (exp, 0));\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  tem = contains_null_expr (TREE_OPERAND (exp, 1));\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  return contains_null_expr (TREE_OPERAND (exp, 2));\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\f\n-/* Return an expression tree representing an equality comparison of\n-   A1 and A2, two objects of ARRAY_TYPE.  The returned expression should\n-   be of type RESULT_TYPE\n-\n-   Two arrays are equal in one of two ways: (1) if both have zero length\n-   in some dimension (not necessarily the same dimension) or (2) if the\n-   lengths in each dimension are equal and the data is equal.  We perform the\n-   length tests in as efficient a manner as possible.  */\n-\n-static tree\n-compare_arrays (tree result_type, tree a1, tree a2)\n-{\n-  tree t1 = TREE_TYPE (a1);\n-  tree t2 = TREE_TYPE (a2);\n-  tree result = convert (result_type, integer_one_node);\n-  tree a1_is_null = convert (result_type, integer_zero_node);\n-  tree a2_is_null = convert (result_type, integer_zero_node);\n-  bool length_zero_p = false;\n-\n-  /* Process each dimension separately and compare the lengths.  If any\n-     dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n-     suppress the comparison of the data.  */\n-  while (TREE_CODE (t1) == ARRAY_TYPE && TREE_CODE (t2) == ARRAY_TYPE)\n-    {\n-      tree lb1 = TYPE_MIN_VALUE (TYPE_DOMAIN (t1));\n-      tree ub1 = TYPE_MAX_VALUE (TYPE_DOMAIN (t1));\n-      tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n-      tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n-      tree bt = get_base_type (TREE_TYPE (lb1));\n-      tree length1 = fold_build2 (MINUS_EXPR, bt, ub1, lb1);\n-      tree length2 = fold_build2 (MINUS_EXPR, bt, ub2, lb2);\n-      tree nbt;\n-      tree tem;\n-      tree comparison, this_a1_is_null, this_a2_is_null;\n-\n-      /* If the length of the first array is a constant, swap our operands\n-\t unless the length of the second array is the constant zero.\n-\t Note that we have set the `length' values to the length - 1.  */\n-      if (TREE_CODE (length1) == INTEGER_CST\n-\t  && !integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n-\t\t\t\t\t  convert (bt, integer_one_node))))\n-\t{\n-\t  tem = a1, a1 = a2, a2 = tem;\n-\t  tem = t1, t1 = t2, t2 = tem;\n-\t  tem = lb1, lb1 = lb2, lb2 = tem;\n-\t  tem = ub1, ub1 = ub2, ub2 = tem;\n-\t  tem = length1, length1 = length2, length2 = tem;\n-\t  tem = a1_is_null, a1_is_null = a2_is_null, a2_is_null = tem;\n-\t}\n-\n-      /* If the length of this dimension in the second array is the constant\n-\t zero, we can just go inside the original bounds for the first\n-\t array and see if last < first.  */\n-      if (integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n-\t\t\t\t      convert (bt, integer_one_node))))\n-\t{\n-\t  tree ub = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\n-\t  comparison = build_binary_op (LT_EXPR, result_type, ub, lb);\n-\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n-\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n-\n-\t  length_zero_p = true;\n-\t  this_a1_is_null = comparison;\n-\t  this_a2_is_null = convert (result_type, integer_one_node);\n-\t}\n-\n-      /* If the length is some other constant value, we know that the\n-\t this dimension in the first array cannot be superflat, so we\n-\t can just use its length from the actual stored bounds.  */\n-      else if (TREE_CODE (length2) == INTEGER_CST)\n-\t{\n-\t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\t  ub2 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n-\t  lb2 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n-\t  nbt = get_base_type (TREE_TYPE (ub1));\n-\n-\t  comparison\n-\t    = build_binary_op (EQ_EXPR, result_type,\n-\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub1, lb1),\n-\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub2, lb2));\n-\n-\t  /* Note that we know that UB2 and LB2 are constant and hence\n-\t     cannot contain a PLACEHOLDER_EXPR.  */\n-\n-\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n-\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n-\n-\t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n-\t  this_a2_is_null = convert (result_type, integer_zero_node);\n-\t}\n-\n-      /* Otherwise compare the computed lengths.  */\n-      else\n-\t{\n-\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n-\t  length2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length2, a2);\n-\n-\t  comparison\n-\t    = build_binary_op (EQ_EXPR, result_type, length1, length2);\n-\n-\t  this_a1_is_null\n-\t    = build_binary_op (LT_EXPR, result_type, length1,\n-\t\t\t       convert (bt, integer_zero_node));\n-\t  this_a2_is_null\n-\t    = build_binary_op (LT_EXPR, result_type, length2,\n-\t\t\t       convert (bt, integer_zero_node));\n-\t}\n-\n-      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n-\t\t\t\tresult, comparison);\n-\n-      a1_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n-\t\t\t\t    this_a1_is_null, a1_is_null);\n-      a2_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n-\t\t\t\t    this_a2_is_null, a2_is_null);\n-\n-      t1 = TREE_TYPE (t1);\n-      t2 = TREE_TYPE (t2);\n-    }\n-\n-  /* Unless the size of some bound is known to be zero, compare the\n-     data in the array.  */\n-  if (!length_zero_p)\n-    {\n-      tree type = find_common_type (TREE_TYPE (a1), TREE_TYPE (a2));\n-\n-      if (type)\n-\ta1 = convert (type, a1), a2 = convert (type, a2);\n-\n-      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n-\t\t\t\tfold_build2 (EQ_EXPR, result_type, a1, a2));\n-\n-    }\n-\n-  /* The result is also true if both sizes are zero.  */\n-  result = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n-\t\t\t    build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n-\t\t\t\t\t     a1_is_null, a2_is_null),\n-\t\t\t    result);\n-\n-  /* If either operand contains SAVE_EXPRs, they have to be evaluated before\n-     starting the comparison above since the place it would be otherwise\n-     evaluated would be wrong.  */\n-\n-  if (contains_save_expr_p (a1))\n-    result = build2 (COMPOUND_EXPR, result_type, a1, result);\n-\n-  if (contains_save_expr_p (a2))\n-    result = build2 (COMPOUND_EXPR, result_type, a2, result);\n-\n-  return result;\n-}\n-\f\n-/* Compute the result of applying OP_CODE to LHS and RHS, where both are of\n-   type TYPE.  We know that TYPE is a modular type with a nonbinary\n-   modulus.  */\n-\n-static tree\n-nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n-                             tree rhs)\n-{\n-  tree modulus = TYPE_MODULUS (type);\n-  unsigned int needed_precision = tree_floor_log2 (modulus) + 1;\n-  unsigned int precision;\n-  bool unsignedp = true;\n-  tree op_type = type;\n-  tree result;\n-\n-  /* If this is an addition of a constant, convert it to a subtraction\n-     of a constant since we can do that faster.  */\n-  if (op_code == PLUS_EXPR && TREE_CODE (rhs) == INTEGER_CST)\n-    {\n-      rhs = fold_build2 (MINUS_EXPR, type, modulus, rhs);\n-      op_code = MINUS_EXPR;\n-    }\n-\n-  /* For the logical operations, we only need PRECISION bits.  For\n-     addition and subtraction, we need one more and for multiplication we\n-     need twice as many.  But we never want to make a size smaller than\n-     our size. */\n-  if (op_code == PLUS_EXPR || op_code == MINUS_EXPR)\n-    needed_precision += 1;\n-  else if (op_code == MULT_EXPR)\n-    needed_precision *= 2;\n-\n-  precision = MAX (needed_precision, TYPE_PRECISION (op_type));\n-\n-  /* Unsigned will do for everything but subtraction.  */\n-  if (op_code == MINUS_EXPR)\n-    unsignedp = false;\n-\n-  /* If our type is the wrong signedness or isn't wide enough, make a new\n-     type and convert both our operands to it.  */\n-  if (TYPE_PRECISION (op_type) < precision\n-      || TYPE_UNSIGNED (op_type) != unsignedp)\n-    {\n-      /* Copy the node so we ensure it can be modified to make it modular.  */\n-      op_type = copy_node (gnat_type_for_size (precision, unsignedp));\n-      modulus = convert (op_type, modulus);\n-      SET_TYPE_MODULUS (op_type, modulus);\n-      TYPE_MODULAR_P (op_type) = 1;\n-      lhs = convert (op_type, lhs);\n-      rhs = convert (op_type, rhs);\n-    }\n-\n-  /* Do the operation, then we'll fix it up.  */\n-  result = fold_build2 (op_code, op_type, lhs, rhs);\n-\n-  /* For multiplication, we have no choice but to do a full modulus\n-     operation.  However, we want to do this in the narrowest\n-     possible size.  */\n-  if (op_code == MULT_EXPR)\n-    {\n-      tree div_type = copy_node (gnat_type_for_size (needed_precision, 1));\n-      modulus = convert (div_type, modulus);\n-      SET_TYPE_MODULUS (div_type, modulus);\n-      TYPE_MODULAR_P (div_type) = 1;\n-      result = convert (op_type,\n-\t\t\tfold_build2 (TRUNC_MOD_EXPR, div_type,\n-\t\t\t\t     convert (div_type, result), modulus));\n-    }\n-\n-  /* For subtraction, add the modulus back if we are negative.  */\n-  else if (op_code == MINUS_EXPR)\n-    {\n-      result = save_expr (result);\n-      result = fold_build3 (COND_EXPR, op_type,\n-\t\t\t    fold_build2 (LT_EXPR, integer_type_node, result,\n-\t\t\t\t\t convert (op_type, integer_zero_node)),\n-\t\t\t    fold_build2 (PLUS_EXPR, op_type, result, modulus),\n-\t\t\t    result);\n-    }\n-\n-  /* For the other operations, subtract the modulus if we are >= it.  */\n-  else\n-    {\n-      result = save_expr (result);\n-      result = fold_build3 (COND_EXPR, op_type,\n-\t\t\t    fold_build2 (GE_EXPR, integer_type_node,\n-\t\t\t\t\t result, modulus),\n-\t\t\t    fold_build2 (MINUS_EXPR, op_type,\n-\t\t\t\t\t result, modulus),\n-\t\t\t    result);\n-    }\n-\n-  return convert (type, result);\n-}\n-\f\n-/* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n-   desired for the result.  Usually the operation is to be performed\n-   in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n-   in which case the type to be used will be derived from the operands.\n-\n-   This function is very much unlike the ones for C and C++ since we\n-   have already done any type conversion and matching required.  All we\n-   have to do here is validate the work done by SEM and handle subtypes.  */\n-\n-tree\n-build_binary_op (enum tree_code op_code, tree result_type,\n-                 tree left_operand, tree right_operand)\n-{\n-  tree left_type  = TREE_TYPE (left_operand);\n-  tree right_type = TREE_TYPE (right_operand);\n-  tree left_base_type = get_base_type (left_type);\n-  tree right_base_type = get_base_type (right_type);\n-  tree operation_type = result_type;\n-  tree best_type = NULL_TREE;\n-  tree modulus, result;\n-  bool has_side_effects = false;\n-\n-  if (operation_type\n-      && TREE_CODE (operation_type) == RECORD_TYPE\n-      && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n-    operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n-\n-  if (operation_type\n-      && !AGGREGATE_TYPE_P (operation_type)\n-      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n-    operation_type = get_base_type (operation_type);\n-\n-  modulus = (operation_type\n-\t     && TREE_CODE (operation_type) == INTEGER_TYPE\n-\t     && TYPE_MODULAR_P (operation_type)\n-\t     ? TYPE_MODULUS (operation_type) : NULL_TREE);\n-\n-  switch (op_code)\n-    {\n-    case MODIFY_EXPR:\n-      /* If there were integral or pointer conversions on the LHS, remove\n-\t them; we'll be putting them back below if needed.  Likewise for\n-\t conversions between array and record types, except for justified\n-\t modular types.  But don't do this if the right operand is not\n-\t BLKmode (for packed arrays) unless we are not changing the mode.  */\n-      while ((CONVERT_EXPR_P (left_operand)\n-\t      || TREE_CODE (left_operand) == VIEW_CONVERT_EXPR)\n-\t     && (((INTEGRAL_TYPE_P (left_type)\n-\t\t   || POINTER_TYPE_P (left_type))\n-\t\t  && (INTEGRAL_TYPE_P (TREE_TYPE\n-\t\t\t\t       (TREE_OPERAND (left_operand, 0)))\n-\t\t      || POINTER_TYPE_P (TREE_TYPE\n-\t\t\t\t\t (TREE_OPERAND (left_operand, 0)))))\n-\t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n-\t\t       && !TYPE_JUSTIFIED_MODULAR_P (left_type))\n-\t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n-\t\t     && ((TREE_CODE (TREE_TYPE\n-\t\t\t\t     (TREE_OPERAND (left_operand, 0)))\n-\t\t\t  == RECORD_TYPE)\n-\t\t\t || (TREE_CODE (TREE_TYPE\n-\t\t\t\t\t(TREE_OPERAND (left_operand, 0)))\n-\t\t\t     == ARRAY_TYPE))\n-\t\t     && (TYPE_MODE (right_type) == BLKmode\n-\t\t\t || (TYPE_MODE (left_type)\n-\t\t\t     == TYPE_MODE (TREE_TYPE\n-\t\t\t\t\t   (TREE_OPERAND\n-\t\t\t\t\t    (left_operand, 0))))))))\n-\t{\n-\t  left_operand = TREE_OPERAND (left_operand, 0);\n-\t  left_type = TREE_TYPE (left_operand);\n-\t}\n-\n-      /* If a class-wide type may be involved, force use of the RHS type.  */\n-      if ((TREE_CODE (right_type) == RECORD_TYPE\n-\t   || TREE_CODE (right_type) == UNION_TYPE)\n-\t  && TYPE_ALIGN_OK (right_type))\n-\toperation_type = right_type;\n-\n-      /* If we are copying between padded objects with compatible types, use\n-\t the padded view of the objects, this is very likely more efficient.\n-\t Likewise for a padded that is assigned a constructor, in order to\n-\t avoid putting a VIEW_CONVERT_EXPR on the LHS.  But don't do this if\n-\t we wouldn't have actually copied anything.  */\n-      else if (TREE_CODE (left_type) == RECORD_TYPE\n-\t       && TYPE_IS_PADDING_P (left_type)\n-\t       && TREE_CONSTANT (TYPE_SIZE (left_type))\n-\t       && ((TREE_CODE (right_operand) == COMPONENT_REF\n-\t\t    && TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t       == RECORD_TYPE\n-\t\t    && TYPE_IS_PADDING_P\n-\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t    && gnat_types_compatible_p\n-\t\t\t(left_type,\n-\t\t\t TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n-\t\t   || TREE_CODE (right_operand) == CONSTRUCTOR)\n-\t       && !integer_zerop (TYPE_SIZE (right_type)))\n-\toperation_type = left_type;\n-\n-      /* Find the best type to use for copying between aggregate types.  */\n-      else if (((TREE_CODE (left_type) == ARRAY_TYPE\n-\t\t && TREE_CODE (right_type) == ARRAY_TYPE)\n-\t\t|| (TREE_CODE (left_type) == RECORD_TYPE\n-\t\t    && TREE_CODE (right_type) == RECORD_TYPE))\n-\t       && (best_type = find_common_type (left_type, right_type)))\n-\toperation_type = best_type;\n-\n-      /* Otherwise use the LHS type.  */\n-      else if (!operation_type)\n-\toperation_type = left_type;\n-\n-      /* Ensure everything on the LHS is valid.  If we have a field reference,\n-\t strip anything that get_inner_reference can handle.  Then remove any\n-\t conversions between types having the same code and mode.  And mark\n-\t VIEW_CONVERT_EXPRs with TREE_ADDRESSABLE.  When done, we must have\n-\t either an INDIRECT_REF, a NULL_EXPR or a DECL node.  */\n-      result = left_operand;\n-      while (true)\n-\t{\n-\t  tree restype = TREE_TYPE (result);\n-\n-\t  if (TREE_CODE (result) == COMPONENT_REF\n-\t      || TREE_CODE (result) == ARRAY_REF\n-\t      || TREE_CODE (result) == ARRAY_RANGE_REF)\n-\t    while (handled_component_p (result))\n-\t      result = TREE_OPERAND (result, 0);\n-\t  else if (TREE_CODE (result) == REALPART_EXPR\n-\t\t   || TREE_CODE (result) == IMAGPART_EXPR\n-\t\t   || (CONVERT_EXPR_P (result)\n-\t\t       && (((TREE_CODE (restype)\n-\t\t\t     == TREE_CODE (TREE_TYPE\n-\t\t\t\t\t   (TREE_OPERAND (result, 0))))\n-\t\t\t     && (TYPE_MODE (TREE_TYPE\n-\t\t\t\t\t    (TREE_OPERAND (result, 0)))\n-\t\t\t\t == TYPE_MODE (restype)))\n-\t\t\t   || TYPE_ALIGN_OK (restype))))\n-\t    result = TREE_OPERAND (result, 0);\n-\t  else if (TREE_CODE (result) == VIEW_CONVERT_EXPR)\n-\t    {\n-\t      TREE_ADDRESSABLE (result) = 1;\n-\t      result = TREE_OPERAND (result, 0);\n-\t    }\n-\t  else\n-\t    break;\n-\t}\n-\n-      gcc_assert (TREE_CODE (result) == INDIRECT_REF\n-\t\t  || TREE_CODE (result) == NULL_EXPR\n-\t\t  || DECL_P (result));\n-\n-      /* Convert the right operand to the operation type unless it is\n-\t either already of the correct type or if the type involves a\n-\t placeholder, since the RHS may not have the same record type.  */\n-      if (operation_type != right_type\n-\t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type)))\n-\t{\n-\t  right_operand = convert (operation_type, right_operand);\n-\t  right_type = operation_type;\n-\t}\n-\n-      /* If the left operand is not of the same type as the operation\n-\t type, wrap it up in a VIEW_CONVERT_EXPR.  */\n-      if (left_type != operation_type)\n-\tleft_operand = unchecked_convert (operation_type, left_operand, false);\n-\n-      has_side_effects = true;\n-      modulus = NULL_TREE;\n-      break;\n-\n-    case ARRAY_REF:\n-      if (!operation_type)\n-\toperation_type = TREE_TYPE (left_type);\n-\n-      /* ... fall through ... */\n-\n-    case ARRAY_RANGE_REF:\n-      /* First look through conversion between type variants.  Note that\n-\t this changes neither the operation type nor the type domain.  */\n-      if (TREE_CODE (left_operand) == VIEW_CONVERT_EXPR\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (left_operand, 0)))\n-\t     == TYPE_MAIN_VARIANT (left_type))\n-\t{\n-\t  left_operand = TREE_OPERAND (left_operand, 0);\n-\t  left_type = TREE_TYPE (left_operand);\n-\t}\n-\n-      /* Then convert the right operand to its base type.  This will\n-\t prevent unneeded signedness conversions when sizetype is wider than\n-\t integer.  */\n-      right_operand = convert (right_base_type, right_operand);\n-      right_operand = convert (TYPE_DOMAIN (left_type), right_operand);\n-\n-      if (!TREE_CONSTANT (right_operand)\n-\t  || !TREE_CONSTANT (TYPE_MIN_VALUE (right_type)))\n-\tgnat_mark_addressable (left_operand);\n-\n-      modulus = NULL_TREE;\n-      break;\n-\n-    case GE_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case LT_EXPR:\n-      gcc_assert (!POINTER_TYPE_P (left_type));\n-\n-      /* ... fall through ... */\n-\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      /* If either operand is a NULL_EXPR, just return a new one.  */\n-      if (TREE_CODE (left_operand) == NULL_EXPR)\n-\treturn build2 (op_code, result_type,\n-\t\t       build1 (NULL_EXPR, integer_type_node,\n-\t\t\t       TREE_OPERAND (left_operand, 0)),\n-\t\t       integer_zero_node);\n-\n-      else if (TREE_CODE (right_operand) == NULL_EXPR)\n-\treturn build2 (op_code, result_type,\n-\t\t       build1 (NULL_EXPR, integer_type_node,\n-\t\t\t       TREE_OPERAND (right_operand, 0)),\n-\t\t       integer_zero_node);\n-\n-      /* If either object is a justified modular types, get the\n-\t fields from within.  */\n-      if (TREE_CODE (left_type) == RECORD_TYPE\n-\t  && TYPE_JUSTIFIED_MODULAR_P (left_type))\n-\t{\n-\t  left_operand = convert (TREE_TYPE (TYPE_FIELDS (left_type)),\n-\t\t\t\t  left_operand);\n-\t  left_type = TREE_TYPE (left_operand);\n-\t  left_base_type = get_base_type (left_type);\n-\t}\n-\n-      if (TREE_CODE (right_type) == RECORD_TYPE\n-\t  && TYPE_JUSTIFIED_MODULAR_P (right_type))\n-\t{\n-\t  right_operand = convert (TREE_TYPE (TYPE_FIELDS (right_type)),\n-\t\t\t\t  right_operand);\n-\t  right_type = TREE_TYPE (right_operand);\n-\t  right_base_type = get_base_type (right_type);\n-\t}\n-\n-      /* If both objects are arrays, compare them specially.  */\n-      if ((TREE_CODE (left_type) == ARRAY_TYPE\n-\t   || (TREE_CODE (left_type) == INTEGER_TYPE\n-\t       && TYPE_HAS_ACTUAL_BOUNDS_P (left_type)))\n-\t  && (TREE_CODE (right_type) == ARRAY_TYPE\n-\t      || (TREE_CODE (right_type) == INTEGER_TYPE\n-\t\t  && TYPE_HAS_ACTUAL_BOUNDS_P (right_type))))\n-\t{\n-\t  result = compare_arrays (result_type, left_operand, right_operand);\n-\n-\t  if (op_code == NE_EXPR)\n-\t    result = invert_truthvalue (result);\n-\t  else\n-\t    gcc_assert (op_code == EQ_EXPR);\n-\n-\t  return result;\n-\t}\n-\n-      /* Otherwise, the base types must be the same unless the objects are\n-\t fat pointers or records.  If we have records, use the best type and\n-\t convert both operands to that type.  */\n-      if (left_base_type != right_base_type)\n-\t{\n-\t  if (TYPE_FAT_POINTER_P (left_base_type)\n-\t      && TYPE_FAT_POINTER_P (right_base_type)\n-\t      && TYPE_MAIN_VARIANT (left_base_type)\n-\t\t == TYPE_MAIN_VARIANT (right_base_type))\n-\t    best_type = left_base_type;\n-\t  else if (TREE_CODE (left_base_type) == RECORD_TYPE\n-\t\t   && TREE_CODE (right_base_type) == RECORD_TYPE)\n-\t    {\n-\t      /* The only way these are permitted to be the same is if both\n-\t\t types have the same name.  In that case, one of them must\n-\t\t not be self-referential.  Use that one as the best type.\n-\t\t Even better is if one is of fixed size.  */\n-\t      gcc_assert (TYPE_NAME (left_base_type)\n-\t\t\t  && (TYPE_NAME (left_base_type)\n-\t\t\t      == TYPE_NAME (right_base_type)));\n-\n-\t      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))\n-\t\tbest_type = left_base_type;\n-\t      else if (TREE_CONSTANT (TYPE_SIZE (right_base_type)))\n-\t\tbest_type = right_base_type;\n-\t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (left_base_type)))\n-\t\tbest_type = left_base_type;\n-\t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (right_base_type)))\n-\t\tbest_type = right_base_type;\n-\t      else\n-\t\tgcc_unreachable ();\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\n-\t  left_operand = convert (best_type, left_operand);\n-\t  right_operand = convert (best_type, right_operand);\n-\t}\n-\n-      /* If we are comparing a fat pointer against zero, we need to\n-\t just compare the data pointer.  */\n-      else if (TYPE_FAT_POINTER_P (left_base_type)\n-\t       && TREE_CODE (right_operand) == CONSTRUCTOR\n-\t       && integer_zerop (VEC_index (constructor_elt,\n-\t\t\t\t\t    CONSTRUCTOR_ELTS (right_operand),\n-\t\t\t\t\t    0)\n-\t\t\t\t ->value))\n-\t{\n-\t  right_operand = build_component_ref (left_operand, NULL_TREE,\n-\t\t\t\t\t       TYPE_FIELDS (left_base_type),\n-\t\t\t\t\t       false);\n-\t  left_operand = convert (TREE_TYPE (right_operand),\n-\t\t\t\t  integer_zero_node);\n-\t}\n-      else\n-\t{\n-\t  left_operand = convert (left_base_type, left_operand);\n-\t  right_operand = convert (right_base_type, right_operand);\n-\t}\n-\n-      modulus = NULL_TREE;\n-      break;\n-\n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      /* In these, the result type and the left operand type should be the\n-\t same.  Do the operation in the base type of those and convert the\n-\t right operand (which is an integer) to that type.\n-\n-\t Note that these operations are only used in loop control where\n-\t we guarantee that no overflow can occur.  So nothing special need\n-\t be done for modular types.  */\n-\n-      gcc_assert (left_type == result_type);\n-      operation_type = get_base_type (result_type);\n-      left_operand = convert (operation_type, left_operand);\n-      right_operand = convert (operation_type, right_operand);\n-      has_side_effects = true;\n-      modulus = NULL_TREE;\n-      break;\n-\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-       /* The RHS of a shift can be any type.  Also, ignore any modulus\n-\t (we used to abort, but this is needed for unchecked conversion\n-\t to modular types).  Otherwise, processing is the same as normal.  */\n-      gcc_assert (operation_type == left_base_type);\n-      modulus = NULL_TREE;\n-      left_operand = convert (operation_type, left_operand);\n-      break;\n-\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-      left_operand = gnat_truthvalue_conversion (left_operand);\n-      right_operand = gnat_truthvalue_conversion (right_operand);\n-      goto common;\n-\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-      /* For binary modulus, if the inputs are in range, so are the\n-\t outputs.  */\n-      if (modulus && integer_pow2p (modulus))\n-\tmodulus = NULL_TREE;\n-\n-      goto common;\n-\n-    case COMPLEX_EXPR:\n-      gcc_assert (TREE_TYPE (result_type) == left_base_type\n-\t\t  && TREE_TYPE (result_type) == right_base_type);\n-      left_operand = convert (left_base_type, left_operand);\n-      right_operand = convert (right_base_type, right_operand);\n-      break;\n-\n-    case TRUNC_DIV_EXPR:   case TRUNC_MOD_EXPR:\n-    case CEIL_DIV_EXPR:    case CEIL_MOD_EXPR:\n-    case FLOOR_DIV_EXPR:   case FLOOR_MOD_EXPR:\n-    case ROUND_DIV_EXPR:   case ROUND_MOD_EXPR:\n-      /* These always produce results lower than either operand.  */\n-      modulus = NULL_TREE;\n-      goto common;\n-\n-    case POINTER_PLUS_EXPR:\n-      gcc_assert (operation_type == left_base_type\n-\t\t  && sizetype == right_base_type);\n-      left_operand = convert (operation_type, left_operand);\n-      right_operand = convert (sizetype, right_operand);\n-      break;\n-\n-    default:\n-    common:\n-      /* The result type should be the same as the base types of the\n-\t both operands (and they should be the same).  Convert\n-\t everything to the result type.  */\n-\n-      gcc_assert (operation_type == left_base_type\n-\t\t  && left_base_type == right_base_type);\n-      left_operand = convert (operation_type, left_operand);\n-      right_operand = convert (operation_type, right_operand);\n-    }\n-\n-  if (modulus && !integer_pow2p (modulus))\n-    {\n-      result = nonbinary_modular_operation (op_code, operation_type,\n-\t\t\t\t\t    left_operand, right_operand);\n-      modulus = NULL_TREE;\n-    }\n-  /* If either operand is a NULL_EXPR, just return a new one.  */\n-  else if (TREE_CODE (left_operand) == NULL_EXPR)\n-    return build1 (NULL_EXPR, operation_type, TREE_OPERAND (left_operand, 0));\n-  else if (TREE_CODE (right_operand) == NULL_EXPR)\n-    return build1 (NULL_EXPR, operation_type, TREE_OPERAND (right_operand, 0));\n-  else if (op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n-    result = fold (build4 (op_code, operation_type, left_operand,\n-\t\t\t   right_operand, NULL_TREE, NULL_TREE));\n-  else\n-    result\n-      = fold_build2 (op_code, operation_type, left_operand, right_operand);\n-\n-  TREE_SIDE_EFFECTS (result) |= has_side_effects;\n-  TREE_CONSTANT (result)\n-    |= (TREE_CONSTANT (left_operand) & TREE_CONSTANT (right_operand)\n-\t&& op_code != ARRAY_REF && op_code != ARRAY_RANGE_REF);\n-\n-  if ((op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n-      && TYPE_VOLATILE (operation_type))\n-    TREE_THIS_VOLATILE (result) = 1;\n-\n-  /* If we are working with modular types, perform the MOD operation\n-     if something above hasn't eliminated the need for it.  */\n-  if (modulus)\n-    result = fold_build2 (FLOOR_MOD_EXPR, operation_type, result,\n-\t\t\t  convert (operation_type, modulus));\n-\n-  if (result_type && result_type != operation_type)\n-    result = convert (result_type, result);\n-\n-  return result;\n-}\n-\f\n-/* Similar, but for unary operations.  */\n-\n-tree\n-build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n-{\n-  tree type = TREE_TYPE (operand);\n-  tree base_type = get_base_type (type);\n-  tree operation_type = result_type;\n-  tree result;\n-  bool side_effects = false;\n-\n-  if (operation_type\n-      && TREE_CODE (operation_type) == RECORD_TYPE\n-      && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n-    operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n-\n-  if (operation_type\n-      && !AGGREGATE_TYPE_P (operation_type)\n-      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n-    operation_type = get_base_type (operation_type);\n-\n-  switch (op_code)\n-    {\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      if (!operation_type)\n-\tresult_type = operation_type = TREE_TYPE (type);\n-      else\n-\tgcc_assert (result_type == TREE_TYPE (type));\n-\n-      result = fold_build1 (op_code, operation_type, operand);\n-      break;\n-\n-    case TRUTH_NOT_EXPR:\n-      gcc_assert (result_type == base_type);\n-      result = invert_truthvalue (gnat_truthvalue_conversion (operand));\n-      break;\n-\n-    case ATTR_ADDR_EXPR:\n-    case ADDR_EXPR:\n-      switch (TREE_CODE (operand))\n-\t{\n-\tcase INDIRECT_REF:\n-\tcase UNCONSTRAINED_ARRAY_REF:\n-\t  result = TREE_OPERAND (operand, 0);\n-\n-\t  /* Make sure the type here is a pointer, not a reference.\n-\t     GCC wants pointer types for function addresses.  */\n-\t  if (!result_type)\n-\t    result_type = build_pointer_type (type);\n-\n-\t  /* If the underlying object can alias everything, propagate the\n-\t     property since we are effectively retrieving the object.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (result))\n-\t      && TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (result)))\n-\t    {\n-\t      if (TREE_CODE (result_type) == POINTER_TYPE\n-\t\t  && !TYPE_REF_CAN_ALIAS_ALL (result_type))\n-\t\tresult_type\n-\t\t  = build_pointer_type_for_mode (TREE_TYPE (result_type),\n-\t\t\t\t\t\t TYPE_MODE (result_type),\n-\t\t\t\t\t\t true);\n-\t      else if (TREE_CODE (result_type) == REFERENCE_TYPE\n-\t\t       && !TYPE_REF_CAN_ALIAS_ALL (result_type))\n-\t        result_type\n-\t\t  = build_reference_type_for_mode (TREE_TYPE (result_type),\n-\t\t\t\t\t\t   TYPE_MODE (result_type),\n-\t\t\t\t\t\t   true);\n-\t    }\n-\t  break;\n-\n-\tcase NULL_EXPR:\n-\t  result = operand;\n-\t  TREE_TYPE (result) = type = build_pointer_type (type);\n-\t  break;\n-\n-\tcase ARRAY_REF:\n-\tcase ARRAY_RANGE_REF:\n-\tcase COMPONENT_REF:\n-\tcase BIT_FIELD_REF:\n-\t    /* If this is for 'Address, find the address of the prefix and\n-\t       add the offset to the field.  Otherwise, do this the normal\n-\t       way.  */\n-\t  if (op_code == ATTR_ADDR_EXPR)\n-\t    {\n-\t      HOST_WIDE_INT bitsize;\n-\t      HOST_WIDE_INT bitpos;\n-\t      tree offset, inner;\n-\t      enum machine_mode mode;\n-\t      int unsignedp, volatilep;\n-\n-\t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t   &mode, &unsignedp, &volatilep,\n-\t\t\t\t\t   false);\n-\n-\t      /* If INNER is a padding type whose field has a self-referential\n-\t\t size, convert to that inner type.  We know the offset is zero\n-\t\t and we need to have that type visible.  */\n-\t      if (TREE_CODE (TREE_TYPE (inner)) == RECORD_TYPE\n-\t\t  && TYPE_IS_PADDING_P (TREE_TYPE (inner))\n-\t\t  && (CONTAINS_PLACEHOLDER_P\n-\t\t      (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t\t     (TREE_TYPE (inner)))))))\n-\t\tinner = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (inner))),\n-\t\t\t\t inner);\n-\n-\t      /* Compute the offset as a byte offset from INNER.  */\n-\t      if (!offset)\n-\t\toffset = size_zero_node;\n-\n-\t      if (bitpos % BITS_PER_UNIT != 0)\n-\t\tpost_error\n-\t\t  (\"taking address of object not aligned on storage unit?\",\n-\t\t   error_gnat_node);\n-\n-\t      offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t   size_int (bitpos / BITS_PER_UNIT));\n-\n-\t      /* Take the address of INNER, convert the offset to void *, and\n-\t\t add then.  It will later be converted to the desired result\n-\t\t type, if any.  */\n-\t      inner = build_unary_op (ADDR_EXPR, NULL_TREE, inner);\n-\t      inner = convert (ptr_void_type_node, inner);\n-\t      result = build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n-\t\t\t\t\tinner, offset);\n-\t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n-\t\t\t\tresult);\n-\t      break;\n-\t    }\n-\t  goto common;\n-\n-\tcase CONSTRUCTOR:\n-\t  /* If this is just a constructor for a padded record, we can\n-\t     just take the address of the single field and convert it to\n-\t     a pointer to our type.  */\n-\t  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n-\t    {\n-\t      result = (VEC_index (constructor_elt,\n-\t\t\t\t   CONSTRUCTOR_ELTS (operand),\n-\t\t\t\t   0)\n-\t\t\t->value);\n-\n-\t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n-\t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n-\t      break;\n-\t    }\n-\n-\t  goto common;\n-\n-\tcase NOP_EXPR:\n-\t  if (AGGREGATE_TYPE_P (type)\n-\t      && AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (operand, 0))))\n-\t    return build_unary_op (ADDR_EXPR, result_type,\n-\t\t\t\t   TREE_OPERAND (operand, 0));\n-\n-\t  /* ... fallthru ... */\n-\n-\tcase VIEW_CONVERT_EXPR:\n-\t  /* If this just a variant conversion or if the conversion doesn't\n-\t     change the mode, get the result type from this type and go down.\n-\t     This is needed for conversions of CONST_DECLs, to eventually get\n-\t     to the address of their CORRESPONDING_VARs.  */\n-\t  if ((TYPE_MAIN_VARIANT (type)\n-\t       == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (operand, 0))))\n-\t      || (TYPE_MODE (type) != BLKmode\n-\t\t  && (TYPE_MODE (type)\n-\t\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (operand, 0))))))\n-\t    return build_unary_op (ADDR_EXPR,\n-\t\t\t\t   (result_type ? result_type\n-\t\t\t\t    : build_pointer_type (type)),\n-\t\t\t\t   TREE_OPERAND (operand, 0));\n-\t  goto common;\n-\n-\tcase CONST_DECL:\n-\t  operand = DECL_CONST_CORRESPONDING_VAR (operand);\n-\n-\t  /* ... fall through ... */\n-\n-\tdefault:\n-\tcommon:\n-\n-\t  /* If we are taking the address of a padded record whose field is\n-\t     contains a template, take the address of the template.  */\n-\t  if (TREE_CODE (type) == RECORD_TYPE\n-\t      && TYPE_IS_PADDING_P (type)\n-\t      && TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == RECORD_TYPE\n-\t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (TYPE_FIELDS (type))))\n-\t    {\n-\t      type = TREE_TYPE (TYPE_FIELDS (type));\n-\t      operand = convert (type, operand);\n-\t    }\n-\n-\t  if (type != error_mark_node)\n-\t    operation_type = build_pointer_type (type);\n-\n-\t  gnat_mark_addressable (operand);\n-\t  result = fold_build1 (ADDR_EXPR, operation_type, operand);\n-\t}\n-\n-      TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);\n-      break;\n-\n-    case INDIRECT_REF:\n-      /* If we want to refer to an entire unconstrained array,\n-\t make up an expression to do so.  This will never survive to\n-\t the backend.  If TYPE is a thin pointer, first convert the\n-\t operand to a fat pointer.  */\n-      if (TYPE_THIN_POINTER_P (type)\n-\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n-\t{\n-\t  operand\n-\t    = convert (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n-\t\t       operand);\n-\t  type = TREE_TYPE (operand);\n-\t}\n-\n-      if (TYPE_FAT_POINTER_P (type))\n-\t{\n-\t  result = build1 (UNCONSTRAINED_ARRAY_REF,\n-\t\t\t   TYPE_UNCONSTRAINED_ARRAY (type), operand);\n-\t  TREE_READONLY (result) = TREE_STATIC (result)\n-\t    = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n-\t}\n-      else if (TREE_CODE (operand) == ADDR_EXPR)\n-\tresult = TREE_OPERAND (operand, 0);\n-\n-      else\n-\t{\n-\t  result = fold_build1 (op_code, TREE_TYPE (type), operand);\n-\t  TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n-\t}\n-\n-      side_effects\n-\t=  (!TYPE_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n-      break;\n-\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n-      {\n-\ttree modulus = ((operation_type\n-\t\t\t && TREE_CODE (operation_type) == INTEGER_TYPE\n-\t\t\t && TYPE_MODULAR_P (operation_type))\n-\t\t\t? TYPE_MODULUS (operation_type) : NULL_TREE);\n-\tint mod_pow2 = modulus && integer_pow2p (modulus);\n-\n-\t/* If this is a modular type, there are various possibilities\n-\t   depending on the operation and whether the modulus is a\n-\t   power of two or not.  */\n-\n-\tif (modulus)\n-\t  {\n-\t    gcc_assert (operation_type == base_type);\n-\t    operand = convert (operation_type, operand);\n-\n-\t    /* The fastest in the negate case for binary modulus is\n-\t       the straightforward code; the TRUNC_MOD_EXPR below\n-\t       is an AND operation.  */\n-\t    if (op_code == NEGATE_EXPR && mod_pow2)\n-\t      result = fold_build2 (TRUNC_MOD_EXPR, operation_type,\n-\t\t\t\t    fold_build1 (NEGATE_EXPR, operation_type,\n-\t\t\t\t\t\t operand),\n-\t\t\t\t    modulus);\n-\n-\t    /* For nonbinary negate case, return zero for zero operand,\n-\t       else return the modulus minus the operand.  If the modulus\n-\t       is a power of two minus one, we can do the subtraction\n-\t       as an XOR since it is equivalent and faster on most machines. */\n-\t    else if (op_code == NEGATE_EXPR && !mod_pow2)\n-\t      {\n-\t\tif (integer_pow2p (fold_build2 (PLUS_EXPR, operation_type,\n-\t\t\t\t\t\tmodulus,\n-\t\t\t\t\t\tconvert (operation_type,\n-\t\t\t\t\t\t\t integer_one_node))))\n-\t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n-\t\t\t\t\toperand, modulus);\n-\t\telse\n-\t\t  result = fold_build2 (MINUS_EXPR, operation_type,\n-\t\t\t\t\tmodulus, operand);\n-\n-\t\tresult = fold_build3 (COND_EXPR, operation_type,\n-\t\t\t\t      fold_build2 (NE_EXPR,\n-\t\t\t\t\t\t   integer_type_node,\n-\t\t\t\t\t\t   operand,\n-\t\t\t\t\t\t   convert\n-\t\t\t\t\t\t     (operation_type,\n-\t\t\t\t\t\t      integer_zero_node)),\n-\t\t\t\t      result, operand);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* For the NOT cases, we need a constant equal to\n-\t\t   the modulus minus one.  For a binary modulus, we\n-\t\t   XOR against the constant and subtract the operand from\n-\t\t   that constant for nonbinary modulus.  */\n-\n-\t\ttree cnst = fold_build2 (MINUS_EXPR, operation_type, modulus,\n-\t\t\t\t\t convert (operation_type,\n-\t\t\t\t\t\t  integer_one_node));\n-\n-\t\tif (mod_pow2)\n-\t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n-\t\t\t\t\toperand, cnst);\n-\t\telse\n-\t\t  result = fold_build2 (MINUS_EXPR, operation_type,\n-\t\t\t\t\tcnst, operand);\n-\t      }\n-\n-\t    break;\n-\t  }\n-      }\n-\n-      /* ... fall through ... */\n-\n-    default:\n-      gcc_assert (operation_type == base_type);\n-      result = fold_build1 (op_code, operation_type,\n-\t\t\t    convert (operation_type, operand));\n-    }\n-\n-  if (side_effects)\n-    {\n-      TREE_SIDE_EFFECTS (result) = 1;\n-      if (TREE_CODE (result) == INDIRECT_REF)\n-\tTREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n-    }\n-\n-  if (result_type && TREE_TYPE (result) != result_type)\n-    result = convert (result_type, result);\n-\n-  return result;\n-}\n-\f\n-/* Similar, but for COND_EXPR.  */\n-\n-tree\n-build_cond_expr (tree result_type, tree condition_operand,\n-                 tree true_operand, tree false_operand)\n-{\n-  tree result;\n-  bool addr_p = false;\n-\n-  /* The front-end verifies that result, true and false operands have same base\n-     type.  Convert everything to the result type.  */\n-\n-  true_operand  = convert (result_type, true_operand);\n-  false_operand = convert (result_type, false_operand);\n-\n-  /* If the result type is unconstrained, take the address of\n-     the operands and then dereference our result.  */\n-  if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n-      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type)))\n-    {\n-      addr_p = true;\n-      result_type = build_pointer_type (result_type);\n-      true_operand = build_unary_op (ADDR_EXPR, result_type, true_operand);\n-      false_operand = build_unary_op (ADDR_EXPR, result_type, false_operand);\n-    }\n-\n-  result = fold_build3 (COND_EXPR, result_type, condition_operand,\n-\t\t\ttrue_operand, false_operand);\n-\n-  /* If either operand is a SAVE_EXPR (possibly surrounded by\n-     arithmetic, make sure it gets done.  */\n-  true_operand  = skip_simple_arithmetic (true_operand);\n-  false_operand = skip_simple_arithmetic (false_operand);\n-\n-  if (TREE_CODE (true_operand) == SAVE_EXPR)\n-    result = build2 (COMPOUND_EXPR, result_type, true_operand, result);\n-\n-  if (TREE_CODE (false_operand) == SAVE_EXPR)\n-    result = build2 (COMPOUND_EXPR, result_type, false_operand, result);\n-\n-  /* ??? Seems the code above is wrong, as it may move ahead of the COND\n-     SAVE_EXPRs with side effects and not shared by both arms.  */\n-\n- if (addr_p)\n-    result = build_unary_op (INDIRECT_REF, NULL_TREE, result);\n-\n-  return result;\n-}\n-\n-/* Similar, but for RETURN_EXPR.  If RESULT_DECL is non-zero, build\n-   a RETURN_EXPR around the assignment of RET_VAL to RESULT_DECL.\n-   If RESULT_DECL is zero, build a bare RETURN_EXPR.  */\n-\n-tree\n-build_return_expr (tree result_decl, tree ret_val)\n-{\n-  tree result_expr;\n-\n-  if (result_decl)\n-    {\n-      /* The gimplifier explicitly enforces the following invariant:\n-\n-           RETURN_EXPR\n-               |\n-           MODIFY_EXPR\n-           /        \\\n-          /          \\\n-      RESULT_DECL    ...\n-\n-      As a consequence, type-homogeneity dictates that we use the type\n-      of the RESULT_DECL as the operation type.  */\n-\n-      tree operation_type = TREE_TYPE (result_decl);\n-\n-      /* Convert the right operand to the operation type.  Note that\n-         it's the same transformation as in the MODIFY_EXPR case of\n-         build_binary_op with the additional guarantee that the type\n-         cannot involve a placeholder, since otherwise the function\n-         would use the \"target pointer\" return mechanism.  */\n-\n-      if (operation_type != TREE_TYPE (ret_val))\n-\tret_val = convert (operation_type, ret_val);\n-\n-      result_expr\n-\t= build2 (MODIFY_EXPR, operation_type, result_decl, ret_val);\n-    }\n-  else\n-    result_expr = NULL_TREE;\n-\n-  return build1 (RETURN_EXPR, void_type_node, result_expr);\n-}\n-\f\n-/* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n-   the CALL_EXPR.  */\n-\n-tree\n-build_call_1_expr (tree fundecl, tree arg)\n-{\n-  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t\t       1, arg);\n-  TREE_SIDE_EFFECTS (call) = 1;\n-  return call;\n-}\n-\n-/* Build a CALL_EXPR to call FUNDECL with two arguments, ARG1 & ARG2.  Return\n-   the CALL_EXPR.  */\n-\n-tree\n-build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n-{\n-  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t\t       2, arg1, arg2);\n-  TREE_SIDE_EFFECTS (call) = 1;\n-  return call;\n-}\n-\n-/* Likewise to call FUNDECL with no arguments.  */\n-\n-tree\n-build_call_0_expr (tree fundecl)\n-{\n-  /* We rely on build_call_nary to compute TREE_SIDE_EFFECTS.  This makes\n-     it possible to propagate DECL_IS_PURE on parameterless functions.  */\n-  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n-\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n-\t\t\t       0);\n-  return call;\n-}\n-\f\n-/* Call a function that raises an exception and pass the line number and file\n-   name, if requested.  MSG says which exception function to call.\n-\n-   GNAT_NODE is the gnat node conveying the source location for which the\n-   error should be signaled, or Empty in which case the error is signaled on\n-   the current ref_file_name/input_line.\n-\n-   KIND says which kind of exception this is for\n-   (N_Raise_{Constraint,Storage,Program}_Error).  */\n-\n-tree\n-build_call_raise (int msg, Node_Id gnat_node, char kind)\n-{\n-  tree fndecl = gnat_raise_decls[msg];\n-  tree label = get_exception_label (kind);\n-  tree filename;\n-  int line_number;\n-  const char *str;\n-  int len;\n-\n-  /* If this is to be done as a goto, handle that case.  */\n-  if (label)\n-    {\n-      Entity_Id local_raise = Get_Local_Raise_Call_Entity ();\n-      tree gnu_result = build1 (GOTO_EXPR, void_type_node, label);\n-\n-      /* If Local_Raise is present, generate\n-\t Local_Raise (exception'Identity);  */\n-      if (Present (local_raise))\n-\t{\n-\t  tree gnu_local_raise\n-\t    = gnat_to_gnu_entity (local_raise, NULL_TREE, 0);\n-\t  tree gnu_exception_entity\n-\t    = gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, 0);\n-\t  tree gnu_call\n-\t    = build_call_1_expr (gnu_local_raise,\n-\t\t\t\t build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t\t gnu_exception_entity));\n-\n-\t  gnu_result = build2 (COMPOUND_EXPR, void_type_node,\n-\t\t\t       gnu_call, gnu_result);}\n-\n-      return gnu_result;\n-    }\n-\n-  str\n-    = (Debug_Flag_NN || Exception_Locations_Suppressed)\n-      ? \"\"\n-      : (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-        ? IDENTIFIER_POINTER\n-          (get_identifier (Get_Name_String\n-\t\t\t   (Debug_Source_Name\n-\t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n-        : ref_filename;\n-\n-  len = strlen (str) + 1;\n-  filename = build_string (len, str);\n-  line_number\n-    = (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n-      ? Get_Logical_Line_Number (Sloc(gnat_node)) : input_line;\n-\n-  TREE_TYPE (filename)\n-    = build_array_type (char_type_node,\n-\t\t\tbuild_index_type (build_int_cst (NULL_TREE, len)));\n-\n-  return\n-    build_call_2_expr (fndecl,\n-\t\t       build1 (ADDR_EXPR, build_pointer_type (char_type_node),\n-\t\t\t       filename),\n-\t\t       build_int_cst (NULL_TREE, line_number));\n-}\n-\f\n-/* qsort comparer for the bit positions of two constructor elements\n-   for record components.  */\n-\n-static int\n-compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n-{\n-  const_tree const elmt1 = * (const_tree const *) rt1;\n-  const_tree const elmt2 = * (const_tree const *) rt2;\n-  const_tree const field1 = TREE_PURPOSE (elmt1);\n-  const_tree const field2 = TREE_PURPOSE (elmt2);\n-  const int ret\n-    = tree_int_cst_compare (bit_position (field1), bit_position (field2));\n-\n-  return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n-}\n-\n-/* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n-\n-tree\n-gnat_build_constructor (tree type, tree list)\n-{\n-  tree elmt;\n-  int n_elmts;\n-  bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n-  bool side_effects = false;\n-  tree result;\n-\n-  /* Scan the elements to see if they are all constant or if any has side\n-     effects, to let us set global flags on the resulting constructor.  Count\n-     the elements along the way for possible sorting purposes below.  */\n-  for (n_elmts = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), n_elmts ++)\n-    {\n-      if (!TREE_CONSTANT (TREE_VALUE (elmt))\n-\t  || (TREE_CODE (type) == RECORD_TYPE\n-\t      && DECL_BIT_FIELD (TREE_PURPOSE (elmt))\n-\t      && TREE_CODE (TREE_VALUE (elmt)) != INTEGER_CST)\n-\t  || !initializer_constant_valid_p (TREE_VALUE (elmt),\n-\t\t\t\t\t    TREE_TYPE (TREE_VALUE (elmt))))\n-\tallconstant = false;\n-\n-      if (TREE_SIDE_EFFECTS (TREE_VALUE (elmt)))\n-\tside_effects = true;\n-\n-      /* Propagate an NULL_EXPR from the size of the type.  We won't ever\n-\t be executing the code we generate here in that case, but handle it\n-\t specially to avoid the compiler blowing up.  */\n-      if (TREE_CODE (type) == RECORD_TYPE\n-\t  && (0 != (result\n-\t\t    = contains_null_expr (DECL_SIZE (TREE_PURPOSE (elmt))))))\n-\treturn build1 (NULL_EXPR, type, TREE_OPERAND (result, 0));\n-    }\n-\n-  /* For record types with constant components only, sort field list\n-     by increasing bit position.  This is necessary to ensure the\n-     constructor can be output as static data.  */\n-  if (allconstant && TREE_CODE (type) == RECORD_TYPE && n_elmts > 1)\n-    {\n-      /* Fill an array with an element tree per index, and ask qsort to order\n-\t them according to what a bitpos comparison function says.  */\n-      tree *gnu_arr = (tree *) alloca (sizeof (tree) * n_elmts);\n-      int i;\n-\n-      for (i = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), i++)\n-\tgnu_arr[i] = elmt;\n-\n-      qsort (gnu_arr, n_elmts, sizeof (tree), compare_elmt_bitpos);\n-\n-      /* Then reconstruct the list from the sorted array contents.  */\n-      list = NULL_TREE;\n-      for (i = n_elmts - 1; i >= 0; i--)\n-\t{\n-\t  TREE_CHAIN (gnu_arr[i]) = list;\n-\t  list = gnu_arr[i];\n-\t}\n-    }\n-\n-  result = build_constructor_from_list (type, list);\n-  TREE_CONSTANT (result) = TREE_STATIC (result) = allconstant;\n-  TREE_SIDE_EFFECTS (result) = side_effects;\n-  TREE_READONLY (result) = TYPE_READONLY (type) || allconstant;\n-  return result;\n-}\n-\f\n-/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n-   an IDENTIFIER_NODE giving the name of the field, or FIELD, a FIELD_DECL,\n-   for the field.  Don't fold the result if NO_FOLD_P is true.\n-\n-   We also handle the fact that we might have been passed a pointer to the\n-   actual record and know how to look for fields in variant parts.  */\n-\n-static tree\n-build_simple_component_ref (tree record_variable, tree component,\n-                            tree field, bool no_fold_p)\n-{\n-  tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n-  tree ref, inner_variable;\n-\n-  gcc_assert ((TREE_CODE (record_type) == RECORD_TYPE\n-\t       || TREE_CODE (record_type) == UNION_TYPE\n-\t       || TREE_CODE (record_type) == QUAL_UNION_TYPE)\n-\t      && TYPE_SIZE (record_type)\n-\t      && (component != 0) != (field != 0));\n-\n-  /* If no field was specified, look for a field with the specified name\n-     in the current record only.  */\n-  if (!field)\n-    for (field = TYPE_FIELDS (record_type); field;\n-\t field = TREE_CHAIN (field))\n-      if (DECL_NAME (field) == component)\n-\tbreak;\n-\n-  if (!field)\n-    return NULL_TREE;\n-\n-  /* If this field is not in the specified record, see if we can find\n-     something in the record whose original field is the same as this one. */\n-  if (DECL_CONTEXT (field) != record_type)\n-    /* Check if there is a field with name COMPONENT in the record.  */\n-    {\n-      tree new_field;\n-\n-      /* First loop thru normal components.  */\n-\n-      for (new_field = TYPE_FIELDS (record_type); new_field;\n-\t   new_field = TREE_CHAIN (new_field))\n-\tif (field == new_field\n-\t    || DECL_ORIGINAL_FIELD (new_field) == field\n-\t    || new_field == DECL_ORIGINAL_FIELD (field)\n-\t    || (DECL_ORIGINAL_FIELD (field)\n-\t\t&& (DECL_ORIGINAL_FIELD (field)\n-\t\t    == DECL_ORIGINAL_FIELD (new_field))))\n-\t  break;\n-\n-      /* Next, loop thru DECL_INTERNAL_P components if we haven't found\n-         the component in the first search. Doing this search in 2 steps\n-         is required to avoiding hidden homonymous fields in the\n-         _Parent field.  */\n-\n-      if (!new_field)\n-\tfor (new_field = TYPE_FIELDS (record_type); new_field;\n-\t     new_field = TREE_CHAIN (new_field))\n-\t  if (DECL_INTERNAL_P (new_field))\n-\t    {\n-\t      tree field_ref\n-\t\t= build_simple_component_ref (record_variable,\n-\t\t\t\t\t      NULL_TREE, new_field, no_fold_p);\n-\t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n-\t\t\t\t\t\tno_fold_p);\n-\n-\t      if (ref)\n-\t\treturn ref;\n-\t    }\n-\n-      field = new_field;\n-    }\n-\n-  if (!field)\n-    return NULL_TREE;\n-\n-  /* If the field's offset has overflowed, do not attempt to access it\n-     as doing so may trigger sanity checks deeper in the back-end.\n-     Note that we don't need to warn since this will be done on trying\n-     to declare the object.  */\n-  if (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST\n-      && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n-    return NULL_TREE;\n-\n-  /* Look through conversion between type variants.  Note that this\n-     is transparent as far as the field is concerned.  */\n-  if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (record_variable, 0)))\n-\t == record_type)\n-    inner_variable = TREE_OPERAND (record_variable, 0);\n-  else\n-    inner_variable = record_variable;\n-\n-  ref = build3 (COMPONENT_REF, TREE_TYPE (field), inner_variable, field,\n-\t\tNULL_TREE);\n-\n-  if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n-    TREE_READONLY (ref) = 1;\n-  if (TREE_THIS_VOLATILE (record_variable) || TREE_THIS_VOLATILE (field)\n-      || TYPE_VOLATILE (record_type))\n-    TREE_THIS_VOLATILE (ref) = 1;\n-\n-  if (no_fold_p)\n-    return ref;\n-\n-  /* The generic folder may punt in this case because the inner array type\n-     can be self-referential, but folding is in fact not problematic.  */\n-  else if (TREE_CODE (record_variable) == CONSTRUCTOR\n-\t   && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n-    {\n-      VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (record_variable);\n-      unsigned HOST_WIDE_INT idx;\n-      tree index, value;\n-      FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n-\tif (index == field)\n-\t  return value;\n-      return ref;\n-    }\n-\n-  else\n-    return fold (ref);\n-}\n-\f\n-/* Like build_simple_component_ref, except that we give an error if the\n-   reference could not be found.  */\n-\n-tree\n-build_component_ref (tree record_variable, tree component,\n-                     tree field, bool no_fold_p)\n-{\n-  tree ref = build_simple_component_ref (record_variable, component, field,\n-\t\t\t\t\t no_fold_p);\n-\n-  if (ref)\n-    return ref;\n-\n-  /* If FIELD was specified, assume this is an invalid user field so\n-     raise constraint error.  Otherwise, we can't find the type to return, so\n-     abort.  */\n-  gcc_assert (field);\n-  return build1 (NULL_EXPR, TREE_TYPE (field),\n-\t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,\n-\t\t\t\t   N_Raise_Constraint_Error));\n-}\n-\f\n-/* Build a GCC tree to call an allocation or deallocation function.\n-   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n-   generate an allocator.\n-\n-   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment in\n-   bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL is the\n-   storage pool to use.  If not preset, malloc and free will be used except\n-   if GNAT_PROC is the \"fake\" value of -1, in which case we allocate the\n-   object dynamically on the stack frame.  */\n-\n-tree\n-build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n-                          Entity_Id gnat_proc, Entity_Id gnat_pool,\n-                          Node_Id gnat_node)\n-{\n-  tree gnu_align = size_int (align / BITS_PER_UNIT);\n-\n-  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_obj);\n-\n-  if (Present (gnat_proc))\n-    {\n-      /* The storage pools are obviously always tagged types, but the\n-\t secondary stack uses the same mechanism and is not tagged */\n-      if (Is_Tagged_Type (Etype (gnat_pool)))\n-\t{\n-\t  /* The size is the third parameter; the alignment is the\n-             same type.  */\n-\t  Entity_Id gnat_size_type\n-\t    = Etype (Next_Formal (Next_Formal (First_Formal (gnat_proc))));\n-\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n-\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n-\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n-\t  tree gnu_pool = gnat_to_gnu (gnat_pool);\n-\t  tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n-\t  tree gnu_call;\n-\n-\t  gnu_size = convert (gnu_size_type, gnu_size);\n-\t  gnu_align = convert (gnu_size_type, gnu_align);\n-\n-\t  /* The first arg is always the address of the storage pool; next\n-\t     comes the address of the object, for a deallocator, then the\n-\t     size and alignment.  */\n-\t  if (gnu_obj)\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 4, gnu_pool_addr,\n-\t\t\t\t\tgnu_obj, gnu_size, gnu_align);\n-\t  else\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 3, gnu_pool_addr,\n-\t\t\t\t\tgnu_size, gnu_align);\n-\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n-\t  return gnu_call;\n-\t}\n-\n-      /* Secondary stack case.  */\n-      else\n-\t{\n-\t  /* The size is the second parameter */\n-\t  Entity_Id gnat_size_type\n-\t    = Etype (Next_Formal (First_Formal (gnat_proc)));\n-\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n-\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n-\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n-\t  tree gnu_call;\n-\n-\t  gnu_size = convert (gnu_size_type, gnu_size);\n-\n-\t  /* The first arg is the address of the object, for a\n-\t     deallocator, then the size */\n-\t  if (gnu_obj)\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 2, gnu_obj, gnu_size);\n-\t  else\n-\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n-\t\t\t\t\tgnu_proc_addr, 1, gnu_size);\n-\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n-\t  return gnu_call;\n-\t}\n-    }\n-\n-  else if (gnu_obj)\n-    return build_call_1_expr (free_decl, gnu_obj);\n-\n-  /* ??? For now, disable variable-sized allocators in the stack since\n-     we can't yet gimplify an ALLOCATE_EXPR.  */\n-  else if (gnat_pool == -1\n-\t   && TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n-    {\n-      /* If the size is a constant, we can put it in the fixed portion of\n-\t the stack frame to avoid the need to adjust the stack pointer.  */\n-      if (TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n-\t{\n-\t  tree gnu_range\n-\t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n-\t  tree gnu_array_type = build_array_type (char_type_node, gnu_range);\n-\t  tree gnu_decl\n-\t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n-\t\t\t       gnu_array_type, NULL_TREE, false, false, false,\n-\t\t\t       false, NULL, gnat_node);\n-\n-\t  return convert (ptr_void_type_node,\n-\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n-\t}\n-      else\n-\tgcc_unreachable ();\n-#if 0\n-\treturn build2 (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n-#endif\n-    }\n-  else\n-    {\n-      if (Nkind (gnat_node) != N_Allocator || !Comes_From_Source (gnat_node))\n-        Check_No_Implicit_Heap_Alloc (gnat_node);\n-\n-      /* If the allocator size is 32bits but the pointer size is 64bits then\n-\t allocate 32bit memory (sometimes necessary on 64bit VMS). Otherwise\n-\t default to standard malloc. */\n-      if (UI_To_Int (Esize (Etype (gnat_node))) == 32 && POINTER_SIZE == 64)\n-        return build_call_1_expr (malloc32_decl, gnu_size);\n-      else\n-        return build_call_1_expr (malloc_decl, gnu_size);\n-    }\n-}\n-\f\n-/* Build a GCC tree to correspond to allocating an object of TYPE whose\n-   initial value is INIT, if INIT is nonzero.  Convert the expression to\n-   RESULT_TYPE, which must be some type of pointer.  Return the tree.\n-   GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n-   the storage pool to use.  GNAT_NODE is used to provide an error\n-   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n-   true, ignore the type of INIT for the purpose of determining the size;\n-   this will cause the maximum size to be allocated if TYPE is of\n-   self-referential size.  */\n-\n-tree\n-build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n-                 Entity_Id gnat_pool, Node_Id gnat_node, bool ignore_init_type)\n-{\n-  tree size = TYPE_SIZE_UNIT (type);\n-  tree result;\n-  unsigned int default_allocator_alignment\n-    = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n-\n-  /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n-  if (init && TREE_CODE (init) == NULL_EXPR)\n-    return build1 (NULL_EXPR, result_type, TREE_OPERAND (init, 0));\n-\n-  /* If RESULT_TYPE is a fat or thin pointer, set SIZE to be the sum of the\n-     sizes of the object and its template.  Allocate the whole thing and\n-     fill in the parts that are known.  */\n-  else if (TYPE_FAT_OR_THIN_POINTER_P (result_type))\n-    {\n-      tree storage_type\n-\t= build_unc_object_type_from_ptr (result_type, type,\n-\t\t\t\t\t  get_identifier (\"ALLOC\"));\n-      tree template_type = TREE_TYPE (TYPE_FIELDS (storage_type));\n-      tree storage_ptr_type = build_pointer_type (storage_type);\n-      tree storage;\n-      tree template_cons = NULL_TREE;\n-\n-      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n-\t\t\t\t\t     init);\n-\n-      /* If the size overflows, pass -1 so the allocator will raise\n-\t storage error.  */\n-      if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n-\tsize = ssize_int (-1);\n-\n-      storage = build_call_alloc_dealloc (NULL_TREE, size,\n-\t\t\t\t\t  TYPE_ALIGN (storage_type),\n-\t\t\t\t\t  gnat_proc, gnat_pool, gnat_node);\n-      storage = convert (storage_ptr_type, protect_multiple_eval (storage));\n-\n-      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n-\t{\n-\t  type = TREE_TYPE (TYPE_FIELDS (type));\n-\n-\t  if (init)\n-\t    init = convert (type, init);\n-\t}\n-\n-      /* If there is an initializing expression, make a constructor for\n-\t the entire object including the bounds and copy it into the\n-\t object.  If there is no initializing expression, just set the\n-\t bounds.  */\n-      if (init)\n-\t{\n-\t  template_cons = tree_cons (TREE_CHAIN (TYPE_FIELDS (storage_type)),\n-\t\t\t\t     init, NULL_TREE);\n-\t  template_cons = tree_cons (TYPE_FIELDS (storage_type),\n-\t\t\t\t     build_template (template_type, type,\n-\t\t\t\t\t\t     init),\n-\t\t\t\t     template_cons);\n-\n-\t  return convert\n-\t    (result_type,\n-\t     build2 (COMPOUND_EXPR, storage_ptr_type,\n-\t\t     build_binary_op\n-\t\t     (MODIFY_EXPR, storage_type,\n-\t\t      build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t      convert (storage_ptr_type, storage)),\n-\t\t      gnat_build_constructor (storage_type, template_cons)),\n-\t\t     convert (storage_ptr_type, storage)));\n-\t}\n-      else\n-\treturn build2\n-\t  (COMPOUND_EXPR, result_type,\n-\t   build_binary_op\n-\t   (MODIFY_EXPR, template_type,\n-\t    build_component_ref\n-\t    (build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t     convert (storage_ptr_type, storage)),\n-\t     NULL_TREE, TYPE_FIELDS (storage_type), 0),\n-\t    build_template (template_type, type, NULL_TREE)),\n-\t   convert (result_type, convert (storage_ptr_type, storage)));\n-    }\n-\n-  /* If we have an initializing expression, see if its size is simpler\n-     than the size from the type.  */\n-  if (!ignore_init_type && init && TYPE_SIZE_UNIT (TREE_TYPE (init))\n-      && (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (init))) == INTEGER_CST\n-\t  || CONTAINS_PLACEHOLDER_P (size)))\n-    size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n-\n-  /* If the size is still self-referential, reference the initializing\n-     expression, if it is present.  If not, this must have been a\n-     call to allocate a library-level object, in which case we use\n-     the maximum size.  */\n-  if (CONTAINS_PLACEHOLDER_P (size))\n-    {\n-      if (!ignore_init_type && init)\n-\tsize = substitute_placeholder_in_expr (size, init);\n-      else\n-\tsize = max_size (size, true);\n-    }\n-\n-  /* If the size overflows, pass -1 so the allocator will raise\n-     storage error.  */\n-  if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n-    size = ssize_int (-1);\n-\n-  /* If this is in the default storage pool and the type alignment is larger\n-     than what the default allocator supports, make an \"aligning\" record type\n-     with room to store a pointer before the field, allocate an object of that\n-     type, store the system's allocator return value just in front of the\n-     field and return the field's address.  */\n-\n-  if (No (gnat_proc) && TYPE_ALIGN (type) > default_allocator_alignment)\n-    {\n-      /* Construct the aligning type with enough room for a pointer ahead\n-\t of the field, then allocate.  */\n-      tree record_type\n-\t= make_aligning_type (type, TYPE_ALIGN (type), size,\n-\t\t\t      default_allocator_alignment,\n-\t\t\t      POINTER_SIZE / BITS_PER_UNIT);\n-\n-      tree record, record_addr;\n-\n-      record_addr\n-\t= build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE_UNIT (record_type),\n-\t\t\t\t    default_allocator_alignment, Empty, Empty,\n-\t\t\t\t    gnat_node);\n-\n-      record_addr\n-\t= convert (build_pointer_type (record_type),\n-\t\t   save_expr (record_addr));\n-\n-      record = build_unary_op (INDIRECT_REF, NULL_TREE, record_addr);\n-\n-      /* Our RESULT (the Ada allocator's value) is the super-aligned address\n-\t of the internal record field ... */\n-      result\n-\t= build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t  build_component_ref\n-\t\t\t  (record, NULL_TREE, TYPE_FIELDS (record_type), 0));\n-      result = convert (result_type, result);\n-\n-      /* ... with the system allocator's return value stored just in\n-\t front.  */\n-      {\n-\ttree ptr_addr\n-\t  = build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n-\t\t\t     convert (ptr_void_type_node, result),\n-\t\t\t     size_int (-POINTER_SIZE/BITS_PER_UNIT));\n-\n-\ttree ptr_ref\n-\t  = convert (build_pointer_type (ptr_void_type_node), ptr_addr);\n-\n-\tresult\n-\t  = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t    build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t\t\t     ptr_ref),\n-\t\t\t\t     convert (ptr_void_type_node,\n-\t\t\t\t\t      record_addr)),\n-\t\t    result);\n-      }\n-    }\n-  else\n-    result = convert (result_type,\n-\t\t      build_call_alloc_dealloc (NULL_TREE, size,\n-\t\t\t\t\t\tTYPE_ALIGN (type),\n-\t\t\t\t\t\tgnat_proc,\n-\t\t\t\t\t\tgnat_pool,\n-\t\t\t\t\t\tgnat_node));\n-\n-  /* If we have an initial value, put the new address into a SAVE_EXPR, assign\n-     the value, and return the address.  Do this with a COMPOUND_EXPR.  */\n-\n-  if (init)\n-    {\n-      result = save_expr (result);\n-      result\n-\t= build2 (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t  build_binary_op\n-\t\t  (MODIFY_EXPR, NULL_TREE,\n-\t\t   build_unary_op (INDIRECT_REF,\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (result)), result),\n-\t\t   init),\n-\t\t  result);\n-    }\n-\n-  return convert (result_type, result);\n-}\n-\f\n-/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record.  */\n-\n-tree\n-fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n-{\n-  tree record_type = TREE_TYPE (TREE_TYPE (get_gnu_tree (gnat_formal)));\n-  tree field;\n-  tree const_list = NULL_TREE;\n-\n-  expr = maybe_unconstrained_array (expr);\n-  gnat_mark_addressable (expr);\n-\n-  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n-    const_list\n-      = tree_cons (field,\n-\t\t   convert (TREE_TYPE (field),\n-\t\t\t    SUBSTITUTE_PLACEHOLDER_IN_EXPR\n-\t\t\t    (DECL_INITIAL (field), expr)),\n-\t\t   const_list);\n-\n-  return gnat_build_constructor (record_type, nreverse (const_list));\n-}\n-\n-/* Indicate that we need to make the address of EXPR_NODE and it therefore\n-   should not be allocated in a register.  Returns true if successful.  */\n-\n-bool\n-gnat_mark_addressable (tree expr_node)\n-{\n-  while (1)\n-    switch (TREE_CODE (expr_node))\n-      {\n-      case ADDR_EXPR:\n-      case COMPONENT_REF:\n-      case ARRAY_REF:\n-      case ARRAY_RANGE_REF:\n-      case REALPART_EXPR:\n-      case IMAGPART_EXPR:\n-      case VIEW_CONVERT_EXPR:\n-      case NON_LVALUE_EXPR:\n-      CASE_CONVERT:\n-\texpr_node = TREE_OPERAND (expr_node, 0);\n-\tbreak;\n-\n-      case CONSTRUCTOR:\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n-\treturn true;\n-\n-      case VAR_DECL:\n-      case PARM_DECL:\n-      case RESULT_DECL:\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n-\treturn true;\n-\n-      case FUNCTION_DECL:\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n-\treturn true;\n-\n-      case CONST_DECL:\n-\treturn (DECL_CONST_CORRESPONDING_VAR (expr_node)\n-\t\t&& (gnat_mark_addressable\n-\t\t    (DECL_CONST_CORRESPONDING_VAR (expr_node))));\n-      default:\n-\treturn true;\n-    }\n-}"}]}