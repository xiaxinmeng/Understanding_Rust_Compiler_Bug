{"sha": "c60026252860eef665bc52174dac66d3426145ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYwMDI2MjUyODYwZWVmNjY1YmM1MjE3NGRhYzY2ZDM0MjYxNDVjYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-14T12:07:44Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-14T12:07:44Z"}, "message": "error.c: Fix comment formatting.\n\n\t* error.c: Fix comment formatting.\n\t* except.c: Likewise.\n\t* expr.c: Likewise.\n\t* friend.c: Likewise.\n\t* g++spec.c: Likewise.\n\t* init.c: Likewise.\n\t* lex.c: Likewise.\n\t* mangle.c: Likewise.\n\t* method.c: Likewise.\n\t* optimize.c: Likewise.\n\t* pt.c: Likewise.\n\t* rtti.c: Likewise.\n\t* search.c: Likewise.\n\t* semantics.c: Likewise.\n\t* spew.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\nFrom-SVN: r57138", "tree": {"sha": "d8c275dbb5dddaf876a0d0ccf175cf047cd053ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c275dbb5dddaf876a0d0ccf175cf047cd053ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c60026252860eef665bc52174dac66d3426145ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c60026252860eef665bc52174dac66d3426145ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c60026252860eef665bc52174dac66d3426145ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c60026252860eef665bc52174dac66d3426145ca/comments", "author": null, "committer": null, "parents": [{"sha": "f197f1cff92d00c23110d3acc7467b98224fa90b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f197f1cff92d00c23110d3acc7467b98224fa90b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f197f1cff92d00c23110d3acc7467b98224fa90b"}], "stats": {"total": 235, "additions": 128, "deletions": 107}, "files": [{"sha": "bbdbef09585c1f980c5483c06bc28ff11966134c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -1,3 +1,24 @@\n+2002-09-14  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* error.c: Fix comment formatting.\n+\t* except.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* friend.c: Likewise.\n+\t* g++spec.c: Likewise.\n+\t* init.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* method.c: Likewise.\n+\t* optimize.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* rtti.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* spew.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2002-09-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* pt.c (unify, ARRAY_TYPE): Element type can be more qualified."}, {"sha": "7d270b2280c7552d5baa9bce0435716600bb8a98", "filename": "gcc/cp/error.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -410,7 +410,7 @@ dump_type (t, flags)\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n-      /* For parameters inside template signature. */\n+      /* For parameters inside template signature.  */\n       if (TYPE_IDENTIFIER (t))\n \tprint_tree_identifier (scratch_buffer, TYPE_IDENTIFIER (t));\n       else\n@@ -472,7 +472,7 @@ dump_type (t, flags)\n \n     default:\n       sorry_for_unsupported_tree (t);\n-      /* Fall through to error. */\n+      /* Fall through to error.  */\n \n     case ERROR_MARK:\n       print_identifier (scratch_buffer, \"<type error>\");\n@@ -848,7 +848,7 @@ dump_decl (t, flags)\n \t  {\n \t    if ((flags & TFF_DECL_SPECIFIERS)\n \t        && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n-\t      /* Say `class T' not just `T'. */\n+\t      /* Say `class T' not just `T'.  */\n \t      output_add_string (scratch_buffer, \"class \");\n \n \t    dump_type (TREE_TYPE (t), flags);\n@@ -1043,7 +1043,7 @@ dump_template_decl (t, flags)\n       nreverse(orig_parms);\n \n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n-\t/* Say `template<arg> class TT' not just `template<arg> TT'. */\n+\t/* Say `template<arg> class TT' not just `template<arg> TT'.  */\n \toutput_add_string (scratch_buffer, \"class \");\n     }\n \n@@ -1073,7 +1073,7 @@ dump_template_decl (t, flags)\n /* Pretty print a function decl. There are several ways we want to print a\n    function declaration. The TFF_ bits in FLAGS tells us how to behave.\n    As error can only apply the '#' flag once to give 0 and 1 for V, there\n-   is %D which doesn't print the throw specs, and %F which does. */\n+   is %D which doesn't print the throw specs, and %F which does.  */\n \n static void\n dump_function_decl (t, flags)\n@@ -1167,7 +1167,7 @@ dump_function_decl (t, flags)\n \n /* Print a parameter list. If this is for a member function, the\n    member object ptr (and any other hidden args) should have\n-   already been removed. */\n+   already been removed.  */\n \n static void\n dump_parameters (parmtypes, flags)\n@@ -1201,7 +1201,7 @@ dump_parameters (parmtypes, flags)\n   print_right_paren (scratch_buffer);\n }\n \n-/* Print an exception specification. T is the exception specification. */\n+/* Print an exception specification. T is the exception specification.  */\n \n static void\n dump_exception_spec (t, flags)\n@@ -1417,7 +1417,7 @@ dump_expr_list (l, flags)\n     }\n }\n \n-/* Print out an expression E under control of FLAGS. */\n+/* Print out an expression E under control of FLAGS.  */\n \n static void\n dump_expr (t, flags)"}, {"sha": "0502543b88735ea3a55301dbe91092e009f8b742", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -117,7 +117,7 @@ prepare_eh_type (type)\n }\n \n /* Build the address of a typeinfo decl for use in the runtime\n-   matching field of the exception model.   */\n+   matching field of the exception model.  */\n \n static tree\n build_eh_type_type (type)"}, {"sha": "3cc6551ee52f2e21870d225d43af6ea11682e36d", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -102,7 +102,7 @@ cxx_expand_expr (exp, target, tmode, modifier)\n \t\t\t  target, tmode, modifier);\n \n     case OFFSET_REF:\n-      /* Offset refs should not make it through to here. */\n+      /* Offset refs should not make it through to here.  */\n       abort ();\n       return const0_rtx;\n       "}, {"sha": "62b20307db41864bcc8e480b9ab40826bb7363f1", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -114,7 +114,7 @@ is_friend (type, supplicant)\n   else\n     context = NULL_TREE;\n \n-  /* A namespace is not friend to anybody. */\n+  /* A namespace is not friend to anybody.  */\n   if (context && TREE_CODE (context) == NAMESPACE_DECL)\n     context = NULL_TREE;\n \n@@ -230,7 +230,7 @@ make_friend_class (type, friend_type)\n      A friend of a class or class template can be a function or\n      class template, a specialization of a function template or\n      class template, or an ordinary (nontemplate) function or\n-     class. */\n+     class.  */\n   if (!is_template_friend)\n     ;/* ok */\n   else if (TREE_CODE (friend_type) == TYPENAME_TYPE)\n@@ -396,14 +396,14 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n \t    /* This must be a local class, so pushdecl will be ok, and\n \t       insert an unqualified friend into the local scope\n \t       (rather than the containing namespace scope, which the\n-\t       next choice will do). */\n+\t       next choice will do).  */\n \t    decl = pushdecl (decl);\n \t  else\n \t    {\n \t      /* We can't use pushdecl, as we might be in a template\n \t         class specialization, and pushdecl will insert an\n \t         unqualified friend decl into the template parameter\n-\t         scope, rather than the namespace containing it. */\n+\t         scope, rather than the namespace containing it.  */\n \t      tree ns = decl_namespace_context (decl);\n \t      \n \t      push_nested_namespace (ns);"}, {"sha": "292f6abd637bba8e29db3cacf5b22f96a3f7a705", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -299,11 +299,11 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   *in_added_libraries = added_libraries;\n }\n \n-/* Called before linking.  Returns 0 on success and -1 on failure. */\n-int lang_specific_pre_link ()  /* Not used for C++. */\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n+int lang_specific_pre_link ()  /* Not used for C++.  */\n {\n   return 0;\n }\n \n-/* Number of extra output files that lang_specific_pre_link may generate. */\n-int lang_specific_extra_outfiles = 0;  /* Not used for C++. */\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+int lang_specific_extra_outfiles = 0;  /* Not used for C++.  */"}, {"sha": "91cfc19a1ee0c756d0f17492a16ad3ff9c1a4012", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -185,7 +185,7 @@ build_forced_zero_init (type)\n       init = integer_zero_node;\n       \n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n-        /* We must make enumeral types the right type. */\n+        /* We must make enumeral types the right type.  */\n         init = fold (build1 (NOP_EXPR, type, init));\n     }\n \n@@ -2126,7 +2126,7 @@ build_new (placement, decl, init, use_global_new)\n   return rval;\n }\n \n-/* Given a Java class, return a decl for the corresponding java.lang.Class. */\n+/* Given a Java class, return a decl for the corresponding java.lang.Class.  */\n \n tree\n build_java_class_ref (type)\n@@ -3218,7 +3218,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t{\n \t  /* We will use ADDR multiple times so we must save it.  */\n \t  addr = save_expr (addr);\n-\t  /* Delete the object. */\n+\t  /* Delete the object.  */\n \t  do_delete = build_builtin_delete_call (addr);\n \t  /* Otherwise, treat this like a complete object destructor\n \t     call.  */"}, {"sha": "971d19319e0dfeede1cbcdf785f9bfd98e8d9398", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -1073,7 +1073,7 @@ do_pending_lang_change ()\n     pop_lang_context ();\n }\n \n-/* Return true if d is in a global scope. */\n+/* Return true if d is in a global scope.  */\n \n static int\n is_global (d)"}, {"sha": "a857ae8dd079b770360d65d561cac943ccdb8099", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -196,7 +196,7 @@ static inline void start_mangling PARAMS ((void));\n static inline const char *finish_mangling PARAMS ((void));\n static tree mangle_special_for_type PARAMS ((tree, const char *));\n \n-/* Foreign language functions. */\n+/* Foreign language functions.  */\n \n static void write_java_integer_type_codes PARAMS ((tree));\n \n@@ -205,7 +205,7 @@ static void write_java_integer_type_codes PARAMS ((tree));\n #define write_char(CHAR)                                              \\\n   obstack_1grow (&G.name_obstack, (CHAR))\n \n-/* Append a sized buffer to the end of the mangled representation. */\n+/* Append a sized buffer to the end of the mangled representation.  */\n #define write_chars(CHAR, LEN)                                        \\\n   obstack_grow (&G.name_obstack, (CHAR), (LEN))\n \n@@ -575,7 +575,7 @@ find_substitution (node)\n     }\n \n   /* Now check the list of available substitutions for this mangling\n-     operation.    */\n+     operation.  */\n   for (i = 0; i < size; ++i)\n     {\n       tree candidate = VARRAY_TREE (G.substitutions, i);\n@@ -1080,7 +1080,7 @@ write_number (number, unsigned_p, base)\n \n /* Write out an integral CST in decimal. Most numbers are small, and\n    representable in a HOST_WIDE_INT. Occasionally we'll have numbers\n-   bigger than that, which we must deal with. */\n+   bigger than that, which we must deal with.  */\n \n static inline void\n write_integer_cst (cst)\n@@ -1091,7 +1091,7 @@ write_integer_cst (cst)\n   if (TREE_INT_CST_HIGH (cst) + (sign < 0))\n     {\n       /* A bignum. We do this in chunks, each of which fits in a\n-\t HOST_WIDE_INT. */\n+\t HOST_WIDE_INT.  */\n       char buffer[sizeof (HOST_WIDE_INT) * 8 * 2];\n       unsigned HOST_WIDE_INT chunk;\n       unsigned chunk_digits;\n@@ -1101,13 +1101,13 @@ write_integer_cst (cst)\n       int done;\n \n       /* HOST_WIDE_INT must be at least 32 bits, so 10^9 is\n-\t representable. */\n+\t representable.  */\n       chunk = 1000000000;\n       chunk_digits = 9;\n       \n       if (sizeof (HOST_WIDE_INT) >= 8)\n \t{\n-\t  /* It is at least 64 bits, so 10^18 is representable. */\n+\t  /* It is at least 64 bits, so 10^18 is representable.  */\n \t  chunk_digits = 18;\n \t  chunk *= chunk;\n \t}\n@@ -1275,7 +1275,7 @@ static void\n write_discriminator (discriminator)\n      int discriminator;\n {\n-  /* If discriminator is zero, don't write anything.  Otherwise... */\n+  /* If discriminator is zero, don't write anything.  Otherwise...  */\n   if (discriminator > 0)\n     {\n       write_char ('_');\n@@ -1810,7 +1810,7 @@ write_expression (expr)\n       code = TREE_CODE (expr);\n     }\n \n-  /* Handle template parameters. */\n+  /* Handle template parameters.  */\n   if (code == TEMPLATE_TYPE_PARM \n       || code == TEMPLATE_TEMPLATE_PARM\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM"}, {"sha": "bc3322123aa357a13475fd0e2b3e21256d44fb8e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -749,7 +749,7 @@ synthesize_method (fndecl)\n      during the generation of the implicit body points at the place\n      where the attempt to generate the function occurs, giving the\n      user a hint as to why we are attempting to generate the\n-     function. */\n+     function.  */\n   DECL_SOURCE_LINE (fndecl) = lineno;\n   DECL_SOURCE_FILE (fndecl) = input_filename;\n "}, {"sha": "15a9ea6a7e62e28d639985c5d1bb1e263480ea85", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -41,7 +41,7 @@ static tree calls_setjmp_r PARAMS ((tree *, int *, void *));\n static void update_cloned_parm PARAMS ((tree, tree));\n static void dump_function PARAMS ((enum tree_dump_index, tree));\n \n-/* Optimize the body of FN. */\n+/* Optimize the body of FN.  */\n \n void\n optimize_function (fn)\n@@ -119,15 +119,15 @@ update_cloned_parm (parm, cloned_parm)\n {\n   DECL_ABSTRACT_ORIGIN (cloned_parm) = parm;\n \n-  /* We may have taken its address. */\n+  /* We may have taken its address.  */\n   TREE_ADDRESSABLE (cloned_parm) = TREE_ADDRESSABLE (parm);\n \n-  /* The definition might have different constness. */\n+  /* The definition might have different constness.  */\n   TREE_READONLY (cloned_parm) = TREE_READONLY (parm);\n   \n   TREE_USED (cloned_parm) = TREE_USED (parm);\n   \n-  /* The name may have changed from the declaration. */\n+  /* The name may have changed from the declaration.  */\n   DECL_NAME (cloned_parm) = DECL_NAME (parm);\n   DECL_SOURCE_LOCATION (cloned_parm) = DECL_SOURCE_LOCATION (parm);\n }\n@@ -176,7 +176,7 @@ maybe_clone_body (fn)\n       DECL_NOT_REALLY_EXTERN (clone) = DECL_NOT_REALLY_EXTERN (fn);\n       TREE_PUBLIC (clone) = TREE_PUBLIC (fn);\n \n-      /* Adjust the parameter names and locations. */\n+      /* Adjust the parameter names and locations.  */\n       parm = DECL_ARGUMENTS (fn);\n       clone_parm = DECL_ARGUMENTS (clone);\n       /* Update the `this' parameter, which is always first.  */\n@@ -194,7 +194,7 @@ maybe_clone_body (fn)\n \t{\n \t  /* Update this parameter.  */\n \t  update_cloned_parm (parm, clone_parm);\n-\t  /* We should only give unused information for one clone. */\n+\t  /* We should only give unused information for one clone.  */\n \t  if (!first)\n \t    TREE_USED (clone_parm) = 1;\n \t}\n@@ -275,7 +275,7 @@ maybe_clone_body (fn)\n   return 1;\n }\n \n-/* Dump FUNCTION_DECL FN as tree dump PHASE. */\n+/* Dump FUNCTION_DECL FN as tree dump PHASE.  */\n \n static void\n dump_function (phase, fn)"}, {"sha": "e05174fb00507ef00643b74fe4a9aef746419ece", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -381,7 +381,7 @@ maybe_begin_member_template_processing (decl)\n   ++inline_parm_levels_used;\n }\n \n-/* Undo the effects of begin_member_template_processing. */\n+/* Undo the effects of begin_member_template_processing.  */\n \n void \n maybe_end_member_template_processing ()\n@@ -617,7 +617,7 @@ check_specialization_scope ()\n     error (\"enclosing class templates are not explicitly specialized\");\n }\n \n-/* We've just seen template <>. */\n+/* We've just seen template <>.  */\n \n void\n begin_specialization ()\n@@ -638,7 +638,7 @@ end_specialization ()\n }\n \n /* Any template <>'s that we have seen thus far are not referring to a\n-   function specialization. */\n+   function specialization.  */\n \n void\n reset_specialization ()\n@@ -981,7 +981,7 @@ determine_specialization (template_id, decl, targs_out,\n   if (fns == error_mark_node)\n     return error_mark_node;\n \n-  /* Check for baselinks. */\n+  /* Check for baselinks.  */\n   if (BASELINK_P (fns))\n     fns = BASELINK_FUNCTIONS (fns);\n \n@@ -1141,7 +1141,7 @@ determine_specialization (template_id, decl, targs_out,\n       return error_mark_node;\n     }\n \n-  /* We have one, and exactly one, match. */\n+  /* We have one, and exactly one, match.  */\n   if (candidates)\n     {\n       /* It was a specialization of an ordinary member function in a\n@@ -2631,7 +2631,7 @@ push_template_decl_real (decl, is_friend)\n \t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n \t    {\n \t      /* A specialization of a member template of a template\n-\t\t class. */\n+\t\t class.  */\n \t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n \t      DECL_TEMPLATE_INFO (tmpl) = DECL_TEMPLATE_INFO (decl);\n \t      DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n@@ -2998,7 +2998,7 @@ convert_nontype_argument (type, expr)\n     case ENUMERAL_TYPE:\n       /* For a non-type template-parameter of integral or enumeration\n          type, integral promotions (_conv.prom_) and integral\n-         conversions (_conv.integral_) are applied. */\n+         conversions (_conv.integral_) are applied.  */\n       if (!INTEGRAL_TYPE_P (expr_type))\n \treturn error_mark_node;\n       \n@@ -4726,7 +4726,7 @@ tsubst_friend_function (decl, args)\n \n       /* Inside pushdecl_namespace_level, we will push into the\n \t current namespace. However, the friend function should go\n-\t into the namespace of the template. */\n+\t into the namespace of the template.  */\n       ns = decl_namespace_context (new_friend);\n       push_nested_namespace (ns);\n       old_decl = pushdecl_namespace_level (new_friend);\n@@ -5789,7 +5789,7 @@ tsubst_decl (t, args, type, complain)\n \n \t/* The template parameters for this new template are all the\n \t   template parameters for the old template, except the\n-\t   outermost level of parameters. */\n+\t   outermost level of parameters.  */\n \tDECL_TEMPLATE_PARMS (r) \n \t  = tsubst_template_parms (DECL_TEMPLATE_PARMS (t), args,\n \t\t\t\t   complain);\n@@ -6774,7 +6774,7 @@ tsubst (t, args, complain, in_decl)\n \tif (fntype == error_mark_node)\n \t  return error_mark_node;\n \n-\t/* Substitue the exception specification. */\n+\t/* Substitue the exception specification.  */\n \traises = TYPE_RAISES_EXCEPTIONS (t);\n \tif (raises)\n \t  {\n@@ -7422,7 +7422,7 @@ tsubst_expr (t, args, complain, in_decl)\n \t    if (decl != error_mark_node)\n \t      {\n                 if (TREE_CODE (decl) != TYPE_DECL)\n-                  /* Make sure the type is instantiated now. */\n+                  /* Make sure the type is instantiated now.  */\n                   complete_type (TREE_TYPE (decl));\n \t        if (init)\n \t          DECL_INITIAL (decl) = error_mark_node;\n@@ -7696,7 +7696,7 @@ instantiate_template (tmpl, targ_ptr)\n       tree spec = instantiate_template (DECL_CLONED_FUNCTION (tmpl), targ_ptr);\n       tree clone;\n       \n-      /* Look for the clone. */\n+      /* Look for the clone.  */\n       for (clone = TREE_CHAIN (spec);\n \t   clone && DECL_CLONED_FUNCTION_P (clone);\n \t   clone = TREE_CHAIN (clone))\n@@ -8893,7 +8893,7 @@ unify (tparms, targs, parm, arg, strict)\n \t  {\n \t    /* Avoid getting confused about cv-quals; don't recurse here.\n \t       Pointers to members should really be just OFFSET_TYPE, not\n-\t       this two-level nonsense... */\n+\t       this two-level nonsense...  */\n \n \t    parm = TREE_TYPE (parm);\n \t    arg = TREE_TYPE (arg);\n@@ -10074,7 +10074,7 @@ instantiate_decl (d, defer_ok)\n \t  /* Don't simply tsubst the function type, as that will give\n \t     duplicate warnings about poor parameter qualifications.\n \t     The function arguments are the same as the decl_arguments\n-\t     without the top level cv qualifiers. */\n+\t     without the top level cv qualifiers.  */\n \t  type = TREE_TYPE (type);\n \t}\n       tsubst (type, args, tf_error | tf_warning, d);"}, {"sha": "7fa76c276cb60af42ef4bad841df03cde15c2ae8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -62,13 +62,13 @@ Boston, MA 02111-1307, USA.  */\n /* Accessors for the type_info objects. We need to remember several things\n    about each of the type_info types. The global tree nodes such as\n    bltn_desc_type_node are TREE_LISTs, and these macros are used to access\n-   the required information. */\n-/* The RECORD_TYPE of a type_info derived class. */\n+   the required information.  */\n+/* The RECORD_TYPE of a type_info derived class.  */\n #define TINFO_PSEUDO_TYPE(NODE) TREE_TYPE (NODE)\n /* The VAR_DECL of the vtable for the type_info derived class.\n-   This is only filled in at the end of the translation. */\n+   This is only filled in at the end of the translation.  */\n #define TINFO_VTABLE_DECL(NODE) TREE_VALUE (NODE)\n-/* The IDENTIFIER_NODE naming the real class. */\n+/* The IDENTIFIER_NODE naming the real class.  */\n #define TINFO_REAL_NAME(NODE) TREE_PURPOSE (NODE)\n \n static tree build_headof PARAMS((tree));\n@@ -923,7 +923,7 @@ dfs_class_hint_mark (binfo, data)\n   return NULL_TREE;\n };\n \n-/* Clear the base's dfs marks, after searching for duplicate bases. */\n+/* Clear the base's dfs marks, after searching for duplicate bases.  */\n \n static tree\n dfs_class_hint_unmark (binfo, data)\n@@ -1104,7 +1104,7 @@ get_pseudo_ti_init (type, var_desc, non_public_p)\n \t  /* Prepend the number of bases.  */\n \t  base_inits = tree_cons (NULL_TREE,\n \t\t\t\t  build_int_2 (nbases, 0), base_inits);\n-\t  /* Prepend the hint flags. */\n+\t  /* Prepend the hint flags.  */\n \t  base_inits = tree_cons (NULL_TREE,\n \t\t\t\t  build_int_2 (hint, 0), base_inits);\n \n@@ -1146,21 +1146,21 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n   VA_FIXEDARG (ap, const char *, real_name);\n   VA_FIXEDARG (ap, int, ident);\n \n-  /* Generate the pseudo type name. */\n+  /* Generate the pseudo type name.  */\n   pseudo_name = (char *)alloca (strlen (real_name) + 30);\n   strcpy (pseudo_name, real_name);\n   strcat (pseudo_name, \"_pseudo\");\n   if (ident)\n     sprintf (pseudo_name + strlen (pseudo_name), \"%d\", ident);\n   \n-  /* First field is the pseudo type_info base class. */\n+  /* First field is the pseudo type_info base class.  */\n   fields[0] = build_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n   \n   /* Now add the derived fields.  */\n   for (ix = 0; (field_decl = va_arg (ap, tree));)\n     fields[++ix] = field_decl;\n   \n-  /* Create the pseudo type. */\n+  /* Create the pseudo type.  */\n   pseudo_type = make_aggr_type (RECORD_TYPE);\n   finish_builtin_type (pseudo_type, pseudo_name, fields, ix, ptr_type_node);\n   TYPE_HAS_CONSTRUCTOR (pseudo_type) = 1;\n@@ -1214,7 +1214,7 @@ get_pseudo_ti_desc (type)\n \t      && TREE_PUBLIC (base_binfo)\n \t      && !TREE_VIA_VIRTUAL (base_binfo)\n \t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n-\t    /* single non-virtual public. */\n+\t    /* single non-virtual public.  */\n \t    return si_class_desc_type_node;\n \t  else\n \t    {\n@@ -1287,7 +1287,7 @@ create_tinfo_types ()\n       (\"__fundamental_type_info\", 0,\n        NULL);\n \n-  /* Array, function and enum type_info. No additional fields. */\n+  /* Array, function and enum type_info. No additional fields.  */\n   ary_desc_type_node = create_pseudo_type_info\n       (\"__array_type_info\", 0,\n        NULL);\n@@ -1311,7 +1311,7 @@ create_tinfo_types ()\n             NULL);\n   \n   /* Base class internal helper. Pointer to base type, offset to base,\n-     flags. */\n+     flags.  */\n   {\n     tree fields[2];\n     \n@@ -1323,12 +1323,12 @@ create_tinfo_types ()\n     TYPE_HAS_CONSTRUCTOR (base_desc_type_node) = 1;\n   }\n   \n-  /* General hierarchy is created as necessary in this vector. */\n+  /* General hierarchy is created as necessary in this vector.  */\n   vmi_class_desc_type_node = make_tree_vec (10);\n   \n   /* Pointer type_info. Adds two fields, qualification mask\n      and pointer to the pointed to type.  This is really a descendant of\n-     __pbase_type_info. */\n+     __pbase_type_info.  */\n   ptr_desc_type_node = create_pseudo_type_info\n       (\"__pointer_type_info\", 0,\n        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n@@ -1462,7 +1462,7 @@ emit_tinfo_decl (decl_ptr, data)\n \n   DECL_INITIAL (decl) = var_init;\n   cp_finish_decl (decl, var_init, NULL_TREE, 0);\n-  /* cp_finish_decl will have dealt with linkage. */\n+  /* cp_finish_decl will have dealt with linkage.  */\n   \n   /* Say we've dealt with it.  */\n   TREE_TYPE (DECL_NAME (decl)) = NULL_TREE;"}, {"sha": "41bde712082aefe31a2ed6b9840d673f073a29ff", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -204,7 +204,7 @@ lookup_base_r (binfo, base, access, within_current_scope,\n   if (same_type_p (BINFO_TYPE (binfo), base))\n     {\n       /* We have found a base. Check against what we have found\n-         already. */\n+         already.  */\n       found = bk_same_type;\n       if (is_virtual)\n \tfound = bk_via_virtual;\n@@ -311,7 +311,7 @@ lookup_base (t, base, access, kind_ptr)\n      base_access access;\n      base_kind *kind_ptr;\n {\n-  tree binfo = NULL;\t\t/* The binfo we've found so far. */\n+  tree binfo = NULL;\t\t/* The binfo we've found so far.  */\n   tree t_binfo = NULL;\n   base_kind bk;\n   \n@@ -1995,7 +1995,7 @@ look_for_overrides_here (type, fndecl)\n }\n \n /* Look in TYPE for virtual functions overridden by FNDECL. Check both\n-   TYPE itself and its bases. */\n+   TYPE itself and its bases.  */\n \n static int\n look_for_overrides_r (type, fndecl)\n@@ -2795,7 +2795,7 @@ binfo_for_vtable (var)\n     }\n \n   /* If no secondary base classes matched, return the primary base, if\n-     there is one.   */\n+     there is one.  */\n   if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (main_binfo)))\n     return get_primary_binfo (main_binfo);\n "}, {"sha": "946f7156d19e874c2038792b0f2c51439e4d17e1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -586,7 +586,7 @@ finish_switch_stmt (switch_stmt)\n   do_poplevel ();\n }\n \n-/* Generate the RTL for T, which is a TRY_BLOCK. */\n+/* Generate the RTL for T, which is a TRY_BLOCK.  */\n \n static void \n genrtl_try_block (t)\n@@ -623,7 +623,7 @@ genrtl_try_block (t)\n     }\n }\n \n-/* Generate the RTL for T, which is an EH_SPEC_BLOCK. */\n+/* Generate the RTL for T, which is an EH_SPEC_BLOCK.  */\n \n static void \n genrtl_eh_spec_block (t)\n@@ -732,7 +732,7 @@ finish_function_handler_sequence (try_block)\n   check_handlers (TRY_HANDLERS (try_block));\n }\n \n-/* Generate the RTL for T, which is a HANDLER. */\n+/* Generate the RTL for T, which is a HANDLER.  */\n \n static void\n genrtl_handler (t)\n@@ -1003,7 +1003,7 @@ finish_eh_cleanup (cleanup)\n   add_stmt (r);\n }\n \n-/* Generate the RTL for a RETURN_INIT. */\n+/* Generate the RTL for a RETURN_INIT.  */\n \n static void\n genrtl_named_return_value ()\n@@ -1633,7 +1633,7 @@ finish_translation_unit ()\n   while (current_namespace != global_namespace)\n     pop_namespace ();\n \n-  /* Do file scope __FUNCTION__ et al. */\n+  /* Do file scope __FUNCTION__ et al.  */\n   finish_fname_decls ();\n   \n   finish_file ();\n@@ -1724,7 +1724,7 @@ begin_class_definition (t)\n   if (t == error_mark_node)\n     return error_mark_node;\n \n-  /* Check the bases are accessible. */\n+  /* Check the bases are accessible.  */\n   decl_type_access_control (TYPE_NAME (t));\n   reset_type_access_control ();\n   "}, {"sha": "bf3407af8c6d1de736459cc486ab36a4c39be75e", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -86,7 +86,7 @@ struct unparsed_text GTY(())\n \n   struct token_chunk *last_chunk; /* End of the token list.  */\n   short last_pos;\t/* Number of tokens used in the last chunk of\n-\t\t\t   TOKENS. */\n+\t\t\t   TOKENS.  */\n \n   short cur_pos;\t/* Current token in 'cur_chunk', when rescanning.  */\n   struct token_chunk *cur_chunk;  /* Current chunk, when rescanning.  */\n@@ -185,7 +185,7 @@ static int first_token;\n static GTY(()) tree defarg_fns;\n /* current default parameter */\n static GTY(()) tree defarg_parm;\n-/* list of unprocessed fns met during current fn. */\n+/* list of unprocessed fns met during current fn.  */\n static GTY(()) tree defarg_depfns;\n /* list of fns with circular defargs */\n static GTY(()) tree defarg_fnsdone;\n@@ -668,7 +668,7 @@ do_aggr ()\n void\n see_typename ()\n {\n-  /* Only types expected, not even namespaces. */\n+  /* Only types expected, not even namespaces.  */\n   looking_for_typename = 2;\n   if (yychar < 0)\n     if ((yychar = yylex ()) < 0) yychar = 0;\n@@ -754,7 +754,7 @@ yylex ()\n     case PTYPENAME:\n     case PTYPENAME_DEFN:\n       /* If we see a SCOPE next, restore the old value.\n-\t Otherwise, we got what we want. */\n+\t Otherwise, we got what we want.  */\n       looking_for_typename = old_looking_for_typename;\n       looking_for_template = 0;\n       break;\n@@ -887,7 +887,7 @@ frob_id (yyc, peek, idp)\n           case NSNAME:\n           case PTYPENAME:\n \t    /* If this got special lookup, remember it.  In these\n-\t       cases, we know it can't be a declarator-id. */\n+\t       cases, we know it can't be a declarator-id.  */\n             if (got_scope || got_object)\n               *idp = trrr;\n             /* FALLTHROUGH */\n@@ -1372,7 +1372,7 @@ do_pending_defargs ()\n               /* No need to say what else is dependent, as they will be\n                  picked up in another pass.  */\n \n-              /* Immediately repeat, but marked so that we break the loop. */\n+              /* Immediately repeat, but marked so that we break the loop.  */\n               defarg_fns = current;\n               TREE_PURPOSE (current) = error_mark_node;\n             }\n@@ -1384,7 +1384,7 @@ do_pending_defargs ()\n }\n \n /* After parsing all the default arguments, we must clear any that remain,\n-   which will be part of a circular dependency. */\n+   which will be part of a circular dependency.  */\n void\n done_pending_defargs ()\n {"}, {"sha": "44a013cfe77be19de6895881e3692e0ec1f1e7a1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -94,7 +94,7 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n       /* If expression doesn't change the type, we consider it as an\n \t lvalue even when cast_as_lvalue extension isn't selected.\n \t That's because parts of the compiler are alleged to be sloppy\n-\t about sticking in NOP_EXPR node for no good reason. */\n+\t about sticking in NOP_EXPR node for no good reason.  */\n       if (allow_cast_as_lvalue ||\n \t  same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ref)),\n \t\t       TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (ref, 0)))))\n@@ -1027,7 +1027,7 @@ get_first_fn (from)\n      tree from;\n {\n   my_friendly_assert (is_overloaded_fn (from), 9);\n-  /* A baselink is also considered an overloaded function. */\n+  /* A baselink is also considered an overloaded function.  */\n   if (BASELINK_P (from))\n     from = BASELINK_FUNCTIONS (from);\n   return OVL_CURRENT (from);\n@@ -1044,7 +1044,7 @@ bound_pmf_p (t)\n \t  && TYPE_PTRMEMFUNC_P (TREE_TYPE (TREE_OPERAND (t, 1))));\n }\n \n-/* Return a new OVL node, concatenating it with the old one. */\n+/* Return a new OVL node, concatenating it with the old one.  */\n \n tree\n ovl_cons (decl, chain)\n@@ -1898,7 +1898,7 @@ maybe_dummy_object (type, binfop)\n   if (current_class_ref && context == current_class_type\n       /* Kludge: Make sure that current_class_type is actually\n          correct.  It might not be if we're in the middle of\n-         tsubst_default_argument. */\n+         tsubst_default_argument.  */\n       && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref)),\n \t\t      current_class_type))\n     decl = current_class_ref;\n@@ -2070,7 +2070,7 @@ handle_init_priority_attribute (node, name, args, flags, no_add_attrs)\n       /* Static objects in functions are initialized the\n \t first time control passes through that\n \t function. This is not precise enough to pin down an\n-\t init_priority value, so don't allow it. */\n+\t init_priority value, so don't allow it.  */\n       || current_function_decl) \n     {\n       error (\"can only use `%s' attribute on file-scope definitions of objects of class type\","}, {"sha": "abf4919e5fb3930ab2a8bbea3d33f99b393eec26", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -491,7 +491,7 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n     return t1;\n  \n   /* Deal with pointer-to-member functions in the same way as we deal\n-     with pointers to functions. */\n+     with pointers to functions.  */\n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n   if (TYPE_PTRMEMFUNC_P (t2))\n@@ -800,11 +800,11 @@ comp_except_specs (t1, t2, exact)\n   if (t1 == t2)\n     return 1;\n   \n-  if (t1 == NULL_TREE)              /* T1 is ... */\n+  if (t1 == NULL_TREE)              /* T1 is ...  */\n     return t2 == NULL_TREE || !exact;\n   if (!TREE_VALUE (t1)) /* t1 is EMPTY */\n     return t2 != NULL_TREE && !TREE_VALUE (t2);\n-  if (t2 == NULL_TREE)              /* T2 is ... */\n+  if (t2 == NULL_TREE)              /* T2 is ...  */\n     return 0;\n   if (TREE_VALUE (t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n     return !exact;\n@@ -2522,7 +2522,7 @@ build_array_ref (array, idx)\n    With the final ISO C++ rules, such an optimization is\n    incorrect: A pointer to a derived member can be static_cast\n    to pointer-to-base-member, as long as the dynamic object\n-   later has the right member. */\n+   later has the right member.  */\n \n tree\n get_member_function_from_ptrfunc (instance_ptrptr, function)\n@@ -2544,7 +2544,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t    {\n \t      /* Extracting the function address from a pmf is only\n \t\t allowed with -Wno-pmf-conversions. It only works for\n-\t\t pmf constants. */\n+\t\t pmf constants.  */\n \t      e1 = build_addr_func (PTRMEM_CST_MEMBER (function));\n \t      e1 = convert (fntype, e1);\n \t      return e1;\n@@ -2583,7 +2583,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t}\n \n       /* Convert down to the right base before using the instance.  First\n-         use the type... */\n+         use the type...  */\n       basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (fntype));\n       basetype = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)),\n \t\t\t      basetype, ba_check, NULL);\n@@ -4292,7 +4292,7 @@ build_unary_op (code, xarg, noconvert)\n \t\t && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (arg, 0), 0))\n \t\t     == INTEGER_CST))\n \t  {\n-\t    /* offsetof idiom, fold it. */\n+\t    /* offsetof idiom, fold it.  */\n \t    tree field = TREE_OPERAND (arg, 1);\n \t    tree rval = build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 0);\n \t    tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (rval)),\n@@ -4583,7 +4583,7 @@ build_x_compound_expr (list)\n \n   if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n     {\n-      /* FIXME: This test should be in the implicit cast to void of the LHS. */\n+      /* FIXME: This test should be in the implicit cast to void of the LHS.  */\n       /* the left-hand operand of a comma expression is like an expression\n          statement: we should warn if it doesn't have any side-effects,\n          unless it was explicitly cast to (void).  */\n@@ -4694,12 +4694,12 @@ build_static_cast (type, expr)\n       ? can_convert_arg (type, intype, expr)\n       : can_convert_arg (strip_all_pointer_quals (type),\n                          strip_all_pointer_quals (intype), expr))\n-    /* This is a standard conversion. */\n+    /* This is a standard conversion.  */\n     ok = 1;\n   else if (TYPE_PTROB_P (type) && TYPE_PTROB_P (intype))\n     {\n       /* They're pointers to objects. They must be aggregates that\n-         are related non-virtually. */\n+         are related non-virtually.  */\n       base_kind kind;\n       \n       if (IS_AGGR_TYPE (TREE_TYPE (type)) && IS_AGGR_TYPE (TREE_TYPE (intype))\n@@ -4712,7 +4712,7 @@ build_static_cast (type, expr)\n     {\n       /* They're pointers to members. The pointed to objects must be\n \t the same (ignoring CV qualifiers), and the containing classes\n-\t must be related non-virtually. */\n+\t must be related non-virtually.  */\n       base_kind kind;\n       \n       if (same_type_p\n@@ -5510,7 +5510,7 @@ get_delta_difference (from, to, force)\n       \n       if (virt_binfo)\n         {\n-          /* This is a reinterpret cast, we choose to do nothing. */\n+          /* This is a reinterpret cast, we choose to do nothing.  */\n           warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n \t              BINFO_TYPE (virt_binfo),\n \t              BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n@@ -5528,7 +5528,7 @@ get_delta_difference (from, to, force)\n   virt_binfo = binfo_from_vbase (binfo);\n   if (virt_binfo)\n     {\n-      /* This is a reinterpret cast, we choose to do nothing. */\n+      /* This is a reinterpret cast, we choose to do nothing.  */\n       if (force)\n         warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n                     BINFO_TYPE (virt_binfo),\n@@ -6149,7 +6149,7 @@ check_return_expr (retval)\n     {\n       if (in_function_try_handler)\n \t/* If a return statement appears in a handler of the\n-\t   function-try-block of a constructor, the program is ill-formed. */\n+\t   function-try-block of a constructor, the program is ill-formed.  */\n \terror (\"cannot return from a handler of a function-try-block of a constructor\");\n       else if (retval)\n \t/* You can't return a value from a constructor.  */\n@@ -6270,7 +6270,7 @@ check_return_expr (retval)\n \n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n-         case that functype is smaller than the valtype. */\n+         case that functype is smaller than the valtype.  */\n       retval = convert_for_initialization\n \t(NULL_TREE, functype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n \t \"return\", NULL_TREE, 0);"}, {"sha": "fb55c8b55658c95549c1195f79313e86e4b33f1c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c60026252860eef665bc52174dac66d3426145ca/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c60026252860eef665bc52174dac66d3426145ca", "patch": "@@ -514,7 +514,7 @@ digest_init (type, init, tail)\n \n   if (TREE_CODE (init) == ERROR_MARK)\n     /* __PRETTY_FUNCTION__'s initializer is a bogus expression inside\n-       a template function. This gets substituted during instantiation. */\n+       a template function. This gets substituted during instantiation.  */\n     return init;\n \n   /* We must strip the outermost array type when completing the type,\n@@ -1403,7 +1403,7 @@ add_exception_specifier (list, spec, complain)\n }\n \n /* Combine the two exceptions specifier lists LIST and ADD, and return\n-   their union. */\n+   their union.  */\n \n tree\n merge_exception_specifiers (list, add)"}]}