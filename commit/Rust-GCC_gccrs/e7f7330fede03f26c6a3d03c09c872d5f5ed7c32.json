{"sha": "e7f7330fede03f26c6a3d03c09c872d5f5ed7c32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmNzMzMGZlZGUwM2YyNmM2YTNkMDNjMDljODcyZDVmNWVkN2MzMg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2015-11-26T16:10:54Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2015-11-26T16:10:54Z"}, "message": "libitm: Use multiplicative hashing in the multi-lock TM method.\n\n\t* method-ml.cc (ml_mg): Use multiplicative instead of simple hashing.\n\t(ml_wt_dispatch::pre_write): Adapt.\n\t(ml_wt_dispatch::pre_load): Likewise.\n\nFrom-SVN: r230975", "tree": {"sha": "d6f4acde73c336428623ca6fbf7da9854ca9b1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f4acde73c336428623ca6fbf7da9854ca9b1a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43a2362b94f05865d77a029ecca7a18da4d5a7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a2362b94f05865d77a029ecca7a18da4d5a7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a2362b94f05865d77a029ecca7a18da4d5a7e1"}], "stats": {"total": 90, "additions": 61, "deletions": 29}, "files": [{"sha": "e0d54c3632243a1f39c61facf6cf31f2770251f2", "filename": "libitm/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=e7f7330fede03f26c6a3d03c09c872d5f5ed7c32", "patch": "@@ -1,3 +1,9 @@\n+2015-11-26  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* method-ml.cc (ml_mg): Use multiplicative instead of simple hashing.\n+\t(ml_wt_dispatch::pre_write): Adapt.\n+\t(ml_wt_dispatch::pre_load): Likewise.\n+\n 2015-11-22  Torvald Riegel  <triegel@redhat.com>\n \n \t* libitm_i.h (gtm_alloc_action): Remove union."}, {"sha": "b4cabc8805268d2359fe846bf4d8167ffd64f0bb", "filename": "libitm/method-ml.cc", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32/libitm%2Fmethod-ml.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7330fede03f26c6a3d03c09c872d5f5ed7c32/libitm%2Fmethod-ml.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-ml.cc?ref=e7f7330fede03f26c6a3d03c09c872d5f5ed7c32", "patch": "@@ -69,23 +69,51 @@ struct ml_mg : public method_group\n   atomic<gtm_word>* orecs __attribute__((aligned(HW_CACHELINE_SIZE)));\n   char tailpadding[HW_CACHELINE_SIZE - sizeof(atomic<gtm_word>*)];\n \n-  // Location-to-orec mapping.  Stripes of 16B mapped to 2^19 orecs.\n-  static const gtm_word L2O_ORECS = 1 << 19;\n-  static const gtm_word L2O_SHIFT = 4;\n-  static size_t get_orec(const void* addr)\n+  // Location-to-orec mapping.  Stripes of 32B mapped to 2^16 orecs using\n+  // multiplicative hashing.  See Section 5.2.2 of Torvald Riegel's PhD thesis\n+  // for the background on this choice of hash function and parameters:\n+  // http://nbn-resolving.de/urn:nbn:de:bsz:14-qucosa-115596\n+  // We pick the Mult32 hash because it works well with fewer orecs (i.e.,\n+  // less space overhead and just 32b multiplication).\n+  // We may want to check and potentially change these settings once we get\n+  // better or just more benchmarks.\n+  static const gtm_word L2O_ORECS_BITS = 16;\n+  static const gtm_word L2O_ORECS = 1 << L2O_ORECS_BITS;\n+  // An iterator over the orecs covering the region [addr,addr+len).\n+  struct orec_iterator\n   {\n-    return ((uintptr_t)addr >> L2O_SHIFT) & (L2O_ORECS - 1);\n-  }\n-  static size_t get_next_orec(size_t orec)\n-  {\n-    return (orec + 1) & (L2O_ORECS - 1);\n-  }\n-  // Returns the next orec after the region.\n-  static size_t get_orec_end(const void* addr, size_t len)\n-  {\n-    return (((uintptr_t)addr + len + (1 << L2O_SHIFT) - 1) >> L2O_SHIFT)\n-        & (L2O_ORECS - 1);\n-  }\n+    static const gtm_word L2O_SHIFT = 5;\n+    static const uint32_t L2O_MULT32 = 81007;\n+    uint32_t mult;\n+    size_t orec;\n+    size_t orec_end;\n+    orec_iterator (const void* addr, size_t len)\n+    {\n+      uint32_t a = (uintptr_t) addr >> L2O_SHIFT;\n+      uint32_t ae = ((uintptr_t) addr + len + (1 << L2O_SHIFT) - 1)\n+\t  >> L2O_SHIFT;\n+      mult = a * L2O_MULT32;\n+      orec = mult >> (32 - L2O_ORECS_BITS);\n+      // We can't really avoid this second multiplication unless we use a\n+      // branch instead or know more about the alignment of addr.  (We often\n+      // know len at compile time because of instantiations of functions\n+      // such as _ITM_RU* for accesses of specific lengths.\n+      orec_end = (ae * L2O_MULT32) >> (32 - L2O_ORECS_BITS);\n+    }\n+    size_t get() { return orec; }\n+    void advance()\n+    {\n+      // We cannot simply increment orec because L2O_MULT32 is larger than\n+      // 1 << (32 - L2O_ORECS_BITS), and thus an increase of the stripe (i.e.,\n+      // addr >> L2O_SHIFT) could increase the resulting orec index by more\n+      // than one; with the current parameters, we would roughly acquire a\n+      // fourth more orecs than necessary for regions covering more than orec.\n+      // Keeping mult around as extra state shouldn't matter much.\n+      mult += L2O_MULT32;\n+      orec = mult >> (32 - L2O_ORECS_BITS);\n+    }\n+    bool reached_end() { return orec == orec_end; }\n+  };\n \n   virtual void init()\n   {\n@@ -142,14 +170,13 @@ class ml_wt_dispatch : public abi_dispatch\n     gtm_word locked_by_tx = ml_mg::set_locked(tx);\n \n     // Lock all orecs that cover the region.\n-    size_t orec = ml_mg::get_orec(addr);\n-    size_t orec_end = ml_mg::get_orec_end(addr, len);\n+    ml_mg::orec_iterator oi(addr, len);\n     do\n       {\n         // Load the orec.  Relaxed memory order is sufficient here because\n         // either we have acquired the orec or we will try to acquire it with\n         // a CAS with stronger memory order.\n-        gtm_word o = o_ml_mg.orecs[orec].load(memory_order_relaxed);\n+        gtm_word o = o_ml_mg.orecs[oi.get()].load(memory_order_relaxed);\n \n         // Check whether we have acquired the orec already.\n         if (likely (locked_by_tx != o))\n@@ -175,7 +202,7 @@ class ml_wt_dispatch : public abi_dispatch\n             // because whenever another thread reads from this CAS'\n             // modification, then it will abort anyway and does not rely on\n             // any further happens-before relation to be established.\n-            if (unlikely (!o_ml_mg.orecs[orec].compare_exchange_strong(\n+            if (unlikely (!o_ml_mg.orecs[oi.get()].compare_exchange_strong(\n                 o, locked_by_tx, memory_order_acquire)))\n               tx->restart(RESTART_LOCKED_WRITE);\n \n@@ -192,12 +219,12 @@ class ml_wt_dispatch : public abi_dispatch\n             // numbers when we have to roll back.\n             // ??? Reserve capacity early to avoid capacity checks here?\n             gtm_rwlog_entry *e = tx->writelog.push();\n-            e->orec = o_ml_mg.orecs + orec;\n+            e->orec = o_ml_mg.orecs + oi.get();\n             e->value = o;\n           }\n-        orec = o_ml_mg.get_next_orec(orec);\n+        oi.advance();\n       }\n-    while (orec != orec_end);\n+    while (!oi.reached_end());\n \n     // Do undo logging.  We do not know which region prior writes logged\n     // (even if orecs have been acquired), so just log everything.\n@@ -275,22 +302,21 @@ class ml_wt_dispatch : public abi_dispatch\n     gtm_word snapshot = tx->shared_state.load(memory_order_relaxed);\n     gtm_word locked_by_tx = ml_mg::set_locked(tx);\n \n-    size_t orec = ml_mg::get_orec(addr);\n-    size_t orec_end = ml_mg::get_orec_end(addr, len);\n+    ml_mg::orec_iterator oi(addr, len);\n     do\n       {\n         // We need acquire memory order here so that this load will\n         // synchronize with the store that releases the orec in trycommit().\n         // In turn, this makes sure that subsequent data loads will read from\n         // a visible sequence of side effects that starts with the most recent\n         // store to the data right before the release of the orec.\n-        gtm_word o = o_ml_mg.orecs[orec].load(memory_order_acquire);\n+        gtm_word o = o_ml_mg.orecs[oi.get()].load(memory_order_acquire);\n \n         if (likely (!ml_mg::is_more_recent_or_locked(o, snapshot)))\n           {\n             success:\n             gtm_rwlog_entry *e = tx->readlog.push();\n-            e->orec = o_ml_mg.orecs + orec;\n+            e->orec = o_ml_mg.orecs + oi.get();\n             e->value = o;\n           }\n         else if (!ml_mg::is_locked(o))\n@@ -308,9 +334,9 @@ class ml_wt_dispatch : public abi_dispatch\n             if (o != locked_by_tx)\n               tx->restart(RESTART_LOCKED_READ);\n           }\n-        orec = o_ml_mg.get_next_orec(orec);\n+        oi.advance();\n       }\n-    while (orec != orec_end);\n+    while (!oi.reached_end());\n     return &tx->readlog[log_start];\n   }\n "}]}