{"sha": "e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY2ZDg4NGU3YjI5ZDE2YTA5OGM4ODFiYzhiNTc3ZjJiMzlkM2NhNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-14T18:59:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-14T18:59:03Z"}, "message": "cp-tree.h (scratchalloc, [...]): Define as macros for now.\n\n\t* cp-tree.h (scratchalloc, build_scratch_list, make_scratch_vec,\n\tscratch_tree_cons): Define as macros for now.\n\t* call.c, class.c, cvt.c, decl.c, decl2.c, except.c, expr.c, init.c,\n\tlex.c, method.c, parse.y, pt.c, rtti.c, search.c, tree.c, typeck.c,\n\ttypeck2.c: Use them and the expression_obstack variants.\n\nFrom-SVN: r15900", "tree": {"sha": "e3025732f5c9bd1333870ea5379c4beaab725a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3025732f5c9bd1333870ea5379c4beaab725a30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/comments", "author": null, "committer": null, "parents": [{"sha": "22ef8a131aff4c58840adca891b573f9023b57ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ef8a131aff4c58840adca891b573f9023b57ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22ef8a131aff4c58840adca891b573f9023b57ea"}], "stats": {"total": 476, "additions": 246, "deletions": 230}, "files": [{"sha": "eb917179cbabf90bc7b96446e49ce5d60d58a28d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1,8 +1,15 @@\n-Mon Oct 13 17:41:26 1997  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n+Tue Oct 14 11:46:14 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (scratchalloc, build_scratch_list, make_scratch_vec,\n+\tscratch_tree_cons): Define as macros for now.\n+\t* call.c, class.c, cvt.c, decl.c, decl2.c, except.c, expr.c, init.c, \n+\tlex.c, method.c, parse.y, pt.c, rtti.c, search.c, tree.c, typeck.c,\n+\ttypeck2.c: Use them and the expression_obstack variants.\n \n- \t* decl.c (store_return_init): Allow classes with explicit ctors to\n-\tbe used with the named return values extension.\n+Mon Oct 13 17:41:26 1997  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n \n+\t* decl.c (store_return_init): Allow classes with explicit ctors to\n+ \tbe used with the named return values extension.\n \n Fri Oct 10 12:21:11 1997  Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "eaa39c69e720fc3a74d3cc370eebad5e29a47410", "filename": "gcc/cp/call.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1267,7 +1267,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \t      if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == FUNCTION_TYPE)\n \t\treturn build_function_call (instance, parms);\n \t      else if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == METHOD_TYPE)\n-\t\treturn build_function_call (instance, tree_cons (NULL_TREE, current_class_ptr, parms));\n+\t\treturn build_function_call (instance, expr_tree_cons (NULL_TREE, current_class_ptr, parms));\n \t    }\n \t}\n       return NULL_TREE;\n@@ -2110,14 +2110,14 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t of the signature pointer?  */\n       constp = TYPE_READONLY (basetype);\n       volatilep = TYPE_VOLATILE (basetype);\n-      parms = tree_cons (NULL_TREE, instance_ptr, parms);\n+      parms = expr_tree_cons (NULL_TREE, instance_ptr, parms);\n     }\n   else if (instance)\n     {\n       /* TREE_READONLY (instance) fails for references.  */\n       constp = TYPE_READONLY (TREE_TYPE (TREE_TYPE (instance_ptr)));\n       volatilep = TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (instance_ptr)));\n-      parms = tree_cons (NULL_TREE, instance_ptr, parms);\n+      parms = expr_tree_cons (NULL_TREE, instance_ptr, parms);\n     }\n   else\n     {\n@@ -2126,18 +2126,18 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  && ! (flags & LOOKUP_HAS_IN_CHARGE))\n \t{\n \t  flags |= LOOKUP_HAS_IN_CHARGE;\n-\t  parms = tree_cons (NULL_TREE, integer_one_node, parms);\n-\t  parmtypes = tree_cons (NULL_TREE, integer_type_node, parmtypes);\n+\t  parms = expr_tree_cons (NULL_TREE, integer_one_node, parms);\n+\t  parmtypes = scratch_tree_cons (NULL_TREE, integer_type_node, parmtypes);\n \t}\n \n       constp = 0;\n       volatilep = 0;\n       instance_ptr = build_int_2 (0, 0);\n       TREE_TYPE (instance_ptr) = build_pointer_type (basetype);\n-      parms = tree_cons (NULL_TREE, instance_ptr, parms);\n+      parms = expr_tree_cons (NULL_TREE, instance_ptr, parms);\n     }\n \n-  parmtypes = tree_cons (NULL_TREE, TREE_TYPE (instance_ptr), parmtypes);\n+  parmtypes = scratch_tree_cons (NULL_TREE, TREE_TYPE (instance_ptr), parmtypes);\n \n   if (last == NULL_TREE)\n     last = parmtypes;\n@@ -2171,10 +2171,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      tree tmplist;\n \t      \n \t      flags |= LOOKUP_HAS_IN_CHARGE;\n-\t      tmplist = tree_cons (NULL_TREE, integer_zero_node,\n+\t      tmplist = expr_tree_cons (NULL_TREE, integer_zero_node,\n \t\t\t\t   TREE_CHAIN (parms));\n \t      TREE_CHAIN (parms) = tmplist;\n-\t      tmplist = tree_cons (NULL_TREE, integer_type_node, TREE_CHAIN (parmtypes));\n+\t      tmplist = scratch_tree_cons (NULL_TREE, integer_type_node, TREE_CHAIN (parmtypes));\n \t      TREE_CHAIN (parmtypes) = tmplist;\n \t    }\n \t  basetype = BINFO_TYPE (tmp);\n@@ -2225,7 +2225,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      else\n \t\tmy_friendly_abort (167);\n \n-\t      friend_parms = tree_cons (NULL_TREE, parm, TREE_CHAIN (parms));\n+\t      friend_parms = expr_tree_cons (NULL_TREE, parm, TREE_CHAIN (parms));\n \n \t      cp->h_len = len;\n \t      cp->harshness = (struct harshness_code *)\n@@ -2275,7 +2275,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n #endif\n \t      ever_seen++;\n \t      if (pass > 0)\n-\t\tfound_fns = tree_cons (NULL_TREE, function, found_fns);\n+\t\tfound_fns = scratch_tree_cons (NULL_TREE, function, found_fns);\n \n \t      /* Not looking for friends here.  */\n \t      if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE\n@@ -2606,7 +2606,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  instance_ptr = convert_pointer_to (basetype, instance_ptr);\n \t  instance = build_indirect_ref (instance_ptr, NULL_PTR);\n \t}\n-      parms = tree_cons (NULL_TREE, instance_ptr,\n+      parms = expr_tree_cons (NULL_TREE, instance_ptr,\n \t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), function, sub_flags));\n     }\n   else\n@@ -2654,7 +2654,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t   || TREE_OPERAND (instance, 0) != instance_ptr)\n \t    instance = build_indirect_ref (instance_ptr, NULL_PTR);\n \t}\n-      parms = tree_cons (NULL_TREE, instance_ptr,\n+      parms = expr_tree_cons (NULL_TREE, instance_ptr,\n \t\t\t convert_arguments (NULL_TREE, TREE_CHAIN (TYPE_ARG_TYPES (fntype)), TREE_CHAIN (parms), function, LOOKUP_NORMAL));\n     }\n \n@@ -2842,7 +2842,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n       if (TREE_CODE (function) == TEMPLATE_DECL)\n \t{\n \t  int ntparms = DECL_NTPARMS (function);\n-\t  tree targs = make_tree_vec (ntparms);\n+\t  tree targs = make_scratch_vec (ntparms);\n \t  int i;\n \n \t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (function),\n@@ -2885,7 +2885,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n \t     passed to calling function.  */\n \t  cp->h_len = parmlength;\n \t  cp->harshness = (struct harshness_code *)\n-\t    oballoc ((parmlength + 1) * sizeof (struct harshness_code));\n+\t    scratchalloc ((parmlength + 1) * sizeof (struct harshness_code));\n \n \t  compute_conversion_costs (function, parms, cp, parmlength);\n \n@@ -3379,7 +3379,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n     }\n \n   len = list_length (argnode);\n-  convs = make_tree_vec (len);\n+  convs = make_scratch_vec (len);\n \n   for (i = 0; i < len; ++i)\n     {\n@@ -3428,7 +3428,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n \tbreak;\n       }\n \n-  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+  cand = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n   cand->convs = convs;\n@@ -3454,7 +3454,7 @@ add_conv_candidate (candidates, fn, obj, arglist)\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (totype));\n   int i, len = list_length (arglist) + 1;\n-  tree convs = make_tree_vec (len);\n+  tree convs = make_scratch_vec (len);\n   tree parmnode = parmlist;\n   tree argnode = arglist;\n   int viable = 1;\n@@ -3505,7 +3505,7 @@ add_conv_candidate (candidates, fn, obj, arglist)\n \tbreak;\n       }\n \n-  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+  cand = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n   cand->convs = convs;\n@@ -3534,7 +3534,7 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n   types[0] = type1;\n   types[1] = type2;\n \n-  convs = make_tree_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n+  convs = make_scratch_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n \n   for (i = 0; i < 2; ++i)\n     {\n@@ -3565,7 +3565,7 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n \tviable = 0;\n     }      \n \n-  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+  cand = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n \n   cand->fn = fnname;\n   cand->convs = convs;\n@@ -4074,10 +4074,10 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t  if (code == COND_EXPR)\n \t    {\n \t      if (real_lvalue_p (args[i]))\n-\t\ttypes[i] = tree_cons\n+\t\ttypes[i] = scratch_tree_cons\n \t\t  (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n \n-\t      types[i] = tree_cons\n+\t      types[i] = scratch_tree_cons\n \t\t(NULL_TREE, TYPE_MAIN_VARIANT (argtypes[i]), types[i]);\n \t    }\n \t\t\n@@ -4095,37 +4095,37 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t\tcontinue;\n \n \t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n \n \t      type = non_reference (type);\n \t      if (i != 0 || ! ref1)\n \t\t{\n \t\t  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \t\t  if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\t    types[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n \t\t  if (INTEGRAL_TYPE_P (type))\n \t\t    type = type_promotes_to (type);\n \t\t}\n \n \t      if (! value_member (type, types[i]))\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n \t    }\n \t}\n       else\n \t{\n \t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n-\t    types[i] = tree_cons\n+\t    types[i] = scratch_tree_cons\n \t      (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n \t  type = non_reference (argtypes[i]);\n \t  if (i != 0 || ! ref1)\n \t    {\n \t      type = TYPE_MAIN_VARIANT (type_decays_to (type));\n \t      if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\ttypes[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n \t      if (INTEGRAL_TYPE_P (type))\n \t\ttype = type_promotes_to (type);\n \t    }\n-\t  types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t  types[i] = scratch_tree_cons (NULL_TREE, type, types[i]);\n \t}\n     }\n \n@@ -4161,7 +4161,7 @@ add_template_candidate (candidates, tmpl, explicit_targs,\n      int flags;\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n-  tree targs = make_tree_vec (ntparms);\n+  tree targs = make_scratch_vec (ntparms);\n   struct z_candidate *cand;\n   int i;\n   tree fn;\n@@ -4188,7 +4188,7 @@ add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n      tree tmpl, obj, arglist, return_type;\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n-  tree targs = make_tree_vec (ntparms);\n+  tree targs = make_scratch_vec (ntparms);\n   struct z_candidate *cand;\n   int i;\n   tree fn;\n@@ -4306,10 +4306,10 @@ build_user_type_conversion_1 (totype, expr, flags)\n     {\n       tree t = build_int_2 (0, 0);\n       TREE_TYPE (t) = build_pointer_type (totype);\n-      args = build_tree_list (NULL_TREE, expr);\n+      args = build_scratch_list (NULL_TREE, expr);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (totype))\n-\targs = tree_cons (NULL_TREE, integer_one_node, args);\n-      args = tree_cons (NULL_TREE, t, args);\n+\targs = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n+      args = scratch_tree_cons (NULL_TREE, t, args);\n \n       ctors = TREE_VALUE (ctors);\n     }\n@@ -4320,7 +4320,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \n       if (TREE_CODE (ctors) == TEMPLATE_DECL) \n \t{\n-\t  templates = decl_tree_cons (NULL_TREE, ctors, templates);\n+\t  templates = scratch_tree_cons (NULL_TREE, ctors, templates);\n \t  candidates = \n \t    add_template_candidate (candidates, ctors,\n \t\t\t\t    NULL_TREE, args, NULL_TREE, flags);\n@@ -4337,7 +4337,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     }\n \n   if (convs)\n-    args = build_tree_list (NULL_TREE, build_this (expr));\n+    args = build_scratch_list (NULL_TREE, build_this (expr));\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n@@ -4362,7 +4362,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t  {\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t      {\n-\t\ttemplates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t\ttemplates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = \n \t\t  add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  args, totype, flags);\n@@ -4507,7 +4507,7 @@ build_new_function_call (fn, args, obj)\n \t{\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n-\t      templates = decl_tree_cons (NULL_TREE, t, templates);\n+\t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n \t\t(candidates, t, explicit_targs, args, NULL_TREE,\n \t\t LOOKUP_NORMAL);  \n@@ -4570,13 +4570,13 @@ build_object_call (obj, args)\n   if (fns)\n     {\n       tree fn = TREE_VALUE (fns);\n-      mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n+      mem_args = scratch_tree_cons (NULL_TREE, build_this (obj), args);\n \n       for (; fn; fn = DECL_CHAIN (fn))\n \t{\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n-\t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t      templates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  mem_args, NULL_TREE, \n@@ -4604,7 +4604,7 @@ build_object_call (obj, args)\n \t  {\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL) \n \t      {\n-\t\ttemplates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t\ttemplates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = add_template_conv_candidate (candidates,\n \t\t\t\t\t\t\t  fn,\n \t\t\t\t\t\t\t  obj,\n@@ -4718,7 +4718,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       {\n \ttree rval;\n \n-\targlist = tree_cons (NULL_TREE, arg2, arg3);\n+\targlist = scratch_tree_cons (NULL_TREE, arg2, arg3);\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_new_function_call\n \t    (lookup_name_nonclass (fnname), arglist, NULL_TREE);\n@@ -4746,9 +4746,9 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_new_function_call\n \t    (lookup_name_nonclass (fnname),\n-\t     build_tree_list (NULL_TREE, arg1), NULL_TREE);\n+\t     build_scratch_list (NULL_TREE, arg1), NULL_TREE);\n \n-\targlist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n+\targlist = scratch_tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n \n \targ1 = TREE_TYPE (arg1);\n \n@@ -4814,20 +4814,20 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   /* + Koenig lookup */\n \n   if (arg2 && arg3)\n-    arglist = tree_cons (NULL_TREE, arg1, tree_cons\n-\t\t      (NULL_TREE, arg2, build_tree_list (NULL_TREE, arg3)));\n+    arglist = scratch_tree_cons (NULL_TREE, arg1, scratch_tree_cons\n+\t\t      (NULL_TREE, arg2, build_scratch_list (NULL_TREE, arg3)));\n   else if (arg2)\n-    arglist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n+    arglist = scratch_tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n   else\n-    arglist = build_tree_list (NULL_TREE, arg1);\n+    arglist = build_scratch_list (NULL_TREE, arg1);\n \n   if (fns && TREE_CODE (fns) == TREE_LIST)\n     fns = TREE_VALUE (fns);\n   for (; fns; fns = DECL_CHAIN (fns))\n     {\n       if (TREE_CODE (fns) == TEMPLATE_DECL)\n \t{\n-\t  templates = decl_tree_cons (NULL_TREE, fns, templates);\n+\t  templates = scratch_tree_cons (NULL_TREE, fns, templates);\n \t  candidates \n \t    = add_template_candidate (candidates, fns, NULL_TREE,\n \t\t\t\t      arglist, TREE_TYPE (fnname),\n@@ -4845,7 +4845,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   if (fns)\n     {\n       tree fn = TREE_VALUE (fns);\n-      mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n+      mem_arglist = scratch_tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n       for (; fn; fn = DECL_CHAIN (fn))\n \t{\n \t  tree this_arglist;\n@@ -4858,7 +4858,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n \t      /* A member template. */\n-\t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n+\t      templates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  this_arglist,  TREE_TYPE\n@@ -5134,10 +5134,10 @@ convert_like (convs, expr)\n \t    tree t = build_int_2 (0, 0);\n \t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (fn));\n \n-\t    args = build_tree_list (NULL_TREE, expr);\n+\t    args = build_scratch_list (NULL_TREE, expr);\n \t    if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n-\t      args = tree_cons (NULL_TREE, integer_one_node, args);\n-\t    args = tree_cons (NULL_TREE, t, args);\n+\t      args = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n+\t    args = scratch_tree_cons (NULL_TREE, t, args);\n \t  }\n \telse\n \t  args = build_this (expr);\n@@ -5232,19 +5232,19 @@ build_over_call (fn, convs, args, flags)\n   int is_method = 0;\n \n   if (args && TREE_CODE (args) != TREE_LIST)\n-    args = build_tree_list (NULL_TREE, args);\n+    args = build_scratch_list (NULL_TREE, args);\n   arg = args;\n \n   /* The implicit parameters to a constructor are not considered by overload\n      resolution, and must be of the proper type.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n-      converted_args = tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n+      converted_args = expr_tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n       arg = TREE_CHAIN (arg);\n       parm = TREE_CHAIN (parm);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n \t{\n-\t  converted_args = tree_cons\n+\t  converted_args = expr_tree_cons\n \t    (NULL_TREE, TREE_VALUE (arg), converted_args);\n \t  arg = TREE_CHAIN (arg);\n \t  parm = TREE_CHAIN (parm);\n@@ -5267,7 +5267,7 @@ build_over_call (fn, convs, args, flags)\n \t  cp_pedwarn (\"passing `%T' as `this' argument of `%#D' discards %s\",\n \t\t      TREE_TYPE (argtype), fn, p);\n \t}\n-      converted_args = tree_cons\n+      converted_args = expr_tree_cons\n \t(NULL_TREE, convert_force (TREE_VALUE (parm), TREE_VALUE (arg), CONV_C_CAST),\n \t converted_args);\n       parm = TREE_CHAIN (parm);\n@@ -5311,7 +5311,7 @@ build_over_call (fn, convs, args, flags)\n \t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \tval = default_conversion (val);\n #endif\n-      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+      converted_args = expr_tree_cons (NULL_TREE, val, converted_args);\n     }\n \n   /* Default arguments */\n@@ -5324,7 +5324,7 @@ build_over_call (fn, convs, args, flags)\n \t   not in tsubst.  */\n \targ = tsubst_expr (arg, DECL_TI_ARGS (fn),\n \t\t\t   TREE_VEC_LENGTH (DECL_TI_ARGS (fn)), NULL_TREE);\n-      converted_args = tree_cons\n+      converted_args = expr_tree_cons\n \t(NULL_TREE, convert_default_arg (TREE_VALUE (parm), arg),\n \t converted_args);\n     }\n@@ -5347,7 +5347,7 @@ build_over_call (fn, convs, args, flags)\n \t/* Convert `short' and `char' to full-size `int'.  */\n \tval = default_conversion (val);\n \n-      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+      converted_args = expr_tree_cons (NULL_TREE, val, converted_args);\n     }\n \n   converted_args = nreverse (converted_args);\n@@ -5551,9 +5551,9 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  && ! (flags & LOOKUP_HAS_IN_CHARGE))\n \t{\n \t  flags |= LOOKUP_HAS_IN_CHARGE;\n-\t  args = tree_cons (NULL_TREE, integer_one_node, args);\n+\t  args = scratch_tree_cons (NULL_TREE, integer_one_node, args);\n \t}\n-      mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n+      mem_args = scratch_tree_cons (NULL_TREE, instance_ptr, args);\n       for (; t; t = DECL_CHAIN (t))\n \t{\n \t  tree this_arglist;\n@@ -5571,7 +5571,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      /* A member template. */\n-\t      templates = decl_tree_cons (NULL_TREE, t, templates);\n+\t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n \t      candidates = \n \t\tadd_template_candidate (candidates, t, explicit_targs,\n \t\t\t\t\tthis_arglist,"}, {"sha": "da5fcd3b3abed77ff72fc1c7605741cc6f7add65", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -270,6 +270,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n     {\n       tree reverse_path = NULL_TREE;\n \n+      push_expression_obstack ();\n       while (path)\n \t{\n \t  tree r = copy_node (path);\n@@ -278,6 +279,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t  path = BINFO_INHERITANCE_CHAIN (path);\n \t}\n       path = reverse_path;\n+      pop_obstacks ();\n     }\n \n   basetype = BINFO_TYPE (path);\n@@ -447,9 +449,9 @@ build_vtable_entry (delta, pfn)\n   else\n     {\n       extern int flag_huge_objects;\n-      tree elems = tree_cons (NULL_TREE, delta,\n-\t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t build_tree_list (NULL_TREE, pfn)));\n+      tree elems = expr_tree_cons (NULL_TREE, delta,\n+\t\t\t      expr_tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t build_expr_list (NULL_TREE, pfn)));\n       tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n       /* DELTA is constructed by `size_int', which means it may be an\n@@ -3324,7 +3326,7 @@ finish_struct_1 (t, warn_anon)\n \t    fdecl = lookup_fnfields (binfo, sname, 0);\n \n \t  if (fdecl)\n-\t    access_decls = tree_cons (access, fdecl, access_decls);\n+\t    access_decls = scratch_tree_cons (access, fdecl, access_decls);\n \t  else\n \t    cp_error_at (\"no members matching `%D' in `%#T'\", x, ctype);\n \t  continue;\n@@ -5100,7 +5102,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\tif (TREE_CODE (elem) == TEMPLATE_DECL)\n \t\t  {\n \t\t    int n = DECL_NTPARMS (elem);\n-\t\t    tree t = make_tree_vec (n);\n+\t\t    tree t = make_scratch_vec (n);\n \t\t    int i, d = 0;\n \t\t    i = type_unification\n \t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), "}, {"sha": "3cb83df2580cc0b21f5e57fb521a616bf9005031", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -2471,6 +2471,10 @@ extern int cp_tree_equal\t\t\tPROTO((tree, tree));\n extern int can_free\t\t\t\tPROTO((struct obstack *, tree));\n extern tree mapcar\t\t\t\tPROTO((tree, tree (*) (tree)));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n+#define scratchalloc expralloc\n+#define scratch_tree_cons expr_tree_cons\n+#define build_scratch_list build_expr_list\n+#define make_scratch_vec make_temp_vec\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "299649280055997126d30ac20f4af55ace03b0fd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -579,7 +579,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  && ! CLASSTYPE_ABSTRACT_VIRTUALS (type)\n \t  && (rval = build_method_call\n \t      (NULL_TREE, ctor_identifier,\n-\t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (type),\n+\t       build_expr_list (NULL_TREE, expr), TYPE_BINFO (type),\n \t       LOOKUP_NO_CONVERSION|LOOKUP_SPECULATIVELY\n \t       | LOOKUP_ONLYCONVERTING)))\n \t{\n@@ -589,7 +589,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    {\n \t      tree t = get_temp_name (type, toplevel_bindings_p ());\n \t      init = build_method_call (t, ctor_identifier,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n+\t\t\t\t\tbuild_expr_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),\n \t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n \t\t\t\t\t| LOOKUP_ONLYCONVERTING);\n@@ -604,7 +604,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  else\n \t    {\n \t      init = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n+\t\t\t\t\tbuild_expr_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),\n \t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n \t\t\t\t\t|LOOKUP_ONLYCONVERTING);\n@@ -711,18 +711,18 @@ convert_to_aggr (type, expr, msgp, protect)\n   can_be_private = 0;\n   can_be_protected = IDENTIFIER_CLASS_VALUE (name) || name == current_class_name;\n \n-  parmlist = build_tree_list (NULL_TREE, expr);\n-  parmtypes = tree_cons (NULL_TREE, TREE_TYPE (expr), void_list_node);\n+  parmlist = build_expr_list (NULL_TREE, expr);\n+  parmtypes = scratch_tree_cons (NULL_TREE, TREE_TYPE (expr), void_list_node);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n     {\n-      parmtypes = tree_cons (NULL_TREE, integer_type_node, parmtypes);\n-      parmlist = tree_cons (NULL_TREE, integer_one_node, parmlist);\n+      parmtypes = expr_tree_cons (NULL_TREE, integer_type_node, parmtypes);\n+      parmlist = scratch_tree_cons (NULL_TREE, integer_one_node, parmlist);\n     }\n \n   /* The type of the first argument will be filled in inside the loop.  */\n-  parmlist = tree_cons (NULL_TREE, integer_zero_node, parmlist);\n-  parmtypes = tree_cons (NULL_TREE, build_pointer_type (basetype), parmtypes);\n+  parmlist = expr_tree_cons (NULL_TREE, integer_zero_node, parmlist);\n+  parmtypes = scratch_tree_cons (NULL_TREE, build_pointer_type (basetype), parmtypes);\n \n   /* No exact conversion was found.  See if an approximate\n      one will do.  */\n@@ -1119,7 +1119,7 @@ ocp_convert (type, expr, convtype, flags)\n \t    }\n \t  if (ctor)\n \t    ctor = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t      build_tree_list (NULL_TREE, ctor),\n+\t\t\t\t      build_expr_list (NULL_TREE, ctor),\n \t\t\t\t      TYPE_BINFO (type), flags);\n \t  if (ctor)\n \t    return build_cplus_new (type, ctor);\n@@ -1139,7 +1139,7 @@ ocp_convert (type, expr, convtype, flags)\n \n \t  if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n \t    ctor = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t      build_tree_list (NULL_TREE, e),\n+\t\t\t\t      build_expr_list (NULL_TREE, e),\n \t\t\t\t      TYPE_BINFO (type),\n \t\t\t\t      (flags & LOOKUP_NORMAL)\n \t\t\t\t      | LOOKUP_SPECULATIVELY"}, {"sha": "ad80b45cabf946d3a35587e325ebeb9d8f3f8651", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -7045,7 +7045,7 @@ expand_static_init (decl, init)\n \t  end_anon_func ();\n \t  mark_addressable (cleanup);\n \t  cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n-\t  fcall = build_function_call (Atexit, tree_cons (NULL_TREE, cleanup, NULL_TREE));\n+\t  fcall = build_function_call (Atexit, expr_tree_cons (NULL_TREE, cleanup, NULL_TREE));\n \t  expand_expr_stmt (fcall);\n \t}\n \n@@ -11318,7 +11318,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t  && ! CLASSTYPE_GOT_SEMICOLON (restype))\n \t{\n \t  cp_error (\"semicolon missing after declaration of `%#T'\", restype);\n-\t  shadow_tag (build_tree_list (NULL_TREE, restype));\n+\t  shadow_tag (build_expr_list (NULL_TREE, restype));\n \t  CLASSTYPE_GOT_SEMICOLON (restype) = 1;\n \t  if (TREE_CODE (fntype) == FUNCTION_TYPE)\n \t    fntype = build_function_type (integer_type_node,\n@@ -12013,7 +12013,7 @@ finish_function (lineno, call_poplevel, nested)\n \t\t\t  expand_expr_stmt\n \t\t\t    (build_scoped_method_call\n \t\t\t     (current_class_ref, vb, dtor_identifier,\n-\t\t\t      build_tree_list (NULL_TREE, integer_zero_node)));\n+\t\t\t      build_expr_list (NULL_TREE, integer_zero_node)));\n \t\t\t}\n \t\t      vbases = TREE_CHAIN (vbases);\n \t\t    }\n@@ -12038,8 +12038,8 @@ finish_function (lineno, call_poplevel, nested)\n \t\t\t\t\t\t\t       error_mark_node),\n \t\t\t\t\t\t       NULL_PTR),\n \t\t\t\t   ansi_opname[(int) DELETE_EXPR],\n-\t\t\t\t   tree_cons (NULL_TREE, current_class_ptr,\n-\t\t\t\t\t      build_tree_list (NULL_TREE, virtual_size)),\n+\t\t\t\t   expr_tree_cons (NULL_TREE, current_class_ptr,\n+\t\t\t\t\t      build_expr_list (NULL_TREE, virtual_size)),\n \t\t\t\t   NULL_TREE, LOOKUP_NORMAL);\n \t  else if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n \t    exprstmt = build_x_delete (ptr_type_node, current_class_ptr, 0,\n@@ -12675,8 +12675,8 @@ maybe_build_cleanup_1 (decl, auto_delete)\n \n       if (TYPE_USES_VIRTUAL_BASECLASSES (type)\n \t  && ! TYPE_HAS_DESTRUCTOR (type))\n-\trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n-\t\t\t\t\t       build_tree_list (NULL_TREE, build_vbase_delete (type, decl))));\n+\trval = build_compound_expr (expr_tree_cons (NULL_TREE, rval,\n+\t\t\t\t\t       build_expr_list (NULL_TREE, build_vbase_delete (type, decl))));\n \n       if (TREE_CODE (decl) != PARM_DECL)\n \tresume_momentary (temp);"}, {"sha": "c9c7f7c0fb2b5e8521c5cb879c7b9af6975381fe", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1446,7 +1446,7 @@ check_classfn (ctype, function)\n \t\t\t/* This function might be an instantiation\n \t\t\t   or specialization of fndecl.  */\n \t\t\ttemplates = \n-\t\t\t  tree_cons (NULL_TREE, fndecl, templates);\n+\t\t\t  scratch_tree_cons (NULL_TREE, fndecl, templates);\n \t\t    }\n #endif\n \t\t  fndecl = DECL_CHAIN (fndecl);\n@@ -1462,7 +1462,7 @@ check_classfn (ctype, function)\n \t       the names don't match, there is some specialization\n \t       occurring.  */\n \t    templates = \n-\t      tree_cons (NULL_TREE, fndecl, templates);\n+\t      scratch_tree_cons (NULL_TREE, fndecl, templates);\n \t}\n     }\n \n@@ -2217,7 +2217,7 @@ finish_anon_union (anon_union_decl)\n       DECL_INITIAL (decl) = NULL_TREE;\n       /* If there's a cleanup to do, it belongs in the\n \t TREE_PURPOSE of the following TREE_LIST.  */\n-      elems = tree_cons (NULL_TREE, decl, elems);\n+      elems = scratch_tree_cons (NULL_TREE, decl, elems);\n       TREE_TYPE (elems) = type;\n     }\n   if (static_p)\n@@ -3598,7 +3598,7 @@ build_expr_from_tree (t)\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n \t  chain = build_expr_from_tree (chain);\n-\treturn tree_cons (purpose, value, chain);\n+\treturn expr_tree_cons (purpose, value, chain);\n       }\n \n     case COMPONENT_REF:\n@@ -3645,7 +3645,7 @@ reparse_decl_as_expr (type, decl)\n {\n   decl = build_expr_from_tree (decl);\n   if (type)\n-    return build_functional_cast (type, build_tree_list (NULL_TREE, decl));\n+    return build_functional_cast (type, build_expr_list (NULL_TREE, decl));\n   else\n     return decl;\n }"}, {"sha": "ef4b6e015f858a5f880ba0177fae7997bd51ac35", "filename": "gcc/cp/except.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -487,11 +487,11 @@ expand_start_catch_block (declspecs, declarator)\n \tinit_type = build_reference_type (init_type);\n \n       exp = saved_throw_value;\n-      exp = tree_cons (NULL_TREE,\n+      exp = expr_tree_cons (NULL_TREE,\n \t\t       build_eh_type_type (TREE_TYPE (decl)),\n-\t\t       tree_cons (NULL_TREE,\n+\t\t       expr_tree_cons (NULL_TREE,\n \t\t\t\t  saved_throw_type,\n-\t\t\t\t  tree_cons (NULL_TREE, exp, NULL_TREE)));\n+\t\t\t\t  expr_tree_cons (NULL_TREE, exp, NULL_TREE)));\n       exp = build_function_call (CatchMatch, exp);\n       call_rtx = expand_call (exp, NULL_RTX, 0);\n       assemble_external (TREE_OPERAND (CatchMatch, 0));\n@@ -618,7 +618,7 @@ do_unwind (inner_throw_label)\n   rtx temp;\n \n   /* Call to  __builtin_return_address. */\n-  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n   /* In the return, the new pc is pc+8, as the value coming in is\n@@ -671,14 +671,14 @@ do_unwind (inner_throw_label)\n #if 0\n   /* I would like to do this here, but the move below doesn't seem to work.  */\n   /* Call to  __builtin_return_address.  */\n-  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n \n   emit_move_insn (next_pc, inner_throw_label);\n   /* So, for now, just pass throw label to stack unwinder.  */\n #endif\n-  params = tree_cons (NULL_TREE, make_tree (ptr_type_node,\n+  params = expr_tree_cons (NULL_TREE, make_tree (ptr_type_node,\n \t\t\t\t\t    inner_throw_label), NULL_TREE);\n   \n   do_function_call (Unwind, params, NULL_TREE);\n@@ -752,7 +752,7 @@ expand_builtin_throw ()\n \n   /* search for an exception handler for the saved_pc */\n   handler = do_function_call (FirstExceptionMatch,\n-\t\t\t      tree_cons (NULL_TREE, saved_pc,\n+\t\t\t      expr_tree_cons (NULL_TREE, saved_pc,\n \t\t\t\t\t NULL_TREE),\n \t\t\t      ptr_type_node);\n   assemble_external (TREE_OPERAND (FirstExceptionMatch, 0));\n@@ -800,7 +800,7 @@ expand_builtin_throw ()\n   emit_move_insn (next_pc,\n \t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));\n #else\n-  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n #endif\n@@ -969,11 +969,11 @@ expand_end_eh_spec (raises)\n \t{\n \t  /* check TREE_VALUE (raises) here */\n \t  exp = saved_throw_value;\n-\t  exp = tree_cons (NULL_TREE,\n+\t  exp = expr_tree_cons (NULL_TREE,\n \t\t\t   build_eh_type_type (match_type),\n-\t\t\t   tree_cons (NULL_TREE,\n+\t\t\t   expr_tree_cons (NULL_TREE,\n \t\t\t\t      saved_throw_type,\n-\t\t\t\t      tree_cons (NULL_TREE, exp, NULL_TREE)));\n+\t\t\t\t      expr_tree_cons (NULL_TREE, exp, NULL_TREE)));\n \t  exp = build_function_call (CatchMatch, exp);\n \t  assemble_external (TREE_OPERAND (CatchMatch, 0));\n \n@@ -1137,7 +1137,7 @@ expand_throw (exp)\n \n \t  /* Make a copy of the thrown object.  WP 15.1.5  */\n \t  exp = build_new (NULL_TREE, TREE_TYPE (exp),\n-\t\t\t   build_tree_list (NULL_TREE, exp),\n+\t\t\t   build_expr_list (NULL_TREE, exp),\n \t\t\t   0);\n \n \t  if (exp == error_mark_node)"}, {"sha": "2162b0d7cf0979c904debbd2acfd03744341b327", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -112,7 +112,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t       parameter value.  */\n \t    mark_addressable (slot);\n \t    if (TREE_PERMANENT (args))\n-\t      args = tree_cons (0, build1 (ADDR_EXPR, type, slot),\n+\t      args = expr_tree_cons (0, build1 (ADDR_EXPR, type, slot),\n \t\t\t\tTREE_CHAIN (args));\n \t    else\n \t      TREE_VALUE (args) = build1 (ADDR_EXPR, type, slot);"}, {"sha": "985fae8f3353d939d7f351f5cf5a8925f11f6e2d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -173,7 +173,7 @@ perform_member_init (member, name, init, explicit)\n       /* Since `init' is already a TREE_LIST on the current_member_init_list,\n \t only build it into one if we aren't already a list.  */\n       if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n-\tinit = build_tree_list (NULL_TREE, init);\n+\tinit = build_expr_list (NULL_TREE, init);\n \n       decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n \n@@ -489,7 +489,7 @@ build_partial_cleanup_for (binfo)\n {\n   return build_scoped_method_call\n     (current_class_ref, binfo, dtor_identifier,\n-     build_tree_list (NULL_TREE, integer_zero_node));\n+     build_expr_list (NULL_TREE, integer_zero_node));\n }\n \n /* Perform whatever initializations have yet to be done on the base\n@@ -1287,14 +1287,14 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n       return;\n     }\n   else\n-    parms = build_tree_list (NULL_TREE, init);\n+    parms = build_expr_list (NULL_TREE, init);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       if (true_exp == exp)\n-\tparms = tree_cons (NULL_TREE, integer_one_node, parms);\n+\tparms = expr_tree_cons (NULL_TREE, integer_one_node, parms);\n       else\n-\tparms = tree_cons (NULL_TREE, integer_zero_node, parms);\n+\tparms = expr_tree_cons (NULL_TREE, integer_zero_node, parms);\n       flags |= LOOKUP_HAS_IN_CHARGE;\n     }\n \n@@ -1549,7 +1549,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t{\n \t\t  /* See if there is a constructor for``type'' that takes a\n \t\t     ``ttype''-typed object.  */\n-\t\t  tree parms = build_tree_list (NULL_TREE, init);\n+\t\t  tree parms = build_expr_list (NULL_TREE, init);\n \t\t  tree as_cons = NULL_TREE;\n \t\t  if (TYPE_HAS_CONSTRUCTOR (type))\n \t\t    as_cons = build_method_call (exp, ctor_identifier,\n@@ -2508,7 +2508,7 @@ build_new (placement, decl, init, use_global_new)\n     {\n       rval = build_builtin_call (build_pointer_type (true_type),\n \t\t\t\t has_array ? BIVN : BIN,\n-\t\t\t\t build_tree_list (NULL_TREE, size));\n+\t\t\t\t build_expr_list (NULL_TREE, size));\n       TREE_CALLS_NEW (rval) = 1;\n     }\n \n@@ -2538,8 +2538,8 @@ build_new (placement, decl, init, use_global_new)\n       rval = cp_convert (build_pointer_type (true_type), rval);\n       TREE_CALLS_NEW (rval) = 1;\n       TREE_SIDE_EFFECTS (rval) = 1;\n-      rval = build_compound_expr (tree_cons (NULL_TREE, exp1,\n-\t\t\t\t\t     build_tree_list (NULL_TREE, rval)));\n+      rval = build_compound_expr (expr_tree_cons (NULL_TREE, exp1,\n+\t\t\t\t\t     build_expr_list (NULL_TREE, rval)));\n     }\n \n   if (rval == error_mark_node)\n@@ -2590,7 +2590,7 @@ build_new (placement, decl, init, use_global_new)\n \n \t  if (rval && TYPE_USES_VIRTUAL_BASECLASSES (true_type))\n \t    {\n-\t      init = tree_cons (NULL_TREE, integer_one_node, init);\n+\t      init = expr_tree_cons (NULL_TREE, integer_one_node, init);\n \t      flags |= LOOKUP_HAS_IN_CHARGE;\n \t    }\n \n@@ -2717,7 +2717,7 @@ build_new (placement, decl, init, use_global_new)\n \n   if (pending_sizes)\n     rval = build_compound_expr (chainon (pending_sizes,\n-\t\t\t\t\t build_tree_list (NULL_TREE, rval)));\n+\t\t\t\t\t build_expr_list (NULL_TREE, rval)));\n \n   return rval;\n }\n@@ -2785,7 +2785,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \t\t\t\t\t\t   1));\n       /* This is the real size */\n       virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n-      body = build_tree_list (NULL_TREE,\n+      body = build_expr_list (NULL_TREE,\n \t\t\t      build_x_delete (ptype, base_tbd,\n \t\t\t\t\t      2 | use_global_delete,\n \t\t\t\t\t      virtual_size));\n@@ -2797,24 +2797,24 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n   else\n     body = NULL_TREE;\n \n-  body = tree_cons (NULL_TREE,\n+  body = expr_tree_cons (NULL_TREE,\n \t\t    build_delete (ptype, tbase, auto_delete,\n \t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n \t\t    body);\n \n-  body = tree_cons (NULL_TREE,\n+  body = expr_tree_cons (NULL_TREE,\n \t\t    build_modify_expr (tbase, NOP_EXPR, build (MINUS_EXPR, ptype, tbase, size_exp)),\n \t\t    body);\n \n-  body = tree_cons (NULL_TREE,\n+  body = expr_tree_cons (NULL_TREE,\n \t\t    build (EXIT_EXPR, void_type_node,\n \t\t\t   build (EQ_EXPR, boolean_type_node, base, tbase)),\n \t\t    body);\n \n   loop = build (LOOP_EXPR, void_type_node, build_compound_expr (body));\n \n-  loop = tree_cons (NULL_TREE, tbase_init,\n-\t\t    tree_cons (NULL_TREE, loop, NULL_TREE));\n+  loop = expr_tree_cons (NULL_TREE, tbase_init,\n+\t\t    expr_tree_cons (NULL_TREE, loop, NULL_TREE));\n   loop = build_compound_expr (loop);\n \n  no_destructor:\n@@ -2855,8 +2855,8 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \n   if (loop && deallocate_expr != integer_zero_node)\n     {\n-      body = tree_cons (NULL_TREE, loop,\n-\t\t\ttree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n+      body = expr_tree_cons (NULL_TREE, loop,\n+\t\t\texpr_tree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n       body = build_compound_expr (body);\n     }\n   else\n@@ -3158,7 +3158,7 @@ build_x_delete (type, addr, which_delete, virtual_size)\n     rval = build_opfncall (code, LOOKUP_NORMAL, addr, virtual_size, NULL_TREE);\n   else\n     rval = build_builtin_call (void_type_node, use_vec_delete ? BIVD : BID,\n-\t\t\t       build_tree_list (NULL_TREE, addr));\n+\t\t\t       build_expr_list (NULL_TREE, addr));\n   return rval;\n }\n \n@@ -3209,7 +3209,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t{\n \t  /* Call the builtin operator delete.  */\n \t  return build_builtin_call (void_type_node, BID,\n-\t\t\t\t     build_tree_list (NULL_TREE, addr));\n+\t\t\t\t     build_expr_list (NULL_TREE, addr));\n \t}\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n@@ -3267,7 +3267,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       /* Call the builtin operator delete.  */\n       return build_builtin_call (void_type_node, BID,\n-\t\t\t\t build_tree_list (NULL_TREE, addr));\n+\t\t\t\t build_expr_list (NULL_TREE, addr));\n     }\n \n   /* Below, we will reverse the order in which these calls are made.\n@@ -3284,7 +3284,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  tree cond = fold (build (BIT_AND_EXPR, integer_type_node,\n \t\t\t\t   auto_delete, integer_one_node));\n \t  tree call = build_builtin_call\n-\t    (void_type_node, BID, build_tree_list (NULL_TREE, addr));\n+\t    (void_type_node, BID, build_expr_list (NULL_TREE, addr));\n \n \t  cond = fold (build (COND_EXPR, void_type_node, cond,\n \t\t\t      call, void_zero_node));\n@@ -3298,7 +3298,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \tpassed_auto_delete = auto_delete;\n \n       expr = build_method_call\n-\t(ref, dtor_identifier, build_tree_list (NULL_TREE, passed_auto_delete),\n+\t(ref, dtor_identifier, build_expr_list (NULL_TREE, passed_auto_delete),\n \t NULL_TREE, flags);\n \n       if (do_delete)\n@@ -3337,14 +3337,14 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  cond = build (COND_EXPR, void_type_node,\n \t\t\tbuild (BIT_AND_EXPR, integer_type_node, auto_delete, integer_one_node),\n \t\t\tbuild_builtin_call (void_type_node, BID,\n-\t\t\t\t\t    build_tree_list (NULL_TREE, addr)),\n+\t\t\t\t\t    build_expr_list (NULL_TREE, addr)),\n \t\t\tvoid_zero_node);\n \t}\n       else\n \tcond = NULL_TREE;\n \n       if (cond)\n-\texprstmt = build_tree_list (NULL_TREE, cond);\n+\texprstmt = build_expr_list (NULL_TREE, cond);\n \n       if (base_binfo\n \t  && ! TREE_VIA_VIRTUAL (base_binfo)\n@@ -3359,8 +3359,8 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n \t  expr = build_scoped_method_call\n \t    (ref, base_binfo, dtor_identifier,\n-\t     build_tree_list (NULL_TREE, this_auto_delete));\n-\t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n+\t     build_expr_list (NULL_TREE, this_auto_delete));\n+\t  exprstmt = expr_tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n \n       /* Take care of the remaining baseclasses.  */\n@@ -3373,9 +3373,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n \t  expr = build_scoped_method_call\n \t    (ref, base_binfo, dtor_identifier,\n-\t     build_tree_list (NULL_TREE, integer_zero_node));\n+\t     build_expr_list (NULL_TREE, integer_zero_node));\n \n-\t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n+\t  exprstmt = expr_tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n \n       for (member = TYPE_FIELDS (type); member; member = TREE_CHAIN (member))\n@@ -3387,7 +3387,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t      tree this_member = build_component_ref (ref, DECL_NAME (member), NULL_TREE, 0);\n \t      tree this_type = TREE_TYPE (member);\n \t      expr = build_delete (this_type, this_member, integer_two_node, flags, 0);\n-\t      exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n+\t      exprstmt = expr_tree_cons (NULL_TREE, expr, exprstmt);\n \t    }\n \t}\n \n@@ -3414,7 +3414,7 @@ build_vbase_delete (type, decl)\n     {\n       tree this_addr = convert_force (build_pointer_type (BINFO_TYPE (vbases)),\n \t\t\t\t      addr, 0);\n-      result = tree_cons (NULL_TREE,\n+      result = expr_tree_cons (NULL_TREE,\n \t\t\t  build_delete (TREE_TYPE (this_addr), this_addr,\n \t\t\t\t\tinteger_zero_node,\n \t\t\t\t\tLOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0),"}, {"sha": "9a795353f7d61bec2464759077aa6f7533a7957d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -4461,7 +4461,7 @@ make_lang_type (code)\n     pi[--i] = 0;\n \n   TYPE_LANG_SPECIFIC (t) = (struct lang_type *) pi;\n-  CLASSTYPE_AS_LIST (t) = build_tree_list (NULL_TREE, t);\n+  CLASSTYPE_AS_LIST (t) = build_expr_list (NULL_TREE, t);\n   SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n   CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n   CLASSTYPE_VBASE_SIZE (t) = integer_zero_node;"}, {"sha": "3dc46d0900529a80fd08883e72e990fbcde2108f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1375,7 +1375,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n     case VEC_NEW_EXPR:\n     case NEW_EXPR:\n       {\n-\ttree args = tree_cons (NULL_TREE, xarg2, arg3);\n+\ttree args = expr_tree_cons (NULL_TREE, xarg2, arg3);\n \tfnname = ansi_opname[(int) code];\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_overload_call (fnname, args, flags & LOOKUP_COMPLAIN);\n@@ -1401,7 +1401,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \tfnname = ansi_opname[(int) code];\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_overload_call (fnname,\n-\t\t\t\t      build_tree_list (NULL_TREE, xarg1),\n+\t\t\t\t      build_expr_list (NULL_TREE, xarg1),\n \t\t\t\t      flags & LOOKUP_COMPLAIN);\n \targ1 = TREE_TYPE (xarg1);\n \n@@ -1425,8 +1425,8 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n \t\t\t\t       error_mark_node),\n \t\t\t       NULL_PTR),\n-\t   fnname, tree_cons (NULL_TREE, xarg1,\n-\t\t\t       build_tree_list (NULL_TREE, xarg2)),\n+\t   fnname, expr_tree_cons (NULL_TREE, xarg1,\n+\t\t\t       build_expr_list (NULL_TREE, xarg2)),\n \t   NULL_TREE, flags);\n #if 0\n \t/* This can happen when operator delete is protected.  */\n@@ -1604,25 +1604,25 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n     }\n   else if (code == COND_EXPR)\n     {\n-      parms = tree_cons (NULL_TREE, xarg2, build_tree_list (NULL_TREE, arg3));\n+      parms = expr_tree_cons (NULL_TREE, xarg2, build_expr_list (NULL_TREE, arg3));\n       rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n     }\n   else if (code == METHOD_CALL_EXPR)\n     {\n       /* must be a member function.  */\n-      parms = tree_cons (NULL_TREE, xarg2, arg3);\n+      parms = expr_tree_cons (NULL_TREE, xarg2, arg3);\n       return build_method_call (xarg1, fnname, parms, NULL_TREE,\n \t\t\t\tLOOKUP_NORMAL);\n     }\n   else if (fields1)\n     {\n-      parms = build_tree_list (NULL_TREE, xarg2);\n+      parms = build_expr_list (NULL_TREE, xarg2);\n       rval = build_method_call (xarg1, fnname, parms, NULL_TREE, flags);\n     }\n   else\n     {\n-      parms = tree_cons (NULL_TREE, xarg1,\n-\t\t\t build_tree_list (NULL_TREE, xarg2));\n+      parms = expr_tree_cons (NULL_TREE, xarg1,\n+\t\t\t build_expr_list (NULL_TREE, xarg2));\n       rval = build_overload_call (fnname, parms, flags);\n     }\n \n@@ -1919,9 +1919,9 @@ emit_thunk (thunk_fndecl)\n     t = build_int_2 (delta, -1 * (delta < 0));\n     TREE_TYPE (t) = signed_type (sizetype);\n     t = fold (build (PLUS_EXPR, TREE_TYPE (a), a, t));\n-    t = tree_cons (NULL_TREE, t, NULL_TREE);\n+    t = expr_tree_cons (NULL_TREE, t, NULL_TREE);\n     for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n-      t = tree_cons (NULL_TREE, a, t);\n+      t = expr_tree_cons (NULL_TREE, a, t);\n     t = nreverse (t);\n     t = build_call (function, TREE_TYPE (TREE_TYPE (function)), t);\n     c_expand_return (t);\n@@ -2102,7 +2102,7 @@ do_build_assign_ref (fndecl)\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n \t  p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n-\t\t\t\t build_tree_list (NULL_TREE, p));\n+\t\t\t\t build_expr_list (NULL_TREE, p));\n \t  expand_expr_stmt (p);\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))"}, {"sha": "dfc59aeb771f9713dbf90fdf72f778b1b16e8edd", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1049,20 +1049,20 @@ already_scoped_stmt:\n \n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n-\t\t{ $$ = tree_cons (NULL_TREE, $$, \n-\t\t                  build_tree_list (NULL_TREE, $3)); }\n+\t\t{ $$ = expr_tree_cons (NULL_TREE, $$, \n+\t\t                  build_expr_list (NULL_TREE, $3)); }\n \t| expr_no_commas ',' error\n-\t\t{ $$ = tree_cons (NULL_TREE, $$, \n-\t\t                  build_tree_list (NULL_TREE, error_mark_node)); }\n+\t\t{ $$ = expr_tree_cons (NULL_TREE, $$, \n+\t\t                  build_expr_list (NULL_TREE, error_mark_node)); }\n \t| nontrivial_exprlist ',' expr_no_commas\n-\t\t{ chainon ($$, build_tree_list (NULL_TREE, $3)); }\n+\t\t{ chainon ($$, build_expr_list (NULL_TREE, $3)); }\n \t| nontrivial_exprlist ',' error\n-\t\t{ chainon ($$, build_tree_list (NULL_TREE, error_mark_node)); }\n+\t\t{ chainon ($$, build_expr_list (NULL_TREE, error_mark_node)); }\n \t;\n \n nonnull_exprlist:\n \t  expr_no_commas\n-\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n+\t\t{ $$ = build_expr_list (NULL_TREE, $$); }\n \t| nontrivial_exprlist\n \t;\n \n@@ -2169,16 +2169,16 @@ initlist:\n \t  init\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| initlist ',' init\n-\t\t{ $$ = tree_cons (NULL_TREE, $3, $$); }\n+\t\t{ $$ = expr_tree_cons (NULL_TREE, $3, $$); }\n \t/* These are for labeled elements.  */\n \t| '[' expr_no_commas ']' init\n-\t\t{ $$ = build_tree_list ($2, $4); }\n+\t\t{ $$ = build_expr_list ($2, $4); }\n \t| initlist ',' CASE expr_no_commas ':' init\n-\t\t{ $$ = tree_cons ($4, $6, $$); }\n+\t\t{ $$ = expr_tree_cons ($4, $6, $$); }\n \t| identifier ':' init\n-\t\t{ $$ = build_tree_list ($$, $3); }\n+\t\t{ $$ = build_expr_list ($$, $3); }\n \t| initlist ',' identifier ':' init\n-\t\t{ $$ = tree_cons ($3, $5, $$); }\n+\t\t{ $$ = expr_tree_cons ($3, $5, $$); }\n \t;\n \n fn.defpen:"}, {"sha": "1e342e8fed6f4a8081d137dd3c0b29034ac34d80", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -380,7 +380,7 @@ determine_explicit_specialization (template_id, type, targs_out,\n       if (list_length (TREE_OPERAND (template_id, 1)) > DECL_NTPARMS (fn))\n \tcontinue;\n \n-      targs = make_tree_vec (DECL_NTPARMS (fn));\n+      targs = make_scratch_vec (DECL_NTPARMS (fn));\n \n       /* We allow incomplete unification here, because we are going to\n \t check all the functions. */\n@@ -417,7 +417,7 @@ determine_explicit_specialization (template_id, type, targs_out,\n \t\t}\n \t    }\n \n-\t  matching_fns = tree_cons (fn, targs, matching_fns);\n+\t  matching_fns = scratch_tree_cons (fn, targs, matching_fns);\n \t}\n     }\n \n@@ -3438,6 +3438,7 @@ instantiate_template (tmpl, targ_ptr)\n \t}\n       TREE_VEC_ELT (targ_ptr, i) = copy_to_permanent (t);\n     }\n+  targ_ptr = copy_to_permanent (targ_ptr);\n \n   if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n     targ_ptr = add_to_template_args (DECL_TI_ARGS (tmpl), targ_ptr);\n@@ -3491,10 +3492,10 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type, strict)\n     {\n       /* This is a template conversion operator.  Use the return types\n          as well as the argument types.  */\n-      fn_arg_types = tree_cons (NULL_TREE, \n+      fn_arg_types = scratch_tree_cons (NULL_TREE, \n \t\t\t\tTREE_TYPE (TREE_TYPE (fn)),\n \t\t\t\tfn_arg_types);\n-      decl_arg_types = tree_cons (NULL_TREE,\n+      decl_arg_types = scratch_tree_cons (NULL_TREE,\n \t\t\t\t  return_type,\n \t\t\t\t  decl_arg_types);\n     }\n@@ -3653,7 +3654,7 @@ type_unification_real (tparms, targs, parms, args, nsubsts, subr,\n \t      nsubsts = 0;\n \t      ntparms = DECL_NTPARMS (arg);\n \t      targs = (tree *) alloca (sizeof (tree) * ntparms);\n-\t      parm = tree_cons (NULL_TREE, parm, NULL_TREE);\n+\t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);\n \t      return \n \t\ttype_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n \t\t\t\t  targs,\n@@ -4029,7 +4030,7 @@ get_bindings (fn, decl)\n      tree fn, decl;\n {\n   int ntparms = DECL_NTPARMS (fn);\n-  tree targs = make_tree_vec (ntparms);\n+  tree targs = make_scratch_vec (ntparms);\n   int i;\n \n   i = fn_type_unification (fn, NULL_TREE, targs, "}, {"sha": "e7b83d37726a39a1a5c8160d79c1db988c2afc4e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -269,7 +269,7 @@ build_x_typeid (exp)\n       tree bad = throw_bad_typeid ();\n \n       bad = build_compound_expr\n-\t(tree_cons (NULL_TREE, bad, build_tree_list\n+\t(expr_tree_cons (NULL_TREE, bad, build_expr_list\n \t\t    (NULL_TREE, cp_convert (type, integer_zero_node))));\n       exp = build (COND_EXPR, type, cond, exp, bad);\n     }\n@@ -624,8 +624,8 @@ build_dynamic_cast_1 (type, expr)\n \t    {\n \t      expr1 = throw_bad_cast ();\n \t      expr1 = build_compound_expr\n-\t\t(tree_cons (NULL_TREE, expr1,\n-\t\t\t    build_tree_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n+\t\t(expr_tree_cons (NULL_TREE, expr1,\n+\t\t\t    build_expr_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n \t      TREE_TYPE (expr1) = type;\n \t      result = save_expr (result);\n \t      return build (COND_EXPR, type, result, result, expr1);\n@@ -810,7 +810,7 @@ expand_class_desc (tdecl, type)\n \t   (NULL_TREE, isvir, tree_cons\n \t    (NULL_TREE, access, NULL_TREE)))));\n       TREE_HAS_CONSTRUCTOR (elt) = TREE_CONSTANT (elt) = TREE_STATIC (elt) = 1;\n-      elts = tree_cons (NULL_TREE, elt, elts);\n+      elts = expr_tree_cons (NULL_TREE, elt, elts);\n       base_cnt++;\n     }\n #if 0\n@@ -837,10 +837,10 @@ expand_class_desc (tdecl, type)\n       offset = BINFO_OFFSET (vb);\n       isvir = build_int_2 (1, 0);\n \n-      base_list = tree_cons (NULL_TREE, base, base_list);\n-      isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);\n-      acc_list = tree_cons (NULL_TREE, access, acc_list);\n-      off_list = tree_cons (NULL_TREE, offset, off_list);\n+      base_list = expr_tree_cons (NULL_TREE, base, base_list);\n+      isvir_list = expr_tree_cons (NULL_TREE, isvir, isvir_list);\n+      acc_list = expr_tree_cons (NULL_TREE, access, acc_list);\n+      off_list = expr_tree_cons (NULL_TREE, offset, off_list);\n \n       base_cnt++;\n       vb = TREE_CHAIN (vb);\n@@ -957,7 +957,7 @@ expand_attr_desc (tdecl, type)\n   elems = tree_cons\n     (NULL_TREE, decay_conversion (tdecl), tree_cons\n      (NULL_TREE, decay_conversion (name_string), tree_cons\n-      (NULL_TREE, attrval, tree_cons (NULL_TREE, t, NULL_TREE))));\n+      (NULL_TREE, attrval, expr_tree_cons (NULL_TREE, t, NULL_TREE))));\n \n   fn = get_identifier (\"__rtti_attr\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n@@ -1199,9 +1199,9 @@ build_t_desc (type, definition)\n   /* Show that we are defining the t_desc for this type.  */\n   DECL_INITIAL (tdecl) = error_mark_node;\n \n-  parents = build_tree_list (NULL_TREE, integer_zero_node);\n-  vbases = build_tree_list (NULL_TREE, integer_zero_node);\n-  offsets = build_tree_list (NULL_TREE, integer_zero_node);\n+  parents = build_expr_list (NULL_TREE, integer_zero_node);\n+  vbases = build_expr_list (NULL_TREE, integer_zero_node);\n+  offsets = build_expr_list (NULL_TREE, integer_zero_node);\n   methods = NULL_TREE;\n   ivars = NULL_TREE;\n "}, {"sha": "d75fe62dff2bbb41bfbc3de061c6f9640ca3db6e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1317,7 +1317,7 @@ lookup_field (xbasetype, name, protect, want_type)\n       return rval;\n     }\n \n-  basetype_chain = build_tree_list (NULL_TREE, basetype_path);\n+  basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n   TREE_VIA_PUBLIC (basetype_chain) = TREE_VIA_PUBLIC (basetype_path);\n   TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n   TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n@@ -1348,11 +1348,11 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      TREE_VIA_PROTECTED (btypes) = TREE_VIA_PROTECTED (base_binfo);\n \t      TREE_VIA_VIRTUAL (btypes) = TREE_VIA_VIRTUAL (base_binfo);\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\tbtypes = tree_cons (NULL_TREE,\n+\t\tbtypes = my_tree_cons (NULL_TREE,\n \t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n \t\t\t\t    btypes);\n \t      else\n-\t\tbtypes = tree_cons (NULL_TREE,\n+\t\tbtypes = my_tree_cons (NULL_TREE,\n \t\t\t\t    TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i),\n \t\t\t\t    btypes);\n \t      obstack_ptr_grow (&search_obstack, btypes);\n@@ -1838,7 +1838,7 @@ lookup_fnfields (basetype_path, name, complain)\n     }\n   else\n     {\n-      basetype_chain = build_tree_list (NULL_TREE, basetype_path);\n+      basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n       TREE_VIA_PUBLIC (basetype_chain) = TREE_VIA_PUBLIC (basetype_path);\n       TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n       TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n@@ -1870,11 +1870,11 @@ lookup_fnfields (basetype_path, name, complain)\n \t      TREE_VIA_PROTECTED (btypes) = TREE_VIA_PROTECTED (base_binfo);\n \t      TREE_VIA_VIRTUAL (btypes) = TREE_VIA_VIRTUAL (base_binfo);\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\tbtypes = tree_cons (NULL_TREE,\n+\t\tbtypes = my_tree_cons (NULL_TREE,\n \t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n \t\t\t\t    btypes);\n \t      else\n-\t\tbtypes = tree_cons (NULL_TREE,\n+\t\tbtypes = my_tree_cons (NULL_TREE,\n \t\t\t\t    TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i),\n \t\t\t\t    btypes);\n \t      obstack_ptr_grow (&search_obstack, btypes);\n@@ -3672,6 +3672,8 @@ reinit_search_statistics ()\n #endif /* GATHER_STATISTICS */\n }\n \n+#define scratch_tree_cons expr_tree_cons\n+\n static tree conversions;\n static void\n add_conversions (binfo)\n@@ -3685,7 +3687,7 @@ add_conversions (binfo)\n       tree tmp = TREE_VEC_ELT (method_vec, i);\n       if (! IDENTIFIER_TYPENAME_P (DECL_NAME (tmp)))\n \tbreak;\n-      conversions = tree_cons (binfo, tmp, conversions);\n+      conversions = scratch_tree_cons (binfo, tmp, conversions);\n     }\n   SET_BINFO_MARKED (binfo);\n }"}, {"sha": "c681651ebf1f32267ed343d52d88c04a8405efcf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -1655,14 +1655,9 @@ extern int depth_reached;\n void\n print_lang_statistics ()\n {\n-  extern struct obstack maybepermanent_obstack, decl_obstack;\n+  extern struct obstack decl_obstack;\n   print_obstack_statistics (\"class_obstack\", &class_obstack);\n   print_obstack_statistics (\"decl_obstack\", &decl_obstack);\n-  print_obstack_statistics (\"permanent_obstack\", &permanent_obstack);\n-  print_obstack_statistics (\"maybepermanent_obstack\", &maybepermanent_obstack);\n-#if 0\n-  print_inline_obstack_statistics ();\n-#endif\n   print_search_statistics ();\n   print_class_statistics ();\n #ifdef GATHER_STATISTICS\n@@ -1765,8 +1760,6 @@ break_out_target_exprs (t)\n /* Obstack used for allocating nodes in template function and variable\n    definitions.  */\n \n-extern struct obstack *expression_obstack;\n-\n /* Similar to `build_nt', except we build\n    on the permanent_obstack, regardless.  */\n \n@@ -2063,13 +2056,20 @@ make_temp_vec (len)\n      int len;\n {\n   register tree node;\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n+  register struct obstack *ambient_obstack = current_obstack;\n+  current_obstack = expression_obstack;\n   node = make_tree_vec (len);\n-  pop_obstacks ();\n+  current_obstack = ambient_obstack;\n   return node;\n }\n \n+void\n+push_expression_obstack ()\n+{\n+  push_obstacks_nochange ();\n+  current_obstack = expression_obstack;\n+}\n+\n /* The type of ARG when used as an lvalue.  */\n \n tree"}, {"sha": "a97dbbb79e794cef23f2d16c904341470f5da34c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -2417,7 +2417,7 @@ build_x_function_call (function, params, decl)\n       decl_addr = build_unary_op (ADDR_EXPR, decl, 0);\n       function = get_member_function_from_ptrfunc (&decl_addr,\n \t\t\t\t\t\t   TREE_OPERAND (function, 1));\n-      params = tree_cons (NULL_TREE, decl_addr, params);\n+      params = expr_tree_cons (NULL_TREE, decl_addr, params);\n       return build_function_call (function, params);\n     }\n \n@@ -2467,7 +2467,7 @@ build_x_function_call (function, params, decl)\n \t}\n       else\n \tdecl = build_c_cast (ctypeptr, decl);\n-      params = tree_cons (NULL_TREE, decl, params);\n+      params = expr_tree_cons (NULL_TREE, decl, params);\n     }\n \n   return build_function_call (function, params);\n@@ -2870,7 +2870,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  if (parmval == error_mark_node)\n \t    return error_mark_node;\n \n-\t  result = tree_cons (NULL_TREE, parmval, result);\n+\t  result = expr_tree_cons (NULL_TREE, parmval, result);\n \t}\n       else\n \t{\n@@ -2881,17 +2881,17 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      && (TYPE_PRECISION (TREE_TYPE (val))\n \t\t  < TYPE_PRECISION (double_type_node)))\n \t    /* Convert `float' to `double'.  */\n-\t    result = tree_cons (NULL_TREE, cp_convert (double_type_node, val), result);\n+\t    result = expr_tree_cons (NULL_TREE, cp_convert (double_type_node, val), result);\n \t  else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n \t\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n \t    {\n \t      cp_warning (\"cannot pass objects of type `%T' through `...'\",\n \t\t\t  TREE_TYPE (val));\n-\t      result = tree_cons (NULL_TREE, val, result);\n+\t      result = expr_tree_cons (NULL_TREE, val, result);\n \t    }\n \t  else\n \t    /* Convert `short' and `char' to full-size `int'.  */\n-\t    result = tree_cons (NULL_TREE, default_conversion (val), result);\n+\t    result = expr_tree_cons (NULL_TREE, default_conversion (val), result);\n \t}\n \n       if (typetail)\n@@ -2936,7 +2936,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      if (parmval == error_mark_node)\n \t\treturn error_mark_node;\n \n-\t      result = tree_cons (0, parmval, result);\n+\t      result = expr_tree_cons (0, parmval, result);\n \t      typetail = TREE_CHAIN (typetail);\n \t      /* ends with `...'.  */\n \t      if (typetail == NULL_TREE)\n@@ -5146,7 +5146,7 @@ build_x_compound_expr (list)\n   result = build_opfncall (COMPOUND_EXPR, LOOKUP_NORMAL,\n \t\t\t   TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n   if (result)\n-    return build_x_compound_expr (tree_cons (NULL_TREE, result, TREE_CHAIN (rest)));\n+    return build_x_compound_expr (expr_tree_cons (NULL_TREE, result, TREE_CHAIN (rest)));\n \n   if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n     {\n@@ -5163,8 +5163,8 @@ build_x_compound_expr (list)\n     warn_if_unused_value (TREE_VALUE(list));\n #endif\n \n-  return build_compound_expr (tree_cons (NULL_TREE, TREE_VALUE (list),\n-\t\t\t\t\t build_tree_list (NULL_TREE, build_x_compound_expr (rest))));\n+  return build_compound_expr (expr_tree_cons (NULL_TREE, TREE_VALUE (list),\n+\t\t\t\t\t build_expr_list (NULL_TREE, build_x_compound_expr (rest))));\n }\n \n /* Given a list of expressions, return a compound expression\n@@ -5248,7 +5248,7 @@ build_static_cast (type, expr)\n   if (IS_AGGR_TYPE (type))\n     return build_cplus_new\n       (type, (build_method_call\n-\t      (NULL_TREE, ctor_identifier, build_tree_list (NULL_TREE, expr),\n+\t      (NULL_TREE, ctor_identifier, build_expr_list (NULL_TREE, expr),\n \t       TYPE_BINFO (type), LOOKUP_NORMAL)));\n \n   expr = decay_conversion (expr);\n@@ -5795,7 +5795,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       else\n \t{\n \t  result = build_method_call (lhs, ctor_identifier,\n-\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n+\t\t\t\t      build_expr_list (NULL_TREE, rhs),\n \t\t\t\t      TYPE_BINFO (lhstype), LOOKUP_NORMAL);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n@@ -6093,7 +6093,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (TREE_SIDE_EFFECTS (lhs))\n \tcond = build_compound_expr (tree_cons\n \t\t\t\t    (NULL_TREE, lhs,\n-\t\t\t\t     build_tree_list (NULL_TREE, cond)));\n+\t\t\t\t     build_expr_list (NULL_TREE, cond)));\n \n       /* Cannot have two identical lhs on this one tree (result) as preexpand\n \t calls will rip them out and fill in RTL for them, but when the\n@@ -6257,18 +6257,18 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n   if (pfn)\n     {\n       u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t    tree_cons (pfn_identifier, pfn, NULL_TREE));\n+\t\t    expr_tree_cons (pfn_identifier, pfn, NULL_TREE));\n     }\n   else\n     {\n       u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t    tree_cons (delta2_identifier, delta2, NULL_TREE));\n+\t\t    expr_tree_cons (delta2_identifier, delta2, NULL_TREE));\n     }\n \n   u = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\ttree_cons (NULL_TREE, delta,\n-\t\t\t   tree_cons (NULL_TREE, idx,\n-\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t\texpr_tree_cons (NULL_TREE, delta,\n+\t\t\t   expr_tree_cons (NULL_TREE, idx,\n+\t\t\t\t      expr_tree_cons (NULL_TREE, u, NULL_TREE))));\n \n   return digest_init (type, u, (tree*)0);\n #else\n@@ -6287,14 +6287,14 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n     {\n       allconstant = TREE_CONSTANT (pfn);\n       allsimple = !! initializer_constant_valid_p (pfn, TREE_TYPE (pfn));\n-      u = tree_cons (pfn_field, pfn, NULL_TREE);\n+      u = expr_tree_cons (pfn_field, pfn, NULL_TREE);\n     }\n   else\n     {\n       delta2 = convert_and_check (delta_type_node, delta2);\n       allconstant = TREE_CONSTANT (delta2);\n       allsimple = !! initializer_constant_valid_p (delta2, TREE_TYPE (delta2));\n-      u = tree_cons (delta2_field, delta2, NULL_TREE);\n+      u = expr_tree_cons (delta2_field, delta2, NULL_TREE);\n     }\n \n   delta = convert_and_check (delta_type_node, delta);\n@@ -6306,9 +6306,9 @@ build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n       && initializer_constant_valid_p (idx, TREE_TYPE (idx));\n \n   u = build (CONSTRUCTOR, subtype, NULL_TREE, u);\n-  u = tree_cons (delta_field, delta,\n-\t\t tree_cons (idx_field, idx,\n-\t\t\t    tree_cons (pfn_or_delta2_field, u, NULL_TREE)));\n+  u = expr_tree_cons (delta_field, delta,\n+\t\t expr_tree_cons (idx_field, idx,\n+\t\t\t    expr_tree_cons (pfn_or_delta2_field, u, NULL_TREE)));\n   u = build (CONSTRUCTOR, type, NULL_TREE, u);\n   TREE_CONSTANT (u) = allconstant;\n   TREE_STATIC (u) = allconstant && allsimple;\n@@ -7036,7 +7036,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t  if (TYPE_HAS_INIT_REF (type))\n \t    {\n \t      tree init = build_method_call (exp, ctor_identifier,\n-\t\t\t\t\t     build_tree_list (NULL_TREE, rhs),\n+\t\t\t\t\t     build_expr_list (NULL_TREE, rhs),\n \t\t\t\t\t     TYPE_BINFO (type), LOOKUP_NORMAL);\n \n \t      if (init == error_mark_node)"}, {"sha": "93c77dd035aefdb072805c69dd10ddee6b0ac6b3", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66d884e7b29d16a098c881bc8b577f2b39d3ca6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e66d884e7b29d16a098c881bc8b577f2b39d3ca6", "patch": "@@ -986,7 +986,7 @@ process_init_constructor (type, init, elts)\n \t    allconstant = 0;\n \t  else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n \t    allsimple = 0;\n-\t  members = tree_cons (NULL_TREE, next1, members);\n+\t  members = expr_tree_cons (NULL_TREE, next1, members);\n \t}\n     }\n   if (TREE_CODE (type) == RECORD_TYPE)\n@@ -1021,7 +1021,7 @@ process_init_constructor (type, init, elts)\n \n \t  if (! DECL_NAME (field))\n \t    {\n-\t      members = tree_cons (field, integer_zero_node, members);\n+\t      members = expr_tree_cons (field, integer_zero_node, members);\n \t      continue;\n \t    }\n \n@@ -1050,7 +1050,7 @@ process_init_constructor (type, init, elts)\n \t    allconstant = 0;\n \t  else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n \t    allsimple = 0;\n-\t  members = tree_cons (field, next1, members);\n+\t  members = expr_tree_cons (field, next1, members);\n \t}\n       for (; field; field = TREE_CHAIN (field))\n \t{\n@@ -1067,7 +1067,7 @@ process_init_constructor (type, init, elts)\n \t\tallconstant = 0;\n \t      else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n \t\tallsimple = 0;\n-\t      members = tree_cons (field, next1, members);\n+\t      members = expr_tree_cons (field, next1, members);\n \t    }\n \t  else if (TREE_READONLY (field))\n \t    error (\"uninitialized const member `%s'\",\n@@ -1149,7 +1149,7 @@ process_init_constructor (type, init, elts)\n \tallconstant = 0;\n       else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n \tallsimple = 0;\n-      members = tree_cons (field, next1, members);\n+      members = expr_tree_cons (field, next1, members);\n     }\n \n   /* If arguments were specified as a list, just remove the ones we used.  */"}]}