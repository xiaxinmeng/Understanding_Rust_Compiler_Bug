{"sha": "bb8df8a62d346532834194e96b8d3970eb8cd6e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI4ZGY4YTYyZDM0NjUzMjgzNDE5NGU5NmI4ZDM5NzBlYjhjZDZlMA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2005-08-10T19:52:55Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2005-08-10T19:52:55Z"}, "message": "rs6000.c (mems_ok_for_quad_peep): Rewrite.\n\n2005-08-10  Eric Christopher  <echristo@apple.com>\n\n        * config/rs6000/rs6000.c (mems_ok_for_quad_peep): Rewrite.\n        * config/rs6000/rs6000.md (*lfq_power2, *stfq_power2): Use\n        V2DFmode.\n\nFrom-SVN: r102956", "tree": {"sha": "7a3055424b4a8f77e035af7455a562a19bcc5135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a3055424b4a8f77e035af7455a562a19bcc5135"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb8df8a62d346532834194e96b8d3970eb8cd6e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb8df8a62d346532834194e96b8d3970eb8cd6e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb8df8a62d346532834194e96b8d3970eb8cd6e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb8df8a62d346532834194e96b8d3970eb8cd6e0/comments", "author": null, "committer": null, "parents": [{"sha": "4f8dbd340cd7e0181a24666bb82ea9fea5a78565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f8dbd340cd7e0181a24666bb82ea9fea5a78565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f8dbd340cd7e0181a24666bb82ea9fea5a78565"}], "stats": {"total": 173, "additions": 96, "deletions": 77}, "files": [{"sha": "e6a03393076d048053f962e602246f1a9a9783fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8df8a62d346532834194e96b8d3970eb8cd6e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8df8a62d346532834194e96b8d3970eb8cd6e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb8df8a62d346532834194e96b8d3970eb8cd6e0", "patch": "@@ -1,3 +1,9 @@\n+2005-08-10  Eric Christopher  <echristo@apple.com>\n+\n+\t* config/rs6000/rs6000.c (mems_ok_for_quad_peep): Rewrite.\n+\t* config/rs6000/rs6000.md (*lfq_power2, *stfq_power2): Use\n+\tV2DFmode.\n+\n 2005-08-10  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* config/darwin.c (machopic_indirect_data_reference): Use a new register\n@@ -74,7 +80,7 @@\n \n 2005-08-09  Dorit Nuzman  <dorit@il.ibm.com>\n \n-\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Set \n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Set\n \tBIT_FIELD_REF_UNSIGNED for newly created BIT_FIELD_REFs.\n \n 2005-08-09  Richard Guenther  <rguenther@suse.de>"}, {"sha": "577bbfbbf81c91283db2f5ad1ae6f78d1fc2be45", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8df8a62d346532834194e96b8d3970eb8cd6e0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8df8a62d346532834194e96b8d3970eb8cd6e0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bb8df8a62d346532834194e96b8d3970eb8cd6e0", "patch": "@@ -1975,7 +1975,7 @@ int\n num_insns_constant (rtx op, enum machine_mode mode)\n {\n   HOST_WIDE_INT low, high;\n-  \n+\n   switch (GET_CODE (op))\n     {\n     case CONST_INT:\n@@ -1992,7 +1992,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t  {\n \t    long l;\n \t    REAL_VALUE_TYPE rv;\n-\t    \n+\n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n \t    REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \t    return num_insns_constant_wide ((HOST_WIDE_INT) l);\n@@ -2007,7 +2007,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t  {\n \t    long l[2];\n \t    REAL_VALUE_TYPE rv;\n-\t    \n+\n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n \t    REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n \t    high = l[WORDS_BIG_ENDIAN == 0];\n@@ -2022,18 +2022,18 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t    if ((high == 0 && low >= 0)\n \t\t|| (high == -1 && low < 0))\n \t      return num_insns_constant_wide (low);\n-\t    \n+\n \t    else if (mask_operand (op, mode))\n \t      return 2;\n-\t    \n+\n \t    else if (low == 0)\n \t      return num_insns_constant_wide (high) + 1;\n-\t    \n+\n \t    else\n \t      return (num_insns_constant_wide (high)\n \t\t      + num_insns_constant_wide (low) + 1);\n \t  }\n-\t\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -2128,7 +2128,7 @@ output_vec_const_move (rtx *operands)\n \treturn \"vxor %0,%0,%0\";\n \n       gcc_assert (easy_vector_constant (vec, mode));\n-      \n+\n       operands[1] = GEN_INT (cst);\n       switch (mode)\n \t{\n@@ -2162,14 +2162,14 @@ output_vec_const_move (rtx *operands)\n \t    }\n \t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n \t    return \"#\";\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n \n   gcc_assert (TARGET_SPE);\n-  \n+\n   /* Vector constant 0 is handled as a splitter of V2SI, and in the\n      pattern of V1DI, V4HI, and V2SF.\n \n@@ -2355,7 +2355,7 @@ mask64_1or2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED,\n     {\n       HOST_WIDE_INT c, lsb;\n       bool one_ok;\n-      \n+\n       c = INTVAL (op);\n \n       /* Disallow all zeros.  */\n@@ -2366,7 +2366,7 @@ mask64_1or2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED,\n          AND there are zero, one or two transitions in the _whole_ of\n          C.  */\n       one_ok = !(c & ~(HOST_WIDE_INT)0xffffffff);\n-      \n+\n       /* We don't change the number of transitions by inverting,\n \t so make sure we start with the LS bit zero.  */\n       if (c & 1)\n@@ -2501,7 +2501,7 @@ rs6000_special_round_type_align (tree type, int computed, int specified)\n {\n   tree field = TYPE_FIELDS (type);\n \n-  /* Skip all non field decls */ \n+  /* Skip all non field decls */\n   while (field != NULL && TREE_CODE (field) != FIELD_DECL)\n     field = TREE_CHAIN (field);\n \n@@ -3574,10 +3574,10 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n \tdest = gen_reg_rtx (mode);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, source));\n       return dest;\n-      \n+\n     case SImode:\n       result = no_new_pseudos ? dest : gen_reg_rtx (SImode);\n-      \n+\n       emit_insn (gen_rtx_SET (VOIDmode, result,\n \t\t\t      GEN_INT (INTVAL (source)\n \t\t\t\t       & (~ (HOST_WIDE_INT) 0xffff))));\n@@ -3594,7 +3594,7 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n \t  c0 = INTVAL (source);\n \t  c1 = -(c0 < 0);\n \t  break;\n-\t  \n+\n \tcase CONST_DOUBLE:\n #if HOST_BITS_PER_WIDE_INT >= 64\n \t  c0 = CONST_DOUBLE_LOW (source);\n@@ -3758,7 +3758,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t   || CONST_DOUBLE_LOW (operands[1]) < 0)\n \t\t  && (CONST_DOUBLE_HIGH (operands[1]) != -1\n \t\t      || CONST_DOUBLE_LOW (operands[1]) >= 0)));\n-  \n+\n   /* Check if GCC is setting up a block move that will end up using FP\n      registers as temporaries.  We must make sure this is acceptable.  */\n   if (GET_CODE (operands[0]) == MEM\n@@ -4549,7 +4549,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t     grovel through the fields for these too.  */\n \t  cum->intoffset = 0;\n \t  rs6000_darwin64_record_arg_advance_recurse (cum, type, 0);\n-\t  rs6000_darwin64_record_arg_advance_flush (cum, \n+\t  rs6000_darwin64_record_arg_advance_flush (cum,\n \t\t\t\t\t\t    size * BITS_PER_UNIT);\n \t}\n     }\n@@ -4711,7 +4711,7 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    structure between cum->intoffset and bitpos to integer registers.  */\n \n static void\n-rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum, \n+rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum,\n \t\t\t\t  HOST_WIDE_INT bitpos, rtx rvec[], int *k)\n {\n   enum machine_mode mode;\n@@ -4755,7 +4755,7 @@ rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum,\n \n   if (intregs > 0 && intregs > GP_ARG_NUM_REG - this_regno)\n     cum->use_stack = 1;\n-    \n+\n   intregs = MIN (intregs, GP_ARG_NUM_REG - this_regno);\n   if (intregs <= 0)\n     return;\n@@ -4779,7 +4779,7 @@ rs6000_darwin64_record_arg_flush (CUMULATIVE_ARGS *cum,\n /* Recursive workhorse for the following.  */\n \n static void\n-rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type, \n+rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type,\n \t\t\t\t    HOST_WIDE_INT startbitpos, rtx rvec[],\n \t\t\t\t    int *k)\n {\n@@ -4813,7 +4813,7 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type,\n #endif\n \t    rs6000_darwin64_record_arg_flush (cum, bitpos, rvec, k);\n \t    rvec[(*k)++]\n-\t      = gen_rtx_EXPR_LIST (VOIDmode, \n+\t      = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t   gen_rtx_REG (mode, cum->fregno++),\n \t\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n \t    if (mode == TFmode)\n@@ -4823,8 +4823,8 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type,\n \t  {\n \t    rs6000_darwin64_record_arg_flush (cum, bitpos, rvec, k);\n \t    rvec[(*k)++]\n-\t      = gen_rtx_EXPR_LIST (VOIDmode, \n-\t\t\t\t   gen_rtx_REG (mode, cum->vregno++), \n+\t      = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t   gen_rtx_REG (mode, cum->vregno++),\n \t\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n \t  }\n \telse if (cum->intoffset == -1)\n@@ -4837,7 +4837,7 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type,\n    being passed by value, along with the offset of where the\n    register's value may be found in the block.  FP fields go in FP\n    register, vector fields go in vector registers, and everything\n-   else goes in int registers, packed as in memory.  \n+   else goes in int registers, packed as in memory.\n \n    This code is also used for function return values.  RETVAL indicates\n    whether this is the case.\n@@ -5249,7 +5249,7 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       /* If we are passing this arg in the fixed parameter save area\n \t (gprs or memory) as well as fprs, then this function should\n \t return the number of bytes passed in the parameter save area\n-\t rather than bytes passed in fprs.  */ \n+\t rather than bytes passed in fprs.  */\n       && !(type\n \t   && (cum->nargs_prototype <= 0\n \t       || (DEFAULT_ABI == ABI_AIX\n@@ -7736,13 +7736,13 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     }\n \n   gcc_assert (TARGET_ALTIVEC || TARGET_SPE);\n-  \n+\n   /* Handle simple unary operations.  */\n   d = (struct builtin_description *) bdesc_1arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n     if (d->code == fcode)\n       return rs6000_expand_unop_builtin (d->icode, arglist, target);\n-  \n+\n   /* Handle simple binary operations.  */\n   d = (struct builtin_description *) bdesc_2arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n@@ -7754,7 +7754,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   for (i = 0; i < ARRAY_SIZE  (bdesc_3arg); i++, d++)\n     if (d->code == fcode)\n       return rs6000_expand_ternop_builtin (d->icode, arglist, target);\n-  \n+\n   gcc_unreachable ();\n }\n \n@@ -8698,7 +8698,7 @@ rs6000_common_init_builtins (void)\n           mode2 = insn_data[d->icode].operand[2].mode;\n           mode3 = insn_data[d->icode].operand[3].mode;\n \t}\n-      \n+\n       /* When all four are of the same mode.  */\n       if (mode0 == mode1 && mode1 == mode2 && mode2 == mode3)\n \t{\n@@ -8795,7 +8795,7 @@ rs6000_common_init_builtins (void)\n \t  mode2 = VOIDmode;\n \t}\n       else\n-\t{ \n+\t{\n           if (d->name == 0 || d->icode == CODE_FOR_nothing)\n \t    continue;\n \n@@ -8945,7 +8945,7 @@ rs6000_common_init_builtins (void)\n         {\n           if (d->name == 0 || d->icode == CODE_FOR_nothing)\n \t    continue;\n-      \n+\n           mode0 = insn_data[d->icode].operand[0].mode;\n           mode1 = insn_data[d->icode].operand[1].mode;\n         }\n@@ -9647,8 +9647,8 @@ int\n mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n {\n   rtx addr1, addr2;\n-  unsigned int reg1;\n-  int offset1;\n+  unsigned int reg1, reg2;\n+  int offset1, offset2;\n \n   /* The mems cannot be volatile.  */\n   if (MEM_VOLATILE_P (mem1) || MEM_VOLATILE_P (mem2))\n@@ -9681,23 +9681,36 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n       offset1 = 0;\n     }\n \n-  /* Make sure the second address is a (mem (plus (reg) (const_int)))\n-     or if it is (mem (reg)) then make sure that offset1 is -8 and the same\n-     register as addr1.  */\n-  if (offset1 == -8 && GET_CODE (addr2) == REG && reg1 == REGNO (addr2))\n-    return 1;\n-  if (GET_CODE (addr2) != PLUS)\n-    return 0;\n-\n-  if (GET_CODE (XEXP (addr2, 0)) != REG\n-      || GET_CODE (XEXP (addr2, 1)) != CONST_INT)\n+  /* And now for the second addr.  */\n+  if (GET_CODE (addr2) == PLUS)\n+    {\n+      /* If not a REG, return zero.  */\n+      if (GET_CODE (XEXP (addr2, 0)) != REG)\n+\treturn 0;\n+      else\n+\t{\n+\t  reg2 = REGNO (XEXP (addr2, 0));\n+\t  /* The offset must be constant. */\n+\t  if (GET_CODE (XEXP (addr2, 1)) != CONST_INT)\n+\t    return 0;\n+\t  offset2 = INTVAL (XEXP (addr2, 1));\n+\t}\n+    }\n+  else if (GET_CODE (addr2) != REG)\n     return 0;\n+  else\n+    {\n+      reg2 = REGNO (addr2);\n+      /* This was a simple (mem (reg)) expression.  Offset is 0.  */\n+      offset2 = 0;\n+    }\n \n-  if (reg1 != REGNO (XEXP (addr2, 0)))\n+  /* Both of these must have the same base register.  */\n+  if (reg1 != reg2)\n     return 0;\n \n   /* The offset for the second addr must be 8 more than the first addr.  */\n-  if (INTVAL (XEXP (addr2, 1)) != offset1 + 8)\n+  if (offset2 != offset1 + 8)\n     return 0;\n \n   /* All the tests passed.  addr1 and addr2 are valid for lfq or stfq\n@@ -10617,7 +10630,7 @@ print_operand (FILE *file, rtx x, int code)\n \t  {\n \t    gcc_assert (GET_CODE (tmp) == PLUS\n \t\t\t&& GET_CODE (XEXP (tmp, 1)) == REG);\n-\t    \n+\n \t    if (REGNO (XEXP (tmp, 0)) == 0)\n \t      fprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (tmp, 1)) ],\n \t\t       reg_names[ REGNO (XEXP (tmp, 0)) ]);\n@@ -10918,7 +10931,7 @@ rs6000_generate_compare (enum rtx_code code)\n \t      gcc_unreachable ();\n \t    }\n \t  break;\n-\t  \n+\n \tcase GT: case GTU: case UNGT: case UNGE: case GE: case GEU:\n \t  switch (op_mode)\n \t    {\n@@ -10929,7 +10942,7 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t: gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t\t   rs6000_compare_op1);\n \t      break;\n-\t      \n+\n \t    case DFmode:\n \t      cmp = flag_unsafe_math_optimizations\n \t\t? gen_tstdfgt_gpr (compare_result, rs6000_compare_op0,\n@@ -10942,7 +10955,7 @@ rs6000_generate_compare (enum rtx_code code)\n \t      gcc_unreachable ();\n \t    }\n \t  break;\n-\t  \n+\n \tcase LT: case LTU: case UNLT: case UNLE: case LE: case LEU:\n \t  switch (op_mode)\n \t    {\n@@ -10953,7 +10966,7 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t: gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n \t\t\t\t   rs6000_compare_op1);\n \t      break;\n-\t      \n+\n \t    case DFmode:\n \t      cmp = flag_unsafe_math_optimizations\n \t\t? gen_tstdflt_gpr (compare_result, rs6000_compare_op0,\n@@ -11577,7 +11590,7 @@ rs6000_emit_vector_select (rtx dest, rtx op1, rtx op2, rtx mask)\n \n   temp = gen_reg_rtx (dest_mode);\n \n-  /* For each vector element, select op1 when mask is 1 otherwise \n+  /* For each vector element, select op1 when mask is 1 otherwise\n      select op2.  */\n   t = gen_rtx_SET (VOIDmode, temp,\n \t\t   gen_rtx_UNSPEC (dest_mode,\n@@ -11867,7 +11880,7 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n    (set M (CODE:MODE M OP))\n    If not NULL, BEFORE is atomically set to M before the operation, and\n    AFTER is set to M after the operation (that is, (CODE:MODE M OP)).\n-   If SYNC_P then a memory barrier is emitted before the operation.  \n+   If SYNC_P then a memory barrier is emitted before the operation.\n    Either OP or M may be wrapped in a NOT operation.  */\n \n void\n@@ -11881,10 +11894,10 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n   rtvec vec;\n   HOST_WIDE_INT imask = GET_MODE_MASK (mode);\n   rtx shift = NULL_RTX;\n-  \n+\n   if (sync_p)\n     emit_insn (gen_memory_barrier ());\n-  \n+\n   if (GET_CODE (m) == NOT)\n     used_m = XEXP (m, 0);\n   else\n@@ -11901,14 +11914,14 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \t  int ishift = 0;\n \t  if (BYTES_BIG_ENDIAN)\n \t    ishift = GET_MODE_BITSIZE (SImode) - GET_MODE_BITSIZE (mode);\n-\t  \n+\n \t  shift = GEN_INT (ishift);\n \t}\n       else\n \t{\n \t  rtx addrSI, aligned_addr;\n \t  int shift_mask = mode == QImode ? 0x18 : 0x10;\n-\t  \n+\n \t  addrSI = force_reg (SImode, gen_lowpart_common (SImode,\n \t\t\t\t\t\t\t  XEXP (used_m, 0)));\n \t  shift = gen_reg_rtx (SImode);\n@@ -11961,7 +11974,7 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \tcase MINUS:\n \t  {\n \t    rtx mask;\n-\t    \n+\n \t    newop = expand_binop (SImode, and_optab,\n \t\t\t\t  oldop, GEN_INT (imask), NULL_RTX,\n \t\t\t\t  1, OPTAB_LIB_WIDEN);\n@@ -12016,7 +12029,7 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n       if (after == NULL_RTX)\n \tafter = gen_reg_rtx (used_mode);\n     }\n-  \n+\n   if ((code == PLUS || code == MINUS || GET_CODE (m) == NOT)\n       && used_mode != mode)\n     the_op = op;  /* Computed above.  */\n@@ -12109,7 +12122,7 @@ emit_store_conditional (enum machine_mode mode, rtx res, rtx mem, rtx val)\n }\n \n /* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation\n-   to perform.  MEM is the memory on which to operate.  VAL is the second \n+   to perform.  MEM is the memory on which to operate.  VAL is the second\n    operand of the binary operator.  BEFORE and AFTER are optional locations to\n    return the value of MEM either before of after the operation.  SCRATCH is\n    a scratch register.  */\n@@ -13361,7 +13374,7 @@ rs6000_emit_load_toc_table (int fromprolog)\n   else\n     {\n       gcc_assert (DEFAULT_ABI == ABI_AIX);\n-      \n+\n       if (TARGET_32BIT)\n \tinsn = emit_insn (gen_load_toc_aix_si (dest));\n       else\n@@ -17767,7 +17780,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n \treturn orig;\n \n       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n-      \n+\n       /* Use a different reg for the intermediate value, as\n \t it will be marked UNCHANGING.  */\n       reg_temp = no_new_pseudos ? reg : gen_reg_rtx (Pmode);\n@@ -17776,7 +17789,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n       offset =\n \trs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n \t\t\t\t\t\tPmode, reg);\n-      \n+\n       if (GET_CODE (offset) == CONST_INT)\n \t{\n \t  if (SMALL_INT (offset))\n@@ -18990,8 +19003,8 @@ rs6000_vector_mode_supported_p (enum machine_mode mode)\n     return false;\n }\n \n-/* Target hook for invalid_arg_for_unprototyped_fn. */ \n-static const char * \n+/* Target hook for invalid_arg_for_unprototyped_fn. */\n+static const char *\n invalid_arg_for_unprototyped_fn (tree typelist, tree funcdecl, tree val)\n {\n   return (!rs6000_darwin64_abi"}, {"sha": "288b40f93b0ded8eb821a379113215d261148995", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8df8a62d346532834194e96b8d3970eb8cd6e0/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8df8a62d346532834194e96b8d3970eb8cd6e0/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=bb8df8a62d346532834194e96b8d3970eb8cd6e0", "patch": "@@ -4830,7 +4830,7 @@\n \t\t\t (match_dup 3)\n \t\t\t (match_dup 4)))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS\n-   && !HONOR_NANS (SFmode) && !HONOR_SIGNED_ZEROS (SFmode)\" \n+   && !HONOR_NANS (SFmode) && !HONOR_SIGNED_ZEROS (SFmode)\"\n   {\n      operands[3] = gen_reg_rtx (SFmode);\n      operands[4] = gen_reg_rtx (SFmode);\n@@ -9144,11 +9144,11 @@\n ;; Peephole to convert two consecutive FP loads or stores into lfq/stfq.\n \n (define_insn \"*lfq_power2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n-\t(match_operand:TF 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:V2DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(match_operand:V2DF 1 \"memory_operand\" \"\"))]\n   \"TARGET_POWER2\n    && TARGET_HARD_FLOAT && TARGET_FPRS\"\n-   \"lfq%U1%X1 %0,%1\")\n+  \"lfq%U1%X1 %0,%1\")\n \n (define_peephole2\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -9160,13 +9160,13 @@\n    && registers_ok_for_quad_peep (operands[0], operands[2])\n    && mems_ok_for_quad_peep (operands[1], operands[3])\"\n   [(set (match_dup 0)\n-        (match_dup 1))]\n-  \"operands[1] = widen_memory_access (operands[1], TFmode, 0);\n-   operands[0] = gen_rtx_REG (TFmode, REGNO (operands[0]));\")\n+\t(match_dup 1))]\n+  \"operands[1] = widen_memory_access (operands[1], V2DFmode, 0);\n+   operands[0] = gen_rtx_REG (V2DFmode, REGNO (operands[0]));\")\n \n (define_insn \"*stfq_power2\"\n-  [(set (match_operand:TF 0 \"memory_operand\" \"\")\n-\t(match_operand:TF 1 \"gpc_reg_operand\" \"f\"))]\n+  [(set (match_operand:V2DF 0 \"memory_operand\" \"\")\n+\t(match_operand:V2DF 1 \"gpc_reg_operand\" \"f\"))]\n   \"TARGET_POWER2\n    && TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"stfq%U0%X0 %1,%0\")\n@@ -9183,8 +9183,8 @@\n    && mems_ok_for_quad_peep (operands[0], operands[2])\"\n   [(set (match_dup 0)\n \t(match_dup 1))]\n-  \"operands[0] = widen_memory_access (operands[0], TFmode, 0);\n-   operands[1] = gen_rtx_REG (TFmode, REGNO (operands[1]));\")\n+  \"operands[0] = widen_memory_access (operands[0], V2DFmode, 0);\n+   operands[1] = gen_rtx_REG (V2DFmode, REGNO (operands[1]));\")\n \n ;; after inserting conditional returns we can sometimes have\n ;; unnecessary register moves.  Unfortunately we cannot have a"}]}