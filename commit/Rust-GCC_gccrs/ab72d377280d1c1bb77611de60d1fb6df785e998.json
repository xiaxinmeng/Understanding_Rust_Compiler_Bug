{"sha": "ab72d377280d1c1bb77611de60d1fb6df785e998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3MmQzNzcyODBkMWMxYmI3NzYxMWRlNjBkMWZiNmRmNzg1ZTk5OA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-16T21:45:08Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-16T21:45:08Z"}, "message": "scoping\n\nFrom-SVN: r12972", "tree": {"sha": "cd279553428f79535a0e81830efea2e93d257262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd279553428f79535a0e81830efea2e93d257262"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab72d377280d1c1bb77611de60d1fb6df785e998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab72d377280d1c1bb77611de60d1fb6df785e998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab72d377280d1c1bb77611de60d1fb6df785e998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab72d377280d1c1bb77611de60d1fb6df785e998/comments", "author": null, "committer": null, "parents": [{"sha": "fe1fd3534199f0595b01432701f76c65d4a464dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1fd3534199f0595b01432701f76c65d4a464dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1fd3534199f0595b01432701f76c65d4a464dc"}], "stats": {"total": 124, "additions": 60, "deletions": 64}, "files": [{"sha": "582e20989df081e8c015db60cb0b0921de57f61a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 60, "deletions": 64, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab72d377280d1c1bb77611de60d1fb6df785e998/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab72d377280d1c1bb77611de60d1fb6df785e998/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ab72d377280d1c1bb77611de60d1fb6df785e998", "patch": "@@ -4970,20 +4970,20 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n       if (is_const_type)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_const_type, context_die);\n+\t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die);\n \t  sub_die = modified_type_die\n \t    (build_type_variant (type, 0, is_volatile_type),\n \t     0, is_volatile_type, context_die);\n \t}\n       else if (is_volatile_type)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_volatile_type, context_die);\n+\t  mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die);\n \t  sub_die = modified_type_die\n \t    (TYPE_MAIN_VARIANT (type), 0, 0, context_die);\n \t}\n       else if (code == POINTER_TYPE)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_pointer_type, context_die);\n+\t  mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die);\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n #if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n@@ -4996,7 +4996,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t}\n       else if (code == REFERENCE_TYPE)\n \t{\n-\t  mod_type_die = new_die (DW_TAG_reference_type, context_die);\n+\t  mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die);\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n #if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n@@ -6080,8 +6080,8 @@ push_decl_scope (scope)\n \n /* Return the DIE for the scope the immediately contains this declaration.  */\n static dw_die_ref\n-scope_die_for_type (type, context_die)\n-    register tree type; \n+scope_die_for (t, context_die)\n+    register tree t; \n     register dw_die_ref context_die;\n {\n   register dw_die_ref scope_die = NULL;\n@@ -6090,24 +6090,33 @@ scope_die_for_type (type, context_die)\n \n   /* Walk back up the declaration tree looking for a place to define\n      this type.  */\n-  containing_scope = TYPE_CONTEXT (type);\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    containing_scope = TYPE_CONTEXT (t);\n+  else if (TREE_CODE (t) == FUNCTION_DECL && DECL_VIRTUAL_P (t))\n+    containing_scope = decl_class_context (t);\n+  else\n+    containing_scope = DECL_CONTEXT (t);\n+\n   if (containing_scope == NULL)\n     {\n       scope_die = comp_unit_die;\n     }\n   else\n     {\n-      for (i = decl_scope_depth - 1, scope_die = context_die;\n-\t   i >= 0\n-\t   && scope_die != NULL\n-\t   && decl_scope_table[i] != containing_scope;\n-\t   --i, scope_die = scope_die->die_parent)\n+      for (i = decl_scope_depth, scope_die = context_die;\n+\t   i > 0 && decl_scope_table[i - 1] != containing_scope;\n+\t   scope_die = scope_die->die_parent)\n \t{\n-\t  /* nothing */ ;\n+\t  if (scope_die->die_tag == DW_TAG_lexical_block)\n+\t    /* nothing */ ;\n+\t  else\n+\t    --i;\n \t}\n-      if (scope_die == NULL)\n+      if (i == 0)\n \t{\n-\t  scope_die = context_die;\n+\t  assert (scope_die == comp_unit_die);\n+\t  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't');\n+\t  assert (TREE_ASM_WRITTEN (containing_scope));\n \t}\n     }\n   return scope_die;\n@@ -6133,7 +6142,6 @@ add_type_attribute (object_die, type, decl_const, decl_volatile, context_die)\n      register dw_die_ref context_die;\n {\n   register enum tree_code code  = TREE_CODE (type);\n-  register dw_die_ref scope_die = NULL;\n   register dw_die_ref type_die  = NULL;\n \n   if (code == ERROR_MARK)\n@@ -6149,11 +6157,10 @@ add_type_attribute (object_die, type, decl_const, decl_volatile, context_die)\n       return;\n     }\n \n-  scope_die = scope_die_for_type (type, context_die);\n   type_die = modified_type_die (type,\n \t\t\t\tdecl_const || TYPE_READONLY (type),\n \t\t\t\tdecl_volatile || TYPE_VOLATILE (type),\n-\t\t\t\tscope_die);\n+\t\t\t\tcontext_die);\n   if (type_die != NULL)\n     {\n       add_AT_die_ref (object_die, DW_AT_type, type_die);\n@@ -6236,14 +6243,10 @@ gen_array_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref scope_die = scope_die_for_type (type, context_die);\n-  register dw_die_ref array_die = lookup_type_die (type);\n+  register dw_die_ref scope_die = scope_die_for (type, context_die);\n+  register dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die);\n   register tree element_type;\n \n-  if (array_die)\n-    return;\n-\n-  array_die  = new_die (DW_TAG_array_type, scope_die);\n #if 0\n   /* We default the array ordering.  SDB will probably do\n      the right things even if DW_AT_ordering is not present.  It's not even\n@@ -6281,10 +6284,8 @@ gen_set_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = lookup_type_die (type);\n-  if (type_die)\n-    return;\n-  type_die = new_die (DW_TAG_set_type, scope_die_for_type (type, context_die));\n+  register dw_die_ref type_die = new_die\n+    (DW_TAG_set_type, scope_die_for (type, context_die));\n   equate_type_number_to_die (type, type_die);\n   add_type_attribute (type_die, TREE_TYPE (type), 0, 0, context_die);\n }\n@@ -6324,7 +6325,7 @@ gen_inlined_enumeration_type_die (type, context_die)\n {\n   register dw_die_ref type_die;\n   type_die = new_die (DW_TAG_enumeration_type,\n-\t\t      scope_die_for_type (type, context_die));\n+\t\t      scope_die_for (type, context_die));\n   assert (TREE_ASM_WRITTEN (type));\n   add_abstract_origin_attribute (type_die, type);\n }\n@@ -6337,7 +6338,7 @@ gen_inlined_structure_type_die (type, context_die)\n {\n   register dw_die_ref type_die;\n   type_die = new_die (DW_TAG_structure_type,\n-\t\t      scope_die_for_type (type, context_die));\n+\t\t      scope_die_for (type, context_die));\n   assert (TREE_ASM_WRITTEN (type));\n   add_abstract_origin_attribute (type_die, type);\n }\n@@ -6350,7 +6351,7 @@ gen_inlined_union_type_die (type, context_die)\n {\n   register dw_die_ref type_die;\n   type_die = new_die (DW_TAG_union_type,\n-\t\t      scope_die_for_type (type, context_die));\n+\t\t      scope_die_for (type, context_die));\n   assert (TREE_ASM_WRITTEN (type));\n   add_abstract_origin_attribute (type_die, type);\n }\n@@ -6371,7 +6372,7 @@ gen_enumeration_type_die (type, is_complete, context_die)\n   if (type_die == NULL)\n     {\n       type_die = new_die (DW_TAG_enumeration_type,\n-\t\t\t  scope_die_for_type (type, context_die));\n+\t\t\t  scope_die_for (type, context_die));\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n     }\n@@ -6599,7 +6600,8 @@ gen_subprogram_die (decl, context_die)\n     }\n   else\n     {\n-      subr_die = new_die (DW_TAG_subprogram, context_die);\n+      subr_die = new_die (DW_TAG_subprogram,\n+\t\t\t  scope_die_for (decl, context_die));\n       if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n \t{\n \t  add_AT_flag (subr_die, DW_AT_external, 1);\n@@ -6686,6 +6688,7 @@ gen_subprogram_die (decl, context_die)\n      FUNCTION_TYPE node ends with a void_type_node then there should *not* be \n      an ellipsis at the end.  */\n \n+  push_decl_scope (decl);\n   /* In the case where we are describing a mere function declaration, all we\n      need to do here (and all we *can* do here) is to describe the *types* of \n      its formal parameters.  */\n@@ -6777,6 +6780,7 @@ gen_subprogram_die (decl, context_die)\n \t}\n #endif\n     }\n+  pop_decl_scope ();\n }\n \n /* Generate a DIE to represent a declared data object.  */\n@@ -6912,13 +6916,16 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n     {\n       register dw_die_ref subr_die = new_die (DW_TAG_inlined_subroutine,\n \t\t\t\t\t      context_die);\n+      register tree decl = block_ultimate_origin (stmt);\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-      add_abstract_origin_attribute (subr_die, block_ultimate_origin (stmt));\n+      add_abstract_origin_attribute (subr_die, decl);\n       sprintf (label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label);\n       sprintf (label, BLOCK_END_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label);\n+      push_decl_scope (decl);\n       decls_for_scope (stmt, subr_die, depth);\n+      pop_decl_scope ();\n       current_function_has_inlines = 1;\n     }\n }\n@@ -6944,50 +6951,46 @@ gen_field_die (decl, context_die)\n   add_data_member_location_attribute (decl_die, decl);\n }\n \n-/* Don't generate either pointer_type DIEs or reference_type DIEs.\n-   Use modified type DIE's instead.\n+#if 0\n+/* Don't generate either pointer_type DIEs or reference_type DIEs here.\n+   Use modified_type_die instead.\n    We keep this code here just in case these types of DIEs may be needed to\n    represent certain things in other languages (e.g. Pascal) someday.  */\n static void\n gen_pointer_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die = lookup_type_die (type);\n-  if (ptr_die)\n-    return;\n-  ptr_die = new_die (DW_TAG_pointer_type, context_die);\n+  register dw_die_ref ptr_die = new_die (DW_TAG_pointer_type, context_die);\n   equate_type_number_to_die (type, ptr_die);\n   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n+  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n }\n \n-/* Don't generate either pointer_type DIEs or reference_type DIEs.\n-   Use modified type DIE's instead.\n+/* Don't generate either pointer_type DIEs or reference_type DIEs here.\n+   Use modified_type_die instead.\n    We keep this code here just in case these types of DIEs may be needed to\n    represent certain things in other languages (e.g. Pascal) someday.  */\n static void\n gen_reference_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ref_die = lookup_type_die (type);\n-  if (ref_die)\n-    return;\n-  ref_die = new_die (DW_TAG_reference_type, context_die);\n+  register dw_die_ref ref_die = new_die (DW_TAG_reference_type, context_die);\n   equate_type_number_to_die (type, ref_die);\n   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);\n+  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n }\n+#endif\n \n /* Generate a DIE for a pointer to a member type.  */\n static void\n gen_ptr_to_mbr_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die = lookup_type_die (type);\n-  if (ptr_die)\n-    return;\n-  ptr_die = new_die (DW_TAG_ptr_to_member_type, context_die);\n+  register dw_die_ref ptr_die = new_die\n+    (DW_TAG_ptr_to_member_type, context_die);\n   equate_type_number_to_die (type, ptr_die);\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n \t\t  lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n@@ -7056,11 +7059,8 @@ gen_string_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = lookup_type_die (type);\n-  if (type_die)\n-    return;\n-  type_die = new_die (DW_TAG_string_type,\n-\t\t      scope_die_for_type (type, context_die));\n+  register dw_die_ref type_die = new_die\n+    (DW_TAG_string_type, scope_die_for (type, context_die));\n   equate_type_number_to_die (type, type_die);\n \n   /* Fudge the string length attribute for now.  */\n@@ -7140,7 +7140,7 @@ gen_struct_or_union_type_die (type, is_complete, context_die)\n     {\n       type_die = new_die (TREE_CODE (type) == RECORD_TYPE\n \t\t\t  ? DW_TAG_structure_type : DW_TAG_union_type,\n-\t\t\t  scope_die_for_type (type, context_die));\n+\t\t\t  scope_die_for (type, context_die));\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n     }\n@@ -7159,7 +7159,9 @@ gen_struct_or_union_type_die (type, is_complete, context_die)\n       if (TYPE_SIZE (type))\n \t{\n \t  add_byte_size_attribute (type_die, type);\n+\t  push_decl_scope (type);\n \t  gen_member_die (type, type_die);\n+\t  pop_decl_scope ();\n \t}\n     }\n   else\n@@ -7173,10 +7175,7 @@ gen_subroutine_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register tree return_type = TREE_TYPE (type);\n-  register dw_die_ref subr_die = lookup_type_die (type);\n-  if (subr_die)\n-    return;\n-  subr_die = new_die (DW_TAG_subroutine_type, context_die);\n+  register dw_die_ref subr_die = new_die (DW_TAG_subroutine_type, context_die);\n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n   add_type_attribute (subr_die, return_type, 0, 0, context_die);\n@@ -7191,8 +7190,7 @@ gen_typedef_die (decl, context_die)\n {\n   register tree origin = decl_ultimate_origin (decl);\n   register dw_die_ref type_die;\n-  type_die = new_die (DW_TAG_typedef,\n-\t\t      scope_die_for_type (decl, context_die));\n+  type_die = new_die (DW_TAG_typedef, scope_die_for (decl, context_die));\n   if (origin != NULL)\n     {\n       add_abstract_origin_attribute (type_die, origin);\n@@ -7562,7 +7560,6 @@ gen_decl_die (decl, context_die)\n       return;\n     }\n \n-  push_decl_scope (DECL_CONTEXT (decl));\n   switch (TREE_CODE (decl))\n     {\n     case CONST_DECL:\n@@ -7680,7 +7677,6 @@ gen_decl_die (decl, context_die)\n     default:\n       abort ();\n     }\n-  pop_decl_scope ();\n }\n \f\n /***************** Debug Information Generation Hooks ***********************/"}]}