{"sha": "d30673031579bf894eb1dc702ea892e0a32c0741", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMwNjczMDMxNTc5YmY4OTRlYjFkYzcwMmVhODkyZTBhMzJjMDc0MQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-09-11T21:30:07Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2006-09-11T21:30:07Z"}, "message": "re PR target/28672 (Gcc went into infinite loop when building libstdc++)\n\n2006-09-11  Alexandre Oliva  <aoliva@redhat.com>\n\n\tPR target/28672\n\t* var-tracking.c (dump_dataflow_set): Start dumping at\n\tregister zero.\n\t(clobber_variable_part): Kill only the variable part in\n\tregisters holding it, leaving other variables alone.\n\nFrom-SVN: r116859", "tree": {"sha": "69d583e945cfa0140121097b07485cc8d04a1563", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69d583e945cfa0140121097b07485cc8d04a1563"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d30673031579bf894eb1dc702ea892e0a32c0741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30673031579bf894eb1dc702ea892e0a32c0741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d30673031579bf894eb1dc702ea892e0a32c0741", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30673031579bf894eb1dc702ea892e0a32c0741/comments", "author": null, "committer": null, "parents": [{"sha": "b7886f1470bf8748ad22464177463f19f6376a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7886f1470bf8748ad22464177463f19f6376a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7886f1470bf8748ad22464177463f19f6376a19"}], "stats": {"total": 38, "additions": 35, "deletions": 3}, "files": [{"sha": "b1a92ec5edce985e4e7cbfa0149301eaef78576b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30673031579bf894eb1dc702ea892e0a32c0741/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30673031579bf894eb1dc702ea892e0a32c0741/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d30673031579bf894eb1dc702ea892e0a32c0741", "patch": "@@ -1,3 +1,11 @@\n+2006-09-11  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR target/28672\n+\t* var-tracking.c (dump_dataflow_set): Start dumping at\n+\tregister zero.\n+\t(clobber_variable_part): Kill only the variable part in\n+\tregisters holding it, leaving other variables alone.\n+\n 2006-09-11  Josh Triplett  <josh@freedesktop.org>\n \n \t* doc/extend.texi (Other Builtins): Actually use the macro"}, {"sha": "815facae1820e47b06f0c10b7aac1e6ecd781f7d", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30673031579bf894eb1dc702ea892e0a32c0741/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30673031579bf894eb1dc702ea892e0a32c0741/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d30673031579bf894eb1dc702ea892e0a32c0741", "patch": "@@ -1960,7 +1960,7 @@ dump_dataflow_set (dataflow_set *set)\n \n   fprintf (dump_file, \"Stack adjustment: \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t   set->stack_adjust);\n-  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       if (set->regs[i])\n \t{\n@@ -2212,8 +2212,32 @@ clobber_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t  for (node = next; node; node = next)\n \t    {\n \t      next = node->next;\n-\t      if (REG_P (node->loc) && node->loc != loc)\n-\t\tvar_reg_delete (set, node->loc, false);\n+\t      if (node->loc != loc)\n+\t\t{\n+\t\t  if (REG_P (node->loc))\n+\t\t    {\n+\t\t      attrs anode, anext;\n+\t\t      attrs *anextp;\n+\n+\t\t      /* Remove the variable part from the register's\n+\t\t\t list, but preserve any other variable parts\n+\t\t\t that might be regarded as live in that same\n+\t\t\t register.  */\n+\t\t      anextp = &set->regs[REGNO (node->loc)];\n+\t\t      for (anode = *anextp; anode; anode = anext)\n+\t\t\t{\n+\t\t\t  anext = anode->next;\n+\t\t\t  if (anode->decl == decl\n+\t\t\t      && anode->offset == offset)\n+\t\t\t    {\n+\t\t\t      pool_free (attrs_pool, anode);\n+\t\t\t      *anextp = anext;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  delete_variable_part (set, node->loc, decl, offset);\n+\t\t}\n \t    }\n \t}\n     }"}]}