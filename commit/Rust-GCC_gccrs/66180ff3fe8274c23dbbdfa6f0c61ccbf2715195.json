{"sha": "66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYxODBmZjNmZTgyNzRjMjNkYmJkZmE2ZjBjNjFjY2JmMjcxNTE5NQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-11-07T10:39:36Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-11-07T10:39:36Z"}, "message": "re PR target/24230 (ICE in extract_insn with altivec)\n\n2005-11-07  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR target/24230\n\n\t* config/rs6000/rs6000.c (easy_vector_splat_const, easy_vector_same,\n\tgen_easy_vector_constant_add_self): Delete.\n\t(vspltis_constant, easy_altivec_constant, gen_easy_altivec_constant):\n\tNew.\n\t(output_vec_const_move): Use gen_easy_altivec_constant.\n\t(rs6000_expand_vector_init): Do not emit a set of a VEC_DUPLICATE.\n\t* config/rs6000/predicates.md (easy_vector_constant): Reorganize tests.\n\t(easy_vector_constant_add_self): Rewritten.\n\t* config/rs6000/rs6000-protos.h (easy_vector_splat_const,\n\teasy_vector_same, gen_easy_vector_constant_add_self): Remove prototype.\n\t(easy_altivec_constant, gen_easy_altivec_constant): Add prototype.\n\ntestsuite:\n2005-11-07  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR target/24230\n\n        * gcc.target/powerpc/altivec-consts.c,\n        gcc.target/powerpc/altivec-splat.c: New testcase.\n\nFrom-SVN: r106588", "tree": {"sha": "91b6e883aabe9991ac9745b208c6eea4bdfad540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91b6e883aabe9991ac9745b208c6eea4bdfad540"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8e1f97b7ea613d9cf460f470f84525abb4e8c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e1f97b7ea613d9cf460f470f84525abb4e8c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e1f97b7ea613d9cf460f470f84525abb4e8c8b"}], "stats": {"total": 764, "additions": 601, "deletions": 163}, "files": [{"sha": "0fce2cf381fa2e66288a535c8944f84356ee0620", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -1,5 +1,25 @@\n 2005-11-07  Paolo Bonzini  <bonzini@gnu.org>\n \n+\tPR target/24230\n+\n+\t* config/rs6000/rs6000.c (easy_vector_splat_const, easy_vector_same,\n+\tgen_easy_vector_constant_add_self): Delete.\n+\t(vspltis_constant, easy_altivec_constant, gen_easy_altivec_constant):\n+\tNew.\n+\t(output_vec_const_move): Use gen_easy_altivec_constant.\n+\t(rs6000_expand_vector_init): Do not emit a set of a VEC_DUPLICATE.\n+\t* config/rs6000/predicates.md (easy_vector_constant): Reorganize tests.\n+\t(easy_vector_constant_add_self): Rewritten.\n+\t* config/rs6000/rs6000-protos.h (easy_vector_splat_const,\n+\teasy_vector_same, gen_easy_vector_constant_add_self): Remove prototype.\n+\t(easy_altivec_constant, gen_easy_altivec_constant): Add prototype.\n+\t* config/rs6000/altivec.md (easy_vector_constant_add_self splitters):\n+\tMacroize and adjust for the other changes.\n+\n+2005-11-07  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR c/24599\n+\n         * c-typeck.c (build_c_cast): Try using a shared constant, and see\n         if TREE_OVERFLOW or TREE_CONSTANT_OVERFLOW really changed.\n "}, {"sha": "26ec2be5cae93e13607dce831af267a4b2364dfa", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -201,18 +201,6 @@\n   rs6000_split_multireg_move (operands[0], operands[1]); DONE;\n })\n \n-(define_split\n-  [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"\")\n-\t(match_operand:V4SI 1 \"easy_vector_constant_add_self\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))\n-   (set (match_dup 0)\n-\t(plus:V4SI (match_dup 0)\n-\t\t   (match_dup 0)))]\n-{ \n-  operands[3] = gen_easy_vector_constant_add_self (operands[1]);\n-})    \n-\n (define_split\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V8HI 1 \"input_operand\" \"\"))]\n@@ -221,18 +209,6 @@\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n-(define_split\n-  [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"\")\n-\t(match_operand:V8HI 1 \"easy_vector_constant_add_self\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))\n-   (set (match_dup 0)\n-\t(plus:V8HI (match_dup 0)\n-\t\t   (match_dup 0)))]\n-{\n-  operands[3] = gen_easy_vector_constant_add_self (operands[1]);\n-})\n-\n (define_split\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V16QI 1 \"input_operand\" \"\"))]\n@@ -241,18 +217,6 @@\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n-(define_split\n-  [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"\")\n-\t(match_operand:V16QI 1 \"easy_vector_constant_add_self\" \"\"))]\n-  \"TARGET_ALTIVEC && reload_completed\"\n-  [(set (match_dup 0) (match_dup 3))\n-   (set (match_dup 0)\n-\t(plus:V16QI (match_dup 0)\n-\t\t   (match_dup 0)))]\n-{\n-  operands[3] = gen_easy_vector_constant_add_self (operands[1]);\n-})\n-\n (define_split\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SF 1 \"input_operand\" \"\"))]\n@@ -263,6 +227,29 @@\n   rs6000_split_multireg_move (operands[0], operands[1]); DONE;\n })\n \n+(define_split\n+  [(set (match_operand:VI 0 \"altivec_register_operand\" \"\")\n+\t(match_operand:VI 1 \"easy_vector_constant_add_self\" \"\"))]\n+  \"TARGET_ALTIVEC && reload_completed\"\n+  [(set (match_dup 0) (match_dup 3))\n+   (set (match_dup 0) (plus:VI (match_dup 0)\n+\t\t\t       (match_dup 0)))]\n+{\n+  rtx dup = gen_easy_altivec_constant (operands[1]);\n+  rtx const_vec;\n+\n+  /* Divide the operand of the resulting VEC_DUPLICATE, and use\n+     simplify_rtx to make a CONST_VECTOR.  */\n+  XEXP (dup, 0) = simplify_const_binary_operation (ASHIFTRT, QImode,\n+\t\t\t\t\t\t   XEXP (dup, 0), const1_rtx);\n+  const_vec = simplify_rtx (dup);\n+\n+  if (GET_MODE (const_vec) == <MODE>mode)\n+    operands[3] = const_vec;\n+  else\n+    operands[3] = gen_lowpart (<MODE>mode, const_vec);\n+})\n+\n (define_insn \"get_vrsave_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(unspec:SI [(reg:SI 109)] UNSPEC_GET_VRSAVE))]"}, {"sha": "4ce00b0674d506fe2b91656d9415cfc3dc64e4f7", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -271,59 +271,55 @@\n (define_predicate \"easy_vector_constant\"\n   (match_code \"const_vector\")\n {\n-  int cst, cst2;\n-\n-  if (!TARGET_ALTIVEC && !TARGET_SPE)\n-    return 0;\n-\n-  if (zero_constant (op, mode)\n-      && ((TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (mode))\n-\t  || (TARGET_SPE && SPE_VECTOR_MODE (mode))))\n-    return 1;\n-\n-  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n-    return 0;\n-\n-  if (TARGET_SPE && mode == V1DImode)\n-    return 0;\n+  if (ALTIVEC_VECTOR_MODE (mode))\n+    {\n+      if (zero_constant (op, mode))\n+        return true;\n+      if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+        return false;\n \n-  cst  = INTVAL (CONST_VECTOR_ELT (op, 0));\n-  cst2 = INTVAL (CONST_VECTOR_ELT (op, 1));\n-\n-  /* Limit SPE vectors to 15 bits signed.  These we can generate with:\n-       li r0, CONSTANT1\n-       evmergelo r0, r0, r0\n-       li r0, CONSTANT2\n-\n-     I don't know how efficient it would be to allow bigger constants,\n-     considering we'll have an extra 'ori' for every 'li'.  I doubt 5\n-     instructions is better than a 64-bit memory load, but I don't\n-     have the e500 timing specs.  */\n-  if (TARGET_SPE && mode == V2SImode\n-      && cst  >= -0x7fff && cst <= 0x7fff\n-      && cst2 >= -0x7fff && cst2 <= 0x7fff)\n-    return 1;\n+      return easy_altivec_constant (op, mode);\n+    }\n \n-  if (TARGET_ALTIVEC\n-      && easy_vector_same (op, mode))\n+  if (SPE_VECTOR_MODE (mode))\n     {\n-      cst = easy_vector_splat_const (cst, mode);\n-      if (EASY_VECTOR_15_ADD_SELF (cst)\n-\t  || EASY_VECTOR_15 (cst))\n-\treturn 1;\n+      int cst, cst2;\n+      if (zero_constant (op, mode))\n+\treturn true;\n+      if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+        return false;\n+\n+      /* Limit SPE vectors to 15 bits signed.  These we can generate with:\n+\t   li r0, CONSTANT1\n+\t   evmergelo r0, r0, r0\n+\t   li r0, CONSTANT2\n+\n+\t I don't know how efficient it would be to allow bigger constants,\n+\t considering we'll have an extra 'ori' for every 'li'.  I doubt 5\n+\t instructions is better than a 64-bit memory load, but I don't\n+\t have the e500 timing specs.  */\n+      if (mode == V2SImode)\n+\t{\n+\t  cst  = INTVAL (CONST_VECTOR_ELT (op, 0));\n+\t  cst2 = INTVAL (CONST_VECTOR_ELT (op, 1));\n+\t  return cst  >= -0x7fff && cst <= 0x7fff\n+\t         && cst2 >= -0x7fff && cst2 <= 0x7fff;\n+\t}\n     }\n-  return 0;\n+\n+  return false;\n })\n \n ;; Same as easy_vector_constant but only for EASY_VECTOR_15_ADD_SELF.\n (define_predicate \"easy_vector_constant_add_self\"\n   (and (match_code \"const_vector\")\n        (and (match_test \"TARGET_ALTIVEC\")\n-\t    (and (match_test \"easy_vector_same (op, mode)\")\n-\t\t (match_test \"EASY_VECTOR_15_ADD_SELF\n-\t\t \t\t(easy_vector_splat_const\n-\t\t\t\t  (INTVAL (CONST_VECTOR_ELT (op, 0)),\n-\t\t\t\t   mode))\")))))\n+\t    (match_test \"easy_altivec_constant (op, mode)\")))\n+{\n+  rtx last = CONST_VECTOR_ELT (op, GET_MODE_NUNITS (mode) - 1);\n+  HOST_WIDE_INT val = (char) (INTVAL (last) & 255);\n+  return EASY_VECTOR_15_ADD_SELF (val);\n+})\n \n ;; Return 1 if operand is constant zero (scalars and vectors).\n (define_predicate \"zero_constant\""}, {"sha": "9911e503fa15a950176da0534ba4df0bd68392f4", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -32,8 +32,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int, int);\n extern void rs6000_va_start (tree, rtx);\n #endif /* TREE_CODE */\n \n-extern int easy_vector_same (rtx, enum machine_mode);\n-extern int easy_vector_splat_const (int, enum machine_mode);\n+extern bool easy_altivec_constant (rtx, enum machine_mode);\n extern bool macho_lo_sum_memory_operand (rtx, enum machine_mode);\n extern int num_insns_constant (rtx, enum machine_mode);\n extern int num_insns_constant_wide (HOST_WIDE_INT);\n@@ -48,7 +47,7 @@ extern bool rs6000_legitimate_small_data_p (enum machine_mode, rtx);\n \n extern rtx rs6000_got_register (rtx);\n extern rtx find_addr_reg (rtx);\n-extern rtx gen_easy_vector_constant_add_self (rtx);\n+extern rtx gen_easy_altivec_constant (rtx);\n extern const char *output_vec_const_move (rtx *);\n extern void rs6000_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);"}, {"sha": "f9b46e358ec02b30254b182f0fc7036fab08bbbc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 138, "deletions": 80, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -2042,73 +2042,150 @@ num_insns_constant (rtx op, enum machine_mode mode)\n     }\n }\n \n-/* Returns the constant for the splat instruction, if exists.  */\n \n-int\n-easy_vector_splat_const (int cst, enum machine_mode mode)\n+/* Return true if OP can be synthesized with a particular vspltisb, vspltish \n+   or vspltisw instruction.  OP is a CONST_VECTOR.  Which instruction is used\n+   depends on STEP and COPIES, one of which will be 1.  If COPIES > 1,\n+   all items are set to the same value and contain COPIES replicas of the\n+   vsplt's operand; if STEP > 1, one in STEP elements is set to the vsplt's\n+   operand and the others are set to the value of the operand's msb.  */\n+\n+static bool\n+vspltis_constant (rtx op, unsigned step, unsigned copies)\n {\n-  switch (mode)\n+  enum machine_mode mode = GET_MODE (op);\n+  enum machine_mode inner = GET_MODE_INNER (mode);\n+\n+  unsigned i;\n+  unsigned nunits = GET_MODE_NUNITS (mode);\n+  unsigned bitsize = GET_MODE_BITSIZE (inner);\n+  unsigned mask = GET_MODE_MASK (inner);\n+\n+  rtx last = CONST_VECTOR_ELT (op, nunits - 1);\n+  HOST_WIDE_INT val = INTVAL (last);\n+  HOST_WIDE_INT splat_val = val;\n+  HOST_WIDE_INT msb_val = val > 0 ? 0 : -1;\n+\n+  /* Construct the value to be splatted, if possible.  If not, return 0.  */\n+  for (i = 2; i <= copies; i *= 2)\n     {\n-    case V4SImode:\n-      if (EASY_VECTOR_15 (cst)\n-\t  || EASY_VECTOR_15_ADD_SELF (cst))\n-\treturn cst;\n-      if ((cst & 0xffff) != ((cst >> 16) & 0xffff))\n-\tbreak;\n-      cst = cst >> 16;\n-      /* Fall thru */\n+      HOST_WIDE_INT small_val;\n+      bitsize /= 2;\n+      small_val = splat_val >> bitsize;\n+      mask >>= bitsize;\n+      if (splat_val != ((small_val << bitsize) | (small_val & mask)))\n+\treturn false;\n+      splat_val = small_val;\n+    }\n \n-    case V8HImode:\n-      if (EASY_VECTOR_15 (cst)\n-\t  || EASY_VECTOR_15_ADD_SELF (cst))\n-\treturn cst;\n-      if ((cst & 0xff) != ((cst >> 8) & 0xff))\n-\tbreak;\n-      cst = cst >> 8;\n-      /* Fall thru */\n+  /* Check if SPLAT_VAL can really be the operand of a vspltis[bhw].  */\n+  if (EASY_VECTOR_15 (splat_val))\n+    ;\n \n-    case V16QImode:\n-      if (EASY_VECTOR_15 (cst)\n-\t  || EASY_VECTOR_15_ADD_SELF (cst))\n-\treturn cst;\n-    default:\n-      break;\n+  /* Also check if we can splat, and then add the result to itself.  Do so if\n+     the value is positive, of if the splat instruction is using OP's mode;\n+     for splat_val < 0, the splat and the add should use the same mode.  */\n+  else if (EASY_VECTOR_15_ADD_SELF (splat_val)\n+           && (splat_val >= 0 || (step == 1 && copies == 1)))\n+    ;\n+\n+  else\n+    return false;\n+\n+  /* Check if VAL is present in every STEP-th element, and the\n+     other elements are filled with its most significant bit.  */\n+  for (i = 0; i < nunits - 1; ++i)\n+    {\n+      HOST_WIDE_INT desired_val;\n+      if (((i + 1) & (step - 1)) == 0)\n+\tdesired_val = val;\n+      else\n+\tdesired_val = msb_val;\n+\n+      if (desired_val != INTVAL (CONST_VECTOR_ELT (op, i)))\n+\treturn false;\n     }\n-  return 0;\n+\n+  return true;\n }\n \n-/* Return nonzero if all elements of a vector have the same value.  */\n \n-int\n-easy_vector_same (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+/* Return true if OP is of the given MODE and can be synthesized \n+   with a vspltisb, vspltish or vspltisw.  */\n+\n+bool\n+easy_altivec_constant (rtx op, enum machine_mode mode)\n {\n-  int units, i, cst;\n+  unsigned step, copies;\n \n-  units = CONST_VECTOR_NUNITS (op);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+  else if (mode != GET_MODE (op))\n+    return false;\n \n-  cst = INTVAL (CONST_VECTOR_ELT (op, 0));\n-  for (i = 1; i < units; ++i)\n-    if (INTVAL (CONST_VECTOR_ELT (op, i)) != cst)\n-      break;\n-  if (i == units && easy_vector_splat_const (cst, mode))\n-    return 1;\n-  return 0;\n+  /* Start with a vspltisw.  */\n+  step = GET_MODE_NUNITS (mode) / 4;\n+  copies = 1;\n+\n+  if (vspltis_constant (op, step, copies))\n+    return true;\n+\n+  /* Then try with a vspltish.  */\n+  if (step == 1)\n+    copies <<= 1;\n+  else\n+    step >>= 1;\n+\n+  if (vspltis_constant (op, step, copies))\n+    return true;\n+\n+  /* And finally a vspltisb.  */\n+  if (step == 1)\n+    copies <<= 1;\n+  else\n+    step >>= 1;\n+\n+  if (vspltis_constant (op, step, copies))\n+    return true;\n+\n+  return false;\n }\n \n-/* Generate easy_vector_constant out of a easy_vector_constant_add_self.  */\n+/* Generate a VEC_DUPLICATE representing a vspltis[bhw] instruction whose\n+   result is OP.  Abort if it is not possible.  */\n \n rtx\n-gen_easy_vector_constant_add_self (rtx op)\n+gen_easy_altivec_constant (rtx op)\n {\n-  int i, units;\n-  rtvec v;\n-  units = GET_MODE_NUNITS (GET_MODE (op));\n-  v = rtvec_alloc (units);\n+  enum machine_mode mode = GET_MODE (op);\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtx last = CONST_VECTOR_ELT (op, nunits - 1);\n+  unsigned step = nunits / 4;\n+  unsigned copies = 1;\n+\n+  /* Start with a vspltisw.  */\n+  if (vspltis_constant (op, step, copies))\n+    return gen_rtx_VEC_DUPLICATE (V4SImode, gen_lowpart (SImode, last));\n+\n+  /* Then try with a vspltish.  */\n+  if (step == 1)\n+    copies <<= 1;\n+  else\n+    step >>= 1;\n+\n+  if (vspltis_constant (op, step, copies))\n+    return gen_rtx_VEC_DUPLICATE (V8HImode, gen_lowpart (HImode, last));\n+\n+  /* And finally a vspltisb.  */\n+  if (step == 1)\n+    copies <<= 1;\n+  else\n+    step >>= 1;\n+\n+  if (vspltis_constant (op, step, copies))\n+    return gen_rtx_VEC_DUPLICATE (V16QImode, gen_lowpart (QImode, last));\n \n-  for (i = 0; i < units; i++)\n-    RTVEC_ELT (v, i) =\n-      GEN_INT (INTVAL (CONST_VECTOR_ELT (op, i)) >> 1);\n-  return gen_rtx_raw_CONST_VECTOR (GET_MODE (op), v);\n+  gcc_unreachable ();\n }\n \n const char *\n@@ -2127,44 +2204,26 @@ output_vec_const_move (rtx *operands)\n \n   if (TARGET_ALTIVEC)\n     {\n+      rtx splat_vec;\n       if (zero_constant (vec, mode))\n \treturn \"vxor %0,%0,%0\";\n \n-      gcc_assert (easy_vector_constant (vec, mode));\n+      splat_vec = gen_easy_altivec_constant (vec);\n+      gcc_assert (GET_CODE (splat_vec) == VEC_DUPLICATE);\n+      operands[1] = XEXP (splat_vec, 0);\n+      if (!EASY_VECTOR_15 (INTVAL (operands[1])))\n+\treturn \"#\";\n \n-      operands[1] = GEN_INT (cst);\n-      switch (mode)\n+      switch (GET_MODE (splat_vec))\n \t{\n \tcase V4SImode:\n-\t  if (EASY_VECTOR_15 (cst))\n-\t    {\n-\t      operands[1] = GEN_INT (cst);\n-\t      return \"vspltisw %0,%1\";\n-\t    }\n-\t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n-\t    return \"#\";\n-\t  cst = cst >> 16;\n-\t  /* Fall thru */\n+\t  return \"vspltisw %0,%1\";\n \n \tcase V8HImode:\n-\t  if (EASY_VECTOR_15 (cst))\n-\t    {\n-\t      operands[1] = GEN_INT (cst);\n-\t      return \"vspltish %0,%1\";\n-\t    }\n-\t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n-\t    return \"#\";\n-\t  cst = cst >> 8;\n-\t  /* Fall thru */\n+\t  return \"vspltish %0,%1\";\n \n \tcase V16QImode:\n-\t  if (EASY_VECTOR_15 (cst))\n-\t    {\n-\t      operands[1] = GEN_INT (cst);\n-\t      return \"vspltisb %0,%1\";\n-\t    }\n-\t  else if (EASY_VECTOR_15_ADD_SELF (cst))\n-\t    return \"#\";\n+\t  return \"vspltisb %0,%1\";\n \n \tdefault:\n \t  gcc_unreachable ();\n@@ -2220,11 +2279,10 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n \t\t\t\t  gen_rtx_XOR (mode, target, target)));\n \t  return;\n \t}\n-      else if (mode != V4SFmode && easy_vector_same (vals, mode))\n+      else if (mode != V4SFmode && easy_vector_constant (vals, mode))\n \t{\n \t  /* Splat immediate.  */\n-\t  x = gen_rtx_VEC_DUPLICATE (mode, CONST_VECTOR_ELT (vals, 0));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, target, vals));\n \t  return;\n \t}\n       else if (all_same)"}, {"sha": "35843029da8ce90d105e84fb1901ebc358d7ec9b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -1689,7 +1689,8 @@ typedef struct rs6000_args\n    && !rs6000_tls_referenced_p (X))\n \n #define EASY_VECTOR_15(n) ((n) >= -16 && (n) <= 15)\n-#define EASY_VECTOR_15_ADD_SELF(n) ((n) >= 0x10 && (n) <= 0x1e && !((n) & 1))\n+#define EASY_VECTOR_15_ADD_SELF(n) (!EASY_VECTOR_15((n))\t\\\n+\t\t\t\t    && EASY_VECTOR_15((n) >> 1))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class."}, {"sha": "53cb4811078433abf9db92852a403d5b1a021c1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -1,5 +1,14 @@\n 2005-11-07  Paolo Bonzini  <bonzini@gnu.org>\n \n+\tPR target/24230\n+\n+        * gcc.target/powerpc/altivec-consts.c,\n+        gcc.target/powerpc/altivec-splat.c: New testcase.\n+\n+2005-11-07  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR c/24599\n+\n         * gcc.dg/overflow-2.c: New testcase.\n \n 2005-11-07  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "2bea3230b89a15f3cacc61143a3d28eef219082e", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-consts.c", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-consts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-consts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-consts.c?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -0,0 +1,320 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-options \"-maltivec -mabi=altivec -O2\" } */\n+\n+/* Check that \"easy\" AltiVec constants are correctly synthesized.  */\n+\n+#include \"altivec_check.h\"\n+\n+extern void abort (void);\n+\n+typedef __attribute__ ((vector_size (16))) unsigned char v16qi;\n+typedef __attribute__ ((vector_size (16))) unsigned short v8hi;\n+typedef __attribute__ ((vector_size (16))) unsigned int v4si;\n+\n+char w[16] __attribute__((aligned(16)));\n+ \n+\f\n+/* Emulate the vspltis? instructions on a 16-byte array of chars.  */\n+\n+void vspltisb (char *v, char val)\n+{\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    v[i] = val;\n+}\n+\n+void vspltish (char *v, char val)\n+{\n+  int i;\n+  for (i = 0; i < 16; i += 2)\n+    v[i] = val >> 7, v[i + 1] = val;\n+}\n+\n+void vspltisw (char *v, char val)\n+{\n+  int i;\n+  for (i = 0; i < 16; i += 4)\n+    v[i] = v[i + 1] = v[i + 2] = val >> 7, v[i + 3] = val;\n+}\n+\n+\f\n+/* Use three different check functions for each mode-instruction pair.\n+   The callers have no typecasting and no addressable vectors, to make\n+   the test more robust.  */\n+\n+void __attribute__ ((noinline)) check_v16qi (v16qi v1, char *v2)\n+{\n+  if (memcmp (&v1, v2, 16))\n+    abort ();\n+}\n+\n+void __attribute__ ((noinline)) check_v8hi (v8hi v1, char *v2)\n+{\n+  if (memcmp (&v1, v2, 16))\n+    abort ();\n+}\n+\n+void __attribute__ ((noinline)) check_v4si (v4si v1, char *v2)\n+{\n+  if (memcmp (&v1, v2, 16))\n+    abort ();\n+}\n+\n+\f\n+/* V16QI tests.  */\n+\n+void v16qi_vspltisb ()\n+{\n+  v16qi v = { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };\n+  vspltisb (w, 15);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltisb_neg ()\n+{\n+  v16qi v = { -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5 };\n+  vspltisb (w, -5);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltisb_addself ()\n+{\n+  v16qi v = { 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 };\n+  vspltisb (w, 30);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltisb_neg_addself ()\n+{\n+  v16qi v = { -24, -24, -24, -24, -24, -24, -24, -24, -24, -24, -24, -24, -24, -24, -24, -24 };\n+  vspltisb (w, -24);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltish ()\n+{\n+  v16qi v = { 0, 15, 0, 15, 0, 15, 0, 15, 0, 15, 0, 15, 0, 15, 0, 15 };\n+  vspltish (w, 15);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltish_addself ()\n+{\n+  v16qi v = { 0, 30, 0, 30, 0, 30, 0, 30, 0, 30, 0, 30, 0, 30, 0, 30 };\n+  vspltish (w, 30);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltish_neg ()\n+{\n+  v16qi v = { -1, -5, -1, -5, -1, -5, -1, -5, -1, -5, -1, -5, -1, -5, -1, -5 };\n+  vspltish (w, -5);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltisw ()\n+{\n+  v16qi v = { 0, 0, 0, 15, 0, 0, 0, 15, 0, 0, 0, 15, 0, 0, 0, 15 };\n+  vspltisw (w, 15);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltisw_addself ()\n+{\n+  v16qi v = { 0, 0, 0, 30, 0, 0, 0, 30, 0, 0, 0, 30, 0, 0, 0, 30 };\n+  vspltisw (w, 30);\n+  check_v16qi (v, w);\n+}\n+\n+void v16qi_vspltisw_neg ()\n+{\n+  v16qi v = { -1, -1, -1, -5, -1, -1, -1, -5, -1, -1, -1, -5, -1, -1, -1, -5 };\n+  vspltisw (w, -5);\n+  check_v16qi (v, w);\n+}\n+\n+\f\n+/* V8HI tests. */\n+\n+void v8hi_vspltisb ()\n+{\n+  v8hi v = { 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F, 0x0F0F };\n+  vspltisb (w, 15);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltisb_addself ()\n+{\n+  v8hi v = { 0x1E1E, 0x1E1E, 0x1E1E, 0x1E1E, 0x1E1E, 0x1E1E, 0x1E1E, 0x1E1E };\n+  vspltisb (w, 30);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltisb_neg ()\n+{\n+  v8hi v = { 0xFBFB, 0xFBFB, 0xFBFB, 0xFBFB, 0xFBFB, 0xFBFB, 0xFBFB, 0xFBFB };\n+  vspltisb (w, -5);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltish ()\n+{\n+  v8hi v = { 15, 15, 15, 15, 15, 15, 15, 15 };\n+  vspltish (w, 15);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltish_neg ()\n+{\n+  v8hi v = { -5, -5, -5, -5, -5, -5, -5, -5 };\n+  vspltish (w, -5);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltish_addself ()\n+{\n+  v8hi v = { 30, 30, 30, 30, 30, 30, 30, 30 };\n+  vspltish (w, 30);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltish_neg_addself ()\n+{\n+  v8hi v = { -24, -24, -24, -24, -24, -24, -24, -24 };\n+  vspltish (w, -24);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltisw ()\n+{\n+  v8hi v = { 0, 15, 0, 15, 0, 15, 0, 15 };\n+  vspltisw (w, 15);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltisw_addself ()\n+{\n+  v8hi v = { 0, 30, 0, 30, 0, 30, 0, 30 };\n+  vspltisw (w, 30);\n+  check_v8hi (v, w);\n+}\n+\n+void v8hi_vspltisw_neg ()\n+{\n+  v8hi v = { -1, -5, -1, -5, -1, -5, -1, -5 };\n+  vspltisw (w, -5);\n+  check_v8hi (v, w);\n+}\n+\n+/* V4SI tests. */\n+\n+void v4si_vspltisb ()\n+{\n+  v4si v = { 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F };\n+  vspltisb (w, 15);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltisb_addself ()\n+{\n+  v4si v = { 0x1E1E1E1E, 0x1E1E1E1E, 0x1E1E1E1E, 0x1E1E1E1E };\n+  vspltisb (w, 30);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltisb_neg ()\n+{\n+  v4si v = { 0xFBFBFBFB, 0xFBFBFBFB, 0xFBFBFBFB, 0xFBFBFBFB };\n+  vspltisb (w, -5);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltish ()\n+{\n+  v4si v = { 0x000F000F, 0x000F000F, 0x000F000F, 0x000F000F };\n+  vspltish (w, 15);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltish_addself ()\n+{\n+  v4si v = { 0x001E001E, 0x001E001E, 0x001E001E, 0x001E001E };\n+  vspltish (w, 30);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltish_neg ()\n+{\n+  v4si v = { 0xFFFBFFFB, 0xFFFBFFFB, 0xFFFBFFFB, 0xFFFBFFFB };\n+  vspltish (w, -5);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltisw ()\n+{\n+  v4si v = { 15, 15, 15, 15 };\n+  vspltisw (w, 15);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltisw_neg ()\n+{\n+  v4si v = { -5, -5, -5, -5 };\n+  vspltisw (w, -5);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltisw_addself ()\n+{\n+  v4si v = { 30, 30, 30, 30 };\n+  vspltisw (w, 30);\n+  check_v4si (v, w);\n+}\n+\n+void v4si_vspltisw_neg_addself ()\n+{\n+  v4si v = { -24, -24, -24, -24 };\n+  vspltisw (w, -24);\n+  check_v4si (v, w);\n+}\n+\n+\f\n+\n+int main ()\n+{\n+  altivec_check ();   /* Exit if hardware doesn't support AltiVec.  */\n+\n+  v16qi_vspltisb ();\n+  v16qi_vspltisb_neg ();\n+  v16qi_vspltisb_addself ();\n+  v16qi_vspltisb_neg_addself ();\n+  v16qi_vspltish ();\n+  v16qi_vspltish_addself ();\n+  v16qi_vspltish_neg ();\n+  v16qi_vspltisw ();\n+  v16qi_vspltisw_addself ();\n+  v16qi_vspltisw_neg ();\n+\n+  v8hi_vspltisb ();\n+  v8hi_vspltisb_addself ();\n+  v8hi_vspltisb_neg ();\n+  v8hi_vspltish ();\n+  v8hi_vspltish_neg ();\n+  v8hi_vspltish_addself ();\n+  v8hi_vspltish_neg_addself ();\n+  v8hi_vspltisw ();\n+  v8hi_vspltisw_addself ();\n+  v8hi_vspltisw_neg ();\n+\n+  v4si_vspltisb ();\n+  v4si_vspltisb_addself ();\n+  v4si_vspltisb_neg ();\n+  v4si_vspltish ();\n+  v4si_vspltish_addself ();\n+  v4si_vspltish_neg ();\n+  v4si_vspltisw ();\n+  v4si_vspltisw_neg ();\n+  v4si_vspltisw_addself ();\n+  v4si_vspltisw_neg_addself ();\n+  return 0;\n+}"}, {"sha": "7e2471fd0b7b9a0a9ba1dd36977a2c3dc757ab12", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-splat.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-splat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66180ff3fe8274c23dbbdfa6f0c61ccbf2715195/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-splat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-splat.c?ref=66180ff3fe8274c23dbbdfa6f0c61ccbf2715195", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-options \"-maltivec -mabi=altivec -O2\" } */\n+\n+/* Testcase by Richard Guenther and Steven Bosscher.\n+   Check that \"easy\" AltiVec constants are correctly synthesized\n+   if they need to be reloaded.  */\n+\n+typedef __attribute__ ((vector_size (16))) unsigned char v16qi;\n+typedef __attribute__ ((vector_size (16))) unsigned short v8hi;\n+typedef __attribute__ ((vector_size (16))) unsigned int v4si;\n+\n+#define REGLIST\t\t\t\t\t\t\t\t\\\n+  \"77\",  \"78\",  \"79\",  \"80\",  \"81\",  \"82\",  \"83\",  \"84\",  \"85\",  \"86\",\t\\\n+  \"87\",  \"88\",  \"89\",  \"90\",  \"91\",  \"92\",  \"93\",  \"94\",  \"95\",  \"96\",\t\\\n+  \"97\",  \"98\",  \"99\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\",\t\\\n+ \"107\", \"108\"\n+\n+\n+#define TEST(a, result, b)\t\t\t\t\\\n+  void a##_##b (int h)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    volatile a tmp;\t\t\t\t\t\\\n+    while (h-- > 0)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        asm (\"\" : : : REGLIST);\t\t\t\t\\\n+        tmp = (a) (result) __builtin_altivec_##b (5);\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  void a##_##b##_neg (int h)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    volatile a tmp;\t\t\t\t\t\\\n+    while (h-- > 0)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        asm (\"\" : : : REGLIST);\t\t\t\t\\\n+        tmp = (a) (result) __builtin_altivec_##b (-5);\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+TEST(v16qi, v16qi, vspltisb)\n+TEST(v16qi, v8hi, vspltish)\n+TEST(v16qi, v4si, vspltisw)\n+TEST(v8hi, v16qi, vspltisb)\n+TEST(v8hi, v8hi, vspltish)\n+TEST(v8hi, v4si, vspltisw)\n+TEST(v4si, v16qi, vspltisb)\n+TEST(v4si, v8hi, vspltish)\n+TEST(v4si, v4si, vspltisw)"}]}