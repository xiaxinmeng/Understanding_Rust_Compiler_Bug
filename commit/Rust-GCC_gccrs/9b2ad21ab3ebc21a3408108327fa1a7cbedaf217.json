{"sha": "9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "node_id": "C_kwDOANBUbNoAKDliMmFkMjFhYjNlYmMyMWEzNDA4MTA4MzI3ZmExYTdjYmVkYWYyMTc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-14T07:00:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-14T12:58:40Z"}, "message": "tree-optimization/102659 - really avoid undef overflow in if-conversion\n\nThis plugs the remaining hole of POINTER_PLUS_EXPR with undefined\noverflow.  Unfortunately we have to go through some lengths to\nnot put invariant conversions into the loop body since that confuses\nthe vectorizers gather/scatter discovery which relies on identifying\nan invariant component of plus and minus expressions.  We can\nemit those in the loop preheader but then we have to accept that\nbeing non-empty when looking for the LOOP_VECTORIZED internal\nfunction call in the vectorizer.\n\n2021-10-14  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102659\n\t* tree-if-conv.c (if_convertible_gimple_assign_stmt_p): Also\n\trewrite pointer typed undefined overflow operations.\n\t(predicate_statements): Likewise.  Make sure to emit invariant\n\tconversions in the preheader.\n\t* tree-vectorizer.c (vect_loop_vectorized_call): Look through\n\tnon-empty preheaders.\n\t* tree-data-ref.c (dr_analyze_indices): Strip useless\n\tconversions to the MEM_REF base type.", "tree": {"sha": "d68d7cfd68cb20de58c40eed4a9702a27434701d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d68d7cfd68cb20de58c40eed4a9702a27434701d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cb52980e5d5fb64a393d385923da1b51ab34606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cb52980e5d5fb64a393d385923da1b51ab34606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cb52980e5d5fb64a393d385923da1b51ab34606"}], "stats": {"total": 41, "additions": 33, "deletions": 8}, "files": [{"sha": "57bac06242fa6a427bf0390291428eb0cedd1564", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "patch": "@@ -1370,6 +1370,7 @@ dr_analyze_indices (struct indices *dri, tree ref, edge nest, loop_p loop)\n       tree op = TREE_OPERAND (ref, 0);\n       tree access_fn = analyze_scalar_evolution (loop, op);\n       access_fn = instantiate_scev (nest, loop, access_fn);\n+      STRIP_NOPS (access_fn);\n       if (TREE_CODE (access_fn) == POLYNOMIAL_CHREC)\n \t{\n \t  tree memoff = TREE_OPERAND (ref, 1);"}, {"sha": "15dcc1e2b94795677051c424c384645eb2b30cf7", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "patch": "@@ -1047,7 +1047,8 @@ if_convertible_gimple_assign_stmt_p (gimple *stmt,\n \tfprintf (dump_file, \"tree could trap...\\n\");\n       return false;\n     }\n-  else if (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+  else if ((INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t    || POINTER_TYPE_P (TREE_TYPE (lhs)))\n \t   && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs))\n \t   && arith_code_with_undefined_signed_overflow\n \t\t\t\t(gimple_assign_rhs_code (stmt)))\n@@ -2520,6 +2521,7 @@ predicate_statements (loop_p loop)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n \t  gassign *stmt = dyn_cast <gassign *> (gsi_stmt (gsi));\n+\t  tree lhs;\n \t  if (!stmt)\n \t    ;\n \t  else if (is_false_predicate (cond)\n@@ -2574,15 +2576,36 @@ predicate_statements (loop_p loop)\n \n \t      gsi_replace (&gsi, new_stmt, true);\n \t    }\n-\t  else if (INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (stmt)))\n-\t\t   && TYPE_OVERFLOW_UNDEFINED\n-\t\t\t(TREE_TYPE (gimple_assign_lhs (stmt)))\n+\t  else if (((lhs = gimple_assign_lhs (stmt)), true)\n+\t\t   && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t\t       || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t\t   && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs))\n \t\t   && arith_code_with_undefined_signed_overflow\n \t\t\t\t\t\t(gimple_assign_rhs_code (stmt)))\n \t    {\n \t      gsi_remove (&gsi, true);\n-\t      gsi_insert_seq_before (&gsi, rewrite_to_defined_overflow (stmt),\n-\t\t\t\t     GSI_LAST_NEW_STMT);\n+\t      gimple_seq stmts = rewrite_to_defined_overflow (stmt);\n+\t      bool first = true;\n+\t      for (gimple_stmt_iterator gsi2 = gsi_start (stmts);\n+\t\t   !gsi_end_p (gsi2);)\n+\t\t{\n+\t\t  gassign *stmt2 = as_a <gassign *> (gsi_stmt (gsi2));\n+\t\t  gsi_remove (&gsi2, false);\n+\t\t  /* Make sure to move invariant conversions out of the\n+\t\t     loop.  */\n+\t\t  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt2))\n+\t\t      && expr_invariant_in_loop_p (loop,\n+\t\t\t\t\t\t   gimple_assign_rhs1 (stmt2)))\n+\t\t    gsi_insert_on_edge_immediate (loop_preheader_edge (loop),\n+\t\t\t\t\t\t  stmt2);\n+\t\t  else if (first)\n+\t\t    {\n+\t\t      gsi_insert_before (&gsi, stmt2, GSI_NEW_STMT);\n+\t\t      first = false;\n+\t\t    }\n+\t\t  else\n+\t\t    gsi_insert_after (&gsi, stmt2, GSI_NEW_STMT);\n+\t\t}\n \t    }\n \t  else if (gimple_vdef (stmt))\n \t    {\n@@ -2601,7 +2624,7 @@ predicate_statements (loop_p loop)\n \t      gimple_assign_set_rhs1 (stmt, ifc_temp_var (type, rhs, &gsi));\n \t      update_stmt (stmt);\n \t    }\n-\t  tree lhs = gimple_get_lhs (gsi_stmt (gsi));\n+\t  lhs = gimple_get_lhs (gsi_stmt (gsi));\n \t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t    ssa_names.add (lhs);\n \t  gsi_next (&gsi);"}, {"sha": "4712dc6e7f907637774482a71036a0bd381c2bd2", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2ad21ab3ebc21a3408108327fa1a7cbedaf217/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=9b2ad21ab3ebc21a3408108327fa1a7cbedaf217", "patch": "@@ -852,7 +852,8 @@ vect_loop_vectorized_call (class loop *loop, gcond **cond)\n   do\n     {\n       g = last_stmt (bb);\n-      if (g)\n+      if ((g && gimple_code (g) == GIMPLE_COND)\n+\t  || !single_succ_p (bb))\n \tbreak;\n       if (!single_pred_p (bb))\n \tbreak;"}]}