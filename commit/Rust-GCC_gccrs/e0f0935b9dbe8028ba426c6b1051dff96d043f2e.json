{"sha": "e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBmMDkzNWI5ZGJlODAyOGJhNDI2YzZiMTA1MWRmZjk2ZDA0M2YyZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-04-03T03:11:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-04-03T03:11:02Z"}, "message": "re PR c++/56821 (Unable to overload with references to 'this'.)\n\n\tPR c++/56821\n\t* mangle.c (write_function_type): Mangle ref-qualifier.\n\t(write_nested_name): Likewise.\n\t(canonicalize_for_substitution): Preserve ref-qualifier.\n\t(write_type): Likewise.\n\nFrom-SVN: r197386", "tree": {"sha": "ed1e3ac4e01777906474084ab463957914cbbe61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed1e3ac4e01777906474084ab463957914cbbe61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd541994aee8383d39920dc48fea0967fb839e6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd541994aee8383d39920dc48fea0967fb839e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd541994aee8383d39920dc48fea0967fb839e6c"}], "stats": {"total": 80, "additions": 76, "deletions": 4}, "files": [{"sha": "68bc51195cc798c4f6944ddd1f82c937b75e7ac9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "patch": "@@ -1,5 +1,11 @@\n 2013-04-02  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/56821\n+\t* mangle.c (write_function_type): Mangle ref-qualifier.\n+\t(write_nested_name): Likewise.\n+\t(canonicalize_for_substitution): Preserve ref-qualifier.\n+\t(write_type): Likewise.\n+\n \tPR c++/34949\n \t* decl.c (begin_destructor_body): Clobber the object in a cleanup.\n "}, {"sha": "4e68c51e1363d727021baec1f4dc64c5866c6314", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "patch": "@@ -350,6 +350,7 @@ canonicalize_for_substitution (tree node)\n       && TYPE_CANONICAL (node) != node\n       && TYPE_MAIN_VARIANT (node) != node)\n     {\n+      tree orig = node;\n       /* Here we want to strip the topmost typedef only.\n          We need to do that so is_std_substitution can do proper\n          name matching.  */\n@@ -361,6 +362,9 @@ canonicalize_for_substitution (tree node)\n       else\n \tnode = cp_build_qualified_type (TYPE_MAIN_VARIANT (node),\n \t\t\t\t\tcp_type_quals (node));\n+      if (TREE_CODE (node) == FUNCTION_TYPE\n+\t  || TREE_CODE (node) == METHOD_TYPE)\n+\tnode = build_ref_qualified_type (node, type_memfn_rqual (orig));\n     }\n   return node;\n }\n@@ -904,9 +908,11 @@ write_unscoped_template_name (const tree decl)\n \n /* Write the nested name, including CV-qualifiers, of DECL.\n \n-   <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E\n-\t\t ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n+   <nested-name> ::= N [<CV-qualifiers>] [<ref-qualifier>] <prefix> <unqualified-name> E\n+\t\t ::= N [<CV-qualifiers>] [<ref-qualifier>] <template-prefix> <template-args> E\n \n+   <ref-qualifier> ::= R # & ref-qualifier\n+                   ::= O # && ref-qualifier\n    <CV-qualifiers> ::= [r] [V] [K]  */\n \n static void\n@@ -926,6 +932,13 @@ write_nested_name (const tree decl)\n \twrite_char ('V');\n       if (DECL_CONST_MEMFUNC_P (decl))\n \twrite_char ('K');\n+      if (FUNCTION_REF_QUALIFIED (TREE_TYPE (decl)))\n+\t{\n+\t  if (FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (decl)))\n+\t    write_char ('O');\n+\t  else\n+\t    write_char ('R');\n+\t}\n     }\n \n   /* Is this a template instance?  */\n@@ -1880,7 +1893,13 @@ write_type (tree type)\n        mangle the unqualified type.  The recursive call is needed here\n        since both the qualified and unqualified types are substitution\n        candidates.  */\n-    write_type (TYPE_MAIN_VARIANT (type));\n+    {\n+      tree t = TYPE_MAIN_VARIANT (type);\n+      if (TREE_CODE (t) == FUNCTION_TYPE\n+\t  || TREE_CODE (t) == METHOD_TYPE)\n+\tt = build_ref_qualified_type (t, type_memfn_rqual (type));\n+      write_type (t);\n+    }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     /* It is important not to use the TYPE_MAIN_VARIANT of TYPE here\n        so that the cv-qualification of the element type is available\n@@ -1892,6 +1911,9 @@ write_type (tree type)\n \n       /* See through any typedefs.  */\n       type = TYPE_MAIN_VARIANT (type);\n+      if (TREE_CODE (type) == FUNCTION_TYPE\n+\t  || TREE_CODE (type) == METHOD_TYPE)\n+\ttype = build_ref_qualified_type (type, type_memfn_rqual (type_orig));\n \n       /* According to the C++ ABI, some library classes are passed the\n \t same as the scalar type of their single member and use the same\n@@ -2327,7 +2349,7 @@ write_builtin_type (tree type)\n    METHOD_TYPE.  The return type is mangled before the parameter\n    types.\n \n-     <function-type> ::= F [Y] <bare-function-type> E   */\n+     <function-type> ::= F [Y] <bare-function-type> [<ref-qualifier>] E   */\n \n static void\n write_function_type (const tree type)\n@@ -2360,6 +2382,13 @@ write_function_type (const tree type)\n      See [dcl.link].  */\n   write_bare_function_type (type, /*include_return_type_p=*/1,\n \t\t\t    /*decl=*/NULL);\n+  if (FUNCTION_REF_QUALIFIED (type))\n+    {\n+      if (FUNCTION_RVALUE_QUALIFIED (type))\n+\twrite_char ('O');\n+      else\n+\twrite_char ('R');\n+    }\n   write_char ('E');\n }\n "}, {"sha": "c6ef0792b50184be4546ceb6e4fd5fab94ee3e01", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual-mangle1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual-mangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f0935b9dbe8028ba426c6b1051dff96d043f2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual-mangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual-mangle1.C?ref=e0f0935b9dbe8028ba426c6b1051dff96d043f2e", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/56821\n+// { dg-require-effective-target c++11 }\n+\n+struct A {\n+  // { dg-final { scan-assembler \"_ZNR1A1fEv\" } }\n+  void f() & {}\n+  // { dg-final { scan-assembler \"_ZNO1A1gEv\" } }\n+  void g() && {}\n+  // { dg-final { scan-assembler \"_ZNKR1A1hEv\" } }\n+  void h() const & {}\n+};\n+\n+// { dg-final { scan-assembler \"_Z1jM1AFvvRE\" } }\n+void j(void (A::*)() &) { }\n+// { dg-final { scan-assembler \"_Z1kM1AFvvOE\" } }\n+void k(void (A::*)() &&) { }\n+// { dg-final { scan-assembler \"_Z1lM1AKFvvRE\" } }\n+void l(void (A::*)() const &) { }\n+\n+// { dg-final { scan-assembler \"_Z1mIFvvOEEvM1AT_\" } }\n+// { dg-final { scan-assembler \"_Z1mIFvvREEvM1AT_\" } }\n+// { dg-final { scan-assembler \"_Z1mIKFvvREEvM1AT_\" } }\n+template <typename T>\n+void m(T A::*) {}\n+\n+// { dg-final { scan-assembler \"_Z1nIM1AFvvOEEvT_\" } }\n+// { dg-final { scan-assembler \"_Z1nIM1AFvvREEvT_\" } }\n+// { dg-final { scan-assembler \"_Z1nIM1AKFvvREEvT_\" } }\n+template <typename T>\n+void n(T) {}\n+\n+int main()\n+{\n+  j(&A::f); k(&A::g); l(&A::h);\n+  m(&A::f); m(&A::g); m(&A::h);\n+  n(&A::f); n(&A::g); n(&A::h);\n+}"}]}