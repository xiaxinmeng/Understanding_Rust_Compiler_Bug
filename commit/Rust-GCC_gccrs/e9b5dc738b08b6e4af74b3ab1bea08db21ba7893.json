{"sha": "e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "node_id": "C_kwDOANBUbNoAKGU5YjVkYzczOGIwOGI2ZTRhZjc0YjNhYjFiZWEwOGRiMjFiYTc4OTM", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:27:19Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:27:19Z"}, "message": "Merge commit 'f80f540e394e87ac70349bad109bfc4b465c7c98^' into HEAD", "tree": {"sha": "308f90708fe3135f4b11836c05467f797f59d52c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/308f90708fe3135f4b11836c05467f797f59d52c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d4f8ef1a199460b7e7cc99b3e721eabbd97951f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4f8ef1a199460b7e7cc99b3e721eabbd97951f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4f8ef1a199460b7e7cc99b3e721eabbd97951f"}, {"sha": "982629bea416df976686467f235e09cb1a5531cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/982629bea416df976686467f235e09cb1a5531cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/982629bea416df976686467f235e09cb1a5531cc"}], "stats": {"total": 10649, "additions": 9495, "deletions": 1154}, "files": [{"sha": "a307c94d0b3cb1deb2bf715e764f3d1fd5d9da60", "filename": "contrib/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,19 @@\n+2022-12-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* filter-clang-warnings.py: Print each warning only one time.\n+\n+2022-12-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_email.py: Use PatchSet constructor\n+\tas newline argument is not supported with older unidiff\n+\tlibrary.\n+\n+2022-12-16  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* gcc-changelog/git_email.py (GitEmail:__init__): Support older\n+\tunidiff.PatchSet that do not have a newline= argument\n+\tof from_filename.\n+\n 2022-12-14  Martin Liska  <mliska@suse.cz>\n \n \t* analyze_brprob.py: Add copyright header."}, {"sha": "0973d74d8d93d731ca2793f9256bb35175fd28bb", "filename": "contrib/filter-clang-warnings.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/contrib%2Ffilter-clang-warnings.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/contrib%2Ffilter-clang-warnings.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Ffilter-clang-warnings.py?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -72,7 +72,7 @@ def skip_warning(filename, message):\n \n lines = [line.strip() for line in open(args.log)]\n total = 0\n-messages = []\n+messages = set()\n for line in lines:\n     token = ': warning: '\n     i = line.find(token)\n@@ -81,7 +81,7 @@ def skip_warning(filename, message):\n         message = line[i + len(token):]\n         if not skip_warning(location, message):\n             total += 1\n-            messages.append(line)\n+            messages.add(line)\n \n for line in sorted(messages):\n     print(line)"}, {"sha": "f3773f178ea494e033d2335c2fcefd8b1da9d3a1", "filename": "contrib/gcc-changelog/git_email.py", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/contrib%2Fgcc-changelog%2Fgit_email.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/contrib%2Fgcc-changelog%2Fgit_email.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_email.py?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -39,14 +39,15 @@\n class GitEmail(GitCommit):\n     def __init__(self, filename):\n         self.filename = filename\n-        diff = PatchSet.from_filename(filename, newline='\\n')\n         date = None\n         author = None\n         subject = ''\n \n         subject_last = False\n-        with open(self.filename, 'r') as f:\n-            lines = f.read().splitlines()\n+        with open(self.filename, newline='\\n') as f:\n+            data = f.read()\n+            diff = PatchSet(data)\n+            lines = data.splitlines()\n         lines = list(takewhile(lambda line: line != '---', lines))\n         for line in lines:\n             if line.startswith(DATE_PREFIX):"}, {"sha": "a4c26b4394d099674f67c495e69577721959f7f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,123 @@\n+2022-12-16  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.cc (pa_option_override): Disable -fstack-protector.\n+\n+2022-12-16  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\tRevert:\n+\t2022-12-15  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira-costs.cc: Include print-rtl.h.\n+\t(record_reg_classes, scan_one_insn): Add code to print debug info.\n+\t* ira.cc (ira_init_register_move_cost): Check that at least one hard\n+\treg of the mode are in the class contents to calculate the\n+\tregister move costs.\n+\n+2022-12-16  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\t* doc/invoke.texi: Document -Wstrict-flex-arrays option.\n+\t* gimple-array-bounds.cc (check_out_of_bounds_and_warn): Add two more\n+\targuments.\n+\t(array_bounds_checker::check_array_ref): Issue warnings for\n+\t-Wstrict-flex-arrays.\n+\t* opts.cc (finish_options): Issue warning for unsupported combination\n+\tof -Wstrict_flex_arrays and -fstrict-flex-array.\n+\t* tree-vrp.cc (execute_ranger_vrp): Enable the pass when\n+\twarn_strict_flex_array is true.\n+\n+2022-12-16  Palmer Dabbelt  <palmer@rivosinc.com>\n+\n+\t* config/riscv/riscv.cc (riscv_option_override): Fix comment\n+\twording.\n+\n+2022-12-16  Palmer Dabbelt  <palmer@rivosinc.com>\n+\n+\t* doc/extend.texi (__builtin_riscv_pause): Imply\n+\tXgnuzihintpausestate.\n+\n+2022-12-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108086\n+\t* tree-inline.cc (remap_ssa_name): Do not unshare the\n+\tresult from the decl_map.\n+\n+2022-12-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108086\n+\t* tree-inline.cc (copy_bb): Remove handling of (foo *)&this->m\n+\tsubstitution which is done in remap_gimple_op_r via\n+\tre-gimplifying.\n+\n+2022-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/106751\n+\t* loop-invariant.cc (move_invariant_reg): If preheader bb ends\n+\twith a JUMP_INSN, split the preheader edge and emit invariants\n+\tinto the new preheader basic block.\n+\n+2022-12-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108086\n+\t* tree-inline.cc (remap_gimple_stmt): Add stmts to the\n+\tsequence without updating them.  Simplify x == x detection.\n+\n+2022-12-16  Haochen Jiang  <haochen.jiang@intel.com>\n+\n+\t* config/i386/cmpccxaddintrin.h\n+\t(__cmpccxadd_epi32): Rename to _cmpccxadd_epi32.\n+\t(__cmpccxadd_epi64): Rename to _cmpccxadd_epi64.\n+\n+2022-12-15  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* ira-costs.cc: Include print-rtl.h.\n+\t(record_reg_classes, scan_one_insn): Add code to print debug info.\n+\t* ira.cc (ira_init_register_move_cost): Check that at least one hard\n+\treg of the mode are in the class contents to calculate the\n+\tregister move costs.\n+\n+2022-12-15  Siddhesh Poyarekar  <siddhesh@gotplt.org>\n+\n+\t* doc/extend.texi (__builtin_dynamic_object_size): Document\n+\tbuiltin.\n+\t* doc/passes.texi\n+\t(Optimize calls to @code{__builtin_object_size}): Also mention\n+\t__builtin_dynamic_object_size.\n+\n+2022-12-15  Siddhesh Poyarekar  <siddhesh@gotplt.org>\n+\n+\tPR middle-end/70090\n+\t* doc/invoke.texi (-fsanitize=object-size): Use\n+\t__builtin_dynamic_object_size instead of\n+\t__builtin_object_size.\n+\n+2022-12-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108086\n+\t* tree-inline.cc (copy_edges_for_bb): Walk stmts backwards for\n+\tsplitting the block to avoid quadratic behavior with setting\n+\tstmts BB on multliple splits.\n+\n+2022-12-15  Spacetown  <michael.foerderer@gmx.de>\n+\n+\tPR gcov-profile/107537\n+\t* gcov.cc (output_branch_count): Add annotation '(fallthrough)'\n+\tor '(throw)' also to uncovered branches.\n+\n+2022-12-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108086\n+\t* tree-inline.cc (copy_edges_for_bb): Do not update all\n+\tstmts again.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108095\n+\t* tree-into-ssa.cc (maybe_register_def): Insert debug stmt\n+\ton all non-EH edges from asm goto if they have a single\n+\tpredecessor rather than asserting there is at most one such edge.\n+\tTest whether there are no PHI nodes next to the single predecessor\n+\ttest.\n+\n 2022-12-14  David Faust  <david.faust@oracle.com>\n \n \tPR target/106773"}, {"sha": "ee0b6666b546329df00e3a4eab97784d3ff1b98e", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1 +1 @@\n-20221215\n+20221217"}, {"sha": "9ca2e46c8baa43fce8f87e722cea462ed35413dd", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,24 @@\n+2022-12-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/106479\n+\t* kf.cc (kf_memcpy_memmove::impl_call_pre): Pass in source region\n+\tto region_model::check_for_poison.\n+\t* region-model-asm.cc (region_model::on_asm_stmt): Pass NULL\n+\tregion to region_model::check_for_poison.\n+\t* region-model.cc (region_model::check_for_poison): Add\n+\t\"src_region\" param, and pass it to poisoned_value_diagnostic.\n+\t(region_model::on_assignment): Pass NULL region to\n+\tregion_model::check_for_poison.\n+\t(region_model::get_rvalue): Likewise.\n+\t* region-model.h (region_model::check_for_poison): Add\n+\t\"src_region\" param.\n+\t* sm-fd.cc (fd_state_machine::on_accept): Pass in source region\n+\tto region_model::check_for_poison.\n+\t* varargs.cc (kf_va_copy::impl_call_pre): Pass NULL region to\n+\tregion_model::check_for_poison.\n+\t(kf_va_arg::impl_call_pre): Pass in source region to\n+\tregion_model::check_for_poison.\n+\n 2022-12-14  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/108065"}, {"sha": "6088bfc72c089c7e753d1746d99c35b92980e8d9", "filename": "gcc/analyzer/kf.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fkf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fkf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fkf.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -288,7 +288,7 @@ kf_memcpy_memmove::impl_call_pre (const call_details &cd) const\n   const svalue *src_contents_sval\n     = model->get_store_value (sized_src_reg, cd.get_ctxt ());\n   model->check_for_poison (src_contents_sval, cd.get_arg_tree (1),\n-\t\t\t   cd.get_ctxt ());\n+\t\t\t   sized_src_reg, cd.get_ctxt ());\n   model->set_value (sized_dest_reg, src_contents_sval, cd.get_ctxt ());\n }\n "}, {"sha": "ac32c6f06f7f6ddf2b1128746f2cc91acf69f91b", "filename": "gcc/analyzer/region-model-asm.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fregion-model-asm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fregion-model-asm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-asm.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -226,7 +226,7 @@ region_model::on_asm_stmt (const gasm *stmt, region_model_context *ctxt)\n \n       tree src_expr = input_tvec[i];\n       const svalue *src_sval = get_rvalue (src_expr, ctxt);\n-      check_for_poison (src_sval, src_expr, ctxt);\n+      check_for_poison (src_sval, src_expr, NULL, ctxt);\n       input_svals.quick_push (src_sval);\n       reachable_regs.handle_sval (src_sval);\n "}, {"sha": "55064400a08b83f6e04661036032f8ae24ab3e47", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1004,11 +1004,13 @@ due_to_ifn_deferred_init_p (const gassign *assign_stmt)\n \n /* Check for SVAL being poisoned, adding a warning to CTXT.\n    Return SVAL, or, if a warning is added, another value, to avoid\n-   repeatedly complaining about the same poisoned value in followup code.  */\n+   repeatedly complaining about the same poisoned value in followup code.\n+   SRC_REGION is a hint about where SVAL came from, and can be NULL.  */\n \n const svalue *\n region_model::check_for_poison (const svalue *sval,\n \t\t\t\ttree expr,\n+\t\t\t\tconst region *src_region,\n \t\t\t\tregion_model_context *ctxt) const\n {\n   if (!ctxt)\n@@ -1046,8 +1048,7 @@ region_model::check_for_poison (const svalue *sval,\n \t the tree other than via the def stmts, using\n \t fixup_tree_for_diagnostic.  */\n       tree diag_arg = fixup_tree_for_diagnostic (expr);\n-      const region *src_region = NULL;\n-      if (pkind == POISON_KIND_UNINIT)\n+      if (src_region == NULL && pkind == POISON_KIND_UNINIT)\n \tsrc_region = get_region_for_poisoned_expr (expr);\n       if (ctxt->warn (make_unique<poisoned_value_diagnostic> (diag_arg,\n \t\t\t\t\t\t\t      pkind,\n@@ -1100,7 +1101,7 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n   if (const svalue *sval = get_gassign_result (assign, ctxt))\n     {\n       tree expr = get_diagnostic_tree_for_gassign (assign);\n-      check_for_poison (sval, expr, ctxt);\n+      check_for_poison (sval, expr, NULL, ctxt);\n       set_value (lhs_reg, sval, ctxt);\n       return;\n     }\n@@ -2227,7 +2228,7 @@ region_model::get_rvalue (path_var pv, region_model_context *ctxt) const\n \n   assert_compat_types (result_sval->get_type (), TREE_TYPE (pv.m_tree));\n \n-  result_sval = check_for_poison (result_sval, pv.m_tree, ctxt);\n+  result_sval = check_for_poison (result_sval, pv.m_tree, NULL, ctxt);\n \n   return result_sval;\n }"}, {"sha": "e8767e5ed41bde32c6e3ff835e27a0c1870cab08", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -485,6 +485,7 @@ class region_model\n \n   const svalue *check_for_poison (const svalue *sval,\n \t\t\t\t  tree expr,\n+\t\t\t\t  const region *src_region,\n \t\t\t\t  region_model_context *ctxt) const;\n \n   void check_region_for_write (const region *dest_reg,"}, {"sha": "03bcdfa60b446d0f558dbeed062b3eccb1b11ee6", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1992,6 +1992,7 @@ fd_state_machine::on_accept (const call_details &cd,\n \t\t\t\t  build_int_cst (TREE_TYPE (len_ptr), 0));\n       old_len_sval = model->check_for_poison (old_len_sval,\n \t\t\t\t\t      star_len_ptr,\n+\t\t\t\t\t      len_reg,\n \t\t\t\t\t      cd.get_ctxt ());\n       if (successful)\n \t{"}, {"sha": "5414f233ab15b6e291ed916063daaa2fd0cf3f76", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -723,6 +723,7 @@ kf_va_copy::impl_call_pre (const call_details &cd) const\n   in_va_list\n     = model->check_for_poison (in_va_list,\n \t\t\t       get_va_list_diag_arg (cd.get_arg_tree (1)),\n+\t\t\t       NULL,\n \t\t\t       cd.get_ctxt ());\n \n   const region *out_dst_reg\n@@ -1004,7 +1005,7 @@ kf_va_arg::impl_call_pre (const call_details &cd) const\n     ap_sval = cast;\n \n   tree va_list_tree = get_va_list_diag_arg (cd.get_arg_tree (0));\n-  ap_sval = model->check_for_poison (ap_sval, va_list_tree, ctxt);\n+  ap_sval = model->check_for_poison (ap_sval, va_list_tree, ap_reg, ctxt);\n \n   if (const region *impl_reg = ap_sval->maybe_get_region ())\n     {"}, {"sha": "3670dcc167b97b39d99a186a471d0c1fe6f185ca", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,7 @@\n+2022-12-16  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\t* c.opt (Wstrict-flex-arrays): New option.\n+\n 2022-12-02  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-attribs.cc (handle_deprecated_attribute): Use type when"}, {"sha": "33edeefd285f6c45b576c9bd1a979ed588281db5", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -976,6 +976,11 @@ Wstringop-truncation\n C ObjC C++ LTO ObjC++ Var(warn_stringop_truncation) Warning Init (1) LangEnabledBy(C ObjC C++ LTO ObjC++, Wall)\n Warn about truncation in string manipulation functions like strncat and strncpy.\n \n+Wstrict-flex-arrays\n+C C++ Var(warn_strict_flex_arrays) Warning\n+Warn about inproper usages of flexible array members\n+according to the level of -fstrict-flex-arrays.\n+\n Wsuggest-attribute=format\n C ObjC C++ ObjC++ Var(warn_suggest_attribute_format) Warning\n Warn about functions which might be candidates for format attributes."}, {"sha": "11fce1f5e5046332901f71435a95fe77409f52d8", "filename": "gcc/config/i386/cmpccxaddintrin.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fconfig%2Fi386%2Fcmpccxaddintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fconfig%2Fi386%2Fcmpccxaddintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcmpccxaddintrin.h?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -58,23 +58,23 @@ typedef enum {\n #ifdef __OPTIMIZE__\n extern __inline int\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n-__cmpccxadd_epi32 (int *__A, int __B, int __C, const _CMPCCX_ENUM __D)\n+_cmpccxadd_epi32 (int *__A, int __B, int __C, const _CMPCCX_ENUM __D)\n {\n   return __builtin_ia32_cmpccxadd (__A, __B, __C, __D);\n }\n \n extern __inline long long\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n-__cmpccxadd_epi64 (long long *__A, long long __B, long long __C,\n+_cmpccxadd_epi64 (long long *__A, long long __B, long long __C,\n \t\t   const _CMPCCX_ENUM __D)\n {\n   return __builtin_ia32_cmpccxadd64 (__A, __B, __C, __D);\n }\n #else\n-#define __cmpccxadd_epi32(A,B,C,D) \\\n+#define _cmpccxadd_epi32(A,B,C,D) \\\n   __builtin_ia32_cmpccxadd ((int *) (A), (int) (B), (int) (C), \\\n \t\t\t    (_CMPCCX_ENUM) (D))\n-#define __cmpccxadd_epi64(A,B,C,D) \\\n+#define _cmpccxadd_epi64(A,B,C,D) \\\n   __builtin_ia32_cmpccxadd64 ((long long *) (A), (long long) (B), \\\n \t\t\t      (long long) (C), (_CMPCCX_ENUM) (D))\n #endif"}, {"sha": "9f43802075fe05ccdc2549fafe7584f9eeb8330c", "filename": "gcc/config/pa/pa.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fconfig%2Fpa%2Fpa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fconfig%2Fpa%2Fpa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -567,6 +567,9 @@ pa_option_override (void)\n       flag_reorder_blocks = 1;\n     }\n \n+  /* Disable -fstack-protector to suppress warning.  */\n+  flag_stack_protect = 0;\n+\n   /* We can't guarantee that .dword is available for 32-bit targets.  */\n   if (UNITS_PER_WORD == 4)\n     targetm.asm_out.aligned_op.di = NULL;"}, {"sha": "6dd2ab2d11e260f6f7fa29683dafc1a6c0e5c348", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -5991,7 +5991,7 @@ riscv_option_override (void)\n     target_flags |= MASK_FDIV;\n \n   /* Handle -mtune, use -mcpu if -mtune is not given, and use default -mtune\n-     if -mtune and -mcpu both not given.  */\n+     if both -mtune and -mcpu are not given.  */\n   cpu = riscv_parse_tune (riscv_tune_string ? riscv_tune_string :\n \t\t\t  (riscv_cpu_string ? riscv_cpu_string :\n \t\t\t   RISCV_TUNE_STRING_DEFAULT));"}, {"sha": "d52b03fcf595b7f8ba6b3b7157c3a4197b22ac31", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,88 @@\n+2022-12-16  Andrew Pinski  <pinskia@gmail.com>\n+\t    Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/107768\n+\t* coroutines.cc (coro_rewrite_function_body): Initialize pointers\n+\tfrom nullptr_node.  (morph_fn_to_coro): Likewise.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/102104\n+\tPR c++/108090\n+\t* error.cc (dump_decl) <case USING_DECL>: Look through a\n+\tpack expansion in the name as well.\n+\t* parser.cc (cp_parser_using_declaration): Handle a parameter\n+\tpack appearing in the terminal name of a variadic using-decl.\n+\t* pt.cc (tsubst_decl) <case USING_DECL>: Likewise.  Combine the\n+\thandling of variadic and non-variadic using-decls.\n+\n+2022-12-15  Jason Merrill  <jason@redhat.com>\n+\n+\t* init.cc (build_vec_init): Rename \"flags\" to \"cleanup_flags\"\n+\tto distinguish from LOOKUP_*.\n+\n+2022-12-15  Arsen Arsenovi\u0107  <arsen@aarsen.me>\n+\n+\t* mangle.cc (write_encoding): Move contract pre/post function\n+\tmangling from here...\n+\t(write_mangled_name): ... to here, and make it happen always.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107188\n+\t* parser.cc (cp_parser_using_declaration): Give up early if the\n+\tscope of an access-declaration isn't possibly a class type.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/100295\n+\tPR c++/107579\n+\t* pt.cc (el_data::skip_unevaluated_operands): New data member.\n+\t(extract_locals_r): If skip_unevaluated_operands is true,\n+\tdon't walk into unevaluated contexts.\n+\t(extract_local_specs): Walk the pattern twice, first with\n+\tskip_unevaluated_operands true followed by it set to false.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/105518\n+\t* pt.cc (tsubst_aggr_type): Handle typedefs by delegating to\n+\ttsubst and adjusting the result if entering_scope.  Split out\n+\tthe main part of the function into ...\n+\t(tsubst_aggr_type_1) ... here.\n+\t(tsubst): Use tsubst_aggr_type_1 instead of tsubst_aggr_type.\n+\tHandle TYPE_PTRMEMFUNC_P RECORD_TYPEs here instead of in\n+\ttsubst_aggr_type_1.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/108104\n+\t* pt.cc (unify) <default>: Relax assert to accept any\n+\tCONSTRUCTOR parm, not just COMPOUND_LITERAL_P one.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/107065\n+\t* typeck.cc (cp_build_unary_op) <case TRUTH_NOT_EXPR>: If\n+\tinvert_truthvalue_loc returns obvalue_p, wrap it into NON_LVALUE_EXPR.\n+\t* parser.cc (cp_parser_binary_expression): Don't call\n+\twarn_logical_not_parentheses if current.lhs is a NON_LVALUE_EXPR\n+\tof a decl with boolean type.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libstdc++/108075\n+\t* rtti.cc (emit_support_tinfos): Add pointers to\n+\t{bfloat16,float{16,32,64,128,32x,64x,128x}}_type_node to fundamentals\n+\tarray.\n+\n+2022-12-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108071\n+\tPR c++/105838\n+\t* call.cc (struct conversion_obstack_sentinel): New.\n+\t(maybe_init_list_as_array): Compare conversion of dummy argument.\n+\n 2022-12-12  Jason Merrill  <jason@redhat.com>\n \n \tRevert:"}, {"sha": "88d6c30d8b1b578ce99d027ccdf832131ae5cefb", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -4132,7 +4132,7 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n   /* We will need to be able to set the resume function pointer to nullptr\n      to signal that the coroutine is 'done'.  */\n   tree zero_resume\n-    = build1 (CONVERT_EXPR, resume_fn_ptr_type, integer_zero_node);\n+    = build1 (CONVERT_EXPR, resume_fn_ptr_type, nullptr_node);\n \n   /* The pointer to the destroy function.  */\n   tree var = coro_build_artificial_var (fn_start, coro_destroy_fn_id,\n@@ -4519,7 +4519,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree ramp_body = push_stmt_list ();\n \n   tree zeroinit = build1_loc (fn_start, CONVERT_EXPR,\n-\t\t\t      coro_frame_ptr, integer_zero_node);\n+\t\t\t      coro_frame_ptr, nullptr_node);\n   tree coro_fp = coro_build_artificial_var (fn_start, \"_Coro_frameptr\",\n \t\t\t\t\t    coro_frame_ptr, orig, zeroinit);\n   tree varlist = coro_fp;\n@@ -4754,7 +4754,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n       gcc_checking_assert (same_type_p (fn_return_type, TREE_TYPE (grooaf)));\n       tree if_stmt = begin_if_stmt ();\n-      tree cond = build1 (CONVERT_EXPR, coro_frame_ptr, integer_zero_node);\n+      tree cond = build1 (CONVERT_EXPR, coro_frame_ptr, nullptr_node);\n       cond = build2 (EQ_EXPR, boolean_type_node, coro_fp, cond);\n       finish_if_stmt_cond (cond, if_stmt);\n       if (VOID_TYPE_P (fn_return_type))"}, {"sha": "e7f60335cc06f4f8161954af16f20d0b12d8fd64", "filename": "gcc/cp/error.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1477,11 +1477,20 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n \tif (!(flags & TFF_UNQUALIFIED_NAME))\n \t  {\n \t    tree scope = USING_DECL_SCOPE (t);\n+\t    tree name = DECL_NAME (t);\n \t    if (PACK_EXPANSION_P (scope))\n \t      {\n \t\tscope = PACK_EXPANSION_PATTERN (scope);\n \t\tvariadic = true;\n \t      }\n+\t    if (identifier_p (name)\n+\t\t&& IDENTIFIER_CONV_OP_P (name)\n+\t\t&& PACK_EXPANSION_P (TREE_TYPE (name)))\n+\t      {\n+\t\tname = make_conv_op_name (PACK_EXPANSION_PATTERN\n+\t\t\t\t\t  (TREE_TYPE (name)));\n+\t\tvariadic = true;\n+\t      }\n \t    dump_type (pp, scope, flags);\n \t    pp_cxx_colon_colon (pp);\n \t  }"}, {"sha": "73e6547c07653a4b459a7ed72edd9f3e3b280e28", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -4379,7 +4379,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t\tbool explicit_value_init_p,\n \t\tint from_array,\n \t\ttsubst_flags_t complain,\n-\t\tvec<tree, va_gc>** flags /* = nullptr */)\n+\t\tvec<tree, va_gc>** cleanup_flags /* = nullptr */)\n {\n   tree rval;\n   tree base2 = NULL_TREE;\n@@ -4590,8 +4590,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t anything for arrays.  But if the array is a subobject, we need to\n \t tell split_nonconstant_init how to turn off this cleanup in favor of\n \t the cleanup for the complete object.  */\n-      if (flags)\n-\tvec_safe_push (*flags, build_tree_list (iterator, maxindex));\n+      if (cleanup_flags)\n+\tvec_safe_push (*cleanup_flags, build_tree_list (iterator, maxindex));\n     }\n \n   /* Should we try to create a constant initializer?  */\n@@ -4650,7 +4650,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  if (digested)\n \t    one_init = cp_build_init_expr (baseref, elt);\n \t  else if (tree vi = get_vec_init_expr (elt))\n-\t    one_init = expand_vec_init_expr (baseref, vi, complain, flags);\n+\t    one_init = expand_vec_init_expr (baseref, vi, complain,\n+\t\t\t\t\t     cleanup_flags);\n \t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else"}, {"sha": "074cf27ec7a20cdb6ced3c0f8ed04524db6ef20d", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -798,6 +798,13 @@ write_mangled_name (const tree decl, bool top_level)\n       write_string (\"_Z\");\n       write_encoding (decl);\n     }\n+\n+  /* If this is the pre/post function for a guarded function, append\n+     .pre/post, like something from create_virtual_clone.  */\n+  if (DECL_IS_PRE_FN_P (decl))\n+    write_string (\".pre\");\n+  else if (DECL_IS_POST_FN_P (decl))\n+    write_string (\".post\");\n }\n \n /* Returns true if the return type of DECL is part of its signature, and\n@@ -856,13 +863,6 @@ write_encoding (const tree decl)\n \t\t\t\tmangle_return_type_p (decl),\n \t\t\t\td);\n \n-      /* If this is the pre/post function for a guarded function, append\n-\t .pre/post, like something from create_virtual_clone.  */\n-      if (DECL_IS_PRE_FN_P (decl))\n-\twrite_string (\".pre\");\n-      else if (DECL_IS_POST_FN_P (decl))\n-\twrite_string (\".post\");\n-\n       /* If this is a coroutine helper, then append an appropriate string to\n \t identify which.  */\n       if (tree ramp = DECL_RAMP_FN (decl))"}, {"sha": "bfd8aeae39f69d0fd9e1e51a41991410799c5398", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -10224,7 +10224,10 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t\t      || (TREE_CODE (TREE_TYPE (TREE_OPERAND (current.lhs, 0)))\n \t\t\t  != BOOLEAN_TYPE))))\n \t  /* Avoid warning for !!b == y where b is boolean.  */\n-\t  && (!DECL_P (tree_strip_any_location_wrapper (current.lhs))\n+\t  && (!(DECL_P (tree_strip_any_location_wrapper (current.lhs))\n+\t\t|| (TREE_CODE (current.lhs) == NON_LVALUE_EXPR\n+\t\t    && DECL_P (tree_strip_any_location_wrapper\n+\t\t\t\t\t    (TREE_OPERAND (current.lhs, 0)))))\n \t      || TREE_TYPE (current.lhs) == NULL_TREE\n \t      || TREE_CODE (TREE_TYPE (current.lhs)) != BOOLEAN_TYPE))\n \twarn_logical_not_parentheses (current.loc, current.tree_type,\n@@ -21670,6 +21673,13 @@ cp_parser_using_declaration (cp_parser* parser,\n \n   cp_warn_deprecated_use_scopes (qscope);\n \n+  if (access_declaration_p\n+      && !MAYBE_CLASS_TYPE_P (qscope)\n+      && TREE_CODE (qscope) != ENUMERAL_TYPE)\n+    /* If the qualifying scope of an access-declaration isn't a class\n+       or enumeration type then it can't be valid.  */\n+    cp_parser_simulate_error (parser);\n+\n   if (access_declaration_p && cp_parser_error_occurred (parser))\n     /* Something has already gone wrong; there's no need to parse\n        further.  Since an error has occurred, the return value of\n@@ -21698,7 +21708,36 @@ cp_parser_using_declaration (cp_parser* parser,\n \tpedwarn (ell->location, OPT_Wc__17_extensions,\n \t\t \"pack expansion in using-declaration only available \"\n \t\t \"with %<-std=c++17%> or %<-std=gnu++17%>\");\n-      qscope = make_pack_expansion (qscope);\n+\n+      /* A parameter pack can appear in the qualifying scope, and/or in the\n+\t terminal name (if naming a conversion function).  Logically they're\n+\t part of a single pack expansion of the overall USING_DECL, but we\n+\t express them as separate pack expansions within the USING_DECL since\n+\t we can't create a pack expansion over a USING_DECL.  */\n+      bool saw_parm_pack = false;\n+      if (uses_parameter_packs (qscope))\n+\t{\n+\t  qscope = make_pack_expansion (qscope);\n+\t  saw_parm_pack = true;\n+\t}\n+      if (identifier_p (identifier)\n+\t  && IDENTIFIER_CONV_OP_P (identifier)\n+\t  && uses_parameter_packs (TREE_TYPE (identifier)))\n+\t{\n+\t  identifier = make_conv_op_name (make_pack_expansion\n+\t\t\t\t\t  (TREE_TYPE (identifier)));\n+\t  saw_parm_pack = true;\n+\t}\n+      if (!saw_parm_pack)\n+\t{\n+\t  /* Issue an error in terms using a SCOPE_REF that includes both\n+\t     components.  */\n+\t  tree name\n+\t    = build_qualified_name (NULL_TREE, qscope, identifier, false);\n+\t  make_pack_expansion (name);\n+\t  gcc_assert (seen_error ());\n+\t  qscope = identifier = error_mark_node;\n+\t}\n     }\n \n   /* The function we call to handle a using-declaration is different"}, {"sha": "2516cca590ee0015daccdd7a07c5f7e3d85f6830", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 153, "deletions": 71, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -185,6 +185,7 @@ static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n static void tsubst_each_template_parm_constraints (tree, tree, tsubst_flags_t);\n tree most_specialized_partial_spec (tree, tsubst_flags_t);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n+static tree tsubst_aggr_type_1 (tree, tree, tsubst_flags_t, tree, int);\n static tree tsubst_arg_types (tree, tree, tree, tsubst_flags_t, tree);\n static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n static bool check_specialization_scope (void);\n@@ -7317,7 +7318,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       && has_value_dependent_address (expr))\n     /* If we want the address and it's value-dependent, don't fold.  */;\n   else if (processing_template_decl\n-\t   && is_nondependent_constant_expression (expr))\n+\t   && !instantiation_dependent_expression_p (expr))\n     non_dep = true;\n   if (error_operand_p (expr))\n     return error_mark_node;\n@@ -13015,17 +13016,26 @@ class el_data\n   /* List of local_specializations used within the pattern.  */\n   tree extra;\n   tsubst_flags_t complain;\n+  /* True iff we don't want to walk into unevaluated contexts.  */\n+  bool skip_unevaluated_operands = false;\n \n   el_data (tsubst_flags_t c)\n     : extra (NULL_TREE), complain (c) {}\n };\n static tree\n-extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data_)\n+extract_locals_r (tree *tp, int *walk_subtrees, void *data_)\n {\n   el_data &data = *reinterpret_cast<el_data*>(data_);\n   tree *extra = &data.extra;\n   tsubst_flags_t complain = data.complain;\n \n+  if (data.skip_unevaluated_operands\n+      && unevaluated_p (TREE_CODE (*tp)))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n   if (TYPE_P (*tp) && typedef_variant_p (*tp))\n     /* Remember local typedefs (85214).  */\n     tp = &TYPE_NAME (*tp);\n@@ -13117,6 +13127,14 @@ static tree\n extract_local_specs (tree pattern, tsubst_flags_t complain)\n {\n   el_data data (complain);\n+  /* Walk the pattern twice, ignoring unevaluated operands the first time\n+     around, so that if a local specialization appears in both an evaluated\n+     and unevaluated context we prefer to process it in the evaluated context\n+     (since e.g. process_outer_var_ref is a no-op inside an unevaluated\n+     context).  */\n+  data.skip_unevaluated_operands = true;\n+  cp_walk_tree (&pattern, extract_locals_r, &data, &data.visited);\n+  data.skip_unevaluated_operands = false;\n   cp_walk_tree (&pattern, extract_locals_r, &data, &data.visited);\n   return data.extra;\n }\n@@ -13828,57 +13846,80 @@ tsubst_aggr_type (tree t,\n   if (t == NULL_TREE)\n     return NULL_TREE;\n \n-  /* If T is an alias template specialization, we want to substitute that\n-     rather than strip it, especially if it's dependent_alias_template_spec_p.\n-     It should be OK not to handle entering_scope in this case, since\n-     DECL_CONTEXT will never be an alias template specialization.  We only get\n-     here with an alias when tsubst calls us for TYPENAME_TYPE.  */\n-  if (alias_template_specialization_p (t, nt_transparent))\n-    return tsubst (t, args, complain, in_decl);\n+  /* Handle typedefs via tsubst so that they get consistently reused.  */\n+  if (typedef_variant_p (t))\n+    {\n+      t = tsubst (t, args, complain, in_decl);\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+\n+      /* The effect of entering_scope is that for a dependent specialization\n+\t A<T>, lookup_template_class prefers to return A's primary template\n+\t type instead of the implicit instantiation.  So when entering_scope,\n+\t we mirror this behavior by inspecting TYPE_CANONICAL appropriately,\n+\t taking advantage of the fact that lookup_template_class links the two\n+\t types by setting TYPE_CANONICAL of the latter to the former.  */\n+      if (entering_scope\n+\t  && CLASS_TYPE_P (t)\n+\t  && dependent_type_p (t)\n+\t  && TYPE_CANONICAL (t) == TREE_TYPE (TYPE_TI_TEMPLATE (t)))\n+\tt = TYPE_CANONICAL (t);\n+\n+      return t;\n+    }\n \n   switch (TREE_CODE (t))\n     {\n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (t))\n-\treturn tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl);\n+      case RECORD_TYPE:\n+      case ENUMERAL_TYPE:\n+      case UNION_TYPE:\n+\treturn tsubst_aggr_type_1 (t, args, complain, in_decl, entering_scope);\n \n-      /* Fall through.  */\n-    case ENUMERAL_TYPE:\n-    case UNION_TYPE:\n-      if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n-\t{\n-\t  tree argvec;\n-\t  tree r;\n+      default:\n+\treturn tsubst (t, args, complain, in_decl);\n+    }\n+}\n+\n+/* The part of tsubst_aggr_type that's shared with the RECORD_, UNION_\n+   and ENUMERAL_TYPE cases of tsubst.  */\n \n-\t  /* Figure out what arguments are appropriate for the\n-\t     type we are trying to find.  For example, given:\n+static tree\n+tsubst_aggr_type_1 (tree t,\n+\t\t    tree args,\n+\t\t    tsubst_flags_t complain,\n+\t\t    tree in_decl,\n+\t\t    int entering_scope)\n+{\n+  if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n+    {\n+      tree argvec;\n+      tree r;\n \n-\t       template <class T> struct S;\n-\t       template <class T, class U> void f(T, U) { S<U> su; }\n+      /* Figure out what arguments are appropriate for the\n+\t type we are trying to find.  For example, given:\n \n-\t     and supposing that we are instantiating f<int, double>,\n-\t     then our ARGS will be {int, double}, but, when looking up\n-\t     S we only want {double}.  */\n-\t  argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n-\t\t\t\t\t complain, in_decl);\n-\t  if (argvec == error_mark_node)\n-\t    r = error_mark_node;\n-\t  else\n-\t    {\n-\t      r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n-\t\t\t\t\t entering_scope, complain);\n-\t      r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n-\t    }\n+\t   template <class T> struct S;\n+\t   template <class T, class U> void f(T, U) { S<U> su; }\n \n-\t  return r;\n-\t}\n+\t and supposing that we are instantiating f<int, double>,\n+\t then our ARGS will be {int, double}, but, when looking up\n+\t S we only want {double}.  */\n+      argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n+\t\t\t\t     complain, in_decl);\n+      if (argvec == error_mark_node)\n+\tr = error_mark_node;\n       else\n-\t/* This is not a template type, so there's nothing to do.  */\n-\treturn t;\n+\t{\n+\t  r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n+\t\t\t\t     entering_scope, complain);\n+\t  r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n+\t}\n \n-    default:\n-      return tsubst (t, args, complain, in_decl);\n+      return r;\n     }\n+  else\n+    /* This is not a template type, so there's nothing to do.  */\n+    return t;\n }\n \n /* Map from a FUNCTION_DECL to a vec of default argument instantiations,\n@@ -14921,43 +14962,81 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n       if (DECL_DEPENDENT_P (t)\n \t  || uses_template_parms (USING_DECL_SCOPE (t)))\n \t{\n+\t  /* True iff this using-decl was written as a pack expansion\n+\t     (and a pack appeared in its scope or name).  If a pack\n+\t     appeared in both, we expand the packs separately and\n+\t     manually merge them.  */\n+\t  bool variadic_p = false;\n+\n \t  tree scope = USING_DECL_SCOPE (t);\n-\t  tree name = tsubst_copy (DECL_NAME (t), args, complain, in_decl);\n \t  if (PACK_EXPANSION_P (scope))\n \t    {\n-\t      tree vec = tsubst_pack_expansion (scope, args, complain, in_decl);\n-\t      int len = TREE_VEC_LENGTH (vec);\n-\t      r = make_tree_vec (len);\n-\t      for (int i = 0; i < len; ++i)\n+\t      scope = tsubst_pack_expansion (scope, args, complain, in_decl);\n+\t      variadic_p = true;\n+\t    }\n+\t  else\n+\t    scope = tsubst_copy (scope, args, complain, in_decl);\n+\n+\t  tree name = DECL_NAME (t);\n+\t  if (IDENTIFIER_CONV_OP_P (name)\n+\t      && PACK_EXPANSION_P (TREE_TYPE (name)))\n+\t    {\n+\t      name = tsubst_pack_expansion (TREE_TYPE (name), args,\n+\t\t\t\t\t    complain, in_decl);\n+\t      if (name == error_mark_node)\n \t\t{\n-\t\t  tree escope = TREE_VEC_ELT (vec, i);\n-\t\t  tree elt = do_class_using_decl (escope, name);\n-\t\t  if (!elt)\n-\t\t    {\n-\t\t      r = error_mark_node;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_PROTECTED (elt) = TREE_PROTECTED (t);\n-\t\t      TREE_PRIVATE (elt) = TREE_PRIVATE (t);\n-\t\t    }\n-\t\t  TREE_VEC_ELT (r, i) = elt;\n+\t\t  r = error_mark_node;\n+\t\t  break;\n \t\t}\n+\t      for (tree& elt : tree_vec_range (name))\n+\t\telt = make_conv_op_name (elt);\n+\t      variadic_p = true;\n \t    }\n \t  else\n+\t    name = tsubst_copy (name, args, complain, in_decl);\n+\n+\t  int len;\n+\t  if (!variadic_p)\n+\t    len = 1;\n+\t  else if (TREE_CODE (scope) == TREE_VEC\n+\t\t   && TREE_CODE (name) == TREE_VEC)\n \t    {\n-\t      tree inst_scope = tsubst_copy (USING_DECL_SCOPE (t), args,\n-\t\t\t\t\t     complain, in_decl);\n-\t      r = do_class_using_decl (inst_scope, name);\n-\t      if (!r)\n-\t\tr = error_mark_node;\n-\t      else\n+\t      if (TREE_VEC_LENGTH (scope) != TREE_VEC_LENGTH (name))\n \t\t{\n-\t\t  TREE_PROTECTED (r) = TREE_PROTECTED (t);\n-\t\t  TREE_PRIVATE (r) = TREE_PRIVATE (t);\n+\t\t  error (\"mismatched argument pack lengths (%d vs %d)\",\n+\t\t\t TREE_VEC_LENGTH (scope), TREE_VEC_LENGTH (name));\n+\t\t  r = error_mark_node;\n+\t\t  break;\n \t\t}\n+\t      len = TREE_VEC_LENGTH (scope);\n \t    }\n+\t  else if (TREE_CODE (scope) == TREE_VEC)\n+\t    len = TREE_VEC_LENGTH (scope);\n+\t  else /* TREE_CODE (name) == TREE_VEC  */\n+\t    len = TREE_VEC_LENGTH (name);\n+\n+\t  r = make_tree_vec (len);\n+\t  for (int i = 0; i < len; ++i)\n+\t    {\n+\t      tree escope = (TREE_CODE (scope) == TREE_VEC\n+\t\t\t     ? TREE_VEC_ELT (scope, i)\n+\t\t\t     : scope);\n+\t      tree ename = (TREE_CODE (name) == TREE_VEC\n+\t\t\t    ? TREE_VEC_ELT (name, i)\n+\t\t\t    : name);\n+\t      tree elt = do_class_using_decl (escope, ename);\n+\t      if (!elt)\n+\t\t{\n+\t\t  r = error_mark_node;\n+\t\t  break;\n+\t\t}\n+\t      TREE_PROTECTED (elt) = TREE_PROTECTED (t);\n+\t      TREE_PRIVATE (elt) = TREE_PRIVATE (t);\n+\t      TREE_VEC_ELT (r, i) = elt;\n+\t    }\n+\n+\t  if (!variadic_p && r != error_mark_node)\n+\t    r = TREE_VEC_ELT (r, 0);\n \t}\n       else\n \t{\n@@ -15795,10 +15874,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   switch (code)\n     {\n     case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\treturn tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl);\n+      /* Fall through.  */\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      return tsubst_aggr_type (t, args, complain, in_decl,\n-\t\t\t       /*entering_scope=*/0);\n+      return tsubst_aggr_type_1 (t, args, complain, in_decl,\n+\t\t\t\t /*entering_scope=*/0);\n \n     case ERROR_MARK:\n     case IDENTIFIER_NODE:\n@@ -24873,7 +24955,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n       if (is_overloaded_fn (parm) || type_unknown_p (parm))\n \treturn unify_success (explain_p);\n       gcc_assert (EXPR_P (parm)\n-\t\t  || COMPOUND_LITERAL_P (parm)\n+\t\t  || TREE_CODE (parm) == CONSTRUCTOR\n \t\t  || TREE_CODE (parm) == TRAIT_EXPR);\n     expr:\n       /* We must be looking at an expression.  This can happen with"}, {"sha": "c2cf78d1c097485499da3044c76112fd8404f8b0", "filename": "gcc/cp/rtti.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Frtti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Frtti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1603,7 +1603,9 @@ emit_support_tinfos (void)\n     &long_long_integer_type_node, &long_long_unsigned_type_node,\n     &float_type_node, &double_type_node, &long_double_type_node,\n     &dfloat32_type_node, &dfloat64_type_node, &dfloat128_type_node,\n-    &nullptr_type_node,\n+    &bfloat16_type_node, &float16_type_node, &float32_type_node,\n+    &float64_type_node, &float128_type_node, &float32x_type_node,\n+    &float64x_type_node, &float128x_type_node, &nullptr_type_node,\n     0\n   };\n   int ix;"}, {"sha": "69b1268cfec946ad1ff23b069d936f228791e266", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -7396,9 +7396,13 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n \t\t\t\t   build_zero_cst (TREE_TYPE (arg)), complain);\n       arg = perform_implicit_conversion (boolean_type_node, arg,\n \t\t\t\t\t complain);\n-      val = invert_truthvalue_loc (location, arg);\n       if (arg != error_mark_node)\n-\treturn val;\n+\t{\n+\t  val = invert_truthvalue_loc (location, arg);\n+\t  if (obvalue_p (val))\n+\t    val = non_lvalue_loc (location, val);\n+\t  return val;\n+\t}\n       errstring = _(\"in argument to unary !\");\n       break;\n "}, {"sha": "adba057c190a42ca74ef8eb88c36c565e66bc675", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -14291,8 +14291,14 @@ and GCC does not issue a warning.\n @end deftypefn\n \n @deftypefn {Built-in Function}{size_t} __builtin_object_size (const void * @var{ptr}, int @var{type})\n-Returns the size of an object pointed to by @var{ptr}.  @xref{Object Size\n-Checking}, for a detailed description of the function.\n+Returns a constant size estimate of an object pointed to by @var{ptr}.\n+@xref{Object Size Checking}, for a detailed description of the function.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}{size_t} __builtin_dynamic_object_size (const void * @var{ptr}, int @var{type})\n+Similar to @code{__builtin_object_size} except that the return value\n+need not be a constant.  @xref{Object Size Checking}, for a detailed\n+description of the function.\n @end deftypefn\n \n @deftypefn {Built-in Function} double __builtin_huge_val (void)\n@@ -21103,7 +21109,9 @@ Returns the value that is currently set in the @samp{tp} register.\n @end deftypefn\n \n @deftypefn {Built-in Function}  void __builtin_riscv_pause (void)\n-Generates the @code{pause} (hint) machine instruction.\n+Generates the @code{pause} (hint) machine instruction.  This implies the\n+Xgnuzihintpausestate extension, which redefines the @code{pause} instruction to\n+change architectural state.\n @end deftypefn\n \n @node RX Built-in Functions"}, {"sha": "c7e88e46e2834ef57a03abbce6f1453d6e4ddf43", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -398,7 +398,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} @gol\n -Wstring-compare @gol\n -Wno-stringop-overflow -Wno-stringop-overread @gol\n--Wno-stringop-truncation @gol\n+-Wno-stringop-truncation -Wstrict-flex-arrays @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} @gol\n -Wswitch  -Wno-switch-bool  -Wswitch-default  -Wswitch-enum @gol\n -Wno-switch-outside-range  -Wno-switch-unreachable  -Wsync-nand @gol\n@@ -7835,6 +7835,31 @@ however, are not suitable arguments to functions that expect\n such arrays GCC issues warnings unless it can prove that the use is\n safe.  @xref{Common Variable Attributes}.\n \n+@item -Wstrict-flex-arrays\n+@opindex Wstrict-flex-arrays\n+@opindex Wno-strict-flex-arrays\n+Warn about inproper usages of flexible array members\n+according to the @var{level} of the @code{strict_flex_array (@var{level})}\n+attribute attached to the trailing array field of a structure if it's\n+available, otherwise according to the @var{level} of the option\n+@option{-fstrict-flex-arrays=@var{level}}.\n+\n+This option is effective only when @var{level} is bigger than 0.  Otherwise,\n+it will be ignored with a warning.\n+\n+when @var{level}=1, warnings will be issued for a trailing array reference\n+of a structure that have 2 or more elements if the trailing array is referenced\n+as a flexible array member.\n+\n+when @var{level}=2, in addition to @var{level}=1, additional warnings will be\n+issued for a trailing one-element array reference of a structure\n+if the array is referenced as a flexible array member.\n+\n+when @var{level}=3, in addition to @var{level}=2, additional warnings will be\n+issued for a trailing zero-length array reference of a structure\n+if the array is referenced as a flexible array member.\n+\n+\n @item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}cold@r{|}malloc@r{]}\n @opindex Wsuggest-attribute=\n @opindex Wno-suggest-attribute=\n@@ -16744,8 +16769,8 @@ or when a method or constructor is invoked on insufficiently aligned object.\n @item -fsanitize=object-size\n @opindex fsanitize=object-size\n This option enables instrumentation of memory references using the\n-@code{__builtin_object_size} function.  Various out of bounds pointer\n-accesses are detected.\n+@code{__builtin_dynamic_object_size} function.  Various out of bounds\n+pointer accesses are detected.\n \n @item -fsanitize=float-divide-by-zero\n @opindex fsanitize=float-divide-by-zero"}, {"sha": "a248c5d9006e6914b074972eeeace9413fcb618a", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -843,12 +843,15 @@ foo()}, this pass tries to change the call so that the address of\n pass is located in @code{tree-nrv.cc} and is described by\n @code{pass_return_slot}.\n \n-@item Optimize calls to @code{__builtin_object_size}\n-\n-This is a propagation pass similar to CCP that tries to remove calls\n-to @code{__builtin_object_size} when the size of the object can be\n-computed at compile-time.  This pass is located in\n-@file{tree-object-size.cc} and is described by\n+@item Optimize calls to @code{__builtin_object_size} or\n+@code{__builtin_dynamic_object_size}\n+\n+This is a propagation pass similar to CCP that tries to remove calls to\n+@code{__builtin_object_size} when the upper or lower bound for the size\n+of the object can be computed at compile-time.  It also tries to replace\n+calls to @code{__builtin_dynamic_object_size} with an expression that\n+evaluates the upper or lower bound for the size of the object.  This\n+pass is located in @file{tree-object-size.cc} and is described by\n @code{pass_object_sizes}.\n \n @item Loop invariant motion"}, {"sha": "9fd42fe3919e32ec93b30c0ab0dd8436cce374a4", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -252,25 +252,33 @@ get_up_bounds_for_array_ref (tree ref, tree *decl,\n \n /* Given the LOW_SUB_ORG, LOW_SUB and UP_SUB, and the computed UP_BOUND\n    and UP_BOUND_P1, check whether the array reference REF is out of bound.\n-   Issue warnings if out of bound, return TRUE if warnings are issued.  */\n+   When out of bounds, set OUT_OF_BOUND to true.\n+   Issue warnings if FOR_ARRAY_BOUND is true.\n+   return TRUE if warnings are issued.  */\n \n static bool\n check_out_of_bounds_and_warn (location_t location, tree ref,\n \t\t\t      tree low_sub_org, tree low_sub, tree up_sub,\n \t\t\t      tree up_bound, tree up_bound_p1,\n \t\t\t      const value_range *vr,\n-\t\t\t      bool ignore_off_by_one)\n+\t\t\t      bool ignore_off_by_one, bool for_array_bound,\n+\t\t\t      bool *out_of_bound)\n {\n   tree low_bound = array_ref_low_bound (ref);\n   tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));\n \n   bool warned = false;\n+  *out_of_bound = false;\n \n   /* Empty array.  */\n   if (up_bound && tree_int_cst_equal (low_bound, up_bound_p1))\n-    warned = warning_at (location, OPT_Warray_bounds_,\n-\t\t\t \"array subscript %E is outside array bounds of %qT\",\n-\t\t\t low_sub_org, artype);\n+    {\n+      *out_of_bound = true;\n+      if (for_array_bound)\n+\twarned = warning_at (location, OPT_Warray_bounds_,\n+\t\t\t     \"array subscript %E is outside array\"\n+\t\t\t     \" bounds of %qT\", low_sub_org, artype);\n+    }\n \n   if (warned)\n     ; /* Do nothing.  */\n@@ -283,24 +291,36 @@ check_out_of_bounds_and_warn (location_t location, tree ref,\n \t      : tree_int_cst_le (up_bound, up_sub))\n \t  && TREE_CODE (low_sub) == INTEGER_CST\n \t  && tree_int_cst_le (low_sub, low_bound))\n-\twarned = warning_at (location, OPT_Warray_bounds_,\n-\t\t\t     \"array subscript [%E, %E] is outside \"\n-\t\t\t     \"array bounds of %qT\",\n-\t\t\t     low_sub, up_sub, artype);\n+\t{\n+\t  *out_of_bound = true;\n+\t  if (for_array_bound)\n+\t    warned = warning_at (location, OPT_Warray_bounds_,\n+\t\t\t\t \"array subscript [%E, %E] is outside \"\n+\t\t\t\t \"array bounds of %qT\",\n+\t\t\t\t low_sub, up_sub, artype);\n+\t}\n     }\n   else if (up_bound\n \t   && TREE_CODE (up_sub) == INTEGER_CST\n \t   && (ignore_off_by_one\n \t       ? !tree_int_cst_le (up_sub, up_bound_p1)\n \t       : !tree_int_cst_le (up_sub, up_bound)))\n-    warned = warning_at (location, OPT_Warray_bounds_,\n-\t\t\t \"array subscript %E is above array bounds of %qT\",\n-\t\t\t up_sub, artype);\n+    {\n+      *out_of_bound = true;\n+      if (for_array_bound)\n+\twarned = warning_at (location, OPT_Warray_bounds_,\n+\t\t\t     \"array subscript %E is above array bounds of %qT\",\n+\t\t\t     up_sub, artype);\n+    }\n   else if (TREE_CODE (low_sub) == INTEGER_CST\n \t   && tree_int_cst_lt (low_sub, low_bound))\n-    warned = warning_at (location, OPT_Warray_bounds_,\n-\t\t\t \"array subscript %E is below array bounds of %qT\",\n-\t\t\t low_sub, artype);\n+    {\n+      *out_of_bound = true;\n+      if (for_array_bound)\n+\twarned = warning_at (location, OPT_Warray_bounds_,\n+\t\t\t     \"array subscript %E is below array bounds of %qT\",\n+\t\t\t     low_sub, artype);\n+    }\n   return warned;\n }\n \n@@ -333,14 +353,21 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \n   tree arg = TREE_OPERAND (ref, 0);\n   const bool compref = TREE_CODE (arg) == COMPONENT_REF;\n+  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n \n   if (compref)\n-    /* Try to determine special array member type for this COMPONENT_REF.  */\n-    sam = component_ref_sam_type (arg);\n+    {\n+      /* Try to determine special array member type for this COMPONENT_REF.  */\n+      sam = component_ref_sam_type (arg);\n+      /* Get the level of strict_flex_array for this array field.  */\n+      tree afield_decl = TREE_OPERAND (arg, 1);\n+      strict_flex_array_level = strict_flex_array_level_of (afield_decl);\n+    }\n \n   get_up_bounds_for_array_ref (ref, &decl, &up_bound, &up_bound_p1);\n \n   bool warned = false;\n+  bool out_of_bound = false;\n \n   tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));\n   tree low_sub_org = TREE_OPERAND (ref, 1);\n@@ -361,7 +388,8 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n   warned = check_out_of_bounds_and_warn (location, ref,\n \t\t\t\t\t low_sub_org, low_sub, up_sub,\n \t\t\t\t\t up_bound, up_bound_p1, vr,\n-\t\t\t\t\t ignore_off_by_one);\n+\t\t\t\t\t ignore_off_by_one, warn_array_bounds,\n+\t\t\t\t\t &out_of_bound);\n \n \n   if (!warned && sam == special_array_member::int_0)\n@@ -373,19 +401,56 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t\t\t       \"of an interior zero-length array %qT\")),\n \t\t\t low_sub, artype);\n \n-  if (warned)\n+  if (warned || out_of_bound)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      if (warned && dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Array bound warning for \");\n \t  dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n+      /* issue warnings for -Wstrict-flex-arrays according to the level of\n+\t flag_strict_flex_arrays.  */\n+      if (out_of_bound && warn_strict_flex_arrays)\n+      switch (strict_flex_array_level)\n+\t{\n+\t  case 3:\n+\t    /* Issue additional warnings for trailing arrays [0].  */\n+\t    if (sam == special_array_member::trail_0)\n+\t      warned = warning_at (location, OPT_Wstrict_flex_arrays,\n+\t\t\t\t   \"trailing array %qT should not be used as \"\n+\t\t\t\t   \"a flexible array member for level 3\",\n+\t\t\t\t   artype);\n+\t    /* FALLTHROUGH.  */\n+\t  case 2:\n+\t    /* Issue additional warnings for trailing arrays [1].  */\n+\t    if (sam == special_array_member::trail_1)\n+\t      warned = warning_at (location, OPT_Wstrict_flex_arrays,\n+\t\t\t\t   \"trailing array %qT should not be used as \"\n+\t\t\t\t   \"a flexible array member for level 2 and \"\n+\t\t\t\t   \"above\", artype);\n+\t    /* FALLTHROUGH.  */\n+\t  case 1:\n+\t    /* Issue warnings for trailing arrays [n].  */\n+\t    if (sam == special_array_member::trail_n)\n+\t      warned = warning_at (location, OPT_Wstrict_flex_arrays,\n+\t\t\t\t   \"trailing array %qT should not be used as \"\n+\t\t\t\t   \"a flexible array member for level 1 and \"\n+\t\t\t\t   \"above\", artype);\n+\t    break;\n+\t  case 0:\n+\t    /* Do nothing.  */\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+\n       /* Avoid more warnings when checking more significant subscripts\n \t of the same expression.  */\n       ref = TREE_OPERAND (ref, 0);\n       suppress_warning (ref, OPT_Warray_bounds_);\n+      suppress_warning (ref, OPT_Wstrict_flex_arrays);\n \n       if (decl)\n \tref = decl;"}, {"sha": "9b5f6cd3223c5105029b91417d5df3f206b1f003", "filename": "gcc/loop-invariant.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Floop-invariant.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Floop-invariant.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1837,6 +1837,8 @@ move_invariant_reg (class loop *loop, unsigned invno)\n       else if (dump_file)\n \tfprintf (dump_file, \"Invariant %d moved without introducing a new \"\n \t\t\t    \"temporary register\\n\", invno);\n+      if (JUMP_P (BB_END (preheader)))\n+\tpreheader = split_edge (loop_preheader_edge (loop));\n       reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n       df_recompute_luids (preheader);\n "}, {"sha": "c23beec42c02afbc298e09a1338283c909899688", "filename": "gcc/m2/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,14 @@\n+2022-12-15  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* configure.ac: Stop probing for realpath.\n+\t* tools-src/calcpath: Break dependency on realpath, cut\n+\tand echo.\n+\t* configure: Rebuilt.\n+\n+2022-12-15  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2config.h.in: Rebuilt.\n+\n 2022-12-14  Gaius Mulley  <gaiusmod2@gmail.com>\n \n \t* COPYING.FDL: New file."}, {"sha": "91768ab9c6ffd4be945f23e6c8d9cc014e2604f4", "filename": "gcc/m2/configure", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fconfigure?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -630,7 +630,6 @@ CPPFLAGS\n LDFLAGS\n CFLAGS\n CC\n-regex_realpath\n target_os\n target_vendor\n target_cpu\n@@ -2235,52 +2234,6 @@ test -n \"$target_alias\" &&\n     NONENONEs,x,x, &&\n   program_prefix=${target_alias}-\n \n-for ac_prog in realpath\n-do\n-  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n-set dummy $ac_prog; ac_word=$2\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n-$as_echo_n \"checking for $ac_word... \" >&6; }\n-if ${ac_cv_prog_regex_realpath+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  if test -n \"$regex_realpath\"; then\n-  ac_cv_prog_regex_realpath=\"$regex_realpath\" # Let the user override the test.\n-else\n-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n-for as_dir in $PATH\n-do\n-  IFS=$as_save_IFS\n-  test -z \"$as_dir\" && as_dir=.\n-    for ac_exec_ext in '' $ac_executable_extensions; do\n-  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n-    ac_cv_prog_regex_realpath=\"$ac_prog\"\n-    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n-    break 2\n-  fi\n-done\n-  done\n-IFS=$as_save_IFS\n-\n-fi\n-fi\n-regex_realpath=$ac_cv_prog_regex_realpath\n-if test -n \"$regex_realpath\"; then\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $regex_realpath\" >&5\n-$as_echo \"$regex_realpath\" >&6; }\n-else\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n-$as_echo \"no\" >&6; }\n-fi\n-\n-\n-  test -n \"$regex_realpath\" && break\n-done\n-\n-if test x$regex_realpath = \"x\" ; then\n-    as_fn_error $? \"realpath is required to build GNU Modula-2 (hint install coreutils).\" \"$LINENO\" 5\n-fi\n-\n ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'"}, {"sha": "5583af7f64c0b3f83a412a1e28dbee70f550a80e", "filename": "gcc/m2/configure.ac", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fconfigure.ac?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -24,11 +24,6 @@ AC_CANONICAL_BUILD\n AC_CANONICAL_HOST\n AC_CANONICAL_TARGET\n \n-AC_CHECK_PROGS(regex_realpath, realpath)\n-if test x$regex_realpath = \"x\" ; then\n-    AC_MSG_ERROR([realpath is required to build GNU Modula-2 (hint install coreutils).])\n-fi\n-\n AC_CHECK_FUNCS([stpcpy])\n \n AC_CHECK_HEADERS(sys/types.h)"}, {"sha": "05324513aa1ecc49f922f73e2eee7ad4edb66bcb", "filename": "gcc/m2/tools-src/calcpath", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2Ftools-src%2Fcalcpath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fm2%2Ftools-src%2Fcalcpath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Ftools-src%2Fcalcpath?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -23,27 +23,29 @@\n \n \n Usage () {\n-   echo \"Usage: calcpath pathcomponent1 pathcomponent2 subdir\"\n-   echo -n \"  if pathcomponent1 is relative then pathcomponent1/pathcomponet2/subdir is\"\n-   echo \" returned\"\n-   echo \"  otherwise pathcomponet2/subdir is returned\"\n-   echo \"  the path is checked for legality in subdir.\"\n+   cat<<EOF\n+Usage: $0 pathcomponent1 pathcomponent2 subdir\n+  if pathcomponent2 is relative then pathcomponent1/pathcompinent2/subdir is returned\n+  otherwise pathcomponent2/subdir is returned\n+  the path is checked for legality in subdir.\n+EOF\n }\n \n+die () {\n+   printf \"calcpath: error: %s\\n\" \"$1\" >&2\n+   exit 1\n+}\n \n if [ $# -eq 3 ]; then\n-   if [ \"$(echo $2 | cut -b 1)\" = \".\" ] ; then\n-       # relative path\n-       the_path=$1/$2/$3\n-   else\n-       the_path=$2/$3\n-   fi\n-   cd $3\n-   if realpath ${the_path} > /dev/null ; then\n-       echo ${the_path}\n+   case \"$2\" in\n+      /*) the_path=\"$2/$3\" ;;\n+      *) the_path=\"$1/$2/$3\" ;;\n+   esac\n+   cd \"$3\" || die \"could not access $3\"\n+   if ( cd \"$the_path\" ); then\n+      printf '%s\\n' \"${the_path}\"\n    else\n-       echo \"calcpath: error ${the_path} is not a valid path in subdirectory $3\" 1>&2\n-       exit 1\n+      die \"${the_path} is not a valid path in subdirectory $3\"\n    fi\n else\n    Usage"}, {"sha": "7981e2c9540d60dc3530233267a4cc4983220529", "filename": "gcc/opts.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Fopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1411,6 +1411,14 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n       opts->x_profile_flag = 0;\n     }\n \n+  if (opts->x_warn_strict_flex_arrays)\n+    if (opts->x_flag_strict_flex_arrays == 0)\n+      {\n+\topts->x_warn_strict_flex_arrays = 0;\n+\twarning_at (UNKNOWN_LOCATION, 0,\n+\t\t    \"%<-Wstrict-flex-arrays%> is ignored when\"\n+\t\t    \" %<-fstrict-flex-arrays%> is not present\");\n+      }\n \n   diagnose_options (opts, opts_set, loc);\n }"}, {"sha": "24c4756a31f5cad96afabd8df9ac4180c8cbeb0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,125 @@\n+2022-12-16  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* lib/target-supports.exp (check_effective_target_static): Return 0\n+\ton hppa*-*-*.\n+\n+2022-12-16  Andrew Pinski  <pinskia@gmail.com>\n+\t    Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/107768\n+\t* g++.dg/coroutines/pr107768.C: New test.\n+\n+2022-12-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/106479\n+\t* gcc.dg/analyzer/pr104308.c (test_memmove_within_uninit): Remove\n+\txfail on region creation event.\n+\n+2022-12-16  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\tRevert:\n+\t2022-12-16  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* gcc.target/avr/pr90706.c: New.\n+\n+2022-12-16  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\t* gcc.dg/Warray-bounds-flex-arrays-1.c: Update testing case with\n+\t-Wstrict-flex-arrays.\n+\t* gcc.dg/Warray-bounds-flex-arrays-2.c: Likewise.\n+\t* gcc.dg/Warray-bounds-flex-arrays-3.c: Likewise.\n+\t* gcc.dg/Warray-bounds-flex-arrays-4.c: Likewise.\n+\t* gcc.dg/Warray-bounds-flex-arrays-5.c: Likewise.\n+\t* gcc.dg/Warray-bounds-flex-arrays-6.c: Likewise.\n+\t* c-c++-common/Wstrict-flex-arrays.c: New test.\n+\t* gcc.dg/Wstrict-flex-arrays-2.c: New test.\n+\t* gcc.dg/Wstrict-flex-arrays-3.c: New test.\n+\t* gcc.dg/Wstrict-flex-arrays.c: New test.\n+\n+2022-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/106751\n+\t* gcc.c-torture/compile/pr106751.c: New test.\n+\n+2022-12-16  Haochen Jiang  <haochen.jiang@intel.com>\n+\n+\t* gcc.target/i386/cmpccxadd-1.c: Fix intrin name.\n+\t* gcc.target/i386/cmpccxadd-2.c: Ditto.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/102104\n+\tPR c++/108090\n+\t* g++.dg/cpp1z/using-variadic1.C: New test.\n+\t* g++.dg/cpp1z/using-variadic1a.C: New test.\n+\t* g++.dg/cpp1z/using-variadic1b.C: New test.\n+\t* g++.dg/cpp1z/using-variadic1c.C: New test.\n+\t* g++.dg/cpp1z/using-variadic2.C: New test.\n+\t* g++.dg/cpp1z/using-variadic3.C: New test.\n+\n+2022-12-15  Arsen Arsenovi\u0107  <arsen@aarsen.me>\n+\n+\t* g++.dg/contracts/contracts-externC.C: New test.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107188\n+\t* g++.dg/cpp2a/concepts-placeholder11.C: New test.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/100295\n+\tPR c++/107579\n+\t* g++.dg/cpp1z/constexpr-if-lambda5.C: New test.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/105518\n+\t* g++.dg/cpp0x/lambda/lambda-alias1.C: New test.\n+\n+2022-12-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/108104\n+\t* g++.dg/template/ptrmem33.C: New test.\n+\n+2022-12-15  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* gcc.target/avr/pr90706.c: New.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/107065\n+\t* g++.dg/cpp0x/pr107065.C: New test.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libstdc++/108075\n+\t* g++.dg/cpp23/ext-floating13.C: New test.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lib/target-supports.exp (check_compile): Further quoting\n+\tfixes for /* Assembly, /* ObjC and (* Modula-2 *) checks.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lib/target-supports.exp (check_compile): Add support for\n+\tRust and Modula-2.  Use \\* rather than * for /* comment for\n+\tAssembly.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108095\n+\t* gcc.dg/pr108095.c: New test.\n+\n+2022-12-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108071\n+\tPR c++/105838\n+\t* g++.dg/cpp0x/initlist131.C: New test.\n+\t* g++.dg/cpp0x/initlist132.C: New test.\n+\t* g++.dg/cpp0x/initlist133.C: New test.\n+\n 2022-12-14  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/108065"}, {"sha": "51514231661ebb660e878202cf19cf218369713e", "filename": "gcc/testsuite/c-c++-common/Wstrict-flex-arrays.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstrict-flex-arrays.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstrict-flex-arrays.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstrict-flex-arrays.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,9 @@\n+/* Test the usage of option -Wstrict-flex-arrays.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays\" } */\n+\n+int main(int argc, char *argv[])\n+{\n+    return 0;\n+}\n+/* { dg-warning \"is ignored when \\'-fstrict-flex-arrays\\' is not present\" \"\" { target *-*-* } 0 } */"}, {"sha": "873056b742bb40926368ed5cdfe33cbd461d0c30", "filename": "gcc/testsuite/g++.dg/contracts/contracts-externC.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-externC.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-externC.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcontracts%2Fcontracts-externC.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,19 @@\n+// simple check to ensure we don't emit a function with the same name twice,\n+// when wrapping functions in pre- and postconditions.\n+// { dg-do link }\n+// { dg-options \"-std=c++2a -fcontracts -fcontract-continuation-mode=on\" }\n+\n+volatile int x = 10;\n+\n+extern \"C\" void\n+f ()\n+  [[ pre: x < 10 ]]\n+{\n+}\n+\n+int\n+main ()\n+  [[ post: x > 10 ]]\n+{\n+  f();\n+}"}, {"sha": "22d7074f2615caedf8f15d05ab16f1422e67e0bf", "filename": "gcc/testsuite/g++.dg/coroutines/pr107768.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr107768.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr107768.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr107768.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,26 @@\n+//  { dg-additional-options \"-Wzero-as-null-pointer-constant -fsyntax-only\" }\n+\n+#include <coroutine>\n+ \n+struct task\n+{\n+    struct promise_type\n+    {\n+        task get_return_object() { return {}; }\n+        std::suspend_never initial_suspend() { return {}; }\n+        std::suspend_never final_suspend() noexcept { return {}; }\n+        void return_void() {}\n+        void unhandled_exception() {}\n+    };\n+};\n+ \n+task resuming_on_new_thread(void)\n+{\n+    struct awaitable\n+    {\n+        bool await_ready() { return false; }\n+        void await_suspend(std::coroutine_handle<> h)         {         }\n+        void await_resume() {}\n+    };\n+    co_await awaitable{};\n+}"}, {"sha": "08c38e6f84c6e0fd9fcd8da6298c07fe180c468b", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-alias1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-alias1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-alias1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-alias1.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/105518\n+// { dg-do compile { target c++11 } }\n+\n+struct integral_constant {\n+  constexpr operator int() const { return 42; }\n+};\n+\n+template<int N>\n+struct A {\n+  using type = A;\n+  static constexpr int value = N;\n+};\n+\n+template<class T>\n+void f(T t) {\n+  using alias = A<t>;\n+  [](int) {\n+    typename alias::type a; // { dg-bogus \"'t' is not captured\" }\n+    return a.value;\n+  }(0);\n+}\n+\n+template void f(integral_constant);"}, {"sha": "5e18bb91cff77e879669ac329e0b0d3a8e224ed7", "filename": "gcc/testsuite/g++.dg/cpp0x/pr107065.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr107065.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr107065.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr107065.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/107065\n+// { dg-do compile { target c++11 } }\n+\n+template<class, class> struct is_same { static constexpr bool value = false; };\n+template<class T> struct is_same<T, T> { static constexpr bool value = true; };\n+\n+int\n+main ()\n+{\n+  bool b = true;\n+  static_assert (is_same<decltype (!(!b)), bool>::value, \"\");\n+  auto bb = (!(!b));\n+  static_assert (is_same<decltype (bb), bool>::value, \"\");\n+}"}, {"sha": "f9b4e0187e209e67069dd02aff3838a7ac8241dc", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-107437.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-107437.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-107437.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-107437.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/107437\n+// { dg-do compile { target c++14 } }\n+\n+struct integral_constant {\n+  constexpr operator int() const { return 42; }\n+};\n+\n+template<int N>\n+struct A {\n+  static constexpr int value = N;\n+};\n+\n+template<class T>\n+void f(T t) {\n+  [=](auto) {\n+    A<t> a; // { dg-bogus \"constant\" }\n+    return a.value;\n+  }(0);\n+}\n+\n+template void f(integral_constant);"}, {"sha": "d2bf0221743f1d4f61b05288ac661a3c0ce0b2f1", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-if-lambda5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-if-lambda5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-if-lambda5.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/100295\n+// { dg-do compile { target c++17 } }\n+\n+template<typename... Ts>\n+void f(Ts... ts) {\n+  auto lambda = [=](auto x) {\n+    if constexpr (sizeof((ts+x) + ...) != 0)\n+      (..., ts);\n+  };\n+  lambda(0);\n+}\n+\n+int main() {\n+  f(0, 'a');\n+}"}, {"sha": "e66cd1dee64232ac1e35159032c3a93db319ef16", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-lambda26.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda26.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,7 +1,6 @@\n // PR c++/87765\n // { dg-do compile { target c++17 } }\n // { dg-additional-options \"-fchecking\" }\n-// { dg-ice \"cxx_eval_constant_expression\" }\n \n template <int N>\n using foo = int;"}, {"sha": "7a8bcbbe37291a4a2f5f1c18675837abd5a3017e", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/102104\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+  operator bool*();\n+};\n+\n+struct B {\n+  using target_type = long*;\n+  operator long*();\n+};\n+\n+template<typename... Bases>\n+struct cls : private Bases... {\n+  using Bases::operator typename Bases::target_type...;\n+};\n+\n+cls<A, B> v1;\n+bool* a1 = v1;\n+long* b1 = v1;\n+\n+cls<B> v2;\n+bool* a2 = v2; // { dg-error \"cannot convert\" }\n+long* b2 = v2;\n+\n+cls<A> v3;\n+bool* a3 = v3;\n+long* b3 = v3; // { dg-error \"cannot convert\" }"}, {"sha": "0393cab6ace1c566de73c6198c1531abe651ba01", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1a.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1a.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/102104\n+// A version of using-variadic1.C where the qualifying scope and the\n+// terminal name of the using-declaration use different parameter packs.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+  operator bool*();\n+};\n+\n+struct B {\n+  using target_type = long*;\n+  operator long*();\n+};\n+\n+template<typename... Bases>\n+struct cls {\n+  template<class... Ts>\n+  struct nested : private Bases... {\n+    using Bases::operator typename Ts::target_type...;\n+  };\n+};\n+\n+cls<A, B>::nested<A, B> v1;\n+bool* a1 = v1;\n+long* b1 = v1;\n+\n+cls<B>::nested<B> v2;\n+bool* a2 = v2; // { dg-error \"cannot convert\" }\n+long* b2 = v2;\n+\n+cls<A>::nested<A> v3;\n+bool* a3 = v3;\n+long* b3 = v3; // { dg-error \"cannot convert\" }"}, {"sha": "fd3a41718b6c9a0ae72769443a2bbce61b5034fa", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1b.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1b.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/102104\n+// A version of using-variadic1.C where only the qualifying scope\n+// uses a parameter pack.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+};\n+\n+struct B {\n+  using target_type = long*;\n+};\n+\n+struct C {\n+  operator bool*();\n+  operator long*();\n+};\n+\n+template<typename Base>\n+struct cls {\n+  template<class... Ts>\n+  struct nested : private Base {\n+    using Base::operator typename Ts::target_type...;\n+  };\n+};\n+\n+cls<C>::nested<A, B> v1;\n+bool* a1 = v1;\n+long* b1 = v1;\n+\n+cls<C>::nested<B> v2;\n+bool* a2 = v2; // { dg-error \"inaccessible|not an accessible\" }\n+long* b2 = v2;\n+\n+cls<C>::nested<A> v3;\n+bool* a3 = v3;\n+long* b3 = v3; // { dg-error \"inaccessible|not an accessible\" }"}, {"sha": "aa86b28fd2e02ea5c8cfd90e64695208fd09ae40", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1c.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1c.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/102104\n+// A version of of using-variadic1.C where only the terminal name\n+// uses a parameter pack.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  operator bool*();\n+};\n+\n+struct B {\n+  operator bool*();\n+};\n+\n+struct C {\n+  using target_type = bool*;\n+};\n+\n+template<typename... Bases>\n+struct cls {\n+  template<class T>\n+  struct nested : private Bases... {\n+    using Bases::operator typename T::target_type...;\n+  };\n+};\n+\n+cls<A, B>::nested<C> v1;\n+bool* a1 = v1; // { dg-error \"ambiguous\" }\n+\n+cls<A>::nested<C> v2;\n+bool* a2 = v2;\n+\n+cls<B>::nested<C> v3;\n+bool* a3 = v3;"}, {"sha": "1d68ceece8a5b35cd7cb97988a0272004dcd62f5", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic2.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/102104\n+// A version of using-variadic1a.C where the argument packs have\n+// different lengths.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+  operator bool*();\n+};\n+\n+struct B {\n+  using target_type = long*;\n+  operator long*();\n+};\n+\n+template<typename... Bases>\n+struct cls {\n+  template<class... Ts>\n+  struct nested : private Bases... {\n+    using Bases::operator typename Ts::target_type...; // { dg-error \"lengths\" }\n+  };\n+};\n+\n+cls<A>::nested<A, B> v1; // { dg-message \"required from here\" }"}, {"sha": "4e1d6894e5610c8a3fd3e59dceb6ed0eea6177db", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic3.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic3.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/108090\n+// { dg-do compile { target c++17 } }\n+\n+template<typename T> struct As { operator T(); };\n+template<typename ...T> struct AsAll : As<T>... {\n+  using As<T>::operator T...;\n+};\n+AsAll<int, float, char> x;"}, {"sha": "fd36c50ceae0ec8d26fb6c095df4f32f311cc71e", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating13.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating13.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,35 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do link { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include <typeinfo>\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+const std::type_info &a = typeid(decltype(0.0f16));\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+const std::type_info &b = typeid(decltype(0.0bf16));\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+const std::type_info &c = typeid(decltype(0.0f32));\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+const std::type_info &d = typeid(decltype(0.0f64));\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+const std::type_info &e = typeid(decltype(0.0f128));\n+#endif\n+#ifdef __FLT32X_MAX__\n+const std::type_info &f = typeid(decltype(0.0f32x));\n+#endif\n+#ifdef __FLT64X_MAX__\n+const std::type_info &g = typeid(decltype(0.0f64x));\n+#endif\n+#ifdef __FLT128X_MAX__\n+const std::type_info &h = typeid(decltype(0.0f128x));\n+#endif\n+\n+int\n+main ()\n+{\n+}"}, {"sha": "61eef743bae8bbe5cef0e47c44ca5449d9e0ff73", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-placeholder11.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-placeholder11.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/107188\n+// { dg-do compile { target c++20 } }\n+\n+namespace N {\n+  template<class, class> concept C = true;\n+}\n+\n+struct X {\n+  N::C<int> auto f() { return 0; }\n+};"}, {"sha": "dca741ae5e2a793acb7199bf3faa6efbe2a947f9", "filename": "gcc/testsuite/g++.dg/template/ptrmem33.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem33.C?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/108104\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  void x();\n+  void y();\n+};\n+\n+enum State { On };\n+\n+template<State state, void (A::*)()>\n+struct B {\n+  static void f();\n+};\n+\n+template<State state>\n+struct B<state, nullptr> {\n+  static void g();\n+};\n+\n+template<State state>\n+struct B<state, &A::y> {\n+  static void h();\n+};\n+\n+int main() {\n+  B<State::On, &A::x>::f();\n+  B<State::On, nullptr>::g();\n+  B<State::On, &A::y>::h();\n+}"}, {"sha": "5fbf93bd332e83b8389e40375527da5b067c3a63", "filename": "gcc/testsuite/gcc.c-torture/compile/pr106751.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr106751.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr106751.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr106751.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,17 @@\n+/* PR rtl-optimization/106751 */\n+\n+int *foo (void);\n+\n+void\n+bar (void)\n+{\n+  asm goto (\"\" : : : : lab);\n+  __builtin_unreachable ();\n+lab:\n+  while (1)\n+    {\n+      int o;\n+      asm (\"\" : \"=r\" (o) : \"g\" (1));\n+      *foo () = o;\n+    }\n+}"}, {"sha": "65c9fec43af8385b56c0c8a945df8c443baa771c", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-1.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,6 +1,6 @@\n-/* Test -fstrict-flex-arrays + -Warray-bounds.  */\n+/* Test -fstrict-flex-arrays + -Warray-bounds + -Wstrict-flex-arrays.  */\n /* { dg-do compile} */\n-/* { dg-options \"-O2 -fstrict-flex-arrays=1 -Warray-bounds\" } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=1 -Warray-bounds\" } */\n \n struct trailing_array_1 {\n     int a;\n@@ -32,6 +32,7 @@ void __attribute__((__noinline__)) stuff(\n     struct trailing_array_4 *trailing_flex)\n {\n     normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    \t\t\t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_1->c[2] = 2; /* { dg-bogus \"array subscript \" } */\n     trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n     trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */"}, {"sha": "2b5a895c598654c59dfdcde7b08e7e192c2d7ff6", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-2.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,6 +1,6 @@\n-/* Test -fstrict-flex-arrays + -Warray-bounds.  */\n+/* Test -fstrict-flex-arrays + -Warray-bounds + -Wstrict-flex-arrays.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fstrict-flex-arrays=2 -Warray-bounds\" } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=2 -Warray-bounds\" } */\n \n struct trailing_array_1 {\n     int a;\n@@ -32,7 +32,9 @@ void __attribute__((__noinline__)) stuff(\n     struct trailing_array_4 *trailing_flex)\n {\n     normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    \t\t\t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_1->c[2] = 2; /* { dg-warning \"array subscript 2 is above array bounds of\"  } */\n+    \t\t\t  /* { dg-warning \"should not be used as a flexible array member for level 2 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n     trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n "}, {"sha": "25b903f2615b84e11ddd5f9dfa31cb180e9eb392", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-3.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-3.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,6 +1,6 @@\n-/* Test -fstrict-flex-arrays + -Warray-bounds.  */\n+/* Test -fstrict-flex-arrays + -Warray-bounds + -Wstrict-flex-arrays.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fstrict-flex-arrays=3 -Warray-bounds\" } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=3 -Warray-bounds\" } */\n \n struct trailing_array_1 {\n     int a;\n@@ -32,8 +32,11 @@ void __attribute__((__noinline__)) stuff(\n     struct trailing_array_4 *trailing_flex)\n {\n     normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */ \n+    \t\t\t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_1->c[2] = 2; /*{ dg-warning \"array subscript 2 is above array bounds of\" } */ \n+    \t\t\t  /* { dg-warning \"should not be used as a flexible array member for level 2 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_0->c[1] = 1; /*{ dg-warning \"array subscript 1 is outside array bounds of\" } */ \n+    \t\t\t  /* { dg-warning \"should not be used as a flexible array member for level 3\" \"\" { target *-*-* } .-1 } */\n     trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript\" } */\n \n }"}, {"sha": "5fc500a19ca6ac88d7f9ed8a95fa86b7233f6262", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-4.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-4.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,6 +1,6 @@\n-/* Test -fstrict-flex-arrays + -Warray-bounds=2.  */\n+/* Test -fstrict-flex-arrays + -Warray-bounds=2 + -Wstrict-flex-arrays.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fstrict-flex-arrays=1 -Warray-bounds=2\" } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=1 -Warray-bounds=2\" } */\n \n struct trailing_array_1 {\n     int a;\n@@ -32,6 +32,7 @@ void __attribute__((__noinline__)) stuff(\n     struct trailing_array_4 *trailing_flex)\n {\n     normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    \t\t\t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_1->c[2] = 2; /* { dg-bogus \"array subscript \" } */\n     trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n     trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */"}, {"sha": "30bb4ca8832eb6de31fc26f38bd5281c97041728", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-5.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-5.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,6 +1,6 @@\n-/* Test -fstrict-flex-arrays + -Warray-bounds=2.  */\n+/* Test -fstrict-flex-arrays + -Warray-bounds=2 + -Wstrict-flex-arrays.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fstrict-flex-arrays=2 -Warray-bounds=2\" } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=2 -Warray-bounds=2\" } */\n \n struct trailing_array_1 {\n     int a;\n@@ -32,7 +32,9 @@ void __attribute__((__noinline__)) stuff(\n     struct trailing_array_4 *trailing_flex)\n {\n     normal->c[5] = 5;   /*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    \t\t\t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_1->c[2] = 2; /*{ dg-warning \"array subscript 2 is above array bounds of\" } */\n+    \t\t\t  /* { dg-warning \"should not be used as a flexible array member for level 2 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n     trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n "}, {"sha": "e847a44516e2ee0a3e4b74b596486fb07c647061", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-6.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-6.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,6 +1,6 @@\n-/* Test -fstrict-flex-arrays + -Warray-bounds=2.  */\n+/* Test -fstrict-flex-arrays + -Warray-bounds=2 + -Wstrict-flex-arrays.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fstrict-flex-arrays=3 -Warray-bounds=2\" } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=3 -Warray-bounds=2\" } */\n \n struct trailing_array_1 {\n     int a;\n@@ -32,8 +32,11 @@ void __attribute__((__noinline__)) stuff(\n     struct trailing_array_4 *trailing_flex)\n {\n     normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */ \n+    \t\t\t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_1->c[2] = 2; /*{ dg-warning \"array subscript 2 is above array bounds of\" } */\n+    \t\t\t  /* { dg-warning \"should not be used as a flexible array member for level 2 and above\" \"\" { target *-*-* } .-1 } */\n     trailing_0->c[1] = 1; /*{ dg-warning \"array subscript 1 is outside array bounds of\" } */\n+    \t\t\t  /* { dg-warning \"should not be used as a flexible array member for level 3\" \"\" { target *-*-* } .-1 } */\n     trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n \n }"}, {"sha": "2e241f962087d0143a4742807169951fd4ca30ef", "filename": "gcc/testsuite/gcc.dg/Wstrict-flex-arrays-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays-2.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,39 @@\n+/* Test -Wstrict-flex-arrays.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=2\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" } */\n+    trailing_1->c[2] = 2; /* { dg-warning \"should not be used as a flexible array member for level 2 and above\" } */\n+    trailing_0->c[1] = 1; /* { dg-bogus \"should not be used as a flexible array member for level 2 and above\" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"should not be used as a flexible array member for level 2 and above\" } */\n+\n+}"}, {"sha": "97eb65ba0a96d4383e3a0ac3ca60ee2bec4486b1", "filename": "gcc/testsuite/gcc.dg/Wstrict-flex-arrays-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays-3.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,39 @@\n+/* Test -Wstrict-flex-arrays.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=3\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" } */\n+    trailing_1->c[2] = 2; /* { dg-warning \"should not be used as a flexible array member for level 2 and above\" } */\n+    trailing_0->c[1] = 1; /* { dg-warning \"should not be used as a flexible array member for level 3\" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"should not be used as a flexible array member for level 3\" } */\n+\n+}"}, {"sha": "110fdc72778ac658401e23f73c2175bb29d6e0b8", "filename": "gcc/testsuite/gcc.dg/Wstrict-flex-arrays.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-flex-arrays.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,39 @@\n+/* Test -Wstrict-flex-arrays.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-flex-arrays -fstrict-flex-arrays=1\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"should not be used as a flexible array member for level 1 and above\" } */\n+    trailing_1->c[2] = 2; /* { dg-bogus \"should not be used as a flexible array member for level 1 and above\" } */\n+    trailing_0->c[1] = 1; /* { dg-bogus \"should not be used as a flexible array member for level 1 and above\" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"should not be used as a flexible array member for level 1 and above\" } */\n+\n+}"}, {"sha": "a3a0cbb731776b26e2ba9447baa7c39f80821a57", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104308.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104308.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104308.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104308.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -6,7 +6,7 @@\n \n int test_memmove_within_uninit (void)\n {\n-  char s[5]; /* { dg-message \"region created on stack here\" \"\" { xfail riscv*-*-* } } */\n+  char s[5]; /* { dg-message \"region created on stack here\" } */\n   memmove(s, s + 1, 2); /* { dg-warning \"use of uninitialized value\" } */\n   return 0;\n }"}, {"sha": "537b79b8d2d4cd1e1c34f6869ad425d447e928a0", "filename": "gcc/testsuite/gcc.target/i386/cmpccxadd-1.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmpccxadd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmpccxadd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmpccxadd-1.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -26,36 +26,36 @@ long long e, f;\n void extern\n cmpccxadd_test(void)\n {\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_O);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_O);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NO);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NO);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_B);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_B);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NB);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NB);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_Z);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_Z);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NZ);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NZ);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_BE);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_BE);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NBE);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NBE);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_S);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_S);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NS);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NS);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_P);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_P);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NP);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NP);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_L);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_L);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NL);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NL);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_LE);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_LE);\n-  b = __cmpccxadd_epi32 (a, b, c, _CMPCCX_NLE);\n-  e = __cmpccxadd_epi64 (d, e, f, _CMPCCX_NLE);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_O);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_O);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NO);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NO);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_B);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_B);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NB);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NB);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_Z);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_Z);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NZ);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NZ);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_BE);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_BE);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NBE);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NBE);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_S);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_S);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NS);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NS);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_P);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_P);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NP);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NP);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_L);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_L);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NL);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NL);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_LE);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_LE);\n+  b = _cmpccxadd_epi32 (a, b, c, _CMPCCX_NLE);\n+  e = _cmpccxadd_epi64 (d, e, f, _CMPCCX_NLE);\n }"}, {"sha": "5e897b12c66e0b510cf6e262fffcd22b1b83ca01", "filename": "gcc/testsuite/gcc.target/i386/cmpccxadd-2.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmpccxadd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmpccxadd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcmpccxadd-2.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -92,39 +92,39 @@ main()\n     _srcdest2_64[i] = srcdest1_64[i];\n   }\n \n-  res[0] = __cmpccxadd_epi32 (&srcdest1[0], srcdest2[0], src3[0], _CMPCCX_O);\n-  res[1] = __cmpccxadd_epi32 (&srcdest1[1], srcdest2[1], src3[1], _CMPCCX_NO);\n-  res[2] = __cmpccxadd_epi32 (&srcdest1[2], srcdest2[2], src3[2], _CMPCCX_B);\n-  res[3] = __cmpccxadd_epi32 (&srcdest1[3], srcdest2[3], src3[3], _CMPCCX_NB);\n-  res[4] = __cmpccxadd_epi32 (&srcdest1[4], srcdest2[4], src3[4], _CMPCCX_Z);\n-  res[5] = __cmpccxadd_epi32 (&srcdest1[5], srcdest2[5], src3[5], _CMPCCX_NZ);\n-  res[6] = __cmpccxadd_epi32 (&srcdest1[6], srcdest2[6], src3[6], _CMPCCX_BE);\n-  res[7] = __cmpccxadd_epi32 (&srcdest1[7], srcdest2[7], src3[7], _CMPCCX_NBE);\n-  res[8] = __cmpccxadd_epi32 (&srcdest1[8], srcdest2[8], src3[8], _CMPCCX_S);\n-  res[9] = __cmpccxadd_epi32 (&srcdest1[9], srcdest2[9], src3[9], _CMPCCX_NS);\n-  res[10] = __cmpccxadd_epi32 (&srcdest1[10], srcdest2[10], src3[10], _CMPCCX_P);\n-  res[11] = __cmpccxadd_epi32 (&srcdest1[11], srcdest2[11], src3[11], _CMPCCX_NP);\n-  res[12] = __cmpccxadd_epi32 (&srcdest1[12], srcdest2[12], src3[12], _CMPCCX_L);\n-  res[13] = __cmpccxadd_epi32 (&srcdest1[13], srcdest2[13], src3[13], _CMPCCX_NL);\n-  res[14] = __cmpccxadd_epi32 (&srcdest1[14], srcdest2[14], src3[14], _CMPCCX_LE);\n-  res[15] = __cmpccxadd_epi32 (&srcdest1[15], srcdest2[15], src3[15], _CMPCCX_NLE);\n+  res[0] = _cmpccxadd_epi32 (&srcdest1[0], srcdest2[0], src3[0], _CMPCCX_O);\n+  res[1] = _cmpccxadd_epi32 (&srcdest1[1], srcdest2[1], src3[1], _CMPCCX_NO);\n+  res[2] = _cmpccxadd_epi32 (&srcdest1[2], srcdest2[2], src3[2], _CMPCCX_B);\n+  res[3] = _cmpccxadd_epi32 (&srcdest1[3], srcdest2[3], src3[3], _CMPCCX_NB);\n+  res[4] = _cmpccxadd_epi32 (&srcdest1[4], srcdest2[4], src3[4], _CMPCCX_Z);\n+  res[5] = _cmpccxadd_epi32 (&srcdest1[5], srcdest2[5], src3[5], _CMPCCX_NZ);\n+  res[6] = _cmpccxadd_epi32 (&srcdest1[6], srcdest2[6], src3[6], _CMPCCX_BE);\n+  res[7] = _cmpccxadd_epi32 (&srcdest1[7], srcdest2[7], src3[7], _CMPCCX_NBE);\n+  res[8] = _cmpccxadd_epi32 (&srcdest1[8], srcdest2[8], src3[8], _CMPCCX_S);\n+  res[9] = _cmpccxadd_epi32 (&srcdest1[9], srcdest2[9], src3[9], _CMPCCX_NS);\n+  res[10] = _cmpccxadd_epi32 (&srcdest1[10], srcdest2[10], src3[10], _CMPCCX_P);\n+  res[11] = _cmpccxadd_epi32 (&srcdest1[11], srcdest2[11], src3[11], _CMPCCX_NP);\n+  res[12] = _cmpccxadd_epi32 (&srcdest1[12], srcdest2[12], src3[12], _CMPCCX_L);\n+  res[13] = _cmpccxadd_epi32 (&srcdest1[13], srcdest2[13], src3[13], _CMPCCX_NL);\n+  res[14] = _cmpccxadd_epi32 (&srcdest1[14], srcdest2[14], src3[14], _CMPCCX_LE);\n+  res[15] = _cmpccxadd_epi32 (&srcdest1[15], srcdest2[15], src3[15], _CMPCCX_NLE);\n \n-  res_64[0] = __cmpccxadd_epi64 (&srcdest1_64[0], srcdest2_64[0], src3_64[0], _CMPCCX_O);\n-  res_64[1] = __cmpccxadd_epi64 (&srcdest1_64[1], srcdest2_64[1], src3_64[1], _CMPCCX_NO);\n-  res_64[2] = __cmpccxadd_epi64 (&srcdest1_64[2], srcdest2_64[2], src3_64[2], _CMPCCX_B);\n-  res_64[3] = __cmpccxadd_epi64 (&srcdest1_64[3], srcdest2_64[3], src3_64[3], _CMPCCX_NB);\n-  res_64[4] = __cmpccxadd_epi64 (&srcdest1_64[4], srcdest2_64[4], src3_64[4], _CMPCCX_Z);\n-  res_64[5] = __cmpccxadd_epi64 (&srcdest1_64[5], srcdest2_64[5], src3_64[5], _CMPCCX_NZ);\n-  res_64[6] = __cmpccxadd_epi64 (&srcdest1_64[6], srcdest2_64[6], src3_64[6], _CMPCCX_BE);\n-  res_64[7] = __cmpccxadd_epi64 (&srcdest1_64[7], srcdest2_64[7], src3_64[7], _CMPCCX_NBE);\n-  res_64[8] = __cmpccxadd_epi64 (&srcdest1_64[8], srcdest2_64[8], src3_64[8], _CMPCCX_S);\n-  res_64[9] = __cmpccxadd_epi64 (&srcdest1_64[9], srcdest2_64[9], src3_64[9], _CMPCCX_NS);\n-  res_64[10] = __cmpccxadd_epi64 (&srcdest1_64[10], srcdest2_64[10], src3_64[10], _CMPCCX_P);\n-  res_64[11] = __cmpccxadd_epi64 (&srcdest1_64[11], srcdest2_64[11], src3_64[11], _CMPCCX_NP);\n-  res_64[12] = __cmpccxadd_epi64 (&srcdest1_64[12], srcdest2_64[12], src3_64[12], _CMPCCX_L);\n-  res_64[13] = __cmpccxadd_epi64 (&srcdest1_64[13], srcdest2_64[13], src3_64[13], _CMPCCX_NL);\n-  res_64[14] = __cmpccxadd_epi64 (&srcdest1_64[14], srcdest2_64[14], src3_64[14], _CMPCCX_LE);\n-  res_64[15] = __cmpccxadd_epi64 (&srcdest1_64[15], srcdest2_64[15], src3_64[15], _CMPCCX_NLE);\n+  res_64[0] = _cmpccxadd_epi64 (&srcdest1_64[0], srcdest2_64[0], src3_64[0], _CMPCCX_O);\n+  res_64[1] = _cmpccxadd_epi64 (&srcdest1_64[1], srcdest2_64[1], src3_64[1], _CMPCCX_NO);\n+  res_64[2] = _cmpccxadd_epi64 (&srcdest1_64[2], srcdest2_64[2], src3_64[2], _CMPCCX_B);\n+  res_64[3] = _cmpccxadd_epi64 (&srcdest1_64[3], srcdest2_64[3], src3_64[3], _CMPCCX_NB);\n+  res_64[4] = _cmpccxadd_epi64 (&srcdest1_64[4], srcdest2_64[4], src3_64[4], _CMPCCX_Z);\n+  res_64[5] = _cmpccxadd_epi64 (&srcdest1_64[5], srcdest2_64[5], src3_64[5], _CMPCCX_NZ);\n+  res_64[6] = _cmpccxadd_epi64 (&srcdest1_64[6], srcdest2_64[6], src3_64[6], _CMPCCX_BE);\n+  res_64[7] = _cmpccxadd_epi64 (&srcdest1_64[7], srcdest2_64[7], src3_64[7], _CMPCCX_NBE);\n+  res_64[8] = _cmpccxadd_epi64 (&srcdest1_64[8], srcdest2_64[8], src3_64[8], _CMPCCX_S);\n+  res_64[9] = _cmpccxadd_epi64 (&srcdest1_64[9], srcdest2_64[9], src3_64[9], _CMPCCX_NS);\n+  res_64[10] = _cmpccxadd_epi64 (&srcdest1_64[10], srcdest2_64[10], src3_64[10], _CMPCCX_P);\n+  res_64[11] = _cmpccxadd_epi64 (&srcdest1_64[11], srcdest2_64[11], src3_64[11], _CMPCCX_NP);\n+  res_64[12] = _cmpccxadd_epi64 (&srcdest1_64[12], srcdest2_64[12], src3_64[12], _CMPCCX_L);\n+  res_64[13] = _cmpccxadd_epi64 (&srcdest1_64[13], srcdest2_64[13], src3_64[13], _CMPCCX_NL);\n+  res_64[14] = _cmpccxadd_epi64 (&srcdest1_64[14], srcdest2_64[14], src3_64[14], _CMPCCX_LE);\n+  res_64[15] = _cmpccxadd_epi64 (&srcdest1_64[15], srcdest2_64[15], src3_64[15], _CMPCCX_NLE);\n \n   for (int i = 0; i < 16; i++)\n   {"}, {"sha": "dccd1aed7c5ad6f3b55a7a1a9939df89f273feae", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1218,6 +1218,9 @@ proc check_effective_target_static {} {\n \n # Return 1 if the target supports -fstack-protector\n proc check_effective_target_fstack_protector {} {\n+    if { [istarget hppa*-*-*] } {\n+\treturn 0;\n+    }\n     return [check_runtime fstack_protector {\n \t#include <string.h>\n \tint main (int argc, char *argv[]) {"}, {"sha": "c6c86af6c4ea9c63a1cb20f29b07732fefd74f31", "filename": "gcc/tree-inline.cc", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftree-inline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftree-inline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -183,7 +183,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  return name;\n \t}\n \n-      return unshare_expr (*n);\n+      return *n;\n     }\n \n   if (processing_debug_stmt)\n@@ -1535,7 +1535,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n       if (id->reset_location)\n \tgimple_set_location (bind, input_location);\n       id->debug_stmts.safe_push (bind);\n-      gimple_seq_add_stmt (&stmts, bind);\n+      gimple_seq_add_stmt_without_update (&stmts, bind);\n       return stmts;\n     }\n \n@@ -1765,7 +1765,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n     }\n   else\n     {\n-      if (gimple_assign_copy_p (stmt)\n+      if (gimple_assign_single_p (stmt)\n \t  && gimple_assign_lhs (stmt) == gimple_assign_rhs1 (stmt)\n \t  && auto_var_in_fn_p (gimple_assign_lhs (stmt), id->src_fn))\n \t{\n@@ -1833,7 +1833,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t  if (id->reset_location)\n \t    gimple_set_location (copy, input_location);\n \t  id->debug_stmts.safe_push (copy);\n-\t  gimple_seq_add_stmt (&stmts, copy);\n+\t  gimple_seq_add_stmt_without_update (&stmts, copy);\n \t  return stmts;\n \t}\n       if (gimple_debug_source_bind_p (stmt))\n@@ -1845,7 +1845,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t  if (id->reset_location)\n \t    gimple_set_location (copy, input_location);\n \t  id->debug_stmts.safe_push (copy);\n-\t  gimple_seq_add_stmt (&stmts, copy);\n+\t  gimple_seq_add_stmt_without_update (&stmts, copy);\n \t  return stmts;\n \t}\n       if (gimple_debug_nonbind_marker_p (stmt))\n@@ -1859,7 +1859,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \n \t  gdebug *copy = as_a <gdebug *> (gimple_copy (stmt));\n \t  id->debug_stmts.safe_push (copy);\n-\t  gimple_seq_add_stmt (&stmts, copy);\n+\t  gimple_seq_add_stmt_without_update (&stmts, copy);\n \t  return stmts;\n \t}\n \n@@ -1967,7 +1967,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t       !gsi_end_p (egsi);\n \t       gsi_next (&egsi))\n \t    walk_gimple_op (gsi_stmt (egsi), remap_gimple_op_r, &wi);\n-\t  gimple_seq_add_seq (&stmts, extra_stmts);\n+\t  gimple_seq_add_seq_without_update (&stmts, extra_stmts);\n \t}\n     }\n \n@@ -2006,14 +2006,14 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t\t\t\t     gimple_cond_code (cond),\n \t\t\t\t     gimple_cond_lhs (cond),\n \t\t\t\t     gimple_cond_rhs (cond));\n-\t    gimple_seq_add_stmt (&stmts, cmp);\n+\t    gimple_seq_add_stmt_without_update (&stmts, cmp);\n \t    gimple_cond_set_code (cond, NE_EXPR);\n \t    gimple_cond_set_lhs (cond, gimple_assign_lhs (cmp));\n \t    gimple_cond_set_rhs (cond, boolean_false_node);\n \t  }\n     }\n \n-  gimple_seq_add_stmt (&stmts, copy);\n+  gimple_seq_add_stmt_without_update (&stmts, copy);\n   return stmts;\n }\n \n@@ -2074,21 +2074,6 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t  gimple_duplicate_stmt_histograms (cfun, stmt, id->src_cfun,\n \t\t\t\t\t    orig_stmt);\n \n-\t  /* With return slot optimization we can end up with\n-\t     non-gimple (foo *)&this->m, fix that here.  */\n-\t  if (is_gimple_assign (stmt)\n-\t      && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n-\t      && !is_gimple_val (gimple_assign_rhs1 (stmt)))\n-\t    {\n-\t      tree new_rhs;\n-\t      new_rhs = force_gimple_operand_gsi (&seq_gsi,\n-\t\t\t\t\t\t  gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t\t  true, NULL, false,\n-\t\t\t\t\t\t  GSI_CONTINUE_LINKING);\n-\t      gimple_assign_set_rhs1 (stmt, new_rhs);\n-\t      id->regimplify = false;\n-\t    }\n-\n \t  gsi_insert_after (&seq_gsi, stmt, GSI_NEW_STMT);\n \n \t  if (id->regimplify)\n@@ -2569,13 +2554,17 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t  && !old_edge->src->aux)\n \tnew_bb->count -= old_edge->count ().apply_scale (num, den);\n \n-  for (si = gsi_start_bb (new_bb); !gsi_end_p (si);)\n+  /* Walk stmts from end to start so that splitting will adjust the BB\n+     pointer for each stmt at most once, even when we split the block\n+     multiple times.  */\n+  bool seen_nondebug = false;\n+  for (si = gsi_last_bb (new_bb); !gsi_end_p (si);)\n     {\n       bool can_throw, nonlocal_goto;\n       gimple *copy_stmt = gsi_stmt (si);\n \n       /* Do this before the possible split_block.  */\n-      gsi_next (&si);\n+      gsi_prev (&si);\n \n       /* If this tree could throw an exception, there are two\n          cases where we need to add abnormal edge(s): the\n@@ -2595,25 +2584,23 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \n       if (can_throw || nonlocal_goto)\n \t{\n-\t  if (!gsi_end_p (si))\n-\t    {\n-\t      while (!gsi_end_p (si) && is_gimple_debug (gsi_stmt (si)))\n-\t\tgsi_next (&si);\n-\t      if (gsi_end_p (si))\n-\t\tneed_debug_cleanup = true;\n-\t    }\n-\t  if (!gsi_end_p (si))\n-\t    /* Note that bb's predecessor edges aren't necessarily\n-\t       right at this point; split_block doesn't care.  */\n+\t  /* If there's only debug insns after copy_stmt don't split\n+\t     the block but instead mark the block for cleanup.  */\n+\t  if (!seen_nondebug)\n+\t    need_debug_cleanup = true;\n+\t  else\n \t    {\n+\t      /* Note that bb's predecessor edges aren't necessarily\n+\t\t right at this point; split_block doesn't care.  */\n \t      edge e = split_block (new_bb, copy_stmt);\n-\n-\t      new_bb = e->dest;\n-\t      new_bb->aux = e->src->aux;\n-\t      si = gsi_start_bb (new_bb);\n+\t      e->dest->aux = new_bb->aux;\n+\t      seen_nondebug = false;\n \t    }\n \t}\n \n+      if (!is_gimple_debug (copy_stmt))\n+\tseen_nondebug = true;\n+\n       bool update_probs = false;\n \n       if (gimple_code (copy_stmt) == GIMPLE_EH_DISPATCH)"}, {"sha": "e6c6c5a301db725855ff7c76eebafaf34afaa01f", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1087,7 +1087,7 @@ execute_ranger_vrp (struct function *fun, bool warn_array_bounds_p,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     ranger->dump (dump_file);\n \n-  if (warn_array_bounds && warn_array_bounds_p)\n+  if ((warn_array_bounds || warn_strict_flex_arrays) && warn_array_bounds_p)\n     {\n       // Set all edges as executable, except those ranger says aren't.\n       int non_exec_flag = ranger->non_executable_edge_flag;"}, {"sha": "135a94245a42bdab1bcc9f45081eca5e1b51ff0e", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 672, "deletions": 641, "changes": 1313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1223,6 +1223,57 @@ elf_fetch_bits_backward (const unsigned char **ppin,\n   return 1;\n }\n \n+/* Initialize backward fetching when the bitstream starts with a 1 bit in the\n+   last byte in memory (which is the first one that we read).  This is used by\n+   zstd decompression.  Returns 1 on success, 0 on error.  */\n+\n+static int\n+elf_fetch_backward_init (const unsigned char **ppin,\n+\t\t\t const unsigned char *pinend,\n+\t\t\t uint64_t *pval, unsigned int *pbits)\n+{\n+  const unsigned char *pin;\n+  unsigned int stream_start;\n+  uint64_t val;\n+  unsigned int bits;\n+\n+  pin = *ppin;\n+  stream_start = (unsigned int)*pin;\n+  if (unlikely (stream_start == 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  val = 0;\n+  bits = 0;\n+\n+  /* Align to a 32-bit boundary.  */\n+  while ((((uintptr_t)pin) & 3) != 0)\n+    {\n+      val <<= 8;\n+      val |= (uint64_t)*pin;\n+      bits += 8;\n+      --pin;\n+    }\n+\n+  val <<= 8;\n+  val |= (uint64_t)*pin;\n+  bits += 8;\n+\n+  *ppin = pin;\n+  *pval = val;\n+  *pbits = bits;\n+  if (!elf_fetch_bits_backward (ppin, pinend, pval, pbits))\n+    return 0;\n+\n+  *pbits -= __builtin_clz (stream_start) - (sizeof (unsigned int) - 1) * 8 + 1;\n+\n+  if (!elf_fetch_bits_backward (ppin, pinend, pval, pbits))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Huffman code tables, like the rest of the zlib format, are defined\n    by RFC 1951.  We store a Huffman code table as a series of tables\n    stored sequentially in memory.  Each entry in a table is 16 bits.\n@@ -2617,14 +2668,13 @@ elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n    - scratch space, one of\n      - to build an FSE table: 512 uint16_t values == 1024 bytes\n      - to build a Huffman tree: 512 uint16_t + 256 uint32_t == 2048 bytes\n-     - buffer for literal values == 2048 bytes\n */\n \n #define ZSTD_TABLE_SIZE\t\t\t\t\t\\\n   (2 * 512 * sizeof (struct elf_zstd_fse_baseline_entry)\t\\\n    + 256 * sizeof (struct elf_zstd_fse_baseline_entry)\t\t\\\n    + 2048 * sizeof (uint16_t)\t\t\t\t\t\\\n-   + 2048)\n+   + 512 * sizeof (uint16_t) + 256 * sizeof (uint32_t))\n \n #define ZSTD_TABLE_LITERAL_FSE_OFFSET (0)\n \n@@ -2642,8 +2692,6 @@ elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n #define ZSTD_TABLE_WORK_OFFSET \\\n   (ZSTD_TABLE_HUFFMAN_OFFSET + 2048 * sizeof (uint16_t))\n \n-#define ZSTD_TABLE_WORK_LIT_SIZE 2048\n-\n /* An entry in a zstd FSE table.  */\n \n struct elf_zstd_fse_entry\n@@ -3427,7 +3475,6 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n       uint16_t *scratch;\n       const unsigned char *pfse;\n       const unsigned char *pback;\n-      unsigned char stream_start;\n       uint64_t val;\n       unsigned int bits;\n       unsigned int state1, state2;\n@@ -3454,31 +3501,8 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n \t FSE_TABLE.  */\n \n       pback = pin + hdr - 1;\n-      stream_start = *pback;\n-      if (unlikely (stream_start == 0))\n-\t{\n-\t  elf_uncompress_failed ();\n-\t  return 0;\n-\t}\n-      val = 0;\n-      bits = 0;\n-      while ((((uintptr_t)pback) & 3) != 0)\n-\t{\n-\t  val <<= 8;\n-\t  val |= (uint64_t)*pback;\n-\t  bits += 8;\n-\t  --pback;\n-\t}\n-      val <<= 8;\n-      val |= (uint64_t)*pback;\n-      bits += 8;\n-\n-      if (!elf_fetch_bits_backward (&pback, pfse, &val, &bits))\n-\treturn 0;\n-\n-      bits -= __builtin_clz (stream_start) - 24 + 1;\n \n-      if (!elf_fetch_bits_backward (&pback, pfse, &val, &bits))\n+      if (!elf_fetch_backward_init (&pback, pfse, &val, &bits))\n \treturn 0;\n \n       bits -= fse_table_bits;\n@@ -3702,331 +3726,615 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n   return 1;\n }\n \n-/* The information used to decompress a sequence code, which can be a literal\n-   length, an offset, or a match length.  */\n+/* Read and decompress the literals and store them ending at POUTEND.  This\n+   works because we are going to use all the literals in the output, so they\n+   must fit into the output buffer.  HUFFMAN_TABLE, and PHUFFMAN_TABLE_BITS\n+   store the Huffman table across calls.  SCRATCH is used to read a Huffman\n+   table.  Store the start of the decompressed literals in *PPLIT.  Update\n+   *PPIN.  Return 1 on success, 0 on error.  */\n \n-struct elf_zstd_seq_decode\n+static int\n+elf_zstd_read_literals (const unsigned char **ppin,\n+\t\t\tconst unsigned char *pinend,\n+\t\t\tunsigned char *pout,\n+\t\t\tunsigned char *poutend,\n+\t\t\tuint16_t *scratch,\n+\t\t\tuint16_t *huffman_table,\n+\t\t\tint *phuffman_table_bits,\n+\t\t\tunsigned char **pplit)\n {\n-  const struct elf_zstd_fse_baseline_entry *table;\n-  int table_bits;\n-};\n+  const unsigned char *pin;\n+  unsigned char *plit;\n+  unsigned char hdr;\n+  uint32_t regenerated_size;\n+  uint32_t compressed_size;\n+  int streams;\n+  uint32_t total_streams_size;\n+  unsigned int huffman_table_bits;\n+  uint64_t huffman_mask;\n \n-/* Unpack a sequence code compression mode.  */\n+  pin = *ppin;\n+  if (unlikely (pin >= pinend))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  hdr = *pin;\n+  ++pin;\n \n-static int\n-elf_zstd_unpack_seq_decode (int mode,\n-\t\t\t    const unsigned char **ppin,\n-\t\t\t    const unsigned char *pinend,\n-\t\t\t    const struct elf_zstd_fse_baseline_entry *predef,\n-\t\t\t    int predef_bits,\n-\t\t\t    uint16_t *scratch,\n-\t\t\t    int maxidx,\n-\t\t\t    struct elf_zstd_fse_baseline_entry *table,\n-\t\t\t    int table_bits,\n-\t\t\t    int (*conv)(const struct elf_zstd_fse_entry *,\n-\t\t\t\t\tint,\n-\t\t\t\t\tstruct elf_zstd_fse_baseline_entry *),\n-\t\t\t    struct elf_zstd_seq_decode *decode)\n-{\n-  switch (mode)\n+  if ((hdr & 3) == 0 || (hdr & 3) == 1)\n     {\n-    case 0:\n-      decode->table = predef;\n-      decode->table_bits = predef_bits;\n-      break;\n+      int raw;\n \n-    case 1:\n-      {\n-\tstruct elf_zstd_fse_entry entry;\n+      /* Raw_literals_Block or RLE_Literals_Block */\n \n-\tif (unlikely (*ppin >= pinend))\n-\t  {\n-\t    elf_uncompress_failed ();\n-\t    return 0;\n-\t  }\n-\tentry.symbol = **ppin;\n-\t++*ppin;\n-\tentry.bits = 0;\n-\tentry.base = 0;\n-\tdecode->table_bits = 0;\n-\tif (!conv (&entry, 0, table))\n+      raw = (hdr & 3) == 0;\n+\n+      switch ((hdr >> 2) & 3)\n+\t{\n+\tcase 0: case 2:\n+\t  regenerated_size = hdr >> 3;\n+\t  break;\n+\tcase 1:\n+\t  if (unlikely (pin >= pinend))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  regenerated_size = (hdr >> 4) + ((uint32_t)(*pin) << 4);\n+\t  ++pin;\n+\t  break;\n+\tcase 3:\n+\t  if (unlikely (pin + 1 >= pinend))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  regenerated_size = ((hdr >> 4)\n+\t\t\t      + ((uint32_t)*pin << 4)\n+\t\t\t      + ((uint32_t)pin[1] << 12));\n+\t  pin += 2;\n+\t  break;\n+\tdefault:\n+\t  elf_uncompress_failed ();\n \t  return 0;\n-      }\n-      break;\n+\t}\n \n-    case 2:\n-      {\n-\tstruct elf_zstd_fse_entry *fse_table;\n+      if (unlikely ((size_t)(poutend - pout) < regenerated_size))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n \n-\t/* We use the same space for the simple FSE table and the baseline\n-\t   table.  */\n-\tfse_table = (struct elf_zstd_fse_entry *)table;\n-\tdecode->table_bits = table_bits;\n-\tif (!elf_zstd_read_fse (ppin, pinend, scratch, maxidx, fse_table,\n-\t\t\t\t&decode->table_bits))\n+      plit = poutend - regenerated_size;\n+\n+      if (raw)\n+\t{\n+\t  if (unlikely (pin + regenerated_size >= pinend))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  memcpy (plit, pin, regenerated_size);\n+\t  pin += regenerated_size;\n+\t}\n+      else\n+\t{\n+\t  if (pin >= pinend)\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  memset (plit, *pin, regenerated_size);\n+\t  ++pin;\n+\t}\n+\n+      *ppin = pin;\n+      *pplit = plit;\n+\n+      return 1;\n+    }\n+\n+  /* Compressed_Literals_Block or Treeless_Literals_Block */\n+\n+  switch ((hdr >> 2) & 3)\n+    {\n+    case 0: case 1:\n+      if (unlikely (pin + 1 >= pinend))\n+\t{\n+\t  elf_uncompress_failed ();\n \t  return 0;\n-\tif (!conv (fse_table, decode->table_bits, table))\n+\t}\n+      regenerated_size = (hdr >> 4) | ((uint32_t)(*pin & 0x3f) << 4);\n+      compressed_size = (uint32_t)*pin >> 6 | ((uint32_t)pin[1] << 2);\n+      pin += 2;\n+      streams = ((hdr >> 2) & 3) == 0 ? 1 : 4;\n+      break;\n+    case 2:\n+      if (unlikely (pin + 2 >= pinend))\n+\t{\n+\t  elf_uncompress_failed ();\n \t  return 0;\n-\tdecode->table = table;\n-      }\n+\t}\n+      regenerated_size = (((uint32_t)hdr >> 4)\n+\t\t\t  | ((uint32_t)*pin << 4)\n+\t\t\t  | (((uint32_t)pin[1] & 3) << 12));\n+      compressed_size = (((uint32_t)pin[1] >> 2)\n+\t\t\t | ((uint32_t)pin[2] << 6));\n+      pin += 3;\n+      streams = 4;\n       break;\n-\n     case 3:\n-      if (unlikely (decode->table_bits == -1))\n+      if (unlikely (pin + 3 >= pinend))\n \t{\n \t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n+      regenerated_size = (((uint32_t)hdr >> 4)\n+\t\t\t  | ((uint32_t)*pin << 4)\n+\t\t\t  | (((uint32_t)pin[1] & 0x3f) << 12));\n+      compressed_size = (((uint32_t)pin[1] >> 6)\n+\t\t\t | ((uint32_t)pin[2] << 2)\n+\t\t\t | ((uint32_t)pin[3] << 10));\n+      pin += 4;\n+      streams = 4;\n       break;\n-\n     default:\n       elf_uncompress_failed ();\n       return 0;\n     }\n \n-  return 1;\n-}\n-\n-/* The different ways that the literals are encoded.  */\n-\n-#define ZSTD_LIT_RAW (0)\n-#define ZSTD_LIT_RLE (1)\n-#define ZSTD_LIT_HUFF (2)\n-\n-/* A struct used to decompress the literals.  The order of these fields is\n-   chosen for packing, not for comprehensibility.  */\n-\n-struct elf_zstd_literals\n-{\n-  /* Current bits in Huffman encoded stream.  */\n-  uint64_t val;\n-\n-  /* For RAW, the current position in the byte stream.\n-     For RLE, a pointer to the byte being repeated.\n-     For HUFF, start of encoded streams.\n-  */\n-  const unsigned char *plit;\n+  if (unlikely (pin + compressed_size > pinend))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n \n-  /* Current position of current Huffman encoded stream.  */\n-  const unsigned char *pback;\n+  pinend = pin + compressed_size;\n+  *ppin = pinend;\n \n-  /* End (reading backward) of current Huffman encoded stream.  */\n-  const unsigned char *pbackend;\n+  if (unlikely ((size_t)(poutend - pout) < regenerated_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n \n-  /* The Huffman table.  */\n-  const uint16_t *huffman_table;\n+  plit = poutend - regenerated_size;\n \n-  /* Remaining number of uncompressed bytes.  */\n-  uint32_t regenerated_size;\n+  *pplit = plit;\n \n-  /* Current number of available bits in Huffman encoded stream.  */\n-  unsigned int bits;\n+  total_streams_size = compressed_size;\n+  if ((hdr & 3) == 2)\n+    {\n+      const unsigned char *ptable;\n \n-  /* Number of bits in the Huffman table.  */\n-  int huffman_table_bits;\n+      /* Compressed_Literals_Block.  Read Huffman tree.  */\n \n-  /* Offsets from PLIT to next Huffman encoded streams, 0 if none.  */\n-  uint32_t stream_off[3];\n+      ptable = pin;\n+      if (!elf_zstd_read_huff (&ptable, pinend, scratch, huffman_table,\n+\t\t\t       phuffman_table_bits))\n+\treturn 0;\n \n-  /* Sizes of next Huffman encoded streams, 0 if none.  */\n-  uint32_t stream_size[3];\n+      if (unlikely (total_streams_size < (size_t)(ptable - pin)))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n \n-  /* A ZSTD_LIT_* code.  */\n-  unsigned char type;\n-};\n+      total_streams_size -= ptable - pin;\n+      pin = ptable;\n+    }\n+  else\n+    {\n+      /* Treeless_Literals_Block.  Reuse previous Huffman tree.  */\n+      if (unlikely (*phuffman_table_bits == 0))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+    }\n \n-/* Output COUNT bytes from the literal byte stream in LITERALS to POUT.  */\n+  /* Decompress COMPRESSED_SIZE bytes of data at PIN using the huffman table,\n+     storing REGENERATED_SIZE bytes of decompressed data at PLIT.  */\n \n-static int\n-elf_zstd_literal_output (struct elf_zstd_literals *literals,\n-\t\t\t size_t count,\n-\t\t\t unsigned char *pout)\n-{\n-  size_t i;\n-  const unsigned char *pback;\n-  const unsigned char *pbackend;\n-  uint64_t val;\n-  unsigned int bits;\n-  const uint16_t *huffman_table;\n-  unsigned int huffman_table_bits;\n-  uint64_t huffman_mask;\n+  huffman_table_bits = (unsigned int)*phuffman_table_bits;\n+  huffman_mask = ((uint64_t)1 << huffman_table_bits) - 1;\n \n-  if (literals->regenerated_size < count)\n+  if (streams == 1)\n     {\n-      elf_uncompress_failed ();\n-      return 0;\n-    }\n-  literals->regenerated_size -= count;\n+      const unsigned char *pback;\n+      const unsigned char *pbackend;\n+      uint64_t val;\n+      unsigned int bits;\n+      uint32_t i;\n \n-  switch (literals->type)\n-    {\n-    case ZSTD_LIT_RAW:\n-      memcpy (pout, literals->plit, count);\n-      literals->plit += count;\n-      return 1;\n+      pback = pin + compressed_size - 1;\n+      pbackend = pin;\n+      if (!elf_fetch_backward_init (&pback, pbackend, &val, &bits))\n+\treturn 0;\n \n-    case ZSTD_LIT_RLE:\n-      memset (pout, *literals->plit, count);\n-      return 1;\n+      /* This is one of the inner loops of the decompression algorithm, so we\n+\t put some effort into optimization.  We can't get more than 64 bytes\n+\t from a single call to elf_fetch_bits_backward, and we can't subtract\n+\t more than 11 bits at a time.  */\n \n-    case ZSTD_LIT_HUFF:\n-      break;\n+      if (regenerated_size >= 64)\n+\t{\n+\t  unsigned char *plitstart;\n+\t  unsigned char *plitstop;\n \n-    default:\n-      elf_uncompress_failed ();\n-      return 0;\n-    }\n+\t  plitstart = plit;\n+\t  plitstop = plit + regenerated_size - 64;\n+\t  while (plit < plitstop)\n+\t    {\n+\t      uint16_t t;\n \n-  /* The literal string is Huffman encoded.  */\n+\t      if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n+\t\treturn 0;\n \n-  pback = literals->pback;\n-  pbackend = literals->pbackend;\n-  val = literals->val;\n-  bits = literals->bits;\n+\t      if (bits < 16)\n+\t\tbreak;\n \n-  huffman_table = literals->huffman_table;\n-  huffman_table_bits = literals->huffman_table_bits;\n-  huffman_mask = ((uint64_t)1 << huffman_table_bits) - 1;\n+\t      while (bits >= 33)\n+\t\t{\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\t\t}\n \n-  /* This is one of the inner loops of the decompression algorithm, so we put\n-     some effort into optimization.  We can't get more than 64 bytes from a\n-     single call to elf_fetch_bits_backward, and we can't subtract more than 11\n-     bits at a time.  */\n+\t      while (bits > 11)\n+\t\t{\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\t\t}\n+\t    }\n \n-  if (count >= 64)\n-    {\n-      unsigned char *poutstart;\n-      unsigned char *poutstop;\n+\t  regenerated_size -= plit - plitstart;\n+\t}\n \n-      poutstart = pout;\n-      poutstop = pout + count - 64;\n-      while (pout <= poutstop)\n+      for (i = 0; i < regenerated_size; ++i)\n \t{\n \t  uint16_t t;\n \n \t  if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n \t    return 0;\n \n-\t  if (bits < 16)\n-\t    break;\n-\n-\t  while (bits >= 33)\n+\t  if (unlikely (bits < huffman_table_bits))\n \t    {\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t      t = huffman_table[(val << (huffman_table_bits - bits))\n \t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n-\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n-\t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n-\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n-\t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n+\t      if (unlikely (bits < (t & 0xff)))\n+\t\t{\n+\t\t  elf_uncompress_failed ();\n+\t\t  return 0;\n+\t\t}\n \t    }\n+\t  else\n+\t    t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t      & huffman_mask];\n \n-\t  while (bits > 11)\n-\t    {\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n-\t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n-\t    }\n+\t  *plit = t >> 8;\n+\t  ++plit;\n+\t  bits -= t & 0xff;\n \t}\n \n-      count -= pout - poutstart;\n+      return 1;\n+    }\n \n-      if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n+  {\n+    uint32_t stream_size1, stream_size2, stream_size3, stream_size4;\n+    uint32_t tot;\n+    const unsigned char *pback1, *pback2, *pback3, *pback4;\n+    const unsigned char *pbackend1, *pbackend2, *pbackend3, *pbackend4;\n+    uint64_t val1, val2, val3, val4;\n+    unsigned int bits1, bits2, bits3, bits4;\n+    unsigned char *plit1, *plit2, *plit3, *plit4;\n+    uint32_t regenerated_stream_size;\n+    uint32_t regenerated_stream_size4;\n+    uint16_t t1, t2, t3, t4;\n+    uint32_t i;\n+    uint32_t limit;\n+\n+    /* Read jump table.  */\n+    if (unlikely (pin + 5 >= pinend))\n+      {\n+\telf_uncompress_failed ();\n \treturn 0;\n-    }\n+      }\n+    stream_size1 = (uint32_t)*pin | ((uint32_t)pin[1] << 8);\n+    pin += 2;\n+    stream_size2 = (uint32_t)*pin | ((uint32_t)pin[1] << 8);\n+    pin += 2;\n+    stream_size3 = (uint32_t)*pin | ((uint32_t)pin[1] << 8);\n+    pin += 2;\n+    tot = stream_size1 + stream_size2 + stream_size3;\n+    if (unlikely (tot > total_streams_size - 6))\n+      {\n+\telf_uncompress_failed ();\n+\treturn 0;\n+      }\n+    stream_size4 = total_streams_size - 6 - tot;\n \n-  for (i = 0; i < count; ++i)\n-    {\n-      uint16_t t;\n+    pback1 = pin + stream_size1 - 1;\n+    pbackend1 = pin;\n \n-      if (unlikely (bits == 0))\n-\t{\n-\t  unsigned char stream_start;\n+    pback2 = pback1 + stream_size2;\n+    pbackend2 = pback1 + 1;\n \n-\t  /* Advance to next stream.  */\n-\t  if (unlikely (literals->stream_off[0] == 0))\n-\t    {\n-\t      elf_uncompress_failed ();\n-\t      return 0;\n-\t    }\n+    pback3 = pback2 + stream_size3;\n+    pbackend3 = pback2 + 1;\n \n-\t  pback = literals->plit + literals->stream_off[0];\n-\t  pbackend = pback;\n-\t  pback += literals->stream_size[0];\n+    pback4 = pback3 + stream_size4;\n+    pbackend4 = pback3 + 1;\n \n-\t  /* Align to a 32-bit boundary.  */\n-\t  val = 0;\n-\t  bits = 0;\n-\t  --pback;\n-\t  stream_start = *pback;\n-\t  if (unlikely (stream_start == 0))\n-\t    {\n-\t      elf_uncompress_failed ();\n+    if (!elf_fetch_backward_init (&pback1, pbackend1, &val1, &bits1))\n+      return 0;\n+    if (!elf_fetch_backward_init (&pback2, pbackend2, &val2, &bits2))\n+      return 0;\n+    if (!elf_fetch_backward_init (&pback3, pbackend3, &val3, &bits3))\n+      return 0;\n+    if (!elf_fetch_backward_init (&pback4, pbackend4, &val4, &bits4))\n+      return 0;\n+\n+    regenerated_stream_size = (regenerated_size + 3) / 4;\n+\n+    plit1 = plit;\n+    plit2 = plit1 + regenerated_stream_size;\n+    plit3 = plit2 + regenerated_stream_size;\n+    plit4 = plit3 + regenerated_stream_size;\n+\n+    regenerated_stream_size4 = regenerated_size - regenerated_stream_size * 3;\n+\n+    /* We can't get more than 64 literal bytes from a single call to\n+       elf_fetch_bits_backward.  The fourth stream can be up to 3 bytes less,\n+       so use as the limit.  */\n+\n+    limit = regenerated_stream_size4 <= 64 ? 0 : regenerated_stream_size4 - 64;\n+    i = 0;\n+    while (i < limit)\n+      {\n+\tif (!elf_fetch_bits_backward (&pback1, pbackend1, &val1, &bits1))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback2, pbackend2, &val2, &bits2))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback3, pbackend3, &val3, &bits3))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback4, pbackend4, &val4, &bits4))\n+\t  return 0;\n+\n+\t/* We can't subtract more than 11 bits at a time.  */\n+\n+\tdo\n+\t  {\n+\t    t1 = huffman_table[(val1 >> (bits1 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\t    t2 = huffman_table[(val2 >> (bits2 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\t    t3 = huffman_table[(val3 >> (bits3 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\t    t4 = huffman_table[(val4 >> (bits4 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\n+\t    *plit1 = t1 >> 8;\n+\t    ++plit1;\n+\t    bits1 -= t1 & 0xff;\n+\n+\t    *plit2 = t2 >> 8;\n+\t    ++plit2;\n+\t    bits2 -= t2 & 0xff;\n+\n+\t    *plit3 = t3 >> 8;\n+\t    ++plit3;\n+\t    bits3 -= t3 & 0xff;\n+\n+\t    *plit4 = t4 >> 8;\n+\t    ++plit4;\n+\t    bits4 -= t4 & 0xff;\n+\n+\t    ++i;\n+\t  }\n+\twhile (bits1 > 11 && bits2 > 11 && bits3 > 11 && bits4 > 11);\n+      }\n+\n+    while (i < regenerated_stream_size)\n+      {\n+\tint use4;\n+\n+\tuse4 = i < regenerated_stream_size4;\n+\n+\tif (!elf_fetch_bits_backward (&pback1, pbackend1, &val1, &bits1))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback2, pbackend2, &val2, &bits2))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback3, pbackend3, &val3, &bits3))\n+\t  return 0;\n+\tif (use4)\n+\t  {\n+\t    if (!elf_fetch_bits_backward (&pback4, pbackend4, &val4, &bits4))\n \t      return 0;\n-\t    }\n-\t  while ((((uintptr_t) pback) & 3) != 0)\n-\t    {\n-\t      val <<= 8;\n-\t      val |= (uint64_t)*pback;\n-\t      bits += 8;\n-\t      --pback;\n-\t    }\n-\t  val <<= 8;\n-\t  val |= (uint64_t)*pback;\n-\t  bits += 8;\n+\t  }\n \n-\t  if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n-\t    return 0;\n+\tif (unlikely (bits1 < huffman_table_bits))\n+\t  {\n+\t    t1 = huffman_table[(val1 << (huffman_table_bits - bits1))\n+\t\t\t       & huffman_mask];\n+\t    if (unlikely (bits1 < (t1 & 0xff)))\n+\t      {\n+\t\telf_uncompress_failed ();\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\telse\n+\t  t1 = huffman_table[(val1 >> (bits1 - huffman_table_bits))\n+\t\t\t     & huffman_mask];\n \n-\t  bits -= __builtin_clz (stream_start) - 24 + 1;\n+\tif (unlikely (bits2 < huffman_table_bits))\n+\t  {\n+\t    t2 = huffman_table[(val2 << (huffman_table_bits - bits2))\n+\t\t\t       & huffman_mask];\n+\t    if (unlikely (bits2 < (t2 & 0xff)))\n+\t      {\n+\t\telf_uncompress_failed ();\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\telse\n+\t  t2 = huffman_table[(val2 >> (bits2 - huffman_table_bits))\n+\t\t\t     & huffman_mask];\n \n-\t  literals->stream_off[0] = literals->stream_off[1];\n-\t  literals->stream_off[1] = literals->stream_off[2];\n-\t  literals->stream_off[2] = 0;\n-\t  literals->stream_size[0] = literals->stream_size[1];\n-\t  literals->stream_size[1] = literals->stream_size[2];\n-\t  literals->stream_size[2] = 0;\n-\t}\n+\tif (unlikely (bits3 < huffman_table_bits))\n+\t  {\n+\t    t3 = huffman_table[(val3 << (huffman_table_bits - bits3))\n+\t\t\t       & huffman_mask];\n+\t    if (unlikely (bits3 < (t3 & 0xff)))\n+\t      {\n+\t\telf_uncompress_failed ();\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\telse\n+\t  t3 = huffman_table[(val3 >> (bits3 - huffman_table_bits))\n+\t\t\t     & huffman_mask];\n \n-      if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n-\treturn 0;\n+\tif (use4)\n+\t  {\n+\t    if (unlikely (bits4 < huffman_table_bits))\n+\t      {\n+\t\tt4 = huffman_table[(val4 << (huffman_table_bits - bits4))\n+\t\t\t\t   & huffman_mask];\n+\t\tif (unlikely (bits4 < (t4 & 0xff)))\n+\t\t  {\n+\t\t    elf_uncompress_failed ();\n+\t\t    return 0;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      t4 = huffman_table[(val4 >> (bits4 - huffman_table_bits))\n+\t\t\t\t & huffman_mask];\n+\n+\t    *plit4 = t4 >> 8;\n+\t    ++plit4;\n+\t    bits4 -= t4 & 0xff;\n+\t  }\n+\n+\t*plit1 = t1 >> 8;\n+\t++plit1;\n+\tbits1 -= t1 & 0xff;\n+\n+\t*plit2 = t2 >> 8;\n+\t++plit2;\n+\tbits2 -= t2 & 0xff;\n+\n+\t*plit3 = t3 >> 8;\n+\t++plit3;\n+\tbits3 -= t3 & 0xff;\n+\n+\t++i;\n+      }\n+  }\n+\n+  return 1;\n+}\n+\n+/* The information used to decompress a sequence code, which can be a literal\n+   length, an offset, or a match length.  */\n+\n+struct elf_zstd_seq_decode\n+{\n+  const struct elf_zstd_fse_baseline_entry *table;\n+  int table_bits;\n+};\n+\n+/* Unpack a sequence code compression mode.  */\n \n-      if (unlikely (bits < huffman_table_bits))\n+static int\n+elf_zstd_unpack_seq_decode (int mode,\n+\t\t\t    const unsigned char **ppin,\n+\t\t\t    const unsigned char *pinend,\n+\t\t\t    const struct elf_zstd_fse_baseline_entry *predef,\n+\t\t\t    int predef_bits,\n+\t\t\t    uint16_t *scratch,\n+\t\t\t    int maxidx,\n+\t\t\t    struct elf_zstd_fse_baseline_entry *table,\n+\t\t\t    int table_bits,\n+\t\t\t    int (*conv)(const struct elf_zstd_fse_entry *,\n+\t\t\t\t\tint,\n+\t\t\t\t\tstruct elf_zstd_fse_baseline_entry *),\n+\t\t\t    struct elf_zstd_seq_decode *decode)\n+{\n+  switch (mode)\n+    {\n+    case 0:\n+      decode->table = predef;\n+      decode->table_bits = predef_bits;\n+      break;\n+\n+    case 1:\n+      {\n+\tstruct elf_zstd_fse_entry entry;\n+\n+\tif (unlikely (*ppin >= pinend))\n+\t  {\n+\t    elf_uncompress_failed ();\n+\t    return 0;\n+\t  }\n+\tentry.symbol = **ppin;\n+\t++*ppin;\n+\tentry.bits = 0;\n+\tentry.base = 0;\n+\tdecode->table_bits = 0;\n+\tif (!conv (&entry, 0, table))\n+\t  return 0;\n+      }\n+      break;\n+\n+    case 2:\n+      {\n+\tstruct elf_zstd_fse_entry *fse_table;\n+\n+\t/* We use the same space for the simple FSE table and the baseline\n+\t   table.  */\n+\tfse_table = (struct elf_zstd_fse_entry *)table;\n+\tdecode->table_bits = table_bits;\n+\tif (!elf_zstd_read_fse (ppin, pinend, scratch, maxidx, fse_table,\n+\t\t\t\t&decode->table_bits))\n+\t  return 0;\n+\tif (!conv (fse_table, decode->table_bits, table))\n+\t  return 0;\n+\tdecode->table = table;\n+      }\n+      break;\n+\n+    case 3:\n+      if (unlikely (decode->table_bits == -1))\n \t{\n-\t  t = huffman_table[(val << (huffman_table_bits - bits))\n-\t\t\t    & huffman_mask];\n-\t  if (unlikely (bits < (t & 0xff)))\n-\t    {\n-\t      elf_uncompress_failed ();\n-\t      return 0;\n-\t    }\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n \t}\n-      else\n-\tt = huffman_table[(val >> (bits - huffman_table_bits)) & huffman_mask];\n-\n-      *pout = t >> 8;\n-      ++pout;\n+      break;\n \n-      bits -= t & 0xff;\n+    default:\n+      elf_uncompress_failed ();\n+      return 0;\n     }\n \n-  literals->pback = pback;\n-  literals->pbackend = pbackend;\n-  literals->val = val;\n-  literals->bits = bits;\n-\n   return 1;\n }\n \n@@ -4250,16 +4558,9 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \tcase 2:\n \t  {\n \t    const unsigned char *pblockend;\n-\t    struct elf_zstd_literals literals;\n-\t    unsigned char lit_hdr;\n-\t    uint32_t lit_section_content;\n-\t    uint32_t lit_compressed_size;\n-\t    uint32_t lit_total_streams_size;\n-\t    const unsigned char *plitend;\n-\t    unsigned char *plitexp;\n-\t    size_t litexp_count;\n-\t    int lit_streams;\n-\t    uint32_t stream_size_1;\n+\t    unsigned char *plitstack;\n+\t    unsigned char *plit;\n+\t    uint32_t literal_count;\n \t    unsigned char seq_hdr;\n \t    size_t seq_count;\n \t    size_t seq;\n@@ -4269,7 +4570,6 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t    unsigned int literal_state;\n \t    unsigned int offset_state;\n \t    unsigned int match_state;\n-\t    unsigned char stream_start;\n \n \t    /* Compressed_Block */\n \t    if (unlikely ((size_t) block_size > (size_t) (pinend - pin)))\n@@ -4280,248 +4580,16 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t    pblockend = pin + block_size;\n \n-\t    if (unlikely (pin >= pinend))\n-\t      {\n-\t\telf_uncompress_failed ();\n-\t\treturn 0;\n-\t      }\n-\t    lit_hdr = *pin;\n-\t    ++pin;\n-\n-\t    if ((lit_hdr & 3) == 0 || (lit_hdr & 3) == 1)\n-\t      {\n-\t\tif ((lit_hdr & 3) == 0)\n-\t\t  literals.type = ZSTD_LIT_RAW;\n-\t\telse\n-\t\t  literals.type = ZSTD_LIT_RLE;\n-\n-\t\t/* Raw_literals_Block or RLE_Literals_Block */\n-\t\tswitch ((lit_hdr >> 2) & 3)\n-\t\t  {\n-\t\t  case 0: case 2:\n-\t\t    literals.regenerated_size = lit_hdr >> 3;\n-\t\t    break;\n-\t\t  case 1:\n-\t\t    if (unlikely (pin >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = (lit_hdr >> 4) + ((*pin) << 4);\n-\t\t    pin++;\n-\t\t    break;\n-\t\t  case 3:\n-\t\t    if (unlikely (pin + 1 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t + (*pin << 4)\n-\t\t\t\t\t\t + (pin[1] << 12));\n-\t\t    pin += 2;\n-\t\t    break;\n-\t\t  default:\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tif (literals.type == ZSTD_LIT_RAW)\n-\t\t  lit_section_content = literals.regenerated_size;\n-\t\telse\n-\t\t  lit_section_content = 1;\n-\t\tlit_compressed_size = 0;\n-\t\tlit_streams = 1;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Compressed_Literals_Block or Treeless_Literals_Block */\n-\t\tliterals.type = ZSTD_LIT_HUFF;\n-\t\tswitch ((lit_hdr >> 2) & 3)\n-\t\t  {\n-\t\t  case 0: case 1:\n-\t\t    if (unlikely (pin + 1 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t | ((*pin & 0x3f) << 4));\n-\t\t    lit_compressed_size = ((*pin >> 6)\n-\t\t\t\t\t   | (pin[1] << 2));\n-\t\t    pin += 2;\n-\t\t    lit_streams = ((lit_hdr >> 2) & 3) == 0 ? 1 : 4;\n-\t\t    break;\n-\t\t  case 2:\n-\t\t    if (unlikely (pin + 2 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t | (*pin << 4)\n-\t\t\t\t\t\t | ((pin[1] & 3) << 12));\n-\t\t    lit_compressed_size = ((pin[1] >> 2)\n-\t\t\t\t\t   | (pin[2] << 6));\n-\t\t    pin += 3;\n-\t\t    lit_streams = 4;\n-\t\t    break;\n-\t\t  case 3:\n-\t\t    if (unlikely (pin + 3 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t | (*pin << 4)\n-\t\t\t\t\t\t | ((pin[1] & 0x3f) << 12));\n-\t\t    lit_compressed_size = ((pin[1] >> 6)\n-\t\t\t\t\t   | (pin[2] << 2)\n-\t\t\t\t\t   | (pin[3] << 10));\n-\t\t    pin += 4;\n-\t\t    lit_streams = 4;\n-\t\t    break;\n-\t\t  default:\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\n-\t\tlit_section_content = lit_compressed_size;\n-\t      }\n-\n-\t    if (unlikely ((size_t)lit_section_content > (size_t)(pinend - pin)))\n-\t      {\n-\t\telf_uncompress_failed ();\n-\t\treturn 0;\n-\t      }\n-\t    plitend = pin + lit_section_content;\n-\n-\t    lit_total_streams_size = lit_compressed_size;\n-\t    if ((lit_hdr & 3) == 2)\n-\t      {\n-\t\t/* Compressed_Literals_Block.  Read Huffman tree.  */\n-\n-\t\tconst unsigned char *ptable;\n-\n-\t\tptable = pin;\n-\t\tif (!elf_zstd_read_huff (&ptable, pinend, scratch,\n-\t\t\t\t\t huffman_table, &huffman_table_bits))\n-\t\t  return 0;\n-\t\tliterals.huffman_table = huffman_table;\n-\t\tliterals.huffman_table_bits = huffman_table_bits;\n-\n-\t\tlit_total_streams_size -= ptable - pin;\n-\t\tpin = ptable;\n-\t      }\n-\t    else if ((lit_hdr & 3) == 3)\n-\t      {\n-\t\t/* Treeless_Literals_Block.  Reuse previous Huffman tree.  */\n-\t\tif (huffman_table_bits == 0)\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tliterals.huffman_table = huffman_table;\n-\t\tliterals.huffman_table_bits = huffman_table_bits;\n-\t      }\n-\t    else\n-\t      {\n-\t\tliterals.huffman_table = NULL;\n-\t\tliterals.huffman_table_bits = 0;\n-\t      }\n+\t    /* Read the literals into the end of the output space, and leave\n+\t       PLIT pointing at them.  */\n \n-\t    if (lit_streams == 1)\n-\t      {\n-\t\tstream_size_1 = block_size;\n-\t\tliterals.stream_off[0] = 0;\n-\t\tliterals.stream_off[1] = 0;\n-\t\tliterals.stream_off[2] = 0;\n-\t\tliterals.stream_size[0] = 0;\n-\t\tliterals.stream_size[1] = 0;\n-\t\tliterals.stream_size[2] = 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\tuint32_t tot;\n-\n-\t\t/* Read jump table.  */\n-\t\tif (unlikely (pin + 5 >= pinend))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tstream_size_1 = *pin | (pin[1] << 8);\n-\t\tpin += 2;\n-\t\tliterals.stream_size[0] = *pin | (pin[1] << 8);\n-\t\tpin += 2;\n-\t\tliterals.stream_size[1] = *pin | (pin[1] << 8);\n-\t\tpin += 2;\n-\t\ttot = (stream_size_1\n-\t\t       + literals.stream_size[0]\n-\t\t       + literals.stream_size[1]);\n-\t\tif (unlikely (tot > lit_total_streams_size - 6))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tliterals.stream_size[2] = lit_total_streams_size - 6 - tot;\n-\n-\t\tliterals.stream_off[0] = stream_size_1;\n-\t\tliterals.stream_off[1] = (literals.stream_off[0]\n-\t\t\t\t\t  + literals.stream_size[0]);\n-\t\tliterals.stream_off[2] = (literals.stream_off[1]\n-\t\t\t\t\t  + literals.stream_size[1]);\n-\t      }\n-\n-\t    literals.plit = pin;\n-\n-\t    if (literals.type == ZSTD_LIT_HUFF)\n-\t      {\n-\t\tconst unsigned char *plback;\n-\n-\t\t/* Set up the first huffman stream.  */\n-\n-\t\tliterals.pbackend = literals.plit;\n-\t\tplback = literals.plit + stream_size_1;\n-\t\tliterals.val = 0;\n-\t\tliterals.bits = 0;\n-\t\t--plback;\n-\t\tstream_start = *plback;\n-\t\tif (unlikely (stream_start == 0))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\twhile ((((uintptr_t) plback) & 3) != 0)\n-\t\t  {\n-\t\t    literals.val <<= 8;\n-\t\t    literals.val |= (uint64_t)*plback;\n-\t\t    literals.bits += 8;\n-\t\t    --plback;\n-\t\t  }\n-\t\tliterals.val <<= 8;\n-\t\tliterals.val |= (uint64_t)*plback;\n-\t\tliterals.bits += 8;\n-\n-\t\tif (!elf_fetch_bits_backward (&plback, literals.pbackend,\n-\t\t\t\t\t      &literals.val, &literals.bits))\n-\t\t  return 0;\n-\n-\t\tliterals.bits -= __builtin_clz (stream_start) - 24 + 1;\n-\n-\t\tliterals.pback = plback;\n-\t      }\n-\t    else\n-\t      {\n-\t\tliterals.val = 0;\n-\t\tliterals.bits = 0;\n-\t\tliterals.pback = NULL;\n-\t\tliterals.pbackend = NULL;\n-\t      }\n-\n-\t    /* We have read all the literal header information.  The literal\n-\t       data starts at LITERALS.PLIT.  Skip ahead to the sequences.  */\n-\n-\t    pin = plitend;\n+\t    if (!elf_zstd_read_literals (&pin, pblockend, pout, poutend,\n+\t\t\t\t\t scratch, huffman_table,\n+\t\t\t\t\t &huffman_table_bits,\n+\t\t\t\t\t &plitstack))\n+\t      return 0;\n+\t    plit = plitstack;\n+\t    literal_count = poutend - plit;\n \n \t    seq_hdr = *pin;\n \t    pin++;\n@@ -4589,53 +4657,10 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t  return 0;\n \t      }\n \n-\t    /* Expand 2048 bytes of literals.  The expanded literals are\n-\t       recorded in PLITEXP and LITEXP_COUNT.  */\n-\n-\t    if (literals.type != ZSTD_LIT_HUFF\n-\t\t|| literals.regenerated_size == 0)\n-\t      {\n-\t\tplitexp = NULL;\n-\t\tlitexp_count = 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\tplitexp = (unsigned char *)scratch;\n-\t\tlitexp_count = ZSTD_TABLE_WORK_LIT_SIZE;\n-\t\tif (litexp_count > literals.regenerated_size)\n-\t\t  litexp_count = literals.regenerated_size;\n-\t\tif (!elf_zstd_literal_output (&literals, litexp_count,\n-\t\t\t\t\t      plitexp))\n-\t\t  return 0;\n-\t      }\n-\n \t    pback = pblockend - 1;\n-\t    val = 0;\n-\t    bits = 0;\n-\t    stream_start = *pback;\n-\t    if (unlikely (stream_start == 0))\n-\t      {\n-\t\telf_uncompress_failed ();\n-\t\treturn 0;\n-\t      }\n-\t    while ((((uintptr_t)pback) & 3) != 0)\n-\t      {\n-\t\tval <<= 8;\n-\t\tval |= (uint64_t)*pback;\n-\t\tbits += 8;\n-\t\t--pback;\n-\t      }\n-\t    val <<= 8;\n-\t    val |= (uint64_t)*pback;\n-\t    bits += 8;\n-\n-\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t    if (!elf_fetch_backward_init (&pback, pin, &val, &bits))\n \t      return 0;\n \n-\t    bits -= __builtin_clz (stream_start) - 24 + 1;\n-\n-\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t      return 0;\n \t    bits -= literal_decode.table_bits;\n \t    literal_state = ((val >> bits)\n \t\t\t     & ((1U << literal_decode.table_bits) - 1));\n@@ -4808,66 +4833,71 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t\t/* The next sequence is now in LITERAL, OFFSET, MATCH.  */\n \n-\t\tif (literal > 0)\n+\t\t/* Copy LITERAL bytes from the literals.  */\n+\n+\t\tif (unlikely ((size_t)(poutend - pout) < literal))\n \t\t  {\n-\t\t    /* Copy LITERAL bytes from the literals.  */\n+\t\t    elf_uncompress_failed ();\n+\t\t    return 0;\n+\t\t  }\n \n-\t\t    if (unlikely ((size_t)(poutend - pout) < literal))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n+\t\tif (unlikely (literal_count < literal))\n+\t\t  {\n+\t\t    elf_uncompress_failed ();\n+\t\t    return 0;\n+\t\t  }\n \n-\t\t    if (literals.type != ZSTD_LIT_HUFF)\n-\t\t      {\n-\t\t\tif (!elf_zstd_literal_output (&literals, literal,\n-\t\t\t\t\t\t      pout))\n-\t\t\t  return 0;\n-\t\t\tpout += literal;\n-\t\t      }\n-\t\t    else if (literal <= litexp_count)\n-\t\t      {\n-\t\t\tmemcpy (pout, plitexp, literal);\n-\t\t\tplitexp += literal;\n-\t\t\tlitexp_count -= literal;\n-\t\t\tpout += literal;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tmemcpy (pout, plitexp, litexp_count);\n-\t\t\tpout += litexp_count;\n-\t\t\tliteral -= litexp_count;\n-\t\t\tlitexp_count = 0;\n+\t\tliteral_count -= literal;\n \n-\t\t\tif (unlikely (literal >= ZSTD_TABLE_WORK_LIT_SIZE))\n-\t\t\t  {\n-\t\t\t    if (!elf_zstd_literal_output (&literals, literal,\n-\t\t\t\t\t\t\t  pout))\n-\t\t\t      return 0;\n-\t\t\t    pout += literal;\n-\t\t\t    literal = 0;\n-\t\t\t  }\n+\t\t/* Often LITERAL is small, so handle small cases quickly.  */\n+\t\tswitch (literal)\n+\t\t  {\n+\t\t  case 8:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 7:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 6:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 5:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 4:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 3:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 2:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 1:\n+\t\t    *pout++ = *plit++;\n+\t\t    break;\n \n-\t\t\tplitexp = (unsigned char *)scratch;\n-\t\t\tlitexp_count = ZSTD_TABLE_WORK_LIT_SIZE;\n-\t\t\tif (litexp_count > literals.regenerated_size)\n-\t\t\t  litexp_count = literals.regenerated_size;\n-\t\t\tif (!elf_zstd_literal_output (&literals,\n-\t\t\t\t\t\t      litexp_count,\n-\t\t\t\t\t\t      plitexp))\n-\t\t\t  return 0;\n+\t\t  case 0:\n+\t\t    break;\n \n-\t\t\tif (unlikely (literal > litexp_count))\n+\t\t  default:\n+\t\t    if (unlikely ((size_t)(plit - pout) < literal))\n+\t\t      {\n+\t\t\tuint32_t move;\n+\n+\t\t\tmove = plit - pout;\n+\t\t\twhile (literal > move)\n \t\t\t  {\n-\t\t\t    elf_uncompress_failed ();\n-\t\t\t    return 0;\n+\t\t\t    memcpy (pout, plit, move);\n+\t\t\t    pout += move;\n+\t\t\t    plit += move;\n+\t\t\t    literal -= move;\n \t\t\t  }\n-\n-\t\t\tmemcpy (pout, plitexp, literal);\n-\t\t\tplitexp += literal;\n-\t\t\tlitexp_count -= literal;\n-\t\t\tpout += literal;\n \t\t      }\n+\n+\t\t    memcpy (pout, plit, literal);\n+\t\t    pout += literal;\n+\t\t    plit += literal;\n \t\t  }\n \n \t\tif (match > 0)\n@@ -4907,34 +4937,35 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t\tif (unlikely (seq >= seq_count))\n \t\t  {\n-\t\t    size_t copy;\n-\n \t\t    /* Copy remaining literals.  */\n-\t\t    if (litexp_count > 0)\n+\t\t    if (literal_count > 0 && plit != pout)\n \t\t      {\n-\t\t\tif (unlikely ((size_t)(poutend - pout) < litexp_count))\n+\t\t\tif (unlikely ((size_t)(poutend - pout)\n+\t\t\t\t      < literal_count))\n \t\t\t  {\n \t\t\t    elf_uncompress_failed ();\n \t\t\t    return 0;\n \t\t\t  }\n-\t\t\tmemcpy (pout, plitexp, litexp_count);\n-\t\t\tpout += litexp_count;\n-\t\t      }\n-\t\t    copy = literals.regenerated_size;\n-\t\t    if (copy > 0)\n-\t\t      {\n-\t\t\tif (unlikely ((size_t)(poutend - pout) < copy))\n+\n+\t\t\tif ((size_t)(plit - pout) < literal_count)\n \t\t\t  {\n-\t\t\t    elf_uncompress_failed ();\n-\t\t\t    return 0;\n+\t\t\t    uint32_t move;\n+\n+\t\t\t    move = plit - pout;\n+\t\t\t    while (literal_count > move)\n+\t\t\t      {\n+\t\t\t\tmemcpy (pout, plit, move);\n+\t\t\t\tpout += move;\n+\t\t\t\tplit += move;\n+\t\t\t\tliteral_count -= move;\n+\t\t\t      }\n \t\t\t  }\n \n-\t\t\tif (!elf_zstd_literal_output (&literals, copy, pout))\n-\t\t\t  return 0;\n-\n-\t\t\tpout += copy;\n+\t\t\tmemcpy (pout, plit, literal_count);\n \t\t      }\n \n+\t\t    pout += literal_count;\n+\n \t\t    break;\n \t\t  }\n \t      }"}, {"sha": "5559ce138ee69e9b936ae1d49b5a99938087013d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,12 @@\n+2022-12-16  Thomas Neumann  <tneumann@users.sourceforge.net>\n+\n+\t* unwind-dw2-fde.c: Initialize fde object lazily when\n+\tthe first exception tries to pass through.\n+\n+2022-12-16  Thomas Neumann  <tneumann@users.sourceforge.net>\n+\n+\t* unwind-dw2-fde.c: Use radix sort instead of split+sort+merge.\n+\n 2022-12-08  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* config/xtensa/xtensa-config-builtin.h (XCHAL_NUM_AREGS)"}, {"sha": "b49ee3829d5d0ef32b1a1b402e756e9a2e383994", "filename": "libgcc/unwind-dw2-fde.c", "status": "modified", "additions": 175, "deletions": 111, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2-fde.c?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -63,8 +63,6 @@ release_registered_frames (void)\n \n static void\n get_pc_range (const struct object *ob, uintptr_type *range);\n-static void\n-init_object (struct object *ob);\n \n #else\n /* Without fast path frame deregistration must always succeed.  */\n@@ -76,6 +74,7 @@ static const int in_shutdown = 0;\n    by decreasing value of pc_begin.  */\n static struct object *unseen_objects;\n static struct object *seen_objects;\n+#endif\n \n #ifdef __GTHREAD_MUTEX_INIT\n static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n@@ -103,7 +102,6 @@ init_object_mutex_once (void)\n static __gthread_mutex_t object_mutex;\n #endif\n #endif\n-#endif\n \n /* Called from crtbegin.o to register the unwind info for an object.  */\n \n@@ -126,10 +124,7 @@ __register_frame_info_bases (const void *begin, struct object *ob,\n #endif\n \n #ifdef ATOMIC_FDE_FAST_PATH\n-  // Initialize eagerly to avoid locking later\n-  init_object (ob);\n-\n-  // And register the frame\n+  // Register the frame in the b-tree\n   uintptr_type range[2];\n   get_pc_range (ob, range);\n   btree_insert (&registered_frames, range[0], range[1] - range[0], ob);\n@@ -180,10 +175,7 @@ __register_frame_info_table_bases (void *begin, struct object *ob,\n   ob->s.b.encoding = DW_EH_PE_omit;\n \n #ifdef ATOMIC_FDE_FAST_PATH\n-  // Initialize eagerly to avoid locking later\n-  init_object (ob);\n-\n-  // And register the frame\n+  // Register the frame in the b-tree\n   uintptr_type range[2];\n   get_pc_range (ob, range);\n   btree_insert (&registered_frames, range[0], range[1] - range[0], ob);\n@@ -456,22 +448,52 @@ fde_mixed_encoding_compare (struct object *ob, const fde *x, const fde *y)\n \n typedef int (*fde_compare_t) (struct object *, const fde *, const fde *);\n \n+// The extractor functions compute the pointer values for a block of\n+// fdes. The block processing hides the call overhead.\n \n-/* This is a special mix of insertion sort and heap sort, optimized for\n-   the data sets that actually occur. They look like\n-   101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.\n-   I.e. a linearly increasing sequence (coming from functions in the text\n-   section), with additionally a few unordered elements (coming from functions\n-   in gnu_linkonce sections) whose values are higher than the values in the\n-   surrounding linear sequence (but not necessarily higher than the values\n-   at the end of the linear sequence!).\n-   The worst-case total run time is O(N) + O(n log (n)), where N is the\n-   total number of FDEs and n is the number of erratic ones.  */\n+static void\n+fde_unencoded_extract (struct object *ob __attribute__ ((unused)),\n+\t\t       _Unwind_Ptr *target, const fde **x, int count)\n+{\n+  for (int index = 0; index < count; ++index)\n+    memcpy (target + index, x[index]->pc_begin, sizeof (_Unwind_Ptr));\n+}\n+\n+static void\n+fde_single_encoding_extract (struct object *ob, _Unwind_Ptr *target,\n+\t\t\t     const fde **x, int count)\n+{\n+  _Unwind_Ptr base;\n+\n+  base = base_from_object (ob->s.b.encoding, ob);\n+  for (int index = 0; index < count; ++index)\n+    read_encoded_value_with_base (ob->s.b.encoding, base, x[index]->pc_begin,\n+\t\t\t\t  target + index);\n+}\n+\n+static void\n+fde_mixed_encoding_extract (struct object *ob, _Unwind_Ptr *target,\n+\t\t\t    const fde **x, int count)\n+{\n+  for (int index = 0; index < count; ++index)\n+    {\n+      int encoding = get_fde_encoding (x[index]);\n+      read_encoded_value_with_base (encoding, base_from_object (encoding, ob),\n+\t\t\t\t    x[index]->pc_begin, target + index);\n+    }\n+}\n+\n+typedef void (*fde_extractor_t) (struct object *, _Unwind_Ptr *, const fde **,\n+\t\t\t\t int);\n+\n+// Data is is sorted using radix sort if possible, using an temporary\n+// auxiliary data structure of the same size as the input. When running\n+// out of memory do in-place heap sort.\n \n struct fde_accumulator\n {\n   struct fde_vector *linear;\n-  struct fde_vector *erratic;\n+  struct fde_vector *aux;\n };\n \n static inline int\n@@ -485,8 +507,8 @@ start_fde_sort (struct fde_accumulator *accu, size_t count)\n   if ((accu->linear = malloc (size)))\n     {\n       accu->linear->count = 0;\n-      if ((accu->erratic = malloc (size)))\n-\taccu->erratic->count = 0;\n+      if ((accu->aux = malloc (size)))\n+\taccu->aux->count = 0;\n       return 1;\n     }\n   else\n@@ -500,59 +522,6 @@ fde_insert (struct fde_accumulator *accu, const fde *this_fde)\n     accu->linear->array[accu->linear->count++] = this_fde;\n }\n \n-/* Split LINEAR into a linear sequence with low values and an erratic\n-   sequence with high values, put the linear one (of longest possible\n-   length) into LINEAR and the erratic one into ERRATIC. This is O(N).\n-\n-   Because the longest linear sequence we are trying to locate within the\n-   incoming LINEAR array can be interspersed with (high valued) erratic\n-   entries.  We construct a chain indicating the sequenced entries.\n-   To avoid having to allocate this chain, we overlay it onto the space of\n-   the ERRATIC array during construction.  A final pass iterates over the\n-   chain to determine what should be placed in the ERRATIC array, and\n-   what is the linear sequence.  This overlay is safe from aliasing.  */\n-\n-static inline void\n-fde_split (struct object *ob, fde_compare_t fde_compare,\n-\t   struct fde_vector *linear, struct fde_vector *erratic)\n-{\n-  static const fde *marker;\n-  size_t count = linear->count;\n-  const fde *const *chain_end = &marker;\n-  size_t i, j, k;\n-\n-  /* This should optimize out, but it is wise to make sure this assumption\n-     is correct. Should these have different sizes, we cannot cast between\n-     them and the overlaying onto ERRATIC will not work.  */\n-  gcc_assert (sizeof (const fde *) == sizeof (const fde **));\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      const fde *const *probe;\n-\n-      for (probe = chain_end;\n-\t   probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;\n-\t   probe = chain_end)\n-\t{\n-\t  chain_end = (const fde *const*) erratic->array[probe - linear->array];\n-\t  erratic->array[probe - linear->array] = NULL;\n-\t}\n-      erratic->array[i] = (const fde *) chain_end;\n-      chain_end = &linear->array[i];\n-    }\n-\n-  /* Each entry in LINEAR which is part of the linear sequence we have\n-     discovered will correspond to a non-NULL entry in the chain we built in\n-     the ERRATIC array.  */\n-  for (i = j = k = 0; i < count; i++)\n-    if (erratic->array[i])\n-      linear->array[j++] = linear->array[i];\n-    else\n-      erratic->array[k++] = linear->array[i];\n-  linear->count = j;\n-  erratic->count = k;\n-}\n-\n #define SWAP(x,y) do { const fde * tmp = x; x = y; y = tmp; } while (0)\n \n /* Convert a semi-heap to a heap.  A semi-heap is a heap except possibly\n@@ -615,59 +584,116 @@ frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n #undef SWAP\n }\n \n-/* Merge V1 and V2, both sorted, and put the result into V1.  */\n+// Radix sort data in V1 using V2 as aux memory. Runtime O(n).\n static inline void\n-fde_merge (struct object *ob, fde_compare_t fde_compare,\n-\t   struct fde_vector *v1, struct fde_vector *v2)\n+fde_radixsort (struct object *ob, fde_extractor_t fde_extractor,\n+\t       struct fde_vector *v1, struct fde_vector *v2)\n {\n-  size_t i1, i2;\n-  const fde * fde2;\n-\n-  i2 = v2->count;\n-  if (i2 > 0)\n+#define FANOUTBITS 8\n+#define FANOUT (1 << FANOUTBITS)\n+#define BLOCKSIZE 128\n+  const unsigned rounds\n+    = (__CHAR_BIT__ * sizeof (_Unwind_Ptr) + FANOUTBITS - 1) / FANOUTBITS;\n+  const fde **a1 = v1->array, **a2 = v2->array;\n+  _Unwind_Ptr ptrs[BLOCKSIZE + 1];\n+  unsigned n = v1->count;\n+  for (unsigned round = 0; round != rounds; ++round)\n     {\n-      i1 = v1->count;\n-      do\n+      unsigned counts[FANOUT] = {0};\n+      unsigned violations = 0;\n+\n+      // Count the number of elements per bucket and check if we are already\n+      // sorted.\n+      _Unwind_Ptr last = 0;\n+      for (unsigned i = 0; i < n;)\n+\t{\n+\t  unsigned chunk = ((n - i) <= BLOCKSIZE) ? (n - i) : BLOCKSIZE;\n+\t  fde_extractor (ob, ptrs + 1, a1 + i, chunk);\n+\t  ptrs[0] = last;\n+\t  for (unsigned j = 0; j < chunk; ++j)\n+\t    {\n+\t      unsigned b = (ptrs[j + 1] >> (round * FANOUTBITS)) & (FANOUT - 1);\n+\t      counts[b]++;\n+\t      // Use summation instead of an if to eliminate branches.\n+\t      violations += ptrs[j + 1] < ptrs[j];\n+\t    }\n+\t  i += chunk;\n+\t  last = ptrs[chunk];\n+\t}\n+\n+      // Stop if we are already sorted.\n+      if (!violations)\n+\t{\n+\t  // The sorted data is in a1 now.\n+\t  a2 = a1;\n+\t  break;\n+\t}\n+\n+      // Compute the prefix sum.\n+      unsigned sum = 0;\n+      for (unsigned i = 0; i != FANOUT; ++i)\n+\t{\n+\t  unsigned s = sum;\n+\t  sum += counts[i];\n+\t  counts[i] = s;\n+\t}\n+\n+      // Place all elements.\n+      for (unsigned i = 0; i < n;)\n \t{\n-\t  i2--;\n-\t  fde2 = v2->array[i2];\n-\t  while (i1 > 0 && fde_compare (ob, v1->array[i1-1], fde2) > 0)\n+\t  unsigned chunk = ((n - i) <= BLOCKSIZE) ? (n - i) : BLOCKSIZE;\n+\t  fde_extractor (ob, ptrs, a1 + i, chunk);\n+\t  for (unsigned j = 0; j < chunk; ++j)\n \t    {\n-\t      v1->array[i1+i2] = v1->array[i1-1];\n-\t      i1--;\n+\t      unsigned b = (ptrs[j] >> (round * FANOUTBITS)) & (FANOUT - 1);\n+\t      a2[counts[b]++] = a1[i + j];\n \t    }\n-\t  v1->array[i1+i2] = fde2;\n+\t  i += chunk;\n \t}\n-      while (i2 > 0);\n-      v1->count += v2->count;\n+\n+      // Swap a1 and a2.\n+      const fde **tmp = a1;\n+      a1 = a2;\n+      a2 = tmp;\n     }\n+#undef BLOCKSIZE\n+#undef FANOUT\n+#undef FANOUTBITS\n+\n+  // The data is in a2 now, move in place if needed.\n+  if (a2 != v1->array)\n+    memcpy (v1->array, a2, sizeof (const fde *) * n);\n }\n \n static inline void\n end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)\n {\n-  fde_compare_t fde_compare;\n-\n   gcc_assert (!accu->linear || accu->linear->count == count);\n \n-  if (ob->s.b.mixed_encoding)\n-    fde_compare = fde_mixed_encoding_compare;\n-  else if (ob->s.b.encoding == DW_EH_PE_absptr)\n-    fde_compare = fde_unencoded_compare;\n-  else\n-    fde_compare = fde_single_encoding_compare;\n-\n-  if (accu->erratic)\n+  if (accu->aux)\n     {\n-      fde_split (ob, fde_compare, accu->linear, accu->erratic);\n-      gcc_assert (accu->linear->count + accu->erratic->count == count);\n-      frame_heapsort (ob, fde_compare, accu->erratic);\n-      fde_merge (ob, fde_compare, accu->linear, accu->erratic);\n-      free (accu->erratic);\n+      fde_extractor_t fde_extractor;\n+      if (ob->s.b.mixed_encoding)\n+\tfde_extractor = fde_mixed_encoding_extract;\n+      else if (ob->s.b.encoding == DW_EH_PE_absptr)\n+\tfde_extractor = fde_unencoded_extract;\n+      else\n+\tfde_extractor = fde_single_encoding_extract;\n+\n+      fde_radixsort (ob, fde_extractor, accu->linear, accu->aux);\n+      free (accu->aux);\n     }\n   else\n     {\n-      /* We've not managed to malloc an erratic array,\n+      fde_compare_t fde_compare;\n+      if (ob->s.b.mixed_encoding)\n+\tfde_compare = fde_mixed_encoding_compare;\n+      else if (ob->s.b.encoding == DW_EH_PE_absptr)\n+\tfde_compare = fde_unencoded_compare;\n+      else\n+\tfde_compare = fde_single_encoding_compare;\n+\n+      /* We've not managed to malloc an aux array,\n \t so heap sort in the linear one.  */\n       frame_heapsort (ob, fde_compare, accu->linear);\n     }\n@@ -892,7 +918,15 @@ init_object (struct object* ob)\n   accu.linear->orig_data = ob->u.single;\n   ob->u.sort = accu.linear;\n \n+#ifdef ATOMIC_FDE_FAST_PATH\n+  // We must update the sorted bit with an atomic operation\n+  struct object tmp;\n+  tmp.s.b = ob->s.b;\n+  tmp.s.b.sorted = 1;\n+  __atomic_store (&(ob->s.b), &(tmp.s.b), __ATOMIC_RELEASE);\n+#else\n   ob->s.b.sorted = 1;\n+#endif\n }\n \n #ifdef ATOMIC_FDE_FAST_PATH\n@@ -1130,6 +1164,21 @@ search_object (struct object* ob, void *pc)\n     }\n }\n \n+#ifdef ATOMIC_FDE_FAST_PATH\n+\n+// Check if the object was already initialized\n+static inline bool\n+is_object_initialized (struct object *ob)\n+{\n+  // We have to use acquire atomics for the read, which\n+  // is a bit involved as we read from a bitfield\n+  struct object tmp;\n+  __atomic_load (&(ob->s.b), &(tmp.s.b), __ATOMIC_ACQUIRE);\n+  return tmp.s.b.sorted;\n+}\n+\n+#endif\n+\n const fde *\n _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n {\n@@ -1141,6 +1190,21 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n   if (!ob)\n     return NULL;\n \n+  // Initialize the object lazily\n+  if (!is_object_initialized (ob))\n+    {\n+      // Check again under mutex\n+      init_object_mutex_once ();\n+      __gthread_mutex_lock (&object_mutex);\n+\n+      if (!ob->s.b.sorted)\n+\t{\n+\t  init_object (ob);\n+\t}\n+\n+      __gthread_mutex_unlock (&object_mutex);\n+    }\n+\n   f = search_object (ob, pc);\n #else\n "}, {"sha": "8ebc0c107a320ad1a13d542ecfccf52a94976664", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,10 @@\n+2022-12-15  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR libfortran/108056\n+\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc,\n+\tgfc_desc_to_cfi_desc): Mostly revert to GCC 11 version for\n+\tthose backward-compatiblity-only functions.\n+\n 2022-10-12  Martin Liska  <mliska@suse.cz>\n \n \t* configure: Regenerate."}, {"sha": "cf81dc53e0eb2b3ae82fdc1b75e8caed8f67b10f", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,14 @@\n+2022-12-16  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR libfortran/108056\n+\t* testsuite/libgomp.fortran/allocate-4.f90: Remove\n+\taccidentally added file.\n+\n+2022-12-15  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR libfortran/108056\n+\t* testsuite/libgomp.fortran/allocate-4.f90: New file.\n+\n 2022-12-14  Julian Brown  <julian@codesourcery.com>\n \n \t* testsuite/libgomp.fortran/combined-directive-splitting-1.f90: New"}, {"sha": "ddb507ba8e40fc278aa5a2ad66e3c688f178b22f", "filename": "libgomp/testsuite/libgomp.fortran/allocate-4.f90", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4f8ef1a199460b7e7cc99b3e721eabbd97951f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4f8ef1a199460b7e7cc99b3e721eabbd97951f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-4.f90?ref=6d4f8ef1a199460b7e7cc99b3e721eabbd97951f", "patch": "@@ -1,42 +0,0 @@\n-! { dg-do compile }\n-\n-\n-subroutine test()\n-use iso_c_binding, only: c_intptr_t\n-implicit none\n-integer, parameter :: omp_allocator_handle_kind = 1 !! <<<\n-integer (kind=omp_allocator_handle_kind), &\n-                 parameter :: omp_high_bw_mem_alloc = 4\n-integer :: q, x,y,z\n-integer, parameter :: cnst(2) = [64, 101]\n-\n-!$omp parallel allocate( omp_high_bw_mem_alloc : x)  firstprivate(x) ! { dg-error \"Expected integer expression of the 'omp_allocator_handle_kind' kind\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( allocator (omp_high_bw_mem_alloc) : x)  firstprivate(x) ! { dg-error \"Expected integer expression of the 'omp_allocator_handle_kind' kind\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( align (q) : x)  firstprivate(x) ! { dg-error \"32:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( align (32) : x)  firstprivate(x) ! OK\n-!$omp end parallel\n-\n-!$omp parallel allocate( align(q) : x) firstprivate(x) ! { dg-error \"31:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( align(cnst(1)) : x ) firstprivate(x) ! OK\n-!$omp end parallel\n-\n-!$omp parallel allocate( align(cnst(2)) : x) firstprivate(x)  ! { dg-error \"31:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( align( 31) :x) firstprivate(x)  ! { dg-error \"32:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( align (32.0): x) firstprivate(x)  ! { dg-error \"32:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n-!$omp end parallel\n-\n-!$omp parallel allocate( align(cnst ) : x ) firstprivate(x)  ! { dg-error \"31:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n-!$omp end parallel\n-end"}, {"sha": "3f5637653e70ee330bbafcff9b694692346e455f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -1,3 +1,68 @@\n+2022-12-16  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/abi/post/hppa-linux-gnu/baseline_symbols.txt: Update.\n+\n+2022-12-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/expected (expected): Add monadic operations.\n+\t(expected<void, E>): Likewise.\n+\t* include/std/version (__cpp_lib_expected): Bump value.\n+\t* testsuite/20_util/expected/synopsis.cc: Adjust expected macro\n+\tvalue.\n+\t* testsuite/20_util/expected/version.cc: Likewise.\n+\t* testsuite/20_util/expected/illformed_neg.cc: Prune additional\n+\terrors from ill-formed monadic operations.\n+\t* testsuite/20_util/expected/observers.cc: Check error_or.\n+\t* testsuite/20_util/expected/monadic.cc: New test.\n+\n+2022-12-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/expected (expected::_M_swap_val_unex): Guard the\n+\tcorrect object.\n+\t(expected::swap): Move is_swappable\n+\trequirement from static_assert to constraint.\n+\t(swap): Likewise.\n+\t(operator==): Remove noexcept-specifier.\n+\t* testsuite/20_util/expected/swap.cc: Check swapping of\n+\ttypes without non-throwing move constructor. Check constraints\n+\ton swap.\n+\t* testsuite/20_util/expected/unexpected.cc: Check constraints on\n+\tswap.\n+\t* testsuite/20_util/expected/equality.cc: New test.\n+\n+2022-12-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/alloc_traits.h (__allocator_traits_base::__rebind):\n+\tAdd static assert for rebind requirement.\n+\t* testsuite/20_util/allocator_traits/members/rebind_alloc.cc:\n+\tFix invalid rebind member in test allocator.\n+\t* testsuite/20_util/allocator_traits/requirements/rebind_neg.cc:\n+\tNew test.\n+\t* testsuite/20_util/scoped_allocator/outermost.cc: Add rebind to\n+\ttest allocator.\n+\t* testsuite/23_containers/forward_list/48101_neg.cc: Prune new\n+\tstatic assert error.\n+\t* testsuite/23_containers/unordered_multiset/48101_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/48101_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/vector/52591.cc: Fix typo in rebind.\n+\n+2022-12-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/108118\n+\t* include/bits/shared_ptr_base.h (weak_ptr::operator=):\n+\tImplement as move-and-swap exactly as specified in the standard.\n+\t* testsuite/20_util/weak_ptr/cons/self_move.cc: New test.\n+\n+2022-12-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libstdc++/108075\n+\t* config/abi/pre/gnu.ver (CXXABI_1.3.14): Export\n+\t_ZTIDF[0-9]*[_bx], _ZTIPDF[0-9]*[_bx] and _ZTIPKDF[0-9]*[_bx].\n+\t* testsuite/util/testsuite_abi.cc (check_version): Handle\n+\tCXXABI_1.3.14.\n+\n 2022-12-14  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/108097"}, {"sha": "ff40f201eb8544bc96b8967bdd43e2ad1e73b018", "filename": "libstdc++-v3/config/abi/post/hppa-linux-gnu/baseline_symbols.txt", "status": "modified", "additions": 6018, "deletions": 1, "changes": 6019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpost%2Fhppa-linux-gnu%2Fbaseline_symbols.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpost%2Fhppa-linux-gnu%2Fbaseline_symbols.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpost%2Fhppa-linux-gnu%2Fbaseline_symbols.txt?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893"}, {"sha": "667cc4dfca4a6e7f20297210750869d6aa90a267", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -2794,6 +2794,16 @@ CXXABI_1.3.13 {\n \n } CXXABI_1.3.12;\n \n+CXXABI_1.3.14 {\n+\n+    # typeinfo for _Float{16,32,64,128,32x,64x,128x} and\n+    # __bf16\n+    _ZTIDF[0-9]*[_bx];\n+    _ZTIPDF[0-9]*[_bx];\n+    _ZTIPKDF[0-9]*[_bx];\n+\n+} CXXABI_1.3.13;\n+\n # Symbols in the support library (libsupc++) supporting transactional memory.\n CXXABI_TM_1 {\n "}, {"sha": "6eae409ab53fb79c6c73662f98c3267918f3b4c6", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -51,12 +51,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct __allocator_traits_base\n   {\n     template<typename _Tp, typename _Up, typename = void>\n-      struct __rebind : __replace_first_arg<_Tp, _Up> { };\n+      struct __rebind : __replace_first_arg<_Tp, _Up>\n+      {\n+\tstatic_assert(is_same<\n+\t  typename __replace_first_arg<_Tp, typename _Tp::value_type>::type,\n+\t\t\t_Tp>::value,\n+\t  \"allocator_traits<A>::rebind_alloc<A::value_type> must be A\");\n+      };\n \n     template<typename _Tp, typename _Up>\n       struct __rebind<_Tp, _Up,\n \t\t      __void_t<typename _Tp::template rebind<_Up>::other>>\n-      { using type = typename _Tp::template rebind<_Up>::other; };\n+      {\n+\tusing type = typename _Tp::template rebind<_Up>::other;\n+\n+\tstatic_assert(is_same<\n+\t  typename _Tp::template rebind<typename _Tp::value_type>::other,\n+\t\t\t_Tp>::value,\n+\t  \"allocator_traits<A>::rebind_alloc<A::value_type> must be A\");\n+      };\n \n   protected:\n     template<typename _Tp>"}, {"sha": "c22b397a194675ef59ce424b6b2667724812496e", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -2049,9 +2049,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __weak_ptr&\n       operator=(__weak_ptr&& __r) noexcept\n       {\n-\t_M_ptr = __r._M_ptr;\n-\t_M_refcount = std::move(__r._M_refcount);\n-\t__r._M_ptr = nullptr;\n+\t__weak_ptr(std::move(__r)).swap(*this);\n \treturn *this;\n       }\n "}, {"sha": "555779581f2cd1fb7115a5a10cc19a22f3003337", "filename": "libstdc++-v3/include/std/expected", "status": "modified", "additions": 588, "deletions": 12, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -35,6 +35,7 @@\n \n #include <initializer_list>\n #include <bits/exception.h>\t// exception\n+#include <bits/invoke.h>\t// __invoke\n #include <bits/stl_construct.h>\t// construct_at\n #include <bits/utility.h>\t// in_place_t\n \n@@ -49,7 +50,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-#define __cpp_lib_expected 202202L\n+#define __cpp_lib_expected 202211L\n \n   /// Discriminated union that holds an expected value or an error value.\n   /**\n@@ -151,11 +152,20 @@ namespace __expected\n   template<typename _Tp>\n     constexpr bool __is_unexpected<unexpected<_Tp>> = true;\n \n+  template<typename _Fn, typename _Tp>\n+    using __result = remove_cvref_t<invoke_result_t<_Fn&&, _Tp&&>>;\n+  template<typename _Fn>\n+    using __result0 = remove_cvref_t<invoke_result_t<_Fn&&>>;\n+\n   template<typename _Er>\n     concept __can_be_unexpected\n       = is_object_v<_Er> && (!is_array_v<_Er>)\n \t  && (!__expected::__is_unexpected<_Er>)\n \t  && (!is_const_v<_Er>) && (!is_volatile_v<_Er>);\n+\n+  // Tag types for in-place construction from an invocation result.\n+  struct __in_place_inv { };\n+  struct __unexpect_inv { };\n }\n /// @endcond\n \n@@ -217,8 +227,8 @@ namespace __expected\n \n       constexpr void\n       swap(unexpected& __other) noexcept(is_nothrow_swappable_v<_Er>)\n+      requires is_swappable_v<_Er>\n       {\n-\tstatic_assert( is_swappable_v<_Er> );\n \tusing std::swap;\n \tswap(_M_unex, __other._M_unex);\n       }\n@@ -230,9 +240,8 @@ namespace __expected\n \t{ return __x._M_unex == __y.error(); }\n \n       friend constexpr void\n-      swap(unexpected& __x, unexpected& __y)\n-      noexcept(noexcept(__x.swap(__y)))\n-      requires requires {__x.swap(__y);}\n+      swap(unexpected& __x, unexpected& __y) noexcept(noexcept(__x.swap(__y)))\n+      requires is_swappable_v<_Er>\n       { __x.swap(__y); }\n \n     private:\n@@ -335,6 +344,14 @@ namespace __expected\n \t\t   __not_<is_convertible<_Err, _Er>>\n \t\t  >;\n \n+      template<typename _Up>\n+\tstatic constexpr bool __same_val\n+\t  = is_same_v<typename _Up::value_type, _Tp>;\n+\n+      template<typename _Up>\n+\tstatic constexpr bool __same_err\n+\t  = is_same_v<typename _Up::error_type, _Er>;\n+\n     public:\n       using value_type = _Tp;\n       using error_type = _Er;\n@@ -792,14 +809,282 @@ namespace __expected\n \t  return static_cast<_Tp>(std::forward<_Up>(__v));\n \t}\n \n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) const&\n+\t{\n+\t  static_assert( is_copy_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return _M_unex;\n+\t}\n+\n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) &&\n+\t{\n+\t  static_assert( is_move_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return std::move(_M_unex);\n+\t}\n+\n+      // monadic operations\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), value());\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), value());\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp&&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(value()));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp&&>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(value()));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, value());\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, value());\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, std::move(value()));\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr(in_place, std::move(value()));\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp&>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_val);\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp&>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_val);\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, _Tp>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_val));\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result<_Fn, const _Tp>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_val));\n+\t\t\t});\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, value());\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, value());\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, std::move(value()));\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Tp>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res(in_place, std::move(value()));\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n       // equality operators\n \n       template<typename _Up, typename _Er2>\n \trequires (!is_void_v<_Up>)\n \tfriend constexpr bool\n \toperator==(const expected& __x, const expected<_Up, _Er2>& __y)\n-\tnoexcept(noexcept(bool(*__x == *__y))\n-\t\t  && noexcept(bool(__x.error() == __y.error())))\n+\t// FIXME: noexcept(noexcept(bool(*__x == *__y))\n+\t\t  // && noexcept(bool(__x.error() == __y.error())))\n \t{\n \t  if (__x.has_value())\n \t    return __y.has_value() && bool(*__x == *__y);\n@@ -810,13 +1095,13 @@ namespace __expected\n       template<typename _Up>\n \tfriend constexpr bool\n \toperator==(const expected& __x, const _Up& __v)\n-\tnoexcept(noexcept(bool(*__x == __v)))\n+\t// FIXME: noexcept(noexcept(bool(*__x == __v)))\n \t{ return __x.has_value() && bool(*__x == __v); }\n \n       template<typename _Er2>\n \tfriend constexpr bool\n \toperator==(const expected& __x, const unexpected<_Er2>& __e)\n-\tnoexcept(noexcept(bool(__x.error() == __e.error())))\n+\t// FIXME: noexcept(noexcept(bool(__x.error() == __e.error())))\n \t{ return !__x.has_value() && bool(__x.error() == __e.error()); }\n \n       friend constexpr void\n@@ -878,7 +1163,7 @@ namespace __expected\n \t  }\n \telse\n \t  {\n-\t    __expected::_Guard<_Tp> __guard(__rhs._M_val);\n+\t    __expected::_Guard<_Tp> __guard(_M_val);\n \t    std::construct_at(__builtin_addressof(_M_unex),\n \t\t\t      std::move(__rhs._M_unex)); // might throw\n \t    _M_has_value = false;\n@@ -889,6 +1174,21 @@ namespace __expected\n \t  }\n       }\n \n+      using __in_place_inv = __expected::__in_place_inv;\n+      using __unexpect_inv = __expected::__unexpect_inv;\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__in_place_inv, _Fn&& __fn)\n+\t: _M_val(std::forward<_Fn>(__fn)()), _M_has_value(true)\n+\t{ }\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__unexpect_inv, _Fn&& __fn)\n+\t: _M_unex(std::forward<_Fn>(__fn)()), _M_has_value(false)\n+\t{ }\n+\n       union {\n \t_Tp _M_val;\n \t_Er _M_unex;\n@@ -911,6 +1211,14 @@ namespace __expected\n \t\t   is_constructible<_Unex, const expected<_Up, _Err>>\n \t\t  >;\n \n+      template<typename _Up>\n+\tstatic constexpr bool __same_val\n+\t  = is_same_v<typename _Up::value_type, _Tp>;\n+\n+      template<typename _Up>\n+\tstatic constexpr bool __same_err\n+\t  = is_same_v<typename _Up::error_type, _Er>;\n+\n     public:\n       using value_type = _Tp;\n       using error_type = _Er;\n@@ -1181,13 +1489,267 @@ namespace __expected\n \treturn std::move(_M_unex);\n       }\n \n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) const&\n+\t{\n+\t  static_assert( is_copy_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return _M_unex;\n+\t}\n+\n+      template<typename _Gr = _Er>\n+\tconstexpr _Er\n+\terror_or(_Gr&& __e) &&\n+\t{\n+\t  static_assert( is_move_constructible_v<_Er> );\n+\t  static_assert( is_convertible_v<_Gr, _Er> );\n+\n+\t  if (_M_has_value)\n+\t    return std::forward<_Gr>(__e);\n+\t  return std::move(_M_unex);\n+\t}\n+\n+      // monadic operations\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+     template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+       template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\tand_then(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  static_assert(__expected::__is_expected<_Up>);\n+\t  static_assert(is_same_v<typename _Up::error_type, _Er>);\n+\n+\t  if (has_value())\n+\t    return std::__invoke(std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Up(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), error());\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\tor_else(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  static_assert(__expected::__is_expected<_Gr>);\n+\t  static_assert(is_same_v<typename _Gr::value_type, _Tp>);\n+\n+\t  if (has_value())\n+\t    return _Gr();\n+\t  else\n+\t    return std::__invoke(std::forward<_Fn>(__f), std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_copy_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, error());\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn> requires is_move_constructible_v<_Er>\n+\tconstexpr auto\n+\ttransform(_Fn&& __f) const &&\n+\t{\n+\t  using _Up = __expected::__result0<_Fn>;\n+\t  using _Res = expected<_Up, _Er>;\n+\n+\t  if (has_value())\n+\t    return _Res(__in_place_inv{}, std::forward<_Fn>(__f));\n+\t  else\n+\t    return _Res(unexpect, std::move(error()));\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       _M_unex);\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n+      template<typename _Fn>\n+\tconstexpr auto\n+\ttransform_error(_Fn&& __f) const &&\n+\t{\n+\t  using _Gr = __expected::__result<_Fn, const _Er&&>;\n+\t  using _Res = expected<_Tp, _Gr>;\n+\n+\t  if (has_value())\n+\t    return _Res();\n+\t  else\n+\t    return _Res(__unexpect_inv{}, [&]() {\n+\t\t\t  return std::__invoke(std::forward<_Fn>(__f),\n+\t\t\t\t\t       std::move(_M_unex));\n+\t\t\t});\n+\t}\n+\n       // equality operators\n \n       template<typename _Up, typename _Er2>\n \trequires is_void_v<_Up>\n \tfriend constexpr bool\n \toperator==(const expected& __x, const expected<_Up, _Er2>& __y)\n-\tnoexcept(noexcept(bool(__x.error() == __y.error())))\n+\t// FIXME: noexcept(noexcept(bool(__x.error() == __y.error())))\n \t{\n \t  if (__x.has_value())\n \t    return __y.has_value();\n@@ -1198,7 +1760,7 @@ namespace __expected\n       template<typename _Er2>\n \tfriend constexpr bool\n \toperator==(const expected& __x, const unexpected<_Er2>& __e)\n-\tnoexcept(noexcept(bool(__x.error() == __e.error())))\n+\t// FIXME: noexcept(noexcept(bool(__x.error() == __e.error())))\n \t{ return !__x.has_value() && bool(__x.error() == __e.error()); }\n \n       friend constexpr void\n@@ -1224,6 +1786,20 @@ namespace __expected\n \t    _M_unex = std::forward<_Vp>(__v);\n \t}\n \n+      using __in_place_inv = __expected::__in_place_inv;\n+      using __unexpect_inv = __expected::__unexpect_inv;\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__in_place_inv, _Fn&& __fn)\n+\t: _M_void(), _M_has_value(true)\n+\t{ std::forward<_Fn>(__fn)(); }\n+\n+      template<typename _Fn>\n+\texplicit constexpr\n+\texpected(__unexpect_inv, _Fn&& __fn)\n+\t: _M_unex(std::forward<_Fn>(__fn)()), _M_has_value(false)\n+\t{ }\n \n       union {\n \tstruct { } _M_void;"}, {"sha": "576eebc7dc8271820b3f9bd653f2ab1875cbc7b0", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -306,7 +306,7 @@\n #define __cpp_lib_constexpr_charconv 202207L\n #define __cpp_lib_constexpr_typeinfo 202106L\n #if __cpp_concepts >= 202002L\n-# define __cpp_lib_expected 202202L\n+# define __cpp_lib_expected 202211L\n #endif\n #define __cpp_lib_invoke_r 202106L\n #define __cpp_lib_is_scoped_enum 202011L"}, {"sha": "dc2b1afa2d53e8964bfc2c8ddcd03a8e033c9638", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/rebind_alloc.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Frebind_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Frebind_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Frebind_alloc.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -24,17 +24,16 @@ using std::is_same;\n template<typename T, typename U>\n   using Rebind = typename std::allocator_traits<T>::template rebind_alloc<U>;\n \n-#if __STDC_HOSTED__\n-template<typename T>\n+template<typename T, typename = T>\n   struct HasRebind {\n     using value_type = T;\n-    template<typename U> struct rebind { using other = std::allocator<U>; };\n+    template<typename U> struct rebind { using other = HasRebind<U>; };\n   };\n \n-static_assert(is_same<Rebind<HasRebind<int>, long>,\n-\t\t      std::allocator<long>>::value,\n+// Would get HasRebind<long, int> here if the first template argument is\n+// replaced instead of using the nested rebind.\n+static_assert(is_same<Rebind<HasRebind<int>, long>, HasRebind<long>>::value,\n \t      \"nested alias template is used\");\n-#endif\n \n template<typename T>\n   struct NoRebind0 {"}, {"sha": "a446b592edf34fe7261ecd26b959ee87ce023f35", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/requirements/rebind_neg.cc", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Frebind_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Frebind_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Frebind_neg.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++11 } }\n+#include <vector>\n+\n+// Custom allocator defined with std::allocator, but doesn't provide rebind.\n+template<typename T> struct Alloc : std::allocator<T> { };\n+\n+std::vector<int, Alloc<int>> v; // { dg-error \"here\" \"\" { target c++17_down } }\n+\n+// Custom allocator that does provide rebind, but incorrectly.\n+template<typename T> struct Alloc2\n+{\n+  using value_type = T;\n+  template<typename U> struct rebind { using other = Alloc<U>; }; // not Alloc2\n+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }\n+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }\n+};\n+\n+std::vector<int, Alloc2<int>> v2; // { dg-error \"here\" }\n+\n+// { dg-error \"static assertion failed: .*rebind_alloc\" \"\" { target *-*-* } 0 }"}, {"sha": "1862719e73d52edf8fee760503a9769eb6e84338", "filename": "libstdc++-v3/testsuite/20_util/expected/equality.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fequality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fequality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fequality.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <expected>\n+#include <testsuite_hooks.h>\n+\n+template<typename T, typename U>\n+concept Eq = requires(T t, U u) { t == u; };\n+\n+static_assert(Eq<std::expected<int, long>, std::expected<short, unsigned>>);\n+static_assert(Eq<std::expected<void, long>, std::expected<void, unsigned>>);\n+// static_assert(!Eq<std::expected<void, long>, std::expected<short, unsigned>>);\n+static_assert(Eq<std::expected<int, long>, short>);\n+static_assert(!Eq<std::expected<void, long>, short>);\n+static_assert(Eq<std::expected<int, long>, std::unexpected<short>>);\n+static_assert(Eq<std::expected<void, long>, std::unexpected<short>>);\n+\n+struct NotEqCmp\n+{\n+  constexpr bool operator==(int) const { return true; }\n+  bool operator==(NotEqCmp) const = delete;\n+};\n+\n+constexpr bool\n+test_eq()\n+{\n+  std::expected<NotEqCmp, int> e1;\n+  VERIFY(e1 == 1);\n+  std::expected<int, int> e2;\n+  VERIFY(e2 == e2);\n+  VERIFY(e1 == e2);\n+  VERIFY(e1 != std::unexpected<int>(1));\n+  e1 = std::unexpected<int>(1);\n+  VERIFY(e1 == std::unexpected<int>(1));\n+  VERIFY(e1 != std::unexpected<int>(2));\n+  VERIFY(e1 != e2);\n+\n+  std::expected<void, int> e3;\n+  VERIFY(e3 == e3);\n+  VERIFY(e3 != std::unexpected<int>(1));\n+  e3 = std::unexpected<int>(1);\n+  VERIFY(e3 == e3);\n+  VERIFY(e3 == std::unexpected<int>(1));\n+  VERIFY(e3 != std::unexpected<int>(2));\n+\n+  return true;\n+}\n+\n+static_assert( test_eq() );"}, {"sha": "f1b0771aeb993a2f2704cd2e7d4ef7b7f085bc73", "filename": "libstdc++-v3/testsuite/20_util/expected/illformed_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -65,3 +65,4 @@ test_expected_error()\n }\n \n // { dg-prune-output \"static assertion failed\" }\n+// { dg-prune-output \"function returning an array\" }"}, {"sha": "d82774b0e1fd0dde3f03f71a8bc59305fa82f5e4", "filename": "libstdc++-v3/testsuite/20_util/expected/monadic.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fmonadic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fmonadic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fmonadic.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,280 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_and_then()\n+{\n+  std::expected<int, int> e1(1);\n+  VERIFY( e1.and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(100);\n+  }).value() == 100 );\n+  VERIFY( std::move(e1).and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(101);\n+  }).value() == 101 );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(102);\n+  }).value() == 102 );\n+  VERIFY( std::move(ce1).and_then([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::expected<long, int>(103);\n+  }).value() == 103 );\n+\n+  auto fail = [] (auto&&) -> std::expected<void, int> { throw 1; };\n+  std::expected<int, int> e2(std::unexpect, 2);\n+  VERIFY( e2.and_then(fail).error() == 2 );\n+  VERIFY( std::move(e2).and_then(fail).error() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.and_then(fail).error() == 2 );\n+  VERIFY( std::move(ce2).and_then(fail).error() == 2 );\n+\n+  int i = 100;\n+  auto vpass = [&] -> std::expected<int, int> { return i++; };\n+  std::expected<void, int> v1;\n+  VERIFY( v1.and_then(vpass).value() == 100 );\n+  VERIFY( std::move(v1).and_then(vpass).value() == 101 );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.and_then(vpass).value() == 102 );\n+  VERIFY( std::move(cv1).and_then(vpass).value() == 103 );\n+\n+  auto vfail = [] -> std::expected<int, int> { throw 1; };\n+  std::expected<void, int> v2(std::unexpect, 2);\n+  VERIFY( v2.and_then(vfail).error() == 2 );\n+  VERIFY( std::move(v2).and_then(vfail).error() == 2 );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.and_then(vfail).error() == 2 );\n+  VERIFY( std::move(cv2).and_then(vfail).error() == 2 );\n+\n+  static_assert(std::is_same_v<decltype(v1.and_then(vpass)),\n+\t\t\t       decltype(vpass())>);\n+  static_assert(std::is_same_v<decltype(cv1.and_then(vpass)),\n+\t\t\t       decltype(vpass())>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_or_else()\n+{\n+  std::expected<int, int> e1(std::unexpect, 1);\n+  VERIFY( e1.or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(100);\n+  }).value() == 100 );\n+  VERIFY( std::move(e1).or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(101);\n+  }).value() == 101 );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(102);\n+  }).value() == 102 );\n+  VERIFY( std::move(ce1).or_else([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::expected<int, long>(103);\n+  }).value() == 103 );\n+\n+  auto f = [] (auto) -> std::expected<int, long> { throw 1; };\n+  std::expected<int, int> e2(2);\n+  VERIFY( e2.or_else(f).value() == 2 );\n+  VERIFY( std::move(e2).or_else(f).value() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.or_else(f).value() == 2 );\n+  VERIFY( std::move(ce2).or_else(f).value() == 2 );\n+\n+  auto vf = [] (auto) -> std::expected<void, long> { return {}; };\n+  std::expected<void, int> v1(std::unexpect, 1);\n+  VERIFY( v1.or_else(vf).has_value() );\n+  VERIFY( std::move(v1).or_else(vf).has_value() );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.or_else(vf).has_value() );\n+  VERIFY( std::move(cv1).or_else(vf).has_value() );\n+\n+  auto vfail = [] (auto) -> std::expected<void, long> { throw 1; };\n+  std::expected<void, int> v2;\n+  VERIFY( v2.or_else(vfail).has_value() );\n+  VERIFY( std::move(v2).or_else(vfail).has_value() );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.or_else(vfail).has_value() );\n+  VERIFY( std::move(cv2).or_else(vfail).has_value() );\n+\n+  static_assert(std::is_same_v<decltype(v1.or_else(vf)), decltype(vf(1))>);\n+  static_assert(std::is_same_v<decltype(cv1.or_else(vf)), decltype(vf(1))>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_transform()\n+{\n+  std::expected<int, int> e1(1);\n+  VERIFY( e1.transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"100\");\n+  }).value() == \"100\" );\n+  VERIFY( std::move(e1).transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"101\");\n+  }).value() == \"101\" );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"102\");\n+  }).value() == \"102\" );\n+  VERIFY( std::move(ce1).transform([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"103\");\n+  }).value() == \"103\" );\n+\n+  auto fail = [] (auto&&) -> std::string_view { throw 1; };\n+  std::expected<int, int> e2(std::unexpect, 2);\n+  VERIFY( e2.transform(fail).error() == 2 );\n+  VERIFY( std::move(e2).transform(fail).error() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.transform(fail).error() == 2 );\n+  VERIFY( std::move(ce2).transform(fail).error() == 2 );\n+\n+  auto vpass = [&] -> std::string_view { return \"ok\"; };\n+  std::expected<void, int> v1;\n+  VERIFY( v1.transform(vpass).value() == \"ok\" );\n+  VERIFY( std::move(v1).transform(vpass).value() == \"ok\" );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.transform(vpass).value() == \"ok\" );\n+  VERIFY( std::move(cv1).transform(vpass).value() == \"ok\" );\n+\n+  auto vfail = [] -> std::string_view { throw 1; };\n+  std::expected<void, int> v2(std::unexpect, 2);\n+  VERIFY( v2.transform(vfail).error() == 2 );\n+  VERIFY( std::move(v2).transform(vfail).error() == 2 );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.transform(vfail).error() == 2 );\n+  VERIFY( std::move(cv2).transform(vfail).error() == 2 );\n+\n+  static_assert(std::is_same_v<decltype(v1.transform(vpass)),\n+\t\t\t       std::expected<decltype(vpass()), int>>);\n+  static_assert(std::is_same_v<decltype(cv1.transform(vpass)),\n+\t\t\t       std::expected<decltype(vpass()), int>>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_transform_error()\n+{\n+  std::expected<int, int> e1(std::unexpect, 1);\n+  VERIFY( e1.transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"100\");\n+  }).error() == \"100\" );\n+  VERIFY( std::move(e1).transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"101\");\n+  }).error() == \"101\" );\n+  const auto& ce1 = e1;\n+  VERIFY( ce1.transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int&> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"102\");\n+  }).error() == \"102\" );\n+  VERIFY( std::move(ce1).transform_error([]<typename T>(T&& v) {\n+    static_assert( std::is_same_v<T, const int> );\n+    VERIFY( v == 1 );\n+    return std::string_view(\"103\");\n+  }).error() == \"103\" );\n+\n+  auto fail = [] (auto&&) -> std::string_view { throw 1; };\n+  std::expected<int, int> e2(2);\n+  VERIFY( e2.transform_error(fail).value() == 2 );\n+  VERIFY( std::move(e2).transform_error(fail).value() == 2 );\n+  const auto& ce2 = e2;\n+  VERIFY( ce2.transform_error(fail).value() == 2 );\n+  VERIFY( std::move(ce2).transform_error(fail).value() == 2 );\n+\n+  auto vpass = [&] (auto) -> std::string_view { return \"ok\"; };\n+  std::expected<void, int> v1(std::unexpect, 1);\n+  VERIFY( v1.transform_error(vpass).error() == \"ok\" );\n+  VERIFY( std::move(v1).transform_error(vpass).error() == \"ok\" );\n+  const auto& cv1 = v1;\n+  VERIFY( cv1.transform_error(vpass).error() == \"ok\" );\n+  VERIFY( std::move(cv1).transform_error(vpass).error() == \"ok\" );\n+\n+  auto vfail = [] (auto) -> std::string_view { throw 1; };\n+  std::expected<void, int> v2;\n+  VERIFY( v2.transform_error(vfail).has_value() );\n+  VERIFY( std::move(v2).transform_error(vfail).has_value() );\n+  const auto& cv2 = v2;\n+  VERIFY( cv2.transform_error(vfail).has_value() );\n+  VERIFY( std::move(cv2).transform_error(vfail).has_value() );\n+\n+  static_assert(std::is_same_v<decltype(v1.transform_error(vpass)),\n+\t\t\t       std::expected<void, decltype(vpass(1))>>);\n+  static_assert(std::is_same_v<decltype(cv1.transform_error(vpass)),\n+\t\t\t       std::expected<void, decltype(vpass(1))>>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_temporary_materialization()\n+{\n+  struct NonCopyable {\n+    constexpr NonCopyable(int i) : i(i) { }\n+    NonCopyable(const NonCopyable&) = delete;\n+    int i;\n+  };\n+\n+  auto xform = [](int i) { return NonCopyable(i); };\n+\n+  std::expected<int, int> e1(1);\n+  std::expected<NonCopyable, int> n1 = e1.transform(xform);\n+  VERIFY( n1.value().i == 1 );\n+  std::expected<int, int> e2(std::unexpected<int>(2));\n+  std::expected<int, NonCopyable> n2 = e2.transform_error(xform);\n+  VERIFY( n2.error().i == 2 );\n+\n+  auto vxform = [] { return NonCopyable(999); };\n+  std::expected<void, int> v1;\n+  std::expected<NonCopyable, int> nv1 = v1.transform(vxform);\n+  VERIFY( nv1.value().i == 999 );\n+  std::expected<void, int> v2(std::unexpected<int>(22));\n+  std::expected<void, NonCopyable> nv2 = v2.transform_error(xform);\n+  VERIFY( nv2.error().i == 22 );\n+\n+  return true;\n+}\n+\n+int main()\n+{\n+  static_assert( test_and_then() );\n+  test_and_then();\n+  static_assert( test_or_else() );\n+  test_or_else();\n+  static_assert( test_transform() );\n+  test_transform();\n+  static_assert( test_transform_error() );\n+  test_transform_error();\n+  static_assert( test_temporary_materialization() );\n+  test_temporary_materialization();\n+}"}, {"sha": "9bcd9edb80915648d80de1e910646080be79a662", "filename": "libstdc++-v3/testsuite/20_util/expected/observers.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -191,6 +191,24 @@ test_value_or()\n   return true;\n }\n \n+constexpr bool\n+test_error_or()\n+{\n+  std::expected<int, int> e1(1), e2(std::unexpect, 3);\n+  VERIFY( e1.error_or(2) == 2 );\n+  VERIFY( std::move(e1).error_or(2) == 2 );\n+  VERIFY( e2.error_or(2) == 3 );\n+  VERIFY( std::move(e2).error_or(2) == 3 );\n+\n+  std::expected<void, int> e3, e4(std::unexpect, 3);\n+  VERIFY( e3.error_or(2) == 2 );\n+  VERIFY( std::move(e3).error_or(2) == 2 );\n+  VERIFY( e4.error_or(2) == 3 );\n+  VERIFY( std::move(e4).error_or(2) == 3 );\n+\n+  return true;\n+}\n+\n int main()\n {\n   static_assert( test_arrow() );\n@@ -206,4 +224,6 @@ int main()\n   test_error();\n   static_assert( test_value_or() );\n   test_value_or();\n+  static_assert( test_error_or() );\n+  test_error_or();\n }"}, {"sha": "08a110da47c4fc82164e421792cce3e1391a1036", "filename": "libstdc++-v3/testsuite/20_util/expected/swap.cc", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fswap.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -4,8 +4,18 @@\n #include <expected>\n #include <testsuite_hooks.h>\n \n+struct NonTrivial\n+{\n+  constexpr NonTrivial(int i) : i(i) { }\n+  constexpr NonTrivial(const NonTrivial& x) noexcept(false): i(x.i) { }\n+  constexpr ~NonTrivial() { }\n+  int i;\n+\n+  constexpr bool operator==(const NonTrivial&) const = default;\n+};\n+\n constexpr bool\n-test_swap()\n+test_swap_obj()\n {\n   std::expected<int, int> e1(1), e2(2);\n   std::expected<int, int> e3(std::unexpect, 3), e4(std::unexpect, 4);\n@@ -27,6 +37,52 @@ test_swap()\n   VERIFY( e3.error() == 4 );\n   VERIFY( e4.error() == 3 );\n \n+  std::expected<int, NonTrivial> e5(1), e6(2);\n+  std::expected<int, NonTrivial> e7(std::unexpect, 3), e8(std::unexpect, 4);\n+\n+  swap(e5, e6);\n+  VERIFY( e5.value() == 2 );\n+  VERIFY( e6.value() == 1 );\n+  swap(e5, e7);\n+  VERIFY( ! e5.has_value() );\n+  VERIFY( e5.error() == 3 );\n+  VERIFY( e7.value() == 2 );\n+  swap(e5, e7);\n+  VERIFY( ! e7.has_value() );\n+  VERIFY( e5.value() == 2 );\n+  VERIFY( e7.error() == 3 );\n+  swap(e7, e8);\n+  VERIFY( ! e7.has_value() );\n+  VERIFY( ! e8.has_value() );\n+  VERIFY( e7.error() == 4 );\n+  VERIFY( e8.error() == 3 );\n+\n+  std::expected<NonTrivial, int> e9(1), e10(2);\n+  std::expected<NonTrivial, int> e11(std::unexpect, 3), e12(std::unexpect, 4);\n+\n+  swap(e9, e10);\n+  VERIFY( e9.value() == 2 );\n+  VERIFY( e10.value() == 1 );\n+  swap(e9, e11);\n+  VERIFY( ! e9.has_value() );\n+  VERIFY( e9.error() == 3 );\n+  VERIFY( e11.value() == 2 );\n+  swap(e9, e11);\n+  VERIFY( ! e11.has_value() );\n+  VERIFY( e9.value() == 2 );\n+  VERIFY( e11.error() == 3 );\n+  swap(e11, e12);\n+  VERIFY( ! e11.has_value() );\n+  VERIFY( ! e12.has_value() );\n+  VERIFY( e11.error() == 4 );\n+  VERIFY( e12.error() == 3 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_swap_void()\n+{\n   std::expected<void, int> v1, v2;\n   std::expected<void, int> v3(std::unexpect, 3), v4(std::unexpect, 4);\n \n@@ -47,11 +103,41 @@ test_swap()\n   VERIFY( v3.error() == 4 );\n   VERIFY( v4.error() == 3 );\n \n+  std::expected<void, NonTrivial> v5, v6;\n+  std::expected<void, NonTrivial> v7(std::unexpect, 3), v8(std::unexpect, 4);\n+\n+  swap(v5, v6);\n+  VERIFY( v5.has_value() );\n+  VERIFY( v6.has_value() );\n+  swap(v5, v7);\n+  VERIFY( ! v5.has_value() );\n+  VERIFY( v5.error() == 3 );\n+  VERIFY( v7.has_value() );\n+  swap(v5, v7);\n+  VERIFY( ! v7.has_value() );\n+  VERIFY( v5.has_value() );\n+  VERIFY( v7.error() == 3 );\n+  swap(v7, v8);\n+  VERIFY( ! v7.has_value() );\n+  VERIFY( ! v8.has_value() );\n+  VERIFY( v7.error() == 4 );\n+  VERIFY( v8.error() == 3 );\n+\n   return true;\n }\n \n+static_assert( std::is_swappable_v<std::expected<int, int>> );\n+static_assert( std::is_swappable_v<std::expected<void, int>> );\n+\n+struct A { A& operator=(A&&) = delete; };\n+static_assert( ! std::is_swappable_v<std::expected<A, int>> );\n+static_assert( ! std::is_swappable_v<std::expected<int, A>> );\n+static_assert( ! std::is_swappable_v<std::expected<void, A>> );\n+\n int main()\n {\n-  static_assert( test_swap() );\n-  test_swap();\n+  static_assert( test_swap_obj() );\n+  test_swap_obj();\n+  static_assert( test_swap_void() );\n+  test_swap_void();\n }"}, {"sha": "b0439614a27077405ce45a8511df07e0935af06e", "filename": "libstdc++-v3/testsuite/20_util/expected/synopsis.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -6,7 +6,7 @@\n \n #ifndef __cpp_lib_expected\n # error \"Feature-test macro for expected missing in <expected>\"\n-#elif __cpp_lib_expected != 202202L\n+#elif __cpp_lib_expected != 202211L\n # error \"Feature-test macro for expected has wrong value in <expected>\"\n #endif\n "}, {"sha": "050f8e3e81f7b50c16ac49260a3ed1c7e526e614", "filename": "libstdc++-v3/testsuite/20_util/expected/unexpected.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Funexpected.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Funexpected.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Funexpected.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -73,6 +73,10 @@ test()\n   return true;\n }\n \n+static_assert( std::is_swappable_v<std::unexpected<int>> );\n+struct A { A& operator=(A&&) = delete; };\n+static_assert( ! std::is_swappable_v<std::unexpected<A>> );\n+\n int main()\n {\n   static_assert( test() );"}, {"sha": "98fccf73dc100e58df96407b4322f9b86c9c1f27", "filename": "libstdc++-v3/testsuite/20_util/expected/version.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -5,6 +5,6 @@\n \n #ifndef __cpp_lib_expected\n # error \"Feature-test macro for expected missing in <version>\"\n-#elif __cpp_lib_expected != 202202L\n+#elif __cpp_lib_expected != 202211L\n # error \"Feature-test macro for expected has wrong value in <version>\"\n #endif"}, {"sha": "af4d29443f5556a4af6baf0c959f762a9d42d72b", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/outermost.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Foutermost.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Foutermost.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Foutermost.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -49,6 +49,14 @@ struct nested_alloc : A\n   template<typename U>\n     nested_alloc(nested_alloc<U>) { }\n \n+  // Need to customize rebind, otherwise nested_alloc<alloc<T>> gets rebound\n+  // to nested_alloc<U>.\n+  template<typename U>\n+    struct rebind\n+    {\n+      using other = typename std::allocator_traits<A>::template rebind_alloc<U>;\n+    };\n+\n   A& outer_allocator() { return *this; }\n \n   template<typename U, typename... Args>"}, {"sha": "c890d2ba94d7d84546b42ac9543bea9f6024bbb3", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/cons/self_move.cc", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcons%2Fself_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcons%2Fself_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcons%2Fself_move.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do run { target c++11 } }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_self_move()\n+{\n+  std::shared_ptr<int> sp(new int(66));\n+  std::weak_ptr<int> wp(sp);\n+  wp = std::move(wp); // PR libstdc++/108118\n+  std::shared_ptr<int> sp2(wp);\n+  VERIFY(sp2 == sp);\n+}\n+\n+int main()\n+{\n+  test_self_move();\n+}"}, {"sha": "195d32931c125026e079c0a2642ab0e9f446507b", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/48101_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2F48101_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2F48101_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2F48101_neg.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -28,3 +28,4 @@ test01()\n // { dg-error \"non-const, non-volatile value_type\" \"\" { target *-*-* } 0 }\n // { dg-prune-output \"std::allocator<.* has no member named \" }\n // { dg-prune-output \"must have the same value_type as its allocator\" }\n+// { dg-prune-output \"rebind_alloc\" }"}, {"sha": "70babc682ae42d86d9bebf604259b6f9ee49bac1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F48101_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F48101_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F48101_neg.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -34,3 +34,4 @@ test01()\n // { dg-prune-output \"use of deleted function\" }\n // { dg-prune-output \"must have the same value_type as its allocator\" }\n // { dg-prune-output \"no match for call\" }\n+// { dg-prune-output \"rebind_alloc\" }"}, {"sha": "30225f3d6e1713ee57a0189730ba0130840a1d4d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F48101_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F48101_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F48101_neg.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -34,3 +34,4 @@ test01()\n // { dg-prune-output \"use of deleted function\" }\n // { dg-prune-output \"must have the same value_type as its allocator\" }\n // { dg-prune-output \"no match for call\" }\n+// { dg-prune-output \"rebind_alloc\" }"}, {"sha": "ea80bb277c1f49190ae21b64e738428066eba1e0", "filename": "libstdc++-v3/testsuite/23_containers/vector/52591.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2F52591.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2F52591.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2F52591.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -60,7 +60,7 @@ void test02()\n template<typename T>\n struct A2 : std::allocator<T>\n {\n-  template<typename U> struct rebind { typedef A1<U> other; };\n+  template<typename U> struct rebind { typedef A2<U> other; };\n \n   A2() = default;\n   template<typename U> A2(const A2<U>&) { }"}, {"sha": "27616f5987ec4f51eda04aeafccbe80efdb56868", "filename": "libstdc++-v3/testsuite/util/testsuite_abi.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b5dc738b08b6e4af74b3ab1bea08db21ba7893/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc?ref=e9b5dc738b08b6e4af74b3ab1bea08db21ba7893", "patch": "@@ -230,6 +230,7 @@ check_version(symbol& test, bool added)\n       known_versions.push_back(\"CXXABI_1.3.11\");\n       known_versions.push_back(\"CXXABI_1.3.12\");\n       known_versions.push_back(\"CXXABI_1.3.13\");\n+      known_versions.push_back(\"CXXABI_1.3.14\");\n       known_versions.push_back(\"CXXABI_IEEE128_1.3.13\");\n       known_versions.push_back(\"CXXABI_TM_1\");\n       known_versions.push_back(\"CXXABI_FLOAT128\");\n@@ -251,7 +252,7 @@ check_version(symbol& test, bool added)\n       bool latestp = (test.version_name == \"GLIBCXX_3.4.31\"\n \t  // XXX remove next line when baselines have been regenerated.\n \t\t     || test.version_name == \"GLIBCXX_IEEE128_3.4.30\"\n-\t\t     || test.version_name == \"CXXABI_1.3.13\"\n+\t\t     || test.version_name == \"CXXABI_1.3.14\"\n \t\t     || test.version_name == \"CXXABI_FLOAT128\"\n \t\t     || test.version_name == \"CXXABI_TM_1\");\n       if (added && !latestp)"}]}