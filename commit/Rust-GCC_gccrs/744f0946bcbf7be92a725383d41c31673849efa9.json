{"sha": "744f0946bcbf7be92a725383d41c31673849efa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ0ZjA5NDZiY2JmN2JlOTJhNzI1MzgzZDQxYzMxNjczODQ5ZWZhOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-01-26T01:26:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-26T01:26:48Z"}, "message": "re PR tree-optimization/26854 (Inordinate compile times on large routines)\n\n\tPR tree-optimization/26854\n\t* c-decl.c (struct c_scope): Add field has_jump_unsafe_decl.\n\t(decl_jump_unsafe): Move higher in file, with no other change.\n\t(bind): Set has_jump_unsafe_decl if appropriate.\n\t(update_label_decls): Test has_jump_unsafe_decl to avoid loop.\n\t(check_earlier_gotos): Likewise.\n\t(c_check_switch_jump_warnings): Likewise.\n\nFrom-SVN: r169267", "tree": {"sha": "40f04bab603217a17801c186064a864353aa2c57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40f04bab603217a17801c186064a864353aa2c57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/744f0946bcbf7be92a725383d41c31673849efa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744f0946bcbf7be92a725383d41c31673849efa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744f0946bcbf7be92a725383d41c31673849efa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744f0946bcbf7be92a725383d41c31673849efa9/comments", "author": null, "committer": null, "parents": [{"sha": "70187f017bf392594f209a7434b82518c34ff00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70187f017bf392594f209a7434b82518c34ff00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70187f017bf392594f209a7434b82518c34ff00b"}], "stats": {"total": 129, "additions": 84, "deletions": 45}, "files": [{"sha": "31838c69e73037cd30622d0f6685ea3e5480d3fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744f0946bcbf7be92a725383d41c31673849efa9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744f0946bcbf7be92a725383d41c31673849efa9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=744f0946bcbf7be92a725383d41c31673849efa9", "patch": "@@ -1,3 +1,13 @@\n+2011-01-25  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR tree-optimization/26854\n+\t* c-decl.c (struct c_scope): Add field has_jump_unsafe_decl.\n+\t(decl_jump_unsafe): Move higher in file, with no other change.\n+\t(bind): Set has_jump_unsafe_decl if appropriate.\n+\t(update_label_decls): Test has_jump_unsafe_decl to avoid loop.\n+\t(check_earlier_gotos): Likewise.\n+\t(c_check_switch_jump_warnings): Likewise.\n+\n 2011-01-25  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/invoke.texi (Warning Options): Add missing hyphen."}, {"sha": "b438b066c831c5247087f233a709137641c636c2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744f0946bcbf7be92a725383d41c31673849efa9/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744f0946bcbf7be92a725383d41c31673849efa9/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=744f0946bcbf7be92a725383d41c31673849efa9", "patch": "@@ -404,6 +404,13 @@ struct GTY((chain_next (\"%h.outer\"))) c_scope {\n      up searching for labels when popping scopes, particularly since\n      labels are normally only found at function scope.  */\n   BOOL_BITFIELD has_label_bindings : 1;\n+\n+  /* True if we should issue a warning if a goto statement crosses any\n+     of the bindings.  We still need to check the list of bindings to\n+     find the specific ones we need to warn about.  This is true if\n+     decl_jump_unsafe would return true for any of the bindings.  This\n+     is used to avoid looping over all the bindings unnecessarily.  */\n+  BOOL_BITFIELD has_jump_unsafe_decl : 1;\n };\n \n /* The scope currently in effect.  */\n@@ -554,6 +561,31 @@ add_stmt (tree t)\n   return t;\n }\n \f\n+/* Return true if we will want to say something if a goto statement\n+   crosses DECL.  */\n+\n+static bool\n+decl_jump_unsafe (tree decl)\n+{\n+  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n+    return false;\n+\n+  /* Always warn about crossing variably modified types.  */\n+  if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == TYPE_DECL)\n+      && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+    return true;\n+\n+  /* Otherwise, only warn if -Wgoto-misses-init and this is an\n+     initialized automatic decl.  */\n+  if (warn_jump_misses_init\n+      && TREE_CODE (decl) == VAR_DECL\n+      && !TREE_STATIC (decl)\n+      && DECL_INITIAL (decl) != NULL_TREE)\n+    return true;\n+\n+  return false;\n+}\n+\f\n \n void\n c_print_identifier (FILE *file, tree node, int indent)\n@@ -602,6 +634,9 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible,\n   b->prev = scope->bindings;\n   scope->bindings = b;\n \n+  if (decl_jump_unsafe (decl))\n+    scope->has_jump_unsafe_decl = 1;\n+\n   if (!name)\n     return;\n \n@@ -758,31 +793,6 @@ set_spot_bindings (struct c_spot_bindings *p, bool defining)\n   p->left_stmt_expr = false;\n }\n \n-/* Return true if we will want to say something if a goto statement\n-   crosses DECL.  */\n-\n-static bool\n-decl_jump_unsafe (tree decl)\n-{\n-  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n-    return false;\n-\n-  /* Always warn about crossing variably modified types.  */\n-  if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == TYPE_DECL)\n-      && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n-    return true;\n-\n-  /* Otherwise, only warn if -Wgoto-misses-init and this is an\n-     initialized automatic decl.  */\n-  if (warn_jump_misses_init\n-      && TREE_CODE (decl) == VAR_DECL\n-      && !TREE_STATIC (decl)\n-      && DECL_INITIAL (decl) != NULL_TREE)\n-    return true;\n-\n-  return false;\n-}\n-\n /* Update spot bindings P as we pop out of SCOPE.  Return true if we\n    should push decls for a label.  */\n \n@@ -969,6 +979,7 @@ update_label_decls (struct c_scope *scope)\n \t    {\n \t      struct c_label_vars *label_vars;\n \t      struct c_binding *b1;\n+\t      bool hjud;\n \t      unsigned int ix;\n \t      struct c_goto_bindings *g;\n \n@@ -977,18 +988,26 @@ update_label_decls (struct c_scope *scope)\n \t      label_vars = b->u.label;\n \n \t      b1 = label_vars->label_bindings.bindings_in_scope;\n+\t      if (label_vars->label_bindings.scope == NULL)\n+\t\thjud = false;\n+\t      else\n+\t\thjud = label_vars->label_bindings.scope->has_jump_unsafe_decl;\n \t      if (update_spot_bindings (scope, &label_vars->label_bindings))\n \t\t{\n \t\t  /* This label is defined in this scope.  */\n-\t\t  for (; b1 != NULL;  b1 = b1->prev)\n+\t\t  if (hjud)\n \t\t    {\n-\t\t      /* A goto from later in the function to this\n-\t\t\t label will never see the initialization of\n-\t\t\t B1, if any.  Save it to issue a warning if\n-\t\t\t needed.  */\n-\t\t      if (decl_jump_unsafe (b1->decl))\n-\t\t\tVEC_safe_push (tree, gc, label_vars->decls_in_scope,\n-\t\t\t\t       b1->decl);\n+\t\t      for (; b1 != NULL; b1 = b1->prev)\n+\t\t\t{\n+\t\t\t  /* A goto from later in the function to this\n+\t\t\t     label will never see the initialization\n+\t\t\t     of B1, if any.  Save it to issue a\n+\t\t\t     warning if needed.  */\n+\t\t\t  if (decl_jump_unsafe (b1->decl))\n+\t\t\t    VEC_safe_push (tree, gc,\n+\t\t\t\t\t   label_vars->decls_in_scope,\n+\t\t\t\t\t   b1->decl);\n+\t\t\t}\n \t\t    }\n \t\t}\n \n@@ -3165,12 +3184,15 @@ check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n       /* We have a goto to this label.  The goto is going forward.  In\n \t g->scope, the goto is going to skip any binding which was\n \t defined after g->bindings_in_scope.  */\n-      for (b = g->goto_bindings.scope->bindings;\n-\t   b != g->goto_bindings.bindings_in_scope;\n-\t   b = b->prev)\n+      if (g->goto_bindings.scope->has_jump_unsafe_decl)\n \t{\n-\t  if (decl_jump_unsafe (b->decl))\n-\t    warn_about_goto (g->loc, label, b->decl);\n+\t  for (b = g->goto_bindings.scope->bindings;\n+\t       b != g->goto_bindings.bindings_in_scope;\n+\t       b = b->prev)\n+\t    {\n+\t      if (decl_jump_unsafe (b->decl))\n+\t\twarn_about_goto (g->loc, label, b->decl);\n+\t    }\n \t}\n \n       /* We also need to warn about decls defined in any scopes\n@@ -3180,14 +3202,17 @@ check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n \t   scope = scope->outer)\n \t{\n \t  gcc_assert (scope != NULL);\n-\t  if (scope == label_vars->label_bindings.scope)\n-\t    b = label_vars->label_bindings.bindings_in_scope;\n-\t  else\n-\t    b = scope->bindings;\n-\t  for (; b != NULL; b = b->prev)\n+\t  if (scope->has_jump_unsafe_decl)\n \t    {\n-\t      if (decl_jump_unsafe (b->decl))\n-\t\twarn_about_goto (g->loc, label, b->decl);\n+\t      if (scope == label_vars->label_bindings.scope)\n+\t\tb = label_vars->label_bindings.bindings_in_scope;\n+\t      else\n+\t\tb = scope->bindings;\n+\t      for (; b != NULL; b = b->prev)\n+\t\t{\n+\t\t  if (decl_jump_unsafe (b->decl))\n+\t\t    warn_about_goto (g->loc, label, b->decl);\n+\t\t}\n \t    }\n \t}\n \n@@ -3303,6 +3328,10 @@ c_check_switch_jump_warnings (struct c_spot_bindings *switch_bindings,\n       struct c_binding *b;\n \n       gcc_assert (scope != NULL);\n+\n+      if (!scope->has_jump_unsafe_decl)\n+\tcontinue;\n+\n       for (b = scope->bindings; b != NULL; b = b->prev)\n \t{\n \t  if (decl_jump_unsafe (b->decl))"}]}