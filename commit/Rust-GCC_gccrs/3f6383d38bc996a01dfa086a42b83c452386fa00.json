{"sha": "3f6383d38bc996a01dfa086a42b83c452386fa00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y2MzgzZDM4YmM5OTZhMDFkZmEwODZhNDJiODNjNDUyMzg2ZmEwMA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2008-05-30T18:21:31Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2008-05-30T18:21:31Z"}, "message": "configure.ac (arm*-*-linux-gnueabi): Don't disable building of libobjc for ARM EABI Linux.\n\n    * configure.ac (arm*-*-linux-gnueabi): Don't disable building\n    of libobjc for ARM EABI Linux.\n    * configure: Regenerate.\n\n    libobjc/\n    * exception.c (__objc_exception_class): Initialise as constant\n    array for ARM EABI. Change macro to static const for non-ARM EABI.\n    (ObjcException): Add note about structure layout. Remove landingPad\n    and handlerSwitchValue for ARM EABI.\n    (get_ttype_entry): Add __ARM_EABI_UNWINDER__ version\n    of function.\n    (CONTINUE_UNWINDING): Define for ARM EABI/otherwise cases.\n    (PERSONALITY_FUNCTION): Use ARM EABI-specific arguments, and add\n    ARM EABI unwinding support.\n    (objc_exception_throw): Use memcpy to initialise exception class.\n\nFrom-SVN: r136215", "tree": {"sha": "c1bdf9cb0cdd9e02e16dc55edb6e15883ce74f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1bdf9cb0cdd9e02e16dc55edb6e15883ce74f99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f6383d38bc996a01dfa086a42b83c452386fa00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6383d38bc996a01dfa086a42b83c452386fa00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f6383d38bc996a01dfa086a42b83c452386fa00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6383d38bc996a01dfa086a42b83c452386fa00/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d750887f5f4273e10625e13d1bac1db9aeef849e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d750887f5f4273e10625e13d1bac1db9aeef849e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d750887f5f4273e10625e13d1bac1db9aeef849e"}], "stats": {"total": 174, "additions": 152, "deletions": 22}, "files": [{"sha": "0926f4e71c3cc124aef83d5df445a476b217b982", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6383d38bc996a01dfa086a42b83c452386fa00/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6383d38bc996a01dfa086a42b83c452386fa00/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=3f6383d38bc996a01dfa086a42b83c452386fa00", "patch": "@@ -1,3 +1,8 @@\n+2008-05-30  Julian Brown  <julian@codesourcery.com>\n+\n+\t* configure.ac (arm*-*-linux-gnueabi): Don't disable building\n+\tof libobjc for ARM EABI Linux.\n+\t* configure: Regenerate.\n \n 2008-05-18 Xinliang David Li   <davidxl@google.com>\n "}, {"sha": "213befb575112dfcefa721e7fc5f6f6f24f49d36", "filename": "configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6383d38bc996a01dfa086a42b83c452386fa00/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6383d38bc996a01dfa086a42b83c452386fa00/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=3f6383d38bc996a01dfa086a42b83c452386fa00", "patch": "@@ -2309,7 +2309,6 @@ case \"${target}\" in\n     ;;\n   arm*-*-linux-gnueabi)\n     noconfigdirs=\"$noconfigdirs target-qthreads\"\n-    noconfigdirs=\"$noconfigdirs target-libobjc\"\n     case ${with_newlib} in\n       no) noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n     esac"}, {"sha": "3b443e5a5095acba914b15c62b65e8a7e16c2235", "filename": "configure.ac", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6383d38bc996a01dfa086a42b83c452386fa00/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6383d38bc996a01dfa086a42b83c452386fa00/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=3f6383d38bc996a01dfa086a42b83c452386fa00", "patch": "@@ -563,7 +563,6 @@ case \"${target}\" in\n     ;;\n   arm*-*-linux-gnueabi)\n     noconfigdirs=\"$noconfigdirs target-qthreads\"\n-    noconfigdirs=\"$noconfigdirs target-libobjc\"\n     case ${with_newlib} in\n       no) noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n     esac"}, {"sha": "fa0e059e089cf1b8d161a5837a710d89a3ef5508", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6383d38bc996a01dfa086a42b83c452386fa00/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6383d38bc996a01dfa086a42b83c452386fa00/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=3f6383d38bc996a01dfa086a42b83c452386fa00", "patch": "@@ -1,3 +1,16 @@\n+2008-05-30  Julian Brown  <julian@codesourcery.com>\n+\n+\t* exception.c (__objc_exception_class): Initialise as constant\n+\tarray for ARM EABI. Change macro to static const for non-ARM EABI.\n+\t(ObjcException): Add note about structure layout. Remove landingPad\n+\tand handlerSwitchValue for ARM EABI.\n+\t(get_ttype_entry): Add __ARM_EABI_UNWINDER__ version\n+\tof function.\n+\t(CONTINUE_UNWINDING): Define for ARM EABI/otherwise cases.\n+\t(PERSONALITY_FUNCTION): Use ARM EABI-specific arguments, and add\n+\tARM EABI unwinding support.\n+\t(objc_exception_throw): Use memcpy to initialise exception class.\n+\n 2008-05-25  Alan Modra  <amodra@bigpond.net.au>\n \n \t* encoding.c (strip_array_types): Rename from get_inner_array_type."}, {"sha": "1a6b9dab4d18c65c8a5bad4c00ef244d8ee738c6", "filename": "libobjc/exception.c", "status": "modified", "additions": 134, "deletions": 20, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6383d38bc996a01dfa086a42b83c452386fa00/libobjc%2Fexception.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6383d38bc996a01dfa086a42b83c452386fa00/libobjc%2Fexception.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fexception.c?ref=3f6383d38bc996a01dfa086a42b83c452386fa00", "patch": "@@ -31,16 +31,25 @@ Boston, MA 02110-1301, USA.  */\n #include \"unwind-pe.h\"\n \n \f\n+#ifdef __ARM_EABI_UNWINDER__\n+\n+const _Unwind_Exception_Class __objc_exception_class\n+  = {'G', 'N', 'U', 'C', 'O', 'B', 'J', 'C'};\n+  \n+#else\n+\n /* This is the exception class we report -- \"GNUCOBJC\".  */\n-#define __objc_exception_class\t\t\t\\\n-  ((((((((_Unwind_Exception_Class) 'G'\t\t\\\n-         << 8 | (_Unwind_Exception_Class) 'N')\t\\\n-        << 8 | (_Unwind_Exception_Class) 'U')\t\\\n-       << 8 | (_Unwind_Exception_Class) 'C')\t\\\n-      << 8 | (_Unwind_Exception_Class) 'O')\t\\\n-     << 8 | (_Unwind_Exception_Class) 'B')\t\\\n-    << 8 | (_Unwind_Exception_Class) 'J')\t\\\n-   << 8 | (_Unwind_Exception_Class) 'C')\n+static const _Unwind_Exception_Class __objc_exception_class\n+  = ((((((((_Unwind_Exception_Class) 'G'\n+            << 8 | (_Unwind_Exception_Class) 'N')\n+           << 8 | (_Unwind_Exception_Class) 'U')\n+          << 8 | (_Unwind_Exception_Class) 'C')\n+         << 8 | (_Unwind_Exception_Class) 'O')\n+        << 8 | (_Unwind_Exception_Class) 'B')\n+       << 8 | (_Unwind_Exception_Class) 'J')\n+      << 8 | (_Unwind_Exception_Class) 'C');\n+\n+#endif\n \n /* This is the object that is passed around by the Objective C runtime\n    to represent the exception in flight.  */\n@@ -50,12 +59,18 @@ struct ObjcException\n   /* This bit is needed in order to interact with the unwind runtime.  */\n   struct _Unwind_Exception base;\n \n-  /* The actual object we want to throw.  */\n+  /* The actual object we want to throw. Note: must come immediately after\n+     unwind header.  */\n   id value;\n \n+#ifdef __ARM_EABI_UNWINDER__\n+  /* Note: we use the barrier cache defined in the unwind control block for\n+     ARM EABI.  */\n+#else\n   /* Cache some internal unwind data between phase 1 and phase 2.  */\n   _Unwind_Ptr landingPad;\n   int handlerSwitchValue;\n+#endif\n };\n \n \f\n@@ -106,6 +121,24 @@ parse_lsda_header (struct _Unwind_Context *context, const unsigned char *p,\n   return p;\n }\n \n+#ifdef __ARM_EABI_UNWINDER__\n+\n+static Class\n+get_ttype_entry (struct lsda_header_info *info, _uleb128_t i)\n+{\n+  _Unwind_Ptr ptr;\n+  \n+  ptr = (_Unwind_Ptr) (info->TType - (i * 4));\n+  ptr = _Unwind_decode_target2 (ptr);\n+  \n+  if (ptr)\n+    return objc_get_class ((const char *) ptr);\n+  else\n+    return 0;\n+}\n+\n+#else\n+\n static Class\n get_ttype_entry (struct lsda_header_info *info, _Unwind_Word i)\n {\n@@ -122,6 +155,8 @@ get_ttype_entry (struct lsda_header_info *info, _Unwind_Word i)\n     return 0;\n }\n \n+#endif\n+\n /* Like unto the method of the same name on Object, but takes an id.  */\n /* ??? Does this bork the meta-type system?  Can/should we look up an\n    isKindOf method on the id?  */\n@@ -150,12 +185,32 @@ isKindOf (id value, Class target)\n #define PERSONALITY_FUNCTION\t__gnu_objc_personality_v0\n #endif\n \n+#ifdef __ARM_EABI_UNWINDER__\n+\n+#define CONTINUE_UNWINDING \\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (__gnu_unwind_frame(ue_header, context) != _URC_OK)\t\\\n+\treturn _URC_FAILURE;\t\t\t\t\t\\\n+      return _URC_CONTINUE_UNWIND;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+_Unwind_Reason_Code\n+PERSONALITY_FUNCTION (_Unwind_State state,\n+\t\t      struct _Unwind_Exception *ue_header,\n+\t\t      struct _Unwind_Context *context)\n+#else\n+\n+#define CONTINUE_UNWINDING return _URC_CONTINUE_UNWIND\n+\n _Unwind_Reason_Code\n PERSONALITY_FUNCTION (int version,\n \t\t      _Unwind_Action actions,\n \t\t      _Unwind_Exception_Class exception_class,\n \t\t      struct _Unwind_Exception *ue_header,\n \t\t      struct _Unwind_Context *context)\n+#endif\n {\n   struct ObjcException *xh = (struct ObjcException *) ue_header;\n \n@@ -165,19 +220,65 @@ PERSONALITY_FUNCTION (int version,\n   const unsigned char *p;\n   _Unwind_Ptr landing_pad, ip;\n   int handler_switch_value;\n-  int saw_cleanup = 0, saw_handler;\n+  int saw_cleanup = 0, saw_handler, foreign_exception;\n   void *return_object;\n+  int ip_before_insn = 0;\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+  _Unwind_Action actions;\n+  \n+  switch (state & _US_ACTION_MASK)\n+    {\n+    case _US_VIRTUAL_UNWIND_FRAME:\n+      actions = _UA_SEARCH_PHASE;\n+      break;\n+\n+    case _US_UNWIND_FRAME_STARTING:\n+      actions = _UA_CLEANUP_PHASE;\n+      if (!(state & _US_FORCE_UNWIND)\n+\t  && ue_header->barrier_cache.sp == _Unwind_GetGR (context, 13))\n+\tactions |= _UA_HANDLER_FRAME;\n+      break;\n+\n+    case _US_UNWIND_FRAME_RESUME:\n+      CONTINUE_UNWINDING;\n+      break;\n+\n+    default:\n+      abort();\n+    }\n+  actions |= state & _US_FORCE_UNWIND;\n+\n+  /* TODO: Foreign exceptions need some attention (e.g. rethrowing doesn't\n+     work).  */\n+  foreign_exception = 0;\n \n+  /* The dwarf unwinder assumes the context structure holds things like the\n+     function and LSDA pointers.  The ARM implementation caches these in\n+     the exception header (UCB).  To avoid rewriting everything we make the\n+     virtual IP register point at the UCB.  */\n+  ip = (_Unwind_Ptr) ue_header;\n+  _Unwind_SetGR (context, 12, ip);\n+\n+#else  /* !__ARM_EABI_UNWINDER.  */\n   /* Interface version check.  */\n   if (version != 1)\n     return _URC_FATAL_PHASE1_ERROR;\n+  \n+  foreign_exception = (exception_class != __objc_exception_class);\n+#endif\n \n   /* Shortcut for phase 2 found handler for domestic exception.  */\n   if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n-      && exception_class == __objc_exception_class)\n+      && !foreign_exception)\n     {\n+#ifdef __ARM_EABI_UNWINDER__\n+      handler_switch_value = (int) ue_header->barrier_cache.bitpattern[1];\n+      landing_pad = (_Unwind_Ptr) ue_header->barrier_cache.bitpattern[3];\n+#else\n       handler_switch_value = xh->handlerSwitchValue;\n       landing_pad = xh->landingPad;\n+#endif\n       goto install_context;\n     }\n \n@@ -186,12 +287,18 @@ PERSONALITY_FUNCTION (int version,\n \n   /* If no LSDA, then there are no handlers or cleanups.  */\n   if (! language_specific_data)\n-    return _URC_CONTINUE_UNWIND;\n+    CONTINUE_UNWINDING;\n \n   /* Parse the LSDA header.  */\n   p = parse_lsda_header (context, language_specific_data, &info);\n   info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);\n+#ifdef HAVE_GETIPINFO\n+  ip = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n   ip = _Unwind_GetIP (context) - 1;\n+#endif\n+  if (!ip_before_insn)\n+    --ip;\n   landing_pad = 0;\n   action_record = 0;\n   handler_switch_value = 0;\n@@ -250,7 +357,7 @@ PERSONALITY_FUNCTION (int version,\n   /* If ip is not present in the table, C++ would call terminate.  */\n   /* ??? As with Java, it's perhaps better to tweek the LSDA to\n      that no-action is mapped to no-entry.  */\n-  return _URC_CONTINUE_UNWIND;\n+  CONTINUE_UNWINDING;\n \n  found_something:\n   saw_cleanup = 0;\n@@ -287,8 +394,7 @@ PERSONALITY_FUNCTION (int version,\n \n \t  /* During forced unwinding, we only run cleanups.  With a\n \t     foreign exception class, we have no class info to match.  */\n-\t  else if ((actions & _UA_FORCE_UNWIND)\n-\t\t   || exception_class != __objc_exception_class)\n+\t  else if ((actions & _UA_FORCE_UNWIND) || foreign_exception)\n \t    ;\n \n \t  else if (ar_filter > 0)\n@@ -318,18 +424,24 @@ PERSONALITY_FUNCTION (int version,\n     }\n \n   if (! saw_handler && ! saw_cleanup)\n-    return _URC_CONTINUE_UNWIND;\n+    CONTINUE_UNWINDING;\n \n   if (actions & _UA_SEARCH_PHASE)\n     {\n       if (!saw_handler)\n-\treturn _URC_CONTINUE_UNWIND;\n+\tCONTINUE_UNWINDING;\n \n       /* For domestic exceptions, we cache data from phase 1 for phase 2.  */\n-      if (exception_class == __objc_exception_class)\n+      if (!foreign_exception)\n         {\n+#ifdef __ARM_EABI_UNWINDER__\n+\t  ue_header->barrier_cache.sp = _Unwind_GetGR (context, 13);\n+\t  ue_header->barrier_cache.bitpattern[1] = (_uw) handler_switch_value;\n+\t  ue_header->barrier_cache.bitpattern[3] = (_uw) landing_pad;\n+#else\n           xh->handlerSwitchValue = handler_switch_value;\n           xh->landingPad = landing_pad;\n+#endif\n \t}\n       return _URC_HANDLER_FOUND;\n     }\n@@ -361,7 +473,9 @@ void\n objc_exception_throw (id value)\n {\n   struct ObjcException *header = calloc (1, sizeof (*header));\n-  header->base.exception_class = __objc_exception_class;\n+  \n+  memcpy (&header->base.exception_class, &__objc_exception_class,\n+\t  sizeof (__objc_exception_class));\n   header->base.exception_cleanup = __objc_exception_cleanup;\n   header->value = value;\n "}]}