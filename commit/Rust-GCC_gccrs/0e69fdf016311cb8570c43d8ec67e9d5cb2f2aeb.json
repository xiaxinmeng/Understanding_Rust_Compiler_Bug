{"sha": "0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2OWZkZjAxNjMxMWNiODU3MGM0M2Q4ZWM2N2U5ZDVjYjJmMmFlYg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-07-19T01:36:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-07-19T01:36:50Z"}, "message": "DR 1170 PR c++/51213\n\n\tDR 1170\n\tPR c++/51213\n\t* semantics.c (perform_access_checks): Add complain parm, return bool.\n\t(perform_deferred_access_checks): Likewise.\n\t(perform_or_defer_access_check): Likewise.\n\t(speculative_access_check): Remove.\n\t* call.c (enforce_access): Add complain parm, return bool.\n\t* decl.c, friend.c, class.c, init.c, parser.c: Adjust callers.\n\t* search.c: Adjust callers.\n\t* cp-tree.h (TINFO_RECHECK_ACCESS_P): New macro.\n\t(FNDECL_RECHECK_ACCESS_P): New macro.\n\t* method.c (synthesized_method_walk): Stop deferring access checks.\n\t* pt.c (recheck_decl_substitution): New.\n\t(instantiate_template_1): Set and check FNDECL_RECHECK_ACCESS_P.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r189639", "tree": {"sha": "d39c6d48e17f0d85751becc5f496f94737ead16b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d39c6d48e17f0d85751becc5f496f94737ead16b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/comments", "author": null, "committer": null, "parents": [{"sha": "1936ace05cdfab4a25242e03c2d70921f00576cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1936ace05cdfab4a25242e03c2d70921f00576cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1936ace05cdfab4a25242e03c2d70921f00576cb"}], "stats": {"total": 403, "additions": 278, "deletions": 125}, "files": [{"sha": "5cc6ccd2f8ec39ddfaeb1cf760e51f82df63b495", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1,3 +1,21 @@\n+2012-07-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tDR 1170\n+\tPR c++/51213\n+\t* semantics.c (perform_access_checks): Add complain parm, return bool.\n+\t(perform_deferred_access_checks): Likewise.\n+\t(perform_or_defer_access_check): Likewise.\n+\t(speculative_access_check): Remove.\n+\t* call.c (enforce_access): Add complain parm, return bool.\n+\t* decl.c, friend.c, class.c, init.c, parser.c: Adjust callers.\n+\t* search.c: Adjust callers.\n+\t* cp-tree.h (TINFO_RECHECK_ACCESS_P): New macro.\n+\t(FNDECL_RECHECK_ACCESS_P): New macro.\n+\t* method.c (synthesized_method_walk): Stop deferring access checks.\n+\t* pt.c (recheck_decl_substitution): New.\n+\t(instantiate_template_1): Set and check FNDECL_RECHECK_ACCESS_P.\n+\n 2012-07-18  Jason Merrill  <jason@redhat.com>\n \n \t* method.c (process_subob_fn): Make sure no_implicit_p is non-null"}, {"sha": "5b3245ffa4e41c709542cadb5cbd81b11645a851", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -5515,7 +5515,8 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       /* If the FN is a member function, make sure that it is\n \t accessible.  */\n       if (BASELINK_P (fns))\n-\tperform_or_defer_access_check (BASELINK_BINFO (fns), fn, fn);\n+\tperform_or_defer_access_check (BASELINK_BINFO (fns), fn, fn,\n+\t\t\t\t       complain);\n \n       /* Core issue 901: It's ok to new a type with deleted delete.  */\n       if (DECL_DELETED_FN (fn) && alloc_fn)\n@@ -5573,19 +5574,23 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n    the declaration to use in the error diagnostic.  */\n \n bool\n-enforce_access (tree basetype_path, tree decl, tree diag_decl)\n+enforce_access (tree basetype_path, tree decl, tree diag_decl,\n+\t\ttsubst_flags_t complain)\n {\n   gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n \n   if (!accessible_p (basetype_path, decl, true))\n     {\n-      if (TREE_PRIVATE (decl))\n-\terror (\"%q+#D is private\", diag_decl);\n-      else if (TREE_PROTECTED (decl))\n-\terror (\"%q+#D is protected\", diag_decl);\n-      else\n-\terror (\"%q+#D is inaccessible\", diag_decl);\n-      error (\"within this context\");\n+      if (complain & tf_error)\n+\t{\n+\t  if (TREE_PRIVATE (decl))\n+\t    error (\"%q+#D is private\", diag_decl);\n+\t  else if (TREE_PROTECTED (decl))\n+\t    error (\"%q+#D is protected\", diag_decl);\n+\t  else\n+\t    error (\"%q+#D is inaccessible\", diag_decl);\n+\t  error (\"within this context\");\n+\t}\n       return false;\n     }\n \n@@ -6510,14 +6515,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \taccess_fn = DECL_TI_TEMPLATE (fn);\n       else\n \taccess_fn = fn;\n-      if (flags & LOOKUP_SPECULATIVE)\n-\t{\n-\t  if (!speculative_access_check (cand->access_path, access_fn, fn,\n-\t\t\t\t\t complain & tf_error))\n-\t    return error_mark_node;\n-\t}\n-      else\n-\tperform_or_defer_access_check (cand->access_path, access_fn, fn);\n+      if (!perform_or_defer_access_check (cand->access_path, access_fn,\n+\t\t\t\t\t  fn, complain))\n+\treturn error_mark_node;\n     }\n \n   /* If we're checking for implicit delete, don't bother with argument"}, {"sha": "96a742097a8a3286d42329e925813a8317ae4157", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1189,7 +1189,8 @@ alter_access (tree t, tree fdecl, tree access)\n     }\n   else\n     {\n-      perform_or_defer_access_check (TYPE_BINFO (t), fdecl, fdecl);\n+      perform_or_defer_access_check (TYPE_BINFO (t), fdecl, fdecl,\n+\t\t\t\t     tf_warning_or_error);\n       DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }\n@@ -7147,7 +7148,8 @@ resolve_address_of_overloaded_function (tree target_type,\n       && DECL_FUNCTION_MEMBER_P (fn))\n     {\n       gcc_assert (access_path);\n-      perform_or_defer_access_check (access_path, fn, fn);\n+      perform_or_defer_access_check (access_path, fn, fn,\n+\t\t\t\t     tf_warning_or_error);\n     }\n \n   if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))"}, {"sha": "f1a4b32603ce80aba3c8f66cc75e81b9d8441528", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -78,6 +78,7 @@ c-common.h, not after.\n       CONVERT_EXPR_VBASE_PATH (in CONVERT_EXPR)\n       OVL_ARG_DEPENDENT (in OVERLOAD)\n       PACK_EXPANSION_LOCAL_P (in *_PACK_EXPANSION)\n+      TINFO_RECHECK_ACCESS_P (in TEMPLATE_INFO)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -725,6 +726,14 @@ typedef struct qualified_typedef_usage_s qualified_typedef_usage_t;\n DEF_VEC_O (qualified_typedef_usage_t);\n DEF_VEC_ALLOC_O (qualified_typedef_usage_t,gc);\n \n+/* Non-zero if this template specialization has access violations that\n+   should be rechecked when the function is instantiated outside argument\n+   deduction.  */\n+#define TINFO_RECHECK_ACCESS_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (TEMPLATE_INFO_CHECK (NODE)))\n+#define FNDECL_RECHECK_ACCESS_P(NODE) \\\n+  (TINFO_RECHECK_ACCESS_P (DECL_TEMPLATE_INFO (NODE)))\n+\n struct GTY(()) tree_template_info {\n   struct tree_common common;\n   VEC(qualified_typedef_usage_t,gc) *typedefs_needing_access_checking;\n@@ -4424,9 +4433,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n    Used by sythesized_method_walk to determine which functions will\n    be called to initialize subobjects, in order to determine exception\n    specification and possible implicit delete.\n-   This is kind of a hack, but since access control doesn't respect SFINAE\n-   we can't just use tf_none to avoid access control errors, we need\n-   another mechanism.  Exiting early also avoids problems with trying\n+   This is kind of a hack, but exiting early avoids problems with trying\n    to perform argument conversions when the class isn't complete yet.  */\n #define LOOKUP_SPECULATIVE (LOOKUP_LIST_ONLY << 1)\n /* Used by calls from defaulted functions to limit the overload set to avoid\n@@ -4901,7 +4908,8 @@ extern bool can_convert_arg\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern bool can_convert_arg_bad\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern bool enforce_access\t\t\t(tree, tree, tree);\n+extern bool enforce_access\t\t\t(tree, tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern void push_defarg_context\t\t\t(tree);\n extern void pop_defarg_context\t\t\t(void);\n extern tree convert_default_arg\t\t\t(tree, tree, tree, int,\n@@ -5497,10 +5505,11 @@ extern void stop_deferring_access_checks\t(void);\n extern void pop_deferring_access_checks\t\t(void);\n extern VEC (deferred_access_check,gc)* get_deferred_access_checks\t\t(void);\n extern void pop_to_parent_deferring_access_checks (void);\n-extern void perform_access_checks\t\t(VEC (deferred_access_check,gc)*);\n-extern void perform_deferred_access_checks\t(void);\n-extern void perform_or_defer_access_check\t(tree, tree, tree);\n-extern bool speculative_access_check\t\t(tree, tree, tree, bool);\n+extern bool perform_access_checks (VEC (deferred_access_check,gc)*,\n+\t\t\t\t   tsubst_flags_t);\n+extern bool perform_deferred_access_checks\t(tsubst_flags_t);\n+extern bool perform_or_defer_access_check\t(tree, tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern int stmts_are_full_exprs_p\t\t(void);\n extern void init_cp_semantics\t\t\t(void);\n extern tree do_poplevel\t\t\t\t(tree);"}, {"sha": "605058d1fc2bbfdad65bf7b8fe183638d7b1412a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -3306,9 +3306,9 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n \t       context, name, t);\n       return error_mark_node;\n     }\n-  \n-  if (complain & tf_error)\n-    perform_or_defer_access_check (TYPE_BINFO (context), t, t);\n+\n+  if (!perform_or_defer_access_check (TYPE_BINFO (context), t, t, complain))\n+    return error_mark_node;\n \n   /* If we are currently parsing a template and if T is a typedef accessed\n      through CONTEXT then we need to remember and check access of T at\n@@ -3378,8 +3378,9 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n \t  return error_mark_node;\n \t}\n \n-      if (complain & tf_error)\n-\tperform_or_defer_access_check (TYPE_BINFO (context), tmpl, tmpl);\n+      if (!perform_or_defer_access_check (TYPE_BINFO (context), tmpl, tmpl,\n+\t\t\t\t\t  complain))\n+\treturn error_mark_node;\n \n       return tmpl;\n     }\n@@ -6647,7 +6648,8 @@ register_dtor_fn (tree decl)\n       gcc_assert (idx >= 0);\n       cleanup = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), idx);\n       /* Make sure it is accessible.  */\n-      perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup);\n+      perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup,\n+\t\t\t\t     tf_warning_or_error);\n     }\n   else\n     {"}, {"sha": "d0cbaedc581d3a844e9ab5a7bdeeee4818248638", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -166,7 +166,8 @@ add_friend (tree type, tree decl, bool complain)\n \n   ctx = DECL_CONTEXT (decl);\n   if (ctx && CLASS_TYPE_P (ctx) && !uses_template_parms (ctx))\n-    perform_or_defer_access_check (TYPE_BINFO (ctx), decl, decl);\n+    perform_or_defer_access_check (TYPE_BINFO (ctx), decl, decl,\n+\t\t\t\t   tf_warning_or_error);\n \n   maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n "}, {"sha": "a725a0c9061d4982d5babe1e891561bc718aedda", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1876,9 +1876,11 @@ build_offset_ref (tree type, tree member, bool address_p)\n \t       (or any class derived from that class).  */\n \t  if (address_p && DECL_P (t)\n \t      && DECL_NONSTATIC_MEMBER_P (t))\n-\t    perform_or_defer_access_check (TYPE_BINFO (type), t, t);\n+\t    perform_or_defer_access_check (TYPE_BINFO (type), t, t,\n+\t\t\t\t\t   tf_warning_or_error);\n \t  else\n-\t    perform_or_defer_access_check (basebinfo, t, t);\n+\t    perform_or_defer_access_check (basebinfo, t, t,\n+\t\t\t\t\t   tf_warning_or_error);\n \n \t  if (DECL_STATIC_FUNCTION_P (t))\n \t    return t;\n@@ -1891,7 +1893,8 @@ build_offset_ref (tree type, tree member, bool address_p)\n     /* We need additional test besides the one in\n        check_accessibility_of_qualified_id in case it is\n        a pointer to non-static member.  */\n-    perform_or_defer_access_check (TYPE_BINFO (type), member, member);\n+    perform_or_defer_access_check (TYPE_BINFO (type), member, member,\n+\t\t\t\t   tf_warning_or_error);\n \n   if (!address_p)\n     {"}, {"sha": "c21ae152d6b2ab90edb1ac57bc30741ad513e112", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1225,6 +1225,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \n   ++cp_unevaluated_operand;\n   ++c_inhibit_evaluation_warnings;\n+  push_deferring_access_checks (dk_no_deferred);\n \n   scope = push_scope (ctype);\n \n@@ -1342,6 +1343,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \n   pop_scope (scope);\n \n+  pop_deferring_access_checks ();\n   --cp_unevaluated_operand;\n   --c_inhibit_evaluation_warnings;\n }"}, {"sha": "70d6dac58675fea539a87b42b6dfb484b1ed81fb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -10515,7 +10515,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n       if (cp_parser_declares_only_class_p (parser))\n \tshadow_tag (&decl_specifiers);\n       /* Perform any deferred access checks.  */\n-      perform_deferred_access_checks ();\n+      perform_deferred_access_checks (tf_warning_or_error);\n     }\n \n   /* Consume the `;'.  */\n@@ -12416,7 +12416,8 @@ cp_parser_template_id (cp_parser *parser,\n \t  FOR_EACH_VEC_ELT (deferred_access_check, access_check, i, chk)\n \t    perform_or_defer_access_check (chk->binfo,\n \t\t\t\t\t   chk->decl,\n-\t\t\t\t\t   chk->diag_decl);\n+\t\t\t\t\t   chk->diag_decl,\n+\t\t\t\t\t   tf_warning_or_error);\n \t}\n       /* Return the stored value.  */\n       return check_value->value;\n@@ -15751,7 +15752,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \n       /* Perform the access control checks for the declarator and the\n \t decl-specifiers.  */\n-      perform_deferred_access_checks ();\n+      perform_deferred_access_checks (tf_warning_or_error);\n \n       /* Restore the saved value.  */\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -21009,7 +21010,7 @@ cp_parser_function_definition_from_specifiers_and_declarator\n      did not check, check them now.  We must wait until we are in the\n      scope of the function to perform the checks, since the function\n      might be a friend.  */\n-  perform_deferred_access_checks ();\n+  perform_deferred_access_checks (tf_warning_or_error);\n \n   if (!success_p)\n     {\n@@ -21303,7 +21304,7 @@ static void\n cp_parser_perform_template_parameter_access_checks (VEC (deferred_access_check,gc)* checks)\n {\n   ++processing_template_parmlist;\n-  perform_access_checks (checks);\n+  perform_access_checks (checks, tf_warning_or_error);\n   --processing_template_parmlist;\n }\n \n@@ -22752,7 +22753,7 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n       FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n \tperform_or_defer_access_check (chk->binfo,\n \t\t\t\t       chk->decl,\n-\t\t\t\t       chk->diag_decl);\n+\t\t\t\t       chk->diag_decl, tf_warning_or_error);\n     }\n   /* Set the scope from the stored value.  */\n   parser->scope = check_value->value;\n@@ -24010,7 +24011,7 @@ cp_parser_objc_method_definition_list (cp_parser* parser)\n \t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n \t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n \t    {\n-\t      perform_deferred_access_checks ();\n+\t      perform_deferred_access_checks (tf_warning_or_error);\n \t      stop_deferring_access_checks ();\n \t      meth = cp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t\t\t     false);"}, {"sha": "65eb2cc103d2359408decdaadddef8a84fddc234", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -8370,7 +8370,8 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n          of the use of the typedef.  */\n       input_location = iter->locus;\n       perform_or_defer_access_check (TYPE_BINFO (type_scope),\n-\t\t\t\t     type_decl, type_decl);\n+\t\t\t\t     type_decl, type_decl,\n+\t\t\t\t     tf_warning_or_error);\n     }\n     input_location = saved_location;\n }\n@@ -8877,7 +8878,7 @@ instantiate_class_template_1 (tree type)\n      added to the template at parsing time. Let's get those and perform\n      the access checks then.  */\n   perform_typedefs_access_check (pattern, args);\n-  perform_deferred_access_checks ();\n+  perform_deferred_access_checks (tf_warning_or_error);\n   pop_nested_class ();\n   maximum_field_alignment = saved_maximum_field_alignment;\n   if (!fn_context)\n@@ -14288,6 +14289,23 @@ deduction_tsubst_fntype (tree fn, tree targs, tsubst_flags_t complain)\n   return r;\n }\n \n+/* We're out of SFINAE context now, so generate diagnostics for the access\n+   errors we saw earlier when instantiating D from TMPL and ARGS.  */\n+\n+static void\n+recheck_decl_substitution (tree d, tree tmpl, tree args)\n+{\n+  tree pattern = DECL_TEMPLATE_RESULT (tmpl);\n+  tree type = TREE_TYPE (pattern);\n+  location_t loc = input_location;\n+\n+  push_access_scope (d);\n+  input_location = DECL_SOURCE_LOCATION (pattern);\n+  tsubst (type, args, tf_warning_or_error, d);\n+  input_location = loc;\n+  pop_access_scope (d);\n+}\n+\n /* Instantiate the indicated variable or function template TMPL with\n    the template arguments in TARG_PTR.  */\n \n@@ -14298,6 +14316,7 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   tree fndecl;\n   tree gen_tmpl;\n   tree spec;\n+  bool access_ok = true;\n \n   if (tmpl == error_mark_node)\n     return error_mark_node;\n@@ -14345,7 +14364,11 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n \t      || fndecl == NULL_TREE);\n \n   if (spec != NULL_TREE)\n-    return spec;\n+    {\n+      if (FNDECL_RECHECK_ACCESS_P (spec) && (complain & tf_error))\n+\trecheck_decl_substitution (spec, gen_tmpl, targ_ptr);\n+      return spec;\n+    }\n \n   if (check_instantiated_args (gen_tmpl, INNERMOST_TEMPLATE_ARGS (targ_ptr),\n \t\t\t       complain))\n@@ -14375,7 +14398,10 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   pop_from_top_level ();\n \n   if (fndecl == error_mark_node)\n-    return error_mark_node;\n+    {\n+      pop_deferring_access_checks ();\n+      return error_mark_node;\n+    }\n \n   /* The DECL_TI_TEMPLATE should always be the immediate parent\n      template, not the most general template.  */\n@@ -14384,7 +14410,8 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   /* Now we know the specialization, compute access previously\n      deferred.  */\n   push_access_scope (fndecl);\n-  perform_deferred_access_checks ();\n+  if (!perform_deferred_access_checks (complain))\n+    access_ok = false;\n   pop_access_scope (fndecl);\n   pop_deferring_access_checks ();\n \n@@ -14395,6 +14422,16 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   if (DECL_CHAIN (gen_tmpl) && DECL_CLONED_FUNCTION_P (DECL_CHAIN (gen_tmpl)))\n     clone_function_decl (fndecl, /*update_method_vec_p=*/0);\n \n+  if (!access_ok)\n+    {\n+      if (!(complain & tf_error))\n+\t{\n+\t  /* Remember to reinstantiate when we're out of SFINAE so the user\n+\t     can see the errors.  */\n+\t  FNDECL_RECHECK_ACCESS_P (fndecl) = true;\n+\t}\n+      return error_mark_node;\n+    }\n   return fndecl;\n }\n "}, {"sha": "048fdf3270a6d5b5342cbfbefa8502b0529b9354", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1254,8 +1254,10 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n       && !really_overloaded_fn (rval))\n     {\n       tree decl = is_overloaded_fn (rval) ? get_first_fn (rval) : rval;\n-      if (!DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n-\tperform_or_defer_access_check (basetype_path, decl, decl);\n+      if (!DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n+\t  && !perform_or_defer_access_check (basetype_path, decl, decl,\n+\t\t\t\t\t     complain))\n+\trval = error_mark_node;\n     }\n \n   if (errstr && protect)"}, {"sha": "6381949a664902b056ba3e714d5b4ae80376cb1c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -223,7 +223,7 @@ pop_to_parent_deferring_access_checks (void)\n       if (ptr->deferring_access_checks_kind == dk_no_deferred)\n \t{\n \t  /* Check access.  */\n-\t  perform_access_checks (checks);\n+\t  perform_access_checks (checks, tf_warning_or_error);\n \t}\n       else\n \t{\n@@ -252,25 +252,30 @@ pop_to_parent_deferring_access_checks (void)\n \n /* Perform the access checks in CHECKS.  The TREE_PURPOSE of each node\n    is the BINFO indicating the qualifying scope used to access the\n-   DECL node stored in the TREE_VALUE of the node.  */\n+   DECL node stored in the TREE_VALUE of the node.  If CHECKS is empty\n+   or we aren't in SFINAE context or all the checks succeed return TRUE,\n+   otherwise FALSE.  */\n \n-void\n-perform_access_checks (VEC (deferred_access_check,gc)* checks)\n+bool\n+perform_access_checks (VEC (deferred_access_check,gc)* checks,\n+\t\t       tsubst_flags_t complain)\n {\n   int i;\n   deferred_access_check *chk;\n   location_t loc = input_location;\n+  bool ok = true;\n \n   if (!checks)\n-    return;\n+    return true;\n \n   FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n     {\n       input_location = chk->loc;\n-      enforce_access (chk->binfo, chk->decl, chk->diag_decl);\n+      ok &= enforce_access (chk->binfo, chk->decl, chk->diag_decl, complain);\n     }\n \n   input_location = loc;\n+  return (complain & tf_error) ? true : ok;\n }\n \n /* Perform the deferred access checks.\n@@ -287,19 +292,21 @@ perform_access_checks (VEC (deferred_access_check,gc)* checks)\n      A::X A::a, x;\t// No error for `A::a', error for `x'\n \n    We have to perform deferred access of `A::X', first with `A::a',\n-   next with `x'.  */\n+   next with `x'.  Return value like perform_access_checks above.  */\n \n-void\n-perform_deferred_access_checks (void)\n+bool\n+perform_deferred_access_checks (tsubst_flags_t complain)\n {\n-  perform_access_checks (get_deferred_access_checks ());\n+  return perform_access_checks (get_deferred_access_checks (), complain);\n }\n \n /* Defer checking the accessibility of DECL, when looked up in\n-   BINFO. DIAG_DECL is the declaration to use to print diagnostics.  */\n+   BINFO. DIAG_DECL is the declaration to use to print diagnostics.\n+   Return value like perform_access_checks above.  */\n \n-void\n-perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n+bool\n+perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n+\t\t\t       tsubst_flags_t complain)\n {\n   int i;\n   deferred_access *ptr;\n@@ -310,7 +317,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n   /* Exit if we are in a context that no access checking is performed.\n      */\n   if (deferred_access_no_check)\n-    return;\n+    return true;\n \n   gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n \n@@ -319,8 +326,8 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n   /* If we are not supposed to defer access checks, just check now.  */\n   if (ptr->deferring_access_checks_kind == dk_no_deferred)\n     {\n-      enforce_access (binfo, decl, diag_decl);\n-      return;\n+      bool ok = enforce_access (binfo, decl, diag_decl, complain);\n+      return (complain & tf_error) ? true : ok;\n     }\n \n   /* See if we are already going to perform this check.  */\n@@ -330,7 +337,7 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n       if (chk->decl == decl && chk->binfo == binfo &&\n \t  chk->diag_decl == diag_decl)\n \t{\n-\t  return;\n+\t  return true;\n \t}\n     }\n   /* If not, record the check.  */\n@@ -341,28 +348,6 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n   new_access->decl = decl;\n   new_access->diag_decl = diag_decl;\n   new_access->loc = input_location;\n-}\n-\n-/* Used by build_over_call in LOOKUP_SPECULATIVE mode: return whether DECL\n-   is accessible in BINFO, and possibly complain if not.  If we're not\n-   checking access, everything is accessible.  */\n-\n-bool\n-speculative_access_check (tree binfo, tree decl, tree diag_decl,\n-\t\t\t  bool complain)\n-{\n-  if (deferred_access_no_check)\n-    return true;\n-\n-  /* If we're checking for implicit delete, we don't want access\n-     control errors.  */\n-  if (!accessible_p (binfo, decl, true))\n-    {\n-      /* Unless we're under maybe_explain_implicit_delete.  */\n-      if (complain)\n-\tenforce_access (binfo, decl, diag_decl);\n-      return false;\n-    }\n \n   return true;\n }\n@@ -1611,7 +1596,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n       tree access_type = TREE_TYPE (object);\n \n       perform_or_defer_access_check (TYPE_BINFO (access_type), decl,\n-\t\t\t\t     decl);\n+\t\t\t\t     decl, tf_warning_or_error);\n \n       /* If the data member was named `C::M', convert `*this' to `C'\n \t first.  */\n@@ -1733,7 +1718,7 @@ check_accessibility_of_qualified_id (tree decl,\n       && CLASS_TYPE_P (qualifying_type)\n       && !dependent_type_p (qualifying_type))\n     perform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl,\n-\t\t\t\t   decl);\n+\t\t\t\t   decl, tf_warning_or_error);\n }\n \n /* EXPR is the result of a qualified-id.  The QUALIFYING_CLASS was the\n@@ -3336,7 +3321,8 @@ finish_id_expression (tree id_expression,\n \t\t{\n \t\t  tree path = currently_open_derived_class (context);\n \t\t  perform_or_defer_access_check (TYPE_BINFO (path),\n-\t\t\t\t\t\t decl, decl);\n+\t\t\t\t\t\t decl, decl,\n+\t\t\t\t\t\t tf_warning_or_error);\n \t\t}\n \t    }\n "}, {"sha": "32ed483ca88b346bdf0b9bb4b2e29f75b4fe8fb3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1,3 +1,12 @@\n+2012-07-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/sfinae37.C: New.\n+\t* g++.dg/template/access23.C: New.\n+\t* g++.dg/template/access7.C: Adjust.\n+\t* g++.dg/template/sfinae10.C: Don't expect errors.\n+\t* g++.dg/template/sfinae6_neg.C: Don't expect errors.\n+\n 2012-07-18  Julian Brown  <julian@codesourcery.com>\n \t    Sandra Loosemore <sandra@codesroucery.com>\n "}, {"sha": "071923e52615af39c2af448aa5b99e58c3955595", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae37.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae37.C?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/51213\n+// { dg-do compile { target c++11 } }\n+\n+class C {\n+  typedef int type;\n+};\n+\n+template<class T, class = typename T::type>\n+auto f(int) -> char;\n+\n+template<class>\n+auto f(...) -> char (&)[2];\n+\n+static_assert(sizeof(f<C>(0)) == 2, \"Ouch\");\n+\n+template<class T>\n+auto g(int) -> decltype(typename T::type(), char());\n+\n+template<class>\n+auto g(...) -> char (&)[2];\n+\n+static_assert(sizeof(g<C>(0)) == 2, \"Ouch\");"}, {"sha": "054cf9201cef7b2f48daad755995279c545b9ba9", "filename": "gcc/testsuite/g++.dg/template/access23.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess23.C?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -0,0 +1,16 @@\n+template <class T>\n+class A\n+{\n+  typedef T I;\n+};\n+\n+template <class T>\n+void f(typename T::I);\n+\n+template <class T>\n+void f(int);\n+\n+int main()\n+{\n+  f<A<float> > (1);\n+}"}, {"sha": "7d1812732c35443af4aea39d2af4c009ab8f59cf", "filename": "gcc/testsuite/g++.dg/template/access7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess7.C?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -14,5 +14,5 @@ typename A::T* f (A) {\t\t\t// { dg-error \"this context\" }\n }\n \n void g () {\n-  f (S<int> ());\t\t\t// { dg-message \"required\" }\n+  f (S<int> ());\t\t\t// { dg-message \"required|no match\" }\n }"}, {"sha": "574feddb3abe2efdaa83e51aa9ebce3f4bc5e5ac", "filename": "gcc/testsuite/g++.dg/template/sfinae10.C", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae10.C?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -81,59 +81,59 @@ struct Y { };\n \n struct Z {\n private:\n-  Z operator+(); // { dg-error \"is private\" }\n-  Z operator-(); // { dg-error \"is private\" }\n-  int operator*(); // { dg-error \"is private\" }\n-  Z operator~(); // { dg-error \"is private\" } \n-  bool operator!(); // { dg-error \"is private\" }  \n-  Z& operator++(); // { dg-error \"is private\" }  \n-  Z& operator--(); // { dg-error \"is private\" }  \n-  Z& operator++(int); // { dg-error \"is private\" }  \n-  Z& operator--(int); // { dg-error \"is private\" }  \n+  Z operator+();\n+  Z operator-();\n+  int operator*();\n+  Z operator~();\n+  bool operator!();\n+  Z& operator++();\n+  Z& operator--();\n+  Z& operator++(int);\n+  Z& operator--(int);\n };\n \n // has_unary_plus\n-DEFINE_PREFIX_UNARY_TRAIT(has_unary_plus, +); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(has_unary_plus, +);\n STATIC_ASSERT((has_unary_plus<int>::value));\n STATIC_ASSERT((!has_unary_plus<int X::*>::value));\n STATIC_ASSERT((has_unary_plus<W>::value));\n STATIC_ASSERT((has_unary_plus<X>::value));\n STATIC_ASSERT((!has_unary_plus<Y>::value));\n \n // is_negatable\n-DEFINE_PREFIX_UNARY_TRAIT(is_negatable, -); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(is_negatable, -);\n STATIC_ASSERT((is_negatable<int>::value));\n STATIC_ASSERT((!is_negatable<int X::*>::value));\n STATIC_ASSERT((is_negatable<W>::value));\n STATIC_ASSERT((is_negatable<X>::value));\n STATIC_ASSERT((!is_negatable<Y>::value));\n \n // is_dereferenceable\n-DEFINE_PREFIX_UNARY_TRAIT(is_dereferenceable, *); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(is_dereferenceable, *);\n STATIC_ASSERT((!is_dereferenceable<int>::value));\n STATIC_ASSERT((is_dereferenceable<int*>::value));\n STATIC_ASSERT((is_dereferenceable<W>::value));\n STATIC_ASSERT((is_dereferenceable<X>::value));\n STATIC_ASSERT((!is_dereferenceable<Y>::value));\n \n // has_bitwise_not\n-DEFINE_PREFIX_UNARY_TRAIT(has_bitwise_not, ~); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(has_bitwise_not, ~);\n STATIC_ASSERT((has_bitwise_not<int>::value));\n STATIC_ASSERT((!has_bitwise_not<int*>::value));\n STATIC_ASSERT((has_bitwise_not<W>::value));\n STATIC_ASSERT((has_bitwise_not<X>::value));\n STATIC_ASSERT((!has_bitwise_not<Y>::value));\n \n // has_truth_not\n-DEFINE_PREFIX_UNARY_TRAIT(has_truth_not, !); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(has_truth_not, !);\n STATIC_ASSERT((has_truth_not<int>::value));\n STATIC_ASSERT((has_truth_not<int*>::value));\n STATIC_ASSERT((has_truth_not<W>::value));\n STATIC_ASSERT((has_truth_not<X>::value));\n STATIC_ASSERT((!has_truth_not<Y>::value));\n \n // has_preincrement\n-DEFINE_PREFIX_UNARY_TRAIT(has_preincrement, ++); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(has_preincrement, ++);\n STATIC_ASSERT((has_preincrement<int>::value));\n STATIC_ASSERT((has_preincrement<int*>::value));\n STATIC_ASSERT((!has_preincrement<int X::*>::value));\n@@ -142,7 +142,7 @@ STATIC_ASSERT((has_preincrement<X>::value));\n STATIC_ASSERT((!has_preincrement<Y>::value));\n \n // has_predecrement\n-DEFINE_PREFIX_UNARY_TRAIT(has_predecrement, --); // { dg-error \"within this context\" }\n+DEFINE_PREFIX_UNARY_TRAIT(has_predecrement, --);\n STATIC_ASSERT((has_predecrement<int>::value));\n STATIC_ASSERT((has_predecrement<int*>::value));\n STATIC_ASSERT((!has_predecrement<int X::*>::value));\n@@ -151,7 +151,7 @@ STATIC_ASSERT((has_predecrement<X>::value));\n STATIC_ASSERT((!has_predecrement<Y>::value));\n \n // has_postincrement\n-DEFINE_POSTFIX_UNARY_TRAIT(has_postincrement, ++); // { dg-error \"within this context\" }\n+DEFINE_POSTFIX_UNARY_TRAIT(has_postincrement, ++);\n STATIC_ASSERT((has_postincrement<int>::value));\n STATIC_ASSERT((has_postincrement<int*>::value));\n STATIC_ASSERT((!has_postincrement<int X::*>::value));\n@@ -160,7 +160,7 @@ STATIC_ASSERT((has_postincrement<X>::value));\n STATIC_ASSERT((!has_postincrement<Y>::value));\n \n // has_postdecrement\n-DEFINE_POSTFIX_UNARY_TRAIT(has_postdecrement, --); // { dg-error \"within this context\" }\n+DEFINE_POSTFIX_UNARY_TRAIT(has_postdecrement, --);\n STATIC_ASSERT((has_postdecrement<int>::value));\n STATIC_ASSERT((has_postdecrement<int*>::value));\n STATIC_ASSERT((!has_postdecrement<int X::*>::value));\n@@ -169,13 +169,12 @@ STATIC_ASSERT((has_postdecrement<X>::value));\n STATIC_ASSERT((!has_postdecrement<Y>::value));\n \n // Check for private members\n-STATIC_ASSERT((has_unary_plus<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((is_negatable<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((is_dereferenceable<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((has_bitwise_not<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((has_truth_not<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((has_preincrement<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((has_predecrement<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((has_postincrement<Z>::value)); // { dg-message \"required from here\" }\n-STATIC_ASSERT((has_postdecrement<Z>::value)); // { dg-message \"required from here\" }\n-\n+STATIC_ASSERT((!has_unary_plus<Z>::value));\n+STATIC_ASSERT((!is_negatable<Z>::value));\n+STATIC_ASSERT((!is_dereferenceable<Z>::value));\n+STATIC_ASSERT((!has_bitwise_not<Z>::value));\n+STATIC_ASSERT((!has_truth_not<Z>::value));\n+STATIC_ASSERT((!has_preincrement<Z>::value));\n+STATIC_ASSERT((!has_predecrement<Z>::value));\n+STATIC_ASSERT((!has_postincrement<Z>::value));\n+STATIC_ASSERT((!has_postdecrement<Z>::value));"}, {"sha": "6ed3d226784411aafe715e7766cd79132b9a218f", "filename": "gcc/testsuite/g++.dg/template/sfinae6_neg.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6_neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6_neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6_neg.C?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -14,7 +14,7 @@ template<typename T> struct enable_if<false, T> { };\n template<typename F, typename T1, typename T2>\n   typename enable_if<sizeof(create_a<F>()(create_a<T1>(), create_a<T2>()), 1),\n \t\t     yes_type>::type\n-  check_is_callable2(type<F>, type<T1>, type<T2>); // { dg-error \"within this context\" }\n+  check_is_callable2(type<F>, type<T1>, type<T2>);\n \n no_type check_is_callable2(...);\n \n@@ -52,7 +52,7 @@ struct F {\n   void operator()(A, A);\n \n private:\n-  void operator()(B, B); // { dg-error \"is private\" }\n+  void operator()(B, B);\n };\n \n-STATIC_ASSERT((is_callable2<F, B, B>::value));\n+STATIC_ASSERT((!is_callable2<F, B, B>::value));"}, {"sha": "f9dd6c740bfbc8894ed3e57a2c37ce2eb3c63df4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -1,3 +1,8 @@\n+2012-07-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/51213\n+\t* testsuite/20_util/pair/noncopyable.cc: New.\n+\n 2012-07-16  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/53270"}, {"sha": "731e7ee7030a8ba799603b929ec6e4cb9fca61f5", "filename": "libstdc++-v3/testsuite/20_util/pair/noncopyable.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fnoncopyable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fnoncopyable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fnoncopyable.cc?ref=0e69fdf016311cb8570c43d8ec67e9d5cb2f2aeb", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+\n+// PR c++/51213\n+class Uncopyable\n+{\n+  Uncopyable(const Uncopyable&);\n+ public:\n+  Uncopyable() = default;\n+};\n+\n+struct ContainsUncopyable\n+{\n+  std::pair<Uncopyable, int> pv;\n+};\n+\n+void foo()\n+{\n+  ContainsUncopyable c;\n+}"}]}