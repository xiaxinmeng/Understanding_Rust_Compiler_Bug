{"sha": "2fbe90f22457f0a82c1d10ff5a918259c41859b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZiZTkwZjIyNDU3ZjBhODJjMWQxMGZmNWE5MTgyNTljNDE4NTliMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-25T18:17:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-25T18:17:53Z"}, "message": "tree-cfg.c (verify_expr): Add macro CHECK_OK.\n\n\t* tree-cfg.c (verify_expr): Add macro CHECK_OK.\n\tProperly test for nest of handled_components in LHS context.\n\nFrom-SVN: r83666", "tree": {"sha": "9e84b7bca9d3217814db5f347a3cb33bd6d238b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e84b7bca9d3217814db5f347a3cb33bd6d238b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fbe90f22457f0a82c1d10ff5a918259c41859b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbe90f22457f0a82c1d10ff5a918259c41859b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbe90f22457f0a82c1d10ff5a918259c41859b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbe90f22457f0a82c1d10ff5a918259c41859b1/comments", "author": null, "committer": null, "parents": [{"sha": "795af1d7351cecbb1304603e5afd7ce018aa93fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795af1d7351cecbb1304603e5afd7ce018aa93fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795af1d7351cecbb1304603e5afd7ce018aa93fa"}], "stats": {"total": 75, "additions": 62, "deletions": 13}, "files": [{"sha": "4720e8350285f0cd82530cb3e1588fe40ed22a95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbe90f22457f0a82c1d10ff5a918259c41859b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbe90f22457f0a82c1d10ff5a918259c41859b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fbe90f22457f0a82c1d10ff5a918259c41859b1", "patch": "@@ -1,3 +1,8 @@\n+2004-06-25  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree-cfg.c (verify_expr): Add macro CHECK_OK.\n+\tProperly test for nest of handled_components in LHS context.\n+\n 2004-06-25  Devang Patel  <dpatel@apple.com>\n \n \t* doc/tree-ssa.texi: Document info about MODIFY_EXPR's type"}, {"sha": "ca8afed5500fc1c357357ae0110b3b28009c91ae", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbe90f22457f0a82c1d10ff5a918259c41859b1/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbe90f22457f0a82c1d10ff5a918259c41859b1/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2fbe90f22457f0a82c1d10ff5a918259c41859b1", "patch": "@@ -3127,13 +3127,18 @@ has_label_p (basic_block bb, tree label)\n    properly noticed as such.  */\n \n static tree\n-verify_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t     void *data ATTRIBUTE_UNUSED)\n+verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   tree t = *tp, x;\n \n   if (TYPE_P (t))\n     *walk_subtrees = 0;\n+  \n+  /* Check operand N for being valid GIMPLE and give error MSG if not.  */\n+#define CHECK_OP(N, MSG) \\\n+  do { if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, N))) != 'c'\t\\\n+         && !is_gimple_val (TREE_OPERAND (t, N)))\t\t\t\\\n+       { error (MSG); return TREE_OPERAND (t, N); }} while (0)\n \n   switch (TREE_CODE (t))\n     {\n@@ -3151,12 +3156,18 @@ verify_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  && is_gimple_reg (TREE_OPERAND (x, 0)))\n \t{\n \t  error (\"GIMPLE register modified with BIT_FIELD_REF\");\n-\t  return *tp;\n+\t  return t;\n \t}\n       break;\n \n     case ADDR_EXPR:\n-      for (x = TREE_OPERAND (t, 0); handled_component_p (x);\n+      /* Skip any references (they will be checked when we recurse down the\n+\t tree) and ensure that any variable used as a prefix is marked\n+\t addressable.  */\n+      for (x = TREE_OPERAND (t, 0);\n+\t   (handled_component_p (x)\n+\t    || TREE_CODE (x) == REALPART_EXPR\n+\t    || TREE_CODE (x) == IMAGPART_EXPR);\n \t   x = TREE_OPERAND (x, 0))\n \t;\n \n@@ -3190,19 +3201,50 @@ verify_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n     case BIT_NOT_EXPR:\n     case NON_LVALUE_EXPR:\n     case TRUTH_NOT_EXPR:\n-      x = TREE_OPERAND (t, 0);\n-      /* We check for constants explicitly since they are not considered\n-\t gimple invariants if they overflowed.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (x)) != 'c'\n-\t  && !is_gimple_val (x))\n-\t{\n-\t  error (\"Invalid operand to unary operator\");\n-\t  return x;\n-\t}\n+      CHECK_OP (0, \"Invalid operand to unary operator\");\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case BIT_FIELD_REF:\n+    case VIEW_CONVERT_EXPR:\n+      /* We have a nest of references.  Verify that each of the operands\n+\t that determine where to reference is either a constant or a variable,\n+\t verify that the base is valid, and then show we've already checked\n+\t the subtrees.  */\n+      while (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR\n+\t     || handled_component_p (t))\n+\t{\n+\t  if (TREE_CODE (t) == COMPONENT_REF && TREE_OPERAND (t, 2))\n+\t    CHECK_OP (2, \"Invalid COMPONENT_REF offset operator\");\n+\t  else if (TREE_CODE (t) == ARRAY_REF\n+\t\t   || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t    {\n+\t      CHECK_OP (1, \"Invalid array index.\");\n+\t      if (TREE_OPERAND (t, 2))\n+\t\tCHECK_OP (2, \"Invalid array lower bound.\");\n+\t      if (TREE_OPERAND (t, 3))\n+\t\tCHECK_OP (3, \"Invalid array stride.\");\n+\t    }\n+\t  else if (TREE_CODE (t) == BIT_FIELD_REF)\n+\t    {\n+\t      CHECK_OP (1, \"Invalid operand to BIT_FIELD_REF\");\n+\t      CHECK_OP (2, \"Invalid operand to BIT_FIELD_REF\");\n+\t    }\n+\n+\t  t = TREE_OPERAND (t, 0);\n+\t}\n+\n+      if (TREE_CODE_CLASS (TREE_CODE (t)) != 'c'\n+\t  && !is_gimple_lvalue (t))\n+\t{\n+\t  error (\"Invalid reference prefix.\");\n+\t  return t;\n+\t}\n+      *walk_subtrees = 0;\n       break;\n \n     case LT_EXPR:\n@@ -3265,6 +3307,8 @@ verify_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       break;\n     }\n   return NULL;\n+\n+#undef CHECK_OP\n }\n \n "}]}