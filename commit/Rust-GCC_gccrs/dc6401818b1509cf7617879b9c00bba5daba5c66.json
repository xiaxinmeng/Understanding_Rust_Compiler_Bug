{"sha": "dc6401818b1509cf7617879b9c00bba5daba5c66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2NDAxODE4YjE1MDljZjc2MTc4NzliOWMwMGJiYTVkYWJhNWM2Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-11T13:18:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-11T13:18:23Z"}, "message": "[AArch64] Add const_offset field to aarch64_address_info\n\nThis patch records the integer value of the address offset in\naarch64_address_info, so that it doesn't need to be re-extracted\nfrom the rtx.  The SVE port will make more use of this.  The patch\nalso uses poly_int64 routines to manipulate the offset, rather than\njust handling CONST_INTs.\n\n2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_address_info): Add a const_offset\n\tfield.\n\t(aarch64_classify_address): Initialize it.  Track polynomial offsets.\n\t(aarch64_print_address_internal): Use it to check for a zero offset.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256534", "tree": {"sha": "47461ef6e6ecc6767cb94c718222286724e160c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47461ef6e6ecc6767cb94c718222286724e160c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc6401818b1509cf7617879b9c00bba5daba5c66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6401818b1509cf7617879b9c00bba5daba5c66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6401818b1509cf7617879b9c00bba5daba5c66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6401818b1509cf7617879b9c00bba5daba5c66/comments", "author": null, "committer": null, "parents": [{"sha": "6a70badb2c1f627cd669f2fcfaeca4a05db50b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a70badb2c1f627cd669f2fcfaeca4a05db50b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a70badb2c1f627cd669f2fcfaeca4a05db50b5b"}], "stats": {"total": 30, "additions": 21, "deletions": 9}, "files": [{"sha": "f27395d5e7f3f63356387c8e577b526e088064fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6401818b1509cf7617879b9c00bba5daba5c66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6401818b1509cf7617879b9c00bba5daba5c66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc6401818b1509cf7617879b9c00bba5daba5c66", "patch": "@@ -1,3 +1,12 @@\n+2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_address_info): Add a const_offset\n+\tfield.\n+\t(aarch64_classify_address): Initialize it.  Track polynomial offsets.\n+\t(aarch64_print_address_internal): Use it to check for a zero offset.\n+\n 2018-01-11  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "ae44c2abe110b7732e1c36de51122595d0acf29e", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6401818b1509cf7617879b9c00bba5daba5c66/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6401818b1509cf7617879b9c00bba5daba5c66/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=dc6401818b1509cf7617879b9c00bba5daba5c66", "patch": "@@ -113,6 +113,7 @@ struct aarch64_address_info {\n   enum aarch64_address_type type;\n   rtx base;\n   rtx offset;\n+  poly_int64 const_offset;\n   int shift;\n   enum aarch64_symbol_type symbol_type;\n };\n@@ -4545,6 +4546,8 @@ aarch64_classify_address (struct aarch64_address_info *info,\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx op0, op1;\n+  poly_int64 offset;\n+\n   HOST_WIDE_INT const_size;\n \n   /* On BE, we use load/store pair for all large int mode load/stores.\n@@ -4573,6 +4576,7 @@ aarch64_classify_address (struct aarch64_address_info *info,\n       info->type = ADDRESS_REG_IMM;\n       info->base = x;\n       info->offset = const0_rtx;\n+      info->const_offset = 0;\n       return aarch64_base_register_rtx_p (x, strict_p);\n \n     case PLUS:\n@@ -4582,24 +4586,24 @@ aarch64_classify_address (struct aarch64_address_info *info,\n       if (! strict_p\n \t  && REG_P (op0)\n \t  && virt_or_elim_regno_p (REGNO (op0))\n-\t  && CONST_INT_P (op1))\n+\t  && poly_int_rtx_p (op1, &offset))\n \t{\n \t  info->type = ADDRESS_REG_IMM;\n \t  info->base = op0;\n \t  info->offset = op1;\n+\t  info->const_offset = offset;\n \n \t  return true;\n \t}\n \n       if (maybe_ne (GET_MODE_SIZE (mode), 0)\n-\t  && CONST_INT_P (op1)\n-\t  && aarch64_base_register_rtx_p (op0, strict_p))\n+\t  && aarch64_base_register_rtx_p (op0, strict_p)\n+\t  && poly_int_rtx_p (op1, &offset))\n \t{\n-\t  HOST_WIDE_INT offset = INTVAL (op1);\n-\n \t  info->type = ADDRESS_REG_IMM;\n \t  info->base = op0;\n \t  info->offset = op1;\n+\t  info->const_offset = offset;\n \n \t  /* TImode and TFmode values are allowed in both pairs of X\n \t     registers and individual Q registers.  The available\n@@ -4679,13 +4683,12 @@ aarch64_classify_address (struct aarch64_address_info *info,\n       info->type = ADDRESS_REG_WB;\n       info->base = XEXP (x, 0);\n       if (GET_CODE (XEXP (x, 1)) == PLUS\n-\t  && CONST_INT_P (XEXP (XEXP (x, 1), 1))\n+\t  && poly_int_rtx_p (XEXP (XEXP (x, 1), 1), &offset)\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), info->base)\n \t  && aarch64_base_register_rtx_p (info->base, strict_p))\n \t{\n-\t  HOST_WIDE_INT offset;\n \t  info->offset = XEXP (XEXP (x, 1), 1);\n-\t  offset = INTVAL (info->offset);\n+\t  info->const_offset = offset;\n \n \t  /* TImode and TFmode values are allowed in both pairs of X\n \t     registers and individual Q registers.  The available\n@@ -5735,7 +5738,7 @@ aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x,\n     switch (addr.type)\n       {\n       case ADDRESS_REG_IMM:\n-\tif (addr.offset == const0_rtx)\n+\tif (known_eq (addr.const_offset, 0))\n \t  asm_fprintf (f, \"[%s]\", reg_names [REGNO (addr.base)]);\n \telse\n \t  asm_fprintf (f, \"[%s, %wd]\", reg_names [REGNO (addr.base)],"}]}