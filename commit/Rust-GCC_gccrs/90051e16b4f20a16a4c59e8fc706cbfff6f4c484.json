{"sha": "90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAwNTFlMTZiNGYyMGExNmE0YzU5ZThmYzcwNmNiZmZmNmY0YzQ4NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-01T00:14:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-01T00:14:43Z"}, "message": "gimplify.c (gimplify_compound_lval): Take fallback argument instead of want_lvalue.\n\n        * gimplify.c (gimplify_compound_lval): Take fallback argument\n        instead of want_lvalue.\n        (gimplify_call_expr): Take want_value argument instead of test\n        function.  Gimplify arguments to val only if reg_type; otherwise\n        allow lvalue forms.\n        (gimplify_expr): Update gimplify_compound_lval and gimplify_call_expr\n        calls.\n        * tree-gimple.c: Update GIMPLE grammer.  Use true/false not 1/0.\n        Tidy commentary globally.\n        (get_call_expr_in): Remove RETURN_EXPR handling.  Tidy.\n        * tree-gimple.h (is_gimple_call_addr): Mark extern.\n\n        * gimplify.c (gimplify_modify_expr_to_memcpy): Fix typo.\n\nFrom-SVN: r83941", "tree": {"sha": "8dacbfb9bdce140d3169928797de60201eccca69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dacbfb9bdce140d3169928797de60201eccca69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/comments", "author": null, "committer": null, "parents": [{"sha": "2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9ef4fa61d2ad90cbca7baa59ce18f609a56274"}], "stats": {"total": 442, "additions": 197, "deletions": 245}, "files": [{"sha": "b013dd69bd3dcaba38112586e3c6867a0d37bbc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "patch": "@@ -1,3 +1,19 @@\n+2004-06-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* gimplify.c (gimplify_compound_lval): Take fallback argument\n+\tinstead of want_lvalue.\n+\t(gimplify_call_expr): Take want_value argument instead of test\n+\tfunction.  Gimplify arguments to val only if reg_type; otherwise\n+\tallow lvalue forms.\n+\t(gimplify_expr): Update gimplify_compound_lval and gimplify_call_expr\n+\tcalls.\n+\t* tree-gimple.c: Update GIMPLE grammer.  Use true/false not 1/0.\n+\tTidy commentary globally.\n+\t(get_call_expr_in): Remove RETURN_EXPR handling.  Tidy.\n+\t* tree-gimple.h (is_gimple_call_addr): Mark extern.\n+\n+\t* gimplify.c (gimplify_modify_expr_to_memcpy): Fix typo.\n+\n 2004-06-30  Richard Henderson  <rth@redhat.com>\n \n \t* tree-gimple.c (right_assocify_expr): Kill"}, {"sha": "e8fdbe9001f0766657d43974b70aaf17163dc70b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "patch": "@@ -1563,7 +1563,7 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n \n static enum gimplify_status\n gimplify_compound_lval (tree *expr_p, tree *pre_p,\n-\t\t\ttree *post_p, bool want_lvalue)\n+\t\t\ttree *post_p, fallback_t fallback)\n {\n   tree *p;\n   varray_type stack;\n@@ -1669,8 +1669,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n     }\n \n   /* Step 2 is to gimplify the base expression.  */\n-  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval,\n-\t\t\twant_lvalue ? fb_lvalue : fb_rvalue);\n+  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval, fallback);\n   ret = MIN (ret, tret);\n \n   /* And finally, the indices and operands to BIT_FIELD_REF.  */\n@@ -1713,12 +1712,11 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n       VARRAY_POP (stack);\n     }\n \n-  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval,\n-\t\t\twant_lvalue ? fb_lvalue : fb_rvalue);\n+  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval, fallback);\n   ret = MIN (ret, tret);\n \n   /* If the outermost expression is a COMPONENT_REF, canonicalize its type.  */\n-  if (!want_lvalue && TREE_CODE (*expr_p) == COMPONENT_REF)\n+  if ((fallback & fb_rvalue) && TREE_CODE (*expr_p) == COMPONENT_REF)\n     {\n       canonicalize_component_ref (expr_p);\n       ret = MIN (ret, GS_OK);\n@@ -1806,20 +1804,12 @@ gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n     }\n }\n \n-/*  Gimplify the CALL_EXPR node pointed by EXPR_P.\n-\n-      call_expr\n-\t      : ID '(' arglist ')'\n-\n-      arglist\n-\t      : arglist ',' val\n-\t      | val\n-\n-    PRE_P points to the list where side effects that must happen before\n-\t*EXPR_P should be stored.  */\n+/* Gimplify the CALL_EXPR node pointed by EXPR_P.  PRE_P points to the\n+   list where side effects that must happen before *EXPR_P should be stored.\n+   WANT_VALUE is true if the result of the call is desired.  */\n \n static enum gimplify_status\n-gimplify_call_expr (tree *expr_p, tree *pre_p, bool (*gimple_test_f) (tree))\n+gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n {\n   tree decl;\n   tree arglist;\n@@ -1863,7 +1853,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool (*gimple_test_f) (tree))\n       if (DECL_FUNCTION_CODE (decl) == BUILT_IN_STACK_RESTORE)\n \tgimplify_ctxp->save_stack = false;\n \n-      new = simplify_builtin (*expr_p, gimple_test_f == is_gimple_stmt);\n+      new = simplify_builtin (*expr_p, !want_value);\n \n       if (new && new != *expr_p)\n \t{\n@@ -1887,13 +1877,24 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool (*gimple_test_f) (tree))\n        arglist = TREE_CHAIN (arglist))\n     {\n       enum gimplify_status t;\n+      bool (*test) (tree);\n+      fallback_t fb;\n+\n+      /* In general, we allow lvalues for function arguments to avoid\n+\t extra overhead of copying large aggregates out of even larger\n+\t aggregates into temporaries only to copy the temporaries to\n+\t the argument list.  Make optimizers happy by pulling out to\n+\t temporaries those types that fit in registers.  */\n+      if (is_gimple_reg_type (TREE_TYPE (TREE_VALUE (arglist))))\n+\ttest = is_gimple_val, fb = fb_rvalue;\n+      else\n+\ttest = is_gimple_lvalue, fb = fb_either;\n \n       /* There is a sequence point before a function call.  Side effects in\n \t the argument list must occur before the actual call. So, when\n \t gimplifying arguments, force gimplify_expr to use an internal\n \t post queue which is then appended to the end of PRE_P.  */\n-      t = gimplify_expr (&TREE_VALUE (arglist), pre_p, NULL, is_gimple_val,\n-\t\t\t fb_rvalue);\n+      t = gimplify_expr (&TREE_VALUE (arglist), pre_p, NULL, test, fb);\n \n       if (t == GS_ERROR)\n \tret = GS_ERROR;\n@@ -1904,7 +1905,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool (*gimple_test_f) (tree))\n   /* Try this again in case gimplification exposed something.  */\n   if (ret != GS_ERROR && decl && DECL_BUILT_IN (decl))\n     {\n-      tree new = simplify_builtin (*expr_p, gimple_test_f == is_gimple_stmt);\n+      tree new = simplify_builtin (*expr_p, !want_value);\n \n       if (new && new != *expr_p)\n \t{\n@@ -2334,7 +2335,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, bool want_value)\n   args = tree_cons (NULL, t, args);\n \n   to_ptr = build_fold_addr_expr (to);\n-  args = tree_cons (NULL, to, args);\n+  args = tree_cons (NULL, to_ptr, args);\n   t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n   t = build_function_call_expr (t, args);\n \n@@ -3508,15 +3509,15 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase IMAGPART_EXPR:\n \tcase COMPONENT_REF:\n \t  ret = gimplify_compound_lval (expr_p, pre_p, post_p,\n-\t\t\t\t\tfallback & fb_lvalue);\n+\t\t\t\t\tfallback ? fallback : fb_rvalue);\n \t  break;\n \n \tcase COND_EXPR:\n \t  ret = gimplify_cond_expr (expr_p, pre_p, NULL_TREE);\n \t  break;\n \n \tcase CALL_EXPR:\n-\t  ret = gimplify_call_expr (expr_p, pre_p, gimple_test_f);\n+\t  ret = gimplify_call_expr (expr_p, pre_p, fallback != fb_none);\n \t  break;\n \n \tcase TREE_LIST:\n@@ -3717,7 +3718,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t    enum gimplify_status r0, r1, r2;\n \n \t    r0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t\tis_gimple_min_lval, fb_either);\n+\t\t\t\tis_gimple_lvalue, fb_either);\n \t    r1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n \t\t\t\tis_gimple_val, fb_rvalue);\n \t    r2 = gimplify_expr (&TREE_OPERAND (*expr_p, 2), pre_p, post_p,"}, {"sha": "7e4c14b534814070aede3855f9e871b87b73f24b", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 153, "deletions": 218, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "patch": "@@ -38,175 +38,141 @@ Boston, MA 02111-1307, USA.  */\n \n \thttp://www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html\n \n-   function:\n-     FUNCTION_DECL\n-       DECL_SAVED_TREE -> block\n-   block:\n-     BIND_EXPR\n-       BIND_EXPR_VARS -> DECL chain\n-       BIND_EXPR_BLOCK -> BLOCK\n-       BIND_EXPR_BODY -> compound-stmt\n-   compound-stmt:\n-     COMPOUND_EXPR\n-       op0 -> non-compound-stmt\n-       op1 -> stmt\n-     | EXPR_VEC\n-       (or other alternate solution)\n-   stmt: compound-stmt | non-compound-stmt\n-   non-compound-stmt:\n-     block\n-     | if-stmt\n-     | switch-stmt\n-     | jump-stmt\n-     | label-stmt\n-     | try-stmt\n-     | modify-stmt\n-     | call-stmt\n-   if-stmt:\n-     COND_EXPR\n-       op0 -> condition\n-       op1 -> stmt\n-       op2 -> stmt\n-   switch-stmt:\n-     SWITCH_EXPR\n-       op0 -> val\n-       op1 -> stmt\n-       op2 -> array of case labels (as LABEL_DECLs?)\n-         FIXME: add case value info\n-\tThe SWITCH_LABELS (op2) are sorted in ascending order, and the\n-\tlast label in the vector is always the default case.\n-   jump-stmt:\n-       GOTO_EXPR\n-         op0 -> LABEL_DECL | '*' ID\n-     | RETURN_EXPR\n-         op0 -> NULL_TREE\n-\t      | RESULT_DECL\n-\t      | MODIFY_EXPR -> RESULT_DECL, varname\n-     | THROW_EXPR?  do we need/want such a thing for opts, perhaps\n-         to generate an ERT_THROW region?  I think so.\n-\t Hmm...this would only work at the GIMPLE level, where we know that\n-\t   the call args don't have any EH impact.  Perhaps\n-\t   annotation of the CALL_EXPR would work better.\n-     | RESX_EXPR\n-   label-stmt:\n-     LABEL_EXPR\n-         op0 -> LABEL_DECL\n-     | CASE_LABEL_EXPR\n-         CASE_LOW -> val | NULL_TREE\n-         CASE_HIGH -> val | NULL_TREE\n-\t CASE_LABEL -> LABEL_DECL  FIXME\n-   try-stmt:\n-     TRY_CATCH_EXPR\n-       op0 -> stmt\n-       op1 -> handler\n-     | TRY_FINALLY_EXPR\n-       op0 -> stmt\n-       op1 -> stmt\n-   handler:\n-     catch-seq\n-     | EH_FILTER_EXPR\n-     | stmt\n-   modify-stmt:\n-     MODIFY_EXPR\n-       op0 -> lhs\n-       op1 -> rhs\n-   call-stmt: CALL_EXPR\n-     op0 -> ID | '&' ID | OBJ_TYPE_REF\n-     op1 -> arglist\n-\n-   addr-expr-arg : compref | ID\n-   lhs: addr-expr-arg | '*' ID | bitfieldref\n-   min-lval: ID | '*' ID\n-   bitfieldref :\n-     BIT_FIELD_REF\n-       op0 -> inner_compref\n-       op1 -> CONST\n-       op2 -> var\n-   compref :\n-     COMPONENT_REF\n-       op0 -> inner_compref\n-     | ARRAY_REF\n-       op0 -> inner_compref\n-       op1 -> val\n-       op2 -> val\n-       op3 -> val\n-     | ARRAY_RANGE_REF\n-       op0 -> inner_compref\n-       op1 -> val\n-       op2 -> val\n-       op3 -> val\n-     | REALPART_EXPR\n-       op0 -> inner_compref\n-     | IMAGPART_EXPR\n-       op0 -> inner_compref\n-\n-   inner_compref : compref | min_lval\n-     | VIEW_CONVERT_EXPR\n-       op0 -> inner_compref\n-     | NOP_EXPR\n-       op0 -> inner_compref\n-     | CONVERT_EXPR\n-       op0 -> inner_compref\n-\n-   condition : val | val relop val\n-   val : ID | CONST\n-\n-   rhs        : varname | CONST\n-\t      | '*' ID\n-\t      | '&' addr-expr-arg\n-\t      | call_expr\n-\t      | unop val\n-\t      | val binop val\n-\t      | '(' cast ')' val\n-\t      | method_ref\n-\n-\t      (cast here stands for all valid C typecasts)\n-\n-      unop\n-\t      : '+'\n-\t      | '-'\n-\t      | '!'\n-\t      | '~'\n-\n-      binop\n-\t      : relop | '-'\n-\t      | '+'\n-\t      | '/'\n-\t      | '*'\n-\t      | '%'\n-\t      | '&'\n-\t      | '|'\n-\t      | '<<'\n-\t      | '>>'\n-\t      | '^'\n-\n-      relop\n-\t      : '<'\n-\t      | '<='\n-\t      | '>'\n-\t      | '>='\n-\t      | '=='\n-\t      | '!='\n-\n+   function\t: FUNCTION_DECL\n+\t\t\tDECL_SAVED_TREE -> compound-stmt\n+\n+   compound-stmt: STATEMENT_LIST\n+\t\t\tmembers -> stmt\n+\n+   stmt\t\t: block\n+\t\t| if-stmt\n+\t\t| switch-stmt\n+\t\t| goto-stmt\n+\t\t| return-stmt\n+\t\t| resx-stmt\n+\t\t| label-stmt\n+\t\t| try-stmt\n+\t\t| modify-stmt\n+\t\t| call-stmt\n+\n+   block\t: BIND_EXPR\n+\t\t\tBIND_EXPR_VARS -> chain of DECLs\n+\t\t\tBIND_EXPR_BLOCK -> BLOCK\n+\t\t\tBIND_EXPR_BODY -> compound-stmt\n+\n+   if-stmt\t: COND_EXPR\n+\t\t\top0 -> condition\n+\t\t\top1 -> compound-stmt\n+\t\t\top2 -> compound-stmt\n+\n+   switch-stmt\t: SWITCH_EXPR\n+\t\t\top0 -> val\n+\t\t\top1 -> NULL\n+\t\t\top2 -> TREE_VEC of CASE_LABEL_EXPRs\n+\t\t\t    The CASE_LABEL_EXPRs are sorted by CASE_LOW,\n+\t\t\t    and default is last.\n+\n+   goto-stmt\t: GOTO_EXPR\n+\t\t\top0 -> LABEL_DECL | val\n+\n+   return-stmt\t: RETURN_EXPR\n+\t\t\top0 -> return-value\n+\n+   return-value\t: NULL\n+\t\t| RESULT_DECL\n+\t\t| MODIFY_EXPR\n+\t\t\top0 -> RESULT_DECL\n+\t\t\top1 -> lhs\n+\n+   resx-stmt\t: RESX_EXPR\n+\n+   label-stmt\t: LABEL_EXPR\n+\t\t\top0 -> LABEL_DECL\n+\n+   try-stmt\t: TRY_CATCH_EXPR\n+\t\t\top0 -> compound-stmt\n+\t\t\top1 -> handler\n+\t\t| TRY_FINALLY_EXPR\n+\t\t\top0 -> compound-stmt\n+\t\t\top1 -> compound-stmt\n+\n+   handler\t: catch-seq\n+\t\t| EH_FILTER_EXPR\n+\t\t| compound-stmt\n+\n+   catch-seq\t: STATEMENT_LIST\n+\t\t\tmembers -> CATCH_EXPR\n+\n+   modify-stmt\t: MODIFY_EXPR\n+\t\t\top0 -> lhs\n+\t\t\top1 -> rhs\n+\n+   call-stmt\t: CALL_EXPR\n+\t\t\top0 -> val | OBJ_TYPE_REF\n+\t\t\top1 -> call-arg-list\n+\n+   call-arg-list: TREE_LIST\n+\t\t\tmembers -> lhs\n+\n+   addr-expr-arg: ID\n+\t\t| compref\n+\n+   lhs\t\t: addr-expr-arg\n+\t\t| '*' val\n+\t\t| bitfieldref\n+\n+   min-lval\t: ID\n+\t\t| '*' val\n+\n+   bitfieldref\t: BIT_FIELD_REF\n+\t\t\top0 -> inner-compref\n+\t\t\top1 -> CONST\n+\t\t\top2 -> var\n+\n+   compref\t: inner-compref\n+\t\t| REALPART_EXPR\n+\t\t\top0 -> inner-compref\n+\t\t| IMAGPART_EXPR\n+\t\t\top0 -> inner-compref\n+\n+   inner-compref: min-lval\n+\t\t| COMPONENT_REF\n+\t\t\top0 -> inner-compref\n+\t\t\top1 -> FIELD_DECL\n+\t\t\top2 -> val\n+\t\t| ARRAY_REF\n+\t\t\top0 -> inner-compref\n+\t\t\top1 -> val\n+\t\t\top2 -> val\n+\t\t\top3 -> val\n+\t\t| ARRAY_RANGE_REF\n+\t\t\top0 -> inner-compref\n+\t\t\top1 -> val\n+\t\t\top2 -> val\n+\t\t\top3 -> val\n+\t\t| VIEW_CONVERT_EXPR\n+\t\t\top0 -> inner-compref\n+\n+   condition\t: val\n+\t\t| val RELOP val\n+\n+   val\t\t: ID\n+\t\t| CONST\n+\n+   rhs\t\t: lhs\n+\t\t| CONST\n+\t\t| '&' addr-expr-arg\n+\t\t| call_expr\n+\t\t| UNOP val\n+\t\t| val BINOP val\n+\t\t| val RELOP val\n */\n \n static inline bool is_gimple_id (tree);\n \n /* Validation of GIMPLE expressions.  */\n \n-/* Return nonzero if T is a GIMPLE RHS:\n-\n-      rhs     : varname | CONST\n-\t      | '*' ID\n-\t      | '&' varname_or_temp\n-\t      | call_expr\n-\t      | unop val\n-\t      | val binop val\n-\t      | '(' cast ')' val\n-\t      | <CONSTRUCTOR <gimple_val ...>>\n-\n-   The last option is only valid GIMPLE for vector and complex types;\n-   aggregate types should have their constructors decomposed.  */\n+/* Return true if T is a GIMPLE RHS.  */\n \n bool\n is_gimple_rhs (tree t)\n@@ -218,7 +184,7 @@ is_gimple_rhs (tree t)\n     case '1':\n     case '2':\n     case '<':\n-      return 1;\n+      return true;\n \n     default:\n       break;\n@@ -242,19 +208,16 @@ is_gimple_rhs (tree t)\n     case COMPLEX_CST:\n     case VECTOR_CST:\n     case OBJ_TYPE_REF:\n-      return 1;\n+      return true;\n \n     default:\n       break;\n     }\n \n-  if (is_gimple_lvalue (t) || is_gimple_val (t))\n-    return 1;\n-\n-  return 0;\n+  return is_gimple_lvalue (t) || is_gimple_val (t);\n }\n \n-/* Returns nonzero if T is a valid CONSTRUCTOR component in GIMPLE, either\n+/* Returns true if T is a valid CONSTRUCTOR component in GIMPLE, either\n    a val or another CONSTRUCTOR.  */\n \n bool\n@@ -264,7 +227,7 @@ is_gimple_constructor_elt (tree t)\n \t  || TREE_CODE (t) == CONSTRUCTOR);\n }\n \n-/*  Return nonzero if T is a valid LHS for a GIMPLE assignment expression.  */\n+/*  Return true if T is a valid LHS for a GIMPLE assignment expression.  */\n \n bool\n is_gimple_lvalue (tree t)\n@@ -276,12 +239,7 @@ is_gimple_lvalue (tree t)\n \t  || TREE_CODE (t) == BIT_FIELD_REF);\n }\n \n-\n-/*  Return nonzero if T is a GIMPLE condition:\n-\n-      condexpr\n-\t      : val\n-\t      | val relop val  */\n+/*  Return true if T is a GIMPLE condition.  */\n \n bool\n is_gimple_condexpr (tree t)\n@@ -290,13 +248,7 @@ is_gimple_condexpr (tree t)\n \t  || TREE_CODE_CLASS (TREE_CODE (t)) == '<');\n }\n \n-\n-/*  Return nonzero if T is a valid operand for '&':\n-\n-      varname\n-\t      : arrayref\n-\t      | compref\n-\t      | ID     */\n+/*  Return true if T is a valid operand for ADDR_EXPR.  */\n \n bool\n is_gimple_addr_expr_arg (tree t)\n@@ -310,7 +262,7 @@ is_gimple_addr_expr_arg (tree t)\n \t  || TREE_CODE (t) == INDIRECT_REF);\n }\n \n-/* Return nonzero if T is function invariant.  Or rather a restricted\n+/* Return true if T is function invariant.  Or rather a restricted\n    form of function invariant.  */\n \n bool\n@@ -333,7 +285,7 @@ is_gimple_min_invariant (tree t)\n     }\n }\n \n-/* Return nonzero if T looks like a valid GIMPLE statement.  */\n+/* Return true if T looks like a valid GIMPLE statement.  */\n \n bool\n is_gimple_stmt (tree t)\n@@ -364,25 +316,23 @@ is_gimple_stmt (tree t)\n     case PHI_NODE:\n     case STATEMENT_LIST:\n       /* These are always void.  */\n-      return 1;\n+      return true;\n \n     case VA_ARG_EXPR:\n       /* FIXME this should be lowered.  */\n-      return 1;\n+      return true;\n \n-    case COMPOUND_EXPR:\n-      /* FIXME should we work harder to make COMPOUND_EXPRs void?  */\n     case CALL_EXPR:\n     case MODIFY_EXPR:\n       /* These are valid regardless of their type.  */\n-      return 1;\n+      return true;\n \n     default:\n-      return 0;\n+      return false;\n     }\n }\n \n-/* Return nonzero if T is a variable.  */\n+/* Return true if T is a variable.  */\n \n bool\n is_gimple_variable (tree t)\n@@ -393,7 +343,7 @@ is_gimple_variable (tree t)\n \t  || TREE_CODE (t) == SSA_NAME);\n }\n \n-/*  Return nonzero if T is a GIMPLE identifier (something with an address).  */\n+/*  Return true if T is a GIMPLE identifier (something with an address).  */\n \n static inline bool\n is_gimple_id (tree t)\n@@ -405,8 +355,7 @@ is_gimple_id (tree t)\n \t  || TREE_CODE (t) == STRING_CST);\n }\n \n-/* Return nonzero if TYPE is a suitable type for a scalar register\n-   variable.  */\n+/* Return true if TYPE is a suitable type for a scalar register variable.  */\n \n bool\n is_gimple_reg_type (tree type)\n@@ -416,7 +365,7 @@ is_gimple_reg_type (tree type)\n }\n \n \n-/* Return nonzero if T is a scalar register variable.  */\n+/* Return true if T is a scalar register variable.  */\n \n bool\n is_gimple_reg (tree t)\n@@ -433,7 +382,7 @@ is_gimple_reg (tree t)\n \t  && ! needs_to_live_in_memory (t));\n }\n \n-/* Return nonzero if T is a GIMPLE variable whose address is not needed.  */\n+/* Return true if T is a GIMPLE variable whose address is not needed.  */\n \n bool\n is_gimple_non_addressable (tree t)\n@@ -446,8 +395,7 @@ is_gimple_non_addressable (tree t)\n \t  && ! needs_to_live_in_memory (t));\n }\n \n-/*  Return nonzero if T is a GIMPLE rvalue, i.e. an identifier or a\n-    constant.  */\n+/* Return true if T is a GIMPLE rvalue, i.e. an identifier or a constant.  */\n \n bool\n is_gimple_val (tree t)\n@@ -456,7 +404,7 @@ is_gimple_val (tree t)\n   if (is_gimple_variable (t)\n       && is_gimple_reg_type (TREE_TYPE (t))\n       && !is_gimple_reg (t))\n-    return 0;\n+    return false;\n \n   /* FIXME make these decls.  That can happen only when we expose the\n      entire landing-pad construct at the tree level.  */\n@@ -467,12 +415,7 @@ is_gimple_val (tree t)\n }\n \n \n-/*  Return true if T is a GIMPLE minimal lvalue, of the form\n-\n-    min_lval: ID | '(' '*' ID ')'\n-\n-    This never actually appears in the original SIMPLE grammar, but is\n-    repeated in several places.  */\n+/* Return true if T is a GIMPLE minimal lvalue.  */\n \n bool\n is_gimple_min_lval (tree t)\n@@ -481,8 +424,7 @@ is_gimple_min_lval (tree t)\n \t  || TREE_CODE (t) == INDIRECT_REF);\n }\n \n-/*  Return nonzero if T is a typecast operation of the form\n-    '(' cast ')' val.  */\n+/* Return true if T is a typecast operation.  */\n \n bool\n is_gimple_cast (tree t)\n@@ -510,17 +452,10 @@ is_gimple_call_addr (tree t)\n tree\n get_call_expr_in (tree t)\n {\n+  if (TREE_CODE (t) == MODIFY_EXPR)\n+    t = TREE_OPERAND (t, 1);\n   if (TREE_CODE (t) == CALL_EXPR)\n     return t;\n-  else if (TREE_CODE (t) == MODIFY_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (t, 1)) == CALL_EXPR)\n-    return TREE_OPERAND (t, 1);\n-  else if (TREE_CODE (t) == RETURN_EXPR\n-           && TREE_OPERAND (t, 0)\n-\t   && TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 1)) == CALL_EXPR)\n-    return TREE_OPERAND (TREE_OPERAND (t, 0), 1);\n-\n   return NULL_TREE;\n }\n "}, {"sha": "5395c67667c341003d8bd3a130cbb0699caf7f58", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90051e16b4f20a16a4c59e8fc706cbfff6f4c484/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=90051e16b4f20a16a4c59e8fc706cbfff6f4c484", "patch": "@@ -74,7 +74,7 @@ extern bool is_gimple_constructor_elt (tree);\n extern bool is_gimple_non_addressable (tree t);\n \n /* Returns true iff T is a valid call address expression.  */\n-bool is_gimple_call_addr (tree);\n+extern bool is_gimple_call_addr (tree);\n /* If T makes a function call, returns the CALL_EXPR operand.  */\n extern tree get_call_expr_in (tree t);\n "}]}