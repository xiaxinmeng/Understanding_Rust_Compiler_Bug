{"sha": "bcf4065c909bd1010208117633ca9ff84cd7b38e", "node_id": "C_kwDOANBUbNoAKGJjZjQwNjVjOTA5YmQxMDEwMjA4MTE3NjMzY2E5ZmY4NGNkN2IzOGU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-05T09:10:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-05T13:34:42Z"}, "message": "Split vector loop analysis into main and epilogue analysis\n\nAs discussed this splits the analysis loop into two, first settling\non a vector mode used for the main loop and only then analyzing\nthe epilogue of that for possible vectorization.  That makes it\neasier to put in support for unrolled main loops.\n\nOn the way I've realized some cleanup opportunities, namely caching\nn_stmts in vec_info_shared (it's computed by dataref analysis)\navoiding to pass that around and setting/clearing loop->aux\nduring analysis - try_vectorize_loop_1 will ultimatively set it\non those we vectorize.\n\nThis also gets rid of the previously introduced callback in\nvect_analyze_loop_1 in favor of making that advance the mode iterator.\nI'm now pushing VOIDmode explicitely into the vector_modes array\nwhich makes the re-start on the epilogue side a bit more\nstraight-forward.  Note that will now use auto-detection of the\nvector mode in case the main loop used it and we want to try\nLOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P and the first mode from\nthe target array if not.  I've added a comment that says we may\nwant to make sure we don't try vectorizing the epilogue with a\nbigger vector size than the main loop but the situation isn't\nvery likely to appear in practice I guess (and it was also present\nbefore this change).\n\nIn principle this change should not change vectorization decisions\nbut the way we handled re-analyzing epilogues as main loops makes\nme only 99% sure that it does.\n\n2021-11-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vec_info_shared::n_stmts): Add.\n\t(LOOP_VINFO_N_STMTS): Likewise.\n\t(vec_info_for_bb): Remove unused function.\n\t* tree-vectorizer.c (vec_info_shared::vec_info_shared):\n\tInitialize n_stmts member.\n\t* tree-vect-loop.c: Remove INCLUDE_FUNCTIONAL.\n\t(vect_create_loop_vinfo): Do not set loop->aux.\n\t(vect_analyze_loop_2): Do not get n_stmts as argument,\n\tinstead use LOOP_VINFO_N_STMTS.  Set LOOP_VINFO_VECTORIZABLE_P\n\there.\n\t(vect_analyze_loop_1): Remove callback, get the mode iterator\n\tand autodetected_vector_mode as argument, advancing the\n\titerator and initializing autodetected_vector_mode here.\n\t(vect_analyze_loop): Split analysis loop into two, first\n\tprocessing main loops only and then epilogues.", "tree": {"sha": "5871261e2d1a8bffc0aca69062c111cd21b39259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5871261e2d1a8bffc0aca69062c111cd21b39259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcf4065c909bd1010208117633ca9ff84cd7b38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf4065c909bd1010208117633ca9ff84cd7b38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf4065c909bd1010208117633ca9ff84cd7b38e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf4065c909bd1010208117633ca9ff84cd7b38e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea42c80585b831fc4f7a0b2576a3d8d3244d8d32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea42c80585b831fc4f7a0b2576a3d8d3244d8d32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea42c80585b831fc4f7a0b2576a3d8d3244d8d32"}], "stats": {"total": 428, "additions": 212, "deletions": 216}, "files": [{"sha": "abf87f99d6d4a18a50c4499fc8cccc8dc3ff814b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 206, "deletions": 209, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf4065c909bd1010208117633ca9ff84cd7b38e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf4065c909bd1010208117633ca9ff84cd7b38e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bcf4065c909bd1010208117633ca9ff84cd7b38e", "patch": "@@ -20,7 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #define INCLUDE_ALGORITHM\n-#define INCLUDE_FUNCTIONAL\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -1520,8 +1519,6 @@ vect_create_loop_vinfo (class loop *loop, vec_info_shared *shared,\n \t  = wi::smin (nit, param_vect_inner_loop_cost_factor).to_uhwi ();\n     }\n \n-  gcc_assert (!loop->aux);\n-  loop->aux = loop_vinfo;\n   return loop_vinfo;\n }\n \n@@ -2209,7 +2206,7 @@ vect_determine_partial_vectors_and_peeling (loop_vec_info loop_vinfo,\n    for it.  The different analyses will record information in the\n    loop_vec_info struct.  */\n static opt_result\n-vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n+vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n {\n   opt_result ok = opt_result::success ();\n   int res;\n@@ -2244,7 +2241,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       opt_result res\n \t= vect_get_datarefs_in_loop (loop, LOOP_VINFO_BBS (loop_vinfo),\n \t\t\t\t     &LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t\t\t\t     n_stmts);\n+\t\t\t\t     &LOOP_VINFO_N_STMTS (loop_vinfo));\n       if (!res)\n \t{\n \t  if (dump_enabled_p ())\n@@ -2341,7 +2338,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   poly_uint64 saved_vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, *n_stmts);\n+  ok = vect_analyze_slp (loop_vinfo, LOOP_VINFO_N_STMTS (loop_vinfo));\n   if (!ok)\n     return ok;\n \n@@ -2641,6 +2638,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t\tLOOP_VINFO_VECT_FACTOR (loop_vinfo)));\n \n   /* Ok to vectorize!  */\n+  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n   return opt_result::success ();\n \n again:\n@@ -2891,46 +2889,70 @@ vect_joust_loop_vinfos (loop_vec_info new_loop_vinfo,\n   return true;\n }\n \n-/* Analyze LOOP with VECTOR_MODE and as epilogue if MAIN_LOOP_VINFO is\n-   not NULL.  Process the analyzed loop with PROCESS even if analysis\n-   failed.  Sets *N_STMTS and FATAL according to the analysis.\n+/* Analyze LOOP with VECTOR_MODES[MODE_I] and as epilogue if MAIN_LOOP_VINFO is\n+   not NULL.  Set AUTODETECTED_VECTOR_MODE if VOIDmode and advance\n+   MODE_I to the next mode useful to analyze.\n    Return the loop_vinfo on success and wrapped null on failure.  */\n \n static opt_loop_vec_info\n vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n \t\t     const vect_loop_form_info *loop_form_info,\n-\t\t     machine_mode vector_mode, loop_vec_info main_loop_vinfo,\n-\t\t     unsigned int *n_stmts, bool &fatal,\n-\t\t     std::function<void(loop_vec_info)> process = nullptr)\n+\t\t     loop_vec_info main_loop_vinfo,\n+\t\t     const vector_modes &vector_modes, unsigned &mode_i,\n+\t\t     machine_mode &autodetected_vector_mode,\n+\t\t     bool &fatal)\n {\n   loop_vec_info loop_vinfo\n     = vect_create_loop_vinfo (loop, shared, loop_form_info);\n-  loop_vinfo->vector_mode = vector_mode;\n-\n   if (main_loop_vinfo)\n     LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = main_loop_vinfo;\n \n+  machine_mode vector_mode = vector_modes[mode_i];\n+  loop_vinfo->vector_mode = vector_mode;\n+\n   /* Run the main analysis.  */\n-  fatal = false;\n-  opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal, n_stmts);\n-  loop->aux = NULL;\n+  opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal);\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"***** Analysis %s with vector mode %s\\n\",\n+\t\t     res ? \"succeeded\" : \" failed\",\n+\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n \n-  /* Process info before we destroy loop_vinfo upon analysis failure\n-     when there was no fatal failure.  */\n-  if (!fatal && process)\n-    process (loop_vinfo);\n+  /* Remember the autodetected vector mode.  */\n+  if (vector_mode == VOIDmode)\n+    autodetected_vector_mode = loop_vinfo->vector_mode;\n \n-  if (dump_enabled_p ())\n+  /* Advance mode_i, first skipping modes that would result in the\n+     same analysis result.  */\n+  while (mode_i + 1 < vector_modes.length ()\n+\t && vect_chooses_same_modes_p (loop_vinfo,\n+\t\t\t\t       vector_modes[mode_i + 1]))\n     {\n-      if (res)\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Analysis succeeded with vector mode %s\\n\",\n-\t\t\t GET_MODE_NAME (loop_vinfo->vector_mode));\n-      else\n+\t\t\t \"***** The result for vector mode %s would\"\n+\t\t\t \" be the same\\n\",\n+\t\t\t GET_MODE_NAME (vector_modes[mode_i + 1]));\n+      mode_i += 1;\n+    }\n+  if (mode_i + 1 < vector_modes.length ()\n+      && VECTOR_MODE_P (autodetected_vector_mode)\n+      && (related_vector_mode (vector_modes[mode_i + 1],\n+\t\t\t       GET_MODE_INNER (autodetected_vector_mode))\n+\t  == autodetected_vector_mode)\n+      && (related_vector_mode (autodetected_vector_mode,\n+\t\t\t       GET_MODE_INNER (vector_modes[mode_i + 1]))\n+\t  == vector_modes[mode_i + 1]))\n+    {\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Analysis failed with vector mode %s\\n\",\n-\t\t\t GET_MODE_NAME (loop_vinfo->vector_mode));\n+\t\t\t \"***** Skipping vector mode %s, which would\"\n+\t\t\t \" repeat the analysis for %s\\n\",\n+\t\t\t GET_MODE_NAME (vector_modes[mode_i + 1]),\n+\t\t\t GET_MODE_NAME (autodetected_vector_mode));\n+      mode_i += 1;\n     }\n+  mode_i++;\n \n   if (!res)\n     {\n@@ -2940,7 +2962,6 @@ vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n       return opt_loop_vec_info::propagate_failure (res);\n     }\n \n-  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n   return opt_loop_vec_info::success (loop_vinfo);\n }\n \n@@ -2952,14 +2973,6 @@ vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n opt_loop_vec_info\n vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n {\n-  auto_vector_modes vector_modes;\n-\n-  /* Autodetect first vector size we try.  */\n-  unsigned int autovec_flags\n-    = targetm.vectorize.autovectorize_vector_modes (&vector_modes,\n-\t\t\t\t\t\t    loop->simdlen != 0);\n-  unsigned int mode_i = 0;\n-\n   DUMP_VECT_SCOPE (\"analyze_loop_nest\");\n \n   if (loop_outer (loop)\n@@ -2985,70 +2998,59 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n       return opt_loop_vec_info::propagate_failure (res);\n     }\n \n-  unsigned n_stmts = 0;\n-  machine_mode autodetected_vector_mode = VOIDmode;\n-  opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-  machine_mode next_vector_mode = VOIDmode;\n-  poly_uint64 lowest_th = 0;\n-  bool pick_lowest_cost_p = ((autovec_flags & VECT_COMPARE_COSTS)\n-\t\t\t     && !unlimited_cost_model (loop));\n+  /* When pick_lowest_cost_p is true, we should in principle iterate\n+     over all the loop_vec_infos that LOOP_VINFO could replace and\n+     try to vectorize LOOP_VINFO under the same conditions.\n+     E.g. when trying to replace an epilogue loop, we should vectorize\n+     LOOP_VINFO as an epilogue loop with the same VF limit.  When trying\n+     to replace the main loop, we should vectorize LOOP_VINFO as a main\n+     loop too.\n \n-  bool vect_epilogues = false;\n-  unsigned HOST_WIDE_INT simdlen = loop->simdlen;\n-  while (1)\n-    {\n-      /* When pick_lowest_cost_p is true, we should in principle iterate\n-\t over all the loop_vec_infos that LOOP_VINFO could replace and\n-\t try to vectorize LOOP_VINFO under the same conditions.\n-\t E.g. when trying to replace an epilogue loop, we should vectorize\n-\t LOOP_VINFO as an epilogue loop with the same VF limit.  When trying\n-\t to replace the main loop, we should vectorize LOOP_VINFO as a main\n-\t loop too.\n+     However, autovectorize_vector_modes is usually sorted as follows:\n \n-\t However, autovectorize_vector_modes is usually sorted as follows:\n+     - Modes that naturally produce lower VFs usually follow modes that\n+     naturally produce higher VFs.\n \n-\t - Modes that naturally produce lower VFs usually follow modes that\n-\t   naturally produce higher VFs.\n+     - When modes naturally produce the same VF, maskable modes\n+     usually follow unmaskable ones, so that the maskable mode\n+     can be used to vectorize the epilogue of the unmaskable mode.\n \n-\t - When modes naturally produce the same VF, maskable modes\n-\t   usually follow unmaskable ones, so that the maskable mode\n-\t   can be used to vectorize the epilogue of the unmaskable mode.\n+     This order is preferred because it leads to the maximum\n+     epilogue vectorization opportunities.  Targets should only use\n+     a different order if they want to make wide modes available while\n+     disparaging them relative to earlier, smaller modes.  The assumption\n+     in that case is that the wider modes are more expensive in some\n+     way that isn't reflected directly in the costs.\n \n-\t This order is preferred because it leads to the maximum\n-\t epilogue vectorization opportunities.  Targets should only use\n-\t a different order if they want to make wide modes available while\n-\t disparaging them relative to earlier, smaller modes.  The assumption\n-\t in that case is that the wider modes are more expensive in some\n-\t way that isn't reflected directly in the costs.\n+     There should therefore be few interesting cases in which\n+     LOOP_VINFO fails when treated as an epilogue loop, succeeds when\n+     treated as a standalone loop, and ends up being genuinely cheaper\n+     than FIRST_LOOP_VINFO.  */\n \n-\t There should therefore be few interesting cases in which\n-\t LOOP_VINFO fails when treated as an epilogue loop, succeeds when\n-\t treated as a standalone loop, and ends up being genuinely cheaper\n-\t than FIRST_LOOP_VINFO.  */\n+  auto_vector_modes vector_modes;\n+  /* Autodetect first vector size we try.  */\n+  vector_modes.safe_push (VOIDmode);\n+  unsigned int autovec_flags\n+    = targetm.vectorize.autovectorize_vector_modes (&vector_modes,\n+\t\t\t\t\t\t    loop->simdlen != 0);\n+  bool pick_lowest_cost_p = ((autovec_flags & VECT_COMPARE_COSTS)\n+\t\t\t     && !unlimited_cost_model (loop));\n+  machine_mode autodetected_vector_mode = VOIDmode;\n+  opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+  unsigned int mode_i = 0;\n+  unsigned int first_loop_i = 0;\n+  unsigned int first_loop_next_i = 0;\n+  unsigned HOST_WIDE_INT simdlen = loop->simdlen;\n \n+  /* First determine the main loop vectorization mode.  */\n+  while (1)\n+    {\n+      unsigned int loop_vinfo_i = mode_i;\n       bool fatal;\n-      auto cb = [&] (loop_vec_info loop_vinfo)\n-\t{\n-\t  if (mode_i == 0)\n-\t    autodetected_vector_mode = loop_vinfo->vector_mode;\n-\t  while (mode_i < vector_modes.length ()\n-\t\t && vect_chooses_same_modes_p (loop_vinfo,\n-\t\t\t\t\t       vector_modes[mode_i]))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"***** The result for vector mode %s would\"\n-\t\t\t\t \" be the same\\n\",\n-\t\t\t\t GET_MODE_NAME (vector_modes[mode_i]));\n-\t      mode_i += 1;\n-\t    }\n-\t};\n       opt_loop_vec_info loop_vinfo\n \t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n-\t\t\t       next_vector_mode,\n-\t\t\t       vect_epilogues\n-\t\t\t       ? (loop_vec_info)first_loop_vinfo : NULL,\n-\t\t\t       &n_stmts, fatal, cb);\n+\t\t\t       NULL, vector_modes, mode_i,\n+\t\t\t       autodetected_vector_mode, fatal);\n       if (fatal)\n \tbreak;\n \n@@ -3061,10 +3063,107 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t    {\n \t      delete first_loop_vinfo;\n \t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t      LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = NULL;\n \t      simdlen = 0;\n \t    }\n \t  else if (pick_lowest_cost_p && first_loop_vinfo)\n+\t    {\n+\t      /* Keep trying to roll back vectorization attempts while the\n+\t\t loop_vec_infos they produced were worse than this one.  */\n+\t      if (vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n+\t\t{\n+\t\t  delete first_loop_vinfo;\n+\t\t  first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t\t}\n+\t    }\n+\t  if (first_loop_vinfo == NULL)\n+\t    {\n+\t      first_loop_vinfo = loop_vinfo;\n+\t      first_loop_i = loop_vinfo_i;\n+\t      first_loop_next_i = mode_i;\n+\t    }\n+\t  else\n+\t    {\n+\t      delete loop_vinfo;\n+\t      loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t    }\n+\n+\t  /* Commit to first_loop_vinfo if we have no reason to try\n+\t     alternatives.  */\n+\t  if (!simdlen && !pick_lowest_cost_p)\n+\t    break;\n+\t}\n+      if (mode_i == vector_modes.length ()\n+\t  || autodetected_vector_mode == VOIDmode)\n+\tbreak;\n+\n+      /* Try the next biggest vector size.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis with vector mode %s\\n\",\n+\t\t\t GET_MODE_NAME (vector_modes[mode_i]));\n+    }\n+  if (!first_loop_vinfo)\n+    return opt_loop_vec_info::propagate_failure (res);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"***** Choosing vector mode %s\\n\",\n+\t\t     GET_MODE_NAME (first_loop_vinfo->vector_mode));\n+\n+  /* Only vectorize epilogues if PARAM_VECT_EPILOGUES_NOMASK is\n+     enabled, SIMDUID is not set, it is the innermost loop and we have\n+     either already found the loop's SIMDLEN or there was no SIMDLEN to\n+     begin with.\n+     TODO: Enable epilogue vectorization for loops with SIMDUID set.  */\n+  bool vect_epilogues = (!simdlen\n+\t\t\t && loop->inner == NULL\n+\t\t\t && param_vect_epilogues_nomask\n+\t\t\t && LOOP_VINFO_PEELING_FOR_NITER (first_loop_vinfo)\n+\t\t\t && !loop->simduid);\n+  if (!vect_epilogues)\n+    return first_loop_vinfo;\n+\n+  /* Now analyze first_loop_vinfo for epilogue vectorization.  */\n+  poly_uint64 lowest_th = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n+\n+  /* Handle the case that the original loop can use partial\n+     vectorization, but want to only adopt it for the epilogue.\n+     The retry should be in the same mode as original.  */\n+  if (LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (first_loop_vinfo))\n+    {\n+      gcc_assert (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (first_loop_vinfo)\n+\t\t  && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (first_loop_vinfo));\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Re-trying analysis with same vector mode\"\n+\t\t\t \" %s for epilogue with partial vectors.\\n\",\n+\t\t\t GET_MODE_NAME (first_loop_vinfo->vector_mode));\n+      mode_i = first_loop_i;\n+    }\n+  else\n+    {\n+      mode_i = first_loop_next_i;\n+      if (mode_i == vector_modes.length ())\n+\treturn first_loop_vinfo;\n+    }\n+\n+  /* ???  If first_loop_vinfo was using VOIDmode then we probably\n+     want to instead search for the corresponding mode in vector_modes[].  */\n+\n+  while (1)\n+    {\n+      bool fatal;\n+      opt_loop_vec_info loop_vinfo\n+\t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n+\t\t\t       first_loop_vinfo,\n+\t\t\t       vector_modes, mode_i,\n+\t\t\t       autodetected_vector_mode, fatal);\n+      if (fatal)\n+\tbreak;\n+\n+      if (loop_vinfo)\n+\t{\n+\t  if (pick_lowest_cost_p)\n \t    {\n \t      /* Keep trying to roll back vectorization attempts while the\n \t\t loop_vec_infos they produced were worse than this one.  */\n@@ -3075,59 +3174,9 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t\t  gcc_assert (vect_epilogues);\n \t\t  delete vinfos.pop ();\n \t\t}\n-\t      if (vinfos.is_empty ()\n-\t\t  && vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n-\t\t{\n-\t\t  if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n-\t\t    {\n-\t\t      delete first_loop_vinfo;\n-\t\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (dump_enabled_p ())\n-\t\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t \"***** Reanalyzing as a main loop \"\n-\t\t\t\t\t \"with vector mode %s\\n\",\n-\t\t\t\t\t GET_MODE_NAME\n-\t\t\t\t\t   (loop_vinfo->vector_mode));\n-\t\t      opt_loop_vec_info main_loop_vinfo\n-\t\t\t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n-\t\t\t\t\t       loop_vinfo->vector_mode,\n-\t\t\t\t\t       NULL, &n_stmts, fatal);\n-\t\t      if (main_loop_vinfo\n-\t\t\t  && vect_joust_loop_vinfos (main_loop_vinfo,\n-\t\t\t\t\t\t     first_loop_vinfo))\n-\t\t\t{\n-\t\t\t  delete first_loop_vinfo;\n-\t\t\t  first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t\t\t  delete loop_vinfo;\n-\t\t\t  loop_vinfo\n-\t\t\t    = opt_loop_vec_info::success (main_loop_vinfo);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (dump_enabled_p ())\n-\t\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t     \"***** No longer preferring vector\"\n-\t\t\t\t\t     \" mode %s after reanalyzing the \"\n-\t\t\t\t\t     \" loop as a main loop\\n\",\n-\t\t\t\t\t     GET_MODE_NAME\n-\t\t\t\t\t       (loop_vinfo->vector_mode));\n-\t\t\t  delete main_loop_vinfo;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n \t    }\n-\n-\t  if (first_loop_vinfo == NULL)\n-\t    {\n-\t      first_loop_vinfo = loop_vinfo;\n-\t      lowest_th = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n-\t    }\n-\t  else if (vect_epilogues\n-\t\t   /* For now only allow one epilogue loop.  */\n-\t\t   && first_loop_vinfo->epilogue_vinfos.is_empty ())\n+\t  /* For now only allow one epilogue loop.  */\n+\t  if (first_loop_vinfo->epilogue_vinfos.is_empty ())\n \t    {\n \t      first_loop_vinfo->epilogue_vinfos.safe_push (loop_vinfo);\n \t      poly_uint64 th = LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo);\n@@ -3144,86 +3193,34 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t      loop_vinfo = opt_loop_vec_info::success (NULL);\n \t    }\n \n-\t  /* Only vectorize epilogues if PARAM_VECT_EPILOGUES_NOMASK is\n-\t     enabled, SIMDUID is not set, it is the innermost loop and we have\n-\t     either already found the loop's SIMDLEN or there was no SIMDLEN to\n-\t     begin with.\n-\t     TODO: Enable epilogue vectorization for loops with SIMDUID set.  */\n-\t  vect_epilogues = (!simdlen\n-\t\t\t    && loop->inner == NULL\n-\t\t\t    && param_vect_epilogues_nomask\n-\t\t\t    && LOOP_VINFO_PEELING_FOR_NITER (first_loop_vinfo)\n-\t\t\t    && !loop->simduid\n-\t\t\t    /* For now only allow one epilogue loop, but allow\n-\t\t\t       pick_lowest_cost_p to replace it.  */\n-\t\t\t    && (first_loop_vinfo->epilogue_vinfos.is_empty ()\n-\t\t\t\t|| pick_lowest_cost_p));\n-\n-\t  /* Commit to first_loop_vinfo if we have no reason to try\n-\t     alternatives.  */\n-\t  if (!simdlen && !vect_epilogues && !pick_lowest_cost_p)\n+\t  /* For now only allow one epilogue loop, but allow\n+\t     pick_lowest_cost_p to replace it, so commit to the\n+\t     first epilogue if we have no reason to try alternatives.  */\n+\t  if (!pick_lowest_cost_p)\n \t    break;\n \t}\n \n-      /* Handle the case that the original loop can use partial\n-\t vectorization, but want to only adopt it for the epilogue.\n-\t The retry should be in the same mode as original.  */\n-      if (vect_epilogues\n-\t  && loop_vinfo\n-\t  && LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo))\n-\t{\n-\t  gcc_assert (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n-\t\t      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo));\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"***** Re-trying analysis with same vector mode\"\n-\t\t\t     \" %s for epilogue with partial vectors.\\n\",\n-\t\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n-\t  continue;\n-\t}\n-\n-      if (mode_i < vector_modes.length ()\n-\t  && VECTOR_MODE_P (autodetected_vector_mode)\n-\t  && (related_vector_mode (vector_modes[mode_i],\n-\t\t\t\t   GET_MODE_INNER (autodetected_vector_mode))\n-\t      == autodetected_vector_mode)\n-\t  && (related_vector_mode (autodetected_vector_mode,\n-\t\t\t\t   GET_MODE_INNER (vector_modes[mode_i]))\n-\t      == vector_modes[mode_i]))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"***** Skipping vector mode %s, which would\"\n-\t\t\t     \" repeat the analysis for %s\\n\",\n-\t\t\t     GET_MODE_NAME (vector_modes[mode_i]),\n-\t\t\t     GET_MODE_NAME (autodetected_vector_mode));\n-\t  mode_i += 1;\n-\t}\n-\n-      if (mode_i == vector_modes.length ()\n-\t  || autodetected_vector_mode == VOIDmode)\n+      if (mode_i == vector_modes.length ())\n \tbreak;\n \n       /* Try the next biggest vector size.  */\n-      next_vector_mode = vector_modes[mode_i++];\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Re-trying analysis with vector mode %s\\n\",\n-\t\t\t GET_MODE_NAME (next_vector_mode));\n+\t\t\t \"***** Re-trying epilogue analysis with vector \"\n+\t\t\t \"mode %s\\n\", GET_MODE_NAME (vector_modes[mode_i]));\n     }\n \n-  if (first_loop_vinfo)\n+  if (!first_loop_vinfo->epilogue_vinfos.is_empty ())\n     {\n-      loop->aux = (loop_vec_info) first_loop_vinfo;\n+      LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo) = lowest_th;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Choosing vector mode %s\\n\",\n-\t\t\t GET_MODE_NAME (first_loop_vinfo->vector_mode));\n-      LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo) = lowest_th;\n-      return first_loop_vinfo;\n+\t\t\t \"***** Choosing epilogue vector mode %s\\n\",\n+\t\t\t GET_MODE_NAME\n+\t\t\t   (first_loop_vinfo->epilogue_vinfos[0]->vector_mode));\n     }\n \n-  return opt_loop_vec_info::propagate_failure (res);\n+  return first_loop_vinfo;\n }\n \n /* Return true if there is an in-order reduction function for CODE, storing"}, {"sha": "a2e13acb6d223b4db16356e4167a4e66536878a3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf4065c909bd1010208117633ca9ff84cd7b38e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf4065c909bd1010208117633ca9ff84cd7b38e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=bcf4065c909bd1010208117633ca9ff84cd7b38e", "patch": "@@ -475,7 +475,8 @@ vec_info::~vec_info ()\n }\n \n vec_info_shared::vec_info_shared ()\n-  : datarefs (vNULL),\n+  : n_stmts (0),\n+    datarefs (vNULL),\n     datarefs_copy (vNULL),\n     ddrs (vNULL)\n {"}, {"sha": "7d3d3935c957fba972b13c428a446ff49b1508fa", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf4065c909bd1010208117633ca9ff84cd7b38e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf4065c909bd1010208117633ca9ff84cd7b38e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bcf4065c909bd1010208117633ca9ff84cd7b38e", "patch": "@@ -350,6 +350,9 @@ class vec_info_shared {\n   void save_datarefs();\n   void check_datarefs();\n \n+  /* The number of scalar stmts.  */\n+  unsigned n_stmts;\n+\n   /* All data references.  Freed by free_data_refs, so not an auto_vec.  */\n   vec<data_reference_p> datarefs;\n   vec<data_reference> datarefs_copy;\n@@ -822,6 +825,7 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_RGROUP_COMPARE_TYPE(L)  (L)->rgroup_compare_type\n #define LOOP_VINFO_RGROUP_IV_TYPE(L)       (L)->rgroup_iv_type\n #define LOOP_VINFO_PTR_MASK(L)             (L)->ptr_mask\n+#define LOOP_VINFO_N_STMTS(L)\t\t   (L)->shared->n_stmts\n #define LOOP_VINFO_LOOP_NEST(L)            (L)->shared->loop_nest\n #define LOOP_VINFO_DATAREFS(L)             (L)->shared->datarefs\n #define LOOP_VINFO_DDRS(L)                 (L)->shared->ddrs\n@@ -928,12 +932,6 @@ typedef class _bb_vec_info : public vec_info\n #define BB_VINFO_DATAREFS(B)         (B)->shared->datarefs\n #define BB_VINFO_DDRS(B)             (B)->shared->ddrs\n \n-static inline bb_vec_info\n-vec_info_for_bb (basic_block bb)\n-{\n-  return (bb_vec_info) bb->aux;\n-}\n-\n /*-----------------------------------------------------------------*/\n /* Info on vectorized defs.                                        */\n /*-----------------------------------------------------------------*/"}]}