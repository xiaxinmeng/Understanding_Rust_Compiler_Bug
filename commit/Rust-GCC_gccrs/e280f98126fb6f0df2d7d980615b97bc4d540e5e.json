{"sha": "e280f98126fb6f0df2d7d980615b97bc4d540e5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4MGY5ODEyNmZiNmYwZGYyZDdkOTgwNjE1Yjk3YmM0ZDU0MGU1ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T10:45:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T10:45:20Z"}, "message": "[multiple changes]\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* make.adb, makeutl.adb, makeutl.ads, clean.adb (Makeutl.Queue): new\n\tpackage.\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* cstand.adb (Create_Standard): select Universal_Integer as an ALFA type\n\t* sem_ch3.adb (Array_Type_Declaration): detect array types in ALFA\n\t* sem_util.adb, sem_util.ads (Has_Static_Array_Bounds): new function to\n\tdetect that an array has static bounds.\n\nFrom-SVN: r177264", "tree": {"sha": "7026427e1396c48997b6965dbb6a0c92aa528215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7026427e1396c48997b6965dbb6a0c92aa528215"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e280f98126fb6f0df2d7d980615b97bc4d540e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e280f98126fb6f0df2d7d980615b97bc4d540e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e280f98126fb6f0df2d7d980615b97bc4d540e5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e280f98126fb6f0df2d7d980615b97bc4d540e5e/comments", "author": null, "committer": null, "parents": [{"sha": "98c99a5a376eb0b8b601fc02dec9eeacf5086196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c99a5a376eb0b8b601fc02dec9eeacf5086196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c99a5a376eb0b8b601fc02dec9eeacf5086196"}], "stats": {"total": 1224, "additions": 670, "deletions": 554}, "files": [{"sha": "6f2e874c65b4a9960a652bc0bed52b06d7312962", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -1,3 +1,15 @@\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* make.adb, makeutl.adb, makeutl.ads, clean.adb (Makeutl.Queue): new\n+\tpackage.\n+\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* cstand.adb (Create_Standard): select Universal_Integer as an ALFA type\n+\t* sem_ch3.adb (Array_Type_Declaration): detect array types in ALFA\n+\t* sem_util.adb, sem_util.ads (Has_Static_Array_Bounds): new function to\n+\tdetect that an array has static bounds.\n+\n 2011-08-03  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_dist.adb: Minor reformatting."}, {"sha": "73e971aa6ba4785de5ad1ab15f41fa5a58345242", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 27, "deletions": 82, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -141,34 +141,6 @@ package body Clean is\n    --  Table to store all the source files of a library unit: spec, body and\n    --  subunits, to detect .dg files and delete them.\n \n-   ----------------------------\n-   -- Queue (Q) manipulation --\n-   ----------------------------\n-\n-   procedure Init_Q;\n-   --  Must be called to initialize the Q\n-\n-   procedure Insert_Q (Lib_File  : File_Name_Type);\n-   --  If Lib_File is not marked, inserts it at the end of Q and mark it\n-\n-   function Empty_Q return Boolean;\n-   --  Returns True if Q is empty\n-\n-   procedure Extract_From_Q (Lib_File : out File_Name_Type);\n-   --  Extracts the first element from the Q\n-\n-   Q_Front : Natural;\n-   --  Points to the first valid element in the Q\n-\n-   package Q is new Table.Table (\n-     Table_Component_Type => File_Name_Type,\n-     Table_Index_Type     => Natural,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => 4000,\n-     Table_Increment      => 100,\n-     Table_Name           => \"Clean.Q\");\n-   --  This is the actual queue\n-\n    -----------------------------\n    -- Other local subprograms --\n    -----------------------------\n@@ -399,8 +371,11 @@ package body Clean is\n       Text    : Text_Buffer_Ptr;\n       The_ALI : ALI_Id;\n \n+      Found : Boolean;\n+      Source : Queue.Source_Info;\n+\n    begin\n-      Init_Q;\n+      Queue.Initialize (Queue_Per_Obj_Dir => False);\n \n       --  It does not really matter if there is or not an object file\n       --  corresponding to an ALI file: if there is one, it will be deleted.\n@@ -414,12 +389,23 @@ package body Clean is\n       for N_File in 1 .. Osint.Number_Of_Files loop\n          Main_Source_File := Next_Main_Source;\n          Main_Lib_File := Osint.Lib_File_Name\n-                             (Main_Source_File, Current_File_Index);\n-         Insert_Q (Main_Lib_File);\n+           (Main_Source_File, Current_File_Index);\n+\n+         if Main_Lib_File /= No_File then\n+            Queue.Insert\n+              ((Format  => Format_Gnatmake,\n+                File    => Main_Lib_File,\n+                Unit    => No_Unit_Name,\n+                Index   => 0,\n+                Project => No_Project));\n+         end if;\n \n-         while not Empty_Q loop\n+         while not Queue.Is_Empty loop\n             Sources.Set_Last (0);\n-            Extract_From_Q (Lib_File);\n+            Queue.Extract (Found, Source);\n+            pragma Assert (Found);\n+            pragma Assert (Source.File /= No_File);\n+            Lib_File := Source.File;\n             Full_Lib_File := Osint.Full_Lib_File_Name (Lib_File);\n \n             --  If we have existing ALI file that is not read-only, process it\n@@ -448,7 +434,14 @@ package body Clean is\n                         for K in ALI.Units.Table (J).First_With ..\n                           ALI.Units.Table (J).Last_With\n                         loop\n-                           Insert_Q (Withs.Table (K).Afile);\n+                           if Withs.Table (K).Afile /= No_File then\n+                              Queue.Insert\n+                                ((Format  => Format_Gnatmake,\n+                                  File    => Withs.Table (K).Afile,\n+                                  Unit    => No_Unit_Name,\n+                                  Index   => 0,\n+                                  Project => No_Project));\n+                           end if;\n                         end loop;\n                      end loop;\n \n@@ -1348,26 +1341,6 @@ package body Clean is\n       end if;\n    end Display_Copyright;\n \n-   -------------\n-   -- Empty_Q --\n-   -------------\n-\n-   function Empty_Q return Boolean is\n-   begin\n-      return Q_Front >= Q.Last;\n-   end Empty_Q;\n-\n-   --------------------\n-   -- Extract_From_Q --\n-   --------------------\n-\n-   procedure Extract_From_Q (Lib_File : out File_Name_Type) is\n-      Lib : constant File_Name_Type := Q.Table (Q_Front);\n-   begin\n-      Q_Front  := Q_Front + 1;\n-      Lib_File := Lib;\n-   end Extract_From_Q;\n-\n    ---------------\n    -- Gnatclean --\n    ---------------\n@@ -1535,16 +1508,6 @@ package body Clean is\n       return False;\n    end In_Extension_Chain;\n \n-   ------------\n-   -- Init_Q --\n-   ------------\n-\n-   procedure Init_Q is\n-   begin\n-      Q_Front := Q.First;\n-      Q.Set_Last (Q.First);\n-   end Init_Q;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -1596,24 +1559,6 @@ package body Clean is\n       All_Projects := False;\n    end Initialize;\n \n-   --------------\n-   -- Insert_Q --\n-   --------------\n-\n-   procedure Insert_Q (Lib_File : File_Name_Type) is\n-   begin\n-      --  Do not insert an empty name or an already marked source\n-\n-      if Lib_File /= No_File and then not Makeutl.Is_Marked (Lib_File) then\n-         Q.Table (Q.Last) := Lib_File;\n-         Q.Increment_Last;\n-\n-         --  Mark the source that has been just added to the Q\n-\n-         Makeutl.Mark (Lib_File);\n-      end if;\n-   end Insert_Q;\n-\n    ----------------------\n    -- Object_File_Name --\n    ----------------------"}, {"sha": "f025be9347823af0cc3fe96ae866095bfcc9cdcb", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -1334,6 +1334,7 @@ package body CStand is\n       Set_Scope (Universal_Integer, Standard_Standard);\n       Build_Signed_Integer_Type\n         (Universal_Integer, Standard_Long_Long_Integer_Size);\n+      Set_Is_In_ALFA (Universal_Integer);\n \n       Universal_Real := New_Standard_Entity;\n       Decl := New_Node (N_Full_Type_Declaration, Stloc);"}, {"sha": "a61728ec6bf3d434a9667ffb5403f1b57e0c7a26", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 47, "deletions": 393, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -71,7 +71,6 @@ with Ada.Command_Line;          use Ada.Command_Line;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.Dynamic_HTables;      use GNAT.Dynamic_HTables;\n-with GNAT.HTable;\n with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n@@ -172,56 +171,6 @@ package body Make is\n    N_M_Switch : Natural := 0;\n    --  Used to count -mxxx switches that can affect multilib\n \n-   package Queue is\n-      ---------------------------------\n-      -- Queue Manipulation Routines --\n-      ---------------------------------\n-\n-      procedure Initialize (Queue_Per_Obj_Dir : Boolean);\n-      --  Initialize the queue\n-\n-      function Is_Empty return Boolean;\n-      --  Returns True if the queue is empty\n-\n-      function Is_Virtually_Empty return Boolean;\n-      --  Returns True if the queue is empty or if all object directories are\n-      --  busy.\n-\n-      procedure Insert\n-        (Source_File_Name : File_Name_Type;\n-         Project          : Project_Id;\n-         Source_Unit      : Unit_Name_Type := No_Unit_Name;\n-         Index            : Int            := 0);\n-      --  Insert source in the queue\n-\n-      procedure Extract\n-        (Source_File_Name  : out File_Name_Type;\n-         Source_Unit       : out Unit_Name_Type;\n-         Source_Index      : out Int);\n-      --  Get the first source that can be compiled from the queue. If no\n-      --  source may be compiled, return No_File/No_Source.\n-\n-      function Size return Natural;\n-      --  Return the total size of the queue, including the sources already\n-      --  extracted.\n-\n-      function Processed return Natural;\n-      --  Return the number of source in the queue that have already been\n-      --  processed.\n-\n-      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type);\n-      --  Indicate that this object directory is busy, so that when\n-      --  One_Compilation_Per_Obj_Dir is True no other compilation occurs in\n-      --  this object directory.\n-\n-      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type);\n-      --  Indicate that there is no compilation for this object directory\n-\n-      function Element (Rank : Positive) return File_Name_Type;\n-      --  Get the file name for element of index Rank in the queue\n-\n-   end Queue;\n-\n    --  The 3 following packages are used to store gcc, gnatbind and gnatlink\n    --  switches found in the project files.\n \n@@ -2736,14 +2685,16 @@ package body Make is\n                end if;\n \n                if Add_It then\n-                  if Is_Marked (Sfile) then\n+                  if not Queue.Insert\n+                       ((Format  => Format_Gnatmake,\n+                         File    => Sfile,\n+                         Unit    => No_Unit_Name,\n+                         Project => No_Project,\n+                         Index   => 0))\n+                  then\n                      if Is_In_Obsoleted (Sfile) then\n                         Executable_Obsolete := True;\n                      end if;\n-\n-                  else\n-                     Queue.Insert (Sfile, Project => No_Project, Index => 0);\n-                     Mark (Sfile, Index => 0);\n                   end if;\n                end if;\n             end;\n@@ -3168,21 +3119,18 @@ package body Make is\n                      else\n                         Source_Index := Unit_Index_Of (Withs.Table (K).Afile);\n \n-                        if Is_Marked (Sfile, Source_Index) then\n-                           Debug_Msg (\"Skipping marked file:\", Sfile);\n-\n-                        elsif not (Check_Readonly_Files or Must_Compile)\n+                        if not (Check_Readonly_Files or Must_Compile)\n                           and then Is_Internal_File_Name (Sfile, False)\n                         then\n                            Debug_Msg (\"Skipping internal file:\", Sfile);\n \n                         else\n                            Queue.Insert\n-                             (Sfile,\n-                              ALI_P.Project,\n-                              Withs.Table (K).Uname,\n-                              Source_Index);\n-                           Mark (Sfile, Source_Index);\n+                             ((Format  => Format_Gnatmake,\n+                               File    => Sfile,\n+                               Project => ALI_P.Project,\n+                               Unit    => Withs.Table (K).Uname,\n+                               Index   => Source_Index));\n                         end if;\n                      end if;\n                   end loop;\n@@ -3306,15 +3254,11 @@ package body Make is\n          Pid             : Process_Id;\n          Process_Created : Boolean;\n \n-         Source_File      : File_Name_Type;\n+         Source           : Queue.Source_Info;\n          Full_Source_File : File_Name_Type;\n          Source_File_Attr : aliased File_Attributes;\n          --  The full name of the source file and its attributes (size, ...)\n \n-         Source_Unit  : Unit_Name_Type;\n-         Source_Index : Int;\n-         --  Index of the current unit in the current source file\n-\n          Lib_File      : File_Name_Type;\n          Full_Lib_File : File_Name_Type;\n          Lib_File_Attr : aliased File_Attributes;\n@@ -3326,18 +3270,20 @@ package body Make is\n          Obj_Stamp : Time_Stamp_Type;\n          --  The object file\n \n+         Found : Boolean;\n+\n       begin\n          if not Queue.Is_Virtually_Empty and then\n             Outstanding_Compiles < Max_Process\n          then\n-            Queue.Extract (Source_File, Source_Unit, Source_Index);\n+            Queue.Extract (Found, Source);\n \n             Osint.Full_Source_Name\n-              (Source_File,\n+              (Source.File,\n                Full_File => Full_Source_File,\n                Attr      => Source_File_Attr'Access);\n \n-            Lib_File := Osint.Lib_File_Name (Source_File, Source_Index);\n+            Lib_File := Osint.Lib_File_Name (Source.File, Source.Index);\n \n             --  ??? This call could be avoided when using projects, since we\n             --  know where the ALI file is supposed to be. That would avoid\n@@ -3352,7 +3298,7 @@ package body Make is\n \n             --  If source has already been compiled, executable is obsolete\n \n-            if Is_In_Obsoleted (Source_File) then\n+            if Is_In_Obsoleted (Source.File) then\n                Executable_Obsolete := True;\n             end if;\n \n@@ -3390,7 +3336,7 @@ package body Make is\n                --  directory of a project being extended must not be skipped).\n \n             elsif Read_Only\n-              and then Is_In_Object_Directory (Source_File, Full_Lib_File)\n+              and then Is_In_Object_Directory (Source.File, Full_Lib_File)\n             then\n                Verbose_Msg\n                  (Lib_File,\n@@ -3401,19 +3347,19 @@ package body Make is\n                --  The source file that we are checking cannot be located\n \n             elsif Full_Source_File = No_File then\n-               Record_Failure (Source_File, Source_Unit, False);\n+               Record_Failure (Source.File, Source.Unit, False);\n \n                --  Source and library files can be located but are internal\n                --  files.\n \n             elsif not (Check_Readonly_Files or else Must_Compile)\n               and then Full_Lib_File /= No_File\n-              and then Is_Internal_File_Name (Source_File, False)\n+              and then Is_Internal_File_Name (Source.File, False)\n             then\n                if Force_Compilations then\n                   Fail\n                     (\"not allowed to compile \"\"\" &\n-                     Get_Name_String (Source_File) &\n+                     Get_Name_String (Source.File) &\n                      \"\"\"; use -a switch, or compile file with \" &\n                      \"\"\"-gnatg\"\" switch\");\n                end if;\n@@ -3428,7 +3374,7 @@ package body Make is\n \n             else\n                Collect_Arguments\n-                  (Source_File, Source_File = Main_Source, Args);\n+                  (Source.File, Source.File = Main_Source, Args);\n \n                --  Do nothing if project of source is externally built\n \n@@ -3442,9 +3388,9 @@ package body Make is\n                   Need_To_Compile := Force_Compilations;\n \n                   if not Force_Compilations then\n-                     Check (Source_File    => Source_File,\n-                            Source_Index   => Source_Index,\n-                            Is_Main_Source => Source_File = Main_Source,\n+                     Check (Source_File    => Source.File,\n+                            Source_Index   => Source.Index,\n+                            Is_Main_Source => Source.File = Main_Source,\n                             The_Args       => Args,\n                             Lib_File       => Lib_File,\n                             Full_Lib_File  => Full_Lib_File,\n@@ -3482,7 +3428,7 @@ package body Make is\n                        and then not External_Unit_Compilation_Allowed\n                      then\n                         Make_Failed (\"external source (\"\n-                                     & Get_Name_String (Source_File)\n+                                     & Get_Name_String (Source.File)\n                                      & \") is not part of any project;\"\n                                      & \" cannot be compiled without\"\n                                      & \" gnatmake switch -x\");\n@@ -3514,7 +3460,7 @@ package body Make is\n \n                            Lib_File :=\n                              Osint.Lib_File_Name\n-                               (Full_Source_File, Source_Index);\n+                               (Full_Source_File, Source.Index);\n                            Full_Lib_File := Lib_File;\n \n                         else\n@@ -3532,7 +3478,7 @@ package body Make is\n                      Collect_Arguments_And_Compile\n                        (Full_Source_File => Full_Source_File,\n                         Lib_File         => Lib_File,\n-                        Source_Index     => Source_Index,\n+                        Source_Index     => Source.Index,\n                         Pid              => Pid,\n                         Process_Created  => Process_Created);\n \n@@ -3584,13 +3530,13 @@ package body Make is\n \n                      if Process_Created then\n                         if Pid = Invalid_Pid then\n-                           Record_Failure (Full_Source_File, Source_Unit);\n+                           Record_Failure (Full_Source_File, Source.Unit);\n                         else\n                            Add_Process\n                              (Pid           => Pid,\n                               Sfile         => Full_Source_File,\n                               Afile         => Lib_File,\n-                              Uname         => Source_Unit,\n+                              Uname         => Source.Unit,\n                               Mfile         => Mfile,\n                               Full_Lib_File => Full_Lib_File,\n                               Lib_File_Attr => Lib_File_Attr);\n@@ -3727,13 +3673,12 @@ package body Make is\n       Check_Source_Files := True;\n       All_Sources        := False;\n \n-      --  Only insert in the Q if it is not already done, to avoid simultaneous\n-      --  compilations if -jnnn is used.\n-\n-      if not Is_Marked (Main_Source, Main_Index) then\n-         Queue.Insert (Main_Source, Main_Project, Index => Main_Index);\n-         Mark (Main_Source, Main_Index);\n-      end if;\n+      Queue.Insert\n+        ((Format  => Format_Gnatmake,\n+          File    => Main_Source,\n+          Project => Main_Project,\n+          Unit    => No_Unit_Name,\n+          Index   => Main_Index));\n \n       First_Compiled_File   := No_File;\n       Most_Recent_Obj_File  := No_File;\n@@ -6497,10 +6442,7 @@ package body Make is\n             end if;\n          end if;\n \n-         --  Remove all marks to be sure to check sources for all executables,\n-         --  as the switches may be different and -s may be in use.\n-\n-         Delete_All_Marks;\n+         Queue.Remove_Marks;\n       end loop Multiple_Main_Loop;\n \n       if Do_Codepeer_Globalize_Step then\n@@ -7033,17 +6975,13 @@ package body Make is\n                  (Main_Project /= No_Project and then\n                   One_Compilation_Per_Obj_Dir);\n \n-         --  And of course, only insert in the Q if the source is not marked\n-\n-         if Sfile /= No_File and then not Is_Marked (Sfile, Index) then\n-            if Verbose_Mode then\n-               Write_Str (\"Adding \"\"\");\n-               Write_Str (Get_Name_String (Sfile));\n-               Write_Line (\"\"\" to the queue\");\n-            end if;\n-\n-            Queue.Insert (Sfile, Project, Index => Index);\n-            Mark (Sfile, Index);\n+         if Sfile /= No_File then\n+            Queue.Insert\n+              ((Format   => Format_Gnatmake,\n+                File     => Sfile,\n+                Project  => Project,\n+                Unit     => No_Unit_Name,\n+                Index    => Index));\n          end if;\n \n          if not Put_In_Q and then Sfile /= No_File then\n@@ -7477,290 +7415,6 @@ package body Make is\n       Scan_Make_Arg (Env, \"--RTS=\" & Line (1 .. N_Read), And_Save => True);\n    end Process_Multilib;\n \n-   -----------\n-   -- Queue --\n-   -----------\n-\n-   package body Queue is\n-\n-      type Q_Record is record\n-         File      : File_Name_Type;\n-         Unit      : Unit_Name_Type;\n-         Index     : Int;\n-         Project   : Project_Id;\n-         Processed : Boolean;\n-      end record;\n-      --  File is the name of the file to compile. Unit is for gnatdist use in\n-      --  order to easily get the unit name of a file to compile when its name\n-      --  is krunched or declared in gnat.adc. Index, when not 0, is the index\n-      --  of the unit in a multi-unit source.\n-\n-      package Q is new Table.Table\n-        (Table_Component_Type => Q_Record,\n-         Table_Index_Type     => Positive,\n-         Table_Low_Bound      => 1,\n-         Table_Initial        => 4000,\n-         Table_Increment      => 100,\n-         Table_Name           => \"Make.Queue.Q\");\n-      --  This is the actual Q\n-\n-      package Busy_Obj_Dirs is new GNAT.HTable.Simple_HTable\n-        (Header_Num => Prj.Header_Num,\n-         Element    => Boolean,\n-         No_Element => False,\n-         Key        => Path_Name_Type,\n-         Hash       => Hash,\n-         Equal      => \"=\");\n-\n-      Q_First : Natural := 1;\n-      --  Points to the first valid element in the queue\n-\n-      Q_Processed           : Natural := 0;\n-      One_Queue_Per_Obj_Dir : Boolean := False;\n-      Q_Initialized         : Boolean := False;\n-\n-      -------------\n-      -- Element --\n-      -------------\n-\n-      function Element (Rank : Positive) return File_Name_Type is\n-      begin\n-         if Rank <= Q.Last then\n-            return Q.Table (Rank).File;\n-         else\n-            return No_File;\n-         end if;\n-      end Element;\n-\n-      -------------\n-      -- Extract --\n-      -------------\n-\n-      --  This body needs commenting ???\n-\n-      procedure Extract\n-        (Source_File_Name : out File_Name_Type;\n-         Source_Unit      : out Unit_Name_Type;\n-         Source_Index     : out Int)\n-      is\n-         Found : Boolean := False;\n-\n-      begin\n-         if One_Queue_Per_Obj_Dir then\n-            for J in Q_First .. Q.Last loop\n-               if not Q.Table (J).Processed\n-                 and then (Q.Table (J).Project = No_Project\n-                            or else not\n-                              Busy_Obj_Dirs.Get\n-                                (Q.Table (J).Project.Object_Directory.Name))\n-               then\n-                  Found := True;\n-                  Source_File_Name := Q.Table (J).File;\n-                  Source_Unit      := Q.Table (J).Unit;\n-                  Source_Index     := Q.Table (J).Index;\n-                  Q.Table (J).Processed := True;\n-\n-                  if J = Q_First then\n-                     while Q_First <= Q.Last\n-                       and then Q.Table (Q_First).Processed\n-                     loop\n-                        Q_First := Q_First + 1;\n-                     end loop;\n-                  end if;\n-\n-                  exit;\n-               end if;\n-            end loop;\n-\n-         elsif Q_First <= Q.Last then\n-            Source_File_Name := Q.Table (Q_First).File;\n-            Source_Unit      := Q.Table (Q_First).Unit;\n-            Source_Index     := Q.Table (Q_First).Index;\n-            Q.Table (Q_First).Processed := True;\n-            Q_First := Q_First + 1;\n-            Found := True;\n-         end if;\n-\n-         if Found then\n-            Q_Processed := Q_Processed + 1;\n-         else\n-            Source_File_Name := No_File;\n-            Source_Unit      := No_Unit_Name;\n-            Source_Index     := 0;\n-         end if;\n-\n-         if Found and then Debug.Debug_Flag_Q then\n-            Write_Str (\"   Q := Q - [ \");\n-            Write_Name (Source_File_Name);\n-\n-            if Source_Index /= 0 then\n-               Write_Str (\", \");\n-               Write_Int (Source_Index);\n-            end if;\n-\n-            Write_Str (\" ]\");\n-            Write_Eol;\n-\n-            Write_Str (\"   Q_First =\");\n-            Write_Int (Int (Q_First));\n-            Write_Eol;\n-\n-            Write_Str (\"   Q.Last =\");\n-            Write_Int (Int (Q.Last));\n-            Write_Eol;\n-         end if;\n-      end Extract;\n-\n-      ----------------\n-      -- Initialize --\n-      ----------------\n-\n-      procedure Initialize (Queue_Per_Obj_Dir : Boolean) is\n-      begin\n-         if not Q_Initialized then\n-            One_Queue_Per_Obj_Dir := Queue_Per_Obj_Dir;\n-            Q.Init;\n-            Q_Initialized := True;\n-            Q_Processed   := 0;\n-            Q_First       := 1;\n-         end if;\n-      end Initialize;\n-\n-      ------------\n-      -- Insert --\n-      ------------\n-\n-      --  This body needs commenting ???\n-\n-      procedure Insert\n-        (Source_File_Name : File_Name_Type;\n-         Project          : Project_Id;\n-         Source_Unit      : Unit_Name_Type := No_Unit_Name;\n-         Index            : Int            := 0)\n-      is\n-      begin\n-         Q.Append\n-           ((File      => Source_File_Name,\n-             Project   => Project,\n-             Unit      => Source_Unit,\n-             Index     => Index,\n-             Processed => False));\n-\n-         if Debug.Debug_Flag_Q then\n-            Write_Str (\"   Q := Q + [ \");\n-            Write_Name (Source_File_Name);\n-\n-            if Index /= 0 then\n-               Write_Str (\", \");\n-               Write_Int (Index);\n-            end if;\n-\n-            Write_Str (\" ] \");\n-            Write_Eol;\n-\n-            Write_Str (\"   Q_First =\");\n-            Write_Int (Int (Q_First));\n-            Write_Eol;\n-\n-            Write_Str (\"   Q.Last =\");\n-            Write_Int (Int (Q.Last));\n-            Write_Eol;\n-         end if;\n-      end Insert;\n-\n-      --------------\n-      -- Is_Empty --\n-      --------------\n-\n-      function Is_Empty return Boolean is\n-      begin\n-         if Debug.Debug_Flag_P then\n-            Write_Str (\"   Q := [\");\n-\n-            for J in Q_First .. Q.Last loop\n-               if not Q.Table (J).Processed then\n-                  Write_Str (\" \");\n-                  Write_Name (Q.Table (J).File);\n-                  Write_Eol;\n-                  Write_Str (\"         \");\n-               end if;\n-            end loop;\n-\n-            Write_Str (\"]\");\n-            Write_Eol;\n-         end if;\n-\n-         return Q_First > Q.Last;\n-      end Is_Empty;\n-\n-      ------------------------\n-      -- Is_Virtually_Empty --\n-      ------------------------\n-\n-      function Is_Virtually_Empty return Boolean is\n-      begin\n-         if One_Queue_Per_Obj_Dir then\n-            for J in Q_First .. Q.Last loop\n-               if not Q.Table (J).Processed\n-                 and then\n-                   (Q.Table (J).Project = No_Project\n-                     or else not\n-                       Busy_Obj_Dirs.Get\n-                         (Q.Table (J).Project.Object_Directory.Name))\n-               then\n-                  return False;\n-               end if;\n-            end loop;\n-\n-            return True;\n-\n-         else\n-            return Is_Empty;\n-         end if;\n-      end Is_Virtually_Empty;\n-\n-      ---------------\n-      -- Processed --\n-      ---------------\n-\n-      function Processed return Natural is\n-      begin\n-         return Q_Processed;\n-      end Processed;\n-\n-      ----------------------\n-      -- Set_Obj_Dir_Busy --\n-      ----------------------\n-\n-      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type) is\n-      begin\n-         if One_Queue_Per_Obj_Dir then\n-            Busy_Obj_Dirs.Set (Obj_Dir, True);\n-         end if;\n-      end Set_Obj_Dir_Busy;\n-\n-      ----------------------\n-      -- Set_Obj_Dir_Free --\n-      ----------------------\n-\n-      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type) is\n-      begin\n-         if One_Queue_Per_Obj_Dir then\n-            Busy_Obj_Dirs.Set (Obj_Dir, False);\n-         end if;\n-      end Set_Obj_Dir_Free;\n-\n-      ----------\n-      -- Size --\n-      ----------\n-\n-      function Size return Natural is\n-      begin\n-         return Q.Last;\n-      end Size;\n-\n-   end Queue;\n-\n    -----------------------------\n    -- Recursive_Compute_Depth --\n    -----------------------------"}, {"sha": "871096c8379972c490bb77fde164a80b124927c2", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 414, "deletions": 63, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -44,30 +44,6 @@ with GNAT.HTable;\n \n package body Makeutl is\n \n-   type Mark_Key is record\n-      File  : File_Name_Type;\n-      Index : Int;\n-   end record;\n-   --  Identify either a mono-unit source (when Index = 0) or a specific unit\n-   --  (index = 1's origin index of unit) in a multi-unit source.\n-\n-   --  There follow many global undocumented declarations, comments needed ???\n-\n-   Max_Mask_Num : constant := 2048;\n-\n-   subtype Mark_Num is Union_Id range 0 .. Max_Mask_Num - 1;\n-\n-   function Hash (Key : Mark_Key) return Mark_Num;\n-\n-   package Marks is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Mark_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => Mark_Key,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  A hash table to keep tracks of the marked units\n-\n    type Linker_Options_Data is record\n       Project : Project_Id;\n       Options : String_List_Id;\n@@ -520,15 +496,6 @@ package body Makeutl is\n       return Name_Find;\n    end Create_Name;\n \n-   ----------------------\n-   -- Delete_All_Marks --\n-   ----------------------\n-\n-   procedure Delete_All_Marks is\n-   begin\n-      Marks.Reset;\n-   end Delete_All_Marks;\n-\n    ----------------------------\n    -- Executable_Prefix_Path --\n    ----------------------------\n@@ -817,15 +784,6 @@ package body Makeutl is\n       end if;\n    end Get_Switches;\n \n-   ----------\n-   -- Hash --\n-   ----------\n-\n-   function Hash (Key : Mark_Key) return Mark_Num is\n-   begin\n-      return Union_Id (Key.File) mod Max_Mask_Num;\n-   end Hash;\n-\n    ------------\n    -- Inform --\n    ------------\n@@ -893,18 +851,6 @@ package body Makeutl is\n          Declaration => Argv (Start .. Finish));\n    end Is_External_Assignment;\n \n-   ---------------\n-   -- Is_Marked --\n-   ---------------\n-\n-   function Is_Marked\n-     (Source_File : File_Name_Type;\n-      Index       : Int := 0) return Boolean\n-   is\n-   begin\n-      return Marks.Get (K => (File => Source_File, Index => Index));\n-   end Is_Marked;\n-\n    -----------------------------\n    -- Linker_Options_Switches --\n    -----------------------------\n@@ -1151,15 +1097,6 @@ package body Makeutl is\n       end Update_Main;\n    end Mains;\n \n-   ----------\n-   -- Mark --\n-   ----------\n-\n-   procedure Mark (Source_File : File_Name_Type; Index : Int := 0) is\n-   begin\n-      Marks.Set (K => (File => Source_File, Index => Index), E => True);\n-   end Mark;\n-\n    -----------------------\n    -- Path_Or_File_Name --\n    -----------------------\n@@ -1363,6 +1300,10 @@ package body Makeutl is\n       Write_Eol;\n    end Verbose_Msg;\n \n+   -----------------\n+   -- Verbose_Msg --\n+   -----------------\n+\n    procedure Verbose_Msg\n      (N1                : File_Name_Type;\n       S1                : String;\n@@ -1376,4 +1317,414 @@ package body Makeutl is\n         (Name_Id (N1), S1, Name_Id (N2), S2, Prefix, Minimum_Verbosity);\n    end Verbose_Msg;\n \n+   -----------\n+   -- Queue --\n+   -----------\n+\n+   package body Queue is\n+      type Q_Record is record\n+         Info      : Source_Info;\n+         Processed : Boolean;\n+      end record;\n+\n+      package Q is new Table.Table\n+        (Table_Component_Type => Q_Record,\n+         Table_Index_Type     => Natural,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 1000,\n+         Table_Increment      => 100,\n+         Table_Name           => \"Makeutl.Queue.Q\");\n+      --  This is the actual Queue\n+\n+      package Busy_Obj_Dirs is new GNAT.HTable.Simple_HTable\n+        (Header_Num => Prj.Header_Num,\n+         Element    => Boolean,\n+         No_Element => False,\n+         Key        => Path_Name_Type,\n+         Hash       => Hash,\n+         Equal      => \"=\");\n+\n+      type Mark_Key is record\n+         File  : File_Name_Type;\n+         Index : Int;\n+      end record;\n+      --  Identify either a mono-unit source (when Index = 0) or a specific\n+      --  unit (index = 1's origin index of unit) in a multi-unit source.\n+\n+      Max_Mask_Num : constant := 2048;\n+      subtype Mark_Num is Union_Id range 0 .. Max_Mask_Num - 1;\n+\n+      function Hash (Key : Mark_Key) return Mark_Num;\n+\n+      package Marks is new GNAT.HTable.Simple_HTable\n+        (Header_Num => Mark_Num,\n+         Element    => Boolean,\n+         No_Element => False,\n+         Key        => Mark_Key,\n+         Hash       => Hash,\n+         Equal      => \"=\");\n+      --  A hash table to keep tracks of the marked units.\n+      --  These are the units that have already been processed, when using the\n+      --  gnatmake format. When using the gprbuild format, we can directly\n+      --  store in the source_id whether the file has already been processed.\n+\n+      procedure Mark (Source_File : File_Name_Type; Index : Int := 0);\n+      --  Mark a unit, identified by its source file and, when Index is not 0,\n+      --  the index of the unit in the source file. Marking is used to signal\n+      --  that the unit has already been inserted in the Q.\n+\n+      function Is_Marked\n+        (Source_File : File_Name_Type;\n+         Index       : Int := 0) return Boolean;\n+      --  Returns True if the unit was previously marked\n+\n+      Q_Processed           : Natural := 0;\n+      Q_Initialized         : Boolean := False;\n+\n+      Q_First               : Natural := 1;\n+      --  Points to the first valid element in the queue\n+\n+      One_Queue_Per_Obj_Dir : Boolean := False;\n+      --  See parameter to Initialize\n+\n+      function Available_Obj_Dir (S : Source_Info) return Boolean;\n+      --  Whether the object directory for S is available for a build\n+\n+      procedure Debug_Display (S : Source_Info);\n+      --  A debug display for S\n+\n+      function Was_Processed (S : Source_Info) return Boolean;\n+      --  Whether S has already been processed. This marks the source as\n+      --  processed, if it hasn't already been processed.\n+\n+      -------------------\n+      -- Was_Processed --\n+      -------------------\n+\n+      function Was_Processed (S : Source_Info) return Boolean is\n+      begin\n+         case S.Format is\n+            when Format_Gprbuild =>\n+               if S.Id.In_The_Queue then\n+                  return True;\n+               end if;\n+               S.Id.In_The_Queue := True;\n+\n+            when Format_Gnatmake =>\n+               if Is_Marked (S.File, S.Index) then\n+                  return True;\n+               end if;\n+               Mark (S.File, Index => S.Index);\n+         end case;\n+\n+         return False;\n+      end Was_Processed;\n+\n+      -----------------------\n+      -- Available_Obj_Dir --\n+      -----------------------\n+\n+      function Available_Obj_Dir (S : Source_Info) return Boolean is\n+      begin\n+         case S.Format is\n+            when Format_Gprbuild =>\n+               return not Busy_Obj_Dirs.Get\n+                 (S.Id.Project.Object_Directory.Name);\n+\n+            when Format_Gnatmake =>\n+               return S.Project = No_Project\n+                 or else\n+                   not Busy_Obj_Dirs.Get (S.Project.Object_Directory.Name);\n+         end case;\n+      end Available_Obj_Dir;\n+\n+      -------------------\n+      -- Debug_Display --\n+      -------------------\n+\n+      procedure Debug_Display (S : Source_Info) is\n+      begin\n+         case S.Format is\n+            when Format_Gprbuild =>\n+               Write_Name (S.Id.File);\n+\n+               if S.Id.Index /= 0 then\n+                  Write_Str (\", \");\n+                  Write_Int (S.Id.Index);\n+               end if;\n+\n+            when Format_Gnatmake =>\n+               Write_Name (S.File);\n+\n+               if S.Index /= 0 then\n+                  Write_Str (\", \");\n+                  Write_Int (S.Index);\n+               end if;\n+         end case;\n+      end Debug_Display;\n+\n+      ----------\n+      -- Hash --\n+      ----------\n+\n+      function Hash (Key : Mark_Key) return Mark_Num is\n+      begin\n+         return Union_Id (Key.File) mod Max_Mask_Num;\n+      end Hash;\n+\n+      ---------------\n+      -- Is_Marked --\n+      ---------------\n+\n+      function Is_Marked\n+        (Source_File : File_Name_Type;\n+         Index       : Int := 0) return Boolean is\n+      begin\n+         return Marks.Get (K => (File => Source_File, Index => Index));\n+      end Is_Marked;\n+\n+      ----------\n+      -- Mark --\n+      ----------\n+\n+      procedure Mark (Source_File : File_Name_Type; Index : Int := 0) is\n+      begin\n+         Marks.Set (K => (File => Source_File, Index => Index), E => True);\n+      end Mark;\n+\n+      -------------\n+      -- Extract --\n+      -------------\n+\n+      procedure Extract\n+        (Found  : out Boolean;\n+         Source : out Source_Info) is\n+      begin\n+         Found := False;\n+\n+         if One_Queue_Per_Obj_Dir then\n+            for J in Q_First .. Q.Last loop\n+               if not Q.Table (J).Processed\n+                 and then Available_Obj_Dir (Q.Table (J).Info)\n+               then\n+                  Found := True;\n+                  Source := Q.Table (J).Info;\n+                  Q.Table (J).Processed := True;\n+\n+                  if J = Q_First then\n+                     while Q_First <= Q.Last\n+                       and then Q.Table (Q_First).Processed\n+                     loop\n+                        Q_First := Q_First + 1;\n+                     end loop;\n+                  end if;\n+\n+                  exit;\n+               end if;\n+            end loop;\n+\n+         elsif Q_First <= Q.Last then\n+            Source := Q.Table (Q_First).Info;\n+            Q.Table (Q_First).Processed := True;\n+            Q_First := Q_First + 1;\n+            Found := True;\n+         end if;\n+\n+         if Found then\n+            Q_Processed := Q_Processed + 1;\n+         end if;\n+\n+         if Found and then Debug.Debug_Flag_Q then\n+            Write_Str (\"   Q := Q - [ \");\n+            Debug_Display (Source);\n+            Write_Str (\" ]\");\n+            Write_Eol;\n+\n+            Write_Str (\"   Q_First =\");\n+            Write_Int (Int (Q_First));\n+            Write_Eol;\n+\n+            Write_Str (\"   Q.Last =\");\n+            Write_Int (Int (Q.Last));\n+            Write_Eol;\n+         end if;\n+      end Extract;\n+\n+      ---------------\n+      -- Processed --\n+      ---------------\n+\n+      function Processed return Natural is\n+      begin\n+         return Q_Processed;\n+      end Processed;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      procedure Initialize\n+        (Queue_Per_Obj_Dir : Boolean;\n+         Force : Boolean := False) is\n+      begin\n+         if Force or else not Q_Initialized then\n+            Q_Initialized := True;\n+\n+            for J in 1 .. Q.Last loop\n+               case Q.Table (J).Info.Format is\n+               when Format_Gprbuild =>\n+                  Q.Table (J).Info.Id.In_The_Queue := False;\n+               when Format_Gnatmake =>\n+                  null;\n+               end case;\n+            end loop;\n+\n+            Q.Init;\n+            Q_Processed := 0;\n+            Q_First     := 1;\n+            One_Queue_Per_Obj_Dir := Queue_Per_Obj_Dir;\n+         end if;\n+      end Initialize;\n+\n+      ------------\n+      -- Insert --\n+      ------------\n+\n+      function Insert (Source  : Source_Info) return Boolean is\n+      begin\n+         --  Only insert in the Q if it is not already done, to avoid\n+         --  simultaneous compilations if -jnnn is used.\n+\n+         if Was_Processed (Source) then\n+            return False;\n+         end if;\n+\n+         if Current_Verbosity = High then\n+            Write_Str (\"Adding \"\"\");\n+            Debug_Display (Source);\n+            Write_Line (\" to the queue\");\n+         end if;\n+\n+         Q.Append (New_Val => (Info => Source, Processed => False));\n+\n+         if Debug.Debug_Flag_Q then\n+            Write_Str (\"   Q := Q + [ \");\n+            Debug_Display (Source);\n+            Write_Str (\" ] \");\n+            Write_Eol;\n+\n+            Write_Str (\"   Q_First =\");\n+            Write_Int (Int (Q_First));\n+            Write_Eol;\n+\n+            Write_Str (\"   Q.Last =\");\n+            Write_Int (Int (Q.Last));\n+            Write_Eol;\n+         end if;\n+\n+         return True;\n+      end Insert;\n+\n+      ------------\n+      -- Insert --\n+      ------------\n+\n+      procedure Insert (Source : Source_Info) is\n+         Tmp : Boolean;\n+         pragma Unreferenced (Tmp);\n+      begin\n+         Tmp := Insert (Source);\n+      end Insert;\n+\n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty return Boolean is\n+      begin\n+         return Q_Processed >= Q.Last;\n+      end Is_Empty;\n+\n+      ------------------------\n+      -- Is_Virtually_Empty --\n+      ------------------------\n+\n+      function Is_Virtually_Empty return Boolean is\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            for J in Q_First .. Q.Last loop\n+               if not Q.Table (J).Processed\n+                 and then Available_Obj_Dir (Q.Table (J).Info)\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+\n+            return True;\n+\n+         else\n+            return Is_Empty;\n+         end if;\n+      end Is_Virtually_Empty;\n+\n+      ----------------------\n+      -- Set_Obj_Dir_Busy --\n+      ----------------------\n+\n+      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type) is\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            Busy_Obj_Dirs.Set (Obj_Dir, True);\n+         end if;\n+      end Set_Obj_Dir_Busy;\n+\n+      ----------------------\n+      -- Set_Obj_Dir_Free --\n+      ----------------------\n+\n+      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type) is\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            Busy_Obj_Dirs.Set (Obj_Dir, False);\n+         end if;\n+      end Set_Obj_Dir_Free;\n+\n+      ----------\n+      -- Size --\n+      ----------\n+\n+      function Size return Natural is\n+      begin\n+         return Q.Last;\n+      end Size;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Rank : Positive) return File_Name_Type is\n+      begin\n+         if Rank <= Q.Last then\n+            case Q.Table (Rank).Info.Format is\n+               when Format_Gprbuild =>\n+                  return Q.Table (Rank).Info.Id.File;\n+               when Format_Gnatmake =>\n+                  return Q.Table (Rank).Info.File;\n+            end case;\n+         else\n+            return No_File;\n+         end if;\n+      end Element;\n+\n+      ------------------\n+      -- Remove_Marks --\n+      ------------------\n+\n+      procedure Remove_Marks is\n+      begin\n+         Marks.Reset;\n+      end Remove_Marks;\n+\n+   end Queue;\n+\n end Makeutl;"}, {"sha": "a59139563f8f8934fa28d763bed7d41927e0f944", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -250,21 +250,86 @@ package Makeutl is\n \n    end Mains;\n \n-   ----------------------\n-   -- Marking Routines --\n-   ----------------------\n-\n-   procedure Mark (Source_File : File_Name_Type; Index : Int := 0);\n-   --  Mark a unit, identified by its source file and, when Index is not 0, the\n-   --  index of the unit in the source file. Marking is used to signal that the\n-   --  unit has already been inserted in the Q.\n-\n-   function Is_Marked\n-     (Source_File : File_Name_Type;\n-      Index       : Int := 0) return Boolean;\n-   --  Returns True if the unit was previously marked\n-\n-   procedure Delete_All_Marks;\n-   --  Remove all file/index couples marked\n+   -----------\n+   -- Queue --\n+   -----------\n+\n+   type Source_Info_Format is (Format_Gprbuild, Format_Gnatmake);\n+\n+   package Queue is\n+      --  The queue of sources to be checked for compilation.\n+      --  There can be a single such queue per application.\n+\n+      type Source_Info (Format : Source_Info_Format := Format_Gprbuild) is\n+         record\n+            case Format is\n+            when Format_Gprbuild =>\n+               Id : Source_Id := null;\n+\n+            when Format_Gnatmake =>\n+               File      : File_Name_Type := No_File;\n+               Unit      : Unit_Name_Type := No_Unit_Name;\n+               Index     : Int := 0;\n+               Project   : Project_Id := No_Project;\n+            end case;\n+         end record;\n+      --  Information about files stored in the queue. The exact information\n+      --  depends on the builder, and in particular whether it only supports\n+      --  project-based files (in which case we have a full Source_Id record).\n+\n+      procedure Initialize\n+        (Queue_Per_Obj_Dir : Boolean;\n+         Force : Boolean := False);\n+      --  Initialize the queue.\n+      --  Queue_Per_Obj_Dir matches the --single-compile-per-obj-dir switch:\n+      --  when True, there cannot be simultaneous compilations with the object\n+      --  files in the same object directory when project files are used.\n+      --\n+      --  Nothing is done if Force is False and the queue was already\n+      --  initialized.\n+\n+      procedure Remove_Marks;\n+      --  Remove all marks set for the files.\n+      --  This means that the files will be handed to the compiler if they are\n+      --  added to the queue, and is mostly useful when recompiling several\n+      --  executables in non-project mode, as the switches may be different\n+      --  and -s may be in use.\n+\n+      function Is_Empty return Boolean;\n+      --  Returns True if the queue is empty\n+\n+      function Is_Virtually_Empty return Boolean;\n+      --  Returns True if the queue is empty or if all object directories are\n+      --  busy.\n+\n+      procedure Insert (Source  : Source_Info);\n+      function Insert (Source  : Source_Info) return Boolean;\n+      --  Insert source in the queue.\n+      --  The second version returns False if the Source was already marked in\n+      --  the queue.\n+\n+      procedure Extract\n+        (Found  : out Boolean;\n+         Source : out Source_Info);\n+      --  Get the first source that can be compiled from the queue. If no\n+      --  source may be compiled, sets Found to False. In this case, the value\n+      --  for Source is undefined.\n+\n+      function Size return Natural;\n+      --  Return the total size of the queue, including the sources already\n+      --  extracted.\n+\n+      function Processed return Natural;\n+      --  Return the number of source in the queue that have aready been\n+      --  processed.\n+\n+      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type);\n+      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type);\n+      --  Mark Obj_Dir as busy or free (see the parameter to Initialize)\n+\n+      function Element (Rank : Positive) return File_Name_Type;\n+      --  Get the file name for element of index Rank in the queue\n+\n+   end Queue;\n \n end Makeutl;"}, {"sha": "8f2376d7bb4337a29ec5cb8f2a9d8771982406c0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -4639,6 +4639,7 @@ package body Sem_Ch3 is\n       Nb_Index      : Nat;\n       P             : constant Node_Id := Parent (Def);\n       Priv          : Entity_Id;\n+      T_In_ALFA     : Boolean := True;\n \n    begin\n       if Nkind (Def) = N_Constrained_Array_Definition then\n@@ -4665,6 +4666,12 @@ package body Sem_Ch3 is\n             Check_SPARK_Restriction (\"subtype mark required\", Index);\n          end if;\n \n+         if Present (Etype (Index))\n+           and then not Is_In_ALFA (Etype (Index))\n+         then\n+            T_In_ALFA := False;\n+         end if;\n+\n          --  Add a subtype declaration for each index of private array type\n          --  declaration whose etype is also private. For example:\n \n@@ -4740,10 +4747,18 @@ package body Sem_Ch3 is\n             Check_SPARK_Restriction (\"subtype mark required\", Component_Typ);\n          end if;\n \n+         if Present (Element_Type)\n+           and then not Is_In_ALFA (Element_Type)\n+         then\n+            T_In_ALFA := False;\n+         end if;\n+\n       --  Ada 2005 (AI-230): Access Definition case\n \n       else pragma Assert (Present (Access_Definition (Component_Def)));\n \n+         T_In_ALFA := False;\n+\n          --  Indicate that the anonymous access type is created by the\n          --  array type declaration.\n \n@@ -4820,6 +4835,12 @@ package body Sem_Ch3 is\n                                (Implicit_Base, Finalize_Storage_Only\n                                                         (Element_Type));\n \n+         --  Final check for static bounds on array\n+\n+         if not Has_Static_Array_Bounds (T) then\n+            T_In_ALFA := False;\n+         end if;\n+\n       --  Unconstrained array case\n \n       else\n@@ -4844,6 +4865,7 @@ package body Sem_Ch3 is\n \n       Set_Component_Type (Base_Type (T), Element_Type);\n       Set_Packed_Array_Type (T, Empty);\n+      Set_Is_In_ALFA (T, T_In_ALFA);\n \n       if Aliased_Present (Component_Definition (Def)) then\n          Check_SPARK_Restriction"}, {"sha": "59d86593927d2a31e06336b5e4ca319cc95d6ef2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -5550,6 +5550,69 @@ package body Sem_Util is\n       end if;\n    end Has_Private_Component;\n \n+   -----------------------------\n+   -- Has_Static_Array_Bounds --\n+   -----------------------------\n+\n+   function Has_Static_Array_Bounds (Typ : Node_Id) return Boolean is\n+      Ndims : constant Nat := Number_Dimensions (Typ);\n+\n+      Index : Node_Id;\n+      Low   : Node_Id;\n+      High  : Node_Id;\n+\n+   begin\n+      --  Unconstrained types do not have static bounds\n+\n+      if not Is_Constrained (Typ) then\n+         return False;\n+      end if;\n+\n+      --  First treat specially string literals, as the lower bound and length\n+      --  of string literals are not stored like those of arrays.\n+\n+      --  A string literal always has static bounds\n+\n+      if Ekind (Typ) = E_String_Literal_Subtype then\n+         return True;\n+      end if;\n+\n+      --  Treat all dimensions in turn\n+\n+      Index := First_Index (Typ);\n+      for Indx in 1 .. Ndims loop\n+\n+         --  In case of an erroneous index which is not a discrete type, return\n+         --  that the type is not static.\n+\n+         if not Is_Discrete_Type (Etype (Index))\n+           or else Etype (Index) = Any_Type\n+         then\n+            return False;\n+         end if;\n+\n+         Get_Index_Bounds (Index, Low, High);\n+\n+         if Error_Posted (Low) or else Error_Posted (High) then\n+            return False;\n+         end if;\n+\n+         if         Is_OK_Static_Expression (Low)\n+           and then Is_OK_Static_Expression (High)\n+         then\n+            null;\n+         else\n+            return False;\n+         end if;\n+\n+         Next (Index);\n+      end loop;\n+\n+      --  If we fall through the loop, all indexes matched\n+\n+      return True;\n+   end Has_Static_Array_Bounds;\n+\n    ----------------\n    -- Has_Stream --\n    ----------------"}, {"sha": "ceba869804b06390a5ac61b2c1445a57e2a2c273", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e280f98126fb6f0df2d7d980615b97bc4d540e5e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=e280f98126fb6f0df2d7d980615b97bc4d540e5e", "patch": "@@ -624,6 +624,9 @@ package Sem_Util is\n    --  Check if a type has a (sub)component of a private type that has not\n    --  yet received a full declaration.\n \n+   function Has_Static_Array_Bounds (Typ : Node_Id) return Boolean;\n+   --  Return whether an array type has static bounds\n+\n    function Has_Stream (T : Entity_Id) return Boolean;\n    --  Tests if type T is derived from Ada.Streams.Root_Stream_Type, or in the\n    --  case of a composite type, has a component for which this predicate is"}]}