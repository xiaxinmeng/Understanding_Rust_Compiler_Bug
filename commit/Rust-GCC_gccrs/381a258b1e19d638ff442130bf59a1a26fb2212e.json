{"sha": "381a258b1e19d638ff442130bf59a1a26fb2212e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxYTI1OGIxZTE5ZDYzOGZmNDQyMTMwYmY1OWExYTI2ZmIyMjEyZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-02-25T21:20:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-02-25T21:20:34Z"}, "message": "revert: tree-flow.h (uid_decl_map_hash, [...]): Move ...\n\n2008-02-25  Richard Guenther  <rguenther@suse.de>\n\n\tRevert:\n\t2008-02-25  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (uid_decl_map_hash, uid_decl_map_eq): Move ...\n\t* tree.h (uid_decl_map_hash, uid_decl_map_eq): ... here.\n\t(lookup_decl_from_uid): Declare.\n\t* tree-ssa.c (uid_decl_map_eq, uid_decl_map_hash): Move ...\n\t* tree.c (uid_decl_map_eq, uid_decl_map_hash): ... here.\n\t(decl_for_uid_map): New global hashtable mapping DECL_UID\n\tto the decl tree.\n\t(init_ttree): Allocate it.\n\t(insert_decl_to_uid_decl_map): New helper function.\n\t(make_node_stat): Insert new decls into the map.\n\t(copy_node_stat): Likewise.\n\t(lookup_decl_from_uid): New function.\n\t(print_decl_for_uid_map_statistics): New helper.\n\t(dump_tree_statistics): Call it.\n\n\t* tree-flow.h (struct gimple_df): Make referenced_vars a bitmap.\n\t(referenced_var_iterator): Adjust.\n\t(FOR_EACH_REFERENCED_VAR): Adjust.\n\t(FOR_EACH_REFERENCED_VAR_IN_BITMAP): New iterator.\n\t(num_referenced_vars): Adjust.\n\t* tree-flow-inline.h (gimple_referenced_vars): Adjust.\n\t(first_referenced_var): Remove.\n\t(end_referenced_vars_p): Likewise.\n\t(next_referenced_var): Likewise.\n\t(referenced_var_iterator_set): New helper function.\n\t* tree-dfa.c (referenced_var_lookup): Adjust.\n\t(referenced_var_check_and_insert): Likewise.\n\t(remove_referenced_var): Likewise.\n\t* tree-ssa.c (verify_flow_insensitive_alias_info): Use\n\tFOR_EACH_REFERENCED_VAR_IN_BITMAP.\n\t(verify_call_clobbering): Likewise.\n\t(verify_memory_partitions): Likewise.\n\t(init_tree_ssa): Allocate bitmap instead of hashtable for\n\treferenced_vars.\n\t(delete_tree_ssa): Adjust.\n\t* tree-ssa-alias.c (mark_aliases_call_clobbered): Use\n\tFOR_EACH_REFERENCED_VAR_IN_BITMAP.\n\t(compute_tag_properties): Likewise.\n\t(set_initial_properties): Likewise.\n\t(find_partition_for): Likewise.\n\t(update_reference_counts): Likewise.\n\t(dump_may_aliases_for): Likewise.\n\t* tree-ssa-operands.c (add_virtual_operand): Likewise.\n\t(add_call_clobber_ops): Likewise.\n\t(add_call_read_ops): Likewise.\n\t(get_asm_expr_operands): Likewise.\n\t* tree-into-ssa.c (dump_decl_set): Likewise.\n\t(update_ssa): Likewise.\n\t* tree-sra.c (scan_function): Likewise.\n\t(decide_instantiations): Likewise.\n\t(scalarize_parms): Likewise.\n\t* tree-ssa-alias-warnings.c (build_reference_table): Likewise.\n\t(dsa_named_for): Likewise.\n\t* tree-ssa-structalias.c (update_alias_info): Likewise.\n\t(merge_smts_into): Likewise.\n\nFrom-SVN: r132643", "tree": {"sha": "8266407752dab136d0fc9a405ebbc3aca2e08f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8266407752dab136d0fc9a405ebbc3aca2e08f48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/381a258b1e19d638ff442130bf59a1a26fb2212e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381a258b1e19d638ff442130bf59a1a26fb2212e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/381a258b1e19d638ff442130bf59a1a26fb2212e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381a258b1e19d638ff442130bf59a1a26fb2212e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dd07840af477dc858b5a8117bf10679e7fbf819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd07840af477dc858b5a8117bf10679e7fbf819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd07840af477dc858b5a8117bf10679e7fbf819"}], "stats": {"total": 535, "additions": 297, "deletions": 238}, "files": [{"sha": "96535c82bcaa3d8a37c8800182916043fac9ed56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -1,3 +1,64 @@\n+2008-02-25  Richard Guenther  <rguenther@suse.de>\n+\n+\tRevert:\n+\t2008-02-25  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (uid_decl_map_hash, uid_decl_map_eq): Move ...\n+\t* tree.h (uid_decl_map_hash, uid_decl_map_eq): ... here.\n+\t(lookup_decl_from_uid): Declare.\n+\t* tree-ssa.c (uid_decl_map_eq, uid_decl_map_hash): Move ...\n+\t* tree.c (uid_decl_map_eq, uid_decl_map_hash): ... here.\n+\t(decl_for_uid_map): New global hashtable mapping DECL_UID\n+\tto the decl tree.\n+\t(init_ttree): Allocate it.\n+\t(insert_decl_to_uid_decl_map): New helper function.\n+\t(make_node_stat): Insert new decls into the map.\n+\t(copy_node_stat): Likewise.\n+\t(lookup_decl_from_uid): New function.\n+\t(print_decl_for_uid_map_statistics): New helper.\n+\t(dump_tree_statistics): Call it.\n+\n+\t* tree-flow.h (struct gimple_df): Make referenced_vars a bitmap.\n+\t(referenced_var_iterator): Adjust.\n+\t(FOR_EACH_REFERENCED_VAR): Adjust.\n+\t(FOR_EACH_REFERENCED_VAR_IN_BITMAP): New iterator.\n+\t(num_referenced_vars): Adjust.\n+\t* tree-flow-inline.h (gimple_referenced_vars): Adjust.\n+\t(first_referenced_var): Remove.\n+\t(end_referenced_vars_p): Likewise.\n+\t(next_referenced_var): Likewise.\n+\t(referenced_var_iterator_set): New helper function.\n+\t* tree-dfa.c (referenced_var_lookup): Adjust.\n+\t(referenced_var_check_and_insert): Likewise.\n+\t(remove_referenced_var): Likewise.\n+\t* tree-ssa.c (verify_flow_insensitive_alias_info): Use\n+\tFOR_EACH_REFERENCED_VAR_IN_BITMAP.\n+\t(verify_call_clobbering): Likewise.\n+\t(verify_memory_partitions): Likewise.\n+\t(init_tree_ssa): Allocate bitmap instead of hashtable for\n+\treferenced_vars.\n+\t(delete_tree_ssa): Adjust.\n+\t* tree-ssa-alias.c (mark_aliases_call_clobbered): Use\n+\tFOR_EACH_REFERENCED_VAR_IN_BITMAP.\n+\t(compute_tag_properties): Likewise.\n+\t(set_initial_properties): Likewise.\n+\t(find_partition_for): Likewise.\n+\t(update_reference_counts): Likewise.\n+\t(dump_may_aliases_for): Likewise.\n+\t* tree-ssa-operands.c (add_virtual_operand): Likewise.\n+\t(add_call_clobber_ops): Likewise.\n+\t(add_call_read_ops): Likewise.\n+\t(get_asm_expr_operands): Likewise.\n+\t* tree-into-ssa.c (dump_decl_set): Likewise.\n+\t(update_ssa): Likewise.\n+\t* tree-sra.c (scan_function): Likewise.\n+\t(decide_instantiations): Likewise.\n+\t(scalarize_parms): Likewise.\n+\t* tree-ssa-alias-warnings.c (build_reference_table): Likewise.\n+\t(dsa_named_for): Likewise.\n+\t* tree-ssa-structalias.c (update_alias_info): Likewise.\n+\t(merge_smts_into): Likewise.\n+\n 2008-02-25  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/29549"}, {"sha": "346f6f3803cee4dec82d277870174d1caaae7424", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -641,16 +641,12 @@ find_vars_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n tree \n referenced_var_lookup (unsigned int uid)\n {\n-  tree var;\n-\n-  gcc_assert (bitmap_bit_p (gimple_referenced_vars (cfun), uid));\n-\n-  /* For now also assert that the variable is really referenced.\n-     Otherwise callers need to deal with the result from this function\n-     being NULL.  */\n-  var = lookup_decl_from_uid (uid);\n-  gcc_assert (var);\n-  return var;\n+  tree h;\n+  struct tree_decl_minimal in;\n+  in.uid = uid;\n+  h = (tree) htab_find_with_hash (gimple_referenced_vars (cfun), &in, uid);\n+  gcc_assert (h || uid == 0);\n+  return h;\n }\n \n /* Check if TO is in the referenced_vars hash table and insert it if not.  \n@@ -659,13 +655,23 @@ referenced_var_lookup (unsigned int uid)\n bool\n referenced_var_check_and_insert (tree to)\n { \n+  tree h, *loc;\n+  struct tree_decl_minimal in;\n   unsigned int uid = DECL_UID (to);\n \n-  if (bitmap_bit_p (gimple_referenced_vars (cfun), uid))\n-    return false;\n-\n-  bitmap_set_bit (gimple_referenced_vars (cfun), uid);\n+  in.uid = uid;\n+  h = (tree) htab_find_with_hash (gimple_referenced_vars (cfun), &in, uid);\n+  if (h)\n+    {\n+      /* DECL_UID has already been entered in the table.  Verify that it is\n+\t the same entry as TO.  See PR 27793.  */\n+      gcc_assert (h == to);\n+      return false;\n+    }\n \n+  loc = (tree *) htab_find_slot_with_hash (gimple_referenced_vars (cfun),\n+\t\t\t\t\t   &in, uid, INSERT);\n+  *loc = to;\n   return true;\n }\n \n@@ -755,6 +761,8 @@ void\n remove_referenced_var (tree var)\n {\n   var_ann_t v_ann;\n+  struct tree_decl_minimal in;\n+  void **loc;\n   unsigned int uid = DECL_UID (var);\n   subvar_t sv;\n \n@@ -774,7 +782,10 @@ remove_referenced_var (tree var)\n     ggc_free (v_ann);\n   var->base.ann = NULL;\n   gcc_assert (DECL_P (var));\n-  bitmap_clear_bit (gimple_referenced_vars (cfun), uid);\n+  in.uid = uid;\n+  loc = htab_find_slot_with_hash (gimple_referenced_vars (cfun), &in, uid,\n+\t\t\t\t  NO_INSERT);\n+  htab_clear_slot (gimple_referenced_vars (cfun), loc);\n }\n \n "}, {"sha": "1afbd1a8fc79a0936ca03122d91ce147de1090f1", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -66,7 +66,7 @@ gimple_call_clobbered_vars (const struct function *fun)\n }\n \n /* Array of all variables referenced in the function.  */\n-static inline bitmap\n+static inline htab_t\n gimple_referenced_vars (const struct function *fun)\n {\n   if (!fun->gimple_df)\n@@ -145,23 +145,34 @@ next_htab_element (htab_iterator *hti)\n   return NULL;\n }\n \n-/* Helper for FOR_EACH_REFERENCED_VAR.  Needed unless iterator\n-   bodies deal with NULL elements.  */\n+/* Initialize ITER to point to the first referenced variable in the\n+   referenced_vars hashtable, and return that variable.  */\n+\n+static inline tree\n+first_referenced_var (referenced_var_iterator *iter)\n+{\n+  return (tree) first_htab_element (&iter->hti,\n+\t\t\t\t    gimple_referenced_vars (cfun));\n+}\n+\n+/* Return true if we have hit the end of the referenced variables ITER is\n+   iterating through.  */\n \n static inline bool\n-referenced_var_iterator_set (referenced_var_iterator *ri, tree *var)\n+end_referenced_vars_p (const referenced_var_iterator *iter)\n {\n-  while (1)\n-    {\n-      if (!bmp_iter_set (&ri->bi, &ri->i))\n-\treturn false;\n-      *var = lookup_decl_from_uid (ri->i);\n-      if (*var)\n-\treturn true;\n-      bmp_iter_next (&ri->bi, &ri->i);\n-    }\n+  return end_htab_p (&iter->hti);\n }\n \n+/* Make ITER point to the next referenced_var in the referenced_var hashtable,\n+   and return that variable.  */\n+\n+static inline tree\n+next_referenced_var (referenced_var_iterator *iter)\n+{\n+  return (tree) next_htab_element (&iter->hti);\n+} \n+\n /* Fill up VEC with the variables in the referenced vars hashtable.  */\n \n static inline void"}, {"sha": "286c60bce2038cb19174dbc02d021717801ebdbc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -138,8 +138,8 @@ struct mem_ref_stats_d GTY(())\n    fields should have gimple_set accessor.  */\n struct gimple_df GTY(())\n {\n-  /* Bitmap of all variables referenced in the function.  */\n-  bitmap referenced_vars;\n+  /* Array of all variables referenced in the function.  */\n+  htab_t GTY((param_is (union tree_node))) referenced_vars;\n \n   /* A list of all the noreturn calls passed to modify_stmt.\n      cleanup_control_flow uses it to detect cases where a mid-block\n@@ -569,29 +569,25 @@ struct int_tree_map GTY(())\n extern unsigned int int_tree_map_hash (const void *);\n extern int int_tree_map_eq (const void *, const void *);\n \n+extern unsigned int uid_decl_map_hash (const void *);\n+extern int uid_decl_map_eq (const void *, const void *);\n+\n typedef struct \n {\n-  bitmap_iterator bi;\n-  unsigned int i;\n+  htab_iterator hti;\n } referenced_var_iterator;\n \n+\n /* This macro loops over all the referenced vars, one at a time, putting the\n-   current var in VAR.  Note:  It is undefined whether referenced variables\n-   you add or remove during the iteration show up or not.  */\n+   current var in VAR.  Note:  You are not allowed to add referenced variables\n+   to the hashtable while using this macro.  Doing so may cause it to behave\n+   erratically.  */\n \n #define FOR_EACH_REFERENCED_VAR(VAR, ITER) \\\n-  for (bmp_iter_set_init (&(ITER).bi, gimple_referenced_vars (cfun), 0, &(ITER).i); \\\n-       referenced_var_iterator_set (&(ITER), &(VAR)); \\\n-       bmp_iter_next (&(ITER).bi, &(ITER).i))\n-\n-/* Iterate over all variables whose UID is set in the bitmap BM, putting the\n-   current var in VAR.  Note: It is undefined whether variables you add or\n-   remove during the iteration show up or not.  */\n+  for ((VAR) = first_referenced_var (&(ITER)); \\\n+       !end_referenced_vars_p (&(ITER)); \\\n+       (VAR) = next_referenced_var (&(ITER))) \n \n-#define FOR_EACH_REFERENCED_VAR_IN_BITMAP(BM, VAR, ITER) \\\n-  for (bmp_iter_set_init (&(ITER).bi, (BM), 0, &(ITER).i); \\\n-       referenced_var_iterator_set (&(ITER), &(VAR)); \\\n-       bmp_iter_next (&(ITER).bi, &(ITER).i))\n \n typedef struct\n {\n@@ -613,7 +609,7 @@ typedef struct\n \n extern tree referenced_var_lookup (unsigned int);\n extern bool referenced_var_check_and_insert (tree);\n-#define num_referenced_vars bitmap_count_bits (gimple_referenced_vars (cfun))\n+#define num_referenced_vars htab_elements (gimple_referenced_vars (cfun))\n #define referenced_var(i) referenced_var_lookup (i)\n \n #define num_ssa_names (VEC_length (tree, cfun->gimple_df->ssa_names))"}, {"sha": "c55f7363697b65edf14e25a769c5a7349e2ee471", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -1463,14 +1463,14 @@ dump_decl_set (FILE *file, bitmap set)\n {\n   if (set)\n     {\n-      referenced_var_iterator ri;\n-      tree var;\n+      bitmap_iterator bi;\n+      unsigned i;\n \n       fprintf (file, \"{ \");\n \n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (set, var, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n \t{\n-\t  print_generic_expr (file, var, 0);\n+\t  print_generic_expr (file, referenced_var (i), 0);\n \t  fprintf (file, \" \");\n \t}\n \n@@ -3201,11 +3201,12 @@ update_ssa (unsigned update_flags)\n      memory symbols into the set MEM_SYMS_TO_RENAME.  */\n   if (!bitmap_empty_p (syms_to_rename))\n     {\n-      referenced_var_iterator ri;\n-      tree sym;\n+      unsigned i;\n+      bitmap_iterator bi;\n \n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (syms_to_rename, sym, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n \t{\n+\t  tree sym = referenced_var (i);\n \t  if (is_gimple_reg (sym))\n \t    bitmap_set_bit (regs_to_rename, i);\n \t  else"}, {"sha": "26f1af4196a00729f0f72addb7b04bb667ef91c8", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -1162,17 +1162,18 @@ scan_function (void)\n   static const struct sra_walk_fns fns = {\n     scan_use, scan_copy, scan_init, scan_ldst, true\n   };\n+  bitmap_iterator bi;\n \n   sra_walk_function (&fns);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      referenced_var_iterator ri;\n-      tree var;\n+      unsigned i;\n \n       fputs (\"\\nScan results:\\n\", dump_file);\n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (sra_candidates, var, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (sra_candidates, 0, i, bi)\n \t{\n+\t  tree var = referenced_var (i);\n \t  struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n \t  if (elt)\n \t    scan_dump (elt);\n@@ -1949,18 +1950,19 @@ decide_block_copy (struct sra_elt *elt)\n static void\n decide_instantiations (void)\n {\n+  unsigned int i;\n   bool cleared_any;\n   bitmap_head done_head;\n-  referenced_var_iterator ri;\n-  tree var;\n+  bitmap_iterator bi;\n \n   /* We cannot clear bits from a bitmap we're iterating over,\n      so save up all the bits to clear until the end.  */\n   bitmap_initialize (&done_head, &bitmap_default_obstack);\n   cleared_any = false;\n \n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (sra_candidates, var, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (sra_candidates, 0, i, bi)\n     {\n+      tree var = referenced_var (i);\n       struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n       if (elt)\n \t{\n@@ -1970,7 +1972,7 @@ decide_instantiations (void)\n \t}\n       if (!elt)\n \t{\n-\t  bitmap_set_bit (&done_head, DECL_UID (var));\n+\t  bitmap_set_bit (&done_head, i);\n \t  cleared_any = true;\n \t}\n     }\n@@ -3530,11 +3532,12 @@ static void\n scalarize_parms (void)\n {\n   tree list = NULL;\n-  referenced_var_iterator ri;\n-  tree var;\n+  unsigned i;\n+  bitmap_iterator bi;\n \n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (needs_copy_in, var, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (needs_copy_in, 0, i, bi)\n     {\n+      tree var = referenced_var (i);\n       struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n       generate_copy_inout (elt, true, var, &list);\n     }"}, {"sha": "05d215c0f28d48198aa8d90dad945ef91000abc6", "filename": "gcc/tree-ssa-alias-warnings.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-alias-warnings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-alias-warnings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-warnings.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -452,11 +452,14 @@ build_reference_table (void)\n \t  /* Add all aliased names to the interesting reference list.  */\n \t  if (pi->pt_vars)\n \t    {\n-\t      referenced_var_iterator ri;\n-\t      tree alias;\n-\n-\t      FOR_EACH_REFERENCED_VAR_IN_BITMAP (pi->pt_vars, alias, ri)\n-\t\tadd_key (ref_table->objs, alias, references_pool);\n+\t      unsigned ix;\n+\t      bitmap_iterator bi;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n+\t\t{\n+\t\t  tree alias = referenced_var (ix);\n+\t\t  add_key (ref_table->objs, alias, references_pool);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -911,13 +914,17 @@ dsa_named_for (tree ptr)\n       /* For all the variables it could be aliased to.  */\n       if (pi->pt_vars)\n \t{\n-\t  referenced_var_iterator ri;\n-\t  tree alias;\n+\t  unsigned ix;\n+\t  bitmap_iterator bi;\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n+\t    {\n+\t      tree alias = referenced_var (ix);\n \n-\t  FOR_EACH_REFERENCED_VAR_IN_BITMAP (pi->pt_vars, alias, ri)\n-\t    if (nonstandard_alias_p (ptr, alias, false))\n-\t      strict_aliasing_warn (SSA_NAME_DEF_STMT (ptr),\n-\t\t\t\t    ptr, true, alias, false, true);\n+\t      if (nonstandard_alias_p (ptr, alias, false))\n+\t\tstrict_aliasing_warn (SSA_NAME_DEF_STMT (ptr),\n+\t\t\t\t      ptr, true, alias, false, true);\n+\t    }\n \t}\n     }\n }"}, {"sha": "7ab2f6b5473eda48a7425625c82482cccc96bae3", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -390,7 +390,8 @@ mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n \t\t\t     bitmap on_worklist, bitmap queued)\n {\n   bitmap aliases;\n-  referenced_var_iterator ri;\n+  bitmap_iterator bi;\n+  unsigned int i;\n   tree entry;\n   var_ann_t ta = var_ann (tag);\n \n@@ -400,8 +401,9 @@ mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n   if (!aliases)\n     return;\n \n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (aliases, entry, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n     {\n+      entry = referenced_var (i);\n       /* If you clobber one part of a structure, you\n \t clobber the entire thing.  While this does not make\n \t the world a particularly nice place, it is necessary\n@@ -418,9 +420,9 @@ mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n     }\n   if (!bitmap_empty_p (queued))\n     {\n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (queued, entry, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (queued, 0, i, bi)\n \t{\n-\t  subvar_t svars = get_subvars_for_var (entry);\n+\t  subvar_t svars = get_subvars_for_var (referenced_var (i));\n \t  unsigned int i;\n \t  tree subvar;\n \n@@ -482,7 +484,8 @@ compute_tag_properties (void)\n       for (k = 0; VEC_iterate (tree, taglist, k, tag); k++)\n \t{\n \t  bitmap ma;\n-\t  referenced_var_iterator ri;\n+\t  bitmap_iterator bi;\n+\t  unsigned int i;\n \t  tree entry;\n \t  bool tagcc = is_call_clobbered (tag);\n \t  bool tagglobal = MTAG_GLOBAL (tag);\n@@ -494,8 +497,9 @@ compute_tag_properties (void)\n \t  if (!ma)\n \t    continue;\n \n-\t  FOR_EACH_REFERENCED_VAR_IN_BITMAP (ma, entry, ri)\n+\t  EXECUTE_IF_SET_IN_BITMAP (ma, 0, i, bi)\n \t    {\n+\t      entry = referenced_var (i);\n \t      /* Call clobbered entries cause the tag to be marked\n \t\t call clobbered.  */\n \t      if (!tagcc && is_call_clobbered (entry))\n@@ -577,10 +581,12 @@ set_initial_properties (struct alias_info *ai)\n \n \t  if (pi->pt_vars)\n \t    {\n-\t      referenced_var_iterator ri;\n-\t      tree alias;\n-\t      FOR_EACH_REFERENCED_VAR_IN_BITMAP (pi->pt_vars, alias, ri)\n+\t      bitmap_iterator bi;\n+\t      unsigned int j;\t      \n+\t      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n \t\t{\n+\t\t  tree alias = referenced_var (j);\n+\n \t\t  /* If you clobber one part of a structure, you\n \t\t     clobber the entire thing.  While this does not make\n \t\t     the world a particularly nice place, it is necessary\n@@ -594,9 +600,9 @@ set_initial_properties (struct alias_info *ai)\n \t      /* Process variables we need to clobber all parts of.  */\n \t      if (!bitmap_empty_p (queued))\n \t\t{\n-\t\t  FOR_EACH_REFERENCED_VAR_IN_BITMAP (queued, alias, ri)\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (queued, 0, j, bi)\n \t\t    {\n-\t\t      subvar_t svars = get_subvars_for_var (alias);\n+\t\t      subvar_t svars = get_subvars_for_var (referenced_var (j));\n \t\t      unsigned int i;\n \t\t      tree subvar;\n \n@@ -1182,11 +1188,13 @@ find_partition_for (mem_sym_stats_t mp_p)\n static void\n rewrite_alias_set_for (tree tag, bitmap new_aliases)\n {\n-  referenced_var_iterator ri;\n+  bitmap_iterator bi;\n+  unsigned i;\n   tree mpt, sym;\n \n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (MTAG_ALIASES (tag), sym, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (MTAG_ALIASES (tag), 0, i, bi)\n     {\n+      sym = referenced_var (i);\n       mpt = memory_partition (sym);\n       if (mpt)\n \tbitmap_set_bit (new_aliases, DECL_UID (mpt));\n@@ -1297,10 +1305,9 @@ estimate_vop_reduction (struct mem_ref_stats_d *mem_ref_stats,\n static void\n update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n {\n-  referenced_var_iterator ri;\n+  unsigned i;\n+  bitmap_iterator bi;\n   mem_sym_stats_t sym_stats;\n-  unsigned int i;\n-  tree sym;\n \n   for (i = 1; i < num_ssa_names; i++)\n     {\n@@ -1313,7 +1320,9 @@ update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n \t  && (pi = SSA_NAME_PTR_INFO (ptr)) != NULL\n \t  && pi->is_dereferenced)\n \t{\n-\t  tree tag, alias;\n+\t  unsigned j;\n+\t  bitmap_iterator bj;\n+\t  tree tag;\n \t  mem_sym_stats_t ptr_stats, tag_stats;\n \n \t  /* If PTR has flow-sensitive points-to information, use\n@@ -1339,8 +1348,9 @@ update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n \t     TAG's alias set, add as many indirect references to ALIAS\n \t     as direct references there are for TAG.  */\n \t  if (MTAG_ALIASES (tag))\n-\t    FOR_EACH_REFERENCED_VAR_IN_BITMAP (MTAG_ALIASES (tag), alias, ri)\n+\t    EXECUTE_IF_SET_IN_BITMAP (MTAG_ALIASES (tag), 0, j, bj)\n \t      {\n+\t\ttree alias = referenced_var (j);\n \t\tsym_stats = get_mem_sym_stats_for (alias);\n \n \t\t/* All the direct references to TAG are indirect references\n@@ -1360,8 +1370,9 @@ update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n \n   /* Call-clobbered symbols are indirectly written at every\n      call/asm site.  */\n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_call_clobbered_vars (cfun), sym, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n     {\n+      tree sym = referenced_var (i);\n       sym_stats = get_mem_sym_stats_for (sym);\n       sym_stats->num_indirect_writes += mem_ref_stats->num_call_sites\n \t                                + mem_ref_stats->num_asm_sites;\n@@ -1370,8 +1381,9 @@ update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n   /* Addressable symbols are indirectly written at some ASM sites.\n      Since only ASM sites that clobber memory actually affect\n      addressable symbols, this is an over-estimation.  */\n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_addressable_vars (cfun), sym, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_addressable_vars (cfun), 0, i, bi)\n     {\n+      tree sym = referenced_var (i);\n       sym_stats = get_mem_sym_stats_for (sym);\n       sym_stats->num_indirect_writes += mem_ref_stats->num_asm_sites;\n     }\n@@ -3470,12 +3482,14 @@ dump_may_aliases_for (FILE *file, tree var)\n   aliases = MTAG_ALIASES (var);\n   if (aliases)\n     {\n-      referenced_var_iterator ri;\n+      bitmap_iterator bi;\n+      unsigned int i;\n       tree al;\n \n       fprintf (file, \"{ \");\n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (aliases, al, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t{\n+\t  al = referenced_var (i);\n \t  print_generic_expr (file, al, dump_flags);\n \t  fprintf (file, \" \");\n \t}"}, {"sha": "ceb18ba55a63391d67974281307d8b9f3a733714", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -1469,9 +1469,7 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n   if (MTAG_P (var))\n     aliases = MTAG_ALIASES (var);\n \n-  if (aliases == NULL\n-      /* ???  We should not have created an empty aliases bitmap.  */\n-      || bitmap_empty_p (aliases))\n+  if (aliases == NULL)\n     {\n       if (!gimple_aliases_computed_p (cfun)\n \t  && (flags & opf_def))\n@@ -1485,16 +1483,18 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n     }\n   else\n     {\n-      referenced_var_iterator ri;\n+      bitmap_iterator bi;\n+      unsigned int i;\n       bool none_added = true;\n-      tree al;\n       \n       /* The variable is aliased.  Add its aliases to the virtual\n \t operands.  */\n       gcc_assert (!bitmap_empty_p (aliases));\n \n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (aliases, al, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t{\n+\t  tree al = referenced_var (i);\n+\n \t  /* For SFTs we have to consider all subvariables of the parent var\n \t     if it is a potential points-to location.  */\n \t  if (TREE_CODE (al) == STRUCT_FIELD_TAG\n@@ -1779,10 +1779,10 @@ get_tmr_operands (tree stmt, tree expr, int flags)\n static void\n add_call_clobber_ops (tree stmt, tree callee)\n {\n-  referenced_var_iterator ri;\n+  unsigned u;\n+  bitmap_iterator bi;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n   bitmap not_read_b, not_written_b;\n-  tree var;\n   \n   /* If we created .GLOBAL_VAR earlier, just use it.  */\n   if (gimple_global_var (cfun))\n@@ -1796,18 +1796,17 @@ add_call_clobber_ops (tree stmt, tree callee)\n      set for each static if the call being processed does not read\n      or write that variable.  */\n   not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n-  not_written_b = callee ? ipa_reference_get_not_written_global (callee) : NULL;\n+  not_written_b = callee ? ipa_reference_get_not_written_global (callee) : NULL; \n \n   /* Add a VDEF operand for every call clobbered variable.  */\n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_call_clobbered_vars (cfun), var, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)\n     {\n-      unsigned int escape_mask;\n+      tree var = referenced_var_lookup (u);\n+      unsigned int escape_mask = var_ann (var)->escape_mask;\n       tree real_var = var;\n       bool not_read;\n       bool not_written;\n-\n-      escape_mask = var_ann (var)->escape_mask;\n-\n+      \n       /* Not read and not written are computed on regular vars, not\n \t subvars, so look at the parent var if this is an SFT. */\n       if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n@@ -1864,10 +1863,10 @@ add_call_clobber_ops (tree stmt, tree callee)\n static void\n add_call_read_ops (tree stmt, tree callee)\n {\n-  referenced_var_iterator ri;\n+  unsigned u;\n+  bitmap_iterator bi;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n   bitmap not_read_b;\n-  tree var;\n \n   /* if the function is not pure, it may reference memory.  Add\n      a VUSE for .GLOBAL_VAR if it has been created.  See add_referenced_var\n@@ -1882,11 +1881,12 @@ add_call_read_ops (tree stmt, tree callee)\n   not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n \n   /* Add a VUSE for each call-clobbered variable.  */\n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_call_clobbered_vars (cfun), var, ri)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, u, bi)\n     {\n+      tree var = referenced_var (u);\n       tree real_var = var;\n       bool not_read;\n-\n+      \n       clobber_stats.readonly_clobbers++;\n \n       /* Not read and not written are computed on regular vars, not\n@@ -2008,18 +2008,21 @@ get_asm_expr_operands (tree stmt)\n   for (link = ASM_CLOBBERS (stmt); link; link = TREE_CHAIN (link))\n     if (strcmp (TREE_STRING_POINTER (TREE_VALUE (link)), \"memory\") == 0)\n       {\n-\treferenced_var_iterator ri;\n-\ttree var;\n+\tunsigned i;\n+\tbitmap_iterator bi;\n \n \ts_ann->references_memory = true;\n \n-\tFOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_call_clobbered_vars (cfun),\n-\t\t\t\t\t   var, ri)\n-\t  add_stmt_operand (&var, s_ann, opf_def | opf_implicit);\n+\tEXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n+\t  {\n+\t    tree var = referenced_var (i);\n+\t    add_stmt_operand (&var, s_ann, opf_def | opf_implicit);\n+\t  }\n \n-\tFOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_addressable_vars (cfun),\n-\t\t\t\t\t   var, ri)\n+\tEXECUTE_IF_SET_IN_BITMAP (gimple_addressable_vars (cfun), 0, i, bi)\n \t  {\n+\t    tree var = referenced_var (i);\n+\n \t    /* Subvars are explicitly represented in this list, so we\n \t       don't need the original to be added to the clobber ops,\n \t       but the original *will* be in this list because we keep"}, {"sha": "70a9d3212c6592bce8a059bcc80142c031b40844", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -3313,11 +3313,12 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t call-clobbered.  */\n       if (stmt_escape_type != NO_ESCAPE)\n \t{\n-\t  referenced_var_iterator ri;\n-\t  tree rvar;\n+\t  bitmap_iterator bi;\n+\t  unsigned i;\n \n-\t  FOR_EACH_REFERENCED_VAR_IN_BITMAP (addr_taken, rvar, ri)\n+\t  EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n \t    {\n+\t      tree rvar = referenced_var (i);\n \t      if (!unmodifiable_var_p (rvar))\n \t\tmark_call_clobbered (rvar, stmt_escape_type);\n \t    }\n@@ -3475,8 +3476,8 @@ update_alias_info (tree stmt, struct alias_info *ai)\n      memory reference stats for all memory symbols referenced by STMT.  */\n   if (stmt_references_memory_p (stmt))\n     {\n-      referenced_var_iterator ri;\n-      tree sym;\n+      unsigned i;\n+      bitmap_iterator bi;\n \n       mem_ref_stats->num_mem_stmts++;\n \n@@ -3503,8 +3504,9 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t memory symbols in its argument list, but these cases do not\n \t occur so frequently as to constitute a serious problem.  */\n       if (STORED_SYMS (stmt))\n-\tFOR_EACH_REFERENCED_VAR_IN_BITMAP (STORED_SYMS (stmt), sym, ri)\n+\tEXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n \t  {\n+\t    tree sym = referenced_var (i);\n \t    pointer_set_insert (ai->written_vars, sym);\n \t    if (!stmt_dereferences_ptr_p\n \t\t&& stmt_escape_type != ESCAPE_TO_CALL\n@@ -3518,8 +3520,8 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t  && stmt_escape_type != ESCAPE_TO_CALL\n \t  && stmt_escape_type != ESCAPE_TO_PURE_CONST\n \t  && stmt_escape_type != ESCAPE_TO_ASM)\n-\tFOR_EACH_REFERENCED_VAR_IN_BITMAP (LOADED_SYMS (stmt), sym, ri)\n-\t  update_mem_sym_stats_from_stmt (sym, stmt, 1, 0);\n+\tEXECUTE_IF_SET_IN_BITMAP (LOADED_SYMS (stmt), 0, i, bi)\n+\t  update_mem_sym_stats_from_stmt (referenced_var (i), stmt, 1, 0);\n     }\n }\n \n@@ -4879,6 +4881,8 @@ set_used_smts (void)\n static void\n merge_smts_into (tree p, bitmap solution)\n {\n+  unsigned int i;\n+  bitmap_iterator bi;\n   tree smt;\n   bitmap aliases;\n   tree var = p;\n@@ -4890,19 +4894,18 @@ merge_smts_into (tree p, bitmap solution)\n   if (smt)\n     {\n       alias_set_type smtset = get_alias_set (TREE_TYPE (smt));\n-      referenced_var_iterator ri;\n-      tree newsmt;\n \n       /* Need to set the SMT subsets first before this\n \t will work properly.  */\n       bitmap_set_bit (solution, DECL_UID (smt));\n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (used_smts, newsmt, ri)\n+      EXECUTE_IF_SET_IN_BITMAP (used_smts, 0, i, bi)\n \t{\n+\t  tree newsmt = referenced_var (i);\n \t  tree newsmttype = TREE_TYPE (newsmt);\n \n \t  if (alias_set_subset_of (get_alias_set (newsmttype),\n \t\t\t\t   smtset))\n-\t    bitmap_set_bit (solution, DECL_UID (newsmt));\n+\t    bitmap_set_bit (solution, i);\n \t}\n \n       aliases = MTAG_ALIASES (smt);"}, {"sha": "6c06df094b175c70d61e33a26f525e526ceb5958", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -378,23 +378,28 @@ verify_flow_insensitive_alias_info (void)\n \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n+      unsigned int j;\n       bitmap aliases;\n       tree alias;\n-      referenced_var_iterator ri;\n+      bitmap_iterator bi;\n \n       if (!MTAG_P (var) || !MTAG_ALIASES (var))\n \tcontinue;\n       \n       aliases = MTAG_ALIASES (var);\n \n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (aliases, alias, ri)\n-\tif (TREE_CODE (alias) != MEMORY_PARTITION_TAG\n-\t    && !may_be_aliased (alias))\n-\t  {\n-\t    error (\"non-addressable variable inside an alias set\");\n-\t    debug_variable (alias);\n-\t    goto err;\n-\t  }\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, j, bi)\n+\t{\n+\t  alias = referenced_var (j);\n+\n+\t  if (TREE_CODE (alias) != MEMORY_PARTITION_TAG\n+\t      && !may_be_aliased (alias))\n+\t    {\n+\t      error (\"non-addressable variable inside an alias set\");\n+\t      debug_variable (alias);\n+\t      goto err;\n+\t    }\n+\t}\n     }\n \n   return;\n@@ -481,17 +486,20 @@ verify_flow_sensitive_alias_info (void)\n static void\n verify_call_clobbering (void)\n {\n-  referenced_var_iterator rvi;\n+  unsigned int i;\n+  bitmap_iterator bi;\n   tree var;\n+  referenced_var_iterator rvi;\n \n   /* At all times, the result of the call_clobbered flag should\n      match the result of the call_clobbered_vars bitmap.  Verify both\n      that everything in call_clobbered_vars is marked\n      call_clobbered, and that everything marked\n      call_clobbered is in call_clobbered_vars.  */\n-  FOR_EACH_REFERENCED_VAR_IN_BITMAP (gimple_call_clobbered_vars (cfun),\n-\t\t\t\t     var, rvi)\n+  EXECUTE_IF_SET_IN_BITMAP (gimple_call_clobbered_vars (cfun), 0, i, bi)\n     {\n+      var = referenced_var (i);\n+\n       if (memory_partition (var))\n \tvar = memory_partition (var);\n \n@@ -542,8 +550,8 @@ verify_memory_partitions (void)\n \n   for (i = 0; VEC_iterate (tree, mpt_table, i, mpt); i++)\n     {\n-      referenced_var_iterator ri;\n-      tree var;\n+      unsigned j;\n+      bitmap_iterator bj;\n \n       if (MPT_SYMBOLS (mpt) == NULL)\n \t{\n@@ -552,14 +560,17 @@ verify_memory_partitions (void)\n \t  goto err;\n \t}\n \n-      FOR_EACH_REFERENCED_VAR_IN_BITMAP (MPT_SYMBOLS (mpt), var, ri)\n-\tif (pointer_set_insert (partitioned_syms, var))\n-\t  {\n-\t    error (\"Partitioned symbols should belong to exactly one \"\n-\t\t   \"partition\");\n-\t    debug_variable (var);\n-\t    goto err;\n-\t  }\n+      EXECUTE_IF_SET_IN_BITMAP (MPT_SYMBOLS (mpt), 0, j, bj)\n+\t{\n+\t  tree var = referenced_var (j);\n+\t  if (pointer_set_insert (partitioned_syms, var))\n+\t    {\n+\t      error (\"Partitioned symbols should belong to exactly one \"\n+\t\t     \"partition\");\n+\t      debug_variable (var);\n+\t      goto err;\n+\t    }\n+\t}\n     }\n \n   pointer_set_destroy (partitioned_syms);\n@@ -763,6 +774,24 @@ int_tree_map_hash (const void *item)\n   return ((const struct int_tree_map *)item)->uid;\n }\n \n+/* Return true if the DECL_UID in both trees are equal.  */\n+\n+int\n+uid_decl_map_eq (const void *va, const void *vb)\n+{\n+  const_tree a = (const_tree) va;\n+  const_tree b = (const_tree) vb;\n+  return (a->decl_minimal.uid == b->decl_minimal.uid);\n+}\n+\n+/* Hash a tree in a uid_decl_map.  */\n+\n+unsigned int\n+uid_decl_map_hash (const void *item)\n+{\n+  return ((const_tree)item)->decl_minimal.uid;\n+}\n+\n /* Return true if the uid in both int tree maps are equal.  */\n \n static int\n@@ -806,7 +835,8 @@ void\n init_tree_ssa (void)\n {\n   cfun->gimple_df = GGC_CNEW (struct gimple_df);\n-  cfun->gimple_df->referenced_vars = BITMAP_GGC_ALLOC ();\n+  cfun->gimple_df->referenced_vars = htab_create_ggc (20, uid_decl_map_hash, \n+\t\t\t\t     \t\t      uid_decl_map_eq, NULL);\n   cfun->gimple_df->default_defs = htab_create_ggc (20, uid_ssaname_map_hash, \n \t\t\t\t                   uid_ssaname_map_eq, NULL);\n   cfun->gimple_df->var_anns = htab_create_ggc (20, var_ann_hash, \n@@ -863,6 +893,7 @@ delete_tree_ssa (void)\n         ggc_free (var->base.ann);\n       var->base.ann = NULL;\n     }\n+  htab_delete (gimple_referenced_vars (cfun));\n   cfun->gimple_df->referenced_vars = NULL;\n \n   fini_ssanames ();"}, {"sha": "043968cb95f22086879549046810979807a2625f", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -110,12 +110,6 @@ static GTY(()) int next_decl_uid;\n /* Unique id for next type created.  */\n static GTY(()) int next_type_uid = 1;\n \n-/* Mapping from unique DECL_UID to the decl tree node.  */\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-     htab_t decl_for_uid_map;\n-\n-static void insert_decl_to_uid_decl_map (tree);\n-\n /* Since we cannot rehash a type after it is in the table, we have to\n    keep the hash code.  */\n \n@@ -237,9 +231,6 @@ init_ttree (void)\n   \n   int_cst_node = make_node (INTEGER_CST);\n \n-  decl_for_uid_map = htab_create_ggc (4093, uid_decl_map_hash,\n-\t\t\t\t      uid_decl_map_eq, NULL);\n-\n   tree_contains_struct[FUNCTION_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[TYPE_DECL][TS_DECL_NON_COMMON] = 1;\n@@ -610,7 +601,6 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t}\n       DECL_SOURCE_LOCATION (t) = input_location;\n       DECL_UID (t) = next_decl_uid++;\n-      insert_decl_to_uid_decl_map (t);\n \n       break;\n \n@@ -714,7 +704,6 @@ copy_node_stat (tree node MEM_STAT_DECL)\n \t  SET_DECL_RESTRICT_BASE (t, DECL_GET_RESTRICT_BASE (node));\n \t  DECL_BASED_ON_RESTRICT_P (t) = 1;\n \t}\n-      insert_decl_to_uid_decl_map (t);\n     }\n   else if (TREE_CODE_CLASS (code) == tcc_type)\n     {\n@@ -3336,70 +3325,6 @@ build_nt_call_list (tree fn, tree arglist)\n   return t;\n }\n \f\n-/* Return true if the DECL_UID in both trees are equal.  */\n-\n-int\n-uid_decl_map_eq (const void *va, const void *vb)\n-{\n-  const_tree a = (const_tree) va;\n-  const_tree b = (const_tree) vb;\n-  return (a->decl_minimal.uid == b->decl_minimal.uid);\n-}\n-\n-/* Hash a tree in a uid_decl_map.  */\n-\n-unsigned int\n-uid_decl_map_hash (const void *item)\n-{\n-  return ((const_tree)item)->decl_minimal.uid;\n-}\n-\n-/* Insert the declaration NODE into the map mapping its unique uid\n-   back to the tree.  */\n-\n-static void\n-insert_decl_to_uid_decl_map (tree node)\n-{\n-  void **slot;\n-  struct tree_decl_minimal key;\n-\n-  key.uid = DECL_UID (node);\n-  slot = htab_find_slot_with_hash (decl_for_uid_map,\n-\t\t\t\t   &key, DECL_UID (node), INSERT);\n-\n-  /* We should never try to re-insert a decl with the same uid.\n-     ???  The C++ frontend breaks this invariant.  Hopefully in a\n-     non-fatal way, so just overwrite the slot in this case.  */\n-#if 0\n-  gcc_assert (!*slot);\n-#endif\n-\n-  *(tree *)slot = node;\n-}\n-\n-/* Lookup the declaration tree from its unique DECL_UID UID.  Returns\n-   the tree node with DECL_UID UID or NULL, if this node was collected.  */\n-\n-tree\n-lookup_decl_from_uid (int uid)\n-{\n-  struct tree_decl_minimal key;\n-\n-  key.uid = uid;\n-  return (tree) htab_find_with_hash (decl_for_uid_map, &key, uid);\n-}\n-\n-/* Print out the statistics for the decl_for_uid_map hash table.  */\n-\n-static void\n-print_decl_for_uid_map_statistics (void)\n-{\n-  fprintf (stderr, \"DECL_FOR_UID_MAP hash: size %ld, %ld elements, %f collisions\\n\",\n-\t   (long) htab_size (decl_for_uid_map),\n-\t   (long) htab_elements (decl_for_uid_map),\n-\t   htab_collisions (decl_for_uid_map));\n-}\n-\n /* Create a DECL_... node of code CODE, name NAME and data type TYPE.\n    We do NOT enter this node in any sort of symbol table.\n \n@@ -6729,7 +6654,6 @@ dump_tree_statistics (void)\n   print_debug_expr_statistics ();\n   print_value_expr_statistics ();\n   print_restrict_base_statistics ();\n-  print_decl_for_uid_map_statistics ();\n   lang_hooks.print_statistics ();\n }\n \f"}, {"sha": "f98afe9be807d74501ec995b0ad88ecf6a8da3f9", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381a258b1e19d638ff442130bf59a1a26fb2212e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=381a258b1e19d638ff442130bf59a1a26fb2212e", "patch": "@@ -5233,12 +5233,6 @@ struct tree_int_map GTY(())\n #define tree_int_map_hash tree_map_base_hash\n #define tree_int_map_marked_p tree_map_base_marked_p\n \n-/* Map from a DECL_UID to the decl tree.  */\n-\n-extern unsigned int uid_decl_map_hash (const void *);\n-extern int uid_decl_map_eq (const void *, const void *);\n-extern tree lookup_decl_from_uid (int);\n-\n /* Map from a tree to initialization/finalization priorities.  */\n \n struct tree_priority_map GTY(())"}]}