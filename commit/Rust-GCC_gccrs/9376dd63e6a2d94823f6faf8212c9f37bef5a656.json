{"sha": "9376dd63e6a2d94823f6faf8212c9f37bef5a656", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM3NmRkNjNlNmEyZDk0ODIzZjZmYWY4MjEyYzlmMzdiZWY1YTY1Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-08-25T20:25:05Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-08-25T20:25:05Z"}, "message": "Support embedding the driver in-process within libgccjit\n\ngcc/ChangeLog:\n\t* gcc-main.c (main): Add params to driver ctor.\n\t* gcc.c (class env_manager): New.\n\t(env): New global.\n\t(env_manager::init): New.\n\t(env_manager::get): New.\n\t(env_manager::xput): New.\n\t(env_manager::restore): New.\n\tPoison getenv and putenv.\n\t(DEFAULT_TARGET_SYSTEM_ROOT): New.\n\t(target_system_root): Update initialization to use\n\tDEFAULT_TARGET_SYSTEM_ROOT.\n\t(struct spec_list): Add field \"default_ptr\".\n\t(INIT_STATIC_SPEC): Initialize new field \"default_ptr\".\n\t(init_spec): Likewise.\n\t(set_spec): Clear field \"default_ptr\".\n\t(read_specs): Free \"spec\" and \"buffer\".\n\t(xputenv): Reimplement in terms of env_manager.\n\t(process_command): Replace ::getenv calls with calls to the\n\tenv_manager singleton.\n\t(process_brace_body): Free string in three places.\n\t(driver::driver): New.\n\t(driver::~driver): New.\n\t(used_arg): Convert from a function to...\n\t(class used_arg_t): ...this class, and...\n\t(used_arg): ...this new global instance.\n\t(used_arg_t::finalize): New function.\n\t(getenv_spec_function): Add \"const\" to local \"value\".  Replace\n\t::getenv call with call to the env_manager singleton.\n\t(path_prefix_reset): New function.\n\t(driver::finalize): New function.\n\t* gcc.h (driver::driver): New.\n\t(driver::~driver): New.\n\t(driver::finalize): New.\n\ngcc/jit/ChangeLog:\n\t* docs/cp/topics/contexts.rst\n\t(gccjit::context::set_bool_use_external_driver): New.\n\t* docs/internals/test-hello-world.exe.log.txt: Update.\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_5): New.\n\t* docs/topics/contexts.rst\n\t(gcc_jit_context_set_bool_use_external_driver): New.\n\t* jit-common.h (enum inner_bool_option): Add\n\tINNER_BOOL_OPTION_USE_EXTERNAL_DRIVER.\n\t* jit-playback.c (gcc_driver_name): New global.\n\t(gcc:jit::playback::context::invoke_driver): Split out second\n\thalf into...\n\t(gcc::jit::playback::context::invoke_embedded_driver): ...this new\n\tfunction, and...\n\t(gcc::jit::playback::context::invoke_external_driver): ...this new\n\tfunction.\n\t* jit-playback.h\n\t(gcc::jit::playback::context::get_inner_bool_option): New.\n\t(gcc::jit::playback::context::invoke_embedded_driver): New.\n\t(gcc::jit::playback::context::invoke_external_driver): New.\n\t* jit-recording.c (inner_bool_option_reproducer_strings):\n\tAdd entry for INNER_BOOL_OPTION_USE_EXTERNAL_DRIVER.\n\t* libgccjit++.h\n\t(gccjit::context::set_bool_use_external_driver): New.\n\t* libgccjit.c (gcc_jit_context_set_bool_use_external_driver): New.\n\t* libgccjit.h (gcc_jit_context_set_bool_use_external_driver): New.\n\t(LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver):\n\tNew.\n\t* libgccjit.map (LIBGCCJIT_ABI_5): New.\n\t* notes.txt: Show invocation of embedded copy of driver.\n\t* docs/internals/test-hello-world.exe.log.txt: Update\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/test-error-pr63969-missing-driver.c: Add call to\n\tgcc_jit_context_set_bool_use_external_driver.\n\nFrom-SVN: r227188", "tree": {"sha": "2745652bd94e40ef40a21a22e1c88c4429fccab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2745652bd94e40ef40a21a22e1c88c4429fccab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9376dd63e6a2d94823f6faf8212c9f37bef5a656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9376dd63e6a2d94823f6faf8212c9f37bef5a656", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9376dd63e6a2d94823f6faf8212c9f37bef5a656", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9376dd63e6a2d94823f6faf8212c9f37bef5a656/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25c65938c8794115531d09a37e17d3bc469f6269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c65938c8794115531d09a37e17d3bc469f6269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c65938c8794115531d09a37e17d3bc469f6269"}], "stats": {"total": 669, "additions": 635, "deletions": 34}, "files": [{"sha": "c79fb4870f7db963da74732ca5e370cd0a5e6b45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -1,3 +1,39 @@\n+2015-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc-main.c (main): Add params to driver ctor.\n+\t* gcc.c (class env_manager): New.\n+\t(env): New global.\n+\t(env_manager::init): New.\n+\t(env_manager::get): New.\n+\t(env_manager::xput): New.\n+\t(env_manager::restore): New.\n+\tPoison getenv and putenv.\n+\t(DEFAULT_TARGET_SYSTEM_ROOT): New.\n+\t(target_system_root): Update initialization to use\n+\tDEFAULT_TARGET_SYSTEM_ROOT.\n+\t(struct spec_list): Add field \"default_ptr\".\n+\t(INIT_STATIC_SPEC): Initialize new field \"default_ptr\".\n+\t(init_spec): Likewise.\n+\t(set_spec): Clear field \"default_ptr\".\n+\t(read_specs): Free \"spec\" and \"buffer\".\n+\t(xputenv): Reimplement in terms of env_manager.\n+\t(process_command): Replace ::getenv calls with calls to the\n+\tenv_manager singleton.\n+\t(process_brace_body): Free string in three places.\n+\t(driver::driver): New.\n+\t(driver::~driver): New.\n+\t(used_arg): Convert from a function to...\n+\t(class used_arg_t): ...this class, and...\n+\t(used_arg): ...this new global instance.\n+\t(used_arg_t::finalize): New function.\n+\t(getenv_spec_function): Add \"const\" to local \"value\".  Replace\n+\t::getenv call with call to the env_manager singleton.\n+\t(path_prefix_reset): New function.\n+\t(driver::finalize): New function.\n+\t* gcc.h (driver::driver): New.\n+\t(driver::~driver): New.\n+\t(driver::finalize): New.\n+\n 2015-08-25  Nathan Sidwell  <nathan@acm.org>\n \n \t* optabs.c (emit_indirect_jump): Don't try an emit a jump if the"}, {"sha": "a0aaa3c7fc71a560953e5558113f79ece3252843", "filename": "gcc/gcc-main.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fgcc-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fgcc-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-main.c?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -40,7 +40,8 @@ extern int main (int, char **);\n int\n main (int argc, char **argv)\n {\n-  driver d;\n+  driver d (false, /* can_finalize */\n+\t    false); /* debug */\n \n   return d.main (argc, argv);\n }"}, {"sha": "4c37edcedcc2cf93919d626ef6338a4d93d80db5", "filename": "gcc/gcc.c", "status": "modified", "additions": 379, "deletions": 21, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -43,6 +43,131 @@ compilation is specified by a string called a \"spec\".  */\n #include \"params.h\"\n #include \"filenames.h\"\n \n+\f\n+\n+/* Manage the manipulation of env vars.\n+\n+   We poison \"getenv\" and \"putenv\", so that all enviroment-handling is\n+   done through this class.  Note that poisoning happens in the\n+   preprocessor at the identifier level, and doesn't distinguish between\n+     env.getenv ();\n+   and\n+     getenv ();\n+   Hence we need to use \"get\" for the accessor method, not \"getenv\".  */\n+\n+class env_manager\n+{\n+ public:\n+  void init (bool can_restore, bool debug);\n+  const char *get (const char *name);\n+  void xput (const char *string);\n+  void restore ();\n+\n+ private:\n+  bool m_can_restore;\n+  bool m_debug;\n+  struct kv\n+  {\n+    char *m_key;\n+    char *m_value;\n+  };\n+  vec<kv> m_keys;\n+\n+};\n+\n+/* The singleton instance of class env_manager.  */\n+\n+static env_manager env;\n+\n+/* Initializer for class env_manager.\n+\n+   We can't do this as a constructor since we have a statically\n+   allocated instance (\"env\" above).  */\n+\n+void\n+env_manager::init (bool can_restore, bool debug)\n+{\n+  m_can_restore = can_restore;\n+  m_debug = debug;\n+}\n+\n+/* Get the value of NAME within the environment.  Essentially\n+   a wrapper for ::getenv, but adding logging, and the possibility\n+   of caching results.  */\n+\n+const char *\n+env_manager::get (const char *name)\n+{\n+  const char *result = ::getenv (name);\n+  if (m_debug)\n+    fprintf (stderr, \"env_manager::getenv (%s) -> %s\\n\", name, result);\n+  return result;\n+}\n+\n+/* Put the given KEY=VALUE entry STRING into the environment.\n+   If the env_manager was initialized with CAN_RESTORE set, then\n+   also record the old value of KEY within the environment, so that it\n+   can be later restored.  */\n+\n+void\n+env_manager::xput (const char *string)\n+{\n+  if (m_debug)\n+    fprintf (stderr, \"env_manager::xput (%s)\\n\", string);\n+  if (verbose_flag)\n+    fnotice (stderr, \"%s\\n\", string);\n+\n+  if (m_can_restore)\n+    {\n+      char *equals = strchr (const_cast <char *> (string), '=');\n+      gcc_assert (equals);\n+\n+      struct kv kv;\n+      kv.m_key = strndup (string, equals - string);\n+      const char *cur_value = ::getenv (kv.m_key);\n+      if (m_debug)\n+\tfprintf (stderr, \"saving old value: %s\\n\",cur_value);\n+      kv.m_value = cur_value ? xstrdup (cur_value) : NULL;\n+      m_keys.safe_push (kv);\n+    }\n+\n+  ::putenv (CONST_CAST (char *, string));\n+}\n+\n+/* Undo any xputenv changes made since last restore.\n+   Can only be called if the env_manager was initialized with\n+   CAN_RESTORE enabled.  */\n+\n+void\n+env_manager::restore ()\n+{\n+  unsigned int i;\n+  struct kv *item;\n+\n+  gcc_assert (m_can_restore);\n+\n+  FOR_EACH_VEC_ELT_REVERSE (m_keys, i, item)\n+    {\n+      if (m_debug)\n+\tprintf (\"restoring saved key: %s value: %s\\n\", item->m_key, item->m_value);\n+      if (item->m_value)\n+\t::setenv (item->m_key, item->m_value, 1);\n+      else\n+\t::unsetenv (item->m_key);\n+      free (item->m_key);\n+      free (item->m_value);\n+    }\n+\n+  m_keys.truncate (0);\n+}\n+\n+/* Forbid other uses of getenv and putenv.  */\n+#if (GCC_VERSION >= 3000)\n+#pragma GCC poison getenv putenv\n+#endif\n+\n+\f\n+\n /* By default there is no special suffix for target executables.  */\n /* FIXME: when autoconf is fixed, remove the host check - dj */\n #if defined(TARGET_EXECUTABLE_SUFFIX) && defined(HOST_EXECUTABLE_SUFFIX)\n@@ -115,10 +240,11 @@ FILE *report_times_to_file = NULL;\n    and library files can be found in an alternate location.  */\n \n #ifdef TARGET_SYSTEM_ROOT\n-static const char *target_system_root = TARGET_SYSTEM_ROOT;\n+#define DEFAULT_TARGET_SYSTEM_ROOT (TARGET_SYSTEM_ROOT)\n #else\n-static const char *target_system_root = 0;\n+#define DEFAULT_TARGET_SYSTEM_ROOT (0)\n #endif\n+static const char *target_system_root = DEFAULT_TARGET_SYSTEM_ROOT;\n \n /* Nonzero means pass the updated target_system_root to the compiler.  */\n \n@@ -235,7 +361,6 @@ static const char *validate_switches (const char *, bool);\n static void validate_all_switches (void);\n static inline void validate_switches_from_spec (const char *, bool);\n static void give_switch (int, int);\n-static int used_arg (const char *, int);\n static int default_arg (const char *, int);\n static void set_multilib_dir (void);\n static void print_multilib_info (void);\n@@ -1395,10 +1520,12 @@ struct spec_list\n   int name_len;\t\t\t/* length of the name */\n   bool user_p;\t\t\t/* whether string come from file spec.  */\n   bool alloc_p;\t\t\t/* whether string was allocated */\n+  const char *default_ptr;\t/* The default value of *ptr_spec.  */\n };\n \n #define INIT_STATIC_SPEC(NAME,PTR) \\\n-  { NAME, NULL, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, false, false }\n+  { NAME, NULL, PTR, (struct spec_list *) 0, sizeof (NAME) - 1, false, false, \\\n+    *PTR }\n \n /* List of statically defined specs.  */\n static struct spec_list static_specs[] =\n@@ -1566,6 +1693,8 @@ init_spec (void)\n       sl->next = next;\n       sl->name_len = strlen (sl->name);\n       sl->ptr_spec = &sl->ptr;\n+      gcc_assert (sl->ptr_spec != NULL);\n+      sl->default_ptr = sl->ptr;\n       next = sl;\n     }\n #endif\n@@ -1740,6 +1869,7 @@ set_spec (const char *name, const char *spec, bool user_p)\n       sl->alloc_p = 0;\n       *(sl->ptr_spec) = \"\";\n       sl->next = specs;\n+      sl->default_ptr = NULL;\n       specs = sl;\n     }\n \n@@ -2132,7 +2262,10 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t  if (! strcmp (suffix, \"*link_command\"))\n \t    link_command_spec = spec;\n \t  else\n-\t    set_spec (suffix + 1, spec, user_p);\n+\t    {\n+\t      set_spec (suffix + 1, spec, user_p);\n+\t      free (spec);\n+\t    }\n \t}\n       else\n \t{\n@@ -2152,6 +2285,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \n   if (link_command_spec == 0)\n     fatal_error (input_location, \"spec file has no spec for linking\");\n+\n+  XDELETEVEC (buffer);\n }\n \f\n /* Record the names of temporary files we tell compilers to write,\n@@ -2494,9 +2629,7 @@ add_to_obstack (char *path, void *data)\n static void\n xputenv (const char *string)\n {\n-  if (verbose_flag)\n-    fnotice (stderr, \"%s\\n\", string);\n-  putenv (CONST_CAST (char *, string));\n+  env.xput (string);\n }\n \n /* Build a list of search directories from PATHS.\n@@ -3970,7 +4103,7 @@ process_command (unsigned int decoded_options_count,\n   struct cl_option_handlers handlers;\n   unsigned int j;\n \n-  gcc_exec_prefix = getenv (\"GCC_EXEC_PREFIX\");\n+  gcc_exec_prefix = env.get (\"GCC_EXEC_PREFIX\");\n \n   n_switches = 0;\n   n_infiles = 0;\n@@ -4075,7 +4208,7 @@ process_command (unsigned int decoded_options_count,\n   /* COMPILER_PATH and LIBRARY_PATH have values\n      that are lists of directory names with colons.  */\n \n-  temp = getenv (\"COMPILER_PATH\");\n+  temp = env.get (\"COMPILER_PATH\");\n   if (temp)\n     {\n       const char *startp, *endp;\n@@ -4109,7 +4242,7 @@ process_command (unsigned int decoded_options_count,\n \t}\n     }\n \n-  temp = getenv (LIBRARY_PATH_ENV);\n+  temp = env.get (LIBRARY_PATH_ENV);\n   if (temp && *cross_compile == '0')\n     {\n       const char *startp, *endp;\n@@ -4142,7 +4275,7 @@ process_command (unsigned int decoded_options_count,\n     }\n \n   /* Use LPATH like LIBRARY_PATH (for the CMU build program).  */\n-  temp = getenv (\"LPATH\");\n+  temp = env.get (\"LPATH\");\n   if (temp && *cross_compile == '0')\n     {\n       const char *startp, *endp;\n@@ -4285,7 +4418,7 @@ process_command (unsigned int decoded_options_count,\n \n   if (!compare_debug)\n     {\n-      const char *gcd = getenv (\"GCC_COMPARE_DEBUG\");\n+      const char *gcd = env.get (\"GCC_COMPARE_DEBUG\");\n \n       if (gcd && gcd[0] == '-')\n \t{\n@@ -6217,7 +6350,10 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n       if (!have_subst)\n \t{\n \t  if (do_spec_1 (string, 0, NULL) < 0)\n-\t    return 0;\n+\t    {\n+\t      free (string);\n+\t      return 0;\n+\t    }\n \t}\n       else\n \t{\n@@ -6233,12 +6369,16 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n \t      {\n \t\tif (do_spec_1 (string, 0,\n \t\t\t       &switches[i].part1[hard_match_len]) < 0)\n-\t\t  return 0;\n+\t\t  {\n+\t\t    free (string);\n+\t\t    return 0;\n+\t\t  }\n \t\t/* Pass any arguments this switch has.  */\n \t\tgive_switch (i, 1);\n \t\tsuffix_subst = NULL;\n \t      }\n \t}\n+      free (string);\n     }\n \n   return p;\n@@ -6947,6 +7087,19 @@ compare_files (char *cmpfile[])\n   return ret;\n }\n \n+driver::driver (bool can_finalize, bool debug) :\n+  explicit_link_files (NULL),\n+  decoded_options (NULL)\n+{\n+  env.init (can_finalize, debug);\n+}\n+\n+driver::~driver ()\n+{\n+  XDELETEVEC (explicit_link_files);\n+  XDELETEVEC (decoded_options);\n+}\n+\n /* driver::main is implemented as a series of driver:: method calls.  */\n \n int\n@@ -8160,9 +8313,13 @@ static int n_mdswitches;\n /* Check whether a particular argument was used.  The first time we\n    canonicalize the switches to keep only the ones we care about.  */\n \n-static int\n-used_arg (const char *p, int len)\n+class used_arg_t\n {\n+ public:\n+  int operator () (const char *p, int len);\n+  void finalize ();\n+\n+ private:\n   struct mswitchstr\n   {\n     const char *str;\n@@ -8171,8 +8328,16 @@ used_arg (const char *p, int len)\n     int rep_len;\n   };\n \n-  static struct mswitchstr *mswitches;\n-  static int n_mswitches;\n+  mswitchstr *mswitches;\n+  int n_mswitches;\n+\n+};\n+\n+used_arg_t used_arg;\n+\n+int\n+used_arg_t::operator () (const char *p, int len)\n+{\n   int i, j;\n \n   if (!mswitches)\n@@ -8301,6 +8466,14 @@ used_arg (const char *p, int len)\n   return 0;\n }\n \n+void used_arg_t::finalize ()\n+{\n+  XDELETEVEC (mswitches);\n+  mswitches = NULL;\n+  n_mswitches = 0;\n+}\n+\n+\n static int\n default_arg (const char *p, int len)\n {\n@@ -8855,15 +9028,15 @@ print_multilib_info (void)\n static const char *\n getenv_spec_function (int argc, const char **argv)\n {\n-  char *value;\n+  const char *value;\n   char *result;\n   char *ptr;\n   size_t len;\n \n   if (argc != 2)\n     return NULL;\n \n-  value = getenv (argv[0]);\n+  value = env.get (argv[0]);\n   if (!value)\n     fatal_error (input_location,\n \t\t \"environment variable %qs not defined\", argv[0]);\n@@ -9526,6 +9699,191 @@ convert_white_space (char *orig)\n     return orig;\n }\n \n+static void\n+path_prefix_reset (path_prefix *prefix)\n+{\n+  struct prefix_list *iter, *next;\n+  iter = prefix->plist;\n+  while (iter)\n+    {\n+      next = iter->next;\n+      free (const_cast <char *> (iter->prefix));\n+      XDELETE (iter);\n+      iter = next;\n+    }\n+  prefix->plist = 0;\n+  prefix->max_len = 0;\n+}\n+\n+/* Restore all state within gcc.c to the initial state, so that the driver\n+   code can be safely re-run in-process.\n+\n+   Many const char * variables are referenced by static specs (see\n+   INIT_STATIC_SPEC above).  These variables are restored to their default\n+   values by a simple loop over the static specs.\n+\n+   For other variables, we directly restore them all to their initial\n+   values (often implicitly 0).\n+\n+   Free the various obstacks in this file, along with \"opts_obstack\"\n+   from opts.c.\n+\n+   This function also restores any environment variables that were changed.  */\n+\n+void\n+driver::finalize ()\n+{\n+  env.restore ();\n+  params_c_finalize ();\n+  diagnostic_finish (global_dc);\n+\n+  is_cpp_driver = 0;\n+  at_file_supplied = 0;\n+  print_help_list = 0;\n+  print_version = 0;\n+  verbose_only_flag = 0;\n+  print_subprocess_help = 0;\n+  use_ld = NULL;\n+  report_times_to_file = NULL;\n+  target_system_root = DEFAULT_TARGET_SYSTEM_ROOT;\n+  target_system_root_changed = 0;\n+  target_sysroot_suffix = 0;\n+  target_sysroot_hdrs_suffix = 0;\n+  save_temps_flag = SAVE_TEMPS_NONE;\n+  save_temps_prefix = 0;\n+  save_temps_length = 0;\n+  spec_machine = DEFAULT_TARGET_MACHINE;\n+  greatest_status = 1;\n+\n+  finalize_options_struct (&global_options);\n+  finalize_options_struct (&global_options_set);\n+\n+  obstack_free (&obstack, NULL);\n+  obstack_free (&opts_obstack, NULL); /* in opts.c */\n+  obstack_free (&collect_obstack, NULL);\n+\n+  link_command_spec = LINK_COMMAND_SPEC;\n+\n+  obstack_free (&multilib_obstack, NULL);\n+\n+  user_specs_head = NULL;\n+  user_specs_tail = NULL;\n+\n+  /* Within the \"compilers\" vec, the fields \"suffix\" and \"spec\" were\n+     statically allocated for the default compilers, but dynamically\n+     allocated for additional compilers.  Delete them for the latter. */\n+  for (int i = n_default_compilers; i < n_compilers; i++)\n+    {\n+      free (const_cast <char *> (compilers[i].suffix));\n+      free (const_cast <char *> (compilers[i].spec));\n+    }\n+  XDELETEVEC (compilers);\n+  compilers = NULL;\n+  n_compilers = 0;\n+\n+  linker_options.truncate (0);\n+  assembler_options.truncate (0);\n+  preprocessor_options.truncate (0);\n+\n+  path_prefix_reset (&exec_prefixes);\n+  path_prefix_reset (&startfile_prefixes);\n+  path_prefix_reset (&include_prefixes);\n+\n+  machine_suffix = 0;\n+  just_machine_suffix = 0;\n+  gcc_exec_prefix = 0;\n+  gcc_libexec_prefix = 0;\n+  md_exec_prefix = MD_EXEC_PREFIX;\n+  md_startfile_prefix = MD_STARTFILE_PREFIX;\n+  md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;\n+  multilib_dir = 0;\n+  multilib_os_dir = 0;\n+  multiarch_dir = 0;\n+\n+  XDELETEVEC (specs);\n+  specs = 0;\n+  for (unsigned i = 0; i < ARRAY_SIZE (static_specs); i++)\n+    {\n+      spec_list *sl = &static_specs[i];\n+      if (sl->alloc_p)\n+\t{\n+\t  if (0)\n+\t    free (const_cast <char *> (*(sl->ptr_spec)));\n+\t  sl->alloc_p = false;\n+\t}\n+      *(sl->ptr_spec) = sl->default_ptr;\n+    }\n+  extra_specs = NULL;\n+\n+  processing_spec_function = 0;\n+\n+  argbuf.truncate (0);\n+\n+  have_c = 0;\n+  have_o = 0;\n+\n+  temp_names = NULL;\n+  execution_count = 0;\n+  signal_count = 0;\n+\n+  temp_filename = NULL;\n+  temp_filename_length = 0;\n+  always_delete_queue = NULL;\n+  failure_delete_queue = NULL;\n+\n+  XDELETEVEC (switches);\n+  switches = NULL;\n+  n_switches = 0;\n+  n_switches_alloc = 0;\n+\n+  compare_debug = 0;\n+  compare_debug_second = 0;\n+  compare_debug_opt = NULL;\n+  for (int i = 0; i < 2; i++)\n+    {\n+      switches_debug_check[i] = NULL;\n+      n_switches_debug_check[i] = 0;\n+      n_switches_alloc_debug_check[i] = 0;\n+      debug_check_temp_file[i] = NULL;\n+    }\n+\n+  XDELETEVEC (infiles);\n+  infiles = NULL;\n+  n_infiles = 0;\n+  n_infiles_alloc = 0;\n+\n+  combine_inputs = false;\n+  added_libraries = 0;\n+  XDELETEVEC (outfiles);\n+  outfiles = NULL;\n+  spec_lang = 0;\n+  last_language_n_infiles = 0;\n+  gcc_input_filename = NULL;\n+  input_file_number = 0;\n+  input_filename_length = 0;\n+  basename_length = 0;\n+  suffixed_basename_length = 0;\n+  input_basename = NULL;\n+  input_suffix = NULL;\n+  /* We don't need to purge \"input_stat\", just to unset \"input_stat_set\".  */\n+  input_stat_set = 0;\n+  input_file_compiler = NULL;\n+  arg_going = 0;\n+  delete_this_arg = 0;\n+  this_is_output_file = 0;\n+  this_is_library_file = 0;\n+  this_is_linker_script = 0;\n+  input_from_pipe = 0;\n+  suffix_subst = NULL;\n+\n+  mdswitches = NULL;\n+  n_mdswitches = 0;\n+\n+  debug_auxbase_opt = NULL;\n+\n+  used_arg.finalize ();\n+}\n+\n /* PR jit/64810.\n    Targets can provide configure-time default options in\n    OPTION_DEFAULT_SPECS.  The jit needs to access these, but"}, {"sha": "e1abe43b15f86643aa1d0ae402496255a6d9553e", "filename": "gcc/gcc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fgcc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fgcc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.h?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -30,7 +30,10 @@ along with GCC; see the file COPYING3.  If not see\n class driver\n {\n  public:\n+  driver (bool can_finalize, bool debug);\n+  ~driver ();\n   int main (int argc, char **argv);\n+  void finalize ();\n \n  private:\n   void set_progname (const char *argv0) const;"}, {"sha": "fae643686f773b8387fe8e6474a9b9833fa336cb", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -1,3 +1,36 @@\n+2015-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/topics/contexts.rst\n+\t(gccjit::context::set_bool_use_external_driver): New.\n+\t* docs/internals/test-hello-world.exe.log.txt: Update.\n+\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_5): New.\n+\t* docs/topics/contexts.rst\n+\t(gcc_jit_context_set_bool_use_external_driver): New.\n+\t* jit-common.h (enum inner_bool_option): Add\n+\tINNER_BOOL_OPTION_USE_EXTERNAL_DRIVER.\n+\t* jit-playback.c (gcc_driver_name): New global.\n+\t(gcc:jit::playback::context::invoke_driver): Split out second\n+\thalf into...\n+\t(gcc::jit::playback::context::invoke_embedded_driver): ...this new\n+\tfunction, and...\n+\t(gcc::jit::playback::context::invoke_external_driver): ...this new\n+\tfunction.\n+\t* jit-playback.h\n+\t(gcc::jit::playback::context::get_inner_bool_option): New.\n+\t(gcc::jit::playback::context::invoke_embedded_driver): New.\n+\t(gcc::jit::playback::context::invoke_external_driver): New.\n+\t* jit-recording.c (inner_bool_option_reproducer_strings):\n+\tAdd entry for INNER_BOOL_OPTION_USE_EXTERNAL_DRIVER.\n+\t* libgccjit++.h\n+\t(gccjit::context::set_bool_use_external_driver): New.\n+\t* libgccjit.c (gcc_jit_context_set_bool_use_external_driver): New.\n+\t* libgccjit.h (gcc_jit_context_set_bool_use_external_driver): New.\n+\t(LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver):\n+\tNew.\n+\t* libgccjit.map (LIBGCCJIT_ABI_5): New.\n+\t* notes.txt: Show invocation of embedded copy of driver.\n+\t* docs/internals/test-hello-world.exe.log.txt: Update\n+\n 2015-08-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-playback.c (invoke_driver): On OS X, add"}, {"sha": "05ce2308624797de8ba3f78d8d779a62bb69e6a3", "filename": "gcc/jit/docs/cp/topics/contexts.rst", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -201,6 +201,26 @@ Boolean options\n \n       #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks\n \n+.. function:: void \\\n+              gccjit::context::set_bool_use_external_driver (int bool_value)\n+\n+   libgccjit internally generates assembler, and uses \"driver\" code\n+   for converting it to other formats (e.g. shared libraries).\n+\n+   By default, libgccjit will use an embedded copy of the driver\n+   code.\n+\n+   This option can be used to instead invoke an external driver executable\n+   as a subprocess; it is a thin wrapper around the C API\n+   :c:func:`gcc_jit_context_set_bool_use_external_driver`.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_5`; you can test for\n+   its presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver\n+\n Integer options\n ***************\n "}, {"sha": "0bab86c25d71d80df37046e5c10005a4581d7c1f", "filename": "gcc/jit/docs/internals/test-hello-world.exe.log.txt", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -1,4 +1,4 @@\n-JIT: libgccjit (GCC) version 6.0.0 20150723 (experimental) (x86_64-unknown-linux-gnu)\n+JIT: libgccjit (GCC) version 6.0.0 20150803 (experimental) (x86_64-pc-linux-gnu)\n JIT:\tcompiled by GNU C version 4.8.3 20140911 (Red Hat 4.8.3-7), GMP version 5.1.2, MPFR version 3.1.2, MPC version 1.0.1\n JIT: entering: gcc_jit_context_set_str_option\n JIT:  GCC_JIT_STR_OPTION_PROGNAME: \"./test-hello-world.c.exe\"\n@@ -65,6 +65,7 @@ JIT:   GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING: false\n JIT:   GCC_JIT_BOOL_OPTION_SELFCHECK_GC: true\n JIT:   GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES: false\n JIT:   gcc_jit_context_set_bool_allow_unreachable_blocks: false\n+JIT:   gcc_jit_context_set_bool_use_external_driver: false\n JIT:   entering: void gcc::jit::recording::context::validate()\n JIT:   exiting: void gcc::jit::recording::context::validate()\n JIT:   entering: gcc::jit::playback::context::context(gcc::jit::recording::context*)\n@@ -133,7 +134,8 @@ JIT:       argv[3]: /tmp/libgccjit-CKq1M9/fake.s\n JIT:       argv[4]: -o\n JIT:       argv[5]: /tmp/libgccjit-CKq1M9/fake.so\n JIT:       argv[6]: -fno-use-linker-plugin\n-JIT:       argv[7]: (null)\n+JIT:       entering: void gcc::jit::playback::context::invoke_embedded_driver(const vec<char*>*)\n+JIT:       exiting: void gcc::jit::playback::context::invoke_embedded_driver(const vec<char*>*)\n JIT:      exiting: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)\n JIT:     exiting: void gcc::jit::playback::context::convert_to_dso(const char*)\n JIT:     entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()"}, {"sha": "e947cad4320223b9c6a4a1410d5538e853e80bd2", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -128,3 +128,10 @@ entrypoints:\n   * :func:`gcc_jit_timer_pop`\n \n   * :func:`gcc_jit_timer_print`\n+\n+.. _LIBGCCJIT_ABI_5:\n+\n+``LIBGCCJIT_ABI_5``\n+-------------------\n+``LIBGCCJIT_ABI_5`` covers the addition of\n+:func:`gcc_jit_context_set_bool_use_external_driver`"}, {"sha": "53ceffb6dedb9a53b4bc34d9779eeb4af9173ec6", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -469,6 +469,26 @@ Boolean options\n \n       #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks\n \n+.. function:: void \\\n+              gcc_jit_context_set_bool_use_external_driver (gcc_jit_context *ctxt, \\\n+                                                            int bool_value)\n+\n+   libgccjit internally generates assembler, and uses \"driver\" code\n+   for converting it to other formats (e.g. shared libraries).\n+\n+   By default, libgccjit will use an embedded copy of the driver\n+   code.\n+\n+   This option can be used to instead invoke an external driver executable\n+   as a subprocess.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_5`; you can test for\n+   its presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver\n+\n Integer options\n ***************\n "}, {"sha": "6400f307d4bd6e57088d3aca9b573085bbfbf00a", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -191,6 +191,7 @@ class dump\n enum inner_bool_option\n {\n   INNER_BOOL_OPTION_ALLOW_UNREACHABLE_BLOCKS,\n+  INNER_BOOL_OPTION_USE_EXTERNAL_DRIVER,\n \n   NUM_INNER_BOOL_OPTIONS\n };"}, {"sha": "44c3ce00d98b5254a33d220763893e46c687e209", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -2373,6 +2373,8 @@ convert_to_dso (const char *ctxt_progname)\n \t\t true);/* bool run_linker */\n }\n \n+static const char * const gcc_driver_name = GCC_DRIVER_NAME;\n+\n void\n playback::context::\n invoke_driver (const char *ctxt_progname,\n@@ -2383,15 +2385,15 @@ invoke_driver (const char *ctxt_progname,\n \t       bool run_linker)\n {\n   JIT_LOG_SCOPE (get_logger ());\n+\n+  bool embedded_driver\n+    = !get_inner_bool_option (INNER_BOOL_OPTION_USE_EXTERNAL_DRIVER);\n+\n   /* Currently this lumps together both assembling and linking into\n      TV_ASSEMBLE.  */\n   auto_timevar assemble_timevar (get_timer (), tv_id);\n-  const char *errmsg;\n   auto_argvec argvec;\n #define ADD_ARG(arg) argvec.safe_push (xstrdup (arg))\n-  int exit_status = 0;\n-  int err = 0;\n-  const char *gcc_driver_name = GCC_DRIVER_NAME;\n \n   ADD_ARG (gcc_driver_name);\n \n@@ -2425,8 +2427,10 @@ invoke_driver (const char *ctxt_progname,\n   ADD_ARG (\"-Wl,-undefined,dynamic_lookup\");\n #endif\n \n-  /* pex argv arrays are NULL-terminated.  */\n-  argvec.safe_push (NULL);\n+  if (0)\n+    ADD_ARG (\"-v\");\n+\n+#undef ADD_ARG\n \n   /* pex_one's error-handling requires pname to be non-NULL.  */\n   gcc_assert (ctxt_progname);\n@@ -2435,9 +2439,42 @@ invoke_driver (const char *ctxt_progname,\n     for (unsigned i = 0; i < argvec.length (); i++)\n       get_logger ()->log (\"argv[%i]: %s\", i, argvec[i]);\n \n+  if (embedded_driver)\n+    invoke_embedded_driver (&argvec);\n+  else\n+    invoke_external_driver (ctxt_progname, &argvec);\n+}\n+\n+void\n+playback::context::\n+invoke_embedded_driver (const vec <char *> *argvec)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+  driver d (true, /* can_finalize */\n+\t    false); /* debug */\n+  int result = d.main (argvec->length (),\n+\t\t       const_cast <char **> (argvec->address ()));\n+  d.finalize ();\n+  if (result)\n+    add_error (NULL, \"error invoking gcc driver\");\n+}\n+\n+void\n+playback::context::\n+invoke_external_driver (const char *ctxt_progname,\n+\t\t\tvec <char *> *argvec)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+  const char *errmsg;\n+  int exit_status = 0;\n+  int err = 0;\n+\n+  /* pex argv arrays are NULL-terminated.  */\n+  argvec->safe_push (NULL);\n+\n   errmsg = pex_one (PEX_SEARCH, /* int flags, */\n \t\t    gcc_driver_name,\n-\t\t    const_cast <char *const *> (argvec.address ()),\n+\t\t    const_cast <char *const *> (argvec->address ()),\n \t\t    ctxt_progname, /* const char *pname */\n \t\t    NULL, /* const char *outname */\n \t\t    NULL, /* const char *errname */\n@@ -2464,7 +2501,6 @@ invoke_driver (const char *ctxt_progname,\n \t\t getenv (\"PATH\"));\n       return;\n     }\n-#undef ADD_ARG\n }\n \n /* Extract the target-specific MULTILIB_DEFAULTS to"}, {"sha": "d99db542021597daf4340ef7d5ae443fc5bc3c7f", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -177,6 +177,12 @@ class context : public log_user\n     return m_recording_ctxt->get_bool_option (opt);\n   }\n \n+  int\n+  get_inner_bool_option (enum inner_bool_option opt) const\n+  {\n+    return m_recording_ctxt->get_inner_bool_option (opt);\n+  }\n+\n   builtins_manager *get_builtins_manager () const\n   {\n     return m_recording_ctxt->get_builtins_manager ();\n@@ -280,6 +286,14 @@ class context : public log_user\n   result *\n   dlopen_built_dso ();\n \n+ private:\n+  void\n+  invoke_embedded_driver (const vec <char *> *argvec);\n+\n+  void\n+  invoke_external_driver (const char *ctxt_progname,\n+\t\t\t  vec <char *> *argvec);\n+\n private:\n   ::gcc::jit::recording::context *m_recording_ctxt;\n "}, {"sha": "70bd171a892024a1bd86f2b53adbbbff34fc56b1", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -1452,7 +1452,8 @@ static const char * const\n \n static const char * const\n  inner_bool_option_reproducer_strings[NUM_INNER_BOOL_OPTIONS] = {\n-  \"gcc_jit_context_set_bool_allow_unreachable_blocks\"\n+  \"gcc_jit_context_set_bool_allow_unreachable_blocks\",\n+  \"gcc_jit_context_set_bool_use_external_driver\"\n };\n \n /* Write the current value of all options to the log file (if any).  */"}, {"sha": "ef9bef1af4780d9249a95da328389344ac1a1c6b", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -124,6 +124,7 @@ namespace gccjit\n \t\t\t  int value);\n \n     void set_bool_allow_unreachable_blocks (int bool_value);\n+    void set_bool_use_external_driver (int bool_value);\n \n     void add_command_line_option (const char *optname);\n \n@@ -665,6 +666,13 @@ context::set_bool_allow_unreachable_blocks (int bool_value)\n \t\t\t\t\t\t     bool_value);\n }\n \n+inline void\n+context::set_bool_use_external_driver (int bool_value)\n+{\n+  gcc_jit_context_set_bool_use_external_driver (m_inner_ctxt,\n+\t\t\t\t\t\tbool_value);\n+}\n+\n inline void\n context::add_command_line_option (const char *optname)\n {"}, {"sha": "55cda6bf890f3509b26572ca48d46b4b0ba26318", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -2608,6 +2608,23 @@ gcc_jit_context_set_bool_allow_unreachable_blocks (gcc_jit_context *ctxt,\n     bool_value);\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::set_inner_bool_option method in\n+   jit-recording.c.  */\n+\n+extern void\n+gcc_jit_context_set_bool_use_external_driver (gcc_jit_context *ctxt,\n+\t\t\t\t\t      int bool_value)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  ctxt->set_inner_bool_option (\n+    gcc::jit::INNER_BOOL_OPTION_USE_EXTERNAL_DRIVER,\n+    bool_value);\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the"}, {"sha": "442ad0a62aca0127467dadaa54d17791a43f6318", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -278,6 +278,30 @@ gcc_jit_context_set_bool_allow_unreachable_blocks (gcc_jit_context *ctxt,\n    tested for with #ifdef.  */\n #define LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks\n \n+/* Implementation detail:\n+   libgccjit internally generates assembler, and uses \"driver\" code\n+   for converting it to other formats (e.g. shared libraries).\n+\n+   By default, libgccjit will use an embedded copy of the driver\n+   code.\n+\n+   This option can be used to instead invoke an external driver executable\n+   as a subprocess.\n+\n+   This entrypoint was added in LIBGCCJIT_ABI_5; you can test for\n+   its presence using\n+     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver\n+*/\n+\n+extern void\n+gcc_jit_context_set_bool_use_external_driver (gcc_jit_context *ctxt,\n+\t\t\t\t\t      int bool_value);\n+\n+/* Pre-canned feature macro to indicate the presence of\n+   gcc_jit_context_set_bool_use_external_driver.  This can be\n+   tested for with #ifdef.  */\n+#define LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver\n+\n /* Add an arbitrary gcc command-line option to the context.\n    The context takes a copy of the string, so the\n    (const char *) optname is not needed anymore after the call"}, {"sha": "a3ced26a562b01c4160d2d00674924a09944c177", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -140,3 +140,8 @@ LIBGCCJIT_ABI_4 {\n     gcc_jit_timer_pop;\n     gcc_jit_timer_print;\n };\n+\n+LIBGCCJIT_ABI_5 {\n+  global:\n+    gcc_jit_context_set_bool_use_external_driver;\n+} LIBGCCJIT_ABI_4;"}, {"sha": "36e05cb7f237d931f97ab7d355e06bb949076dc8", "filename": "gcc/jit/notes.txt", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fnotes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Fjit%2Fnotes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fnotes.txt?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -78,7 +78,13 @@ Client Code   . Generated .            libgccjit.so\n               .           .      \u2502   .               .\n               .           .      \u2502   (assuming an in-memory compile):\n               .           .      \u2502   .               .\n-              .           .      \u2502   . Convert assembler to DSO (\"fake.so\")\n+              .           .      --> Convert assembler to DSO, via embedded\n+              .           .          copy of driver:\n+              .           .           driver::main ()\n+              .           .             invocation of \"as\"\n+              .           .             invocation of \"ld\"\n+              .           .           driver::finalize ()\n+              .           .      <----\n               .           .      \u2502   .               .\n               .           .      \u2502   . Load DSO (dlopen \"fake.so\")\n               .           .      \u2502   .               ."}, {"sha": "7deb14776ca993b48b293eb4ad6ce6c35f1acb18", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -1,3 +1,8 @@\n+2015-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-pr63969-missing-driver.c: Add call to\n+\tgcc_jit_context_set_bool_use_external_driver.\n+\n 2015-08-25  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.c-torture/execute/builtins/20010124-1.x: New."}, {"sha": "733522310debfcdd7a11f4f67deb2ae38251a3d7", "filename": "gcc/testsuite/jit.dg/test-error-pr63969-missing-driver.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-pr63969-missing-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9376dd63e6a2d94823f6faf8212c9f37bef5a656/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-pr63969-missing-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-pr63969-missing-driver.c?ref=9376dd63e6a2d94823f6faf8212c9f37bef5a656", "patch": "@@ -21,6 +21,10 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n      Unset it.  */\n   gcc_jit_context_set_str_option (ctxt, GCC_JIT_STR_OPTION_PROGNAME, NULL);\n \n+  /* By default, we use an embedded copy of the driver.\n+     Opt-in to using an external copy of the driver.  */\n+  gcc_jit_context_set_bool_use_external_driver (ctxt, 1);\n+\n   /* Break PATH, so that the driver can't be found\n      by gcc::jit::playback::context::compile ()\n      within gcc_jit_context_compile.  */"}]}