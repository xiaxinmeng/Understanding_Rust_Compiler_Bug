{"sha": "f661c0bb6371f355966a67b5ce71398e80792948", "node_id": "C_kwDOANBUbNoAKGY2NjFjMGJiNjM3MWYzNTU5NjZhNjdiNWNlNzEzOThlODA3OTI5NDg", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-02-07T13:27:36Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-02-07T13:46:35Z"}, "message": "RA: Implement reuse of equivalent memory for caller saves optimization\n\nThe test case shows opportunity to reuse memory with constant address for\ncaller saves optimization for constant or pure function call.  The patch\nimplements the memory reuse.\n\n        PR rtl-optimization/103541\n\ngcc/ChangeLog:\n\n\t* ira.h (struct ira_reg_equiv_s): Add new field caller_save_p.\n\t* ira.cc (validate_equiv_mem): Check memref address variance.\n\t(update_equiv_regs): Define caller save equivalence for\n\tvalid_combine.\n\t(setup_reg_equiv): Clear defined_p flag for caller save equivalence.\n\t* lra-constraints.cc (lra_copy_reg_equiv): Add new arg\n\tcall_save_p.  Use caller save equivalence depending on the arg.\n\t(split_reg): Adjust the call.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr103541.c: New.", "tree": {"sha": "2fed39477f056cd4366a0ededc2e6f8d580f9e7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fed39477f056cd4366a0ededc2e6f8d580f9e7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f661c0bb6371f355966a67b5ce71398e80792948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f661c0bb6371f355966a67b5ce71398e80792948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f661c0bb6371f355966a67b5ce71398e80792948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f661c0bb6371f355966a67b5ce71398e80792948/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "295adfc9ed20468cdaba3afe258d57b58a8df792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295adfc9ed20468cdaba3afe258d57b58a8df792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/295adfc9ed20468cdaba3afe258d57b58a8df792"}], "stats": {"total": 54, "additions": 44, "deletions": 10}, "files": [{"sha": "c6ee46286bc7326b2f56cf7b8130f0491aafa353", "filename": "gcc/ira.cc", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Fira.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Fira.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.cc?ref=f661c0bb6371f355966a67b5ce71398e80792948", "patch": "@@ -3070,6 +3070,8 @@ validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n     info->equiv_mem_modified = true;\n }\n \n+static int equiv_init_varies_p (rtx x);\n+\n enum valid_equiv { valid_none, valid_combine, valid_reload };\n \n /* Verify that no store between START and the death of REG invalidates\n@@ -3113,7 +3115,8 @@ validate_equiv_mem (rtx_insn *start, rtx reg, rtx memref)\n \t     been changed and all hell breaks loose.  */\n \t  ret = valid_combine;\n \t  if (!MEM_READONLY_P (memref)\n-\t      && !RTL_CONST_OR_PURE_CALL_P (insn))\n+\t      && (!RTL_CONST_OR_PURE_CALL_P (insn)\n+\t\t  || equiv_init_varies_p (XEXP (memref, 0))))\n \t    return valid_none;\n \t}\n \n@@ -3766,7 +3769,18 @@ update_equiv_regs (void)\n \t\t{\n \t\t  replacement = copy_rtx (SET_SRC (set));\n \t\t  if (validity == valid_reload)\n-\t\t    note = set_unique_reg_note (insn, REG_EQUIV, replacement);\n+\t\t    {\n+\t\t      note = set_unique_reg_note (insn, REG_EQUIV, replacement);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* We still can use this equivalence for caller save\n+\t\t\t optimization in LRA.  Mark this.  */\n+\t\t      ira_reg_equiv[regno].caller_save_p = true;\n+\t\t      ira_reg_equiv[regno].init_insns\n+\t\t\t= gen_rtx_INSN_LIST (VOIDmode, insn,\n+\t\t\t\t\t     ira_reg_equiv[regno].init_insns);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -4156,7 +4170,7 @@ setup_reg_equiv (void)\n \t\t   legitimate, we ignore such REG_EQUIV notes.  */\n \t\tif (memory_operand (x, VOIDmode))\n \t\t  {\n-\t\t    ira_reg_equiv[i].defined_p = true;\n+\t\t    ira_reg_equiv[i].defined_p = !ira_reg_equiv[i].caller_save_p;\n \t\t    ira_reg_equiv[i].memory = x;\n \t\t    continue;\n \t\t  }"}, {"sha": "3d35025a46e120dfab6dfb4abe15dacf9c771dc4", "filename": "gcc/ira.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=f661c0bb6371f355966a67b5ce71398e80792948", "patch": "@@ -175,8 +175,11 @@ extern struct target_ira *this_target_ira;\n /* Major structure describing equivalence info for a pseudo.  */\n struct ira_reg_equiv_s\n {\n-  /* True if we can use this equivalence.  */\n+  /* True if we can use this as a general equivalence.  */\n   bool defined_p;\n+  /* True if we can use this equivalence only for caller save/restore\n+     location.  */\n+  bool caller_save_p;\n   /* True if the usage of the equivalence is profitable.  */\n   bool profitable_p;\n   /* Equiv. memory, constant, invariant, and initializing insns of"}, {"sha": "dd4f68bbfc0de5caaff4143db20266772cc83638", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=f661c0bb6371f355966a67b5ce71398e80792948", "patch": "@@ -5771,14 +5771,17 @@ choose_split_class (enum reg_class allocno_class,\n   return best_cl;\n }\n \n-/* Copy any equivalence information from ORIGINAL_REGNO to NEW_REGNO.\n-   It only makes sense to call this function if NEW_REGNO is always\n-   equal to ORIGINAL_REGNO.  */\n+/* Copy any equivalence information from ORIGINAL_REGNO to NEW_REGNO.  It only\n+   makes sense to call this function if NEW_REGNO is always equal to\n+   ORIGINAL_REGNO.  Set up defined_p flag when caller_save_p flag is set up and\n+   CALL_SAVE_P is true.  */\n \n static void\n-lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno)\n+lra_copy_reg_equiv (unsigned int new_regno, unsigned int original_regno,\n+\t\t    bool call_save_p)\n {\n-  if (!ira_reg_equiv[original_regno].defined_p)\n+  if (!ira_reg_equiv[original_regno].defined_p\n+      && !(call_save_p && ira_reg_equiv[original_regno].caller_save_p))\n     return;\n \n   ira_expand_reg_equiv ();\n@@ -5958,7 +5961,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n      rematerializing the original value instead of spilling to the stack.  */\n   if (!HARD_REGISTER_NUM_P (original_regno)\n       && mode == PSEUDO_REGNO_MODE (original_regno))\n-    lra_copy_reg_equiv (new_regno, original_regno);\n+    lra_copy_reg_equiv (new_regno, original_regno, call_save_p);\n   lra_reg_info[new_regno].restore_rtx = regno_reg_rtx[original_regno];\n   bitmap_set_bit (&lra_split_regs, new_regno);\n   if (to != NULL)"}, {"sha": "72b257d42ee2fb8c43d23ab23396e7f8e4d94770", "filename": "gcc/testsuite/gcc.target/i386/pr103541.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f661c0bb6371f355966a67b5ce71398e80792948/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103541.c?ref=f661c0bb6371f355966a67b5ce71398e80792948", "patch": "@@ -0,0 +1,14 @@\n+/* PR rtl-optimization/103541 */\n+/* { dg-do compile  { target x86_64-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+float a;\n+__attribute__((const)) float foo (float);\n+\n+float\n+test()\n+{\n+        return a + foo(a) + a;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\\\\\(%rsp\\\\\\)\" } } */"}]}