{"sha": "d1485032c8ae427d2090b32d8dfc50e207f64fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE0ODUwMzJjOGFlNDI3ZDIwOTBiMzJkOGRmYzUwZTIwN2Y2NGZkOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-10-18T21:10:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-18T21:10:32Z"}, "message": "tree.c (restore_tree_status): Also free up temporary storage when we finish a toplevel function.\n\n\t* tree.c (restore_tree_status): Also free up temporary storage\n\twhen we finish a toplevel function.\n\t(dump_tree_statistics): Print stats for backend obstacks.\n\n\t* libgcc2.c (__throw): Don't copy the return address.\n\t* dwarf2out.c (expand_builtin_dwarf_reg_size): Ignore return address.\n\n\t* except.c (exceptions_via_longjmp): Initialize to 2 (uninitialized).\n\t* toplev.c (main): Initialize exceptions_via_longjmp.\n\n\t* tree.c: Add extra_inline_obstacks.\n\t(save_tree_status): Use it.\n\t(restore_tree_status): If this is a toplevel inline obstack and we\n\tdidn't want to save anything on it, recycle it.\n\t(print_inline_obstack_statistics): New fn.\n\t* function.c (pop_function_context_from): Pass context to\n\trestore_tree_status.\n\t* obstack.h (obstack_empty_p): New macro.\n\nFrom-SVN: r16050", "tree": {"sha": "3d75f9c5827cef9704b4bbc12cbda4145c21754a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d75f9c5827cef9704b4bbc12cbda4145c21754a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1485032c8ae427d2090b32d8dfc50e207f64fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1485032c8ae427d2090b32d8dfc50e207f64fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1485032c8ae427d2090b32d8dfc50e207f64fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1485032c8ae427d2090b32d8dfc50e207f64fd9/comments", "author": null, "committer": null, "parents": [{"sha": "6bd35f867188095d5a51f49917f245995b5f97b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd35f867188095d5a51f49917f245995b5f97b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd35f867188095d5a51f49917f245995b5f97b3"}], "stats": {"total": 168, "additions": 143, "deletions": 25}, "files": [{"sha": "6cc23741e9f2c97fca52ecf4b1a837d47aed8379", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -1,7 +1,30 @@\n+Sat Oct 18 13:47:15 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (restore_tree_status): Also free up temporary storage\n+\twhen we finish a toplevel function.\n+\t(dump_tree_statistics): Print stats for backend obstacks.\n+\n Sat Oct 18 12:47:31 1997  Doug Evans  <dje@canuck.cygnus.com>\n \n \t* expr.c (use_group_regs): Don't call use_reg for MEMs.\n \n+Sat Oct 18 09:49:46 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* libgcc2.c (__throw): Don't copy the return address.\n+\t* dwarf2out.c (expand_builtin_dwarf_reg_size): Ignore return address.\n+\n+\t* except.c (exceptions_via_longjmp): Initialize to 2 (uninitialized).\n+\t* toplev.c (main): Initialize exceptions_via_longjmp.\n+\n+\t* tree.c: Add extra_inline_obstacks.\n+\t(save_tree_status): Use it.\n+\t(restore_tree_status): If this is a toplevel inline obstack and we\n+\tdidn't want to save anything on it, recycle it.\n+\t(print_inline_obstack_statistics): New fn.\n+\t* function.c (pop_function_context_from): Pass context to \n+\trestore_tree_status.\n+\t* obstack.h (obstack_empty_p): New macro.\n+\n Sat Oct 18 00:43:59 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386/freebsd.h (ASM_COMMENT_START): Fix."}, {"sha": "eebac520cac490f439b8b321a93e27880b44d1cf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -520,27 +520,31 @@ expand_builtin_dwarf_reg_size (reg_tree, target)\n      tree reg_tree;\n      rtx target;\n {\n-  int i, n_ranges, size;\n+  int size;\n   struct reg_size_range ranges[5];\n   tree t, t2;\n \n-  ranges[0].beg = 0;\n-  ranges[0].size = GET_MODE_SIZE (reg_raw_mode[0]);\n-  n_ranges = 1;\n+  int i = 0;\n+  int n_ranges = 0;\n+  int last_size = -1;\n \n-  for (i = 1; i < FIRST_PSEUDO_REGISTER; ++i)\n+  for (; i < FIRST_PSEUDO_REGISTER; ++i)\n     {\n+      /* The return address is out of order on the MIPS, and we don't use\n+\t copy_reg for it anyway, so we don't care here how large it is.  */\n+      if (DWARF_FRAME_REGNUM (i) == DWARF_FRAME_RETURN_COLUMN)\n+\tcontinue;\n+\n       size = GET_MODE_SIZE (reg_raw_mode[i]);\n-      if (size != ranges[n_ranges-1].size)\n+      if (size != last_size)\n \t{\n-\t  ranges[n_ranges-1].end = i-1;\n \t  ranges[n_ranges].beg = i;\n-\t  ranges[n_ranges].size = GET_MODE_SIZE (reg_raw_mode[i]);\n+\t  ranges[n_ranges].size = last_size = GET_MODE_SIZE (reg_raw_mode[i]);\n \t  ++n_ranges;\n \t  assert (n_ranges < 5);\n \t}\n+      ranges[n_ranges-1].end = i;\n     }\n-  ranges[n_ranges-1].end = i-1;\n \n   /* The usual case: fp regs surrounded by general regs.  */\n   if (n_ranges == 3 && ranges[0].size == ranges[2].size)"}, {"sha": "2a2554bc15b56d00a12ba6d5a14f6dd9e0f75679", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -98,7 +98,7 @@ Boston, MA 02111-1307, USA.  */\n    is stored in a section named .eh_frame and the information for the\n    entire shared object or program is registered with a call to\n    __register_frame.  On other targets, the information for each\n-   translation unit is registered separately with a static constructor.\n+   translation unit is registered from the file generated by collect2.\n    __register_frame is defined in frame.c, and is responsible for\n    recording all of the unwind regions into one list (which is kept in a\n    static variable named unwind_table_list).\n@@ -409,11 +409,7 @@ Boston, MA 02111-1307, USA.  */\n /* One to use setjmp/longjmp method of generating code for exception\n    handling.  */\n \n-#if DWARF2_UNWIND_INFO\n-int exceptions_via_longjmp = 0;\n-#else\n-int exceptions_via_longjmp = 1;\n-#endif\n+int exceptions_via_longjmp = 2;\n \n /* One to enable asynchronous exception support.  */\n "}, {"sha": "61a72fe7d96d12178920c5d6895d21a6ede27538", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -610,7 +610,7 @@ pop_function_context_from (context)\n   reg_renumber = 0;\n   current_function_args_info = p->args_info;\n \n-  restore_tree_status (p);\n+  restore_tree_status (p, context);\n   restore_storage_status (p);\n   restore_expr_status (p);\n   restore_emit_status (p);"}, {"sha": "ae97c5313ae7b615fb844f7895eee2aab42e2c85", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -3733,7 +3733,7 @@ __throw ()\n \t  sub_udata = p;\n \n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-\t    if (udata->saved[i])\n+\t    if (i != udata->retaddr_column && udata->saved[i])\n \t      {\n #ifdef INCOMING_REGNO\n \t\t/* If you modify the saved value of the return address"}, {"sha": "1b172acab276cf4354164b1262d7cca48cf41fbe", "filename": "gcc/obstack.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Fobstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Fobstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobstack.h?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -332,6 +332,11 @@ int obstack_chunk_size (struct obstack *obstack);\n   ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n      (unsigned) (__o->chunk_limit - __o->next_free); })\n \n+#define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n+     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })\n+\n #define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\t\\\n ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n@@ -460,6 +465,9 @@ __extension__\t\t\t\t\t\t\t\t\\\n #define obstack_room(h)\t\t\\\n  (unsigned) ((h)->chunk_limit - (h)->next_free)\n \n+#define obstack_empty_p(h) \\ \n+ ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)\n+\n /* Note that the call to _obstack_newchunk is enclosed in (..., 0)\n    so that we can avoid having void expressions\n    in the arms of the conditional expression."}, {"sha": "41e2c5b87f04bb92cf4dbaa5dc73549355b57ec4", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -4294,6 +4294,15 @@ main (argc, argv, envp)\n   OVERRIDE_OPTIONS;\n #endif\n \n+  if (exceptions_via_longjmp == 2)\n+    {\n+#ifdef DWARF2_UNWIND_INFO\n+      exceptions_via_longjmp = ! DWARF2_UNWIND_INFO;\n+#else\n+      exceptions_via_longjmp = 1;\n+#endif\n+    }\n+\n   if (profile_block_flag == 3)\n     {\n       warning (\"`-ax' and `-a' are conflicting options. `-a' ignored.\");"}, {"sha": "d5eabaea008a5c1bdc64cf8525dd89341936cc9a", "filename": "gcc/tree.c", "status": "modified", "additions": 86, "deletions": 8, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1485032c8ae427d2090b32d8dfc50e207f64fd9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d1485032c8ae427d2090b32d8dfc50e207f64fd9", "patch": "@@ -81,6 +81,10 @@ struct obstack maybepermanent_obstack;\n \n struct simple_obstack_stack *toplev_inline_obstacks;\n \n+/* Former elements of toplev_inline_obstacks that have been recycled.  */\n+\n+struct simple_obstack_stack *extra_inline_obstacks;\n+\n /* This is a list of function_maybepermanent_obstacks for inline functions\n    nested in the current function that were compiled in the middle of\n    compiling other functions.  */\n@@ -381,12 +385,22 @@ save_tree_status (p, context)\n \t  head = &f->inline_obstacks;\n \t}\n \n-      current = ((struct simple_obstack_stack *)\n-\t\t xmalloc (sizeof (struct simple_obstack_stack)));\n+      if (context == NULL_TREE && extra_inline_obstacks)\n+\t{\n+\t  current = extra_inline_obstacks;\n+\t  extra_inline_obstacks = current->next;\n+\t}\n+      else\n+\t{\n+\t  current = ((struct simple_obstack_stack *)\n+\t\t     xmalloc (sizeof (struct simple_obstack_stack)));\n+\n+\t  current->obstack\n+\t    = (struct obstack *) xmalloc (sizeof (struct obstack));\n+\t  gcc_obstack_init (current->obstack);\n+\t}\n \n-      current->obstack = (struct obstack *) xmalloc (sizeof (struct obstack));\n       function_maybepermanent_obstack = current->obstack;\n-      gcc_obstack_init (function_maybepermanent_obstack);\n \n       current->next = *head;\n       *head = current;\n@@ -411,8 +425,9 @@ save_tree_status (p, context)\n    This is used after a nested function.  */\n \n void\n-restore_tree_status (p)\n+restore_tree_status (p, context)\n      struct function *p;\n+     tree context;\n {\n   all_types_permanent = p->all_types_permanent;\n   momentary_stack = p->momentary_stack;\n@@ -428,6 +443,29 @@ restore_tree_status (p)\n      past the nested function's end.  */\n   obstack_free (function_maybepermanent_obstack, maybepermanent_firstobj);\n \n+  /* If we were compiling a toplevel function, we can free this space now.  */\n+  if (context == NULL_TREE)\n+    {\n+      obstack_free (&temporary_obstack, temporary_firstobj);\n+      obstack_free (&momentary_obstack, momentary_function_firstobj);\n+    }\n+\n+  /* If we were compiling a toplevel function that we don't actually want\n+     to save anything from, return the obstack to the pool.  */\n+  if (context == NULL_TREE\n+      && obstack_empty_p (function_maybepermanent_obstack))\n+    {\n+      struct simple_obstack_stack *current, **p = &toplev_inline_obstacks;\n+\n+      while ((*p)->obstack != function_maybepermanent_obstack)\n+\tp = &((*p)->next);\n+      current = *p;\n+      *p = current->next;\n+\n+      current->next = extra_inline_obstacks;\n+      extra_inline_obstacks = current;\n+    }\n+\n   obstack_free (function_obstack, 0);\n   free (function_obstack);\n \n@@ -4469,24 +4507,58 @@ decl_type_context (decl)\n   return NULL_TREE;\n }\n \n+/* Print debugging information about the size of the\n+   toplev_inline_obstacks.  */\n+\n+void\n+print_inline_obstack_statistics ()\n+{\n+  struct simple_obstack_stack *current = toplev_inline_obstacks;\n+  int n_obstacks = 0;\n+  unsigned long n_alloc = 0;\n+  int n_chunks = 0;\n+\n+  for (; current; current = current->next, ++n_obstacks)\n+    {\n+      struct obstack *o = current->obstack;\n+      struct _obstack_chunk *chunk = o->chunk;\n+\n+      n_alloc += o->next_free - chunk->contents;\n+      chunk = chunk->prev;\n+      ++n_chunks;\n+      for (; chunk; chunk = chunk->prev, ++n_chunks)\n+\tn_alloc += chunk->limit - &chunk->contents[0];\n+    }\n+  fprintf (stderr, \"inline obstacks: %d obstacks, %lu bytes, %d chunks\\n\",\n+\t   n_obstacks, n_alloc, n_chunks);\n+}\n+\n+/* Print debugging information about the obstack O, named STR.  */\n+\n void\n print_obstack_statistics (str, o)\n      char *str;\n      struct obstack *o;\n {\n   struct _obstack_chunk *chunk = o->chunk;\n-  int n_chunks = 0;\n-  int n_alloc = 0;\n+  int n_chunks = 1;\n+  unsigned long n_alloc = 0;\n \n+  n_alloc += o->next_free - chunk->contents;\n+  chunk = chunk->prev;\n   while (chunk)\n     {\n       n_chunks += 1;\n       n_alloc += chunk->limit - &chunk->contents[0];\n       chunk = chunk->prev;\n     }\n-  fprintf (stderr, \"obstack %s: %d bytes, %d chunks\\n\",\n+  fprintf (stderr, \"obstack %s: %lu bytes, %d chunks\\n\",\n \t   str, n_alloc, n_chunks);\n }\n+\n+/* Print debugging information about tree nodes generated during the compile,\n+   and any language-specific information.  */\n+\n void\n dump_tree_statistics ()\n {\n@@ -4512,6 +4584,12 @@ dump_tree_statistics ()\n #else\n   fprintf (stderr, \"(No per-node statistics)\\n\");\n #endif\n+  print_obstack_statistics (\"permanent_obstack\", &permanent_obstack);\n+  print_obstack_statistics (\"maybepermanent_obstack\", &maybepermanent_obstack);\n+  print_obstack_statistics (\"temporary_obstack\", &temporary_obstack);\n+  print_obstack_statistics (\"momentary_obstack\", &momentary_obstack);\n+  print_obstack_statistics (\"temp_decl_obstack\", &temp_decl_obstack);\n+  print_inline_obstack_statistics ();\n   print_lang_statistics ();\n }\n \f"}]}