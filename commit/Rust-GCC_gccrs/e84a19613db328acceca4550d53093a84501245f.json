{"sha": "e84a19613db328acceca4550d53093a84501245f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0YTE5NjEzZGIzMjhhY2NlY2E0NTUwZDUzMDkzYTg0NTAxMjQ1Zg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:53:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:53:20Z"}, "message": "erroutc.ads, [...] (Set_Specific_Warning_On): New procedure\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* erroutc.ads, erroutc.adb (Set_Specific_Warning_On): New procedure\n\t(Set_Specific_Warning_Off): New procedure\n\t(Warning_Specifically_Suppressed): New function\n\t(Validate_Specific_Warnings): New procedure\n\t(Output_Msg_Text): Complete rewrite to support -gnatjnn\n\n\t* err_vars.ads: Implement insertion character ~ (insert string)\n\nFrom-SVN: r118252", "tree": {"sha": "42884bc1ba8007991e0c6cd2d2a66f5a81a3e6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42884bc1ba8007991e0c6cd2d2a66f5a81a3e6a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e84a19613db328acceca4550d53093a84501245f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84a19613db328acceca4550d53093a84501245f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e84a19613db328acceca4550d53093a84501245f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84a19613db328acceca4550d53093a84501245f/comments", "author": null, "committer": null, "parents": [{"sha": "4ecc031cdb794be4acb8a2824350d1c6c36c9566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ecc031cdb794be4acb8a2824350d1c6c36c9566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ecc031cdb794be4acb8a2824350d1c6c36c9566"}], "stats": {"total": 412, "additions": 400, "deletions": 12}, "files": [{"sha": "fedeb0718fdca511586fe1597a197a603d6622b3", "filename": "gcc/ada/err_vars.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84a19613db328acceca4550d53093a84501245f/gcc%2Fada%2Ferr_vars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84a19613db328acceca4550d53093a84501245f/gcc%2Fada%2Ferr_vars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferr_vars.ads?ref=e84a19613db328acceca4550d53093a84501245f", "patch": "@@ -132,4 +132,9 @@ package Err_Vars is\n    --  Used if current message contains a < insertion character to indicate\n    --  if the current message is a warning message.\n \n+   Error_Msg_String : String (1 .. 4096);\n+   Error_Msg_Strlen : Natural;\n+   --  Used if current message contains a ~ insertion character to indicate\n+   --  insertion of the string Error_Msg_String (1 .. Error_Msg_Strlen).\n+\n end Err_Vars;"}, {"sha": "cb508f22c75cfdb2503dc5db749b770a01e3be72", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 304, "deletions": 6, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84a19613db328acceca4550d53093a84501245f/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84a19613db328acceca4550d53093a84501245f/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=e84a19613db328acceca4550d53093a84501245f", "patch": "@@ -43,10 +43,6 @@ with Uintp;    use Uintp;\n \n package body Erroutc is\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n    ---------------\n    -- Add_Class --\n    ---------------\n@@ -370,7 +366,6 @@ package body Erroutc is\n       while T /= No_Error_Msg\n         and then Errors.Table (T).Line = Errors.Table (E).Line\n         and then Errors.Table (T).Sfile = Errors.Table (E).Sfile\n-\n       loop\n          Write_Str (\"        >>> \");\n          Output_Msg_Text (T);\n@@ -437,18 +432,106 @@ package body Erroutc is\n    ---------------------\n \n    procedure Output_Msg_Text (E : Error_Msg_Id) is\n+      Offs : constant Nat := Column - 1;\n+      --  Offset to start of message, used for continuations\n+\n+      Max : Integer;\n+      --  Maximum characters to output on next line\n+\n+      Length : Nat;\n+      --  Maximum total length of lines\n+\n    begin\n+      if Error_Msg_Line_Length = 0 then\n+         Length := Nat'Last;\n+      else\n+         Length := Error_Msg_Line_Length;\n+      end if;\n+\n+      Max := Integer (Length - Column + 1);\n+\n       if Errors.Table (E).Warn then\n          Write_Str (\"warning: \");\n+         Max := Max - 9;\n \n       elsif Errors.Table (E).Style then\n          null;\n \n       elsif Opt.Unique_Error_Tag then\n          Write_Str (\"error: \");\n+         Max := Max - 7;\n       end if;\n \n-      Write_Str (Errors.Table (E).Text.all);\n+      --  Here we have to split the message up into multiple lines\n+\n+      declare\n+         Txt   : constant String_Ptr := Errors.Table (E).Text;\n+         Len   : constant Natural    := Txt'Length;\n+         Ptr   : Natural;\n+         Split : Natural;\n+         Start : Natural;\n+\n+      begin\n+         Ptr := 1;\n+         loop\n+            --  Make sure we do not have ludicrously small line\n+\n+            Max := Integer'Max (Max, 20);\n+\n+            --  If remaining text fits, output it respecting LF and we are done\n+\n+            if Len - Ptr < Max then\n+               for J in Ptr .. Len loop\n+                  if Txt (J) = ASCII.LF then\n+                     Write_Eol;\n+                     Write_Spaces (Offs);\n+                  else\n+                     Write_Char (Txt (J));\n+                  end if;\n+               end loop;\n+\n+               return;\n+\n+            --  Line does not fit\n+\n+            else\n+               Start := Ptr;\n+\n+               --  First scan forward looing for a hard end of line\n+\n+               for Scan in Ptr .. Ptr + Max - 1 loop\n+                  if Txt (Scan) = ASCII.LF then\n+                     Split := Scan - 1;\n+                     Ptr := Scan + 1;\n+                     goto Continue;\n+                  end if;\n+               end loop;\n+\n+               --  Otherwise scan backwards looking for a space\n+\n+               for Scan in reverse Ptr .. Ptr + Max - 1 loop\n+                  if Txt (Scan) = ' ' then\n+                     Split := Scan - 1;\n+                     Ptr := Scan + 1;\n+                     goto Continue;\n+                  end if;\n+               end loop;\n+\n+               --  If we fall through, no space, so split line arbitrarily\n+\n+               Split := Ptr + Max - 1;\n+               Ptr := Split + 1;\n+            end if;\n+\n+         <<Continue>>\n+            if Start <= Split then\n+               Write_Line (Txt (Start .. Split));\n+               Write_Spaces (Offs);\n+            end if;\n+\n+            Max := Integer (Length - Column + 1);\n+         end loop;\n+      end;\n    end Output_Msg_Text;\n \n    --------------------\n@@ -916,6 +999,79 @@ package body Erroutc is\n       end if;\n    end Set_Next_Non_Deleted_Msg;\n \n+   ------------------------------\n+   -- Set_Specific_Warning_Off --\n+   ------------------------------\n+\n+   procedure Set_Specific_Warning_Off (Loc : Source_Ptr; Msg : String) is\n+      pragma Assert (Msg'First = 1);\n+\n+      Pattern : String  := Msg;\n+      Patlen  : Natural := Msg'Length;\n+\n+      Star_Start : Boolean;\n+      Star_End   : Boolean;\n+\n+   begin\n+      if Pattern (1) = '*' then\n+         Star_Start := True;\n+         Pattern (1 .. Patlen - 1) := Pattern (2 .. Patlen);\n+         Patlen := Patlen - 1;\n+      else\n+         Star_Start := False;\n+      end if;\n+\n+      if Pattern (Patlen) = '*' then\n+         Star_End := True;\n+         Patlen := Patlen - 1;\n+      else\n+         Star_End := False;\n+      end if;\n+\n+      Specific_Warnings.Increment_Last;\n+      Specific_Warnings.Table (Specific_Warnings.Last) :=\n+        (Start      => Loc,\n+         Msg        => new String'(Msg),\n+         Pattern    => new String'(Pattern (1 .. Patlen)),\n+         Patlen     => Patlen,\n+         Stop       => Source_Last (Current_Source_File),\n+         Open       => True,\n+         Used       => False,\n+         Star_Start => Star_Start,\n+         Star_End   => Star_End);\n+   end Set_Specific_Warning_Off;\n+\n+   -----------------------------\n+   -- Set_Specific_Warning_On --\n+   -----------------------------\n+\n+   procedure Set_Specific_Warning_On\n+     (Loc : Source_Ptr;\n+      Msg : String;\n+      Err : out Boolean)\n+   is\n+   begin\n+      for J in 1 .. Specific_Warnings.Last loop\n+         declare\n+            SWE : Specific_Warning_Entry renames Specific_Warnings.Table (J);\n+         begin\n+            if Msg = SWE.Msg.all\n+              and then Loc > SWE.Start\n+              and then SWE.Open\n+              and then Get_Source_File_Index (SWE.Start) =\n+                       Get_Source_File_Index (Loc)\n+            then\n+               SWE.Stop := Loc;\n+               SWE.Open := False;\n+               Err := False;\n+               return;\n+            end if;\n+         end;\n+      end loop;\n+\n+      Err := True;\n+   end Set_Specific_Warning_On;\n+\n    ---------------------------\n    -- Set_Warnings_Mode_Off --\n    ---------------------------\n@@ -1017,12 +1173,154 @@ package body Erroutc is\n       end if;\n    end Test_Style_Warning_Serious_Msg;\n \n+   --------------------------------\n+   -- Validate_Specific_Warnings --\n+   --------------------------------\n+\n+   procedure Validate_Specific_Warnings (Eproc : Error_Msg_Proc) is\n+   begin\n+      for J in Specific_Warnings.First .. Specific_Warnings.Last loop\n+         declare\n+            SWE : Specific_Warning_Entry renames Specific_Warnings.Table (J);\n+         begin\n+            if SWE.Start /= No_Location then\n+               if SWE.Open then\n+                  Eproc.all\n+                    (\"?pragma Warnings Off with no matching Warnings On\",\n+                     SWE.Start);\n+               elsif not SWE.Used then\n+                  Eproc.all\n+                    (\"?no warning suppressed by this pragma\", SWE.Start);\n+               end if;\n+            end if;\n+         end;\n+      end loop;\n+   end Validate_Specific_Warnings;\n+\n+   -------------------------------------\n+   -- Warning_Specifically_Suppressed --\n+   -------------------------------------\n+\n+   function Warning_Specifically_Suppressed\n+     (Loc : Source_Ptr;\n+      Msg : String_Ptr) return Boolean\n+   is\n+      pragma Assert (Msg'First = 1);\n+\n+      Msglen : constant Natural := Msg'Length;\n+      Patlen : Natural;\n+      --  Length of message\n+\n+      Pattern : String_Ptr;\n+      --  Pattern itself, excluding initial and final *\n+\n+      Star_Start : Boolean;\n+      Star_End   : Boolean;\n+      --  Indications of * at start and end of original pattern\n+\n+      Msgp : Natural;\n+      Patp : Natural;\n+      --  Scan pointers for message and pattern\n+\n+   begin\n+      --  Loop through specific warning suppression entries\n+\n+      for J in Specific_Warnings.First .. Specific_Warnings.Last loop\n+         declare\n+            SWE : Specific_Warning_Entry renames Specific_Warnings.Table (J);\n+\n+         begin\n+            --  See if location is in range\n+\n+            if SWE.Start = No_Location\n+              or else (SWE.Start <= Loc and then Loc <= SWE.Stop)\n+            then\n+               Patlen     := SWE.Patlen;\n+               Pattern    := SWE.Pattern;\n+               Star_Start := SWE.Star_Start;\n+               Star_End   := SWE.Star_End;\n+\n+               --  Loop through possible starting positions in Msg\n+\n+               Outer : for M in 1 .. 1 + (Msglen - Patlen) loop\n+\n+                  --  See if pattern matches string starting at Msg (J)\n+\n+                  Msgp := M;\n+                  Patp := 1;\n+                  Inner : loop\n+\n+                     --  If pattern exhausted, then match if we are at end\n+                     --  of message, or if pattern ended with an asterisk,\n+                     --  otherwise match failure at this position.\n+\n+                     if Patp > Patlen then\n+                        if Msgp > Msglen or else Star_End then\n+                           SWE.Used := True;\n+                           return True;\n+                        else\n+                           exit Inner;\n+                        end if;\n+\n+                        --  Otherwise if message exhausted (and we still have\n+                        --  pattern characters left), then match failure here.\n+\n+                     elsif Msgp > Msglen then\n+                        exit Inner;\n+                     end if;\n+\n+                     --  Here we have pattern and message characters left\n+\n+                     --  Handle \"*\" pattern match\n+\n+                     if Patp < Patlen - 1 and then\n+                       Pattern (Patp .. Patp + 2) = \"\"\"*\"\"\"\n+                     then\n+                        Patp := Patp + 3;\n+\n+                        --  Must have \" and at least three chars in msg or we\n+                        --  have no match at this position.\n+\n+                        exit Inner when Msg (Msgp) /= '\"';\n+                        Msgp := Msgp + 1;\n+\n+                        --  Scan out \" string \" in message\n+\n+                        Scan : loop\n+                           exit Inner when Msgp = Msglen;\n+                           Msgp := Msgp + 1;\n+                           exit Scan when Msg (Msgp - 1) = '\"';\n+                        end loop Scan;\n+\n+                     --  If not \"*\" case, just compare character\n+\n+                     else\n+                        exit Inner when Pattern (Patp) /= Msg (Msgp);\n+                        Patp := Patp + 1;\n+                        Msgp := Msgp + 1;\n+                     end if;\n+                  end loop Inner;\n+\n+                  --  Advance to next position if star at end of original\n+                  --  pattern, otherwise no more match attempts are possible\n+\n+                  exit Outer when not Star_Start;\n+               end loop Outer;\n+            end if;\n+         end;\n+      end loop;\n+\n+      return False;\n+   end Warning_Specifically_Suppressed;\n+\n    -------------------------\n    -- Warnings_Suppressed --\n    -------------------------\n \n    function Warnings_Suppressed (Loc : Source_Ptr) return Boolean is\n    begin\n+      --  Loop through table of ON/OFF warnings\n+\n       for J in Warnings.First .. Warnings.Last loop\n          if Warnings.Table (J).Start <= Loc\n            and then Loc <= Warnings.Table (J).Stop"}, {"sha": "51934df954776726ba6ea312908ae3c6d776b7d7", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 91, "deletions": 6, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84a19613db328acceca4550d53093a84501245f/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84a19613db328acceca4550d53093a84501245f/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=e84a19613db328acceca4550d53093a84501245f", "patch": "@@ -41,6 +41,10 @@ package Erroutc is\n    --  Msg_Cont parameter in Error_Msg_Internal and then set True if a \\\n    --  insertion character is encountered.\n \n+   Continuation_New_Line : Boolean := False;\n+   --  Indicates if current message was a continuation line marked with \\\\ to\n+   --  force a new line. Set True if \\\\ encountered.\n+\n    Flag_Source : Source_File_Index;\n    --  Source file index for source file where error is being posted\n \n@@ -140,7 +144,8 @@ package Erroutc is\n       --  Text of error message, fully expanded with all insertions\n \n       Next : Error_Msg_Id;\n-      --  Pointer to next message in error chain\n+      --  Pointer to next message in error chain. A value of No_Error_Msg\n+      --  indicates the end of the chain.\n \n       Sfile : Source_File_Index;\n       --  Source table index of source file. In the case of an error that\n@@ -218,9 +223,12 @@ package Erroutc is\n    --------------------------\n \n    --  Pragma Warnings allows warnings to be turned off for a specified\n-   --  region of code, and the following tabl is the data structure used\n+   --  region of code, and the following tables are the data structure used\n    --  to keep track of these regions.\n \n+   --  The first table is used for the basic command line control, and for\n+   --  the forms of Warning with a single ON or OFF parameter\n+\n    --  It contains pairs of source locations, the first being the start\n    --  location for a warnings off region, and the second being the end\n    --  location. When a pragma Warnings (Off) is encountered, a new entry\n@@ -247,6 +255,49 @@ package Erroutc is\n      Table_Increment      => 200,\n      Table_Name           => \"Warnings\");\n \n+   --  The second table is used for the specific forms of the pragma, where\n+   --  the first argument is ON or OFF, and the second parameter is a string\n+   --  which is the entire message to suppress, or a prefix of it.\n+\n+   type Specific_Warning_Entry is record\n+      Start : Source_Ptr;\n+      Stop  : Source_Ptr;\n+      --  Starting and ending source pointers for the range. These are always\n+      --  from the same source file. Start is set to No_Location for the case\n+      --  of a configuration pragma.\n+\n+      Msg : String_Ptr;\n+      --  Message from pragma Warnings (Off, string)\n+\n+      Pattern : String_Ptr;\n+      --  Same as Msg, excluding initial and final asterisks if present. The\n+      --  lower bound of this string is always one.\n+\n+      Patlen : Natural;\n+      --  Length of pattern string (excluding initial/final asterisks)\n+\n+      Open : Boolean;\n+      --  Set to True if OFF has been encountered with no matchin ON\n+\n+      Used : Boolean;\n+      --  Set to True if entry has been used to suppress a warning\n+\n+      Star_Start : Boolean;\n+      --  True if given pattern had * at start\n+\n+      Star_End : Boolean;\n+      --  True if given pattern had * at end\n+\n+   end record;\n+\n+   package Specific_Warnings is new Table.Table (\n+     Table_Component_Type => Specific_Warning_Entry,\n+     Table_Index_Type     => Natural,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Specific_Warnings\");\n+\n    -----------------\n    -- Subprograms --\n    -----------------\n@@ -292,9 +343,11 @@ package Erroutc is\n    --  as all blanks, avoiding output of junk line numbers.\n \n    procedure Output_Msg_Text (E : Error_Msg_Id);\n-   --  Outputs characters of text in the text of the error message E, excluding\n-   --  any final exclamation point. Note that no end of line is output, the\n-   --  caller is responsible for adding the end of line.\n+   --  Outputs characters of text in the text of the error message E. Note that\n+   --  no end of line is output, the caller is responsible for adding the end\n+   --  of line. If Error_Msg_Line_Length is non-zero, this is the routine that\n+   --  splits the line generating multiple lines of output, and in this case\n+   --  the last line has no terminating end of line character.\n \n    procedure Purge_Messages (From : Source_Ptr; To : Source_Ptr);\n    --  All error messages whose location is in the range From .. To (not\n@@ -375,6 +428,24 @@ package Erroutc is\n    --  the input value of E was either already No_Error_Msg, or was the\n    --  last non-deleted message.\n \n+   procedure Set_Specific_Warning_Off (Loc : Source_Ptr; Msg : String);\n+   --  This is called in response to the two argument form of pragma Warnings\n+   --  where the first argument is OFF, and the second argument is the prefix\n+   --  of a specific warning to be suppressed. The first argument is the start\n+   --  of the suppression range, and the second argument is the string from\n+   --  the pragma. Loc is set to No_Location for the configuration pragma case.\n+\n+   procedure Set_Specific_Warning_On\n+     (Loc : Source_Ptr;\n+      Msg : String;\n+      Err : out Boolean);\n+   --  This is called in response to the two argument form of pragma Warnings\n+   --  where the first argument is ON, and the second argument is the prefix\n+   --  of a specific warning to be suppressed. The first argument is the end\n+   --  of the suppression range, and the second argument is the string from\n+   --  the pragma. Err is set to True on return to report the error of no\n+   --  matching Warnings Off pragma preceding this one.\n+\n    procedure Set_Warnings_Mode_Off (Loc : Source_Ptr);\n    --  Called in response to a pragma Warnings (Off) to record the source\n    --  location from which warnings are to be turned off.\n@@ -395,6 +466,20 @@ package Erroutc is\n    function Warnings_Suppressed (Loc : Source_Ptr) return Boolean;\n    --  Determines if given location is covered by a warnings off suppression\n    --  range in the warnings table (or is suppressed by compilation option,\n-   --  which generates a warning range for the whole source file).\n+   --  which generates a warning range for the whole source file). This routine\n+   --  only deals with the general ON/OFF case, not specific warnings\n+\n+   function Warning_Specifically_Suppressed\n+     (Loc : Source_Ptr;\n+      Msg : String_Ptr) return Boolean;\n+   --  Determines if given message to be posted at given location is suppressed\n+   --  by specific ON/OFF Warnings pragmas specifying this particular message.\n+\n+   type Error_Msg_Proc is\n+     access procedure (Msg : String; Flag_Location : Source_Ptr);\n+   procedure Validate_Specific_Warnings (Eproc : Error_Msg_Proc);\n+   --  Checks that specific warnings are consistent (for non-configuration\n+   --  case, properly closed, and used). The argument is a pointer to the\n+   --  Error_Msg procedure to be called if any inconsistencies are detected.\n \n end Erroutc;"}]}