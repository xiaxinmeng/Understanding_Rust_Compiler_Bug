{"sha": "a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkMjJmYjIxYzZmMWFkN2U4YjZiNzIyYmZjMGU3ZTExZjUwY2I5Mg==", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2021-01-16T20:58:13Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2021-01-16T20:58:13Z"}, "message": "openmp: Add support for the OpenMP 5.0 task detach clause\n\n2021-01-16  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\n\tgcc/\n\t* builtin-types.def\n\t(BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT): Rename\n\tto...\n\t(BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT_PTR):\n\t...this.  Add extra argument.\n\t* gimplify.c (omp_default_clause): Ensure that event handle is\n\tfirstprivate in a task region.\n\t(gimplify_scan_omp_clauses): Handle OMP_CLAUSE_DETACH.\n\t(gimplify_adjust_omp_clauses): Likewise.\n\t* omp-builtins.def (BUILT_IN_GOMP_TASK): Change function type to\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT_PTR.\n\t* omp-expand.c (expand_task_call): Add GOMP_TASK_FLAG_DETACH to flags\n\tif detach clause specified.  Add detach argument when generating\n\tcall to\tGOMP_task.\n\t* omp-low.c (scan_sharing_clauses): Setup data environment for detach\n\tclause.\n\t(finish_taskreg_scan): Move field for variable containing the event\n\thandle to the front of the struct.\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_DETACH.  Fix\n\tordering.\n\t* tree-nested.c (convert_nonlocal_omp_clauses): Handle\n\tOMP_CLAUSE_DETACH clause.\n\t(convert_local_omp_clauses): Handle OMP_CLAUSE_DETACH clause.\n\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_DETACH.\n\t* tree.c (omp_clause_num_ops): Add entry for OMP_CLAUSE_DETACH.\n\tFix ordering.\n\t(omp_clause_code_name): Add entry for OMP_CLAUSE_DETACH.  Fix\n\tordering.\n\t(walk_tree_1): Handle OMP_CLAUSE_DETACH.\n\n\tgcc/c-family/\n\t* c-pragma.h (pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_DETACH.\n\tRedefine PRAGMA_OACC_CLAUSE_DETACH.\n\n\tgcc/c/\n\t* c-parser.c (c_parser_omp_clause_detach): New.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_DETACH clause.\n\t(OMP_TASK_CLAUSE_MASK): Add mask for PRAGMA_OMP_CLAUSE_DETACH.\n\t* c-typeck.c (c_finish_omp_clauses): Handle PRAGMA_OMP_CLAUSE_DETACH\n\tclause.  Prevent use of detach with mergeable and overriding the\n\tdata sharing mode of the event handle.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_omp_clause_detach): New.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_DETACH.\n\t(OMP_TASK_CLAUSE_MASK): Add mask for PRAGMA_OMP_CLAUSE_DETACH.\n\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_DETACH clause.\n\t* semantics.c (finish_omp_clauses): Handle OMP_CLAUSE_DETACH clause.\n\tPrevent use of detach with mergeable and overriding the\tdata sharing\n\tmode of the event handle.\n\n\tgcc/fortran/\n\t* dump-parse-tree.c (show_omp_clauses): Handle detach clause.\n\t* frontend-passes.c (gfc_code_walker): Walk detach expression.\n\t* gfortran.h (struct gfc_omp_clauses): Add detach field.\n\t(gfc_c_intptr_kind): New.\n\t* openmp.c (gfc_free_omp_clauses): Free detach clause.\n\t(gfc_match_omp_detach): New.\n\t(enum omp_mask1): Add OMP_CLAUSE_DETACH.\n\t(enum omp_mask2): Remove OMP_CLAUSE_DETACH.\n\t(gfc_match_omp_clauses): Handle OMP_CLAUSE_DETACH for OpenMP.\n\t(OMP_TASK_CLAUSES): Add OMP_CLAUSE_DETACH.\n\t(resolve_omp_clauses): Prevent use of detach with mergeable and\n\toverriding the data sharing mode of the event handle.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Handle detach clause.\n\t* trans-types.c (gfc_c_intptr_kind): New.\n\t(gfc_init_kinds): Initialize gfc_c_intptr_kind.\n\t* types.def\n\t(BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT): Rename\n\tto...\n\t(BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT_PTR):\n\t...this.  Add extra argument.\n\n\tgcc/testsuite/\n\t* c-c++-common/gomp/task-detach-1.c: New.\n\t* g++.dg/gomp/task-detach-1.C: New.\n\t* gcc.dg/gomp/task-detach-1.c: New.\n\t* gfortran.dg/gomp/task-detach-1.f90: New.\n\n\tinclude/\n\t* gomp-constants.h (GOMP_TASK_FLAG_DETACH): New.\n\n\tlibgomp/\n\t* fortran.c (omp_fulfill_event_): New.\n\t* libgomp.h (struct gomp_task): Add detach and completion_sem fields.\n\t(struct gomp_team): Add task_detach_queue and task_detach_count\n\tfields.\n\t* libgomp.map (OMP_5.0.1): Add omp_fulfill_event and omp_fulfill_event_.\n\t* libgomp_g.h (GOMP_task): Add extra argument.\n\t* omp.h.in (enum omp_event_handle_t): New.\n\t(omp_fulfill_event): New.\n\t* omp_lib.f90.in (omp_event_handle_kind): New.\n\t(omp_fulfill_event): New.\n\t* omp_lib.h.in (omp_event_handle_kind): New.\n\t(omp_fulfill_event): Declare.\n\t* priority_queue.c (priority_tree_find): New.\n\t(priority_list_find): New.\n\t(priority_queue_find): New.\n\t* priority_queue.h (priority_queue_predicate): New.\n\t(priority_queue_find): New.\n\t* task.c (gomp_init_task): Initialize detach field.\n\t(task_fulfilled_p): New.\n\t(GOMP_task): Add detach argument.  Ignore detach argument if\n\tGOMP_TASK_FLAG_DETACH not set in flags.  Initialize completion_sem\n\tfield.\tCopy address of completion_sem into detach argument and\n\tinto the start of the data record.  Wait for detach event if task\n\tnot deferred.\n\t(gomp_barrier_handle_tasks): Queue tasks with unfulfilled events.\n\tRemove completed tasks and requeue dependent tasks.\n\t(omp_fulfill_event): New.\n\t* team.c (gomp_new_team): Initialize task_detach_queue and\n\ttask_detach_count fields.\n\t(free_team): Free task_detach_queue field.\n\t* testsuite/libgomp.c-c++-common/task-detach-1.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/task-detach-2.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/task-detach-3.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/task-detach-4.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/task-detach-5.c: New testcase.\n\t* testsuite/libgomp.c-c++-common/task-detach-6.c: New testcase.\n\t* testsuite/libgomp.fortran/task-detach-1.f90: New testcase.\n\t* testsuite/libgomp.fortran/task-detach-2.f90: New testcase.\n\t* testsuite/libgomp.fortran/task-detach-3.f90: New testcase.\n\t* testsuite/libgomp.fortran/task-detach-4.f90: New testcase.\n\t* testsuite/libgomp.fortran/task-detach-5.f90: New testcase.\n\t* testsuite/libgomp.fortran/task-detach-6.f90: New testcase.", "tree": {"sha": "7d7d0ac7d3170bea065caea25f6942a864b9a73b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d7d0ac7d3170bea065caea25f6942a864b9a73b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e5d56919dd544a530445cfd8c3f6264f3d706f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5d56919dd544a530445cfd8c3f6264f3d706f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5d56919dd544a530445cfd8c3f6264f3d706f3"}], "stats": {"total": 1245, "additions": 1183, "deletions": 62}, "files": [{"sha": "d160826e1d4f5167c6376b34d9bac75e33576bac", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -759,17 +759,17 @@ DEF_FUNCTION_TYPE_8 (BT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n \t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_LONG, BT_ULONGLONG,\n \t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR, BT_PTR)\n \n-DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n-\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n-\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n-\t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR,\n \t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n \t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_9 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n \t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG, BT_PTR, BT_PTR)\n \n+DEF_FUNCTION_TYPE_10 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT_PTR,\n+\t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t      BT_BOOL, BT_UINT, BT_PTR, BT_INT, BT_PTR)\n DEF_FUNCTION_TYPE_10 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n \t\t      BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t      BT_ULONGLONG, BT_LONG, BT_ULONGLONG, BT_PTR_ULONGLONG,"}, {"sha": "6c34ffa5be43f6014b7d2221b586958143f5ef2b", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -95,6 +95,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_DEFAULT,\n   PRAGMA_OMP_CLAUSE_DEFAULTMAP,\n   PRAGMA_OMP_CLAUSE_DEPEND,\n+  PRAGMA_OMP_CLAUSE_DETACH,\n   PRAGMA_OMP_CLAUSE_DEVICE,\n   PRAGMA_OMP_CLAUSE_DEVICE_TYPE,\n   PRAGMA_OMP_CLAUSE_DIST_SCHEDULE,\n@@ -151,7 +152,6 @@ enum pragma_omp_clause {\n   PRAGMA_OACC_CLAUSE_COPYOUT,\n   PRAGMA_OACC_CLAUSE_CREATE,\n   PRAGMA_OACC_CLAUSE_DELETE,\n-  PRAGMA_OACC_CLAUSE_DETACH,\n   PRAGMA_OACC_CLAUSE_DEVICEPTR,\n   PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT,\n   PRAGMA_OACC_CLAUSE_FINALIZE,\n@@ -174,6 +174,7 @@ enum pragma_omp_clause {\n   PRAGMA_OACC_CLAUSE_COPYIN = PRAGMA_OMP_CLAUSE_COPYIN,\n   PRAGMA_OACC_CLAUSE_DEVICE = PRAGMA_OMP_CLAUSE_DEVICE,\n   PRAGMA_OACC_CLAUSE_DEFAULT = PRAGMA_OMP_CLAUSE_DEFAULT,\n+  PRAGMA_OACC_CLAUSE_DETACH = PRAGMA_OMP_CLAUSE_DETACH,\n   PRAGMA_OACC_CLAUSE_FIRSTPRIVATE = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n   PRAGMA_OACC_CLAUSE_IF = PRAGMA_OMP_CLAUSE_IF,\n   PRAGMA_OACC_CLAUSE_PRIVATE = PRAGMA_OMP_CLAUSE_PRIVATE,"}, {"sha": "a8df208493cad7511be0c879305aca12ce2a857e", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -15977,6 +15977,56 @@ c_parser_omp_clause_uniform (c_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenMP 5.0:\n+   detach ( event-handle ) */\n+\n+static tree\n+c_parser_omp_clause_detach (c_parser *parser, tree list)\n+{\n+  matching_parens parens;\n+  location_t clause_loc = c_parser_peek_token (parser)->location;\n+\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if (c_parser_next_token_is_not (parser, CPP_NAME)\n+      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+    {\n+      c_parser_error (parser, \"expected identifier\");\n+      parens.skip_until_found_close (parser);\n+      return list;\n+    }\n+\n+  tree t = lookup_name (c_parser_peek_token (parser)->value);\n+  if (t == NULL_TREE)\n+    {\n+      undeclared_variable (c_parser_peek_token (parser)->location,\n+\t\t\t   c_parser_peek_token (parser)->value);\n+      parens.skip_until_found_close (parser);\n+      return list;\n+    }\n+  c_parser_consume_token (parser);\n+\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+  if (!INTEGRAL_TYPE_P (type)\n+      || TREE_CODE (type) != ENUMERAL_TYPE\n+      || TYPE_NAME (type) != get_identifier (\"omp_event_handle_t\"))\n+    {\n+      error_at (clause_loc, \"%<detach%> clause event handle \"\n+\t\t\t    \"has type %qT rather than \"\n+\t\t\t    \"%<omp_event_handle_t%>\",\n+\t\t\t    type);\n+      parens.skip_until_found_close (parser);\n+      return list;\n+    }\n+\n+  tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DETACH);\n+  OMP_CLAUSE_DECL (u) = t;\n+  OMP_CLAUSE_CHAIN (u) = list;\n+  parens.skip_until_found_close (parser);\n+  return u;\n+}\n+\n /* Parse all OpenACC clauses.  The set clauses allowed by the directive\n    is a bitmask in MASK.  Return the list of clauses found.  */\n \n@@ -16243,6 +16293,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_default (parser, clauses, false);\n \t  c_name = \"default\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DETACH:\n+\t  clauses = c_parser_omp_clause_detach (parser, clauses);\n+\t  c_name = \"detach\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:\n \t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n \t  c_name = \"firstprivate\";\n@@ -19190,7 +19244,8 @@ c_parser_omp_single (location_t loc, c_parser *parser, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DETACH))\n \n static tree\n c_parser_omp_task (location_t loc, c_parser *parser, bool *if_p)"}, {"sha": "8ef08434e74b32bde41171098c46259c56cd6d1d", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -13854,6 +13854,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   tree simdlen = NULL_TREE, safelen = NULL_TREE;\n   bool branch_seen = false;\n   bool copyprivate_seen = false;\n+  bool mergeable_seen = false;\n+  tree *detach_seen = NULL;\n   bool linear_variable_step_check = false;\n   tree *nowait_clause = NULL;\n   tree ordered_clause = NULL_TREE;\n@@ -14937,6 +14939,21 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n+\tcase OMP_CLAUSE_DETACH:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (detach_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"too many %qs clauses on a task construct\",\n+\t\t\t\"detach\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  detach_seen = pc;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  c_mark_addressable (t);\n+\t  continue;\n+\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_NUM_TEAMS:\n@@ -14945,7 +14962,6 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_FINAL:\n-\tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_PARALLEL:\n@@ -14979,6 +14995,11 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n+\tcase OMP_CLAUSE_MERGEABLE:\n+\t  mergeable_seen = true;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n \tcase OMP_CLAUSE_NOGROUP:\n \t  nogroup_seen = pc;\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n@@ -15230,6 +15251,41 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n       *nogroup_seen = OMP_CLAUSE_CHAIN (*nogroup_seen);\n     }\n \n+  if (detach_seen)\n+    {\n+      if (mergeable_seen)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (*detach_seen),\n+\t\t    \"%<detach%> clause must not be used together with \"\n+\t\t    \"%<mergeable%> clause\");\n+\t  *detach_seen = OMP_CLAUSE_CHAIN (*detach_seen);\n+\t}\n+      else\n+\t{\n+\t  tree detach_decl = OMP_CLAUSE_DECL (*detach_seen);\n+\n+\t  for (pc = &clauses, c = clauses; c ; c = *pc)\n+\t    {\n+\t      bool remove = false;\n+\t      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t  && OMP_CLAUSE_DECL (c) == detach_decl)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"the event handle of a %<detach%> clause \"\n+\t\t\t    \"should not be in a data-sharing clause\");\n+\t\t  remove = true;\n+\t\t}\n+\t      if (remove)\n+\t\t*pc = OMP_CLAUSE_CHAIN (c);\n+\t      else\n+\t\tpc = &OMP_CLAUSE_CHAIN (c);\n+\t    }\n+\t}\n+    }\n+\n   bitmap_obstack_release (NULL);\n   return clauses;\n }"}, {"sha": "e67339d56f94de9c0b5b5a6f4aa34e9bf3d3b3d6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -37411,6 +37411,52 @@ cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,\n   return list;\n }\n \n+/* OpenMP 5.0:\n+   detach ( event-handle ) */\n+\n+static tree\n+cp_parser_omp_clause_detach (cp_parser *parser, tree list)\n+{\n+  matching_parens parens;\n+\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  cp_token *token;\n+  tree name, decl;\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  name = cp_parser_id_expression (parser, /*template_p=*/false,\n+\t\t\t\t\t  /*check_dependency_p=*/true,\n+\t\t\t\t\t  /*template_p=*/NULL,\n+\t\t\t\t\t  /*declarator_p=*/false,\n+\t\t\t\t\t  /*optional_p=*/false);\n+  if (name == error_mark_node)\n+    decl = error_mark_node;\n+  else\n+    {\n+      if (identifier_p (name))\n+\tdecl = cp_parser_lookup_name_simple (parser, name, token->location);\n+      else\n+\tdecl = name;\n+      if (decl == error_mark_node)\n+\tcp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n+\t\t\t\t     token->location);\n+    }\n+\n+  if (decl == error_mark_node\n+      || !parens.require_close (parser))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  tree u = build_omp_clause (token->location, OMP_CLAUSE_DETACH);\n+  OMP_CLAUSE_DECL (u) = decl;\n+  OMP_CLAUSE_CHAIN (u) = list;\n+\n+  return u;\n+}\n+\n /* OpenMP 5.0:\n    iterators ( iterators-definition )\n \n@@ -38470,6 +38516,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t token->location);\n \t  c_name = \"depend\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DETACH:\n+\t  clauses = cp_parser_omp_clause_detach (parser, clauses);\n+\t  c_name = \"detach\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_MAP:\n \t  clauses = cp_parser_omp_clause_map (parser, clauses);\n \t  c_name = \"map\";\n@@ -41045,7 +41095,8 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DEPEND)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DETACH))\n \n static tree\n cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)"}, {"sha": "957140115e49e0a1606c6d8e01120de5930791be", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -17354,6 +17354,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_VECTOR:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_DETACH:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain,\n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);"}, {"sha": "c8a6283b1206f5b60e3077ab4daf21ee27d85167", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -6401,6 +6401,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n      has been seen, -2 if mixed inscan/normal reduction diagnosed.  */\n   int reduction_seen = 0;\n   bool allocate_seen = false;\n+  bool detach_seen = false;\n+  bool mergeable_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n@@ -7418,6 +7420,36 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t}\n \t    }\n \t  break;\n+\tcase OMP_CLAUSE_DETACH:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (detach_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"too many %qs clauses on a task construct\",\n+\t\t\t\"detach\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree type = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+\t      if (!type_dependent_expression_p (t)\n+\t\t  && (!INTEGRAL_TYPE_P (type)\n+\t\t      || TREE_CODE (type) != ENUMERAL_TYPE\n+\t\t      || (DECL_NAME (TYPE_NAME (type))\n+\t\t\t  != get_identifier (\"omp_event_handle_t\"))))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<detach%> clause event handle \"\n+\t\t\t    \"has type %qT rather than \"\n+\t\t\t    \"%<omp_event_handle_t%>\",\n+\t\t\t    type);\n+\t\t  remove = true;\n+\t\t}\n+\t      detach_seen = true;\n+\t      cxx_mark_addressable (t);\n+\t    }\n+\t  break;\n \n \tcase OMP_CLAUSE_MAP:\n \tcase OMP_CLAUSE_TO:\n@@ -7949,7 +7981,6 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n-\tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PARALLEL:\n \tcase OMP_CLAUSE_FOR:\n \tcase OMP_CLAUSE_SECTIONS:\n@@ -7968,6 +7999,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_FINALIZE:\n \t  break;\n \n+\tcase OMP_CLAUSE_MERGEABLE:\n+\t  mergeable_seen = true;\n+\t  break;\n+\n \tcase OMP_CLAUSE_TILE:\n \t  for (tree list = OMP_CLAUSE_TILE_LIST (c); !remove && list;\n \t       list = TREE_CHAIN (list))\n@@ -8205,6 +8240,17 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n+\tcase OMP_CLAUSE_DETACH:\n+\t  if (mergeable_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<detach%> clause must not be used together with \"\n+\t\t\t\"%<mergeable%> clause\");\n+\t      *pc = OMP_CLAUSE_CHAIN (c);\n+\t      continue;\n+\t    }\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n \tcase OMP_CLAUSE_NOWAIT:\n \t  if (copyprivate_seen)\n \t    {\n@@ -8365,6 +8411,19 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t}\n \n+      if (detach_seen\n+\t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t  && OMP_CLAUSE_DECL (c) == t)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"the event handle of a %<detach%> clause \"\n+\t\t    \"should not be in a data-sharing clause\");\n+\t  remove = true;\n+\t}\n+\n       /* We're interested in the base element, not arrays.  */\n       inner_type = type = TREE_TYPE (t);\n       if ((need_complete_type"}, {"sha": "059d8421bb59d97b0457a608b14488f9a7bdfc05", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -1727,6 +1727,12 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       show_expr (omp_clauses->priority);\n       fputc (')', dumpfile);\n     }\n+  if (omp_clauses->detach)\n+    {\n+      fputs (\" DETACH(\", dumpfile);\n+      show_expr (omp_clauses->detach);\n+      fputc (')', dumpfile);\n+    }\n   for (i = 0; i < OMP_IF_LAST; i++)\n     if (omp_clauses->if_exprs[i])\n       {"}, {"sha": "63ee7b9cd50d989dc52fa374cf40f2c190362aee", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -5597,6 +5597,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->hint);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->num_tasks);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->priority);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->detach);\n \t\t  for (idx = 0; idx < OMP_IF_LAST; idx++)\n \t\t    WALK_SUBEXPR (co->ext.omp_clauses->if_exprs[idx]);\n \t\t  for (idx = 0;"}, {"sha": "7935aca23db25b0f2d75f14c2f7ffe50bcade903", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -1416,6 +1416,7 @@ typedef struct gfc_omp_clauses\n   struct gfc_expr *hint;\n   struct gfc_expr *num_tasks;\n   struct gfc_expr *priority;\n+  struct gfc_expr *detach;\n   struct gfc_expr *if_exprs[OMP_IF_LAST];\n   enum gfc_omp_sched_kind dist_sched_kind;\n   struct gfc_expr *dist_chunk_size;\n@@ -3104,6 +3105,7 @@ extern int gfc_default_character_kind;\n extern int gfc_default_logical_kind;\n extern int gfc_default_complex_kind;\n extern int gfc_c_int_kind;\n+extern int gfc_c_intptr_kind;\n extern int gfc_atomic_int_kind;\n extern int gfc_atomic_logical_kind;\n extern int gfc_intio_kind;"}, {"sha": "a9ecd96cb357eeec24e8d706432bbab2baf2edb4", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -91,6 +91,7 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr (c->hint);\n   gfc_free_expr (c->num_tasks);\n   gfc_free_expr (c->priority);\n+  gfc_free_expr (c->detach);\n   for (i = 0; i < OMP_IF_LAST; i++)\n     gfc_free_expr (c->if_exprs[i]);\n   gfc_free_expr (c->async_expr);\n@@ -448,6 +449,39 @@ gfc_match_omp_to_link (const char *str, gfc_omp_namelist **list)\n   return MATCH_ERROR;\n }\n \n+/* Match detach(event-handle).  */\n+\n+static match\n+gfc_match_omp_detach (gfc_expr **expr)\n+{\n+  locus old_loc = gfc_current_locus;\n+\n+  if (gfc_match (\"detach ( \") != MATCH_YES)\n+    goto syntax_error;\n+\n+  if (gfc_match_variable (expr, 0) != MATCH_YES)\n+    goto syntax_error;\n+\n+  if ((*expr)->ts.type != BT_INTEGER || (*expr)->ts.kind != gfc_c_intptr_kind)\n+    {\n+      gfc_error (\"%qs at %L should be of type \"\n+\t\t \"integer(kind=omp_event_handle_kind)\",\n+\t\t (*expr)->symtree->n.sym->name, &(*expr)->where);\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    goto syntax_error;\n+\n+  return MATCH_YES;\n+\n+syntax_error:\n+   gfc_error (\"Syntax error in OpenMP detach clause at %C\");\n+   gfc_current_locus = old_loc;\n+   return MATCH_ERROR;\n+\n+}\n+\n /* Match depend(sink : ...) construct a namelist from it.  */\n \n static match\n@@ -807,6 +841,7 @@ enum omp_mask1\n   OMP_CLAUSE_ATOMIC,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_CAPTURE,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_MEMORDER,  /* OpenMP 5.0.  */\n+  OMP_CLAUSE_DETACH,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_NOWAIT,\n   /* This must come last.  */\n   OMP_MASK1_LAST\n@@ -840,7 +875,6 @@ enum omp_mask2\n   OMP_CLAUSE_IF_PRESENT,\n   OMP_CLAUSE_FINALIZE,\n   OMP_CLAUSE_ATTACH,\n-  OMP_CLAUSE_DETACH,\n   /* This must come last.  */\n   OMP_MASK2_LAST\n };\n@@ -1378,6 +1412,12 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tgfc_current_locus = old_loc;\n \t    }\n \t  if ((mask & OMP_CLAUSE_DETACH)\n+\t      && !openacc\n+\t      && !c->detach\n+\t      && gfc_match_omp_detach (&c->detach) == MATCH_YES)\n+\t    continue;\n+\t  if ((mask & OMP_CLAUSE_DETACH)\n+\t      && openacc\n \t      && gfc_match (\"detach ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n \t\t\t\t\t   OMP_MAP_DETACH, false,\n@@ -2763,7 +2803,8 @@ gfc_match_oacc_routine (void)\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT\t\t\\\n    | OMP_CLAUSE_UNTIED | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE\t\\\n-   | OMP_CLAUSE_DEPEND | OMP_CLAUSE_PRIORITY | OMP_CLAUSE_IN_REDUCTION)\n+   | OMP_CLAUSE_DEPEND | OMP_CLAUSE_PRIORITY | OMP_CLAUSE_IN_REDUCTION\t\\\n+   | OMP_CLAUSE_DETACH)\n #define OMP_TASKLOOP_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF\t\t\\\n@@ -5061,6 +5102,10 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\tif (n->sym->attr.associate_var)\n \t\t  gfc_error (\"ASSOCIATE name %qs in SHARED clause at %L\",\n \t\t\t     n->sym->name, &n->where);\n+\t\tif (omp_clauses->detach\n+\t\t    && n->sym == omp_clauses->detach->symtree->n.sym)\n+\t\t  gfc_error (\"DETACH event handle %qs in SHARED clause at %L\",\n+\t\t\t     n->sym->name, &n->where);\n \t      }\n \t    break;\n \t  case OMP_LIST_ALIGNED:\n@@ -5387,7 +5432,13 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t    default:\n \t\t      break;\n \t\t    }\n-\n+\t\tif (omp_clauses->detach\n+\t\t    && (list == OMP_LIST_PRIVATE\n+\t\t\t|| list == OMP_LIST_FIRSTPRIVATE\n+\t\t\t|| list == OMP_LIST_LASTPRIVATE)\n+\t\t    && n->sym == omp_clauses->detach->symtree->n.sym)\n+\t\t  gfc_error (\"DETACH event handle %qs in %s clause at %L\",\n+\t\t\t     n->sym->name, name, &n->where);\n \t\tswitch (list)\n \t\t  {\n \t\t  case OMP_LIST_REDUCTION_INSCAN:\n@@ -5684,6 +5735,9 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \tgfc_error (\"%s must contain at least one MAP clause at %L\",\n \t\t   p, &code->loc);\n     }\n+  if (!openacc && omp_clauses->mergeable && omp_clauses->detach)\n+    gfc_error (\"%<DETACH%> clause at %L must not be used together with \"\n+\t       \"%<MERGEABLE%> clause\", &omp_clauses->detach->where);\n }\n \n "}, {"sha": "00358ca4d396088f7ec14dc84dabce20f0654a6d", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -3673,6 +3673,22 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->detach)\n+    {\n+      tree detach;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->detach);\n+      gfc_add_block_to_block (block, &se.pre);\n+      detach = se.expr;\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DETACH);\n+      TREE_ADDRESSABLE (detach) = 1;\n+      OMP_CLAUSE_DECL (c) = detach;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n   if (clauses->hint)\n     {\n       tree hint;"}, {"sha": "ccdc4687c3931b10554ddd210238a920b41a3115", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -114,6 +114,7 @@ int gfc_default_character_kind;\n int gfc_default_logical_kind;\n int gfc_default_complex_kind;\n int gfc_c_int_kind;\n+int gfc_c_intptr_kind;\n int gfc_atomic_int_kind;\n int gfc_atomic_logical_kind;\n \n@@ -691,6 +692,8 @@ gfc_init_kinds (void)\n   /* Choose atomic kinds to match C's int.  */\n   gfc_atomic_int_kind = gfc_c_int_kind;\n   gfc_atomic_logical_kind = gfc_c_int_kind;\n+\n+  gfc_c_intptr_kind = POINTER_SIZE / 8;\n }\n \n "}, {"sha": "8626ed0a4f8eb9499b47288eafc4bc3fc618ab71", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -235,17 +235,17 @@ DEF_FUNCTION_TYPE_8 (BT_FN_BOOL_UINT_ULLPTR_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n \t\t     BT_BOOL, BT_UINT, BT_PTR_ULONGLONG, BT_LONG, BT_ULONGLONG,\n \t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR, BT_PTR)\n \n-DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n-\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n-\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n-\t\t     BT_BOOL, BT_UINT, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_9 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR,\n \t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,\n \t\t     BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_9 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR_PTR_PTR,\n \t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG, BT_PTR, BT_PTR)\n \n+DEF_FUNCTION_TYPE_10 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT_PTR,\n+\t\t      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t      BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t      BT_BOOL, BT_UINT, BT_PTR, BT_INT, BT_PTR)\n DEF_FUNCTION_TYPE_10 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_LONG_ULL_ULLPTR_ULLPTR_PTR_PTR,\n \t\t      BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t      BT_ULONGLONG, BT_LONG, BT_ULONGLONG, BT_PTR_ULONGLONG,"}, {"sha": "d2ac5f913593f1581dacaed0f1f2a4c9632dab3b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -7220,6 +7220,15 @@ omp_default_clause (struct gimplify_omp_ctx *ctx, tree decl,\n   enum omp_clause_default_kind kind;\n \n   kind = lang_hooks.decls.omp_predetermined_sharing (decl);\n+  if (ctx->region_type & ORT_TASK)\n+    {\n+      tree detach_clause = omp_find_clause (ctx->clauses, OMP_CLAUSE_DETACH);\n+\n+      /* The event-handle specified by a detach clause should always be firstprivate,\n+\t regardless of the current default.  */\n+      if (detach_clause && OMP_CLAUSE_DECL (detach_clause) == decl)\n+\tkind = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n+    }\n   if (kind != OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n     default_kind = kind;\n   else if (VAR_P (decl) && TREE_STATIC (decl) && DECL_IN_CONSTANT_POOL (decl))\n@@ -9754,6 +9763,10 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_DETACH:\n+\t  flags = GOVD_FIRSTPRIVATE | GOVD_SEEN;\n+\t  goto do_add;\n+\n \tcase OMP_CLAUSE_IF:\n \t  if (OMP_CLAUSE_IF_MODIFIER (c) != ERROR_MARK\n \t      && OMP_CLAUSE_IF_MODIFIER (c) != code)\n@@ -10900,6 +10913,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_ORDER:\n \tcase OMP_CLAUSE_BIND:\n+\tcase OMP_CLAUSE_DETACH:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:"}, {"sha": "cfbf1e67b8e5f807e818e3aa9151da3a2be7dcb6", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -381,7 +381,7 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_REDUCTIONS,\n \t\t  \"GOMP_parallel_reductions\",\n \t\t  BT_FN_UINT_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK, \"GOMP_task\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,\n+\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT_PTR,\n \t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKLOOP, \"GOMP_taskloop\",\n \t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_UINT_LONG_INT_LONG_LONG_LONG,"}, {"sha": "7559ec8026311e001f068e25cf26f03a9027c9b4", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -762,6 +762,7 @@ expand_task_call (struct omp_region *region, basic_block bb,\n   tree depend = omp_find_clause (clauses, OMP_CLAUSE_DEPEND);\n   tree finalc = omp_find_clause (clauses, OMP_CLAUSE_FINAL);\n   tree priority = omp_find_clause (clauses, OMP_CLAUSE_PRIORITY);\n+  tree detach = omp_find_clause (clauses, OMP_CLAUSE_DETACH);\n \n   unsigned int iflags\n     = (untied ? GOMP_TASK_FLAG_UNTIED : 0)\n@@ -811,8 +812,13 @@ expand_task_call (struct omp_region *region, basic_block bb,\n       if (omp_find_clause (clauses, OMP_CLAUSE_REDUCTION))\n \tiflags |= GOMP_TASK_FLAG_REDUCTION;\n     }\n-  else if (priority)\n-    iflags |= GOMP_TASK_FLAG_PRIORITY;\n+  else\n+    {\n+      if (priority)\n+\tiflags |= GOMP_TASK_FLAG_PRIORITY;\n+      if (detach)\n+\tiflags |= GOMP_TASK_FLAG_DETACH;\n+    }\n \n   tree flags = build_int_cst (unsigned_type_node, iflags);\n \n@@ -853,6 +859,11 @@ expand_task_call (struct omp_region *region, basic_block bb,\n     priority = integer_zero_node;\n \n   gsi = gsi_last_nondebug_bb (bb);\n+\n+  detach = (detach\n+\t    ? build_fold_addr_expr (OMP_CLAUSE_DECL (detach))\n+\t    : null_pointer_node);\n+\n   tree t = gimple_omp_task_data_arg (entry_stmt);\n   if (t == NULL)\n     t2 = null_pointer_node;\n@@ -875,10 +886,10 @@ expand_task_call (struct omp_region *region, basic_block bb,\n \t\t\t num_tasks, priority, startvar, endvar, step);\n   else\n     t = build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_TASK),\n-\t\t\t 9, t1, t2, t3,\n+\t\t\t 10, t1, t2, t3,\n \t\t\t gimple_omp_task_arg_size (entry_stmt),\n \t\t\t gimple_omp_task_arg_align (entry_stmt), cond, flags,\n-\t\t\t depend, priority);\n+\t\t\t depend, priority, detach);\n \n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);"}, {"sha": "c1267dcce2eaecfadb25c73a2441a325e88c34c8", "filename": "gcc/omp-low.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -1412,6 +1412,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\tcase OMP_CLAUSE_DETACH:\n \t  if (ctx->outer)\n \t    scan_omp_op (&OMP_CLAUSE_OPERAND (c, 0), ctx->outer);\n \t  break;\n@@ -1779,6 +1780,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_SIMDLEN:\n \tcase OMP_CLAUSE_ALIGNED:\n \tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_DETACH:\n \tcase OMP_CLAUSE_ALLOCATE:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n@@ -2350,6 +2352,9 @@ finish_taskreg_scan (omp_context *ctx)\n     {\n       location_t loc = gimple_location (ctx->stmt);\n       tree *p, vla_fields = NULL_TREE, *q = &vla_fields;\n+      tree detach_clause\n+\t= omp_find_clause (gimple_omp_task_clauses (ctx->stmt),\n+\t\t\t   OMP_CLAUSE_DETACH);\n       /* Move VLA fields to the end.  */\n       p = &TYPE_FIELDS (ctx->record_type);\n       while (*p)\n@@ -2416,6 +2421,48 @@ finish_taskreg_scan (omp_context *ctx)\n \t      TYPE_FIELDS (ctx->srecord_type) = f1;\n \t    }\n \t}\n+      if (detach_clause)\n+\t{\n+\t  tree c, field;\n+\n+\t  /* Look for a firstprivate clause with the detach event handle.  */\n+\t  for (c = gimple_omp_taskreg_clauses (ctx->stmt);\n+\t       c; c = OMP_CLAUSE_CHAIN (c))\n+\t    {\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)\n+\t\tcontinue;\n+\t      if (maybe_lookup_decl_in_outer_ctx (OMP_CLAUSE_DECL (c), ctx)\n+\t\t  == OMP_CLAUSE_DECL (detach_clause))\n+\t\tbreak;\n+\t    }\n+\n+\t  gcc_assert (c);\n+\t  field = lookup_field (OMP_CLAUSE_DECL (c), ctx);\n+\n+\t  /* Move field corresponding to the detach clause first.\n+\t     This is filled by GOMP_task and needs to be in a\n+\t     specific position.  */\n+\t  p = &TYPE_FIELDS (ctx->record_type);\n+\t  while (*p)\n+\t    if (*p == field)\n+\t      *p = DECL_CHAIN (*p);\n+\t    else\n+\t      p = &DECL_CHAIN (*p);\n+\t  DECL_CHAIN (field) = TYPE_FIELDS (ctx->record_type);\n+\t  TYPE_FIELDS (ctx->record_type) = field;\n+\t  if (ctx->srecord_type)\n+\t    {\n+\t      field = lookup_sfield (OMP_CLAUSE_DECL (detach_clause), ctx);\n+\t      p = &TYPE_FIELDS (ctx->srecord_type);\n+\t      while (*p)\n+\t\tif (*p == field)\n+\t\t  *p = DECL_CHAIN (*p);\n+\t\telse\n+\t\t  p = &DECL_CHAIN (*p);\n+\t      DECL_CHAIN (field) = TYPE_FIELDS (ctx->srecord_type);\n+\t      TYPE_FIELDS (ctx->srecord_type) = field;\n+\t    }\n+\t}\n       layout_type (ctx->record_type);\n       fixup_child_record_type (ctx);\n       if (ctx->srecord_type)"}, {"sha": "4558bc1f89cbb34c8c3fd8e18dcfcd2952862a3d", "filename": "gcc/testsuite/c-c++-common/gomp/task-detach-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftask-detach-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftask-detach-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftask-detach-1.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+typedef enum omp_event_handle_t\n+{\n+  __omp_event_handle_t_max__ = __UINTPTR_MAX__\n+} omp_event_handle_t;\n+\n+extern void omp_fulfill_event (omp_event_handle_t);\n+\n+void f (omp_event_handle_t x, omp_event_handle_t y, int z)\n+{\n+  #pragma omp task detach (x) detach (y) /* { dg-error \"too many 'detach' clauses on a task construct\" } */\n+    ;\n+\n+  #pragma omp task mergeable detach (x) /* { dg-error \"'detach' clause must not be used together with 'mergeable' clause\" } */\n+    ;\n+\n+  #pragma omp task detach (x) mergeable /* { dg-error \"'detach' clause must not be used together with 'mergeable' clause\" } */\n+    ;\n+\n+  #pragma omp task detach (z) /* { dg-error \"'detach' clause event handle has type 'int' rather than 'omp_event_handle_t'\" } */\n+    ;\n+\n+  #pragma omp parallel master default (none) /* { dg-message \"enclosing 'parallel'\" } */\n+    #pragma omp task detach (x) /* { dg-error \"'x' not specified in enclosing 'parallel'\" } */\n+      ;\n+\n+  #pragma omp task detach (x) default (none) /* This should work.  */\n+    omp_fulfill_event (x);\n+\n+  #pragma omp task detach (x) firstprivate (x) /* { dg-error \"the event handle of a 'detach' clause should not be in a data-sharing clause\" } */\n+    ;\n+\n+  #pragma omp task detach (x) shared (x) /* { dg-error \"the event handle of a 'detach' clause should not be in a data-sharing clause\" } */\n+    ;\n+}"}, {"sha": "6028cb418c7472e19e4d9bdd923362f5e48d2c5c", "filename": "gcc/testsuite/g++.dg/gomp/task-detach-1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-detach-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-detach-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-detach-1.C?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+typedef enum omp_event_handle_t\n+{\n+  __omp_event_handle_t_max__ = __UINTPTR_MAX__\n+} omp_event_handle_t;\n+\n+template <typename T>\n+void foo ()\n+{\n+  T t;\n+  #pragma omp task detach (t)\n+    ;\n+}\n+\n+template <typename T>\n+void bar ()\n+{\n+  T t;\n+  #pragma omp task detach (t) // { dg-error \"'detach' clause event handle has type 'int' rather than 'omp_event_handle_t'\" }\n+    ;\n+}\n+\n+void f()\n+{\n+  foo <omp_event_handle_t> ();\n+  bar <int> (); // { dg-message \"required from here\" }\n+}"}, {"sha": "611044d8d971eef48526c70b9f6f69a3b945aea9", "filename": "gcc/testsuite/gcc.dg/gomp/task-detach-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftask-detach-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftask-detach-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftask-detach-1.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+typedef enum omp_event_handle_t\n+{\n+  __omp_event_handle_t_max__ = __UINTPTR_MAX__\n+} omp_event_handle_t;\n+\n+extern void omp_fulfill_event (omp_event_handle_t);\n+\n+void f (omp_event_handle_t x)\n+{\n+  void g (void)\n+  {\n+    #pragma omp task detach (x)\n+      omp_fulfill_event (x);\n+  }\n+\n+  g ();\n+}"}, {"sha": "4763f13ba8409b9b665efa4b6146280f37d239ce", "filename": "gcc/testsuite/gfortran.dg/gomp/task-detach-1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftask-detach-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftask-detach-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftask-detach-1.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+program task_detach_1\n+  use iso_c_binding, only: c_intptr_t\n+  implicit none\n+  \n+  integer, parameter :: omp_event_handle_kind = c_intptr_t\n+  integer (kind=omp_event_handle_kind) :: x, y\n+  integer :: z\n+  \n+  !$omp task detach(x) detach(y) ! { dg-error \"Failed to match clause at \\\\\\(1\\\\\\)\" }\n+  !$omp end task ! { dg-error \"Unexpected !\\\\\\$OMP END TASK statement at \\\\\\(1\\\\\\)\" }\n+\n+  !$omp task mergeable detach(x) ! { dg-error \"'DETACH' clause at \\\\\\(1\\\\\\) must not be used together with 'MERGEABLE' clause\" }\n+  !$omp end task\n+\n+  !$omp task detach(x) mergeable ! { dg-error \"'DETACH' clause at \\\\\\(1\\\\\\) must not be used together with 'MERGEABLE' clause\" }\n+  !$omp end task\n+\n+  !$omp task detach(z) ! { dg-error \"'z' at \\\\\\(1\\\\\\) should be of type integer\\\\\\(kind=omp_event_handle_kind\\\\\\)\" }\n+  !$omp end task ! { dg-error \"Unexpected !\\\\\\$OMP END TASK statement at \\\\\\(1\\\\\\)\" }\n+  \n+  !$omp task detach (x) firstprivate (x) ! { dg-error \"DETACH event handle 'x' in FIRSTPRIVATE clause at \\\\\\(1\\\\\\)\" }\n+  !$omp end task\n+\n+  !$omp task detach (x) shared (x) ! { dg-error \"DETACH event handle 'x' in SHARED clause at \\\\\\(1\\\\\\)\" }\n+  !$omp end task\n+end program"}, {"sha": "d2e6c895e42f971628656c7b9bbdb00ebd537a58", "filename": "gcc/tree-core.h", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -299,19 +299,8 @@ enum omp_clause_code {\n   /* OpenMP clause: link (variable-list).  */\n   OMP_CLAUSE_LINK,\n \n-  /* OpenMP clause: from (variable-list).  */\n-  OMP_CLAUSE_FROM,\n-\n-  /* OpenMP clause: to (variable-list).  */\n-  OMP_CLAUSE_TO,\n-\n-  /* OpenACC clauses: {copy, copyin, copyout, create, delete, deviceptr,\n-     device, host (self), present, present_or_copy (pcopy), present_or_copyin\n-     (pcopyin), present_or_copyout (pcopyout), present_or_create (pcreate)}\n-     (variable-list).\n-\n-     OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n-  OMP_CLAUSE_MAP,\n+  /* OpenMP clause: detach (event-handle).  */\n+  OMP_CLAUSE_DETACH,\n \n   /* OpenACC clause: use_device (variable-list).\n      OpenMP clause: use_device_ptr (ptr-list).  */\n@@ -329,6 +318,20 @@ enum omp_clause_code {\n   /* OpenMP clause: exclusive (variable-list).  */\n   OMP_CLAUSE_EXCLUSIVE,\n \n+  /* OpenMP clause: from (variable-list).  */\n+  OMP_CLAUSE_FROM,\n+\n+  /* OpenMP clause: to (variable-list).  */\n+  OMP_CLAUSE_TO,\n+\n+  /* OpenACC clauses: {copy, copyin, copyout, create, delete, deviceptr,\n+     device, host (self), present, present_or_copy (pcopy), present_or_copyin\n+     (pcopyin), present_or_copyout (pcopyout), present_or_create (pcreate)}\n+     (variable-list).\n+\n+     OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n+  OMP_CLAUSE_MAP,\n+\n   /* Internal structure to hold OpenACC cache directive's variable-list.\n      #pragma acc cache (variable-list).  */\n   OMP_CLAUSE__CACHE_,"}, {"sha": "1b52669b622aa3256be932f1053f6834012a924f", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -1339,6 +1339,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\tcase OMP_CLAUSE_DETACH:\n \tdo_decl_clause:\n \t  if (pdecl == NULL)\n \t    pdecl = &OMP_CLAUSE_DECL (clause);\n@@ -2108,6 +2109,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n+\tcase OMP_CLAUSE_DETACH:\n \tdo_decl_clause:\n \t  if (pdecl == NULL)\n \t    pdecl = &OMP_CLAUSE_DECL (clause);"}, {"sha": "aabe6bb23b9c407a666bec1df3f8cf94aebcacb1", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -1265,6 +1265,12 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n     case OMP_CLAUSE_FINALIZE:\n       pp_string (pp, \"finalize\");\n       break;\n+    case OMP_CLAUSE_DETACH:\n+      pp_string (pp, \"detach(\");\n+      dump_generic_node (pp, OMP_CLAUSE_DECL (clause), spc, flags,\n+\t\t\t false);\n+      pp_right_paren (pp);\n+      break;\n \n     default:\n       gcc_unreachable ();"}, {"sha": "a25c71f11526530677895c341792f515c017a25b", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -297,14 +297,15 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_UNIFORM  */\n   1, /* OMP_CLAUSE_TO_DECLARE  */\n   1, /* OMP_CLAUSE_LINK  */\n-  2, /* OMP_CLAUSE_FROM  */\n-  2, /* OMP_CLAUSE_TO  */\n-  2, /* OMP_CLAUSE_MAP  */\n+  1, /* OMP_CLAUSE_DETACH  */\n   1, /* OMP_CLAUSE_USE_DEVICE_PTR  */\n   1, /* OMP_CLAUSE_USE_DEVICE_ADDR  */\n   1, /* OMP_CLAUSE_IS_DEVICE_PTR  */\n   1, /* OMP_CLAUSE_INCLUSIVE  */\n   1, /* OMP_CLAUSE_EXCLUSIVE  */\n+  2, /* OMP_CLAUSE_FROM  */\n+  2, /* OMP_CLAUSE_TO  */\n+  2, /* OMP_CLAUSE_MAP  */\n   2, /* OMP_CLAUSE__CACHE_  */\n   2, /* OMP_CLAUSE_GANG  */\n   1, /* OMP_CLAUSE_ASYNC  */\n@@ -382,14 +383,15 @@ const char * const omp_clause_code_name[] =\n   \"uniform\",\n   \"to\",\n   \"link\",\n-  \"from\",\n-  \"to\",\n-  \"map\",\n+  \"detach\",\n   \"use_device_ptr\",\n   \"use_device_addr\",\n   \"is_device_ptr\",\n   \"inclusive\",\n   \"exclusive\",\n+  \"from\",\n+  \"to\",\n+  \"map\",\n   \"_cache_\",\n   \"gang\",\n   \"async\",\n@@ -12240,6 +12242,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE_TO_DECLARE:\n \tcase OMP_CLAUSE_LINK:\n+\tcase OMP_CLAUSE_DETACH:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:"}, {"sha": "6e163b025609307aa466f2af97cf31a7afbf553b", "filename": "include/gomp-constants.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -221,6 +221,7 @@ enum gomp_map_kind\n #define GOMP_TASK_FLAG_IF\t\t(1 << 10)\n #define GOMP_TASK_FLAG_NOGROUP\t\t(1 << 11)\n #define GOMP_TASK_FLAG_REDUCTION\t(1 << 12)\n+#define GOMP_TASK_FLAG_DETACH\t\t(1 << 13)\n \n /* GOMP_target{_ext,update_ext,enter_exit_data} flags argument.  */\n #define GOMP_TARGET_FLAG_NOWAIT\t\t(1 << 0)"}, {"sha": "4ec39c4e61b08d9c78b4acd3e1122f5230e8c8ac", "filename": "libgomp/fortran.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -604,6 +604,12 @@ omp_get_max_task_priority_ (void)\n   return omp_get_max_task_priority ();\n }\n \n+void\n+omp_fulfill_event_ (intptr_t event)\n+{\n+  omp_fulfill_event ((omp_event_handle_t) event);\n+}\n+\n void\n omp_set_affinity_format_ (const char *format, size_t format_len)\n {"}, {"sha": "b4d0c93dd20625b543fd6fdd3c07ffa2832470b5", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -545,6 +545,9 @@ struct gomp_task\n      entries and the gomp_task in which they reside.  */\n   struct priority_node pnode[3];\n \n+  bool detach;\n+  gomp_sem_t completion_sem;\n+\n   struct gomp_task_icv icv;\n   void (*fn) (void *);\n   void *fn_data;\n@@ -685,6 +688,10 @@ struct gomp_team\n   int work_share_cancelled;\n   int team_cancelled;\n \n+  /* Tasks waiting for their completion event to be fulfilled.  */\n+  struct priority_queue task_detach_queue;\n+  unsigned int task_detach_count;\n+\n   /* This array contains structures for implicit tasks.  */\n   struct gomp_task implicit_task[];\n };"}, {"sha": "4ad190a52af099e55f71ac639e03098b607a076b", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -195,6 +195,8 @@ OMP_5.0.1 {\n \tomp_free;\n \tomp_get_supported_active_levels;\n \tomp_get_supported_active_levels_;\n+\tomp_fulfill_event;\n+\tomp_fulfill_event_;\n } OMP_5.0;\n \n GOMP_1.0 {"}, {"sha": "3cbe0a4ca89ef2b8118b7e9af551ce54e56d2dab", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -294,7 +294,7 @@ extern bool GOMP_cancellation_point (int);\n /* task.c */\n \n extern void GOMP_task (void (*) (void *), void *, void (*) (void *, void *),\n-\t\t       long, long, bool, unsigned, void **, int);\n+\t\t       long, long, bool, unsigned, void **, int, void *);\n extern void GOMP_taskloop (void (*) (void *), void *,\n \t\t\t   void (*) (void *, void *), long, long, unsigned,\n \t\t\t   unsigned long, int, long, long, long);"}, {"sha": "69f96f091245a9055085ea17b81edd3decf4f980", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -171,6 +171,11 @@ typedef struct omp_alloctrait_t\n   omp_uintptr_t value;\n } omp_alloctrait_t;\n \n+typedef enum omp_event_handle_t __GOMP_UINTPTR_T_ENUM\n+{\n+  __omp_event_handle_t_max__ = __UINTPTR_MAX__\n+} omp_event_handle_t;\n+\n #ifdef __cplusplus\n extern \"C\" {\n # define __GOMP_NOTHROW throw ()\n@@ -245,6 +250,8 @@ extern int omp_is_initial_device (void) __GOMP_NOTHROW;\n extern int omp_get_initial_device (void) __GOMP_NOTHROW;\n extern int omp_get_max_task_priority (void) __GOMP_NOTHROW;\n \n+extern void omp_fulfill_event (omp_event_handle_t) __GOMP_NOTHROW;\n+\n extern void *omp_target_alloc (__SIZE_TYPE__, int) __GOMP_NOTHROW;\n extern void omp_target_free (void *, int) __GOMP_NOTHROW;\n extern int omp_target_is_present (const void *, int) __GOMP_NOTHROW;"}, {"sha": "851f85f531623156d21153cb124214f75b1a54a5", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -39,6 +39,7 @@\n         integer, parameter :: omp_alloctrait_val_kind = c_intptr_t\n         integer, parameter :: omp_memspace_handle_kind = c_intptr_t\n         integer, parameter :: omp_depend_kind = @OMP_DEPEND_KIND@\n+        integer, parameter :: omp_event_handle_kind = c_intptr_t\n         integer (omp_sched_kind), parameter :: omp_sched_static = 1\n         integer (omp_sched_kind), parameter :: omp_sched_dynamic = 2\n         integer (omp_sched_kind), parameter :: omp_sched_guided = 3\n@@ -555,6 +556,14 @@\n           end function omp_get_max_task_priority\n         end interface\n \n+        interface\n+          subroutine omp_fulfill_event (event)\n+            use omp_lib_kinds\n+            integer (kind=omp_event_handle_kind), &\n+              value, intent(in) :: event\n+          end subroutine omp_fulfill_event\n+        end interface\n+\n         interface\n           subroutine omp_set_affinity_format (format)\n             character(len=*), intent(in) :: format"}, {"sha": "06d17b5fcdc0d396a82d3bf459edcd1549da368c", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -82,10 +82,12 @@\n \n       integer omp_allocator_handle_kind, omp_alloctrait_key_kind\n       integer omp_alloctrait_val_kind, omp_memspace_handle_kind\n+      integer omp_event_handle_kind\n       parameter (omp_allocator_handle_kind = @INTPTR_T_KIND@)\n       parameter (omp_alloctrait_key_kind = 4)\n       parameter (omp_alloctrait_val_kind = @INTPTR_T_KIND@)\n       parameter (omp_memspace_handle_kind = @INTPTR_T_KIND@)\n+      parameter (omp_event_handle_kind = @INTPTR_T_KIND@)\n       integer (omp_alloctrait_key_kind) omp_atk_sync_hint\n       integer (omp_alloctrait_key_kind) omp_atk_alignment\n       integer (omp_alloctrait_key_kind) omp_atk_access\n@@ -245,6 +247,8 @@\n       external omp_get_max_task_priority\n       integer(4) omp_get_max_task_priority\n \n+      external omp_fulfill_event\n+\n       external omp_set_affinity_format, omp_get_affinity_format\n       external omp_display_affinity, omp_capture_affinity\n       integer(4) omp_get_affinity_format"}, {"sha": "39b69f4f31c7bfd5bd476fc09fe3437cad31a356", "filename": "libgomp/priority_queue.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fpriority_queue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fpriority_queue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fpriority_queue.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -168,6 +168,63 @@ priority_queue_verify (enum priority_queue_type type,\n }\n #endif /* _LIBGOMP_CHECKING_ */\n \n+/* Tree version of priority_queue_find.  */\n+\n+static struct gomp_task *\n+priority_tree_find (enum priority_queue_type type,\n+\t\t    prio_splay_tree_node node,\n+\t\t    priority_queue_predicate pred)\n+{\n+ again:\n+  if (!node)\n+    return NULL;\n+  struct gomp_task *task = priority_tree_find (type, node->right, pred);\n+  if (task)\n+    return task;\n+  task = priority_node_to_task (type, node->key.l.tasks);\n+  if (pred (task))\n+    return task;\n+  node = node->left;\n+  goto again;\n+}\n+\n+/* List version of priority_queue_find.  */\n+\n+static struct gomp_task *\n+priority_list_find (enum priority_queue_type type,\n+\t\t     struct priority_list *list,\n+\t\t     priority_queue_predicate pred)\n+{\n+  struct priority_node *node = list->tasks;\n+  if (!node)\n+    return NULL;\n+\n+  do\n+    {\n+      struct gomp_task *task = priority_node_to_task (type, node);\n+      if (pred (task))\n+\treturn task;\n+      node = node->next;\n+    }\n+  while (node != list->tasks);\n+\n+  return NULL;\n+}\n+\n+/* Return the highest priority task in the priority queue HEAD that\n+   satisfies the predicate PRED.  HEAD contains tasks of type TYPE.  */\n+\n+struct gomp_task *\n+priority_queue_find (enum priority_queue_type type,\n+\t\t     struct priority_queue *head,\n+\t\t     priority_queue_predicate pred)\n+{\n+  if (priority_queue_multi_p (head))\n+    return priority_tree_find (type, head->t.root, pred);\n+  else\n+    return priority_list_find (type, &head->l, pred);\n+}\n+\n /* Remove NODE from priority queue HEAD, wherever it may be inside the\n    tree.  HEAD contains tasks of type TYPE.  */\n "}, {"sha": "d8d31b7cc0501a225515a35c305d3d6859062fdc", "filename": "libgomp/priority_queue.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fpriority_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fpriority_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fpriority_queue.h?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -113,6 +113,8 @@ enum priority_queue_type\n   PQ_IGNORED = 999\n };\n \n+typedef bool (*priority_queue_predicate) (struct gomp_task *);\n+\n /* Priority queue implementation prototypes.  */\n \n extern bool priority_queue_task_in_queue_p (enum priority_queue_type,\n@@ -122,6 +124,9 @@ extern void priority_queue_dump (enum priority_queue_type,\n \t\t\t\t struct priority_queue *);\n extern void priority_queue_verify (enum priority_queue_type,\n \t\t\t\t   struct priority_queue *, bool);\n+extern struct gomp_task *priority_queue_find (enum priority_queue_type,\n+\t\t\t\t\t      struct priority_queue *,\n+\t\t\t\t\t      priority_queue_predicate);\n extern void priority_tree_remove (enum priority_queue_type,\n \t\t\t\t  struct priority_queue *,\n \t\t\t\t  struct priority_node *);"}, {"sha": "5ece87844ab6cbfd930405ce0daa7cbc68ddfcfd", "filename": "libgomp/task.c", "status": "modified", "additions": 111, "deletions": 21, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -86,6 +86,7 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n   task->dependers = NULL;\n   task->depend_hash = NULL;\n   task->depend_count = 0;\n+  task->detach = false;\n }\n \n /* Clean up a task, after completing it.  */\n@@ -326,6 +327,12 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n     }\n }\n \n+static bool\n+task_fulfilled_p (struct gomp_task *task)\n+{\n+  return __atomic_load_n (&task->completion_sem, __ATOMIC_RELAXED);\n+}\n+\n /* Called when encountering an explicit task directive.  If IF_CLAUSE is\n    false, then we must not delay in executing the task.  If UNTIED is true,\n    then the task may be executed by any member of the team.\n@@ -347,7 +354,7 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n void\n GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t   long arg_size, long arg_align, bool if_clause, unsigned flags,\n-\t   void **depend, int priority)\n+\t   void **depend, int priority, void *detach)\n {\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_team *team = thr->ts.team;\n@@ -383,6 +390,9 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n   else if (priority > gomp_max_task_priority_var)\n     priority = gomp_max_task_priority_var;\n \n+  if ((flags & GOMP_TASK_FLAG_DETACH) == 0)\n+    detach = NULL;\n+\n   if (!if_clause || team == NULL\n       || (thr->task && thr->task->final_task)\n       || team->task_count > 64 * team->nthreads)\n@@ -404,6 +414,18 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       task.final_task = (thr->task && thr->task->final_task)\n \t\t\t|| (flags & GOMP_TASK_FLAG_FINAL);\n       task.priority = priority;\n+\n+      if (detach)\n+\t{\n+\t  task.detach = true;\n+\t  gomp_sem_init (&task.completion_sem, 0);\n+\t  *(void **) detach = &task.completion_sem;\n+\t  if (data)\n+\t    *(void **) data = &task.completion_sem;\n+\n+\t  gomp_debug (0, \"New event: %p\\n\", &task.completion_sem);\n+\t}\n+\n       if (thr->task)\n \t{\n \t  task.in_tied_task = thr->task->in_tied_task;\n@@ -420,6 +442,10 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t}\n       else\n \tfn (data);\n+\n+      if (detach && !task_fulfilled_p (&task))\n+\tgomp_sem_wait (&task.completion_sem);\n+\n       /* Access to \"children\" is normally done inside a task_lock\n \t mutex region, but the only way this particular task.children\n \t can be set is if this thread's task work function (fn)\n@@ -458,6 +484,16 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       task->kind = GOMP_TASK_UNDEFERRED;\n       task->in_tied_task = parent->in_tied_task;\n       task->taskgroup = taskgroup;\n+      if (detach)\n+\t{\n+\t  task->detach = true;\n+\t  gomp_sem_init (&task->completion_sem, 0);\n+\t  *(void **) detach = &task->completion_sem;\n+\t  if (data)\n+\t    *(void **) data = &task->completion_sem;\n+\n+\t  gomp_debug (0, \"New event: %p\\n\", &task->completion_sem);\n+\t}\n       thr->task = task;\n       if (cpyfn)\n \t{\n@@ -1325,6 +1361,28 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n   while (1)\n     {\n       bool cancelled = false;\n+\n+      /* Look for a queued detached task with a fulfilled completion event\n+\t that is ready to finish.  */\n+      child_task = priority_queue_find (PQ_TEAM, &team->task_detach_queue,\n+\t\t\t\t\ttask_fulfilled_p);\n+      if (child_task)\n+\t{\n+\t  priority_queue_remove (PQ_TEAM, &team->task_detach_queue,\n+\t\t\t\t child_task, MEMMODEL_RELAXED);\n+\t  --team->task_detach_count;\n+\t  gomp_debug (0, \"thread %d: found task with fulfilled event %p\\n\",\n+\t\t      thr->ts.team_id, &child_task->completion_sem);\n+\n+\tif (to_free)\n+\t  {\n+\t    gomp_finish_task (to_free);\n+\t    free (to_free);\n+\t    to_free = NULL;\n+\t  }\n+\t  goto finish_cancelled;\n+\t}\n+\n       if (!priority_queue_empty_p (&team->task_queue, MEMMODEL_RELAXED))\n \t{\n \t  bool ignored;\n@@ -1392,29 +1450,43 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n-\t finish_cancelled:;\n-\t  size_t new_tasks\n-\t    = gomp_task_run_post_handle_depend (child_task, team);\n-\t  gomp_task_run_post_remove_parent (child_task);\n-\t  gomp_clear_parent (&child_task->children_queue);\n-\t  gomp_task_run_post_remove_taskgroup (child_task);\n-\t  to_free = child_task;\n-\t  child_task = NULL;\n-\t  if (!cancelled)\n-\t    team->task_running_count--;\n-\t  if (new_tasks > 1)\n+\t  if (child_task->detach && !task_fulfilled_p (child_task))\n \t    {\n-\t      do_wake = team->nthreads - team->task_running_count;\n-\t      if (do_wake > new_tasks)\n-\t\tdo_wake = new_tasks;\n+\t      priority_queue_insert (PQ_TEAM, &team->task_detach_queue,\n+\t\t\t\t     child_task, child_task->priority,\n+\t\t\t\t     PRIORITY_INSERT_END,\n+\t\t\t\t     false, false);\n+\t      ++team->task_detach_count;\n+\t      gomp_debug (0, \"thread %d: queueing task with event %p\\n\",\n+\t\t\t  thr->ts.team_id, &child_task->completion_sem);\n+\t      child_task = NULL;\n \t    }\n-\t  if (--team->task_count == 0\n-\t      && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n+\t  else\n \t    {\n-\t      gomp_team_barrier_done (&team->barrier, state);\n-\t      gomp_mutex_unlock (&team->task_lock);\n-\t      gomp_team_barrier_wake (&team->barrier, 0);\n-\t      gomp_mutex_lock (&team->task_lock);\n+\t     finish_cancelled:;\n+\t      size_t new_tasks\n+\t\t= gomp_task_run_post_handle_depend (child_task, team);\n+\t      gomp_task_run_post_remove_parent (child_task);\n+\t      gomp_clear_parent (&child_task->children_queue);\n+\t      gomp_task_run_post_remove_taskgroup (child_task);\n+\t      to_free = child_task;\n+\t      child_task = NULL;\n+\t      if (!cancelled)\n+\t\tteam->task_running_count--;\n+\t      if (new_tasks > 1)\n+\t\t{\n+\t\t  do_wake = team->nthreads - team->task_running_count;\n+\t\t  if (do_wake > new_tasks)\n+\t\t    do_wake = new_tasks;\n+\t\t}\n+\t      if (--team->task_count == 0\n+\t\t  && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n+\t\t{\n+\t\t  gomp_team_barrier_done (&team->barrier, state);\n+\t\t  gomp_mutex_unlock (&team->task_lock);\n+\t\t  gomp_team_barrier_wake (&team->barrier, 0);\n+\t\t  gomp_mutex_lock (&team->task_lock);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -2326,3 +2398,21 @@ omp_in_final (void)\n }\n \n ialias (omp_in_final)\n+\n+void\n+omp_fulfill_event (omp_event_handle_t event)\n+{\n+  gomp_sem_t *sem = (gomp_sem_t *) event;\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr ? thr->ts.team : NULL;\n+\n+  if (__atomic_load_n (sem, __ATOMIC_RELAXED))\n+    gomp_fatal (\"omp_fulfill_event: %p event already fulfilled!\\n\", sem);\n+\n+  gomp_debug (0, \"omp_fulfill_event: %p\\n\", sem);\n+  gomp_sem_post (sem);\n+  if (team)\n+    gomp_team_barrier_wake (&team->barrier, 1);\n+}\n+\n+ialias (omp_fulfill_event)"}, {"sha": "0f3707c2f80cac664f753e678a1ad9410d040a57", "filename": "libgomp/team.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -206,6 +206,9 @@ gomp_new_team (unsigned nthreads)\n   team->work_share_cancelled = 0;\n   team->team_cancelled = 0;\n \n+  priority_queue_init (&team->task_detach_queue);\n+  team->task_detach_count = 0;\n+\n   return team;\n }\n \n@@ -221,6 +224,7 @@ free_team (struct gomp_team *team)\n   gomp_barrier_destroy (&team->barrier);\n   gomp_mutex_destroy (&team->task_lock);\n   priority_queue_free (&team->task_queue);\n+  priority_queue_free (&team->task_detach_queue);\n   team_free (team);\n }\n "}, {"sha": "8583e3761b591041360b07150cd8f1f00969aa5c", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-1.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test chaining of detached tasks, with each task fulfilling the\n+   completion event of the previous one.  */\n+\n+int main (void)\n+{\n+  omp_event_handle_t detach_event1, detach_event2;\n+  int x = 0, y = 0, z = 0;\n+\n+  #pragma omp parallel\n+    #pragma omp single\n+    {\n+      #pragma omp task detach(detach_event1)\n+\tx++;\n+\n+      #pragma omp task detach(detach_event2)\n+      {\n+\ty++;\n+\tomp_fulfill_event (detach_event1);\n+      }\n+\n+      #pragma omp task\n+      {\n+\tz++;\n+\tomp_fulfill_event (detach_event2);\n+      }\n+    }\n+\n+  assert (x == 1);\n+  assert (y == 1);\n+  assert (z == 1);\n+}"}, {"sha": "943ac2a3f85added621ddd25beb662d9ebfec3ff", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-2.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test handling of detach clause with only a single thread.  The runtime\n+   should not block when a task with an unfulfilled event finishes\n+   running.  */\n+\n+int main (void)\n+{\n+  omp_event_handle_t detach_event1, detach_event2;\n+  int x = 0, y = 0, z = 0;\n+\n+  #pragma omp parallel num_threads(1)\n+    #pragma omp single\n+    {\n+      #pragma omp task detach(detach_event1)\n+\tx++;\n+\n+      #pragma omp task detach(detach_event2)\n+      {\n+\ty++;\n+\tomp_fulfill_event (detach_event1);\n+      }\n+\n+      #pragma omp task\n+      {\n+\tz++;\n+\tomp_fulfill_event (detach_event2);\n+      }\n+    }\n+\n+  assert (x == 1);\n+  assert (y == 1);\n+  assert (z == 1);\n+}"}, {"sha": "2609fb1c43dc97d0e51f2909688c71b07220035f", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-3.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test the task detach clause used together with dependencies.  */\n+\n+int main (void)\n+{\n+  omp_event_handle_t detach_event;\n+  int x = 0, y = 0, z = 0;\n+  int dep;\n+\n+  #pragma omp parallel\n+    #pragma omp single\n+    {\n+      #pragma omp task depend(out:dep) detach(detach_event)\n+\tx++;\n+\n+      #pragma omp task\n+      {\n+\ty++;\n+\tomp_fulfill_event(detach_event);\n+      }\n+\n+      #pragma omp task depend(in:dep)\n+\tz++;\n+    }\n+\n+  assert (x == 1);\n+  assert (y == 1);\n+  assert (z == 1);\n+}"}, {"sha": "eeb9554c66518a86d6bc0b79c98ee420489455c1", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-4.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test detach clause, where a task fulfills its own completion event.  */\n+\n+int main (void)\n+{\n+  omp_event_handle_t detach_event;\n+  int x = 0;\n+\n+  detach_event = (omp_event_handle_t) 0x123456789abcdef0;\n+\n+  #pragma omp parallel\n+    #pragma omp single\n+      #pragma omp task detach(detach_event)\n+      {\n+\tx++;\n+\tomp_fulfill_event(detach_event);\n+      }\n+\n+  assert (x == 1);\n+}"}, {"sha": "5a0151729efdecf9de39f6a7813086b61a25d0e7", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-5.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-5.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test tasks with detach clause.  Each thread spawns off a chain of tasks,\n+   that can then be executed by any available thread.  */\n+\n+int main (void)\n+{\n+  int x = 0, y = 0, z = 0;\n+  int thread_count;\n+  omp_event_handle_t detach_event1, detach_event2;\n+\n+  #pragma omp parallel firstprivate(detach_event1, detach_event2)\n+  {\n+    #pragma omp single\n+      thread_count = omp_get_num_threads();\n+\n+    #pragma omp task detach(detach_event1) untied\n+      #pragma omp atomic update\n+\tx++;\n+\n+    #pragma omp task detach(detach_event2) untied\n+    {\n+      #pragma omp atomic update\n+\ty++;\n+      omp_fulfill_event (detach_event1);\n+    }\n+\n+    #pragma omp task untied\n+    {\n+      #pragma omp atomic update\n+\tz++;\n+      omp_fulfill_event (detach_event2);\n+    }\n+  }\n+\n+  assert (x == thread_count);\n+  assert (y == thread_count);\n+  assert (z == thread_count);\n+}"}, {"sha": "b5f68ccabdcc7471f02f6f57edf58d8fad795f1c", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-6.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-6.c?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test tasks with detach clause on an offload device.  Each device\n+   thread spawns off a chain of tasks, that can then be executed by\n+   any available thread.  */\n+\n+int main (void)\n+{\n+  int x = 0, y = 0, z = 0;\n+  int thread_count;\n+  omp_event_handle_t detach_event1, detach_event2;\n+\n+  #pragma omp target map(tofrom: x, y, z) map(from: thread_count)\n+    #pragma omp parallel firstprivate(detach_event1, detach_event2)\n+      {\n+\t#pragma omp single\n+\t  thread_count = omp_get_num_threads();\n+\n+\t#pragma omp task detach(detach_event1) untied\n+\t  #pragma omp atomic update\n+\t    x++;\n+\n+\t#pragma omp task detach(detach_event2) untied\n+\t{\n+\t  #pragma omp atomic update\n+\t    y++;\n+\t  omp_fulfill_event (detach_event1);\n+\t}\n+\n+\t#pragma omp task untied\n+\t{\n+\t  #pragma omp atomic update\n+\t    z++;\n+\t  omp_fulfill_event (detach_event2);\n+\t}\n+\n+\t#pragma omp taskwait\n+      }\n+\n+  assert (x == thread_count);\n+  assert (y == thread_count);\n+  assert (z == thread_count);\n+}"}, {"sha": "217bf657506bbad2383ca80f7d21170b34f956f6", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-1.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+\n+! Test chaining of detached tasks, with each task fulfilling the\n+! completion event of the previous one.\n+\n+program task_detach_1\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+\n+  !$omp parallel\n+    !$omp single\n+      !$omp task detach(detach_event1)\n+        x = x + 1\n+      !$omp end task\n+\n+      !$omp task detach(detach_event2)\n+        y = y + 1\n+\tcall omp_fulfill_event (detach_event1)\n+      !$omp end task\n+\n+      !$omp task\n+        z = z + 1\n+\tcall omp_fulfill_event (detach_event2)\n+      !$omp end task\n+    !$omp end single\n+  !$omp end parallel\n+\n+  if (x /= 1) stop 1\n+  if (y /= 1) stop 2\n+  if (z /= 1) stop 3\n+end program"}, {"sha": "ecb4829e14b29a44646ba87d5116fae471e5a579", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-2.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-2.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+\n+! Test handling of detach clause with only a single thread.  The runtime\n+! should not block when a task with an unfulfilled event finishes\n+! running.\n+\n+program task_detach_2\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+\n+  !$omp parallel num_threads(1)\n+    !$omp single\n+      !$omp task detach(detach_event1)\n+        x = x + 1\n+      !$omp end task\n+\n+      !$omp task detach(detach_event2)\n+        y = y + 1\n+\tcall omp_fulfill_event (detach_event1)\n+      !$omp end task\n+\n+      !$omp task\n+        z = z + 1\n+\tcall omp_fulfill_event (detach_event2)\n+      !$omp end task\n+    !$omp end single\n+  !$omp end parallel\n+\n+  if (x /= 1) stop 1\n+  if (y /= 1) stop 2\n+  if (z /= 1) stop 3\n+end program"}, {"sha": "bdf93a5909a99f1ef89ec9bee445246f91423a34", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-3.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-3.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+\n+! Test the task detach clause used together with dependencies.\n+\n+program task_detach_3\n+\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: dep\n+\n+  !$omp parallel\n+    !$omp single\n+      !$omp task depend(out:dep) detach(detach_event)\n+        x = x + 1\n+      !$omp end task\n+\n+      !$omp task\n+        y = y + 1\n+\tcall omp_fulfill_event(detach_event)\n+      !$omp end task\n+\n+      !$omp task depend(in:dep)\n+        z = z + 1\n+      !$omp end task\n+    !$omp end single\n+  !$omp end parallel\n+\n+  if (x /= 1) stop 1\n+  if (y /= 1) stop 2\n+  if (z /= 1) stop 3\n+end program"}, {"sha": "6d0843cb126ffa508d0f7d6a54f6b9ab7c826f4f", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-4.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-4.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+\n+! Test detach clause, where a task fulfills its own completion event.\n+\n+program task_detach_4\n+\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event\n+  integer :: x = 0\n+\n+  !$omp parallel\n+    !$omp single\n+      !$omp task detach(detach_event)\n+        x = x + 1\n+\tcall omp_fulfill_event(detach_event)\n+      !$omp end task\n+    !$omp end single\n+  !$omp end parallel\n+\n+  if (x /= 1) stop 1\n+end program"}, {"sha": "955d687ca8b53b48af8d4be87677c76ea9b25df1", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-5.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-5.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+\n+! Test tasks with detach clause.  Each thread spawns off a chain of tasks,\n+! that can then be executed by any available thread.\n+\n+program task_detach_5\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: thread_count\n+\n+  !$omp parallel firstprivate(detach_event1, detach_event2)\n+    !$omp single\n+      thread_count = omp_get_num_threads()\n+    !$omp end single\n+\n+    !$omp task detach(detach_event1) untied\n+      !$omp atomic update\n+\tx = x + 1\n+    !$omp end task\n+\n+    !$omp task detach(detach_event2) untied\n+      !$omp atomic update\n+\ty = y + 1\n+      call omp_fulfill_event (detach_event1);\n+    !$omp end task\n+\n+    !$omp task untied\n+      !$omp atomic update\n+\tz = z + 1\n+      call omp_fulfill_event (detach_event2);\n+    !$omp end task\n+  !$omp end parallel\n+\n+  if (x /= thread_count) stop 1\n+  if (y /= thread_count) stop 2\n+  if (z /= thread_count) stop 3\n+end program"}, {"sha": "0fe21553494f6877087cd5c095d810c2d3add7d9", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-6.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-6.f90?ref=a6d22fb21c6f1ad7e8b6b722bfc0e7e11f50cb92", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+\n+! Test tasks with detach clause on an offload device.  Each device\n+! thread spawns off a chain of tasks, that can then be executed by\n+! any available thread.\n+\n+program task_detach_6\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: thread_count\n+\n+  !$omp target map(tofrom: x, y, z) map(from: thread_count)\n+    !$omp parallel firstprivate(detach_event1, detach_event2)\n+      !$omp single\n+\tthread_count = omp_get_num_threads()\n+      !$omp end single\n+\n+      !$omp task detach(detach_event1) untied\n+\t!$omp atomic update\n+\t  x = x + 1\n+      !$omp end task\n+\n+      !$omp task detach(detach_event2) untied\n+\t!$omp atomic update\n+\t  y = y + 1\n+\tcall omp_fulfill_event (detach_event1);\n+      !$omp end task\n+\n+      !$omp task untied\n+\t!$omp atomic update\n+\t  z = z + 1\n+\tcall omp_fulfill_event (detach_event2);\n+      !$omp end task\n+\n+      !$omp taskwait\n+    !$omp end parallel\n+  !$omp end target\n+\n+  if (x /= thread_count) stop 1\n+  if (y /= thread_count) stop 2\n+  if (z /= thread_count) stop 3\n+end program"}]}