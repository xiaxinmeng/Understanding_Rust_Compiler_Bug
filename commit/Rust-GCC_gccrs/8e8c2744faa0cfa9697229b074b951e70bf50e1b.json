{"sha": "8e8c2744faa0cfa9697229b074b951e70bf50e1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4YzI3NDRmYWEwY2ZhOTY5NzIyOWIwNzRiOTUxZTcwYmY1MGUxYg==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-10-11T11:21:07Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-10-11T11:21:07Z"}, "message": "New flag -fdec-math for COTAN and degree trig intrinsics.\n\n2016-10-11  Fritz Reese  <fritzoreese@gmail.com>\n\nNew flag -fdec-math for COTAN and degree trig intrinsics.\n\n\tgcc/fortran/\n\t* lang.opt: New flag -fdec-math.\n\t* options.c (set_dec_flags): Enable with -fdec.\n\t* invoke.texi, gfortran.texi, intrinsic.texi: Update documentation.\n\t* intrinsics.c (add_functions, do_simplify): New intrinsics\n\twith -fdec-math.\n\t* gfortran.h (gfc_isym_id): New isym GFC_ISYM_COTAN.\n\t* gfortran.h (gfc_resolve_atan2d, gfc_resolve_cotan,\n\tgfc_resolve_trigd, gfc_resolve_atrigd): New prototypes.\n\t* iresolve.c (resolve_trig_call, get_degrees, get_radians,\n\tis_trig_resolved, gfc_resolve_cotan, gfc_resolve_trigd,\n\tgfc_resolve_atrigd, gfc_resolve_atan2d): New functions.\n\t* intrinsics.h (gfc_simplify_atan2d, gfc_simplify_atrigd,\n\tgfc_simplify_cotan, gfc_simplify_trigd): New prototypes.\n\t* simplify.c (simplify_trig_call, degrees_f, radians_f,\n\tgfc_simplify_cotan, gfc_simplify_trigd, gfc_simplify_atrigd,\n\tgfc_simplify_atan2d): New functions.\n\n\tgcc/testsuite/gfortran.dg/\n\t* dec_math.f90: New testsuite.\n\nFrom-SVN: r240989", "tree": {"sha": "d575169173ea76fc3df30eb1dd5be2ec0a60ee4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d575169173ea76fc3df30eb1dd5be2ec0a60ee4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e8c2744faa0cfa9697229b074b951e70bf50e1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8c2744faa0cfa9697229b074b951e70bf50e1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8c2744faa0cfa9697229b074b951e70bf50e1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8c2744faa0cfa9697229b074b951e70bf50e1b/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9760fbe005693d949db626b0a2cc6a6d3801b8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9760fbe005693d949db626b0a2cc6a6d3801b8ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9760fbe005693d949db626b0a2cc6a6d3801b8ba"}], "stats": {"total": 1468, "additions": 1463, "deletions": 5}, "files": [{"sha": "907a8ef41e9d3edad31f4ce12eb2ad3602458e13", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -1,3 +1,22 @@\n+2016-10-11  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\t* lang.opt: New flag -fdec-math.\n+\t* options.c (set_dec_flags): Enable with -fdec.\n+\t* invoke.texi, gfortran.texi, intrinsic.texi: Update documentation.\n+\t* intrinsics.c (add_functions, do_simplify): New intrinsics\n+\twith -fdec-math.\n+\t* gfortran.h (gfc_isym_id): New isym GFC_ISYM_COTAN.\n+\t* gfortran.h (gfc_resolve_atan2d, gfc_resolve_cotan,\n+\tgfc_resolve_trigd, gfc_resolve_atrigd): New prototypes.\n+\t* iresolve.c (resolve_trig_call, get_degrees, get_radians,\n+\tis_trig_resolved, gfc_resolve_cotan, gfc_resolve_trigd,\n+\tgfc_resolve_atrigd, gfc_resolve_atan2d): New functions.\n+\t* intrinsics.h (gfc_simplify_atan2d, gfc_simplify_atrigd,\n+\tgfc_simplify_cotan, gfc_simplify_trigd): New prototypes.\n+\t* simplify.c (simplify_trig_call, degrees_f, radians_f,\n+\tgfc_simplify_cotan, gfc_simplify_trigd, gfc_simplify_atrigd,\n+\tgfc_simplify_atan2d): New functions.\n+\n 2016-10-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/77915"}, {"sha": "33de0ffbe98cac27da1068082afc0a50e174bb52", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -390,6 +390,7 @@ enum gfc_isym_id\n   GFC_ISYM_CONVERSION,\n   GFC_ISYM_COS,\n   GFC_ISYM_COSH,\n+  GFC_ISYM_COTAN,\n   GFC_ISYM_COUNT,\n   GFC_ISYM_CPU_TIME,\n   GFC_ISYM_CSHIFT,"}, {"sha": "301c28610bbea6bffd3a7ae504cf666850bcc8d8", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -1463,6 +1463,7 @@ without warning.\n * UNION and MAP::\n * Type variants for integer intrinsics::\n * AUTOMATIC and STATIC attributes::\n+* Extended math intrinsics::\n @end menu\n \n @node Old-style kind specifications\n@@ -2472,6 +2473,42 @@ subroutine f\n endsubroutine\n @end example\n \n+@node Extended math intrinsics\n+@subsection Extended math intrinsics\n+@cindex intrinsics, math\n+@cindex intrinsics, trigonometric functions\n+\n+GNU Fortran supports an extended list of mathematical intrinsics with the\n+compile flag @option{-fdec-math} for compatability with legacy code.\n+These intrinsics are described fully in @ref{Intrinsic Procedures} where it is\n+noted that they are extensions and should be avoided whenever possible.\n+\n+Specifically, @option{-fdec-math} enables the @ref{COTAN} intrinsic, and\n+trigonometric intrinsics which accept or produce values in degrees instead of\n+radians.  Here is a summary of the new intrinsics:\n+\n+@multitable @columnfractions .5 .5\n+@headitem Radians @tab Degrees\n+@item @code{@ref{ACOS}}   @tab @code{@ref{ACOSD}}*\n+@item @code{@ref{ASIN}}   @tab @code{@ref{ASIND}}*\n+@item @code{@ref{ATAN}}   @tab @code{@ref{ATAND}}*\n+@item @code{@ref{ATAN2}}  @tab @code{@ref{ATAN2D}}*\n+@item @code{@ref{COS}}    @tab @code{@ref{COSD}}*\n+@item @code{@ref{COTAN}}* @tab @code{@ref{COTAND}}*\n+@item @code{@ref{SIN}}    @tab @code{@ref{SIND}}*\n+@item @code{@ref{TAN}}    @tab @code{@ref{TAND}}*\n+@end multitable\n+\n+* Enabled with @option{-fdec-math}.\n+\n+For advanced users, it may be important to know the implementation of these\n+functions. They are simply wrappers around the standard radian functions, which\n+have more accurate builtin versions. These functions convert their arguments\n+(or results) to degrees (or radians) by taking the value modulus 360 (or 2*pi)\n+and then multiplying it by a constant radian-to-degree (or degree-to-radian)\n+factor, as appropriate. The factor is computed at compile-time as 180/pi (or\n+pi/180).\n+\n \n @node Extensions not implemented in GNU Fortran\n @section Extensions not implemented in GNU Fortran"}, {"sha": "fdc11d8831c8e6543ae1c42f8c7576dc0d618b0f", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -3139,6 +3139,117 @@ add_functions (void)\n \t\t\n   make_generic (\"loc\", GFC_ISYM_LOC, GFC_STD_GNU);\n \n+  if (flag_dec_math)\n+    {\n+      add_sym_1 (\"acosd\", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dacosd\", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"acosd\", GFC_ISYM_ACOS, GFC_STD_GNU);\n+\n+      add_sym_1 (\"asind\", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dasind\", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"asind\", GFC_ISYM_ASIN, GFC_STD_GNU);\n+\n+      add_sym_1 (\"atand\", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"datand\", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"atand\", GFC_ISYM_ATAN, GFC_STD_GNU);\n+\n+      add_sym_2 (\"atan2d\",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_atan2, gfc_simplify_atan2d, gfc_resolve_atan2d,\n+\t\t y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_2 (\"datan2d\",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_datan2, gfc_simplify_atan2d, gfc_resolve_atan2d,\n+\t\t y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"atan2d\", GFC_ISYM_ATAN2, GFC_STD_GNU);\n+\n+      add_sym_1 (\"cosd\", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dcosd\", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"cosd\", GFC_ISYM_COS, GFC_STD_GNU);\n+\n+      add_sym_1 (\"cotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_rc2008, gfc_simplify_cotan, gfc_resolve_cotan,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dcotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_cotan, gfc_resolve_cotan,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"cotan\", GFC_ISYM_COTAN, GFC_STD_GNU);\n+\n+      add_sym_1 (\"cotand\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dcotand\",GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"cotand\", GFC_ISYM_COTAN, GFC_STD_GNU);\n+\n+      add_sym_1 (\"sind\", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dsind\", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"sind\", GFC_ISYM_SIN, GFC_STD_GNU);\n+\n+      add_sym_1 (\"tand\", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dr, GFC_STD_GNU,\n+\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dr, REQUIRED);\n+\n+      add_sym_1 (\"dtand\", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n+\t\t dd, GFC_STD_GNU,\n+\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n+\t\t x, BT_REAL, dd, REQUIRED);\n+\n+      make_generic (\"tand\", GFC_ISYM_TAN, GFC_STD_GNU);\n+    }\n+\n   /* The following function is internally used for coarray libray functions.\n      \"make_from_module\" makes it inaccessible for external users.  */\n   add_sym_1 (GFC_PREFIX (\"caf_get\"), GFC_ISYM_CAF_GET, CLASS_IMPURE, ACTUAL_NO,\n@@ -4227,6 +4338,15 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n       goto finish;\n     }\n \n+  /* Some math intrinsics need to wrap the original expression.  */\n+  if (specific->simplify.f1 == gfc_simplify_trigd\n+      || specific->simplify.f1 == gfc_simplify_atrigd\n+      || specific->simplify.f1 == gfc_simplify_cotan)\n+    {\n+      result = (*specific->simplify.f1) (e);\n+      goto finish;\n+    }\n+\n   if (specific->simplify.f1 == NULL)\n     {\n       result = NULL;"}, {"sha": "8bba6e0cb3798f98ecb4d055bcca2c0d3df1d35c", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -238,6 +238,7 @@ gfc_expr *gfc_simplify_adjustr (gfc_expr *);\n gfc_expr *gfc_simplify_aimag (gfc_expr *);\n gfc_expr *gfc_simplify_aint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_all (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_atrigd (gfc_expr *);\n gfc_expr *gfc_simplify_dint (gfc_expr *);\n gfc_expr *gfc_simplify_anint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dnint (gfc_expr *);\n@@ -248,6 +249,7 @@ gfc_expr *gfc_simplify_asinh (gfc_expr *);\n gfc_expr *gfc_simplify_atan (gfc_expr *);\n gfc_expr *gfc_simplify_atanh (gfc_expr *);\n gfc_expr *gfc_simplify_atan2 (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_atan2d (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_bessel_j0 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_j1 (gfc_expr *);\n gfc_expr *gfc_simplify_bessel_jn (gfc_expr *, gfc_expr *);\n@@ -271,6 +273,7 @@ gfc_expr *gfc_simplify_complex (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_conjg (gfc_expr *);\n gfc_expr *gfc_simplify_cos (gfc_expr *);\n gfc_expr *gfc_simplify_cosh (gfc_expr *);\n+gfc_expr *gfc_simplify_cotan (gfc_expr *);\n gfc_expr *gfc_simplify_count (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dcmplx (gfc_expr *, gfc_expr *);\n@@ -401,6 +404,7 @@ gfc_expr *gfc_simplify_tiny (gfc_expr *);\n gfc_expr *gfc_simplify_trailz (gfc_expr *);\n gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_transpose (gfc_expr *);\n+gfc_expr *gfc_simplify_trigd (gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -434,6 +438,7 @@ void gfc_resolve_asinh (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan (gfc_expr *, gfc_expr *);\n void gfc_resolve_atanh (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan2 (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_atan2d (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_atomic_def (gfc_code *);\n void gfc_resolve_atomic_ref (gfc_code *);\n void gfc_resolve_besn (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -452,6 +457,7 @@ void gfc_resolve_conjg (gfc_expr *, gfc_expr *);\n void gfc_resolve_cos (gfc_expr *, gfc_expr *);\n void gfc_resolve_cosh (gfc_expr *, gfc_expr *);\n void gfc_resolve_count (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_cotan (gfc_expr *, gfc_expr *);\n void gfc_resolve_cshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ctime (gfc_expr *, gfc_expr *);\n void gfc_resolve_dble (gfc_expr *, gfc_expr *);\n@@ -582,6 +588,8 @@ void gfc_resolve_time (gfc_expr *);\n void gfc_resolve_time8 (gfc_expr *);\n void gfc_resolve_transfer (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_transpose (gfc_expr *, gfc_expr *);\n+void gfc_resolve_trigd (gfc_expr *, gfc_expr *);\n+void gfc_resolve_atrigd (gfc_expr *, gfc_expr *);\n void gfc_resolve_trim (gfc_expr *, gfc_expr *);\n void gfc_resolve_ttynam (gfc_expr *, gfc_expr *);\n void gfc_resolve_ubound (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "16e1d5cb47b57e36d4e00344f678c3c176d02667", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 560, "deletions": 4, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -23,6 +23,9 @@ Some basic guidelines for editing this document:\n @end ignore\n \n @tex\n+\\gdef\\acosd{\\mathop{\\rm acosd}\\nolimits}\n+\\gdef\\asind{\\mathop{\\rm asind}\\nolimits}\n+\\gdef\\atand{\\mathop{\\rm atand}\\nolimits}\n \\gdef\\acos{\\mathop{\\rm acos}\\nolimits}\n \\gdef\\asin{\\mathop{\\rm asin}\\nolimits}\n \\gdef\\atan{\\mathop{\\rm atan}\\nolimits}\n@@ -43,6 +46,7 @@ Some basic guidelines for editing this document:\n * @code{ACCESS}:        ACCESS,    Checks file access modes\n * @code{ACHAR}:         ACHAR,     Character in @acronym{ASCII} collating sequence\n * @code{ACOS}:          ACOS,      Arccosine function\n+* @code{ACOSD}:         ACOSD,     Arccosine function, degrees\n * @code{ACOSH}:         ACOSH,     Inverse hyperbolic cosine function\n * @code{ADJUSTL}:       ADJUSTL,   Left adjust a string\n * @code{ADJUSTR}:       ADJUSTR,   Right adjust a string\n@@ -55,10 +59,13 @@ Some basic guidelines for editing this document:\n * @code{ANINT}:         ANINT,     Nearest whole number\n * @code{ANY}:           ANY,       Determine if any values are true\n * @code{ASIN}:          ASIN,      Arcsine function\n+* @code{ASIND}:         ASIND,     Arcsine function, degrees\n * @code{ASINH}:         ASINH,     Inverse hyperbolic sine function\n * @code{ASSOCIATED}:    ASSOCIATED, Status of a pointer or pointer/target pair\n * @code{ATAN}:          ATAN,      Arctangent function\n+* @code{ATAND}:         ATAND,     Arctangent function, degrees\n * @code{ATAN2}:         ATAN2,     Arctangent function\n+* @code{ATAN2D}:        ATAN2D,    Arctangent function, degrees\n * @code{ATANH}:         ATANH,     Inverse hyperbolic tangent function\n * @code{ATOMIC_ADD}:    ATOMIC_ADD, Atomic ADD operation\n * @code{ATOMIC_AND}:    ATOMIC_AND, Atomic bitwise AND operation\n@@ -106,7 +113,10 @@ Some basic guidelines for editing this document:\n * @code{COMPLEX}:       COMPLEX,   Complex conversion function\n * @code{CONJG}:         CONJG,     Complex conjugate function\n * @code{COS}:           COS,       Cosine function\n+* @code{COSD}:          COSD,      Cosine function, degrees\n * @code{COSH}:          COSH,      Hyperbolic cosine function\n+* @code{COTAN}:         COTAN,     Cotangent function\n+* @code{COTAND}:        COTAND,    Cotangent function, degrees\n * @code{COUNT}:         COUNT,     Count occurrences of TRUE in an array\n * @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine\n * @code{CSHIFT}:        CSHIFT,    Circular shift elements of an array\n@@ -277,6 +287,7 @@ Some basic guidelines for editing this document:\n * @code{SIGN}:          SIGN,      Sign copying function\n * @code{SIGNAL}:        SIGNAL,    Signal handling subroutine (or function)\n * @code{SIN}:           SIN,       Sine function\n+* @code{SIND}:          SIND,      Sine function, degrees\n * @code{SINH}:          SINH,      Hyperbolic sine function\n * @code{SIZE}:          SIZE,      Function to determine the size of an array\n * @code{SIZEOF}:        SIZEOF,    Determine the size in bytes of an expression\n@@ -292,6 +303,7 @@ Some basic guidelines for editing this document:\n * @code{SYSTEM}:        SYSTEM,    Execute a shell command\n * @code{SYSTEM_CLOCK}:  SYSTEM_CLOCK, Time function\n * @code{TAN}:           TAN,       Tangent function\n+* @code{TAND}:          TAND,      Tangent function, degrees\n * @code{TANH}:          TANH,      Hyperbolic tangent function\n * @code{THIS_IMAGE}:    THIS_IMAGE, Cosubscript index of this image\n * @code{TIME}:          TIME,      Time function\n@@ -619,6 +631,65 @@ end program test_acos\n \n @item @emph{See also}:\n Inverse function: @ref{COS}\n+Degrees function: @ref{ACOSD}\n+\n+@end table\n+\n+\n+\n+@node ACOSD\n+@section @code{ACOSD} --- Arccosine function, degrees\n+@fnindex ACOSD\n+@fnindex DACOSD\n+@cindex trigonometric function, cosine, inverse, degrees\n+@cindex cosine, inverse, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ACOSD(X)} computes the arccosine of @var{X} in degrees (inverse of\n+@code{COSD(X)}).\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = ACOSD(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall either be @code{REAL} with a magnitude that is\n+less than or equal to one - or the type shall be @code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of the same type and kind as @var{X}.\n+The real part of the result is in degrees and lies in the range\n+@math{0 \\leq \\Re \\acos(x) \\leq 180}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_acosd\n+  real(8) :: x = 0.866_8\n+  x = acosd(x)\n+end program test_acosd\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument         @tab Return type     @tab Standard\n+@item @code{ACOSD(X)}  @tab @code{REAL(4) X} @tab @code{REAL(4)}  @tab GNU Extension\n+@item @code{DACOSD(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}  @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Inverse function: @ref{COSD}\n+Radians function: @ref{ACOS}\n \n @end table\n \n@@ -1269,6 +1340,65 @@ end program test_asin\n \n @item @emph{See also}:\n Inverse function: @ref{SIN}\n+Degrees function: @ref{ASIND}\n+\n+@end table\n+\n+\n+\n+@node ASIND\n+@section @code{ASIND} --- Arcsine function, degrees\n+@fnindex ASIND\n+@fnindex DASIND\n+@cindex trigonometric function, sine, inverse, degrees\n+@cindex sine, inverse, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ASIND(X)} computes the arcsine of its @var{X} in degrees (inverse of\n+@code{SIND(X)}).\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = ASIND(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be either @code{REAL} and a magnitude that is\n+less than or equal to one - or be @code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of the same type and kind as @var{X}.\n+The real part of the result is in degrees and lies in the range\n+@math{-90 \\leq \\Re \\asin(x) \\leq 90}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_asind\n+  real(8) :: x = 0.866_8\n+  x = asind(x)\n+end program test_asind\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument          @tab Return type       @tab Standard\n+@item @code{ASIND(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab GNU Extension\n+@item @code{DASIND(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Inverse function: @ref{SIND}\n+Radians function: @ref{ASIN}\n \n @end table\n \n@@ -1458,6 +1588,71 @@ end program test_atan\n \n @item @emph{See also}:\n Inverse function: @ref{TAN}\n+Degrees function: @ref{ATAND}\n+\n+@end table\n+\n+\n+\n+@node ATAND\n+@section @code{ATAND} --- Arctangent function, degrees\n+@fnindex ATAND\n+@fnindex DATAND\n+@cindex trigonometric function, tangent, inverse, degrees\n+@cindex tangent, inverse, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATAND(X)} computes the arctangent of @var{X} in degrees (inverse of\n+@ref{TAND}).\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@multitable @columnfractions .80\n+@item @code{RESULT = ATAND(X)}\n+@item @code{RESULT = ATAND(Y, X)}\n+@end multitable\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be @code{REAL} or @code{COMPLEX};\n+if @var{Y} is present, @var{X} shall be REAL.\n+@item @var{Y} shall be of the same type and kind as @var{X}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of the same type and kind as @var{X}.\n+If @var{Y} is present, the result is identical to @code{ATAND2(Y,X)}.\n+Otherwise, it is the arcus tangent of @var{X}, where the real part of\n+the result is in degrees and lies in the range\n+@math{-90 \\leq \\Re \\atand(x) \\leq 90}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_atand\n+  real(8) :: x = 2.866_8\n+  x = atand(x)\n+end program test_atand\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument          @tab Return type       @tab Standard\n+@item @code{ATAND(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab GNU Extension\n+@item @code{DATAND(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Inverse function: @ref{TAND}\n+Radians function: @ref{ATAN}\n \n @end table\n \n@@ -1473,7 +1668,7 @@ Inverse function: @ref{TAN}\n @table @asis\n @item @emph{Description}:\n @code{ATAN2(Y, X)} computes the principal value of the argument\n-function of the complex number @math{X + i Y}. This function can\n+function of the complex number @math{X + i Y}.  This function can\n be used to transform from Cartesian into polar coordinates and\n allows to determine the angle in the correct quadrant.\n \n@@ -1518,6 +1713,78 @@ end program test_atan2\n @item @code{ATAN2(X, Y)}  @tab @code{REAL(4) X, Y} @tab @code{REAL(4)} @tab Fortran 77 and later\n @item @code{DATAN2(X, Y)} @tab @code{REAL(8) X, Y} @tab @code{REAL(8)} @tab Fortran 77 and later\n @end multitable\n+\n+@item @emph{See also}:\n+Alias: @ref{ATAN}\n+Degrees function: @ref{ATAN2D}\n+\n+@end table\n+\n+\n+\n+@node ATAN2D\n+@section @code{ATAN2D} --- Arctangent function, degrees\n+@fnindex ATAN2D\n+@fnindex DATAN2D\n+@cindex trigonometric function, tangent, inverse, degrees\n+@cindex tangent, inverse, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATAN2D(Y, X)} computes the principal value of the argument\n+function of the complex number @math{X + i Y} in degrees.  This function can\n+be used to transform from Cartesian into polar coordinates and\n+allows to determine the angle in the correct quadrant.\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = ATAN2D(Y, X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{Y} @tab The type shall be @code{REAL}.\n+@item @var{X} @tab The type and kind type parameter shall be the same as @var{Y}.\n+If @var{Y} is zero, then @var{X} must be nonzero.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has the same type and kind type parameter as @var{Y}. It\n+is the principal value of the complex number @math{X + i Y}.  If @var{X}\n+is nonzero, then it lies in the range @math{-180 \\le \\atan (x) \\leq 180}.\n+The sign is positive if @var{Y} is positive.  If @var{Y} is zero, then\n+the return value is zero if @var{X} is strictly positive, @math{180} if\n+@var{X} is negative and @var{Y} is positive zero (or the processor does\n+not handle signed zeros), and @math{-180} if @var{X} is negative and\n+@var{Y} is negative zero.  Finally, if @var{X} is zero, then the\n+magnitude of the result is @math{90}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_atan2d\n+  real(4) :: x = 1.e0_4, y = 0.5e0_4\n+  x = atan2d(y,x)\n+end program test_atan2d\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name                @tab Argument            @tab Return type    @tab Standard\n+@item @code{ATAN2D(X, Y)}  @tab @code{REAL(4) X, Y} @tab @code{REAL(4)} @tab GNU Extension\n+@item @code{DATAN2D(X, Y)} @tab @code{REAL(8) X, Y} @tab @code{REAL(8)} @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Alias: @ref{ATAND}\n+Radians function: @ref{ATAN2}\n+\n @end table\n \n \n@@ -3895,6 +4162,70 @@ end program test_cos\n \n @item @emph{See also}:\n Inverse function: @ref{ACOS}\n+Degrees function: @ref{COSD}\n+\n+@end table\n+\n+\n+\n+@node COSD\n+@section @code{COSD} --- Cosine function, degrees\n+@fnindex COSD\n+@fnindex DCOSD\n+@fnindex CCOSD\n+@fnindex ZCOSD\n+@fnindex CDCOSD\n+@cindex trigonometric function, cosine, degrees\n+@cindex cosine, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{COSD(X)} computes the cosine of @var{X} in degrees.\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = COSD(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of the same type and kind as @var{X}. The real part\n+of the result is in degrees.  If @var{X} is of the type @code{REAL},\n+the return value lies in the range @math{ -1 \\leq \\cosd (x) \\leq 1}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_cosd\n+  real :: x = 0.0\n+  x = cosd(x)\n+end program test_cosd\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument            @tab Return type       @tab Standard\n+@item @code{COSD(X)}   @tab @code{REAL(4) X}    @tab @code{REAL(4)}    @tab GNU Extension\n+@item @code{DCOSD(X)}  @tab @code{REAL(8) X}    @tab @code{REAL(8)}    @tab GNU Extension\n+@item @code{CCOSD(X)}  @tab @code{COMPLEX(4) X} @tab @code{COMPLEX(4)} @tab GNU Extension\n+@item @code{ZCOSD(X)}  @tab @code{COMPLEX(8) X} @tab @code{COMPLEX(8)} @tab GNU extension\n+@item @code{CDCOSD(X)} @tab @code{COMPLEX(8) X} @tab @code{COMPLEX(8)} @tab GNU extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Inverse function: @ref{ACOSD}\n+Radians function: @ref{COS}\n \n @end table\n \n@@ -3954,6 +4285,115 @@ Inverse function: @ref{ACOSH}\n \n \n \n+@node COTAN\n+@section @code{COTAN} --- Cotangent function\n+@fnindex COTAN\n+@fnindex DCOTAN\n+@cindex trigonometric function, cotangent\n+@cindex cotangent\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{COTAN(X)} computes the cotangent of @var{X}. Equivalent to @code{COS(x)}\n+divided by @code{SIN(x)}, or @code{1 / TAN(x)}.\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = COTAN(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be @code{REAL} or @code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has same type and kind as @var{X}, and its value is in radians.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_cotan\n+  real(8) :: x = 0.165_8\n+  x = cotan(x)\n+end program test_cotan\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument          @tab Return type     @tab Standard\n+@item @code{COTAN(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab GNU Extension\n+@item @code{DCOTAN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Converse function: @ref{TAN}\n+Degrees function: @ref{COTAND}\n+@end table\n+\n+\n+\n+@node COTAND\n+@section @code{COTAND} --- Cotangent function, degrees\n+@fnindex COTAND\n+@fnindex DCOTAND\n+@cindex trigonometric function, cotangent, degrees\n+@cindex cotangent, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{COTAND(X)} computes the cotangent of @var{X} in degrees.  Equivalent to\n+@code{COSD(x)} divided by @code{SIND(x)}, or @code{1 / TAND(x)}.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = COTAND(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be @code{REAL} or @code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has same type and kind as @var{X}, and its value is in degrees.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_cotand\n+  real(8) :: x = 0.165_8\n+  x = cotand(x)\n+end program test_cotand\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument          @tab Return type     @tab Standard\n+@item @code{COTAND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab GNU Extension\n+@item @code{DCOTAND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Converse function: @ref{TAND}\n+Radians function: @ref{COTAN}\n+\n+@end table\n+\n+\n+\n @node COUNT\n @section @code{COUNT} --- Count function\n @fnindex COUNT\n@@ -12390,7 +12830,69 @@ end program test_sin\n @end multitable\n \n @item @emph{See also}:\n-@ref{ASIN}\n+Inverse function: @ref{ASIN}\n+Degrees function: @ref{SIND}\n+@end table\n+\n+\n+\n+@node SIND\n+@section @code{SIND} --- Sine function, degrees\n+@fnindex SIND\n+@fnindex DSIND\n+@fnindex CSIND\n+@fnindex ZSIND\n+@fnindex CDSIND\n+@cindex trigonometric function, sine, degrees\n+@cindex sine, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{SIND(X)} computes the sine of @var{X} in degrees.\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = SIND(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has same type and kind as @var{X}, and its value is in degrees.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_sind\n+  real :: x = 0.0\n+  x = sind(x)\n+end program test_sind\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument             @tab Return type       @tab Standard\n+@item @code{SIND(X)}   @tab @code{REAL(4) X}     @tab @code{REAL(4)}    @tab GNU Extension\n+@item @code{DSIND(X)}  @tab @code{REAL(8) X}     @tab @code{REAL(8)}    @tab GNU Extension\n+@item @code{CSIND(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)} @tab GNU Extension\n+@item @code{ZSIND(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)} @tab GNU Extension\n+@item @code{CDSIND(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)} @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Inverse function: @ref{ASIND}\n+Radians function: @ref{SIN}\n+\n @end table\n \n \n@@ -13151,7 +13653,7 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value has same type and kind as @var{X}.\n+The return value has same type and kind as @var{X}, and its value is in radians.\n \n @item @emph{Example}:\n @smallexample\n@@ -13169,7 +13671,61 @@ end program test_tan\n @end multitable\n \n @item @emph{See also}:\n-@ref{ATAN}\n+Inverse function: @ref{ATAN}\n+Degrees function: @ref{TAND}\n+@end table\n+\n+\n+\n+@node TAND\n+@section @code{TAND} --- Tangent function, degrees\n+@fnindex TAND\n+@fnindex DTAND\n+@cindex trigonometric function, tangent, degrees\n+@cindex tangent, degrees\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{TAND(X)} computes the tangent of @var{X} in degrees.\n+\n+This function is for compatibility only and should be avoided in favor of\n+standard constructs wherever possible.\n+\n+@item @emph{Standard}:\n+GNU Extension, enabled with @option{-fdec-math}.\n+\n+@item @emph{Class}:\n+Elemental function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = TAND(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab The type shall be @code{REAL} or @code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has same type and kind as @var{X}, and its value is in degrees.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_tand\n+  real(8) :: x = 0.165_8\n+  x = tand(x)\n+end program test_tand\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .20 .20 .20 .25\n+@item Name            @tab Argument          @tab Return type     @tab Standard\n+@item @code{TAND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab GNU Extension\n+@item @code{DTAND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab GNU Extension\n+@end multitable\n+\n+@item @emph{See also}:\n+Inverse function: @ref{ATAND}\n+Radians function: @ref{TAN}\n @end table\n \n "}, {"sha": "655ee6fb08e8e697fffdd3f28979578a0a108733", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -116,7 +116,7 @@ by type.  Explanations are in the following sections.\n @xref{Fortran Dialect Options,,Options controlling Fortran dialect}.\n @gccoptlist{-fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code @gol\n -fd-lines-as-comments @gol\n--fdec -fdec-structure -fdec-intrinsic-ints -fdec-static @gol\n+-fdec -fdec-structure -fdec-intrinsic-ints -fdec-static -fdec-math @gol\n -fdefault-double-8 -fdefault-integer-8 @gol\n -fdefault-real-8 -fdollar-ok -ffixed-line-length-@var{n} @gol\n -ffixed-line-length-none -ffree-form -ffree-line-length-@var{n} @gol\n@@ -255,6 +255,11 @@ instead where possible.\n Enable B/I/J/K kind variants of existing integer functions (e.g. BIAND, IIAND,\n JIAND, etc...). For a complete list of intrinsics see the full documentation.\n \n+@item -fdec-math\n+@opindex @code{fdec-math}\n+Enable legacy math intrinsics such as COTAN and degree-valued trigonometric\n+functions (e.g. TAND, ATAND, etc...) for compatability with older code.\n+\n @item -fdec-static\n @opindex @code{fdec-static}\n Enable DEC-style STATIC and AUTOMATIC attributes to explicitly specify"}, {"sha": "f4f81b2e58918e7727c682ec2810742004ac9a7d", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -673,6 +673,86 @@ gfc_resolve_cosh (gfc_expr *f, gfc_expr *x)\n }\n \n \n+/* Our replacement of elements of a trig call with an EXPR_OP (e.g.\n+   multiplying the result or operands by a factor to convert to/from degrees)\n+   will cause the resolve_* function to be invoked again when resolving the\n+   freshly created EXPR_OP.  See gfc_resolve_trigd, gfc_resolve_atrigd,\n+   gfc_resolve_cotan.  We must observe this and avoid recursively creating\n+   layers of nested EXPR_OP expressions.  */\n+\n+static bool\n+is_trig_resolved (gfc_expr *f)\n+{\n+  /* We know we've already resolved the function if we see the lib call\n+     starting with '__'.  */\n+  return f->value.function.name != NULL\n+    && 0 == strncmp (\"__\", f->value.function.name, 2);\n+}\n+\n+/* Return a shallow copy of the function expression f.  The original expression\n+   has its pointers cleared so that it may be freed without affecting the\n+   shallow copy.  This is similar to gfc_copy_expr, but doesn't perform a deep\n+   copy of the argument list, allowing it to be reused somewhere else,\n+   setting the expression up nicely for gfc_replace_expr.  */\n+\n+static gfc_expr *\n+copy_replace_function_shallow (gfc_expr *f)\n+{\n+  gfc_expr *fcopy;\n+  gfc_actual_arglist *args;\n+\n+  /* The only thing deep-copied in gfc_copy_expr is args.  */\n+  args = f->value.function.actual;\n+  f->value.function.actual = NULL;\n+  fcopy = gfc_copy_expr (f);\n+  fcopy->value.function.actual = args;\n+\n+  /* Clear the old function so the shallow copy is not affected if the old\n+     expression is freed.  */\n+  f->value.function.name = NULL;\n+  f->value.function.isym = NULL;\n+  f->value.function.actual = NULL;\n+  f->value.function.esym = NULL;\n+  f->shape = NULL;\n+  f->ref = NULL;\n+\n+  return fcopy;\n+}\n+\n+\n+/* Resolve cotan = cos / sin.  */\n+\n+void\n+gfc_resolve_cotan (gfc_expr *f, gfc_expr *x)\n+{\n+  gfc_expr *result, *fcopy, *sin;\n+  gfc_actual_arglist *sin_args;\n+\n+  if (is_trig_resolved (f))\n+    return;\n+\n+  /* Compute cotan (x) = cos (x) / sin (x).  */\n+  f->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_COS);\n+  gfc_resolve_cos (f, x);\n+\n+  sin_args = gfc_get_actual_arglist ();\n+  sin_args->expr = gfc_copy_expr (x);\n+\n+  sin = gfc_get_expr ();\n+  sin->ts = f->ts;\n+  sin->where = f->where;\n+  sin->expr_type = EXPR_FUNCTION;\n+  sin->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_SIN);\n+  sin->value.function.actual = sin_args;\n+  gfc_resolve_sin (sin, sin_args->expr);\n+\n+  /* Replace f with cos/sin - we do this in place in f for the caller.  */\n+  fcopy = copy_replace_function_shallow (f);\n+  result = gfc_divide (fcopy, sin);\n+  gfc_replace_expr (f, result);\n+}\n+\n+\n void\n gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n@@ -2578,6 +2658,159 @@ gfc_resolve_tanh (gfc_expr *f, gfc_expr *x)\n }\n \n \n+/* Build an expression for converting degrees to radians.  */\n+\n+static gfc_expr *\n+get_radians (gfc_expr *deg)\n+{\n+  gfc_expr *result, *factor;\n+  gfc_actual_arglist *mod_args;\n+\n+  gcc_assert (deg->ts.type == BT_REAL);\n+\n+  /* Set deg = deg % 360 to avoid offsets from large angles.  */\n+  factor = gfc_get_constant_expr (deg->ts.type, deg->ts.kind, &deg->where);\n+  mpfr_set_d (factor->value.real, 360.0, GFC_RND_MODE);\n+\n+  mod_args = gfc_get_actual_arglist ();\n+  mod_args->expr = deg;\n+  mod_args->next = gfc_get_actual_arglist ();\n+  mod_args->next->expr = factor;\n+\n+  result = gfc_get_expr ();\n+  result->ts = deg->ts;\n+  result->where = deg->where;\n+  result->expr_type = EXPR_FUNCTION;\n+  result->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_MOD);\n+  result->value.function.actual = mod_args;\n+\n+  /* Set factor = pi / 180.  */\n+  factor = gfc_get_constant_expr (deg->ts.type, deg->ts.kind, &deg->where);\n+  mpfr_const_pi (factor->value.real, GFC_RND_MODE);\n+  mpfr_div_d (factor->value.real, factor->value.real, 180.0, GFC_RND_MODE);\n+\n+  /* Result is rad = (deg % 360) * (pi / 180).  */\n+  result = gfc_multiply (result, factor);\n+  return result;\n+}\n+\n+\n+/* Build an expression for converting radians to degrees.  */\n+\n+static gfc_expr *\n+get_degrees (gfc_expr *rad)\n+{\n+  gfc_expr *result, *factor;\n+  gfc_actual_arglist *mod_args;\n+\n+  gcc_assert (rad->ts.type == BT_REAL);\n+\n+  /* Set rad = rad % 2pi to avoid offsets from large angles.  */\n+  factor = gfc_get_constant_expr (rad->ts.type, rad->ts.kind, &rad->where);\n+  mpfr_const_pi (factor->value.real, GFC_RND_MODE);\n+  mpfr_mul_ui (factor->value.real, factor->value.real, 2, GFC_RND_MODE);\n+\n+  mod_args = gfc_get_actual_arglist ();\n+  mod_args->expr = rad;\n+  mod_args->next = gfc_get_actual_arglist ();\n+  mod_args->next->expr = factor;\n+\n+  result = gfc_get_expr ();\n+  result->ts = rad->ts;\n+  result->where = rad->where;\n+  result->expr_type = EXPR_FUNCTION;\n+  result->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_MOD);\n+  result->value.function.actual = mod_args;\n+\n+  /* Set factor = 180 / pi.  */\n+  factor = gfc_get_constant_expr (rad->ts.type, rad->ts.kind, &rad->where);\n+  mpfr_set_d (factor->value.real, 180.0, GFC_RND_MODE);\n+  mpfr_init (tmp);\n+  mpfr_const_pi (tmp, GFC_RND_MODE);\n+  mpfr_div (factor->value.real, factor->value.real, tmp, GFC_RND_MODE);\n+  mpfr_clear (tmp);\n+\n+  /* Result is deg = (rad % 2pi) * (180 / pi).  */\n+  result = gfc_multiply (result, factor);\n+  return result;\n+}\n+\n+\n+/* Resolve a call to a trig function.  */\n+\n+static void\n+resolve_trig_call (gfc_expr *f, gfc_expr *x)\n+{\n+  switch (f->value.function.isym->id)\n+    {\n+      case GFC_ISYM_ACOS:\n+\treturn gfc_resolve_acos (f, x);\n+      case GFC_ISYM_ASIN:\n+\treturn gfc_resolve_asin (f, x);\n+      case GFC_ISYM_ATAN:\n+\treturn gfc_resolve_atan (f, x);\n+      case GFC_ISYM_ATAN2:\n+\t/* NB. arg3 is unused for atan2 */\n+\treturn gfc_resolve_atan2 (f, x, NULL);\n+      case GFC_ISYM_COS:\n+\treturn gfc_resolve_cos (f, x);\n+      case GFC_ISYM_COTAN:\n+\treturn gfc_resolve_cotan (f, x);\n+      case GFC_ISYM_SIN:\n+\treturn gfc_resolve_sin (f, x);\n+      case GFC_ISYM_TAN:\n+\treturn gfc_resolve_tan (f, x);\n+      default:\n+\tbreak;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Resolve degree trig function as trigd (x) = trig (radians (x)).  */\n+\n+void\n+gfc_resolve_trigd (gfc_expr *f, gfc_expr *x)\n+{\n+  if (is_trig_resolved (f))\n+    return;\n+\n+  x = get_radians (x);\n+  f->value.function.actual->expr = x;\n+\n+  resolve_trig_call (f, x);\n+}\n+\n+\n+/* Resolve degree inverse trig function as atrigd (x) = degrees (atrig (x)).  */\n+\n+void\n+gfc_resolve_atrigd (gfc_expr *f, gfc_expr *x)\n+{\n+  gfc_expr *result, *fcopy;\n+\n+  if (is_trig_resolved (f))\n+    return;\n+\n+  resolve_trig_call (f, x);\n+\n+  fcopy = copy_replace_function_shallow (f);\n+  result = get_degrees (fcopy);\n+  gfc_replace_expr (f, result);\n+}\n+\n+\n+/* Resolve atan2d(x) = degrees(atan2(x)).  */\n+\n+void\n+gfc_resolve_atan2d (gfc_expr *f, gfc_expr *x, gfc_expr *y ATTRIBUTE_UNUSED)\n+{\n+  /* Note that we lose the second arg here - that's okay because it is\n+     unused in gfc_resolve_atan2 anyway.  */\n+  gfc_resolve_atrigd (f, x);\n+}\n+\n+\n void\n gfc_resolve_image_index (gfc_expr *f, gfc_expr *array ATTRIBUTE_UNUSED,\n \t\t\t gfc_expr *sub ATTRIBUTE_UNUSED)"}, {"sha": "b563e09c578d0903a03512a84a6ef48e2c170dc0", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -428,6 +428,10 @@ fdec-intrinsic-ints\n Fortran Var(flag_dec_intrinsic_ints)\n Enable kind-specific variants of integer intrinsic functions.\n \n+fdec-math\n+Fortran Var(flag_dec_math)\n+Enable legacy math intrinsics for compatibility.\n+\n fdec-structure\n Fortran\n Enable support for DEC STRUCTURE/RECORD."}, {"sha": "93403f7cf17582d43a689e373ad42c3a730f350b", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -55,6 +55,7 @@ set_dec_flags (int value)\n     gfc_option.flag_dec_structure  = value;\n     flag_dec_intrinsic_ints = value;\n     flag_dec_static = value;\n+    flag_dec_math = value;\n }\n \n "}, {"sha": "bf60f7475d61fa3c2752244f96f0161fced44efa", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -1706,6 +1706,152 @@ gfc_simplify_conjg (gfc_expr *e)\n   return range_check (result, \"CONJG\");\n }\n \n+/* Return the simplification of the constant expression in icall, or NULL\n+   if the expression is not constant.  */\n+\n+static gfc_expr *\n+simplify_trig_call (gfc_expr *icall)\n+{\n+  gfc_isym_id func = icall->value.function.isym->id;\n+  gfc_expr *x = icall->value.function.actual->expr;\n+\n+  /* The actual simplifiers will return NULL for non-constant x.  */\n+  switch (func)\n+  {\n+    case GFC_ISYM_ACOS:\n+\treturn gfc_simplify_acos (x);\n+    case GFC_ISYM_ASIN:\n+\treturn gfc_simplify_asin (x);\n+    case GFC_ISYM_ATAN:\n+\treturn gfc_simplify_atan (x);\n+    case GFC_ISYM_COS:\n+\treturn gfc_simplify_cos (x);\n+    case GFC_ISYM_COTAN:\n+\treturn gfc_simplify_cotan (x);\n+    case GFC_ISYM_SIN:\n+\treturn gfc_simplify_sin (x);\n+    case GFC_ISYM_TAN:\n+\treturn gfc_simplify_tan (x);\n+    default:\n+\t break;\n+  }\n+\n+  gfc_internal_error (\"in simplify_trig_call(): Bad intrinsic\");\n+  return NULL;\n+}\n+\n+/* Convert a floating-point number from radians to degrees.  */\n+\n+static void\n+degrees_f (mpfr_t x, mp_rnd_t rnd_mode)\n+{\n+    mpfr_t tmp;\n+    mpfr_init (tmp);\n+\n+    /* Set x = x % 2pi to avoid offsets with large angles.  */\n+    mpfr_const_pi (tmp, rnd_mode);\n+    mpfr_mul_ui (tmp, tmp, 2, rnd_mode);\n+    mpfr_fmod (tmp, x, tmp, rnd_mode);\n+\n+    /* Set x = x * 180.  */\n+    mpfr_mul_d (x, x, 180.0, rnd_mode);\n+\n+    /* Set x = x / pi.  */\n+    mpfr_const_pi (tmp, rnd_mode);\n+    mpfr_div (x, x, tmp, rnd_mode);\n+\n+    mpfr_clear (tmp);\n+}\n+\n+/* Convert a floating-point number from degrees to radians.  */\n+\n+static void\n+radians_f (mpfr_t x, mp_rnd_t rnd_mode)\n+{\n+    mpfr_t tmp;\n+    mpfr_init (tmp);\n+\n+    /* Set x = x % 360 to avoid offsets with large angles.  */\n+    mpfr_fmod_d (tmp, x, 360.0, rnd_mode);\n+\n+    /* Set x = x * pi.  */\n+    mpfr_const_pi (tmp, rnd_mode);\n+    mpfr_mul (x, x, tmp, rnd_mode);\n+\n+    /* Set x = x / 180.  */\n+    mpfr_div_d (x, x, 180.0, rnd_mode);\n+\n+    mpfr_clear (tmp);\n+}\n+\n+\n+/* Convert argument to radians before calling a trig function.  */\n+\n+gfc_expr *\n+gfc_simplify_trigd (gfc_expr *icall)\n+{\n+  gfc_expr *arg;\n+\n+  arg = icall->value.function.actual->expr;\n+\n+  if (arg->ts.type != BT_REAL)\n+    gfc_internal_error (\"in gfc_simplify_trigd(): Bad type\");\n+\n+  if (arg->expr_type == EXPR_CONSTANT)\n+    /* Convert constant to radians before passing off to simplifier.  */\n+    radians_f (arg->value.real, GFC_RND_MODE);\n+\n+  /* Let the usual simplifier take over - we just simplified the arg.  */\n+  return simplify_trig_call (icall);\n+}\n+\n+/* Convert result of an inverse trig function to degrees.  */\n+\n+gfc_expr *\n+gfc_simplify_atrigd (gfc_expr *icall)\n+{\n+  gfc_expr *result;\n+\n+  if (icall->value.function.actual->expr->ts.type != BT_REAL)\n+    gfc_internal_error (\"in gfc_simplify_atrigd(): Bad type\");\n+\n+  /* See if another simplifier has work to do first.  */\n+  result = simplify_trig_call (icall);\n+\n+  if (result && result->expr_type == EXPR_CONSTANT)\n+  {\n+      /* Convert constant to degrees after passing off to actual simplifier.  */\n+      degrees_f (result->value.real, GFC_RND_MODE);\n+      return result;\n+  }\n+\n+  /* Let gfc_resolve_atrigd take care of the non-constant case.  */\n+  return NULL;\n+}\n+\n+/* Convert the result of atan2 to degrees.  */\n+\n+gfc_expr *\n+gfc_simplify_atan2d (gfc_expr *y, gfc_expr *x)\n+{\n+  gfc_expr *result;\n+\n+  if (x->ts.type != BT_REAL || y->ts.type != BT_REAL)\n+    gfc_internal_error (\"in gfc_simplify_atan2d(): Bad type\");\n+\n+  if (x->expr_type == EXPR_CONSTANT && y->expr_type == EXPR_CONSTANT)\n+    {\n+      result = gfc_simplify_atan2 (y, x);\n+      if (result != NULL)\n+\t{\n+\t  degrees_f (result->value.real, GFC_RND_MODE);\n+\t  return result;\n+\t}\n+    }\n+\n+  /* Let gfc_resolve_atan2d take care of the non-constant case.  */\n+  return NULL;\n+}\n \n gfc_expr *\n gfc_simplify_cos (gfc_expr *x)\n@@ -6243,6 +6389,41 @@ gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n }\n \n \n+gfc_expr *\n+gfc_simplify_cotan (gfc_expr *x)\n+{\n+  gfc_expr *result;\n+  mpc_t swp, *val;\n+\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+\n+  switch (x->ts.type)\n+    {\n+      case BT_REAL:\n+\tmpfr_cot (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+\n+      case BT_COMPLEX:\n+\t/* There is no builtin mpc_cot, so compute cot = cos / sin.  */\n+\tval = &result->value.complex;\n+\tmpc_init2 (swp, mpfr_get_default_prec ());\n+\tmpc_cos (swp, x->value.complex, GFC_MPC_RND_MODE);\n+\tmpc_sin (*val, x->value.complex, GFC_MPC_RND_MODE);\n+\tmpc_div (*val, swp, *val, GFC_MPC_RND_MODE);\n+\tmpc_clear (swp);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  return range_check (result, \"COTAN\");\n+}\n+\n+\n gfc_expr *\n gfc_simplify_tan (gfc_expr *x)\n {"}, {"sha": "e1ed8e5250f7f22afca8f1e22ef1b20358f65c74", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -1,3 +1,7 @@\n+2016-10-11  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\t* gfortran.dg/dec_math.f90: New testsuite.\n+\n 2016-10-11  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* gcc.dg/tree-ssa/pr59597.c: Typedef  __INT32_TYPE__ to i32."}, {"sha": "857a261892b788cdf45c50bab8a8281123d3c42d", "filename": "gcc/testsuite/gfortran.dg/dec_math.f90", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8c2744faa0cfa9697229b074b951e70bf50e1b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math.f90?ref=8e8c2744faa0cfa9697229b074b951e70bf50e1b", "patch": "@@ -0,0 +1,289 @@\n+! { dg-options \"-fdec-math\" }\n+! { dg-do run }\n+!\n+! Test extra math intrinsics offered by -fdec-math.\n+!\n+\n+  subroutine cmpf(f1, f2, tolerance, str)\n+    implicit none\n+    real(4), intent(in) :: f1, f2, tolerance\n+    character(len=*), intent(in) :: str\n+    if ( abs(f2 - f1) .gt. tolerance ) then\n+      write (*, '(A,F12.6,F12.6)') str, f1, f2\n+      call abort()\n+    endif\n+  endsubroutine\n+\n+  subroutine cmpd(d1, d2, tolerance, str)\n+    implicit none\n+    real(8), intent(in) :: d1, d2, tolerance\n+    character(len=*), intent(in) :: str\n+    if ( dabs(d2 - d1) .gt. tolerance ) then\n+      write (*, '(A,F12.6,F12.6)') str, d1, d2\n+      call abort()\n+    endif\n+  endsubroutine\n+\n+implicit none\n+\n+  real(4), parameter :: pi_f = (4.0_4 *  atan(1.0_4))\n+  real(8), parameter :: pi_d = (4.0_8 * datan(1.0_8))\n+  real(4), parameter :: r2d_f = 180.0_4 / pi_f\n+  real(8), parameter :: r2d_d = 180.0_8 / pi_d\n+  real(4), parameter :: d2r_f = pi_f / 180.0_4\n+  real(8), parameter :: d2r_d = pi_d / 180.0_8\n+\n+! inputs\n+real(4) :: f_i1, f_i2\n+real(4), volatile :: xf\n+real(8) :: d_i1, d_i2\n+real(8), volatile :: xd\n+\n+! expected outputs from (oe) default (oxe) expression\n+real(4) :: f_oe, f_oxe\n+real(8) :: d_oe, d_oxe\n+\n+! actual outputs from (oa) default (oc) constant (ox) expression\n+real(4) :: f_oa, f_oc, f_ox\n+real(8) :: d_oa, d_oc, d_ox\n+\n+! tolerance of the answer: assert |exp-act| <= tol\n+real(4) :: f_tol\n+real(8) :: d_tol\n+\n+! equivalence tolerance\n+f_tol = 5e-5_4\n+d_tol = 5e-6_8\n+\n+! multiplication factors to test non-constant expressions\n+xf = 2.0_4\n+xd = 2.0_8\n+\n+! Input\n+f_i1 = 0.68032123_4\n+d_i1 = 0.68032123_8\n+\n+! Expected\n+f_oe =     r2d_f*acos (f_i1)\n+f_oxe = xf*r2d_f*acos (f_i1)\n+d_oe =     r2d_d*dacos(d_i1)\n+d_oxe = xd*r2d_d*dacos(d_i1)\n+\n+! Actual\n+f_oa =    acosd (f_i1)\n+f_oc =    acosd (0.68032123_4)\n+f_ox = xf*acosd (f_i1)\n+d_oa =    dacosd (d_i1)\n+d_oc =    dacosd (0.68032123_8)\n+d_ox = xd*dacosd (0.68032123_8)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) acosd\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) acosd\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) acosd\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dacosd\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dacosd\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) dacosd\")\n+\n+! Input\n+f_i1 = 60.0_4\n+d_i1 = 60.0_8\n+\n+! Expected\n+f_oe  =    cos (d2r_f*f_i1)\n+f_oxe = xf*cos (d2r_f*f_i1)\n+d_oe  =    cos (d2r_d*d_i1)\n+d_oxe = xd*cos (d2r_d*d_i1)\n+\n+! Actual\n+f_oa =     cosd (f_i1)\n+f_oc =     cosd (60.0_4)\n+f_ox = xf* cosd (f_i1)\n+d_oa =    dcosd (d_i1)\n+d_oc =    dcosd (60.0_8)\n+d_ox = xd* cosd (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) cosd\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) cosd\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) cosd\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dcosd\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dcosd\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) cosd\")\n+\n+! Input\n+f_i1 = 0.79345021_4\n+d_i1 = 0.79345021_8\n+\n+! Expected\n+f_oe  =    r2d_f*asin (f_i1)\n+f_oxe = xf*r2d_f*asin (f_i1)\n+d_oe  =    r2d_d*asin (d_i1)\n+d_oxe = xd*r2d_d*asin (d_i1)\n+\n+! Actual\n+f_oa =     asind (f_i1)\n+f_oc =     asind (0.79345021_4)\n+f_ox = xf* asind (f_i1)\n+d_oa =    dasind (d_i1)\n+d_oc =    dasind (0.79345021_8)\n+d_ox = xd* asind (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) asind\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) asind\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) asind\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dasind\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dasind\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) asind\")\n+\n+! Input\n+f_i1 = 60.0_4\n+d_i1 = 60.0_8\n+\n+! Expected\n+f_oe  =    sin (d2r_f*f_i1)\n+f_oxe = xf*sin (d2r_f*f_i1)\n+d_oe  =    sin (d2r_d*d_i1)\n+d_oxe = xd*sin (d2r_d*d_i1)\n+\n+! Actual\n+f_oa =     sind (f_i1)\n+f_oc =     sind (60.0_4)\n+f_ox = xf* sind (f_i1)\n+d_oa =    dsind (d_i1)\n+d_oc =    dsind (60.0_8)\n+d_ox = xd* sind (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) sind\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) sind\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) sind\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dsind\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dsind\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) sind\")\n+\n+! Input\n+f_i1 = 2.679676_4\n+f_i2 = 1.0_4\n+d_i1 = 2.679676_8\n+d_i2 = 1.0_8\n+\n+! Expected\n+f_oe  =    r2d_f*atan2 (f_i1, f_i2)\n+f_oxe = xf*r2d_f*atan2 (f_i1, f_i2)\n+d_oe  =    r2d_d*atan2 (d_i1, d_i2)\n+d_oxe = xd*r2d_d*atan2 (d_i1, d_i2)\n+\n+! Actual\n+f_oa =     atan2d (f_i1, f_i2)\n+f_oc =     atan2d (2.679676_4, 1.0_4)\n+f_ox = xf* atan2d (f_i1, f_i2)\n+d_oa =    datan2d (d_i1, d_i2)\n+d_oc =    datan2d (2.679676_8, 1.0_8)\n+d_ox = xd* atan2d (d_i1, d_i2)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) atan2d\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) atan2d\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) atan2d\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) datan2d\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) datan2d\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) atan2d\")\n+\n+! Input\n+f_i1 = 1.5874993_4\n+d_i1 = 1.5874993_8\n+\n+! Expected\n+f_oe  =    r2d_f*atan (f_i1)\n+f_oxe = xf*r2d_f*atan (f_i1)\n+d_oe  =    r2d_d*atan (d_i1)\n+d_oxe = xd*r2d_d*atan (d_i1)\n+\n+! Actual\n+f_oa =     atand (f_i1)\n+f_oc =     atand (1.5874993_4)\n+f_ox = xf* atand (f_i1)\n+d_oa =    datand (d_i1)\n+d_oc =    datand (1.5874993_8)\n+d_ox = xd* atand (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) atand\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) atand\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) atand\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) datand\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) datand\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) atand\")\n+\n+! Input\n+f_i1 = 0.6_4\n+d_i1 = 0.6_8\n+\n+! Expected\n+f_oe  =    cotan (d2r_f*f_i1)\n+f_oxe = xf*cotan (d2r_f*f_i1)\n+d_oe  =    cotan (d2r_d*d_i1)\n+d_oxe = xd*cotan (d2r_d*d_i1)\n+\n+! Actual\n+f_oa =     cotand (f_i1)\n+f_oc =     cotand (0.6_4)\n+f_ox = xf* cotand (f_i1)\n+d_oa =    dcotand (d_i1)\n+d_oc =    dcotand (0.6_8)\n+d_ox = xd* cotand (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) cotand\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) cotand\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) cotand\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dcotand\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dcotand\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) cotand\")\n+\n+! Input\n+f_i1 = 0.6_4\n+d_i1 = 0.6_8\n+\n+! Expected\n+f_oe  =     1.0_4/tan (f_i1)\n+f_oxe = xf* 1.0_4/tan (f_i1)\n+d_oe  =    1.0_8/dtan (d_i1)\n+d_oxe = xd*1.0_8/dtan (d_i1)\n+\n+! Actual\n+f_oa =     cotan (f_i1)\n+f_oc =     cotan (0.6_4)\n+f_ox = xf* cotan (f_i1)\n+d_oa =    dcotan (d_i1)\n+d_oc =    dcotan (0.6_8)\n+d_ox = xd* cotan (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) cotan\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) cotan\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) cotan\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dcotan\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dcotan\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) cotan\")\n+\n+! Input\n+f_i1 = 60.0_4\n+d_i1 = 60.0_8\n+\n+! Expected\n+f_oe  =    tan (d2r_f*f_i1)\n+f_oxe = xf*tan (d2r_f*f_i1)\n+d_oe  =    tan (d2r_d*d_i1)\n+d_oxe = xd*tan (d2r_d*d_i1)\n+\n+! Actual\n+f_oa =     tand (f_i1)\n+f_oc =     tand (60.0_4)\n+f_ox = xf* tand (f_i1)\n+d_oa =    dtand (d_i1)\n+d_oc =    dtand (60.0_8)\n+d_ox = xd* tand (d_i1)\n+\n+call cmpf(f_oe,  f_oa, f_tol, \"( ) tand\")\n+call cmpf(f_oe,  f_oc, f_tol, \"(c) tand\")\n+call cmpf(f_oxe, f_ox, f_tol, \"(x) tand\")\n+call cmpd(d_oe,  d_oa, d_tol, \"( ) dtand\")\n+call cmpd(d_oe,  d_oc, d_tol, \"(c) dtand\")\n+call cmpd(d_oxe, d_ox, d_tol, \"(x) tand\")\n+\n+end"}]}