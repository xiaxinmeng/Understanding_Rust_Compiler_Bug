{"sha": "eae97bd90c2f25af25fe2deb8aa01621783866c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlOTdiZDkwYzJmMjVhZjI1ZmUyZGViOGFhMDE2MjE3ODM4NjZjOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-04-27T14:02:45Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-04-27T14:02:45Z"}, "message": "decl.c (maybe_push_to_top_level): Always clear current_template_parms and processing_template_decl.\n\n\t* decl.c (maybe_push_to_top_level): Always clear\n\tcurrent_template_parms and processing_template_decl.\n\t(pushtag): Remove check of current_class_type and some comments,\n\tsince maybe_push_to_top_level no longer creates confusion.\n\nFrom-SVN: r19434", "tree": {"sha": "b37ff11fda421233cb9f70607f8a21c80f7e8dd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b37ff11fda421233cb9f70607f8a21c80f7e8dd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eae97bd90c2f25af25fe2deb8aa01621783866c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae97bd90c2f25af25fe2deb8aa01621783866c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae97bd90c2f25af25fe2deb8aa01621783866c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae97bd90c2f25af25fe2deb8aa01621783866c9/comments", "author": null, "committer": null, "parents": [{"sha": "07623417034f67b6785c10a2ccfd64fbb90e9710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07623417034f67b6785c10a2ccfd64fbb90e9710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07623417034f67b6785c10a2ccfd64fbb90e9710"}], "stats": {"total": 50, "additions": 21, "deletions": 29}, "files": [{"sha": "8c2180ddc6ca90014abf690fefa7ddac1c54e27f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae97bd90c2f25af25fe2deb8aa01621783866c9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae97bd90c2f25af25fe2deb8aa01621783866c9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eae97bd90c2f25af25fe2deb8aa01621783866c9", "patch": "@@ -1,3 +1,10 @@\n+Mon Apr 27 13:58:10 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* decl.c (maybe_push_to_top_level): Always clear\n+\tcurrent_template_parms and processing_template_decl.\n+\t(pushtag): Remove check of current_class_type and some comments,\n+\tsince maybe_push_to_top_level no longer creates confusion.\n+\n Sun Apr 26 12:10:18 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* cp-tree.h (CLASSTYPE_IS_TEMPLATE): New macro."}, {"sha": "56129f201e081bf4ad362765ab5b915cb37fff95", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae97bd90c2f25af25fe2deb8aa01621783866c9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae97bd90c2f25af25fe2deb8aa01621783866c9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eae97bd90c2f25af25fe2deb8aa01621783866c9", "patch": "@@ -2017,11 +2017,8 @@ maybe_push_to_top_level (pseudo)\n   previous_class_type = previous_class_values = NULL_TREE;\n   processing_specialization = 0;\n   processing_explicit_instantiation = 0;\n-  if (!pseudo)\n-    {\n-      current_template_parms = NULL_TREE;\n-      processing_template_decl = 0;\n-    }\n+  current_template_parms = NULL_TREE;\n+  processing_template_decl = 0;\n \n   s->prev = current_saved_scope;\n   s->old_bindings = old_bindings;\n@@ -2228,38 +2225,26 @@ pushtag (name, type, globalize)\n \n \t  if (IS_AGGR_TYPE (type)\n \t      && (/* If !GLOBALIZE then we are looking at a\n-\t\t     definition.  */\n+\t\t     definition.  It may not be a primary template.\n+\t\t     (For example, in:\n+\t\t  \n+\t\t       template <class T>\n+\t\t       struct S1 { class S2 {}; }\n+\t\t  \n+\t\t     we have to push_template_decl for S2.)  */\n \t\t  (processing_template_decl && !globalize)\n-\t\t  /* This next condition is tricky.  If we are\n-\t\t     declaring a friend template class, we will have\n-\t\t     GLOBALIZE set, since something like:\n+\t\t  /* If we are declaring a friend template class, we\n+\t\t     will have GLOBALIZE set, since something like:\n \n \t\t       template <class T>\n \t\t       struct S1 {\n \t\t         template <class U>\n \t\t         friend class S2; \n \t\t       };\n \n-\t\t     declares S2 to be at global scope.  The condition\n-\t\t     says that we are looking at a primary template\n-\t\t     that is being declared in class scope.  We can't\n-\t\t     just drop the `in class scope' and then not check\n-\t\t     GLOBALIZE either since on this code:\n-\t\t  \n-\t\t       template <class T>\n-\t\t       struct S1 {};\n-\t\t       template <class T>\n-\t\t       struct S2 { S1<T> f(); } \n-\n-\t\t     we get called by lookup_template_class (with TYPE\n-\t\t     set to S1<T> and GLOBALIZE set to 1).  However,\n-\t\t     lookup_template_class calls\n-\t\t     maybe_push_to_top_level which doesn't clear\n-\t\t     processing_template_decl, so we would then\n-\t\t     incorrectly call push_template_decl.  */\n-\t\t  || (current_class_type != NULL_TREE\n-\t\t      && (processing_template_decl > \n-\t\t\t  template_class_depth (current_class_type)))))\n+\t\t     declares S2 to be at global scope.  */\n+\t\t  || (processing_template_decl > \n+\t\t      template_class_depth (current_class_type))))\n \t    {\n \t      d = push_template_decl_real (d, globalize);\n \t      /* If the current binding level is the binding level for"}]}