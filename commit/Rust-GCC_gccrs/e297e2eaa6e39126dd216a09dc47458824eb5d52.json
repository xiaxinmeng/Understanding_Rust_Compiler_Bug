{"sha": "e297e2eaa6e39126dd216a09dc47458824eb5d52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI5N2UyZWFhNmUzOTEyNmRkMjE2YTA5ZGM0NzQ1ODgyNGViNWQ1Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-04-15T09:23:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-04-15T09:23:21Z"}, "message": "decl.c (gnat_to_gnu_entity): Create a mere scalar constant instead of a reference for renaming of scalar literal.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Create a mere\n\tscalar constant instead of a reference for renaming of scalar literal.\n\tDo not create a new object for constant renaming except for a function\n\tcall.  Make sure a VAR_DECL is created for the renaming pointer.\n\t* gcc-interface/trans.c (constant_decl_with_initializer_p): New.\n\t(fold_constant_decl_in_expr): New function.\n\t(Identifier_to_gnu): Use constant_decl_with_initializer_p.\n\tFor a constant renaming, try to fold a constant DECL in the result.\n\t(lvalue_required_p) <N_Object_Renaming_Declaration>: Always return 1.\n\t(Identifier_to_gnu): Reference the renamed object of constant renaming\n\tpointers directly.\n\t(Case_Statement_to_gnu): Do not re-fold the bounds of integer types.\n\tAssert that the case values are constant.\n\t* gcc-interface/utils.c (invalidate_global_renaming_pointers): Do not\n\tinvalidate constant renaming pointers.\n\nCo-Authored-By: Pierre-Marie de Rodat <derodat@adacore.com>\n\nFrom-SVN: r209411", "tree": {"sha": "017986e6c0b887f1af51a9d79ce4f4dce42907d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/017986e6c0b887f1af51a9d79ce4f4dce42907d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e297e2eaa6e39126dd216a09dc47458824eb5d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e297e2eaa6e39126dd216a09dc47458824eb5d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e297e2eaa6e39126dd216a09dc47458824eb5d52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e297e2eaa6e39126dd216a09dc47458824eb5d52/comments", "author": null, "committer": null, "parents": [{"sha": "e63b36bda5085924a07cb2c57788e0e7e72c6272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63b36bda5085924a07cb2c57788e0e7e72c6272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63b36bda5085924a07cb2c57788e0e7e72c6272"}], "stats": {"total": 320, "additions": 198, "deletions": 122}, "files": [{"sha": "090f121e20c96262a873a6aa6afc932de642ca13", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e297e2eaa6e39126dd216a09dc47458824eb5d52", "patch": "@@ -1,3 +1,22 @@\n+2014-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+            Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Create a mere\n+\tscalar constant instead of a reference for renaming of scalar literal.\n+\tDo not create a new object for constant renaming except for a function\n+\tcall.  Make sure a VAR_DECL is created for the renaming pointer.\n+\t* gcc-interface/trans.c (constant_decl_with_initializer_p): New.\n+\t(fold_constant_decl_in_expr): New function.\n+\t(Identifier_to_gnu): Use constant_decl_with_initializer_p.\n+\tFor a constant renaming, try to fold a constant DECL in the result.\n+\t(lvalue_required_p) <N_Object_Renaming_Declaration>: Always return 1.\n+\t(Identifier_to_gnu): Reference the renamed object of constant renaming\n+\tpointers directly.\n+\t(Case_Statement_to_gnu): Do not re-fold the bounds of integer types.\n+\tAssert that the case values are constant.\n+\t* gcc-interface/utils.c (invalidate_global_renaming_pointers): Do not\n+\tinvalidate constant renaming pointers.\n+\n 2014-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (type_for_vector_element_p): New predicate."}, {"sha": "7c3f7e5ea7bd472312ae3bff38d6825446e22bd9", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 64, "deletions": 79, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=e297e2eaa6e39126dd216a09dc47458824eb5d52", "patch": "@@ -960,18 +960,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_type = TREE_TYPE (gnu_expr);\n \n \t    /* Case 1: If this is a constant renaming stemming from a function\n-\t       call, treat it as a normal object whose initial value is what\n-\t       is being renamed.  RM 3.3 says that the result of evaluating a\n-\t       function call is a constant object.  As a consequence, it can\n-\t       be the inner object of a constant renaming.  In this case, the\n-\t       renaming must be fully instantiated, i.e. it cannot be a mere\n-\t       reference to (part of) an existing object.  */\n+\t       call, treat it as a normal object whose initial value is what is\n+\t       being renamed.  RM 3.3 says that the result of evaluating a\n+\t       function call is a constant object.  Treat constant literals\n+\t       the same way.  As a consequence, it can be the inner object of\n+\t       a constant renaming.  In this case, the renaming must be fully\n+\t       instantiated, i.e. it cannot be a mere reference to (part of) an\n+\t       existing object.  */\n \t    if (const_flag)\n \t      {\n \t        tree inner_object = gnu_expr;\n \t\twhile (handled_component_p (inner_object))\n \t\t  inner_object = TREE_OPERAND (inner_object, 0);\n-\t\tif (TREE_CODE (inner_object) == CALL_EXPR)\n+\t\tif (TREE_CODE (inner_object) == CALL_EXPR\n+\t\t    || CONSTANT_CLASS_P (inner_object))\n \t\t  create_normal_object = true;\n \t      }\n \n@@ -1030,15 +1032,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       about that failure.  */\n \t\t  }\n \n-\t\t/* Case 3: If this is a constant renaming and creating a\n-\t\t   new object is allowed and cheap, treat it as a normal\n-\t\t   object whose initial value is what is being renamed.  */\n-\t\tif (const_flag\n-\t\t    && !Is_Composite_Type\n-\t\t        (Underlying_Type (Etype (gnat_entity))))\n-\t\t  ;\n-\n-\t\t/* Case 4: Make this into a constant pointer to the object we\n+\t\t/* Case 3: Make this into a constant pointer to the object we\n \t\t   are to rename and attach the object to the pointer if it is\n \t\t   something we can stabilize.\n \n@@ -1050,68 +1044,59 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   The pointer is called a \"renaming\" pointer in this case.\n \n \t\t   In the rare cases where we cannot stabilize the renamed\n-\t\t   object, we just make a \"bare\" pointer, and the renamed\n-\t\t   entity is always accessed indirectly through it.  */\n-\t\telse\n-\t\t  {\n-\t\t    /* We need to preserve the volatileness of the renamed\n-\t\t       object through the indirection.  */\n-\t\t    if (TREE_THIS_VOLATILE (gnu_expr)\n-\t\t\t&& !TYPE_VOLATILE (gnu_type))\n-\t\t      gnu_type\n-\t\t\t= build_qualified_type (gnu_type,\n-\t\t\t\t\t\t(TYPE_QUALS (gnu_type)\n-\t\t\t\t\t\t | TYPE_QUAL_VOLATILE));\n-\t\t    gnu_type = build_reference_type (gnu_type);\n-\t\t    inner_const_flag = TREE_READONLY (gnu_expr);\n-\t\t    const_flag = true;\n-\n-\t\t    /* If the previous attempt at stabilizing failed, there\n-\t\t       is no point in trying again and we reuse the result\n-\t\t       without attaching it to the pointer.  In this case it\n-\t\t       will only be used as the initializing expression of\n-\t\t       the pointer and thus needs no special treatment with\n-\t\t       regard to multiple evaluations.  */\n-\t\t    if (maybe_stable_expr)\n-\t\t      ;\n-\n-\t\t    /* Otherwise, try to stabilize and attach the expression\n-\t\t       to the pointer if the stabilization succeeds.\n-\n-\t\t       Note that this might introduce SAVE_EXPRs and we don't\n-\t\t       check whether we're at the global level or not.  This\n-\t\t       is fine since we are building a pointer initializer and\n-\t\t       neither the pointer nor the initializing expression can\n-\t\t       be accessed before the pointer elaboration has taken\n-\t\t       place in a correct program.\n-\n-\t\t       These SAVE_EXPRs will be evaluated at the right place\n-\t\t       by either the evaluation of the initializer for the\n-\t\t       non-global case or the elaboration code for the global\n-\t\t       case, and will be attached to the elaboration procedure\n-\t\t       in the latter case.  */\n-\t\t    else\n-\t \t     {\n-\t\t\tmaybe_stable_expr\n-\t\t\t  = gnat_stabilize_reference (gnu_expr, true, &stable);\n+\t\t   object, we just make a \"bare\" pointer and the renamed\n+\t\t   object will always be accessed indirectly through it.\n+\n+\t\t   Note that we need to preserve the volatility of the renamed\n+\t\t   object through the indirection.  */\n+\t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n+\t\t  gnu_type = build_qualified_type (gnu_type,\n+\t\t\t\t\t\t   (TYPE_QUALS (gnu_type)\n+\t\t\t\t\t\t    | TYPE_QUAL_VOLATILE));\n+\t\tgnu_type = build_reference_type (gnu_type);\n+\t\tinner_const_flag = TREE_READONLY (gnu_expr);\n+\t\tconst_flag = true;\n \n-\t\t\tif (stable)\n-\t\t\t  renamed_obj = maybe_stable_expr;\n+\t\t/* If the previous attempt at stabilizing failed, there is\n+\t\t   no point in trying again and we reuse the result without\n+\t\t   attaching it to the pointer.  In this case it will only\n+\t\t   be used as the initializing expression of the pointer and\n+\t\t   thus needs no special treatment with regard to multiple\n+\t\t   evaluations.\n+\n+\t\t   Otherwise, try to stabilize and attach the expression to\n+\t\t   the pointer if the stabilization succeeds.\n+\n+\t\t   Note that this might introduce SAVE_EXPRs and we don't\n+\t\t   check whether we are at the global level or not.  This\n+\t\t   is fine since we are building a pointer initializer and\n+\t\t   neither the pointer nor the initializing expression can\n+\t\t   be accessed before the pointer elaboration has taken\n+\t\t   place in a correct program.\n+\n+\t\t   These SAVE_EXPRs will be evaluated at the right place\n+\t\t   by either the evaluation of the initializer for the\n+\t\t   non-global case or the elaboration code for the global\n+\t\t   case, and will be attached to the elaboration procedure\n+\t\t   in the latter case.  */\n+\t\tif (!maybe_stable_expr)\n+\t\t  {\n+\t\t    maybe_stable_expr\n+\t\t      = gnat_stabilize_reference (gnu_expr, true, &stable);\n \n-\t\t\t/* Attaching is actually performed downstream, as soon\n-\t\t\t   as we have a VAR_DECL for the pointer we make.  */\n-\t\t      }\n+\t\t    if (stable)\n+\t\t      renamed_obj = maybe_stable_expr;\n+\t\t  }\n \n-\t\t    if (type_annotate_only\n- \t\t\t&& TREE_CODE (maybe_stable_expr) == ERROR_MARK)\n-\t\t      gnu_expr = NULL_TREE;\n-\t\t    else\n-\t\t      gnu_expr = build_unary_op (ADDR_EXPR, gnu_type,\n-\t\t\t\t\t\t maybe_stable_expr);\n+\t\tif (type_annotate_only\n+ \t\t    && TREE_CODE (maybe_stable_expr) == ERROR_MARK)\n+\t\t  gnu_expr = NULL_TREE;\n+\t\telse\n+\t\t  gnu_expr\n+\t\t    = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n \n-\t\t    gnu_size = NULL_TREE;\n-\t\t    used_by_ref = true;\n-\t\t  }\n+\t\tgnu_size = NULL_TREE;\n+\t\tused_by_ref = true;\n \t      }\n \t  }\n \n@@ -1483,10 +1468,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Now create the variable or the constant and set various flags.  */\n \tgnu_decl\n-\t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t     gnu_expr, const_flag, Is_Public (gnat_entity),\n-\t\t\t     imported_p || !definition, static_p, attr_list,\n-\t\t\t     gnat_entity);\n+\t  = create_var_decl_1 (gnu_entity_name, gnu_ext_name, gnu_type,\n+\t\t\t       gnu_expr, const_flag, Is_Public (gnat_entity),\n+\t\t\t       imported_p || !definition, static_p,\n+\t\t\t       !renamed_obj, attr_list, gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -1517,7 +1502,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If this is a renaming pointer, attach the renamed object to it and\n \t   register it if we are at the global level.  Note that an external\n \t   constant is at the global level.  */\n-\tif (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n+\tif (renamed_obj)\n \t  {\n \t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n \t    if ((!definition && kind == E_Constant) || global_bindings_p ())"}, {"sha": "ae7a2efc62662e6acec8a55edf99ae741735dc3b", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 109, "deletions": 41, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=e297e2eaa6e39126dd216a09dc47458824eb5d52", "patch": "@@ -898,17 +898,8 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t\t\t\taddress_of_constant, aliased);\n \n     case N_Object_Renaming_Declaration:\n-      /* We need to make a real renaming only if the constant object is\n-\t aliased or if we may use a renaming pointer; otherwise we can\n-\t optimize and return the rvalue.  We make an exception if the object\n-\t is an identifier since in this case the rvalue can be propagated\n-\t attached to the CONST_DECL.  */\n-      return (!constant\n-\t      || aliased\n-\t      /* This should match the constant case of the renaming code.  */\n-\t      || Is_Composite_Type\n-\t\t (Underlying_Type (Etype (Name (gnat_parent))))\n-\t      || Nkind (Name (gnat_parent)) == N_Identifier);\n+      /* We need to preserve addresses through a renaming.  */\n+      return 1;\n \n     case N_Object_Declaration:\n       /* We cannot use a constructor if this is an atomic object because\n@@ -968,6 +959,77 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n   gcc_unreachable ();\n }\n \n+/* Return true if T is a constant DECL node that can be safely replaced\n+   by its initializer.  */\n+\n+static bool\n+constant_decl_with_initializer_p (tree t)\n+{\n+  if (!TREE_CONSTANT (t) || !DECL_P (t) || !DECL_INITIAL (t))\n+    return false;\n+\n+  /* Return false for aggregate types that contain a placeholder since\n+     their initializers cannot be manipulated easily.  */\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n+      && !TYPE_IS_FAT_POINTER_P (TREE_TYPE (t))\n+      && type_contains_placeholder_p (TREE_TYPE (t)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return an expression equivalent to EXP but where constant DECL nodes\n+   have been replaced by their initializer.  */\n+\n+static tree\n+fold_constant_decl_in_expr (tree exp)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  tree op0;\n+\n+  switch (code)\n+    {\n+    case CONST_DECL:\n+    case VAR_DECL:\n+      if (!constant_decl_with_initializer_p (exp))\n+\treturn exp;\n+\n+      return DECL_INITIAL (exp);\n+\n+    case BIT_FIELD_REF:\n+    case COMPONENT_REF:\n+      op0 = fold_constant_decl_in_expr (TREE_OPERAND (exp, 0));\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      return fold_build3 (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1),\n+\t\t\t  TREE_OPERAND (exp, 2));\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      op0 = fold_constant_decl_in_expr (TREE_OPERAND (exp, 0));\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      return fold (build4 (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1),\n+\t\t\t   TREE_OPERAND (exp, 2), TREE_OPERAND (exp, 3)));\n+\n+    case VIEW_CONVERT_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      op0 = fold_constant_decl_in_expr (TREE_OPERAND (exp, 0));\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      return fold_build1 (code, TREE_TYPE (exp), op0);\n+\n+    default:\n+      return exp;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Identifier,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer\n    to where we should place the result type.  */\n@@ -1112,13 +1174,16 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t\t\t  true, false)))\n \tgnu_result = DECL_INITIAL (gnu_result);\n \n-      /* If it's a renaming pointer and we are at the right binding level,\n-\t we can reference the renamed object directly, since the renamed\n-\t expression has been protected against multiple evaluations.  */\n+      /* If it's a renaming pointer and, either the renamed object is constant\n+\t or we are at the right binding level, we can reference the renamed\n+\t object directly, since it is constant or has been protected against\n+\t multiple evaluations.  */\n       if (TREE_CODE (gnu_result) == VAR_DECL\n           && !DECL_LOOP_PARM_P (gnu_result)\n \t  && DECL_RENAMED_OBJECT (gnu_result)\n-\t  && (!DECL_RENAMING_GLOBAL_P (gnu_result) || global_bindings_p ()))\n+\t  && (TREE_CONSTANT (DECL_RENAMED_OBJECT (gnu_result))\n+\t      || !DECL_RENAMING_GLOBAL_P (gnu_result)\n+\t      || global_bindings_p ()))\n \tgnu_result = DECL_RENAMED_OBJECT (gnu_result);\n \n       /* Otherwise, do the final dereference.  */\n@@ -1138,15 +1203,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \n   /* If we have a constant declaration and its initializer, try to return the\n      latter to avoid the need to call fold in lots of places and the need for\n-     elaboration code if this identifier is used as an initializer itself.\n-     Don't do it for aggregate types that contain a placeholder since their\n-     initializers cannot be manipulated easily.  */\n-  if (TREE_CONSTANT (gnu_result)\n-      && DECL_P (gnu_result)\n-      && DECL_INITIAL (gnu_result)\n-      && !(AGGREGATE_TYPE_P (TREE_TYPE (gnu_result))\n-\t   && !TYPE_IS_FAT_POINTER_P (TREE_TYPE (gnu_result))\n-\t   && type_contains_placeholder_p (TREE_TYPE (gnu_result))))\n+     elaboration code if this identifier is used as an initializer itself.  */\n+  if (constant_decl_with_initializer_p (gnu_result))\n     {\n       bool constant_only = (TREE_CODE (gnu_result) == CONST_DECL\n \t\t\t    && !DECL_CONST_CORRESPONDING_VAR (gnu_result));\n@@ -1166,6 +1224,21 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \tgnu_result = DECL_INITIAL (gnu_result);\n     }\n \n+  /* But for a constant renaming we couldn't do that incrementally for its\n+     definition because of the need to return an lvalue so, if the present\n+     context doesn't itself require an lvalue, we try again here.  */\n+  else if (Ekind (gnat_temp) == E_Constant\n+\t   && Is_Elementary_Type (gnat_temp_type)\n+\t   && Present (Renamed_Object (gnat_temp)))\n+    {\n+      if (require_lvalue < 0)\n+\trequire_lvalue\n+\t  = lvalue_required_p (gnat_node, gnu_result_type, true, false,\n+\t\t\t       Is_Aliased (gnat_temp));\n+      if (!require_lvalue)\n+\tgnu_result = fold_constant_decl_in_expr (gnu_result);\n+    }\n+\n   /* The GNAT tree has the type of a function set to its result type, so we\n      adjust here.  Also use the type of the result if the Etype is a subtype\n      that is nominally unconstrained.  Likewise if this is a deferred constant\n@@ -2327,9 +2400,11 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n       /* First compile all the different case choices for the current WHEN\n \t alternative.  */\n       for (gnat_choice = First (Discrete_Choices (gnat_when));\n-\t   Present (gnat_choice); gnat_choice = Next (gnat_choice))\n+\t   Present (gnat_choice);\n+\t   gnat_choice = Next (gnat_choice))\n \t{\n \t  tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n+\t  tree label = create_artificial_label (input_location);\n \n \t  switch (Nkind (gnat_choice))\n \t    {\n@@ -2353,8 +2428,8 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t\t{\n \t\t  tree gnu_type = get_unpadded_type (Entity (gnat_choice));\n \n-\t\t  gnu_low = fold (TYPE_MIN_VALUE (gnu_type));\n-\t\t  gnu_high = fold (TYPE_MAX_VALUE (gnu_type));\n+\t\t  gnu_low = TYPE_MIN_VALUE (gnu_type);\n+\t\t  gnu_high = TYPE_MAX_VALUE (gnu_type);\n \t\t  break;\n \t\t}\n \n@@ -2372,20 +2447,13 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t      gcc_unreachable ();\n \t    }\n \n-\t  /* If the case value is a subtype that raises Constraint_Error at\n-\t     run time because of a wrong bound, then gnu_low or gnu_high is\n-\t     not translated into an INTEGER_CST.  In such a case, we need\n-\t     to ensure that the when statement is not added in the tree,\n-\t     otherwise it will crash the gimplifier.  */\n-\t  if ((!gnu_low || TREE_CODE (gnu_low) == INTEGER_CST)\n-\t      && (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST))\n-\t    {\n-\t      add_stmt_with_node (build_case_label\n-\t\t\t\t  (gnu_low, gnu_high,\n-\t\t\t\t   create_artificial_label (input_location)),\n-\t\t\t\t  gnat_choice);\n-\t      choices_added_p = true;\n-\t    }\n+\t  /* Everything should be folded into constants at this point.  */\n+\t  gcc_assert (!gnu_low  || TREE_CODE (gnu_low)  == INTEGER_CST);\n+\t  gcc_assert (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST);\n+\n+\t  add_stmt_with_node (build_case_label (gnu_low, gnu_high, label),\n+\t\t\t      gnat_choice);\n+\t  choices_added_p = true;\n \t}\n \n       /* This construct doesn't define a scope so we shouldn't push a binding"}, {"sha": "4814f9aeff2ed53775a0f46f8e2acf1db289a25f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297e2eaa6e39126dd216a09dc47458824eb5d52/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e297e2eaa6e39126dd216a09dc47458824eb5d52", "patch": "@@ -2514,7 +2514,10 @@ record_global_renaming_pointer (tree decl)\n   vec_safe_push (global_renaming_pointers, decl);\n }\n \n-/* Invalidate the global renaming pointers.   */\n+/* Invalidate the global renaming pointers that are not constant, lest their\n+   renamed object contains SAVE_EXPRs tied to an elaboration routine.  Note\n+   that we should not blindly invalidate everything here because of the need\n+   to propagate constant values through renaming.  */\n \n void\n invalidate_global_renaming_pointers (void)\n@@ -2526,7 +2529,8 @@ invalidate_global_renaming_pointers (void)\n     return;\n \n   FOR_EACH_VEC_ELT (*global_renaming_pointers, i, iter)\n-    SET_DECL_RENAMED_OBJECT (iter, NULL_TREE);\n+    if (!TREE_CONSTANT (DECL_RENAMED_OBJECT (iter)))\n+      SET_DECL_RENAMED_OBJECT (iter, NULL_TREE);\n \n   vec_free (global_renaming_pointers);\n }"}]}