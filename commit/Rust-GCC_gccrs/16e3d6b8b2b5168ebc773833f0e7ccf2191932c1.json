{"sha": "16e3d6b8b2b5168ebc773833f0e7ccf2191932c1", "node_id": "C_kwDOANBUbNoAKDE2ZTNkNmI4YjJiNTE2OGViYzc3MzgzM2YwZTdjY2YyMTkxOTMyYzE", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-09-23T12:35:42Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-09-23T12:40:34Z"}, "message": "rs6000: Add psabi diagnostic for C++ zero-width bit field ABI change\n\nPreviously zero-width bit fields were removed from structs, so that otherwise\nhomogeneous aggregates were treated as such and\tpassed in FPRs and VSRs.\nThis was incorrect behavior per\tthe ELFv2 ABI.\tNow that these fields are no\nlonger being removed, we generate the correct parameter\tpassing\tcode.  Alert\nthe unwary user\tin the rare cases where\tthis behavior changes.\n\n2021-09-23  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\tPR target/102024\n\t* config/rs6000/rs6000-call.c (rs6000_aggregate_candidate): Detect\n\tzero-width bit fields and return indicator.\n\t(rs6000_discover_homogeneous_aggregate): Diagnose when the\n\tpresence of a zero-width bit field changes parameter passing in\n\tGCC 12.\n\ngcc/testsuite/\n\tPR target/102024\n\t* g++.target/powerpc/pr102024.C: New.", "tree": {"sha": "ace3890d9b8d93efe6710561fecae58d8e7d1721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ace3890d9b8d93efe6710561fecae58d8e7d1721"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1/comments", "author": null, "committer": null, "parents": [{"sha": "00446916206cbf9812a92b418090919515289a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00446916206cbf9812a92b418090919515289a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00446916206cbf9812a92b418090919515289a20"}], "stats": {"total": 87, "additions": 81, "deletions": 6}, "files": [{"sha": "2eceb2c71c08c6695ca7e46f050d7e85433075bb", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=16e3d6b8b2b5168ebc773833f0e7ccf2191932c1", "patch": "@@ -6223,11 +6223,19 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n    or vector type.  If a non-floating point or vector type is found, or\n    if a floating point or vector type that doesn't match a non-VOIDmode\n    *MODEP is found, then return -1, otherwise return the count in the\n-   sub-tree.  */\n+   sub-tree.\n+\n+   There have been some ABI snafus along the way with C++.  Modify\n+   EMPTY_BASE_SEEN to a nonzero value iff a C++ empty base class makes\n+   an appearance; separate flag bits indicate whether or not such a\n+   field is marked \"no unique address\".  Modify ZERO_WIDTH_BF_SEEN\n+   to 1 iff a C++ zero-length bitfield makes an appearance, but\n+   in this case otherwise treat this as still being a homogeneous\n+   aggregate.  */\n \n static int\n rs6000_aggregate_candidate (const_tree type, machine_mode *modep,\n-\t\t\t    int *empty_base_seen)\n+\t\t\t    int *empty_base_seen, int *zero_width_bf_seen)\n {\n   machine_mode mode;\n   HOST_WIDE_INT size;\n@@ -6298,7 +6306,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep,\n \t  return -1;\n \n \tcount = rs6000_aggregate_candidate (TREE_TYPE (type), modep,\n-\t\t\t\t\t    empty_base_seen);\n+\t\t\t\t\t    empty_base_seen,\n+\t\t\t\t\t    zero_width_bf_seen);\n \tif (count == -1\n \t    || !index\n \t    || !TYPE_MAX_VALUE (index)\n@@ -6336,6 +6345,26 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep,\n \t    if (TREE_CODE (field) != FIELD_DECL)\n \t      continue;\n \n+\t    if (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field))\n+\t      {\n+\t\t/* GCC 11 and earlier generated incorrect code in a rare\n+\t\t   corner case for C++.  When a RECORD_TYPE looks like a\n+\t\t   homogeneous aggregate, except that it also contains\n+\t\t   one or more zero-width bit fields, these earlier\n+\t\t   compilers would incorrectly pass the fields in FPRs\n+\t\t   or VSRs.  This occurred because the front end wrongly\n+\t\t   removed these bitfields from the RECORD_TYPE.  In\n+\t\t   GCC 12 and later, the front end flaw was corrected.\n+\t\t   We want to diagnose this case.  To do this, we pretend\n+\t\t   that we don't see the zero-width bit fields (hence\n+\t\t   the continue statement here), but pass back a flag\n+\t\t   indicating what happened.  The caller then diagnoses\n+\t\t   the issue and rejects the RECORD_TYPE as a homogeneous\n+\t\t   aggregate.  */\n+\t\t*zero_width_bf_seen = 1;\n+\t\tcontinue;\n+\t      }\n+\n \t    if (DECL_FIELD_ABI_IGNORED (field))\n \t      {\n \t\tif (lookup_attribute (\"no_unique_address\",\n@@ -6347,7 +6376,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep,\n \t      }\n \n \t    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep,\n-\t\t\t\t\t\t    empty_base_seen);\n+\t\t\t\t\t\t    empty_base_seen,\n+\t\t\t\t\t\t    zero_width_bf_seen);\n \t    if (sub_count < 0)\n \t      return -1;\n \t    count += sub_count;\n@@ -6381,7 +6411,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep,\n \t      continue;\n \n \t    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep,\n-\t\t\t\t\t\t    empty_base_seen);\n+\t\t\t\t\t\t    empty_base_seen,\n+\t\t\t\t\t\t    zero_width_bf_seen);\n \t    if (sub_count < 0)\n \t      return -1;\n \t    count = count > sub_count ? count : sub_count;\n@@ -6423,8 +6454,10 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,\n     {\n       machine_mode field_mode = VOIDmode;\n       int empty_base_seen = 0;\n+      int zero_width_bf_seen = 0;\n       int field_count = rs6000_aggregate_candidate (type, &field_mode,\n-\t\t\t\t\t\t    &empty_base_seen);\n+\t\t\t\t\t\t    &empty_base_seen,\n+\t\t\t\t\t\t    &zero_width_bf_seen);\n \n       if (field_count > 0)\n \t{\n@@ -6460,6 +6493,25 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,\n \t\t      last_reported_type_uid = uid;\n \t\t    }\n \t\t}\n+\t      if (zero_width_bf_seen && warn_psabi)\n+\t\t{\n+\t\t  static unsigned last_reported_type_uid;\n+\t\t  unsigned uid = TYPE_UID (TYPE_MAIN_VARIANT (type));\n+\t\t  if (uid != last_reported_type_uid)\n+\t\t    {\n+\t\t      inform (input_location,\n+\t\t\t      \"ELFv2 parameter passing for an argument \"\n+\t\t\t      \"containing zero-width bit fields but that is \"\n+\t\t\t      \"otherwise a homogeneous aggregate was \"\n+\t\t\t      \"corrected in GCC 12\");\n+\t\t      last_reported_type_uid = uid;\n+\t\t    }\n+\t\t  if (elt_mode)\n+\t\t    *elt_mode = mode;\n+\t\t  if (n_elts)\n+\t\t    *n_elts = 1;\n+\t\t  return false;\n+\t\t}\n \t      return true;\n \t    }\n \t}"}, {"sha": "769585052b507ad971868795f861106230c976e3", "filename": "gcc/testsuite/g++.target/powerpc/pr102024.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr102024.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e3d6b8b2b5168ebc773833f0e7ccf2191932c1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr102024.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr102024.C?ref=16e3d6b8b2b5168ebc773833f0e7ccf2191932c1", "patch": "@@ -0,0 +1,23 @@\n+// PR target/102024\n+// { dg-do compile { target powerpc_elfv2 } }\n+// { dg-options \"-O2\" }\n+\n+// Test that a zero-width bit field in an otherwise homogeneous aggregate\n+// generates a psabi warning and passes arguments in GPRs.\n+\n+// { dg-final { scan-assembler-times {\\mstd\\M} 4 } }\n+\n+struct a_thing\n+{\n+  double x;\n+  double y;\n+  double z;\n+  int : 0;\n+  double w;\n+};\n+\n+double\n+foo (a_thing a) // { dg-message \"ELFv2 parameter passing for an argument containing zero-width bit fields but that is otherwise a homogeneous aggregate was corrected in GCC 12\" }\n+{\n+  return a.x * a.y + a.z - a.w;\n+}"}]}