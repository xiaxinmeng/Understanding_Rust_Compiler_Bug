{"sha": "654187d05376f08667c8ba88309073e0345431c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU0MTg3ZDA1Mzc2ZjA4NjY3YzhiYTg4MzA5MDczZTAzNDU0MzFjMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-17T13:43:30Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-17T13:43:30Z"}, "message": "Fortran: Prefer GCC internal macros to float.h in ISO_Fortran_binding.h.\n\n2021-09-17  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Tobias Burnus  <tobias@codesourcery.com>\n\nlibgfortran/\n\t* ISO_Fortran_binding.h: Only include float.h if the C compiler\n\tdoesn't have predefined __LDBL_* and __DBL_* macros. Handle\n\tLDBL_MANT_DIG == 53 for FreeBSD.", "tree": {"sha": "93c13ebe158c2b149c274a69dcad9bd872c22fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93c13ebe158c2b149c274a69dcad9bd872c22fdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/654187d05376f08667c8ba88309073e0345431c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/654187d05376f08667c8ba88309073e0345431c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/654187d05376f08667c8ba88309073e0345431c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/654187d05376f08667c8ba88309073e0345431c2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8593d2fcbb86a5a9102bbdfd36b88e184fc53258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8593d2fcbb86a5a9102bbdfd36b88e184fc53258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8593d2fcbb86a5a9102bbdfd36b88e184fc53258"}], "stats": {"total": 75, "additions": 58, "deletions": 17}, "files": [{"sha": "50b02d27c9c21b77ba766ec04a2dcd5ffc39b919", "filename": "libgfortran/ISO_Fortran_binding.h", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/654187d05376f08667c8ba88309073e0345431c2/libgfortran%2FISO_Fortran_binding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/654187d05376f08667c8ba88309073e0345431c2/libgfortran%2FISO_Fortran_binding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FISO_Fortran_binding.h?ref=654187d05376f08667c8ba88309073e0345431c2", "patch": "@@ -32,7 +32,6 @@ extern \"C\" {\n \n #include <stddef.h>  /* Standard ptrdiff_t tand size_t. */\n #include <stdint.h>  /* Integer types. */\n-#include <float.h>  /* Macros for floating-point type characteristics.  */\n \n /* Constants, defined as macros. */\n #define CFI_VERSION 1\n@@ -217,40 +216,82 @@ extern int CFI_setpointer (CFI_cdesc_t *, CFI_cdesc_t *, const CFI_index_t []);\n #endif\n \n /* The situation with long double support is more complicated; we need to\n-   examine the type in more detail to figure out its kind.  */\n+   examine the type in more detail to figure out its kind.\n+   GCC and some other compilers predefine the __LDBL* macros; otherwise\n+   get the parameters we need from float.h.  */\n+\n+#if (defined (__LDBL_MANT_DIG__) \\\n+     && defined (__LDBL_MIN_EXP__) \\\n+     && defined (__LDBL_MAX_EXP__) \\\n+     && defined (__DBL_MANT_DIG__) \\\n+     && defined (__DBL_MIN_EXP__) \\\n+     && defined (__DBL_MAX_EXP__))\n+#define __CFI_LDBL_MANT_DIG__ __LDBL_MANT_DIG__\n+#define __CFI_LDBL_MIN_EXP__ __LDBL_MIN_EXP__\n+#define __CFI_LDBL_MAX_EXP__ __LDBL_MAX_EXP__\n+#define __CFI_DBL_MANT_DIG__ __DBL_MANT_DIG__\n+#define __CFI_DBL_MIN_EXP__ __DBL_MIN_EXP__\n+#define __CFI_DBL_MAX_EXP__ __DBL_MAX_EXP__\n+\n+#else\n+#include <float.h>\n+\n+#if (defined (LDBL_MANT_DIG) \\\n+     && defined (LDBL_MIN_EXP) \\\n+     && defined (LDBL_MAX_EXP) \\\n+     && defined (DBL_MANT_DIG) \\\n+     && defined (DBL_MIN_EXP) \\\n+     && defined (DBL_MAX_EXP))\n+#define __CFI_LDBL_MANT_DIG__ LDBL_MANT_DIG\n+#define __CFI_LDBL_MIN_EXP__ LDBL_MIN_EXP\n+#define __CFI_LDBL_MAX_EXP__ LDBL_MAX_EXP\n+#define __CFI_DBL_MANT_DIG__ DBL_MANT_DIG\n+#define __CFI_DBL_MIN_EXP__ DBL_MIN_EXP\n+#define __CFI_DBL_MAX_EXP__ DBL_MAX_EXP\n+\n+#else\n+#define CFI_no_long_double 1\n+\n+#endif  /* Definitions from float.h.  */\n+#endif  /* Definitions from compiler builtins.  */\n+\n+/* Can't determine anything about long double support?  */\n+#if (defined (CFI_no_long_double))\n+#define CFI_type_long_double -2\n+#define CFI_type_long_double_Complex -2\n \n /* Long double is the same kind as double.  */\n-#if (LDBL_MANT_DIG == DBL_MANT_DIG \\\n-     && LDBL_MIN_EXP == DBL_MIN_EXP \\\n-     && LDBL_MAX_EXP == DBL_MAX_EXP)\n+#elif (__CFI_LDBL_MANT_DIG__ == __CFI_DBL_MANT_DIG__ \\\n+     && __CFI_LDBL_MIN_EXP__ == __CFI_DBL_MIN_EXP__ \\\n+     && __CFI_LDBL_MAX_EXP__ == __CFI_DBL_MAX_EXP__)\n #define CFI_type_long_double CFI_type_double\n #define CFI_type_long_double_Complex CFI_type_double_Complex\n \n /* This is the 80-bit encoding on x86; Fortran assigns it kind 10.  */\n-#elif (LDBL_MANT_DIG == 64 \\\n-       && LDBL_MIN_EXP == -16381 \\\n-       && LDBL_MAX_EXP == 16384)\n+#elif ((__CFI_LDBL_MANT_DIG__ == 64 || __CFI_LDBL_MANT_DIG__ == 53) \\\n+       && __CFI_LDBL_MIN_EXP__ == -16381 \\\n+       && __CFI_LDBL_MAX_EXP__ == 16384)\n #define CFI_type_long_double (CFI_type_Real + (10 << CFI_type_kind_shift))\n #define CFI_type_long_double_Complex (CFI_type_Complex + (10 << CFI_type_kind_shift))\n \n /* This is the 96-bit encoding on m68k; Fortran assigns it kind 10.  */\n-#elif (LDBL_MANT_DIG == 64 \\\n-       && LDBL_MIN_EXP == -16382 \\\n-       && LDBL_MAX_EXP == 16384)\n+#elif (__CFI_LDBL_MANT_DIG__ == 64 \\\n+       && __CFI_LDBL_MIN_EXP__ == -16382 \\\n+       && __CFI_LDBL_MAX_EXP__ == 16384)\n #define CFI_type_long_double (CFI_type_Real + (10 << CFI_type_kind_shift))\n #define CFI_type_long_double_Complex (CFI_type_Complex + (10 << CFI_type_kind_shift))\n \n /* This is the IEEE 128-bit encoding, same as float128.  */\n-#elif (LDBL_MANT_DIG == 113 \\\n-       && LDBL_MIN_EXP == -16381 \\\n-       && LDBL_MAX_EXP == 16384)\n+#elif (__CFI_LDBL_MANT_DIG__ == 113 \\\n+       && __CFI_LDBL_MIN_EXP__ == -16381 \\\n+       && __CFI_LDBL_MAX_EXP__ == 16384)\n #define CFI_type_long_double (CFI_type_Real + (16 << CFI_type_kind_shift))\n #define CFI_type_long_double_Complex (CFI_type_Complex + (16 << CFI_type_kind_shift))\n \n /* This is the IBM128 encoding used on PowerPC; also assigned kind 16.  */\n-#elif (LDBL_MANT_DIG == 106 \\\n-       && LDBL_MIN_EXP == -968 \\\n-       && LDBL_MAX_EXP == 1024)\n+#elif (__CFI_LDBL_MANT_DIG__ == 106 \\\n+       && __CFI_LDBL_MIN_EXP__ == -968 \\\n+       && __CFI_LDBL_MAX_EXP__ == 1024)\n #define CFI_type_long_double (CFI_type_Real + (16 << CFI_type_kind_shift))\n #define CFI_type_long_double_Complex (CFI_type_Complex + (16 << CFI_type_kind_shift))\n #define CFI_no_float128 1"}]}