{"sha": "5fa234669f3882aa2190c916df497259153412e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhMjM0NjY5ZjM4ODJhYTIxOTBjOTE2ZGY0OTcyNTkxNTM0MTJlNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-06-21T07:46:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-06-21T07:46:43Z"}, "message": "tree-data-ref.c (dr_step_indicator): Handle NULL DR_STEP.\n\n2018-06-21  Richard Biener  <rguenther@suse.de>\n\n\t* tree-data-ref.c (dr_step_indicator): Handle NULL DR_STEP.\n\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr):\n\tAvoid calling vect_mark_for_runtime_alias_test with gathers or scatters.\n\t(vect_analyze_data_ref_dependence): Re-order checks to deal with\n\tNULL DR_STEP.\n\t(vect_record_base_alignments): Do not record base alignment\n\tfor gathers or scatters.\n\t(vect_compute_data_ref_alignment): Drop return value that is always\n\ttrue.  Bail out early for gathers or scatters.\n\t(vect_enhance_data_refs_alignment): Bail out early for gathers\n\tor scatters.\n\t(vect_find_same_alignment_drs): Likewise.\n\t(vect_analyze_data_refs_alignment): Remove dead code.\n\t(vect_slp_analyze_and_verify_node_alignment): Likewise.\n\t(vect_analyze_data_refs): For possible gathers or scatters do\n\tnot create an alternate DR, just check their possible validity\n\tand mark them.  Adjust DECL_NONALIASED handling to not rely\n\ton DR_BASE_ADDRESS.\n\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): Do not\n\tupdate inits of gathers or scatters.\n\t* tree-vect-patterns.c (vect_recog_mask_conversion_pattern):\n\tAlso copy gather/scatter flag to pattern vinfo.\n\nFrom-SVN: r261834", "tree": {"sha": "23dd6ee895c84a78f946b78eef32ec8baef5b502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23dd6ee895c84a78f946b78eef32ec8baef5b502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fa234669f3882aa2190c916df497259153412e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa234669f3882aa2190c916df497259153412e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa234669f3882aa2190c916df497259153412e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa234669f3882aa2190c916df497259153412e4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ac6620a52ced600f617eb7018899f7a67cc6d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac6620a52ced600f617eb7018899f7a67cc6d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ac6620a52ced600f617eb7018899f7a67cc6d83"}], "stats": {"total": 183, "additions": 102, "deletions": 81}, "files": [{"sha": "d9fbc0c1c55aca7d1079e64af3bad660abcc80cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa234669f3882aa2190c916df497259153412e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa234669f3882aa2190c916df497259153412e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fa234669f3882aa2190c916df497259153412e4", "patch": "@@ -1,3 +1,28 @@\n+2018-06-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-data-ref.c (dr_step_indicator): Handle NULL DR_STEP.\n+\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr):\n+\tAvoid calling vect_mark_for_runtime_alias_test with gathers or scatters.\n+\t(vect_analyze_data_ref_dependence): Re-order checks to deal with\n+\tNULL DR_STEP.\n+\t(vect_record_base_alignments): Do not record base alignment\n+\tfor gathers or scatters.\n+\t(vect_compute_data_ref_alignment): Drop return value that is always\n+\ttrue.  Bail out early for gathers or scatters.\n+\t(vect_enhance_data_refs_alignment): Bail out early for gathers\n+\tor scatters.\n+\t(vect_find_same_alignment_drs): Likewise.\n+\t(vect_analyze_data_refs_alignment): Remove dead code.\n+\t(vect_slp_analyze_and_verify_node_alignment): Likewise.\n+\t(vect_analyze_data_refs): For possible gathers or scatters do\n+\tnot create an alternate DR, just check their possible validity\n+\tand mark them.  Adjust DECL_NONALIASED handling to not rely\n+\ton DR_BASE_ADDRESS.\n+\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): Do not\n+\tupdate inits of gathers or scatters.\n+\t* tree-vect-patterns.c (vect_recog_mask_conversion_pattern):\n+\tAlso copy gather/scatter flag to pattern vinfo.\n+\n 2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Change"}, {"sha": "b163eaf841d19d3b1ae12b662385220a703b6231", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5fa234669f3882aa2190c916df497259153412e4", "patch": "@@ -5454,6 +5454,8 @@ static tree\n dr_step_indicator (struct data_reference *dr, int useful_min)\n {\n   tree step = DR_STEP (dr);\n+  if (!step)\n+    return NULL_TREE;\n   STRIP_NOPS (step);\n   /* Look for cases where the step is scaled by a positive constant\n      integer, which will often be the access size.  If the multiplication"}, {"sha": "1ac37bf5001286f942a6df392ef17f67dcd46214", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 68, "deletions": 80, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=5fa234669f3882aa2190c916df497259153412e4", "patch": "@@ -267,7 +267,11 @@ vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \n \t     Note that the alias checks will be removed if the VF ends up\n \t     being small enough.  */\n-\t  return vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n+\t  return (!STMT_VINFO_GATHER_SCATTER_P\n+\t\t     (vinfo_for_stmt (DR_STMT (DDR_A (ddr))))\n+\t\t  && !STMT_VINFO_GATHER_SCATTER_P\n+\t\t        (vinfo_for_stmt (DR_STMT (DDR_B (ddr))))\n+\t\t  && vect_mark_for_runtime_alias_test (ddr, loop_vinfo));\n \t}\n     }\n   return true;\n@@ -479,15 +483,15 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  if (loop->safelen < 2)\n \t    {\n \t      tree indicator = dr_zero_step_indicator (dra);\n-\t      if (TREE_CODE (indicator) != INTEGER_CST)\n-\t\tvect_check_nonzero_value (loop_vinfo, indicator);\n-\t      else if (integer_zerop (indicator))\n+\t      if (!indicator || integer_zerop (indicator))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"access also has a zero step\\n\");\n \t\t  return true;\n \t\t}\n+\t      else if (TREE_CODE (indicator) != INTEGER_CST)\n+\t\tvect_check_nonzero_value (loop_vinfo, indicator);\n \t    }\n \t  continue;\n \t}\n@@ -832,19 +836,18 @@ vect_record_base_alignments (vec_info *vinfo)\n   FOR_EACH_VEC_ELT (vinfo->datarefs, i, dr)\n     {\n       gimple *stmt = vect_dr_stmt (dr);\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       if (!DR_IS_CONDITIONAL_IN_STMT (dr)\n-\t  && STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n+\t  && STMT_VINFO_VECTORIZABLE (stmt_info)\n+\t  && !STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n \t{\n \t  vect_record_base_alignment (vinfo, stmt, &DR_INNERMOST (dr));\n \n \t  /* If DR is nested in the loop that is being vectorized, we can also\n \t     record the alignment of the base wrt the outer loop.  */\n \t  if (loop && nested_in_vect_loop_p (loop, stmt))\n-\t    {\n-\t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t      vect_record_base_alignment\n-\t\t (vinfo, stmt, &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info));\n-\t    }\n+\t    vect_record_base_alignment\n+\t\t(vinfo, stmt, &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info));\n \t}\n     }\n }\n@@ -865,14 +868,12 @@ vect_calculate_target_alignment (struct data_reference *dr)\n    Compute the misalignment of the data reference DR.\n \n    Output:\n-   1. If during the misalignment computation it is found that the data reference\n-      cannot be vectorized then false is returned.\n-   2. DR_MISALIGNMENT (DR) is defined.\n+   1. DR_MISALIGNMENT (DR) is defined.\n \n    FOR NOW: No analysis is actually performed. Misalignment is calculated\n    only for trivial cases. TODO.  */\n \n-static bool\n+static void\n vect_compute_data_ref_alignment (struct data_reference *dr)\n {\n   gimple *stmt = vect_dr_stmt (dr);\n@@ -893,6 +894,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   /* Initialize misalignment to unknown.  */\n   SET_DR_MISALIGNMENT (dr, DR_MISALIGNMENT_UNKNOWN);\n \n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    return;\n+\n   innermost_loop_behavior *drb = vect_dr_behavior (dr);\n   bool step_preserves_misalignment_p;\n \n@@ -970,7 +974,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n \t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t}\n-      return true;\n+      return;\n     }\n \n   if (base_alignment < vector_alignment)\n@@ -988,7 +992,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n \t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n-\t  return true;\n+\t  return;\n \t}\n \n       /* Force the alignment of the decl.\n@@ -1027,7 +1031,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n \t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t}\n-      return true;\n+      return;\n     }\n \n   SET_DR_MISALIGNMENT (dr, const_misalignment);\n@@ -1040,7 +1044,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n     }\n \n-  return true;\n+  return;\n }\n \n /* Function vect_update_misalignment_for_peel.\n@@ -1733,8 +1737,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n         continue;\n \n-      /* For invariant accesses there is nothing to enhance.  */\n-      if (integer_zerop (DR_STEP (dr)))\n+      /* For scatter-gather or invariant accesses there is nothing\n+\t to enhance.  */\n+      if (STMT_VINFO_GATHER_SCATTER_P (stmt_info)\n+\t  || integer_zerop (DR_STEP (dr)))\n \tcontinue;\n \n       /* Strided accesses perform only component accesses, alignment is\n@@ -2295,6 +2301,10 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n   if (dra == drb)\n     return;\n \n+  if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n+      || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n+    return;\n+\n   if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n       || !operand_equal_p (DR_OFFSET (dra), DR_OFFSET (drb), 0)\n       || !operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n@@ -2357,22 +2367,8 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (vect_dr_stmt (dr));\n-      if (STMT_VINFO_VECTORIZABLE (stmt_info)\n-\t  && !vect_compute_data_ref_alignment (dr))\n-\t{\n-\t  /* Strided accesses perform only component accesses, misalignment\n-\t     information is irrelevant for them.  */\n-\t  if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t    continue;\n-\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: can't calculate alignment \"\n-\t\t\t     \"for data ref.\\n\");\n-\n-\t  return false;\n-\t}\n+      if (STMT_VINFO_VECTORIZABLE (stmt_info))\n+\tvect_compute_data_ref_alignment (dr);\n     }\n \n   return true;\n@@ -2393,12 +2389,12 @@ vect_slp_analyze_and_verify_node_alignment (slp_tree node)\n     first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n \n   data_reference_p dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-  if (! vect_compute_data_ref_alignment (dr)\n-      /* For creating the data-ref pointer we need alignment of the\n-\t first element anyway.  */\n-      || (dr != first_dr\n-\t  && ! vect_compute_data_ref_alignment (first_dr))\n-      || ! verify_data_ref_alignment (dr))\n+  vect_compute_data_ref_alignment (dr);\n+  /* For creating the data-ref pointer we need alignment of the\n+     first element anyway.  */\n+  if (dr != first_dr)\n+    vect_compute_data_ref_alignment (first_dr);\n+  if (! verify_data_ref_alignment (dr))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4102,21 +4098,20 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  /* If target supports vector gather loads or scatter stores, or if\n \t     this might be a SIMD lane access, see if they can't be used.  */\n \t  if (is_a <loop_vec_info> (vinfo)\n-\t      && (maybe_gather || maybe_scatter || maybe_simd_lane_access)\n \t      && !nested_in_vect_loop_p (loop, stmt))\n \t    {\n-\t      struct data_reference *newdr\n-\t\t= create_data_ref (NULL, loop_containing_stmt (stmt),\n-\t\t\t\t   DR_REF (dr), stmt, !maybe_scatter,\n-\t\t\t\t   DR_IS_CONDITIONAL_IN_STMT (dr));\n-\t      gcc_assert (newdr != NULL && DR_REF (newdr));\n-\t      if (DR_BASE_ADDRESS (newdr)\n-\t\t  && DR_OFFSET (newdr)\n-\t\t  && DR_INIT (newdr)\n-\t\t  && DR_STEP (newdr)\n-\t\t  && integer_zerop (DR_STEP (newdr)))\n+\t      if (maybe_simd_lane_access)\n \t\t{\n-\t\t  if (maybe_simd_lane_access)\n+\t\t  struct data_reference *newdr\n+\t\t    = create_data_ref (NULL, loop_containing_stmt (stmt),\n+\t\t\t\t       DR_REF (dr), stmt, !maybe_scatter,\n+\t\t\t\t       DR_IS_CONDITIONAL_IN_STMT (dr));\n+\t\t  gcc_assert (newdr != NULL && DR_REF (newdr));\n+\t\t  if (DR_BASE_ADDRESS (newdr)\n+\t\t      && DR_OFFSET (newdr)\n+\t\t      && DR_INIT (newdr)\n+\t\t      && DR_STEP (newdr)\n+\t\t      && integer_zerop (DR_STEP (newdr)))\n \t\t    {\n \t\t      tree off = DR_OFFSET (newdr);\n \t\t      STRIP_NOPS (off);\n@@ -4130,7 +4125,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t\t  if (CONVERT_EXPR_P (off)\n \t\t\t      && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (off,\n \t\t\t\t\t\t\t\t\t  0)))\n-\t\t\t\t < TYPE_PRECISION (TREE_TYPE (off)))\n+\t\t\t      < TYPE_PRECISION (TREE_TYPE (off)))\n \t\t\t    off = TREE_OPERAND (off, 0);\n \t\t\t  if (TREE_CODE (off) == SSA_NAME)\n \t\t\t    {\n@@ -4147,33 +4142,32 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t\t\t  if (arg == loop->simduid\n \t\t\t\t      /* For now.  */\n \t\t\t\t      && tree_int_cst_equal\n-\t\t\t\t\t   (TYPE_SIZE_UNIT (reft),\n-\t\t\t\t\t    step))\n+\t\t\t\t      (TYPE_SIZE_UNIT (reft),\n+\t\t\t\t       step))\n \t\t\t\t    {\n \t\t\t\t      DR_OFFSET (newdr) = ssize_int (0);\n \t\t\t\t      DR_STEP (newdr) = step;\n \t\t\t\t      DR_OFFSET_ALIGNMENT (newdr)\n-\t\t\t\t\t= BIGGEST_ALIGNMENT;\n+\t\t\t\t\t  = BIGGEST_ALIGNMENT;\n \t\t\t\t      DR_STEP_ALIGNMENT (newdr)\n-\t\t\t\t\t= highest_pow2_factor (step);\n+\t\t\t\t\t  = highest_pow2_factor (step);\n \t\t\t\t      dr = newdr;\n \t\t\t\t      simd_lane_access = true;\n \t\t\t\t    }\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}\n \t\t    }\n-\t\t  if (!simd_lane_access && (maybe_gather || maybe_scatter))\n-\t\t    {\n-\t\t      dr = newdr;\n-\t\t      if (maybe_gather)\n-\t\t\tgatherscatter = GATHER;\n-\t\t      else\n-\t\t\tgatherscatter = SCATTER;\n-\t\t    }\n+\t\t  if (!simd_lane_access)\n+\t\t    free_data_ref (newdr);\n+\t\t}\n+\t      if (!simd_lane_access && (maybe_gather || maybe_scatter))\n+\t\t{\n+\t\t  if (maybe_gather)\n+\t\t    gatherscatter = GATHER;\n+\t\t  else\n+\t\t    gatherscatter = SCATTER;\n \t\t}\n-\t      if (gatherscatter == SG_NONE && !simd_lane_access)\n-\t\tfree_data_ref (newdr);\n \t    }\n \n \t  if (gatherscatter == SG_NONE && !simd_lane_access)\n@@ -4196,9 +4190,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t    }\n         }\n \n-      if (TREE_CODE (DR_BASE_ADDRESS (dr)) == ADDR_EXPR\n-\t  && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (dr), 0))\n-\t  && DECL_NONALIASED (TREE_OPERAND (DR_BASE_ADDRESS (dr), 0)))\n+      tree base = get_base_address (DR_REF (dr));\n+      if (base && VAR_P (base) && DECL_NONALIASED (base))\n \t{\n           if (dump_enabled_p ())\n             {\n@@ -4218,6 +4211,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t}\n \n       if (is_a <loop_vec_info> (vinfo)\n+\t  && DR_STEP (dr)\n \t  && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n \t{\n \t  if (nested_in_vect_loop_p (loop, stmt))\n@@ -4330,11 +4324,10 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t      continue;\n \t    }\n \n-\t  if (gatherscatter != SG_NONE || simd_lane_access)\n+\t  if (simd_lane_access)\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n-\t      if (gatherscatter != SG_NONE)\n-\t\tfree_data_ref (dr);\n+\t      free_data_ref (dr);\n \t    }\n \t  return false;\n         }\n@@ -4363,8 +4356,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t\t\t\t  &gs_info)\n \t      || !get_vectype_for_scalar_type (TREE_TYPE (gs_info.offset)))\n \t    {\n-\t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n-\t      free_data_ref (dr);\n \t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4377,9 +4368,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t}\n \t      return false;\n \t    }\n-\n-\t  free_data_ref (datarefs[i]);\n-\t  datarefs[i] = dr;\n \t  STMT_VINFO_GATHER_SCATTER_P (stmt_info) = gatherscatter;\n \t}\n     }"}, {"sha": "f52ca0de2ac7791471575f190d56359557e12424", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=5fa234669f3882aa2190c916df497259153412e4", "patch": "@@ -1752,7 +1752,11 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,\n     }\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    vect_update_init_of_dr (dr, niters, code);\n+    {\n+      gimple *stmt = DR_STMT (dr);\n+      if (!STMT_VINFO_GATHER_SCATTER_P (vinfo_for_stmt (stmt)))\n+\tvect_update_init_of_dr (dr, niters, code);\n+    }\n }\n \n /* For the information recorded in LOOP_VINFO prepare the loop for peeling"}, {"sha": "9654bd7818a08f2f9f3ec3e430f102178f921359", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa234669f3882aa2190c916df497259153412e4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=5fa234669f3882aa2190c916df497259153412e4", "patch": "@@ -3848,6 +3848,8 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n       STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n \t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n+      STMT_VINFO_GATHER_SCATTER_P (pattern_stmt_info)\n+\t= STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo);\n \n       *type_out = vectype1;\n       stmts->safe_push (last_stmt);"}]}