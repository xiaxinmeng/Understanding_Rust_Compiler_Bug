{"sha": "70e73d3c4277fa602999b3e3c104a06024932c70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBlNzNkM2M0Mjc3ZmE2MDI5OTliM2UzYzEwNGEwNjAyNDkzMmM3MA==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-11-18T16:45:37Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-11-18T16:45:37Z"}, "message": "[ARM] Optional -mthumb for Thumb only targets\n\n2016-11-18  Terry Guo  <terry.guo@arm.com>\n            Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    * common/config/arm/arm-common.c (arm_target_thumb_only): New function.\n    * config/arm/arm-opts.h: Include arm-flags.h.\n    (struct arm_arch_core_flag): Define.\n    (arm_arch_core_flags): Define.\n    * config/arm/arm-protos.h: Include arm-flags.h\n    (FL_NONE, FL_ANY, FL_CO_PROC, FL_ARCH3M, FL_MODE26, FL_MODE32,\n    FL_ARCH4, FL_ARCH5, FL_THUMB, FL_LDSCHED, FL_STRONG, FL_ARCH5E,\n    FL_XSCALE, FL_ARCH6, FL_VFPV2, FL_WBUF, FL_ARCH6K, FL_THUMB2, FL_NOTM,\n    FL_THUMB_DIV, FL_VFPV3, FL_NEON, FL_ARCH7EM, FL_ARCH7, FL_ARM_DIV,\n    FL_ARCH8, FL_CRC32, FL_SMALLMUL, FL_NO_VOLATILE_CE, FL_IWMMXT,\n    FL_IWMMXT2, FL_ARCH6KZ, FL2_ARCH8_1, FL2_ARCH8_2, FL2_FP16INST,\n    FL_TUNE, FL_FOR_ARCH2, FL_FOR_ARCH3, FL_FOR_ARCH3M, FL_FOR_ARCH4,\n    FL_FOR_ARCH4T, FL_FOR_ARCH5, FL_FOR_ARCH5T, FL_FOR_ARCH5E,\n    FL_FOR_ARCH5TE, FL_FOR_ARCH5TEJ, FL_FOR_ARCH6, FL_FOR_ARCH6J,\n    FL_FOR_ARCH6K, FL_FOR_ARCH6Z, FL_FOR_ARCH6ZK, FL_FOR_ARCH6KZ,\n    FL_FOR_ARCH6T2, FL_FOR_ARCH6M, FL_FOR_ARCH7, FL_FOR_ARCH7A,\n    FL_FOR_ARCH7VE, FL_FOR_ARCH7R, FL_FOR_ARCH7M, FL_FOR_ARCH7EM,\n    FL_FOR_ARCH8A, FL2_FOR_ARCH8_1A, FL2_FOR_ARCH8_2A, FL_FOR_ARCH8M_BASE,\n    FL_FOR_ARCH8M_MAIN, arm_feature_set, ARM_FSET_MAKE,\n    ARM_FSET_MAKE_CPU1, ARM_FSET_MAKE_CPU2, ARM_FSET_CPU1, ARM_FSET_CPU2,\n    ARM_FSET_EMPTY, ARM_FSET_ANY, ARM_FSET_HAS_CPU1, ARM_FSET_HAS_CPU2,\n    ARM_FSET_HAS_CPU, ARM_FSET_ADD_CPU1, ARM_FSET_ADD_CPU2,\n    ARM_FSET_DEL_CPU1, ARM_FSET_DEL_CPU2, ARM_FSET_UNION, ARM_FSET_INTER,\n    ARM_FSET_XOR, ARM_FSET_EXCLUDE, ARM_FSET_IS_EMPTY,\n    ARM_FSET_CPU_SUBSET): Move to ...\n    * config/arm/arm-flags.h: This new file.\n    * config/arm/arm.h (TARGET_MODE_SPEC_FUNCTIONS): Define.\n    (EXTRA_SPEC_FUNCTIONS): Add TARGET_MODE_SPEC_FUNCTIONS to its value.\n    (TARGET_MODE_SPECS): Define.\n    (DRIVER_SELF_SPECS): Add TARGET_MODE_SPECS to its value.\n\n    gcc/testsuite/\n    * gcc.target/arm/optional_thumb-1.c: New test.\n    * gcc.target/arm/optional_thumb-2.c: New test.\n    * gcc.target/arm/optional_thumb-3.c: New test.\n\nFrom-SVN: r242597", "tree": {"sha": "0738e0d3eecf68cd9832d1f205bfb9fe3d9ae111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0738e0d3eecf68cd9832d1f205bfb9fe3d9ae111"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70e73d3c4277fa602999b3e3c104a06024932c70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e73d3c4277fa602999b3e3c104a06024932c70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e73d3c4277fa602999b3e3c104a06024932c70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e73d3c4277fa602999b3e3c104a06024932c70/comments", "author": null, "committer": null, "parents": [{"sha": "05237cf81e0b0bb1c530d4fc46566e25c513730f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05237cf81e0b0bb1c530d4fc46566e25c513730f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05237cf81e0b0bb1c530d4fc46566e25c513730f"}], "stats": {"total": 529, "additions": 340, "deletions": 189}, "files": [{"sha": "062999c28a2af189bb71b95c0c8ecc04514d0bbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -1,3 +1,37 @@\n+2016-11-18  Terry Guo  <terry.guo@arm.com>\n+\t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* common/config/arm/arm-common.c (arm_target_thumb_only): New function.\n+\t* config/arm/arm-opts.h: Include arm-flags.h.\n+\t(struct arm_arch_core_flag): Define.\n+\t(arm_arch_core_flags): Define.\n+\t* config/arm/arm-protos.h: Include arm-flags.h\n+\t(FL_NONE, FL_ANY, FL_CO_PROC, FL_ARCH3M, FL_MODE26, FL_MODE32,\n+\tFL_ARCH4, FL_ARCH5, FL_THUMB, FL_LDSCHED, FL_STRONG, FL_ARCH5E,\n+\tFL_XSCALE, FL_ARCH6, FL_VFPV2, FL_WBUF, FL_ARCH6K, FL_THUMB2, FL_NOTM,\n+\tFL_THUMB_DIV, FL_VFPV3, FL_NEON, FL_ARCH7EM, FL_ARCH7, FL_ARM_DIV,\n+\tFL_ARCH8, FL_CRC32, FL_SMALLMUL, FL_NO_VOLATILE_CE, FL_IWMMXT,\n+\tFL_IWMMXT2, FL_ARCH6KZ, FL2_ARCH8_1, FL2_ARCH8_2, FL2_FP16INST,\n+\tFL_TUNE, FL_FOR_ARCH2, FL_FOR_ARCH3, FL_FOR_ARCH3M, FL_FOR_ARCH4,\n+\tFL_FOR_ARCH4T, FL_FOR_ARCH5, FL_FOR_ARCH5T, FL_FOR_ARCH5E,\n+\tFL_FOR_ARCH5TE, FL_FOR_ARCH5TEJ, FL_FOR_ARCH6, FL_FOR_ARCH6J,\n+\tFL_FOR_ARCH6K, FL_FOR_ARCH6Z, FL_FOR_ARCH6ZK, FL_FOR_ARCH6KZ,\n+\tFL_FOR_ARCH6T2, FL_FOR_ARCH6M, FL_FOR_ARCH7, FL_FOR_ARCH7A,\n+\tFL_FOR_ARCH7VE, FL_FOR_ARCH7R, FL_FOR_ARCH7M, FL_FOR_ARCH7EM,\n+\tFL_FOR_ARCH8A, FL2_FOR_ARCH8_1A, FL2_FOR_ARCH8_2A, FL_FOR_ARCH8M_BASE,\n+\tFL_FOR_ARCH8M_MAIN, arm_feature_set, ARM_FSET_MAKE,\n+\tARM_FSET_MAKE_CPU1, ARM_FSET_MAKE_CPU2, ARM_FSET_CPU1, ARM_FSET_CPU2,\n+\tARM_FSET_EMPTY, ARM_FSET_ANY, ARM_FSET_HAS_CPU1, ARM_FSET_HAS_CPU2,\n+\tARM_FSET_HAS_CPU, ARM_FSET_ADD_CPU1, ARM_FSET_ADD_CPU2,\n+\tARM_FSET_DEL_CPU1, ARM_FSET_DEL_CPU2, ARM_FSET_UNION, ARM_FSET_INTER,\n+\tARM_FSET_XOR, ARM_FSET_EXCLUDE, ARM_FSET_IS_EMPTY,\n+\tARM_FSET_CPU_SUBSET): Move to ...\n+\t* config/arm/arm-flags.h: This new file.\n+\t* config/arm/arm.h (TARGET_MODE_SPEC_FUNCTIONS): Define.\n+\t(EXTRA_SPEC_FUNCTIONS): Add TARGET_MODE_SPEC_FUNCTIONS to its value.\n+\t(TARGET_MODE_SPECS): Define.\n+\t(DRIVER_SELF_SPECS): Add TARGET_MODE_SPECS to its value.\n+\n 2016-11-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/arm-protos.h (FL_NONE, FL_ANY, FL_CO_PROC, FL_ARCH3M,"}, {"sha": "473417a2e5f04488197c27ead2b65680bddec274", "filename": "gcc/common/config/arm/arm-common.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -98,6 +98,29 @@ arm_rewrite_mcpu (int argc, const char **argv)\n   return arm_rewrite_selected_cpu (argv[argc - 1]);\n }\n \n+/* Called by the driver to check whether the target denoted by current\n+   command line options is a Thumb-only target.  ARGV is an array of\n+   -march and -mcpu values (ie. it contains the rhs after the equal\n+   sign) and we use the last one of them to make a decision.  The\n+   number of elements in ARGV is given in ARGC.  */\n+const char *\n+arm_target_thumb_only (int argc, const char **argv)\n+{\n+  unsigned int opt;\n+\n+  if (argc)\n+    {\n+      for (opt = 0; opt < (ARRAY_SIZE (arm_arch_core_flags)); opt++)\n+\tif ((strcmp (argv[argc - 1], arm_arch_core_flags[opt].name) == 0)\n+\t    && !ARM_FSET_HAS_CPU1(arm_arch_core_flags[opt].flags, FL_NOTM))\n+\t  return \"-mthumb\";\n+\n+      return NULL;\n+    }\n+  else\n+    return NULL;\n+}\n+\n #undef ARM_CPU_NAME_LENGTH\n \n "}, {"sha": "7ce059bcf87b162d2ea77a0d1322edb25d04676c", "filename": "gcc/config/arm/arm-flags.h", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm-flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm-flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-flags.h?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -0,0 +1,211 @@\n+/* Flags used to identify the presence of processor capabilities.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ARM_FLAGS_H\n+#define GCC_ARM_FLAGS_H\n+\n+/* Flags used to identify the presence of processor capabilities.  */\n+\n+/* Bit values used to identify processor capabilities.  */\n+#define FL_NONE\t      (0U)\t\t/* No flags.  */\n+#define FL_ANY\t      (0xffffffffU)\t/* All flags.  */\n+#define FL_CO_PROC    (1U << 0)\t\t/* Has external co-processor bus.  */\n+#define FL_ARCH3M     (1U << 1)\t\t/* Extended multiply.  */\n+#define FL_MODE26     (1U << 2)\t\t/* 26-bit mode support.  */\n+#define FL_MODE32     (1U << 3)\t\t/* 32-bit mode support.  */\n+#define FL_ARCH4      (1U << 4)\t\t/* Architecture rel 4.  */\n+#define FL_ARCH5      (1U << 5)\t\t/* Architecture rel 5.  */\n+#define FL_THUMB      (1U << 6)\t\t/* Thumb aware.  */\n+#define FL_LDSCHED    (1U << 7)\t\t/* Load scheduling necessary.  */\n+#define FL_STRONG     (1U << 8)\t\t/* StrongARM.  */\n+#define FL_ARCH5E     (1U << 9)\t\t/* DSP extensions to v5.  */\n+#define FL_XSCALE     (1U << 10)\t/* XScale.  */\n+/* spare\t      (1U << 11) */\n+#define FL_ARCH6      (1U << 12)\t/* Architecture rel 6.  Adds\n+\t\t\t\t\t   media instructions.  */\n+#define FL_VFPV2      (1U << 13)\t/* Vector Floating Point V2.  */\n+#define FL_WBUF\t      (1U << 14)\t/* Schedule for write buffer ops.\n+\t\t\t\t\t   Note: ARM6 & 7 derivatives only.  */\n+#define FL_ARCH6K     (1U << 15)\t/* Architecture rel 6 K extensions.  */\n+#define FL_THUMB2     (1U << 16)\t/* Thumb-2.  */\n+#define FL_NOTM\t      (1U << 17)\t/* Instructions not present in the 'M'\n+\t\t\t\t\t   profile.  */\n+#define FL_THUMB_DIV  (1U << 18)\t/* Hardware divide (Thumb mode).  */\n+#define FL_VFPV3      (1U << 19)\t/* Vector Floating Point V3.  */\n+#define FL_NEON       (1U << 20)\t/* Neon instructions.  */\n+#define FL_ARCH7EM    (1U << 21)\t/* Instructions present in the ARMv7E-M\n+\t\t\t\t\t   architecture.  */\n+#define FL_ARCH7      (1U << 22)\t/* Architecture 7.  */\n+#define FL_ARM_DIV    (1U << 23)\t/* Hardware divide (ARM mode).  */\n+#define FL_ARCH8      (1U << 24)\t/* Architecture 8.  */\n+#define FL_CRC32      (1U << 25)\t/* ARMv8 CRC32 instructions.  */\n+#define FL_SMALLMUL   (1U << 26)\t/* Small multiply supported.  */\n+#define FL_NO_VOLATILE_CE  (1U << 27)\t/* No volatile memory in IT block.  */\n+\n+#define FL_IWMMXT     (1U << 29)\t/* XScale v2 or \"Intel Wireless MMX\n+\t\t\t\t\t   technology\".  */\n+#define FL_IWMMXT2    (1U << 30)\t/* \"Intel Wireless MMX2\n+\t\t\t\t\t    technology\".  */\n+#define FL_ARCH6KZ    (1U << 31)\t/* ARMv6KZ architecture.  */\n+\n+#define FL2_ARCH8_1   (1U << 0)\t\t/* Architecture 8.1.  */\n+#define FL2_ARCH8_2   (1U << 1)\t\t/* Architecture 8.2.  */\n+#define FL2_FP16INST  (1U << 2)\t\t/* FP16 Instructions for ARMv8.2 and\n+\t\t\t\t\t   later.  */\n+\n+/* Flags that only effect tuning, not available instructions.  */\n+#define FL_TUNE\t\t(FL_WBUF | FL_VFPV2 | FL_STRONG | FL_LDSCHED \\\n+\t\t\t | FL_CO_PROC)\n+\n+#define FL_FOR_ARCH2\t\tFL_NOTM\n+#define FL_FOR_ARCH3\t\t(FL_FOR_ARCH2 | FL_MODE32)\n+#define FL_FOR_ARCH3M\t\t(FL_FOR_ARCH3 | FL_ARCH3M)\n+#define FL_FOR_ARCH4\t\t(FL_FOR_ARCH3M | FL_ARCH4)\n+#define FL_FOR_ARCH4T\t\t(FL_FOR_ARCH4 | FL_THUMB)\n+#define FL_FOR_ARCH5\t\t(FL_FOR_ARCH4 | FL_ARCH5)\n+#define FL_FOR_ARCH5T\t\t(FL_FOR_ARCH5 | FL_THUMB)\n+#define FL_FOR_ARCH5E\t\t(FL_FOR_ARCH5 | FL_ARCH5E)\n+#define FL_FOR_ARCH5TE\t\t(FL_FOR_ARCH5E | FL_THUMB)\n+#define FL_FOR_ARCH5TEJ\t\tFL_FOR_ARCH5TE\n+#define FL_FOR_ARCH6\t\t(FL_FOR_ARCH5TE | FL_ARCH6)\n+#define FL_FOR_ARCH6J\t\tFL_FOR_ARCH6\n+#define FL_FOR_ARCH6K\t\t(FL_FOR_ARCH6 | FL_ARCH6K)\n+#define FL_FOR_ARCH6Z\t\tFL_FOR_ARCH6\n+#define FL_FOR_ARCH6ZK\t\tFL_FOR_ARCH6K\n+#define FL_FOR_ARCH6KZ\t\t(FL_FOR_ARCH6K | FL_ARCH6KZ)\n+#define FL_FOR_ARCH6T2\t\t(FL_FOR_ARCH6 | FL_THUMB2)\n+#define FL_FOR_ARCH6M\t\t(FL_FOR_ARCH6 & ~FL_NOTM)\n+#define FL_FOR_ARCH7\t\t((FL_FOR_ARCH6T2 & ~FL_NOTM) | FL_ARCH7)\n+#define FL_FOR_ARCH7A\t\t(FL_FOR_ARCH7 | FL_NOTM | FL_ARCH6K)\n+#define FL_FOR_ARCH7VE\t\t(FL_FOR_ARCH7A | FL_THUMB_DIV | FL_ARM_DIV)\n+#define FL_FOR_ARCH7R\t\t(FL_FOR_ARCH7A | FL_THUMB_DIV)\n+#define FL_FOR_ARCH7M\t\t(FL_FOR_ARCH7 | FL_THUMB_DIV)\n+#define FL_FOR_ARCH7EM\t\t(FL_FOR_ARCH7M | FL_ARCH7EM)\n+#define FL_FOR_ARCH8A\t\t(FL_FOR_ARCH7VE | FL_ARCH8)\n+#define FL2_FOR_ARCH8_1A\tFL2_ARCH8_1\n+#define FL2_FOR_ARCH8_2A\t(FL2_FOR_ARCH8_1A | FL2_ARCH8_2)\n+#define FL_FOR_ARCH8M_BASE\t(FL_FOR_ARCH6M | FL_ARCH8 | FL_THUMB_DIV)\n+#define FL_FOR_ARCH8M_MAIN\t(FL_FOR_ARCH7M | FL_ARCH8)\n+\n+/* There are too many feature bits to fit in a single word so the set of cpu and\n+   fpu capabilities is a structure.  A feature set is created and manipulated\n+   with the ARM_FSET macros.  */\n+\n+typedef struct\n+{\n+  unsigned cpu[2];\n+} arm_feature_set;\n+\n+\n+/* Initialize a feature set.  */\n+\n+#define ARM_FSET_MAKE(CPU1,CPU2) { { (CPU1), (CPU2) } }\n+\n+#define ARM_FSET_MAKE_CPU1(CPU1) ARM_FSET_MAKE ((CPU1), (FL_NONE))\n+#define ARM_FSET_MAKE_CPU2(CPU2) ARM_FSET_MAKE ((FL_NONE), (CPU2))\n+\n+/* Accessors.  */\n+\n+#define ARM_FSET_CPU1(S) ((S).cpu[0])\n+#define ARM_FSET_CPU2(S) ((S).cpu[1])\n+\n+/* Useful combinations.  */\n+\n+#define ARM_FSET_EMPTY ARM_FSET_MAKE (FL_NONE, FL_NONE)\n+#define ARM_FSET_ANY ARM_FSET_MAKE (FL_ANY, FL_ANY)\n+\n+/* Tests for a specific CPU feature.  */\n+\n+#define ARM_FSET_HAS_CPU1(A, F)  \\\n+  (((A).cpu[0] & ((unsigned long)(F))) == ((unsigned long)(F)))\n+#define ARM_FSET_HAS_CPU2(A, F)  \\\n+  (((A).cpu[1] & ((unsigned long)(F))) == ((unsigned long)(F)))\n+#define ARM_FSET_HAS_CPU(A, F1, F2)\t\t\t\t\\\n+  (ARM_FSET_HAS_CPU1 ((A), (F1)) && ARM_FSET_HAS_CPU2 ((A), (F2)))\n+\n+/* Add a feature to a feature set.  */\n+\n+#define ARM_FSET_ADD_CPU1(DST, F)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[0] |= (F);\t\t\t\\\n+  } while (0)\n+\n+#define ARM_FSET_ADD_CPU2(DST, F)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[1] |= (F);\t\t\t\\\n+  } while (0)\n+\n+/* Remove a feature from a feature set.  */\n+\n+#define ARM_FSET_DEL_CPU1(DST, F)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[0] &= ~(F);\t\t\t\\\n+  } while (0)\n+\n+#define ARM_FSET_DEL_CPU2(DST, F)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[1] &= ~(F);\t\t\t\\\n+  } while (0)\n+\n+/* Union of feature sets.  */\n+\n+#define ARM_FSET_UNION(DST,F1,F2)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[0] = (F1).cpu[0] | (F2).cpu[0];\t\\\n+    (DST).cpu[1] = (F1).cpu[1] | (F2).cpu[1];\t\\\n+  } while (0)\n+\n+/* Intersection of feature sets.  */\n+\n+#define ARM_FSET_INTER(DST,F1,F2)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[0] = (F1).cpu[0] & (F2).cpu[0];\t\\\n+    (DST).cpu[1] = (F1).cpu[1] & (F2).cpu[1];\t\\\n+  } while (0)\n+\n+/* Exclusive disjunction.  */\n+\n+#define ARM_FSET_XOR(DST,F1,F2)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    (DST).cpu[0] = (F1).cpu[0] ^ (F2).cpu[0];\t\t\\\n+    (DST).cpu[1] = (F1).cpu[1] ^ (F2).cpu[1];\t\t\\\n+  } while (0)\n+\n+/* Difference of feature sets: F1 excluding the elements of F2.  */\n+\n+#define ARM_FSET_EXCLUDE(DST,F1,F2)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    (DST).cpu[0] = (F1).cpu[0] & ~(F2).cpu[0];\t\\\n+    (DST).cpu[1] = (F1).cpu[1] & ~(F2).cpu[1];\t\\\n+  } while (0)\n+\n+/* Test for an empty feature set.  */\n+\n+#define ARM_FSET_IS_EMPTY(A)\t\t\\\n+  (!((A).cpu[0]) && !((A).cpu[1]))\n+\n+/* Tests whether the cpu features of A are a subset of B.  */\n+\n+#define ARM_FSET_CPU_SUBSET(A,B)\t\t\t\t\t\\\n+  ((((A).cpu[0] & (B).cpu[0]) == (A).cpu[0])\t\t\t\t\\\n+   && (((A).cpu[1] & (B).cpu[1]) == (A).cpu[1]))\n+\n+#endif /* GCC_ARM_FLAGS_H */"}, {"sha": "6971534a562e7b37a67d9a20f40f29b5f00dd9bc", "filename": "gcc/config/arm/arm-opts.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-opts.h?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -25,6 +25,8 @@\n #ifndef ARM_OPTS_H\n #define ARM_OPTS_H\n \n+#include \"arm-flags.h\"\n+\n /* The various ARM cores.  */\n enum processor_type\n {\n@@ -77,4 +79,24 @@ enum arm_tls_type {\n   TLS_GNU,\n   TLS_GNU2\n };\n+\n+struct arm_arch_core_flag\n+{\n+  const char *const name;\n+  const arm_feature_set flags;\n+};\n+\n+static const struct arm_arch_core_flag arm_arch_core_flags[] =\n+{\n+#undef ARM_CORE\n+#define ARM_CORE(NAME, X, IDENT, ARCH, FLAGS, COSTS) \\\n+  {NAME, FLAGS},\n+#include \"arm-cores.def\"\n+#undef ARM_CORE\n+#undef ARM_ARCH\n+#define ARM_ARCH(NAME, CORE, ARCH, FLAGS) \\\n+  {NAME, FLAGS},\n+#include \"arm-arches.def\"\n+#undef ARM_ARCH\n+};\n #endif"}, {"sha": "68e9beaa2612ca5aff7a835123690aabc2c600ad", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 186, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -22,6 +22,8 @@\n #ifndef GCC_ARM_PROTOS_H\n #define GCC_ARM_PROTOS_H\n \n+#include \"arm-flags.h\"\n+\n extern enum unwind_info_type arm_except_unwind_info (struct gcc_options *);\n extern int use_return_insn (int, rtx);\n extern bool use_simple_return_p (void);\n@@ -348,192 +350,6 @@ extern void arm_cpu_cpp_builtins (struct cpp_reader *);\n \n extern bool arm_is_constant_pool_ref (rtx);\n \n-/* Flags used to identify the presence of processor capabilities.  */\n-\n-/* Bit values used to identify processor capabilities.  */\n-#define FL_NONE\t      (0U)\t\t/* No flags.  */\n-#define FL_ANY\t      (0xffffffffU)\t/* All flags.  */\n-#define FL_CO_PROC    (1U << 0)\t\t/* Has external co-processor bus.  */\n-#define FL_ARCH3M     (1U << 1)\t\t/* Extended multiply.  */\n-#define FL_MODE26     (1U << 2)\t\t/* 26-bit mode support.  */\n-#define FL_MODE32     (1U << 3)\t\t/* 32-bit mode support.  */\n-#define FL_ARCH4      (1U << 4)\t\t/* Architecture rel 4.  */\n-#define FL_ARCH5      (1U << 5)\t\t/* Architecture rel 5.  */\n-#define FL_THUMB      (1U << 6)\t\t/* Thumb aware.  */\n-#define FL_LDSCHED    (1U << 7)\t\t/* Load scheduling necessary.  */\n-#define FL_STRONG     (1U << 8)\t\t/* StrongARM.  */\n-#define FL_ARCH5E     (1U << 9)\t\t/* DSP extensions to v5.  */\n-#define FL_XSCALE     (1U << 10)\t/* XScale.  */\n-/* spare\t      (1U << 11) */\n-#define FL_ARCH6      (1U << 12)\t/* Architecture rel 6.  Adds\n-\t\t\t\t\t   media instructions.  */\n-#define FL_VFPV2      (1U << 13)\t/* Vector Floating Point V2.  */\n-#define FL_WBUF\t      (1U << 14)\t/* Schedule for write buffer ops.\n-\t\t\t\t\t   Note: ARM6 & 7 derivatives only.  */\n-#define FL_ARCH6K     (1U << 15)\t/* Architecture rel 6 K extensions.  */\n-#define FL_THUMB2     (1U << 16)\t/* Thumb-2.  */\n-#define FL_NOTM\t      (1U << 17)\t/* Instructions not present in the 'M'\n-\t\t\t\t\t   profile.  */\n-#define FL_THUMB_DIV  (1U << 18)\t/* Hardware divide (Thumb mode).  */\n-#define FL_VFPV3      (1U << 19)\t/* Vector Floating Point V3.  */\n-#define FL_NEON       (1U << 20)\t/* Neon instructions.  */\n-#define FL_ARCH7EM    (1U << 21)\t/* Instructions present in the ARMv7E-M\n-\t\t\t\t\t   architecture.  */\n-#define FL_ARCH7      (1U << 22)\t/* Architecture 7.  */\n-#define FL_ARM_DIV    (1U << 23)\t/* Hardware divide (ARM mode).  */\n-#define FL_ARCH8      (1U << 24)\t/* Architecture 8.  */\n-#define FL_CRC32      (1U << 25)\t/* ARMv8 CRC32 instructions.  */\n-#define FL_SMALLMUL   (1U << 26)\t/* Small multiply supported.  */\n-#define FL_NO_VOLATILE_CE  (1U << 27)\t/* No volatile memory in IT block.  */\n-\n-#define FL_IWMMXT     (1U << 29)\t/* XScale v2 or \"Intel Wireless MMX\n-\t\t\t\t\t   technology\".  */\n-#define FL_IWMMXT2    (1U << 30)\t/* \"Intel Wireless MMX2\n-\t\t\t\t\t    technology\".  */\n-#define FL_ARCH6KZ    (1U << 31)\t/* ARMv6KZ architecture.  */\n-\n-#define FL2_ARCH8_1   (1U << 0)\t\t/* Architecture 8.1.  */\n-#define FL2_ARCH8_2   (1U << 1)\t\t/* Architecture 8.2.  */\n-#define FL2_FP16INST  (1U << 2)\t\t/* FP16 Instructions for ARMv8.2 and\n-\t\t\t\t\t   later.  */\n-\n-/* Flags that only effect tuning, not available instructions.  */\n-#define FL_TUNE\t\t(FL_WBUF | FL_VFPV2 | FL_STRONG | FL_LDSCHED \\\n-\t\t\t | FL_CO_PROC)\n-\n-#define FL_FOR_ARCH2\t\tFL_NOTM\n-#define FL_FOR_ARCH3\t\t(FL_FOR_ARCH2 | FL_MODE32)\n-#define FL_FOR_ARCH3M\t\t(FL_FOR_ARCH3 | FL_ARCH3M)\n-#define FL_FOR_ARCH4\t\t(FL_FOR_ARCH3M | FL_ARCH4)\n-#define FL_FOR_ARCH4T\t\t(FL_FOR_ARCH4 | FL_THUMB)\n-#define FL_FOR_ARCH5\t\t(FL_FOR_ARCH4 | FL_ARCH5)\n-#define FL_FOR_ARCH5T\t\t(FL_FOR_ARCH5 | FL_THUMB)\n-#define FL_FOR_ARCH5E\t\t(FL_FOR_ARCH5 | FL_ARCH5E)\n-#define FL_FOR_ARCH5TE\t\t(FL_FOR_ARCH5E | FL_THUMB)\n-#define FL_FOR_ARCH5TEJ\t\tFL_FOR_ARCH5TE\n-#define FL_FOR_ARCH6\t\t(FL_FOR_ARCH5TE | FL_ARCH6)\n-#define FL_FOR_ARCH6J\t\tFL_FOR_ARCH6\n-#define FL_FOR_ARCH6K\t\t(FL_FOR_ARCH6 | FL_ARCH6K)\n-#define FL_FOR_ARCH6Z\t\tFL_FOR_ARCH6\n-#define FL_FOR_ARCH6ZK\t\tFL_FOR_ARCH6K\n-#define FL_FOR_ARCH6KZ\t\t(FL_FOR_ARCH6K | FL_ARCH6KZ)\n-#define FL_FOR_ARCH6T2\t\t(FL_FOR_ARCH6 | FL_THUMB2)\n-#define FL_FOR_ARCH6M\t\t(FL_FOR_ARCH6 & ~FL_NOTM)\n-#define FL_FOR_ARCH7\t\t((FL_FOR_ARCH6T2 & ~FL_NOTM) | FL_ARCH7)\n-#define FL_FOR_ARCH7A\t\t(FL_FOR_ARCH7 | FL_NOTM | FL_ARCH6K)\n-#define FL_FOR_ARCH7VE\t\t(FL_FOR_ARCH7A | FL_THUMB_DIV | FL_ARM_DIV)\n-#define FL_FOR_ARCH7R\t\t(FL_FOR_ARCH7A | FL_THUMB_DIV)\n-#define FL_FOR_ARCH7M\t\t(FL_FOR_ARCH7 | FL_THUMB_DIV)\n-#define FL_FOR_ARCH7EM\t\t(FL_FOR_ARCH7M | FL_ARCH7EM)\n-#define FL_FOR_ARCH8A\t\t(FL_FOR_ARCH7VE | FL_ARCH8)\n-#define FL2_FOR_ARCH8_1A\tFL2_ARCH8_1\n-#define FL2_FOR_ARCH8_2A\t(FL2_FOR_ARCH8_1A | FL2_ARCH8_2)\n-#define FL_FOR_ARCH8M_BASE\t(FL_FOR_ARCH6M | FL_ARCH8 | FL_THUMB_DIV)\n-#define FL_FOR_ARCH8M_MAIN\t(FL_FOR_ARCH7M | FL_ARCH8)\n-\n-/* There are too many feature bits to fit in a single word so the set of cpu and\n-   fpu capabilities is a structure.  A feature set is created and manipulated\n-   with the ARM_FSET macros.  */\n-\n-typedef struct\n-{\n-  unsigned cpu[2];\n-} arm_feature_set;\n-\n-\n-/* Initialize a feature set.  */\n-\n-#define ARM_FSET_MAKE(CPU1,CPU2) { { (CPU1), (CPU2) } }\n-\n-#define ARM_FSET_MAKE_CPU1(CPU1) ARM_FSET_MAKE ((CPU1), (FL_NONE))\n-#define ARM_FSET_MAKE_CPU2(CPU2) ARM_FSET_MAKE ((FL_NONE), (CPU2))\n-\n-/* Accessors.  */\n-\n-#define ARM_FSET_CPU1(S) ((S).cpu[0])\n-#define ARM_FSET_CPU2(S) ((S).cpu[1])\n-\n-/* Useful combinations.  */\n-\n-#define ARM_FSET_EMPTY ARM_FSET_MAKE (FL_NONE, FL_NONE)\n-#define ARM_FSET_ANY ARM_FSET_MAKE (FL_ANY, FL_ANY)\n-\n-/* Tests for a specific CPU feature.  */\n-\n-#define ARM_FSET_HAS_CPU1(A, F)  \\\n-  (((A).cpu[0] & ((unsigned long)(F))) == ((unsigned long)(F)))\n-#define ARM_FSET_HAS_CPU2(A, F)  \\\n-  (((A).cpu[1] & ((unsigned long)(F))) == ((unsigned long)(F)))\n-#define ARM_FSET_HAS_CPU(A, F1, F2)\t\t\t\t\\\n-  (ARM_FSET_HAS_CPU1 ((A), (F1)) && ARM_FSET_HAS_CPU2 ((A), (F2)))\n-\n-/* Add a feature to a feature set.  */\n-\n-#define ARM_FSET_ADD_CPU1(DST, F)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[0] |= (F);\t\t\t\\\n-  } while (0)\n-\n-#define ARM_FSET_ADD_CPU2(DST, F)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[1] |= (F);\t\t\t\\\n-  } while (0)\n-\n-/* Remove a feature from a feature set.  */\n-\n-#define ARM_FSET_DEL_CPU1(DST, F)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[0] &= ~(F);\t\t\t\\\n-  } while (0)\n-\n-#define ARM_FSET_DEL_CPU2(DST, F)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[1] &= ~(F);\t\t\t\\\n-  } while (0)\n-\n-/* Union of feature sets.  */\n-\n-#define ARM_FSET_UNION(DST,F1,F2)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[0] = (F1).cpu[0] | (F2).cpu[0];\t\\\n-    (DST).cpu[1] = (F1).cpu[1] | (F2).cpu[1];\t\\\n-  } while (0)\n-\n-/* Intersection of feature sets.  */\n-\n-#define ARM_FSET_INTER(DST,F1,F2)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[0] = (F1).cpu[0] & (F2).cpu[0];\t\\\n-    (DST).cpu[1] = (F1).cpu[1] & (F2).cpu[1];\t\\\n-  } while (0)\n-\n-/* Exclusive disjunction.  */\n-\n-#define ARM_FSET_XOR(DST,F1,F2)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    (DST).cpu[0] = (F1).cpu[0] ^ (F2).cpu[0];\t\t\\\n-    (DST).cpu[1] = (F1).cpu[1] ^ (F2).cpu[1];\t\t\\\n-  } while (0)\n-\n-/* Difference of feature sets: F1 excluding the elements of F2.  */\n-\n-#define ARM_FSET_EXCLUDE(DST,F1,F2)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    (DST).cpu[0] = (F1).cpu[0] & ~(F2).cpu[0];\t\\\n-    (DST).cpu[1] = (F1).cpu[1] & ~(F2).cpu[1];\t\\\n-  } while (0)\n-\n-/* Test for an empty feature set.  */\n-\n-#define ARM_FSET_IS_EMPTY(A)\t\t\\\n-  (!((A).cpu[0]) && !((A).cpu[1]))\n-\n-/* Tests whether the cpu features of A are a subset of B.  */\n-\n-#define ARM_FSET_CPU_SUBSET(A,B)\t\t\t\t\t\\\n-  ((((A).cpu[0] & (B).cpu[0]) == (A).cpu[0])\t\t\t\t\\\n-   && (((A).cpu[1] & (B).cpu[1]) == (A).cpu[1]))\n-\n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n extern arm_feature_set insn_flags;"}, {"sha": "7ad0fbf0d803cfc9015b78ffdb4e8d2f94f43d1e", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -2250,24 +2250,40 @@ extern const char *arm_rewrite_mcpu (int argc, const char **argv);\n    \"   :%{march=*:-march=%*}}\"\t\t\t\t\t\\\n    BIG_LITTLE_SPEC\n \n+extern const char *arm_target_thumb_only (int argc, const char **argv);\n+#define TARGET_MODE_SPEC_FUNCTIONS\t\t\t\t\t\\\n+  { \"target_mode_check\", arm_target_thumb_only },\n+\n /* -mcpu=native handling only makes sense with compiler running on\n    an ARM chip.  */\n #if defined(__arm__)\n extern const char *host_detect_local_cpu (int argc, const char **argv);\n # define EXTRA_SPEC_FUNCTIONS\t\t\t\t\t\t\\\n   { \"local_cpu_detect\", host_detect_local_cpu },\t\t\t\\\n-  BIG_LITTLE_CPU_SPEC_FUNCTIONS\n+  BIG_LITTLE_CPU_SPEC_FUNCTIONS\t\t\t\t\t\t\\\n+  TARGET_MODE_SPEC_FUNCTIONS\n \n # define MCPU_MTUNE_NATIVE_SPECS\t\t\t\t\t\\\n    \" %{march=native:%<march=native %:local_cpu_detect(arch)}\"\t\t\\\n    \" %{mcpu=native:%<mcpu=native %:local_cpu_detect(cpu)}\"\t\t\\\n    \" %{mtune=native:%<mtune=native %:local_cpu_detect(tune)}\"\n #else\n # define MCPU_MTUNE_NATIVE_SPECS \"\"\n-# define EXTRA_SPEC_FUNCTIONS BIG_LITTLE_CPU_SPEC_FUNCTIONS\n+# define EXTRA_SPEC_FUNCTIONS\t\t\t\t\t\t\\\n+\tBIG_LITTLE_CPU_SPEC_FUNCTIONS\t\t\t\t\t\\\n+\tTARGET_MODE_SPEC_FUNCTIONS\n #endif\n \n-#define DRIVER_SELF_SPECS MCPU_MTUNE_NATIVE_SPECS\n+/* Automatically add -mthumb for Thumb-only targets if mode isn't specified\n+   via the configuration option --with-mode or via the command line. The\n+   function target_mode_check is called to do the check with either:\n+   - an array of -march values if any is given;\n+   - an array of -mcpu values if any is given;\n+   - an empty array.  */\n+#define TARGET_MODE_SPECS\t\t\t\t\t\t\\\n+  \" %{!marm:%{!mthumb:%:target_mode_check(%{march=*:%*;mcpu=*:%*;:})}}\"\n+\n+#define DRIVER_SELF_SPECS MCPU_MTUNE_NATIVE_SPECS TARGET_MODE_SPECS\n #define TARGET_SUPPORTS_WIDE_INT 1\n \n /* For switching between functions with different target attributes.  */"}, {"sha": "37083c4c3776804062a719e23eaf30a5f0632791", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -1,3 +1,9 @@\n+2016-11-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* gcc.target/arm/optional_thumb-1.c: New test.\n+\t* gcc.target/arm/optional_thumb-2.c: New test.\n+\t* gcc.target/arm/optional_thumb-3.c: New test.\n+\n 2016-11-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/htm-builtins-1.c (DEFAULT_MAX_REPETITIONS)"}, {"sha": "23df62887ba4aaa1d8717a34ecda9a40246f0552", "filename": "gcc/testsuite/gcc.target/arm/optional_thumb-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-1.c?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"-marm/-mthumb/-march/-mcpu given\" { *-*-*} { \"-marm\" \"-mthumb\" \"-march=*\" \"-mcpu=*\" } } */\n+/* { dg-options \"-march=armv6-m\" } */\n+\n+/* Check that -mthumb is not needed when compiling for a Thumb-only target.  */\n+\n+int foo;"}, {"sha": "4bd53a45eca97e62dd3b86d5a1a66c5ca21e7aad", "filename": "gcc/testsuite/gcc.target/arm/optional_thumb-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-2.c?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"-marm/-mthumb/-march/-mcpu given\" { *-*-*} { \"-marm\" \"-mthumb\" \"-march=*\" \"-mcpu=*\" } } */\n+/* { dg-options \"-mcpu=cortex-m4\" } */\n+\n+/* Check that -mthumb is not needed when compiling for a Thumb-only target.  */\n+\n+int foo;"}, {"sha": "f1fd5c8840b191e600c20a7817c611bb9bb645df", "filename": "gcc/testsuite/gcc.target/arm/optional_thumb-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e73d3c4277fa602999b3e3c104a06024932c70/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Foptional_thumb-3.c?ref=70e73d3c4277fa602999b3e3c104a06024932c70", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_cortex_m } */\n+/* { dg-skip-if \"-mthumb given\" { *-*-*} { \"-mthumb\" } } */\n+/* { dg-options \"-marm\" } */\n+/* { dg-error \"target CPU does not support ARM mode\" \"missing error with -marm on Thumb-only targets\" { target *-*-*} 0 } */\n+\n+/* Check that -marm gives an error when compiling for a Thumb-only target.  */\n+\n+int foo;"}]}