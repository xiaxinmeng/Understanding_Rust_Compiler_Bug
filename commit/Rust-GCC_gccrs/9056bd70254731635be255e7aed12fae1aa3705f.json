{"sha": "9056bd70254731635be255e7aed12fae1aa3705f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA1NmJkNzAyNTQ3MzE2MzViZTI1NWU3YWVkMTJmYWUxYWEzNzA1Zg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-06-29T18:57:25Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-29T18:57:25Z"}, "message": "Andrew Vaught <andyv@firstinter.net>\n\n2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\nAndrew Vaught  <andyv@firstinter.net>\n\nPR fortran/13249\nPR fortran/15481\n* declc (gfc_match_save): Adapt to new common structures,\ndon't allow saving USE-associated common.\n* dump-parse-tree (gfc_show_attr): (saved_)common are not\nsymbol attributes any longer.\n(gfc_show_symbol): Don't show old-style commons any longer.\n(gfc_show_namespace): Adapt call to gfc_traverse_symtree to new\ninterface.\n* gfortran.h (symbol_attribute): Remove common and saved_common\nattributes.\n(gfc_symbol): Remove common_head element.\n(gfc_common_head): New struct.\n(gfc_get_common_head): New macro.\n(gfc_symtree): Add field 'common' to union.\n(gfc_namespace): Add field 'common_root'; change type of field\n'blank_common' to blank_common.\n(gfc_add_data): New prototype.\n(gfc_traverse_symtree): Expect a symtree as first argument\ninstead of namespace.\n* match.c (gfc_get_common): New function.\n(match_common_name): Change to take char * as argument, adapt,\nfix bug with empty name.\n(gfc_match_common): Adapt to new data structures. Disallow\nredeclaration of USE-associated COMMON-block. Fix bug with\nempty common.\n(var_element): Adapt to new common structures.\n* match.h (gfc_get_common): Declare.\n* module.c: Add 2004 to copyright years, add commons to module\nfile layout description.\n(ab_attribute, attr_bits, mio_symbol_attributes): Remove code\nfor removed attributes.\n(mio_symbol): Adapt to new way of storing common relations.\n(load_commons): New function.\n(read_module): Skip common list on first pass, load_commons at\nsecond.\n(write_commons): New function.\n(write_module): Call write_commons().\n* symbol.c (gfc_add_saved_comon, gfc_add_common): Remove\nfunctions related to removed attributes.\n(gfc_add_data): New function.\n(gfc_clear_attr): Don't set removed attributes.\n(gfc_copy_attr): Don't copy removed attributes.\n(traverse_symtree): Remove.\n(gfc_traverse_symtree): Don't traverse symbol\ntree of the passed namespace, but require a symtree to be passed\ninstead. Unify with traverse_symtree.\n(gfc_traverse_ns): Call gfc_traverse_symtree according to new\ninterface.\n(save_symbol): Remove setting of removed attribute.\n* trans-common.c (gfc_sym_mangled_common_id): Change to\ntake 'char *' argument instead of 'gfc_symbol'.\n(build_common_decl, new_segment, translate_common): Adapt to new\ndata structures, add new\nargument name.\n(create_common): Adapt to new data structures, add new\nargument name. Fix typo in intialization of derived types.\n(finish_equivalences): Add second argument in call to\ncreate_common.\n(named_common): take 'gfc_symtree' instead of 'gfc_symbol'.\n(gfc_trans_common): Adapt to new data structures.\n* trans-decl.c (gfc_create_module_variables): Also output\nsymbols from commons.\n\nCo-Authored-By: Andrew Vaught <andyv@firstinter.net>\n\nFrom-SVN: r83871", "tree": {"sha": "1b6d752026c3acc16fa03a6a9d17146fbf0fd272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b6d752026c3acc16fa03a6a9d17146fbf0fd272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9056bd70254731635be255e7aed12fae1aa3705f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9056bd70254731635be255e7aed12fae1aa3705f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9056bd70254731635be255e7aed12fae1aa3705f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9056bd70254731635be255e7aed12fae1aa3705f/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d78f96d060bfbcdc39633b28df1143dd7150d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d78f96d060bfbcdc39633b28df1143dd7150d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d78f96d060bfbcdc39633b28df1143dd7150d2"}], "stats": {"total": 463, "additions": 298, "deletions": 165}, "files": [{"sha": "1623cb75d58d85cf39655ac7e4d3f4c16b36bf00", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -1,3 +1,70 @@\n+2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\tAndrew Vaught  <andyv@firstinter.net>\n+\n+\tPR fortran/13249\n+\tPR fortran/15481\n+\t* declc (gfc_match_save): Adapt to new common structures,\n+\tdon't allow saving USE-associated common.\n+\t* dump-parse-tree (gfc_show_attr): (saved_)common are not\n+\tsymbol attributes any longer.\n+\t(gfc_show_symbol): Don't show old-style commons any longer.\n+\t(gfc_show_namespace): Adapt call to gfc_traverse_symtree to new\n+\tinterface.\n+\t* gfortran.h (symbol_attribute): Remove common and saved_common\n+\tattributes.\n+\t(gfc_symbol): Remove common_head element.\n+\t(gfc_common_head): New struct.\n+\t(gfc_get_common_head): New macro.\n+\t(gfc_symtree): Add field 'common' to union.\n+\t(gfc_namespace): Add field 'common_root'; change type of field\n+\t'blank_common' to blank_common.\n+\t(gfc_add_data): New prototype.\n+\t(gfc_traverse_symtree): Expect a symtree as first argument\n+\tinstead of namespace.\n+\t* match.c (gfc_get_common): New function.\n+\t(match_common_name): Change to take char * as argument, adapt,\n+\tfix bug with empty name.\n+\t(gfc_match_common): Adapt to new data structures. Disallow\n+\tredeclaration of USE-associated COMMON-block. Fix bug with\n+\tempty common.\n+\t(var_element): Adapt to new common structures.\n+\t* match.h (gfc_get_common): Declare.\n+\t* module.c: Add 2004 to copyright years, add commons to module\n+\tfile layout description.\n+\t(ab_attribute, attr_bits, mio_symbol_attributes): Remove code\n+\tfor removed attributes.\n+\t(mio_symbol): Adapt to new way of storing common relations.\n+\t(load_commons): New function.\n+\t(read_module): Skip common list on first pass, load_commons at\n+\tsecond.\n+\t(write_commons): New function.\n+\t(write_module): Call write_commons().\n+\t* symbol.c (gfc_add_saved_comon, gfc_add_common): Remove\n+\tfunctions related to removed attributes.\n+\t(gfc_add_data): New function.\n+\t(gfc_clear_attr): Don't set removed attributes.\n+\t(gfc_copy_attr): Don't copy removed attributes.\n+\t(traverse_symtree): Remove.\n+\t(gfc_traverse_symtree): Don't traverse symbol \n+\ttree of the passed namespace, but require a symtree to be passed\n+\tinstead. Unify with traverse_symtree.\n+\t(gfc_traverse_ns): Call gfc_traverse_symtree according to new\n+\tinterface.\n+\t(save_symbol): Remove setting of removed attribute.\n+\t* trans-common.c (gfc_sym_mangled_common_id): Change to\n+\ttake 'char *' argument instead of 'gfc_symbol'.\n+\t(build_common_decl, new_segment, translate_common): Adapt to new\n+\tdata structures, add new\n+\targument name.\n+\t(create_common): Adapt to new data structures, add new\n+\targument name. Fix typo in intialization of derived types.\n+\t(finish_equivalences): Add second argument in call to\n+\tcreate_common.\n+\t(named_common): take 'gfc_symtree' instead of 'gfc_symbol'.\n+\t(gfc_trans_common): Adapt to new data structures.\n+\t* trans-decl.c (gfc_create_module_variables): Also output\n+\tsymbols from commons.\n+\n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* io.c: Add 2004 to copyright years."}, {"sha": "fab762fc63e59aff5a354e6810012b471b98630b", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -2427,6 +2427,8 @@ gfc_match_parameter (void)\n match\n gfc_match_save (void)\n {\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_common_head *c;\n   gfc_symbol *sym;\n   match m;\n \n@@ -2469,14 +2471,22 @@ gfc_match_save (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      m = gfc_match (\" / %s /\", &sym);\n+      m = gfc_match (\" / %n /\", &n);\n       if (m == MATCH_ERROR)\n \treturn MATCH_ERROR;\n       if (m == MATCH_NO)\n \tgoto syntax;\n \n-      if (gfc_add_saved_common (&sym->attr, NULL) == FAILURE)\n-\treturn MATCH_ERROR;\n+      c = gfc_get_common (n);\n+\n+      if (c->use_assoc) \n+\t{       \n+\t  gfc_error(\"COMMON block '%s' at %C is already USE associated\", n);\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      c->saved = 1;\n+\n       gfc_current_ns->seen_save = 1;\n \n     next_item:"}, {"sha": "3b7fc6911c4b629cbe51b3b147fd0598127d3695", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -544,8 +544,6 @@ gfc_show_attr (symbol_attribute * attr)\n     gfc_status (\" TARGET\");\n   if (attr->dummy)\n     gfc_status (\" DUMMY\");\n-  if (attr->common)\n-    gfc_status (\" COMMON\");\n   if (attr->result)\n     gfc_status (\" RESULT\");\n   if (attr->entry)\n@@ -559,8 +557,6 @@ gfc_show_attr (symbol_attribute * attr)\n     gfc_status (\" IN-NAMELIST\");\n   if (attr->in_common)\n     gfc_status (\" IN-COMMON\");\n-  if (attr->saved_common)\n-    gfc_status (\" SAVED-COMMON\");\n \n   if (attr->function)\n     gfc_status (\" FUNCTION\");\n@@ -616,7 +612,6 @@ gfc_show_symbol (gfc_symbol * sym)\n {\n   gfc_formal_arglist *formal;\n   gfc_interface *intr;\n-  gfc_symbol *s;\n \n   if (sym == NULL)\n     return;\n@@ -649,14 +644,6 @@ gfc_show_symbol (gfc_symbol * sym)\n \tgfc_status (\" %s\", intr->sym->name);\n     }\n \n-  if (sym->common_head)\n-    {\n-      show_indent ();\n-      gfc_status (\"Common members:\");\n-      for (s = sym->common_head; s; s = s->common_next)\n-\tgfc_status (\" %s\", s->name);\n-    }\n-\n   if (sym->result)\n     {\n       show_indent ();\n@@ -1445,7 +1432,7 @@ gfc_show_namespace (gfc_namespace * ns)\n \t}\n \n       gfc_current_ns = ns;\n-      gfc_traverse_symtree (ns, show_symtree);\n+      gfc_traverse_symtree (ns->sym_root, show_symtree);\n \n       for (op = GFC_INTRINSIC_BEGIN; op != GFC_INTRINSIC_END; op++)\n \t{"}, {"sha": "d35506ae6e68bd3a875a2748f1e9606e1de8e25d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -385,12 +385,12 @@ typedef struct\n   /* Variable attributes.  */\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, save:1, target:1,\n-    dummy:1, common:1, result:1, entry:1, assign:1;\n+    dummy:1, result:1, entry:1, assign:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n     use_assoc:1;\t\t/* Symbol has been use-associated.  */\n \n-  unsigned in_namelist:1, in_common:1, saved_common:1;\n+  unsigned in_namelist:1, in_common:1;\n   unsigned function:1, subroutine:1, generic:1;\n   unsigned implicit_type:1;\t/* Type defined via implicit rules */\n \n@@ -642,8 +642,7 @@ typedef struct gfc_symbol\n   struct gfc_symbol *result;\t/* function result symbol */\n   gfc_component *components;\t/* Derived type components */\n \n-  /* TODO: These three fields are mutually exclusive.  */\n-  struct gfc_symbol *common_head, *common_next;\t/* Links for COMMON syms */\n+  struct gfc_symbol *common_next;\t/* Links for COMMON syms */\n   /* Make sure setup code for dummy arguments is generated in the correct\n      order.  */\n   int dummy_order;\n@@ -671,6 +670,20 @@ typedef struct gfc_symbol\n gfc_symbol;\n \n \n+/* This structure is used to keep track of symbols in common blocks.  */\n+\n+typedef struct\n+{\n+  locus where;\n+  int use_assoc, saved;\n+  gfc_symbol *head;\n+} \n+gfc_common_head;\n+\n+#define gfc_get_common_head() gfc_getmem(sizeof(gfc_common_head))\n+\n+\n+\n /* Within a namespace, symbols are pointed to by symtree nodes that\n    are linked together in a balanced binary tree.  There can be\n    several symtrees pointing to the same symbol node via USE\n@@ -687,6 +700,7 @@ typedef struct gfc_symtree\n   {\n     gfc_symbol *sym;\t\t/* Symbol associated with this node */\n     gfc_user_op *uop;\n+    gfc_common_head *common;\n   }\n   n;\n \n@@ -696,7 +710,8 @@ gfc_symtree;\n \n typedef struct gfc_namespace\n {\n-  gfc_symtree *sym_root, *uop_root;\t/* Roots of the red/black symbol trees */\n+  /* Roots of the red/black symbol trees */\n+  gfc_symtree *sym_root, *uop_root, *common_root;\t\n \n   int set_flag[GFC_LETTERS];\n   gfc_typespec default_type[GFC_LETTERS];\t/* IMPLICIT typespecs */\n@@ -705,7 +720,7 @@ typedef struct gfc_namespace\n   gfc_interface *operator[GFC_INTRINSIC_OPS];\n   struct gfc_namespace *parent, *contained, *sibling;\n   struct gfc_code *code;\n-  gfc_symbol *blank_common;\n+  gfc_common_head blank_common;\n   struct gfc_equiv *equiv;\n   gfc_access default_access, operator_access[GFC_INTRINSIC_OPS];\n \n@@ -1447,6 +1462,7 @@ try gfc_add_dummy (symbol_attribute *, locus *);\n try gfc_add_generic (symbol_attribute *, locus *);\n try gfc_add_common (symbol_attribute *, locus *);\n try gfc_add_in_common (symbol_attribute *, locus *);\n+try gfc_add_data (symbol_attribute *, locus *);\n try gfc_add_in_namelist (symbol_attribute *, locus *);\n try gfc_add_sequence (symbol_attribute *, locus *);\n try gfc_add_elemental (symbol_attribute *, locus *);\n@@ -1501,7 +1517,7 @@ void gfc_free_namespace (gfc_namespace *);\n void gfc_symbol_init_2 (void);\n void gfc_symbol_done_2 (void);\n \n-void gfc_traverse_symtree (gfc_namespace *, void (*)(gfc_symtree *));\n+void gfc_traverse_symtree (gfc_symtree *, void (*)(gfc_symtree *));\n void gfc_traverse_ns (gfc_namespace *, void (*)(gfc_symbol *));\n void gfc_traverse_user_op (gfc_namespace *, void (*)(gfc_user_op *));\n void gfc_save_all (gfc_namespace *);"}, {"sha": "d605361ec0377c035a9c3c0ef287e3fba250a4d0", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -2246,23 +2246,49 @@ gfc_match_implicit (void)\n }\n \n \n+/* Given a name, return a pointer to the common head structure,\n+   creating it if it does not exist.\n+   TODO: Add to global symbol tree.  */\n+\n+gfc_common_head *\n+gfc_get_common (char *name)\n+{\n+  gfc_symtree *st;\n+\n+  st = gfc_find_symtree (gfc_current_ns->common_root, name);\n+  if (st == NULL)\n+    st = gfc_new_symtree (&gfc_current_ns->common_root, name);\n+\n+  if (st->n.common == NULL)\n+    {\n+      st->n.common = gfc_get_common_head ();\n+      st->n.common->where = gfc_current_locus;\n+    }\n+\n+  return st->n.common;\n+}\n+\n+\n /* Match a common block name.  */\n \n static match\n-match_common_name (gfc_symbol ** sym)\n+match_common_name (char *name)\n {\n   match m;\n \n   if (gfc_match_char ('/') == MATCH_NO)\n-    return MATCH_NO;\n+    {\n+      name[0] = '\\0';\n+      return MATCH_YES;\n+    }\n \n   if (gfc_match_char ('/') == MATCH_YES)\n     {\n-      *sym = NULL;\n+      name[0] = '\\0';\n       return MATCH_YES;\n     }\n \n-  m = gfc_match_symbol (sym, 0);\n+  m = gfc_match_name (name);\n \n   if (m == MATCH_ERROR)\n     return MATCH_ERROR;\n@@ -2279,38 +2305,48 @@ match_common_name (gfc_symbol ** sym)\n match\n gfc_match_common (void)\n {\n-  gfc_symbol *sym, *common_name, **head, *tail, *old_blank_common;\n+  gfc_symbol *sym, **head, *tail, *old_blank_common;\n+  char name[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_common_head *t;\n   gfc_array_spec *as;\n   match m;\n \n-  old_blank_common = gfc_current_ns->blank_common;\n+  old_blank_common = gfc_current_ns->blank_common.head;\n   if (old_blank_common)\n     {\n       while (old_blank_common->common_next)\n \told_blank_common = old_blank_common->common_next;\n     }\n \n-  common_name = NULL;\n   as = NULL;\n \n   if (gfc_match_eos () == MATCH_YES)\n     goto syntax;\n \n   for (;;)\n     {\n-      m = match_common_name (&common_name);\n+      m = match_common_name (name);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n \n-      if (common_name == NULL)\n-\thead = &gfc_current_ns->blank_common;\n+      if (name[0] == '\\0')\n+\t{\n+\t  t = &gfc_current_ns->blank_common;\n+\t  if (t->head == NULL)\n+\t    t->where = gfc_current_locus;\n+\t  head = &t->head;\n+\t}\n       else\n \t{\n-\t  head = &common_name->common_head;\n+\t  t = gfc_get_common (name);\n+\t  head = &t->head;\n \n-\t  if (!common_name->attr.common\n-\t      && gfc_add_common (&common_name->attr, NULL) == FAILURE)\n-\t    goto cleanup;\n+\t  if (t->use_assoc)\n+\t    {\n+\t      gfc_error (\"COMMON block '%s' at %C has already \"\n+\t\t\t \"been USE-associated\");\n+\t      goto cleanup;\n+\t    }\n \t}\n \n       if (*head == NULL)\n@@ -2323,6 +2359,9 @@ gfc_match_common (void)\n \t}\n \n       /* Grab the list of symbols.  */\n+      if (gfc_match_eos () == MATCH_YES)\n+\tgoto done;\n+  \n       for (;;)\n \t{\n \t  m = gfc_match_symbol (&sym, 0);\n@@ -2338,16 +2377,18 @@ gfc_match_common (void)\n \t      goto cleanup;\n \t    }\n \n+\t  if (gfc_add_in_common (&sym->attr, NULL) == FAILURE) \n+\t    goto cleanup;\n+\n \t  if (sym->value != NULL\n-\t      && (common_name == NULL || !sym->attr.data))\n+\t      && (name[0] == '\\0' || !sym->attr.data))\n \t    {\n-\t      if (common_name == NULL)\n+\t      if (name[0] == '\\0')\n \t\tgfc_error (\"Previously initialized symbol '%s' in \"\n \t\t\t   \"blank COMMON block at %C\", sym->name);\n \t      else\n \t\tgfc_error (\"Previously initialized symbol '%s' in \"\n-\t\t\t   \"COMMON block '%s' at %C\", sym->name,\n-\t\t\t   common_name->name);\n+\t\t\t   \"COMMON block '%s' at %C\", sym->name, name);\n \t      goto cleanup;\n \t    }\n \n@@ -2422,7 +2463,7 @@ gfc_match_common (void)\n   if (old_blank_common)\n     old_blank_common->common_next = NULL;\n   else\n-    gfc_current_ns->blank_common = NULL;\n+    gfc_current_ns->blank_common.head = NULL;\n   gfc_free_array_spec (as);\n   return MATCH_ERROR;\n }\n@@ -2827,7 +2868,8 @@ static match\n var_element (gfc_data_variable * new)\n {\n   match m;\n-  gfc_symbol *sym, *t;\n+  gfc_symbol *sym;\n+  gfc_common_head *t;\n \n   memset (new, '\\0', sizeof (gfc_data_variable));\n \n@@ -2847,17 +2889,20 @@ var_element (gfc_data_variable * new)\n       return MATCH_ERROR;\n     }\n \n+#if 0 // TODO: Find out where to move this message\n   if (sym->attr.in_common)\n     /* See if sym is in the blank common block.  */\n-    for (t = sym->ns->blank_common; t; t = t->common_next)\n-      if (sym == t)\n+    for (t = &sym->ns->blank_common; t; t = t->common_next)\n+      if (sym == t->head)\n \t{\n \t  gfc_error (\"DATA statement at %C may not initialize variable \"\n \t\t     \"'%s' from blank COMMON\", sym->name);\n \t  return MATCH_ERROR;\n \t}\n+#endif\n \n-  sym->attr.data = 1;\n+  if (gfc_add_data (&sym->attr, &new->expr->where) == FAILURE)\n+    return MATCH_ERROR;\n \n   return MATCH_YES;\n }"}, {"sha": "85729ec0ae834a1ae855145fc0602a95997d40e2", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -89,6 +89,10 @@ match gfc_match_where (gfc_statement *);\n match gfc_match_elsewhere (void);\n match gfc_match_forall (gfc_statement *);\n \n+/* Other functions.  */\n+\n+gfc_common_head *gfc_get_common (char *);\n+\n /* decl.c */\n \n match gfc_match_null (gfc_expr **);"}, {"sha": "7f720ba97700ec17e962ae8200e33695c56b31f8", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -1,6 +1,7 @@\n /* Handle modules, which amounts to loading and saving symbols and\n    their attendant structures.\n-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, \n+   Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -43,6 +44,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    ( ( <name of generic interface> <module of generic interface> <i/f1> ... )\n      ...\n    )\n+   ( ( <common name> <symbol> <saved flag>)\n+     ...\n+   )\n    ( <Symbol Number (in no particular order)>\n      <True name of symbol>\n      <Module name of symbol>\n@@ -1361,8 +1365,8 @@ mio_internal_string (char *string)\n \n typedef enum\n { AB_ALLOCATABLE, AB_DIMENSION, AB_EXTERNAL, AB_INTRINSIC, AB_OPTIONAL,\n-  AB_POINTER, AB_SAVE, AB_TARGET, AB_DUMMY, AB_COMMON, AB_RESULT,\n-  AB_ENTRY, AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, AB_SAVED_COMMON,\n+  AB_POINTER, AB_SAVE, AB_TARGET, AB_DUMMY, AB_RESULT,\n+  AB_ENTRY, AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, \n   AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE, AB_ELEMENTAL, AB_PURE,\n   AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT\n }\n@@ -1379,13 +1383,11 @@ static const mstring attr_bits[] =\n     minit (\"SAVE\", AB_SAVE),\n     minit (\"TARGET\", AB_TARGET),\n     minit (\"DUMMY\", AB_DUMMY),\n-    minit (\"COMMON\", AB_COMMON),\n     minit (\"RESULT\", AB_RESULT),\n     minit (\"ENTRY\", AB_ENTRY),\n     minit (\"DATA\", AB_DATA),\n     minit (\"IN_NAMELIST\", AB_IN_NAMELIST),\n     minit (\"IN_COMMON\", AB_IN_COMMON),\n-    minit (\"SAVED_COMMON\", AB_SAVED_COMMON),\n     minit (\"FUNCTION\", AB_FUNCTION),\n     minit (\"SUBROUTINE\", AB_SUBROUTINE),\n     minit (\"SEQUENCE\", AB_SEQUENCE),\n@@ -1450,8 +1452,6 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_TARGET, attr_bits);\n       if (attr->dummy)\n \tMIO_NAME(ab_attribute) (AB_DUMMY, attr_bits);\n-      if (attr->common)\n-\tMIO_NAME(ab_attribute) (AB_COMMON, attr_bits);\n       if (attr->result)\n \tMIO_NAME(ab_attribute) (AB_RESULT, attr_bits);\n       if (attr->entry)\n@@ -1463,8 +1463,6 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_IN_NAMELIST, attr_bits);\n       if (attr->in_common)\n \tMIO_NAME(ab_attribute) (AB_IN_COMMON, attr_bits);\n-      if (attr->saved_common)\n-\tMIO_NAME(ab_attribute) (AB_SAVED_COMMON, attr_bits);\n \n       if (attr->function)\n \tMIO_NAME(ab_attribute) (AB_FUNCTION, attr_bits);\n@@ -1527,9 +1525,6 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_DUMMY:\n \t      attr->dummy = 1;\n \t      break;\n-\t    case AB_COMMON:\n-\t      attr->common = 1;\n-\t      break;\n \t    case AB_RESULT:\n \t      attr->result = 1;\n \t      break;\n@@ -1545,9 +1540,6 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_IN_COMMON:\n \t      attr->in_common = 1;\n \t      break;\n-\t    case AB_SAVED_COMMON:\n-\t      attr->saved_common = 1;\n-\t      break;\n \t    case AB_FUNCTION:\n \t      attr->function = 1;\n \t      break;\n@@ -2679,7 +2671,6 @@ mio_symbol (gfc_symbol * sym)\n     }\n \n   /* Save/restore common block links */\n-  mio_symbol_ref (&sym->common_head);\n   mio_symbol_ref (&sym->common_next);\n \n   mio_formal_arglist (sym);\n@@ -2698,9 +2689,6 @@ mio_symbol (gfc_symbol * sym)\n     sym->component_access =\n       MIO_NAME(gfc_access) (sym->component_access, access_types);\n \n-  mio_symbol_ref (&sym->common_head);\n-  mio_symbol_ref (&sym->common_next);\n-\n   mio_rparen ();\n }\n \n@@ -2820,6 +2808,34 @@ load_generic_interfaces (void)\n }\n \n \n+/* Load common blocks.  */\n+\n+static void\n+load_commons(void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_common_head *p;\n+\n+  mio_lparen ();\n+\n+  while (peek_atom () != ATOM_RPAREN)\n+    {\n+      mio_lparen ();\n+      mio_internal_string (name);\n+\n+      p = gfc_get_common (name);\n+\n+      mio_symbol_ref (&p->head);\n+      mio_integer (&p->saved);\n+      p->use_assoc = 1;\n+\n+      mio_rparen();\n+    }\n+\n+  mio_rparen();\n+}\n+\n+\n /* Recursive function to traverse the pointer_info tree and load a\n    needed symbol.  We return nonzero if we load a symbol and stop the\n    traversal, because the act of loading can alter the tree.  */\n@@ -2931,6 +2947,7 @@ read_module (void)\n   get_module_locus (&user_operators);\n   skip_list ();\n   skip_list ();\n+  skip_list ();\n \n   mio_lparen ();\n \n@@ -3067,6 +3084,8 @@ read_module (void)\n   load_operator_interfaces ();\n   load_generic_interfaces ();\n \n+  load_commons ();\n+\n   /* At this point, we read those symbols that are needed but haven't\n      been loaded yet.  If one symbol requires another, the other gets\n      marked as NEEDED if its previous state was UNUSED.  */\n@@ -3137,6 +3156,30 @@ check_access (gfc_access specific_access, gfc_access default_access)\n }\n \n \n+/* Write a common block to the module */\n+\n+static void\n+write_common (gfc_symtree *st)\n+{\n+  gfc_common_head *p;\n+\n+  if (st == NULL)\n+    return;\n+\n+  write_common(st->left);\n+  write_common(st->right);\n+\n+  mio_lparen();\n+  mio_internal_string(st->name);\n+\n+  p = st->n.common;\n+  mio_symbol_ref(&p->head);\n+  mio_integer(&p->saved);\n+\n+  mio_rparen();\n+}\n+\n+\n /* Write a symbol to the module.  */\n \n static void\n@@ -3329,6 +3372,12 @@ write_module (void)\n   write_char ('\\n');\n   write_char ('\\n');\n \n+  mio_lparen ();\n+  write_common (gfc_current_ns->common_root);\n+  mio_rparen ();\n+  write_char ('\\n');\n+  write_char ('\\n');\n+\n   /* Write symbol information.  First we traverse all symbols in the\n      primary namespace, writing those that need to be written.\n      Sometimes writing one symbol will cause another to need to be\n@@ -3347,7 +3396,7 @@ write_module (void)\n   write_char ('\\n');\n \n   mio_lparen ();\n-  gfc_traverse_symtree (gfc_current_ns, write_symtree);\n+  gfc_traverse_symtree (gfc_current_ns->sym_root, write_symtree);\n   mio_rparen ();\n }\n "}, {"sha": "3f9ca813c65d1bad6f0edf8792d84ba6300073cb", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -1,5 +1,6 @@\n /* Main parser.\n-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, \n+   Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC."}, {"sha": "c1d0212a13e1d8ffdaa1430d2abf517a5d1d3977", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 17, "deletions": 60, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -672,24 +672,6 @@ gfc_add_save (symbol_attribute * attr, locus * where)\n }\n \n \n-try\n-gfc_add_saved_common (symbol_attribute * attr, locus * where)\n-{\n-\n-  if (check_used (attr, where))\n-    return FAILURE;\n-\n-  if (attr->saved_common)\n-    {\n-      duplicate_attr (\"SAVE\", where);\n-      return FAILURE;\n-    }\n-\n-  attr->saved_common = 1;\n-  return check_conflict (attr, where);\n-}\n-\n-\n try\n gfc_add_target (symbol_attribute * attr, locus * where)\n {\n@@ -721,22 +703,6 @@ gfc_add_dummy (symbol_attribute * attr, locus * where)\n }\n \n \n-try\n-gfc_add_common (symbol_attribute * attr, locus * where)\n-{\n-  /* TODO: We currently add common blocks into the same namespace as normal\n-     variables.  This is wrong.  Disable the checks below as a temporary\n-     hack.  See PR13249  */\n-#if 0\n-  if (check_used (attr, where) || check_done (attr, where))\n-    return FAILURE;\n-#endif\n-\n-  attr->common = 1;\n-  return check_conflict (attr, where);\n-}\n-\n-\n try\n gfc_add_in_common (symbol_attribute * attr, locus * where)\n {\n@@ -756,6 +722,18 @@ gfc_add_in_common (symbol_attribute * attr, locus * where)\n }\n \n \n+try\n+gfc_add_data (symbol_attribute *attr, locus *where)\n+{\n+\n+  if (check_used (attr, where))\n+    return FAILURE;\n+\n+  attr->data = 1;\n+  return check_conflict (attr, where);\n+}\n+\n+\n try\n gfc_add_in_namelist (symbol_attribute * attr, locus * where)\n {\n@@ -1061,15 +1039,13 @@ gfc_clear_attr (symbol_attribute * attr)\n   attr->save = 0;\n   attr->target = 0;\n   attr->dummy = 0;\n-  attr->common = 0;\n   attr->result = 0;\n   attr->entry = 0;\n   attr->data = 0;\n   attr->use_assoc = 0;\n   attr->in_namelist = 0;\n \n   attr->in_common = 0;\n-  attr->saved_common = 0;\n   attr->function = 0;\n   attr->subroutine = 0;\n   attr->generic = 0;\n@@ -1122,8 +1098,6 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n     goto fail;\n   if (src->dummy && gfc_add_dummy (dest, where) == FAILURE)\n     goto fail;\n-  if (src->common && gfc_add_common (dest, where) == FAILURE)\n-    goto fail;\n   if (src->result && gfc_add_result (dest, where) == FAILURE)\n     goto fail;\n   if (src->entry)\n@@ -1134,8 +1108,6 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n \n   if (src->in_common && gfc_add_in_common (dest, where) == FAILURE)\n     goto fail;\n-  if (src->saved_common && gfc_add_saved_common (dest, where) == FAILURE)\n-    goto fail;\n \n   if (src->generic && gfc_add_generic (dest, where) == FAILURE)\n     goto fail;\n@@ -2323,28 +2295,19 @@ clear_sym_mark (gfc_symtree * st)\n \n /* Recursively traverse the symtree nodes.  */\n \n-static void\n-traverse_symtree (gfc_symtree * st, void (*func) (gfc_symtree *))\n+void\n+gfc_traverse_symtree (gfc_symtree * st, void (*func) (gfc_symtree *))\n {\n-\n   if (st != NULL)\n     {\n       (*func) (st);\n \n-      traverse_symtree (st->left, func);\n-      traverse_symtree (st->right, func);\n+      gfc_traverse_symtree (st->left, func);\n+      gfc_traverse_symtree (st->right, func);\n     }\n }\n \n \n-void\n-gfc_traverse_symtree (gfc_namespace * ns, void (*func) (gfc_symtree *))\n-{\n-\n-  traverse_symtree (ns->sym_root, func);\n-}\n-\n-\n /* Recursive namespace traversal function.  */\n \n static void\n@@ -2370,7 +2333,7 @@ void\n gfc_traverse_ns (gfc_namespace * ns, void (*func) (gfc_symbol *))\n {\n \n-  gfc_traverse_symtree (ns, clear_sym_mark);\n+  gfc_traverse_symtree (ns->sym_root, clear_sym_mark);\n \n   traverse_ns (ns->sym_root, func);\n }\n@@ -2385,12 +2348,6 @@ save_symbol (gfc_symbol * sym)\n   if (sym->attr.use_assoc)\n     return;\n \n-  if (sym->attr.common)\n-    {\n-      gfc_add_saved_common (&sym->attr, &sym->declared_at);\n-      return;\n-    }\n-\n   if (sym->attr.in_common\n       || sym->attr.dummy\n       || sym->attr.flavor != FL_VARIABLE)"}, {"sha": "769469d9ccacafd640f829c5af57e848165fa2de", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -168,24 +168,24 @@ add_segments (segment_info *list, segment_info *v)\n /* Construct mangled common block name from symbol name.  */\n \n static tree\n-gfc_sym_mangled_common_id (gfc_symbol *sym)\n+gfc_sym_mangled_common_id (const char  *name)\n {\n   int has_underscore;\n-  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n+  char mangled_name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n-  if (strcmp (sym->name, BLANK_COMMON_NAME) == 0)\n-    return get_identifier (sym->name);\n+  if (strcmp (name, BLANK_COMMON_NAME) == 0)\n+    return get_identifier (name);\n   if (gfc_option.flag_underscoring)\n     {\n-      has_underscore = strchr (sym->name, '_') != 0;\n+      has_underscore = strchr (name, '_') != 0;\n       if (gfc_option.flag_second_underscore && has_underscore)\n-        snprintf (name, sizeof name, \"%s__\", sym->name);\n+        snprintf (mangled_name, sizeof mangled_name, \"%s__\", name);\n       else\n-        snprintf (name, sizeof name, \"%s_\", sym->name);\n-      return get_identifier (name);\n+        snprintf (mangled_name, sizeof mangled_name, \"%s_\", name);\n+      return get_identifier (mangled_name);\n     }\n   else\n-    return get_identifier (sym->name);\n+    return get_identifier (name);\n }\n \n \n@@ -252,7 +252,8 @@ build_equiv_decl (tree union_type, bool is_init)\n /* Get storage for common block.  */\n \n static tree\n-build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n+build_common_decl (gfc_common_head *com, const char *name, \n+\t\t   tree union_type, bool is_init)\n {\n   gfc_symbol *common_sym;\n   tree decl;\n@@ -261,7 +262,7 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n   if (gfc_common_ns == NULL)\n     gfc_common_ns = gfc_get_namespace (NULL);\n \n-  gfc_get_symbol (sym->name, gfc_common_ns, &common_sym);\n+  gfc_get_symbol (name, gfc_common_ns, &common_sym);\n   decl = common_sym->backend_decl;\n \n   /* Update the size of this common block as needed.  */\n@@ -273,9 +274,9 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n           /* Named common blocks of the same name shall be of the same size\n              in all scoping units of a program in which they appear, but\n              blank common blocks may be of different sizes.  */\n-          if (strcmp (sym->name, BLANK_COMMON_NAME))\n+          if (strcmp (name, BLANK_COMMON_NAME))\n               gfc_warning (\"Named COMMON block '%s' at %L shall be of the \"\n-                           \"same size\", sym->name, &sym->declared_at);\n+                           \"same size\", name, &com->where);\n           DECL_SIZE_UNIT (decl) = size;\n         }\n      }\n@@ -289,8 +290,8 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n   /* If there is no backend_decl for the common block, build it.  */\n   if (decl == NULL_TREE)\n     {\n-      decl = build_decl (VAR_DECL, get_identifier (sym->name), union_type);\n-      SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_common_id (sym));\n+      decl = build_decl (VAR_DECL, get_identifier (name), union_type);\n+      SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_common_id (name));\n       TREE_PUBLIC (decl) = 1;\n       TREE_STATIC (decl) = 1;\n       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;\n@@ -323,7 +324,7 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n    backend declarations for all of the elements.  */\n \n static void\n-create_common (gfc_symbol *sym)\n+create_common (gfc_common_head *com, const char *name)\n { \n   segment_info *h, *next_s; \n   tree union_type;\n@@ -354,8 +355,8 @@ create_common (gfc_symbol *sym)\n     }\n   finish_record_layout (rli, true);\n \n-  if (sym)\n-    decl = build_common_decl (sym, union_type, is_init);\n+  if (com)\n+    decl = build_common_decl (com, name, union_type, is_init);\n   else\n     decl = build_equiv_decl (union_type, is_init);\n \n@@ -395,7 +396,7 @@ create_common (gfc_symbol *sym)\n \n \t\t    case BT_DERIVED:\n \t\t      gfc_init_se (&se, NULL);\n-\t\t      gfc_conv_structure (&se, sym->value, 1);\n+\t\t      gfc_conv_structure (&se, h->sym->value, 1);\n \t\t      break;\n \n \t\t    default:\n@@ -725,7 +726,7 @@ add_equivalences (void)\n    and all of the symbols equivalenced with that symbol.  */\n  \n static void\n-new_segment (gfc_symbol *common_sym, gfc_symbol *sym)\n+new_segment (gfc_common_head *common, const char *name, gfc_symbol *sym)\n {\n   HOST_WIDE_INT length;\n \n@@ -742,7 +743,7 @@ new_segment (gfc_symbol *common_sym, gfc_symbol *sym)\n   if (current_segment->offset < 0)\n     gfc_error (\"The equivalence set for '%s' cause an invalid extension \"\n \t       \"to COMMON '%s' at %L\",\n-\t       sym->name, common_sym->name, &common_sym->declared_at);\n+\t       sym->name, name, &common->where);\n \n   /* The offset of the next common variable.  */ \n   current_offset += length;\n@@ -783,7 +784,7 @@ finish_equivalences (gfc_namespace *ns)\n \t  v->offset -= min_offset;\n \n         current_common = current_segment;\n-        create_common (NULL);\n+        create_common (NULL, NULL);\n         break;\n       }\n }\n@@ -792,7 +793,8 @@ finish_equivalences (gfc_namespace *ns)\n /* Translate a single common block.  */\n \n static void \n-translate_common (gfc_symbol *common_sym, gfc_symbol *var_list)\n+translate_common (gfc_common_head *common, const char *name, \n+\t\t  gfc_symbol *var_list)\n {\n   gfc_symbol *sym;\n \n@@ -803,20 +805,19 @@ translate_common (gfc_symbol *common_sym, gfc_symbol *var_list)\n   for (sym = var_list; sym; sym = sym->common_next)\n     {\n       if (! sym->equiv_built)\n-\tnew_segment (common_sym, sym);\n+\tnew_segment (common, name, sym);\n     }\n \n-  create_common (common_sym);\n+  create_common (common, name);\n }          \n  \n \n /* Work function for translating a named common block.  */\n \n static void\n-named_common (gfc_symbol *s)\n+named_common (gfc_symtree *st)\n {\n-  if (s->attr.common)\n-    translate_common (s, s->common_head);\n+  translate_common (st->n.common, st->name, st->n.common->head);\n }\n \n \n@@ -827,17 +828,17 @@ named_common (gfc_symbol *s)\n void \n gfc_trans_common (gfc_namespace *ns)\n {\n-  gfc_symbol *sym;\n+  gfc_common_head *c;\n \n   /* Translate the blank common block.  */\n-  if (ns->blank_common != NULL)\n+  if (ns->blank_common.head != NULL)\n     {\n-      gfc_get_symbol (BLANK_COMMON_NAME, ns, &sym);\n-      translate_common (sym, ns->blank_common);\n+      c = gfc_get_common_head ();\n+      translate_common (c, BLANK_COMMON_NAME, ns->blank_common.head);\n     }\n  \n   /* Translate all named common blocks.  */\n-  gfc_traverse_ns (ns, named_common); \n+  gfc_traverse_symtree (ns->common_root, named_common); \n \n   /* Commit the newly created symbols for common blocks.  */\n   gfc_commit_symbols ();"}, {"sha": "e642467168092b3f41d69a9f65191be2f0f73bf3", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9056bd70254731635be255e7aed12fae1aa3705f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=9056bd70254731635be255e7aed12fae1aa3705f", "patch": "@@ -1787,10 +1787,6 @@ gfc_create_module_variable (gfc_symbol * sym)\n       internal_error (\"module symbol %s in wrong namespace\", sym->name);\n     }\n \n-  /* Don't ouptut symbols from common blocks.  */\n-  if (sym->attr.common)\n-    return;\n-\n   /* Only output variables and array valued parametes.  */\n   if (sym->attr.flavor != FL_VARIABLE\n       && (sym->attr.flavor != FL_PARAMETER || sym->attr.dimension == 0))"}]}