{"sha": "deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGViMjU0ZTAyOWM5NDMwYTBjM2QwY2IwNDRlNGNhN2IzZjE1YjYxOQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:04:15Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:04:15Z"}, "message": "[arm] Early expansion of uaddvdi4.\n\nThis code borrows strongly on the uaddvti4 expansion for aarch64 since\nthe principles are similar.  Firstly, if the one of the low words of\nthe expansion is 0, we can simply copy the other low word to the\ndestination and use uaddvsi4 for the upper word.  If that doesn't work\nwe have to handle three possible cases for the upper work (the lower\nword is simply an add-with-carry operation as for adddi3): zero in the\nupper word, some other constant and a register (each has a different\ncanonicalization).  We use CC_ADCmode (a new CC mode variant) to\ndescribe the cases as the introduction of the carry means we can\nno-longer use the normal overflow trick of comparing the sum against\none of the operands.\n\n\t* config/arm/arm-modes.def (CC_ADC): New CC mode.\n\t* config/arm/arm.c (arm_select_cc_mode): Detect selection of\n\tCC_ADCmode.\n\t(maybe_get_arm_condition_code): Handle CC_ADCmode.\n\t* config/arm/arm.md (uaddvdi4): Early expansion of unsigned addition\n\twith overflow.\n\t(addsi3_cin_cout_reg, addsi3_cin_cout_imm, addsi3_cin_cout_0): New\n\texpand patterns.\n\t(addsi3_cin_cout_reg_insn, addsi3_cin_cout_0_insn): New insn patterns\n\t(addsi3_cin_cout_imm_insn): Likewise.\n\t(adddi3_compareC): Delete insn.\n\t* config/arm/predicates.md (arm_carry_operation): Handle CC_ADCmode.\n\nFrom-SVN: r277183", "tree": {"sha": "298b85caada95864b050d03a65267b8c76b1496f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/298b85caada95864b050d03a65267b8c76b1496f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/comments", "author": null, "committer": null, "parents": [{"sha": "ed6588f239790be8437515ca2dc5e44568963342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6588f239790be8437515ca2dc5e44568963342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed6588f239790be8437515ca2dc5e44568963342"}], "stats": {"total": 208, "additions": 188, "deletions": 20}, "files": [{"sha": "902cf51a37c8aa9d6d5061aa820592122aa2cc10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "patch": "@@ -1,3 +1,18 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm-modes.def (CC_ADC): New CC mode.\n+\t* config/arm/arm.c (arm_select_cc_mode): Detect selection of\n+\tCC_ADCmode.\n+\t(maybe_get_arm_condition_code): Handle CC_ADCmode.\n+\t* config/arm/arm.md (uaddvdi4): Early expansion of unsigned addition\n+\twith overflow.\n+\t(addsi3_cin_cout_reg, addsi3_cin_cout_imm, addsi3_cin_cout_0): New\n+\texpand patterns.\n+\t(addsi3_cin_cout_reg_insn, addsi3_cin_cout_0_insn): New insn patterns\n+\t(addsi3_cin_cout_imm_insn): Likewise.\n+\t(adddi3_compareC): Delete insn.\n+\t* config/arm/predicates.md (arm_carry_operation): Handle CC_ADCmode.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (adddi3): Call gen_addsi3_compare_op1."}, {"sha": "a6b520df32d63c10cdba3cf4d1c2a4e339e9e160", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "patch": "@@ -42,6 +42,9 @@ ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n    CC_Bmode should be used if only the C flag is correct after a subtract\n      (eg after an unsigned borrow with carry-in propagation).\n    (used for DImode signed comparisons).\n+   CC_ADCmode is used when the carry is formed from the output of ADC for an\n+     addtion.  In this case we cannot use the trick of comparing the sum\n+     against one of the other operands.\n    CCmode should be used otherwise.  */\n \n CC_MODE (CC_NOOV);\n@@ -65,6 +68,7 @@ CC_MODE (CC_C);\n CC_MODE (CC_B);\n CC_MODE (CC_N);\n CC_MODE (CC_V);\n+CC_MODE (CC_ADC);\n \n /* Vector modes.  */\n VECTOR_MODES (INT, 4);        /*            V4QI V2HI */"}, {"sha": "fb1a68106519ae2cbefe81ad535e2a9f39545433", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "patch": "@@ -15387,6 +15387,14 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n       && (rtx_equal_p (XEXP (x, 0), y) || rtx_equal_p (XEXP (x, 1), y)))\n     return CC_Cmode;\n \n+  if (GET_MODE (x) == DImode\n+      && GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == ZERO_EXTEND\n+      && CONST_INT_P (y)\n+      && UINTVAL (y) == 0x800000000\n+      && (op == GEU || op == LTU))\n+    return CC_ADCmode;\n+\n   if (GET_MODE (x) == DImode\n       && (op == GE || op == LT)\n       && GET_CODE (x) == SIGN_EXTEND\n@@ -23952,6 +23960,14 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n+    case E_CC_ADCmode:\n+      switch (comp_code)\n+\t{\n+\tcase GEU: return ARM_CS;\n+\tcase LTU: return ARM_CC;\n+\tdefault: return ARM_NV;\n+\t}\n+\n     case E_CCmode:\n     case E_CC_RSBmode:\n       switch (comp_code)"}, {"sha": "9f0e43571fdbb99b3bf1980ff7b082fbd8d2fe84", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 152, "deletions": 19, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "patch": "@@ -517,16 +517,165 @@\n (define_expand \"uaddvdi4\"\n   [(match_operand:DI 0 \"s_register_operand\")\n    (match_operand:DI 1 \"s_register_operand\")\n-   (match_operand:DI 2 \"s_register_operand\")\n+   (match_operand:DI 2 \"reg_or_int_operand\")\n    (match_operand 3 \"\")]\n   \"TARGET_32BIT\"\n {\n-  emit_insn (gen_adddi3_compareC (operands[0], operands[1], operands[2]));\n-  arm_gen_unlikely_cbranch (LTU, CC_Cmode, operands[3]);\n+  rtx lo_result, hi_result;\n+  rtx lo_op1, hi_op1, lo_op2, hi_op2;\n+  arm_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,\n+\t\t\t  &lo_op2, &hi_op2);\n+  lo_result = gen_lowpart (SImode, operands[0]);\n+  hi_result = gen_highpart (SImode, operands[0]);\n+\n+  if (lo_op2 == const0_rtx)\n+    {\n+      emit_move_insn (lo_result, lo_op1);\n+      if (!arm_add_operand (hi_op2, SImode))\n+\thi_op2 = force_reg (SImode, hi_op2);\n+\n+      gen_uaddvsi4 (hi_result, hi_op1, hi_op2, operands[3]);\n+    }\n+  else\n+    {\n+      if (!arm_add_operand (lo_op2, SImode))\n+\tlo_op2 = force_reg (SImode, lo_op2);\n+      if (!arm_not_operand (hi_op2, SImode))\n+\thi_op2 = force_reg (SImode, hi_op2);\n+\n+      emit_insn (gen_addsi3_compare_op1 (lo_result, lo_op1, lo_op2));\n+\n+      if (hi_op2 == const0_rtx)\n+        emit_insn (gen_addsi3_cin_cout_0 (hi_result, hi_op1));\n+      else if (CONST_INT_P (hi_op2))\n+        emit_insn (gen_addsi3_cin_cout_imm (hi_result, hi_op1, hi_op2));\n+      else\n+        emit_insn (gen_addsi3_cin_cout_reg (hi_result, hi_op1, hi_op2));\n+\n+      arm_gen_unlikely_cbranch (GEU, CC_ADCmode, operands[3]);\n+    }\n \n   DONE;\n })\n \n+(define_expand \"addsi3_cin_cout_reg\"\n+  [(parallel\n+    [(set (match_dup 3)\n+\t  (compare:CC_ADC\n+\t   (plus:DI\n+\t    (plus:DI (match_dup 4)\n+\t\t     (zero_extend:DI (match_operand:SI 1 \"s_register_operand\")))\n+\t    (zero_extend:DI (match_operand:SI 2 \"s_register_operand\")))\n+\t   (const_int 4294967296)))\n+     (set (match_operand:SI 0 \"s_register_operand\")\n+\t  (plus:SI (plus:SI (match_dup 5) (match_dup 1))\n+\t\t   (match_dup 2)))])]\n+  \"TARGET_32BIT\"\n+  {\n+    operands[3] = gen_rtx_REG (CC_ADCmode, CC_REGNUM);\n+    rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+    operands[4] = gen_rtx_LTU (DImode, ccin, const0_rtx);\n+    operands[5] = gen_rtx_LTU (SImode, ccin, const0_rtx);\n+  }\n+)\n+\n+(define_insn \"*addsi3_cin_cout_reg_insn\"\n+  [(set (reg:CC_ADC CC_REGNUM)\n+\t(compare:CC_ADC\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (match_operand:DI 3 \"arm_carry_operation\" \"\")\n+\t   (zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"%0,r\")))\n+\t  (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"l,r\")))\n+\t(const_int 4294967296)))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=l,r\")\n+\t(plus:SI (plus:SI (match_operand:SI 4 \"arm_carry_operation\" \"\")\n+\t\t\t  (match_dup 1))\n+\t\t (match_dup 2)))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   adcs%?\\\\t%0, %0, %2\n+   adcs%?\\\\t%0, %1, %2\"\n+  [(set_attr \"type\" \"alus_sreg\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,4\")]\n+)\n+\n+(define_expand \"addsi3_cin_cout_imm\"\n+  [(parallel\n+    [(set (match_dup 3)\n+\t  (compare:CC_ADC\n+\t   (plus:DI\n+\t    (plus:DI (match_dup 4)\n+\t\t     (zero_extend:DI (match_operand:SI 1 \"s_register_operand\")))\n+\t    (match_dup 6))\n+\t   (const_int 4294967296)))\n+     (set (match_operand:SI 0 \"s_register_operand\")\n+\t  (plus:SI (plus:SI (match_dup 5) (match_dup 1))\n+\t\t   (match_operand:SI 2 \"arm_adcimm_operand\")))])]\n+  \"TARGET_32BIT\"\n+  {\n+    operands[3] = gen_rtx_REG (CC_ADCmode, CC_REGNUM);\n+    rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+    operands[4] = gen_rtx_LTU (DImode, ccin, const0_rtx);\n+    operands[5] = gen_rtx_LTU (SImode, ccin, const0_rtx);\n+    operands[6] = GEN_INT (UINTVAL (operands[2]) & 0xffffffff);\n+  }\n+)\n+\n+(define_insn \"*addsi3_cin_cout_imm_insn\"\n+  [(set (reg:CC_ADC CC_REGNUM)\n+\t(compare:CC_ADC\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (match_operand:DI 3 \"arm_carry_operation\" \"\")\n+\t   (zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"r,r\")))\n+\t  (match_operand:DI 5 \"const_int_operand\" \"n,n\"))\n+\t(const_int 4294967296)))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(plus:SI (plus:SI (match_operand:SI 4 \"arm_carry_operation\" \"\")\n+\t\t\t  (match_dup 1))\n+\t\t (match_operand:SI 2 \"arm_adcimm_operand\" \"I,K\")))]\n+  \"TARGET_32BIT\n+   && (UINTVAL (operands[2]) & 0xffffffff) == UINTVAL (operands[5])\"\n+  \"@\n+   adcs%?\\\\t%0, %1, %2\n+   sbcs%?\\\\t%0, %1, #%B2\"\n+  [(set_attr \"type\" \"alus_imm\")]\n+)\n+\n+(define_expand \"addsi3_cin_cout_0\"\n+  [(parallel\n+    [(set (match_dup 2)\n+\t  (compare:CC_ADC\n+\t   (plus:DI (match_dup 3)\n+\t\t    (zero_extend:DI (match_operand:SI 1 \"s_register_operand\")))\n+\t   (const_int 4294967296)))\n+     (set (match_operand:SI 0 \"s_register_operand\")\n+\t  (plus:SI (match_dup 4) (match_dup 1)))])]\n+  \"TARGET_32BIT\"\n+  {\n+    operands[2] = gen_rtx_REG (CC_ADCmode, CC_REGNUM);\n+    rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+    operands[3] = gen_rtx_LTU (DImode, ccin, const0_rtx);\n+    operands[4] = gen_rtx_LTU (SImode, ccin, const0_rtx);\n+  }\n+)\n+\n+(define_insn \"*addsi3_cin_cout_0_insn\"\n+  [(set (reg:CC_ADC CC_REGNUM)\n+\t(compare:CC_ADC\n+\t (plus:DI\n+\t  (match_operand:DI 2 \"arm_carry_operation\" \"\")\n+\t  (zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n+\t(const_int 4294967296)))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 3 \"arm_carry_operation\" \"\") (match_dup 1)))]\n+  \"TARGET_32BIT\"\n+  \"adcs%?\\\\t%0, %1, #0\"\n+  [(set_attr \"type\" \"alus_imm\")]\n+)\n+\n (define_expand \"addsi3\"\n   [(set (match_operand:SI          0 \"s_register_operand\")\n \t(plus:SI (match_operand:SI 1 \"s_register_operand\")\n@@ -636,22 +785,6 @@\n    (set_attr \"type\" \"alus_sreg\")]\n )\n \n-(define_insn \"adddi3_compareC\"\n-  [(set (reg:CC_C CC_REGNUM)\n-\t(compare:CC_C\n-\t  (plus:DI\n-\t    (match_operand:DI 1 \"register_operand\" \"r\")\n-\t    (match_operand:DI 2 \"register_operand\" \"r\"))\n-\t  (match_dup 1)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(plus:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_32BIT\"\n-  \"adds\\\\t%Q0, %Q1, %Q2;adcs\\\\t%R0, %R1, %R2\"\n- [(set_attr \"conds\" \"set\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn \"addsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV"}, {"sha": "8a8f10ccb501d1c9e2ac7f18f4de138fd7634fe7", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb254e029c9430a0c3d0cb044e4ca7b3f15b619/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=deb254e029c9430a0c3d0cb044e4ca7b3f15b619", "patch": "@@ -376,7 +376,7 @@\n     machine_mode ccmode = GET_MODE (op0);\n     if (ccmode == CC_Cmode)\n       return GET_CODE (op) == LTU;\n-    else if (ccmode == CCmode || ccmode == CC_RSBmode)\n+    else if (ccmode == CCmode || ccmode == CC_RSBmode || ccmode == CC_ADCmode)\n       return GET_CODE (op) == GEU;\n \n     return false;"}]}