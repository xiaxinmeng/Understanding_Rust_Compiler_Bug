{"sha": "78926be115ab4e63da3a413ef95b27570c6f2a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg5MjZiZTExNWFiNGU2M2RhM2E0MTNlZjk1YjI3NTcwYzZmMmE5MQ==", "commit": {"author": {"name": "Kazuhiro Inaoka", "email": "inaoka.kazuhiro@renesas.com", "date": "2011-08-11T12:34:30Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-08-11T12:34:30Z"}, "message": "rx.md (movsicc): Allow register to register transfers.\n\n\t* config/rx/rx.md (movsicc): Allow register to register\n\ttransfers.\n\t(*movsicc): Likewise.\n\t(*stcc): Restrict this pattern to EQ and NE compares.\n\t(*stcc_reg): New pattern.  Works for any comparison but only for\n\tregister transfers.\n\nFrom-SVN: r177665", "tree": {"sha": "69b26c78e62baddcafabf7dd034726a144ef24dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69b26c78e62baddcafabf7dd034726a144ef24dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78926be115ab4e63da3a413ef95b27570c6f2a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78926be115ab4e63da3a413ef95b27570c6f2a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78926be115ab4e63da3a413ef95b27570c6f2a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78926be115ab4e63da3a413ef95b27570c6f2a91/comments", "author": null, "committer": null, "parents": [{"sha": "c30f448beb6481abd41588a70ce524fd0111a59f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c30f448beb6481abd41588a70ce524fd0111a59f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c30f448beb6481abd41588a70ce524fd0111a59f"}], "stats": {"total": 75, "additions": 52, "deletions": 23}, "files": [{"sha": "678b880c24a8116ee4483a441049446c534772f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78926be115ab4e63da3a413ef95b27570c6f2a91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78926be115ab4e63da3a413ef95b27570c6f2a91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78926be115ab4e63da3a413ef95b27570c6f2a91", "patch": "@@ -1,3 +1,12 @@\n+2011-08-11   Kazuhiro Inaoka  <kazuhiro.inaoka.ud@renesas.com>\n+\n+\t* config/rx/rx.md (movsicc): Allow register to register\n+\ttransfers.\n+\t(*movsicc): Likewise.\n+\t(*stcc): Restrict this pattern to EQ and NE compares.\n+\t(*stcc_reg): New pattern.  Works for any comparison but only for\n+\tregister transfers.\n+\n 2011-08-11   Diego Novillo  <dnovillo@google.com>\n \n \t* tree-streamer-out.c (lto_output_ts_decl_with_vis_tree_pointers):\n@@ -164,7 +173,7 @@\n \t(process_decls): Use process_bypass.  Update after field name changes.\n \n 2011-08-11  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \tPR target/49687\n \t* config/avr/avr.md (smulqi3_highpart): New insn.\n \t(umulqi3_highpart): New insn."}, {"sha": "f7b8e16eb9155a1d2b44f6e50b95abca8e3ea445", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78926be115ab4e63da3a413ef95b27570c6f2a91/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78926be115ab4e63da3a413ef95b27570c6f2a91/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=78926be115ab4e63da3a413ef95b27570c6f2a91", "patch": "@@ -708,24 +708,24 @@\n      (clobber (reg:CC CC_REG))])]\n   \"\"\n {\n-  /* ??? Support other conditions via cstore into a temporary?  */\n-  if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)\n-    FAIL;\n-  /* One operand must be a constant.  */\n-  if (!CONSTANT_P (operands[2]) && !CONSTANT_P (operands[3]))\n+  /* One operand must be a constant or a register, the other must be a register.  */\n+  if (   ! CONSTANT_P (operands[2])\n+      && ! CONSTANT_P (operands[3])\n+      && ! (REG_P (operands[2]) && REG_P (operands[3])))\n     FAIL;\n })\n \n (define_insn_and_split \"*movsicc\"\n-  [(set (match_operand:SI     0 \"register_operand\" \"=r,r\")\n+  [(set (match_operand:SI     0 \"register_operand\" \"=r,r,r\")\n \t(if_then_else:SI\n-\t  (match_operator 5 \"rx_z_comparison_operator\"\n-\t   [(match_operand:SI 3 \"register_operand\"  \"r,r\")\n-\t    (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ\")])\n-\t  (match_operand:SI   1 \"nonmemory_operand\" \"i,ri\")\n-\t  (match_operand:SI   2 \"nonmemory_operand\" \"ri,i\")))\n+\t  (match_operator     5 \"comparison_operator\"\n+\t   [(match_operand:SI 3 \"register_operand\"  \"r,r,r\")\n+\t    (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ,riQ\")])\n+\t  (match_operand:SI   1 \"nonmemory_operand\" \"i,ri,r\")\n+\t  (match_operand:SI   2 \"nonmemory_operand\" \"ri,i,r\")))\n    (clobber (reg:CC CC_REG))]\n-  \"CONSTANT_P (operands[1]) || CONSTANT_P (operands[2])\"\n+  \"(CONSTANT_P (operands[1]) || CONSTANT_P (operands[2]))\n+    || (REG_P (operands[1]) && REG_P (operands[2]))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -742,8 +742,11 @@\n   op1 = operands[1];\n   op2 = operands[2];\n \n-  /* If OP2 is the constant, reverse the sense of the move.  */\n-  if (!CONSTANT_P (operands[1]))\n+  /* If OP2 is the constant, reverse the sense of the move.\n+     Likewise if both operands are registers but OP1 == OP0.  */\n+  if ((! CONSTANT_P (operands[1]) && CONSTANT_P (operands[2]))\n+      || (REG_P (operands[1]) && REG_P (operands[2])\n+          && rtx_equal_p (op0, op1)))\n     {\n       x = op1, op1 = op2, op2 = x;\n       cmp_code = reverse_condition (cmp_code);\n@@ -752,7 +755,7 @@\n   /* If OP2 does not match the output, copy it into place.  We have allowed\n      these alternatives so that the destination can legitimately be one of\n      the comparison operands without increasing register pressure.  */\n-  if (!rtx_equal_p (op0, op2))\n+  if (! rtx_equal_p (op0, op2))\n     emit_move_insn (op0, op2);\n \n   x = gen_rtx_fmt_ee (cmp_code, VOIDmode, flags, const0_rtx);\n@@ -768,16 +771,33 @@\n \t    [(reg CC_REG) (const_int 0)])\n \t  (match_operand:SI 1 \"immediate_operand\" \"Sint08,Sint16,Sint24,i\")\n \t  (match_dup 0)))]\n-  \"reload_completed\"\n-{\n-  if (GET_CODE (operands[2]) == EQ)\n-    return \"stz\\t%1, %0\";\n-  else\n-    return \"stnz\\t%1, %0\";\n-}\n+  \"reload_completed\n+   && ((GET_CODE (operands[2]) == EQ) || (GET_CODE (operands[2]) == NE))\"\n+  {\n+    if (GET_CODE (operands[2]) == EQ)\n+      return \"stz\\t%1, %0\";\n+    else\n+     return \"stnz\\t%1, %0\";\n+  }\n   [(set_attr \"length\" \"4,5,6,7\")]\n )\n \n+(define_insn \"*stcc_reg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+r,r,r,r,r,r\")\n+\t(if_then_else:SI\n+\t  (match_operator 2 \"comparison_operator\"\n+\t    [(reg CC_REG) (const_int 0)])\n+\t  (match_operand:SI 1 \"nonmemory_operand\"\n+\t\t              \"r,Uint04,Sint08,Sint16,Sint24,i\")\n+\t  (match_dup 0)))]\n+  \"reload_completed\"\n+  {\n+    PUT_CODE (operands[2], reverse_condition (GET_CODE (operands[2])));\n+    return \"b%B2 1f\\n\\tmov %1, %0\\n1:\";\n+  }\n+  [(set_attr \"length\" \"3,3,4,5,6,7\")]\n+)\n+\n ;; Arithmetic Instructions\n \n (define_insn \"abssi2\""}]}