{"sha": "ba60d5c3d56f2561188e02eb2e33314714781c2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE2MGQ1YzNkNTZmMjU2MTE4OGUwMmViMmUzMzMxNDcxNDc4MWMyZg==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2015-08-28T15:04:17Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2015-08-28T15:04:17Z"}, "message": "Revert: completely_scalarize arrays as well as records\n\ngcc/:\n\tRevert:\n\t2015-08-27  Alan Lawrence  <alan.lawrence@arm.com>\n\t\tPR tree-optimization/67283\n\t\t* tree-sra.c (type_consists_of_records_p): Rename to...\n\t\t(scalarizable_type_p): ...this, add case for ARRAY_TYPE.\n\n\t\t(completely_scalarize_record): Rename to...\n\t\t(completely_scalarize): ...this, add ARRAY_TYPE case, move some\n\t\t code to:\n\t\t(scalarize_elem): New.\n\ngcc/testsuite/:\n\n\tRevert:\n\t2015-08-27  Alan Lawrence  <alan.lawrence@arm.com>\n\t\t* gcc.dg/tree-ssa/sra-15.c: New.\n\nFrom-SVN: r227303", "tree": {"sha": "b285ceffe12a51731dbb4d35528b6935069929e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b285ceffe12a51731dbb4d35528b6935069929e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba60d5c3d56f2561188e02eb2e33314714781c2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba60d5c3d56f2561188e02eb2e33314714781c2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba60d5c3d56f2561188e02eb2e33314714781c2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba60d5c3d56f2561188e02eb2e33314714781c2f/comments", "author": null, "committer": null, "parents": [{"sha": "bd459d0b1dccf93dfd79204362a1740ca827c0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd459d0b1dccf93dfd79204362a1740ca827c0e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd459d0b1dccf93dfd79204362a1740ca827c0e4"}], "stats": {"total": 205, "additions": 67, "deletions": 138}, "files": [{"sha": "09d4a6d96fbc006dada3abca3c1f7a3ad0c4db25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba60d5c3d56f2561188e02eb2e33314714781c2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba60d5c3d56f2561188e02eb2e33314714781c2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba60d5c3d56f2561188e02eb2e33314714781c2f", "patch": "@@ -1,3 +1,16 @@\n+2015-08-28  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tRevert:\n+\t2015-08-27  Alan Lawrence  <alan.lawrence@arm.com>\n+\t\tPR tree-optimization/67283\n+\t\t* tree-sra.c (type_consists_of_records_p): Rename to...\n+\t\t(scalarizable_type_p): ...this, add case for ARRAY_TYPE.\n+\n+\t\t(completely_scalarize_record): Rename to...\n+\t\t(completely_scalarize): ...this, add ARRAY_TYPE case, move some\n+\t\t code to:\n+\t\t(scalarize_elem): New.\n+\n 2015-08-28  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_symbol_context): Rename"}, {"sha": "388417a0d6f97430386211b4f952f6e147a40f4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba60d5c3d56f2561188e02eb2e33314714781c2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba60d5c3d56f2561188e02eb2e33314714781c2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba60d5c3d56f2561188e02eb2e33314714781c2f", "patch": "@@ -1,3 +1,9 @@\n+2015-08-28  Alan Lawrence  <alan.lawrence@arm.com>\n+\tRevert:\n+\t2015-08-27  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t\t* gcc.dg/tree-ssa/sra-15.c: New.\n+\n 2015-08-28  Andrew Bennett  <andrew.bennett@imgtec.com>\n \n \t* gcc.target/mips/madd-8.c: Add lo register to clobber list. "}, {"sha": "a22062e32d1a94711e20c06676aed7ce4a7513f3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-15.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd459d0b1dccf93dfd79204362a1740ca827c0e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd459d0b1dccf93dfd79204362a1740ca827c0e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-15.c?ref=bd459d0b1dccf93dfd79204362a1740ca827c0e4", "patch": "@@ -1,37 +0,0 @@\n-/* Verify that SRA total scalarization works on records containing arrays.  */\n-/* { dg-do run } */\n-/* { dg-options \"-O1 -fdump-tree-release_ssa --param sra-max-scalarization-size-Ospeed=32\" } */\n-\n-extern void abort (void);\n-\n-struct S\n-{\n-  char c;\n-  unsigned short f[2][2];\n-  int i;\n-  unsigned short f3, f4;\n-};\n-\n-\n-int __attribute__ ((noinline))\n-foo (struct S *p)\n-{\n-  struct S l;\n-\n-  l = *p;\n-  l.i++;\n-  l.f[1][0] += 3;\n-  *p = l;\n-}\n-\n-int\n-main (int argc, char **argv)\n-{\n-  struct S a = {0, { {5, 7}, {9, 11} }, 4, 0, 0};\n-  foo (&a);\n-  if (a.i != 5 || a.f[1][0] != 12)\n-    abort ();\n-  return 0;\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"l;\" 0 \"release_ssa\" } } */"}, {"sha": "8b3a0adf7cce76ed6962b608481f6cf0550dabfa", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 48, "deletions": 101, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba60d5c3d56f2561188e02eb2e33314714781c2f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba60d5c3d56f2561188e02eb2e33314714781c2f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ba60d5c3d56f2561188e02eb2e33314714781c2f", "patch": "@@ -915,126 +915,73 @@ create_access (tree expr, gimple stmt, bool write)\n }\n \n \n-/* Return true iff TYPE is scalarizable - i.e. a RECORD_TYPE or ARRAY_TYPE with\n-   fields that are either of gimple register types (excluding bit-fields)\n-   or (recursively) scalarizable types.  */\n+/* Return true iff TYPE is a RECORD_TYPE with fields that are either of gimple\n+   register types or (recursively) records with only these two kinds of fields.\n+   It also returns false if any of these records contains a bit-field.  */\n \n static bool\n-scalarizable_type_p (tree type)\n+type_consists_of_records_p (tree type)\n {\n-  gcc_assert (!is_gimple_reg_type (type));\n+  tree fld;\n \n-  switch (TREE_CODE (type))\n-  {\n-  case RECORD_TYPE:\n-    for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n-      if (TREE_CODE (fld) == FIELD_DECL)\n-\t{\n-\t  tree ft = TREE_TYPE (fld);\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return false;\n \n-\t  if (DECL_BIT_FIELD (fld))\n-\t    return false;\n+  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+    if (TREE_CODE (fld) == FIELD_DECL)\n+      {\n+\ttree ft = TREE_TYPE (fld);\n \n-\t  if (!is_gimple_reg_type (ft)\n-\t      && !scalarizable_type_p (ft))\n-\t    return false;\n-\t}\n+\tif (DECL_BIT_FIELD (fld))\n+\t  return false;\n \n-    return true;\n+\tif (!is_gimple_reg_type (ft)\n+\t    && !type_consists_of_records_p (ft))\n+\t  return false;\n+      }\n \n-  case ARRAY_TYPE:\n-    {\n-      tree elem = TREE_TYPE (type);\n-      if (DECL_P (elem) && DECL_BIT_FIELD (elem))\n-\treturn false;\n-      if (!is_gimple_reg_type (elem)\n-\t && !scalarizable_type_p (elem))\n-\treturn false;\n-      return true;\n-    }\n-  default:\n-    return false;\n-  }\n+  return true;\n }\n \n-static void scalarize_elem (tree, HOST_WIDE_INT, HOST_WIDE_INT, tree, tree);\n-\n-/* Create total_scalarization accesses for all scalar fields of a member\n-   of type DECL_TYPE conforming to scalarizable_type_p.  BASE\n-   must be the top-most VAR_DECL representing the variable; within that,\n-   OFFSET locates the member and REF must be the memory reference expression for\n-   the member.  */\n+/* Create total_scalarization accesses for all scalar type fields in DECL that\n+   must be of a RECORD_TYPE conforming to type_consists_of_records_p.  BASE\n+   must be the top-most VAR_DECL representing the variable, OFFSET must be the\n+   offset of DECL within BASE.  REF must be the memory reference expression for\n+   the given decl.  */\n \n static void\n-completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)\n+completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset,\n+\t\t\t     tree ref)\n {\n-  switch (TREE_CODE (decl_type))\n-    {\n-    case RECORD_TYPE:\n-      for (tree fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))\n-\tif (TREE_CODE (fld) == FIELD_DECL)\n-\t  {\n-\t    HOST_WIDE_INT pos = offset + int_bit_position (fld);\n-\t    tree ft = TREE_TYPE (fld);\n-\t    tree nref = build3 (COMPONENT_REF, ft, ref, fld, NULL_TREE);\n+  tree fld, decl_type = TREE_TYPE (decl);\n \n-\t    scalarize_elem (base, pos, tree_to_uhwi (DECL_SIZE (fld)), nref,\n-\t\t\t    ft);\n-\t  }\n-      break;\n-    case ARRAY_TYPE:\n+  for (fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))\n+    if (TREE_CODE (fld) == FIELD_DECL)\n       {\n-\ttree elemtype = TREE_TYPE (decl_type);\n-\ttree elem_size = TYPE_SIZE (elemtype);\n-\tgcc_assert (elem_size && tree_fits_uhwi_p (elem_size));\n-\tint el_size = tree_to_uhwi (elem_size);\n-\tgcc_assert (el_size);\n-\n-\ttree minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (decl_type));\n-\ttree maxidx = TYPE_MAX_VALUE (TYPE_DOMAIN (decl_type));\n-\tgcc_assert (TREE_CODE (minidx) == INTEGER_CST\n-\t\t    && TREE_CODE (maxidx) == INTEGER_CST);\n-\tunsigned HOST_WIDE_INT len = tree_to_uhwi (maxidx)\n-\t\t\t\t     + 1 - tree_to_uhwi (minidx);\n-\t/* 4th operand to ARRAY_REF is size in units of the type alignment.  */\n-\tfor (unsigned HOST_WIDE_INT idx = 0; idx < len; idx++)\n+\tHOST_WIDE_INT pos = offset + int_bit_position (fld);\n+\ttree ft = TREE_TYPE (fld);\n+\ttree nref = build3 (COMPONENT_REF, TREE_TYPE (fld), ref, fld,\n+\t\t\t    NULL_TREE);\n+\n+\tif (is_gimple_reg_type (ft))\n \t  {\n-\t    tree t_idx = build_int_cst (TYPE_DOMAIN (decl_type), idx);\n-\t    tree nref = build4 (ARRAY_REF, elemtype, ref, t_idx, NULL_TREE,\n-\t\t\t\tNULL_TREE);\n-\t    int el_off = offset + idx * el_size;\n-\t    scalarize_elem (base, el_off, el_size, nref, elemtype);\n+\t    struct access *access;\n+\t    HOST_WIDE_INT size;\n+\n+\t    size = tree_to_uhwi (DECL_SIZE (fld));\n+\t    access = create_access_1 (base, pos, size);\n+\t    access->expr = nref;\n+\t    access->type = ft;\n+\t    access->grp_total_scalarization = 1;\n+\t    /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n \t  }\n+\telse\n+\t  completely_scalarize_record (base, fld, pos, nref);\n       }\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Create total_scalarization accesses for a member of type TYPE, which must\n-   satisfy either is_gimple_reg_type or scalarizable_type_p.  BASE must be the\n-   top-most VAR_DECL representing the variable; within that, POS and SIZE locate\n-   the member and REF must be the reference expression for it.  */\n-\n-static void\n-scalarize_elem (tree base, HOST_WIDE_INT pos, HOST_WIDE_INT size,\n-\t\t tree ref, tree type)\n-{\n-  if (is_gimple_reg_type (type))\n-  {\n-    struct access *access = create_access_1 (base, pos, size);\n-    access->expr = ref;\n-    access->type = type;\n-    access->grp_total_scalarization = 1;\n-    /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n-  }\n-  else\n-    completely_scalarize (base, type, pos, ref);\n }\n \n /* Create a total_scalarization access for VAR as a whole.  VAR must be of a\n-   RECORD_TYPE or ARRAY_TYPE conforming to scalarizable_type_p.  */\n+   RECORD_TYPE conforming to type_consists_of_records_p.  */\n \n static void\n create_total_scalarization_access (tree var)\n@@ -2574,13 +2521,13 @@ analyze_all_variable_accesses (void)\n \ttree var = candidate (i);\n \n \tif (TREE_CODE (var) == VAR_DECL\n-\t    && scalarizable_type_p (TREE_TYPE (var)))\n+\t    && type_consists_of_records_p (TREE_TYPE (var)))\n \t  {\n \t    if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var)))\n \t\t<= max_scalarization_size)\n \t      {\n \t\tcreate_total_scalarization_access (var);\n-\t\tcompletely_scalarize (var, TREE_TYPE (var), 0, var);\n+\t\tcompletely_scalarize_record (var, var, 0, var);\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  {\n \t\t    fprintf (dump_file, \"Will attempt to totally scalarize \");"}]}