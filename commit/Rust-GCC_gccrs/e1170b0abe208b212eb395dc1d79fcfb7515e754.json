{"sha": "e1170b0abe208b212eb395dc1d79fcfb7515e754", "node_id": "C_kwDOANBUbNoAKGUxMTcwYjBhYmUyMDhiMjEyZWIzOTVkYzFkNzlmY2ZiNzUxNWU3NTQ", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-08T17:22:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:27Z"}, "message": "rust constexprC: start porting cxx_eval_builtin_function_call\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "3e88985b4ad915060e4b0cc5672b0304264d4fce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e88985b4ad915060e4b0cc5672b0304264d4fce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1170b0abe208b212eb395dc1d79fcfb7515e754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1170b0abe208b212eb395dc1d79fcfb7515e754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1170b0abe208b212eb395dc1d79fcfb7515e754", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1170b0abe208b212eb395dc1d79fcfb7515e754/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd31c63fe15c4e39d3036ff7adcd22eadd6b53ea"}], "stats": {"total": 818, "additions": 818, "deletions": 0}, "files": [{"sha": "8c6543271aad0bfc6a0374f5b58ade9df08c4b28", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 732, "deletions": 0, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1170b0abe208b212eb395dc1d79fcfb7515e754/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1170b0abe208b212eb395dc1d79fcfb7515e754/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=e1170b0abe208b212eb395dc1d79fcfb7515e754", "patch": "@@ -31,6 +31,11 @@\n #include \"gimplify.h\"\n #include \"function.h\"\n #include \"gcc-rich-location.h\"\n+#include \"target.h\"\n+#include \"file-prefix-map.h\"\n+#include \"cgraph.h\"\n+\n+#include \"output.h\"\n \n // forked from gcc/c-family/c-common.cc c_global_trees\n tree c_global_trees[CTI_MAX];\n@@ -44,6 +49,9 @@ namespace Rust {\n void\n mark_exp_read (tree exp)\n {\n+  char tmp_name[32];\n+  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"Lsrc_loc\", 1);\n+\n   if (exp == NULL)\n     return;\n \n@@ -4151,4 +4159,728 @@ rs_get_callee_fndecl_nofold (tree call)\n   return rs_get_fndecl_from_callee (cp_get_callee (call), false);\n }\n \n+// forked from gcc/cp/init.cc is_class_type\n+\n+/* Report an error if TYPE is not a user-defined, class type.  If\n+   OR_ELSE is nonzero, give an error message.  */\n+\n+int\n+is_class_type (tree type, int or_else)\n+{\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (!CLASS_TYPE_P (type))\n+    {\n+      if (or_else)\n+\terror (\"%qT is not a class type\", type);\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+// forked from gcc/cp/decl.cc lookup_enumerator\n+\n+/* Look for an enumerator with the given NAME within the enumeration\n+   type ENUMTYPE.  This routine is used primarily for qualified name\n+   lookup into an enumerator in C++0x, e.g.,\n+\n+     enum class Color { Red, Green, Blue };\n+\n+     Color color = Color::Red;\n+\n+   Returns the value corresponding to the enumerator, or\n+   NULL_TREE if no such enumerator was found.  */\n+tree\n+lookup_enumerator (tree enumtype, tree name)\n+{\n+  tree e;\n+  gcc_assert (enumtype && TREE_CODE (enumtype) == ENUMERAL_TYPE);\n+\n+  e = purpose_member (name, TYPE_VALUES (enumtype));\n+  return e ? TREE_VALUE (e) : NULL_TREE;\n+}\n+\n+// forked from gcc/cp/init.cc constant_value_1\n+// commented out mark_used\n+\n+/* If DECL is a scalar enumeration constant or variable with a\n+   constant initializer, return the initializer (or, its initializers,\n+   recursively); otherwise, return DECL.  If STRICT_P, the\n+   initializer is only returned if DECL is a\n+   constant-expression.  If RETURN_AGGREGATE_CST_OK_P, it is ok to\n+   return an aggregate constant.  If UNSHARE_P, return an unshared\n+   copy of the initializer.  */\n+\n+static tree\n+constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p,\n+\t\t  bool unshare_p)\n+{\n+  while (TREE_CODE (decl) == CONST_DECL || decl_constant_var_p (decl)\n+\t || (!strict_p && VAR_P (decl)\n+\t     && RS_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl))))\n+    {\n+      tree init;\n+      /* If DECL is a static data member in a template\n+\t specialization, we must instantiate it here.  The\n+\t initializer for the static data member is not processed\n+\t until needed; we need it now.  */\n+      // mark_used (decl, tf_none);\n+      init = DECL_INITIAL (decl);\n+      if (init == error_mark_node)\n+\t{\n+\t  if (TREE_CODE (decl) == CONST_DECL\n+\t      || DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+\t    /* Treat the error as a constant to avoid cascading errors on\n+\t       excessively recursive template instantiation (c++/9335).  */\n+\t    return init;\n+\t  else\n+\t    return decl;\n+\t}\n+\n+      /* Instantiate a non-dependent initializer for user variables.  We\n+\t mustn't do this for the temporary for an array compound literal;\n+\t trying to instatiate the initializer will keep creating new\n+\t temporaries until we crash.  Probably it's not useful to do it for\n+\t other artificial variables, either.  */\n+      if (!DECL_ARTIFICIAL (decl))\n+\tinit = instantiate_non_dependent_or_null (init);\n+      if (!init || !TREE_TYPE (init) || !TREE_CONSTANT (init)\n+\t  || (!return_aggregate_cst_ok_p\n+\t      /* Unless RETURN_AGGREGATE_CST_OK_P is true, do not\n+\t\t return an aggregate constant (of which string\n+\t\t literals are a special case), as we do not want\n+\t\t to make inadvertent copies of such entities, and\n+\t\t we must be sure that their addresses are the\n+\t\t same everywhere.  */\n+\t      && (TREE_CODE (init) == CONSTRUCTOR\n+\t\t  || TREE_CODE (init) == STRING_CST)))\n+\tbreak;\n+      /* Don't return a CONSTRUCTOR for a variable with partial run-time\n+\t initialization, since it doesn't represent the entire value.\n+\t Similarly for VECTOR_CSTs created by cp_folding those\n+\t CONSTRUCTORs.  */\n+      if ((TREE_CODE (init) == CONSTRUCTOR || TREE_CODE (init) == VECTOR_CST)\n+\t  && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+\tbreak;\n+      /* If the variable has a dynamic initializer, don't use its\n+\t DECL_INITIAL which doesn't reflect the real value.  */\n+      if (VAR_P (decl) && TREE_STATIC (decl)\n+\t  && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)\n+\t  && DECL_NONTRIVIALLY_INITIALIZED_P (decl))\n+\tbreak;\n+      decl = init;\n+    }\n+  return unshare_p ? unshare_expr (decl) : decl;\n+}\n+\n+// forked from gcc/cp/init.cc decl_constant_value\n+\n+/* A more relaxed version of decl_really_constant_value, used by the\n+   common C/C++ code.  */\n+\n+tree\n+decl_constant_value (tree decl, bool unshare_p)\n+{\n+  return constant_value_1 (decl, /*strict_p=*/false,\n+\t\t\t   /*return_aggregate_cst_ok_p=*/true,\n+\t\t\t   /*unshare_p=*/unshare_p);\n+}\n+\n+// Below is forked from gcc/cp/init.cc decl_constant_value\n+\n+tree\n+decl_constant_value (tree decl)\n+{\n+  return decl_constant_value (decl, /*unshare_p=*/true);\n+}\n+\n+// Below is forked from gcc/cp/cp-gimplify.cc\n+\n+/* Type for source_location_table hash_set.  */\n+struct GTY ((for_user)) source_location_table_entry\n+{\n+  location_t loc;\n+  unsigned uid;\n+  tree var;\n+};\n+\n+/* Traits class for function start hash maps below.  */\n+\n+struct source_location_table_entry_hash\n+  : ggc_remove<source_location_table_entry>\n+{\n+  typedef source_location_table_entry value_type;\n+  typedef source_location_table_entry compare_type;\n+\n+  static hashval_t hash (const source_location_table_entry &ref)\n+  {\n+    inchash::hash hstate (0);\n+    hstate.add_int (ref.loc);\n+    hstate.add_int (ref.uid);\n+    return hstate.end ();\n+  }\n+\n+  static bool equal (const source_location_table_entry &ref1,\n+\t\t     const source_location_table_entry &ref2)\n+  {\n+    return ref1.loc == ref2.loc && ref1.uid == ref2.uid;\n+  }\n+\n+  static void mark_deleted (source_location_table_entry &ref)\n+  {\n+    ref.loc = UNKNOWN_LOCATION;\n+    ref.uid = -1U;\n+    ref.var = NULL_TREE;\n+  }\n+\n+  static const bool empty_zero_p = true;\n+\n+  static void mark_empty (source_location_table_entry &ref)\n+  {\n+    ref.loc = UNKNOWN_LOCATION;\n+    ref.uid = 0;\n+    ref.var = NULL_TREE;\n+  }\n+\n+  static bool is_deleted (const source_location_table_entry &ref)\n+  {\n+    return (ref.loc == UNKNOWN_LOCATION && ref.uid == -1U\n+\t    && ref.var == NULL_TREE);\n+  }\n+\n+  static bool is_empty (const source_location_table_entry &ref)\n+  {\n+    return (ref.loc == UNKNOWN_LOCATION && ref.uid == 0\n+\t    && ref.var == NULL_TREE);\n+  }\n+\n+  static void pch_nx (source_location_table_entry &p)\n+  {\n+    extern void gt_pch_nx (source_location_table_entry &);\n+    gt_pch_nx (p);\n+  }\n+\n+  static void pch_nx (source_location_table_entry &p, gt_pointer_operator op,\n+\t\t      void *cookie)\n+  {\n+    extern void gt_pch_nx (source_location_table_entry *, gt_pointer_operator,\n+\t\t\t   void *);\n+    gt_pch_nx (&p, op, cookie);\n+  }\n+};\n+\n+static GTY (())\n+  hash_table<source_location_table_entry_hash> *source_location_table;\n+static GTY (()) unsigned int source_location_id;\n+\n+// Above is forked from gcc/cp/cp-gimplify.cc\n+\n+// forked from gcc/cp/tree.cc lvalue_kind\n+\n+/* If REF is an lvalue, returns the kind of lvalue that REF is.\n+   Otherwise, returns clk_none.  */\n+\n+cp_lvalue_kind\n+lvalue_kind (const_tree ref)\n+{\n+  cp_lvalue_kind op1_lvalue_kind = clk_none;\n+  cp_lvalue_kind op2_lvalue_kind = clk_none;\n+\n+  /* Expressions of reference type are sometimes wrapped in\n+     INDIRECT_REFs.  INDIRECT_REFs are just internal compiler\n+     representation, not part of the language, so we have to look\n+     through them.  */\n+  if (REFERENCE_REF_P (ref))\n+    return lvalue_kind (TREE_OPERAND (ref, 0));\n+\n+  if (TREE_TYPE (ref) && TYPE_REF_P (TREE_TYPE (ref)))\n+    {\n+      /* unnamed rvalue references are rvalues */\n+      if (TYPE_REF_IS_RVALUE (TREE_TYPE (ref)) && TREE_CODE (ref) != PARM_DECL\n+\t  && !VAR_P (ref)\n+\t  && TREE_CODE (ref) != COMPONENT_REF\n+\t  /* Functions are always lvalues.  */\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (ref))) != FUNCTION_TYPE)\n+\t{\n+\t  op1_lvalue_kind = clk_rvalueref;\n+\t  if (implicit_rvalue_p (ref))\n+\t    op1_lvalue_kind |= clk_implicit_rval;\n+\t  return op1_lvalue_kind;\n+\t}\n+\n+      /* lvalue references and named rvalue references are lvalues.  */\n+      return clk_ordinary;\n+    }\n+\n+  if (ref == current_class_ptr)\n+    return clk_none;\n+\n+  /* Expressions with cv void type are prvalues.  */\n+  if (TREE_TYPE (ref) && VOID_TYPE_P (TREE_TYPE (ref)))\n+    return clk_none;\n+\n+  switch (TREE_CODE (ref))\n+    {\n+    case SAVE_EXPR:\n+      return clk_none;\n+\n+      /* preincrements and predecrements are valid lvals, provided\n+\t what they refer to are valid lvals.  */\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      return lvalue_kind (TREE_OPERAND (ref, 0));\n+\n+      case ARRAY_REF: {\n+\ttree op1 = TREE_OPERAND (ref, 0);\n+\tif (TREE_CODE (TREE_TYPE (op1)) == ARRAY_TYPE)\n+\t  {\n+\t    op1_lvalue_kind = lvalue_kind (op1);\n+\t    if (op1_lvalue_kind == clk_class)\n+\t      /* in the case of an array operand, the result is an lvalue if\n+\t\t that operand is an lvalue and an xvalue otherwise */\n+\t      op1_lvalue_kind = clk_rvalueref;\n+\t    return op1_lvalue_kind;\n+\t  }\n+\telse\n+\t  return clk_ordinary;\n+      }\n+\n+    case MEMBER_REF:\n+    case DOTSTAR_EXPR:\n+      if (TREE_CODE (ref) == MEMBER_REF)\n+\top1_lvalue_kind = clk_ordinary;\n+      else\n+\top1_lvalue_kind = lvalue_kind (TREE_OPERAND (ref, 0));\n+      if (TYPE_PTRMEMFUNC_P (TREE_TYPE (TREE_OPERAND (ref, 1))))\n+\top1_lvalue_kind = clk_none;\n+      else if (op1_lvalue_kind == clk_class)\n+\t/* The result of a .* expression whose second operand is a pointer to a\n+\t   data member is an lvalue if the first operand is an lvalue and an\n+\t   xvalue otherwise.  */\n+\top1_lvalue_kind = clk_rvalueref;\n+      return op1_lvalue_kind;\n+\n+    case COMPONENT_REF:\n+      op1_lvalue_kind = lvalue_kind (TREE_OPERAND (ref, 0));\n+      if (op1_lvalue_kind == clk_class)\n+\t/* If E1 is an lvalue, then E1.E2 is an lvalue;\n+\t   otherwise E1.E2 is an xvalue.  */\n+\top1_lvalue_kind = clk_rvalueref;\n+\n+      /* Look at the member designator.  */\n+      if (!op1_lvalue_kind)\n+\t;\n+      else if (is_overloaded_fn (TREE_OPERAND (ref, 1)))\n+\t/* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n+\t   situations.  If we're seeing a COMPONENT_REF, it's a non-static\n+\t   member, so it isn't an lvalue. */\n+\top1_lvalue_kind = clk_none;\n+      else if (TREE_CODE (TREE_OPERAND (ref, 1)) != FIELD_DECL)\n+\t/* This can be IDENTIFIER_NODE in a template.  */;\n+      else if (DECL_C_BIT_FIELD (TREE_OPERAND (ref, 1)))\n+\t{\n+\t  /* Clear the ordinary bit.  If this object was a class\n+\t     rvalue we want to preserve that information.  */\n+\t  op1_lvalue_kind &= ~clk_ordinary;\n+\t  /* The lvalue is for a bitfield.  */\n+\t  op1_lvalue_kind |= clk_bitfield;\n+\t}\n+      else if (DECL_PACKED (TREE_OPERAND (ref, 1)))\n+\top1_lvalue_kind |= clk_packed;\n+\n+      return op1_lvalue_kind;\n+\n+    case STRING_CST:\n+    case COMPOUND_LITERAL_EXPR:\n+      return clk_ordinary;\n+\n+    case CONST_DECL:\n+      /* CONST_DECL without TREE_STATIC are enumeration values and\n+\t thus not lvalues.  With TREE_STATIC they are used by ObjC++\n+\t in objc_build_string_object and need to be considered as\n+\t lvalues.  */\n+      if (!TREE_STATIC (ref))\n+\treturn clk_none;\n+      /* FALLTHRU */\n+    case VAR_DECL:\n+      if (VAR_P (ref) && DECL_HAS_VALUE_EXPR_P (ref))\n+\treturn lvalue_kind (DECL_VALUE_EXPR (CONST_CAST_TREE (ref)));\n+\n+      if (TREE_READONLY (ref) && !TREE_STATIC (ref) && DECL_LANG_SPECIFIC (ref)\n+\t  && DECL_IN_AGGR_P (ref))\n+\treturn clk_none;\n+      /* FALLTHRU */\n+    case INDIRECT_REF:\n+    case ARROW_EXPR:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case PLACEHOLDER_EXPR:\n+      return clk_ordinary;\n+\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      /* Disallow <? and >? as lvalues if either argument side-effects.  */\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (ref, 0))\n+\t  || TREE_SIDE_EFFECTS (TREE_OPERAND (ref, 1)))\n+\treturn clk_none;\n+      op1_lvalue_kind = lvalue_kind (TREE_OPERAND (ref, 0));\n+      op2_lvalue_kind = lvalue_kind (TREE_OPERAND (ref, 1));\n+      break;\n+\n+      case COND_EXPR: {\n+\ttree op1 = TREE_OPERAND (ref, 1);\n+\tif (!op1)\n+\t  op1 = TREE_OPERAND (ref, 0);\n+\ttree op2 = TREE_OPERAND (ref, 2);\n+\top1_lvalue_kind = lvalue_kind (op1);\n+\top2_lvalue_kind = lvalue_kind (op2);\n+\tif (!op1_lvalue_kind != !op2_lvalue_kind)\n+\t  {\n+\t    /* The second or the third operand (but not both) is a\n+\t       throw-expression; the result is of the type\n+\t       and value category of the other.  */\n+\t    if (op1_lvalue_kind && TREE_CODE (op2) == THROW_EXPR)\n+\t      op2_lvalue_kind = op1_lvalue_kind;\n+\t    else if (op2_lvalue_kind && TREE_CODE (op1) == THROW_EXPR)\n+\t      op1_lvalue_kind = op2_lvalue_kind;\n+\t  }\n+      }\n+      break;\n+\n+    case MODIFY_EXPR:\n+    case TYPEID_EXPR:\n+      return clk_ordinary;\n+\n+    case COMPOUND_EXPR:\n+      return lvalue_kind (TREE_OPERAND (ref, 1));\n+\n+    case TARGET_EXPR:\n+      return clk_class;\n+\n+    case VA_ARG_EXPR:\n+      return (CLASS_TYPE_P (TREE_TYPE (ref)) ? clk_class : clk_none);\n+\n+    case CALL_EXPR:\n+      /* We can see calls outside of TARGET_EXPR in templates.  */\n+      if (CLASS_TYPE_P (TREE_TYPE (ref)))\n+\treturn clk_class;\n+      return clk_none;\n+\n+    case FUNCTION_DECL:\n+      /* All functions (except non-static-member functions) are\n+\t lvalues.  */\n+      return (DECL_NONSTATIC_MEMBER_FUNCTION_P (ref) ? clk_none : clk_ordinary);\n+\n+    case NON_DEPENDENT_EXPR:\n+    case PAREN_EXPR:\n+      return lvalue_kind (TREE_OPERAND (ref, 0));\n+\n+    case TEMPLATE_PARM_INDEX:\n+      if (CLASS_TYPE_P (TREE_TYPE (ref)))\n+\t/* A template parameter object is an lvalue.  */\n+\treturn clk_ordinary;\n+      return clk_none;\n+\n+    default:\n+    default_:\n+      if (!TREE_TYPE (ref))\n+\treturn clk_none;\n+      if (CLASS_TYPE_P (TREE_TYPE (ref))\n+\t  || TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n+\treturn clk_class;\n+      return clk_none;\n+    }\n+\n+  /* If one operand is not an lvalue at all, then this expression is\n+     not an lvalue.  */\n+  if (!op1_lvalue_kind || !op2_lvalue_kind)\n+    return clk_none;\n+\n+  /* Otherwise, it's an lvalue, and it has all the odd properties\n+     contributed by either operand.  */\n+  op1_lvalue_kind = op1_lvalue_kind | op2_lvalue_kind;\n+  /* It's not an ordinary lvalue if it involves any other kind.  */\n+  if ((op1_lvalue_kind & ~clk_ordinary) != clk_none)\n+    op1_lvalue_kind &= ~clk_ordinary;\n+  /* It can't be both a pseudo-lvalue and a non-addressable lvalue.\n+     A COND_EXPR of those should be wrapped in a TARGET_EXPR.  */\n+  if ((op1_lvalue_kind & (clk_rvalueref | clk_class))\n+      && (op1_lvalue_kind & (clk_bitfield | clk_packed)))\n+    op1_lvalue_kind = clk_none;\n+  return op1_lvalue_kind;\n+}\n+\n+// forked from gcc/cp/tree.cc glvalue_p\n+\n+/* This differs from lvalue_p in that xvalues are included.  */\n+\n+bool\n+glvalue_p (const_tree ref)\n+{\n+  cp_lvalue_kind kind = lvalue_kind (ref);\n+  if (kind & clk_class)\n+    return false;\n+  else\n+    return (kind != clk_none);\n+}\n+\n+// forked from gcc/cp/init.cc cv_qualified_p\n+\n+/* Returns nonzero if TYPE is const or volatile.  */\n+\n+bool\n+cv_qualified_p (const_tree type)\n+{\n+  int quals = rs_type_quals (type);\n+  return (quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)) != 0;\n+}\n+\n+// forked from gcc/cp/tree.cc rvalue\n+\n+/* EXPR is being used in an rvalue context.  Return a version of EXPR\n+   that is marked as an rvalue.  */\n+\n+tree\n+rvalue (tree expr)\n+{\n+  tree type;\n+\n+  if (error_operand_p (expr))\n+    return expr;\n+\n+  expr = mark_rvalue_use (expr);\n+\n+  /* [basic.lval]\n+\n+     Non-class rvalues always have cv-unqualified types.  */\n+  type = TREE_TYPE (expr);\n+  if (!CLASS_TYPE_P (type) && cv_qualified_p (type))\n+    type = cv_unqualified (type);\n+\n+  /* We need to do this for rvalue refs as well to get the right answer\n+     from decltype; see c++/36628.  */\n+  if (glvalue_p (expr))\n+    {\n+      /* But don't use this function for class lvalues; use move (to treat an\n+\t lvalue as an xvalue) or force_rvalue (to make a prvalue copy).  */\n+      gcc_checking_assert (!CLASS_TYPE_P (type));\n+      expr = build1 (NON_LVALUE_EXPR, type, expr);\n+    }\n+  else if (type != TREE_TYPE (expr))\n+    expr = build_nop (type, expr);\n+\n+  return expr;\n+}\n+\n+// forked from gcc/cp/tree.cc bitfield_p\n+\n+/* True if REF is a bit-field.  */\n+\n+bool\n+bitfield_p (const_tree ref)\n+{\n+  return (lvalue_kind (ref) & clk_bitfield);\n+}\n+\n+// forked from gcc/cp/typeck.cc cxx_mark_addressable\n+\n+/* Mark EXP saying that we need to be able to take the\n+   address of it; it should not be allocated in a register.\n+   Value is true if successful.  ARRAY_REF_P is true if this\n+   is for ARRAY_REF construction - in that case we don't want\n+   to look through VIEW_CONVERT_EXPR from VECTOR_TYPE to ARRAY_TYPE,\n+   it is fine to use ARRAY_REFs for vector subscripts on vector\n+   register variables.\n+\n+   C++: we do not allow `current_class_ptr' to be addressable.  */\n+\n+bool\n+cxx_mark_addressable (tree exp, bool array_ref_p)\n+{\n+  tree x = exp;\n+\n+  while (1)\n+    switch (TREE_CODE (x))\n+      {\n+      case VIEW_CONVERT_EXPR:\n+\tif (array_ref_p && TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n+\t    && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))))\n+\t  return true;\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+\n+      case COMPONENT_REF:\n+\tif (bitfield_p (x))\n+\t  error (\"attempt to take address of bit-field\");\n+\t/* FALLTHRU */\n+      case ADDR_EXPR:\n+      case ARRAY_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+\n+      case PARM_DECL:\n+\tif (x == current_class_ptr)\n+\t  {\n+\t    error (\"cannot take the address of %<this%>, which is an rvalue \"\n+\t\t   \"expression\");\n+\t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later.  */\n+\t    return true;\n+\t  }\n+\t/* Fall through.  */\n+\n+      case VAR_DECL:\n+\t/* Caller should not be trying to mark initialized\n+\t   constant fields addressable.  */\n+\tgcc_assert (DECL_LANG_SPECIFIC (x) == 0 || DECL_IN_AGGR_P (x) == 0\n+\t\t    || TREE_STATIC (x) || DECL_EXTERNAL (x));\n+\t/* Fall through.  */\n+\n+      case RESULT_DECL:\n+\tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x) && !DECL_ARTIFICIAL (x))\n+\t  {\n+\t    if (VAR_P (x) && DECL_HARD_REGISTER (x))\n+\t      {\n+\t\terror (\"address of explicit register variable %qD requested\",\n+\t\t       x);\n+\t\treturn false;\n+\t      }\n+\t    else if (extra_warnings)\n+\t      warning (\n+\t\tOPT_Wextra,\n+\t\t\"address requested for %qD, which is declared %<register%>\", x);\n+\t  }\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn true;\n+\n+      case CONST_DECL:\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn true;\n+\n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn true;\n+\n+      case TARGET_EXPR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\tcxx_mark_addressable (TREE_OPERAND (x, 0));\n+\treturn true;\n+\n+      default:\n+\treturn true;\n+      }\n+}\n+\n+// forked from gcc/cp/typeck.cc build_address\n+\n+/* Returns the address of T.  This function will fold away\n+   ADDR_EXPR of INDIRECT_REF.  This is only for low-level usage;\n+   most places should use cp_build_addr_expr instead.  */\n+\n+tree\n+build_address (tree t)\n+{\n+  if (error_operand_p (t) || !cxx_mark_addressable (t))\n+    return error_mark_node;\n+  gcc_checking_assert (TREE_CODE (t) != CONSTRUCTOR);\n+  t = build_fold_addr_expr_loc (EXPR_LOCATION (t), t);\n+  if (TREE_CODE (t) != ADDR_EXPR)\n+    t = rvalue (t);\n+  return t;\n+}\n+\n+// forked from gcc/cp/gp-gimplify.cc fold_builtin_source_location\n+\n+/* Fold __builtin_source_location () call.  LOC is the location\n+   of the call.  */\n+\n+tree\n+fold_builtin_source_location (location_t loc)\n+{\n+  if (source_location_impl == error_mark_node)\n+    return build_zero_cst (const_ptr_type_node);\n+  if (source_location_table == NULL)\n+    source_location_table\n+      = hash_table<source_location_table_entry_hash>::create_ggc (64);\n+  const line_map_ordinary *map;\n+  source_location_table_entry entry;\n+  entry.loc = linemap_resolve_location (line_table, loc,\n+\t\t\t\t\tLRK_MACRO_EXPANSION_POINT, &map);\n+  entry.uid = current_function_decl ? DECL_UID (current_function_decl) : -1;\n+  entry.var = error_mark_node;\n+  source_location_table_entry *entryp\n+    = source_location_table->find_slot (entry, INSERT);\n+  tree var;\n+  if (entryp->var)\n+    var = entryp->var;\n+  else\n+    {\n+      char tmp_name[32];\n+      ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"Lsrc_loc\", source_location_id++);\n+      var = build_decl (loc, VAR_DECL, get_identifier (tmp_name),\n+\t\t\tsource_location_impl);\n+      TREE_STATIC (var) = 1;\n+      TREE_PUBLIC (var) = 0;\n+      DECL_ARTIFICIAL (var) = 1;\n+      DECL_IGNORED_P (var) = 1;\n+      DECL_EXTERNAL (var) = 0;\n+      DECL_DECLARED_CONSTEXPR_P (var) = 1;\n+      DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (var) = 1;\n+      layout_decl (var, 0);\n+\n+      vec<constructor_elt, va_gc> *v = NULL;\n+      vec_alloc (v, 4);\n+      for (tree field = TYPE_FIELDS (source_location_impl);\n+\t   (field = next_initializable_field (field)) != NULL_TREE;\n+\t   field = DECL_CHAIN (field))\n+\t{\n+\t  const char *n = IDENTIFIER_POINTER (DECL_NAME (field));\n+\t  tree val = NULL_TREE;\n+\t  if (strcmp (n, \"_M_file_name\") == 0)\n+\t    {\n+\t      if (const char *fname = LOCATION_FILE (loc))\n+\t\t{\n+\t\t  fname = remap_macro_filename (fname);\n+\t\t  val = build_string_literal (strlen (fname) + 1, fname);\n+\t\t}\n+\t      else\n+\t\tval = build_string_literal (1, \"\");\n+\t    }\n+\t  else if (strcmp (n, \"_M_function_name\") == 0)\n+\t    {\n+\t      const char *name = \"todo: add funciton name here\";\n+\n+\t      // if (current_function_decl)\n+\t      // name = cxx_printable_name (current_function_decl, 2);\n+\n+\t      val = build_string_literal (strlen (name) + 1, name);\n+\t    }\n+\t  else if (strcmp (n, \"_M_line\") == 0)\n+\t    val = build_int_cst (TREE_TYPE (field), LOCATION_LINE (loc));\n+\t  else if (strcmp (n, \"_M_column\") == 0)\n+\t    val = build_int_cst (TREE_TYPE (field), LOCATION_COLUMN (loc));\n+\t  else\n+\t    gcc_unreachable ();\n+\t  CONSTRUCTOR_APPEND_ELT (v, field, val);\n+\t}\n+\n+      tree ctor = build_constructor (source_location_impl, v);\n+      TREE_CONSTANT (ctor) = 1;\n+      TREE_STATIC (ctor) = 1;\n+      DECL_INITIAL (var) = ctor;\n+      varpool_node::finalize_decl (var);\n+      *entryp = entry;\n+      entryp->var = var;\n+    }\n+\n+  return build_fold_addr_expr_with_type_loc (loc, var, const_ptr_type_node);\n+}\n+\n } // namespace Rust"}, {"sha": "bb3b430437274592b87eda00cb1d4ae6b23eb531", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1170b0abe208b212eb395dc1d79fcfb7515e754/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1170b0abe208b212eb395dc1d79fcfb7515e754/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=e1170b0abe208b212eb395dc1d79fcfb7515e754", "patch": "@@ -1279,6 +1279,24 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n #define TARGET_EXPR_DIRECT_INIT_P(NODE)                                        \\\n   TREE_LANG_FLAG_2 (TARGET_EXPR_CHECK (NODE))\n \n+/* Nonzero if DECL is a declaration of __builtin_constant_p.  */\n+#define DECL_IS_BUILTIN_CONSTANT_P(NODE)                                       \\\n+  (TREE_CODE (NODE) == FUNCTION_DECL                                           \\\n+   && DECL_BUILT_IN_CLASS (NODE) == BUILT_IN_NORMAL                            \\\n+   && DECL_FUNCTION_CODE (NODE) == BUILT_IN_CONSTANT_P)\n+\n+/* True iff this represents an lvalue being treated as an rvalue during return\n+   or throw as per [class.copy.elision].  */\n+#define IMPLICIT_RVALUE_P(NODE)                                                \\\n+  TREE_LANG_FLAG_3 (TREE_CHECK2 ((NODE), NON_LVALUE_EXPR, STATIC_CAST_EXPR))\n+\n+/* Nonzero for _DECL means that this decl appears in (or will appear\n+   in) as a member in a RECORD_TYPE or UNION_TYPE node.  It is also for\n+   detecting circularity in case members are multiply defined.  In the\n+   case of a VAR_DECL, it means that no definition has been seen, even\n+   if an initializer has been.  */\n+#define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3 (NODE))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -1400,6 +1418,16 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/c-family/c-common.h\n \n+// Below macros are copied from gcc/cp/name-lookup.h\n+\n+/* Lookup walker marking.  */\n+#define LOOKUP_SEEN_P(NODE) TREE_VISITED (NODE)\n+#define LOOKUP_FOUND_P(NODE)                                                   \\\n+  TREE_LANG_FLAG_4 (TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, ENUMERAL_TYPE, \\\n+\t\t\t\t NAMESPACE_DECL))\n+\n+// Above macros are copied from gcc/cp/name-lookup.h\n+\n // Below macros are copied from gcc/cp/name-lookup.cc\n \n /* Create an overload suitable for recording an artificial TYPE_DECL\n@@ -1435,6 +1463,22 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+/* The various kinds of lvalues we distinguish.  */\n+enum cp_lvalue_kind_flags\n+{\n+  clk_none = 0,\t     /* Things that are not an lvalue.  */\n+  clk_ordinary = 1,  /* An ordinary lvalue.  */\n+  clk_rvalueref = 2, /* An xvalue (rvalue formed using an rvalue reference) */\n+  clk_class = 4,     /* A prvalue of class or array type.  */\n+  clk_bitfield = 8,  /* An lvalue for a bit-field.  */\n+  clk_packed = 16,   /* An lvalue for a packed field.  */\n+  clk_implicit_rval = 1 << 5 /* An lvalue being treated as an xvalue.  */\n+};\n+\n+/* This type is used for parameters and variables which hold\n+   combinations of the flags in enum cp_lvalue_kind_flags.  */\n+typedef int cp_lvalue_kind;\n+\n // forked from gcc/cp/name_lookup.h scope_kind\n \n /* The kinds of scopes we recognize.  */\n@@ -2673,6 +2717,29 @@ in_immediate_context ();\n \n extern tree cp_get_callee_fndecl_nofold (tree);\n \n+extern bool\n+cxx_mark_addressable (tree, bool = false);\n+\n+extern tree fold_builtin_source_location (location_t);\n+\n+extern tree build_address (tree);\n+\n+extern bool bitfield_p (const_tree);\n+\n+extern tree rvalue (tree);\n+\n+extern bool glvalue_p (const_tree);\n+\n+extern cp_lvalue_kind lvalue_kind (const_tree);\n+\n+extern tree\n+decl_constant_value (tree, bool);\n+\n+extern tree lookup_enumerator (tree, tree);\n+\n+extern int\n+is_class_type (tree, int);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -2875,6 +2942,25 @@ cxx_incomplete_type_error (const_tree value, const_tree type)\n extern location_t\n location_of (tree t);\n \n+/* Helpers for IMPLICIT_RVALUE_P to look through automatic dereference.  */\n+\n+inline bool\n+implicit_rvalue_p (const_tree t)\n+{\n+  if (REFERENCE_REF_P (t))\n+    t = TREE_OPERAND (t, 0);\n+  return ((TREE_CODE (t) == NON_LVALUE_EXPR) && IMPLICIT_RVALUE_P (t));\n+}\n+inline tree\n+set_implicit_rvalue_p (tree ot)\n+{\n+  tree t = ot;\n+  if (REFERENCE_REF_P (t))\n+    t = TREE_OPERAND (t, 0);\n+  IMPLICIT_RVALUE_P (t) = 1;\n+  return ot;\n+}\n+\n namespace Compile {\n extern tree\n maybe_constant_init (tree, tree = NULL_TREE, bool = false);"}]}