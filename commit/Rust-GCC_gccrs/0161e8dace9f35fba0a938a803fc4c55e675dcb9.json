{"sha": "0161e8dace9f35fba0a938a803fc4c55e675dcb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2MWU4ZGFjZTlmMzVmYmEwYTkzOGE4MDNmYzRjNTVlNjc1ZGNiOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-08T17:35:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-08T17:35:57Z"}, "message": "(enum attrs): Add A_FORMAT_ARG.\n\n(init_attribute): Initialize it.\n(decl_attributes, case A_FORMAT): Clean up error messages.\n(decl_attributes, case A_FORMAT_ARG): New case.\n(struct international_format_info): New structure and typedef.\n(international_format_list): New variable.\n(record_international_format): New function.\n(init_format_info): Call it for gettext, dcgettext, and dcgettext.\n(check_format_info): See if format arg is call to internationalization\nfunction.\n\nFrom-SVN: r12241", "tree": {"sha": "756ca1df2529ba6c3122383e324e3b5c2e7cb603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/756ca1df2529ba6c3122383e324e3b5c2e7cb603"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0161e8dace9f35fba0a938a803fc4c55e675dcb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0161e8dace9f35fba0a938a803fc4c55e675dcb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0161e8dace9f35fba0a938a803fc4c55e675dcb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0161e8dace9f35fba0a938a803fc4c55e675dcb9/comments", "author": null, "committer": null, "parents": [{"sha": "87e2427658c101fef8e5673914088e40edac8043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e2427658c101fef8e5673914088e40edac8043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e2427658c101fef8e5673914088e40edac8043"}], "stats": {"total": 173, "additions": 167, "deletions": 6}, "files": [{"sha": "04c1ef3522a3f09adbc52038a855f69ac2181122", "filename": "gcc/c-common.c", "status": "modified", "additions": 167, "deletions": 6, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0161e8dace9f35fba0a938a803fc4c55e675dcb9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0161e8dace9f35fba0a938a803fc4c55e675dcb9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0161e8dace9f35fba0a938a803fc4c55e675dcb9", "patch": "@@ -39,12 +39,13 @@ extern struct obstack permanent_obstack;\n \n enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n-\t    A_UNUSED, A_FORMAT, A_WEAK, A_ALIAS};\n+\t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS};\n \n static void declare_hidden_char_array\tPROTO((char *, char *));\n static void add_attribute\t\tPROTO((enum attrs, char *,\n \t\t\t\t\t       int, int, int));\n static void init_attributes\t\tPROTO((void));\n+static void record_international_format\tPROTO((tree, tree, int));\n \n /* Make bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n \n@@ -275,6 +276,7 @@ init_attributes ()\n   add_attribute (A_SECTION, \"section\", 1, 1, 1);\n   add_attribute (A_ALIGNED, \"aligned\", 0, 1, 0);\n   add_attribute (A_FORMAT, \"format\", 3, 3, 1);\n+  add_attribute (A_FORMAT_ARG, \"format_arg\", 1, 1, 1);\n   add_attribute (A_WEAK, \"weak\", 0, 0, 1);\n   add_attribute (A_ALIAS, \"alias\", 1, 1, 1);\n }\n@@ -580,9 +582,15 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\t\t || !strcmp (IDENTIFIER_POINTER (format_type),\n \t\t\t\t     \"__scanf__\")))\n \t      is_scan = 1;\n+\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE)\n+\t      {\n+\t\terror (\"`%s' is an unrecognized format function type\",\n+\t\t       IDENTIFIER_POINTER (format_type));\n+\t\tcontinue;\n+\t      }\n \t    else\n \t      {\n-\t\terror (\"unrecognized format specifier for `%s'\");\n+\t\terror (\"unrecognized format specifier\");\n \t\tcontinue;\n \t      }\n \n@@ -653,6 +661,70 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    break;\n \t  }\n \n+\tcase A_FORMAT_ARG:\n+\t  {\n+\t    tree format_num_expr = TREE_VALUE (args);\n+\t    int format_num, arg_num;\n+\t    tree argument;\n+\t\n+\t    if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t      {\n+\t\terror_with_decl (decl,\n+\t\t\t \"argument format specified for non-function `%s'\");\n+\t\tcontinue;\n+\t      }\n+\t\n+\t    /* Strip any conversions from the first arg number and verify it\n+\t       is a constant.  */\n+\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n+\n+\t    if (TREE_CODE (format_num_expr) != INTEGER_CST)\n+\t      {\n+\t\terror (\"format string has non-constant operand number\");\n+\t\tcontinue;\n+\t      }\n+\n+\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n+\n+\t    /* If a parameter list is specified, verify that the format_num\n+\t       argument is actually a string, in case the format attribute\n+\t       is in error.  */\n+\t    argument = TYPE_ARG_TYPES (type);\n+\t    if (argument)\n+\t      {\n+\t\tfor (arg_num = 1; ; ++arg_num)\n+\t\t  {\n+\t\t    if (argument == 0 || arg_num == format_num)\n+\t\t      break;\n+\t\t    argument = TREE_CHAIN (argument);\n+\t\t  }\n+\t\tif (! argument\n+\t\t    || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n+\t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n+\t\t      != char_type_node))\n+\t\t  {\n+\t\t    error (\"format string arg not a string type\");\n+\t\t    continue;\n+\t\t  }\n+\t      }\n+\n+\t    if (TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) != POINTER_TYPE\n+\t\t|| (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (TREE_TYPE (decl))))\n+\t\t    != char_type_node))\n+\t      {\n+\t\terror (\"function does not return string type\");\n+\t\tcontinue;\n+\t      }\n+\n+\t    record_international_format (DECL_NAME (decl),\n+\t\t\t\t\t DECL_ASSEMBLER_NAME (decl),\n+\t\t\t\t\t format_num);\n+\t    break;\n+\t  }\n+\n \tcase A_WEAK:\n \t  declare_weak (decl);\n \t  break;\n@@ -749,7 +821,8 @@ static format_char_info scan_char_table[] = {\n   { NULL }\n };\n \n-typedef struct function_format_info {\n+typedef struct function_format_info\n+{\n   struct function_format_info *next;  /* next structure on the list */\n   tree name;\t\t\t/* identifier such as \"printf\" */\n   tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n@@ -760,14 +833,27 @@ typedef struct function_format_info {\n \n static function_format_info *function_format_list = NULL;\n \n-static void check_format_info PROTO((function_format_info *, tree));\n+typedef struct international_format_info\n+{\n+  struct international_format_info *next;  /* next structure on the list */\n+  tree name;\t\t\t/* identifier such as \"gettext\" */\n+  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n+  int format_num;\t\t/* number of format argument */\n+} international_format_info;\n+\n+static international_format_info *international_format_list = NULL;\n+\n+static void check_format_info\t\tPROTO((function_format_info *, tree));\n \n /* Initialize the table of functions to perform format checking on.\n    The ANSI functions are always checked (whether <stdio.h> is\n    included or not), since it is common to call printf without\n    including <stdio.h>.  There shouldn't be a problem with this,\n    since ANSI reserves these function names whether you include the\n-   header file or not.  In any case, the checking is harmless.  */\n+   header file or not.  In any case, the checking is harmless. \n+\n+   Also initialize the name of function that modify the format string for\n+   internationalization purposes.  */\n \n void\n init_function_format_info ()\n@@ -781,6 +867,10 @@ init_function_format_info ()\n   record_function_format (get_identifier (\"vprintf\"), NULL_TREE, 0, 1, 0);\n   record_function_format (get_identifier (\"vfprintf\"), NULL_TREE, 0, 2, 0);\n   record_function_format (get_identifier (\"vsprintf\"), NULL_TREE, 0, 2, 0);\n+\n+  record_international_format (get_identifier (\"gettext\"), NULL_TREE, 1);\n+  record_international_format (get_identifier (\"dgettext\"), NULL_TREE, 2);\n+  record_international_format (get_identifier (\"dcgettext\"), NULL_TREE, 2);\n }\n \n /* Record information for argument format checking.  FUNCTION_IDENT is\n@@ -789,7 +879,7 @@ init_function_format_info ()\n    false indicates printf-style format checking.  FORMAT_NUM is the number\n    of the argument which is the format control string (starting from 1).\n    FIRST_ARG_NUM is the number of the first actual argument to check\n-   against teh format string, or zero if no checking is not be done\n+   against the format string, or zero if no checking is not be done\n    (e.g. for varargs such as vfprintf).  */\n \n void\n@@ -825,6 +915,43 @@ record_function_format (name, assembler_name, is_scan,\n   info->first_arg_num = first_arg_num;\n }\n \n+/* Record information for the names of function that modify the format\n+   argument to format functions.  FUNCTION_IDENT is the identifier node for\n+   the name of the function (its decl need not exist yet) and FORMAT_NUM is\n+   the number of the argument which is the format control string (starting\n+   from 1).  */\n+\n+void\n+record_international_format (name, assembler_name, format_num)\n+      tree name;\n+      tree assembler_name;\n+      int format_num;\n+{\n+  international_format_info *info;\n+\n+  /* Re-use existing structure if it's there.  */\n+\n+  for (info = international_format_list; info; info = info->next)\n+    {\n+      if (info->name == name && info->assembler_name == assembler_name)\n+\tbreak;\n+    }\n+\n+  if (! info)\n+    {\n+      info\n+\t= (international_format_info *)\n+\t  xmalloc (sizeof (international_format_info));\n+      info->next = international_format_list;\n+      international_format_list = info;\n+\n+      info->name = name;\n+      info->assembler_name = assembler_name;\n+    }\n+\n+  info->format_num = format_num;\n+}\n+\n static char\ttfaff[] = \"too few arguments for format\";\n \f\n /* Check the argument list of a call to printf, scanf, etc.\n@@ -895,9 +1022,43 @@ check_format_info (info, params)\n   params = TREE_CHAIN (params);\n   if (format_tree == 0)\n     return;\n+\n   /* We can only check the format if it's a string constant.  */\n   while (TREE_CODE (format_tree) == NOP_EXPR)\n     format_tree = TREE_OPERAND (format_tree, 0); /* strip coercion */\n+\n+  if (TREE_CODE (format_tree) == CALL_EXPR\n+      && TREE_CODE (TREE_OPERAND (format_tree, 0)) == ADDR_EXPR\n+      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0))\n+\t  == FUNCTION_DECL))\n+    {\n+      tree function = TREE_OPERAND (TREE_OPERAND (format_tree, 0), 0);\n+\n+      /* See if this is a call to a known internationalization function\n+\t that modifies the format arg.  */\n+      international_format_info *info;\n+\n+      for (info = international_format_list; info; info = info->next)\n+\tif (info->assembler_name\n+\t    ? (info->assembler_name == DECL_ASSEMBLER_NAME (function))\n+\t    : (info->name == DECL_NAME (function)))\n+\t  {\n+\t    tree inner_args;\n+\t    int i;\n+\n+\t    for (inner_args = TREE_OPERAND (format_tree, 1), i = 1;\n+\t\t inner_args != 0;\n+\t\t inner_args = TREE_CHAIN (inner_args), i++)\n+\t      if (i == info->format_num)\n+\t\t{\n+\t\t  format_tree = TREE_VALUE (inner_args);\n+\n+\t\t  while (TREE_CODE (format_tree) == NOP_EXPR)\n+\t\t    format_tree = TREE_OPERAND (format_tree, 0);\n+\t\t}\n+\t  }\n+    }\n+\n   if (integer_zerop (format_tree))\n     {\n       warning (\"null format string\");"}]}