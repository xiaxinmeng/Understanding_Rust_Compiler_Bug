{"sha": "dac1de7fde494296333492db90f8977bc74393e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFjMWRlN2ZkZTQ5NDI5NjMzMzQ5MmRiOTBmODk3N2JjNzQzOTNlMA==", "commit": {"author": {"name": "Yizhe", "email": "yizhe@pku.edu.cn", "date": "2021-03-17T07:25:20Z"}, "committer": {"name": "YizhePKU", "email": "yizhe@pku.edu.cn", "date": "2021-04-02T17:10:47Z"}, "message": "Fix include", "tree": {"sha": "3f21b4d1ca52b75b46b8f6e60f9353ce302ac448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f21b4d1ca52b75b46b8f6e60f9353ce302ac448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dac1de7fde494296333492db90f8977bc74393e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac1de7fde494296333492db90f8977bc74393e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dac1de7fde494296333492db90f8977bc74393e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac1de7fde494296333492db90f8977bc74393e0/comments", "author": {"login": "YizhePKU", "id": 42838469, "node_id": "MDQ6VXNlcjQyODM4NDY5", "avatar_url": "https://avatars.githubusercontent.com/u/42838469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YizhePKU", "html_url": "https://github.com/YizhePKU", "followers_url": "https://api.github.com/users/YizhePKU/followers", "following_url": "https://api.github.com/users/YizhePKU/following{/other_user}", "gists_url": "https://api.github.com/users/YizhePKU/gists{/gist_id}", "starred_url": "https://api.github.com/users/YizhePKU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YizhePKU/subscriptions", "organizations_url": "https://api.github.com/users/YizhePKU/orgs", "repos_url": "https://api.github.com/users/YizhePKU/repos", "events_url": "https://api.github.com/users/YizhePKU/events{/privacy}", "received_events_url": "https://api.github.com/users/YizhePKU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "YizhePKU", "id": 42838469, "node_id": "MDQ6VXNlcjQyODM4NDY5", "avatar_url": "https://avatars.githubusercontent.com/u/42838469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YizhePKU", "html_url": "https://github.com/YizhePKU", "followers_url": "https://api.github.com/users/YizhePKU/followers", "following_url": "https://api.github.com/users/YizhePKU/following{/other_user}", "gists_url": "https://api.github.com/users/YizhePKU/gists{/gist_id}", "starred_url": "https://api.github.com/users/YizhePKU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YizhePKU/subscriptions", "organizations_url": "https://api.github.com/users/YizhePKU/orgs", "repos_url": "https://api.github.com/users/YizhePKU/repos", "events_url": "https://api.github.com/users/YizhePKU/events{/privacy}", "received_events_url": "https://api.github.com/users/YizhePKU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63697c37cf329e3b265ff4eaa16a6efd28f2a38b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63697c37cf329e3b265ff4eaa16a6efd28f2a38b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63697c37cf329e3b265ff4eaa16a6efd28f2a38b"}], "stats": {"total": 206, "additions": 104, "deletions": 102}, "files": [{"sha": "cb20a2e956d3800dac90960111c223243efaafef", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 104, "deletions": 102, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac1de7fde494296333492db90f8977bc74393e0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac1de7fde494296333492db90f8977bc74393e0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=dac1de7fde494296333492db90f8977bc74393e0", "patch": "@@ -20,6 +20,9 @@ along with GCC; see the file COPYING3.  If not see\n /* DO NOT INCLUDE ANYWHERE - this is automatically included with rust-parse.h\n  * This is also the reason why there are no include guards. */\n \n+#include \"rust-diagnostics.h\"\n+#include \"util/rust-make-unique.h\"\n+\n namespace Rust {\n // Left binding powers of operations.\n enum binding_powers\n@@ -402,7 +405,7 @@ Parser<ManagedTokenSource>::parse_crate ()\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse items\n-  std::vector<std::unique_ptr<AST::Item> > items;\n+  std::vector<std::unique_ptr<AST::Item>> items;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != END_OF_FILE)\n@@ -415,7 +418,7 @@ Parser<ManagedTokenSource>::parse_crate ()\n \t  add_error (std::move (error));\n \n \t  // TODO: should all items be cleared?\n-\t  items = std::vector<std::unique_ptr<AST::Item> > ();\n+\t  items = std::vector<std::unique_ptr<AST::Item>> ();\n \t  break;\n \t}\n \n@@ -874,7 +877,7 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n     }\n \n   // parse actual token tree vector - 0 or more\n-  std::vector<std::unique_ptr<AST::TokenTree> > token_trees_in_tree;\n+  std::vector<std::unique_ptr<AST::TokenTree>> token_trees_in_tree;\n \n   // repeat loop until finding the matching delimiter\n   t = lexer.peek_token ();\n@@ -979,10 +982,10 @@ Parser<ManagedTokenSource>::parse_token_tree ()\n  * individually is pretty simple and allows for better error diagnostics and\n  * detection. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::Item> >\n+std::vector<std::unique_ptr<AST::Item>>\n Parser<ManagedTokenSource>::parse_items ()\n {\n-  std::vector<std::unique_ptr<AST::Item> > items;\n+  std::vector<std::unique_ptr<AST::Item>> items;\n \n   // TODO: replace with do-while loop?\n   // infinite loop to save on comparisons (may be a tight loop) - breaks when\n@@ -1544,7 +1547,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n   lexer.skip_token ();\n \n   // parse actual token trees\n-  std::vector<std::unique_ptr<AST::TokenTree> > token_trees;\n+  std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1713,7 +1716,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n   lexer.skip_token ();\n \n   // parse actual macro matches\n-  std::vector<std::unique_ptr<AST::MacroMatch> > matches;\n+  std::vector<std::unique_ptr<AST::MacroMatch>> matches;\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1883,7 +1886,7 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n   skip_token (DOLLAR_SIGN);\n   skip_token (LEFT_PAREN);\n \n-  std::vector<std::unique_ptr<AST::MacroMatch> > matches;\n+  std::vector<std::unique_ptr<AST::MacroMatch>> matches;\n \n   // parse required first macro match\n   std::unique_ptr<AST::MacroMatch> initial_match = parse_macro_match ();\n@@ -2091,7 +2094,7 @@ Parser<ManagedTokenSource>::parse_module (\n \tstd::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n \t// parse items\n-\tstd::vector<std::unique_ptr<AST::Item> > items;\n+\tstd::vector<std::unique_ptr<AST::Item>> items;\n \tconst_TokenPtr tok = lexer.peek_token ();\n \twhile (tok->get_id () != RIGHT_CURLY)\n \t  {\n@@ -2331,7 +2334,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n \n-\t    std::vector<std::unique_ptr<AST::UseTree> > use_trees;\n+\t    std::vector<std::unique_ptr<AST::UseTree>> use_trees;\n \n \t    const_TokenPtr t = lexer.peek_token ();\n \t    while (t->get_id () != RIGHT_CURLY)\n@@ -2409,7 +2412,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n \n-\t    std::vector<std::unique_ptr<AST::UseTree> > use_trees;\n+\t    std::vector<std::unique_ptr<AST::UseTree>> use_trees;\n \n \t    // TODO: think of better control structure\n \t    const_TokenPtr t = lexer.peek_token ();\n@@ -2523,7 +2526,7 @@ Parser<ManagedTokenSource>::parse_function (\n   Identifier function_name = function_name_tok->get_str ();\n \n   // parse generic params - if exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   if (!skip_token (LEFT_PAREN))\n@@ -2626,20 +2629,20 @@ Parser<ManagedTokenSource>::parse_function_qualifiers ()\n \n // Parses generic (lifetime or type) params inside angle brackets (optional).\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::GenericParam> >\n+std::vector<std::unique_ptr<AST::GenericParam>>\n Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n {\n   if (lexer.peek_token ()->get_id () != LEFT_ANGLE)\n     {\n       // seems to be no generic params, so exit with empty vector\n-      return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n     }\n   lexer.skip_token ();\n \n   // DEBUG:\n   fprintf (stderr, \"skipped left angle in generic param\\n\");\n \n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params (is_right_angle_tok);\n \n   // DEBUG:\n@@ -2652,7 +2655,7 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n       fprintf (stderr, \"failed to skip generics right angle - returning empty \"\n \t\t       \"generic params\\n\");\n \n-      return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n     }\n \n   return generic_params;\n@@ -2661,10 +2664,10 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n /* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n  * always parse_generic_params_in_angles is what is wanted. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::GenericParam> >\n+std::vector<std::unique_ptr<AST::GenericParam>>\n Parser<ManagedTokenSource>::parse_generic_params ()\n {\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n \n   // can't parse lifetime and type params separately due to lookahead issues\n   // thus, parse them all here\n@@ -2748,12 +2751,12 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t    \"failed to parse identifier in type param in generic params\");\n \t  add_error (std::move (error));\n \n-\t  return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n \t}\n       Identifier ident = ident_tok->get_str ();\n \n       // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n       if (lexer.peek_token ()->get_id () == COLON)\n \t{\n \t  lexer.skip_token ();\n@@ -2777,7 +2780,7 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t\t\"failed to parse type in type param in generic params\");\n \t      add_error (std::move (error));\n \n-\t      return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+\t      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n \t    }\n \t}\n \n@@ -2811,7 +2814,7 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t\t       \"failed to parse type param in generic params\");\n \t  add_error (std::move (error));\n \n-\t  return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n \t}\n \n       // DEBUG\n@@ -2858,10 +2861,10 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n  * always parse_generic_params_in_angles is what is wanted. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::GenericParam> >\n+std::vector<std::unique_ptr<AST::GenericParam>>\n Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n \n   /* can't parse lifetime and type params separately due to lookahead issues\n    * thus, parse them all here */\n@@ -2929,7 +2932,7 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n       Identifier ident = ident_tok->get_str ();\n \n       // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n       if (lexer.peek_token ()->get_id () == COLON)\n \t{\n \t  lexer.skip_token ();\n@@ -3021,10 +3024,10 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n /* Parses lifetime generic parameters (pointers). Will also consume any trailing\n  * comma. No extra checks for end token. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::LifetimeParam> >\n+std::vector<std::unique_ptr<AST::LifetimeParam>>\n Parser<ManagedTokenSource>::parse_lifetime_params ()\n {\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n+  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params;\n \n   while (lexer.peek_token ()->get_id () != END_OF_FILE)\n     {\n@@ -3055,10 +3058,10 @@ Parser<ManagedTokenSource>::parse_lifetime_params ()\n  * comma. Has extra is_end_token predicate checking. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::LifetimeParam> >\n+std::vector<std::unique_ptr<AST::LifetimeParam>>\n Parser<ManagedTokenSource>::parse_lifetime_params (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n+  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params;\n \n   // if end_token is not specified, it defaults to EOF, so should work fine\n   while (!is_end_token (lexer.peek_token ()->get_id ()))\n@@ -3244,10 +3247,10 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n \n // Parses type generic parameters. Will also consume any trailing comma.\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::TypeParam> >\n+std::vector<std::unique_ptr<AST::TypeParam>>\n Parser<ManagedTokenSource>::parse_type_params ()\n {\n-  std::vector<std::unique_ptr<AST::TypeParam> > type_params;\n+  std::vector<std::unique_ptr<AST::TypeParam>> type_params;\n \n   // infinite loop with break on failure as no info on ending token\n   while (true)\n@@ -3276,10 +3279,10 @@ Parser<ManagedTokenSource>::parse_type_params ()\n // Parses type generic parameters. Will also consume any trailing comma.\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::TypeParam> >\n+std::vector<std::unique_ptr<AST::TypeParam>>\n Parser<ManagedTokenSource>::parse_type_params (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::TypeParam> > type_params;\n+  std::vector<std::unique_ptr<AST::TypeParam>> type_params;\n \n   while (!is_end_token (lexer.peek_token ()->get_id ()))\n     {\n@@ -3329,7 +3332,7 @@ Parser<ManagedTokenSource>::parse_type_param ()\n   lexer.skip_token ();\n \n   // parse type param bounds (if they exist)\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n   if (lexer.peek_token ()->get_id () == COLON)\n     {\n       lexer.skip_token ();\n@@ -3492,7 +3495,7 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n \n   /* parse where clause items - this is not a separate rule in the reference so\n    * won't be here */\n-  std::vector<std::unique_ptr<AST::WhereClauseItem> > where_clause_items;\n+  std::vector<std::unique_ptr<AST::WhereClauseItem>> where_clause_items;\n \n   /* HACK: where clauses end with a right curly or semicolon or equals in all\n    * uses currently */\n@@ -3589,7 +3592,7 @@ Parser<ManagedTokenSource>::parse_type_bound_where_clause_item ()\n     }\n \n   // parse type param bounds if they exist\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds\n     = parse_type_param_bounds ();\n \n   return std::unique_ptr<AST::TypeBoundWhereClauseItem> (\n@@ -3637,10 +3640,10 @@ Parser<ManagedTokenSource>::parse_for_lifetimes ()\n \n // Parses type parameter bounds in where clause or generic arguments.\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::TypeParamBound> >\n+std::vector<std::unique_ptr<AST::TypeParamBound>>\n Parser<ManagedTokenSource>::parse_type_param_bounds ()\n {\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n \n   std::unique_ptr<AST::TypeParamBound> initial_bound\n     = parse_type_param_bound ();\n@@ -3677,10 +3680,10 @@ Parser<ManagedTokenSource>::parse_type_param_bounds ()\n  * token handling. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::TypeParamBound> >\n+std::vector<std::unique_ptr<AST::TypeParamBound>>\n Parser<ManagedTokenSource>::parse_type_param_bounds (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n \n   std::unique_ptr<AST::TypeParamBound> initial_bound\n     = parse_type_param_bound ();\n@@ -3917,7 +3920,7 @@ Parser<ManagedTokenSource>::parse_type_alias (\n   Identifier alias_name = alias_name_tok->get_str ();\n \n   // parse generic params, which may not exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // parse where clause, which may not exist\n@@ -3977,7 +3980,7 @@ Parser<ManagedTokenSource>::parse_struct (\n   Identifier struct_name = name_tok->get_str ();\n \n   // parse generic params, which may or may not exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // branch on next token - determines whether proper struct or tuple struct\n@@ -4285,7 +4288,7 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n   Identifier enum_name = enum_name_tok->get_str ();\n \n   // parse generic params (of enum container, not enum variants) if they exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // parse where clause if it exists\n@@ -4298,7 +4301,7 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n     }\n \n   // parse actual enum variant definitions\n-  std::vector<std::unique_ptr<AST::EnumItem> > enum_items\n+  std::vector<std::unique_ptr<AST::EnumItem>> enum_items\n     = parse_enum_items ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n   if (!skip_token (RIGHT_CURLY))\n@@ -4315,10 +4318,10 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n \n // Parses the enum variants inside an enum definiton.\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::EnumItem> >\n+std::vector<std::unique_ptr<AST::EnumItem>>\n Parser<ManagedTokenSource>::parse_enum_items ()\n {\n-  std::vector<std::unique_ptr<AST::EnumItem> > items;\n+  std::vector<std::unique_ptr<AST::EnumItem>> items;\n \n   std::unique_ptr<AST::EnumItem> initial_item = parse_enum_item ();\n \n@@ -4351,10 +4354,10 @@ Parser<ManagedTokenSource>::parse_enum_items ()\n // Parses the enum variants inside an enum definiton.\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::EnumItem> >\n+std::vector<std::unique_ptr<AST::EnumItem>>\n Parser<ManagedTokenSource>::parse_enum_items (EndTokenPred is_end_tok)\n {\n-  std::vector<std::unique_ptr<AST::EnumItem> > items;\n+  std::vector<std::unique_ptr<AST::EnumItem>> items;\n \n   std::unique_ptr<AST::EnumItem> initial_item = parse_enum_item ();\n \n@@ -4491,7 +4494,7 @@ Parser<ManagedTokenSource>::parse_union (\n   Identifier union_name = union_name_tok->get_str ();\n \n   // parse optional generic parameters\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // parse optional where clause\n@@ -4656,11 +4659,11 @@ Parser<ManagedTokenSource>::parse_trait (\n   Identifier ident = ident_tok->get_str ();\n \n   // parse generic parameters (if they exist)\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // create placeholder type param bounds in case they don't exist\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n \n   // parse type param bounds (if they exist)\n   if (lexer.peek_token ()->get_id () == COLON)\n@@ -4685,7 +4688,7 @@ Parser<ManagedTokenSource>::parse_trait (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse trait items\n-  std::vector<std::unique_ptr<AST::TraitItem> > trait_items;\n+  std::vector<std::unique_ptr<AST::TraitItem>> trait_items;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_CURLY)\n@@ -4761,7 +4764,7 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \tIdentifier ident = ident_tok->get_str ();\n \n \t// parse generic params\n-\tstd::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+\tstd::vector<std::unique_ptr<AST::GenericParam>> generic_params\n \t  = parse_generic_params_in_angles ();\n \n \tif (!skip_token (LEFT_PAREN))\n@@ -4894,7 +4897,7 @@ Parser<ManagedTokenSource>::parse_trait_type (\n   Identifier ident = ident_tok->get_str ();\n \n   bool has_colon = false;\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \n   // parse optional colon\n   if (lexer.peek_token ()->get_id () == COLON)\n@@ -4988,7 +4991,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n     }\n \n   // parse generic params (shared by trait and inherent impls)\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // Again, trait impl-only feature, but optional one, so can be used for\n@@ -5041,7 +5044,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n       // parse inherent impl items\n-      std::vector<std::unique_ptr<AST::InherentImplItem> > impl_items;\n+      std::vector<std::unique_ptr<AST::InherentImplItem>> impl_items;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () != RIGHT_CURLY)\n@@ -5116,7 +5119,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n       // parse trait impl items\n-      std::vector<std::unique_ptr<AST::TraitImplItem> > impl_items;\n+      std::vector<std::unique_ptr<AST::TraitImplItem>> impl_items;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () != RIGHT_CURLY)\n@@ -5298,7 +5301,7 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n   Identifier ident = ident_tok->get_str ();\n \n   // parse generic params\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   if (!skip_token (LEFT_PAREN))\n@@ -5533,7 +5536,7 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n     \"about to start parsing generic params in trait impl function or method\\n\");\n \n   // parse generic params\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // DEBUG:\n@@ -5691,7 +5694,7 @@ Parser<ManagedTokenSource>::parse_extern_block (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse declarations inside extern block\n-  std::vector<std::unique_ptr<AST::ExternalItem> > extern_items;\n+  std::vector<std::unique_ptr<AST::ExternalItem>> extern_items;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_CURLY)\n@@ -5808,7 +5811,7 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \tIdentifier ident = ident_tok->get_str ();\n \n \t// parse (optional) generic params\n-\tstd::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+\tstd::vector<std::unique_ptr<AST::GenericParam>> generic_params\n \t  = parse_generic_params_in_angles ();\n \n \tif (!skip_token (LEFT_PAREN))\n@@ -6134,7 +6137,7 @@ Parser<ManagedTokenSource>::parse_type_path ()\n     }\n \n   // create segment vector\n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n \n   // parse required initial segment\n   std::unique_ptr<AST::TypePathSegment> initial_segment\n@@ -6219,7 +6222,7 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n     }\n \n   // try to parse types second\n-  std::vector<std::unique_ptr<AST::Type> > type_args;\n+  std::vector<std::unique_ptr<AST::Type>> type_args;\n \n   // TODO: think of better control structure\n   t = lexer.peek_token ();\n@@ -6404,7 +6407,7 @@ Parser<ManagedTokenSource>::parse_type_path_function ()\n     }\n \n   // parse function inputs\n-  std::vector<std::unique_ptr<AST::Type> > inputs;\n+  std::vector<std::unique_ptr<AST::Type>> inputs;\n \n   while (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n     {\n@@ -6707,7 +6710,7 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_type ()\n     }\n \n   // parse path segments\n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n   segments.reserve (1);\n \n   // parse initial required segment\n@@ -6881,7 +6884,7 @@ Parser<ManagedTokenSource>::parse_method ()\n   Identifier method_name = ident_tok->get_str ();\n \n   // parse generic params - if exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   if (!skip_token (LEFT_PAREN))\n@@ -7284,7 +7287,7 @@ Parser<ManagedTokenSource>::parse_block_expr (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse statements and expression\n-  std::vector<std::unique_ptr<AST::Stmt> > stmts;\n+  std::vector<std::unique_ptr<AST::Stmt>> stmts;\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n \n   const_TokenPtr t = lexer.peek_token ();\n@@ -7896,7 +7899,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n   lexer.skip_token ();\n \n   // parse match arm patterns (which are required)\n-  std::vector<std::unique_ptr<AST::Pattern> > match_arm_patterns\n+  std::vector<std::unique_ptr<AST::Pattern>> match_arm_patterns\n     = parse_match_arm_patterns (EQUAL);\n   if (match_arm_patterns.empty ())\n     {\n@@ -8201,7 +8204,7 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n   lexer.skip_token ();\n \n   // parse predicate patterns\n-  std::vector<std::unique_ptr<AST::Pattern> > predicate_patterns\n+  std::vector<std::unique_ptr<AST::Pattern>> predicate_patterns\n     = parse_match_arm_patterns (EQUAL);\n   // TODO: have to ensure that there is at least 1 pattern?\n \n@@ -8524,7 +8527,7 @@ Parser<ManagedTokenSource>::parse_match_arm ()\n     }\n \n   // parse match arm patterns - at least 1 is required\n-  std::vector<std::unique_ptr<AST::Pattern> > match_arm_patterns\n+  std::vector<std::unique_ptr<AST::Pattern>> match_arm_patterns\n     = parse_match_arm_patterns (RIGHT_CURLY);\n   if (match_arm_patterns.empty ())\n     {\n@@ -8568,7 +8571,7 @@ Parser<ManagedTokenSource>::parse_match_arm ()\n  * that would exist after the patterns are done (e.g. '}' for match expr, '='\n  * for if let and while let). */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::Pattern> >\n+std::vector<std::unique_ptr<AST::Pattern>>\n Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n {\n   // skip optional leading '|'\n@@ -8582,7 +8585,7 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n    * If semantically different, I need a wrapped \"match arm patterns\" object for\n    * this. */\n \n-  std::vector<std::unique_ptr<AST::Pattern> > patterns;\n+  std::vector<std::unique_ptr<AST::Pattern>> patterns;\n \n   // quick break out if end_token_id\n   if (lexer.peek_token ()->get_id () == end_token_id)\n@@ -8777,7 +8780,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n       else if (lexer.peek_token ()->get_id () == RIGHT_SQUARE)\n \t{\n \t  // single-element array expression\n-\t  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+\t  std::vector<std::unique_ptr<AST::Expr>> exprs;\n \t  exprs.reserve (1);\n \t  exprs.push_back (std::move (initial_expr));\n \t  exprs.shrink_to_fit ();\n@@ -8794,7 +8797,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n       else if (lexer.peek_token ()->get_id () == COMMA)\n \t{\n \t  // multi-element array expression (or trailing comma)\n-\t  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+\t  std::vector<std::unique_ptr<AST::Expr>> exprs;\n \t  exprs.push_back (std::move (initial_expr));\n \n \t  const_TokenPtr t = lexer.peek_token ();\n@@ -8914,7 +8917,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n \n       // create tuple with empty tuple elems\n       return std::unique_ptr<AST::TupleExpr> (\n-\tnew AST::TupleExpr (std::vector<std::unique_ptr<AST::Expr> > (),\n+\tnew AST::TupleExpr (std::vector<std::unique_ptr<AST::Expr>> (),\n \t\t\t    std::move (inner_attrs), std::move (outer_attrs),\n \t\t\t    locus));\n     }\n@@ -8945,7 +8948,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n   else if (lexer.peek_token ()->get_id () == COMMA)\n     {\n       // tuple expr\n-      std::vector<std::unique_ptr<AST::Expr> > exprs;\n+      std::vector<std::unique_ptr<AST::Expr>> exprs;\n       exprs.push_back (std::move (first_expr));\n \n       // parse potential other tuple exprs\n@@ -9073,7 +9076,7 @@ Parser<ManagedTokenSource>::parse_type ()\n       case LIFETIME: {\n \t/* probably a lifetime bound, so probably type param bounds in\n \t * TraitObjectType */\n-\tstd::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n+\tstd::vector<std::unique_ptr<AST::TypeParamBound>> bounds\n \t  = parse_type_param_bounds ();\n \n \treturn std::unique_ptr<AST::TraitObjectType> (\n@@ -9138,7 +9141,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t    }\n \t    case PLUS: {\n \t      // type param bounds\n-\t      std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t      std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \n \t      // convert type path to trait bound\n \t      std::unique_ptr<AST::TraitBound> path_bound (\n@@ -9193,7 +9196,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t{\n \t  /* cannot be one bound because lifetime prevents it from being\n \t   * traitbound */\n-\t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n+\t  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds\n \t    = parse_type_param_bounds ();\n \n \t  return std::unique_ptr<AST::ImplTraitType> (\n@@ -9230,7 +9233,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t    }\n \n \t  // parse additional type param bounds\n-\t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \t  bounds.push_back (std::move (initial_bound));\n \t  while (t->get_id () == PLUS)\n \t    {\n@@ -9266,7 +9269,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  {\n \t    /* cannot be one bound because lifetime prevents it from being\n \t     * traitbound */\n-\t    std::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n+\t    std::vector<std::unique_ptr<AST::TypeParamBound>> bounds\n \t      = parse_type_param_bounds ();\n \n \t    return std::unique_ptr<AST::TraitObjectType> (\n@@ -9303,7 +9306,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      }\n \n \t    // parse additional type param bounds\n-\t    std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t    std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \t    bounds.push_back (std::move (initial_bound));\n \t    while (t->get_id () == PLUS)\n \t      {\n@@ -9359,7 +9362,7 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n    * whether trailing comma happens */\n   const_TokenPtr t = lexer.peek_token ();\n   bool trailing_comma = true;\n-  std::vector<std::unique_ptr<AST::Type> > types;\n+  std::vector<std::unique_ptr<AST::Type>> types;\n \n   while (t->get_id () != RIGHT_PAREN)\n     {\n@@ -9398,7 +9401,7 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n       if (lexer.peek_token ()->get_id () == PLUS)\n \t{\n \t  // create type param bounds vector\n-\t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \n \t  // HACK: convert type to traitbound and add to bounds\n \t  std::unique_ptr<AST::Type> released_ptr = std::move (types[0]);\n@@ -9523,7 +9526,7 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n \tstd::unique_ptr<AST::TraitBound> initial_bound (\n \t  new AST::TraitBound (std::move (path), for_locus, false, false,\n \t\t\t       std::move (for_lifetimes)));\n-\tstd::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\tstd::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \tbounds.push_back (std::move (initial_bound));\n \n \twhile (t->get_id () == PLUS)\n@@ -10124,7 +10127,7 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n    * whether trailing comma happens */\n   const_TokenPtr t = lexer.peek_token ();\n   bool trailing_comma = true;\n-  std::vector<std::unique_ptr<AST::Type> > types;\n+  std::vector<std::unique_ptr<AST::Type>> types;\n \n   while (t->get_id () != RIGHT_PAREN)\n     {\n@@ -10681,7 +10684,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n       lexer.skip_token ();\n \n       // parse new patterns while next token is a comma\n-      std::vector<std::unique_ptr<AST::Pattern> > patterns;\n+      std::vector<std::unique_ptr<AST::Pattern>> patterns;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () == COMMA)\n@@ -10720,8 +10723,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n       // create ranged tuple pattern items with only upper items\n       std::unique_ptr<AST::TuplePatternItemsRanged> items (\n \tnew AST::TuplePatternItemsRanged (\n-\t  std::vector<std::unique_ptr<AST::Pattern> > (),\n-\t  std::move (patterns)));\n+\t  std::vector<std::unique_ptr<AST::Pattern>> (), std::move (patterns)));\n       return std::unique_ptr<AST::TuplePattern> (\n \tnew AST::TuplePattern (std::move (items), paren_locus));\n     }\n@@ -10752,7 +10754,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n \tlexer.skip_token ();\n \n \t// create vector of patterns\n-\tstd::vector<std::unique_ptr<AST::Pattern> > patterns;\n+\tstd::vector<std::unique_ptr<AST::Pattern>> patterns;\n \tpatterns.push_back (std::move (initial_pattern));\n \n \tt = lexer.peek_token ();\n@@ -10794,7 +10796,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n \t    lexer.skip_token ();\n \n \t    // parse upper patterns\n-\t    std::vector<std::unique_ptr<AST::Pattern> > upper_patterns;\n+\t    std::vector<std::unique_ptr<AST::Pattern>> upper_patterns;\n \t    t = lexer.peek_token ();\n \t    while (t->get_id () == COMMA)\n \t      {\n@@ -10872,7 +10874,7 @@ Parser<ManagedTokenSource>::parse_slice_pattern ()\n       return nullptr;\n     }\n \n-  std::vector<std::unique_ptr<AST::Pattern> > patterns;\n+  std::vector<std::unique_ptr<AST::Pattern>> patterns;\n   patterns.push_back (std::move (initial_pattern));\n \n   const_TokenPtr t = lexer.peek_token ();\n@@ -11121,7 +11123,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::TupleStructItems>\n Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n {\n-  std::vector<std::unique_ptr<AST::Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<AST::Pattern>> lower_patterns;\n \n   // DEBUG\n   fprintf (stderr, \"started parsing tuple struct items\\n\");\n@@ -11135,7 +11137,7 @@ Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n       // DEBUG\n       fprintf (stderr, \"'..' at front in tuple struct items detected\\n\");\n \n-      std::vector<std::unique_ptr<AST::Pattern> > upper_patterns;\n+      std::vector<std::unique_ptr<AST::Pattern>> upper_patterns;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () == COMMA)\n@@ -11216,7 +11218,7 @@ Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n \t// has an upper range that must be parsed separately\n \tlexer.skip_token ();\n \n-\tstd::vector<std::unique_ptr<AST::Pattern> > upper_patterns;\n+\tstd::vector<std::unique_ptr<AST::Pattern>> upper_patterns;\n \n \tt = lexer.peek_token ();\n \twhile (t->get_id () == COMMA)\n@@ -11261,7 +11263,7 @@ template <typename ManagedTokenSource>\n AST::StructPatternElements\n Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n {\n-  std::vector<std::unique_ptr<AST::StructPatternField> > fields;\n+  std::vector<std::unique_ptr<AST::StructPatternField>> fields;\n \n   std::vector<AST::Attribute> etc_attrs;\n   bool has_etc = false;\n@@ -11751,7 +11753,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \tlexer.skip_token ();\n \n \t// parse actual token trees\n-\tstd::vector<std::unique_ptr<AST::TokenTree> > token_trees;\n+\tstd::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n \n \tt3 = lexer.peek_token ();\n \t// parse token trees until the initial delimiter token is found again\n@@ -12066,7 +12068,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n   lexer.skip_token ();\n \n   // parse actual token trees\n-  std::vector<std::unique_ptr<AST::TokenTree> > token_trees;\n+  std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n \n   t3 = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -14218,7 +14220,7 @@ Parser<ManagedTokenSource>::parse_method_call_expr (\n     }\n \n   // parse method params (if they exist)\n-  std::vector<std::unique_ptr<AST::Expr> > params;\n+  std::vector<std::unique_ptr<AST::Expr>> params;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)\n@@ -14264,7 +14266,7 @@ Parser<ManagedTokenSource>::parse_function_call_expr (\n   std::vector<AST::Attribute> outer_attrs, ParseRestrictions)\n {\n   // parse function params (if they exist)\n-  std::vector<std::unique_ptr<AST::Expr> > params;\n+  std::vector<std::unique_ptr<AST::Expr>> params;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)\n@@ -14375,7 +14377,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n \t// struct with struct expr fields\n \n \t// parse struct expr fields\n-\tstd::vector<std::unique_ptr<AST::StructExprField> > fields;\n+\tstd::vector<std::unique_ptr<AST::StructExprField>> fields;\n \n \twhile (t->get_id () != RIGHT_CURLY && t->get_id () != DOT_DOT)\n \t  {\n@@ -14489,7 +14491,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n \n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n-  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+  std::vector<std::unique_ptr<AST::Expr>> exprs;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)"}, {"sha": "0c4da2fb6c2413d0bb19ddbfc5201dd16f761ff7", "filename": "gcc/rust/util/rust-make-unique.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac1de7fde494296333492db90f8977bc74393e0/gcc%2Frust%2Futil%2Frust-make-unique.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac1de7fde494296333492db90f8977bc74393e0/gcc%2Frust%2Futil%2Frust-make-unique.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-make-unique.h?ref=dac1de7fde494296333492db90f8977bc74393e0", "previous_filename": "gcc/rust/util/rust-make_unique.h"}]}