{"sha": "d242408fda0bb64230b5446911d860df3e19a3da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI0MjQwOGZkYTBiYjY0MjMwYjU0NDY5MTFkODYwZGYzZTE5YTNkYQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-11-20T15:10:19Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-11-20T15:10:19Z"}, "message": "convert many if_marked htab to hash_table\n\nada/\n\n\t* gcc-interface/decl.c, gcc-interface/utils.c: replace htab with\n\thash_table.\n\ncp/\n\n\t* cp-objcp-common.c: Use hash_table instead of htab.\n\ngcc/\n\n\t* config/i386/i386.c, function.c, trans-mem.c, tree-core.h,\n\ttree.c, tree.h, ubsan.c, varasm.c: Use hash_table instead of htab.\n\nFrom-SVN: r217867", "tree": {"sha": "f1326eb25df16ac5403659af6e7b0668a0042fb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1326eb25df16ac5403659af6e7b0668a0042fb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d242408fda0bb64230b5446911d860df3e19a3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d242408fda0bb64230b5446911d860df3e19a3da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d242408fda0bb64230b5446911d860df3e19a3da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d242408fda0bb64230b5446911d860df3e19a3da/comments", "author": null, "committer": null, "parents": [{"sha": "aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aebf76a2d6de989fe3e8c88aa047e4cfbd1e340e"}], "stats": {"total": 532, "additions": 326, "deletions": 206}, "files": [{"sha": "4d481c973c6ba819b4810e341731a5d74f5cec78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -1,3 +1,8 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* config/i386/i386.c, function.c, trans-mem.c, tree-core.h,\n+\ttree.c, tree.h, ubsan.c, varasm.c: Use hash_table instead of htab.\n+\n 2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* doc/gty.texi: Document the new cache gty attribute."}, {"sha": "fa056d3bb9920ad2919dfe2e92b1b94403f90dc4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -1,3 +1,8 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* gcc-interface/decl.c, gcc-interface/utils.c: replace htab with\n+\thash_table.\n+\n 2014-11-20  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma, case Elaborate): Forbid pragma"}, {"sha": "c133a22c777f4006cab47f1c5b4994c540fd9b8f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -128,8 +128,35 @@ typedef struct variant_desc_d {\n \n \n /* A hash table used to cache the result of annotate_value.  */\n-static GTY ((if_marked (\"tree_int_map_marked_p\"),\n-\t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n+\n+struct value_annotation_hasher : ggc_cache_hasher<tree_int_map *>\n+{\n+  static inline hashval_t\n+  hash (tree_int_map *m)\n+  {\n+    return htab_hash_pointer (m->base.from);\n+  }\n+\n+  static inline bool\n+  equal (tree_int_map *a, tree_int_map *b)\n+  {\n+    return a->base.from == b->base.from;\n+  }\n+\n+  static void\n+  handle_cache_entry (tree_int_map *&m)\n+  {\n+    extern void gt_ggc_mx (tree_int_map *&);\n+    if (m == HTAB_EMPTY_ENTRY || m == HTAB_DELETED_ENTRY)\n+      return;\n+    else if (ggc_marked_p (m->base.from))\n+      gt_ggc_mx (m);\n+    else\n+      m = static_cast<tree_int_map *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n+\n+static GTY ((cache)) hash_table<value_annotation_hasher> *annotate_value_cache;\n \n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute (struct attrib **,\n@@ -7362,7 +7389,7 @@ annotate_value (tree gnu_size)\n       struct tree_int_map *e;\n \n       in.base.from = gnu_size;\n-      e = (struct tree_int_map *) htab_find (annotate_value_cache, &in);\n+      e = annotate_value_cache->find (&in);\n \n       if (e)\n \treturn (Node_Ref_Or_Val) e->to;\n@@ -7491,8 +7518,7 @@ annotate_value (tree gnu_size)\n \t look up, so we have to search again.  Allocating and inserting an\n \t entry at that point would be an alternative, but then we'd better\n \t discard the entry if we decided not to cache it.  */\n-      h = (struct tree_int_map **)\n-\t    htab_find_slot (annotate_value_cache, &in, INSERT);\n+      h = annotate_value_cache->find_slot (&in, INSERT);\n       gcc_assert (!*h);\n       *h = ggc_alloc<tree_int_map> ();\n       (*h)->base.from = gnu_size;\n@@ -8840,8 +8866,7 @@ void\n init_gnat_decl (void)\n {\n   /* Initialize the cache of annotated values.  */\n-  annotate_value_cache\n-    = htab_create_ggc (512, tree_int_map_hash, tree_int_map_eq, 0);\n+  annotate_value_cache = hash_table<value_annotation_hasher>::create_ggc (512);\n }\n \n /* Destroy data structures of the decl.c module.  */\n@@ -8850,7 +8875,7 @@ void\n destroy_gnat_decl (void)\n {\n   /* Destroy the cache of annotated values.  */\n-  htab_delete (annotate_value_cache);\n+  annotate_value_cache->empty ();\n   annotate_value_cache = NULL;\n }\n "}, {"sha": "32f0012c0c83e1669772bfd34e63d640cf283565", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -233,20 +233,23 @@ static GTY(()) vec<tree, va_gc> *global_renaming_pointers;\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n-static int pad_type_hash_marked_p (const void *p);\n-static hashval_t pad_type_hash_hash (const void *p);\n-static int pad_type_hash_eq (const void *p1, const void *p2);\n-\n /* A hash table of padded types.  It is modelled on the generic type\n    hash table in tree.c, which must thus be used as a reference.  */\n-struct GTY(()) pad_type_hash {\n+\n+struct GTY((for_user)) pad_type_hash {\n   unsigned long hash;\n   tree type;\n };\n \n-static GTY ((if_marked (\"pad_type_hash_marked_p\"),\n-\t     param_is (struct pad_type_hash)))\n-  htab_t pad_type_hash_table;\n+struct pad_type_hasher : ggc_cache_hasher<pad_type_hash *>\n+{\n+  static inline hashval_t hash (pad_type_hash *t) { return t->hash; }\n+  static bool equal (pad_type_hash *a, pad_type_hash *b);\n+  static void handle_cache_entry (pad_type_hash *&);\n+};\n+\n+static GTY ((cache))\n+  hash_table<pad_type_hasher> *pad_type_hash_table;\n \n static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n@@ -294,8 +297,7 @@ init_gnat_utils (void)\n   dummy_node_table = ggc_cleared_vec_alloc<tree> (max_gnat_nodes);\n \n   /* Initialize the hash table of padded types.  */\n-  pad_type_hash_table\n-    = htab_create_ggc (512, pad_type_hash_hash, pad_type_hash_eq, 0);\n+  pad_type_hash_table = hash_table<pad_type_hasher>::create_ggc (512);\n }\n \n /* Destroy data structures of the utils.c module.  */\n@@ -312,7 +314,7 @@ destroy_gnat_utils (void)\n   dummy_node_table = NULL;\n \n   /* Destroy the hash table of padded types.  */\n-  htab_delete (pad_type_hash_table);\n+  pad_type_hash_table->empty ();\n   pad_type_hash_table = NULL;\n \n   /* Invalidate the global renaming pointers.   */\n@@ -1155,29 +1157,23 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \n /* See if the data pointed to by the hash table slot is marked.  */\n \n-static int\n-pad_type_hash_marked_p (const void *p)\n-{\n-  const_tree const type = ((const struct pad_type_hash *) p)->type;\n-\n-  return ggc_marked_p (type);\n-}\n-\n-/* Return the cached hash value.  */\n-\n-static hashval_t\n-pad_type_hash_hash (const void *p)\n+void\n+pad_type_hasher::handle_cache_entry (pad_type_hash *&t)\n {\n-  return ((const struct pad_type_hash *) p)->hash;\n+  extern void gt_ggc_mx (pad_type_hash *&);\n+  if (t == HTAB_EMPTY_ENTRY || t == HTAB_DELETED_ENTRY)\n+    return;\n+  else if (ggc_marked_p (t->type))\n+    gt_ggc_mx (t);\n+  else\n+    t = static_cast<pad_type_hash *> (HTAB_DELETED_ENTRY);\n }\n \n-/* Return 1 iff the padded types are equivalent.  */\n+/* Return true iff the padded types are equivalent.  */\n \n-static int\n-pad_type_hash_eq (const void *p1, const void *p2)\n+bool\n+pad_type_hasher::equal (pad_type_hash *t1, pad_type_hash *t2)\n {\n-  const struct pad_type_hash *const t1 = (const struct pad_type_hash *) p1;\n-  const struct pad_type_hash *const t2 = (const struct pad_type_hash *) p2;\n   tree type1, type2;\n \n   if (t1->hash != t2->hash)\n@@ -1204,7 +1200,6 @@ lookup_and_insert_pad_type (tree type)\n {\n   hashval_t hashcode;\n   struct pad_type_hash in, *h;\n-  void **loc;\n \n   hashcode\n     = iterative_hash_object (TYPE_HASH (TREE_TYPE (TYPE_FIELDS (type))), 0);\n@@ -1214,16 +1209,14 @@ lookup_and_insert_pad_type (tree type)\n \n   in.hash = hashcode;\n   in.type = type;\n-  h = (struct pad_type_hash *)\n-\thtab_find_with_hash (pad_type_hash_table, &in, hashcode);\n+  h = pad_type_hash_table->find_with_hash (&in, hashcode);\n   if (h)\n     return h->type;\n \n   h = ggc_alloc<pad_type_hash> ();\n   h->hash = hashcode;\n   h->type = type;\n-  loc = htab_find_slot_with_hash (pad_type_hash_table, h, hashcode, INSERT);\n-  *loc = (void *)h;\n+  *pad_type_hash_table->find_slot_with_hash (h, hashcode, INSERT) = h;\n   return NULL_TREE;\n }\n "}, {"sha": "7372c387ced60d3a713af84192e6e9cdcb7c7fcd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -14055,14 +14055,34 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n    to symbol DECL if BEIMPORT is true.  Otherwise create or return the\n    unique refptr-DECL symbol corresponding to symbol DECL.  */\n \n-static GTY((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n-  htab_t dllimport_map;\n+struct dllimport_hasher : ggc_cache_hasher<tree_map *>\n+{\n+  static inline hashval_t hash (tree_map *m) { return m->hash; }\n+  static inline bool\n+  equal (tree_map *a, tree_map *b)\n+  {\n+    return a->base.from == b->base.from;\n+  }\n+\n+  static void\n+  handle_cache_entry (tree_map *&m)\n+  {\n+    extern void gt_ggc_mx (tree_map *&);\n+    if (m == HTAB_EMPTY_ENTRY || m == HTAB_DELETED_ENTRY)\n+      return;\n+    else if (ggc_marked_p (m->base.from))\n+      gt_ggc_mx (m);\n+    else\n+      m = static_cast<tree_map *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n+\n+static GTY((cache)) hash_table<dllimport_hasher> *dllimport_map;\n \n static tree\n get_dllimport_decl (tree decl, bool beimport)\n {\n   struct tree_map *h, in;\n-  void **loc;\n   const char *name;\n   const char *prefix;\n   size_t namelen, prefixlen;\n@@ -14071,12 +14091,12 @@ get_dllimport_decl (tree decl, bool beimport)\n   rtx rtl;\n \n   if (!dllimport_map)\n-    dllimport_map = htab_create_ggc (512, tree_map_hash, tree_map_eq, 0);\n+    dllimport_map = hash_table<dllimport_hasher>::create_ggc (512);\n \n   in.hash = htab_hash_pointer (decl);\n   in.base.from = decl;\n-  loc = htab_find_slot_with_hash (dllimport_map, &in, in.hash, INSERT);\n-  h = (struct tree_map *) *loc;\n+  tree_map **loc = dllimport_map->find_slot_with_hash (&in, in.hash, INSERT);\n+  h = *loc;\n   if (h)\n     return h->to;\n "}, {"sha": "3111050cb62a3e1248dbffe394217c4d15edbb2c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -1,3 +1,7 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* cp-objcp-common.c: Use hash_table instead of htab.\n+\n 2014-11-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/56041"}, {"sha": "9457af27964e3841e8dda40ca6a6daf08d101d84", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -178,8 +178,8 @@ has_c_linkage (const_tree decl)\n   return DECL_EXTERN_C_P (decl);\n }\n \n-static GTY ((if_marked (\"tree_decl_map_marked_p\"), param_is (struct tree_decl_map)))\n-     htab_t shadowed_var_for_decl;\n+static GTY ((cache))\n+     hash_table<tree_decl_map_cache_hasher> *shadowed_var_for_decl;\n \n /* Lookup a shadowed var for FROM, and return it if we find one.  */\n \n@@ -189,8 +189,7 @@ decl_shadowed_for_var_lookup (tree from)\n   struct tree_decl_map *h, in;\n   in.base.from = from;\n \n-  h = (struct tree_decl_map *)\n-      htab_find_with_hash (shadowed_var_for_decl, &in, DECL_UID (from));\n+  h = shadowed_var_for_decl->find_with_hash (&in, DECL_UID (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;\n@@ -202,21 +201,18 @@ void\n decl_shadowed_for_var_insert (tree from, tree to)\n {\n   struct tree_decl_map *h;\n-  void **loc;\n \n   h = ggc_alloc<tree_decl_map> ();\n   h->base.from = from;\n   h->to = to;\n-  loc = htab_find_slot_with_hash (shadowed_var_for_decl, h, DECL_UID (from),\n-\t\t\t\t  INSERT);\n-  *(struct tree_decl_map **) loc = h;\n+  *shadowed_var_for_decl->find_slot_with_hash (h, DECL_UID (from), INSERT) = h;\n }\n \n void\n init_shadowed_var_for_decl (void)\n {\n-  shadowed_var_for_decl = htab_create_ggc (512, tree_decl_map_hash,\n-\t\t\t\t\t   tree_decl_map_eq, 0);\n+  shadowed_var_for_decl\n+    = hash_table<tree_decl_map_cache_hasher>::create_ggc (512);\n }\n \n /* Return true if stmt can fall through.  Used by block_may_fallthru"}, {"sha": "f069fed61a2b4bdb7a497d387a4d995b8f14d87b", "filename": "gcc/function.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -116,10 +116,17 @@ struct machine_function * (*init_machine_status) (void);\n struct function *cfun = 0;\n \n /* These hashes record the prologue and epilogue insns.  */\n-static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n-  htab_t prologue_insn_hash;\n-static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n-  htab_t epilogue_insn_hash;\n+\n+struct insn_cache_hasher : ggc_cache_hasher<rtx>\n+{\n+  static hashval_t hash (rtx x) { return htab_hash_pointer (x); }\n+  static bool equal (rtx a, rtx b) { return a == b; }\n+};\n+\n+static GTY((cache))\n+  hash_table<insn_cache_hasher> *prologue_insn_hash;\n+static GTY((cache))\n+  hash_table<insn_cache_hasher> *epilogue_insn_hash;\n \f\n \n hash_table<used_type_hasher> *types_used_by_vars_hash = NULL;\n@@ -136,8 +143,9 @@ static tree *get_block_vector (tree, int *);\n extern tree debug_find_var_in_block_tree (tree, tree);\n /* We always define `record_insns' even if it's not used so that we\n    can always export `prologue_epilogue_contains'.  */\n-static void record_insns (rtx_insn *, rtx, htab_t *) ATTRIBUTE_UNUSED;\n-static bool contains (const_rtx, htab_t);\n+static void record_insns (rtx_insn *, rtx, hash_table<insn_cache_hasher> **)\n+     ATTRIBUTE_UNUSED;\n+static bool contains (const_rtx, hash_table<insn_cache_hasher> *);\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n@@ -5527,18 +5535,17 @@ get_arg_pointer_save_area (void)\n    for the first time.  */\n \n static void\n-record_insns (rtx_insn *insns, rtx end, htab_t *hashp)\n+record_insns (rtx_insn *insns, rtx end, hash_table<insn_cache_hasher> **hashp)\n {\n   rtx_insn *tmp;\n-  htab_t hash = *hashp;\n+  hash_table<insn_cache_hasher> *hash = *hashp;\n \n   if (hash == NULL)\n-    *hashp = hash\n-      = htab_create_ggc (17, htab_hash_pointer, htab_eq_pointer, NULL);\n+    *hashp = hash = hash_table<insn_cache_hasher>::create_ggc (17);\n \n   for (tmp = insns; tmp != end; tmp = NEXT_INSN (tmp))\n     {\n-      void **slot = htab_find_slot (hash, tmp, INSERT);\n+      rtx *slot = hash->find_slot (tmp, INSERT);\n       gcc_assert (*slot == NULL);\n       *slot = tmp;\n     }\n@@ -5551,18 +5558,18 @@ record_insns (rtx_insn *insns, rtx end, htab_t *hashp)\n void\n maybe_copy_prologue_epilogue_insn (rtx insn, rtx copy)\n {\n-  htab_t hash;\n-  void **slot;\n+  hash_table<insn_cache_hasher> *hash;\n+  rtx *slot;\n \n   hash = epilogue_insn_hash;\n-  if (!hash || !htab_find (hash, insn))\n+  if (!hash || !hash->find (insn))\n     {\n       hash = prologue_insn_hash;\n-      if (!hash || !htab_find (hash, insn))\n+      if (!hash || !hash->find (insn))\n \treturn;\n     }\n \n-  slot = htab_find_slot (hash, copy, INSERT);\n+  slot = hash->find_slot (copy, INSERT);\n   gcc_assert (*slot == NULL);\n   *slot = copy;\n }\n@@ -5571,7 +5578,7 @@ maybe_copy_prologue_epilogue_insn (rtx insn, rtx copy)\n    we can be running after reorg, SEQUENCE rtl is possible.  */\n \n static bool\n-contains (const_rtx insn, htab_t hash)\n+contains (const_rtx insn, hash_table<insn_cache_hasher> *hash)\n {\n   if (hash == NULL)\n     return false;\n@@ -5581,12 +5588,12 @@ contains (const_rtx insn, htab_t hash)\n       rtx_sequence *seq = as_a <rtx_sequence *> (PATTERN (insn));\n       int i;\n       for (i = seq->len () - 1; i >= 0; i--)\n-\tif (htab_find (hash, seq->element (i)))\n+\tif (hash->find (seq->element (i)))\n \t  return true;\n       return false;\n     }\n \n-  return htab_find (hash, insn) != NULL;\n+  return hash->find (const_cast<rtx> (insn)) != NULL;\n }\n \n int\n@@ -6198,7 +6205,7 @@ reposition_prologue_and_epilogue_notes (void)\n      non-null is a signal that it is non-empty.  */\n   if (prologue_insn_hash != NULL)\n     {\n-      size_t len = htab_elements (prologue_insn_hash);\n+      size_t len = prologue_insn_hash->elements ();\n       rtx_insn *insn, *last = NULL, *note = NULL;\n \n       /* Scan from the beginning until we reach the last prologue insn.  */"}, {"sha": "a7de3e60f2f3f122d01fade27c2ea331d2288c54", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -472,8 +472,29 @@ build_tm_abort_call (location_t loc, bool is_outer)\n /* Map for aribtrary function replacement under TM, as created\n    by the tm_wrap attribute.  */\n \n-static GTY((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n-     htab_t tm_wrap_map;\n+struct tm_wrapper_hasher : ggc_cache_hasher<tree_map *>\n+{\n+  static inline hashval_t hash (tree_map *m) { return m->hash; }\n+  static inline bool\n+  equal (tree_map *a, tree_map *b)\n+  {\n+    return a->base.from == b->base.from;\n+  }\n+\n+  static void\n+  handle_cache_entry (tree_map *&m)\n+    {\n+      extern void gt_ggc_mx (tree_map *&);\n+      if (m == HTAB_EMPTY_ENTRY || m == HTAB_DELETED_ENTRY)\n+\treturn;\n+      else if (ggc_marked_p (m->base.from))\n+\tgt_ggc_mx (m);\n+      else\n+\tm = static_cast<tree_map *> (HTAB_DELETED_ENTRY);\n+    }\n+};\n+\n+static GTY((cache)) hash_table<tm_wrapper_hasher> *tm_wrap_map;\n \n void\n record_tm_replacement (tree from, tree to)\n@@ -489,15 +510,14 @@ record_tm_replacement (tree from, tree to)\n   DECL_UNINLINABLE (from) = 1;\n \n   if (tm_wrap_map == NULL)\n-    tm_wrap_map = htab_create_ggc (32, tree_map_hash, tree_map_eq, 0);\n+    tm_wrap_map = hash_table<tm_wrapper_hasher>::create_ggc (32);\n \n   h = ggc_alloc<tree_map> ();\n   h->hash = htab_hash_pointer (from);\n   h->base.from = from;\n   h->to = to;\n \n-  slot = (struct tree_map **)\n-    htab_find_slot_with_hash (tm_wrap_map, h, h->hash, INSERT);\n+  slot = tm_wrap_map->find_slot_with_hash (h, h->hash, INSERT);\n   *slot = h;\n }\n \n@@ -512,7 +532,7 @@ find_tm_replacement_function (tree fndecl)\n \n       in.base.from = fndecl;\n       in.hash = htab_hash_pointer (fndecl);\n-      h = (struct tree_map *) htab_find_with_hash (tm_wrap_map, &in, in.hash);\n+      h = tm_wrap_map->find_with_hash (&in, in.hash);\n       if (h)\n \treturn h->to;\n     }"}, {"sha": "76d62a37d9cae078cfb11a8c1fd2cc12859d8693", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -1778,26 +1778,26 @@ struct GTY(()) tree_map_base {\n \n /* Map from a tree to another tree.  */\n \n-struct GTY(()) tree_map {\n+struct GTY((for_user)) tree_map {\n   struct tree_map_base base;\n   unsigned int hash;\n   tree to;\n };\n \n /* Map from a decl tree to another tree.  */\n-struct GTY(()) tree_decl_map {\n+struct GTY((for_user)) tree_decl_map {\n   struct tree_map_base base;\n   tree to;\n };\n \n /* Map from a tree to an int.  */\n-struct GTY(()) tree_int_map {\n+struct GTY((for_user)) tree_int_map {\n   struct tree_map_base base;\n   unsigned int to;\n };\n \n /* Map from a decl tree to a tree vector.  */\n-struct GTY(()) tree_vec_map {\n+struct GTY((for_user)) tree_vec_map {\n   struct tree_map_base base;\n   vec<tree, va_gc> *to;\n };"}, {"sha": "1d5e4f6cd1eca5189ded8f9a40d1d6e15d74d8b4", "filename": "gcc/tree.c", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -185,23 +185,40 @@ static GTY(()) int next_debug_decl_uid;\n /* Since we cannot rehash a type after it is in the table, we have to\n    keep the hash code.  */\n \n-struct GTY(()) type_hash {\n+struct GTY((for_user)) type_hash {\n   unsigned long hash;\n   tree type;\n };\n \n /* Initial size of the hash table (rounded to next prime).  */\n #define TYPE_HASH_INITIAL_SIZE 1000\n \n+struct type_cache_hasher : ggc_cache_hasher<type_hash *>\n+{\n+  static hashval_t hash (type_hash *t) { return t->hash; }\n+  static bool equal (type_hash *a, type_hash *b);\n+\n+  static void\n+  handle_cache_entry (type_hash *&t)\n+  {\n+    extern void gt_ggc_mx (type_hash *&);\n+    if (t == HTAB_DELETED_ENTRY || t == HTAB_EMPTY_ENTRY)\n+      return;\n+    else if (ggc_marked_p (t->type))\n+      gt_ggc_mx (t);\n+    else\n+      t = static_cast<type_hash *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n+\n /* Now here is the hash table.  When recording a type, it is added to\n    the slot whose index is the hash code.  Note that the hash table is\n    used for several kinds of types (function types, array types and\n    array index range types, for now).  While all these live in the\n    same table, they are completely independent, and the hash code is\n    computed differently for each of these.  */\n \n-static GTY ((if_marked (\"type_hash_marked_p\"), param_is (struct type_hash)))\n-     htab_t type_hash_table;\n+static GTY ((cache)) hash_table<type_cache_hasher> *type_hash_table;\n \n /* Hash table and temporary node for larger integer const values.  */\n static GTY (()) tree int_cst_node;\n@@ -233,22 +250,42 @@ static GTY ((cache)) hash_table<cl_option_hasher> *cl_option_hash_table;\n /* General tree->tree mapping  structure for use in hash tables.  */\n \n \n-static GTY ((if_marked (\"tree_decl_map_marked_p\"), param_is (struct tree_decl_map)))\n-     htab_t debug_expr_for_decl;\n+static GTY ((cache))\n+     hash_table<tree_decl_map_cache_hasher> *debug_expr_for_decl;\n \n-static GTY ((if_marked (\"tree_decl_map_marked_p\"), param_is (struct tree_decl_map)))\n-     htab_t value_expr_for_decl;\n+static GTY ((cache))\n+     hash_table<tree_decl_map_cache_hasher> *value_expr_for_decl;\n+\n+     struct tree_vec_map_cache_hasher : ggc_cache_hasher<tree_vec_map *>\n+{\n+  static hashval_t hash (tree_vec_map *m) { return DECL_UID (m->base.from); }\n+\n+  static bool\n+  equal (tree_vec_map *a, tree_vec_map *b)\n+  {\n+    return a->base.from == b->base.from;\n+  }\n+\n+  static void\n+  handle_cache_entry (tree_vec_map *&m)\n+  {\n+    extern void gt_ggc_mx (tree_vec_map *&);\n+    if (m == HTAB_EMPTY_ENTRY || m == HTAB_DELETED_ENTRY)\n+      return;\n+    else if (ggc_marked_p (m->base.from))\n+      gt_ggc_mx (m);\n+    else\n+      m = static_cast<tree_vec_map *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n \n-static GTY ((if_marked (\"tree_vec_map_marked_p\"), param_is (struct tree_vec_map)))\n-     htab_t debug_args_for_decl;\n+static GTY ((cache))\n+     hash_table<tree_vec_map_cache_hasher> *debug_args_for_decl;\n \n static void set_type_quals (tree, int);\n-static int type_hash_eq (const void *, const void *);\n-static hashval_t type_hash_hash (const void *);\n static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n-static int type_hash_marked_p (const void *);\n static void type_hash_list (const_tree, inchash::hash &);\n static void attribute_hash_list (const_tree, inchash::hash &);\n \n@@ -584,14 +621,14 @@ void\n init_ttree (void)\n {\n   /* Initialize the hash table of types.  */\n-  type_hash_table = htab_create_ggc (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n-\t\t\t\t     type_hash_eq, 0);\n+  type_hash_table\n+    = hash_table<type_cache_hasher>::create_ggc (TYPE_HASH_INITIAL_SIZE);\n \n-  debug_expr_for_decl = htab_create_ggc (512, tree_decl_map_hash,\n-\t\t\t\t\t tree_decl_map_eq, 0);\n+  debug_expr_for_decl\n+    = hash_table<tree_decl_map_cache_hasher>::create_ggc (512);\n \n-  value_expr_for_decl = htab_create_ggc (512, tree_decl_map_hash,\n-\t\t\t\t\t tree_decl_map_eq, 0);\n+  value_expr_for_decl\n+    = hash_table<tree_decl_map_cache_hasher>::create_ggc (512);\n \n   int_cst_hash_table = hash_table<int_cst_hasher>::create_ggc (1024);\n \n@@ -6573,9 +6610,9 @@ static void\n print_debug_expr_statistics (void)\n {\n   fprintf (stderr, \"DECL_DEBUG_EXPR  hash: size %ld, %ld elements, %f collisions\\n\",\n-\t   (long) htab_size (debug_expr_for_decl),\n-\t   (long) htab_elements (debug_expr_for_decl),\n-\t   htab_collisions (debug_expr_for_decl));\n+\t   (long) debug_expr_for_decl->size (),\n+\t   (long) debug_expr_for_decl->elements (),\n+\t   debug_expr_for_decl->collisions ());\n }\n \n /* Print out the statistics for the DECL_VALUE_EXPR hash table.  */\n@@ -6584,9 +6621,9 @@ static void\n print_value_expr_statistics (void)\n {\n   fprintf (stderr, \"DECL_VALUE_EXPR  hash: size %ld, %ld elements, %f collisions\\n\",\n-\t   (long) htab_size (value_expr_for_decl),\n-\t   (long) htab_elements (value_expr_for_decl),\n-\t   htab_collisions (value_expr_for_decl));\n+\t   (long) value_expr_for_decl->size (),\n+\t   (long) value_expr_for_decl->elements (),\n+\t   value_expr_for_decl->collisions ());\n }\n \n /* Lookup a debug expression for FROM, and return it if we find one.  */\n@@ -6597,8 +6634,7 @@ decl_debug_expr_lookup (tree from)\n   struct tree_decl_map *h, in;\n   in.base.from = from;\n \n-  h = (struct tree_decl_map *)\n-      htab_find_with_hash (debug_expr_for_decl, &in, DECL_UID (from));\n+  h = debug_expr_for_decl->find_with_hash (&in, DECL_UID (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;\n@@ -6610,14 +6646,11 @@ void\n decl_debug_expr_insert (tree from, tree to)\n {\n   struct tree_decl_map *h;\n-  void **loc;\n \n   h = ggc_alloc<tree_decl_map> ();\n   h->base.from = from;\n   h->to = to;\n-  loc = htab_find_slot_with_hash (debug_expr_for_decl, h, DECL_UID (from),\n-\t\t\t\t  INSERT);\n-  *(struct tree_decl_map **) loc = h;\n+  *debug_expr_for_decl->find_slot_with_hash (h, DECL_UID (from), INSERT) = h;\n }\n \n /* Lookup a value expression for FROM, and return it if we find one.  */\n@@ -6628,8 +6661,7 @@ decl_value_expr_lookup (tree from)\n   struct tree_decl_map *h, in;\n   in.base.from = from;\n \n-  h = (struct tree_decl_map *)\n-      htab_find_with_hash (value_expr_for_decl, &in, DECL_UID (from));\n+  h = value_expr_for_decl->find_with_hash (&in, DECL_UID (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;\n@@ -6641,14 +6673,11 @@ void\n decl_value_expr_insert (tree from, tree to)\n {\n   struct tree_decl_map *h;\n-  void **loc;\n \n   h = ggc_alloc<tree_decl_map> ();\n   h->base.from = from;\n   h->to = to;\n-  loc = htab_find_slot_with_hash (value_expr_for_decl, h, DECL_UID (from),\n-\t\t\t\t  INSERT);\n-  *(struct tree_decl_map **) loc = h;\n+  *value_expr_for_decl->find_slot_with_hash (h, DECL_UID (from), INSERT) = h;\n }\n \n /* Lookup a vector of debug arguments for FROM, and return it if we\n@@ -6663,8 +6692,7 @@ decl_debug_args_lookup (tree from)\n     return NULL;\n   gcc_checking_assert (debug_args_for_decl != NULL);\n   in.base.from = from;\n-  h = (struct tree_vec_map *)\n-      htab_find_with_hash (debug_args_for_decl, &in, DECL_UID (from));\n+  h = debug_args_for_decl->find_with_hash (&in, DECL_UID (from));\n   if (h)\n     return &h->to;\n   return NULL;\n@@ -6677,19 +6705,17 @@ vec<tree, va_gc> **\n decl_debug_args_insert (tree from)\n {\n   struct tree_vec_map *h;\n-  void **loc;\n+  tree_vec_map **loc;\n \n   if (DECL_HAS_DEBUG_ARGS_P (from))\n     return decl_debug_args_lookup (from);\n   if (debug_args_for_decl == NULL)\n-    debug_args_for_decl = htab_create_ggc (64, tree_vec_map_hash,\n-\t\t\t\t\t   tree_vec_map_eq, 0);\n+    debug_args_for_decl = hash_table<tree_vec_map_cache_hasher>::create_ggc (64);\n   h = ggc_alloc<tree_vec_map> ();\n   h->base.from = from;\n   h->to = NULL;\n-  loc = htab_find_slot_with_hash (debug_args_for_decl, h, DECL_UID (from),\n-\t\t\t\t  INSERT);\n-  *(struct tree_vec_map **) loc = h;\n+  loc = debug_args_for_decl->find_slot_with_hash (h, DECL_UID (from), INSERT);\n+  *loc = h;\n   DECL_HAS_DEBUG_ARGS_P (from) = 1;\n   return &h->to;\n }\n@@ -6715,12 +6741,9 @@ type_hash_list (const_tree list, inchash::hash &hstate)\n \n /* Returns true iff the types are equivalent.  */\n \n-static int\n-type_hash_eq (const void *va, const void *vb)\n+bool\n+type_cache_hasher::equal (type_hash *a, type_hash *b)\n {\n-  const struct type_hash *const a = (const struct type_hash *) va,\n-    *const b = (const struct type_hash *) vb;\n-\n   /* First test the things that are the same for all types.  */\n   if (a->hash != b->hash\n       || TREE_CODE (a->type) != TREE_CODE (b->type)\n@@ -6827,14 +6850,6 @@ type_hash_eq (const void *va, const void *vb)\n   return 1;\n }\n \n-/* Return the cached hash value.  */\n-\n-static hashval_t\n-type_hash_hash (const void *item)\n-{\n-  return ((const struct type_hash *) item)->hash;\n-}\n-\n /* Given TYPE, and HASHCODE its hash code, return the canonical\n    object for an identical type if one already exists.\n    Otherwise, return TYPE, and record it as the canonical object.\n@@ -6848,7 +6863,7 @@ tree\n type_hash_canon (unsigned int hashcode, tree type)\n {\n   type_hash in;\n-  void **loc;\n+  type_hash **loc;\n \n   /* The hash table only contains main variants, so ensure that's what we're\n      being passed.  */\n@@ -6861,7 +6876,7 @@ type_hash_canon (unsigned int hashcode, tree type)\n   in.hash = hashcode;\n   in.type = type;\n \n-  loc = htab_find_slot_with_hash (type_hash_table, &in, hashcode, INSERT);\n+  loc = type_hash_table->find_slot_with_hash (&in, hashcode, INSERT);\n   if (*loc)\n     {\n       tree t1 = ((type_hash *) *loc)->type;\n@@ -6881,31 +6896,19 @@ type_hash_canon (unsigned int hashcode, tree type)\n       h = ggc_alloc<type_hash> ();\n       h->hash = hashcode;\n       h->type = type;\n-      *loc = (void *)h;\n+      *loc = h;\n \n       return type;\n     }\n }\n \n-/* See if the data pointed to by the type hash table is marked.  We consider\n-   it marked if the type is marked or if a debug type number or symbol\n-   table entry has been made for the type.  */\n-\n-static int\n-type_hash_marked_p (const void *p)\n-{\n-  const_tree const type = ((const struct type_hash *) p)->type;\n-\n-  return ggc_marked_p (type);\n-}\n-\n static void\n print_type_hash_statistics (void)\n {\n   fprintf (stderr, \"Type hash: size %ld, %ld elements, %f collisions\\n\",\n-\t   (long) htab_size (type_hash_table),\n-\t   (long) htab_elements (type_hash_table),\n-\t   htab_collisions (type_hash_table));\n+\t   (long) type_hash_table->size (),\n+\t   (long) type_hash_table->elements (),\n+\t   type_hash_table->collisions ());\n }\n \n /* Compute a hash code for a list of attributes (chain of TREE_LIST nodes"}, {"sha": "7126dac835f84814120a0c2a1695076b4bd1c7b5", "filename": "gcc/tree.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -4402,6 +4402,28 @@ extern unsigned int tree_map_hash (const void *);\n extern unsigned int tree_decl_map_hash (const void *);\n #define tree_decl_map_marked_p tree_map_base_marked_p\n \n+struct tree_decl_map_cache_hasher : ggc_cache_hasher<tree_decl_map *>\n+{\n+  static hashval_t hash (tree_decl_map *m) { return tree_decl_map_hash (m); }\n+  static bool\n+  equal (tree_decl_map *a, tree_decl_map *b)\n+  {\n+    return tree_decl_map_eq (a, b);\n+  }\n+\n+  static void\n+  handle_cache_entry (tree_decl_map *&m)\n+  {\n+    extern void gt_ggc_mx (tree_decl_map *&);\n+    if (m == HTAB_EMPTY_ENTRY || m == HTAB_DELETED_ENTRY)\n+      return;\n+    else if (ggc_marked_p (m->base.from))\n+      gt_ggc_mx (m);\n+    else\n+      m = static_cast<tree_decl_map *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n+\n #define tree_int_map_eq tree_map_base_eq\n #define tree_int_map_hash tree_map_base_hash\n #define tree_int_map_marked_p tree_map_base_marked_p"}, {"sha": "b3d5343605e0276c4adef61f42c59a79e69c355c", "filename": "gcc/ubsan.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -71,24 +71,40 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Map from a tree to a VAR_DECL tree.  */\n \n-struct GTY(()) tree_type_map {\n+struct GTY((for_user)) tree_type_map {\n   struct tree_map_base type;\n   tree decl;\n };\n \n-#define tree_type_map_eq tree_map_base_eq\n-#define tree_type_map_marked_p tree_map_base_marked_p\n-\n-/* Hash from a tree in a tree_type_map.  */\n-\n-unsigned int\n-tree_type_map_hash (const void *item)\n+struct tree_type_map_cache_hasher : ggc_cache_hasher<tree_type_map *>\n {\n-  return TYPE_UID (((const struct tree_type_map *)item)->type.from);\n-}\n+  static inline hashval_t\n+  hash (tree_type_map *t)\n+  {\n+    return TYPE_UID (t->type.from);\n+  }\n+\n+  static inline bool\n+  equal (tree_type_map *a, tree_type_map *b)\n+  {\n+    return a->type.from == b->type.from;\n+  }\n+\n+  static void\n+  handle_cache_entry (tree_type_map *&m)\n+  {\n+    extern void gt_ggc_mx (tree_type_map *&);\n+    if (m == HTAB_EMPTY_ENTRY || m == HTAB_DELETED_ENTRY)\n+      return;\n+    else if (ggc_marked_p (m->type.from))\n+      gt_ggc_mx (m);\n+    else\n+      m = static_cast<tree_type_map *> (HTAB_DELETED_ENTRY);\n+  }\n+};\n \n-static GTY ((if_marked (\"tree_type_map_marked_p\"), param_is (struct tree_type_map)))\n-     htab_t decl_tree_for_type;\n+static GTY ((cache))\n+     hash_table<tree_type_map_cache_hasher> *decl_tree_for_type;\n \n /* Lookup a VAR_DECL for TYPE, and return it if we find one.  */\n \n@@ -98,17 +114,16 @@ decl_for_type_lookup (tree type)\n   /* If the hash table is not initialized yet, create it now.  */\n   if (decl_tree_for_type == NULL)\n     {\n-      decl_tree_for_type = htab_create_ggc (10, tree_type_map_hash,\n-\t\t\t\t\t    tree_type_map_eq, 0);\n+      decl_tree_for_type\n+\t= hash_table<tree_type_map_cache_hasher>::create_ggc (10);\n       /* That also means we don't have to bother with the lookup.  */\n       return NULL_TREE;\n     }\n \n   struct tree_type_map *h, in;\n   in.type.from = type;\n \n-  h = (struct tree_type_map *)\n-      htab_find_with_hash (decl_tree_for_type, &in, TYPE_UID (type));\n+  h = decl_tree_for_type->find_with_hash (&in, TYPE_UID (type));\n   return h ? h->decl : NULL_TREE;\n }\n \n@@ -118,14 +133,11 @@ static void\n decl_for_type_insert (tree type, tree decl)\n {\n   struct tree_type_map *h;\n-  void **slot;\n \n   h = ggc_alloc<tree_type_map> ();\n   h->type.from = type;\n   h->decl = decl;\n-  slot = htab_find_slot_with_hash (decl_tree_for_type, h, TYPE_UID (type),\n-                                  INSERT);\n-  *(struct tree_type_map **) slot = h;\n+  *decl_tree_for_type->find_slot_with_hash (h, TYPE_UID (type), INSERT) = h;\n }\n \n /* Helper routine, which encodes a value in the pointer_sized_int_node."}, {"sha": "07eb72aee31f268d8a5d69bc605e108e779575e5", "filename": "gcc/varasm.c", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242408fda0bb64230b5446911d860df3e19a3da/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d242408fda0bb64230b5446911d860df3e19a3da", "patch": "@@ -5727,24 +5727,41 @@ assemble_alias (tree decl, tree target)\n    to its transaction aware clone.  Note that tm_pure functions are\n    considered to be their own clone.  */\n \n-static GTY((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n-     htab_t tm_clone_hash;\n+struct tm_clone_hasher : ggc_cache_hasher<tree_map *>\n+{\n+  static hashval_t hash (tree_map *m) { return tree_map_hash (m); }\n+  static bool equal (tree_map *a, tree_map *b) { return tree_map_eq (a, b); }\n+\n+  static void handle_cache_entry (tree_map *&e)\n+  {\n+    if (e != HTAB_EMPTY_ENTRY || e != HTAB_DELETED_ENTRY)\n+      {\n+\textern void gt_ggc_mx (tree_map *&);\n+\tif (ggc_marked_p (e->base.from))\n+\t  gt_ggc_mx (e);\n+\telse\n+\t  e = static_cast<tree_map *> (HTAB_DELETED_ENTRY);\n+      }\n+  }\n+};\n+\n+static GTY((cache))\n+     hash_table<tm_clone_hasher> *tm_clone_hash;\n \n void\n record_tm_clone_pair (tree o, tree n)\n {\n   struct tree_map **slot, *h;\n \n   if (tm_clone_hash == NULL)\n-    tm_clone_hash = htab_create_ggc (32, tree_map_hash, tree_map_eq, 0);\n+    tm_clone_hash = hash_table<tm_clone_hasher>::create_ggc (32);\n \n   h = ggc_alloc<tree_map> ();\n   h->hash = htab_hash_pointer (o);\n   h->base.from = o;\n   h->to = n;\n \n-  slot = (struct tree_map **)\n-    htab_find_slot_with_hash (tm_clone_hash, h, h->hash, INSERT);\n+  slot = tm_clone_hash->find_slot_with_hash (h, h->hash, INSERT);\n   *slot = h;\n }\n \n@@ -5757,8 +5774,7 @@ get_tm_clone_pair (tree o)\n \n       in.base.from = o;\n       in.hash = htab_hash_pointer (o);\n-      h = (struct tree_map *) htab_find_with_hash (tm_clone_hash,\n-\t\t\t\t\t\t   &in, in.hash);\n+      h = tm_clone_hash->find_with_hash (&in, in.hash);\n       if (h)\n \treturn h->to;\n     }\n@@ -5773,19 +5789,6 @@ typedef struct tm_alias_pair\n } tm_alias_pair;\n \n \n-/* Helper function for finish_tm_clone_pairs.  Dump a hash table entry\n-   into a VEC in INFO.  */\n-\n-static int\n-dump_tm_clone_to_vec (void **slot, void *info)\n-{\n-  struct tree_map *map = (struct tree_map *) *slot;\n-  vec<tm_alias_pair> *tm_alias_pairs = (vec<tm_alias_pair> *) info;\n-  tm_alias_pair p = {DECL_UID (map->base.from), map->base.from, map->to};\n-  tm_alias_pairs->safe_push (p);\n-  return 1;\n-}\n-\n /* Dump the actual pairs to the .tm_clone_table section.  */\n \n static void\n@@ -5866,15 +5869,20 @@ finish_tm_clone_pairs (void)\n      to a vector, sort it, and dump the vector.  */\n \n   /* Dump the hashtable to a vector.  */\n-  htab_traverse_noresize (tm_clone_hash, dump_tm_clone_to_vec,\n-\t\t\t  (void *) &tm_alias_pairs);\n+  tree_map *map;\n+  hash_table<tm_clone_hasher>::iterator iter;\n+  FOR_EACH_HASH_TABLE_ELEMENT (*tm_clone_hash, map, tree_map *, iter)\n+    {\n+      tm_alias_pair p = {DECL_UID (map->base.from), map->base.from, map->to};\n+      tm_alias_pairs.safe_push (p);\n+    }\n   /* Sort it.  */\n   tm_alias_pairs.qsort (tm_alias_pair_cmp);\n \n   /* Dump it.  */\n   dump_tm_clone_pairs (tm_alias_pairs);\n \n-  htab_delete (tm_clone_hash);\n+  tm_clone_hash->empty ();\n   tm_clone_hash = NULL;\n   tm_alias_pairs.release ();\n }"}]}