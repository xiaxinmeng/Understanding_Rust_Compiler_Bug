{"sha": "b56b9fe39dc195086c6767812dead9ab424c5247", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU2YjlmZTM5ZGMxOTUwODZjNjc2NzgxMmRlYWQ5YWI0MjRjNTI0Nw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-02-19T02:45:34Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-02-19T02:45:34Z"}, "message": "function.c (gimplify_parameters): Call build_gimple_modify_stmt instead of calling build2 with a GIMPLE_MODIFY_STMT.\n\n\n\t* function.c (gimplify_parameters): Call build_gimple_modify_stmt\n\tinstead of calling build2 with a GIMPLE_MODIFY_STMT.\n\t* gimple-low.c (lower_function_body, lower_builtin_setjmp):\n\tLikewise.\n\t* gimplify.c (build_stack_save_restore, gimplify_return_expr,\n\tgimplify_decl_expr,  gimplify_self_mod_expr, gimplify_cond_expr,\n\tgimplify_init_ctor_eval_range, gimple_push_cleanup,\n\tgimplify_omp_for, gimplify_omp_atomic_pipeline, \n\tgimplify_omp_atomic_mutex, gimplify_expr, gimplify_one_sizepos,\n\tforce_gimple_operand): Likewise.\n\t* ipa-cp.c (constant_val_insert): Likewise.\n\t* lambda-code.c (lbv_to_gcc_expression, lle_to_gcc_expression,\n\tlambda_loopnest_to_gcc_loopnest, replace_uses_equiv_to_x_with_y,\n\tperfect_nestify): Likewise.\n\t* langhooks.c (lhd_omp_assignment): Likewise.\n\t* omp-low.c (lower_rec_input_clauses, lower_reduction_clauses,\n\tlower_copyprivate_clauses, lower_send_clauses,\n\tlower_send_shared_vars, expand_parallel_call,\n\texpand_omp_for_generic, expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk, expand_omp_sections,\n\tlower_omp_single_copy, lower_omp_for_lastprivate,\n\tlower_omp_parallel, init_tmp_var, save_tmp_var): Likewise.\n\t* value-prof.c (tree_divmod_fixed_value, tree_mod_pow2,\n\ttree_mod_subtract, tree_ic, tree_stringop_fixed_value):\n\tLikewise.\n\nFrom-SVN: r122120", "tree": {"sha": "b1a71a012250204314eb9f32b1e3ee95d8c2e5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1a71a012250204314eb9f32b1e3ee95d8c2e5bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b56b9fe39dc195086c6767812dead9ab424c5247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b56b9fe39dc195086c6767812dead9ab424c5247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b56b9fe39dc195086c6767812dead9ab424c5247", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b56b9fe39dc195086c6767812dead9ab424c5247/comments", "author": null, "committer": null, "parents": [{"sha": "da08281c06d60796e3ff5962eb4e655be1cc00ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da08281c06d60796e3ff5962eb4e655be1cc00ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da08281c06d60796e3ff5962eb4e655be1cc00ed"}], "stats": {"total": 310, "additions": 169, "deletions": 141}, "files": [{"sha": "677a96f6dcd2a3523b5798d8c6306f95de227e44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1,3 +1,31 @@\n+2007-02-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* function.c (gimplify_parameters): Call build_gimple_modify_stmt\n+\tinstead of calling build2 with a GIMPLE_MODIFY_STMT.\n+\t* gimple-low.c (lower_function_body, lower_builtin_setjmp):\n+\tLikewise.\n+\t* gimplify.c (build_stack_save_restore, gimplify_return_expr,\n+\tgimplify_decl_expr,  gimplify_self_mod_expr, gimplify_cond_expr,\n+\tgimplify_init_ctor_eval_range, gimple_push_cleanup,\n+\tgimplify_omp_for, gimplify_omp_atomic_pipeline, \n+\tgimplify_omp_atomic_mutex, gimplify_expr, gimplify_one_sizepos,\n+\tforce_gimple_operand): Likewise.\n+\t* ipa-cp.c (constant_val_insert): Likewise.\n+\t* lambda-code.c (lbv_to_gcc_expression, lle_to_gcc_expression,\n+\tlambda_loopnest_to_gcc_loopnest, replace_uses_equiv_to_x_with_y,\n+\tperfect_nestify): Likewise.\n+\t* langhooks.c (lhd_omp_assignment): Likewise.\n+\t* omp-low.c (lower_rec_input_clauses, lower_reduction_clauses,\n+\tlower_copyprivate_clauses, lower_send_clauses,\n+\tlower_send_shared_vars, expand_parallel_call,\n+\texpand_omp_for_generic, expand_omp_for_static_nochunk,\n+\texpand_omp_for_static_chunk, expand_omp_sections,\n+\tlower_omp_single_copy, lower_omp_for_lastprivate,\n+\tlower_omp_parallel, init_tmp_var, save_tmp_var): Likewise.\n+\t* value-prof.c (tree_divmod_fixed_value, tree_mod_pow2,\n+\ttree_mod_subtract, tree_ic, tree_stringop_fixed_value):\n+\tLikewise.\n+\n 2007-02-19  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/sh/divtab.c, config/sh/sh.c, config/sh/sh.h,"}, {"sha": "3c6222700c93c551d583e8e7cfdcd3106d71ee03", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -3213,11 +3213,11 @@ gimplify_parameters (void)\n \t\t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (parm));\n \t\t  t = fold_convert (ptr_type, t);\n-\t\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n+\t\t  t = build_gimple_modify_stmt (addr, t);\n \t\t  gimplify_and_add (t, &stmts);\n \t\t}\n \n-\t      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, local, parm);\n+\t      t = build_gimple_modify_stmt (local, parm);\n \t      gimplify_and_add (t, &stmts);\n \n \t      SET_DECL_VALUE_EXPR (parm, local);"}, {"sha": "642cd4fdd5c0e92eaf91a100cc376687250e039a", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1,6 +1,6 @@\n /* Tree lowering pass.  Lowers GIMPLE into unstructured form.\n \n-   Copyright (C) 2003, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -137,7 +137,7 @@ lower_function_body (void)\n       arg = build_addr (disp_label, current_function_decl);\n       t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];\n       t = build_call_expr (t, 1, arg);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, disp_var, t);\n+      x = build_gimple_modify_stmt (disp_var, t);\n \n       /* Build 'goto DISP_VAR;' and insert.  */\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n@@ -671,7 +671,8 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n   /* Build 'DEST = 0' and insert.  */\n   if (dest)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dest, integer_zero_node);\n+      t = build_gimple_modify_stmt (dest, fold_convert (TREE_TYPE (dest),\n+\t\t\t\t\t\t\tinteger_zero_node));\n       SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n       tsi_link_before (tsi, t, TSI_SAME_STMT);\n     }\n@@ -694,7 +695,8 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n   /* Build 'DEST = 1' and insert.  */\n   if (dest)\n     {\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, dest, integer_one_node);\n+      t = build_gimple_modify_stmt (dest, fold_convert (TREE_TYPE (dest),\n+\t\t\t\t\t\t\tinteger_one_node));\n       SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n       tsi_link_before (tsi, t, TSI_SAME_STMT);\n     }"}, {"sha": "34e6249d2a26ef89eae6fc0ad60f149d25bed4a3", "filename": "gcc/gimplify.c", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1043,7 +1043,7 @@ build_stack_save_restore (tree *save, tree *restore)\n     build_call_expr (implicit_built_in_decls[BUILT_IN_STACK_SAVE], 0);\n   tmp_var = create_tmp_var (ptr_type_node, \"saved_stack\");\n \n-  *save = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, tmp_var, save_call);\n+  *save = build_gimple_modify_stmt (tmp_var, save_call);\n   *restore =\n     build_call_expr (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n \t\t     1, tmp_var);\n@@ -1197,8 +1197,7 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n   if (result == result_decl)\n     ret_expr = result;\n   else\n-    ret_expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (result), result_decl,\n-\t\t       result);\n+    ret_expr = build_gimple_modify_stmt (result_decl, result);\n   TREE_OPERAND (stmt, 0) = ret_expr;\n \n   return GS_ALL_DONE;\n@@ -1252,7 +1251,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (decl));\n \t  t = fold_convert (ptr_type, t);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n+\t  t = build_gimple_modify_stmt (addr, t);\n \n \t  gimplify_and_add (t, stmt_p);\n \n@@ -1951,7 +1950,7 @@ gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n     }\n \n   t1 = build2 (arith_code, TREE_TYPE (*expr_p), lhs, rhs);\n-  t1 = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (lvalue), lvalue, t1);\n+  t1 = build_gimple_modify_stmt (lvalue, t1);\n \n   if (postfix)\n     {\n@@ -2467,14 +2466,12 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, fallback_t fallback)\n \t if this branch is void; in C++ it can be, if it's a throw.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n \tTREE_OPERAND (expr, 1)\n-\t  = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp,\n-\t      \t    TREE_OPERAND (expr, 1));\n+\t  = build_gimple_modify_stmt (tmp, TREE_OPERAND (expr, 1));\n \n       /* Build the else clause, 't1 = b;'.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n \tTREE_OPERAND (expr, 2)\n-\t  = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp2,\n-\t      \t    TREE_OPERAND (expr, 2));\n+\t  = build_gimple_modify_stmt (tmp2, TREE_OPERAND (expr, 2));\n \n       TREE_TYPE (expr) = void_type_node;\n       recalculate_side_effects (expr);\n@@ -2732,16 +2729,15 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n \t\t\t       tree *pre_p, bool cleared)\n {\n   tree loop_entry_label, loop_exit_label;\n-  tree var, var_type, cref;\n+  tree var, var_type, cref, tmp;\n \n   loop_entry_label = create_artificial_label ();\n   loop_exit_label = create_artificial_label ();\n \n   /* Create and initialize the index variable.  */\n   var_type = TREE_TYPE (upper);\n   var = create_tmp_var (var_type, NULL);\n-  append_to_statement_list (build2 (GIMPLE_MODIFY_STMT, var_type, var, lower),\n-\t\t\t    pre_p);\n+  append_to_statement_list (build_gimple_modify_stmt (var, lower), pre_p);\n \n   /* Add the loop entry label.  */\n   append_to_statement_list (build1 (LABEL_EXPR,\n@@ -2762,9 +2758,7 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n     gimplify_init_ctor_eval (cref, CONSTRUCTOR_ELTS (value),\n \t\t\t     pre_p, cleared);\n   else\n-    append_to_statement_list (build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (cref),\n-\t\t\t\t      cref, value),\n-\t\t\t      pre_p);\n+    append_to_statement_list (build_gimple_modify_stmt (cref, value), pre_p);\n \n   /* We exit the loop when the index var is equal to the upper bound.  */\n   gimplify_and_add (build3 (COND_EXPR, void_type_node,\n@@ -2777,11 +2771,9 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n \t\t    pre_p);\n \n   /* Otherwise, increment the index var...  */\n-  append_to_statement_list (build2 (GIMPLE_MODIFY_STMT, var_type, var,\n-\t\t\t\t    build2 (PLUS_EXPR, var_type, var,\n-\t\t\t\t\t    fold_convert (var_type,\n-\t\t\t\t\t\t\t  integer_one_node))),\n-\t\t\t    pre_p);\n+  tmp = build2 (PLUS_EXPR, var_type, var,\n+\t\tfold_convert (var_type, integer_one_node));\n+  append_to_statement_list (build_gimple_modify_stmt (var, tmp), pre_p);\n \n   /* ...and jump back to the loop entry.  */\n   append_to_statement_list (build1 (GOTO_EXPR,\n@@ -4240,10 +4232,8 @@ gimple_push_cleanup (tree var, tree cleanup, bool eh_only, tree *pre_p)\n       */\n \n       tree flag = create_tmp_var (boolean_type_node, \"cleanup\");\n-      tree ffalse = build2 (GIMPLE_MODIFY_STMT, void_type_node, flag,\n-\t\t\t    boolean_false_node);\n-      tree ftrue = build2 (GIMPLE_MODIFY_STMT, void_type_node, flag,\n-\t\t\t   boolean_true_node);\n+      tree ffalse = build_gimple_modify_stmt (flag, boolean_false_node);\n+      tree ftrue = build_gimple_modify_stmt (flag, boolean_true_node);\n       cleanup = build3 (COND_EXPR, void_type_node, flag, cleanup, NULL);\n       wce = build1 (WITH_CLEANUP_EXPR, void_type_node, cleanup);\n       append_to_statement_list (ffalse, &gimplify_ctxp->conditional_cleanups);\n@@ -5008,14 +4998,16 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n       t = build_int_cst (TREE_TYPE (decl), 1);\n-      goto build_modify;\n+      t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n+      t = build_gimple_modify_stmt (decl, t);\n+      OMP_FOR_INCR (for_stmt) = t;\n+      break;\n+\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       t = build_int_cst (TREE_TYPE (decl), -1);\n-      goto build_modify;\n-    build_modify:\n       t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, decl, t);\n+      t = build_gimple_modify_stmt (decl, t);\n       OMP_FOR_INCR (for_stmt) = t;\n       break;\n       \n@@ -5229,7 +5221,7 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n     return GS_ERROR;\n \n   x = build_fold_indirect_ref (addr);\n-  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldval, x);\n+  x = build_gimple_modify_stmt (oldval, x);\n   gimplify_and_add (x, pre_p);\n \n   /* For floating-point values, we'll need to view-convert them to integers\n@@ -5247,7 +5239,7 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n       newival = create_tmp_var (itype, NULL);\n \n       x = build1 (VIEW_CONVERT_EXPR, itype, oldval);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival, x);\n+      x = build_gimple_modify_stmt (oldival, x);\n       gimplify_and_add (x, pre_p);\n       iaddr = fold_convert (build_pointer_type (itype), addr);\n     }\n@@ -5258,32 +5250,31 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n   x = build1 (LABEL_EXPR, void_type_node, label);\n   gimplify_and_add (x, pre_p);\n \n-  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, newval, rhs);\n+  x = build_gimple_modify_stmt (newval, rhs);\n   gimplify_and_add (x, pre_p);\n \n   if (newval != newival)\n     {\n       x = build1 (VIEW_CONVERT_EXPR, itype, newval);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, newival, x);\n+      x = build_gimple_modify_stmt (newival, x);\n       gimplify_and_add (x, pre_p);\n     }\n \n-  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival2,\n-\t      fold_convert (itype, oldival));\n+  x = build_gimple_modify_stmt (oldival2, fold_convert (itype, oldival));\n   gimplify_and_add (x, pre_p);\n \n   x = build_call_expr (cmpxchg, 3, iaddr, fold_convert (itype, oldival),\n \t\t       fold_convert (itype, newival));\n   if (oldval == oldival)\n     x = fold_convert (type, x);\n-  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival, x);\n+  x = build_gimple_modify_stmt (oldival, x);\n   gimplify_and_add (x, pre_p);\n \n   /* For floating point, be prepared for the loop backedge.  */\n   if (oldval != oldival)\n     {\n       x = build1 (VIEW_CONVERT_EXPR, type, oldival);\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldval, x);\n+      x = build_gimple_modify_stmt (oldval, x);\n       gimplify_and_add (x, pre_p);\n     }\n \n@@ -5321,7 +5312,7 @@ gimplify_omp_atomic_mutex (tree *expr_p, tree *pre_p, tree addr, tree rhs)\n   gimplify_and_add (t, pre_p);\n \n   t = build_fold_indirect_ref (addr);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, t, rhs);\n+  t = build_gimple_modify_stmt (t, rhs);\n   gimplify_and_add (t, pre_p);\n   \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n@@ -5989,7 +5980,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t     given a TREE_ADDRESSABLE type.  */\n \t  tree tmp = create_tmp_var_raw (type, \"vol\");\n \t  gimple_add_tmp_var (tmp);\n-\t  *expr_p = build2 (GIMPLE_MODIFY_STMT, type, tmp, *expr_p);\n+\t  *expr_p = build_gimple_modify_stmt (tmp, *expr_p);\n \t}\n       else\n \t/* We can't do anything useful with a volatile reference to\n@@ -6221,7 +6212,7 @@ gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n \n       *expr_p = create_tmp_var (type, NULL);\n       tmp = build1 (NOP_EXPR, type, expr);\n-      tmp = build2 (GIMPLE_MODIFY_STMT, type, *expr_p, tmp);\n+      tmp = build_gimple_modify_stmt (*expr_p, tmp);\n       if (EXPR_HAS_LOCATION (expr))\n \tSET_EXPR_LOCUS (tmp, EXPR_LOCUS (expr));\n       else\n@@ -6474,7 +6465,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   gimplify_ctxp->into_ssa = gimple_in_ssa_p (cfun);\n \n   if (var)\n-    expr = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, expr);\n+    expr = build_gimple_modify_stmt (var, expr);\n \n   ret = gimplify_expr (&expr, stmts, NULL,\n \t\t       gimple_test_f, fb_rvalue);"}, {"sha": "32f8b6d6dcd4d34064993366cbbabbc30c41a6b2", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1,5 +1,5 @@\n /* Interprocedural constant propagation\n-   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Razya Ladelsky <RAZYA@il.ibm.com>\n    \n This file is part of GCC.\n@@ -445,7 +445,7 @@ constant_val_insert (tree parm1, tree val)\n   tree init_stmt = NULL;\n   edge e_step;\n \n-  init_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, parm1, val);\n+  init_stmt = build_gimple_modify_stmt (parm1, val);\n \n   if (init_stmt)\n     {"}, {"sha": "3a7fa5fc01f180cde2b11b9ecda6e0597c6d209f", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1,5 +1,5 @@\n /*  Loop transformation code generation\n-    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+    Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n     Contributed by Daniel Berlin <dberlin@dberlin.org>\n \n     This file is part of GCC.\n@@ -1540,8 +1540,8 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   add_referenced_var (resvar);\n \n   /* Start at 0.  */\n-  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-      \t\t integer_zero_node);\n+  stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t   fold_convert (type, integer_zero_node));\n   name = make_ssa_name (resvar, stmt);\n   GIMPLE_STMT_OPERAND (stmt, 0) = name;\n   tsi = tsi_last (stmts);\n@@ -1556,8 +1556,9 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t  \n \t  /* newname = coefficient * induction_variable */\n \t  coeffmult = build_int_cst (type, LBV_COEFFICIENTS (lbv)[i]);\n-\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t\t fold_build2 (MULT_EXPR, type, iv, coeffmult));\n+\t  stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t\t   fold_build2 (MULT_EXPR, type,\n+\t\t\t\t\t\t\tiv, coeffmult));\n \n \t  newname = make_ssa_name (resvar, stmt);\n \t  GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n@@ -1566,8 +1567,9 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t  /* name = name + newname */\n-\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t\t build2 (PLUS_EXPR, type, name, newname));\n+\t  stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t\t   build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t   name, newname));\n \t  name = make_ssa_name (resvar, stmt);\n \t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n@@ -1581,8 +1583,9 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n   if (LBV_DENOMINATOR (lbv) != 1)\n     {\n       tree denominator = build_int_cst (type, LBV_DENOMINATOR (lbv));\n-      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t     build2 (CEIL_DIV_EXPR, type, name, denominator));\n+      stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t       build2 (CEIL_DIV_EXPR, type,\n+\t\t\t\t\t       name, denominator));\n       name = make_ssa_name (resvar, stmt);\n       GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       fold_stmt (&stmt);\n@@ -1632,8 +1635,8 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n   for (; lle != NULL; lle = LLE_NEXT (lle))\n     {\n       /* Start at name = 0.  */\n-      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t  \t     integer_zero_node);\n+      stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t       fold_convert (type, integer_zero_node));\n       name = make_ssa_name (resvar, stmt);\n       GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       fold_stmt (&stmt);\n@@ -1664,16 +1667,17 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \n \t      /* newname = mult */\n-\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar, mult);\n+\t      stmt = build_gimple_modify_stmt (resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n \t      GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n-\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t\t     build2 (PLUS_EXPR, type, name, newname));\n+\t      stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t\t       build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t       name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n \t      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t      fold_stmt (&stmt);\n@@ -1705,16 +1709,17 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t}\n \n \t      /* newname = mult */\n-\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar, mult);\n+\t      stmt = build_gimple_modify_stmt (resvar, mult);\n \t      newname = make_ssa_name (resvar, stmt);\n \t      GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n \t      fold_stmt (&stmt);\n \t      tsi = tsi_last (stmts);\n \t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \n \t      /* name = name + newname */\n-\t      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t\t     build2 (PLUS_EXPR, type, name, newname));\n+\t      stmt = build_gimple_modify_stmt (resvar,\n+\t\t\t\t\t       build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t       name, newname));\n \t      name = make_ssa_name (resvar, stmt);\n \t      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t      fold_stmt (&stmt);\n@@ -1727,9 +1732,9 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n          name = name + constant.  */\n       if (LLE_CONSTANT (lle) != 0)\n \t{\n-\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t\t build2 (PLUS_EXPR, type, name, \n-\t\t\t         build_int_cst (type, LLE_CONSTANT (lle))));\n+\t  tree incr = build_int_cst (type, LLE_CONSTANT (lle));\n+\t  stmt = build_gimple_modify_stmt (resvar, build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t\t   name, incr));\n \t  name = make_ssa_name (resvar, stmt);\n \t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n@@ -1741,9 +1746,9 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n          name = name + linear offset.  */\n       if (LLE_CONSTANT (offset) != 0)\n \t{\n-\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t\t build2 (PLUS_EXPR, type, name, \n-\t\t\t         build_int_cst (type, LLE_CONSTANT (offset))));\n+\t  tree incr = build_int_cst (type, LLE_CONSTANT (offset));\n+\t  stmt = build_gimple_modify_stmt (resvar, build2 (PLUS_EXPR, type,\n+\t\t\t\t\t\t\t   name, incr));\n \t  name = make_ssa_name (resvar, stmt);\n \t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n \t  fold_stmt (&stmt);\n@@ -1757,7 +1762,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t  stmt = build_int_cst (type, LLE_DENOMINATOR (lle));\n \t  stmt = build2 (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n \t\t\t type, name, stmt);\n-\t  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar, stmt);\n+\t  stmt = build_gimple_modify_stmt (resvar, stmt);\n \n \t  /* name = {ceil, floor}(name/denominator) */\n \t  name = make_ssa_name (resvar, stmt);\n@@ -1777,8 +1782,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n     {\n       tree op1 = VEC_index (tree, results, 0);\n       tree op2 = VEC_index (tree, results, 1);\n-      stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, resvar,\n-\t\t     build2 (wrap, type, op1, op2));\n+      stmt = build_gimple_modify_stmt (resvar, build2 (wrap, type, op1, op2));\n       name = make_ssa_name (resvar, stmt);\n       GIMPLE_STMT_OPERAND (stmt, 0) = name;\n       tsi = tsi_last (stmts);\n@@ -1895,8 +1899,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t test,  and let redundancy elimination sort it out.  */\n       inc_stmt = build2 (PLUS_EXPR, type, \n \t\t\t ivvar, build_int_cst (type, LL_STEP (newloop)));\n-      inc_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t  \t\t SSA_NAME_VAR (ivvar), inc_stmt);\n+      inc_stmt = build_gimple_modify_stmt (SSA_NAME_VAR (ivvar), inc_stmt);\n       ivvarinced = make_ssa_name (SSA_NAME_VAR (ivvar), inc_stmt);\n       GIMPLE_STMT_OPERAND (inc_stmt, 0) = ivvarinced;\n       bsi = bsi_for_stmt (exitcond);\n@@ -2187,7 +2190,7 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n       var = create_tmp_var (TREE_TYPE (use), \"perfecttmp\");\n       add_referenced_var (var);\n       val = force_gimple_operand_bsi (firstbsi, val, false, NULL);\n-      setstmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, val);\n+      setstmt = build_gimple_modify_stmt (var, val);\n       var = make_ssa_name (var, setstmt);\n       GIMPLE_STMT_OPERAND (setstmt, 0) = var;\n       bsi_insert_before (firstbsi, setstmt, BSI_SAME_STMT);\n@@ -2535,8 +2538,7 @@ perfect_nestify (struct loop *loop,\n   exit_condition = get_loop_exit_condition (newloop);\n   uboundvar = create_tmp_var (integer_type_node, \"uboundvar\");\n   add_referenced_var (uboundvar);\n-  stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, uboundvar, \n-\t\t VEC_index (tree, ubounds, 0));\n+  stmt = build_gimple_modify_stmt (uboundvar, VEC_index (tree, ubounds, 0));\n   uboundvar = make_ssa_name (uboundvar, stmt);\n   GIMPLE_STMT_OPERAND (stmt, 0) = uboundvar;\n "}, {"sha": "9a33bcafc9e370378d22f59dc930fe86842451bd", "filename": "gcc/langhooks.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1,5 +1,6 @@\n /* Default language-specific hooks.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva  <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -570,7 +571,7 @@ lhd_omp_predetermined_sharing (tree decl ATTRIBUTE_UNUSED)\n tree\n lhd_omp_assignment (tree clause ATTRIBUTE_UNUSED, tree dst, tree src)\n {\n-  return build2 (GIMPLE_MODIFY_STMT, void_type_node, dst, src);\n+  return build_gimple_modify_stmt (dst, src);\n }\n \n /* Register language specific type size variables as potentially OpenMP"}, {"sha": "1ced1eaa8755bb2db1bb0cea90e68793c1cd9840", "filename": "gcc/omp-low.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -3,7 +3,7 @@\n    marshalling to implement data sharing and copying clauses.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n-   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1675,7 +1675,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t      x = TYPE_SIZE_UNIT (TREE_TYPE (new_var));\n \t      x = build_call_expr (built_in_decls[BUILT_IN_ALLOCA], 1, x);\n \t      x = fold_convert (TREE_TYPE (ptr), x);\n-\t      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ptr, x);\n+\t      x = build_gimple_modify_stmt (ptr, x);\n \t      gimplify_and_add (x, ilist);\n \t    }\n \t  else if (is_reference (var))\n@@ -1709,7 +1709,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\t  x = fold_convert (TREE_TYPE (new_var), x);\n \t\t}\n \n-\t      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var, x);\n+\t      x = build_gimple_modify_stmt (new_var, x);\n \t      gimplify_and_add (x, ilist);\n \n \t      new_var = build_fold_indirect_ref (new_var);\n@@ -1792,7 +1792,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\t{\n \t\t  x = omp_reduction_init (c, TREE_TYPE (new_var));\n \t\t  gcc_assert (TREE_CODE (TREE_TYPE (new_var)) != ARRAY_TYPE);\n-\t\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, new_var, x);\n+\t\t  x = build_gimple_modify_stmt (new_var, x);\n \t\t  gimplify_and_add (x, ilist);\n \t\t}\n \t      break;\n@@ -1956,7 +1956,7 @@ lower_reduction_clauses (tree clauses, tree *stmt_list, omp_context *ctx)\n \t{\n \t  x = build2 (code, TREE_TYPE (ref), ref, new_var);\n \t  ref = build_outer_var_ref (var, ctx);\n-\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ref, x);\n+\t  x = build_gimple_modify_stmt (ref, x);\n \t  append_to_statement_list (x, &sub_list);\n \t}\n     }\n@@ -1993,7 +1993,7 @@ lower_copyprivate_clauses (tree clauses, tree *slist, tree *rlist,\n       ref = build_sender_ref (var, ctx);\n       x = (ctx->is_nested) ? lookup_decl_in_outer_ctx (var, ctx) : var;\n       x = by_ref ? build_fold_addr_expr (x) : x;\n-      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ref, x);\n+      x = build_gimple_modify_stmt (ref, x);\n       gimplify_and_add (x, slist);\n \n       ref = build_receiver_ref (var, by_ref, ctx);\n@@ -2074,14 +2074,14 @@ lower_send_clauses (tree clauses, tree *ilist, tree *olist, omp_context *ctx)\n \t{\n \t  ref = build_sender_ref (val, ctx);\n \t  x = by_ref ? build_fold_addr_expr (var) : var;\n-\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ref, x);\n+\t  x = build_gimple_modify_stmt (ref, x);\n \t  gimplify_and_add (x, ilist);\n \t}\n \n       if (do_out)\n \t{\n \t  ref = build_sender_ref (val, ctx);\n-\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, ref);\n+\t  x = build_gimple_modify_stmt (var, ref);\n \t  gimplify_and_add (x, olist);\n \t}\n     }\n@@ -2118,17 +2118,17 @@ lower_send_shared_vars (tree *ilist, tree *olist, omp_context *ctx)\n \t{\n \t  x = build_sender_ref (ovar, ctx);\n \t  var = build_fold_addr_expr (var);\n-\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, var);\n+\t  x = build_gimple_modify_stmt (x, var);\n \t  gimplify_and_add (x, ilist);\n \t}\n       else\n \t{\n \t  x = build_sender_ref (ovar, ctx);\n-\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, x, var);\n+\t  x = build_gimple_modify_stmt (x, var);\n \t  gimplify_and_add (x, ilist);\n \n \t  x = build_sender_ref (ovar, ctx);\n-\t  x = build2 (GIMPLE_MODIFY_STMT, void_type_node, var, x);\n+\t  x = build_gimple_modify_stmt (var, x);\n \t  gimplify_and_add (x, olist);\n \t}\n     }\n@@ -2226,14 +2226,14 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t  si = bsi_start (then_bb);\n \t  t = build1 (LABEL_EXPR, void_type_node, then_lab);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp, val);\n+\t  t = build_gimple_modify_stmt (tmp, val);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  si = bsi_start (else_bb);\n \t  t = build1 (LABEL_EXPR, void_type_node, else_lab);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp, \n-\t              build_int_cst (unsigned_type_node, 1));\n+\t  t = build_gimple_modify_stmt (tmp, \n+\t\t\t\t\tbuild_int_cst (unsigned_type_node, 1));\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n@@ -2640,11 +2640,11 @@ expand_omp_for_generic (struct omp_region *region,\n   /* Iteration setup for sequential loop goes in L0_BB.  */\n   list = alloc_stmt_list ();\n   t = fold_convert (type, istart0);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n+  t = build_gimple_modify_stmt (fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = fold_convert (type, iend0);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, iend, t);\n+  t = build_gimple_modify_stmt (iend, t);\n   gimplify_and_add (t, &list);\n \n   si = bsi_start (l0_bb);\n@@ -2666,7 +2666,7 @@ expand_omp_for_generic (struct omp_region *region,\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n+  t = build_gimple_modify_stmt (fd->v, t);\n   gimplify_and_add (t, &list);\n   \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, iend);\n@@ -2841,7 +2841,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   t = fold_convert (type, s0);\n   t = build2 (MULT_EXPR, type, t, fd->step);\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n+  t = build_gimple_modify_stmt (fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = fold_convert (type, e0);\n@@ -2856,7 +2856,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n+  t = build_gimple_modify_stmt (fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n@@ -3023,7 +3023,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   t = fold_convert (type, s0);\n   t = build2 (MULT_EXPR, type, t, fd->step);\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n+  t = build_gimple_modify_stmt (fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = fold_convert (type, e0);\n@@ -3039,7 +3039,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, t);\n+  t = build_gimple_modify_stmt (fd->v, t);\n   gimplify_and_add (t, &list);\n \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n@@ -3058,7 +3058,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \n   t = build_int_cst (type, 1);\n   t = build2 (PLUS_EXPR, type, trip, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, trip, t);\n+  t = build_gimple_modify_stmt (trip, t);\n   gimplify_and_add (t, &list);\n \n   si = bsi_start (trip_update_bb);\n@@ -3206,7 +3206,7 @@ expand_omp_sections (struct omp_region *region)\n       t = build_int_cst (unsigned_type_node, len);\n       u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n       t = build_call_expr (u, 1, t);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, v, t);\n+      t = build_gimple_modify_stmt (v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n     }\n   bsi_remove (&si, true);\n@@ -3273,7 +3273,7 @@ expand_omp_sections (struct omp_region *region)\n       gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n \n       t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT], 0);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, v, t);\n+      t = build_gimple_modify_stmt (v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n       bsi_remove (&si, true);\n     }\n@@ -3709,7 +3709,7 @@ lower_omp_single_copy (tree single_stmt, tree *pre_p, omp_context *ctx)\n \n   t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START], 0);\n   t = fold_convert (ptr_type, t);\n-  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, ctx->receiver_decl, t);\n+  t = build_gimple_modify_stmt (ctx->receiver_decl, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build2 (EQ_EXPR, boolean_type_node, ctx->receiver_decl,\n@@ -3994,7 +3994,7 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, tree *body_p,\n \n       /* Initialize the iterator variable, so that threads that don't execute\n \t any iterations don't execute the lastprivate clauses by accident.  */\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, fd->v, vinit);\n+      t = build_gimple_modify_stmt (fd->v, vinit);\n       gimplify_and_add (t, body_p);\n     }\n }\n@@ -4134,7 +4134,7 @@ lower_omp_parallel (tree *stmt_p, omp_context *ctx)\n       t = build_fold_addr_expr (ctx->sender_decl);\n       /* fixup_child_record_type might have changed receiver_decl's type.  */\n       t = fold_convert (TREE_TYPE (ctx->receiver_decl), t);\n-      t = build2 (GIMPLE_MODIFY_STMT, void_type_node, ctx->receiver_decl, t);\n+      t = build_gimple_modify_stmt (ctx->receiver_decl, t);\n       append_to_statement_list (t, &new_body);\n     }\n \n@@ -4186,7 +4186,7 @@ init_tmp_var (tree exp, tree_stmt_iterator *tsi)\n \n   t = create_tmp_var (TREE_TYPE (exp), NULL);\n   DECL_GIMPLE_REG_P (t) = 1;\n-  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (t), t, exp);\n+  stmt = build_gimple_modify_stmt (t, exp);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n \n@@ -4203,7 +4203,7 @@ save_tmp_var (tree exp, tree_stmt_iterator *tsi)\n \n   t = create_tmp_var (TREE_TYPE (exp), NULL);\n   DECL_GIMPLE_REG_P (t) = 1;\n-  stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (t), exp, t);\n+  stmt = build_gimple_modify_stmt (exp, t);\n   SET_EXPR_LOCUS (stmt, EXPR_LOCUS (tsi_stmt (*tsi)));\n   tsi_link_after (tsi, stmt, TSI_SAME_STMT);\n "}, {"sha": "24a21717278572637c3a920ead285c05392c7ba5", "filename": "gcc/value-prof.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b56b9fe39dc195086c6767812dead9ab424c5247/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=b56b9fe39dc195086c6767812dead9ab424c5247", "patch": "@@ -1,5 +1,5 @@\n /* Transformations based on profile information for values.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -523,9 +523,8 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv,\n-\t\t  fold_convert (optype, value));\n-  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, op2);\n+  stmt1 = build_gimple_modify_stmt (tmpv, fold_convert (optype, value));\n+  stmt2 = build_gimple_modify_stmt (tmp1, op2);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n \t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n@@ -537,15 +536,17 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n \n   tmp2 = create_tmp_var (optype, \"PROF\");\n   label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmp2,\n-\t\t  build2 (TREE_CODE (operation), optype, op1, tmpv));\n+  stmt1 = build_gimple_modify_stmt (tmp2,\n+\t\t\t\t    build2 (TREE_CODE (operation), optype,\n+\t\t\t\t\t    op1, tmpv));\n   bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb2end = stmt1;\n \n   label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmp2,\n-\t\t  build2 (TREE_CODE (operation), optype, op1, op2));\n+  stmt1 = build_gimple_modify_stmt (tmp2,\n+\t\t\t\t    build2 (TREE_CODE (operation), optype,\n+\t\t\t\t\t    op1, op2));\n   bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb3end = stmt1;\n@@ -680,10 +681,11 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n \n   tmp2 = create_tmp_var (optype, \"PROF\");\n   tmp3 = create_tmp_var (optype, \"PROF\");\n-  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp2, \n-\t\t  build2 (PLUS_EXPR, optype, op2, build_int_cst (optype, -1)));\n-  stmt3 = build2 (GIMPLE_MODIFY_STMT, optype, tmp3,\n-\t\t  build2 (BIT_AND_EXPR, optype, tmp2, op2));\n+  stmt2 = build_gimple_modify_stmt (tmp2, \n+\t\t\t\t    build2 (PLUS_EXPR, optype, op2,\n+\t\t\t\t\t    build_int_cst (optype, -1)));\n+  stmt3 = build_gimple_modify_stmt (tmp3,\n+\t\t\t\t    build2 (BIT_AND_EXPR, optype, tmp2, op2));\n   stmt4 = build3 (COND_EXPR, void_type_node,\n \t\t  build2 (NE_EXPR, boolean_type_node,\n \t\t\t  tmp3, build_int_cst (optype, 0)),\n@@ -696,15 +698,16 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n \n   /* tmp2 == op2-1 inherited from previous block */\n   label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n-\t\t  build2 (BIT_AND_EXPR, optype, op1, tmp2));\n+  stmt1 = build_gimple_modify_stmt (result,\n+\t\t\t\t    build2 (BIT_AND_EXPR, optype, op1, tmp2));\n   bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb2end = stmt1;\n \n   label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n-\t\t  build2 (TREE_CODE (operation), optype, op1, op2));\n+  stmt1 = build_gimple_modify_stmt (result,\n+\t\t\t\t    build2 (TREE_CODE (operation), optype,\n+\t\t\t\t\t    op1, op2));\n   bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb3end = stmt1;\n@@ -838,8 +841,8 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n   bsi = bsi_for_stmt (stmt);\n \n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result, op1);\n-  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, op2);\n+  stmt1 = build_gimple_modify_stmt (result, op1);\n+  stmt2 = build_gimple_modify_stmt (tmp1, op2);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (LT_EXPR, boolean_type_node, result, tmp1),\n \t    build1 (GOTO_EXPR, void_type_node, label_decl3),\n@@ -853,8 +856,9 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n   if (ncounts)\t/* Assumed to be 0 or 1 */\n     {\n       label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n-      stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n-\t\t      build2 (MINUS_EXPR, optype, result, tmp1));\n+      stmt1 = build_gimple_modify_stmt (result,\n+\t\t\t\t\tbuild2 (MINUS_EXPR, optype,\n+\t\t\t\t\t\tresult, tmp1));\n       stmt2 = build3 (COND_EXPR, void_type_node,\n \t\tbuild2 (LT_EXPR, boolean_type_node, result, tmp1),\n \t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n@@ -867,8 +871,9 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n \n   /* Fallback case. */\n   label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, result,\n-\t\t    build2 (TREE_CODE (operation), optype, result, tmp1));\n+  stmt1 = build_gimple_modify_stmt (result,\n+\t\t\t\t    build2 (TREE_CODE (operation), optype,\n+\t\t\t\t\t    result, tmp1));\n   bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb3end = stmt1;\n@@ -1055,7 +1060,7 @@ tree_ic (tree stmt, tree call, struct cgraph_node* direct_call,\n \t int prob, gcov_type count, gcov_type all)\n {\n   tree stmt1, stmt2, stmt3;\n-  tree tmp1, tmpv;\n+  tree tmp1, tmpv, tmp;\n   tree label_decl1 = create_artificial_label ();\n   tree label_decl2 = create_artificial_label ();\n   tree label1, label2;\n@@ -1072,11 +1077,11 @@ tree_ic (tree stmt, tree call, struct cgraph_node* direct_call,\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv, \n-\t\t  unshare_expr (CALL_EXPR_FN (call)));\n-  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, \n-\t\t  fold_convert (optype, build_addr (direct_call->decl, \n-\t\t\t\t\t\t    current_function_decl)));\n+  stmt1 = build_gimple_modify_stmt (tmpv, \n+\t\t\t\t    unshare_expr (CALL_EXPR_FN (call)));\n+  tmp = fold_convert (optype, build_addr (direct_call->decl, \n+\t\t\t\t\t  current_function_decl));\n+  stmt2 = build_gimple_modify_stmt (tmp1, tmp);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t\t  build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n \t\t  build1 (GOTO_EXPR, void_type_node, label_decl2),\n@@ -1279,9 +1284,8 @@ tree_stringop_fixed_value (tree stmt, tree value, int prob, gcov_type count,\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv,\n-\t\t  fold_convert (optype, value));\n-  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, blck_size);\n+  stmt1 = build_gimple_modify_stmt (tmpv, fold_convert (optype, value));\n+  stmt2 = build_gimple_modify_stmt (tmp1, blck_size);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n \t    build1 (GOTO_EXPR, void_type_node, label_decl2),"}]}