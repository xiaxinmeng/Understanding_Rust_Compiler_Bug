{"sha": "34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "node_id": "C_kwDOANBUbNoAKDM0YTVlZWJjMWI5OGI2NTE5ZDU5MGMzYjE2NWMzYmFlMWFmYTVmYmI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-04-18T16:56:43Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-04-26T15:02:40Z"}, "message": "gccrs: Track Self properly with TypePredicateBounds\n\nWhen we handle generic trait bounds we never tracked its associated Self\ntype. Its important to remember a Trait Predicate is associated with a type\nthis means we end up missing a lot of helpful type information down the\nline relating to higher ranked trait bounds and associated types\ncompuations. Remember traits have an implict Generic Type Parameter of Self\nwe use this in computing trait defintions so in that case no associated\ntype is specified which is to be expected but in all other cases we do\neven if it is generic its still useful type information to keep track of.\n\nThere is one regression here with compile/issue-1893.rs this testcase\nmostly worked out as a fluke rather than a proper fix so its no suprise\nhere it has regressed the other two test cases one where the number\ngeneric arguments has changed, Rustc gets around this and has a seperate\nerror message for this case.\n\nWe need to solve this patch in order to solve #2019\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-trait-resolve.cc (TraitResolver::resolve_trait): use new interface\n\t* typecheck/rust-hir-type-check-base.h: update prototype to include Self\n\t* typecheck/rust-hir-type-check-expr.cc (TypeCheckExpr::visit): lifewise\n\t* typecheck/rust-hir-type-check-item.cc (TypeCheckItem::resolve_impl_block_substitutions):\n\tlikewise\n\t* typecheck/rust-hir-type-check-path.cc (TypeCheckExpr::visit): likewise\n\t(TypeCheckExpr::resolve_segments): likewise\n\t* typecheck/rust-hir-type-check-type.cc (TypeCheckType::visit): likewise\n\t(TypeResolveGenericParam::visit): likewise\n\t(ResolveWhereClauseItem::visit): likewise\n\t* typecheck/rust-tyty-bounds.cc (TypeCheckBase::get_predicate_from_bound): likewise\n\t(TypeBoundPredicate::apply_generic_arguments): likewise\n\t(TypeBoundsMappings::lookup_predicate): likewise\n\t* typecheck/rust-tyty-bounds.h: likewise\n\t* typecheck/rust-tyty.h:likewise\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-1893.rs: regression\n\t* rust/compile/traits12.rs: rustc uses a custom error message here\n\t* rust/compile/unconstrained_type_param.rs: extra error message\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "2a5999e1d095be896bf4e65827f41dff10fb419b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a5999e1d095be896bf4e65827f41dff10fb419b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "198f98ec04c9f09f956fee36cfb93957e06fbe7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198f98ec04c9f09f956fee36cfb93957e06fbe7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198f98ec04c9f09f956fee36cfb93957e06fbe7d"}], "stats": {"total": 197, "additions": 148, "deletions": 49}, "files": [{"sha": "58b791b6d6dcfbcbc7a5d3bd68160e20f87bc5d6", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -228,7 +228,9 @@ TraitResolver::resolve_trait (HIR::Trait *trait_reference)\n \t      HIR::TraitBound *b\n \t\t= static_cast<HIR::TraitBound *> (bound.get ());\n \n-\t      auto predicate = get_predicate_from_bound (b->get_path ());\n+\t      auto predicate = get_predicate_from_bound (\n+\t\tb->get_path (),\n+\t\tnullptr /*this will setup a PLACEHOLDER for self*/);\n \t      if (predicate.is_error ())\n \t\treturn &TraitReference::error_node ();\n \n@@ -484,26 +486,36 @@ AssociatedImplTrait::setup_associated_types (\n \n   // infer the arguments on the predicate\n   std::vector<TyTy::BaseType *> impl_trait_predicate_args;\n-  for (const auto &arg : impl_predicate.get_substs ())\n+\n+  for (size_t i = 0; i < impl_predicate.get_substs ().size (); i++)\n     {\n-      const TyTy::ParamType *p = arg.get_param_ty ();\n-      if (p->get_symbol ().compare (\"Self\") == 0)\n+      const auto &arg = impl_predicate.get_substs ().at (i);\n+      if (i == 0)\n \tcontinue;\n \n+      const TyTy::ParamType *p = arg.get_param_ty ();\n       TyTy::BaseType *r = p->resolve ();\n-      r = SubstMapperInternal::Resolve (r, infer_arguments);\n+      if (!r->is_concrete ())\n+\t{\n+\t  r = SubstMapperInternal::Resolve (r, infer_arguments);\n+\t}\n       impl_trait_predicate_args.push_back (r);\n     }\n \n   // unify the bounds arguments\n   std::vector<TyTy::BaseType *> hrtb_bound_arguments;\n-  for (const auto &arg : bound.get_substs ())\n+  for (size_t i = 0; i < bound.get_substs ().size (); i++)\n     {\n-      const TyTy::ParamType *p = arg.get_param_ty ();\n-      if (p->get_symbol ().compare (\"Self\") == 0)\n+      const auto &arg = bound.get_substs ().at (i);\n+      if (i == 0)\n \tcontinue;\n \n+      const TyTy::ParamType *p = arg.get_param_ty ();\n       TyTy::BaseType *r = p->resolve ();\n+      if (!r->is_concrete ())\n+\t{\n+\t  r = SubstMapperInternal::Resolve (r, infer_arguments);\n+\t}\n       hrtb_bound_arguments.push_back (r);\n     }\n "}, {"sha": "ad3b0e11b6eb444a7c692b365a8ec5d843d2cd2a", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -37,7 +37,8 @@ class TypeCheckBase\n \n   TraitReference *resolve_trait_path (HIR::TypePath &);\n \n-  TyTy::TypeBoundPredicate get_predicate_from_bound (HIR::TypePath &path);\n+  TyTy::TypeBoundPredicate\n+  get_predicate_from_bound (HIR::TypePath &path, HIR::Type *associated_self);\n \n   bool check_for_unconstrained (\n     const std::vector<TyTy::SubstitutionParamMapping> &params_to_constrain,"}, {"sha": "42b9623fad683e5557341cfc88f1b6ff7e2baaf6", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -1572,7 +1572,7 @@ TypeCheckExpr::visit (HIR::ClosureExpr &expr)\n   args.get_type_args ().push_back (std::unique_ptr<HIR::Type> (implicit_tuple));\n \n   // apply the arguments\n-  predicate.apply_generic_arguments (&args);\n+  predicate.apply_generic_arguments (&args, false);\n \n   // finally inherit the trait bound\n   infered->inherit_bounds ({predicate});"}, {"sha": "0e8ce6b7b78ae7ae35964b8a019cef656c326351", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -501,7 +501,8 @@ TypeCheckItem::resolve_impl_block_substitutions (HIR::ImplBlock &impl_block,\n \n       // we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n       // for example\n-      specified_bound = get_predicate_from_bound (*ref.get ());\n+      specified_bound\n+\t= get_predicate_from_bound (*ref.get (), impl_block.get_type ().get ());\n     }\n \n   TyTy::BaseType *self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n@@ -537,7 +538,8 @@ TypeCheckItem::validate_trait_impl_block (\n \n       // we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n       // for example\n-      specified_bound = get_predicate_from_bound (*ref.get ());\n+      specified_bound\n+\t= get_predicate_from_bound (*ref.get (), impl_block.get_type ().get ());\n     }\n \n   bool is_trait_impl_block = !trait_reference->is_error ();"}, {"sha": "d43587f6f354f77fca1f33004b7dee09e9595051", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-path-probe.h\"\n@@ -59,7 +60,9 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     return;\n \n   // get the predicate for the bound\n-  auto specified_bound = get_predicate_from_bound (*trait_path_ref.get ());\n+  auto specified_bound\n+    = get_predicate_from_bound (*trait_path_ref.get (),\n+\t\t\t\tqual_path_type.get_type ().get ());\n   if (specified_bound.is_error ())\n     return;\n \n@@ -396,33 +399,41 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  bool found_impl_trait\n \t    = context->lookup_associated_trait_impl (impl_block_id,\n \t\t\t\t\t\t     &associated);\n-\t  TyTy::BaseType *impl_block_ty = nullptr;\n-\t  if (found_impl_trait)\n-\t    {\n-\t      TyTy::TypeBoundPredicate predicate (*associated->get_trait (),\n-\t\t\t\t\t\t  seg.get_locus ());\n-\t      impl_block_ty\n-\t\t= associated->setup_associated_types (prev_segment, predicate);\n-\t    }\n-\t  else\n-\t    {\n-\t      // get the type of the parent Self\n-\t      HirId impl_ty_id = associated_impl_block->get_type ()\n-\t\t\t\t   ->get_mappings ()\n-\t\t\t\t   .get_hirid ();\n-\n-\t      bool ok = query_type (impl_ty_id, &impl_block_ty);\n-\t      rust_assert (ok);\n+\t  TyTy::BaseType *impl_block_ty\n+\t    = TypeCheckItem::ResolveImplBlockSelf (*associated_impl_block);\n \n-\t      if (impl_block_ty->needs_generic_substitutions ())\n-\t\timpl_block_ty\n-\t\t  = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n-\t    }\n+\t  if (impl_block_ty->needs_generic_substitutions ())\n+\t    impl_block_ty\n+\t      = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n \n \t  prev_segment = unify_site (seg.get_mappings ().get_hirid (),\n \t\t\t\t     TyTy::TyWithLocation (prev_segment),\n \t\t\t\t     TyTy::TyWithLocation (impl_block_ty),\n \t\t\t\t     seg.get_locus ());\n+\n+\t  if (found_impl_trait)\n+\t    {\n+\t      // we need to setup with apropriate bounds\n+\t      HIR::TypePath &bound_path\n+\t\t= *associated->get_impl_block ()->get_trait_ref ().get ();\n+\n+\t      // generate an implicit HIR Type we can apply to the predicate\n+\t      HirId implicit_id = mappings->get_next_hir_id ();\n+\t      context->insert_implicit_type (implicit_id, impl_block_ty);\n+\n+\t      Analysis::NodeMapping mappings (expr_mappings.get_crate_num (),\n+\t\t\t\t\t      expr_mappings.get_nodeid (),\n+\t\t\t\t\t      implicit_id,\n+\t\t\t\t\t      expr_mappings.get_local_defid ());\n+\t      HIR::TypePath *implicit_self_bound\n+\t\t= new HIR::TypePath (mappings, {},\n+\t\t\t\t     Linemap::predeclared_location (), false);\n+\n+\t      TyTy::TypeBoundPredicate predicate\n+\t\t= get_predicate_from_bound (bound_path, implicit_self_bound);\n+\t      impl_block_ty\n+\t\t= associated->setup_associated_types (prev_segment, predicate);\n+\t    }\n \t}\n \n       if (tyseg->needs_generic_substitutions ())"}, {"sha": "0170a5a1d896a8b843b38b313975a252a7f50121", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -193,7 +193,8 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \n   // get the predicate for the bound\n   auto specified_bound\n-    = get_predicate_from_bound (*qual_path_type.get_trait ().get ());\n+    = get_predicate_from_bound (*qual_path_type.get_trait ().get (),\n+\t\t\t\tqual_path_type.get_type ().get ());\n   if (specified_bound.is_error ())\n     return;\n \n@@ -559,8 +560,9 @@ TypeCheckType::visit (HIR::TraitObjectType &type)\n       HIR::TypeParamBound &b = *bound.get ();\n       HIR::TraitBound &trait_bound = static_cast<HIR::TraitBound &> (b);\n \n-      TyTy::TypeBoundPredicate predicate\n-\t= get_predicate_from_bound (trait_bound.get_path ());\n+      TyTy::TypeBoundPredicate predicate = get_predicate_from_bound (\n+\ttrait_bound.get_path (),\n+\tnullptr /*this will setup a PLACEHOLDER for self*/);\n \n       if (!predicate.is_error ()\n \t  && predicate.is_object_safe (true, type.get_locus ()))\n@@ -682,6 +684,30 @@ TypeResolveGenericParam::visit (HIR::TypeParam &param)\n   if (param.has_type ())\n     TypeCheckType::Resolve (param.get_type ().get ());\n \n+  HIR::Type *implicit_self_bound = nullptr;\n+  if (param.has_type_param_bounds ())\n+    {\n+      // We need two possible parameter types. One with no Bounds and one with\n+      // the bounds. the Self type for the bounds cannot itself contain the\n+      // bounds otherwise it will be a trait cycle\n+      HirId implicit_id = mappings->get_next_hir_id ();\n+      TyTy::ParamType *p\n+\t= new TyTy::ParamType (param.get_type_representation (),\n+\t\t\t       param.get_locus (), implicit_id, param,\n+\t\t\t       {} /*empty specified bounds*/);\n+      context->insert_implicit_type (implicit_id, p);\n+\n+      // generate an implicit HIR Type we can apply to the predicate\n+      Analysis::NodeMapping mappings (param.get_mappings ().get_crate_num (),\n+\t\t\t\t      param.get_mappings ().get_nodeid (),\n+\t\t\t\t      implicit_id,\n+\t\t\t\t      param.get_mappings ().get_local_defid ());\n+      implicit_self_bound\n+\t= new HIR::TypePath (mappings, {}, Linemap::predeclared_location (),\n+\t\t\t     false);\n+    }\n+\n+  // resolve the bounds\n   std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n   if (param.has_type_param_bounds ())\n     {\n@@ -694,7 +720,8 @@ TypeResolveGenericParam::visit (HIR::TypeParam &param)\n \t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n \n \t\tTyTy::TypeBoundPredicate predicate\n-\t\t  = get_predicate_from_bound (b->get_path ());\n+\t\t  = get_predicate_from_bound (b->get_path (),\n+\t\t\t\t\t      implicit_self_bound);\n \t\tif (!predicate.is_error ())\n \t\t  specified_bounds.push_back (std::move (predicate));\n \t      }\n@@ -738,6 +765,8 @@ ResolveWhereClauseItem::visit (HIR::TypeBoundWhereClauseItem &item)\n   auto &binding_type_path = item.get_bound_type ();\n   TyTy::BaseType *binding = TypeCheckType::Resolve (binding_type_path.get ());\n \n+  // FIXME double check there might be a trait cycle here see TypeParam handling\n+\n   std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n   for (auto &bound : item.get_type_param_bounds ())\n     {\n@@ -747,7 +776,8 @@ ResolveWhereClauseItem::visit (HIR::TypeBoundWhereClauseItem &item)\n \t    HIR::TraitBound *b = static_cast<HIR::TraitBound *> (bound.get ());\n \n \t    TyTy::TypeBoundPredicate predicate\n-\t      = get_predicate_from_bound (b->get_path ());\n+\t      = get_predicate_from_bound (b->get_path (),\n+\t\t\t\t\t  binding_type_path.get ());\n \t    if (!predicate.is_error ())\n \t      specified_bounds.push_back (std::move (predicate));\n \t  }"}, {"sha": "6f946bd655037cfc42fa20ee538423035d2760f0", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -171,7 +171,8 @@ TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n }\n \n TyTy::TypeBoundPredicate\n-TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n+TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path,\n+\t\t\t\t\t HIR::Type *associated_self)\n {\n   TyTy::TypeBoundPredicate lookup = TyTy::TypeBoundPredicate::error ();\n   bool already_resolved\n@@ -251,17 +252,33 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n       break;\n     }\n \n+  if (associated_self != nullptr)\n+    {\n+      std::vector<std::unique_ptr<HIR::Type>> type_args;\n+      type_args.push_back (\n+\tstd::unique_ptr<HIR::Type> (associated_self->clone_type ()));\n+      for (auto &arg : args.get_type_args ())\n+\t{\n+\t  type_args.push_back (std::unique_ptr<HIR::Type> (arg->clone_type ()));\n+\t}\n+\n+      args = HIR::GenericArgs (args.get_lifetime_args (), std::move (type_args),\n+\t\t\t       args.get_binding_args (), args.get_const_args (),\n+\t\t\t       args.get_locus ());\n+    }\n+\n   // we try to apply generic arguments when they are non empty and or when the\n   // predicate requires them so that we get the relevant Foo expects x number\n   // arguments but got zero see test case rust/compile/traits12.rs\n   if (!args.is_empty () || predicate.requires_generic_args ())\n     {\n       // this is applying generic arguments to a trait reference\n-      predicate.apply_generic_arguments (&args);\n+      predicate.apply_generic_arguments (&args, associated_self != nullptr);\n     }\n \n   context->insert_resolved_predicate (type_path.get_mappings ().get_hirid (),\n \t\t\t\t      predicate);\n+\n   return predicate;\n }\n \n@@ -416,12 +433,21 @@ TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n }\n \n void\n-TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n+TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args,\n+\t\t\t\t\t     bool has_associated_self)\n {\n-  // we need to get the substitutions argument mappings but also remember that\n-  // we have an implicit Self argument which we must be careful to respect\n-  rust_assert (!used_arguments.is_empty ());\n   rust_assert (!substitutions.empty ());\n+  if (has_associated_self)\n+    {\n+      used_arguments = SubstitutionArgumentMappings::empty ();\n+    }\n+  else\n+    {\n+      // we need to get the substitutions argument mappings but also remember\n+      // that we have an implicit Self argument which we must be careful to\n+      // respect\n+      rust_assert (!used_arguments.is_empty ());\n+    }\n \n   // now actually perform a substitution\n   used_arguments = get_mappings_from_generic_args (*generic_args);\n@@ -690,6 +716,17 @@ TypeBoundsMappings::get_specified_bounds () const\n   return specified_bounds;\n }\n \n+TypeBoundPredicate\n+TypeBoundsMappings::lookup_predicate (DefId id)\n+{\n+  for (auto &b : specified_bounds)\n+    {\n+      if (b.get_id () == id)\n+\treturn b;\n+    }\n+  return TypeBoundPredicate::error ();\n+}\n+\n size_t\n TypeBoundsMappings::num_specified_bounds () const\n {"}, {"sha": "2392740a9bd60be0bf3db247fa9ced8f48500ee1", "filename": "gcc/rust/typecheck/rust-tyty-bounds.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.h?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -20,6 +20,7 @@\n #define RUST_TYTY_BOUNDS_H\n \n #include \"rust-location.h\"\n+#include \"rust-mapping-common.h\"\n \n namespace Rust {\n \n@@ -68,6 +69,8 @@ class TypeBoundsMappings\n \n   const std::vector<TypeBoundPredicate> &get_specified_bounds () const;\n \n+  TypeBoundPredicate lookup_predicate (DefId id);\n+\n   size_t num_specified_bounds () const;\n \n   std::string raw_bounds_as_string () const;"}, {"sha": "550b76672eaaddc16d195bd769e7b438ebf18ae3", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -408,7 +408,8 @@ class TypeBoundPredicate : public SubstitutionRef\n   // https://doc.rust-lang.org/reference/items/traits.html#object-safety\n   bool is_object_safe (bool emit_error, Location locus) const;\n \n-  void apply_generic_arguments (HIR::GenericArgs *generic_args);\n+  void apply_generic_arguments (HIR::GenericArgs *generic_args,\n+\t\t\t\tbool has_associated_self);\n \n   bool contains_item (const std::string &search) const;\n "}, {"sha": "8d32e0d37c8dc20ef327e6a19d4a21c3f6a76da5", "filename": "gcc/testsuite/rust/compile/issue-1893.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1893.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1893.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1893.rs?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -1,3 +1,4 @@\n+// { dg-additional-options \"-frust-compile-until=nameresolution\" }\n pub enum Option<T> {\n     None,\n     Some(T),"}, {"sha": "b170692f265c4a81d02f98f072ef8ef6f44d8502", "filename": "gcc/testsuite/rust/compile/traits12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits12.rs?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -10,7 +10,7 @@ struct Foo<T> {\n }\n \n impl<T> A for Foo<usize> {\n-    // { dg-error \"generic item takes at least 1 type arguments but 0 were supplied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"generic item takes at least 2 type arguments but 1 were supplied\" \"\" { target *-*-* } .-1 }\n     // { dg-error \"unconstrained type parameter\" \"\" { target *-*-* } .-2 }\n     type Output = T;\n "}, {"sha": "9f3db93a5e760d11473b28e304fd341345a93814", "filename": "gcc/testsuite/rust/compile/unconstrained_type_param.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Ftestsuite%2Frust%2Fcompile%2Funconstrained_type_param.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a5eebc1b98b6519d590c3b165c3bae1afa5fbb/gcc%2Ftestsuite%2Frust%2Fcompile%2Funconstrained_type_param.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Funconstrained_type_param.rs?ref=34a5eebc1b98b6519d590c3b165c3bae1afa5fbb", "patch": "@@ -9,6 +9,7 @@ impl<X, Y> Foo<X> {\n \n fn main() {\n     let a = Foo::test();\n-    // { dg-error \"Failed to resolve expression of function call\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"expected\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"Failed to resolve expression of function call\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-3 }\n }"}]}