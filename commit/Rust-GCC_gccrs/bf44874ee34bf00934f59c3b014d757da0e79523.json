{"sha": "bf44874ee34bf00934f59c3b014d757da0e79523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY0NDg3NGVlMzRiZjAwOTM0ZjU5YzNiMDE0ZDc1N2RhMGU3OTUyMw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-02-29T22:42:58Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-02-29T22:42:58Z"}, "message": "calls.c (emit_library_call): Do not abort if FUNCTION_ARG returns a PARALLEL.\n\n        * calls.c (emit_library_call): Do not abort if FUNCTION_ARG\n        returns a PARALLEL.  Use emit_group_load and use_group_regs\n        as needed.\n        (emit_library_call_value): Similarly.\n\nFrom-SVN: r32267", "tree": {"sha": "2ed463184749db51d465363650fc6c6718454a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ed463184749db51d465363650fc6c6718454a2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf44874ee34bf00934f59c3b014d757da0e79523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf44874ee34bf00934f59c3b014d757da0e79523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf44874ee34bf00934f59c3b014d757da0e79523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf44874ee34bf00934f59c3b014d757da0e79523/comments", "author": null, "committer": null, "parents": [{"sha": "a7a1d2701f5d7e496d53fa19708219d192df91ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a1d2701f5d7e496d53fa19708219d192df91ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a1d2701f5d7e496d53fa19708219d192df91ba"}], "stats": {"total": 45, "additions": 35, "deletions": 10}, "files": [{"sha": "ccf6ea4bfc34824e6f2d0b8f1b1af730ea371b54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf44874ee34bf00934f59c3b014d757da0e79523/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf44874ee34bf00934f59c3b014d757da0e79523/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf44874ee34bf00934f59c3b014d757da0e79523", "patch": "@@ -5,6 +5,11 @@ Tue Feb 29 14:07:04 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n Tue Feb 29 10:45:59 2000  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (emit_library_call): Do not abort if FUNCTION_ARG\n+\treturns a PARALLEL.  Use emit_group_load and use_group_regs\n+\tas needed.  \n+\t(emit_library_call_value): Similarly.\n+\n \t* pa/t-pa: Use quadlib.c instead of quadlib.asm.\n \t* pa/quadlib.asm: Remove.\n \t* pa/quadlib.c: New file."}, {"sha": "c4e6039f23c2aa2921cf0cac620e924ba07fb630", "filename": "gcc/calls.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf44874ee34bf00934f59c3b014d757da0e79523/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf44874ee34bf00934f59c3b014d757da0e79523/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bf44874ee34bf00934f59c3b014d757da0e79523", "patch": "@@ -2804,8 +2804,7 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n       argvec[count].mode = mode;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-      if (argvec[count].reg && GET_CODE (argvec[count].reg) == PARALLEL)\n-\tabort ();\n+\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n       argvec[count].partial\n \t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n@@ -3085,8 +3084,15 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n \n-      if (reg != 0 && partial == 0)\n+      /* Handle calls that pass values in multiple non-contiguous\n+\t locations.  The PA64 has examples of this for library calls.  */\n+      if (GET_CODE (reg) == PARALLEL)\n+\temit_group_load (reg, val,\n+\t\t\t GET_MODE_SIZE (GET_MODE (val)),\n+\t\t\t GET_MODE_ALIGNMENT (GET_MODE (val)));\n+      else if (reg != 0 && partial == 0)\n \temit_move_insn (reg, val);\n+\n       NO_DEFER_POP;\n     }\n \n@@ -3096,8 +3102,12 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n   /* Any regs containing parms remain in use through the call.  */\n   for (count = 0; count < nargs; count++)\n-    if (argvec[count].reg != 0)\n-       use_reg (&call_fusage, argvec[count].reg);\n+    {\n+      if (GET_CODE (argvec[count].reg) == PARALLEL)\n+\tuse_group_regs (&call_fusage, argvec[count].reg);\n+      else if (argvec[count].reg != 0)\n+\tuse_reg (&call_fusage, argvec[count].reg);\n+    }\n \n   /* Don't allow popping to be deferred, since then\n      cse'ing of library calls could delete a call and leave the pop.  */\n@@ -3382,8 +3392,7 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n       argvec[count].mode = mode;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-      if (argvec[count].reg && GET_CODE (argvec[count].reg) == PARALLEL)\n-\tabort ();\n+\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n       argvec[count].partial\n \t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n@@ -3662,8 +3671,15 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n \n-      if (reg != 0 && partial == 0)\n+      /* Handle calls that pass values in multiple non-contiguous\n+\t locations.  The PA64 has examples of this for library calls.  */\n+      if (GET_CODE (reg) == PARALLEL)\n+\temit_group_load (reg, val,\n+\t\t\t GET_MODE_SIZE (GET_MODE (val)),\n+\t\t\t GET_MODE_ALIGNMENT (GET_MODE (val)));\n+      else if (reg != 0 && partial == 0)\n \temit_move_insn (reg, val);\n+\n       NO_DEFER_POP;\n     }\n \n@@ -3675,8 +3691,12 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n \n   /* Any regs containing parms remain in use through the call.  */\n   for (count = 0; count < nargs; count++)\n-    if (argvec[count].reg != 0)\n-       use_reg (&call_fusage, argvec[count].reg);\n+    {\n+      if (GET_CODE (argvec[count].reg) == PARALLEL)\n+\tuse_group_regs (&call_fusage, argvec[count].reg);\n+      else if (argvec[count].reg != 0)\n+\tuse_reg (&call_fusage, argvec[count].reg);\n+    }\n \n   /* Pass the function the address in which to return a structure value.  */\n   if (mem_value != 0 && struct_value_rtx != 0 && ! pcc_struct_value)"}]}