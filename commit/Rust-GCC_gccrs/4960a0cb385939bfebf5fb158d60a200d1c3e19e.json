{"sha": "4960a0cb385939bfebf5fb158d60a200d1c3e19e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2MGEwY2IzODU5MzliZmViZjVmYjE1OGQ2MGEyMDBkMWMzZTE5ZQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim.kuvyrkov@linaro.org", "date": "2014-05-22T07:26:00Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2014-05-22T07:26:00Z"}, "message": "Cleanup and improve multipass_dfa_lookahead_guard\n\n\t* config/i386/i386.c (core2i7_first_cycle_multipass_filter_ready_try,)\n\t(core2i7_first_cycle_multipass_begin,)\n\t(core2i7_first_cycle_multipass_issue,)\n\t(core2i7_first_cycle_multipass_backtrack): Update signature.\n\t* config/ia64/ia64.c\n\t(ia64_first_cycle_multipass_dfa_lookahead_guard_spec): Remove.\n\t(ia64_first_cycle_multipass_dfa_lookahead_guard): Update signature.\n\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC): Remove\n\thook definition.\n\t(ia64_first_cycle_multipass_dfa_lookahead_guard): Merge logic from\n\tia64_first_cycle_multipass_dfa_lookahead_guard_spec.  Update return\n\tvalues.\n\t* config/rs6000/rs6000.c (rs6000_use_sched_lookahead_guard): Update\n\treturn values.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in\n\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC): Remove.\n\t* haifa-sched.c (ready_try): Make signed to allow negative values.\n\t(rebug_ready_list_1): Update.\n\t(choose_ready): Simplify.\n\t(sched_extend_ready_list): Update.\n\nFrom-SVN: r210747", "tree": {"sha": "ee9f4c968ffd6c4f3e6f24c445abeb18d376052e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee9f4c968ffd6c4f3e6f24c445abeb18d376052e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4960a0cb385939bfebf5fb158d60a200d1c3e19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4960a0cb385939bfebf5fb158d60a200d1c3e19e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4960a0cb385939bfebf5fb158d60a200d1c3e19e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4960a0cb385939bfebf5fb158d60a200d1c3e19e/comments", "author": {"login": "maxim-kuvyrkov", "id": 12545699, "node_id": "MDQ6VXNlcjEyNTQ1Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/12545699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxim-kuvyrkov", "html_url": "https://github.com/maxim-kuvyrkov", "followers_url": "https://api.github.com/users/maxim-kuvyrkov/followers", "following_url": "https://api.github.com/users/maxim-kuvyrkov/following{/other_user}", "gists_url": "https://api.github.com/users/maxim-kuvyrkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxim-kuvyrkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxim-kuvyrkov/subscriptions", "organizations_url": "https://api.github.com/users/maxim-kuvyrkov/orgs", "repos_url": "https://api.github.com/users/maxim-kuvyrkov/repos", "events_url": "https://api.github.com/users/maxim-kuvyrkov/events{/privacy}", "received_events_url": "https://api.github.com/users/maxim-kuvyrkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16d83dd6f873552cce2116602073412cb0c297ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d83dd6f873552cce2116602073412cb0c297ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d83dd6f873552cce2116602073412cb0c297ed"}], "stats": {"total": 260, "additions": 136, "deletions": 124}, "files": [{"sha": "c86e5a8b9a61ce2f66013f8b53f0fa9213bb0648", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -1,3 +1,28 @@\n+2014-05-22  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n+\n+\tCleanup and improve multipass_dfa_lookahead_guard\n+        * config/i386/i386.c (core2i7_first_cycle_multipass_filter_ready_try,)\n+        (core2i7_first_cycle_multipass_begin,)\n+        (core2i7_first_cycle_multipass_issue,)\n+        (core2i7_first_cycle_multipass_backtrack): Update signature.\n+        * config/ia64/ia64.c\n+        (ia64_first_cycle_multipass_dfa_lookahead_guard_spec): Remove.\n+        (ia64_first_cycle_multipass_dfa_lookahead_guard): Update signature.\n+        (TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC): Remove\n+        hook definition.\n+        (ia64_first_cycle_multipass_dfa_lookahead_guard): Merge logic from\n+        ia64_first_cycle_multipass_dfa_lookahead_guard_spec.  Update return\n+        values.\n+        * config/rs6000/rs6000.c (rs6000_use_sched_lookahead_guard): Update\n+        return values.\n+        * doc/tm.texi: Regenerate.\n+        * doc/tm.texi.in\n+        (TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC): Remove.\n+        * haifa-sched.c (ready_try): Make signed to allow negative values.\n+        (rebug_ready_list_1): Update.\n+        (choose_ready): Simplify.\n+        (sched_extend_ready_list): Update.\n+\n 2014-05-22  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \n \tRemove IA64 speculation tweaking flags"}, {"sha": "24c6f82c4b2b55037d55941df598a76d9635d3d6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -26383,7 +26383,7 @@ static int min_insn_size (rtx);\n static void\n core2i7_first_cycle_multipass_filter_ready_try\n (const_ix86_first_cycle_multipass_data_t data,\n- char *ready_try, int n_ready, bool first_cycle_insn_p)\n+ signed char *ready_try, int n_ready, bool first_cycle_insn_p)\n {\n   while (n_ready--)\n     {\n@@ -26415,7 +26415,8 @@ core2i7_first_cycle_multipass_filter_ready_try\n \n /* Prepare for a new round of multipass lookahead scheduling.  */\n static void\n-core2i7_first_cycle_multipass_begin (void *_data, char *ready_try, int n_ready,\n+core2i7_first_cycle_multipass_begin (void *_data,\n+\t\t\t\t     signed char *ready_try, int n_ready,\n \t\t\t\t     bool first_cycle_insn_p)\n {\n   ix86_first_cycle_multipass_data_t data\n@@ -26436,7 +26437,8 @@ core2i7_first_cycle_multipass_begin (void *_data, char *ready_try, int n_ready,\n /* INSN is being issued in current solution.  Account for its impact on\n    the decoder model.  */\n static void\n-core2i7_first_cycle_multipass_issue (void *_data, char *ready_try, int n_ready,\n+core2i7_first_cycle_multipass_issue (void *_data,\n+\t\t\t\t     signed char *ready_try, int n_ready,\n \t\t\t\t     rtx insn, const void *_prev_data)\n {\n   ix86_first_cycle_multipass_data_t data\n@@ -26474,7 +26476,7 @@ core2i7_first_cycle_multipass_issue (void *_data, char *ready_try, int n_ready,\n /* Revert the effect on ready_try.  */\n static void\n core2i7_first_cycle_multipass_backtrack (const void *_data,\n-\t\t\t\t\t char *ready_try,\n+\t\t\t\t\t signed char *ready_try,\n \t\t\t\t\t int n_ready ATTRIBUTE_UNUSED)\n {\n   const_ix86_first_cycle_multipass_data_t data"}, {"sha": "d6e4cf4961f7c636f384d3b77402ad3035d35167", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -169,8 +169,7 @@ static int ia64_first_cycle_multipass_dfa_lookahead (void);\n static void ia64_dependencies_evaluation_hook (rtx, rtx);\n static void ia64_init_dfa_pre_cycle_insn (void);\n static rtx ia64_dfa_pre_cycle_insn (void);\n-static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx);\n-static bool ia64_first_cycle_multipass_dfa_lookahead_guard_spec (const_rtx);\n+static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx, int);\n static int ia64_dfa_new_cycle (FILE *, int, rtx, int, int, int *);\n static void ia64_h_i_d_extended (void);\n static void * ia64_alloc_sched_context (void);\n@@ -496,10 +495,6 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_SCHED_GEN_SPEC_CHECK\n #define TARGET_SCHED_GEN_SPEC_CHECK ia64_gen_spec_check\n \n-#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\\\n-  ia64_first_cycle_multipass_dfa_lookahead_guard_spec\n-\n #undef TARGET_SCHED_SKIP_RTX_P\n #define TARGET_SCHED_SKIP_RTX_P ia64_skip_rtx_p\n \n@@ -7531,32 +7526,28 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n-/* We are choosing insn from the ready queue.  Return nonzero if INSN\n+/* We are choosing insn from the ready queue.  Return zero if INSN\n    can be chosen.  */\n \n static int\n-ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn)\n+ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn, int ready_index)\n {\n   gcc_assert (insn && INSN_P (insn));\n-  return ((!reload_completed\n-\t   || !safe_group_barrier_needed (insn))\n-\t  && ia64_first_cycle_multipass_dfa_lookahead_guard_spec (insn)\n-\t  && (!mflag_sched_mem_insns_hard_limit\n-\t      || !is_load_p (insn)\n-\t      || mem_ops_in_group[current_cycle % 4] < ia64_max_memory_insns));\n-}\n \n-/* We are choosing insn from the ready queue.  Return nonzero if INSN\n-   can be chosen.  */\n+  /* Size of ALAT is 32.  As far as we perform conservative\n+     data speculation, we keep ALAT half-empty.  */\n+  if ((TODO_SPEC (insn) & BEGIN_DATA) && pending_data_specs >= 16)\n+    return ready_index == 0 ? -1 : 1;\n \n-static bool\n-ia64_first_cycle_multipass_dfa_lookahead_guard_spec (const_rtx insn)\n-{\n-  gcc_assert (insn  && INSN_P (insn));\n-  /* Size of ALAT is 32.  As far as we perform conservative data speculation,\n-     we keep ALAT half-empty.  */\n-  return (pending_data_specs < 16\n-\t  || !(TODO_SPEC (insn) & BEGIN_DATA));\n+  if (ready_index == 0)\n+    return 0;\n+\n+  if ((!reload_completed\n+       || !safe_group_barrier_needed (insn))\n+      && (!mflag_sched_mem_insns_hard_limit\n+\t  || !is_load_p (insn)\n+\t  || mem_ops_in_group[current_cycle % 4] < ia64_max_memory_insns))\n+    return 0;\n }\n \n /* The following variable value is pseudo-insn used by the DFA insn"}, {"sha": "f58ccd0936cda973bfb006652e5f8a02bf4c3fe7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -26796,22 +26796,25 @@ rs6000_use_sched_lookahead (void)\n     }\n }\n \n-/* We are choosing insn from the ready queue.  Return nonzero if INSN can be chosen.  */\n+/* We are choosing insn from the ready queue.  Return zero if INSN can be\n+   chosen.  */\n static int\n-rs6000_use_sched_lookahead_guard (rtx insn)\n+rs6000_use_sched_lookahead_guard (rtx insn, int ready_index)\n {\n+  if (ready_index == 0)\n+    return 0;\n+\n   if (rs6000_cpu_attr != CPU_CELL)\n-    return 1;\n+    return 0;\n \n-   if (insn == NULL_RTX || !INSN_P (insn))\n-     abort ();\n+  gcc_assert (insn != NULL_RTX && INSN_P (insn));\n \n   if (!reload_completed\n       || is_nonpipeline_insn (insn)\n       || is_microcoded_insn (insn))\n-    return 0;\n+    return 1;\n \n-  return 1;\n+  return 0;\n }\n \n /* Determine if PAT refers to memory. If so, set MEM_REF to the MEM rtx"}, {"sha": "05342b3d8acad94dedd1e5d539c95a31f67eb977", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -6716,26 +6716,32 @@ schedules to choose the best one.\n The default is no multipass scheduling.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx @var{insn})\n+@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx @var{insn}, int @var{ready_index})\n \n This hook controls what insns from the ready insn queue will be\n considered for the multipass insn scheduling.  If the hook returns\n-zero for @var{insn}, the insn will be not chosen to\n-be issued.\n+zero for @var{insn}, the insn will be considered in multipass scheduling.\n+Positive return values will remove @var{insn} from consideration on\n+the current round of multipass scheduling.\n+Negative return values will remove @var{insn} from consideration for given\n+number of cycles.\n+Backends should be careful about returning non-zero for highest priority\n+instruction at position 0 in the ready list.  @var{ready_index} is passed\n+to allow backends make correct judgements.\n \n The default is that any ready insns can be chosen to be issued.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN (void *@var{data}, char *@var{ready_try}, int @var{n_ready}, bool @var{first_cycle_insn_p})\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN (void *@var{data}, signed char *@var{ready_try}, int @var{n_ready}, bool @var{first_cycle_insn_p})\n This hook prepares the target backend for a new round of multipass\n scheduling.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE (void *@var{data}, char *@var{ready_try}, int @var{n_ready}, rtx @var{insn}, const void *@var{prev_data})\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE (void *@var{data}, signed char *@var{ready_try}, int @var{n_ready}, rtx @var{insn}, const void *@var{prev_data})\n This hook is called when multipass scheduling evaluates instruction INSN.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK (const void *@var{data}, char *@var{ready_try}, int @var{n_ready})\n+@deftypefn {Target Hook} void TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK (const void *@var{data}, signed char *@var{ready_try}, int @var{n_ready})\n This is called when multipass scheduling backtracks from evaluation of\n an instruction.\n @end deftypefn\n@@ -6843,19 +6849,6 @@ a pattern for a branchy check corresponding to a simple check denoted by\n @var{insn} should be generated.  In this case @var{label} can't be null.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC (const_rtx @var{insn})\n-This hook is used as a workaround for\n-@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD} not being\n-called on the first instruction of the ready list.  The hook is used to\n-discard speculative instructions that stand first in the ready list from\n-being scheduled on the current cycle.  If the hook returns @code{false},\n-@var{insn} will not be chosen to be issued.\n-For non-speculative instructions,\n-the hook should always return @code{true}.  For example, in the ia64 backend\n-the hook is used to cancel data speculative insns when the ALAT table\n-is nearly full.\n-@end deftypefn\n-\n @deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_FLAGS (struct spec_info_def *@var{spec_info})\n This hook is used by the insn scheduler to find out what features should be\n enabled/used."}, {"sha": "8a66842fd7712c1a84b330027501d19e021d1e6e", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -5019,8 +5019,6 @@ them: try the first ones in this list first.\n \n @hook TARGET_SCHED_GEN_SPEC_CHECK\n \n-@hook TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC\n-\n @hook TARGET_SCHED_SET_SCHED_FLAGS\n \n @hook TARGET_SCHED_SMS_RES_MII"}, {"sha": "0e1800a633260ebae4a98656a4a9c6c21025bc34", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -345,7 +345,7 @@ size_t dfa_state_size;\n \n /* The following array is used to find the best insn from ready when\n    the automaton pipeline interface is used.  */\n-char *ready_try = NULL;\n+signed char *ready_try = NULL;\n \n /* The ready list.  */\n struct ready_list ready = {NULL, 0, 0, 0, 0};\n@@ -5126,7 +5126,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n    If READY_TRY is non-zero then only print insns that max_issue\n    will consider.  */\n static void\n-debug_ready_list_1 (struct ready_list *ready, char *ready_try)\n+debug_ready_list_1 (struct ready_list *ready, signed char *ready_try)\n {\n   rtx *p;\n   int i;\n@@ -5566,10 +5566,9 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n     }\n   else\n     {\n-      /* Try to choose the better insn.  */\n+      /* Try to choose the best insn.  */\n       int index = 0, i;\n       rtx insn;\n-      ds_t ts;\n \n       insn = ready_element (ready, 0);\n       if (INSN_CODE (insn) < 0)\n@@ -5578,42 +5577,56 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n \t  return 0;\n \t}\n \n-      ts = TODO_SPEC (insn);\n-      if ((ts & SPECULATIVE)\n-\t  && (targetm.sched.first_cycle_multipass_dfa_lookahead_guard_spec\n-\t      && (!targetm.sched\n-\t\t  .first_cycle_multipass_dfa_lookahead_guard_spec (insn))))\n-\t/* Discard speculative instruction that stands first in the ready\n-\t   list.  */\n+      /* Filter the search space.  */\n+      for (i = 0; i < ready->n_ready; i++)\n \t{\n-\t  change_queue_index (insn, 1);\n-\t  return 1;\n-\t}\n+\t  ready_try[i] = 0;\n \n-      for (i = 0; i < ready->n_ready; i++)\n-\tready_try [i] = 0;\n+\t  insn = ready_element (ready, i);\n \n-      /* Let the target filter the search space.  */\n-      for (i = 1; i < ready->n_ready; i++)\n-\tif (!ready_try[i])\n-\t  {\n-\t    insn = ready_element (ready, i);\n-\n-\t    /* If this insn is recognizable we should have already\n-\t       recognized it earlier.\n-\t       ??? Not very clear where this is supposed to be done.\n-\t       See dep_cost_1.  */\n-\t    gcc_checking_assert (INSN_CODE (insn) >= 0\n-\t\t\t\t || recog_memoized (insn) < 0);\n-\n-\t    ready_try [i]\n-\t      = (/* INSN_CODE check can be omitted here as it is also done later\n-\t\t    in max_issue ().  */\n-\t\t INSN_CODE (insn) < 0\n-\t\t || (targetm.sched.first_cycle_multipass_dfa_lookahead_guard\n-\t\t     && !targetm.sched.first_cycle_multipass_dfa_lookahead_guard\n-\t\t     (insn)));\n-\t  }\n+\t  /* If this insn is recognizable we should have already\n+\t     recognized it earlier.\n+\t     ??? Not very clear where this is supposed to be done.\n+\t     See dep_cost_1.  */\n+\t  gcc_checking_assert (INSN_CODE (insn) >= 0\n+\t\t\t       || recog_memoized (insn) < 0);\n+\t  if (INSN_CODE (insn) < 0)\n+\t    {\n+\t      /* Non-recognized insns at position 0 are handled above.  */\n+\t      gcc_assert (i > 0);\n+\t      ready_try[i] = 1;\n+\t      continue;\n+\t    }\n+\n+\t  if (targetm.sched.first_cycle_multipass_dfa_lookahead_guard)\n+\t    {\n+\t      ready_try[i]\n+\t\t= (targetm.sched.first_cycle_multipass_dfa_lookahead_guard\n+\t\t    (insn, i));\n+\n+\t      if (ready_try[i] < 0)\n+\t\t/* Queue instruction for several cycles.\n+\t\t   We need to restart choose_ready as we have changed\n+\t\t   the ready list.  */\n+\t\t{\n+\t\t  change_queue_index (insn, -ready_try[i]);\n+\t\t  return 1;\n+\t\t}\n+\n+\t      /* Make sure that we didn't end up with 0'th insn filtered out.\n+\t\t Don't be tempted to make life easier for backends and just\n+\t\t requeue 0'th insn if (ready_try[0] == 0) and restart\n+\t\t choose_ready.  Backends should be very considerate about\n+\t\t requeueing instructions -- especially the highest priority\n+\t\t one at position 0.  */\n+\t      gcc_assert (ready_try[i] == 0 || i > 0);\n+\t      if (ready_try[i])\n+\t\tcontinue;\n+\t    }\n+\n+\t  gcc_assert (ready_try[i] == 0);\n+\t  /* INSN made it through the scrutiny of filters!  */\n+\t}\n \n       if (max_issue (ready, 1, curr_state, first_cycle_insn_p, &index) == 0)\n \t{\n@@ -7193,8 +7206,9 @@ sched_extend_ready_list (int new_sched_ready_n_insns)\n \n   gcc_assert (new_sched_ready_n_insns >= sched_ready_n_insns);\n \n-  ready_try = (char *) xrecalloc (ready_try, new_sched_ready_n_insns,\n-                                  sched_ready_n_insns, sizeof (*ready_try));\n+  ready_try = (signed char *) xrecalloc (ready_try, new_sched_ready_n_insns,\n+\t\t\t\t\t sched_ready_n_insns,\n+\t\t\t\t\t sizeof (*ready_try));\n \n   /* We allocate +1 element to save initial state in the choice_stack[0]\n      entry.  */"}, {"sha": "ffe618cc67dc3efa67ba5895d3828e559771080a", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -170,7 +170,7 @@ struct ready_list\n   int n_debug;\n };\n \n-extern char *ready_try;\n+extern signed char *ready_try;\n extern struct ready_list ready;\n \n extern int max_issue (struct ready_list *, int, state_t, bool, int *);"}, {"sha": "0c864acd7f79e9f66b8a30457c46259ab36e7809", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -4225,7 +4225,7 @@ invoke_dfa_lookahead_guard (void)\n       if (! have_hook || i == 0)\n         r = 0;\n       else\n-        r = !targetm.sched.first_cycle_multipass_dfa_lookahead_guard (insn);\n+        r = targetm.sched.first_cycle_multipass_dfa_lookahead_guard (insn, i);\n \n       gcc_assert (INSN_CODE (insn) >= 0);\n "}, {"sha": "5fe2e823e2757db0926ba5fa6eb6165cdb712945", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4960a0cb385939bfebf5fb158d60a200d1c3e19e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=4960a0cb385939bfebf5fb158d60a200d1c3e19e", "patch": "@@ -1174,11 +1174,17 @@ DEFHOOK\n  \"\\n\\\n This hook controls what insns from the ready insn queue will be\\n\\\n considered for the multipass insn scheduling.  If the hook returns\\n\\\n-zero for @var{insn}, the insn will be not chosen to\\n\\\n-be issued.\\n\\\n+zero for @var{insn}, the insn will be considered in multipass scheduling.\\n\\\n+Positive return values will remove @var{insn} from consideration on\\n\\\n+the current round of multipass scheduling.\\n\\\n+Negative return values will remove @var{insn} from consideration for given\\n\\\n+number of cycles.\\n\\\n+Backends should be careful about returning non-zero for highest priority\\n\\\n+instruction at position 0 in the ready list.  @var{ready_index} is passed\\n\\\n+to allow backends make correct judgements.\\n\\\n \\n\\\n The default is that any ready insns can be chosen to be issued.\",\n- int, (rtx insn), NULL)\n+ int, (rtx insn, int ready_index), NULL)\n \n /* This hook prepares the target for a new round of multipass\n    scheduling.\n@@ -1193,7 +1199,7 @@ DEFHOOK\n (first_cycle_multipass_begin,\n  \"This hook prepares the target backend for a new round of multipass\\n\\\n scheduling.\",\n- void, (void *data, char *ready_try, int n_ready, bool first_cycle_insn_p),\n+ void, (void *data, signed char *ready_try, int n_ready, bool first_cycle_insn_p),\n  NULL)\n \n /* This hook is called when multipass scheduling evaluates instruction INSN.\n@@ -1209,7 +1215,7 @@ scheduling.\",\n DEFHOOK\n (first_cycle_multipass_issue,\n  \"This hook is called when multipass scheduling evaluates instruction INSN.\",\n- void, (void *data, char *ready_try, int n_ready, rtx insn,\n+ void, (void *data, signed char *ready_try, int n_ready, rtx insn,\n \tconst void *prev_data), NULL)\n \n /* This hook is called when multipass scheduling backtracks from evaluation of\n@@ -1225,7 +1231,7 @@ DEFHOOK\n (first_cycle_multipass_backtrack,\n  \"This is called when multipass scheduling backtracks from evaluation of\\n\\\n an instruction.\",\n- void, (const void *data, char *ready_try, int n_ready), NULL)\n+ void, (const void *data, signed char *ready_try, int n_ready), NULL)\n \n /* This hook notifies the target about the result of the concluded current\n    round of multipass scheduling.\n@@ -1421,26 +1427,6 @@ a pattern for a branchy check corresponding to a simple check denoted by\\n\\\n @var{insn} should be generated.  In this case @var{label} can't be null.\",\n  rtx, (rtx insn, rtx label, unsigned int ds), NULL)\n \n-/* The following member value is a pointer to a function controlling\n-   what insns from the ready insn queue will be considered for the\n-   multipass insn scheduling.  If the hook returns zero for the insn\n-   passed as the parameter, the insn will not be chosen to be\n-   issued.  This hook is used to discard speculative instructions,\n-   that stand at the first position of the ready list.  */\n-DEFHOOK\n-(first_cycle_multipass_dfa_lookahead_guard_spec,\n- \"This hook is used as a workaround for\\n\\\n-@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD} not being\\n\\\n-called on the first instruction of the ready list.  The hook is used to\\n\\\n-discard speculative instructions that stand first in the ready list from\\n\\\n-being scheduled on the current cycle.  If the hook returns @code{false},\\n\\\n-@var{insn} will not be chosen to be issued.\\n\\\n-For non-speculative instructions,\\n\\\n-the hook should always return @code{true}.  For example, in the ia64 backend\\n\\\n-the hook is used to cancel data speculative insns when the ALAT table\\n\\\n-is nearly full.\",\n- bool, (const_rtx insn), NULL)\n-\n /* The following member value is a pointer to a function that provides\n    information about the speculation capabilities of the target.\n    The parameter is a pointer to spec_info variable.  */"}]}