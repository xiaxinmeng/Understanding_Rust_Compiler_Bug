{"sha": "82cb25749bc242b88c5ca61365452ebba48fd307", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjYjI1NzQ5YmMyNDJiODhjNWNhNjEzNjU0NTJlYmJhNDhmZDMwNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-08-16T14:50:31Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-08-16T14:50:31Z"}, "message": "indirect_array.h: Trivial formatting fixes.\n\n2004-08-16  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/indirect_array.h: Trivial formatting fixes.\n\t* include/bits/valarray_after.h: Likewise.\n\t* include/bits/valarray_array.h: Likewise.\n\t* src/valarray-inst.cc: Likewise.\n\nFrom-SVN: r86056", "tree": {"sha": "a6e75da9d39200002fdf788792bb646c3e36a7e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6e75da9d39200002fdf788792bb646c3e36a7e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82cb25749bc242b88c5ca61365452ebba48fd307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82cb25749bc242b88c5ca61365452ebba48fd307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82cb25749bc242b88c5ca61365452ebba48fd307", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82cb25749bc242b88c5ca61365452ebba48fd307/comments", "author": null, "committer": null, "parents": [{"sha": "8242fd2d6e386da34410a2bdbf82fc24a68b94fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8242fd2d6e386da34410a2bdbf82fc24a68b94fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8242fd2d6e386da34410a2bdbf82fc24a68b94fd"}], "stats": {"total": 743, "additions": 375, "deletions": 368}, "files": [{"sha": "bc22eec0113bce43994eb0ca772a5c27caf9508e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=82cb25749bc242b88c5ca61365452ebba48fd307", "patch": "@@ -1,3 +1,10 @@\n+2004-08-16  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/indirect_array.h: Trivial formatting fixes.\n+\t* include/bits/valarray_after.h: Likewise.\n+\t* include/bits/valarray_array.h: Likewise.\n+\t* src/valarray-inst.cc: Likewise.\n+\n 2004-08-15  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/27_io/basic_stringstream/rdbuf/char/2832.cc: Remove junk."}, {"sha": "4c90753a2cad0372300e2f5c910b24be17f2d461", "filename": "libstdc++-v3/include/bits/indirect_array.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h?ref=82cb25749bc242b88c5ca61365452ebba48fd307", "patch": "@@ -46,10 +46,10 @@ namespace std\n    *  @brief  Reference to arbitrary subset of an array.\n    *\n    *  An indirect_array is a reference to the actual elements of an array\n-   *  specified by an ordered array of indices.  The way to get an indirect_array is to\n-   *  call operator[](valarray<size_t>) on a valarray.  The returned\n-   *  indirect_array then permits carrying operations out on the referenced\n-   *  subset of elements in the original valarray.\n+   *  specified by an ordered array of indices.  The way to get an\n+   *  indirect_array is to call operator[](valarray<size_t>) on a valarray.\n+   *  The returned indirect_array then permits carrying operations out on the\n+   *  referenced subset of elements in the original valarray.\n    *\n    *  For example, if an indirect_array is obtained using the array (4,2,0) as\n    *  an argument, and then assigned to an array containing (1,2,3), then the\n@@ -143,34 +143,35 @@ namespace std\n     : _M_sz(__a._M_sz), _M_index(__a._M_index), _M_array(__a._M_array) {}\n \n   template<typename _Tp>\n-     inline\n-     indirect_array<_Tp>::indirect_array(_Array<_Tp> __a, size_t __s,\n-\t\t\t\t\t _Array<size_t> __i)\n-     : _M_sz(__s), _M_index(__i), _M_array(__a) {}\n+    inline\n+    indirect_array<_Tp>::indirect_array(_Array<_Tp> __a, size_t __s,\n+\t\t\t\t\t_Array<size_t> __i)\n+    : _M_sz(__s), _M_index(__i), _M_array(__a) {}\n \n   template<typename _Tp>\n-     inline indirect_array<_Tp>&\n-     indirect_array<_Tp>::operator=(const indirect_array<_Tp>& __a)\n-     {\n-       std::__valarray_copy(__a._M_array, _M_sz, __a._M_index, _M_array, _M_index);\n-       return *this;\n-     }\n+    inline indirect_array<_Tp>&\n+    indirect_array<_Tp>::operator=(const indirect_array<_Tp>& __a)\n+    {\n+      std::__valarray_copy(__a._M_array, _M_sz, __a._M_index, _M_array,\n+\t\t\t   _M_index);\n+      return *this;\n+    }\n \n   template<typename _Tp>\n-     inline void\n-     indirect_array<_Tp>::operator=(const _Tp& __t) const\n-     { std::__valarray_fill(_M_array, _M_index, _M_sz, __t); }\n+    inline void\n+    indirect_array<_Tp>::operator=(const _Tp& __t) const\n+    { std::__valarray_fill(_M_array, _M_index, _M_sz, __t); }\n \n   template<typename _Tp>\n-     inline void\n-     indirect_array<_Tp>::operator=(const valarray<_Tp>& __v) const\n-     { std::__valarray_copy(_Array<_Tp>(__v), _M_sz, _M_array, _M_index); }\n+    inline void\n+    indirect_array<_Tp>::operator=(const valarray<_Tp>& __v) const\n+    { std::__valarray_copy(_Array<_Tp>(__v), _M_sz, _M_array, _M_index); }\n \n   template<typename _Tp>\n-     template<class _Dom>\n-       inline void\n-       indirect_array<_Tp>::operator=(const _Expr<_Dom,_Tp>& __e) const\n-       { std::__valarray_copy(__e, _M_sz, _M_array, _M_index); }\n+    template<class _Dom>\n+      inline void\n+      indirect_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const\n+      { std::__valarray_copy(__e, _M_sz, _M_array, _M_index); }\n \n #undef _DEFINE_VALARRAY_OPERATOR\n #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)\t\t\t\t\\"}, {"sha": "d3482e4cd04af729da503c119cf25dacb743d888", "filename": "libstdc++-v3/include/bits/valarray_after.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h?ref=82cb25749bc242b88c5ca61365452ebba48fd307", "patch": "@@ -127,7 +127,9 @@ namespace std\n       operator[] (size_t __i) const\n       { return _M_expr[_M_index[__i]]; }\n       \n-      size_t size() const { return _M_index.size(); }\n+      size_t\n+      size() const\n+      { return _M_index.size(); }\n \n     private:\n       const _Dom&\t      _M_expr;"}, {"sha": "f46bd0828b3b38446f6283e74628b1ac92085866", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "modified", "additions": 337, "deletions": 339, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=82cb25749bc242b88c5ca61365452ebba48fd307", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- internal _Array helper class.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2003\n+// Copyright (C) 1997, 1998, 1999, 2000, 2003, 2004\n //  Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -58,12 +58,12 @@ namespace std\n   { return operator new(__n); }\n \n   template<typename _Tp>\n-     inline _Tp*__restrict__\n-     __valarray_get_storage(size_t __n)\n-     {\n-       return static_cast<_Tp*__restrict__>\n-         (std::__valarray_get_memory(__n * sizeof(_Tp)));\n-     }\n+    inline _Tp*__restrict__\n+    __valarray_get_storage(size_t __n)\n+    {\n+      return static_cast<_Tp*__restrict__>\n+\t(std::__valarray_get_memory(__n * sizeof(_Tp)));\n+    }\n \n   // Return memory to the system\n   inline void\n@@ -73,280 +73,279 @@ namespace std\n   // Turn a raw-memory into an array of _Tp filled with _Tp()\n   // This is required in 'valarray<T> v(n);'\n   template<typename _Tp, bool>\n-     struct _Array_default_ctor\n-     {\n-       // Please note that this isn't exception safe.  But\n-       // valarrays aren't required to be exception safe.\n-       inline static void\n-       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-       {\n-\t while (__b != __e)\n-\t   new(__b++) _Tp();\n-       }\n-     };\n-\n-  template<typename _Tp>\n-     struct _Array_default_ctor<_Tp, true>\n-     {\n-       // For fundamental types, it suffices to say 'memset()'\n-       inline static void\n-       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-       { std::memset(__b, 0, (__e - __b) * sizeof(_Tp)); }\n-     };\n-\n-  template<typename _Tp>\n-     inline void\n-     __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-     {\n-       _Array_default_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n-         _S_do_it(__b, __e);\n-     }\n+    struct _Array_default_ctor\n+    {\n+      // Please note that this isn't exception safe.  But\n+      // valarrays aren't required to be exception safe.\n+      inline static void\n+      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+      {\n+\twhile (__b != __e)\n+\t  new(__b++) _Tp();\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct _Array_default_ctor<_Tp, true>\n+    {\n+      // For fundamental types, it suffices to say 'memset()'\n+      inline static void\n+      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+      { std::memset(__b, 0, (__e - __b) * sizeof(_Tp)); }\n+    };\n+\n+  template<typename _Tp>\n+    inline void\n+    __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+    {\n+      _Array_default_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+\t_S_do_it(__b, __e);\n+    }\n \n   // Turn a raw-memory into an array of _Tp filled with __t\n   // This is the required in valarray<T> v(n, t).  Also\n   // used in valarray<>::resize().\n   template<typename _Tp, bool>\n-     struct _Array_init_ctor\n-     {\n-       // Please note that this isn't exception safe.  But\n-       // valarrays aren't required to be exception safe.\n-       inline static void\n-       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)\n-       {\n-\t while (__b != __e)\n-\t   new(__b++) _Tp(__t);\n-       }\n-     };\n-\n-  template<typename _Tp>\n-     struct _Array_init_ctor<_Tp, true>\n-     {\n-       inline static void\n-       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e,  const _Tp __t)\n-       {\n-\t while (__b != __e)\n-\t   *__b++ = __t;\n-       }\n-     };\n-\n-  template<typename _Tp>\n-     inline void\n-     __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n-                               const _Tp __t)\n-     {\n-       _Array_init_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n-         _S_do_it(__b, __e, __t);\n-     }\n+    struct _Array_init_ctor\n+    {\n+      // Please note that this isn't exception safe.  But\n+      // valarrays aren't required to be exception safe.\n+      inline static void\n+      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)\n+      {\n+\twhile (__b != __e)\n+\t  new(__b++) _Tp(__t);\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct _Array_init_ctor<_Tp, true>\n+    {\n+      inline static void\n+      _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e,  const _Tp __t)\n+      {\n+\twhile (__b != __e)\n+\t  *__b++ = __t;\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    inline void\n+    __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n+\t\t\t      const _Tp __t)\n+    {\n+      _Array_init_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+\t_S_do_it(__b, __e, __t);\n+    }\n \n   //\n   // copy-construct raw array [__o, *) from plain array [__b, __e)\n   // We can't just say 'memcpy()'\n   //\n   template<typename _Tp, bool>\n-     struct _Array_copy_ctor\n-     {\n-       // Please note that this isn't exception safe.  But\n-       // valarrays aren't required to be exception safe.\n-       inline static void\n-       _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n-                _Tp* __restrict__ __o)\n-       {\n-\t while (__b != __e)\n-\t   new(__o++) _Tp(*__b++);\n-       }\n-     };\n-\n-  template<typename _Tp>\n-     struct _Array_copy_ctor<_Tp, true>\n-     {\n-       inline static void\n-       _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n-                _Tp* __restrict__ __o)\n-       { std::memcpy(__o, __b, (__e - __b)*sizeof(_Tp)); }\n-     };\n-\n-  template<typename _Tp>\n-     inline void\n-     __valarray_copy_construct(const _Tp* __restrict__ __b,\n-                               const _Tp* __restrict__ __e,\n-                               _Tp* __restrict__ __o)\n-     {\n-       _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n-         _S_do_it(__b, __e, __o);\n-     }\n+    struct _Array_copy_ctor\n+    {\n+      // Please note that this isn't exception safe.  But\n+      // valarrays aren't required to be exception safe.\n+      inline static void\n+      _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n+\t       _Tp* __restrict__ __o)\n+      {\n+\twhile (__b != __e)\n+\t  new(__o++) _Tp(*__b++);\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct _Array_copy_ctor<_Tp, true>\n+    {\n+      inline static void\n+      _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n+\t       _Tp* __restrict__ __o)\n+      { std::memcpy(__o, __b, (__e - __b)*sizeof(_Tp)); }\n+    };\n+\n+  template<typename _Tp>\n+    inline void\n+    __valarray_copy_construct(const _Tp* __restrict__ __b,\n+\t\t\t      const _Tp* __restrict__ __e,\n+\t\t\t      _Tp* __restrict__ __o)\n+    {\n+      _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+\t_S_do_it(__b, __e, __o);\n+    }\n \n   // copy-construct raw array [__o, *) from strided array __a[<__n : __s>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n-                                size_t __s, _Tp* __restrict__ __o)\n-     {\n-       if (__is_fundamental<_Tp>::_M_type)\n-         while (__n--)\n-\t   {\n-\t     *__o++ = *__a;\n-\t     __a += __s;\n-\t   }\n-       else\n-         while (__n--)\n-\t   {\n-\t     new(__o++) _Tp(*__a);\n-\t     __a += __s;\n-\t   }\n-     }\n+    inline void\n+    __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n+\t\t\t       size_t __s, _Tp* __restrict__ __o)\n+    {\n+      if (__is_fundamental<_Tp>::_M_type)\n+\twhile (__n--)\n+\t  {\n+\t    *__o++ = *__a;\n+\t    __a += __s;\n+\t  }\n+      else\n+\twhile (__n--)\n+\t  {\n+\t    new(__o++) _Tp(*__a);\n+\t    __a += __s;\n+\t  }\n+    }\n \n   // copy-construct raw array [__o, *) from indexed array __a[__i[<__n>]]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy_construct (const _Tp* __restrict__ __a,\n-                                const size_t* __restrict__ __i,\n-                                _Tp* __restrict__ __o, size_t __n)\n-     {\n-       if (__is_fundamental<_Tp>::_M_type)\n-         while (__n--)\n-\t   *__o++ = __a[*__i++];\n-       else\n-         while (__n--)\n-\t   new (__o++) _Tp(__a[*__i++]);\n-     }\n+    inline void\n+    __valarray_copy_construct (const _Tp* __restrict__ __a,\n+\t\t\t       const size_t* __restrict__ __i,\n+\t\t\t       _Tp* __restrict__ __o, size_t __n)\n+    {\n+      if (__is_fundamental<_Tp>::_M_type)\n+\twhile (__n--)\n+\t  *__o++ = __a[*__i++];\n+      else\n+\twhile (__n--)\n+\t  new (__o++) _Tp(__a[*__i++]);\n+    }\n \n   // Do the necessary cleanup when we're done with arrays.\n   template<typename _Tp>\n-     inline void\n-     __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-     {\n-       if (!__is_fundamental<_Tp>::_M_type)\n-         while (__b != __e)\n-\t   {\n-\t     __b->~_Tp();\n-\t     ++__b;\n-\t   }\n-     }\n+    inline void\n+    __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+    {\n+      if (!__is_fundamental<_Tp>::_M_type)\n+\twhile (__b != __e)\n+\t  {\n+\t    __b->~_Tp();\n+\t    ++__b;\n+\t  }\n+    }\n \n   // Fill a plain array __a[<__n>] with __t\n   template<typename _Tp>\n-     inline void\n-     __valarray_fill(_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n-     {\n-       while (__n--)\n-\t *__a++ = __t;\n-     }\n-\n+    inline void\n+    __valarray_fill(_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n+    {\n+      while (__n--)\n+\t*__a++ = __t;\n+    }\n+  \n   // fill strided array __a[<__n-1 : __s>] with __t\n   template<typename _Tp>\n-     inline void\n-     __valarray_fill(_Tp* __restrict__ __a, size_t __n,\n-\t\t     size_t __s, const _Tp& __t)\n-     {\n-       for (size_t __i = 0; __i < __n; ++__i, __a += __s)\n-\t *__a = __t;\n-     }\n+    inline void\n+    __valarray_fill(_Tp* __restrict__ __a, size_t __n,\n+\t\t    size_t __s, const _Tp& __t)\n+    { \n+      for (size_t __i = 0; __i < __n; ++__i, __a += __s)\n+\t*__a = __t;\n+    }\n \n   // fill indir   ect array __a[__i[<__n>]] with __i\n   template<typename _Tp>\n-     inline void\n-     __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n-                     size_t __n, const _Tp& __t)\n-     {\n-       for (size_t __j = 0; __j < __n; ++__j, ++__i)\n-\t __a[*__i] = __t;\n-     }\n-\n+    inline void\n+    __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n+\t\t    size_t __n, const _Tp& __t)\n+    {\n+      for (size_t __j = 0; __j < __n; ++__j, ++__i)\n+\t__a[*__i] = __t;\n+    }\n+  \n   // copy plain array __a[<__n>] in __b[<__n>]\n   // For non-fundamental types, it is wrong to say 'memcpy()'\n   template<typename _Tp, bool>\n-     struct _Array_copier\n-     {\n-       inline static void\n-       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n-       {\n-\t while(__n--)\n-\t   *__b++ = *__a++;\n-       }\n-     };\n-\n-  template<typename _Tp>\n-     struct _Array_copier<_Tp, true>\n-     {\n-       inline static void\n-       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n-       { std::memcpy (__b, __a, __n * sizeof (_Tp)); }\n-     };\n+    struct _Array_copier\n+    {\n+      inline static void\n+      _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n+      {\n+\twhile(__n--)\n+\t  *__b++ = *__a++;\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct _Array_copier<_Tp, true>\n+    {\n+      inline static void\n+      _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n+      { std::memcpy (__b, __a, __n * sizeof (_Tp)); }\n+    };\n \n   // Copy a plain array __a[<__n>] into a play array __b[<>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n-\t\t     _Tp* __restrict__ __b)\n-     {\n-       _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n-         _S_do_it(__a, __n, __b);\n-     }\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n+\t\t    _Tp* __restrict__ __b)\n+    {\n+      _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n+\t_S_do_it(__a, __n, __b);\n+    }\n \n   // Copy strided array __a[<__n : __s>] in plain __b[<__n>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(const _Tp* __restrict__ __a, size_t __n, size_t __s,\n-\t\t     _Tp* __restrict__ __b)\n-     {\n-       for (size_t __i = 0; __i < __n; ++__i, ++__b, __a += __s)\n-\t *__b = *__a;\n-     }\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __a, size_t __n, size_t __s,\n+\t\t    _Tp* __restrict__ __b)\n+    {\n+      for (size_t __i = 0; __i < __n; ++__i, ++__b, __a += __s)\n+\t*__b = *__a;\n+    }\n \n   // Copy a plain array  __a[<__n>] into a strided array __b[<__n : __s>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(const _Tp* __restrict__ __a, _Tp* __restrict__ __b,\n-\t\t     size_t __n, size_t __s)\n-     {\n-       for (size_t __i = 0; __i < __n; ++__i, ++__a, __b += __s)\n-\t *__b = *__a;\n-     }\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __a, _Tp* __restrict__ __b,\n+\t\t    size_t __n, size_t __s)\n+    {\n+      for (size_t __i = 0; __i < __n; ++__i, ++__a, __b += __s)\n+\t*__b = *__a;\n+    }\n \n   // Copy strided array __src[<__n : __s1>] into another\n   // strided array __dst[< : __s2>].  Their sizes must match.\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(const _Tp* __restrict__ __src, size_t __n, size_t __s1,\n-                     _Tp* __restrict__ __dst, size_t __s2)\n-     {\n-       for (size_t __i = 0; __i < __n; ++__i)\n-         __dst[__i * __s2] = __src[__i * __s1];\n-     }\n-\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __src, size_t __n, size_t __s1,\n+\t\t    _Tp* __restrict__ __dst, size_t __s2)\n+    {\n+      for (size_t __i = 0; __i < __n; ++__i)\n+\t__dst[__i * __s2] = __src[__i * __s1];\n+    }\n \n   // Copy an indexed array __a[__i[<__n>]] in plain array __b[<__n>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy (const _Tp* __restrict__ __a,\n-                      const size_t* __restrict__ __i,\n-                      _Tp* __restrict__ __b, size_t __n)\n-     {\n-       for (size_t __j = 0; __j < __n; ++__j, ++__b, ++__i)\n-\t *__b = __a[*__i];\n-     }\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __a,\n+\t\t    const size_t* __restrict__ __i,\n+\t\t    _Tp* __restrict__ __b, size_t __n)\n+    {\n+      for (size_t __j = 0; __j < __n; ++__j, ++__b, ++__i)\n+\t*__b = __a[*__i];\n+    }\n \n   // Copy a plain array __a[<__n>] in an indexed array __b[__i[<__n>]]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n-                      _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n-     {\n-       for (size_t __j = 0; __j < __n; ++__j, ++__a, ++__i)\n-         __b[*__i] = *__a;\n-     }\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n+\t\t    _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n+    {\n+      for (size_t __j = 0; __j < __n; ++__j, ++__a, ++__i)\n+\t__b[*__i] = *__a;\n+    }\n \n   // Copy the __n first elements of an indexed array __src[<__i>] into\n   // another indexed array __dst[<__j>].\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(const _Tp* __restrict__ __src, size_t __n,\n-                     const size_t* __restrict__ __i,\n-                     _Tp* __restrict__ __dst, const size_t* __restrict__ __j)\n-     {\n-       for (size_t __k = 0; __k < __n; ++__k)\n-         __dst[*__j++] = __src[*__i++];\n-     }\n+    inline void\n+    __valarray_copy(const _Tp* __restrict__ __src, size_t __n,\n+\t\t    const size_t* __restrict__ __i,\n+\t\t    _Tp* __restrict__ __dst, const size_t* __restrict__ __j)\n+    {\n+      for (size_t __k = 0; __k < __n; ++__k)\n+\t__dst[*__j++] = __src[*__i++];\n+    }\n \n   //\n   // Compute the sum of elements in range [__f, __l)\n@@ -356,59 +355,59 @@ namespace std\n   // algorithm.\n   //\n   template<typename _Tp>\n-     inline _Tp\n-     __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)\n-     {\n-       _Tp __r = _Tp();\n-       while (__f != __l)\n-\t __r += *__f++;\n-       return __r;\n-     }\n+    inline _Tp\n+    __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)\n+    {\n+      _Tp __r = _Tp();\n+      while (__f != __l)\n+\t__r += *__f++;\n+      return __r;\n+    }\n \n   // Compute the product of all elements in range [__f, __l)\n   template<typename _Tp>\n-     inline _Tp\n-     __valarray_product(const _Tp* __restrict__ __f,\n-                        const _Tp* __restrict__ __l)\n-     {\n-       _Tp __r = _Tp(1);\n-       while (__f != __l)\n-\t __r = __r * *__f++;\n-       return __r;\n-     }\n+    inline _Tp\n+    __valarray_product(const _Tp* __restrict__ __f,\n+\t\t       const _Tp* __restrict__ __l)\n+    {\n+      _Tp __r = _Tp(1);\n+      while (__f != __l)\n+\t__r = __r * *__f++;\n+      return __r;\n+    }\n \n   // Compute the min/max of an array-expression\n   template<typename _Ta>\n-     inline typename _Ta::value_type\n-     __valarray_min(const _Ta& __a)\n-     {\n-       size_t __s = __a.size();\n-       typedef typename _Ta::value_type _Value_type;\n-       _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n-       for (size_t __i = 1; __i < __s; ++__i)\n-         {\n-           _Value_type __t = __a[__i];\n-           if (__t < __r)\n-             __r = __t;\n-         }\n-       return __r;\n-     }\n+    inline typename _Ta::value_type\n+    __valarray_min(const _Ta& __a)\n+    {\n+      size_t __s = __a.size();\n+      typedef typename _Ta::value_type _Value_type;\n+      _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n+      for (size_t __i = 1; __i < __s; ++__i)\n+\t{\n+\t  _Value_type __t = __a[__i];\n+\t  if (__t < __r)\n+\t    __r = __t;\n+\t}\n+      return __r;\n+    }\n \n   template<typename _Ta>\n-     inline typename _Ta::value_type\n-     __valarray_max(const _Ta& __a)\n-     {\n-       size_t __s = __a.size();\n-       typedef typename _Ta::value_type _Value_type;\n-       _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n-       for (size_t __i = 1; __i < __s; ++__i)\n-         {\n-           _Value_type __t = __a[__i];\n-           if (__t > __r)\n-             __r = __t;\n-         }\n-       return __r;\n-     }\n+    inline typename _Ta::value_type\n+    __valarray_max(const _Ta& __a)\n+    {\n+      size_t __s = __a.size();\n+      typedef typename _Ta::value_type _Value_type;\n+      _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n+      for (size_t __i = 1; __i < __s; ++__i)\n+\t{\n+\t  _Value_type __t = __a[__i];\n+\t  if (__t > __r)\n+\t    __r = __t;\n+\t}\n+      return __r;\n+    }\n \n   //\n   // Helper class _Array, first layer of valarray abstraction.\n@@ -417,112 +416,111 @@ namespace std\n   //\n \n   template<typename _Tp>\n-     struct _Array\n-     {\n-       explicit _Array(size_t);\n-       explicit _Array(_Tp* const __restrict__);\n-       explicit _Array(const valarray<_Tp>&);\n-       _Array(const _Tp* __restrict__, size_t);\n-\n-       _Tp* begin() const;\n-\n-       _Tp* const __restrict__ _M_data;\n-     };\n+    struct _Array\n+    {\n+      explicit _Array(size_t);\n+      explicit _Array(_Tp* const __restrict__);\n+      explicit _Array(const valarray<_Tp>&);\n+      _Array(const _Tp* __restrict__, size_t);\n+      \n+      _Tp* begin() const;\n+      \n+      _Tp* const __restrict__ _M_data;\n+    };\n \n   template<typename _Tp>\n-     inline void\n-     __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)\n-     { std::__valarray_fill(__a._M_data, __n, __t); }\n+    inline void\n+    __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)\n+    { std::__valarray_fill(__a._M_data, __n, __t); }\n \n   template<typename _Tp>\n-     inline void\n-     __valarray_fill(_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n-     { std::__valarray_fill(__a._M_data, __n, __s, __t); }\n+    inline void\n+    __valarray_fill(_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n+    { std::__valarray_fill(__a._M_data, __n, __s, __t); }\n \n   template<typename _Tp>\n-     inline void\n-     __valarray_fill(_Array<_Tp> __a, _Array<size_t> __i,\n-\t\t     size_t __n, const _Tp& __t)\n-     { std::__valarray_fill(__a._M_data, __i._M_data, __n, __t); }\n+    inline void\n+    __valarray_fill(_Array<_Tp> __a, _Array<size_t> __i,\n+\t\t    size_t __n, const _Tp& __t)\n+    { std::__valarray_fill(__a._M_data, __i._M_data, __n, __t); }\n \n   // Copy a plain array __a[<__n>] into a play array __b[<>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\n-     { std::__valarray_copy(__a._M_data, __n, __b._M_data); }\n+    inline void\n+    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\n+    { std::__valarray_copy(__a._M_data, __n, __b._M_data); }\n \n   // Copy strided array __a[<__n : __s>] in plain __b[<__n>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)\n-     { std::__valarray_copy(__a._M_data, __n, __s, __b._M_data); }\n+    inline void\n+    __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)\n+    { std::__valarray_copy(__a._M_data, __n, __s, __b._M_data); }\n \n   // Copy a plain array  __a[<__n>] into a strided array __b[<__n : __s>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)\n-     { __valarray_copy(__a._M_data, __b._M_data, __n, __s); }\n+    inline void\n+    __valarray_copy(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)\n+    { __valarray_copy(__a._M_data, __b._M_data, __n, __s); }\n \n   // Copy strided array __src[<__n : __s1>] into another\n   // strided array __dst[< : __s2>].  Their sizes must match.\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s1,\n-                     _Array<_Tp> __b, size_t __s2)\n-     { std::__valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2); }\n-\n+    inline void\n+    __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s1,\n+                    _Array<_Tp> __b, size_t __s2)\n+    { std::__valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2); }\n \n   // Copy an indexed array __a[__i[<__n>]] in plain array __b[<__n>]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __a, _Array<size_t> __i,\n-\t\t     _Array<_Tp> __b, size_t __n)\n-     { std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n); }\n+    inline void\n+    __valarray_copy(_Array<_Tp> __a, _Array<size_t> __i,\n+\t\t    _Array<_Tp> __b, size_t __n)\n+    { std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n); }\n \n   // Copy a plain array __a[<__n>] in an indexed array __b[__i[<__n>]]\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,\n-\t\t     _Array<size_t> __i)\n-     { std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data); }\n+    inline void\n+    __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,\n+\t\t    _Array<size_t> __i)\n+    { std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data); }\n \n   // Copy the __n first elements of an indexed array __src[<__i>] into\n   // another indexed array __dst[<__j>].\n   template<typename _Tp>\n-     inline void\n-     __valarray_copy(_Array<_Tp> __src, size_t __n, _Array<size_t> __i,\n-                     _Array<_Tp> __dst, _Array<size_t> __j)\n-     {\n-       std::__valarray_copy(__src._M_data, __n, __i._M_data,\n-\t\t\t    __dst._M_data, __j._M_data);\n-     }\n+    inline void\n+    __valarray_copy(_Array<_Tp> __src, size_t __n, _Array<size_t> __i,\n+                    _Array<_Tp> __dst, _Array<size_t> __j)\n+    {\n+      std::__valarray_copy(__src._M_data, __n, __i._M_data,\n+\t\t    __dst._M_data, __j._M_data);\n+    }\n \n   template<typename _Tp>\n-     inline\n-     _Array<_Tp>::_Array(size_t __n)\n-     : _M_data(__valarray_get_storage<_Tp>(__n))\n-     { std::__valarray_default_construct(_M_data, _M_data + __n); }\n+    inline\n+    _Array<_Tp>::_Array(size_t __n)\n+    : _M_data(__valarray_get_storage<_Tp>(__n))\n+    { std::__valarray_default_construct(_M_data, _M_data + __n); }\n \n   template<typename _Tp>\n-     inline\n-     _Array<_Tp>::_Array(_Tp* const __restrict__ __p)\n-     : _M_data (__p) {}\n+    inline\n+    _Array<_Tp>::_Array(_Tp* const __restrict__ __p)\n+    : _M_data (__p) {}\n \n   template<typename _Tp>\n-     inline\n-     _Array<_Tp>::_Array(const valarray<_Tp>& __v)\n-     : _M_data (__v._M_data) {}\n+    inline\n+    _Array<_Tp>::_Array(const valarray<_Tp>& __v)\n+    : _M_data (__v._M_data) {}\n \n   template<typename _Tp>\n-     inline\n-     _Array<_Tp>::_Array(const _Tp* __restrict__ __b, size_t __s)\n-     : _M_data(__valarray_get_storage<_Tp>(__s))\n-     { std::__valarray_copy_construct(__b, __s, _M_data); }\n+    inline\n+    _Array<_Tp>::_Array(const _Tp* __restrict__ __b, size_t __s)\n+    : _M_data(__valarray_get_storage<_Tp>(__s))\n+    { std::__valarray_copy_construct(__b, __s, _M_data); }\n \n   template<typename _Tp>\n-     inline _Tp*\n-     _Array<_Tp>::begin () const\n-     { return _M_data; }\n+    inline _Tp*\n+    _Array<_Tp>::begin () const\n+    { return _M_data; }\n \n #define _DEFINE_ARRAY_FUNCTION(_Op, _Name)\t\t\t\t\\\n   template<typename _Tp>\t\t        \t\t\t\\"}, {"sha": "81afedb1be2080347a836ca2fb1894439ad3217d", "filename": "libstdc++-v3/src/valarray-inst.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cb25749bc242b88c5ca61365452ebba48fd307/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc?ref=82cb25749bc242b88c5ca61365452ebba48fd307", "patch": "@@ -1,6 +1,6 @@\n // Explicit instantiation file.\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -48,7 +48,6 @@ namespace std\n   template size_t valarray<size_t>::size() const;\n   template size_t& valarray<size_t>::operator[](size_t);\n \n-\n   inline size_t\n   __valarray_product(const valarray<size_t>& __a)\n   {\n@@ -110,7 +109,7 @@ namespace std\n   \n   gslice::_Indexer::_Indexer(size_t __o, const valarray<size_t>& __l,\n                              const valarray<size_t>& __s)\n-      : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),\n-        _M_index(__l.size() == 0 ? 0 : __valarray_product(__l))\n+  : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),\n+    _M_index(__l.size() == 0 ? 0 : __valarray_product(__l))\n   { __gslice_to_index(__o, __l, __s, _M_index); }  \n } // namespace std"}]}