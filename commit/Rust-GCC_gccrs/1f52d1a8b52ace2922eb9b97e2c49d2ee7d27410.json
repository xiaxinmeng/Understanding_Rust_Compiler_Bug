{"sha": "1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY1MmQxYThiNTJhY2UyOTIyZWI5Yjk3ZTJjNDlkMmVlN2QyNzQxMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-07-06T07:53:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-07-06T07:53:48Z"}, "message": "omp-low.c (struct omp_context): Add for_simd_scan_phase member.\n\n\t* omp-low.c (struct omp_context): Add for_simd_scan_phase member.\n\t(maybe_lookup_ctx): Add forward declaration.\n\t(omp_find_scan): Likewise.  Walk into body of simd if composited\n\twith worksharing loop.\n\t(scan_omp_simd_scan): New function.\n\t(scan_omp_1_stmt): Call it.\n\t(lower_rec_simd_input_clauses): Don't create rvar nor rvar2 if\n\tctx->for_simd_scan_phase.\n\t(lower_rec_input_clauses): Do much less work for inscan reductions\n\tin ctx->for_simd_scan_phase is_simd regions.\n\t(lower_omp_scan): Set is_simd also on simd constructs composited\n\twith worksharing loop, unless ctx->for_simd_scan_phase.  Never emit\n\ta sorry message.  Don't change GIMPLE_OMP_SCAN stmts into nops and\n\temit their body after in simd constructs composited with worksharing\n\tloop.\n\t(lower_omp_for_scan): Handle worksharing loop composited with simd.\n\n\t* c-c++-common/gomp/scan-4.c: Don't expect sorry message.\n\n\t* testsuite/libgomp.c/scan-11.c: New test.\n\t* testsuite/libgomp.c/scan-12.c: New test.\n\t* testsuite/libgomp.c/scan-13.c: New test.\n\t* testsuite/libgomp.c/scan-14.c: New test.\n\t* testsuite/libgomp.c/scan-15.c: New test.\n\t* testsuite/libgomp.c/scan-16.c: New test.\n\t* testsuite/libgomp.c/scan-17.c: New test.\n\t* testsuite/libgomp.c/scan-18.c: New test.\n\t* testsuite/libgomp.c++/scan-9.C: New test.\n\t* testsuite/libgomp.c++/scan-10.C: New test.\n\t* testsuite/libgomp.c++/scan-11.C: New test.\n\t* testsuite/libgomp.c++/scan-12.C: New test.\n\t* testsuite/libgomp.c++/scan-13.C: New test.\n\t* testsuite/libgomp.c++/scan-14.C: New test.\n\t* testsuite/libgomp.c++/scan-15.C: New test.\n\t* testsuite/libgomp.c++/scan-16.C: New test.\n\nFrom-SVN: r273157", "tree": {"sha": "c0fb4cdd9e6e30b44977e0712e7550965c100e2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0fb4cdd9e6e30b44977e0712e7550965c100e2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d1212877acd3f7a2a6ff23f91dc1a0ed106fdd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d1212877acd3f7a2a6ff23f91dc1a0ed106fdd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d1212877acd3f7a2a6ff23f91dc1a0ed106fdd4"}], "stats": {"total": 2495, "additions": 2440, "deletions": 55}, "files": [{"sha": "3ce8b90a5d9ca1a75f91748789c8316b27e49421", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -1,5 +1,22 @@\n 2019-07-06  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* omp-low.c (struct omp_context): Add for_simd_scan_phase member.\n+\t(maybe_lookup_ctx): Add forward declaration.\n+\t(omp_find_scan): Likewise.  Walk into body of simd if composited\n+\twith worksharing loop.\n+\t(scan_omp_simd_scan): New function.\n+\t(scan_omp_1_stmt): Call it.\n+\t(lower_rec_simd_input_clauses): Don't create rvar nor rvar2 if\n+\tctx->for_simd_scan_phase.\n+\t(lower_rec_input_clauses): Do much less work for inscan reductions\n+\tin ctx->for_simd_scan_phase is_simd regions.\n+\t(lower_omp_scan): Set is_simd also on simd constructs composited\n+\twith worksharing loop, unless ctx->for_simd_scan_phase.  Never emit\n+\ta sorry message.  Don't change GIMPLE_OMP_SCAN stmts into nops and\n+\temit their body after in simd constructs composited with worksharing\n+\tloop.\n+\t(lower_omp_for_scan): Handle worksharing loop composited with simd.\n+\n \t* omp-low.c (omp_find_scan): Make static.\n \t(lower_omp_for_scan): Fix order of merge arguments in input phase of\n \tthe second loop, var2 represents the first partial sum and so needs"}, {"sha": "5d5fb6a8eb2889abd61a50c16ed9c632d5599fc5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 275, "deletions": 54, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -147,6 +147,9 @@ struct omp_context\n \n   /* True if there is nested scan context with exclusive clause.  */\n   bool scan_exclusive;\n+\n+  /* True in the second simd loop of for simd with inscan reductions.  */\n+  bool for_simd_scan_phase;\n };\n \n static splay_tree all_contexts;\n@@ -2421,6 +2424,85 @@ scan_omp_simd (gimple_stmt_iterator *gsi, gomp_for *stmt,\n   scan_omp_for (stmt, outer_ctx)->simt_stmt = new_stmt;\n }\n \n+static tree omp_find_scan (gimple_stmt_iterator *, bool *,\n+\t\t\t   struct walk_stmt_info *);\n+static omp_context *maybe_lookup_ctx (gimple *);\n+\n+/* Duplicate #pragma omp simd, one for the scan input phase loop and one\n+   for scan phase loop.  */\n+\n+static void\n+scan_omp_simd_scan (gimple_stmt_iterator *gsi, gomp_for *stmt,\n+\t\t    omp_context *outer_ctx)\n+{\n+  /* The only change between inclusive and exclusive scan will be\n+     within the first simd loop, so just use inclusive in the\n+     worksharing loop.  */\n+  outer_ctx->scan_inclusive = true;\n+  tree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_INCLUSIVE);\n+  OMP_CLAUSE_DECL (c) = integer_zero_node;\n+\n+  gomp_scan *input_stmt = gimple_build_omp_scan (NULL, NULL_TREE);\n+  gomp_scan *scan_stmt = gimple_build_omp_scan (NULL, c);\n+  gsi_replace (gsi, input_stmt, false);\n+  gimple_seq input_body = NULL;\n+  gimple_seq_add_stmt (&input_body, stmt);\n+  gsi_insert_after (gsi, scan_stmt, GSI_NEW_STMT);\n+\n+  gimple_stmt_iterator input1_gsi = gsi_none ();\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  wi.val_only = true;\n+  wi.info = (void *) &input1_gsi;\n+  walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), omp_find_scan, NULL, &wi);\n+  gcc_assert (!gsi_end_p (input1_gsi));\n+\n+  gimple *input_stmt1 = gsi_stmt (input1_gsi);\n+  gsi_next (&input1_gsi);\n+  gimple *scan_stmt1 = gsi_stmt (input1_gsi);\n+  gcc_assert (scan_stmt1 && gimple_code (scan_stmt1) == GIMPLE_OMP_SCAN);\n+  c = gimple_omp_scan_clauses (as_a <gomp_scan *> (scan_stmt1));\n+  if (c && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_EXCLUSIVE)\n+    std::swap (input_stmt1, scan_stmt1);\n+\n+  gimple_seq input_body1 = gimple_omp_body (input_stmt1);\n+  gimple_omp_set_body (input_stmt1, NULL);\n+\n+  gimple_seq scan_body = copy_gimple_seq_and_replace_locals (stmt);\n+  gomp_for *new_stmt = as_a <gomp_for *> (scan_body);\n+\n+  gimple_omp_set_body (input_stmt1, input_body1);\n+  gimple_omp_set_body (scan_stmt1, NULL);\n+\n+  gimple_stmt_iterator input2_gsi = gsi_none ();\n+  memset (&wi, 0, sizeof (wi));\n+  wi.val_only = true;\n+  wi.info = (void *) &input2_gsi;\n+  walk_gimple_seq_mod (gimple_omp_body_ptr (new_stmt), omp_find_scan,\n+\t\t       NULL, &wi);\n+  gcc_assert (!gsi_end_p (input2_gsi));\n+\n+  gimple *input_stmt2 = gsi_stmt (input2_gsi);\n+  gsi_next (&input2_gsi);\n+  gimple *scan_stmt2 = gsi_stmt (input2_gsi);\n+  gcc_assert (scan_stmt2 && gimple_code (scan_stmt2) == GIMPLE_OMP_SCAN);\n+  if (c && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_EXCLUSIVE)\n+    std::swap (input_stmt2, scan_stmt2);\n+\n+  gimple_omp_set_body (input_stmt2, NULL);\n+\n+  gimple_omp_set_body (input_stmt, input_body);\n+  gimple_omp_set_body (scan_stmt, scan_body);\n+\n+  omp_context *ctx = new_omp_context (input_stmt, outer_ctx);\n+  scan_omp (gimple_omp_body_ptr (input_stmt), ctx);\n+\n+  ctx = new_omp_context (scan_stmt, outer_ctx);\n+  scan_omp (gimple_omp_body_ptr (scan_stmt), ctx);\n+\n+  maybe_lookup_ctx (new_stmt)->for_simd_scan_phase = true;\n+}\n+\n /* Scan an OpenMP sections directive.  */\n \n static void\n@@ -3319,6 +3401,19 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_FOR:\n+      if ((gimple_omp_for_kind (as_a <gomp_for *> (stmt))\n+\t   == GF_OMP_FOR_KIND_SIMD)\n+\t  && gimple_omp_for_combined_into_p (stmt)\n+\t  && gimple_code (ctx->stmt) != GIMPLE_OMP_SCAN)\n+\t{\n+\t  tree clauses = gimple_omp_for_clauses (as_a <gomp_for *> (stmt));\n+\t  tree c = omp_find_clause (clauses, OMP_CLAUSE_REDUCTION);\n+\t  if (c && OMP_CLAUSE_REDUCTION_INSCAN (c) && !seen_error ())\n+\t    {\n+\t      scan_omp_simd_scan (gsi, as_a <gomp_for *> (stmt), ctx);\n+\t      break;\n+\t    }\n+\t}\n       if ((gimple_omp_for_kind (as_a <gomp_for *> (stmt))\n \t   == GF_OMP_FOR_KIND_SIMD)\n \t  && omp_maybe_offloaded_ctx (ctx)\n@@ -3757,7 +3852,7 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t\t     DECL_ATTRIBUTES (avar));\n       gimple_add_tmp_var (avar);\n       tree iavar = avar;\n-      if (rvar)\n+      if (rvar && !ctx->for_simd_scan_phase)\n \t{\n \t  /* For inscan reductions, create another array temporary,\n \t     which will hold the reduced value.  */\n@@ -5213,7 +5308,16 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      x = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t(c, unshare_expr (ivar),\n \t\t\t\t build_outer_var_ref (var, ctx));\n-\t\t      if (rvarp)\n+\t\t      if (rvarp && ctx->for_simd_scan_phase)\n+\t\t\t{\n+\t\t\t  if (x)\n+\t\t\t    gimplify_and_add (x, &llist[0]);\n+\t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, ivar);\n+\t\t\t  if (x)\n+\t\t\t    gimplify_and_add (x, &llist[1]);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else if (rvarp)\n \t\t\t{\n \t\t\t  if (x)\n \t\t\t    {\n@@ -5371,6 +5475,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t      && OMP_CLAUSE_REDUCTION_INSCAN (c))\n \t\t    {\n+\t\t      if (ctx->for_simd_scan_phase)\n+\t\t\tgoto do_dtor;\n \t\t      if (x || (!is_simd\n \t\t\t\t&& OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c)))\n \t\t\t{\n@@ -5532,6 +5638,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t      if (rvarp)\n \t\t\t{\n+\t\t\t  if (ctx->for_simd_scan_phase)\n+\t\t\t    break;\n \t\t\t  gimplify_assign (ivar, ref, &llist[0]);\n \t\t\t  ref = build_outer_var_ref (var, ctx);\n \t\t\t  gimplify_assign (ref, rvar, &llist[3]);\n@@ -8629,11 +8737,13 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   bool input_phase = has_clauses ^ octx->scan_inclusive;\n   bool is_simd = (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n-\t\t  && (gimple_omp_for_kind (octx->stmt) & GF_OMP_FOR_SIMD)\n-\t\t  && !gimple_omp_for_combined_into_p (octx->stmt));\n+\t\t  && (gimple_omp_for_kind (octx->stmt) & GF_OMP_FOR_SIMD));\n   bool is_for = (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n \t\t && gimple_omp_for_kind (octx->stmt) == GF_OMP_FOR_KIND_FOR\n \t\t && !gimple_omp_for_combined_p (octx->stmt));\n+  bool is_for_simd = is_simd && gimple_omp_for_combined_into_p (octx->stmt);\n+  if (is_for_simd && octx->for_simd_scan_phase)\n+    is_simd = false;\n   if (is_simd)\n     if (tree c = omp_find_clause (gimple_omp_for_clauses (octx->stmt),\n \t\t\t\t  OMP_CLAUSE__SIMDUID_))\n@@ -8866,10 +8976,7 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      }\n \t  }\n     }\n-  else if (has_clauses)\n-    sorry_at (gimple_location (stmt),\n-\t      \"%<#pragma omp scan%> not supported yet\");\n-  if (!is_for)\n+  if (is_simd && !is_for_simd)\n     {\n       gsi_insert_seq_after (gsi_p, gimple_omp_body (stmt), GSI_SAME_STMT);\n       gsi_insert_seq_after (gsi_p, before, GSI_SAME_STMT);\n@@ -9115,6 +9222,12 @@ omp_find_scan (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     {\n     WALK_SUBSTMTS;\n \n+    case GIMPLE_OMP_FOR:\n+      if ((gimple_omp_for_kind (stmt) & GF_OMP_FOR_SIMD)\n+\t  && gimple_omp_for_combined_into_p (stmt))\n+\t*handled_ops_p = false;\n+      break;\n+\n     case GIMPLE_OMP_SCAN:\n       *(gimple_stmt_iterator *) (wi->info) = *gsi_p;\n       return integer_zero_node;\n@@ -9255,6 +9368,7 @@ static void\n lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n \t\t    struct omp_for_data *fd, omp_context *ctx)\n {\n+  bool is_for_simd = gimple_omp_for_combined_p (stmt);\n   gcc_assert (ctx->scan_inclusive || ctx->scan_exclusive);\n \n   gimple_seq body = gimple_omp_body (stmt);\n@@ -9299,6 +9413,45 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n   gcc_assert (scan_stmt2 && gimple_code (scan_stmt2) == GIMPLE_OMP_SCAN);\n   gimple_omp_set_body (scan_stmt2, scan_body);\n \n+  gimple_stmt_iterator input3_gsi = gsi_none ();\n+  gimple_stmt_iterator scan3_gsi = gsi_none ();\n+  gimple_stmt_iterator input4_gsi = gsi_none ();\n+  gimple_stmt_iterator scan4_gsi = gsi_none ();\n+  gimple *input_stmt3 = NULL, *scan_stmt3 = NULL;\n+  gimple *input_stmt4 = NULL, *scan_stmt4 = NULL;\n+  omp_context *input_simd_ctx = NULL, *scan_simd_ctx = NULL;\n+  if (is_for_simd)\n+    {\n+      memset (&wi, 0, sizeof (wi));\n+      wi.val_only = true;\n+      wi.info = (void *) &input3_gsi;\n+      walk_gimple_seq_mod (&input_body, omp_find_scan, NULL, &wi);\n+      gcc_assert (!gsi_end_p (input3_gsi));\n+\n+      input_stmt3 = gsi_stmt (input3_gsi);\n+      gsi = input3_gsi;\n+      gsi_next (&gsi);\n+      scan3_gsi = gsi;\n+      scan_stmt3 = gsi_stmt (gsi);\n+      gcc_assert (scan_stmt3 && gimple_code (scan_stmt3) == GIMPLE_OMP_SCAN);\n+\n+      memset (&wi, 0, sizeof (wi));\n+      wi.val_only = true;\n+      wi.info = (void *) &input4_gsi;\n+      walk_gimple_seq_mod (&scan_body, omp_find_scan, NULL, &wi);\n+      gcc_assert (!gsi_end_p (input4_gsi));\n+\n+      input_stmt4 = gsi_stmt (input4_gsi);\n+      gsi = input4_gsi;\n+      gsi_next (&gsi);\n+      scan4_gsi = gsi;\n+      scan_stmt4 = gsi_stmt (gsi);\n+      gcc_assert (scan_stmt4 && gimple_code (scan_stmt4) == GIMPLE_OMP_SCAN);\n+\n+      input_simd_ctx = maybe_lookup_ctx (input_stmt3)->outer;\n+      scan_simd_ctx = maybe_lookup_ctx (input_stmt4)->outer;\n+    }\n+\n   tree num_threads = create_tmp_var (integer_type_node);\n   tree thread_num = create_tmp_var (integer_type_node);\n   tree nthreads_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n@@ -9390,6 +9543,18 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n \tx = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (rprivb), rprivb, x);\n \ttree rprivb_ref = build_simple_mem_ref_loc (clause_loc, x);\n \n+\ttree var4 = is_for_simd ? new_var : var2;\n+\ttree var5 = NULL_TREE, var6 = NULL_TREE;\n+\tif (is_for_simd)\n+\t  {\n+\t    var5 = lookup_decl (var, input_simd_ctx);\n+\t    var6 = lookup_decl (var, scan_simd_ctx);\n+\t    if (new_vard != new_var)\n+\t      {\n+\t\tvar5 = build_simple_mem_ref_loc (clause_loc, var5);\n+\t\tvar6 = build_simple_mem_ref_loc (clause_loc, var6);\n+\t      }\n+\t  }\n \tif (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t  {\n \t    tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n@@ -9401,28 +9566,33 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n \t      gimplify_and_add (x, &clist);\n \n \t    x = build_outer_var_ref (var, ctx);\n-\t    x = lang_hooks.decls.omp_clause_assign_op (c, var2, x);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, unshare_expr (var4),\n+\t\t\t\t\t\t       x);\n \t    gimplify_and_add (x, &thr01_list);\n \n \t    tree y = (DECL_HAS_VALUE_EXPR_P (new_vard)\n \t\t      ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n \t    if (var3)\n \t      {\n-\t\tx = lang_hooks.decls.omp_clause_assign_op (c, var2, var3);\n+\t\tx = unshare_expr (var4);\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var3);\n \t\tgimplify_and_add (x, &thrn1_list);\n-\t\tx = lang_hooks.decls.omp_clause_assign_op (c, var2, var3);\n+\t\tx = unshare_expr (var4);\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var3);\n \t\tgimplify_and_add (x, &thr02_list);\n \t      }\n \t    else if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n \t      {\n \t\t/* Otherwise, assign to it the identity element.  */\n \t\tgimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n \t\ttseq = copy_gimple_seq_and_replace_locals (tseq);\n-\n-\t\tif (new_vard != new_var)\n-\t\t  val = build_fold_addr_expr_loc (clause_loc, val);\n-\t\tSET_DECL_VALUE_EXPR (new_vard, val);\n-\t\tDECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t\tif (!is_for_simd)\n+\t\t  {\n+\t\t    if (new_vard != new_var)\n+\t\t      val = build_fold_addr_expr_loc (clause_loc, val);\n+\t\t    SET_DECL_VALUE_EXPR (new_vard, val);\n+\t\t    DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t\t  }\n \t\tSET_DECL_VALUE_EXPR (placeholder, error_mark_node);\n \t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n \t\tlower_omp (&tseq, ctx);\n@@ -9442,47 +9612,64 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n \t\t  }\n \t      }\n \n-\t    x = lang_hooks.decls.omp_clause_assign_op (c, var2, rprivam1_ref);\n+\t    x = unshare_expr (var4);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, rprivam1_ref);\n \t    gimplify_and_add (x, &thrn2_list);\n \n-\t    if (ctx->scan_exclusive)\n+\t    if (is_for_simd)\n \t      {\n \t\tx = unshare_expr (rprivb_ref);\n-\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var5);\n \t\tgimplify_and_add (x, &scan1_list);\n \t      }\n+\t    else\n+\t      {\n+\t\tif (ctx->scan_exclusive)\n+\t\t  {\n+\t\t    x = unshare_expr (rprivb_ref);\n+\t\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t\t    gimplify_and_add (x, &scan1_list);\n+\t\t  }\n \n-\t    gimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n-\t    tseq = copy_gimple_seq_and_replace_locals (tseq);\n-\t    SET_DECL_VALUE_EXPR (placeholder, var2);\n-\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n-\t    lower_omp (&tseq, ctx);\n-\t    gimple_seq_add_seq (&scan1_list, tseq);\n+\t\tgimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n+\t\ttseq = copy_gimple_seq_and_replace_locals (tseq);\n+\t\tSET_DECL_VALUE_EXPR (placeholder, var2);\n+\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t\tlower_omp (&tseq, ctx);\n+\t\tgimple_seq_add_seq (&scan1_list, tseq);\n \n-\t    if (ctx->scan_inclusive)\n-\t      {\n-\t\tx = unshare_expr (rprivb_ref);\n-\t\tx = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n-\t\tgimplify_and_add (x, &scan1_list);\n+\t\tif (ctx->scan_inclusive)\n+\t\t  {\n+\t\t    x = unshare_expr (rprivb_ref);\n+\t\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t\t    gimplify_and_add (x, &scan1_list);\n+\t\t  }\n \t      }\n \n \t    x = unshare_expr (rpriva_ref);\n-\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, x,\n+\t\t\t\t\t\t       unshare_expr (var4));\n \t    gimplify_and_add (x, &mdlist);\n \n-\t    x = unshare_expr (new_var);\n-\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, var2);\n+\t    x = unshare_expr (is_for_simd ? var6 : new_var);\n+\t    x = lang_hooks.decls.omp_clause_assign_op (c, x, var4);\n \t    gimplify_and_add (x, &input2_list);\n \n \t    val = rprivb_ref;\n \t    if (new_vard != new_var)\n \t      val = build_fold_addr_expr_loc (clause_loc, val);\n \n-\t    tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n+\t    gimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n \t    tseq = copy_gimple_seq_and_replace_locals (tseq);\n \t    SET_DECL_VALUE_EXPR (new_vard, val);\n \t    DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n-\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t    if (is_for_simd)\n+\t      {\n+\t\tSET_DECL_VALUE_EXPR (placeholder, var6);\n+\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t      }\n+\t    else\n+\t      DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n \t    lower_omp (&tseq, ctx);\n \t    if (y)\n \t      SET_DECL_VALUE_EXPR (new_vard, y);\n@@ -9491,9 +9678,12 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n \t\tDECL_HAS_VALUE_EXPR_P (new_vard) = 0;\n \t\tSET_DECL_VALUE_EXPR (new_vard, NULL_TREE);\n \t      }\n-\t    SET_DECL_VALUE_EXPR (placeholder, new_var);\n-\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n-\t    lower_omp (&tseq, ctx);\n+\t    if (!is_for_simd)\n+\t      {\n+\t\tSET_DECL_VALUE_EXPR (placeholder, new_var);\n+\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t\tlower_omp (&tseq, ctx);\n+\t      }\n \t    gimple_seq_add_seq (&input2_list, tseq);\n \n \t    x = build_outer_var_ref (var, ctx);\n@@ -9532,29 +9722,38 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n \telse\n \t  {\n \t    x = build_outer_var_ref (var, ctx);\n-\t    gimplify_assign (var2, x, &thr01_list);\n+\t    gimplify_assign (unshare_expr (var4), x, &thr01_list);\n \n \t    x = omp_reduction_init (c, TREE_TYPE (new_var));\n-\t    gimplify_assign (var2, unshare_expr (x), &thrn1_list);\n-\t    gimplify_assign (var2, x, &thr02_list);\n+\t    gimplify_assign (unshare_expr (var4), unshare_expr (x),\n+\t\t\t     &thrn1_list);\n+\t    gimplify_assign (unshare_expr (var4), x, &thr02_list);\n \n-\t    gimplify_assign (var2, rprivam1_ref, &thrn2_list);\n+\t    gimplify_assign (unshare_expr (var4), rprivam1_ref, &thrn2_list);\n \n \t    enum tree_code code = OMP_CLAUSE_REDUCTION_CODE (c);\n \t    if (code == MINUS_EXPR)\n \t      code = PLUS_EXPR;\n \n-\t    if (ctx->scan_exclusive)\n-\t      gimplify_assign (unshare_expr (rprivb_ref), var2, &scan1_list);\n-\t    x = build2 (code, TREE_TYPE (new_var), var2, new_var);\n-\t    gimplify_assign (var2, x, &scan1_list);\n-\t    if (ctx->scan_inclusive)\n-\t      gimplify_assign (unshare_expr (rprivb_ref), var2, &scan1_list);\n+\t    if (is_for_simd)\n+\t      gimplify_assign (unshare_expr (rprivb_ref), var5, &scan1_list);\n+\t    else\n+\t      {\n+\t\tif (ctx->scan_exclusive)\n+\t\t  gimplify_assign (unshare_expr (rprivb_ref), var2,\n+\t\t\t\t   &scan1_list);\n+\t\tx = build2 (code, TREE_TYPE (new_var), var2, new_var);\n+\t\tgimplify_assign (var2, x, &scan1_list);\n+\t\tif (ctx->scan_inclusive)\n+\t\t  gimplify_assign (unshare_expr (rprivb_ref), var2,\n+\t\t\t\t   &scan1_list);\n+\t      }\n \n-\t    gimplify_assign (unshare_expr (rpriva_ref), var2, &mdlist);\n+\t    gimplify_assign (unshare_expr (rpriva_ref), unshare_expr (var4),\n+\t\t\t     &mdlist);\n \n-\t    x = build2 (code, TREE_TYPE (new_var), var2, rprivb_ref);\n-\t    gimplify_assign (new_var, x, &input2_list);\n+\t    x = build2 (code, TREE_TYPE (new_var), var4, rprivb_ref);\n+\t    gimplify_assign (is_for_simd ? var6 : new_var, x, &input2_list);\n \n \t    gimplify_assign (build_outer_var_ref (var, ctx), rpriva_ref,\n \t\t\t     &last_list);\n@@ -9568,7 +9767,8 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n   g = gimple_build_assign (ivar, PLUS_EXPR, ivar, size_one_node);\n   gimple_seq_add_stmt (&scan1_list, g);\n   g = gimple_build_assign (ivar, PLUS_EXPR, ivar, size_one_node);\n-  gimple_seq_add_stmt (gimple_omp_body_ptr (scan_stmt2), g);\n+  gimple_seq_add_stmt (gimple_omp_body_ptr (is_for_simd\n+\t\t\t\t\t    ? scan_stmt4 : scan_stmt2), g);\n \n   tree controlb = create_tmp_var (boolean_type_node);\n   tree controlp = create_tmp_var (ptr_type_node);\n@@ -9598,8 +9798,29 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n   *cp2 = gimple_omp_for_clauses (new_stmt);\n   gimple_omp_for_set_clauses (new_stmt, new_clauses2);\n \n-  gimple_omp_set_body (scan_stmt1, scan1_list);\n-  gimple_omp_set_body (input_stmt2, input2_list);\n+  if (is_for_simd)\n+    {\n+      gimple_seq_add_seq (gimple_omp_body_ptr (scan_stmt3), scan1_list);\n+      gimple_seq_add_seq (gimple_omp_body_ptr (input_stmt4), input2_list);\n+\n+      gsi_insert_seq_after (&input3_gsi, gimple_omp_body (input_stmt3),\n+\t\t\t    GSI_SAME_STMT);\n+      gsi_remove (&input3_gsi, true);\n+      gsi_insert_seq_after (&scan3_gsi, gimple_omp_body (scan_stmt3),\n+\t\t\t    GSI_SAME_STMT);\n+      gsi_remove (&scan3_gsi, true);\n+      gsi_insert_seq_after (&input4_gsi, gimple_omp_body (input_stmt4),\n+\t\t\t    GSI_SAME_STMT);\n+      gsi_remove (&input4_gsi, true);\n+      gsi_insert_seq_after (&scan4_gsi, gimple_omp_body (scan_stmt4),\n+\t\t\t    GSI_SAME_STMT);\n+      gsi_remove (&scan4_gsi, true);\n+    }\n+  else\n+    {\n+      gimple_omp_set_body (scan_stmt1, scan1_list);\n+      gimple_omp_set_body (input_stmt2, input2_list);\n+    }\n \n   gsi_insert_seq_after (&input1_gsi, gimple_omp_body (input_stmt1),\n \t\t\tGSI_SAME_STMT);"}, {"sha": "cc0661a947ee87dbd50af7afc3151e404cf5ef91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -1,5 +1,7 @@\n 2019-07-06  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/scan-4.c: Don't expect sorry message.\n+\n \tPR tree-optimization/91096\n \t* gcc.dg/vect/vect-simd-10.c (FLT_MIN_VALUE): Define.\n \t(bar, main): Use it instead of -__builtin_inff ()."}, {"sha": "b2e22e81cd1c9f7055ba1dbd15dc4c6b8cd15ecd", "filename": "gcc/testsuite/c-c++-common/gomp/scan-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-4.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -8,7 +8,7 @@ f1 (int *c, int *d)\n   for (i = 0; i < 64; i++)\n     {\n       d[i] = a;\n-      #pragma omp scan exclusive (a)\t\t/* { dg-message \"sorry, unimplemented: '#pragma omp scan' not supported yet\" } */\n+      #pragma omp scan exclusive (a)\n       a += c[i];\n     }\n }"}, {"sha": "8ffe379f74cee112215f25170d2de773200b7934", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -1,3 +1,22 @@\n+2019-07-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c/scan-11.c: New test.\n+\t* testsuite/libgomp.c/scan-12.c: New test.\n+\t* testsuite/libgomp.c/scan-13.c: New test.\n+\t* testsuite/libgomp.c/scan-14.c: New test.\n+\t* testsuite/libgomp.c/scan-15.c: New test.\n+\t* testsuite/libgomp.c/scan-16.c: New test.\n+\t* testsuite/libgomp.c/scan-17.c: New test.\n+\t* testsuite/libgomp.c/scan-18.c: New test.\n+\t* testsuite/libgomp.c++/scan-9.C: New test.\n+\t* testsuite/libgomp.c++/scan-10.C: New test.\n+\t* testsuite/libgomp.c++/scan-11.C: New test.\n+\t* testsuite/libgomp.c++/scan-12.C: New test.\n+\t* testsuite/libgomp.c++/scan-13.C: New test.\n+\t* testsuite/libgomp.c++/scan-14.C: New test.\n+\t* testsuite/libgomp.c++/scan-15.C: New test.\n+\t* testsuite/libgomp.c++/scan-16.C: New test.\n+\n 2019-07-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c/scan-9.c: New test."}, {"sha": "c72ba6ee5d94ee1de9bb3f06d88338fe239d20a2", "filename": "libgomp/testsuite/libgomp.c++/scan-10.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-10.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,119 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp for simd if (0) reduction (inscan, +:r) nowait\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd simdlen(1) reduction (inscan, +:s) nowait\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel for simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+}"}, {"sha": "d618f125617b3b269bc3e27a52d0a3a00caf6157", "filename": "libgomp/testsuite/libgomp.c++/scan-11.C", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-11.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,122 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp for simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, foo:s) if (0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp parallel for simd simdlen (1) reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel for simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "6f9bfc3723f3638b3b1f76e9515e4a25c68d453a", "filename": "libgomp/testsuite/libgomp.c++/scan-12.C", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-12.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,153 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } }\n+\n+extern \"C\" void abort ();\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b, S &r)\n+{\n+  #pragma omp for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar ()\n+{\n+  S s;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b, S &r)\n+{\n+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux ()\n+{\n+  S s;\n+  #pragma omp parallel for simd reduction (inscan, plus:s) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  r.s = 0;\n+  baz (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+}"}, {"sha": "eb91297a82769c5b2b2db39b643f817806468b34", "filename": "libgomp/testsuite/libgomp.c++/scan-13.C", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-13.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,161 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { xfail *-*-* } } }\n+\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  T s;\n+};\n+\n+template <typename T>\n+S<T>::S () : s (0)\n+{\n+}\n+\n+template <typename T>\n+S<T>::~S ()\n+{\n+}\n+\n+template <typename T>\n+S<T>::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+template <typename T>\n+S<T> &\n+S<T>::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+template <typename T>\n+static inline void\n+ini (S<T> &x)\n+{\n+  x.s = 0;\n+}\n+\n+S<int> r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S<int>: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S<int>: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+template <typename T>\n+__attribute__((noipa)) void\n+foo (S<T> *a, S<T> *b)\n+{\n+  #pragma omp for simd if (0) reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) S<T>\n+bar (void)\n+{\n+  S<T> s;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return S<T> (s);\n+}\n+\n+__attribute__((noipa)) void\n+baz (S<int> *a, S<int> *b)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S<int>\n+qux (void)\n+{\n+  S<int> s;\n+  #pragma omp parallel for simd simdlen(1) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return S<int> (s);\n+}\n+\n+int\n+main ()\n+{\n+  S<int> s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (bar<int> ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  r.s = 0;\n+  baz (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+}"}, {"sha": "197ec6e8b191a7c79ea304ed91736a9e1b798ba4", "filename": "libgomp/testsuite/libgomp.c++/scan-14.C", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-14.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,123 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+template <typename T, typename U>\n+__attribute__((noipa)) void\n+foo (T a, T b, U r)\n+{\n+  #pragma omp for simd if (0) reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) T\n+bar ()\n+{\n+  T &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, +:s) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) void\n+baz (T *a, T *b, T &r)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r)\n+  for (T i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) int\n+qux ()\n+{\n+  T s = q;\n+  q = 0;\n+  #pragma omp parallel for simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo<int *, int &> (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar<int> () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz<int> (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux<int &> () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+}"}, {"sha": "b6a8787aa44261d4e64a706451b20deb1b15c8f3", "filename": "libgomp/testsuite/libgomp.c++/scan-15.C", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-15.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,121 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } }\n+\n+extern \"C\" void abort ();\n+int r, a[1024], b[1024], q;\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp for simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, foo:s) nowait\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp parallel for simd reduction (inscan, foo:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp parallel for simd reduction (inscan, foo:s)simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+}"}, {"sha": "025860e8c7af9fbd16f0f1edf980f8996f8ed11a", "filename": "libgomp/testsuite/libgomp.c++/scan-16.C", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-16.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,153 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { xfail *-*-* } } }\n+\n+extern \"C\" void abort ();\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b, S &r)\n+{\n+  #pragma omp for simd simdlen (1) reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp parallel\n+  #pragma omp for simd if (0) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b, S &r)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp parallel for simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  r.s = 0;\n+  baz (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+}"}, {"sha": "340004e3b41c04bbd38bd0e6303ffe62478ad9fc", "filename": "libgomp/testsuite/libgomp.c++/scan-9.C", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fscan-9.C?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,154 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } }\n+\n+extern \"C\" void abort ();\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b)\n+{\n+  #pragma omp for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return S (s);\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b)\n+{\n+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return S (s);\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  r.s = 0;\n+  baz (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "7443a504440219897f18723c5c9cbc9aa83bdd60", "filename": "libgomp/testsuite/libgomp.c/scan-11.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-11.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, +:s) if (0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "6e3204687426dccdcf27958a8f9442fba151c57f", "filename": "libgomp/testsuite/libgomp.c/scan-12.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-12.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for simd reduction (inscan, foo:r) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "3c8ce2da04dd38b907d9fd375e2df774ea7b6074", "filename": "libgomp/testsuite/libgomp.c/scan-13.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-13.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+float r = 1.0f, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (float *a, float *b)\n+{\n+  #pragma omp for simd reduction (inscan, *:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r *= a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) float\n+bar (void)\n+{\n+  float s = -__builtin_inff ();\n+  #pragma omp parallel for simd reduction (inscan, max:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s = s > a[i] ? s : a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  float s = 1.0f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (i < 80)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 200)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else if (i < 280)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 380)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else\n+\tswitch (i % 6)\n+\t  {\n+\t  case 0: a[i] = 0.25f; break;\n+\t  case 1: a[i] = 2.0f; break;\n+\t  case 2: a[i] = -1.0f; break;\n+\t  case 3: a[i] = -4.0f; break;\n+\t  case 4: a[i] = 0.5f; break;\n+\t  case 5: a[i] = 1.0f; break;\n+\t  default: a[i] = 0.0f; break;\n+\t  }\n+      b[i] = -19.0f;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r * 16384.0f != 0.125f)\n+    abort ();\n+  float m = -175.25f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s *= a[i];\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\t{\n+\t  a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);\n+\t  b[i] = -231.75f;\n+\t  m += 0.75f;\n+\t}\n+    }\n+  if (bar () != 592.0f)\n+    abort ();\n+  s = -__builtin_inff ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (s < a[i])\n+\ts = a[i];\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "53bd11e5157197448f07120a6ec2469f2424b283", "filename": "libgomp/testsuite/libgomp.c/scan-14.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-14.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,182 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+unsigned short r2, b2[1024];\n+unsigned char r3, b3[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp for simd reduction (inscan, +:r, r2, r3) if (simd:0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { r += a[i]; r2 += a[i]; r3 += a[i]; }\n+      #pragma omp scan inclusive(r, r2, r3)\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, +:s, s2, s3) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\ts += 2 * a[i];\n+\ts2 += 2 * a[i];\n+\ts3 += 2 * a[i];\n+      }\n+      #pragma omp scan inclusive(s, s2, s3)\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tr += a[i];\n+\tr2 += a[i];\n+\tr3 += a[i];\n+      }\n+      #pragma omp scan inclusive(r, r2, r3)\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel for simd reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }\n+      #pragma omp scan inclusive(s, s2, s3)\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  unsigned short s2;\n+  unsigned char s3;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      b2[i] = -1;\n+      b3[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+    }\n+  if (bar (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = -1;\n+\t  b2[i] = -1;\n+\t  b3[i] = -1;\n+\t}\n+    }\n+  r = 0;\n+  r2 = 0;\n+  r3 = 0;\n+  baz (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+    }\n+  s2 = 0;\n+  s3 = 0;\n+  if (qux (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "4a02519129b46b6982e0da121d770f5af75ad8d0", "filename": "libgomp/testsuite/libgomp.c/scan-15.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-15.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "53705d0f43028c1c4a1e07c8c73ae49783ea7eb6", "filename": "libgomp/testsuite/libgomp.c/scan-16.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-16.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp for simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd simdlen (1) reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp parallel for simd if (simd: 0) reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp parallel for simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "22b2e62ee98b25142c3467857274a1e4fff78eb7", "filename": "libgomp/testsuite/libgomp.c/scan-17.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-17.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+float r = 1.0f, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (float *a, float *b)\n+{\n+  #pragma omp for simd reduction (inscan, *:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r *= a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) float\n+bar (void)\n+{\n+  float s = -__builtin_inff ();\n+  #pragma omp parallel for simd reduction (inscan, max:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s = s > a[i] ? s : a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  float s = 1.0f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (i < 80)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 200)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else if (i < 280)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 380)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else\n+\tswitch (i % 6)\n+\t  {\n+\t  case 0: a[i] = 0.25f; break;\n+\t  case 1: a[i] = 2.0f; break;\n+\t  case 2: a[i] = -1.0f; break;\n+\t  case 3: a[i] = -4.0f; break;\n+\t  case 4: a[i] = 0.5f; break;\n+\t  case 5: a[i] = 1.0f; break;\n+\t  default: a[i] = 0.0f; break;\n+\t  }\n+      b[i] = -19.0f;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b);\n+  if (r * 16384.0f != 0.125f)\n+    abort ();\n+  float m = -175.25f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -231.75f;\n+      s *= a[i];\n+      a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);\n+      m += 0.75f;\n+    }\n+  if (bar () != 592.0f)\n+    abort ();\n+  s = -__builtin_inff ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      if (s < a[i])\n+\ts = a[i];\n+    }\n+  return 0;\n+}"}, {"sha": "ea13687bb0628b8d761aefc9d4bdb96fa245627e", "filename": "libgomp/testsuite/libgomp.c/scan-18.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fscan-18.c?ref=1f52d1a8b52ace2922eb9b97e2c49d2ee7d27410", "patch": "@@ -0,0 +1,182 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-O2 -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[2-6] loops\" 2 \"vect\" { target sse2_runtime } } } */\n+\n+extern void abort (void);\n+int r, a[1024], b[1024];\n+unsigned short r2, b2[1024];\n+unsigned char r3, b3[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp for simd reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+      #pragma omp scan exclusive(r, r2, r3)\n+      { r += a[i]; r2 += a[i]; r3 += a[i]; }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel\n+  #pragma omp for simd reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+      #pragma omp scan exclusive(s, s2, s3)\n+      {\n+\ts += 2 * a[i];\n+\ts2 += 2 * a[i];\n+\ts3 += 2 * a[i];\n+      }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp parallel for simd reduction (inscan, +:r, r2, r3) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+      #pragma omp scan exclusive(r, r2, r3)\n+      {\n+\tr += a[i];\n+\tr2 += a[i];\n+\tr3 += a[i];\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp parallel for simd simdlen (1) reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+      #pragma omp scan exclusive(s, s2, s3)\n+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  unsigned short s2;\n+  unsigned char s3;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      b2[i] = -1;\n+      b3[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  #pragma omp parallel\n+  foo (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+      s += i;\n+    }\n+  if (bar (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = -1;\n+\t  b2[i] = -1;\n+\t  b3[i] = -1;\n+\t}\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  r2 = 0;\n+  r3 = 0;\n+  baz (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+      s += i;\n+    }\n+  s2 = 0;\n+  s3 = 0;\n+  if (qux (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}]}