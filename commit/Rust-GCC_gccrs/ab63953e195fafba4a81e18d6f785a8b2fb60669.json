{"sha": "ab63953e195fafba4a81e18d6f785a8b2fb60669", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2Mzk1M2UxOTVmYWZiYTRhODFlMThkNmY3ODVhOGIyZmI2MDY2OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-01T17:24:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-01T17:24:18Z"}, "message": "reorg.c (fill_slots_from_thread): Don't steal delay list from target if condition code of jump conflicts with...\n\n        * reorg.c (fill_slots_from_thread): Don't steal delay list from target\n        if condition code of jump conflicts with opposite_needed.\n        * reorg.c (fill_slots_from_thread): Mark resources referenced in\n        opposite_needed thread.  Return delay_list even when cannot get\n        any more delay insns from end of subroutine.\n        * reorg.c (fill_slots_from_thread): New parameter, delay_list.\n        All callers changed.\n\nFrom-SVN: r18348", "tree": {"sha": "4ef7ad7f211a274a4aa2f4cf8537b6e6e0185d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef7ad7f211a274a4aa2f4cf8537b6e6e0185d63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab63953e195fafba4a81e18d6f785a8b2fb60669", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab63953e195fafba4a81e18d6f785a8b2fb60669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab63953e195fafba4a81e18d6f785a8b2fb60669", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab63953e195fafba4a81e18d6f785a8b2fb60669/comments", "author": null, "committer": null, "parents": [{"sha": "925b1f338e7632f828226bf471476fc5d3ddbc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/925b1f338e7632f828226bf471476fc5d3ddbc79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/925b1f338e7632f828226bf471476fc5d3ddbc79"}], "stats": {"total": 56, "additions": 39, "deletions": 17}, "files": [{"sha": "f92143ef3fb95da58a06104e7c521ed1106ebc58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab63953e195fafba4a81e18d6f785a8b2fb60669/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab63953e195fafba4a81e18d6f785a8b2fb60669/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab63953e195fafba4a81e18d6f785a8b2fb60669", "patch": "@@ -1,4 +1,18 @@\n-Sun Feb 22 16:23:46 1998  Bruno Haible  <bruno@linuix.mathematik.uni-karlsruhe.de>\n+Sun Mar  1 18:25:49 1998  Michael P. Hayes  <michaelh@ongaonga.chch.cri.nz>\n+\n+\t* reorg.c (fill_slots_from_thread): Don't steal delay list from target\n+\tif condition code of jump conflicts with opposite_needed. \n+\n+\t* reorg.c (fill_slots_from_thread): Mark resources referenced in\n+\topposite_needed thread.  Return delay_list even when cannot get\n+\tany more delay insns from end of subroutine.\n+\n+Sun Mar  1 18:26:21 1998  Ken Rose (rose@acm.org)\n+\n+\t* reorg.c (fill_slots_from_thread): New parameter, delay_list.\n+\tAll callers changed.\n+\n+Sun Mar  1 18:25:37 1998  Bruno Haible  <bruno@linuix.mathematik.uni-karlsruhe.de>\n \n \t* frame.c (start_fde_sort, fde_split, heapsort, fde_merge,\n \tend_fde_sort): New functions for fast sorting of an FDE array."}, {"sha": "9b7b3a5eb1fee1b26e602293cc8a957af4f97f5b", "filename": "gcc/reorg.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab63953e195fafba4a81e18d6f785a8b2fb60669/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab63953e195fafba4a81e18d6f785a8b2fb60669/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=ab63953e195fafba4a81e18d6f785a8b2fb60669", "patch": "@@ -1,5 +1,5 @@\n /* Perform instruction reorganizations for delay slot filling.\n-   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu).\n    Hacked by Michael Tiemann (tiemann@cygnus.com).\n \n@@ -267,15 +267,15 @@ static rtx next_insn_no_annul\tPROTO((rtx));\n static void mark_target_live_regs PROTO((rtx, struct resources *));\n static void fill_simple_delay_slots PROTO((int));\n static rtx fill_slots_from_thread PROTO((rtx, rtx, rtx, rtx, int, int,\n-\t\t\t\t\t int, int, int *));\n+\t\t\t\t\t int, int, int *, rtx));\n static void fill_eager_delay_slots PROTO((void));\n static void relax_delay_slots\tPROTO((rtx));\n static void make_return_insns\tPROTO((rtx));\n static int redirect_with_delay_slots_safe_p PROTO ((rtx, rtx, rtx));\n static int redirect_with_delay_list_safe_p PROTO ((rtx, rtx, rtx));\n \f\n /* Given X, some rtl, and RES, a pointer to a `struct resource', mark\n-   which resources are references by the insn.  If INCLUDE_CALLED_ROUTINE\n+   which resources are references by the insn.  If INCLUDE_DELAYED_EFFECTS\n    is TRUE, resources used by the called routine will be included for\n    CALL_INSNs.  */\n \n@@ -491,9 +491,10 @@ mark_referenced_resources (x, res, include_delayed_effects)\n       }\n }\n \f\n-/* Given X, a part of an insn, and a pointer to a `struct resource', RES,\n-   indicate which resources are modified by the insn. If INCLUDE_CALLED_ROUTINE\n-   is nonzero, also mark resources potentially set by the called routine.\n+/* Given X, a part of an insn, and a pointer to a `struct resource',\n+   RES, indicate which resources are modified by the insn. If\n+   INCLUDE_DELAYED_EFFECTS is nonzero, also mark resources potentially\n+   set by the called routine.\n \n    If IN_DEST is nonzero, it means we are inside a SET.  Otherwise,\n    objects are being referenced instead of set.\n@@ -747,7 +748,7 @@ resource_conflicts_p (res1, res2)\n }\n \n /* Return TRUE if any resource marked in RES, a `struct resources', is\n-   referenced by INSN.  If INCLUDE_CALLED_ROUTINE is set, return if the called\n+   referenced by INSN.  If INCLUDE_DELAYED_EFFECTS is set, return if the called\n    routine is using those resources.\n \n    We compute this by computing all the resources referenced by INSN and\n@@ -769,7 +770,7 @@ insn_references_resource_p (insn, res, include_delayed_effects)\n }\n \n /* Return TRUE if INSN modifies resources that are marked in RES.\n-   INCLUDE_CALLED_ROUTINE is set if the actions of that routine should be\n+   INCLUDE_DELAYED_EFFECTS is set if the actions of that routine should be\n    included.   CC0 is only modified if it is explicitly set; see comments\n    in front of mark_set_resources for details.  */\n \n@@ -3335,7 +3336,8 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t\t\t    NULL, 1, 1,\n \t\t\t\t    own_thread_p (JUMP_LABEL (insn),\n \t\t\t\t\t\t  JUMP_LABEL (insn), 0),\n-\t\t\t\t    slots_to_fill, &slots_filled);\n+\t\t\t\t    slots_to_fill, &slots_filled,\n+\t\t\t\t    delay_list);\n \n       if (delay_list)\n \tunfilled_slots_base[i]\n@@ -3464,17 +3466,17 @@ fill_simple_delay_slots (non_jumps_p)\n static rtx\n fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t\tthread_if_true, own_thread,\n-\t\t\tslots_to_fill, pslots_filled)\n+\t\t\tslots_to_fill, pslots_filled, delay_list)\n      rtx insn;\n      rtx condition;\n      rtx thread, opposite_thread;\n      int likely;\n      int thread_if_true;\n      int own_thread;\n      int slots_to_fill, *pslots_filled;\n+     rtx delay_list;\n {\n   rtx new_thread;\n-  rtx delay_list = 0;\n   struct resources opposite_needed, set, needed;\n   rtx trial;\n   int lose = 0;\n@@ -3491,7 +3493,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n   /* If our thread is the end of subroutine, we can't get any delay\n      insns from that.  */\n   if (thread == 0)\n-    return 0;\n+      return delay_list;\n \n   /* If this is an unconditional branch, nothing is needed at the\n      opposite thread.  Otherwise, compute what is needed there.  */\n@@ -3648,6 +3650,8 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \n \t\t  delay_list = add_to_delay_list (temp, delay_list);\n \n+\t\t  mark_set_resources (trial, &opposite_needed, 0, 1);\n+\n \t\t  if (slots_to_fill == ++(*pslots_filled))\n \t\t    {\n \t\t      /* Even though we have filled all the slots, we\n@@ -3717,7 +3721,9 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n     {\n       /* If this is the `true' thread, we will want to follow the jump,\n \t so we can only do this if we have taken everything up to here.  */\n-      if (thread_if_true && trial == new_thread)\n+      if (thread_if_true && trial == new_thread\n+\t  && ! insn_references_resource_p (XVECEXP (PATTERN (trial), 0, 0),\n+\t\t\t\t\t   &opposite_needed, 0))\n \tdelay_list\n \t  = steal_delay_list_from_target (insn, condition, PATTERN (trial),\n \t\t\t\t\t  delay_list, &set, &needed,\n@@ -3916,7 +3922,7 @@ fill_eager_delay_slots ()\n \t    = fill_slots_from_thread (insn, condition, insn_at_target,\n \t\t\t\t      fallthrough_insn, prediction == 2, 1,\n \t\t\t\t      own_target,\n-\t\t\t\t      slots_to_fill, &slots_filled);\n+\t\t\t\t      slots_to_fill, &slots_filled, delay_list);\n \n \t  if (delay_list == 0 && own_fallthrough)\n \t    {\n@@ -3931,7 +3937,8 @@ fill_eager_delay_slots ()\n \t\t= fill_slots_from_thread (insn, condition, fallthrough_insn,\n \t\t\t\t\t  insn_at_target, 0, 0,\n \t\t\t\t\t  own_fallthrough,\n-\t\t\t\t\t  slots_to_fill, &slots_filled);\n+\t\t\t\t\t  slots_to_fill, &slots_filled,\n+\t\t\t\t\t  delay_list);\n \t    }\n \t}\n       else\n@@ -3948,7 +3955,8 @@ fill_eager_delay_slots ()\n \t      = fill_slots_from_thread (insn, condition, insn_at_target,\n \t\t\t\t\tnext_active_insn (insn), 0, 1,\n \t\t\t\t\town_target,\n-\t\t\t\t\tslots_to_fill, &slots_filled);\n+\t\t\t\t\tslots_to_fill, &slots_filled,\n+\t\t\t\t\tdelay_list);\n \t}\n \n       if (delay_list)"}]}