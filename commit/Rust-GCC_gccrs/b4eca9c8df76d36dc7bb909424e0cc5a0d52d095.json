{"sha": "b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlY2E5YzhkZjc2ZDM2ZGM3YmI5MDk0MjRlMGNjNWEwZDUyZDA5NQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-12T00:41:23Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-12T00:41:23Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.md (negsi_cond, negdi_cond, stack_protect_test): Remove\n\tget_t_reg_rtx when invoking gen_branch_true or gen_branch_false.\n\t(*zero_extend<mode>si2_compact): Convert to insn_and_split.  Convert\n\tzero extensions of T bit stores to reg moves in splitter.  Remove\n\tobsolete unnamed peephole2 that caught zero extensions after negc T bit\n\tstores.\n\t(*branch_true_eq, *branch_false_ne): Delete.\n\t(branch_true, branch_false): Convert insn to expander.  Move actual\n\tinsn logic to...\n\t(*cbranch_t): ...this new insn_and_split.  Try to find preceding\n\tredundant T bit stores and tests and combine them with the conditional\n\tbranch if possible in the splitter.\n\t(movrt_xor, *movt_movrt): New insn_and_split.\n\t* config/sh/predicates.md (cbranch_treg_value): New predicate.\n\t* config/sh/sh-protos.h (sh_eval_treg_value): Forward declare...\n\t* config/sh/sh.c (sh_eval_treg_value): ...this new function.\n\t(expand_cbranchsi4, expand_cbranchdi4): Remove get_t_reg_rtx\n\twhen invoking gen_branch_true or gen_branch_false.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-13.c: New.\n\t* gcc.target/sh/pr51244-14.c: New.\n\t* gcc.target/sh/pr51244-15.c: New.\n\t* gcc.target/sh/pr51244-16.c: New.\n\nFrom-SVN: r192387", "tree": {"sha": "962653c07a00c814ead771a9568becdae982ddb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/962653c07a00c814ead771a9568becdae982ddb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/comments", "author": null, "committer": null, "parents": [{"sha": "76a2a3f738f94ff070c2e4179951f8579f70555e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a2a3f738f94ff070c2e4179951f8579f70555e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a2a3f738f94ff070c2e4179951f8579f70555e"}], "stats": {"total": 629, "additions": 566, "deletions": 63}, "files": [{"sha": "779c3bb13401b353a76bba4ce30baefc28dcdddc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -1,3 +1,25 @@\n+2012-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.md (negsi_cond, negdi_cond, stack_protect_test): Remove\n+\tget_t_reg_rtx when invoking gen_branch_true or gen_branch_false.\n+\t(*zero_extend<mode>si2_compact): Convert to insn_and_split.  Convert\n+\tzero extensions of T bit stores to reg moves in splitter.  Remove\n+\tobsolete unnamed peephole2 that caught zero extensions after negc T bit\n+\tstores.\n+\t(*branch_true_eq, *branch_false_ne): Delete.\n+\t(branch_true, branch_false): Convert insn to expander.  Move actual\n+\tinsn logic to...\n+\t(*cbranch_t): ...this new insn_and_split.  Try to find preceding\n+\tredundant T bit stores and tests and combine them with the conditional\n+\tbranch if possible in the splitter.\n+\t(movrt_xor, *movt_movrt): New insn_and_split.\n+\t* config/sh/predicates.md (cbranch_treg_value): New predicate.\n+\t* config/sh/sh-protos.h (sh_eval_treg_value): Forward declare...\n+\t* config/sh/sh.c (sh_eval_treg_value): ...this new function.\n+\t(expand_cbranchsi4, expand_cbranchdi4): Remove get_t_reg_rtx\n+\twhen invoking gen_branch_true or gen_branch_false.\n+\n 2012-10-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.md (IMODE): New mode iterator."}, {"sha": "8ada743b74b20878727aafd7122bfc831b53e281", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -1048,6 +1048,14 @@\n     }\n })\n \n+;; A predicate that returns true if OP is a valid construct around the T bit\n+;; that can be used as an operand for conditional branches.\n+(define_predicate \"cbranch_treg_value\"\n+  (match_code \"eq,ne,reg,subreg,xor,sign_extend,zero_extend\")\n+{\n+  return sh_eval_treg_value (op) >= 0;\n+})\n+\n ;; Returns true of OP is arith_reg_operand or t_reg_operand.\n (define_predicate \"arith_reg_or_t_reg_operand\"\n   (ior (match_operand 0 \"arith_reg_operand\")"}, {"sha": "f3c037cb6118d492d671fd42255ecab5b1605127", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -162,6 +162,7 @@ extern bool sh_cfun_trap_exit_p (void);\n extern void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n \t\t\t\t\tenum machine_mode mode = VOIDmode);\n extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);\n+extern int sh_eval_treg_value (rtx op);\n #endif /* RTX_CODE */\n \n extern void sh_cpu_cpp_builtins (cpp_reader* pfile);"}, {"sha": "b4bfa0842f831df10dc931ab5a0c0720e68c81b8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -2059,7 +2059,7 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n void\n expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n {\n-  rtx (*branch_expander) (rtx, rtx) = gen_branch_true;\n+  rtx (*branch_expander) (rtx) = gen_branch_true;\n   comparison = prepare_cbranch_operands (operands, SImode, comparison);\n   switch (comparison)\n     {\n@@ -2071,7 +2071,7 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n   emit_insn (gen_rtx_SET (VOIDmode, get_t_reg_rtx (),\n                           gen_rtx_fmt_ee (comparison, SImode,\n                                           operands[1], operands[2])));\n-  rtx jump = emit_jump_insn (branch_expander (operands[3], get_t_reg_rtx ()));\n+  rtx jump = emit_jump_insn (branch_expander (operands[3]));\n   if (probability >= 0)\n     add_reg_note (jump, REG_BR_PROB, GEN_INT (probability));\n }\n@@ -2123,7 +2123,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n       if (TARGET_CMPEQDI_T)\n \t{\n \t  emit_insn (gen_cmpeqdi_t (operands[1], operands[2]));\n-\t  emit_jump_insn (gen_branch_true (operands[3], get_t_reg_rtx ()));\n+\t  emit_jump_insn (gen_branch_true (operands[3]));\n \t  return true;\n \t}\n       msw_skip = NE;\n@@ -2150,7 +2150,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n       if (TARGET_CMPEQDI_T)\n \t{\n \t  emit_insn (gen_cmpeqdi_t (operands[1], operands[2]));\n-\t  emit_jump_insn (gen_branch_false (operands[3], get_t_reg_rtx ()));\n+\t  emit_jump_insn (gen_branch_false (operands[3]));\n \t  return true;\n \t}\n       msw_taken = NE;\n@@ -2281,6 +2281,43 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n   return true;\n }\n \n+/* Given an operand, return 1 if the evaluated operand plugged into an\n+   if_then_else will result in a branch_true, 0 if branch_false, or\n+   -1 if neither nor applies.  The truth table goes like this:\n+\n+       op   | cmpval |   code  | result\n+   ---------+--------+---------+--------------------\n+      T (0) |   0    |  EQ (1) |  0 = 0 ^ (0 == 1)\n+      T (0) |   1    |  EQ (1) |  1 = 0 ^ (1 == 1)\n+      T (0) |   0    |  NE (0) |  1 = 0 ^ (0 == 0)\n+      T (0) |   1    |  NE (0) |  0 = 0 ^ (1 == 0)\n+     !T (1) |   0    |  EQ (1) |  1 = 1 ^ (0 == 1)\n+     !T (1) |   1    |  EQ (1) |  0 = 1 ^ (1 == 1)\n+     !T (1) |   0    |  NE (0) |  0 = 1 ^ (0 == 0)\n+     !T (1) |   1    |  NE (0) |  1 = 1 ^ (1 == 0)  */\n+int\n+sh_eval_treg_value (rtx op)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  if ((code != EQ && code != NE) || !CONST_INT_P (XEXP (op, 1)))\n+    return -1;\n+\n+  int cmpop = code == EQ ? 1 : 0;\n+  int cmpval = INTVAL (XEXP (op, 1));\n+  if (cmpval != 0 && cmpval != 1)\n+    return -1;\n+\n+  int t;\n+  if (t_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0))))\n+    t = 0;\n+  else if (negt_reg_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0))))\n+    t = 1;\n+  else\n+    return -1;\n+  \n+  return t ^ (cmpval == cmpop);\n+}\n+\n /* Emit INSN, possibly in a PARALLEL with an USE of fpscr for SH4.  */\n \n static void\n@@ -2485,9 +2522,9 @@ sh_emit_compare_and_branch (rtx *operands, enum machine_mode mode)\n     sh_emit_set_t_insn (gen_ieee_ccmpeqsf_t (op0, op1), mode);\n \n   if (branch_code == code)\n-    emit_jump_insn (gen_branch_true (operands[3], get_t_reg_rtx ()));\n+    emit_jump_insn (gen_branch_true (operands[3]));\n   else\n-    emit_jump_insn (gen_branch_false (operands[3], get_t_reg_rtx ()));\n+    emit_jump_insn (gen_branch_false (operands[3]));\n }\n \n void\n@@ -2521,7 +2558,7 @@ sh_emit_compare_and_set (rtx *operands, enum machine_mode mode)\n             {\n               lab = gen_label_rtx ();\n               sh_emit_scc_to_t (EQ, op0, op1);\n-              emit_jump_insn (gen_branch_true (lab, get_t_reg_rtx ()));\n+              emit_jump_insn (gen_branch_true (lab));\n               code = GT;\n            }\n           else"}, {"sha": "dacabb7cdf20c4faed06914c8ccf3d9ef026db1e", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 209, "deletions": 56, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -5322,8 +5322,8 @@ label:\n   emit_insn (gen_movsi (operands[0], operands[1]));\n \n   emit_jump_insn (INTVAL (operands[3])\n-\t\t  ? gen_branch_true (skip_neg_label, get_t_reg_rtx ())\n-\t\t  : gen_branch_false (skip_neg_label, get_t_reg_rtx ()));\n+\t\t  ? gen_branch_true (skip_neg_label)\n+\t\t  : gen_branch_false (skip_neg_label));\n \n   emit_label_after (skip_neg_label,\n \t\t    emit_insn (gen_negsi2 (operands[0], operands[1])));\n@@ -5391,8 +5391,8 @@ label:\n   emit_insn (gen_movsi (high_dst, high_src));\n \n   emit_jump_insn (INTVAL (operands[3]) \n-\t\t  ? gen_branch_true (skip_neg_label, get_t_reg_rtx ())\n-\t\t  : gen_branch_false (skip_neg_label, get_t_reg_rtx ()));\n+\t\t  ? gen_branch_true (skip_neg_label)\n+\t\t  : gen_branch_false (skip_neg_label));\n \n   if (!INTVAL (operands[3]))\n     emit_insn (gen_clrt ());\n@@ -5575,11 +5575,57 @@ label:\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n \t(zero_extend:SI (match_operand:QIHI 1 \"zero_extend_operand\")))])\n \n-(define_insn \"*zero_extend<mode>si2_compact\"\n+(define_insn_and_split \"*zero_extend<mode>si2_compact\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(zero_extend:SI (match_operand:QIHI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"extu.<bw>\t%1,%0\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(set (match_dup 0) (match_dup 2))]\n+{\n+  /* Sometimes combine fails to combine a T bit or negated T bit store to a\n+     reg with a following zero extension.  In the split pass after combine,\n+     try to figure the extended reg was set.  If it originated from the T\n+     bit we can replace the zero extension with a reg move, which will be\n+     eliminated.  Notice that this also helps the *cbranch_t splitter when\n+     it tries to post-combine tests and conditional branches, as it does not\n+     check for zero extensions.  */\n+  rtx ext_reg;\n+  if (REG_P (operands[1]))\n+    ext_reg = operands[1];\n+  else if (GET_CODE (operands[1]) == SUBREG && REG_P (SUBREG_REG (operands[1])))\n+    ext_reg = SUBREG_REG (operands[1]);\n+  else\n+    FAIL;\n+\n+  /* Reg moves must be of the same mode.  */\n+  if (GET_MODE (ext_reg) != SImode)\n+    FAIL;\n+\n+  operands[2] = NULL_RTX;\n+  for (rtx i = prev_nonnote_insn_bb (curr_insn); i != NULL_RTX;\n+       i = prev_nonnote_insn_bb (i))\n+    {\n+      if (LABEL_P (i) || BARRIER_P (i))\n+\tbreak;\n+      if (!NONJUMP_INSN_P (i))\n+\tcontinue;\n+\n+      if (reg_set_p (ext_reg, i))\n+\t{\n+\t  rtx set_op = XEXP (set_of (ext_reg, i), 1);\n+\t  if (set_op == NULL_RTX)\n+\t    break;\n+\t  if (t_reg_operand (set_op, VOIDmode)\n+\t      || negt_reg_operand (set_op, VOIDmode))\n+\t    operands[2] = ext_reg;\n+\t  break;\n+\t}\n+    }\n+\n+  if (operands[2] == NULL_RTX)\n+    FAIL;\n+}\n   [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*zero_extendhisi2_media\"\n@@ -8108,47 +8154,126 @@ label:\n ;; Define the real conditional branch instructions.\n ;; ------------------------------------------------------------------------\n \n-(define_insn \"branch_true\"\n-  [(set (pc) (if_then_else (ne (match_operand 1 \"t_reg_operand\" \"\")\n-\t\t\t       (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"branch_true\"\n+  [(set (pc) (if_then_else (ne (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0))\n \t\t\t   (pc)))]\n-  \"TARGET_SH1\"\n-{\n-  return output_branch (1, insn, operands);\n-}\n-  [(set_attr \"type\" \"cbranch\")])\n+  \"TARGET_SH1\")\n \n-(define_insn \"*branch_true_eq\"\n-  [(set (pc) (if_then_else (eq (match_operand 1 \"t_reg_operand\" \"\")\n-\t\t\t       (const_int 1))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+(define_expand \"branch_false\"\n+  [(set (pc) (if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0))\n \t\t\t   (pc)))]\n-  \"TARGET_SH1\"\n-{\n-  return output_branch (1, insn, operands);\n-}\n-  [(set_attr \"type\" \"cbranch\")])\n+  \"TARGET_SH1\")\n \n-(define_insn \"branch_false\"\n-  [(set (pc) (if_then_else (eq (match_operand 1 \"t_reg_operand\" \"\")\n-\t\t\t       (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+(define_insn_and_split \"*cbranch_t\"\n+  [(set (pc) (if_then_else (match_operand 1 \"cbranch_treg_value\")\n+\t\t\t   (label_ref (match_operand 0))\n \t\t\t   (pc)))]\n   \"TARGET_SH1\"\n {\n-  return output_branch (0, insn, operands);\n+  return output_branch (sh_eval_treg_value (operands[1]), insn, operands);\n }\n-  [(set_attr \"type\" \"cbranch\")])\n-\n-(define_insn \"*branch_false_ne\"\n-  [(set (pc) (if_then_else (ne (match_operand 1 \"t_reg_operand\" \"\")\n-\t\t\t       (const_int 1))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+  \"&& can_create_pseudo_p ()\"\n+  [(set (pc) (if_then_else (eq (reg:SI T_REG) (match_dup 2))\n+\t\t\t   (label_ref (match_dup 0))\n \t\t\t   (pc)))]\n-  \"TARGET_SH1\"\n {\n-  return output_branch (0, insn, operands);\n+  /* Try to find missed test and branch combine opportunities which result\n+     in redundant T bit tests before conditional branches.\n+     FIXME: Probably this would not be needed if CCmode was used\n+     together with TARGET_FIXED_CONDITION_CODE_REGS.  */\n+\n+  const int treg_value = sh_eval_treg_value (operands[1]);\n+  operands[2] = NULL_RTX;\n+\n+  /* Scan the insns backwards for an insn that sets the T bit by testing a\n+     reg against zero like:\n+\t(set (reg T_REG) (eq (reg) (const_int 0)))  */\n+  rtx testing_insn = NULL_RTX;\n+  rtx tested_reg = NULL_RTX;\n+\n+  for (rtx i = prev_nonnote_insn_bb (curr_insn); i != NULL_RTX;\n+       i = prev_nonnote_insn_bb (i))\n+    {\n+      if (LABEL_P (i) || BARRIER_P (i))\n+\tbreak;\n+      if (!NONJUMP_INSN_P (i))\n+\tcontinue;\n+\n+      rtx p = PATTERN (i);\n+      if (p != NULL_RTX\n+\t  && GET_CODE (p) == SET && t_reg_operand (XEXP (p, 0), VOIDmode)\n+\t  && GET_CODE (XEXP (p, 1)) == EQ\n+\t  && REG_P (XEXP (XEXP (p, 1), 0))\n+\t  && satisfies_constraint_Z (XEXP (XEXP (p, 1), 1)))\n+\t{\n+\t  testing_insn = i;\n+\t  tested_reg = XEXP (XEXP (p, 1), 0);\n+\t  break;\n+\t}\n+    }\n+\n+  if (testing_insn == NULL_RTX)\n+    FAIL;\n+\n+  /* Continue scanning the insns backwards and try to find the insn that\n+     sets the tested reg which we found above.  If the reg is set by storing\n+     the T bit or the negated T bit we can eliminate the test insn before\n+     the branch.  Notice that the branch condition has to be inverted if the\n+     test is eliminated.  */\n+\n+  /* If the T bit is used between the testing insn and the brach insn\n+     leave it alone.  */\n+  if (reg_used_between_p (get_t_reg_rtx (), testing_insn, curr_insn))\n+    FAIL;\n+\n+  for (rtx i = prev_nonnote_insn_bb (testing_insn); i != NULL_RTX;\n+       i = prev_nonnote_insn_bb (i))\n+    {\n+      if (LABEL_P (i) || BARRIER_P (i))\n+\tbreak;\n+      if (!NONJUMP_INSN_P (i))\n+\tcontinue;\n+\n+      if (reg_set_p (tested_reg, i))\n+\t{\n+\t  const_rtx tested_reg_set = set_of (tested_reg, i);\n+\n+\t  /* It could also be a clobber...  */\n+\t  if (tested_reg_set == NULL_RTX || GET_CODE (tested_reg_set) != SET)\n+\t    break;\n+\n+\t  rtx set_op1 = XEXP (tested_reg_set, 1);\n+\t  if (t_reg_operand (set_op1, VOIDmode))\n+\t    operands[2] = GEN_INT (treg_value ^ 1);\n+\t  else if (negt_reg_operand (set_op1, VOIDmode))\n+\t    operands[2] = GEN_INT (treg_value);\n+\t  else if (REG_P (set_op1))\n+\t    {\n+\t      /* If it's a reg-reg copy follow the copied reg.  This can\n+\t\t happen e.g. when T bit store zero-extensions are\n+\t\t eliminated.  */\n+\t      tested_reg = set_op1;\n+\t      continue;\n+\t    }\n+\n+\t  /* It's only safe to remove the testing insn if the T bit is not\n+\t     modified between the testing insn and the insn that stores the\n+\t     T bit.  Notice that some T bit stores such as negc also modify\n+\t     the T bit.  */\n+\t  if (modified_between_p (get_t_reg_rtx (), i, testing_insn)\n+\t      || modified_in_p (get_t_reg_rtx (), i))\n+\t    operands[2] = NULL_RTX;\n+\n+\t  break;\n+\t}\n+    }\n+\n+  if (operands[2] == NULL_RTX)\n+    FAIL;\n+\n+  set_insn_deleted (testing_insn);\n }\n   [(set_attr \"type\" \"cbranch\")])\n \n@@ -10960,25 +11085,53 @@ label:\n \t(set (reg:SI T_REG) (const_int 1))\n \t(use (match_dup 2))])])\n \n-;; In some cases the zero extension does not get combined away and a \n-;; sequence like the following might remain:\n-;;\tmov\t#-1,r2\n-;;\ttst\tr1,r1\n-;;\tnegc\tr2,r1\n-;;\textu.b\tr1,r1\n-(define_peephole2\n-  [(parallel\n-       [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t     (xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))\n-\t(set (reg:SI T_REG) (const_int 1))\n-\t(use (match_operand:SI 2 \"arith_reg_operand\" \"\"))])\n-   (set (match_dup 0)\n-\t(zero_extend:SI (match_operand 3 \"arith_reg_operand\" \"\")))]\n-  \"TARGET_SH1 && REGNO (operands[0]) == REGNO (operands[3])\"\n-  [(parallel\n-       [(set (match_dup 0) (xor:SI (match_dup 1) (const_int 1)))\n-\t(set (reg:SI T_REG) (const_int 1))\n-\t(use (match_dup 2))])])\n+;; Store the negated T bit in a reg using r0 and xor.  This one doesn't\n+;; clobber the T bit, which is useful when storing the T bit and the\n+;; negated T bit in parallel.  On SH2A the movrt insn can be used for that.\n+;; Usually we don't want this insn to be matched, except for cases where the\n+;; T bit clobber is really not appreciated.  Hence the extra use on T_REG.\n+(define_insn_and_split \"movrt_xor\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z\")\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\") (const_int 1)))\n+   (use (reg:SI T_REG))]\n+  \"TARGET_SH1 && !TARGET_SH2A\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (reg:SI T_REG))\n+   (set (match_dup 0) (xor:SI (match_dup 0) (const_int 1)))])\n+\n+;; Store the T bit and the negated T bit in two regs in parallel.  There is\n+;; no real insn to do that, but specifying this pattern will give combine\n+;; some opportunities.\n+(define_insn_and_split \"*movt_movrt\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t\t   (match_operand:SI 1 \"negt_reg_operand\"))\n+\t      (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t\t   (match_operand:SI 3 \"t_reg_operand\"))])]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx i = TARGET_SH2A\n+\t  ? gen_movrt (operands[0], get_t_reg_rtx ())\n+\t  : gen_movrt_xor (operands[0], get_t_reg_rtx ());\n+  \n+  emit_insn (i);\n+  emit_insn (gen_movt (operands[2], get_t_reg_rtx ()));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*movt_movrt\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t\t   (match_operand:SI 1 \"t_reg_operand\"))\n+\t      (set (match_operand:SI 2 \"arith_reg_dest\")\n+\t\t   (match_operand:SI 3 \"negt_reg_operand\"))])]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 2) (match_dup 3))\n+\t      (set (match_dup 0) (match_dup 1))])])\n \n ;; Use negc to store the T bit in a MSB of a reg in the following way:\n ;;\tT = 1: 0x80000000 -> reg\n@@ -15165,7 +15318,7 @@ label:\n   else\n     {\n       emit_insn (gen_stack_protect_test_si (operands[0], operands[1]));\n-      emit_jump_insn (gen_branch_true (operands[2], get_t_reg_rtx ()));\n+      emit_jump_insn (gen_branch_true (operands[2]));\n     }\n \n   DONE;"}, {"sha": "b35fe712ab22b58c0b7fbdb289dc773f850d2351", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -1,3 +1,11 @@\n+2012-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-13.c: New.\n+\t* gcc.target/sh/pr51244-14.c: New.\n+\t* gcc.target/sh/pr51244-15.c: New.\n+\t* gcc.target/sh/pr51244-16.c: New.\n+\n 2012-10-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51878"}, {"sha": "7e823dc030c06a0cf4bfb4736c0a8f1fe4390306", "filename": "gcc/testsuite/gcc.target/sh/pr51244-13.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-13.c?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -0,0 +1,85 @@\n+/* This is a case extracted from CSiBE which contained the following\n+   sequence:\n+\tshll\tr0\n+\tmovt\tr0\n+\ttst\tr0,r0\n+\tbf\t.L11\n+   where the 'tst r0,r0' before the branch can be omitted by inverting the\n+   branch condition.  The tested function contains two other tst insns.  If\n+   everything goes as expected we will be seeing only those other two tst\n+   insns.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-times \"tst\" 2 } } */\n+\n+static __inline__ int\n+__test_bit (unsigned long nr, volatile void * addr)\n+{\n+  /*  This is on purpose.  */\n+  int oldbit;\n+  return oldbit & 1;\n+}\n+\n+static __inline__ int\n+__constant_test_bit (unsigned long nr, volatile void * addr)\n+{\n+  return (((volatile char *) addr)[(nr>>3)^7] & (1<<(nr&7))) != 0;\n+}\n+\n+struct list_head\n+{\n+  struct list_head *next, *prev;\n+};\n+\n+static inline void\n+__list_del (struct list_head *prev, struct list_head *next)\n+{\n+  next->prev = prev;\n+  prev->next = next;\n+}\n+\n+static inline void\n+list_del (struct list_head *entry)\n+{\n+ __list_del(entry->prev, entry->next);\n+ entry->next = 0;\n+ entry->prev = 0;\n+}\n+\n+extern int nr_active_pages;\n+extern int nr_inactive_pages;\n+extern struct list_head active_list;\n+\n+typedef struct page\n+{\n+ unsigned long flags;\n+ struct list_head lru;\n+} mem_map_t;\n+\n+void\n+activate_page_nolock (struct page * page)\n+{\n+ if ((__builtin_constant_p((6))\n+      ? __constant_test_bit((6),(&(page)->flags))\n+      : __test_bit((6),(&(page)->flags)) )\n+     && !(__builtin_constant_p((7))\n+          ? __constant_test_bit((7),(&(page)->flags))\n+          : __test_bit((7),(&(page)->flags)) ))\n+    {\n+      list_del(&(page)->lru);\n+      nr_inactive_pages--;\n+      if (!(__builtin_constant_p(6) ? __constant_test_bit((6),(&(page)->flags))\n+\t\t\t\t    : __test_bit((6),(&(page)->flags))))\n+\tprintk(\"\", \"\", 43);\n+\n+      if ((__builtin_constant_p(7) ? __constant_test_bit((7),(&(page)->flags))\n+\t\t\t\t   : __test_bit((7),(&(page)->flags))))\n+\tprintk(\"\", \"\", 43);\n+\n+      (__builtin_constant_p(7) ? __constant_set_bit((7),(&(page)->flags))\n+\t\t\t        : __set_bit((7),(&(page)->flags)) );\n+      list_add(&(page)->lru, &active_list);\n+      nr_active_pages++;\n+    }\n+}"}, {"sha": "0ff7008fbc9b44692df60b66c5244a73c75b5a87", "filename": "gcc/testsuite/gcc.target/sh/pr51244-14.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-14.c?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -0,0 +1,107 @@\n+/* This is a case extracted from CSiBE which would sometimes contain the\n+   following sequence:\n+\tcmp/eq\tr12,r13\n+\tmovt\tr0\n+\txor\t#1,r0\n+\textu.b\tr0,r0\n+\tmovt\tr3\n+\ttst\tr0,r0\n+\tbf/s\t.L35\n+   where the negated T bit store did not combine properly.  Since there are\n+   other movt insns we only check for the xor and the extu.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"xor|extu\" } } */\n+\n+typedef struct transaction_s transaction_t;\n+\n+struct journal_head\n+{\n+  transaction_t * b_transaction;\n+  struct journal_head *b_cpnext, *b_cpprev;\n+};\n+\n+struct transaction_s\n+{\n+  struct journal_head * t_checkpoint_list;\n+  transaction_t *t_cpnext, *t_cpprev;\n+};\n+\n+struct journal_s\n+{\n+  transaction_t * j_checkpoint_transactions;\n+  unsigned long j_first, j_last;\n+};\n+\n+typedef struct journal_s journal_t;\n+\n+extern int __try_to_free_cp_buf (struct journal_head *jh);\n+extern int __cleanup_transaction (journal_t *journal, transaction_t *transaction);\n+extern void __flush_batch (void **bhs, int *batch_count);\n+extern void* jh2bh (void*);\n+\n+static int\n+__flush_buffer (journal_t *journal, struct journal_head *jh,\n+\t\tvoid **bhs, int *batch_count, int *drop_count)\n+{\n+  void *bh = jh2bh (jh);\n+  int ret = 0;\n+  if (bh)\n+    {\n+      bhs[*batch_count] = bh;\n+      (*batch_count)++;\n+      if (*batch_count == 64)\n+\t  ret = 1;\n+    }\n+  else\n+    {\n+      int last_buffer = 0;\n+      if (jh->b_cpnext == jh)\n+\tlast_buffer = 1;\n+      if (__try_to_free_cp_buf (jh))\n+\t{\n+\t  (*drop_count)++;\n+\t  ret = last_buffer;\n+\t}\n+    }\n+  return ret;\n+}\n+\n+int\n+log_do_checkpoint (journal_t *journal, int nblocks)\n+{\n+  transaction_t *transaction, *last_transaction, *next_transaction;\n+  int batch_count = 0;\n+  void *bhs[64];\n+\n+repeat:\n+  transaction = journal->j_checkpoint_transactions;\n+  if (transaction == ((void *)0))\n+    return 0;\n+  last_transaction = transaction->t_cpprev;\n+  next_transaction = transaction;\n+  do\n+    {\n+      struct journal_head *jh, *last_jh, *next_jh;\n+      int drop_count = 0;\n+      int cleanup_ret, retry = 0;\n+      transaction = next_transaction;\n+      next_transaction = transaction->t_cpnext;\n+      jh = transaction->t_checkpoint_list;\n+      last_jh = jh->b_cpprev;\n+      next_jh = jh;\n+      do\n+\t{\n+\t  jh = next_jh;\n+\t  next_jh = jh->b_cpnext;\n+\t  retry = __flush_buffer(journal, jh, bhs, &batch_count, &drop_count);\n+\t} while (jh != last_jh && !retry);\n+\n+      if (retry)\n+\tgoto repeat;\n+\n+      cleanup_ret = __cleanup_transaction(journal, transaction);\n+      goto repeat;\n+    } while (transaction != last_transaction);\n+}"}, {"sha": "ec98d5e61385f62fd50b8f8ddea9e1fd2e4d593f", "filename": "gcc/testsuite/gcc.target/sh/pr51244-15.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-15.c?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -0,0 +1,71 @@\n+/* Check that the redundant test removal code in the *cbranch_t split works\n+   as expected on non-SH2A targets.  Because on SH2A the movrt instruction\n+   is used, this test is re-used and checked differently in pr51244-16.c.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" \"-m2a*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-times \"tst\" 6 } } */\n+/* { dg-final { scan-assembler-times \"movt\" 6 } } */\n+/* { dg-final { scan-assembler-times \"xor\" 3 } } */\n+/* { dg-final { scan-assembler-not \"extu|exts|negc\" } } */\n+\n+typedef char bool;\n+\n+int\n+test_0 (int a, int b, int c, int* d)\n+{\n+  /* non SH2A: 1x tst, 1x movt, 1x xor\n+         SH2A: 1x tst, 1x movrt  */\n+  bool x = a == 0;\n+  d[2] = !x;\n+  return x ? b : c;\n+}\n+\n+int\n+test_1 (int a, int b, int c, int* d)\n+{\n+  /* 1x tst, 1x movt  */\n+  bool x = a != 0;\n+  d[2] = !x;\n+  return x ? b : c;\n+}\n+\n+int\n+test_2 (int a, int b, int c, char* d)\n+{\n+  /* Check that there is no sign/zero-extension before the store.\n+     non SH2A: 1x tst, 1x movt, 1x xor\n+         SH2A: 1x tst, 1x movrt  */\n+  bool x = a == 0;\n+  d[2] = !x;\n+  return x ? b : c;\n+}\n+\n+int\n+test_3 (int a, int b, int c, char* d)\n+{\n+  /* Check that there is no sign/zero-extension before the store.\n+     1x tst, 1x movt  */\n+  bool x = a != 0;\n+  d[2] = !x;\n+  return x ? b : c;\n+}\n+\n+int\n+test_4 (int a, int b, int c, char* d)\n+{\n+  /* 1x tst, 1x movt  */\n+  bool x = a != 0;\n+  d[2] = !x;\n+  return !x ? b : c;\n+}\n+\n+int\n+test_5 (int a, int b, int c, char* d)\n+{\n+  /* non SH2A: 1x tst, 1x movt, 1x xor\n+         SH2A: 1x tst, 1x movrt  */\n+  bool x = a == 0;\n+  d[2] = !x;\n+  return !x ? b : c;\n+}"}, {"sha": "8717df7f34a727c1fe8109af1811350bc4208347", "filename": "gcc/testsuite/gcc.target/sh/pr51244-16.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4eca9c8df76d36dc7bb909424e0cc5a0d52d095/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-16.c?ref=b4eca9c8df76d36dc7bb909424e0cc5a0d52d095", "patch": "@@ -0,0 +1,11 @@\n+/* Check that the redundant test removal code in the *cbranch_t split works\n+   as expected on SH2A targets.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"tst\" 6 } } */\n+/* { dg-final { scan-assembler-times \"movt\" 3 } } */\n+/* { dg-final { scan-assembler-times \"movrt\" 3 } } */\n+/* { dg-final { scan-assembler-not \"extu|exts|negc\" } } */\n+\n+#include \"pr51244-15.c\""}]}