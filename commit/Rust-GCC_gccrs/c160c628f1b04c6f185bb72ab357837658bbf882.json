{"sha": "c160c628f1b04c6f185bb72ab357837658bbf882", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE2MGM2MjhmMWIwNGM2ZjE4NWJiNzJhYjM1NzgzNzY1OGJiZjg4Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-22T22:38:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-22T22:38:23Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r571", "tree": {"sha": "48ee761264a1efa7d287eba7c21f943e1cf11388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48ee761264a1efa7d287eba7c21f943e1cf11388"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c160c628f1b04c6f185bb72ab357837658bbf882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c160c628f1b04c6f185bb72ab357837658bbf882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c160c628f1b04c6f185bb72ab357837658bbf882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c160c628f1b04c6f185bb72ab357837658bbf882/comments", "author": null, "committer": null, "parents": [{"sha": "13a07c712632ff93436bb7f5fb3efe2705701fde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a07c712632ff93436bb7f5fb3efe2705701fde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a07c712632ff93436bb7f5fb3efe2705701fde"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "51658511e7b74e5055162724f75a8e6a41721148", "filename": "gcc/loop.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c160c628f1b04c6f185bb72ab357837658bbf882/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c160c628f1b04c6f185bb72ab357837658bbf882/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c160c628f1b04c6f185bb72ab357837658bbf882", "patch": "@@ -1458,6 +1458,34 @@ rtx_equal_for_loop_p (x, y, movables)\n   return 1;\n }\n \f\n+/* If X contains any LABEL_REF's, add REG_LABEL notes for them to all\n+  insns in INSNS which use thet reference.  */\n+\n+static void\n+add_label_notes (x, insns)\n+     rtx x;\n+     rtx insns;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i;\n+  char *fmt;\n+  rtx insn;\n+\n+  if (code == LABEL_REF)\n+    {\n+      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+\tif (reg_mentioned_p (XEXP (x, 0), insn))\n+\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, XEXP (x, 0),\n+\t\t\t\t      REG_NOTES (insn));\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      add_label_notes (XEXP (x, i), insns);\n+}\n+\f\n /* Scan MOVABLES, and move the insns that deserve to be moved.\n    If two matching movables are combined, replace one reg with the\n    other throughout.  */\n@@ -1635,10 +1663,12 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \n \t\t  start_sequence ();\n \t\t  emit_move_insn (m->set_dest, m->set_src);\n-\t\t  temp = gen_sequence ();\n+\t\t  temp = get_insns ();\n \t\t  end_sequence ();\n \n-\t\t  i1 = emit_insn_before (temp, loop_start);\n+\t\t  add_label_notes (m->set_src, temp);\n+\n+\t\t  i1 = emit_insns_before (temp, loop_start);\n \t\t  if (! find_reg_note (i1, REG_EQUAL, 0))\n \t\t    REG_NOTES (i1)\n \t\t      = gen_rtx (EXPR_LIST,\n@@ -4504,11 +4534,19 @@ update_giv_derive (p)\n \t\t be able to compute a compensation.  */\n \t      else if (biv->insn == p)\n \t\t{\n-\t\t  if (biv->mult_val == const1_rtx\n-\t\t      && (tem = simplify_giv_expr (gen_rtx (MULT, giv->mode,\n-\t\t\t\t\t\t\t    biv->add_val,\n-\t\t\t\t\t\t\t    giv->mult_val),\n-\t\t\t\t\t\t   &dummy)))\n+\t\t  tem = 0;\n+\n+\t\t  if (biv->mult_val == const1_rtx)\n+\t\t    tem = simplify_giv_expr (gen_rtx (MULT, giv->mode,\n+\t\t\t\t\t\t      biv->add_val,\n+\t\t\t\t\t\t      giv->mult_val),\n+\t\t\t\t\t     &dummy);\n+\n+\t\t  if (tem && giv->derive_adjustment)\n+\t\t    tem = simplify_giv_expr (gen_rtx (PLUS, giv->mode, tem,\n+\t\t\t\t\t\t      giv->derive_adjustment),\n+\t\t\t\t\t     &dummy);\n+\t\t  if (tem)\n \t\t    giv->derive_adjustment = tem;\n \t\t  else\n \t\t    giv->cant_derive = 1;"}]}