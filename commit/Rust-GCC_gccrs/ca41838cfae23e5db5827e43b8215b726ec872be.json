{"sha": "ca41838cfae23e5db5827e43b8215b726ec872be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0MTgzOGNmYWUyM2U1ZGI1ODI3ZTQzYjgyMTViNzI2ZWM4NzJiZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2008-05-17T13:49:44Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2008-05-17T13:49:44Z"}, "message": "intrinsic.c (add_functions): Change FLUSH(C) to FLUSH(UNIT).\n\n2008-05-16  Tobias Burnus  <burnus@net-b.de>\n\n        * intrinsic.c (add_functions): Change FLUSH(C) to FLUSH(UNIT).\n        * intrinsic.texi: Change INTEGER(*) to INTEGER; fix keyword=  name for\n        ABS, ADJUSTL, AINT, ALLOCATED, ANINT, ASSOCIATED, C_ASSOCIATED,\n        CEILING, DBLE, DFLOAT, DOT_PRODUCT, DREAL, FLOAT, FLOOR, GET_COMMAND.\n\nFrom-SVN: r135471", "tree": {"sha": "cc5e4fdc0d37d474e1d5b548acc24e83a6b76fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc5e4fdc0d37d474e1d5b548acc24e83a6b76fd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca41838cfae23e5db5827e43b8215b726ec872be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca41838cfae23e5db5827e43b8215b726ec872be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca41838cfae23e5db5827e43b8215b726ec872be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca41838cfae23e5db5827e43b8215b726ec872be/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c7d304769bf867571977ed28df4a8f121d02371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c7d304769bf867571977ed28df4a8f121d02371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c7d304769bf867571977ed28df4a8f121d02371"}], "stats": {"total": 730, "additions": 377, "deletions": 353}, "files": [{"sha": "2b2922955b9573f79528ae67bad7994841661c43", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca41838cfae23e5db5827e43b8215b726ec872be/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca41838cfae23e5db5827e43b8215b726ec872be/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ca41838cfae23e5db5827e43b8215b726ec872be", "patch": "@@ -1,3 +1,10 @@\n+2008-05-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* intrinsic.c (add_functions): Change FLUSH(C) to FLUSH(UNIT).\n+\t* intrinsic.texi: Change INTEGER(*) to INTEGER; fix keyword= name for\n+\tABS, ADJUSTL, AINT, ALLOCATED, ANINT, ASSOCIATED, C_ASSOCIATED,\n+\tCEILING, DBLE, DFLOAT, DOT_PRODUCT, DREAL, FLOAT, FLOOR, GET_COMMAND.\n+\n 2008-05-16  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/35756\n@@ -16,6 +23,10 @@\n \tnot evaluate scalars outside the loop.  Clean up whitespace.\n \t* trans.h : Add a bitfield 'where' to gfc_ss.\n \n+2008-05-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* intrinsic.c (add_functions): Change FLUSH(C) to FLUSH(UNIT)\n+\n 2008-05-16  Tobias Burnus  <burnus@net-b.de>\n \n \t* libgfortran.h: Increase GFC_MAX_DIMENSIONS to 15."}, {"sha": "6def478e266cafdc0e6fa6ad55cade50b49cab25", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca41838cfae23e5db5827e43b8215b726ec872be/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca41838cfae23e5db5827e43b8215b726ec872be/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=ca41838cfae23e5db5827e43b8215b726ec872be", "patch": "@@ -2578,7 +2578,7 @@ add_subroutines (void)\n \n   add_sym_1s (\"flush\", GFC_ISYM_FLUSH, NO_CLASS, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_flush, NULL, gfc_resolve_flush,\n-\t      c, BT_INTEGER, di, OPTIONAL);\n+\t      ut, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_3s (\"fputc\", GFC_ISYM_FPUTC, NO_CLASS, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_fgetputc_sub, NULL, gfc_resolve_fputc_sub,"}, {"sha": "f5c92030c54fc563dc8630efd14a895776dcf2d9", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 365, "deletions": 352, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca41838cfae23e5db5827e43b8215b726ec872be/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca41838cfae23e5db5827e43b8215b726ec872be/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=ca41838cfae23e5db5827e43b8215b726ec872be", "patch": "@@ -358,7 +358,7 @@ end program test_abort\n \n @table @asis\n @item @emph{Description}:\n-@code{ABS(X)} computes the absolute value of @code{X}.\n+@code{ABS(A)} computes the absolute value of @code{A}.\n \n @item @emph{Standard}:\n Fortran 77 and later, has overloads that are GNU extensions\n@@ -367,18 +367,18 @@ Fortran 77 and later, has overloads that are GNU extensions\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = ABS(X)}\n+@code{RESULT = ABS(A)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type of the argument shall be an @code{INTEGER(*)},\n-@code{REAL(*)}, or @code{COMPLEX(*)}.\n+@item @var{A} @tab The type of the argument shall be an @code{INTEGER},\n+@code{REAL}, or @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n The return value is of the same type and\n-kind as the argument except the return value is @code{REAL(*)} for a\n-@code{COMPLEX(*)} argument.\n+kind as the argument except the return value is @code{REAL} for a\n+@code{COMPLEX} argument.\n \n @item @emph{Example}:\n @smallexample\n@@ -395,11 +395,11 @@ end program test_abs\n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n @item Name            @tab Argument            @tab Return type       @tab Standard\n-@item @code{CABS(Z)}  @tab @code{COMPLEX(4) Z} @tab @code{REAL(4)}    @tab Fortran 77 and later\n-@item @code{DABS(X)}  @tab @code{REAL(8)    X} @tab @code{REAL(8)}    @tab Fortran 77 and later\n-@item @code{IABS(I)}  @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)} @tab Fortran 77 and later\n-@item @code{ZABS(Z)}  @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab GNU extension\n-@item @code{CDABS(Z)} @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab GNU extension\n+@item @code{CABS(A)}  @tab @code{COMPLEX(4) Z} @tab @code{REAL(4)}    @tab Fortran 77 and later\n+@item @code{DABS(A)}  @tab @code{REAL(8)    X} @tab @code{REAL(8)}    @tab Fortran 77 and later\n+@item @code{IABS(A)}  @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)} @tab Fortran 77 and later\n+@item @code{ZABS(A)}  @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab GNU extension\n+@item @code{CDABS(A)} @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab GNU extension\n @end multitable\n @end table\n \n@@ -485,15 +485,16 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I}    @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I}    @tab The type shall be @code{INTEGER}.\n @item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n                       the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{CHARACTER} with a length of one.  The\n-kind type parameter is the same as  @code{KIND('A')}.\n+The return value is of type @code{CHARACTER} with a length of one.\n+If the @var{KIND} argument is present, the return value is of the\n+specified kind and of the default kind otherwise.\n \n @item @emph{Example}:\n @smallexample\n@@ -536,14 +537,14 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)} with a magnitude that is\n+@item @var{X} @tab The type shall be @code{REAL} with a magnitude that is\n less than one.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it lies in the\n-range @math{ 0 \\leq \\acos(x) \\leq \\pi}. The kind type parameter \n-is the same as @var{X}.\n+The return value is of type @code{REAL} and it lies in the\n+range @math{ 0 \\leq \\acos(x) \\leq \\pi}. The return value if of the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -625,7 +626,7 @@ Inverse function: @ref{COSH}\n \n @table @asis\n @item @emph{Description}:\n-@code{ADJUSTL(STR)} will left adjust a string by removing leading spaces.\n+@code{ADJUSTL(STRING)} will left adjust a string by removing leading spaces.\n Spaces are inserted at the end of the string as needed.\n \n @item @emph{Standard}:\n@@ -635,17 +636,17 @@ Fortran 95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = ADJUSTL(STR)}\n+@code{RESULT = ADJUSTL(STRING)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STR} @tab The type shall be @code{CHARACTER}.\n+@item @var{STRING} @tab The type shall be @code{CHARACTER}.\n @end multitable\n \n @item @emph{Return value}:\n The return value is of type @code{CHARACTER} where leading spaces \n are removed and the same number of spaces are inserted on the end\n-of @var{STR}.\n+of @var{STR}. The return value has the same kind as @var{STRING}.\n \n @item @emph{Example}:\n @smallexample\n@@ -670,7 +671,7 @@ end program test_adjustl\n \n @table @asis\n @item @emph{Description}:\n-@code{ADJUSTR(STR)} will right adjust a string by removing trailing spaces.\n+@code{ADJUSTR(STRING)} will right adjust a string by removing trailing spaces.\n Spaces are inserted at the start of the string as needed.\n \n @item @emph{Standard}:\n@@ -680,7 +681,7 @@ Fortran 95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = ADJUSTR(STR)}\n+@code{RESULT = ADJUSTR(STRING)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n@@ -690,7 +691,7 @@ Elemental function\n @item @emph{Return value}:\n The return value is of type @code{CHARACTER} where trailing spaces \n are removed and the same number of spaces are inserted at the start\n-of @var{STR}.\n+of @var{STR}. The return value has the same kind as @var{STRING}.\n \n @item @emph{Example}:\n @smallexample\n@@ -733,11 +734,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{Z} @tab The type of the argument shall be @code{COMPLEX(*)}.\n+@item @var{Z} @tab The type of the argument shall be @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type real with the\n+The return value is of type @code{REAL} with the\n kind type parameter of the argument.\n \n @item @emph{Example}:\n@@ -755,8 +756,8 @@ end program test_aimag\n @multitable @columnfractions .20 .20 .20 .25\n @item Name            @tab Argument            @tab Return type       @tab Standard\n @item @code{DIMAG(Z)} @tab @code{COMPLEX(8) Z} @tab @code{REAL(8)}    @tab GNU extension\n-@item @code{IMAG(Z)}  @tab @code{COMPLEX(*) Z} @tab @code{REAL(*)}    @tab GNU extension\n-@item @code{IMAGPART(Z)} @tab @code{COMPLEX(*) Z} @tab @code{REAL(*)} @tab GNU extension\n+@item @code{IMAG(Z)}  @tab @code{COMPLEX Z} @tab @code{REAL}    @tab GNU extension\n+@item @code{IMAGPART(Z)} @tab @code{COMPLEX Z} @tab @code{REAL} @tab GNU extension\n @end multitable\n @end table\n \n@@ -771,7 +772,7 @@ end program test_aimag\n \n @table @asis\n @item @emph{Description}:\n-@code{AINT(X [, KIND])} truncates its argument to a whole number.\n+@code{AINT(A [, KIND])} truncates its argument to a whole number.\n \n @item @emph{Standard}:\n Fortran 77 and later\n@@ -780,22 +781,22 @@ Fortran 77 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = AINT(X [, KIND])} \n+@code{RESULT = AINT(A [, KIND])} \n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{A}    @tab The type of the argument shall be @code{REAL}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type real with the kind type parameter of the\n+The return value is of type @code{REAL} with the kind type parameter of the\n argument if the optional @var{KIND} is absent; otherwise, the kind\n type parameter will be given by @var{KIND}.  If the magnitude of \n-@var{X} is less than one, then @code{AINT(X)} returns zero.  If the\n-magnitude is equal to or greater than one, then it returns the largest\n+@var{X} is less than one, @code{AINT(X)} returns zero.  If the\n+magnitude is equal to or greater than one then it returns the largest\n whole number that does not exceed its magnitude.  The sign is the same\n as the sign of @var{X}. \n \n@@ -893,14 +894,14 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and\n+@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL} and\n it shall not be scalar.\n @item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer\n with a value that lies between one and the rank of @var{MASK}.\n @end multitable\n \n @item @emph{Return value}:\n-@code{ALL(MASK)} returns a scalar value of type @code{LOGICAL(*)} where\n+@code{ALL(MASK)} returns a scalar value of type @code{LOGICAL} where\n the kind type parameter is the same as the kind type parameter of\n @var{MASK}.  If @var{DIM} is present, then @code{ALL(MASK, DIM)} returns\n an array with the rank of @var{MASK} minus 1.  The shape is determined from\n@@ -945,7 +946,7 @@ end program test_all\n \n @table @asis\n @item @emph{Description}:\n-@code{ALLOCATED(X)} checks the status of whether @var{X} is allocated.\n+@code{ALLOCATED(ARRAY)} checks the status of whether @var{X} is allocated.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -954,16 +955,16 @@ Fortran 95 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = ALLOCATED(X)}\n+@code{RESULT = ALLOCATED(ARRAY)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X}    @tab The argument shall be an @code{ALLOCATABLE} array.\n+@item @var{ARRAY}    @tab The argument shall be an @code{ALLOCATABLE} array.\n @end multitable\n \n @item @emph{Return value}:\n The return value is a scalar @code{LOGICAL} with the default logical\n-kind type parameter.  If @var{X} is allocated, @code{ALLOCATED(X)}\n+kind type parameter.  If @var{ARRAY} is allocated, @code{ALLOCATED(ARRAY)}\n is @code{.TRUE.}; otherwise, it returns @code{.FALSE.} \n \n @item @emph{Example}:\n@@ -1003,13 +1004,13 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be either a scalar @code{INTEGER(*)}\n+@item @var{I} @tab The type shall be either a scalar @code{INTEGER}\n type or a scalar @code{LOGICAL} type.\n @item @var{J} @tab The type shall be the same as the type of @var{I}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is either a scalar @code{INTEGER(*)} or a scalar\n+The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n return has the larger kind.\n@@ -1041,7 +1042,7 @@ Fortran 95 elemental function: @ref{IAND}\n \n @table @asis\n @item @emph{Description}:\n-@code{ANINT(X [, KIND])} rounds its argument to the nearest whole number.\n+@code{ANINT(A [, KIND])} rounds its argument to the nearest whole number.\n \n @item @emph{Standard}:\n Fortran 77 and later\n@@ -1050,22 +1051,22 @@ Fortran 77 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = ANINT(X [, KIND])}\n+@code{RESULT = ANINT(A [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{A}    @tab The type of the argument shall be @code{REAL}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n The return value is of type real with the kind type parameter of the\n argument if the optional @var{KIND} is absent; otherwise, the kind\n-type parameter will be given by @var{KIND}.  If @var{X} is greater than\n-zero, then @code{ANINT(X)} returns @code{AINT(X+0.5)}.  If @var{X} is\n-less than or equal to zero, then it returns @code{AINT(X-0.5)}.\n+type parameter will be given by @var{KIND}.  If @var{A} is greater than\n+zero, @code{ANINT(A)} returns @code{AINT(X+0.5)}.  If @var{A} is\n+less than or equal to zero then it returns @code{AINT(X-0.5)}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1082,7 +1083,7 @@ end program test_anint\n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n @item Name            @tab Argument         @tab Return type      @tab Standard\n-@item @code{DNINT(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}   @tab Fortran 77 and later\n+@item @code{DNINT(A)} @tab @code{REAL(8) A} @tab @code{REAL(8)}   @tab Fortran 77 and later\n @end multitable\n @end table\n \n@@ -1110,14 +1111,14 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and\n+@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL} and\n it shall not be scalar.\n @item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer\n with a value that lies between one and the rank of @var{MASK}.\n @end multitable\n \n @item @emph{Return value}:\n-@code{ANY(MASK)} returns a scalar value of type @code{LOGICAL(*)} where\n+@code{ANY(MASK)} returns a scalar value of type @code{LOGICAL} where\n the kind type parameter is the same as the kind type parameter of\n @var{MASK}.  If @var{DIM} is present, then @code{ANY(MASK, DIM)} returns\n an array with the rank of @var{MASK} minus 1.  The shape is determined from\n@@ -1177,12 +1178,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and a magnitude that is\n+@item @var{X} @tab The type shall be @code{REAL}, and a magnitude that is\n less than one.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it lies in the\n+The return value is of type @code{REAL} and it lies in the\n range @math{-\\pi / 2 \\leq \\asin (x) \\leq \\pi / 2}.  The kind type\n parameter is the same as @var{X}.\n \n@@ -1265,8 +1266,8 @@ Inverse function: @ref{SINH}\n \n @table @asis\n @item @emph{Description}:\n-@code{ASSOCIATED(PTR [, TGT])} determines the status of the pointer @var{PTR}\n-or if @var{PTR} is associated with the target @var{TGT}.\n+@code{ASSOCIATED(POINTER [, TARGET])} determines the status of the pointer\n+@var{POINTER} or if @var{POINTER} is associated with the target @var{TARGET}.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -1275,44 +1276,45 @@ Fortran 95 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = ASSOCIATED(PTR [, TGT])}\n+@code{RESULT = ASSOCIATED(POINTER [, TARGET])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{PTR} @tab @var{PTR} shall have the @code{POINTER} attribute and\n-it can be of any type.\n-@item @var{TGT} @tab (Optional) @var{TGT} shall be a @code{POINTER} or\n-a @code{TARGET}.  It must have the same type, kind type parameter, and\n-array rank as @var{PTR}.\n+@item @var{POINTER} @tab @var{POINTER} shall have the @code{POINTER} attribute\n+and it can be of any type.\n+@item @var{TARGET} @tab (Optional) @var{TARGET} shall be a pointer or\n+a target.  It must have the same type, kind type parameter, and\n+array rank as @var{POINTER}.\n @end multitable\n-The status of neither @var{PTR} nor @var{TGT} can be undefined.\n+The association status of neither @var{POINTER} nor @var{TARGET} shall be\n+undefined.\n \n @item @emph{Return value}:\n-@code{ASSOCIATED(PTR)} returns a scalar value of type @code{LOGICAL(4)}.\n+@code{ASSOCIATED(POINTER)} returns a scalar value of type @code{LOGICAL(4)}.\n There are several cases:\n @table @asis\n-@item (A) If the optional @var{TGT} is not present, then @code{ASSOCIATED(PTR)}\n-is true if @var{PTR} is associated with a target; otherwise, it returns false.\n-@item (B) If @var{TGT} is present and a scalar target, the result is true if\n-@var{TGT}\n-is not a 0 sized storage sequence and the target associated with @var{PTR}\n-occupies the same storage units.  If @var{PTR} is disassociated, then the \n-result is false.\n-@item (C) If @var{TGT} is present and an array target, the result is true if\n-@var{TGT} and @var{PTR} have the same shape, are not 0 sized arrays, are\n-arrays whose elements are not 0 sized storage sequences, and @var{TGT} and\n-@var{PTR} occupy the same storage units in array element order.\n-As in case(B), the result is false, if @var{PTR} is disassociated.\n-@item (D) If @var{TGT} is present and an scalar pointer, the result is true if\n-target associated with @var{PTR} and the target associated with @var{TGT}\n-are not 0 sized storage sequences and occupy the same storage units.\n-The result is false, if either @var{TGT} or @var{PTR} is disassociated.\n-@item (E) If @var{TGT} is present and an array pointer, the result is true if\n-target associated with @var{PTR} and the target associated with @var{TGT}\n-have the same shape, are not 0 sized arrays, are arrays whose elements are\n-not 0 sized storage sequences, and @var{TGT} and @var{PTR} occupy the same\n-storage units in array element order.\n-The result is false, if either @var{TGT} or @var{PTR} is disassociated.\n+@item (A) When the optional @var{TARGET} is not present then\n+@code{ASSOCIATED(POINTER)} is true if @var{POINTER} is associated with a target; otherwise, it returns false.\n+@item (B) If @var{TARGET} is present and a scalar target, the result is true if\n+@var{TARGET} is not a zero-sized storage sequence and the target associated with @var{POINTER} occupies the same storage units.  If @var{POINTER} is\n+disassociated, the result is false.\n+@item (C) If @var{TARGET} is present and an array target, the result is true if\n+@var{TARGET} and @var{POINTER} have the same shape, are not zero-sized arrays,\n+are arrays whose elements are not zero-sized storage sequences, and\n+@var{TARGET} and @var{POINTER} occupy the same storage units in array element\n+order.\n+As in case(B), the result is false, if @var{POINTER} is disassociated.\n+@item (D) If @var{TARGET} is present and an scalar pointer, the result is true\n+if @var{TARGET} is associated with @var{POINTER}, the target associated with\n+@var{TARGET} are not zero-sized storage sequences and occupy the same storage\n+units.\n+The result is false, if either @var{TARGET} or @var{POINTER} is disassociated.\n+@item (E) If @var{TARGET} is present and an array pointer, the result is true if\n+target associated with @var{POINTER} and the target associated with @var{TARGET}\n+have the same shape, are not zero-sized arrays, are arrays whose elements are\n+not zero-sized storage sequences, and @var{TARGET} and @var{POINTER} occupy\n+the same storage units in array element order.\n+The result is false, if either @var{TARGET} or @var{POINTER} is disassociated.\n @end table\n \n @item @emph{Example}:\n@@ -1355,11 +1357,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it lies in the\n+The return value is of type @code{REAL} and it lies in the\n range @math{ - \\pi / 2 \\leq \\atan (x) \\leq \\pi / 2}.\n \n @item @emph{Example}:\n@@ -1392,7 +1394,7 @@ Inverse function: @ref{TAN}\n \n @table @asis\n @item @emph{Description}:\n-@code{ATAN2(Y,X)} computes the arctangent of the complex number\n+@code{ATAN2(Y, X)} computes the arctangent of the complex number\n @math{X + i Y}.\n \n @item @emph{Standard}:\n@@ -1402,11 +1404,11 @@ Fortran 77 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = ATAN2(Y,X)}\n+@code{RESULT = ATAN2(Y, X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{Y} @tab The type shall be @code{REAL(*)}.\n+@item @var{Y} @tab The type shall be @code{REAL}.\n @item @var{X} @tab The type and kind type parameter shall be the same as @var{Y}.\n If @var{Y} is zero, then @var{X} must be nonzero.\n @end multitable\n@@ -1512,12 +1514,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it lies in the\n-range @math{ - 0.4027... \\leq Bessel (0,x) \\leq 1}.\n+The return value is of type @code{REAL} and lies in the\n+range @math{ - 0.4027... \\leq Bessel (0,x) \\leq 1}. It has the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1560,12 +1563,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it lies in the\n-range @math{ - 0.5818... \\leq Bessel (0,x) \\leq 0.5818 }.\n+The return value is of type @code{REAL} and it lies in the\n+range @math{ - 0.5818... \\leq Bessel (0,x) \\leq 0.5818 }. It has the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1610,12 +1614,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER(*)}.\n-@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL(*)}.\n+@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER}.\n+@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is a scalar of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL}. It has the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1628,7 +1633,7 @@ end program test_besjn\n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n @item Name             @tab Argument            @tab Return type       @tab Standard\n-@item @code{DBESJN(X)} @tab @code{INTEGER(*) N} @tab @code{REAL(8)}    @tab GNU extension\n+@item @code{DBESJN(X)} @tab @code{INTEGER N} @tab @code{REAL(8)}    @tab GNU extension\n @item                  @tab @code{REAL(8) X}    @tab                   @tab\n @end multitable\n @end table\n@@ -1659,11 +1664,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is a scalar of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL}. It has the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1706,11 +1712,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be @code{REAL}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is a scalar of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL}. It has the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1755,12 +1762,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER(*)}.\n-@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL(*)}.\n+@item @var{N} @tab Shall be a scalar or an array of type  @code{INTEGER}.\n+@item @var{X} @tab Shall be a scalar or an array of type  @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is a scalar of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL}. It has the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1773,7 +1781,7 @@ end program test_besyn\n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n @item Name               @tab Argument            @tab Return type     @tab Standard\n-@item @code{DBESYN(N,X)} @tab @code{INTEGER(*) N} @tab @code{REAL(8)}  @tab GNU extension\n+@item @code{DBESYN(N,X)} @tab @code{INTEGER N} @tab @code{REAL(8)}  @tab GNU extension\n @item                    @tab @code{REAL(8)    X} @tab                 @tab \n @end multitable\n @end table\n@@ -1802,11 +1810,11 @@ Inquiry function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)}\n+The return value is of type @code{INTEGER}\n \n @item @emph{Example}:\n @smallexample\n@@ -1842,8 +1850,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{POS} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1872,8 +1880,8 @@ end program test_btest\n \n @table @asis\n @item @emph{Description}:\n-@code{C_ASSOCIATED(c_prt1[, c_ptr2])} determines the status of the C pointer @var{c_ptr1}\n-or if @var{c_ptr1} is associated with the target @var{c_ptr2}.\n+@code{C_ASSOCIATED(c_prt_1[, c_ptr_2])} determines the status of the C pointer\n+@var{c_ptr_1} or if @var{c_ptr_1} is associated with the target @var{c_ptr_2}.\n \n @item @emph{Standard}:\n Fortran 2003 and later\n@@ -1882,17 +1890,17 @@ Fortran 2003 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = C_ASSOCIATED(c_prt1[, c_ptr2])}\n+@code{RESULT = C_ASSOCIATED(c_prt_1[, c_ptr_2])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{c_ptr1} @tab Scalar of the type @code{C_PTR} or @code{C_FUNPTR}.\n-@item @var{c_ptr2} @tab (Optional) Scalar of the same type as @var{c_ptr1}.\n+@item @var{c_ptr_1} @tab Scalar of the type @code{C_PTR} or @code{C_FUNPTR}.\n+@item @var{c_ptr_2} @tab (Optional) Scalar of the same type as @var{c_ptr_1}.\n @end multitable\n \n @item @emph{Return value}:\n The return value is of type @code{LOGICAL}; it is @code{.false.} if either\n-@var{c_ptr1} is a C NULL pointer or if @var{c_ptr1} and @var{c_ptr2}\n+@var{c_ptr_1} is a C NULL pointer or if @var{c_ptr1} and @var{c_ptr_2}\n point to different addresses.\n \n @item @emph{Example}:\n@@ -1976,8 +1984,8 @@ end program main\n \n @table @asis\n @item @emph{Description}:\n-@code{C_F_PROCPOINTER(cptr, fptr)} Assign the target of the C function pointer\n-@var{cptr} to the Fortran procedure pointer @var{fptr}.\n+@code{C_F_PROCPOINTER(CPTR, FPTR)} Assign the target of the C function pointer\n+@var{CPTR} to the Fortran procedure pointer @var{FPTR}.\n \n Note: Due to the currently lacking support of procedure pointers in GNU Fortran\n this function is not fully operable.\n@@ -1993,9 +2001,9 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{cptr}  @tab scalar of the type @code{C_FUNPTR}. It is\n+@item @var{CPTR}  @tab scalar of the type @code{C_FUNPTR}. It is\n \t\t       @code{INTENT(IN)}.\n-@item @var{fptr}  @tab procedure pointer interoperable with @var{cptr}. It is\n+@item @var{FPTR}  @tab procedure pointer interoperable with @var{cptr}. It is\n \t\t       @code{INTENT(OUT)}.\n @end multitable\n \n@@ -2036,8 +2044,8 @@ end program main\n \n @table @asis\n @item @emph{Description}:\n-@code{C_F_POINTER(cptr, fptr[, shape])} Assign the target the C pointer\n-@var{cptr} to the Fortran pointer @var{fptr} and specify its\n+@code{C_F_POINTER(CPTR, FPTR[, SHAPE])} Assign the target the C pointer\n+@var{CPTR} to the Fortran pointer @var{FPTR} and specify its\n shape.\n \n @item @emph{Standard}:\n@@ -2047,15 +2055,15 @@ Fortran 2003 and later\n Subroutine\n \n @item @emph{Syntax}:\n-@code{CALL C_F_POINTER(cptr, fptr[, shape])}\n+@code{CALL C_F_POINTER(CPTR, FPTR[, SHAPE])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{cptr}  @tab scalar of the type @code{C_PTR}. It is\n+@item @var{CPTR}  @tab scalar of the type @code{C_PTR}. It is\n \t\t       @code{INTENT(IN)}.\n-@item @var{fptr}  @tab pointer interoperable with @var{cptr}. It is\n+@item @var{FPTR}  @tab pointer interoperable with @var{cptr}. It is\n \t\t       @code{INTENT(OUT)}.\n-@item @var{shape} @tab (Optional) Rank-one array of type @code{INTEGER}\n+@item @var{SHAPE} @tab (Optional) Rank-one array of type @code{INTEGER}\n                        with @code{INTENT(IN)}. It shall be present\n \t\t       if and only if @var{fptr} is an array. The size\n \t\t       must be equal to the rank of @var{fptr}.\n@@ -2091,7 +2099,7 @@ end program main\n \n @table @asis\n @item @emph{Description}:\n-@code{C_LOC(x)} determines the C address of the argument.\n+@code{C_LOC(X)} determines the C address of the argument.\n \n @item @emph{Standard}:\n Fortran 2003 and later\n@@ -2100,11 +2108,11 @@ Fortran 2003 and later\n Inquiry function\n \n @item @emph{Syntax}:\n-@code{RESULT = C_LOC(x)}\n+@code{RESULT = C_LOC(X)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{x} @tab Associated scalar pointer or interoperable scalar\n+@item @var{X} @tab Associated scalar pointer or interoperable scalar\n \t\t   or allocated allocatable variable with @code{TARGET}\n \t\t   attribute.\n @end multitable\n@@ -2138,7 +2146,7 @@ end subroutine association_test\n \n @table @asis\n @item @emph{Description}:\n-@code{CEILING(X)} returns the least integer greater than or equal to @var{X}.\n+@code{CEILING(A)} returns the least integer greater than or equal to @var{A}.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -2147,18 +2155,19 @@ Fortran 95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = CEILING(X [, KIND])}\n+@code{RESULT = CEILING(A [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{A} @tab The type shall be @code{REAL}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(KIND)}\n+The return value is of type @code{INTEGER(KIND)} if @var{KIND} is present\n+and a default-kind @code{INTEGER} otherwise.\n \n @item @emph{Example}:\n @smallexample\n@@ -2197,8 +2206,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n@@ -2253,7 +2262,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NAME}   @tab The type shall be @code{CHARACTER(*)} and shall\n+@item @var{NAME}   @tab The type shall be @code{CHARACTER} and shall\n                         specify a valid path within the file system.\n @item @var{STATUS} @tab (Optional) @code{INTEGER} status flag of the default\n                         kind.  Returns 0 on success, and a system specific\n@@ -2370,12 +2379,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type may be @code{INTEGER(*)}, @code{REAL(*)},\n-                   or @code{COMPLEX(*)}.\n+@item @var{X} @tab The type may be @code{INTEGER}, @code{REAL},\n+                   or @code{COMPLEX}.\n @item @var{Y} @tab (Optional; only allowed if @var{X} is not\n-                   @code{COMPLEX(*)}.)  May be @code{INTEGER(*)}\n-\t\t   or @code{REAL(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+                   @code{COMPLEX}.)  May be @code{INTEGER}\n+\t\t   or @code{REAL}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n@@ -2470,8 +2479,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)}.\n-@item @var{Y} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)}.\n+@item @var{X} @tab The type may be @code{INTEGER} or @code{REAL}.\n+@item @var{Y} @tab The type may be @code{INTEGER} or @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -2520,11 +2529,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{Z} @tab The type shall be @code{COMPLEX(*)}.\n+@item @var{Z} @tab The type shall be @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{COMPLEX(*)}.\n+The return value is of type @code{COMPLEX}.\n \n @item @emph{Example}:\n @smallexample\n@@ -2572,12 +2581,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)} or\n-@code{COMPLEX(*)}.\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it lies in the\n+The return value is of type @code{REAL} and it lies in the\n range @math{ -1 \\leq \\cos (x) \\leq 1}.  The kind type\n parameter is the same as @var{X}.\n \n@@ -2628,12 +2637,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it is positive\n-(@math{ \\cosh (x) \\geq 0 }.\n+The return value is of type @code{REAL} and it is positive\n+(@math{ \\cosh (x) \\geq 0 }. The return value is of the same\n+kind as @var{X}.\n \n @item @emph{Example}:\n @smallexample\n@@ -2730,7 +2740,7 @@ end program test_count\n \n @table @asis\n @item @emph{Description}:\n-Returns a @code{REAL(*)} value representing the elapsed CPU time in\n+Returns a @code{REAL} value representing the elapsed CPU time in\n seconds.  This is useful for testing segments of code to determine\n execution time.\n \n@@ -2755,7 +2765,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{TIME} @tab The type shall be @code{REAL(*)} with @code{INTENT(OUT)}.\n+@item @var{TIME} @tab The type shall be @code{REAL} with @code{INTENT(OUT)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -2969,7 +2979,7 @@ end program test_time_and_date\n \n @table @asis\n @item @emph{Description}:\n-@code{DBLE(X)} Converts @var{X} to double precision real type.\n+@code{DBLE(A)} Converts @var{A} to double precision real type.\n \n @item @emph{Standard}:\n Fortran 77 and later\n@@ -2978,12 +2988,12 @@ Fortran 77 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = DBLE(X)}\n+@code{RESULT = DBLE(A)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{INTEGER(*)}, @code{REAL(*)},\n-                   or @code{COMPLEX(*)}.\n+@item @var{A} @tab The type shall be @code{INTEGER}, @code{REAL},\n+                   or @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3029,10 +3039,10 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type may be @code{INTEGER(*)}, @code{REAL(*)},\n-                   or @code{COMPLEX(*)}.\n-@item @var{Y} @tab (Optional if @var{X} is not @code{COMPLEX(*)}.) May be\n-                   @code{INTEGER(*)} or @code{REAL(*)}. \n+@item @var{X} @tab The type may be @code{INTEGER}, @code{REAL},\n+                   or @code{COMPLEX}.\n+@item @var{Y} @tab (Optional if @var{X} is not @code{COMPLEX}.) May be\n+                   @code{INTEGER} or @code{REAL}. \n @end multitable\n \n @item @emph{Return value}:\n@@ -3062,7 +3072,7 @@ end program test_dcmplx\n \n @table @asis\n @item @emph{Description}:\n-@code{DFLOAT(X)} Converts @var{X} to double precision real type.\n+@code{DFLOAT(A)} Converts @var{A} to double precision real type.\n \n @item @emph{Standard}:\n GNU extension\n@@ -3071,11 +3081,11 @@ GNU extension\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = DFLOAT(X)}\n+@code{RESULT = DFLOAT(A)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{A} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3117,7 +3127,7 @@ Inquiry function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)}.\n+@item @var{X} @tab The type may be @code{INTEGER} or @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3161,12 +3171,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{INTEGER(*)} or @code{REAL(*)}\n+@item @var{X} @tab The type shall be @code{INTEGER} or @code{REAL}\n @item @var{Y} @tab The type shall be the same type and kind as @var{X}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} or @code{REAL(*)}.\n+The return value is of type @code{INTEGER} or @code{REAL}.\n \n @item @emph{Example}:\n @smallexample\n@@ -3199,12 +3209,13 @@ end program test_dim\n \n @table @asis\n @item @emph{Description}:\n-@code{DOT_PRODUCT(X,Y)} computes the dot product multiplication of two vectors\n-@var{X} and @var{Y}.  The two vectors may be either numeric or logical\n-and must be arrays of rank one and of equal size. If the vectors are\n-@code{INTEGER(*)} or @code{REAL(*)}, the result is @code{SUM(X*Y)}. If the\n-vectors are @code{COMPLEX(*)}, the result is @code{SUM(CONJG(X)*Y)}. If the \n-vectors are @code{LOGICAL}, the result is @code{ANY(X.AND.Y)}.\n+@code{DOT_PRODUCT(VECTOR_A, VECTOR_B)} computes the dot product multiplication\n+of two vectors @var{VECTOR_A} and @var{VECTOR_B}.  The two vectors may be\n+either numeric or logical and must be arrays of rank one and of equal size. If\n+the vectors are @code{INTEGER} or @code{REAL}, the result is\n+@code{SUM(VECTOR_A*VECTOR_B)}. If the vectors are @code{COMPLEX}, the result\n+is @code{SUM(CONJG(VECTOR_A)*VECTOR_B)}. If the vectors are @code{LOGICAL},\n+the result is @code{ANY(VECTOR_A .AND. VECTOR_B)}.  \n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -3213,17 +3224,17 @@ Fortran 95 and later\n Transformational function\n \n @item @emph{Syntax}:\n-@code{RESULT = DOT_PRODUCT(X, Y)}\n+@code{RESULT = DOT_PRODUCT(VECTOR_A, VECTOR_B)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be numeric or @code{LOGICAL}, rank 1.\n-@item @var{Y} @tab The type shall be numeric or @code{LOGICAL}, rank 1.\n+@item @var{VECTOR_A} @tab The type shall be numeric or @code{LOGICAL}, rank 1.\n+@item @var{VECTOR_B} @tab The type shall be numeric if @var{VECTOR_A} is of numeric type or @code{LOGICAL} if @var{VECTOR_A} is of type @code{LOGICAL}. @var{VECTOR_B} shall be a rank-one array.\n @end multitable\n \n @item @emph{Return value}:\n If the arguments are numeric, the return value is a scaler of numeric type,\n-@code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.  If the arguments are\n+@code{INTEGER}, @code{REAL}, or @code{COMPLEX}.  If the arguments are\n @code{LOGICAL}, the return value is @code{.TRUE.} or @code{.FALSE.}.\n \n @item @emph{Example}:\n@@ -3300,11 +3311,11 @@ GNU extension\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = DREAL(Z)}\n+@code{RESULT = DREAL(A)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{Z} @tab The type shall be @code{COMPLEX(8)}.\n+@item @var{A} @tab The type shall be @code{COMPLEX(8)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3421,7 +3432,7 @@ end program test_dtime\n \n @table @asis\n @item @emph{Description}:\n-@code{EOSHIFT(ARRAY, SHIFT[,BOUNDARY, DIM])} performs an end-off shift on\n+@code{EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM])} performs an end-off shift on\n elements of @var{ARRAY} along the dimension of @var{DIM}.  If @var{DIM} is\n omitted it is taken to be @code{1}.  @var{DIM} is a scaler of type\n @code{INTEGER} in the range of @math{1 /leq DIM /leq n)} where @math{n} is the\n@@ -3499,7 +3510,7 @@ Inquiry function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3790,8 +3801,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)} or\n-@code{COMPLEX(*)}.\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3839,7 +3850,7 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -3923,7 +3934,7 @@ end program test_fdate\n \n @table @asis\n @item @emph{Description}:\n-@code{FLOAT(I)} converts the integer @var{I} to a default real value.\n+@code{FLOAT(A)} converts the integer @var{A} to a default real value.\n \n @item @emph{Standard}:\n Fortran 77 and later\n@@ -3932,11 +3943,11 @@ Fortran 77 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = FLOAT(I)}\n+@code{RESULT = FLOAT(A)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{A} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -4085,7 +4096,7 @@ END PROGRAM\n \n @table @asis\n @item @emph{Description}:\n-@code{FLOOR(X)} returns the greatest integer less than or equal to @var{X}.\n+@code{FLOOR(A)} returns the greatest integer less than or equal to @var{X}.\n \n @item @emph{Standard}:\n Fortran 95 and later\n@@ -4094,18 +4105,19 @@ Fortran 95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = FLOOR(X [, KIND])}\n+@code{RESULT = FLOOR(A [, KIND])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{A} @tab The type shall be @code{REAL}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(KIND)}\n+The return value is of type @code{INTEGER(KIND)} if @var{KIND} is present\n+and of default-kind @code{INTEGER} otherwise.\n \n @item @emph{Example}:\n @smallexample\n@@ -4644,7 +4656,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{RESULT}  @tab Shall of type @code{CHARACTER(*)}.\n+@item @var{RESULT}  @tab Shall of type @code{CHARACTER}.\n @end multitable\n \n @item @emph{Example}:\n@@ -4670,7 +4682,7 @@ END PROGRAM\n \n @table @asis\n @item @emph{Description}:\n-Retrieve the @var{N}th argument that was passed on the\n+Retrieve the @var{POS}-th argument that was passed on the\n command line when the containing program was invoked.\n \n This intrinsic routine is provided for backwards compatibility with \n@@ -4691,7 +4703,7 @@ Subroutine\n @multitable @columnfractions .15 .70\n @item @var{POS}   @tab Shall be of type @code{INTEGER} and not wider than\n the default integer kind; @math{@var{POS} \\geq 0}\n-@item @var{VALUE} @tab Shall be of type @code{CHARACTER(*)}. \n+@item @var{VALUE} @tab Shall be of type @code{CHARACTER}. \n @end multitable\n \n @item @emph{Return value}:\n@@ -4741,16 +4753,17 @@ Fortran 2003 and later\n Subroutine\n \n @item @emph{Syntax}:\n-@code{CALL GET_COMMAND(CMD)}\n+@code{CALL GET_COMMAND(COMMAND)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{CMD} @tab Shall be of type @code{CHARACTER(*)}. \n+@item @var{COMMAND} @tab Shall be of type @code{CHARACTER}. \n @end multitable\n \n @item @emph{Return value}:\n-Stores the entire command line that was used to invoke the program in @var{ARG}. \n-If @var{ARG} is not large enough, the command will be truncated. \n+Stores the entire command line that was used to invoke the program in\n+@var{COMMAND}. If @var{COMMAND} is not large enough, the command will be\n+truncated. \n \n @item @emph{Example}:\n @smallexample\n@@ -4790,7 +4803,7 @@ Subroutine\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{N}   @tab Shall be of type @code{INTEGER(4)}, @math{@var{N} \\geq 0}\n-@item @var{ARG} @tab Shall be of type @code{CHARACTER(*)}. \n+@item @var{ARG} @tab Shall be of type @code{CHARACTER}. \n @end multitable\n \n @item @emph{Return value}:\n@@ -4847,7 +4860,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{CWD}    @tab The type shall be @code{CHARACTER(*)}.\n+@item @var{CWD}    @tab The type shall be @code{CHARACTER}.\n @item @var{STATUS} @tab (Optional) status flag. Returns 0 on success, \n                         a system specific and nonzero error code otherwise.\n @end multitable\n@@ -4892,8 +4905,8 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ENVVAR} @tab Shall be of type @code{CHARACTER(*)}. \n-@item @var{VALUE}  @tab Shall be of type @code{CHARACTER(*)}. \n+@item @var{ENVVAR} @tab Shall be of type @code{CHARACTER}. \n+@item @var{VALUE}  @tab Shall be of type @code{CHARACTER}. \n @end multitable\n \n @item @emph{Return value}:\n@@ -4936,8 +4949,8 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ENVVAR} @tab Shall be of type @code{CHARACTER(*)}. \n-@item @var{VALUE}  @tab Shall be of type @code{CHARACTER(*)}. \n+@item @var{ENVVAR} @tab Shall be of type @code{CHARACTER}. \n+@item @var{VALUE}  @tab Shall be of type @code{CHARACTER}. \n @end multitable\n \n @item @emph{Return value}:\n@@ -5010,7 +5023,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{LOGIN} @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{LOGIN} @tab Shall be of type @code{CHARACTER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -5129,7 +5142,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STIME}  @tab An @code{INTEGER(*)} scalar expression\n+@item @var{STIME}  @tab An @code{INTEGER} scalar expression\n                         corresponding to a system time, with \n \t\t\t@code{INTENT(IN)}.\n @item @var{TARRAY} @tab A default @code{INTEGER} array with 9 elements,\n@@ -5186,7 +5199,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{NAME}    @tab Shall of type @code{CHARACTER(*)}.\n+@item @var{NAME}    @tab Shall of type @code{CHARACTER}.\n @item @var{STATUS}  @tab (Optional) status flag of type @code{INTEGER}.\n                          Returns 0 on success, or a system specific error\n                          code otherwise.\n@@ -5352,14 +5365,14 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{J} @tab The type shall be @code{INTEGER(*)}, of the same\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{J} @tab The type shall be @code{INTEGER}, of the same\n kind as @var{I}.  (As a GNU extension, different kinds are also \n permitted.)\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER(*)}, of the same kind as the\n+The return type is @code{INTEGER}, of the same kind as the\n arguments.  (If the argument kinds differ, it is of the same kind as\n the larger argument.)\n \n@@ -5445,12 +5458,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{POS} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -5485,13 +5498,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{LEN} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{POS} @tab The type shall be @code{INTEGER}.\n+@item @var{LEN} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -5521,12 +5534,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{POS} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -5674,14 +5687,14 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{J} @tab The type shall be @code{INTEGER(*)}, of the same\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{J} @tab The type shall be @code{INTEGER}, of the same\n kind as @var{I}.  (As a GNU extension, different kinds are also \n permitted.)\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER(*)}, of the same kind as the\n+The return type is @code{INTEGER}, of the same kind as the\n arguments.  (If the argument kinds differ, it is of the same kind as\n the larger argument.)\n \n@@ -5748,11 +5761,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab Shall be a scalar @code{CHARACTER(*)}, with\n+@item @var{STRING} @tab Shall be a scalar @code{CHARACTER}, with\n @code{INTENT(IN)}\n-@item @var{SUBSTRING} @tab Shall be a scalar @code{CHARACTER(*)}, with\n+@item @var{SUBSTRING} @tab Shall be a scalar @code{CHARACTER}, with\n @code{INTENT(IN)}\n-@item @var{BACK} @tab (Optional) Shall be a scalar @code{LOGICAL(*)}, with\n+@item @var{BACK} @tab (Optional) Shall be a scalar @code{LOGICAL}, with\n @code{INTENT(IN)}\n @item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n@@ -5791,26 +5804,26 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A}    @tab Shall be of type @code{INTEGER(*)},\n-                      @code{REAL(*)}, or @code{COMPLEX(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{A}    @tab Shall be of type @code{INTEGER},\n+                      @code{REAL}, or @code{COMPLEX}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-These functions return a @code{INTEGER(*)} variable or array under \n+These functions return a @code{INTEGER} variable or array under \n the following rules: \n \n @table @asis\n @item (A)\n-If @var{A} is of type @code{INTEGER(*)}, @code{INT(A) = A} \n+If @var{A} is of type @code{INTEGER}, @code{INT(A) = A} \n @item (B)\n-If @var{A} is of type @code{REAL(*)} and @math{|A| < 1}, @code{INT(A)} equals @code{0}. \n+If @var{A} is of type @code{REAL} and @math{|A| < 1}, @code{INT(A)} equals @code{0}. \n If @math{|A| \\geq 1}, then @code{INT(A)} equals the largest integer that does not exceed \n the range of @var{A} and whose sign is the same as the sign of @var{A}.\n @item (C)\n-If @var{A} is of type @code{COMPLEX(*)}, rule B is applied to the real part of @var{A}.\n+If @var{A} is of type @code{COMPLEX}, rule B is applied to the real part of @var{A}.\n @end table\n \n @item @emph{Example}:\n@@ -5859,8 +5872,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A}    @tab Shall be of type @code{INTEGER(*)},\n-                      @code{REAL(*)}, or @code{COMPLEX(*)}.\n+@item @var{A}    @tab Shall be of type @code{INTEGER},\n+                      @code{REAL}, or @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -5894,8 +5907,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A}    @tab Shall be of type @code{INTEGER(*)},\n-                      @code{REAL(*)}, or @code{COMPLEX(*)}.\n+@item @var{A}    @tab Shall be of type @code{INTEGER},\n+                      @code{REAL}, or @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -5929,14 +5942,14 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{J} @tab The type shall be @code{INTEGER(*)}, of the same\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{J} @tab The type shall be @code{INTEGER}, of the same\n kind as @var{I}.  (As a GNU extension, different kinds are also \n permitted.)\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER(*)}, of the same kind as the\n+The return type is @code{INTEGER}, of the same kind as the\n arguments.  (If the argument kinds differ, it is of the same kind as\n the larger argument.)\n \n@@ -6107,7 +6120,7 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{UNIT} @tab Shall be a scalar @code{INTEGER(*)}.\n+@item @var{UNIT} @tab Shall be a scalar @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -6155,12 +6168,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{SHIFT} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -6196,15 +6209,15 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{SHIFT} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{SIZE} @tab (Optional) The type shall be @code{INTEGER(*)};\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n+@item @var{SIZE} @tab (Optional) The type shall be @code{INTEGER};\n the value must be greater than zero and less than or equal to\n @code{BIT_SIZE(I)}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -6401,7 +6414,7 @@ Inquiry function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{ARRAY} @tab Shall be an array, of any type.\n-@item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER(*)}.\n+@item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER}.\n @item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n@@ -6447,7 +6460,7 @@ Inquiry function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{STRING} @tab Shall be a scalar or array of type\n-@code{CHARACTER(*)}, with @code{INTENT(IN)}\n+@code{CHARACTER}, with @code{INTENT(IN)}\n @item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n@@ -6483,7 +6496,7 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER(*)},\n+@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER},\n with @code{INTENT(IN)}\n @item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n@@ -6803,7 +6816,7 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER(*)},\n+@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER},\n with @code{INTENT(IN)}\n @end multitable\n \n@@ -6883,12 +6896,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)} or\n-@code{COMPLEX(*)}.\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.\n+The return value is of type @code{REAL} or @code{COMPLEX}.\n The kind type parameter is the same as @var{X}.\n \n @item @emph{Example}:\n@@ -6937,11 +6950,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.\n+The return value is of type @code{REAL} or @code{COMPLEX}.\n The kind type parameter is the same as @var{X}.\n \n @item @emph{Example}:\n@@ -6982,8 +6995,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{L}    @tab The type shall be @code{LOGICAL(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{L}    @tab The type shall be @code{LOGICAL}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n@@ -7022,8 +7035,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A}    @tab Shall be of type @code{INTEGER(*)},\n-                      @code{REAL(*)}, or @code{COMPLEX(*)}.\n+@item @var{A}    @tab Shall be of type @code{INTEGER},\n+                      @code{REAL}, or @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -7062,12 +7075,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{SHIFT} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -7103,7 +7116,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{FILE}   @tab The type shall be @code{CHARACTER(*)}, a valid path within the file system.\n+@item @var{FILE}   @tab The type shall be @code{CHARACTER}, a valid path within the file system.\n @item @var{BUFF}   @tab The type shall be @code{INTEGER(4), DIMENSION(13)}.\n @item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER(4)}. Returns 0 \n                         on success and a system specific error code otherwise.\n@@ -7140,7 +7153,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STIME}  @tab An @code{INTEGER(*)} scalar expression\n+@item @var{STIME}  @tab An @code{INTEGER} scalar expression\n                         corresponding to a system time, with \n \t\t\t@code{INTENT(IN)}.\n @item @var{TARRAY} @tab A default @code{INTEGER} array with 9 elements,\n@@ -7196,7 +7209,7 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{SIZE} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{SIZE} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -7258,14 +7271,14 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{MATRIX_A} @tab An array of @code{INTEGER(*)},\n-                          @code{REAL(*)}, @code{COMPLEX(*)}, or\n-\t\t\t  @code{LOGICAL(*)} type, with a rank of\n+@item @var{MATRIX_A} @tab An array of @code{INTEGER},\n+                          @code{REAL}, @code{COMPLEX}, or\n+\t\t\t  @code{LOGICAL} type, with a rank of\n \t\t\t  one or two.\n-@item @var{MATRIX_B} @tab An array of @code{INTEGER(*)},\n-                          @code{REAL(*)}, or @code{COMPLEX(*)} type if\n+@item @var{MATRIX_B} @tab An array of @code{INTEGER},\n+                          @code{REAL}, or @code{COMPLEX} type if\n \t\t\t  @var{MATRIX_A} is of a numeric type;\n-\t\t\t  otherwise, an array of @code{LOGICAL(*)}\n+\t\t\t  otherwise, an array of @code{LOGICAL}\n \t\t\t  type. The rank shall be one or two, and the\n \t\t\t  first (or only) dimension of @var{MATRIX_B}\n \t\t\t  shall be equal to the last (or only)\n@@ -7307,8 +7320,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A1}          @tab The type shall be @code{INTEGER(*)} or\n-                             @code{REAL(*)}.\n+@item @var{A1}          @tab The type shall be @code{INTEGER} or\n+                             @code{REAL}.\n @item @var{A2}, @var{A3}, ... @tab An expression of the same type and kind\n                              as @var{A1}.  (As a GNU extension, \n \t\t\t     arguments of different kinds are\n@@ -7324,7 +7337,7 @@ and has the same type and kind as the first argument.\n @item Name             @tab Argument            @tab Return type         @tab Standard\n @item @code{MAX0(I)}   @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)}   @tab Fortran 77 and later\n @item @code{AMAX0(I)}  @tab @code{INTEGER(4) I} @tab @code{REAL(MAX(X))} @tab Fortran 77 and later\n-@item @code{MAX1(X)}   @tab @code{REAL(*) X}    @tab @code{INT(MAX(X))}  @tab Fortran 77 and later\n+@item @code{MAX1(X)}   @tab @code{REAL X}    @tab @code{INT(MAX(X))}  @tab Fortran 77 and later\n @item @code{AMAX1(X)}  @tab @code{REAL(4)    X} @tab @code{REAL(4)}      @tab Fortran 77 and later\n @item @code{DMAX1(X)}  @tab @code{REAL(8)    X} @tab @code{REAL(8)}      @tab Fortran 77 and later\n @end multitable\n@@ -7411,13 +7424,13 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)},\n-                       @code{REAL(*)}, or @code{CHARACTER(*)}.\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER},\n+                       @code{REAL}, or @code{CHARACTER}.\n @item @var{DIM}   @tab (Optional) Shall be a scalar of type\n-                       @code{INTEGER(*)}, with a value between one\n+                       @code{INTEGER}, with a value between one\n \t\t       and the rank of @var{ARRAY}, inclusive.  It\n \t\t       may not be an optional dummy argument.\n-@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL(*)},\n+@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL},\n                        and conformable with @var{ARRAY}.\n @end multitable\n \n@@ -7468,13 +7481,13 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)},\n-                       @code{REAL(*)}, or @code{CHARACTER(*)}.\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER},\n+                       @code{REAL}, or @code{CHARACTER}.\n @item @var{DIM}   @tab (Optional) Shall be a scalar of type\n-                       @code{INTEGER(*)}, with a value between one\n+                       @code{INTEGER}, with a value between one\n \t\t       and the rank of @var{ARRAY}, inclusive.  It\n \t\t       may not be an optional dummy argument.\n-@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL(*)},\n+@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL},\n                        and conformable with @var{ARRAY}.\n @end multitable\n \n@@ -7595,7 +7608,7 @@ Elemental function\n @item @var{TSOURCE} @tab May be of any type.\n @item @var{FSOURCE} @tab Shall be of the same type and type parameters\n                          as @var{TSOURCE}.\n-@item @var{MASK}    @tab Shall be of type @code{LOGICAL(*)}.\n+@item @var{MASK}    @tab Shall be of type @code{LOGICAL}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -7630,8 +7643,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A1}          @tab The type shall be @code{INTEGER(*)} or\n-                             @code{REAL(*)}.\n+@item @var{A1}          @tab The type shall be @code{INTEGER} or\n+                             @code{REAL}.\n @item @var{A2}, @var{A3}, ... @tab An expression of the same type and kind\n                              as @var{A1}.  (As a GNU extension, \n \t\t\t     arguments of different kinds are\n@@ -7647,7 +7660,7 @@ and has the same type and kind as the first argument.\n @item Name             @tab Argument            @tab Return type         @tab Standard\n @item @code{MIN0(I)}   @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)}   @tab Fortran 77 and later\n @item @code{AMIN0(I)}  @tab @code{INTEGER(4) I} @tab @code{REAL(MIN(X))} @tab Fortran 77 and later\n-@item @code{MIN1(X)}   @tab @code{REAL(*) X}    @tab @code{INT(MIN(X))}  @tab Fortran 77 and later\n+@item @code{MIN1(X)}   @tab @code{REAL X}    @tab @code{INT(MIN(X))}  @tab Fortran 77 and later\n @item @code{AMIN1(X)}  @tab @code{REAL(4)    X} @tab @code{REAL(4)}      @tab Fortran 77 and later\n @item @code{DMIN1(X)}  @tab @code{REAL(8)    X} @tab @code{REAL(8)}      @tab Fortran 77 and later\n @end multitable\n@@ -7725,13 +7738,13 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)},\n-                       @code{REAL(*)}, or @code{CHARACTER(*)}.\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER},\n+                       @code{REAL}, or @code{CHARACTER}.\n @item @var{DIM}   @tab (Optional) Shall be a scalar of type\n-                       @code{INTEGER(*)}, with a value between one\n+                       @code{INTEGER}, with a value between one\n \t\t       and the rank of @var{ARRAY}, inclusive.  It\n \t\t       may not be an optional dummy argument.\n-@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL(*)},\n+@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL},\n                        and conformable with @var{ARRAY}.\n @end multitable\n \n@@ -7782,13 +7795,13 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)},\n-                       @code{REAL(*)}, or @code{CHARACTER(*)}.\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER},\n+                       @code{REAL}, or @code{CHARACTER}.\n @item @var{DIM}   @tab (Optional) Shall be a scalar of type\n-                       @code{INTEGER(*)}, with a value between one\n+                       @code{INTEGER}, with a value between one\n \t\t       and the rank of @var{ARRAY}, inclusive.  It\n \t\t       may not be an optional dummy argument.\n-@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL(*)},\n+@item @var{MASK}  @tab Shall be an array of type @code{LOGICAL},\n                        and conformable with @var{ARRAY}.\n @end multitable\n \n@@ -7996,12 +8009,12 @@ Elemental subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{FROM}    @tab The type shall be @code{INTEGER(*)}.\n-@item @var{FROMPOS} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{LEN}     @tab The type shall be @code{INTEGER(*)}.\n-@item @var{TO}      @tab The type shall be @code{INTEGER(*)}, of the\n+@item @var{FROM}    @tab The type shall be @code{INTEGER}.\n+@item @var{FROMPOS} @tab The type shall be @code{INTEGER}.\n+@item @var{LEN}     @tab The type shall be @code{INTEGER}.\n+@item @var{TO}      @tab The type shall be @code{INTEGER}, of the\n                          same kind as @var{FROM}.\n-@item @var{TOPOS}   @tab The type shall be @code{INTEGER(*)}.\n+@item @var{TOPOS}   @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{See also}:\n@@ -8175,11 +8188,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER(*)}, of the same kind as the\n+The return type is @code{INTEGER}, of the same kind as the\n argument.\n \n @item @emph{See also}:\n@@ -8259,13 +8272,13 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be either a scalar @code{INTEGER(*)}\n+@item @var{X} @tab The type shall be either a scalar @code{INTEGER}\n type or a scalar @code{LOGICAL} type.\n @item @var{Y} @tab The type shall be the same as the type of @var{X}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is either a scalar @code{INTEGER(*)} or a scalar\n+The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n return has the larger kind.\n@@ -8497,8 +8510,8 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)}, \n-@code{REAL(*)} or @code{COMPLEX(*)}.\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER}, \n+@code{REAL} or @code{COMPLEX}.\n @item @var{DIM}   @tab (Optional) shall be a scalar of type \n @code{INTEGER} with a value in the range from 1 to n, where n \n equals the rank of @var{ARRAY}.\n@@ -8685,7 +8698,7 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{HARVEST} @tab Shall be a scalar or an array of type @code{REAL(*)}.\n+@item @var{HARVEST} @tab Shall be a scalar or an array of type @code{REAL}.\n @end multitable\n \n @item @emph{Example}:\n@@ -8827,15 +8840,15 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X}    @tab Shall be @code{INTEGER(*)}, @code{REAL(*)}, or\n-                      @code{COMPLEX(*)}.\n-@item @var{KIND} @tab (Optional) An @code{INTEGER(*)} initialization\n+@item @var{X}    @tab Shall be @code{INTEGER}, @code{REAL}, or\n+                      @code{COMPLEX}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n                       expression indicating the kind parameter of\n \t\t      the result.\n @end multitable\n \n @item @emph{Return value}:\n-These functions return a @code{REAL(*)} variable or array under\n+These functions return a @code{REAL} variable or array under\n the following rules: \n \n @table @asis\n@@ -8930,8 +8943,8 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING}  @tab Shall be scalar and of type @code{CHARACTER(*)}.\n-@item @var{NCOPIES} @tab Shall be scalar and of type @code{INTEGER(*)}.\n+@item @var{STRING}  @tab Shall be scalar and of type @code{CHARACTER}.\n+@item @var{NCOPIES} @tab Shall be scalar and of type @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -9066,12 +9079,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{SHIFT} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{INTEGER(*)} and of the same kind as\n+The return value is of type @code{INTEGER} and of the same kind as\n @var{I}.\n \n @item @emph{See also}:\n@@ -9150,8 +9163,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab Shall be of type @code{CHARACTER(*)}.\n-@item @var{SET}    @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{STRING} @tab Shall be of type @code{CHARACTER}.\n+@item @var{SET}    @tab Shall be of type @code{CHARACTER}.\n @item @var{BACK}   @tab (Optional) shall be of type @code{LOGICAL}.\n @item @var{KIND}   @tab (Optional) An @code{INTEGER} initialization\n                         expression indicating the kind parameter of\n@@ -9647,8 +9660,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)} or\n-@code{COMPLEX(*)}.\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -9700,11 +9713,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)}.\n+The return value is of type @code{REAL}.\n \n @item @emph{Example}:\n @smallexample\n@@ -9909,7 +9922,7 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab Shall be of type @code{REAL(*)}.\n+@item @var{X} @tab Shall be of type @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -10006,12 +10019,12 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)} or\n-@code{COMPLEX(*)}.\n+@item @var{X} @tab The type shall be @code{REAL} or\n+@code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.\n+The return value is of type @code{REAL} or @code{COMPLEX}.\n The kind type parameter is the same as @var{X}.\n \n @item @emph{Example}:\n@@ -10129,7 +10142,7 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{FILE}   @tab The type shall be @code{CHARACTER(*)}, a valid path within the file system.\n+@item @var{FILE}   @tab The type shall be @code{CHARACTER}, a valid path within the file system.\n @item @var{BUFF}   @tab The type shall be @code{INTEGER(4), DIMENSION(13)}.\n @item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER(4)}. Returns 0 \n                         on success and a system specific error code otherwise.\n@@ -10192,8 +10205,8 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER(*)}, \n-@code{REAL(*)} or @code{COMPLEX(*)}.\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER}, \n+@code{REAL} or @code{COMPLEX}.\n @item @var{DIM}   @tab (Optional) shall be a scalar of type \n @code{INTEGER} with a value in the range from 1 to n, where n \n equals the rank of @var{ARRAY}.\n@@ -10382,11 +10395,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)}.  The kind type parameter is\n+The return value is of type @code{REAL}.  The kind type parameter is\n the same as @var{X}.\n \n @item @emph{Example}:\n@@ -10432,11 +10445,11 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type shall be @code{REAL}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and lies in the range\n+The return value is of type @code{REAL} and lies in the range\n @math{ - 1 \\leq tanh(x) \\leq 1 }.\n \n @item @emph{Example}:\n@@ -10689,11 +10702,11 @@ Transformational function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER(*)}.\n+@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER}.\n @end multitable\n \n @item @emph{Return value}:\n-A scalar of type @code{CHARACTER(*)} which length is that of @var{STRING}\n+A scalar of type @code{CHARACTER} which length is that of @var{STRING}\n less the number of trailing blanks.\n \n @item @emph{Example}:\n@@ -10737,8 +10750,8 @@ Subroutine, function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{UNIT} @tab Shall be a scalar @code{INTEGER(*)}.\n-@item @var{NAME} @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{UNIT} @tab Shall be a scalar @code{INTEGER}.\n+@item @var{NAME} @tab Shall be of type @code{CHARACTER}.\n @end multitable\n \n @item @emph{Example}:\n@@ -10778,7 +10791,7 @@ Inquiry function\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{ARRAY} @tab Shall be an array, of any type.\n-@item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER(*)}.\n+@item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER}.\n @item @var{KIND}@tab (Optional) An @code{INTEGER} initialization\n                      expression indicating the kind parameter of\n \t\t     the result.\n@@ -10822,9 +10835,9 @@ Subroutine\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{MASK} @tab Shall be a scalar of type @code{INTEGER(*)}.\n+@item @var{MASK} @tab Shall be a scalar of type @code{INTEGER}.\n @item @var{MASK} @tab (Optional) Shall be a scalar of type\n-                      @code{INTEGER(*)}.\n+                      @code{INTEGER}.\n @end multitable\n \n @end table\n@@ -10948,8 +10961,8 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{STRING} @tab Shall be of type @code{CHARACTER(*)}.\n-@item @var{SET}    @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{STRING} @tab Shall be of type @code{CHARACTER}.\n+@item @var{SET}    @tab Shall be of type @code{CHARACTER}.\n @item @var{BACK}   @tab (Optional) shall be of type @code{LOGICAL}.\n @item @var{KIND}   @tab (Optional) An @code{INTEGER} initialization\n                         expression indicating the kind parameter of\n@@ -11002,13 +11015,13 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be either  a scalar @code{INTEGER(*)}\n+@item @var{X} @tab The type shall be either  a scalar @code{INTEGER}\n type or a scalar @code{LOGICAL} type.\n @item @var{Y} @tab The type shall be the same as the type of @var{I}.\n @end multitable\n \n @item @emph{Return value}:\n-The return type is either a scalar @code{INTEGER(*)} or a scalar\n+The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n return has the larger kind."}]}