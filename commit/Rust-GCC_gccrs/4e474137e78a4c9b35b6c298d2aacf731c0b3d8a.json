{"sha": "4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "node_id": "C_kwDOANBUbNoAKDRlNDc0MTM3ZTc4YTRjOWIzNWI2YzI5OGQyYWFjZjczMWMwYjNkOGE", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2022-04-12T09:29:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:29Z"}, "message": "[Ada] Remove remaining references to gnatfind/gnatxref\n\ngcc/ada/\n\n\t* gnat1drv.adb, gnatcmd.adb: Remove references to gnatfind/xref.\n\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst,\n\tdoc/gnat_ugn/the_gnat_compilation_model.rst: Ditto.\n\t* gnat_ugn.texi: Regenerate.\n\t* gnatfind.adb, gnatxref.adb, xr_tabls.adb, xr_tabls.ads,\n\txref_lib.adb, xref_lib.ads: Removed, no longer used.", "tree": {"sha": "cb641b4cc6bcbcbaa7ca04cc892a18d00b5954d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb641b4cc6bcbcbaa7ca04cc892a18d00b5954d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c92f4fddd68463e7bc21e6a71c89848410311351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c92f4fddd68463e7bc21e6a71c89848410311351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c92f4fddd68463e7bc21e6a71c89848410311351"}], "stats": {"total": 4908, "additions": 16, "deletions": 4892}, "files": [{"sha": "ed6b463efdeb34d83f9a689bfbeca163b4848477", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "patch": "@@ -6015,10 +6015,10 @@ Debugging Control\n \n :switch:`-gnatx`\n   Normally the compiler generates full cross-referencing information in\n-  the :file:`ALI` file. This information is used by a number of tools,\n-  including ``gnatfind`` and ``gnatxref``. The :switch:`-gnatx` switch\n-  suppresses this information. This saves some space and may slightly\n-  speed up compilation, but means that these tools cannot be used.\n+  the :file:`ALI` file. This information is used by a number of tools.\n+  The :switch:`-gnatx` switch suppresses this information. This saves some space\n+  and may slightly speed up compilation, but means that tools depending\n+  on this information cannot be used.\n \n \n .. index:: -fgnat-encodings  (gcc)"}, {"sha": "363670300e3620cfcf3fc410e110cba7320cd1d7", "filename": "gcc/ada/doc/gnat_ugn/the_gnat_compilation_model.rst", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fthe_gnat_compilation_model.rst?ref=4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "patch": "@@ -1743,8 +1743,7 @@ The following information is contained in the :file:`ALI` file.\n   if any of these units are modified.\n \n * Cross-reference data. Contains information on all entities referenced\n-  in the unit. Used by tools like ``gnatxref`` and ``gnatfind`` to\n-  provide cross-reference information.\n+  in the unit. Used by some tools to provide cross-reference information.\n \n For a full detailed description of the format of the :file:`ALI` file,\n see the source of the body of unit ``Lib.Writ``, contained in file\n@@ -2009,8 +2008,8 @@ be :file:`adalib`).\n You can also specify a new default path to the run-time library at compilation\n time with the switch :switch:`--RTS=rts-path`. You can thus choose / change\n the run-time library you want your program to be compiled with. This switch is\n-recognized by ``gcc``, ``gnatmake``, ``gnatbind``,\n-``gnatls``, ``gnatfind`` and ``gnatxref``.\n+recognized by ``gcc``, ``gnatmake``, ``gnatbind``, ``gnatls``, and all\n+project aware tools.\n \n It is possible to install a library before or after the standard GNAT\n library, by reordering the lines in the configuration files. In general, a"}, {"sha": "49ddf03d04be5efed597172a792aa280da7b5c60", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "patch": "@@ -1442,7 +1442,7 @@ begin\n \n                --  Do not generate an ALI file in this case, because it would\n                --  become obsolete when the parent is compiled, and thus\n-               --  confuse tools such as gnatfind.\n+               --  confuse some tools.\n \n             elsif Main_Unit_Kind = N_Subprogram_Declaration then\n                Write_Str (\" (subprogram spec)\");"}, {"sha": "1664c4912e0302adbc3fa9c1f9329d8bab676159", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "patch": "@@ -3197,8 +3197,7 @@ if any of these units are modified.\n \n @item \n Cross-reference data. Contains information on all entities referenced\n-in the unit. Used by tools like @code{gnatxref} and @code{gnatfind} to\n-provide cross-reference information.\n+in the unit. Used by some tools to provide cross-reference information.\n @end itemize\n \n For a full detailed description of the format of the @code{ALI} file,\n@@ -3505,8 +3504,8 @@ be @code{adalib}).\n You can also specify a new default path to the run-time library at compilation\n time with the switch @code{--RTS=rts-path}. You can thus choose / change\n the run-time library you want your program to be compiled with. This switch is\n-recognized by @code{gcc}, @code{gnatmake}, @code{gnatbind},\n-@code{gnatls}, @code{gnatfind} and @code{gnatxref}.\n+recognized by @code{gcc}, @code{gnatmake}, @code{gnatbind}, @code{gnatls}, and all\n+project aware tools.\n \n It is possible to install a library before or after the standard GNAT\n library, by reordering the lines in the configuration files. In general, a\n@@ -15077,10 +15076,10 @@ types in package Standard.\n @item @code{-gnatx}\n \n Normally the compiler generates full cross-referencing information in\n-the @code{ALI} file. This information is used by a number of tools,\n-including @code{gnatfind} and @code{gnatxref}. The @code{-gnatx} switch\n-suppresses this information. This saves some space and may slightly\n-speed up compilation, but means that these tools cannot be used.\n+the @code{ALI} file. This information is used by a number of tools.\n+The @code{-gnatx} switch suppresses this information. This saves some space\n+and may slightly speed up compilation, but means that tools depending\n+on this information cannot be used.\n @end table\n \n @geindex -fgnat-encodings (gcc)"}, {"sha": "74192bc36195e7db4158b4a3d01e2c7c045f10b7", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e474137e78a4c9b35b6c298d2aacf731c0b3d8a/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=4e474137e78a4c9b35b6c298d2aacf731c0b3d8a", "patch": "@@ -57,7 +57,6 @@ procedure GNATCmd is\n       Compile,\n       Check,\n       Elim,\n-      Find,\n       Krunch,\n       Link,\n       List,\n@@ -69,10 +68,9 @@ procedure GNATCmd is\n       Stack,\n       Stub,\n       Test,\n-      Xref,\n       Undefined);\n \n-   subtype Real_Command_Type is Command_Type range Bind .. Xref;\n+   subtype Real_Command_Type is Command_Type range Bind .. Test;\n    --  All real command types (excludes only Undefined).\n \n    type Alternate_Command is (Comp, Ls, Kr, Pp, Prep);\n@@ -160,11 +158,6 @@ procedure GNATCmd is\n          Unixcmd  => new String'(\"gnatelim\"),\n          Unixsws  => null),\n \n-      Find =>\n-        (Cname    => new String'(\"FIND\"),\n-         Unixcmd  => new String'(\"gnatfind\"),\n-         Unixsws  => null),\n-\n       Krunch =>\n         (Cname    => new String'(\"KRUNCH\"),\n          Unixcmd  => new String'(\"gnatkr\"),\n@@ -218,11 +211,6 @@ procedure GNATCmd is\n       Test =>\n         (Cname    => new String'(\"TEST\"),\n          Unixcmd  => new String'(\"gnattest\"),\n-         Unixsws  => null),\n-\n-      Xref =>\n-        (Cname    => new String'(\"XREF\"),\n-         Unixcmd  => new String'(\"gnatxref\"),\n          Unixsws  => null)\n      );\n \n@@ -590,30 +578,6 @@ begin\n          end loop;\n       end if;\n \n-      --  For FIND and XREF, look for switch -P. If it is specified, then\n-      --  report an error indicating that the command does not support project\n-      --  files.\n-\n-      if The_Command in Find | Xref then\n-         declare\n-            Argv : String_Access;\n-         begin\n-            for Arg_Num in 1 .. Last_Switches.Last loop\n-               Argv := Last_Switches.Table (Arg_Num);\n-\n-               if Argv'Length >= 2\n-                 and then Argv (Argv'First .. Argv'First + 1) = \"-P\"\n-               then\n-                  if The_Command = Find then\n-                     Fail (\"'gnat find -P' is not supported;\");\n-                  else\n-                     Fail (\"'gnat xref -P' is not supported;\");\n-                  end if;\n-               end if;\n-            end loop;\n-         end;\n-      end if;\n-\n       --  Gather all the arguments and invoke the executable\n \n       declare"}, {"sha": "04b0fe4faf290c20352a40117be94c94a584bb87", "filename": "gcc/ada/gnatfind.adb", "status": "removed", "additions": 0, "deletions": 407, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fgnatfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fgnatfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatfind.adb?ref=c92f4fddd68463e7bc21e6a71c89848410311351", "patch": "@@ -1,407 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             G N A T F I N D                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1998-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Opt;\n-with Osint;    use Osint;\n-with Switch;   use Switch;\n-with Types;    use Types;\n-with Xr_Tabls;\n-with Xref_Lib; use Xref_Lib;\n-\n-with Ada.Command_Line;  use Ada.Command_Line;\n-with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n-with Ada.Text_IO;       use Ada.Text_IO;\n-\n-with GNAT.Command_Line; use GNAT.Command_Line;\n-\n-with System.Strings;    use System.Strings;\n-\n---------------\n--- Gnatfind --\n---------------\n-\n-procedure Gnatfind is\n-   Output_Ref      : Boolean := False;\n-   Pattern         : Xref_Lib.Search_Pattern;\n-   Local_Symbols   : Boolean := True;\n-   Prj_File        : File_Name_String;\n-   Prj_File_Length : Natural := 0;\n-   Nb_File         : Natural := 0;\n-   Usage_Error     : exception;\n-   Full_Path_Name  : Boolean := False;\n-   Have_Entity     : Boolean := False;\n-   Wide_Search     : Boolean := True;\n-   Glob_Mode       : Boolean := True;\n-   Der_Info        : Boolean := False;\n-   Type_Tree       : Boolean := False;\n-   Read_Only       : Boolean := False;\n-   Source_Lines    : Boolean := False;\n-\n-   Has_File_In_Entity : Boolean := False;\n-   --  Will be true if a file name was specified in the entity\n-\n-   RTS_Specified : String_Access := null;\n-   --  Used to detect multiple use of --RTS= switch\n-\n-   EXT_Specified : String_Access := null;\n-   --  Used to detect multiple use of --ext= switch\n-\n-   procedure Parse_Cmd_Line;\n-   --  Parse every switch on the command line\n-\n-   procedure Usage;\n-   --  Display the usage\n-\n-   procedure Write_Usage;\n-   pragma No_Return (Write_Usage);\n-   --  Print a small help page for program usage and exit program\n-\n-   --------------------\n-   -- Parse_Cmd_Line --\n-   --------------------\n-\n-   procedure Parse_Cmd_Line is\n-\n-      procedure Check_Version_And_Help is new Check_Version_And_Help_G (Usage);\n-\n-   --  Start of processing for Parse_Cmd_Line\n-\n-   begin\n-      --  First check for --version or --help\n-\n-      Check_Version_And_Help (\"GNATFIND\", \"1998\");\n-\n-      --  Now scan the other switches\n-\n-      GNAT.Command_Line.Initialize_Option_Scan;\n-\n-      loop\n-         case\n-           GNAT.Command_Line.Getopt\n-             (\"a aI: aO: d e f g h I: nostdinc nostdlib p: r s t -RTS= -ext=\")\n-         is\n-            when ASCII.NUL =>\n-               exit;\n-\n-            when 'a'    =>\n-               if GNAT.Command_Line.Full_Switch = \"a\" then\n-                  Read_Only := True;\n-               elsif GNAT.Command_Line.Full_Switch = \"aI\" then\n-                  Osint.Add_Src_Search_Dir (GNAT.Command_Line.Parameter);\n-               else\n-                  Osint.Add_Lib_Search_Dir (GNAT.Command_Line.Parameter);\n-               end if;\n-\n-            when 'd'    =>\n-               Der_Info := True;\n-\n-            when 'e'    =>\n-               Glob_Mode := False;\n-\n-            when 'f'    =>\n-               Full_Path_Name := True;\n-\n-            when 'g'    =>\n-               Local_Symbols := False;\n-\n-            when 'h'    =>\n-               Write_Usage;\n-\n-            when 'I'    =>\n-               Osint.Add_Src_Search_Dir (GNAT.Command_Line.Parameter);\n-               Osint.Add_Lib_Search_Dir (GNAT.Command_Line.Parameter);\n-\n-            when 'n'    =>\n-               if GNAT.Command_Line.Full_Switch = \"nostdinc\" then\n-                  Opt.No_Stdinc := True;\n-               elsif GNAT.Command_Line.Full_Switch = \"nostdlib\" then\n-                  Opt.No_Stdlib := True;\n-               end if;\n-\n-            when 'p'    =>\n-               declare\n-                  S : constant String := GNAT.Command_Line.Parameter;\n-               begin\n-                  Prj_File_Length := S'Length;\n-                  Prj_File (1 .. Prj_File_Length) := S;\n-               end;\n-\n-            when 'r'    =>\n-               Output_Ref := True;\n-\n-            when 's' =>\n-               Source_Lines := True;\n-\n-            when 't' =>\n-               Type_Tree := True;\n-\n-            --  Only switch starting with -- recognized is --RTS\n-\n-            when '-' =>\n-               if GNAT.Command_Line.Full_Switch = \"-RTS\" then\n-\n-                  --  Check that it is the first time we see this switch\n-\n-                  if RTS_Specified = null then\n-                     RTS_Specified := new String'(GNAT.Command_Line.Parameter);\n-                  elsif RTS_Specified.all /= GNAT.Command_Line.Parameter then\n-                     Osint.Fail (\"--RTS cannot be specified multiple times\");\n-                  end if;\n-\n-                  Opt.No_Stdinc := True;\n-                  Opt.RTS_Switch := True;\n-\n-                  declare\n-                     Src_Path_Name : constant String_Ptr :=\n-                                       Get_RTS_Search_Dir\n-                                         (GNAT.Command_Line.Parameter,\n-                                          Include);\n-                     Lib_Path_Name : constant String_Ptr :=\n-                                       Get_RTS_Search_Dir\n-                                         (GNAT.Command_Line.Parameter,\n-                                          Objects);\n-\n-                  begin\n-                     if Src_Path_Name /= null\n-                       and then Lib_Path_Name /= null\n-                     then\n-                        Add_Search_Dirs (Src_Path_Name, Include);\n-                        Add_Search_Dirs (Lib_Path_Name, Objects);\n-\n-                     elsif Src_Path_Name = null\n-                       and then Lib_Path_Name = null\n-                     then\n-                        Osint.Fail (\"RTS path not valid: missing \" &\n-                                      \"adainclude and adalib directories\");\n-\n-                     elsif Src_Path_Name = null then\n-                        Osint.Fail (\"RTS path not valid: missing \" &\n-                                      \"adainclude directory\");\n-\n-                     elsif Lib_Path_Name = null then\n-                        Osint.Fail (\"RTS path not valid: missing \" &\n-                                      \"adalib directory\");\n-                     end if;\n-                  end;\n-\n-               --  Process -ext switch\n-\n-               elsif GNAT.Command_Line.Full_Switch = \"-ext\" then\n-\n-                  --  Check that it is the first time we see this switch\n-\n-                  if EXT_Specified = null then\n-                     EXT_Specified := new String'(GNAT.Command_Line.Parameter);\n-                  elsif EXT_Specified.all /= GNAT.Command_Line.Parameter then\n-                     Osint.Fail (\"--ext cannot be specified multiple times\");\n-                  end if;\n-\n-                  if\n-                    EXT_Specified'Length = Osint.ALI_Default_Suffix'Length\n-                  then\n-                     Osint.ALI_Suffix := EXT_Specified.all'Access;\n-                  else\n-                     Osint.Fail (\"--ext argument must have 3 characters\");\n-                  end if;\n-\n-               end if;\n-\n-            when others =>\n-               Try_Help;\n-               raise Usage_Error;\n-         end case;\n-      end loop;\n-\n-      --  Get the other arguments\n-\n-      loop\n-         declare\n-            S : constant String := GNAT.Command_Line.Get_Argument;\n-\n-         begin\n-            exit when S'Length = 0;\n-\n-            --  First argument is the pattern\n-\n-            if not Have_Entity then\n-               Add_Entity (Pattern, S, Glob_Mode);\n-               Have_Entity := True;\n-\n-               if not Has_File_In_Entity\n-                 and then Index (S, \":\") /= 0\n-               then\n-                  Has_File_In_Entity := True;\n-               end if;\n-\n-            --  Next arguments are the files to search\n-\n-            else\n-               Add_Xref_File (S);\n-               Wide_Search := False;\n-               Nb_File := Nb_File + 1;\n-            end if;\n-         end;\n-      end loop;\n-\n-   exception\n-      when GNAT.Command_Line.Invalid_Switch =>\n-         Ada.Text_IO.Put_Line (\"Invalid switch : \"\n-                               & GNAT.Command_Line.Full_Switch);\n-         Try_Help;\n-         raise Usage_Error;\n-\n-      when GNAT.Command_Line.Invalid_Parameter =>\n-         Ada.Text_IO.Put_Line (\"Parameter missing for : \"\n-                               & GNAT.Command_Line.Full_Switch);\n-         Try_Help;\n-         raise Usage_Error;\n-\n-      when Xref_Lib.Invalid_Argument =>\n-         Ada.Text_IO.Put_Line (\"Invalid line or column in the pattern\");\n-         Try_Help;\n-         raise Usage_Error;\n-   end Parse_Cmd_Line;\n-\n-   -----------\n-   -- Usage --\n-   -----------\n-\n-   procedure Usage is\n-   begin\n-      Put_Line (\"Usage: gnatfind pattern[:sourcefile[:line[:column]]] \"\n-                & \"[file1 file2 ...]\");\n-      New_Line;\n-      Put_Line (\"  pattern     Name of the entity to look for (can have \"\n-                & \"wildcards)\");\n-      Put_Line (\"  sourcefile  Only find entities referenced from this \"\n-                & \"file\");\n-      Put_Line (\"  line        Only find entities referenced from this line \"\n-                & \"of file\");\n-      Put_Line (\"  column      Only find entities referenced from this columns\"\n-                & \" of file\");\n-      Put_Line (\"  file ...    Set of Ada source files to search for \"\n-                & \"references. This parameters are optional\");\n-      New_Line;\n-      Put_Line (\"gnatfind switches:\");\n-      Display_Usage_Version_And_Help;\n-      Put_Line (\"   -a        Consider all files, even when the ali file is \"\n-                & \"readonly\");\n-      Put_Line (\"   -aIdir    Specify source files search path\");\n-      Put_Line (\"   -aOdir    Specify library/object files search path\");\n-      Put_Line (\"   -d        Output derived type information\");\n-      Put_Line (\"   -e        Use the full regular expression set for \"\n-                & \"pattern\");\n-      Put_Line (\"   -f        Output full path name\");\n-      Put_Line (\"   -g        Output information only for global symbols\");\n-      Put_Line (\"   -Idir     Like -aIdir -aOdir\");\n-      Put_Line (\"   -nostdinc Don't look for sources in the system default\"\n-                & \" directory\");\n-      Put_Line (\"   -nostdlib Don't look for library files in the system\"\n-                & \" default directory\");\n-      Put_Line (\"   --ext=xxx Specify alternate ali file extension\");\n-      Put_Line (\"   --RTS=dir specify the default source and object search\"\n-                & \" path\");\n-      Put_Line (\"   -p file   Use file as the configuration file\");\n-      Put_Line (\"   -r        Find all references (default to find declaration\"\n-                & \" only)\");\n-      Put_Line (\"   -s        Print source line\");\n-      Put_Line (\"   -t        Print type hierarchy\");\n-   end Usage;\n-\n-   -----------------\n-   -- Write_Usage --\n-   -----------------\n-\n-   procedure Write_Usage is\n-   begin\n-      Display_Version (\"GNATFIND\", \"1998\");\n-      New_Line;\n-\n-      Usage;\n-\n-      raise Usage_Error;\n-   end Write_Usage;\n-\n---  Start of processing for Gnatfind\n-\n-begin\n-   Put_Line\n-     (\"WARNING: gnatfind is obsolete and will be removed in the next release\");\n-   Put_Line\n-     (\"Consider using Libadalang or GNAT Studio python scripting instead\");\n-\n-   Parse_Cmd_Line;\n-\n-   if not Have_Entity then\n-      if Argument_Count = 0 then\n-         Write_Usage;\n-      else\n-         Try_Help;\n-         raise Usage_Error;\n-      end if;\n-   end if;\n-\n-   --  Special case to speed things up: if the user has a command line of the\n-   --  form 'gnatfind entity:file', i.e. has specified a file and only wants\n-   --  the bodies and specs, then we can restrict the search to the .ali file\n-   --  associated with 'file'.\n-\n-   if Has_File_In_Entity\n-     and then not Output_Ref\n-   then\n-      Wide_Search := False;\n-   end if;\n-\n-   --  Find the project file\n-\n-   if Prj_File_Length = 0 then\n-      Xr_Tabls.Create_Project_File (Default_Project_File (\".\"));\n-   else\n-      Xr_Tabls.Create_Project_File (Prj_File (1 .. Prj_File_Length));\n-   end if;\n-\n-   --  Fill up the table\n-\n-   if Type_Tree and then Nb_File > 1 then\n-      Ada.Text_IO.Put_Line (\"Error: for type hierarchy output you must \"\n-                            & \"specify only one file.\");\n-      Ada.Text_IO.New_Line;\n-      Try_Help;\n-      raise Usage_Error;\n-   end if;\n-\n-   Search (Pattern, Local_Symbols, Wide_Search, Read_Only,\n-           Der_Info, Type_Tree);\n-\n-   if Source_Lines then\n-      Xr_Tabls.Grep_Source_Files;\n-   end if;\n-\n-   Print_Gnatfind (Output_Ref, Full_Path_Name);\n-\n-exception\n-   when Usage_Error =>\n-      null;\n-end Gnatfind;"}, {"sha": "9499d11551a6ffabd76a91d27b522a82a55401ca", "filename": "gcc/ada/gnatxref.adb", "status": "removed", "additions": 0, "deletions": 344, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fgnatxref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fgnatxref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatxref.adb?ref=c92f4fddd68463e7bc21e6a71c89848410311351", "patch": "@@ -1,344 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             G N A T X R E F                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1998-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Opt;\n-with Osint;    use Osint;\n-with Types;    use Types;\n-with Switch;   use Switch;\n-with Xr_Tabls;\n-with Xref_Lib; use Xref_Lib;\n-\n-with Ada.Command_Line;  use Ada.Command_Line;\n-with Ada.Strings.Fixed;\n-with Ada.Text_IO;       use Ada.Text_IO;\n-\n-with GNAT.Command_Line; use GNAT.Command_Line;\n-\n-with System.Strings;    use System.Strings;\n-\n-procedure Gnatxref is\n-   Search_Unused   : Boolean := False;\n-   Local_Symbols   : Boolean := True;\n-   Prj_File        : File_Name_String;\n-   Prj_File_Length : Natural := 0;\n-   Usage_Error     : exception;\n-   Full_Path_Name  : Boolean := False;\n-   Vi_Mode         : Boolean := False;\n-   Read_Only       : Boolean := False;\n-   Have_File       : Boolean := False;\n-   Der_Info        : Boolean := False;\n-\n-   RTS_Specified : String_Access := null;\n-   --  Used to detect multiple use of --RTS= switch\n-\n-   EXT_Specified : String_Access := null;\n-   --  Used to detect multiple use of --ext= switch\n-\n-   procedure Parse_Cmd_Line;\n-   --  Parse every switch on the command line\n-\n-   procedure Usage;\n-   --  Display the usage\n-\n-   procedure Write_Usage;\n-   pragma No_Return (Write_Usage);\n-   --  Print a small help page for program usage\n-\n-   --------------------\n-   -- Parse_Cmd_Line --\n-   --------------------\n-\n-   procedure Parse_Cmd_Line is\n-\n-      procedure Check_Version_And_Help is new Check_Version_And_Help_G (Usage);\n-\n-   --  Start of processing for Parse_Cmd_Line\n-\n-   begin\n-      --  First check for --version or --help\n-\n-      Check_Version_And_Help (\"GNATXREF\", \"1998\");\n-\n-      loop\n-         case\n-           GNAT.Command_Line.Getopt\n-             (\"a aI: aO: d f g h I: nostdinc nostdlib p: u v -RTS= -ext=\")\n-         is\n-            when ASCII.NUL =>\n-               exit;\n-\n-            when 'a' =>\n-               if GNAT.Command_Line.Full_Switch = \"a\" then\n-                  Read_Only := True;\n-\n-               elsif GNAT.Command_Line.Full_Switch = \"aI\" then\n-                  Osint.Add_Src_Search_Dir (GNAT.Command_Line.Parameter);\n-\n-               else\n-                  Osint.Add_Lib_Search_Dir (GNAT.Command_Line.Parameter);\n-               end if;\n-\n-            when 'd' =>\n-               Der_Info := True;\n-\n-            when 'f' =>\n-               Full_Path_Name := True;\n-\n-            when 'g' =>\n-               Local_Symbols := False;\n-\n-            when 'h' =>\n-               Write_Usage;\n-\n-            when 'I' =>\n-               Osint.Add_Src_Search_Dir (GNAT.Command_Line.Parameter);\n-               Osint.Add_Lib_Search_Dir (GNAT.Command_Line.Parameter);\n-\n-            when 'n' =>\n-               if GNAT.Command_Line.Full_Switch = \"nostdinc\" then\n-                  Opt.No_Stdinc := True;\n-               elsif GNAT.Command_Line.Full_Switch = \"nostdlib\" then\n-                  Opt.No_Stdlib := True;\n-               end if;\n-\n-            when 'p' =>\n-               declare\n-                  S : constant String := GNAT.Command_Line.Parameter;\n-               begin\n-                  Prj_File_Length := S'Length;\n-                  Prj_File (1 .. Prj_File_Length) := S;\n-               end;\n-\n-            when 'u' =>\n-               Search_Unused := True;\n-               Vi_Mode := False;\n-\n-            when 'v' =>\n-               Vi_Mode := True;\n-               Search_Unused := False;\n-\n-            --  The only switch starting with -- recognized is --RTS\n-\n-            when '-' =>\n-\n-               --  Check that it is the first time we see this switch\n-\n-               if Full_Switch = \"-RTS\" then\n-                  if RTS_Specified = null then\n-                     RTS_Specified := new String'(GNAT.Command_Line.Parameter);\n-\n-                  elsif RTS_Specified.all /= GNAT.Command_Line.Parameter then\n-                     Osint.Fail (\"--RTS cannot be specified multiple times\");\n-                  end if;\n-\n-                  Opt.No_Stdinc  := True;\n-                  Opt.RTS_Switch := True;\n-\n-                  declare\n-                     Src_Path_Name : constant String_Ptr :=\n-                                       Get_RTS_Search_Dir\n-                                         (GNAT.Command_Line.Parameter,\n-                                          Include);\n-\n-                     Lib_Path_Name : constant String_Ptr :=\n-                                       Get_RTS_Search_Dir\n-                                         (GNAT.Command_Line.Parameter,\n-                                          Objects);\n-\n-                  begin\n-                     if Src_Path_Name /= null\n-                       and then Lib_Path_Name /= null\n-                     then\n-                        Add_Search_Dirs (Src_Path_Name, Include);\n-                        Add_Search_Dirs (Lib_Path_Name, Objects);\n-\n-                     elsif Src_Path_Name = null\n-                       and then Lib_Path_Name = null\n-                     then\n-                        Osint.Fail\n-                          (\"RTS path not valid: missing adainclude and \"\n-                           & \"adalib directories\");\n-\n-                     elsif Src_Path_Name = null then\n-                        Osint.Fail\n-                          (\"RTS path not valid: missing adainclude directory\");\n-\n-                     elsif Lib_Path_Name = null then\n-                        Osint.Fail\n-                          (\"RTS path not valid: missing adalib directory\");\n-                     end if;\n-                  end;\n-\n-               elsif GNAT.Command_Line.Full_Switch = \"-ext\" then\n-\n-                  --  Check that it is the first time we see this switch\n-\n-                  if EXT_Specified = null then\n-                     EXT_Specified := new String'(GNAT.Command_Line.Parameter);\n-\n-                  elsif EXT_Specified.all /= GNAT.Command_Line.Parameter then\n-                     Osint.Fail (\"--ext cannot be specified multiple times\");\n-                  end if;\n-\n-                  if EXT_Specified'Length = Osint.ALI_Default_Suffix'Length\n-                  then\n-                     Osint.ALI_Suffix := EXT_Specified.all'Access;\n-                  else\n-                     Osint.Fail (\"--ext argument must have 3 characters\");\n-                  end if;\n-               end if;\n-\n-            when others =>\n-               Try_Help;\n-               raise Usage_Error;\n-         end case;\n-      end loop;\n-\n-      --  Get the other arguments\n-\n-      loop\n-         declare\n-            S : constant String := GNAT.Command_Line.Get_Argument;\n-\n-         begin\n-            exit when S'Length = 0;\n-\n-            if Ada.Strings.Fixed.Index (S, \":\") /= 0 then\n-               Ada.Text_IO.Put_Line\n-                 (\"Only file names are allowed on the command line\");\n-               Try_Help;\n-               raise Usage_Error;\n-            end if;\n-\n-            Add_Xref_File (S);\n-            Have_File := True;\n-         end;\n-      end loop;\n-\n-   exception\n-      when GNAT.Command_Line.Invalid_Switch =>\n-         Ada.Text_IO.Put_Line (\"Invalid switch : \"\n-                               & GNAT.Command_Line.Full_Switch);\n-         Try_Help;\n-         raise Usage_Error;\n-\n-      when GNAT.Command_Line.Invalid_Parameter =>\n-         Ada.Text_IO.Put_Line (\"Parameter missing for : \"\n-                               & GNAT.Command_Line.Full_Switch);\n-         Try_Help;\n-         raise Usage_Error;\n-   end Parse_Cmd_Line;\n-\n-   -----------\n-   -- Usage --\n-   -----------\n-\n-   procedure Usage is\n-   begin\n-      Put_Line (\"Usage: gnatxref [switches] file1 file2 ...\");\n-      New_Line;\n-      Put_Line (\"  file ... list of source files to xref, \" &\n-                \"including with'ed units\");\n-      New_Line;\n-      Put_Line (\"gnatxref switches:\");\n-      Display_Usage_Version_And_Help;\n-      Put_Line (\"   -a        Consider all files, even when the ali file is\"\n-                & \" readonly\");\n-      Put_Line (\"   -aIdir    Specify source files search path\");\n-      Put_Line (\"   -aOdir    Specify library/object files search path\");\n-      Put_Line (\"   -d        Output derived type information\");\n-      Put_Line (\"   -f        Output full path name\");\n-      Put_Line (\"   -g        Output information only for global symbols\");\n-      Put_Line (\"   -Idir     Like -aIdir -aOdir\");\n-      Put_Line (\"   -nostdinc Don't look for sources in the system default\"\n-                & \" directory\");\n-      Put_Line (\"   -nostdlib Don't look for library files in the system\"\n-                & \" default directory\");\n-      Put_Line (\"   --ext=xxx Specify alternate ali file extension\");\n-      Put_Line (\"   --RTS=dir specify the default source and object search\"\n-                & \" path\");\n-      Put_Line (\"   -p file   Use file as the configuration file\");\n-      Put_Line (\"   -u        List unused entities\");\n-      Put_Line (\"   -v        Print a 'tags' file for vi\");\n-      New_Line;\n-\n-   end Usage;\n-\n-   -----------------\n-   -- Write_Usage --\n-   -----------------\n-\n-   procedure Write_Usage is\n-   begin\n-      Display_Version (\"GNATXREF\", \"1998\");\n-      New_Line;\n-      Usage;\n-      raise Usage_Error;\n-   end Write_Usage;\n-\n-begin\n-   Put_Line\n-     (\"WARNING: gnatxref is obsolete and will be removed in the next release\");\n-   Put_Line\n-     (\"Consider using Libadalang or GNAT Studio python scripting instead\");\n-\n-   Parse_Cmd_Line;\n-\n-   if not Have_File then\n-      if Argument_Count = 0 then\n-         Write_Usage;\n-      else\n-         Try_Help;\n-         raise Usage_Error;\n-      end if;\n-   end if;\n-\n-   Xr_Tabls.Set_Default_Match (True);\n-\n-   --  Find the project file\n-\n-   if Prj_File_Length = 0 then\n-      Xr_Tabls.Create_Project_File\n-        (Default_Project_File (Osint.To_Host_Dir_Spec (\".\", False).all));\n-   else\n-      Xr_Tabls.Create_Project_File (Prj_File (1 .. Prj_File_Length));\n-   end if;\n-\n-   --  Fill up the table\n-\n-   Search_Xref (Local_Symbols, Read_Only, Der_Info);\n-\n-   if Search_Unused then\n-      Print_Unused (Full_Path_Name);\n-   elsif Vi_Mode then\n-      Print_Vi (Full_Path_Name);\n-   else\n-      Print_Xref (Full_Path_Name);\n-   end if;\n-\n-exception\n-   when Usage_Error =>\n-      null;\n-end Gnatxref;"}, {"sha": "8f6fb7a27a8a7cc84aaabd7333b3010f5a105e49", "filename": "gcc/ada/xr_tabls.adb", "status": "removed", "additions": 0, "deletions": 1628, "changes": 1628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxr_tabls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxr_tabls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxr_tabls.adb?ref=c92f4fddd68463e7bc21e6a71c89848410311351", "patch": "@@ -1,1628 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             X R  _ T A B L S                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1998-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Types;    use Types;\n-with Osint;\n-\n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n-with Ada.Strings.Fixed;\n-with Ada.Strings;\n-with Ada.Text_IO;\n-with Ada.Characters.Handling;   use Ada.Characters.Handling;\n-with Ada.Strings.Unbounded;     use Ada.Strings.Unbounded;\n-\n-with GNAT.OS_Lib;               use GNAT.OS_Lib;\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.HTable;\n-with GNAT.Heap_Sort_G;\n-\n-package body Xr_Tabls is\n-\n-   type HTable_Headers is range 1 .. 10000;\n-\n-   procedure Set_Next (E : File_Reference; Next : File_Reference);\n-   function  Next (E : File_Reference) return File_Reference;\n-   function  Get_Key (E : File_Reference) return Cst_String_Access;\n-   function  Hash (F : Cst_String_Access) return HTable_Headers;\n-   function  Equal (F1, F2 : Cst_String_Access) return Boolean;\n-   --  The five subprograms above are used to instantiate the static\n-   --  htable to store the files that should be processed.\n-\n-   package File_HTable is new GNAT.HTable.Static_HTable\n-     (Header_Num => HTable_Headers,\n-      Element    => File_Record,\n-      Elmt_Ptr   => File_Reference,\n-      Null_Ptr   => null,\n-      Set_Next   => Set_Next,\n-      Next       => Next,\n-      Key        => Cst_String_Access,\n-      Get_Key    => Get_Key,\n-      Hash       => Hash,\n-      Equal      => Equal);\n-   --  A hash table to store all the files referenced in the\n-   --  application.  The keys in this htable are the name of the files\n-   --  themselves, therefore it is assumed that the source path\n-   --  doesn't contain twice the same source or ALI file name\n-\n-   type Unvisited_Files_Record;\n-   type Unvisited_Files_Access is access Unvisited_Files_Record;\n-   type Unvisited_Files_Record is record\n-      File : File_Reference;\n-      Next : Unvisited_Files_Access;\n-   end record;\n-   --  A special list, in addition to File_HTable, that only stores\n-   --  the files that haven't been visited so far. Note that the File\n-   --  list points to some data in File_HTable, and thus should never be freed.\n-\n-   function Next (E : Declaration_Reference) return Declaration_Reference;\n-   procedure Set_Next (E, Next : Declaration_Reference);\n-   function  Get_Key (E : Declaration_Reference) return Cst_String_Access;\n-   --  The subprograms above are used to instantiate the static\n-   --  htable to store the entities that have been found in the application\n-\n-   package Entities_HTable is new GNAT.HTable.Static_HTable\n-     (Header_Num => HTable_Headers,\n-      Element    => Declaration_Record,\n-      Elmt_Ptr   => Declaration_Reference,\n-      Null_Ptr   => null,\n-      Set_Next   => Set_Next,\n-      Next       => Next,\n-      Key        => Cst_String_Access,\n-      Get_Key    => Get_Key,\n-      Hash       => Hash,\n-      Equal      => Equal);\n-   --  A hash table to store all the entities defined in the\n-   --  application. For each entity, we store a list of its reference\n-   --  locations as well.\n-   --  The keys in this htable should be created with Key_From_Ref,\n-   --  and are the file, line and column of the declaration, which are\n-   --  unique for every entity.\n-\n-   Entities_Count : Natural := 0;\n-   --  Number of entities in Entities_HTable. This is used in the end\n-   --  when sorting the table.\n-\n-   Longest_File_Name_In_Table : Natural := 0;\n-   --  The length of the longest file name stored\n-\n-   Unvisited_Files : Unvisited_Files_Access := null;\n-   --  Linked list of unvisited files\n-\n-   Directories : Project_File_Ptr;\n-   --  Store the list of directories to visit\n-\n-   Default_Match : Boolean := False;\n-   --  Default value for match in declarations\n-\n-   function Parse_Gnatls_Src return String;\n-   --  Return the standard source directories (taking into account the\n-   --  ADA_INCLUDE_PATH environment variable, if Osint.Add_Default_Search_Dirs\n-   --  was called first).\n-\n-   function Parse_Gnatls_Obj return String;\n-   --  Return the standard object directories (taking into account the\n-   --  ADA_OBJECTS_PATH environment variable).\n-\n-   function Key_From_Ref\n-     (File_Ref  : File_Reference;\n-      Line      : Natural;\n-      Column    : Natural)\n-      return      String;\n-   --  Return a key for the symbol declared at File_Ref, Line,\n-   --  Column. This key should be used for lookup in Entity_HTable\n-\n-   function Is_Less_Than (Decl1, Decl2 : Declaration_Reference) return Boolean;\n-   --  Compare two declarations (the comparison is case-insensitive)\n-\n-   function Is_Less_Than (Ref1, Ref2 : Reference) return Boolean;\n-   --  Compare two references\n-\n-   procedure Store_References\n-     (Decl            : Declaration_Reference;\n-      Get_Writes      : Boolean := False;\n-      Get_Reads       : Boolean := False;\n-      Get_Bodies      : Boolean := False;\n-      Get_Declaration : Boolean := False;\n-      Arr             : in out Reference_Array;\n-      Index           : in out Natural);\n-   --  Store in Arr, starting at Index, all the references to Decl. The Get_*\n-   --  parameters can be used to indicate which references should be stored.\n-   --  Constraint_Error will be raised if Arr is not big enough.\n-\n-   procedure Sort (Arr : in out Reference_Array);\n-   --  Sort an array of references (Arr'First must be 1)\n-\n-   --------------\n-   -- Set_Next --\n-   --------------\n-\n-   procedure Set_Next (E : File_Reference; Next : File_Reference) is\n-   begin\n-      E.Next := Next;\n-   end Set_Next;\n-\n-   procedure Set_Next\n-     (E : Declaration_Reference; Next : Declaration_Reference) is\n-   begin\n-      E.Next := Next;\n-   end Set_Next;\n-\n-   -------------\n-   -- Get_Key --\n-   -------------\n-\n-   function Get_Key (E : File_Reference) return Cst_String_Access is\n-   begin\n-      return E.File;\n-   end Get_Key;\n-\n-   function Get_Key (E : Declaration_Reference) return Cst_String_Access is\n-   begin\n-      return E.Key;\n-   end Get_Key;\n-\n-   ----------\n-   -- Hash --\n-   ----------\n-\n-   function Hash (F : Cst_String_Access) return HTable_Headers is\n-      function H is new GNAT.HTable.Hash (HTable_Headers);\n-\n-   begin\n-      return H (F.all);\n-   end Hash;\n-\n-   -----------\n-   -- Equal --\n-   -----------\n-\n-   function Equal (F1, F2 : Cst_String_Access) return Boolean is\n-   begin\n-      return F1.all = F2.all;\n-   end Equal;\n-\n-   ------------------\n-   -- Key_From_Ref --\n-   ------------------\n-\n-   function Key_From_Ref\n-     (File_Ref : File_Reference;\n-      Line     : Natural;\n-      Column   : Natural)\n-      return     String\n-   is\n-   begin\n-      return File_Ref.File.all & Natural'Image (Line) & Natural'Image (Column);\n-   end Key_From_Ref;\n-\n-   ---------------------\n-   -- Add_Declaration --\n-   ---------------------\n-\n-   function Add_Declaration\n-     (File_Ref     : File_Reference;\n-      Symbol       : String;\n-      Line         : Natural;\n-      Column       : Natural;\n-      Decl_Type    : Character;\n-      Is_Parameter : Boolean := False;\n-      Remove_Only  : Boolean := False;\n-      Symbol_Match : Boolean := True)\n-      return         Declaration_Reference\n-   is\n-      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n-        (Declaration_Record, Declaration_Reference);\n-\n-      Key : aliased constant String := Key_From_Ref (File_Ref, Line, Column);\n-\n-      New_Decl : Declaration_Reference :=\n-                   Entities_HTable.Get (Key'Unchecked_Access);\n-\n-      Is_Param : Boolean := Is_Parameter;\n-\n-   begin\n-      --  Insert the Declaration in the table. There might already be a\n-      --  declaration in the table if the entity is a parameter, so we\n-      --  need to check that first.\n-\n-      if New_Decl /= null and then New_Decl.Symbol_Length = 0 then\n-         Is_Param := Is_Parameter or else New_Decl.Is_Parameter;\n-         Entities_HTable.Remove (Key'Unrestricted_Access);\n-         Entities_Count := Entities_Count - 1;\n-         Free (New_Decl.Key);\n-         Unchecked_Free (New_Decl);\n-         New_Decl := null;\n-      end if;\n-\n-      --  The declaration might also already be there for parent types. In\n-      --  this case, we should keep the entry, since some other entries are\n-      --  pointing to it.\n-\n-      if New_Decl = null\n-        and then not Remove_Only\n-      then\n-         New_Decl :=\n-           new Declaration_Record'\n-             (Symbol_Length => Symbol'Length,\n-              Symbol        => Symbol,\n-              Key           => new String'(Key),\n-              Decl          => new Reference_Record'\n-                                     (File          => File_Ref,\n-                                      Line          => Line,\n-                                      Column        => Column,\n-                                      Source_Line   => null,\n-                                      Next          => null),\n-              Is_Parameter  => Is_Param,\n-              Decl_Type     => Decl_Type,\n-              Body_Ref      => null,\n-              Ref_Ref       => null,\n-              Modif_Ref     => null,\n-              Match         => Symbol_Match\n-                                 and then\n-                                   (Default_Match\n-                                     or else Match (File_Ref, Line, Column)),\n-              Par_Symbol    => null,\n-              Next          => null);\n-\n-         Entities_HTable.Set (New_Decl);\n-         Entities_Count := Entities_Count + 1;\n-\n-         if New_Decl.Match then\n-            Longest_File_Name_In_Table :=\n-              Natural'Max (File_Ref.File'Length, Longest_File_Name_In_Table);\n-         end if;\n-\n-      elsif New_Decl /= null\n-        and then not New_Decl.Match\n-      then\n-         New_Decl.Match := Default_Match\n-           or else Match (File_Ref, Line, Column);\n-         New_Decl.Is_Parameter := New_Decl.Is_Parameter or Is_Param;\n-\n-      elsif New_Decl /= null then\n-         New_Decl.Is_Parameter := New_Decl.Is_Parameter or Is_Param;\n-      end if;\n-\n-      return New_Decl;\n-   end Add_Declaration;\n-\n-   ----------------------\n-   -- Add_To_Xref_File --\n-   ----------------------\n-\n-   function Add_To_Xref_File\n-     (File_Name       : String;\n-      Visited         : Boolean := True;\n-      Emit_Warning    : Boolean := False;\n-      Gnatchop_File   : String  := \"\";\n-      Gnatchop_Offset : Integer := 0) return File_Reference\n-   is\n-      Base    : aliased constant String := Base_Name (File_Name);\n-      Dir     : constant String := Dir_Name (File_Name);\n-      Dir_Acc : GNAT.OS_Lib.String_Access   := null;\n-      Ref     : File_Reference;\n-\n-   begin\n-      --  Do we have a directory name as well?\n-\n-      if File_Name /= Base then\n-         Dir_Acc := new String'(Dir);\n-      end if;\n-\n-      Ref := File_HTable.Get (Base'Unchecked_Access);\n-      if Ref = null then\n-         Ref := new File_Record'\n-           (File            => new String'(Base),\n-            Dir             => Dir_Acc,\n-            Lines           => null,\n-            Visited         => Visited,\n-            Emit_Warning    => Emit_Warning,\n-            Gnatchop_File   => new String'(Gnatchop_File),\n-            Gnatchop_Offset => Gnatchop_Offset,\n-            Next            => null);\n-         File_HTable.Set (Ref);\n-\n-         if not Visited then\n-\n-            --  Keep a separate list for faster access\n-\n-            Set_Unvisited (Ref);\n-         end if;\n-      end if;\n-      return Ref;\n-   end Add_To_Xref_File;\n-\n-   --------------\n-   -- Add_Line --\n-   --------------\n-\n-   procedure Add_Line\n-     (File   : File_Reference;\n-      Line   : Natural;\n-      Column : Natural)\n-   is\n-   begin\n-      File.Lines := new Ref_In_File'(Line   => Line,\n-                                     Column => Column,\n-                                     Next   => File.Lines);\n-   end Add_Line;\n-\n-   ----------------\n-   -- Add_Parent --\n-   ----------------\n-\n-   procedure Add_Parent\n-     (Declaration : in out Declaration_Reference;\n-      Symbol      : String;\n-      Line        : Natural;\n-      Column      : Natural;\n-      File_Ref    : File_Reference)\n-   is\n-   begin\n-      Declaration.Par_Symbol :=\n-        Add_Declaration\n-          (File_Ref, Symbol, Line, Column,\n-           Decl_Type    => ' ',\n-           Symbol_Match => False);\n-   end Add_Parent;\n-\n-   -------------------\n-   -- Add_Reference --\n-   -------------------\n-\n-   procedure Add_Reference\n-     (Declaration   : Declaration_Reference;\n-      File_Ref      : File_Reference;\n-      Line          : Natural;\n-      Column        : Natural;\n-      Ref_Type      : Character;\n-      Labels_As_Ref : Boolean)\n-   is\n-      New_Ref : Reference;\n-      New_Decl : Declaration_Reference;\n-      pragma Unreferenced (New_Decl);\n-\n-   begin\n-      case Ref_Type is\n-         when ' ' | 'b' | 'c' | 'H' | 'i' | 'm' | 'o' | 'r' | 'R' | 's' | 'x'\n-         =>\n-            null;\n-\n-         when 'l' | 'w' =>\n-            if not Labels_As_Ref then\n-               return;\n-            end if;\n-\n-         when '=' | '<' | '>' | '^' =>\n-\n-            --  Create dummy declaration in table to report it as a parameter\n-\n-            --  In a given ALI file, the declaration of the subprogram comes\n-            --  before the declaration of the parameter. However, it is\n-            --  possible that another ALI file has been parsed that also\n-            --  references the parameter (for instance a named parameter in\n-            --  a call), so we need to check whether there already exists a\n-            --  declaration for the parameter.\n-\n-            New_Decl :=\n-              Add_Declaration\n-                (File_Ref     => File_Ref,\n-                 Symbol       => \"\",\n-                 Line         => Line,\n-                 Column       => Column,\n-                 Decl_Type    => ' ',\n-                 Is_Parameter => True);\n-\n-         when 'd' | 'e' | 'E' | 'k' | 'p' | 'P' | 't' | 'z' =>\n-            return;\n-\n-         when others =>\n-            Ada.Text_IO.Put_Line (\"Unknown reference type: \" & Ref_Type);\n-            return;\n-      end case;\n-\n-      New_Ref := new Reference_Record'\n-        (File        => File_Ref,\n-         Line        => Line,\n-         Column      => Column,\n-         Source_Line => null,\n-         Next        => null);\n-\n-      --  We can insert the reference into the list directly, since all the\n-      --  references will appear only once in the ALI file corresponding to the\n-      --  file where they are referenced. This saves a lot of time compared to\n-      --  checking the list to check if it exists.\n-\n-      case Ref_Type is\n-         when 'b' | 'c' =>\n-            New_Ref.Next          := Declaration.Body_Ref;\n-            Declaration.Body_Ref  := New_Ref;\n-\n-         when ' ' | 'H' | 'i' | 'l' | 'o' | 'r' | 'R' | 's' | 'w' | 'x' =>\n-            New_Ref.Next          := Declaration.Ref_Ref;\n-            Declaration.Ref_Ref   := New_Ref;\n-\n-         when 'm' =>\n-            New_Ref.Next          := Declaration.Modif_Ref;\n-            Declaration.Modif_Ref := New_Ref;\n-\n-         when others =>\n-            null;\n-      end case;\n-\n-      if not Declaration.Match then\n-         Declaration.Match := Match (File_Ref, Line, Column);\n-      end if;\n-\n-      if Declaration.Match then\n-         Longest_File_Name_In_Table :=\n-           Natural'Max (File_Ref.File'Length, Longest_File_Name_In_Table);\n-      end if;\n-   end Add_Reference;\n-\n-   -------------------\n-   -- ALI_File_Name --\n-   -------------------\n-\n-   function ALI_File_Name (Ada_File_Name : String) return String is\n-      --  Should ideally be based on the naming scheme defined in\n-      --  project files but this is too late for an obsolescent feature.\n-\n-      Index : constant Natural :=\n-                Ada.Strings.Fixed.Index\n-                  (Ada_File_Name, \".\", Going => Ada.Strings.Backward);\n-\n-   begin\n-      if Index /= 0 then\n-         return Ada_File_Name (Ada_File_Name'First .. Index)\n-           & Osint.ALI_Suffix.all;\n-      else\n-         return Ada_File_Name & \".\" & Osint.ALI_Suffix.all;\n-      end if;\n-   end ALI_File_Name;\n-\n-   ------------------\n-   -- Is_Less_Than --\n-   ------------------\n-\n-   function Is_Less_Than (Ref1, Ref2 : Reference) return Boolean is\n-   begin\n-      if Ref1 = null then\n-         return False;\n-      elsif Ref2 = null then\n-         return True;\n-      end if;\n-\n-      if Ref1.File.File.all < Ref2.File.File.all then\n-         return True;\n-\n-      elsif Ref1.File.File.all = Ref2.File.File.all then\n-         return (Ref1.Line < Ref2.Line\n-                 or else (Ref1.Line = Ref2.Line\n-                          and then Ref1.Column < Ref2.Column));\n-      end if;\n-\n-      return False;\n-   end Is_Less_Than;\n-\n-   ------------------\n-   -- Is_Less_Than --\n-   ------------------\n-\n-   function Is_Less_Than (Decl1, Decl2 : Declaration_Reference) return Boolean\n-   is\n-      --  We cannot store the data case-insensitive in the table,\n-      --  since we wouldn't be able to find the right casing for the\n-      --  display later on.\n-\n-      S1 : constant String := To_Lower (Decl1.Symbol);\n-      S2 : constant String := To_Lower (Decl2.Symbol);\n-\n-   begin\n-      if S1 < S2 then\n-         return True;\n-      elsif S1 > S2 then\n-         return False;\n-      end if;\n-\n-      return Decl1.Key.all < Decl2.Key.all;\n-   end Is_Less_Than;\n-\n-   -------------------------\n-   -- Create_Project_File --\n-   -------------------------\n-\n-   procedure Create_Project_File (Name : String) is\n-      Obj_Dir     : Unbounded_String := Null_Unbounded_String;\n-      Src_Dir     : Unbounded_String := Null_Unbounded_String;\n-      Build_Dir   : GNAT.OS_Lib.String_Access := new String'(\"\");\n-\n-      F           : File_Descriptor;\n-      Len         : Positive;\n-      File_Name   : aliased String := Name & ASCII.NUL;\n-\n-   begin\n-      --  Read the size of the file\n-\n-      F := Open_Read (File_Name'Address, Text);\n-\n-      --  Project file not found\n-\n-      if F /= Invalid_FD then\n-         Len := Positive (File_Length (F));\n-\n-         declare\n-            Buffer : String (1 .. Len);\n-            Index  : Positive := Buffer'First;\n-            Last   : Positive;\n-\n-         begin\n-            Len := Read (F, Buffer'Address, Len);\n-            Close (F);\n-\n-            --  First, look for Build_Dir, since all the source and object\n-            --  path are relative to it.\n-\n-            while Index <= Buffer'Last loop\n-\n-               --  Find the end of line\n-\n-               Last := Index;\n-               while Last <= Buffer'Last\n-                 and then Buffer (Last) /= ASCII.LF\n-                 and then Buffer (Last) /= ASCII.CR\n-               loop\n-                  Last := Last + 1;\n-               end loop;\n-\n-               if Index <= Buffer'Last - 9\n-                 and then Buffer (Index .. Index + 9) = \"build_dir=\"\n-               then\n-                  Index := Index + 10;\n-                  while Index <= Last\n-                    and then (Buffer (Index) = ' '\n-                              or else Buffer (Index) = ASCII.HT)\n-                  loop\n-                     Index := Index + 1;\n-                  end loop;\n-\n-                  Free (Build_Dir);\n-                  Build_Dir := new String'(Buffer (Index .. Last - 1));\n-               end if;\n-\n-               Index := Last + 1;\n-\n-               --  In case we had a ASCII.CR/ASCII.LF end of line, skip the\n-               --  remaining symbol\n-\n-               if Index <= Buffer'Last\n-                 and then Buffer (Index) = ASCII.LF\n-               then\n-                  Index := Index + 1;\n-               end if;\n-            end loop;\n-\n-            --  Now parse the source and object paths\n-\n-            Index := Buffer'First;\n-            while Index <= Buffer'Last loop\n-\n-               --  Find the end of line\n-\n-               Last := Index;\n-               while Last <= Buffer'Last\n-                 and then Buffer (Last) /= ASCII.LF\n-                 and then Buffer (Last) /= ASCII.CR\n-               loop\n-                  Last := Last + 1;\n-               end loop;\n-\n-               if Index <= Buffer'Last - 7\n-                 and then Buffer (Index .. Index + 7) = \"src_dir=\"\n-               then\n-                  Append (Src_Dir, Normalize_Pathname\n-                          (Name      => Ada.Strings.Fixed.Trim\n-                           (Buffer (Index + 8 .. Last - 1), Ada.Strings.Both),\n-                           Directory => Build_Dir.all) & Path_Separator);\n-\n-               elsif Index <= Buffer'Last - 7\n-                 and then Buffer (Index .. Index + 7) = \"obj_dir=\"\n-               then\n-                  Append (Obj_Dir, Normalize_Pathname\n-                          (Name      => Ada.Strings.Fixed.Trim\n-                           (Buffer (Index + 8 .. Last - 1), Ada.Strings.Both),\n-                           Directory => Build_Dir.all) & Path_Separator);\n-               end if;\n-\n-               --  In case we had a ASCII.CR/ASCII.LF end of line, skip the\n-               --  remaining symbol\n-               Index := Last + 1;\n-\n-               if Index <= Buffer'Last\n-                 and then Buffer (Index) = ASCII.LF\n-               then\n-                  Index := Index + 1;\n-               end if;\n-            end loop;\n-         end;\n-      end if;\n-\n-      Osint.Add_Default_Search_Dirs;\n-\n-      declare\n-         Src : constant String := Parse_Gnatls_Src;\n-         Obj : constant String := Parse_Gnatls_Obj;\n-\n-      begin\n-         Directories := new Project_File'\n-           (Src_Dir_Length     => Length (Src_Dir) + Src'Length,\n-            Obj_Dir_Length     => Length (Obj_Dir) + Obj'Length,\n-            Src_Dir            => To_String (Src_Dir) & Src,\n-            Obj_Dir            => To_String (Obj_Dir) & Obj,\n-            Src_Dir_Index      => 1,\n-            Obj_Dir_Index      => 1,\n-            Last_Obj_Dir_Start => 0);\n-      end;\n-\n-      Free (Build_Dir);\n-   end Create_Project_File;\n-\n-   ---------------------\n-   -- Current_Obj_Dir --\n-   ---------------------\n-\n-   function Current_Obj_Dir return String is\n-   begin\n-      return Directories.Obj_Dir\n-        (Directories.Last_Obj_Dir_Start .. Directories.Obj_Dir_Index - 2);\n-   end Current_Obj_Dir;\n-\n-   ----------------\n-   -- Get_Column --\n-   ----------------\n-\n-   function Get_Column (Decl : Declaration_Reference) return String is\n-   begin\n-      return Ada.Strings.Fixed.Trim (Natural'Image (Decl.Decl.Column),\n-                                     Ada.Strings.Left);\n-   end Get_Column;\n-\n-   function Get_Column (Ref : Reference) return String is\n-   begin\n-      return Ada.Strings.Fixed.Trim (Natural'Image (Ref.Column),\n-                                     Ada.Strings.Left);\n-   end Get_Column;\n-\n-   ---------------------\n-   -- Get_Declaration --\n-   ---------------------\n-\n-   function Get_Declaration\n-     (File_Ref : File_Reference;\n-      Line     : Natural;\n-      Column   : Natural)\n-      return     Declaration_Reference\n-   is\n-      Key : aliased constant String := Key_From_Ref (File_Ref, Line, Column);\n-\n-   begin\n-      return Entities_HTable.Get (Key'Unchecked_Access);\n-   end Get_Declaration;\n-\n-   ----------------------\n-   -- Get_Emit_Warning --\n-   ----------------------\n-\n-   function Get_Emit_Warning (File : File_Reference) return Boolean is\n-   begin\n-      return File.Emit_Warning;\n-   end Get_Emit_Warning;\n-\n-   --------------\n-   -- Get_File --\n-   --------------\n-\n-   function Get_File\n-     (Decl     : Declaration_Reference;\n-      With_Dir : Boolean := False) return String\n-   is\n-   begin\n-      return Get_File (Decl.Decl.File, With_Dir);\n-   end Get_File;\n-\n-   function Get_File\n-     (Ref      : Reference;\n-      With_Dir : Boolean := False) return String\n-   is\n-   begin\n-      return Get_File (Ref.File, With_Dir);\n-   end Get_File;\n-\n-   function Get_File\n-     (File     : File_Reference;\n-      With_Dir : Boolean := False;\n-      Strip    : Natural    := 0) return String\n-   is\n-      pragma Annotate (CodePeer, Skip_Analysis);\n-      --  Disable CodePeer false positives\n-\n-      Tmp : GNAT.OS_Lib.String_Access;\n-\n-      function Internal_Strip (Full_Name : String) return String;\n-      --  Internal function to process the Strip parameter\n-\n-      --------------------\n-      -- Internal_Strip --\n-      --------------------\n-\n-      function Internal_Strip (Full_Name : String) return String is\n-         Unit_End        : Natural;\n-         Extension_Start : Natural;\n-         S               : Natural;\n-\n-      begin\n-         if Strip = 0 then\n-            return Full_Name;\n-         end if;\n-\n-         --  Isolate the file extension\n-\n-         Extension_Start := Full_Name'Last;\n-         while Extension_Start >= Full_Name'First\n-           and then Full_Name (Extension_Start) /= '.'\n-         loop\n-            Extension_Start := Extension_Start - 1;\n-         end loop;\n-\n-         --  Strip the right number of subunit_names\n-\n-         S := Strip;\n-         Unit_End := Extension_Start - 1;\n-         while Unit_End >= Full_Name'First\n-           and then S > 0\n-         loop\n-            if Full_Name (Unit_End) = '-' then\n-               S := S - 1;\n-            end if;\n-\n-            Unit_End := Unit_End - 1;\n-         end loop;\n-\n-         if Unit_End < Full_Name'First then\n-            return \"\";\n-         else\n-            return Full_Name (Full_Name'First .. Unit_End)\n-              & Full_Name (Extension_Start .. Full_Name'Last);\n-         end if;\n-      end Internal_Strip;\n-\n-   --  Start of processing for Get_File\n-\n-   begin\n-      --  If we do not want the full path name\n-\n-      if not With_Dir then\n-         return Internal_Strip (File.File.all);\n-      end if;\n-\n-      if File.Dir = null then\n-         if Ada.Strings.Fixed.Tail (File.File.all, 3) =\n-                                               Osint.ALI_Suffix.all\n-         then\n-            Tmp := Locate_Regular_File\n-                     (Internal_Strip (File.File.all), Directories.Obj_Dir);\n-         else\n-            Tmp := Locate_Regular_File\n-                     (File.File.all, Directories.Src_Dir);\n-         end if;\n-\n-         if Tmp = null then\n-            File.Dir := new String'(\"\");\n-         else\n-            File.Dir := new String'(Dir_Name (Tmp.all));\n-            Free (Tmp);\n-         end if;\n-      end if;\n-\n-      return Internal_Strip (File.Dir.all & File.File.all);\n-   end Get_File;\n-\n-   ------------------\n-   -- Get_File_Ref --\n-   ------------------\n-\n-   function Get_File_Ref (Ref : Reference) return File_Reference is\n-   begin\n-      return Ref.File;\n-   end Get_File_Ref;\n-\n-   -----------------------\n-   -- Get_Gnatchop_File --\n-   -----------------------\n-\n-   function Get_Gnatchop_File\n-     (File     : File_Reference;\n-      With_Dir : Boolean := False)\n-      return     String\n-   is\n-   begin\n-      if File.Gnatchop_File.all = \"\" then\n-         return Get_File (File, With_Dir);\n-      else\n-         return File.Gnatchop_File.all;\n-      end if;\n-   end Get_Gnatchop_File;\n-\n-   function Get_Gnatchop_File\n-     (Ref      : Reference;\n-      With_Dir : Boolean := False)\n-      return     String\n-   is\n-   begin\n-      return Get_Gnatchop_File (Ref.File, With_Dir);\n-   end Get_Gnatchop_File;\n-\n-   function Get_Gnatchop_File\n-     (Decl     : Declaration_Reference;\n-      With_Dir : Boolean := False)\n-      return     String\n-   is\n-   begin\n-      return Get_Gnatchop_File (Decl.Decl.File, With_Dir);\n-   end Get_Gnatchop_File;\n-\n-   --------------\n-   -- Get_Line --\n-   --------------\n-\n-   function Get_Line (Decl : Declaration_Reference) return String is\n-   begin\n-      return Ada.Strings.Fixed.Trim (Natural'Image (Decl.Decl.Line),\n-                                     Ada.Strings.Left);\n-   end Get_Line;\n-\n-   function Get_Line (Ref : Reference) return String is\n-   begin\n-      return Ada.Strings.Fixed.Trim (Natural'Image (Ref.Line),\n-                                     Ada.Strings.Left);\n-   end Get_Line;\n-\n-   ----------------\n-   -- Get_Parent --\n-   ----------------\n-\n-   function Get_Parent\n-     (Decl : Declaration_Reference)\n-      return Declaration_Reference\n-   is\n-   begin\n-      return Decl.Par_Symbol;\n-   end Get_Parent;\n-\n-   ---------------------\n-   -- Get_Source_Line --\n-   ---------------------\n-\n-   function Get_Source_Line (Ref : Reference) return String is\n-   begin\n-      if Ref.Source_Line /= null then\n-         return Ref.Source_Line.all;\n-      else\n-         return \"\";\n-      end if;\n-   end Get_Source_Line;\n-\n-   function Get_Source_Line (Decl : Declaration_Reference) return String is\n-   begin\n-      if Decl.Decl.Source_Line /= null then\n-         return Decl.Decl.Source_Line.all;\n-      else\n-         return \"\";\n-      end if;\n-   end Get_Source_Line;\n-\n-   ----------------\n-   -- Get_Symbol --\n-   ----------------\n-\n-   function Get_Symbol (Decl : Declaration_Reference) return String is\n-   begin\n-      return Decl.Symbol;\n-   end Get_Symbol;\n-\n-   --------------\n-   -- Get_Type --\n-   --------------\n-\n-   function Get_Type (Decl : Declaration_Reference) return Character is\n-   begin\n-      return Decl.Decl_Type;\n-   end Get_Type;\n-\n-   ----------\n-   -- Sort --\n-   ----------\n-\n-   procedure Sort (Arr : in out Reference_Array) is\n-      Tmp : Reference;\n-\n-      function Lt (Op1, Op2 : Natural) return Boolean;\n-      procedure Move (From, To : Natural);\n-      --  See GNAT.Heap_Sort_G\n-\n-      --------\n-      -- Lt --\n-      --------\n-\n-      function Lt (Op1, Op2 : Natural) return Boolean is\n-      begin\n-         if Op1 = 0 then\n-            return Is_Less_Than (Tmp, Arr (Op2));\n-         elsif Op2 = 0 then\n-            return Is_Less_Than (Arr (Op1), Tmp);\n-         else\n-            return Is_Less_Than (Arr (Op1), Arr (Op2));\n-         end if;\n-      end Lt;\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From, To : Natural) is\n-      begin\n-         if To = 0 then\n-            Tmp := Arr (From);\n-         elsif From = 0 then\n-            Arr (To) := Tmp;\n-         else\n-            Arr (To) := Arr (From);\n-         end if;\n-      end Move;\n-\n-      package Ref_Sort is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-   --  Start of processing for Sort\n-\n-   begin\n-      Ref_Sort.Sort (Arr'Last);\n-   end Sort;\n-\n-   -----------------------\n-   -- Grep_Source_Files --\n-   -----------------------\n-\n-   procedure Grep_Source_Files is\n-      Length       : Natural := 0;\n-      Decl         : Declaration_Reference := Entities_HTable.Get_First;\n-      Arr          : Reference_Array_Access;\n-      Index        : Natural;\n-      End_Index    : Natural := 0;\n-      Current_File : File_Reference;\n-      Current_Line : Cst_String_Access;\n-      Buffer       : GNAT.OS_Lib.String_Access;\n-      Ref          : Reference;\n-      Line         : Natural := Natural'Last;\n-\n-   begin\n-      --  Create a temporary array, where all references will be\n-      --  sorted by files. This way, we only have to read the source\n-      --  files once.\n-\n-      while Decl /= null loop\n-\n-         --  Add 1 for the declaration itself\n-\n-         Length := Length + References_Count (Decl, True, True, True) + 1;\n-         Decl := Entities_HTable.Get_Next;\n-      end loop;\n-\n-      Arr := new Reference_Array (1 .. Length);\n-      Index := Arr'First;\n-\n-      Decl := Entities_HTable.Get_First;\n-      while Decl /= null loop\n-         Store_References (Decl, True, True, True, True, Arr.all, Index);\n-         Decl := Entities_HTable.Get_Next;\n-      end loop;\n-\n-      Sort (Arr.all);\n-\n-      --  Now traverse the whole array and find the appropriate source\n-      --  lines.\n-\n-      for R in Arr'Range loop\n-         Ref := Arr (R);\n-\n-         if Ref.File /= Current_File then\n-            Free (Buffer);\n-            begin\n-               Read_File (Get_File (Ref.File, With_Dir => True), Buffer);\n-               End_Index := Buffer'First - 1;\n-               Line := 0;\n-            exception\n-               when Ada.Text_IO.Name_Error | Ada.Text_IO.End_Error =>\n-                  Line := Natural'Last;\n-            end;\n-            Current_File := Ref.File;\n-         end if;\n-\n-         if Ref.Line > Line then\n-\n-            --  Do not free Current_Line, it is referenced by the last\n-            --  Ref we processed.\n-\n-            loop\n-               Index := End_Index + 1;\n-\n-               loop\n-                  End_Index := End_Index + 1;\n-                  exit when End_Index > Buffer'Last\n-                    or else Buffer (End_Index) = ASCII.LF;\n-               end loop;\n-\n-               --  Skip spaces at beginning of line\n-\n-               while Index < End_Index and then\n-                 (Buffer (Index) = ' ' or else Buffer (Index) = ASCII.HT)\n-               loop\n-                  Index := Index + 1;\n-               end loop;\n-\n-               Line := Line + 1;\n-               exit when Ref.Line = Line;\n-            end loop;\n-\n-            Current_Line := new String'(Buffer (Index .. End_Index - 1));\n-         end if;\n-\n-         Ref.Source_Line := Current_Line;\n-      end loop;\n-\n-      Free (Buffer);\n-      Free (Arr);\n-   end Grep_Source_Files;\n-\n-   ---------------\n-   -- Read_File --\n-   ---------------\n-\n-   procedure Read_File\n-     (File_Name : String;\n-      Contents  : out GNAT.OS_Lib.String_Access)\n-   is\n-      Name_0 : constant String := File_Name & ASCII.NUL;\n-      FD     : constant File_Descriptor := Open_Read (Name_0'Address, Binary);\n-      Length : Natural;\n-\n-   begin\n-      if FD = Invalid_FD then\n-         raise Ada.Text_IO.Name_Error;\n-      end if;\n-\n-      --  Include room for EOF char\n-\n-      Length := Natural (File_Length (FD));\n-\n-      declare\n-         Buffer    : String (1 .. Length + 1);\n-         This_Read : Integer;\n-         Read_Ptr  : Natural := 1;\n-\n-      begin\n-         loop\n-            This_Read := Read (FD,\n-                               A => Buffer (Read_Ptr)'Address,\n-                               N => Length + 1 - Read_Ptr);\n-            Read_Ptr := Read_Ptr + Integer'Max (This_Read, 0);\n-            exit when This_Read <= 0;\n-         end loop;\n-\n-         Buffer (Read_Ptr) := EOF;\n-         Contents := new String'(Buffer (1 .. Read_Ptr));\n-\n-         if Read_Ptr /= Length + 1 then\n-            raise Ada.Text_IO.End_Error;\n-         end if;\n-\n-         Close (FD);\n-      end;\n-   end Read_File;\n-\n-   -----------------------\n-   -- Longest_File_Name --\n-   -----------------------\n-\n-   function Longest_File_Name return Natural is\n-   begin\n-      return Longest_File_Name_In_Table;\n-   end Longest_File_Name;\n-\n-   -----------\n-   -- Match --\n-   -----------\n-\n-   function Match\n-     (File   : File_Reference;\n-      Line   : Natural;\n-      Column : Natural)\n-      return   Boolean\n-   is\n-      Ref : Ref_In_File_Ptr := File.Lines;\n-\n-   begin\n-      while Ref /= null loop\n-         if (Ref.Line = 0 or else Ref.Line = Line)\n-           and then (Ref.Column = 0 or else Ref.Column = Column)\n-         then\n-            return True;\n-         end if;\n-\n-         Ref := Ref.Next;\n-      end loop;\n-\n-      return False;\n-   end Match;\n-\n-   -----------\n-   -- Match --\n-   -----------\n-\n-   function Match (Decl : Declaration_Reference) return Boolean is\n-   begin\n-      return Decl.Match;\n-   end Match;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (E : File_Reference) return File_Reference is\n-   begin\n-      return E.Next;\n-   end Next;\n-\n-   function Next (E : Declaration_Reference) return Declaration_Reference is\n-   begin\n-      return E.Next;\n-   end Next;\n-\n-   ------------------\n-   -- Next_Obj_Dir --\n-   ------------------\n-\n-   function Next_Obj_Dir return String is\n-      First : constant Integer := Directories.Obj_Dir_Index;\n-      Last  : Integer;\n-\n-   begin\n-      Last := Directories.Obj_Dir_Index;\n-\n-      if Last > Directories.Obj_Dir_Length then\n-         return String'(1 .. 0 => ' ');\n-      end if;\n-\n-      while Directories.Obj_Dir (Last) /= Path_Separator loop\n-         Last := Last + 1;\n-      end loop;\n-\n-      Directories.Obj_Dir_Index := Last + 1;\n-      Directories.Last_Obj_Dir_Start := First;\n-      return Directories.Obj_Dir (First .. Last - 1);\n-   end Next_Obj_Dir;\n-\n-   -------------------------\n-   -- Next_Unvisited_File --\n-   -------------------------\n-\n-   function Next_Unvisited_File return File_Reference is\n-      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n-        (Unvisited_Files_Record, Unvisited_Files_Access);\n-\n-      Ref : File_Reference;\n-      Tmp : Unvisited_Files_Access;\n-\n-   begin\n-      if Unvisited_Files = null then\n-         return Empty_File;\n-      else\n-         Tmp := Unvisited_Files;\n-         Ref := Unvisited_Files.File;\n-         Unvisited_Files := Unvisited_Files.Next;\n-         Unchecked_Free (Tmp);\n-         return Ref;\n-      end if;\n-   end Next_Unvisited_File;\n-\n-   ----------------------\n-   -- Parse_Gnatls_Src --\n-   ----------------------\n-\n-   function Parse_Gnatls_Src return String is\n-      Length : Natural;\n-\n-   begin\n-      Length := 0;\n-      for J in 1 .. Osint.Nb_Dir_In_Src_Search_Path loop\n-         if Osint.Dir_In_Src_Search_Path (J)'Length = 0 then\n-            Length := Length + 2;\n-         else\n-            Length := Length + Osint.Dir_In_Src_Search_Path (J)'Length + 1;\n-         end if;\n-      end loop;\n-\n-      declare\n-         Result : String (1 .. Length);\n-         L      : Natural;\n-\n-      begin\n-         L := Result'First;\n-         for J in 1 .. Osint.Nb_Dir_In_Src_Search_Path loop\n-            if Osint.Dir_In_Src_Search_Path (J)'Length = 0 then\n-               Result (L .. L + 1) := \".\" & Path_Separator;\n-               L := L + 2;\n-\n-            else\n-               Result (L .. L + Osint.Dir_In_Src_Search_Path (J)'Length - 1) :=\n-                 Osint.Dir_In_Src_Search_Path (J).all;\n-               L := L + Osint.Dir_In_Src_Search_Path (J)'Length;\n-               Result (L) := Path_Separator;\n-               L := L + 1;\n-            end if;\n-         end loop;\n-\n-         return Result;\n-      end;\n-   end Parse_Gnatls_Src;\n-\n-   ----------------------\n-   -- Parse_Gnatls_Obj --\n-   ----------------------\n-\n-   function Parse_Gnatls_Obj return String is\n-      Length : Natural;\n-\n-   begin\n-      Length := 0;\n-      for J in 1 .. Osint.Nb_Dir_In_Obj_Search_Path loop\n-         if Osint.Dir_In_Obj_Search_Path (J)'Length = 0 then\n-            Length := Length + 2;\n-         else\n-            Length := Length + Osint.Dir_In_Obj_Search_Path (J)'Length + 1;\n-         end if;\n-      end loop;\n-\n-      declare\n-         Result : String (1 .. Length);\n-         L      : Natural;\n-\n-      begin\n-         L := Result'First;\n-         for J in 1 .. Osint.Nb_Dir_In_Obj_Search_Path loop\n-            if Osint.Dir_In_Obj_Search_Path (J)'Length = 0 then\n-               Result (L .. L + 1) := \".\" & Path_Separator;\n-               L := L + 2;\n-            else\n-               Result (L .. L + Osint.Dir_In_Obj_Search_Path (J)'Length - 1) :=\n-                 Osint.Dir_In_Obj_Search_Path (J).all;\n-               L := L + Osint.Dir_In_Obj_Search_Path (J)'Length;\n-               Result (L) := Path_Separator;\n-               L := L + 1;\n-            end if;\n-         end loop;\n-\n-         return Result;\n-      end;\n-   end Parse_Gnatls_Obj;\n-\n-   -------------------\n-   -- Reset_Obj_Dir --\n-   -------------------\n-\n-   procedure Reset_Obj_Dir is\n-   begin\n-      Directories.Obj_Dir_Index := 1;\n-   end Reset_Obj_Dir;\n-\n-   -----------------------\n-   -- Set_Default_Match --\n-   -----------------------\n-\n-   procedure Set_Default_Match (Value : Boolean) is\n-   begin\n-      Default_Match := Value;\n-   end Set_Default_Match;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Str : in out Cst_String_Access) is\n-      function Convert is new Ada.Unchecked_Conversion\n-        (Cst_String_Access, GNAT.OS_Lib.String_Access);\n-\n-      S : GNAT.OS_Lib.String_Access := Convert (Str);\n-\n-   begin\n-      Free (S);\n-      Str := null;\n-   end Free;\n-\n-   ---------------------\n-   -- Reset_Directory --\n-   ---------------------\n-\n-   procedure Reset_Directory (File : File_Reference) is\n-   begin\n-      Free (File.Dir);\n-   end Reset_Directory;\n-\n-   -------------------\n-   -- Set_Unvisited --\n-   -------------------\n-\n-   procedure Set_Unvisited (File_Ref : File_Reference) is\n-      F : constant String := Get_File (File_Ref, With_Dir => False);\n-\n-   begin\n-      File_Ref.Visited := False;\n-\n-      --  Do not add a source file to the list. This is true for gnatxref\n-      --  gnatfind, so good enough.\n-\n-      if F'Length > 4\n-        and then F (F'Last - 3 .. F'Last) = \".\" & Osint.ALI_Suffix.all\n-      then\n-         Unvisited_Files := new Unvisited_Files_Record'\n-           (File => File_Ref,\n-            Next => Unvisited_Files);\n-      end if;\n-   end Set_Unvisited;\n-\n-   ----------------------\n-   -- Get_Declarations --\n-   ----------------------\n-\n-   function Get_Declarations\n-     (Sorted : Boolean := True)\n-      return   Declaration_Array_Access\n-   is\n-      Arr   : constant Declaration_Array_Access :=\n-                new Declaration_Array (1 .. Entities_Count);\n-      Decl  : Declaration_Reference := Entities_HTable.Get_First;\n-      Index : Natural               := Arr'First;\n-      Tmp   : Declaration_Reference;\n-\n-      procedure Move (From : Natural; To : Natural);\n-      function Lt (Op1, Op2 : Natural) return Boolean;\n-      --  See GNAT.Heap_Sort_G\n-\n-      --------\n-      -- Lt --\n-      --------\n-\n-      function Lt (Op1, Op2 : Natural) return Boolean is\n-      begin\n-         if Op1 = 0 then\n-            return Is_Less_Than (Tmp, Arr (Op2));\n-         elsif Op2 = 0 then\n-            return Is_Less_Than (Arr (Op1), Tmp);\n-         else\n-            return Is_Less_Than (Arr (Op1), Arr (Op2));\n-         end if;\n-      end Lt;\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         if To = 0 then\n-            Tmp := Arr (From);\n-         elsif From = 0 then\n-            Arr (To) := Tmp;\n-         else\n-            Arr (To) := Arr (From);\n-         end if;\n-      end Move;\n-\n-      package Decl_Sort is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-   --  Start of processing for Get_Declarations\n-\n-   begin\n-      while Decl /= null loop\n-         Arr (Index) := Decl;\n-         Index := Index + 1;\n-         Decl := Entities_HTable.Get_Next;\n-      end loop;\n-\n-      if Sorted and then Arr'Length /= 0 then\n-         Decl_Sort.Sort (Entities_Count);\n-      end if;\n-\n-      return Arr;\n-   end Get_Declarations;\n-\n-   ----------------------\n-   -- References_Count --\n-   ----------------------\n-\n-   function References_Count\n-     (Decl       : Declaration_Reference;\n-      Get_Reads  : Boolean := False;\n-      Get_Writes : Boolean := False;\n-      Get_Bodies : Boolean := False)\n-      return       Natural\n-   is\n-      function List_Length (E : Reference) return Natural;\n-      --  Return the number of references in E\n-\n-      -----------------\n-      -- List_Length --\n-      -----------------\n-\n-      function List_Length (E : Reference) return Natural is\n-         L  : Natural := 0;\n-         E1 : Reference := E;\n-\n-      begin\n-         while E1 /= null loop\n-            L := L + 1;\n-            E1 := E1.Next;\n-         end loop;\n-\n-         return L;\n-      end List_Length;\n-\n-      Length : Natural := 0;\n-\n-   --  Start of processing for References_Count\n-\n-   begin\n-      if Get_Reads then\n-         Length := List_Length (Decl.Ref_Ref);\n-      end if;\n-\n-      if Get_Writes then\n-         Length := Length + List_Length (Decl.Modif_Ref);\n-      end if;\n-\n-      if Get_Bodies then\n-         Length := Length + List_Length (Decl.Body_Ref);\n-      end if;\n-\n-      return Length;\n-   end References_Count;\n-\n-   ----------------------\n-   -- Store_References --\n-   ----------------------\n-\n-   procedure Store_References\n-     (Decl            : Declaration_Reference;\n-      Get_Writes      : Boolean := False;\n-      Get_Reads       : Boolean := False;\n-      Get_Bodies      : Boolean := False;\n-      Get_Declaration : Boolean := False;\n-      Arr             : in out Reference_Array;\n-      Index           : in out Natural)\n-   is\n-      procedure Add (List : Reference);\n-      --  Add all the references in List to Arr\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      procedure Add (List : Reference) is\n-         E : Reference := List;\n-      begin\n-         while E /= null loop\n-            Arr (Index) := E;\n-            Index := Index + 1;\n-            E := E.Next;\n-         end loop;\n-      end Add;\n-\n-   --  Start of processing for Store_References\n-\n-   begin\n-      if Get_Declaration then\n-         Add (Decl.Decl);\n-      end if;\n-\n-      if Get_Reads then\n-         Add (Decl.Ref_Ref);\n-      end if;\n-\n-      if Get_Writes then\n-         Add (Decl.Modif_Ref);\n-      end if;\n-\n-      if Get_Bodies then\n-         Add (Decl.Body_Ref);\n-      end if;\n-   end Store_References;\n-\n-   --------------------\n-   -- Get_References --\n-   --------------------\n-\n-   function Get_References\n-     (Decl : Declaration_Reference;\n-      Get_Reads  : Boolean := False;\n-      Get_Writes : Boolean := False;\n-      Get_Bodies : Boolean := False)\n-      return       Reference_Array_Access\n-   is\n-      Length : constant Natural :=\n-                 References_Count (Decl, Get_Reads, Get_Writes, Get_Bodies);\n-\n-      Arr : constant Reference_Array_Access :=\n-              new Reference_Array (1 .. Length);\n-\n-      Index : Natural := Arr'First;\n-\n-   begin\n-      Store_References\n-        (Decl            => Decl,\n-         Get_Writes      => Get_Writes,\n-         Get_Reads       => Get_Reads,\n-         Get_Bodies      => Get_Bodies,\n-         Get_Declaration => False,\n-         Arr             => Arr.all,\n-         Index           => Index);\n-\n-      if Arr'Length /= 0 then\n-         Sort (Arr.all);\n-      end if;\n-\n-      return Arr;\n-   end Get_References;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Arr : in out Reference_Array_Access) is\n-      procedure Internal is new Ada.Unchecked_Deallocation\n-        (Reference_Array, Reference_Array_Access);\n-   begin\n-      Internal (Arr);\n-   end Free;\n-\n-   ------------------\n-   -- Is_Parameter --\n-   ------------------\n-\n-   function Is_Parameter (Decl : Declaration_Reference) return Boolean is\n-   begin\n-      return Decl.Is_Parameter;\n-   end Is_Parameter;\n-\n-end Xr_Tabls;"}, {"sha": "e8662b79c72b311a3e93da1bd9ce9a13d5faa1b6", "filename": "gcc/ada/xr_tabls.ads", "status": "removed", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxr_tabls.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxr_tabls.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxr_tabls.ads?ref=c92f4fddd68463e7bc21e6a71c89848410311351", "patch": "@@ -1,388 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             X R  _ T A B L S                             --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1998-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Cross reference utilities used by gnatxref and gnatfind\n-\n-with GNAT.OS_Lib;\n-\n-package Xr_Tabls is\n-\n-   -------------------\n-   -- Project files --\n-   -------------------\n-\n-   function ALI_File_Name (Ada_File_Name : String) return String;\n-   --  Returns the ali file name corresponding to Ada_File_Name\n-\n-   procedure Create_Project_File (Name : String);\n-   --  Open and parse a new project file. If the file Name could not be\n-   --  opened or is not a valid project file, then a project file associated\n-   --  with the standard default directories is returned\n-\n-   function Next_Obj_Dir return String;\n-   --  Returns the next directory to visit to find related ali files\n-   --  If there are no more such directories, returns a null string.\n-\n-   function Current_Obj_Dir return String;\n-   --  Returns the obj_dir which was returned by the last Next_Obj_Dir call\n-\n-   procedure Reset_Obj_Dir;\n-   --  Reset the iterator for Obj_Dir\n-\n-   ------------\n-   -- Tables --\n-   ------------\n-\n-   type Declaration_Reference is private;\n-   Empty_Declaration : constant Declaration_Reference;\n-\n-   type Declaration_Array is array (Natural range <>) of Declaration_Reference;\n-   type Declaration_Array_Access is access Declaration_Array;\n-\n-   type File_Reference is private;\n-   Empty_File : constant File_Reference;\n-\n-   type Reference is private;\n-   Empty_Reference : constant Reference;\n-\n-   type Reference_Array is array (Natural range <>) of Reference;\n-   type Reference_Array_Access is access Reference_Array;\n-\n-   procedure Free (Arr : in out Reference_Array_Access);\n-\n-   function Add_Declaration\n-     (File_Ref     : File_Reference;\n-      Symbol       : String;\n-      Line         : Natural;\n-      Column       : Natural;\n-      Decl_Type    : Character;\n-      Is_Parameter : Boolean := False;\n-      Remove_Only  : Boolean := False;\n-      Symbol_Match : Boolean := True)\n-      return         Declaration_Reference;\n-   --  Add a new declaration in the table and return the index to it. Decl_Type\n-   --  is the type of the entity Any previous instance of this entity in the\n-   --  htable is removed. If Remove_Only is True, then any previous instance is\n-   --  removed, but the new entity is never inserted. Symbol_Match should be\n-   --  set to False if the name of the symbol doesn't match the pattern from\n-   --  the command line. In that case, the entity will not be output by\n-   --  gnatfind. If Symbol_Match is True, the entity will only be output if\n-   --  the file name itself matches. Is_Parameter should be set to True if\n-   --  the entity is known to be a subprogram parameter.\n-\n-   procedure Add_Parent\n-     (Declaration : in out Declaration_Reference;\n-      Symbol      : String;\n-      Line        : Natural;\n-      Column      : Natural;\n-      File_Ref    : File_Reference);\n-   --  The parent declaration (Symbol in file File_Ref at position Line and\n-   --  Column) information is added to Declaration.\n-\n-   function Add_To_Xref_File\n-     (File_Name       : String;\n-      Visited         : Boolean := True;\n-      Emit_Warning    : Boolean := False;\n-      Gnatchop_File   : String  := \"\";\n-      Gnatchop_Offset : Integer := 0)\n-      return            File_Reference;\n-   --  Add a new reference to a file in the table. Ref is used to return the\n-   --  index in the table where this file is stored. Visited is the value which\n-   --  will be used in the table (if True, the file will not be returned by\n-   --  Next_Unvisited_File). If Emit_Warning is True and the ali file does\n-   --  not exist or does not have cross-referencing information, then a\n-   --  warning will be emitted. Gnatchop_File is the name of the file that\n-   --  File_Name was extracted from through a call to \"gnatchop -r\" (using\n-   --  pragma Source_Reference). Gnatchop_Offset should be the index of the\n-   --  first line of File_Name within the Gnatchop_File.\n-\n-   procedure Add_Line\n-     (File   : File_Reference;\n-      Line   : Natural;\n-      Column : Natural);\n-   --  Add a new reference in a file, which the user has provided on the\n-   --  command line. This is used for an optimized matching algorithm.\n-\n-   procedure Add_Reference\n-     (Declaration   : Declaration_Reference;\n-      File_Ref      : File_Reference;\n-      Line          : Natural;\n-      Column        : Natural;\n-      Ref_Type      : Character;\n-      Labels_As_Ref : Boolean);\n-   --  Add a new reference (Ref_Type = 'r'), body (Ref_Type = 'b') or\n-   --  modification (Ref_Type = 'm') to an entity. If Labels_As_Ref is True,\n-   --  then the references to the entity after the end statements (\"end Foo\")\n-   --  are counted as actual references. This means that the entity will never\n-   --  be reported as unreferenced (for instance in the case of gnatxref -u).\n-\n-   function Get_Declarations\n-     (Sorted : Boolean := True)\n-      return   Declaration_Array_Access;\n-   --  Return a sorted list of all the declarations in the application.\n-   --  Freeing this array is the responsibility of the caller, however it\n-   --  shouldn't free the actual contents of the array, which are pointers\n-   --  to internal data\n-\n-   function References_Count\n-     (Decl       : Declaration_Reference;\n-      Get_Reads  : Boolean := False;\n-      Get_Writes : Boolean := False;\n-      Get_Bodies : Boolean := False)\n-      return       Natural;\n-   --  Return the number of references in Decl for the categories specified\n-   --  by the Get_* parameters (read-only accesses, write accesses and bodies)\n-\n-   function Get_References\n-     (Decl : Declaration_Reference;\n-      Get_Reads  : Boolean := False;\n-      Get_Writes : Boolean := False;\n-      Get_Bodies : Boolean := False)\n-      return       Reference_Array_Access;\n-   --  Return a sorted list of all references to the entity in decl. The\n-   --  parameters Get_* are used to specify what kind of references should be\n-   --  merged and returned (read-only accesses, write accesses and bodies).\n-\n-   function Get_Column (Decl : Declaration_Reference) return String;\n-   function Get_Column (Ref : Reference) return String;\n-\n-   function Get_Declaration\n-     (File_Ref : File_Reference;\n-      Line     : Natural;\n-      Column   : Natural)\n-      return     Declaration_Reference;\n-   --  Returns reference to the declaration found in file File_Ref at the\n-   --  given Line and Column\n-\n-   function Get_Parent\n-     (Decl : Declaration_Reference)\n-      return Declaration_Reference;\n-   --  Returns reference to Decl's parent declaration\n-\n-   function Get_Emit_Warning (File : File_Reference) return Boolean;\n-   --  Returns the Emit_Warning field of the structure\n-\n-   function Get_Gnatchop_File\n-     (File     : File_Reference;\n-      With_Dir : Boolean := False)\n-      return     String;\n-   function Get_Gnatchop_File\n-     (Ref      : Reference;\n-      With_Dir : Boolean := False)\n-      return     String;\n-   function Get_Gnatchop_File\n-     (Decl     : Declaration_Reference;\n-      With_Dir : Boolean := False)\n-      return     String;\n-   --  Return the name of the file that File was extracted from through a\n-   --  call to \"gnatchop -r\". The file name for File is returned if File\n-   --  was not extracted from such a file. The directory will be given only\n-   --  if With_Dir is True.\n-\n-   function Get_File\n-     (Decl     : Declaration_Reference;\n-      With_Dir : Boolean := False) return String;\n-   pragma Inline (Get_File);\n-   --  Extract column number or file name from reference\n-\n-   function Get_File\n-     (Ref      : Reference;\n-      With_Dir : Boolean := False) return String;\n-   pragma Inline (Get_File);\n-\n-   function Get_File\n-     (File     : File_Reference;\n-      With_Dir : Boolean := False;\n-      Strip    : Natural := 0) return String;\n-   --  Returns the file name (and its directory if With_Dir is True or the user\n-   --  has used the -f switch on the command line. If Strip is not 0, then the\n-   --  last Strip-th \"-...\" substrings are removed first. For instance, with\n-   --  Strip=2, a file name \"parent-child1-child2-child3.ali\" would be returned\n-   --  as \"parent-child1.ali\". This is used when looking for the ALI file to\n-   --  use for a package, since for separates with have to use the parent's\n-   --  ALI. The null string is returned if there is no such parent unit.\n-   --\n-   --  Note that this version of Get_File is not inlined\n-\n-   function Get_File_Ref (Ref : Reference)              return File_Reference;\n-   function Get_Line     (Decl : Declaration_Reference) return String;\n-   function Get_Line     (Ref : Reference)              return String;\n-   function Get_Symbol   (Decl : Declaration_Reference) return String;\n-   function Get_Type     (Decl : Declaration_Reference) return Character;\n-   function Is_Parameter (Decl : Declaration_Reference) return Boolean;\n-   --  Functions that return the contents of a declaration\n-\n-   function Get_Source_Line (Ref : Reference)              return String;\n-   function Get_Source_Line (Decl : Declaration_Reference) return String;\n-   --  Return the source line associated with the reference\n-\n-   procedure Grep_Source_Files;\n-   --  Parse all the source files which have at least one reference, and grep\n-   --  the appropriate source lines so that we'll be able to display them. This\n-   --  function should be called once all the .ali files have been parsed, and\n-   --  only if the appropriate user switch\n-   --  has been used (gnatfind -s).\n-   --\n-   --  Note: To save memory, the strings for the source lines are shared. Thus\n-   --  it is no longer possible to free the references, or we would free the\n-   --  same chunk multiple times. It doesn't matter, though, since this is only\n-   --  called once, prior to exiting gnatfind.\n-\n-   function Longest_File_Name return Natural;\n-   --  Returns the longest file name found\n-\n-   function Match (Decl : Declaration_Reference) return Boolean;\n-   --  Return True if the declaration matches\n-\n-   function Match\n-     (File   : File_Reference;\n-      Line   : Natural;\n-      Column : Natural)\n-      return   Boolean;\n-   --  Returns True if File:Line:Column was given on the command line\n-   --  by the user\n-\n-   function Next_Unvisited_File return File_Reference;\n-   --  Returns the next unvisited library file in the list If there is no more\n-   --  unvisited file, return Empty_File. Two calls to this subprogram will\n-   --  return different files.\n-\n-   procedure Set_Default_Match (Value : Boolean);\n-   --  Set the default value for match in declarations.\n-   --  This is used so that if no file was provided in the\n-   --  command line, then every file match\n-\n-   procedure Reset_Directory (File : File_Reference);\n-   --  Reset the cached directory for file. Next time Get_File is called, the\n-   --  directory will be recomputed.\n-\n-   procedure Set_Unvisited (File_Ref : File_Reference);\n-   --  Set File_Ref as unvisited. So Next_Unvisited_File will return it\n-\n-   procedure Read_File\n-     (File_Name : String;\n-      Contents  : out GNAT.OS_Lib.String_Access);\n-   --  Reads File_Name into the newly allocated string Contents. Types.EOF\n-   --  character will be added to the returned Contents to simplify parsing.\n-   --  Name_Error is raised if the file was not found. End_Error is raised if\n-   --  the file could not be read correctly. For most systems correct reading\n-   --  means that the number of bytes read is equal to the file size.\n-\n-private\n-   type Project_File (Src_Dir_Length, Obj_Dir_Length : Natural) is record\n-      Src_Dir_Index      : Integer;\n-      Obj_Dir_Index      : Integer;\n-      Last_Obj_Dir_Start : Natural;\n-      Src_Dir            : String (1 .. Src_Dir_Length);\n-      Obj_Dir            : String (1 .. Obj_Dir_Length);\n-   end record;\n-\n-   type Project_File_Ptr is access all Project_File;\n-   --  This is actually a list of all the directories to be searched,\n-   --  either for source files or for library files\n-\n-   type Ref_In_File;\n-   type Ref_In_File_Ptr is access all Ref_In_File;\n-\n-   type Ref_In_File is record\n-      Line   : Natural;\n-      Column : Natural;\n-      Next   : Ref_In_File_Ptr := null;\n-   end record;\n-\n-   type File_Record;\n-   type File_Reference is access all File_Record;\n-\n-   Empty_File : constant File_Reference := null;\n-   type Cst_String_Access is access constant String;\n-\n-   procedure Free (Str : in out Cst_String_Access);\n-\n-   type File_Record is record\n-      File            : Cst_String_Access;\n-      Dir             : GNAT.OS_Lib.String_Access;\n-      Lines           : Ref_In_File_Ptr := null;\n-      Visited         : Boolean         := False;\n-      Emit_Warning    : Boolean         := False;\n-      Gnatchop_File   : GNAT.OS_Lib.String_Access   := null;\n-      Gnatchop_Offset : Integer         := 0;\n-      Next            : File_Reference  := null;\n-   end record;\n-   --  Holds a reference to a source file, that was referenced in at least one\n-   --  ALI file. Gnatchop_File will contain the name of the file that File was\n-   --  extracted From. Gnatchop_Offset contains the index of the first line of\n-   --  File within Gnatchop_File. These two fields are used to properly support\n-   --  gnatchop files and pragma Source_Reference.\n-   --\n-   --  Lines is used for files that were given on the command line, to\n-   --  memorize the lines and columns that the user specified.\n-\n-   type Reference_Record;\n-   type Reference is access all Reference_Record;\n-\n-   Empty_Reference : constant Reference := null;\n-\n-   type Reference_Record is record\n-      File        : File_Reference;\n-      Line        : Natural;\n-      Column      : Natural;\n-      Source_Line : Cst_String_Access;\n-      Next        : Reference := null;\n-   end record;\n-   --  File is a reference to the Ada source file\n-   --  Source_Line is the Line as it appears in the source file. This\n-   --  field is only used when the switch is set on the command line of\n-   --  gnatfind.\n-\n-   type Declaration_Record;\n-   type Declaration_Reference is access all Declaration_Record;\n-\n-   Empty_Declaration : constant Declaration_Reference := null;\n-\n-   type Declaration_Record (Symbol_Length : Natural) is record\n-      Key          : Cst_String_Access;\n-      Decl         : Reference;\n-      Is_Parameter : Boolean := False; -- True if entity is subprog param\n-      Decl_Type    : Character;\n-      Body_Ref     : Reference := null;\n-      Ref_Ref      : Reference := null;\n-      Modif_Ref    : Reference := null;\n-      Match        : Boolean := False;\n-      Par_Symbol   : Declaration_Reference := null;\n-      Next         : Declaration_Reference := null;\n-      Symbol       : String (1 .. Symbol_Length);\n-   end record;\n-   --  The lists of referenced (Body_Ref, Ref_Ref and Modif_Ref) are\n-   --  kept unsorted until the results needs to be printed. This saves\n-   --  lots of time while the internal tables are created.\n-\n-   pragma Inline (Get_Column);\n-   pragma Inline (Get_Emit_Warning);\n-   pragma Inline (Get_File_Ref);\n-   pragma Inline (Get_Line);\n-   pragma Inline (Get_Symbol);\n-   pragma Inline (Get_Type);\n-   pragma Inline (Longest_File_Name);\n-end Xr_Tabls;"}, {"sha": "3cb7bcb8469ee9ed72e81a67f2497af0170d0804", "filename": "gcc/ada/xref_lib.adb", "status": "removed", "additions": 0, "deletions": 1892, "changes": 1892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=c92f4fddd68463e7bc21e6a71c89848410311351", "patch": "@@ -1,1892 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             X R E F _ L I B                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1998-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-pragma Ada_2012;\n-\n-with Osint;\n-with Output; use Output;\n-with Types;  use Types;\n-\n-with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n-with Ada.Text_IO;\n-with Ada.Unchecked_Deallocation;\n-\n-with GNAT.Command_Line; use GNAT.Command_Line;\n-with GNAT.IO_Aux;       use GNAT.IO_Aux;\n-\n-package body Xref_Lib is\n-\n-   Type_Position : constant := 50;\n-   --  Column for label identifying type of entity\n-\n-   ---------------------\n-   -- Local Variables --\n-   ---------------------\n-\n-   Pipe : constant Character := '|';\n-   --  First character on xref lines in the .ali file\n-\n-   No_Xref_Information : exception;\n-   --  Exception raised when there is no cross-referencing information in\n-   --  the .ali files.\n-\n-   procedure Parse_EOL\n-     (Source                 : not null access String;\n-      Ptr                    : in out Positive;\n-      Skip_Continuation_Line : Boolean := False);\n-   --  On return Source (Ptr) is the first character of the next line\n-   --  or EOF. Source.all must be terminated by EOF.\n-   --\n-   --  If Skip_Continuation_Line is True, this subprogram skips as many\n-   --  lines as required when the second or more lines starts with '.'\n-   --  (continuation lines in ALI files).\n-\n-   function Current_Xref_File (File : ALI_File) return File_Reference;\n-   --  Return the file matching the last 'X' line we found while parsing\n-   --  the ALI file.\n-\n-   function File_Name (File : ALI_File; Num : Positive) return File_Reference;\n-   --  Returns the dependency file name number Num\n-\n-   function Get_Full_Type (Decl : Declaration_Reference) return String;\n-   --  Returns the full type corresponding to a type letter as found in\n-   --  the .ali files.\n-\n-   procedure Open\n-     (Name         : String;\n-      File         : in out ALI_File;\n-      Dependencies : Boolean := False);\n-   --  Open a new ALI file. If Dependencies is True, the insert every library\n-   --  file 'with'ed in the files database (used for gnatxref)\n-\n-   procedure Parse_Identifier_Info\n-     (Pattern       : Search_Pattern;\n-      File          : in out ALI_File;\n-      Local_Symbols : Boolean;\n-      Der_Info      : Boolean := False;\n-      Type_Tree     : Boolean := False;\n-      Wide_Search   : Boolean := True;\n-      Labels_As_Ref : Boolean := True);\n-   --  Output the file and the line where the identifier was referenced,\n-   --  If Local_Symbols is False then only the publicly visible symbols\n-   --  will be processed.\n-   --\n-   --  If Labels_As_Ref is true, then the references to the entities after\n-   --  the end statements (\"end Foo\") will be counted as actual references.\n-   --  The entity will never be reported as unreferenced by gnatxref -u\n-\n-   procedure Parse_Token\n-     (Source    : not null access String;\n-      Ptr       : in out Positive;\n-      Token_Ptr : out Positive);\n-   --  Skips any separators and stores the start of the token in Token_Ptr.\n-   --  Then stores the position of the next separator in Ptr. On return\n-   --  Source (Token_Ptr .. Ptr - 1) is the token. Separators are space\n-   --  and ASCII.HT. Parse_Token will never skip to the next line.\n-\n-   procedure Parse_Number\n-     (Source : not null access String;\n-      Ptr    : in out Positive;\n-      Number : out Natural);\n-   --  Skips any separators and parses Source up to the first character that\n-   --  is not a decimal digit. Returns value of parsed digits or 0 if none.\n-\n-   procedure Parse_X_Filename (File : in out ALI_File);\n-   --  Reads and processes \"X...\" lines in the ALI file\n-   --  and updates the File.X_File information.\n-\n-   procedure Skip_To_First_X_Line\n-     (File    : in out ALI_File;\n-      D_Lines : Boolean;\n-      W_Lines : Boolean);\n-   --  Skip the lines in the ALI file until the first cross-reference line\n-   --  (^X...) is found. Search is started from the beginning of the file.\n-   --  If not such line is found, No_Xref_Information is raised.\n-   --  If W_Lines is false, then the lines \"^W\" are not parsed.\n-   --  If D_Lines is false, then the lines \"^D\" are not parsed.\n-\n-   ----------------\n-   -- Add_Entity --\n-   ----------------\n-\n-   procedure Add_Entity\n-     (Pattern : in out Search_Pattern;\n-      Entity  : String;\n-      Glob    : Boolean := False)\n-   is\n-      File_Start : Natural;\n-      Line_Start : Natural;\n-      Col_Start  : Natural;\n-      Line_Num   : Natural := 0;\n-      Col_Num    : Natural := 0;\n-\n-      File_Ref : File_Reference := Empty_File;\n-      pragma Warnings (Off, File_Ref);\n-\n-   begin\n-      --  Find the end of the first item in Entity (pattern or file?)\n-      --  If there is no ':', we only have a pattern\n-\n-      File_Start := Index (Entity, \":\");\n-\n-      --  If the regular expression is invalid, just consider it as a string\n-\n-      if File_Start = 0 then\n-         begin\n-            Pattern.Entity := Compile (Entity, Glob, False);\n-            Pattern.Initialized := True;\n-\n-         exception\n-            when Error_In_Regexp =>\n-\n-               --  The basic idea is to insert a \\ before every character\n-\n-               declare\n-                  Tmp_Regexp : String (1 .. 2 * Entity'Length);\n-                  Index      : Positive := 1;\n-\n-               begin\n-                  for J in Entity'Range loop\n-                     Tmp_Regexp (Index) := '\\';\n-                     Tmp_Regexp (Index + 1) := Entity (J);\n-                     Index := Index + 2;\n-                  end loop;\n-\n-                  Pattern.Entity := Compile (Tmp_Regexp, True, False);\n-                  Pattern.Initialized := True;\n-               end;\n-         end;\n-\n-         Set_Default_Match (True);\n-         return;\n-      end if;\n-\n-      --  If there is a dot in the pattern, then it is a file name\n-\n-      if (Glob and then\n-           Index (Entity (Entity'First .. File_Start - 1), \".\") /= 0)\n-             or else\n-              (not Glob\n-                 and then Index (Entity (Entity'First .. File_Start - 1),\n-                                   \"\\.\") /= 0)\n-      then\n-         Pattern.Entity      := Compile (\".*\", False);\n-         Pattern.Initialized := True;\n-         File_Start          := Entity'First;\n-\n-      else\n-         --  If the regular expression is invalid, just consider it as a string\n-\n-         begin\n-            Pattern.Entity :=\n-              Compile (Entity (Entity'First .. File_Start - 1), Glob, False);\n-            Pattern.Initialized := True;\n-\n-         exception\n-            when Error_In_Regexp =>\n-\n-               --  The basic idea is to insert a \\ before every character\n-\n-               declare\n-                  Tmp_Regexp : String (1 .. 2 * (File_Start - Entity'First));\n-                  Index      : Positive := 1;\n-\n-               begin\n-                  for J in Entity'First .. File_Start - 1 loop\n-                     Tmp_Regexp (Index) := '\\';\n-                     Tmp_Regexp (Index + 1) := Entity (J);\n-                     Index := Index + 2;\n-                  end loop;\n-\n-                  Pattern.Entity := Compile (Tmp_Regexp, True, False);\n-                  Pattern.Initialized := True;\n-               end;\n-         end;\n-\n-         File_Start := File_Start + 1;\n-      end if;\n-\n-      --  Parse the file name\n-\n-      Line_Start := Index (Entity (File_Start .. Entity'Last), \":\");\n-\n-      --  Check if it was a disk:\\directory item (for Windows)\n-\n-      if File_Start = Line_Start - 1\n-        and then Line_Start < Entity'Last\n-        and then Entity (Line_Start + 1) = '\\'\n-      then\n-         Line_Start := Index (Entity (Line_Start + 1 .. Entity'Last), \":\");\n-      end if;\n-\n-      if Line_Start = 0 then\n-         Line_Start := Entity'Length + 1;\n-\n-      elsif Line_Start /= Entity'Last then\n-         Col_Start := Index (Entity (Line_Start + 1 .. Entity'Last), \":\");\n-\n-         if Col_Start = 0 then\n-            Col_Start := Entity'Last + 1;\n-         end if;\n-\n-         if Col_Start > Line_Start + 1 then\n-            begin\n-               Line_Num := Natural'Value\n-                 (Entity (Line_Start + 1 .. Col_Start - 1));\n-\n-            exception\n-               when Constraint_Error =>\n-                  raise Invalid_Argument;\n-            end;\n-         end if;\n-\n-         if Col_Start < Entity'Last then\n-            begin\n-               Col_Num := Natural'Value (Entity\n-                                         (Col_Start + 1 .. Entity'Last));\n-\n-            exception\n-               when Constraint_Error => raise Invalid_Argument;\n-            end;\n-         end if;\n-      end if;\n-\n-      declare\n-         File_Name : String := Entity (File_Start .. Line_Start - 1);\n-\n-      begin\n-         Osint.Canonical_Case_File_Name (File_Name);\n-         File_Ref := Add_To_Xref_File (File_Name, Visited => True);\n-         Pattern.File_Ref := File_Ref;\n-\n-         Add_Line (Pattern.File_Ref, Line_Num, Col_Num);\n-\n-         File_Ref :=\n-           Add_To_Xref_File\n-             (ALI_File_Name (File_Name),\n-              Visited      => False,\n-              Emit_Warning => True);\n-      end;\n-   end Add_Entity;\n-\n-   -------------------\n-   -- Add_Xref_File --\n-   -------------------\n-\n-   procedure Add_Xref_File (File : String) is\n-      File_Ref : File_Reference := Empty_File;\n-      pragma Unreferenced (File_Ref);\n-\n-      Iterator : Expansion_Iterator;\n-\n-      procedure Add_Xref_File_Internal (File : String);\n-      --  Do the actual addition of the file\n-\n-      ----------------------------\n-      -- Add_Xref_File_Internal --\n-      ----------------------------\n-\n-      procedure Add_Xref_File_Internal (File : String) is\n-      begin\n-         --  Case where we have an ALI file, accept it even though this is\n-         --  not official usage, since the intention is obvious\n-\n-         if Tail (File, 4) = \".\" & Osint.ALI_Suffix.all then\n-            File_Ref := Add_To_Xref_File\n-                          (File, Visited => False, Emit_Warning => True);\n-\n-         --  Normal non-ali file case\n-\n-         else\n-            File_Ref := Add_To_Xref_File (File, Visited => True);\n-\n-            File_Ref := Add_To_Xref_File\n-                         (ALI_File_Name (File),\n-                          Visited => False, Emit_Warning => True);\n-         end if;\n-      end Add_Xref_File_Internal;\n-\n-   --  Start of processing for Add_Xref_File\n-\n-   begin\n-      --  Check if we need to do the expansion\n-\n-      if Ada.Strings.Fixed.Index (File, \"*\") /= 0\n-        or else Ada.Strings.Fixed.Index (File, \"?\") /= 0\n-      then\n-         Start_Expansion (Iterator, File);\n-\n-         loop\n-            declare\n-               S : constant String := Expansion (Iterator);\n-\n-            begin\n-               exit when S'Length = 0;\n-               Add_Xref_File_Internal (S);\n-            end;\n-         end loop;\n-\n-      else\n-         Add_Xref_File_Internal (File);\n-      end if;\n-   end Add_Xref_File;\n-\n-   -----------------------\n-   -- Current_Xref_File --\n-   -----------------------\n-\n-   function Current_Xref_File (File : ALI_File) return File_Reference is\n-   begin\n-      return File.X_File;\n-   end Current_Xref_File;\n-\n-   --------------------------\n-   -- Default_Project_File --\n-   --------------------------\n-\n-   function Default_Project_File (Dir_Name : String) return String is\n-      My_Dir  : Dir_Type;\n-      Dir_Ent : File_Name_String;\n-      Last    : Natural;\n-\n-   begin\n-      Open (My_Dir, Dir_Name);\n-\n-      loop\n-         Read (My_Dir, Dir_Ent, Last);\n-         exit when Last = 0;\n-\n-         if Tail (Dir_Ent (1 .. Last), 4) = \".adp\" then\n-\n-            --  The first project file found is the good one\n-\n-            Close (My_Dir);\n-            return Dir_Ent (1 .. Last);\n-         end if;\n-      end loop;\n-\n-      Close (My_Dir);\n-      return String'(1 .. 0 => ' ');\n-\n-   exception\n-      when Directory_Error => return String'(1 .. 0 => ' ');\n-   end Default_Project_File;\n-\n-   ---------------\n-   -- File_Name --\n-   ---------------\n-\n-   function File_Name\n-     (File : ALI_File;\n-      Num  : Positive) return File_Reference\n-   is\n-      Table : Table_Type renames File.Dep.Table (1 .. Last (File.Dep));\n-   begin\n-      return Table (Num);\n-   end File_Name;\n-\n-   --------------------\n-   -- Find_ALI_Files --\n-   --------------------\n-\n-   procedure Find_ALI_Files is\n-      My_Dir  : Rec_DIR;\n-      Dir_Ent : File_Name_String;\n-      Last    : Natural;\n-\n-      File_Ref : File_Reference;\n-      pragma Unreferenced (File_Ref);\n-\n-      function Open_Next_Dir return Boolean;\n-      --  Tries to open the next object directory, and return False if\n-      --  the directory cannot be opened.\n-\n-      -------------------\n-      -- Open_Next_Dir --\n-      -------------------\n-\n-      function Open_Next_Dir return Boolean is\n-      begin\n-         --  Until we are able to open a new directory\n-\n-         loop\n-            declare\n-               Obj_Dir : constant String := Next_Obj_Dir;\n-\n-            begin\n-               --  Case of no more Obj_Dir lines\n-\n-               if Obj_Dir'Length = 0 then\n-                  return False;\n-               end if;\n-\n-               Open (My_Dir.Dir, Obj_Dir);\n-               exit;\n-\n-            exception\n-\n-               --  Could not open the directory\n-\n-               when Directory_Error => null;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end Open_Next_Dir;\n-\n-   --  Start of processing for Find_ALI_Files\n-\n-   begin\n-      Reset_Obj_Dir;\n-\n-      if Open_Next_Dir then\n-         loop\n-            Read (My_Dir.Dir, Dir_Ent, Last);\n-\n-            if Last = 0 then\n-               Close (My_Dir.Dir);\n-\n-               if not Open_Next_Dir then\n-                  return;\n-               end if;\n-\n-            elsif Last > 4\n-              and then Dir_Ent (Last - 3 .. Last) = \".\" & Osint.ALI_Suffix.all\n-            then\n-               File_Ref :=\n-                 Add_To_Xref_File (Dir_Ent (1 .. Last), Visited => False);\n-            end if;\n-         end loop;\n-      end if;\n-   end Find_ALI_Files;\n-\n-   -------------------\n-   -- Get_Full_Type --\n-   -------------------\n-\n-   function Get_Full_Type (Decl : Declaration_Reference) return String is\n-\n-      function Param_String return String;\n-      --  Return the string to display depending on whether Decl is a parameter\n-\n-      ------------------\n-      -- Param_String --\n-      ------------------\n-\n-      function Param_String return String is\n-      begin\n-         if Is_Parameter (Decl) then\n-            return \"parameter \";\n-         else\n-            return \"\";\n-         end if;\n-      end Param_String;\n-\n-   --  Start of processing for Get_Full_Type\n-\n-   begin\n-      case Get_Type (Decl) is\n-         when 'A' => return \"array type\";\n-         when 'B' => return \"boolean type\";\n-         when 'C' => return \"class-wide type\";\n-         when 'D' => return \"decimal type\";\n-         when 'E' => return \"enumeration type\";\n-         when 'F' => return \"float type\";\n-         when 'H' => return \"abstract type\";\n-         when 'I' => return \"integer type\";\n-         when 'M' => return \"modular type\";\n-         when 'O' => return \"fixed type\";\n-         when 'P' => return \"access type\";\n-         when 'R' => return \"record type\";\n-         when 'S' => return \"string type\";\n-         when 'T' => return \"task type\";\n-         when 'W' => return \"protected type\";\n-\n-         when 'a' => return Param_String & \"array object\";\n-         when 'b' => return Param_String & \"boolean object\";\n-         when 'c' => return Param_String & \"class-wide object\";\n-         when 'd' => return Param_String & \"decimal object\";\n-         when 'e' => return Param_String & \"enumeration object\";\n-         when 'f' => return Param_String & \"float object\";\n-         when 'i' => return Param_String & \"integer object\";\n-         when 'j' => return Param_String & \"class object\";\n-         when 'm' => return Param_String & \"modular object\";\n-         when 'o' => return Param_String & \"fixed object\";\n-         when 'p' => return Param_String & \"access object\";\n-         when 'r' => return Param_String & \"record object\";\n-         when 's' => return Param_String & \"string object\";\n-         when 't' => return Param_String & \"task object\";\n-         when 'w' => return Param_String & \"protected object\";\n-         when 'x' => return Param_String & \"abstract procedure\";\n-         when 'y' => return Param_String & \"abstract function\";\n-\n-         when 'h' => return \"interface\";\n-         when 'g' => return \"macro\";\n-         when 'G' => return \"function macro\";\n-         when 'J' => return \"class\";\n-         when 'K' => return \"package\";\n-         when 'k' => return \"generic package\";\n-         when 'L' => return \"statement label\";\n-         when 'l' => return \"loop label\";\n-         when 'N' => return \"named number\";\n-         when 'n' => return \"enumeration literal\";\n-         when 'q' => return \"block label\";\n-         when 'Q' => return \"include file\";\n-         when 'U' => return \"procedure\";\n-         when 'u' => return \"generic procedure\";\n-         when 'V' => return \"function\";\n-         when 'v' => return \"generic function\";\n-         when 'X' => return \"exception\";\n-         when 'Y' => return \"entry\";\n-\n-         when '+' => return \"private type\";\n-         when '*' => return \"private variable\";\n-\n-         --  The above should be the only possibilities, but for this kind\n-         --  of informational output, we don't want to bomb if we find\n-         --  something else, so just return three question marks when we\n-         --  have an unknown Abbrev value\n-\n-         when others =>\n-            if Is_Parameter (Decl) then\n-               return \"parameter\";\n-            else\n-               return \"??? (\" & Get_Type (Decl) & \")\";\n-            end if;\n-      end case;\n-   end Get_Full_Type;\n-\n-   --------------------------\n-   -- Skip_To_First_X_Line --\n-   --------------------------\n-\n-   procedure Skip_To_First_X_Line\n-     (File    : in out ALI_File;\n-      D_Lines : Boolean;\n-      W_Lines : Boolean)\n-   is\n-      Ali              : String_Access renames File.Buffer;\n-      Token            : Positive;\n-      Ptr              : Positive := Ali'First;\n-      Num_Dependencies : Natural  := 0;\n-      File_Start       : Positive;\n-      File_End         : Positive;\n-      Gnatchop_Offset  : Integer;\n-      Gnatchop_Name    : Positive;\n-\n-      File_Ref : File_Reference;\n-      pragma Unreferenced (File_Ref);\n-\n-   begin\n-      --  Read all the lines possibly processing with-clauses and dependency\n-      --  information and exit on finding the first Xref line.\n-      --  A fall-through of the loop means that there is no xref information\n-      --  which is an error condition.\n-\n-      while Ali (Ptr) /= EOF loop\n-         if D_Lines and then Ali (Ptr) = 'D' then\n-\n-            --  Found dependency information. Format looks like:\n-            --  D src-nam time-stmp checksum [subunit-name] [line:file-name]\n-\n-            --  Skip the D and parse the filenam\n-\n-            Ptr := Ptr + 1;\n-            Parse_Token (Ali, Ptr, Token);\n-            File_Start := Token;\n-            File_End := Ptr - 1;\n-\n-            Num_Dependencies := Num_Dependencies + 1;\n-            Set_Last (File.Dep, Num_Dependencies);\n-\n-            Parse_Token (Ali, Ptr, Token); --  Skip time-stamp\n-            Parse_Token (Ali, Ptr, Token); --  Skip checksum\n-            Parse_Token (Ali, Ptr, Token); --  Read next entity on the line\n-\n-            if not (Ali (Token) in '0' .. '9') then\n-               Parse_Token (Ali, Ptr, Token); --  Was a subunit name\n-            end if;\n-\n-            --  Did we have a gnatchop-ed file with a pragma Source_Reference ?\n-\n-            Gnatchop_Offset := 0;\n-\n-            if Ali (Token) in '0' .. '9' then\n-               Gnatchop_Name := Token;\n-               while Ali (Gnatchop_Name) /= ':' loop\n-                  Gnatchop_Name := Gnatchop_Name + 1;\n-               end loop;\n-\n-               Gnatchop_Offset :=\n-                 2 - Natural'Value (Ali (Token .. Gnatchop_Name - 1));\n-               Token := Gnatchop_Name + 1;\n-            end if;\n-\n-            declare\n-               Table : Table_Type renames\n-                         File.Dep.Table (1 .. Last (File.Dep));\n-            begin\n-               Table (Num_Dependencies) := Add_To_Xref_File\n-                 (Ali (File_Start .. File_End),\n-                  Gnatchop_File => Ali (Token .. Ptr - 1),\n-                  Gnatchop_Offset => Gnatchop_Offset);\n-            end;\n-\n-         elsif W_Lines and then Ali (Ptr) = 'W' then\n-\n-            --  Found with-clause information. Format looks like:\n-            --     \"W debug%s               debug.adb               debug.ali\"\n-\n-            --  Skip the W and parse the .ali filename (3rd token)\n-\n-            Parse_Token (Ali, Ptr, Token);\n-            Parse_Token (Ali, Ptr, Token);\n-            Parse_Token (Ali, Ptr, Token);\n-\n-            File_Ref :=\n-              Add_To_Xref_File (Ali (Token .. Ptr - 1), Visited => False);\n-\n-         elsif Ali (Ptr) = 'X' then\n-\n-            --  Found a cross-referencing line - stop processing\n-\n-            File.Current_Line := Ptr;\n-            File.Xref_Line    := Ptr;\n-            return;\n-         end if;\n-\n-         Parse_EOL (Ali, Ptr);\n-      end loop;\n-\n-      raise No_Xref_Information;\n-   end Skip_To_First_X_Line;\n-\n-   ----------\n-   -- Open --\n-   ----------\n-\n-   procedure Open\n-     (Name         : String;\n-      File         : in out ALI_File;\n-      Dependencies : Boolean := False)\n-   is\n-      Ali : String_Access renames File.Buffer;\n-      pragma Warnings (Off, Ali);\n-\n-   begin\n-      if File.Buffer /= null then\n-         Free (File.Buffer);\n-      end if;\n-\n-      Init (File.Dep);\n-\n-      begin\n-         Read_File (Name, Ali);\n-\n-      exception\n-         when Ada.Text_IO.Name_Error | Ada.Text_IO.End_Error =>\n-            raise No_Xref_Information;\n-      end;\n-\n-      Skip_To_First_X_Line (File, D_Lines => True, W_Lines => Dependencies);\n-   end Open;\n-\n-   ---------------\n-   -- Parse_EOL --\n-   ---------------\n-\n-   procedure Parse_EOL\n-     (Source                 : not null access String;\n-      Ptr                    : in out Positive;\n-      Skip_Continuation_Line : Boolean := False)\n-   is\n-   begin\n-      loop\n-         pragma Assert (Source (Ptr) /= EOF);\n-\n-         --  Skip to end of line\n-\n-         while Source (Ptr) /= ASCII.CR and then Source (Ptr) /= ASCII.LF\n-           and then Source (Ptr) /= EOF\n-         loop\n-            Ptr := Ptr + 1;\n-         end loop;\n-\n-         --  Skip CR or LF if not at end of file\n-\n-         if Source (Ptr) /= EOF then\n-            Ptr := Ptr + 1;\n-         end if;\n-\n-         --  Skip past CR/LF\n-\n-         if Source (Ptr - 1) = ASCII.CR and then Source (Ptr) = ASCII.LF then\n-            Ptr := Ptr + 1;\n-         end if;\n-\n-         exit when not Skip_Continuation_Line or else Source (Ptr) /= '.';\n-      end loop;\n-   end Parse_EOL;\n-\n-   ---------------------------\n-   -- Parse_Identifier_Info --\n-   ---------------------------\n-\n-   procedure Parse_Identifier_Info\n-     (Pattern       : Search_Pattern;\n-      File          : in out ALI_File;\n-      Local_Symbols : Boolean;\n-      Der_Info      : Boolean := False;\n-      Type_Tree     : Boolean := False;\n-      Wide_Search   : Boolean := True;\n-      Labels_As_Ref : Boolean := True)\n-   is\n-      Ptr      : Positive renames File.Current_Line;\n-      Ali      : String_Access renames File.Buffer;\n-\n-      E_Line   : Natural;   --  Line number of current entity\n-      E_Col    : Natural;   --  Column number of current entity\n-      E_Name   : Positive;  --  Pointer to begin of entity name\n-      E_Global : Boolean;   --  True iff entity is global\n-      E_Type   : Character; --  Type of current entity\n-\n-      R_Line   : Natural;   --  Line number of current reference\n-      R_Col    : Natural;   --  Column number of current reference\n-\n-      R_Type   : Character := ASCII.NUL; --  Type of current reference\n-\n-      Decl_Ref : Declaration_Reference;\n-      File_Ref : File_Reference := Current_Xref_File (File);\n-\n-      function Get_Symbol_Name (Eun, Line, Col : Natural) return String;\n-      --  Returns the symbol name for the entity defined at the specified\n-      --  line and column in the dependent unit number Eun. For this we need\n-      --  to parse the ali file again because the parent entity is not in\n-      --  the declaration table if it did not match the search pattern.\n-      --  If the symbol is not found, we return (1 .. 3 => '?').\n-\n-      procedure Skip_To_Matching_Closing_Bracket;\n-      --  When Ptr points to an opening square bracket, moves it to the\n-      --  character following the matching closing bracket\n-\n-      ---------------------\n-      -- Get_Symbol_Name --\n-      ---------------------\n-\n-      function Get_Symbol_Name (Eun, Line, Col : Natural) return String is\n-         Ptr    : Positive := 1;\n-         E_Eun  : Positive;   --  Unit number of current entity\n-         E_Line : Natural;    --  Line number of current entity\n-         E_Col  : Natural;    --  Column number of current entity\n-         E_Name : Positive;   --  Pointer to begin of entity name\n-\n-      begin\n-         --  Look for the X lines corresponding to unit Eun\n-\n-         loop\n-            if Ali (Ptr) = EOF then\n-               return \"???\";\n-            end if;\n-\n-            if Ali (Ptr) = 'X' then\n-               Ptr := Ptr + 1;\n-               Parse_Number (Ali, Ptr, E_Eun);\n-               exit when E_Eun = Eun;\n-            end if;\n-\n-            Parse_EOL (Ali, Ptr, Skip_Continuation_Line => True);\n-         end loop;\n-\n-         --  Here we are in the right Ali section, we now look for the entity\n-         --  declared at position (Line, Col).\n-\n-         loop\n-            Parse_Number (Ali, Ptr, E_Line);\n-            exit when Ali (Ptr) = EOF;\n-            Ptr := Ptr + 1;\n-            Parse_Number (Ali, Ptr, E_Col);\n-            exit when Ali (Ptr) = EOF;\n-            Ptr := Ptr + 1;\n-\n-            if Line = E_Line and then Col = E_Col then\n-               Parse_Token (Ali, Ptr, E_Name);\n-               return Ali (E_Name .. Ptr - 1);\n-            end if;\n-\n-            Parse_EOL (Ali, Ptr, Skip_Continuation_Line => True);\n-            exit when Ali (Ptr) = EOF;\n-         end loop;\n-\n-         return \"???\";\n-      end Get_Symbol_Name;\n-\n-      --------------------------------------\n-      -- Skip_To_Matching_Closing_Bracket --\n-      --------------------------------------\n-\n-      procedure Skip_To_Matching_Closing_Bracket is\n-         Num_Brackets : Natural;\n-\n-      begin\n-         Num_Brackets := 1;\n-         while Num_Brackets /= 0 loop\n-            Ptr := Ptr + 1;\n-            if Ali (Ptr) = '[' then\n-               Num_Brackets := Num_Brackets + 1;\n-            elsif Ali (Ptr) = ']' then\n-               Num_Brackets := Num_Brackets - 1;\n-            end if;\n-         end loop;\n-\n-         Ptr := Ptr + 1;\n-      end Skip_To_Matching_Closing_Bracket;\n-\n-      Table : Table_Type renames File.Dep.Table (1 .. Last (File.Dep));\n-\n-   --  Start of processing for Parse_Identifier_Info\n-\n-   begin\n-      --  The identifier info looks like:\n-      --     \"38U9*Debug 12|36r6 36r19\"\n-\n-      --  Extract the line, column and entity name information\n-\n-      Parse_Number (Ali, Ptr, E_Line);\n-\n-      if Ali (Ptr) > ' ' then\n-         E_Type := Ali (Ptr);\n-         Ptr := Ptr + 1;\n-\n-         --  Ignore some of the entities (labels,...)\n-\n-         if E_Type in 'l' | 'L' | 'q' then\n-            Parse_EOL (Ali, Ptr, Skip_Continuation_Line => True);\n-            return;\n-         end if;\n-      else\n-         --  Unexpected contents, skip line and return\n-\n-         Parse_EOL (Ali, Ptr, Skip_Continuation_Line => True);\n-         return;\n-      end if;\n-\n-      Parse_Number (Ali, Ptr, E_Col);\n-\n-      E_Global := False;\n-      if Ali (Ptr) >= ' ' then\n-         E_Global := (Ali (Ptr) = '*');\n-         Ptr := Ptr + 1;\n-      end if;\n-\n-      Parse_Token (Ali, Ptr, E_Name);\n-\n-      --  Exit if the symbol does not match or if we have a local symbol and we\n-      --  do not want it or if the file is unknown.\n-\n-      if File.X_File = Empty_File then\n-         return;\n-      end if;\n-\n-      if (not Local_Symbols and not E_Global)\n-        or else (Pattern.Initialized\n-                  and then not Match (Ali (E_Name .. Ptr - 1), Pattern.Entity))\n-        or else (E_Name >= Ptr)\n-      then\n-         Decl_Ref := Add_Declaration\n-           (File.X_File, Ali (E_Name .. Ptr - 1), E_Line, E_Col, E_Type,\n-            Remove_Only => True);\n-         Parse_EOL (Ali, Ptr, Skip_Continuation_Line => True);\n-         return;\n-      end if;\n-\n-      --  Insert the declaration in the table\n-\n-      Decl_Ref := Add_Declaration\n-        (File.X_File, Ali (E_Name .. Ptr - 1), E_Line, E_Col, E_Type);\n-\n-      if Ali (Ptr) = '[' then\n-         Skip_To_Matching_Closing_Bracket;\n-      end if;\n-\n-      --  Skip any renaming indication\n-\n-      if Ali (Ptr) = '=' then\n-         declare\n-            P_Line, P_Column : Natural;\n-            pragma Warnings (Off, P_Line);\n-            pragma Warnings (Off, P_Column);\n-         begin\n-            Ptr := Ptr + 1;\n-            Parse_Number (Ali, Ptr, P_Line);\n-            Ptr := Ptr + 1;\n-            Parse_Number (Ali, Ptr, P_Column);\n-         end;\n-      end if;\n-\n-      while Ptr <= Ali'Last\n-         and then (Ali (Ptr) = '<'\n-                   or else Ali (Ptr) = '('\n-                   or else Ali (Ptr) = '{')\n-      loop\n-         --  Here we have a type derivation information. The format is\n-         --  <3|12I45> which means that the current entity is derived from the\n-         --  type defined in unit number 3, line 12 column 45. The pipe and\n-         --  unit number is optional. It is specified only if the parent type\n-         --  is not defined in the current unit.\n-\n-         --  We also have the format for generic instantiations, as in\n-         --  7a5*Uid(3|5I8[4|2]) 2|4r74\n-\n-         --  We could also have something like\n-         --  16I9*I<integer>\n-         --  that indicates that I derives from the predefined type integer.\n-\n-         Ptr := Ptr + 1;\n-\n-         if Ali (Ptr) in '0' .. '9' then\n-            Parse_Derived_Info : declare\n-               P_Line   : Natural;          --  parent entity line\n-               P_Column : Natural;          --  parent entity column\n-               P_Eun    : Natural := 0;     --  parent entity file number\n-\n-            begin\n-               Parse_Number (Ali, Ptr, P_Line);\n-\n-               --  If we have a pipe then the first number was the unit number\n-\n-               if Ali (Ptr) = '|' then\n-                  P_Eun := P_Line;\n-                  Ptr := Ptr + 1;\n-\n-                  --  Now we have the line number\n-\n-                  Parse_Number (Ali, Ptr, P_Line);\n-\n-               else\n-                  --  We don't have a unit number specified, so we set P_Eun to\n-                  --  the current unit.\n-\n-                  for K in Table'Range loop\n-                     P_Eun := K;\n-                     exit when Table (K) = File_Ref;\n-                  end loop;\n-               end if;\n-\n-               --  Then parse the type and column number\n-\n-               Ptr := Ptr + 1;\n-               Parse_Number (Ali, Ptr, P_Column);\n-\n-               --  Skip the information for generics instantiations\n-\n-               if Ali (Ptr) = '[' then\n-                  Skip_To_Matching_Closing_Bracket;\n-               end if;\n-\n-               --  Skip '>', or ')' or '>'\n-\n-               Ptr := Ptr + 1;\n-\n-               --  The derived info is needed only is the derived info mode is\n-               --  on or if we want to output the type hierarchy\n-\n-               if Der_Info or else Type_Tree then\n-                  pragma Assert (P_Eun /= 0);\n-\n-                  declare\n-                     Symbol : constant String :=\n-                                Get_Symbol_Name (P_Eun, P_Line, P_Column);\n-                  begin\n-                     if Symbol /= \"???\" then\n-                        Add_Parent\n-                          (Decl_Ref,\n-                           Symbol,\n-                           P_Line,\n-                           P_Column,\n-                           Table (P_Eun));\n-                     end if;\n-                  end;\n-               end if;\n-\n-               if Type_Tree\n-                 and then (Pattern.File_Ref = Empty_File\n-                             or else\n-                           Pattern.File_Ref = Current_Xref_File (File))\n-               then\n-                  Search_Parent_Tree : declare\n-                     Pattern         : Search_Pattern;  --  Parent type pattern\n-                     File_Pos_Backup : Positive;\n-\n-                  begin\n-                     Add_Entity\n-                       (Pattern,\n-                        Get_Symbol_Name (P_Eun, P_Line, P_Column)\n-                        & ':' & Get_Gnatchop_File (Table (P_Eun))\n-                        & ':' & Get_Line (Get_Parent (Decl_Ref))\n-                        & ':' & Get_Column (Get_Parent (Decl_Ref)),\n-                        False);\n-\n-                     --  No default match is needed to look for the parent type\n-                     --  since we are using the fully qualified symbol name:\n-                     --  symbol:file:line:column\n-\n-                     Set_Default_Match (False);\n-\n-                     --  The parent hierarchy is defined in the same unit as\n-                     --  the derived type. So we want to revisit the unit.\n-\n-                     File_Pos_Backup   := File.Current_Line;\n-\n-                     Skip_To_First_X_Line\n-                       (File, D_Lines => False, W_Lines => False);\n-\n-                     while File.Buffer (File.Current_Line) /= EOF loop\n-                        Parse_X_Filename (File);\n-                        Parse_Identifier_Info\n-                          (Pattern       => Pattern,\n-                           File          => File,\n-                           Local_Symbols => False,\n-                           Der_Info      => Der_Info,\n-                           Type_Tree     => True,\n-                           Wide_Search   => False,\n-                           Labels_As_Ref => Labels_As_Ref);\n-                     end loop;\n-\n-                     File.Current_Line := File_Pos_Backup;\n-                  end Search_Parent_Tree;\n-               end if;\n-            end Parse_Derived_Info;\n-\n-         else\n-            while Ali (Ptr) /= '>'\n-              and then Ali (Ptr) /= ')'\n-              and then Ali (Ptr) /= '}'\n-            loop\n-               Ptr := Ptr + 1;\n-            end loop;\n-            Ptr := Ptr + 1;\n-         end if;\n-      end loop;\n-\n-      --  To find the body, we will have to parse the file too\n-\n-      if Wide_Search then\n-         declare\n-            File_Name : constant String := Get_Gnatchop_File (File.X_File);\n-            Ignored : File_Reference;\n-         begin\n-            Ignored := Add_To_Xref_File (ALI_File_Name (File_Name), False);\n-         end;\n-      end if;\n-\n-      --  Parse references to this entity.\n-      --  Ptr points to next reference with leading blanks\n-\n-      loop\n-         --  Process references on current line\n-\n-         while Ali (Ptr) = ' ' or else Ali (Ptr) = ASCII.HT loop\n-\n-            --  For every reference read the line, type and column,\n-            --  optionally preceded by a file number and a pipe symbol.\n-\n-            Parse_Number (Ali, Ptr, R_Line);\n-\n-            if Ali (Ptr) = Pipe then\n-               Ptr := Ptr + 1;\n-               File_Ref := File_Name (File, R_Line);\n-\n-               Parse_Number (Ali, Ptr, R_Line);\n-            end if;\n-\n-            if Ali (Ptr) > ' ' then\n-               R_Type := Ali (Ptr);\n-               Ptr := Ptr + 1;\n-            end if;\n-\n-            --  Imported entities may have an indication specifying information\n-            --  about the corresponding external name:\n-            --    5U14*Foo2 5>20 6b<c,myfoo2>22   # Imported entity\n-            --    5U14*Foo2 5>20 6i<c,myfoo2>22   # Exported entity\n-\n-            if Ali (Ptr) = '<'\n-              and then (R_Type = 'b' or else R_Type = 'i')\n-            then\n-               while Ptr <= Ali'Last\n-                 and then Ali (Ptr) /= '>'\n-               loop\n-                  Ptr := Ptr + 1;\n-               end loop;\n-               Ptr := Ptr + 1;\n-            end if;\n-\n-            Parse_Number (Ali, Ptr, R_Col);\n-\n-            pragma Assert (R_Type /= ASCII.NUL);\n-\n-            --  Insert the reference or body in the table\n-\n-            Add_Reference\n-              (Decl_Ref, File_Ref, R_Line, R_Col, R_Type, Labels_As_Ref);\n-\n-            --  Skip generic information, if any\n-\n-            if Ali (Ptr) = '[' then\n-               declare\n-                  Num_Nested : Integer := 1;\n-\n-               begin\n-                  Ptr := Ptr + 1;\n-                  while Num_Nested /= 0 loop\n-                     if Ali (Ptr) = ']' then\n-                        Num_Nested := Num_Nested - 1;\n-                     elsif Ali (Ptr) = '[' then\n-                        Num_Nested := Num_Nested + 1;\n-                     end if;\n-\n-                     Ptr := Ptr + 1;\n-                  end loop;\n-               end;\n-            end if;\n-\n-         end loop;\n-\n-         Parse_EOL (Ali, Ptr);\n-\n-         --   Loop until new line is no continuation line\n-\n-         exit when Ali (Ptr) /= '.';\n-         Ptr := Ptr + 1;\n-      end loop;\n-   end Parse_Identifier_Info;\n-\n-   ------------------\n-   -- Parse_Number --\n-   ------------------\n-\n-   procedure Parse_Number\n-     (Source : not null access String;\n-      Ptr    : in out Positive;\n-      Number : out Natural)\n-   is\n-   begin\n-      --  Skip separators\n-\n-      while Source (Ptr) = ' ' or else Source (Ptr) = ASCII.HT loop\n-         Ptr := Ptr + 1;\n-      end loop;\n-\n-      Number := 0;\n-      while Source (Ptr) in '0' .. '9' loop\n-         Number :=\n-           10 * Number + (Character'Pos (Source (Ptr)) - Character'Pos ('0'));\n-         Ptr := Ptr + 1;\n-      end loop;\n-   end Parse_Number;\n-\n-   -----------------\n-   -- Parse_Token --\n-   -----------------\n-\n-   procedure Parse_Token\n-     (Source    : not null access String;\n-      Ptr       : in out Positive;\n-      Token_Ptr : out Positive)\n-   is\n-      In_Quotes : Character := ASCII.NUL;\n-\n-   begin\n-      --  Skip separators\n-\n-      while Source (Ptr) = ' ' or else Source (Ptr) = ASCII.HT loop\n-         Ptr := Ptr + 1;\n-      end loop;\n-\n-      Token_Ptr := Ptr;\n-\n-      --  Find end-of-token\n-\n-      while (In_Quotes /= ASCII.NUL or else\n-               not (Source (Ptr) = ' '\n-                     or else Source (Ptr) = ASCII.HT\n-                     or else Source (Ptr) = '<'\n-                     or else Source (Ptr) = '{'\n-                     or else Source (Ptr) = '['\n-                     or else Source (Ptr) = '='\n-                     or else Source (Ptr) = '('))\n-        and then Source (Ptr) >= ' '\n-      loop\n-         --  Double-quotes are used for operators\n-         --  Simple-quotes are used for character constants, for instance when\n-         --  they are found in an enumeration type \"type A is ('+', '-');\"\n-\n-         case Source (Ptr) is\n-            when '\"' | ''' =>\n-               if In_Quotes = Source (Ptr) then\n-                  In_Quotes := ASCII.NUL;\n-               elsif In_Quotes = ASCII.NUL then\n-                  In_Quotes := Source (Ptr);\n-               end if;\n-\n-            when others =>\n-               null;\n-         end case;\n-\n-         Ptr := Ptr + 1;\n-      end loop;\n-   end Parse_Token;\n-\n-   ----------------------\n-   -- Parse_X_Filename --\n-   ----------------------\n-\n-   procedure Parse_X_Filename (File : in out ALI_File) is\n-      Ali     : String_Access renames File.Buffer;\n-      Ptr     : Positive renames File.Current_Line;\n-      File_Nr : Natural;\n-\n-      Table : Table_Type renames File.Dep.Table (1 .. Last (File.Dep));\n-\n-   begin\n-      while Ali (Ptr) = 'X' loop\n-\n-         --  The current line is the start of a new Xref file section,\n-         --  whose format looks like:\n-\n-         --     \" X 1 debug.ads\"\n-\n-         --  Skip the X and read the file number for the new X_File\n-\n-         Ptr := Ptr + 1;\n-         Parse_Number (Ali, Ptr, File_Nr);\n-\n-         --  If the referenced file is unknown, we simply ignore it\n-\n-         if File_Nr in Table'Range then\n-            File.X_File := Table (File_Nr);\n-         else\n-            File.X_File := Empty_File;\n-         end if;\n-\n-         Parse_EOL (Ali, Ptr);\n-      end loop;\n-   end Parse_X_Filename;\n-\n-   --------------------\n-   -- Print_Gnatfind --\n-   --------------------\n-\n-   procedure Print_Gnatfind\n-     (References     : Boolean;\n-      Full_Path_Name : Boolean)\n-   is\n-      Decls : constant Declaration_Array_Access := Get_Declarations;\n-      Decl  : Declaration_Reference;\n-      Arr   : Reference_Array_Access;\n-\n-      procedure Print_Ref\n-        (Ref : Reference;\n-         Msg : String := \"      \");\n-      --  Print a reference, according to the extended tag of the output\n-\n-      ---------------\n-      -- Print_Ref --\n-      ---------------\n-\n-      procedure Print_Ref\n-        (Ref : Reference;\n-         Msg : String := \"      \")\n-      is\n-         F : String_Access :=\n-               Osint.To_Host_File_Spec\n-                (Get_Gnatchop_File (Ref, Full_Path_Name));\n-\n-         Buffer : constant String :=\n-                    F.all &\n-                    \":\" & Get_Line (Ref)   &\n-                    \":\" & Get_Column (Ref) &\n-                    \": \";\n-\n-         Num_Blanks : Integer := Longest_File_Name + 10 - Buffer'Length;\n-\n-      begin\n-         Free (F);\n-         Num_Blanks := Integer'Max (0, Num_Blanks);\n-         Write_Line\n-           (Buffer\n-            & String'(1 .. Num_Blanks => ' ')\n-            & Msg & \" \" & Get_Symbol (Decl));\n-\n-         if Get_Source_Line (Ref)'Length /= 0 then\n-            Write_Line (\"   \" & Get_Source_Line (Ref));\n-         end if;\n-      end Print_Ref;\n-\n-   --  Start of processing for Print_Gnatfind\n-\n-   begin\n-      for D in Decls'Range loop\n-         Decl := Decls (D);\n-\n-         if Match (Decl) then\n-\n-            --  Output the declaration\n-\n-            declare\n-               Parent : constant Declaration_Reference := Get_Parent (Decl);\n-\n-               F : String_Access :=\n-                     Osint.To_Host_File_Spec\n-                      (Get_Gnatchop_File (Decl, Full_Path_Name));\n-\n-               Buffer : constant String :=\n-                          F.all &\n-                          \":\" & Get_Line (Decl)   &\n-                          \":\" & Get_Column (Decl) &\n-                          \": \";\n-\n-               Num_Blanks : Integer := Longest_File_Name + 10 - Buffer'Length;\n-\n-            begin\n-               Free (F);\n-               Num_Blanks := Integer'Max (0, Num_Blanks);\n-               Write_Line\n-                 (Buffer & String'(1 .. Num_Blanks => ' ')\n-                  & \"(spec) \" & Get_Symbol (Decl));\n-\n-               if Parent /= Empty_Declaration then\n-                  F := Osint.To_Host_File_Spec (Get_Gnatchop_File (Parent));\n-                  Write_Line\n-                    (Buffer & String'(1 .. Num_Blanks => ' ')\n-                     & \"   derived from \" & Get_Symbol (Parent)\n-                     & \" (\"\n-                     & F.all\n-                     & ':' & Get_Line (Parent)\n-                     & ':' & Get_Column (Parent) & ')');\n-                  Free (F);\n-               end if;\n-            end;\n-\n-            if Get_Source_Line (Decl)'Length /= 0 then\n-               Write_Line (\"   \" & Get_Source_Line (Decl));\n-            end if;\n-\n-            --  Output the body (sorted)\n-\n-            Arr := Get_References (Decl, Get_Bodies => True);\n-\n-            for R in Arr'Range loop\n-               Print_Ref (Arr (R), \"(body)\");\n-            end loop;\n-\n-            Free (Arr);\n-\n-            if References then\n-               Arr := Get_References\n-                 (Decl, Get_Writes => True, Get_Reads => True);\n-\n-               for R in Arr'Range loop\n-                  Print_Ref (Arr (R));\n-               end loop;\n-\n-               Free (Arr);\n-            end if;\n-         end if;\n-      end loop;\n-   end Print_Gnatfind;\n-\n-   ------------------\n-   -- Print_Unused --\n-   ------------------\n-\n-   procedure Print_Unused (Full_Path_Name : Boolean) is\n-      Decls : constant Declaration_Array_Access := Get_Declarations;\n-      Decl  : Declaration_Reference;\n-      Arr   : Reference_Array_Access;\n-      F     : String_Access;\n-\n-   begin\n-      for D in Decls'Range loop\n-         Decl := Decls (D);\n-\n-         if References_Count\n-             (Decl, Get_Reads => True, Get_Writes => True) = 0\n-         then\n-            F := Osint.To_Host_File_Spec\n-              (Get_Gnatchop_File (Decl, Full_Path_Name));\n-            Write_Str (Get_Symbol (Decl)\n-                        & \" (\"\n-                        & Get_Full_Type (Decl)\n-                        & \") \"\n-                        & F.all\n-                        & ':'\n-                        & Get_Line (Decl)\n-                        & ':'\n-                        & Get_Column (Decl));\n-            Free (F);\n-\n-            --  Print the body if any\n-\n-            Arr := Get_References (Decl, Get_Bodies => True);\n-\n-            for R in Arr'Range loop\n-               F := Osint.To_Host_File_Spec\n-                      (Get_Gnatchop_File (Arr (R), Full_Path_Name));\n-               Write_Str (' '\n-                           & F.all\n-                           & ':' & Get_Line (Arr (R))\n-                           & ':' & Get_Column (Arr (R)));\n-               Free (F);\n-            end loop;\n-\n-            Write_Eol;\n-            Free (Arr);\n-         end if;\n-      end loop;\n-   end Print_Unused;\n-\n-   --------------\n-   -- Print_Vi --\n-   --------------\n-\n-   procedure Print_Vi (Full_Path_Name : Boolean) is\n-      Tab   : constant Character := ASCII.HT;\n-      Decls : constant Declaration_Array_Access :=\n-                Get_Declarations (Sorted => False);\n-      Decl  : Declaration_Reference;\n-      Arr   : Reference_Array_Access;\n-      F     : String_Access;\n-\n-   begin\n-      for D in Decls'Range loop\n-         Decl := Decls (D);\n-\n-         F := Osint.To_Host_File_Spec (Get_File (Decl, Full_Path_Name));\n-         Write_Line (Get_Symbol (Decl) & Tab & F.all & Tab & Get_Line (Decl));\n-         Free (F);\n-\n-         --  Print the body if any\n-\n-         Arr := Get_References (Decl, Get_Bodies => True);\n-\n-         for R in Arr'Range loop\n-            F := Osint.To_Host_File_Spec (Get_File (Arr (R), Full_Path_Name));\n-            Write_Line\n-              (Get_Symbol (Decl) & Tab & F.all & Tab  & Get_Line (Arr (R)));\n-            Free (F);\n-         end loop;\n-\n-         Free (Arr);\n-\n-         --  Print the modifications\n-\n-         Arr := Get_References (Decl, Get_Writes => True, Get_Reads => True);\n-\n-         for R in Arr'Range loop\n-            F := Osint.To_Host_File_Spec (Get_File (Arr (R), Full_Path_Name));\n-            Write_Line\n-              (Get_Symbol (Decl) & Tab & F.all & Tab & Get_Line (Arr (R)));\n-            Free (F);\n-         end loop;\n-\n-         Free (Arr);\n-      end loop;\n-   end Print_Vi;\n-\n-   ----------------\n-   -- Print_Xref --\n-   ----------------\n-\n-   procedure Print_Xref (Full_Path_Name : Boolean) is\n-      Decls : constant Declaration_Array_Access := Get_Declarations;\n-      Decl : Declaration_Reference;\n-\n-      Margin : constant := 10;\n-      --  Column where file names start\n-\n-      procedure New_Line80;\n-      --  Go to start of new line\n-\n-      procedure Print80 (S : String);\n-      --  Print the text, respecting the 80 columns rule\n-\n-      procedure Print_Ref (Line, Column : String);\n-      --  The beginning of the output is aligned on a column multiple of 9\n-\n-      procedure Print_List\n-        (Decl       : Declaration_Reference;\n-         Msg        : String;\n-         Get_Reads  : Boolean := False;\n-         Get_Writes : Boolean := False;\n-         Get_Bodies : Boolean := False);\n-      --  Print a list of references. If the list is not empty, Msg will\n-      --  be printed prior to the list.\n-\n-      ----------------\n-      -- New_Line80 --\n-      ----------------\n-\n-      procedure New_Line80 is\n-      begin\n-         Write_Eol;\n-         Write_Str (String'(1 .. Margin - 1 => ' '));\n-      end New_Line80;\n-\n-      -------------\n-      -- Print80 --\n-      -------------\n-\n-      procedure Print80 (S : String) is\n-         Align : Natural := Margin - (Integer (Column) mod Margin);\n-\n-      begin\n-         if Align = Margin then\n-            Align := 0;\n-         end if;\n-\n-         Write_Str (String'(1 .. Align => ' ') & S);\n-      end Print80;\n-\n-      ---------------\n-      -- Print_Ref --\n-      ---------------\n-\n-      procedure Print_Ref (Line, Column : String) is\n-         Line_Align : constant Integer := 4 - Line'Length;\n-\n-         S : constant String := String'(1 .. Line_Align => ' ')\n-                                  & Line & ':' & Column;\n-\n-         Align : Natural := Margin - (Integer (Output.Column) mod Margin);\n-\n-      begin\n-         if Align = Margin then\n-            Align := 0;\n-         end if;\n-\n-         if Integer (Output.Column) + Align + S'Length > 79 then\n-            New_Line80;\n-            Align := 0;\n-         end if;\n-\n-         Write_Str (String'(1 .. Align => ' ') & S);\n-      end Print_Ref;\n-\n-      ----------------\n-      -- Print_List --\n-      ----------------\n-\n-      procedure Print_List\n-        (Decl       : Declaration_Reference;\n-         Msg        : String;\n-         Get_Reads  : Boolean := False;\n-         Get_Writes : Boolean := False;\n-         Get_Bodies : Boolean := False)\n-      is\n-         Arr : Reference_Array_Access :=\n-                 Get_References\n-                   (Decl,\n-                    Get_Writes => Get_Writes,\n-                    Get_Reads  => Get_Reads,\n-                    Get_Bodies => Get_Bodies);\n-         File : File_Reference := Empty_File;\n-         F    : String_Access;\n-\n-      begin\n-         if Arr'Length /= 0 then\n-            Write_Eol;\n-            Write_Str (Msg);\n-         end if;\n-\n-         for R in Arr'Range loop\n-            if Get_File_Ref (Arr (R)) /= File then\n-               if File /= Empty_File then\n-                  New_Line80;\n-               end if;\n-\n-               File := Get_File_Ref (Arr (R));\n-               F := Osint.To_Host_File_Spec\n-                 (Get_Gnatchop_File (Arr (R), Full_Path_Name));\n-\n-               if F = null then\n-                  Write_Str (\"<unknown> \");\n-               else\n-                  Write_Str (F.all & ' ');\n-                  Free (F);\n-               end if;\n-            end if;\n-\n-            Print_Ref (Get_Line (Arr (R)), Get_Column (Arr (R)));\n-         end loop;\n-\n-         Free (Arr);\n-      end Print_List;\n-\n-      F : String_Access;\n-\n-   --  Start of processing for Print_Xref\n-\n-   begin\n-      for D in Decls'Range loop\n-         Decl := Decls (D);\n-\n-         Write_Str (Get_Symbol (Decl));\n-\n-         --  Put the declaration type in column Type_Position, but if the\n-         --  declaration name is too long, put at least one space between its\n-         --  name and its type.\n-\n-         while Column < Type_Position - 1 loop\n-            Write_Char (' ');\n-         end loop;\n-\n-         Write_Char (' ');\n-\n-         Write_Line (Get_Full_Type (Decl));\n-\n-         Write_Parent_Info : declare\n-            Parent : constant Declaration_Reference := Get_Parent (Decl);\n-\n-         begin\n-            if Parent /= Empty_Declaration then\n-               Write_Str (\"  Ptype: \");\n-               F := Osint.To_Host_File_Spec (Get_Gnatchop_File (Parent));\n-               Print80 (F.all);\n-               Free (F);\n-               Print_Ref (Get_Line (Parent), Get_Column (Parent));\n-               Print80 (\"  \" & Get_Symbol (Parent));\n-               Write_Eol;\n-            end if;\n-         end Write_Parent_Info;\n-\n-         Write_Str (\"  Decl:  \");\n-         F := Osint.To_Host_File_Spec\n-               (Get_Gnatchop_File (Decl, Full_Path_Name));\n-\n-         if F = null then\n-            Print80 (\"<unknown> \");\n-         else\n-            Print80 (F.all & ' ');\n-            Free (F);\n-         end if;\n-\n-         Print_Ref (Get_Line (Decl), Get_Column (Decl));\n-\n-         Print_List\n-           (Decl, \"  Body:  \", Get_Bodies => True);\n-         Print_List\n-           (Decl, \"  Modi:  \", Get_Writes => True);\n-         Print_List\n-           (Decl, \"  Ref:   \", Get_Reads => True);\n-         Write_Eol;\n-      end loop;\n-   end Print_Xref;\n-\n-   ------------\n-   -- Search --\n-   ------------\n-\n-   procedure Search\n-     (Pattern       : Search_Pattern;\n-      Local_Symbols : Boolean;\n-      Wide_Search   : Boolean;\n-      Read_Only     : Boolean;\n-      Der_Info      : Boolean;\n-      Type_Tree     : Boolean)\n-   is\n-      type String_Access is access String;\n-      procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);\n-\n-      ALIfile   : ALI_File;\n-      File_Ref  : File_Reference;\n-      Strip_Num : Natural := 0;\n-      Ali_Name  : String_Access;\n-\n-   begin\n-      --  If we want all the .ali files, then find them\n-\n-      if Wide_Search then\n-         Find_ALI_Files;\n-      end if;\n-\n-      loop\n-         --  Get the next unread ali file\n-\n-         File_Ref := Next_Unvisited_File;\n-\n-         exit when File_Ref = Empty_File;\n-\n-         --  Find the ALI file to use. Most of the time, it will be the unit\n-         --  name, with a different extension. However, when dealing with\n-         --  separates the ALI file is in fact the parent's ALI file (and this\n-         --  is recursive, in case the parent itself is a separate).\n-\n-         Strip_Num := 0;\n-         loop\n-            Free (Ali_Name);\n-            Ali_Name := new String'\n-              (Get_File (File_Ref, With_Dir => True, Strip => Strip_Num));\n-\n-            --  Stripped too many things...\n-\n-            if Ali_Name.all = \"\" then\n-               if Get_Emit_Warning (File_Ref) then\n-                  Set_Standard_Error;\n-                  Write_Line\n-                    (\"warning : file \" & Get_File (File_Ref, With_Dir => True)\n-                     & \" not found\");\n-                  Set_Standard_Output;\n-               end if;\n-               Free (Ali_Name);\n-               exit;\n-\n-            --  If not found, try the parent's ALI file (this is needed for\n-            --  separate units and subprograms).\n-\n-            --  Reset the cached directory first, in case the separate's\n-            --  ALI file is not in the same directory.\n-\n-            elsif not File_Exists (Ali_Name.all) then\n-               Strip_Num := Strip_Num + 1;\n-               Reset_Directory (File_Ref);\n-\n-            --  Else we finally found it\n-\n-            else\n-               exit;\n-            end if;\n-         end loop;\n-\n-         --  If we had to get the parent's ALI, insert it in the list as usual.\n-         --  This is to avoid parsing it twice in case it has already been\n-         --  parsed.\n-\n-         if Ali_Name /= null and then Strip_Num /= 0 then\n-            File_Ref := Add_To_Xref_File\n-              (File_Name => Ali_Name.all,\n-               Visited   => False);\n-\n-         --  Now that we have a file name, parse it to find any reference to\n-         --  the entity.\n-\n-         elsif Ali_Name /= null\n-           and then (Read_Only or else Is_Writable_File (Ali_Name.all))\n-         then\n-            begin\n-               Open (Ali_Name.all, ALIfile);\n-\n-               --  The cross-reference section in the ALI file may be followed\n-               --  by other sections, which can be identified by the starting\n-               --  character of every line, which should neither be 'X' nor a\n-               --  figure in '1' .. '9'.\n-\n-               --  The loop tests below also take into account the end-of-file\n-               --  possibility.\n-\n-               while ALIfile.Buffer (ALIfile.Current_Line) = 'X' loop\n-                  Parse_X_Filename (ALIfile);\n-\n-                  while ALIfile.Buffer (ALIfile.Current_Line) in '1' .. '9'\n-                  loop\n-                     Parse_Identifier_Info\n-                       (Pattern, ALIfile, Local_Symbols, Der_Info, Type_Tree,\n-                        Wide_Search, Labels_As_Ref => True);\n-                  end loop;\n-               end loop;\n-\n-            exception\n-               when No_Xref_Information   =>\n-                  if Get_Emit_Warning (File_Ref) then\n-                     Set_Standard_Error;\n-                     Write_Line\n-                       (\"warning : No cross-referencing information in  \"\n-                        & Ali_Name.all);\n-                     Set_Standard_Output;\n-                  end if;\n-            end;\n-         end if;\n-      end loop;\n-\n-      Free (Ali_Name);\n-   end Search;\n-\n-   -----------------\n-   -- Search_Xref --\n-   -----------------\n-\n-   procedure Search_Xref\n-     (Local_Symbols : Boolean;\n-      Read_Only     : Boolean;\n-      Der_Info      : Boolean)\n-   is\n-      ALIfile      : ALI_File;\n-      File_Ref     : File_Reference;\n-      Null_Pattern : Search_Pattern;\n-\n-   begin\n-      Null_Pattern.Initialized := False;\n-\n-      loop\n-         --  Find the next unvisited file\n-\n-         File_Ref := Next_Unvisited_File;\n-         exit when File_Ref = Empty_File;\n-\n-         --  Search the object directories for the .ali file\n-\n-         declare\n-            F : constant String := Get_File (File_Ref, With_Dir => True);\n-\n-         begin\n-            if Read_Only or else Is_Writable_File (F) then\n-               Open (F, ALIfile, True);\n-\n-               --  The cross-reference section in the ALI file may be followed\n-               --  by other sections, which can be identified by the starting\n-               --  character of every line, which should neither be 'X' nor a\n-               --  figure in '1' .. '9'.\n-\n-               --  The loop tests below also take into account the end-of-file\n-               --  possibility.\n-\n-               while ALIfile.Buffer (ALIfile.Current_Line) = 'X' loop\n-                  Parse_X_Filename (ALIfile);\n-\n-                  while ALIfile.Buffer (ALIfile.Current_Line) in '1' .. '9'\n-                  loop\n-                     Parse_Identifier_Info\n-                       (Null_Pattern, ALIfile, Local_Symbols, Der_Info,\n-                        Labels_As_Ref => False);\n-                  end loop;\n-               end loop;\n-            end if;\n-\n-         exception\n-            when No_Xref_Information => null;\n-         end;\n-      end loop;\n-   end Search_Xref;\n-\n-end Xref_Lib;"}, {"sha": "467e3a52417b1c0d3efb17f3e29abe7aad451319", "filename": "gcc/ada/xref_lib.ads", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxref_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92f4fddd68463e7bc21e6a71c89848410311351/gcc%2Fada%2Fxref_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.ads?ref=c92f4fddd68463e7bc21e6a71c89848410311351", "patch": "@@ -1,179 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              X R E F _ L I B                             --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1998-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Miscellaneous utilities for the cross-referencing tool\n-\n-with Hostparm;\n-with Xr_Tabls;  use Xr_Tabls;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.OS_Lib;               use GNAT.OS_Lib;\n-with GNAT.Dynamic_Tables;\n-with GNAT.Regexp;               use GNAT.Regexp;\n-\n-package Xref_Lib is\n-\n-   subtype File_Name_String is String (1 .. Hostparm.Max_Name_Length);\n-   subtype Line_String      is String (1 .. Hostparm.Max_Line_Length);\n-\n-   type ALI_File is limited private;\n-\n-   ---------------------\n-   -- Directory Input --\n-   ---------------------\n-\n-   type Rec_DIR is limited private;\n-   --  This one is used for recursive search of .ali files\n-\n-   procedure Find_ALI_Files;\n-   --  Find all the ali files that we will have to parse, and have them to\n-   --  the file list\n-\n-   ---------------------\n-   -- Search patterns --\n-   ---------------------\n-\n-   type Search_Pattern is private;\n-   type Search_Pattern_Ptr is access all Search_Pattern;\n-\n-   procedure Add_Entity\n-     (Pattern : in out Search_Pattern;\n-      Entity  : String;\n-      Glob    : Boolean := False);\n-   --  Add a new entity to the search pattern (the entity should have the\n-   --  form pattern[:file[:line[:column]]], and it is parsed entirely in\n-   --  this procedure. Glob indicates if we should use the 'globbing\n-   --  patterns' (True) or the full regular expressions (False)\n-\n-   procedure Add_Xref_File (File : String);\n-   --  Add a new file in the list of files to search for references. File\n-   --  is interpreted as a globbing regular expression, which is expanded.\n-\n-   Invalid_Argument : exception;\n-   --  Exception raised when there is a syntax error in the command line\n-\n-   -----------------------\n-   -- Output Algorithms --\n-   -----------------------\n-\n-   procedure Print_Gnatfind\n-     (References     : Boolean;\n-      Full_Path_Name : Boolean);\n-   procedure Print_Unused (Full_Path_Name : Boolean);\n-   procedure Print_Vi     (Full_Path_Name : Boolean);\n-   procedure Print_Xref   (Full_Path_Name : Boolean);\n-   --  The actual print procedures. These functions step through the symbol\n-   --  table and print all the symbols if they match the files given on the\n-   --  command line (they already match the entities if they are in the\n-   --  symbol table)\n-\n-   ------------------------\n-   -- General Algorithms --\n-   ------------------------\n-\n-   function Default_Project_File (Dir_Name : String) return String;\n-   --  Returns the default Project file name for the directory Dir_Name\n-\n-   procedure Search\n-     (Pattern       : Search_Pattern;\n-      Local_Symbols : Boolean;\n-      Wide_Search   : Boolean;\n-      Read_Only     : Boolean;\n-      Der_Info      : Boolean;\n-      Type_Tree     : Boolean);\n-   --  Search every ALI file for entities matching Pattern, and add\n-   --  these entities to the internal symbol tables.\n-   --\n-   --  If Wide_Search is True, all ALI files found in the object path\n-   --  are searched.\n-   --\n-   --  If Read_Only is True, read-only ALI files will also be parsed,\n-   --  similar to gnatmake -a.\n-   --\n-   --  If Der_Info is true, then the derived type information will be\n-   --  processed.\n-   --\n-   --  If Type_Tree is true, then the type hierarchy will be searched\n-   --  going from the pattern to the parent type.\n-\n-   procedure Search_Xref\n-     (Local_Symbols : Boolean;\n-      Read_Only     : Boolean;\n-      Der_Info      : Boolean);\n-   --  Search every ali file given in the command line and all their\n-   --  dependencies. If Read_Only is True, we parse the read-only ali\n-   --  files too. If Der_Mode is true then the derived type information will\n-   --  be processed\n-\n-private\n-   type Rec_DIR is limited record\n-      Dir : GNAT.Directory_Operations.Dir_Type;\n-   end record;\n-\n-   package Dependencies_Tables is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Xr_Tabls.File_Reference,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 400,\n-      Table_Increment      => 100);\n-   use Dependencies_Tables;\n-\n-   type Dependencies is new Dependencies_Tables.Instance;\n-\n-   type ALI_File is limited record\n-      Buffer : String_Access := null;\n-      --  Buffer used to read the whole file at once\n-\n-      Current_Line : Positive;\n-      --  Start of the current line in Buffer\n-\n-      Xref_Line : Positive;\n-      --  Start of the xref lines in Buffer\n-\n-      X_File : Xr_Tabls.File_Reference;\n-      --  Stores the cross-referencing file-name (\"X...\" lines), as an\n-      --  index into the dependencies table\n-\n-      Dep : Dependencies;\n-      --  Store file name associated with each number (\"D...\" lines)\n-   end record;\n-\n-   --  The following record type stores all the patterns that are searched for\n-\n-   type Search_Pattern is record\n-      Entity : GNAT.Regexp.Regexp;\n-      --  A regular expression matching the entities we are looking for.\n-      --  File is a list of the places where the declaration of the entities\n-      --  has to be. When the user enters a file:line:column on the command\n-      --  line, it is stored as \"Entity_Name Declaration_File:line:column\"\n-\n-      File_Ref : Xr_Tabls.File_Reference;\n-      --  A reference to the source file, if any\n-\n-      Initialized : Boolean := False;\n-      --  Set to True when Entity has been initialized\n-   end record;\n-\n-end Xref_Lib;"}]}