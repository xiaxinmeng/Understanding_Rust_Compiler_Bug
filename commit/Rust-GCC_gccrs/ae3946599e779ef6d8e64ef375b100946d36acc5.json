{"sha": "ae3946599e779ef6d8e64ef375b100946d36acc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUzOTQ2NTk5ZTc3OWVmNmQ4ZTY0ZWYzNzViMTAwOTQ2ZDM2YWNjNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-31T09:02:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-31T09:02:25Z"}, "message": "re PR other/19696 (gcc.c-torture/execute/ieee/copysign1.c: Unsatisfied symbols: copysignl)\n\n        PR 19696\n        * optabs.c (expand_copysign_absneg): New.\n        (expand_copysign_bit): Split out from ...\n        (expand_copysign): ... here.  Use expand_copysign_absneg.\n\nFrom-SVN: r94471", "tree": {"sha": "446c61c7cd56c92feee2a375720bdd442021fe06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/446c61c7cd56c92feee2a375720bdd442021fe06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae3946599e779ef6d8e64ef375b100946d36acc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3946599e779ef6d8e64ef375b100946d36acc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae3946599e779ef6d8e64ef375b100946d36acc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3946599e779ef6d8e64ef375b100946d36acc5/comments", "author": null, "committer": null, "parents": [{"sha": "2b1e8a76efd4aa5d8a9aa111016fe26eca7e6308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1e8a76efd4aa5d8a9aa111016fe26eca7e6308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1e8a76efd4aa5d8a9aa111016fe26eca7e6308"}], "stats": {"total": 173, "additions": 143, "deletions": 30}, "files": [{"sha": "8138da594df11d6b2e4184a53f0370b1d608d37c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3946599e779ef6d8e64ef375b100946d36acc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3946599e779ef6d8e64ef375b100946d36acc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae3946599e779ef6d8e64ef375b100946d36acc5", "patch": "@@ -1,3 +1,10 @@\n+2005-01-31  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 19696\n+\t* optabs.c (expand_copysign_absneg): New.\n+\t(expand_copysign_bit): Split out from ...\n+\t(expand_copysign): ... here.  Use expand_copysign_absneg.\n+\n 2005-01-30  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/19697"}, {"sha": "dd3232b499cb6631e4558cc7f39a9747ca1785c3", "filename": "gcc/optabs.c", "status": "modified", "additions": 136, "deletions": 30, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae3946599e779ef6d8e64ef375b100946d36acc5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae3946599e779ef6d8e64ef375b100946d36acc5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ae3946599e779ef6d8e64ef375b100946d36acc5", "patch": "@@ -2657,44 +2657,99 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n   return target;\n }\n \n-/* Expand the C99 copysign operation.  OP0 and OP1 must be the same \n-   scalar floating point mode.  Return NULL if we do not know how to\n-   expand the operation inline.  */\n+/* A subroutine of expand_copysign, perform the copysign operation using the\n+   abs and neg primitives advertised to exist on the target.  The assumption\n+   is that we have a split register file, and leaving op0 in fp registers,\n+   and not playing with subregs so much, will help the register allocator.  */\n \n-rtx\n-expand_copysign (rtx op0, rtx op1, rtx target)\n+static rtx\n+expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n+\t\t        int bitpos, bool op0_is_abs)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n-  const struct real_format *fmt;\n   enum machine_mode imode;\n-  int bitpos, word, nwords, i, have_abs;\n   HOST_WIDE_INT hi, lo;\n-  rtx temp, insns;\n+  int word;\n+  rtx label;\n \n-  gcc_assert (SCALAR_FLOAT_MODE_P (mode));\n-  gcc_assert (GET_MODE (op1) == mode);\n+  if (target == op1)\n+    target = NULL_RTX;\n \n-  /* First try to do it with a special instruction.  */\n-  temp = expand_binop (mode, copysign_optab, op0, op1,\n-\t\t       target, 0, OPTAB_DIRECT);\n-  if (temp)\n-    return temp;\n-\n-  fmt = REAL_MODE_FORMAT (mode);\n-  if (fmt == NULL || !fmt->has_signed_zero)\n-    return NULL_RTX;\n+  if (!op0_is_abs)\n+    {\n+      op0 = expand_unop (mode, abs_optab, op0, target, 0);\n+      if (op0 == NULL)\n+\treturn NULL_RTX;\n+      target = op0;\n+    }\n+  else\n+    {\n+      if (target == NULL_RTX)\n+        target = copy_to_reg (op0);\n+      else\n+\temit_move_insn (target, op0);\n+    }\n \n-  bitpos = fmt->signbit;\n-  if (bitpos < 0)\n-    return NULL_RTX;\n+  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n+    {\n+      imode = int_mode_for_mode (mode);\n+      if (imode == BLKmode)\n+\treturn NULL_RTX;\n+      op1 = gen_lowpart (imode, op1);\n+    }\n+  else\n+    {\n+      imode = word_mode;\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tword = (GET_MODE_BITSIZE (mode) - bitpos) / BITS_PER_WORD;\n+      else\n+\tword = bitpos / BITS_PER_WORD;\n+      bitpos = bitpos % BITS_PER_WORD;\n+      op1 = operand_subword_force (op1, word, mode);\n+    }\n \n-  have_abs = false;\n-  if (GET_CODE (op0) == CONST_DOUBLE)\n+  if (bitpos < HOST_BITS_PER_WIDE_INT)\n     {\n-      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op0)))\n-\top0 = simplify_unary_operation (ABS, mode, op0, mode);\n-      have_abs = true;\n+      hi = 0;\n+      lo = (HOST_WIDE_INT) 1 << bitpos;\n     }\n+  else\n+    {\n+      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n+      lo = 0;\n+    }\n+\n+  op1 = expand_binop (imode, and_optab, op1,\n+\t\t      immed_double_const (lo, hi, imode),\n+\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+  label = gen_label_rtx ();\n+  emit_cmp_and_jump_insns (op1, const0_rtx, EQ, NULL_RTX, imode, 1, label);\n+\n+  if (GET_CODE (op0) == CONST_DOUBLE)\n+    op0 = simplify_unary_operation (NEG, mode, op0, mode);\n+  else\n+    op0 = expand_unop (mode, neg_optab, op0, target, 0);\n+  if (op0 != target)\n+    emit_move_insn (target, op0);\n+\n+  emit_label (label);\n+\n+  return target;\n+}\n+\n+\n+/* A subroutine of expand_copysign, perform the entire copysign operation\n+   with integer bitmasks.  BITPOS is the position of the sign bit; OP0_IS_ABS\n+   is true if op0 is known to have its sign bit clear.  */\n+\n+static rtx\n+expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n+\t\t     int bitpos, bool op0_is_abs)\n+{\n+  enum machine_mode imode;\n+  HOST_WIDE_INT hi, lo;\n+  int word, nwords, i;\n+  rtx temp, insns;\n \n   if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n     {\n@@ -2741,7 +2796,7 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n \t\n \t  if (i == word)\n \t    {\n-\t      if (!have_abs)\n+\t      if (!op0_is_abs)\n \t\top0_piece = expand_binop (imode, and_optab, op0_piece,\n \t\t\t\t\t  immed_double_const (~lo, ~hi, imode),\n \t\t\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -2772,7 +2827,7 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n \t\t          NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n       op0 = gen_lowpart (imode, op0);\n-      if (!have_abs)\n+      if (!op0_is_abs)\n \top0 = expand_binop (imode, and_optab, op0,\n \t\t\t    immed_double_const (~lo, ~hi, imode),\n \t\t\t    NULL_RTX, 1, OPTAB_LIB_WIDEN);\n@@ -2784,6 +2839,57 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n \n   return target;\n }\n+\n+/* Expand the C99 copysign operation.  OP0 and OP1 must be the same \n+   scalar floating point mode.  Return NULL if we do not know how to\n+   expand the operation inline.  */\n+\n+rtx\n+expand_copysign (rtx op0, rtx op1, rtx target)\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+  const struct real_format *fmt;\n+  int bitpos;\n+  bool op0_is_abs;\n+  rtx temp;\n+\n+  gcc_assert (SCALAR_FLOAT_MODE_P (mode));\n+  gcc_assert (GET_MODE (op1) == mode);\n+\n+  /* First try to do it with a special instruction.  */\n+  temp = expand_binop (mode, copysign_optab, op0, op1,\n+\t\t       target, 0, OPTAB_DIRECT);\n+  if (temp)\n+    return temp;\n+\n+  fmt = REAL_MODE_FORMAT (mode);\n+  if (fmt == NULL || !fmt->has_signed_zero)\n+    return NULL_RTX;\n+\n+  bitpos = fmt->signbit;\n+  if (bitpos < 0)\n+    return NULL_RTX;\n+\n+  op0_is_abs = false;\n+  if (GET_CODE (op0) == CONST_DOUBLE)\n+    {\n+      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op0)))\n+\top0 = simplify_unary_operation (ABS, mode, op0, mode);\n+      op0_is_abs = true;\n+    }\n+\n+  if (GET_CODE (op0) == CONST_DOUBLE\n+      || (neg_optab->handlers[mode].insn_code != CODE_FOR_nothing\n+          && abs_optab->handlers[mode].insn_code != CODE_FOR_nothing))\n+    {\n+      temp = expand_copysign_absneg (mode, op0, op1, target,\n+\t\t\t\t     bitpos, op0_is_abs);\n+      if (temp)\n+\treturn temp;\n+    }\n+\n+  return expand_copysign_bit (mode, op0, op1, target, bitpos, op0_is_abs);\n+}\n \f\n /* Generate an instruction whose insn-code is INSN_CODE,\n    with two operands: an output TARGET and an input OP0."}]}