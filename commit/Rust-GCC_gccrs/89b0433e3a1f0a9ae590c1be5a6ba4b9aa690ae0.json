{"sha": "89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODliMDQzM2UzYTFmMGE5YWU1OTBjMWJlNWE2YmE0YjlhYTY5MGFlMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-19T10:36:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-19T10:36:07Z"}, "message": "tree.h (TYPE_CACHED_VALUES_P): New.\n\n\t* tree.h (TYPE_CACHED_VALUES_P): New.\n\t(TYPE_CACHED_VALUES): New.\n\t(TYPE_ORIG_SIZE_TYPE): Adjust.\n\t* tree.def (INTEGER_CST): Update documentation.\n\t* tree.c: Inlcude params.h.\n\t(build_int_cst): Cache small values.\n\t(build_type_copy): Do not copy the value cache.\n\t* c-common.c (c_common_nodes_and_builtins): Add comment, remove\n\tunneeded zeroing.\n\t* c-typeck.c (build_c_cast): Add comment about OVERFLOW setting.\n\t* expmed.c (const_mult_add_overflow_p): Clear type copy's value\n\tcache.\n\t* fold-const.c (force_fit_type): Copy value when setting\n\toverflows.\n\t(int_const_binop): Likewise.\n\t* stor-layout.c: Include params.h\n\t(set_sizetype): Create values cache.\n\t(fixup_unsigned_type): Set UNSIGNED_P before caching any values.\n\t* params.def (PARAM_INTEGER_SHARE_LIMIT): New.\n\t* params.h (INTEGER_SHARE_LIMIT): New.\n\t* Makefile.in (tree.o, stor-layout.o): Depend on PARAMS_H.\n\n\t* cp/decl.c (finish_enum): Do not copy value node early, copy\n\tlater.\n\t* cp/lex.c (cxx_init): Force null_node to be unique.\n\n\t* java/parse.h (JAVA_RADIX10_FLAG): Rename to ...\n\t(JAVA_NOT_RADIX10_FLAG): ... here.  Invert meaning.\n\t* java/lex.c (do_java_lex): Adjust.\n\t(error_if_numeric_overflow): Likewise.\n\nFrom-SVN: r86247", "tree": {"sha": "ba738aa254abf741ddc0722884b43575c2331ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba738aa254abf741ddc0722884b43575c2331ca6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/comments", "author": null, "committer": null, "parents": [{"sha": "abc145a322be89c774fdcae8c883685d7943028a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc145a322be89c774fdcae8c883685d7943028a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc145a322be89c774fdcae8c883685d7943028a"}], "stats": {"total": 284, "additions": 226, "deletions": 58}, "files": [{"sha": "537d2a1c7540ae38234a90a80f53e13d4f1dde0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -1,3 +1,27 @@\n+2004-08-19  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (TYPE_CACHED_VALUES_P): New.\n+\t(TYPE_CACHED_VALUES): New.\n+\t(TYPE_ORIG_SIZE_TYPE): Adjust.\n+\t* tree.def (INTEGER_CST): Update documentation.\n+\t* tree.c: Inlcude params.h.\n+\t(build_int_cst): Cache small values.\n+\t(build_type_copy): Do not copy the value cache.\n+\t* c-common.c (c_common_nodes_and_builtins): Add comment, remove\n+\tunneeded zeroing.\n+\t* c-typeck.c (build_c_cast): Add comment about OVERFLOW setting.\n+\t* expmed.c (const_mult_add_overflow_p): Clear type copy's value\n+\tcache.\n+\t* fold-const.c (force_fit_type): Copy value when setting\n+\toverflows.\n+\t(int_const_binop): Likewise.\n+\t* stor-layout.c: Include params.h\n+\t(set_sizetype): Create values cache.\n+\t(fixup_unsigned_type): Set UNSIGNED_P before caching any values.\n+\t* params.def (PARAM_INTEGER_SHARE_LIMIT): New.\n+\t* params.h (INTEGER_SHARE_LIMIT): New.\n+\t* Makefile.in (tree.o, stor-layout.o): Depend on PARAMS_H.\n+\t\n 2004-08-19  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* gimplify.c (gimplify_minimax_expr): Remove.\n@@ -404,19 +428,20 @@\n \t* reg-stack.c (emit_swap_insn): Add condition to step over\n \tNOTE_INSN_UNLIKELY_EXECUTED_CODE notes.\n \t* toplev.c (user_defined_section_attribute): New global variable.\n-\t* toplev.h (user_defined_section_attribute): Extern declaration for new\n-\tglobal variable.\n+\t* toplev.h (user_defined_section_attribute): Extern declaration\n+\tfor new global variable.\n \t* varasm.c (unlikely_section_label): New global variable.\n \t(unlikely_text_section_name): New global variable.\n-\t(unlikely_text_section): Add code to initialize unlikely_text_section_name\n-\tif necessary; modify to use unlikely_text_section_name and\n-\tunlikely_section_label; also to use named_section properly.\n-\t(in_unlikely_text_section):  Modify to work correctly with named_section\n-\tand to use unlikely_text_section_name.\n+\t(unlikely_text_section): Add code to initialize\n+\tunlikely_text_section_name if necessary; modify to use\n+\tunlikely_text_section_name and unlikely_section_label; also to use\n+\tnamed_section properly.\n+\t(in_unlikely_text_section):  Modify to work correctly with\n+\tnamed_section and to use unlikely_text_section_name.\n \t(named_section):  Add code to work properly with cold section.\n \t(function_section): Clean up if-statement.\n-\t* config/darwin.c (darwin_asm_named_section): Return to original code,\n-\tremoving use of SECTION_FORMAT_STRING.\n+\t* config/darwin.c (darwin_asm_named_section): Return to original\n+\tcode, removing use of SECTION_FORMAT_STRING.\n \t* config/arm/pe.h (switch_to_section):  Add case for\n \tin_unlikely_executed_text to switch statement.\n \t* config/i386/cygming.h (switch_to_section): Likewise.\n@@ -677,30 +702,32 @@\n \n 2004-08-17  Dorit Naishlos  <dorit@il.ibm.com>\n \n-\t* tree-vectorizer.c: New File: loop vectorization on SSAed GIMPLE trees.\n+\t* tree-vectorizer.c: New File: loop vectorization on SSAed GIMPLE\n+\ttrees.\n \t* tree-vectorizer.h: New File: Same.\n \t* Makefile.in (tree-vectorizer.c, tree-vectorizer.h): Add new files.\n \t* common.opt (ftree-vectorize): New flag to enable vectorization.\n-\t* timevar.def (TV_TREE_VECTORIZATION): New dump file for vectorization\n-\tpass.\n+\t* timevar.def (TV_TREE_VECTORIZATION): New dump file for\n+\tvectorization pass.\n \t* tree-data-ref.h (init_data_ref): Additional argument.\n \t(array_base_name_differ_p): Moved to tree-data-ref.c.\n \t* tree-data-ref.c (array_base_name_differ_p): Revised.\n \t(initialize_data_dependence_relation): Call array_base_name_differ_p\n \twith an extra argument.\n \t(analyze_all_data_dependences): Same.\n \t(init_data_ref): Additional argument is_read to set DR_IS_READ.\n-\t* tree-ssa-phiopt.c (empty_block_p): Expose for usage out of this file.\n+\t* tree-ssa-phiopt.c (empty_block_p): Expose for usage out of this\n+\tfile.\n \t* tree-flow.h (vectorize_loops, empty_block_p): Add declaration.\n \t* tree-optimize.c (pass_vectorize): Schedule the vectorization pass.\n \t* tree-pass.h (tree_opt_pass pass_vectorize): Declare the new\n \tvectorization pass.\n \t* tree-ssa-loop.c (tree_ssa_loop_init): Call scev_initialize.\n \t(tree_ssa_loop_done): Call scev_finalize.\n \t(tree_vectorize): Define the new vectorization pass.\n-\t* defaults.h (UNITS_PER_SIMD_WORD): Allow targets to specify the size of\n-\tthe vector they support (until support for multiple vector sizes is\n-\tadded to the vectorizer).\n+\t* defaults.h (UNITS_PER_SIMD_WORD): Allow targets to specify the\n+\tsize of the vector they support (until support for multiple vector\n+\tsizes is added to the vectorizer).\n \t* config/i386/i386.h (UNITS_PER_SIMD_WORD): Define.\n \t* config/rs6000/rs6000.h (UNITS_PER_SIMD_WORD): Define.\n \t* invoke.texi (fdump-tree-vect, ftree-vectorize): Add\n@@ -2543,7 +2570,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "a71558bf3e4720844f6f5f83f8749b6d467a0495", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -1563,7 +1563,8 @@ convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(FLA\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) toplev.h \\\n    tree-inline.h $(RTL_H) insn-config.h $(INTEGRATE_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) diagnostic.h\n-tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(FLAGS_H) function.h \\\n+tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   $(FLAGS_H) function.h $(PARAMS_H) \\\n    toplev.h $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n    real.h gt-tree.h tree-iterator.h $(BASIC_BLOCK_H) $(TREE_FLOW_H)\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1576,8 +1577,9 @@ tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_GIMPLE_H)\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h real.h\n-stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(FLAGS_H) function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H) $(TM_P_H) $(TARGET_H) \\\n+stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) $(PARAMS_H) $(FLAGS_H) function.h $(EXPR_H) $(RTL_H) toplev.h \\\n+   $(GGC_H) $(TM_P_H) $(TARGET_H) \\\n    langhooks.h $(REGS_H)\n tree-alias-type.o: tree-alias-type.c tree-alias-type.h $(SYSTEM_H) $(CONFIG_H) \\\n    $(GGC_H) $(TM_H) coretypes.h $(VARRAY_H)"}, {"sha": "663e2c1f7f49a6fbdc88a836c918e99abb0783db", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -3001,9 +3001,8 @@ c_common_nodes_and_builtins (void)\n \n   record_builtin_type (RID_VOID, NULL, void_type_node);\n \n+  /* This node must not be shared. */\n   void_zero_node = make_node (INTEGER_CST);\n-  TREE_INT_CST_LOW (void_zero_node) = 0;\n-  TREE_INT_CST_HIGH (void_zero_node) = 0;\n   TREE_TYPE (void_zero_node) = void_type_node;\n \n   void_list_node = build_void_list_node ();"}, {"sha": "ad8acee710db1bcd8f26fc0e201e4a04fb4a6996", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -3109,11 +3109,15 @@ build_c_cast (tree type, tree expr)\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n \t  if (EXPR_P (ovalue))\n+\t    /* If OVALUE had overflow set, then so will VALUE, so it\n+\t       is safe to overwrite.  */\n \t    TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n \t  else\n \t    TREE_OVERFLOW (value) = 0;\n \t  \n \t  if (TREE_CODE_CLASS (TREE_CODE (ovalue)) == 'c')\n+\t    /* Similarly, constant_overflow cannot have become\n+\t       cleared.  */\n \t    TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n \t}\n     }"}, {"sha": "0cd1b21d32ec66a6815f34aaeef84c65f963acda", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -1,3 +1,9 @@\n+2004-08-19  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* decl.c (finish_enum): Do not copy value node early, copy\n+\tlater.\n+\t* lex.c (cxx_init): Force null_node to be unique.\n+\t\n 2004-08-19  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c++/17041"}, {"sha": "0c60f3c6d35f99d5b5b5ef84c2117bc0a77a9f64", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -9311,16 +9311,6 @@ finish_enum (tree enumtype)\n \t    maxnode = value;\n \t  else if (tree_int_cst_lt (value, minnode))\n \t    minnode = value;\n-\n-\t  /* Set the TREE_TYPE for the values as well.  That's so that when\n-\t     we call decl_constant_value we get an entity of the right type\n-\t     (but with the constant value).  But first make a copy so we\n-\t     don't clobber shared INTEGER_CSTs.  */\n-\t  if (TREE_TYPE (value) != enumtype)\n-\t    {\n-\t      value = DECL_INITIAL (decl) = copy_node (value);\n-\t      TREE_TYPE (value) = enumtype;\n-\t    }\n \t}\n     }\n   else\n@@ -9405,6 +9395,10 @@ finish_enum (tree enumtype)\n       decl = TREE_VALUE (values);\n       value = perform_implicit_conversion (underlying_type,\n \t\t\t\t\t   DECL_INITIAL (decl));\n+\n+      /* Do not clobber shared ints.  */\n+      value = copy_node (value);\n+      \n       TREE_TYPE (value) = enumtype;\n       DECL_INITIAL (decl) = value;\n       TREE_VALUE (values) = value;"}, {"sha": "fe220f2ae24a67a88971d17813a31f74df7afa3f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -354,8 +354,10 @@ cxx_init (void)\n \n   cxx_init_decl_processing ();\n \n-  /* Create the built-in __null node.  */\n-  null_node = build_int_cst (c_common_type_for_size (POINTER_SIZE, 0), 0, 0);\n+  /* Create the built-in __null node.  It is important that this is\n+     not shared. */\n+  null_node = make_node (INTEGER_CST);\n+  TREE_TYPE (null_node) = c_common_type_for_size (POINTER_SIZE, 0);\n   ridpointers[RID_NULL] = null_node;\n \n   interface_unknown = 1;"}, {"sha": "bb24504d27c8db5a8c3e809112380f5492f6b8b9", "filename": "gcc/expmed.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -4550,7 +4550,8 @@ make_tree (tree type, rtx x)\n    UNSIGNEDP is nonzero to do unsigned multiplication.  */\n \n bool\n-const_mult_add_overflow_p (rtx x, rtx mult, rtx add, enum machine_mode mode, int unsignedp)\n+const_mult_add_overflow_p (rtx x, rtx mult, rtx add,\n+\t\t\t   enum machine_mode mode, int unsignedp)\n {\n   tree type, mult_type, add_type, result;\n \n@@ -4561,7 +4562,15 @@ const_mult_add_overflow_p (rtx x, rtx mult, rtx add, enum machine_mode mode, int\n   mult_type = type;\n   if (unsignedp)\n     {\n+      /* FIXME:It would be nice if we could step directly from this\n+\t type to its sizetype equivalent.  */\n       mult_type = copy_node (type);\n+      if (TYPE_CACHED_VALUES_P (mult_type))\n+\t{\n+\t  /* Clear any set of cached values it has. */\n+\t  TYPE_CACHED_VALUES_P (mult_type) = 0;\n+\t  TYPE_CACHED_VALUES (mult_type) = NULL_TREE;\n+\t}\n       TYPE_IS_SIZETYPE (mult_type) = 1;\n     }\n "}, {"sha": "092712bad9541dca6fd92bc88228e9f023b5d773", "filename": "gcc/fold-const.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -268,18 +268,21 @@ force_fit_type (tree t, int overflowable,\n   if (overflowed || overflowed_const\n       || low != TREE_INT_CST_LOW (t) || high != TREE_INT_CST_HIGH (t))\n     {\n+      t = build_int_cst (TREE_TYPE (t), low, high);\n+      \n       if (overflowed\n \t  || overflowable < 0\n \t  || (overflowable > 0 && sign_extended_type))\n \t{\n+\t  t = copy_node (t);\n \t  TREE_OVERFLOW (t) = 1;\n \t  TREE_CONSTANT_OVERFLOW (t) = 1;\n \t}\n       else if (overflowed_const)\n-\tTREE_CONSTANT_OVERFLOW (t) = 1;\n-      \n-      TREE_INT_CST_LOW (t) = low;\n-      TREE_INT_CST_HIGH (t) = high;\n+\t{\n+\t  t = copy_node (t);\n+\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\t}\n     }\n   \n   return t;\n@@ -1425,11 +1428,16 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       /* Propagate overflow flags ourselves.  */\n       if (((!uns || is_sizetype) && overflow)\n \t  | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2))\n-\tTREE_OVERFLOW (t) = 1;\n-\n-      if (TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1)\n-\t  | TREE_CONSTANT_OVERFLOW (arg2))\n-\tTREE_CONSTANT_OVERFLOW (t) = 1;\n+\t{\n+\t  t = copy_node (t);\n+\t  TREE_OVERFLOW (t) = 1;\n+\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\t}\n+      else if (TREE_CONSTANT_OVERFLOW (arg1) | TREE_CONSTANT_OVERFLOW (arg2))\n+\t{\n+\t  t = copy_node (t);\n+\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\t}\n     }\n   else\n     t = force_fit_type (t, 1,"}, {"sha": "4489f6a5630478fcb3c4ce46f1286958213be500", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -1,7 +1,14 @@\n+2004-08-19  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* parse.h (JAVA_RADIX10_FLAG): Rename to ...\n+\t(JAVA_NOT_RADIX10_FLAG): ... here.  Invert meaning.\n+\t* lex.c (do_java_lex): Adjust.\n+\t(error_if_numeric_overflow): Likewise.\n+\n 2004-08-18  Andrew Pinski  <apinski@apple.com>\n \n-\t* class.c (make_local_function_alias): Only make a new decl if we support\n-\talias attribute on all decls.\n+\t* class.c (make_local_function_alias): Only make a new decl if we\n+\tsupport alias attribute on all decls.\n \n 2004-08-18  Bryce McKinlay  <mckinlay@redhat.com>\n "}, {"sha": "7c497bda9ed2675046e9f56527834de5adeee4a2", "filename": "gcc/java/lex.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -1303,9 +1303,14 @@ do_java_lex (YYSTYPE *java_lval)\n       value = build_int_cst (long_suffix ? long_type_node : int_type_node,\n \t\t\t     low, high);\n       value = force_fit_type (value, 0, false, false);\n-      SET_LVAL_NODE (value);\n+\n+      if (radix != 10)\n+\t{\n+\t  value = copy_node (value);\n+\t  JAVA_NOT_RADIX10_FLAG (value) = 1;\n+\t}\n       \n-      JAVA_RADIX10_FLAG (value) = radix == 10;\n+      SET_LVAL_NODE (value);\n #endif\n       return INT_LIT_TK;\n     }\n@@ -1733,7 +1738,7 @@ static void\n error_if_numeric_overflow (tree value)\n {\n   if (TREE_CODE (value) == INTEGER_CST\n-      && JAVA_RADIX10_FLAG (value)\n+      && !JAVA_NOT_RADIX10_FLAG (value)\n       && tree_int_cst_sgn (value) < 0)\n     {\n       if (TREE_TYPE (value) == long_type_node)"}, {"sha": "9e4e0f8fca4f661a8094e55404080b5160e49943", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -910,9 +910,9 @@ struct parser_ctxt GTY(()) {\n     TREE_PURPOSE (CPC_INSTANCE_INITIALIZER_LIST (C)) = (S);\n \n /* This is used by the lexer to communicate with the parser.  It is\n-   set on an integer constant if the radix is 10, so that the parser\n+   set on an integer constant if the radix is NOT 10, so that the parser\n    can correctly diagnose a numeric overflow.  */\n-#define JAVA_RADIX10_FLAG(NODE) TREE_LANG_FLAG_0(NODE)\n+#define JAVA_NOT_RADIX10_FLAG(NODE) TREE_LANG_FLAG_0(NODE)\n \n #ifndef JC1_LITE\n void java_complete_class (void);"}, {"sha": "331e0523d2d31142ea4b0f1622ac58ded66813b9", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -379,6 +379,14 @@ DEFPARAM(PARAM_MAX_SCHED_REGION_INSNS,\n \t \"The maximum number of insns in a region to be considered for interblock scheduling\",\n \t 100)\n \n+/* INTEGER_CST nodes are shared for values [{-1,0} .. N) for\n+   {signed,unsigned} integral types.  This determines N.\n+   Experimentation shows 256 to be a good value.  */\n+DEFPARAM (PARAM_INTEGER_SHARE_LIMIT,\n+\t  \"integer-share-limit\",\n+\t  \"The upper bound for sharing integer constants\",\n+\t  256)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "603f21b6f3f925e11319d43743082d5962e35d02", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -122,4 +122,6 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_GLOBAL_VAR_THRESHOLD)\n #define MAX_ALIASED_VOPS \\\n   PARAM_VALUE (PARAM_MAX_ALIASED_VOPS)\n+#define INTEGER_SHARE_LIMIT \\\n+  PARAM_VALUE (PARAM_INTEGER_SHARE_LIMIT)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "156702f652f7567c9b30ed8d8986b6c8b0cd1af8", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -35,6 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"regs.h\"\n+#include \"params.h\"\n \n /* Set to one when set_sizetype has been called.  */\n static int sizetype_set;\n@@ -1900,7 +1901,9 @@ set_sizetype (tree type)\n \n   /* Make copies of nodes since we'll be setting TYPE_IS_SIZETYPE.  */\n   sizetype = copy_node (type);\n-  TYPE_ORIG_SIZE_TYPE (sizetype) = type;\n+  TYPE_CACHED_VALUES (sizetype) = make_tree_vec (INTEGER_SHARE_LIMIT);\n+  TYPE_CACHED_VALUES_P (sizetype) = 1;\n+  TREE_TYPE (TYPE_CACHED_VALUES (sizetype)) = type;\n   TYPE_IS_SIZETYPE (sizetype) = 1;\n   bitsizetype = make_node (INTEGER_TYPE);\n   TYPE_NAME (bitsizetype) = TYPE_NAME (type);\n@@ -2047,6 +2050,8 @@ fixup_unsigned_type (tree type)\n   if (precision > HOST_BITS_PER_WIDE_INT * 2)\n     precision = HOST_BITS_PER_WIDE_INT * 2;\n \n+  TYPE_UNSIGNED (type) = 1;\n+  \n   set_min_and_max_values_for_integral_type (type, precision, \n \t\t\t\t\t    /*is_unsigned=*/true);\n "}, {"sha": "d0a182b2052c20d0679599940491f863efc4fc1a", "filename": "gcc/tree.c", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -48,6 +48,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-iterator.h\"\n #include \"basic-block.h\"\n #include \"tree-flow.h\"\n+#include \"params.h\"\n \n /* obstack.[ch] explicitly declined to prototype this.  */\n extern int _obstack_allocated_p (struct obstack *h, void *obj);\n@@ -427,15 +428,84 @@ tree\n build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n {\n   tree t;\n+  int ix = -1;\n+  int limit = 0;\n \n   if (!type)\n     type = integer_type_node;\n-\n+  \n+  switch (TREE_CODE (type))\n+    {\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* Cache NULL pointer.  */\n+      if (!hi && !low)\n+\t{\n+\t  limit = 1;\n+\t  ix = 0;\n+\t}\n+      break;\n+      \n+    case BOOLEAN_TYPE:\n+      /* Cache false or true.  */\n+      limit = 2;\n+      if (!hi && low < 2)\n+\tix = low;\n+      break;\n+      \n+    case INTEGER_TYPE:\n+    case CHAR_TYPE:\n+    case OFFSET_TYPE:\n+      if (TYPE_UNSIGNED (type))\n+\t{\n+\t  /* Cache 0..N */\n+\t  limit = INTEGER_SHARE_LIMIT;\n+\t  if (!hi && low < (unsigned HOST_WIDE_INT)INTEGER_SHARE_LIMIT)\n+\t    ix = low;\n+\t}\n+      else\n+\t{\n+\t  /* Cache -1..N */\n+\t  limit = INTEGER_SHARE_LIMIT + 1;\n+\t  if (!hi && low < (unsigned HOST_WIDE_INT)INTEGER_SHARE_LIMIT)\n+\t    ix = low + 1;\n+\t  else if (hi == -1 && low == -(unsigned HOST_WIDE_INT)1)\n+\t    ix = 0;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  \n+  if (ix >= 0)\n+    {\n+      if (!TYPE_CACHED_VALUES_P (type))\n+\t{\n+\t  TYPE_CACHED_VALUES_P (type) = 1;\n+\t  TYPE_CACHED_VALUES (type) = make_tree_vec (limit);\n+\t}\n+      \n+      t = TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix);\n+      if (t)\n+\t{\n+\t  /* Make sure no one is clobbering the shared constant.  */\n+\t  if (TREE_TYPE (t) != type)\n+\t    abort ();\n+\t  if (TREE_INT_CST_LOW (t) != low || TREE_INT_CST_HIGH (t) != hi)\n+\t    abort ();\n+\t  return t;\n+\t}\n+    }\n+  \n   t = make_node (INTEGER_CST);\n \n   TREE_INT_CST_LOW (t) = low;\n   TREE_INT_CST_HIGH (t) = hi;\n   TREE_TYPE (t) = type;\n+\n+  if (ix >= 0)\n+    TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n+  \n   return t;\n }\n \n@@ -3097,6 +3167,14 @@ build_type_copy (tree type)\n   tree t, m = TYPE_MAIN_VARIANT (type);\n \n   t = copy_node (type);\n+  if (TYPE_CACHED_VALUES_P(t))\n+    {\n+      /* Do not copy the values cache.  */\n+      if (TREE_CODE (t) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t))\n+\tabort ();\n+      TYPE_CACHED_VALUES_P (t) = 0;\n+      TYPE_CACHED_VALUES (t) = NULL_TREE;\n+    }\n \n   TYPE_POINTER_TO (t) = 0;\n   TYPE_REFERENCE_TO (t) = 0;"}, {"sha": "fc7ed81a54fd329fde97fe6efed0fb8e35b4d2fe", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -258,10 +258,13 @@ DEFTREECODE (LANG_TYPE, \"lang_type\", 't', 0)\n /* First, the constants.  */\n \n /* Contents are in TREE_INT_CST_LOW and TREE_INT_CST_HIGH fields,\n-   32 bits each, giving us a 64 bit constant capability.\n-   Note: constants of type char in Pascal are INTEGER_CST,\n-   and so are pointer constants such as nil in Pascal or NULL in C.\n-   `(int *) 1' in C also results in an INTEGER_CST.  */\n+   32 bits each, giving us a 64 bit constant capability.  INTEGER_CST\n+   nodes can be shared, and therefore should be considered read only.\n+   They should be copied, before setting a flag such as\n+   TREE_OVERFLOW.  If an INTEGER_CST has TREE_OVERFLOW or\n+   TREE_CONSTANT_OVERFLOW already set, it is known to be unique.\n+   INTEGER_CST nodes are created for the integral types, for pointer\n+   types and for vector and float types in some circumstances.  */\n DEFTREECODE (INTEGER_CST, \"integer_cst\", 'c', 0)\n \n /* Contents are in TREE_REAL_CST field.  */"}, {"sha": "f498db1aaf87cc9d91645e89cfe222b50e63cc0b", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=89b0433e3a1f0a9ae590c1be5a6ba4b9aa690ae0", "patch": "@@ -230,6 +230,8 @@ struct tree_common GTY(())\n            VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n        ASM_VOLATILE_P in\n            ASM_EXPR\n+       TYPE_CACHED_VALUES_P in\n+          ..._TYPE\n \n    private_flag:\n \n@@ -782,6 +784,10 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    for this name in an inner scope.  */\n #define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n \n+/* In a _TYPE, indicates whether TYPE_CACHED_VALUES contains a vector\n+   of cached values, or is something else.  */\n+#define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK(NODE)->common.public_flag)\n+\n /* In any expression, decl, or constant, nonzero means it has side effects or\n    reevaluation of the whole expression could produce a different value.\n    This is set if any subexpression is a function call, a side effect or a\n@@ -1377,10 +1383,13 @@ struct tree_block GTY(())\n #define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type.size)\n #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n #define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)\n-#define TYPE_ORIG_SIZE_TYPE(NODE) (INTEGER_TYPE_CHECK (NODE)->type.values)\n #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)\n #define TYPE_DOMAIN(NODE) (SET_OR_ARRAY_CHECK (NODE)->type.values)\n #define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)\n+#define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type.values)\n+#define TYPE_ORIG_SIZE_TYPE(NODE)\t\t\t\\\n+  (INTEGER_TYPE_CHECK (NODE)->type.values\t\t\\\n+  ? TREE_TYPE ((NODE)->type.values) : NULL_TREE)\n #define TYPE_METHODS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.maxval)\n #define TYPE_VFIELD(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.minval)\n #define TYPE_ARG_TYPES(NODE) (FUNC_OR_METHOD_CHECK (NODE)->type.values)"}]}