{"sha": "864e0cbdc8b587c4702367f97fa391d110d920d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY0ZTBjYmRjOGI1ODdjNDcwMjM2N2Y5N2ZhMzkxZDExMGQ5MjBkNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-11-30T09:48:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-11-30T09:48:04Z"}, "message": "[multiple changes]\n\n2009-11-30  Robert Dewar  <dewar@adacore.com>\n\n\t* g-alleve.adb: Minor code reorganization (use conditional expressions)\n\n2009-11-30  Thomas Quinot  <quinot@adacore.com>\n\n\t* a-tasatt.adb, s-taprop-dummy.adb (Ada.Task_Attributes.Reference):\n\tRemove unreachable code.\n\t(System.Task_Primitives.Operations.Initialize, dummy version):\n\tUse plain Program_Error rather than call to\n\tSystem.Error_Reporting.Shutdown.\n\nFrom-SVN: r154766", "tree": {"sha": "20c24f79dac60f4774ea7956bf9ccabd608a4b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20c24f79dac60f4774ea7956bf9ccabd608a4b01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/864e0cbdc8b587c4702367f97fa391d110d920d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/864e0cbdc8b587c4702367f97fa391d110d920d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/864e0cbdc8b587c4702367f97fa391d110d920d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/864e0cbdc8b587c4702367f97fa391d110d920d5/comments", "author": null, "committer": null, "parents": [{"sha": "979bbe902b9ccd20555c44d799b0a19eae7bcdbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/979bbe902b9ccd20555c44d799b0a19eae7bcdbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/979bbe902b9ccd20555c44d799b0a19eae7bcdbc"}], "stats": {"total": 218, "additions": 64, "deletions": 154}, "files": [{"sha": "cb9fbab6e349b59597c21237035f717dfd013fa8", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864e0cbdc8b587c4702367f97fa391d110d920d5/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864e0cbdc8b587c4702367f97fa391d110d920d5/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=864e0cbdc8b587c4702367f97fa391d110d920d5", "patch": "@@ -221,7 +221,6 @@\n --  general use 'Unchecked_Access instead of 'Access as the package can be\n --  instantiated from within a local context.\n \n-with System.Error_Reporting;\n with System.Storage_Elements;\n with System.Task_Primitives.Operations;\n with System.Tasking;\n@@ -237,8 +236,7 @@ pragma Elaborate_All (System.Tasking.Task_Attributes);\n \n package body Ada.Task_Attributes is\n \n-   use System.Error_Reporting,\n-       System.Tasking.Initialization,\n+   use System.Tasking.Initialization,\n        System.Tasking,\n        System.Tasking.Task_Attributes,\n        Ada.Exceptions;\n@@ -424,9 +422,6 @@ package body Ada.Task_Attributes is\n          end;\n       end if;\n \n-      pragma Assert (Shutdown (\"Should never get here in Reference\"));\n-      return null;\n-\n    exception\n       when Tasking_Error | Program_Error =>\n          raise;"}, {"sha": "39d0b7240dbc3e246d6aae4a2d8f571c3402476b", "filename": "gcc/ada/g-alleve.adb", "status": "modified", "additions": 62, "deletions": 143, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864e0cbdc8b587c4702367f97fa391d110d920d5/gcc%2Fada%2Fg-alleve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864e0cbdc8b587c4702367f97fa391d110d920d5/gcc%2Fada%2Fg-alleve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alleve.adb?ref=864e0cbdc8b587c4702367f97fa391d110d920d5", "patch": "@@ -376,11 +376,8 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for K in Varray_Type'Range loop\n-            if A (K) /= Component_Type'First then\n-               D (K) := abs (A (K));\n-            else\n-               D (K) := Component_Type'First;\n-            end if;\n+            D (K) := (if A (K) /= Component_Type'First\n+                      then abs (A (K)) else Component_Type'First);\n          end loop;\n \n          return D;\n@@ -443,11 +440,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) > B (J) then\n-               D (J) := Bool_True;\n-            else\n-               D (J) := Bool_False;\n-            end if;\n+            D (J) := (if A (J) > B (J) then Bool_True else Bool_False);\n          end loop;\n \n          return D;\n@@ -489,11 +482,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) > B (J) then\n-               D (J) := A (J);\n-            else\n-               D (J) := B (J);\n-            end if;\n+            D (J) := (if A (J) > B (J) then A (J) else B (J));\n          end loop;\n \n          return D;\n@@ -545,11 +534,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) < B (J) then\n-               D (J) := A (J);\n-            else\n-               D (J) := B (J);\n-            end if;\n+            D (J) := (if A (J) < B (J) then A (J) else B (J));\n          end loop;\n \n          return D;\n@@ -971,11 +956,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) = B (J) then\n-               D (J) := Bool_True;\n-            else\n-               D (J) := Bool_False;\n-            end if;\n+            D (J) := (if A (J) = B (J) then Bool_True else Bool_False);\n          end loop;\n \n          return D;\n@@ -992,11 +973,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n          D : Varray_Type;\n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) > B (J) then\n-               D (J) := Bool_True;\n-            else\n-               D (J) := Bool_False;\n-            end if;\n+            D (J) := (if A (J) > B (J) then Bool_True else Bool_False);\n          end loop;\n \n          return D;\n@@ -1011,11 +988,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) > B (J) then\n-               D (J) := A (J);\n-            else\n-               D (J) := B (J);\n-            end if;\n+            D (J) := (if A (J) > B (J) then A (J) else B (J));\n          end loop;\n \n          return D;\n@@ -1030,11 +1003,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in Varray_Type'Range loop\n-            if A (J) < B (J) then\n-               D (J) := A (J);\n-            else\n-               D (J) := B (J);\n-            end if;\n+            D (J) := (if A (J) < B (J) then A (J) else B (J));\n          end loop;\n \n          return D;\n@@ -1248,17 +1217,15 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       begin\n \n          for J in 0 .. N - 1 loop\n-            if Use_Even_Components then\n-               Offset := Index_Type (2 * J + Integer (Index_Type'First));\n-            else\n-               Offset := Index_Type (2 * J + 1 + Integer (Index_Type'First));\n-            end if;\n+            Offset :=\n+              Index_Type ((if Use_Even_Components then 2 * J else 2 * J + 1) +\n+                          Integer (Index_Type'First));\n \n             Double_Offset :=\n               Double_Index_Type (J + Integer (Double_Index_Type'First));\n             D (Double_Offset) :=\n-              Double_Component_Type (A (Offset))\n-              * Double_Component_Type (B (Offset));\n+              Double_Component_Type (A (Offset)) *\n+              Double_Component_Type (B (Offset));\n          end loop;\n \n          return D;\n@@ -1418,17 +1385,15 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n       begin\n          for J in 0 .. N - 1 loop\n-            if Use_Even_Components then\n-               Offset := Index_Type (2 * J + Integer (Index_Type'First));\n-            else\n-               Offset := Index_Type (2 * J + 1 + Integer (Index_Type'First));\n-            end if;\n+            Offset :=\n+              Index_Type ((if Use_Even_Components then 2 * J else 2 * J + 1) +\n+                          Integer (Index_Type'First));\n \n             Double_Offset :=\n               Double_Index_Type (J + Integer (Double_Index_Type'First));\n             D (Double_Offset) :=\n-              Double_Component_Type (A (Offset))\n-              * Double_Component_Type (B (Offset));\n+              Double_Component_Type (A (Offset)) *\n+              Double_Component_Type (B (Offset));\n          end loop;\n \n          return D;\n@@ -1620,11 +1585,7 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       if (Bits (VSCR, NJ_POS, NJ_POS) = 1)\n         and then abs (X) < 2.0 ** (-126)\n       then\n-         if X < 0.0 then\n-            D := -0.0;\n-         else\n-            D := 0.0;\n-         end if;\n+         D := (if X < 0.0 then -0.0 else +0.0);\n       else\n          D := X;\n       end if;\n@@ -1648,17 +1609,18 @@ package body GNAT.Altivec.Low_Level_Vectors is\n    function Rnd_To_FPI_Near (X : F64) return F64 is\n       Result  : F64;\n       Ceiling : F64;\n+\n    begin\n       Result := F64 (SI64 (X));\n \n       if (F64'Ceiling (X) - X) = (X + 1.0 - F64'Ceiling (X)) then\n+\n          --  Round to even\n+\n          Ceiling := F64'Ceiling (X);\n-         if Rnd_To_FPI_Trunc (Ceiling / 2.0) * 2.0 = Ceiling then\n-            Result := Ceiling;\n-         else\n-            Result := Ceiling - 1.0;\n-         end if;\n+         Result :=\n+           (if Rnd_To_FPI_Trunc (Ceiling / 2.0) * 2.0 = Ceiling\n+            then Ceiling else Ceiling - 1.0);\n       end if;\n \n       return Result;\n@@ -2111,14 +2073,9 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n    begin\n       for J in Varray_unsigned_int'Range loop\n-         Addition_Result :=\n-           UI64 (VA.Values (J)) + UI64 (VB.Values (J));\n-\n-         if Addition_Result > UI64 (unsigned_int'Last) then\n-            D.Values (J) := 1;\n-         else\n-            D.Values (J) := 0;\n-         end if;\n+         Addition_Result := UI64 (VA.Values (J)) + UI64 (VB.Values (J));\n+         D.Values (J) :=\n+           (if Addition_Result > UI64 (unsigned_int'Last) then 1 else 0);\n       end loop;\n \n       return To_LL_VSI (To_Vector (D));\n@@ -2374,19 +2331,15 @@ package body GNAT.Altivec.Low_Level_Vectors is\n             D.Values (K) := Write_Bit (D.Values (K), 1, 1);\n \n          else\n-            if NJ_Truncate (VA.Values (J))\n-              <= NJ_Truncate (VB.Values (J)) then\n-               D.Values (K) := Write_Bit (D.Values (K), 0, 0);\n-            else\n-               D.Values (K) := Write_Bit (D.Values (K), 0, 1);\n-            end if;\n-\n-            if NJ_Truncate (VA.Values (J))\n-              >= -NJ_Truncate (VB.Values (J)) then\n-               D.Values (K) := Write_Bit (D.Values (K), 1, 0);\n-            else\n-               D.Values (K) := Write_Bit (D.Values (K), 1, 1);\n-            end if;\n+            D.Values (K) :=\n+              (if NJ_Truncate (VA.Values (J)) <= NJ_Truncate (VB.Values (J))\n+               then Write_Bit (D.Values (K), 0, 0)\n+               else Write_Bit (D.Values (K), 0, 1));\n+\n+            D.Values (K) :=\n+              (if NJ_Truncate (VA.Values (J)) >= -NJ_Truncate (VB.Values (J))\n+               then Write_Bit (D.Values (K), 1, 0)\n+               else Write_Bit (D.Values (K), 1, 1));\n          end if;\n       end loop;\n \n@@ -2441,17 +2394,11 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       VA : constant VF_View := To_View (A);\n       VB : constant VF_View := To_View (B);\n       D  : VUI_View;\n-      K  : Vint_Range;\n \n    begin\n       for J in Varray_float'Range loop\n-         K := Vint_Range (J);\n-\n-         if VA.Values (J) = VB.Values (J) then\n-            D.Values (K) := unsigned_int'Last;\n-         else\n-            D.Values (K) := 0;\n-         end if;\n+         D.Values (Vint_Range (J)) :=\n+            (if VA.Values (J) = VB.Values (J) then unsigned_int'Last else 0);\n       end loop;\n \n       return To_LL_VSI (To_Vector (D));\n@@ -2465,17 +2412,12 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       VA : constant VF_View := To_View (A);\n       VB : constant VF_View := To_View (B);\n       D : VSI_View;\n-      K : Vint_Range;\n \n    begin\n       for J in Varray_float'Range loop\n-         K := Vint_Range (J);\n-\n-         if VA.Values (J) >= VB.Values (J) then\n-            D.Values (K) := Signed_Bool_True;\n-         else\n-            D.Values (K) := Signed_Bool_False;\n-         end if;\n+         D.Values (Vint_Range (J)) :=\n+           (if VA.Values (J) >= VB.Values (J) then Signed_Bool_True\n+                                              else Signed_Bool_False);\n       end loop;\n \n       return To_Vector (D);\n@@ -2567,18 +2509,12 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       VA : constant VF_View := To_View (A);\n       VB : constant VF_View := To_View (B);\n       D  : VSI_View;\n-      K  : Vint_Range;\n \n    begin\n       for J in Varray_float'Range loop\n-         K := Vint_Range (J);\n-\n-         if NJ_Truncate (VA.Values (J))\n-           > NJ_Truncate (VB.Values (J)) then\n-            D.Values (K) := Signed_Bool_True;\n-         else\n-            D.Values (K) := Signed_Bool_False;\n-         end if;\n+         D.Values (Vint_Range (J)) :=\n+           (if NJ_Truncate (VA.Values (J)) > NJ_Truncate (VB.Values (J))\n+            then Signed_Bool_True else Signed_Bool_False);\n       end loop;\n \n       return To_Vector (D);\n@@ -3069,11 +3005,8 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n    begin\n       for J in Varray_float'Range loop\n-         if VA.Values (J) > VB.Values (J) then\n-            D.Values (J) := VA.Values (J);\n-         else\n-            D.Values (J) := VB.Values (J);\n-         end if;\n+         D.Values (J) := (if VA.Values (J) > VB.Values (J) then VA.Values (J)\n+                                                           else VB.Values (J));\n       end loop;\n \n       return To_Vector (D);\n@@ -3186,11 +3119,8 @@ package body GNAT.Altivec.Low_Level_Vectors is\n \n    begin\n       for J in Varray_float'Range loop\n-         if VA.Values (J) < VB.Values (J) then\n-            D.Values (J) := VA.Values (J);\n-         else\n-            D.Values (J) := VB.Values (J);\n-         end if;\n+         D.Values (J) := (if VA.Values (J) < VB.Values (J) then VA.Values (J)\n+                                                           else VB.Values (J));\n       end loop;\n \n       return To_Vector (D);\n@@ -3924,12 +3854,9 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       for N in Vchar_Range'Range loop\n          J := Vchar_Range (Integer (Bits (VC.Values (N), 4, 7))\n                            + Integer (Vchar_Range'First));\n-\n-         if Bits (VC.Values (N), 3, 3) = 0 then\n-            D.Values (N) := VA.Values (J);\n-         else\n-            D.Values (N) := VB.Values (J);\n-         end if;\n+         D.Values (N) :=\n+           (if Bits (VC.Values (N), 3, 3) = 0 then VA.Values (J)\n+                                              else VB.Values (J));\n       end loop;\n \n       return To_LL_VSI (To_Vector (D));\n@@ -4184,12 +4111,9 @@ package body GNAT.Altivec.Low_Level_Vectors is\n    begin\n       for N in Vchar_Range'Range loop\n          J := Natural (N) + M;\n-\n-         if J <= Natural (Vchar_Range'Last) then\n-            D.Values (N) := VA.Values (Vchar_Range (J));\n-         else\n-            D.Values (N) := 0;\n-         end if;\n+         D.Values (N) :=\n+           (if J <= Natural (Vchar_Range'Last) then VA.Values (Vchar_Range (J))\n+                                               else 0);\n       end loop;\n \n       return To_LL_VSI (To_Vector (D));\n@@ -4530,12 +4454,8 @@ package body GNAT.Altivec.Low_Level_Vectors is\n    begin\n       for J in Vint_Range'Range loop\n          Subst_Result := SI64 (VA.Values (J)) - SI64 (VB.Values (J));\n-\n-         if Subst_Result < SI64 (unsigned_int'First) then\n-            D.Values (J) := 0;\n-         else\n-            D.Values (J) := 1;\n-         end if;\n+         D.Values (J) :=\n+           (if Subst_Result < SI64 (unsigned_int'First) then 0 else 1);\n       end loop;\n \n       return To_LL_VSI (To_Vector (D));\n@@ -5023,12 +4943,11 @@ package body GNAT.Altivec.Low_Level_Vectors is\n       D := To_View (vcmpbfp (B, C));\n \n       for J in Vint_Range'Range loop\n+\n          --  vcmpbfp is not returning the usual bool vector; do the conversion\n-         if D.Values (J) = 0 then\n-            D.Values (J) := Signed_Bool_False;\n-         else\n-            D.Values (J) := Signed_Bool_True;\n-         end if;\n+\n+         D.Values (J) :=\n+           (if D.Values (J) = 0 then Signed_Bool_False else Signed_Bool_True);\n       end loop;\n \n       return LL_VSI_Operations.Check_CR6 (A, D.Values);"}, {"sha": "894500bb7545bb23f2c830ca25cc208bdf332908", "filename": "gcc/ada/s-taprop-dummy.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864e0cbdc8b587c4702367f97fa391d110d920d5/gcc%2Fada%2Fs-taprop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864e0cbdc8b587c4702367f97fa391d110d920d5/gcc%2Fada%2Fs-taprop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-dummy.adb?ref=864e0cbdc8b587c4702367f97fa391d110d920d5", "patch": "@@ -38,8 +38,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with System.Error_Reporting;\n-\n package body System.Task_Primitives.Operations is\n \n    use System.Tasking;\n@@ -192,9 +190,7 @@ package body System.Task_Primitives.Operations is\n    procedure Initialize (Environment_Task : Task_Id) is\n       No_Tasking : Boolean;\n    begin\n-      No_Tasking :=\n-        System.Error_Reporting.Shutdown\n-          (\"Tasking not implemented on this configuration\");\n+      raise Program_Error with \"Tasking not implemented on this configuration\";\n    end Initialize;\n \n    procedure Initialize (S : in out Suspension_Object) is"}]}