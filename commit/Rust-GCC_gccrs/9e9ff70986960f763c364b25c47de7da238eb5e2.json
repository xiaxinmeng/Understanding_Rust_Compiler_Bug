{"sha": "9e9ff70986960f763c364b25c47de7da238eb5e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5ZmY3MDk4Njk2MGY3NjNjMzY0YjI1YzQ3ZGU3ZGEyMzhlYjVlMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-01T19:32:00Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-01T19:32:00Z"}, "message": "80th Cygnus<->FSF merge\n\nFrom-SVN: r11150", "tree": {"sha": "6806af6d0f56e2b5be73a4012cdb484c5f7ae122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6806af6d0f56e2b5be73a4012cdb484c5f7ae122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9ff70986960f763c364b25c47de7da238eb5e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9ff70986960f763c364b25c47de7da238eb5e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9ff70986960f763c364b25c47de7da238eb5e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9ff70986960f763c364b25c47de7da238eb5e2/comments", "author": null, "committer": null, "parents": [{"sha": "96bb8ed304ac79195cc2d3f1a5d544a5501be4f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96bb8ed304ac79195cc2d3f1a5d544a5501be4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96bb8ed304ac79195cc2d3f1a5d544a5501be4f6"}], "stats": {"total": 2689, "additions": 530, "deletions": 2159}, "files": [{"sha": "b745716903a86440a44e291f4fd186520fe2b517", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 186, "deletions": 14, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -1,3 +1,175 @@\n+Thu Feb  1 09:27:01 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_struct_anon): Switch around code to not move anon\n+\tunion elements around, nor mess up their contexts, nor offsets,\n+\tinstead we now build up the right number of COMPONENT_REFs for all\n+\tthe anon unions that may be present at build_component_ref time.\n+\t* typeck.c (lookup_anon_field): New routine to handle field lookup\n+\ton fields without names.  We find them, based upon their unique type\n+\tinstead.\n+\t* typeck.c (build_component_ref): Allow FIELD_DECL components.\n+\tHandle finding components in anonymous unions, and ensure that a\n+\tCOMPONENT_REF is built for each level as necessary.\n+\n+Tue Jan 30 18:18:23 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Make the INDIRECT_BIND case come after\n+\tcode that ensures that copy ctors are used if appropriate.\n+\n+Tue Jan 30 17:35:14 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (build_vec_delete): Only give an error if base isn't an\n+\terror_mark_node.\n+\n+Mon Jan 29 17:09:06 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* spew.c (do_aggr): `new struct S;' isn't a forward declaration.\n+\t(yylex): If we see `new', keep slurping.\n+\n+Thu Jan 25 18:31:36 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_struct_1): Move code for handling anon unions...\n+\t(finish_struct_anon): to here.  Fixup so that we do the offset\n+\tcalculations right, and so that the fields are physically moved to\n+\tthe containers's chain.\n+\n+Thu Jan 25 18:27:37 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Avoid trying to get an operand off an\n+\tidentifier node.\n+\n+Wed Jan 24 11:25:30 1996  Jim Wilson  <wilson@chestnut.cygnus.com>\n+\n+\t* typeck.c (pointer_int_sum): Use TYPE_PRECISION (sizetype) not\n+\tPOINTER_SIZE to agree with expr.c.\n+\n+Thu Jan 25 13:01:23 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (lookup_field): Don't report ambiguities if protect is 0,\n+\tinstead return NULL_TREE.\n+\n+Wed Jan 24 13:01:26 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_struct_1): Call warn_hidden if we want warnings\n+\tabout overloaded virtual functions.\n+\t(warn_hidden): New routine to warn of virtual functions that are\n+\thidden by other virtual functions, that are not overridden.\n+\t(get_basefndecls): New routine, used by warn_hidden.\n+\t(mark_overriders): New routine, used by warn_hidden.\n+\t* search.c (get_matching_virtual): Remove old warning that just\n+\tisn't very useful.\n+\n+Tue Jan 23 12:26:10 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (output_builtin_tdesc_entries): #if 0 the function definition.\n+\n+\t* typeck.c (null_ptr_cst_p): Delete unused fn.\n+\t(build_function_call_maybe): Delete unused fn.\n+\n+\t* expr.c (extract_init): #if 0 the code after unconditional return 0\n+\tfor now.\n+\n+\tDelete old cadillac code.\n+\t* edsel.c: Remove file.\n+\t* Make-lang.in (CXX_SRCS): Take edsel.c off the list.\n+\t* Makefile.in (CXX_OBJS): Delete edsel.o.\n+\t(edsel.o): Delete rule.\n+\t* cp-tree.h (flag_cadillac): Delete var decl.\n+\t* lang-options.h: Delete \"-fcadillac\" and \"-fno-cadillac\".\n+\t* decl2.c (flag_cadillac): Delete var definition.\n+\t(lang_decode_option): Delete handling of -fcadillac and -fno-cadillac.\n+\t(grokfield): Delete code depending on flag_cadillac.\n+\t(finish_anon_union): Likewise.\n+\t* class.c (finish_struct_1): Likewise.\n+\t(pushclass): Likewise.\n+\t(popclass): Likewise.\n+\t(push_lang_context): Likewise.\n+\t(pop_lang_context): Likewise.\n+\t* decl.c (init_decl_processing): Likewise.\n+\t(start_decl): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(xref_tag): Likewise.\n+\t(finish_enum): Likewise.\n+\t(start_function): Likewise.\n+\t(finish_function): Likewise.\n+\t(finish_stmt): Likewise.\n+\t* lex.c (lang_init): Likewise.\n+\t(check_newline): Likewise.\n+\n+\t* lex.c (do_pending_inlines): Delete synthesized method kludge.\n+\n+\tDelete defunct, ancient garbage collection implementation.\n+\t* rtti.c: New file with the RTTI stuff from gc.c.\n+\t* gc.c: Removed file (moved the remaining stuff into rtti.c).\n+\t* Makefile.in (CXX_OBJS): Replace gc.o with rtti.o.\n+\t(rtti.o): New rule, replacing gc.o.\n+\t* Make-lang.in (CXX_SRCS): Replace gc.c with rtti.c.\n+\t* cp-tree.h: Delete gc-related fn decls.\n+\t(DECL_GC_OFFSET): Delete macro.\n+\t(flag_gc): Delete extern decl.\n+\t* decl.c (current_function_obstack_index): Delete var decl.\n+\t(current_function_obstack_usage): Delete var decl.\n+\t(start_function): Delete clearing of current_function_obstack_index\n+\tand current_function_obstack_usage.\n+\t(init_decl_processing): Delete code relying on -fgc.\n+\tDelete call to init_gc_processing.\n+\t(cp_finish_decl): Delete calls to build_static_gc_entry and\n+\ttype_needs_gc_entry.  Delete gc code setting DECL_GC_OFFSET.\n+\t(store_parm_decls): Delete -fgc calls to cp_expand_decl_cleanup\n+\tand to expand_expr of a __gc_main call.\n+\t(maybe_gc_cleanup): Delete var decl.\n+\t(finish_function): Delete call to expand_gc_prologue_and_epilogue.\n+\t* decl2.c (flag_gc): Delete var decl.\n+\t(lang_f_options): Delete offering of -fgc.\n+\t(lang_decode_option): Delete -fgc and -fno-gc handling.\n+\t(get_temp_regvar): Delete gc code.\n+\t* init.c (build_new): Delete gc code.\n+\t* lex.c (init_lex): Delete checking of flag_gc.\n+\n+\t* typeck.c (convert_arguments): Delete gc code.\n+\t(build_component_addr): Delete -fgc warning.\n+\t(build_modify_expr): Delete gc code.\n+\n+\t* decl2.c (build_push_scope): Delete fn.\n+\t* cp-tree.h (build_push_scope): Delete decl.\n+\n+\t* search.c (clear_search_slots): Delete fn.\n+\t* cp-tree.h (clear_search_slots): Delete decl.\n+\n+\t* search.c (tree_needs_constructor_p): Delete fn.\n+\t* cp-tree.h (tree_needs_constructor_p): Delete decl.\n+\n+\t* tree.c (id_cmp): Delete fn.\n+\n+\t* tree.c (set_fnaddr_from_vtable_entry): Delete fn.\n+\t* cp-tree.h (set_fnaddr_from_vtable_entry): Delete decl.\n+\n+\t* tree.c (decl_value_member): Delete fn.\n+\t* cp-tree.h (decl_value_member): Delete decl.\n+\n+\t* tree.c (list_hash_lookup_or_cons): Delete fn.\n+\t* cp-tree.h (list_hash_lookup_or_cons): Delete decl.\n+\n+\t* method.c (cplus_exception_name): Delete fn.\n+\t(EXCEPTION_NAME_{PREFIX, LENGTH}): Delete macros.\n+\n+\t* spew.c (shift_tokens): Delete fn.\n+\n+Mon Jan 22 17:49:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (init_exception_processing): Pass 1 to needs_pop in calls\n+\tto cp_finish_decl.\n+\t* parse.y: Ditto.\n+\n+Mon Jan 22 17:34:29 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* tree.c (build_cplus_staticfn_type): Delete function definition;\n+\tnever used.\n+\t* cp-tree.h (build_cplus_staticfn_type): Delete decl.\n+\n+\t* tree.c (virtual_member): Delete function definition; never used.\n+\t* cp-tree.h (virtual_member): Delete decl.\n+\n Fri Jan 19 18:03:14 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* typeck.c (build_component_ref): Handle getting vbase pointers\n@@ -16,8 +188,8 @@ Fri Jan 19 16:01:47 1996  Mike Stump  <mrs@cygnus.com>\n Fri Jan 19 14:09:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (store_bindings): Split out from push_to_top_level.\n-  \t(push_to_top_level): Call it for b->type_shadowed on class binding\n- \tlevels.\n+\t(push_to_top_level): Call it for b->type_shadowed on class binding\n+\tlevels.\n \n Fri Jan 19 13:53:14 1996  Mike Stump  <mrs@cygnus.com>\n \n@@ -86,7 +258,7 @@ Tue Jan 16 00:25:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \t* decl2.c (constructor_name_full): Handle TEMPLATE_TYPE_PARMs.\n \n \t* decl.c (grokdeclarator): Also accept TEMPLATE_TYPE_PARM as a\n- \tscope.\n+\tscope.\n \n Mon Jan 15 16:19:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n@@ -96,8 +268,8 @@ Mon Jan 15 16:19:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \t(nested_type): Ditto.\n \tTake types directly instead of as identifiers.\n \t* call.c (build_scoped_method_call): Take types directly instead of\n- \tas identifiers.\n-  \t* decl.c (xref_basetypes): Ditto.\n+\tas identifiers.\n+\t* decl.c (xref_basetypes): Ditto.\n \t* init.c (expand_member_init): Ditto.\n \t(build_member_call): Ditto.\n \t(build_offset_ref): Ditto.\n@@ -128,7 +300,7 @@ Thu Jan 11 14:55:07 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n Mon Jan  8 17:35:12 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck.c (build_modify_expr): Use a COMPOUND_EXPR instead of\n- \texpand_target_expr.\n+\texpand_target_expr.\n \n Thu Jan  4 12:30:32 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n@@ -225,7 +397,7 @@ Tue Dec 19 22:36:56 1995  Jason Merrill  <jason@yorick.cygnus.com>\n Mon Dec 18 15:51:33 1995  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cp-tree.h, decl2.c (flag_weak): New flag to control the use of\n- \tweak symbols.\t\n+\tweak symbols.\t\n \t* lang-options.h: Add -f{no-,}weak.\n \t* decl.c (init_decl_processing): If the target does not support weak\n \tsymbols, don't use them.\n@@ -253,7 +425,7 @@ Thu Dec 14 16:05:58 1995  Mike Stump  <mrs@cygnus.com>\n Thu Dec 14 14:16:26 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (expand_aggr_init_1): Use expand_aggr_init_1 instead of\n- \texpand_assignment, as the later doesn't handle things that have\n+\texpand_assignment, as the later doesn't handle things that have\n \tcopy constructors well.  The compiler would do bitwise copying,\n \tinstead of ctor calling in some cases.\n \n@@ -325,7 +497,7 @@ Wed Dec  6 11:48:21 1995  Mike Stump  <mrs@cygnus.com>\n \tchanges.\n \t(push_eh_cleanup): New routine to register a cleanup for an\n \texception object.\n- \t(empty_fndecl): Used to default cleanup actions to\n+\t(empty_fndecl): Used to default cleanup actions to\n \tnothing.\n \t(init_exception_processing): Setup empty_fndecl.  Setup\n \tsaved_cleanup.\n@@ -390,7 +562,7 @@ Wed Nov 22 14:19:22 1995  Mike Stump  <mrs@cygnus.com>\n Wed Nov 22 11:52:19 1995  Paul Russell  <Rusty.Russell@adelaide.maptek.com.au>\n \n \t* typeck.c (build_unary_op): Set TREE_NO_UNUSED_WARNING to avoid\n- \twarnings.\n+\twarnings.\n \n Tue Nov 21 17:15:23 1995  Mike Stump  <mrs@cygnus.com>\n \n@@ -408,7 +580,7 @@ Tue Nov 21 13:32:03 1995  Mike Stump  <mrs@cygnus.com>\n Thu Nov  9 13:35:30 1995  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (do_function_instantiation): Don't try to find a file-scope\n- \ttemplate for a member function.\n+\ttemplate for a member function.\n \n Tue Nov 14 06:20:35 1995  Mike Stump  <mrs@cygnus.com>\n \n@@ -537,7 +709,7 @@ Thu Oct 19 14:26:10 1995  Mike Stump  <mrs@cygnus.com>\n Thu Oct 19 10:36:30 1995  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* class.c (finish_struct_bits): Check aggregate_value_p instead of\n- \tRETURN_IN_MEMORY.\n+\tRETURN_IN_MEMORY.\n \n Wed Oct 18 18:12:32 1995  Jason Merrill  <jason@yorick.cygnus.com>\n \n@@ -740,7 +912,7 @@ Wed Sep 13 18:32:24 1995  Mike Stump  <mrs@cygnus.com>\n Wed Sep 13 16:52:06 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* typeck.c (comptypes): Tighten up comparisons of template type\n- \tparms.\n+\tparms.\n \n \t* decl.c (duplicate_decls): Turn off whining about virtual functions\n \tredeclared inline for now.\n@@ -9656,7 +9828,7 @@ Tue Dec  7 16:09:34 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* toplev.c (lang_options): Ditto.\n \n-       Mon Oct  4 12:50:02 1993  Chip Salzenberg  (chip@fin.uucp)\n+Mon Oct  4 12:50:02 1993  Chip Salzenberg  (chip@fin.uucp)\n \n \t[changes propagated from 930810 snapshot]\n \t* cp-decl.c (init_decl_processing): Make long long available for use"}, {"sha": "c6a227bbebb0dea7b2ea17bd6c28c1220bb2a5bf", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -86,9 +86,9 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o getopt.o getopt1.o $(LIBDEPS)\n CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/except.c $(srcdir)/cp/input.c $(srcdir)/cp/pt.c \\\n  $(srcdir)/cp/spew.c $(srcdir)/cp/xref.c $(srcdir)/cp/class.c \\\n- $(srcdir)/cp/edsel.c $(srcdir)/cp/expr.c $(srcdir)/cp/lex.c \\\n+ $(srcdir)/cp/expr.c $(srcdir)/cp/lex.c \\\n  $(srcdir)/cp/ptree.c $(srcdir)/cp/tree.c $(srcdir)/cp/cvt.c \\\n- $(srcdir)/cp/errfn.c $(srcdir)/cp/gc.c $(srcdir)/cp/method.c \\\n+ $(srcdir)/cp/errfn.c $(srcdir)/cp/rtti.c $(srcdir)/cp/method.c \\\n  $(srcdir)/cp/search.c $(srcdir)/cp/typeck.c $(srcdir)/cp/decl.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/init.c $(srcdir)/cp/parse.y \\\n  $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c $(srcdir)/cp/repo.c"}, {"sha": "7ba077e7552c79dffae5f86fafb72e3aa0806b22", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -159,8 +159,8 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n # Language-specific object files for g++\n \n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n- class.o decl2.o error.o gc.o lex.o parse.o ptree.o spew.o typeck.o cvt.o \\\n- edsel.o except.o init.o method.o search.o tree.o xref.o repo.o\n+ class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n+ except.o init.o method.o search.o tree.o xref.o repo.o\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -238,11 +238,10 @@ cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) class.h\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h $(srcdir)/../flags.h\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H)\n-gc.o : gc.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n+rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n except.o : except.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H)\n expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../expr.h ../insn-codes.h\n-edsel.o : edsel.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h $(srcdir)/../flags.h\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h\n pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H)\n error.o : error.c $(CONFIG_H) $(CXX_TREE_H)"}, {"sha": "929e5b104900c6d8a3543dba0a3e29b1867768fc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 164, "deletions": 60, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -2697,6 +2697,167 @@ merge_overrides (binfo, old, do_self, t)\n     }\n }\n \n+/* Get the base virtual function declarations in T that are either\n+   overridden or hidden by FNDECL as a list.  We set TREE_PURPOSE with\n+   the overrider/hider.  */\n+tree\n+get_basefndecls (fndecl, t)\n+     tree fndecl, t;\n+{\n+  tree methods = TYPE_METHODS (t);\n+  tree base_fndecls = NULL_TREE;\n+  tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n+  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  while (methods)\n+    {\n+      tree purpose = NULL_TREE;\n+\n+      if (TREE_CODE (methods) == FUNCTION_DECL\n+\t  && DECL_VINDEX (methods) != NULL_TREE\n+\t  && DECL_NAME (fndecl) == DECL_NAME (methods))\n+\tbase_fndecls = temp_tree_cons (fndecl, methods, base_fndecls);\n+\n+      methods = TREE_CHAIN (methods);\n+    }\n+\n+  if (base_fndecls)\n+    return base_fndecls;\n+\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree basetype = BINFO_TYPE (base_binfo);\n+      tree methods = TYPE_METHODS (basetype);\n+\n+      base_fndecls = chainon (get_basefndecls (fndecl, basetype),\n+\t\t\t      base_fndecls);\n+    }\n+\n+  return base_fndecls;\n+}\n+\n+/* Mark the functions that have been hidden with their overriders.\n+   Since we start out with all functions already marked with a hider,\n+   no need to mark functions that are just hidden.  */\n+void\n+mark_overriders (fndecl, base_fndecls)\n+     tree fndecl, base_fndecls;\n+{\n+  while (base_fndecls)\n+    {\n+      if (overrides (TREE_VALUE (base_fndecls), fndecl))\n+\tTREE_PURPOSE (base_fndecls) = fndecl;\n+\n+      base_fndecls = TREE_CHAIN (base_fndecls);\n+    }\n+}\n+\n+/* Warn about hidden virtual functions that are not overridden in t.  */\n+void\n+warn_hidden (t)\n+     tree t;\n+{\n+  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n+  int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n+  int i;\n+\n+  /* We go through each separately named virtual function.  */\n+  for (i = 1; i < n_methods; ++i)\n+    {\n+      tree fndecl = TREE_VEC_ELT (method_vec, i);\n+\n+      tree base_fndecls = NULL_TREE;\n+      tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n+      int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+      if (DECL_VINDEX (fndecl) == NULL_TREE)\n+\tcontinue;\n+\n+      /* First we get a list of all possible functions that might be\n+\t hidden from each base class.  */\n+      for (i = 0; i < n_baseclasses; i++)\n+\t{\n+\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\t  tree basetype = BINFO_TYPE (base_binfo);\n+\n+\t  base_fndecls = chainon (get_basefndecls (fndecl, basetype),\n+\t\t\t\t  base_fndecls);\n+\t}\n+\n+      if (TREE_CHAIN (fndecl)\n+\t  && DECL_NAME (TREE_CHAIN (fndecl)) == DECL_NAME (fndecl))\n+\t  fndecl = TREE_CHAIN (fndecl);\n+\telse\n+\t  fndecl = NULL_TREE;\n+\n+      /* ...then mark up all the base functions with overriders, preferring\n+\t overriders to hiders.  */\n+      if (base_fndecls)\n+\twhile (fndecl)\n+\t  {\n+\t    mark_overriders (fndecl, base_fndecls);\n+\t    \n+\t    if (TREE_CHAIN (fndecl)\n+\t\t&& DECL_NAME (TREE_CHAIN (fndecl)) == DECL_NAME (fndecl))\n+\t      fndecl = TREE_CHAIN (fndecl);\n+\t    else\n+\t      fndecl = NULL_TREE;\n+\t  }\n+\n+      /* Now give a warning for all base functions without overriders,\n+\t as they are hidden.  */\n+      while (base_fndecls)\n+\t{\n+\t  if (! overrides (TREE_VALUE (base_fndecls),\n+\t\t\t   TREE_PURPOSE (base_fndecls)))\n+\t    {\n+\t      /* Here we know it is a hider, and no overrider exists.  */\n+\t      cp_warning_at (\"`%D' was hidden\", TREE_VALUE (base_fndecls));\n+\t      cp_warning_at (\"  by `%D'\", TREE_PURPOSE (base_fndecls));\n+\t    }\n+\n+\t  base_fndecls = TREE_CHAIN (base_fndecls);\n+\t}\n+    }\n+}\n+\n+/* Check for things that are invalid.  There are probably plenty of other\n+   things we should check for also.  */\n+static void\n+finish_struct_anon (t)\n+     tree t;\n+{\n+  tree field;\n+  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_STATIC (field))\n+\tcontinue;\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t{\n+\t  tree* uelt = &TYPE_FIELDS (TREE_TYPE (field));\n+\t  for (; *uelt; uelt = &TREE_CHAIN (*uelt))\n+\t    {\n+\t      tree offset, x;\n+\n+\t      if (TREE_CODE (*uelt) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      if (TREE_PRIVATE (*uelt))\n+\t\tcp_pedwarn_at (\"private member `%#D' in anonymous union\",\n+\t\t\t       *uelt);\n+\t      else if (TREE_PROTECTED (*uelt))\n+\t\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n+\t\t\t       *uelt);\n+\t    }\n+\t}\n+    }\n+}\n+\n extern int interface_only, interface_unknown;\n \n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n@@ -3577,52 +3738,7 @@ finish_struct_1 (t, warn_anon)\n \n   layout_type (t);\n \n-  {\n-    tree field;\n-    for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n-      {\n-\tif (TREE_STATIC (field))\n-\t  continue;\n-\tif (TREE_CODE (field) != FIELD_DECL)\n-\t  continue;\n-\n-\t/* If this field is an anonymous union,\n-\t   give each union-member the same position as the union has.\n-\n-\t   ??? This is a real kludge because it makes the structure\n-\t   of the types look strange.  This feature is only used by\n-\t   C++, which should have build_component_ref build two\n-\t   COMPONENT_REF operations, one for the union and one for\n-\t   the inner field.  We set the offset of this field to zero\n-\t   so that either the old or the correct method will work.\n-\t   Setting DECL_FIELD_CONTEXT is wrong unless the inner fields are\n-\t   moved into the type of this field, but nothing seems to break\n-\t   by doing this.  */\n-\n-\tif (DECL_NAME (field) == NULL_TREE\n-\t    && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n-\t  {\n-\t    tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n-\t    for (; uelt; uelt = TREE_CHAIN (uelt))\n-\t      {\n-\t\tif (TREE_CODE (uelt) != FIELD_DECL)\n-\t\t  continue;\n-\n-\t\tif (TREE_PRIVATE (uelt))\n-\t\t  cp_pedwarn_at (\"private member `%#D' in anonymous union\",\n-\t\t\t\t uelt);\n-\t\telse if (TREE_PROTECTED (uelt))\n-\t\t  cp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n-\t\t\t\t uelt);\n-\n-\t\tDECL_FIELD_CONTEXT (uelt) = DECL_FIELD_CONTEXT (field);\n-\t\tDECL_FIELD_BITPOS (uelt) = DECL_FIELD_BITPOS (field);\n-\t      }\n-\n-\t    DECL_FIELD_BITPOS (field) = integer_zero_node;\n-\t  }\n-      }\n-  }\n+  finish_struct_anon (t);\n \n   if (n_baseclasses)\n     TYPE_FIELDS (t) = TREE_CHAIN (TYPE_FIELDS (t));\n@@ -4001,8 +4117,8 @@ finish_struct_1 (t, warn_anon)\n \n   resume_momentary (old);\n \n-  if (flag_cadillac)\n-    cadillac_finish_struct (t);\n+  if (warn_overloaded_virtual)\n+    warn_hidden (t);\n \n #if 0\n   /* This has to be done after we have sorted out what to do with\n@@ -4453,9 +4569,6 @@ pushclass (type, modify)\n \n       current_function_decl = this_fndecl;\n     }\n-\n-  if (flag_cadillac)\n-    cadillac_push_class (type);\n }\n  \n /* Get out of the current class scope. If we were in a class scope\n@@ -4466,9 +4579,6 @@ void\n popclass (modify)\n      int modify;\n {\n-  if (flag_cadillac)\n-    cadillac_pop_class ();\n-\n   if (modify < 0)\n     {\n       /* Back this old class out completely.  */\n@@ -4589,18 +4699,12 @@ push_lang_context (name)\n     }\n   else\n     error (\"language string `\\\"%s\\\"' not recognized\", IDENTIFIER_POINTER (name));\n-\n-  if (flag_cadillac)\n-    cadillac_push_lang (name);\n }\n   \n /* Get out of the current language scope.  */\n void\n pop_lang_context ()\n {\n-  if (flag_cadillac)\n-    cadillac_pop_lang ();\n-\n   current_lang_name = *--current_lang_stack;\n   if (current_lang_name == lang_name_cplusplus)\n     strict_prototype = strict_prototypes_lang_cplusplus;"}, {"sha": "e9b4a28075483d23394e7d7874f40e0642f2aae2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -298,10 +298,6 @@ extern int flag_handle_signatures;\n    inline by default.  */\n \n extern int flag_default_inline;\n-\n-/* Nonzero means emit cadillac protocol.  */\n-\n-extern int flag_cadillac;\n \f\n /* C++ language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n@@ -1318,9 +1314,6 @@ extern int flag_new_for_scope;\n #define DECL_REFERENCE_SLOT(NODE) ((tree)(NODE)->decl.arguments)\n #define SET_DECL_REFERENCE_SLOT(NODE,VAL) ((NODE)->decl.arguments=VAL)\n \n-/* For local VAR_DECLs, holds index into gc-protected obstack.  */\n-#define DECL_GC_OFFSET(NODE) ((NODE)->decl.result)\n-\n /* Accessor macros for C++ template decl nodes.  */\n #define DECL_TEMPLATE_IS_CLASS(NODE)    (DECL_RESULT(NODE) == NULL_TREE)\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n@@ -1779,10 +1772,6 @@ extern int flag_this_is_variable;\n \n extern int flag_int_enum_equivalence;\n \n-/* Nonzero means layout structures so that we can do garbage collection.  */\n-\n-extern int flag_gc;\n-\n /* Nonzero means generate 'rtti' that give run-time type information.  */\n \n extern int flag_rtti;\n@@ -1810,14 +1799,6 @@ extern int flag_implicit_templates;\n \n extern int flag_weak;\n \n-/* Current end of entries in the gc obstack for stack pointer variables.  */\n-\n-extern int current_function_obstack_index;\n-\n-/* Flag saying whether we have used the obstack in this function or not.  */\n-\n-extern int current_function_obstack_usage;\n-\n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n extern tree current_class_decl, C_C_D;\t/* PARM_DECL: the class instance variable */\n@@ -2082,7 +2063,6 @@ extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n extern tree groktypefield\t\t\tPROTO((tree, tree));\n extern tree grokoptypename\t\t\tPROTO((tree, tree));\n-extern tree build_push_scope\t\t\tPROTO((tree, tree));\n extern void cplus_decl_attributes\t\tPROTO((tree, tree, tree)); \n extern tree constructor_name_full\t\tPROTO((tree));\n extern tree constructor_name\t\t\tPROTO((tree));\n@@ -2113,8 +2093,6 @@ extern tree current_namespace_id\t\tPROTO((tree));\n extern tree get_namespace_id\t\t\tPROTO((void));\n extern void check_default_args\t\t\tPROTO((tree));\n \n-/* in edsel.c */\n-\n /* in except.c */\n extern tree protect_list;\n extern void start_protect\t\t\tPROTO((void));\n@@ -2145,19 +2123,12 @@ extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n extern int decl_in_memory_p\t\t\tPROTO((tree));\n extern tree unsave_expr_now\t\t\tPROTO((tree));\n \n-/* in gc.c */\n-extern int type_needs_gc_entry\t\t\tPROTO((tree));\n-extern int value_safe_from_gc\t\t\tPROTO((tree, tree));\n-extern void build_static_gc_entry\t\tPROTO((tree, tree));\n-extern tree protect_value_from_gc\t\tPROTO((tree, tree));\n+/* in rtti.c */\n extern tree build_headof\t\t\tPROTO((tree));\n extern tree build_classof\t\t\tPROTO((tree));\n extern tree build_t_desc\t\t\tPROTO((tree, int));\n extern tree build_i_desc\t\t\tPROTO((tree));\n extern tree build_m_desc\t\t\tPROTO((tree));\n-extern void expand_gc_prologue_and_epilogue\tPROTO((void));\n-extern void lang_expand_end_bindings\t\tPROTO((struct rtx_def *, struct rtx_def *));\n-extern void init_gc_processing\t\t\tPROTO((void));\n extern tree build_typeid\t\t\tPROTO((tree));\n extern tree get_typeid\t\t\t\tPROTO((tree));\n extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n@@ -2174,7 +2145,6 @@ extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n extern tree get_type_value\t\t\tPROTO((tree));\n extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n-extern tree get_member_function\t\t\tPROTO((tree *, tree, tree));\n extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n extern tree resolve_offset_ref\t\t\tPROTO((tree));\n extern tree decl_constant_value\t\t\tPROTO((tree));\n@@ -2316,14 +2286,13 @@ extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));\n extern HOST_WIDE_INT breadth_first_search\tPROTO((tree, int (*)(), int (*)()));\n-extern int tree_needs_constructor_p\t\tPROTO((tree, int));\n extern int tree_has_any_destructor_p\t\tPROTO((tree, int));\n extern tree get_matching_virtual\t\tPROTO((tree, tree, int));\n extern tree get_abstract_virtuals\t\tPROTO((tree));\n extern tree get_baselinks\t\t\tPROTO((tree, tree, tree));\n extern tree next_baselink\t\t\tPROTO((tree));\n extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n-extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree, tree, int));\n+extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree, tree));\n extern void clear_search_slots\t\t\tPROTO((tree));\n extern tree get_vbase_types\t\t\tPROTO((tree));\n extern void build_mi_matrix\t\t\tPROTO((tree));\n@@ -2375,19 +2344,15 @@ extern tree hash_tree_cons\t\t\tPROTO((int, int, int, tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n extern tree hash_chainon\t\t\tPROTO((tree, tree));\n extern tree get_decl_list\t\t\tPROTO((tree));\n-extern tree list_hash_lookup_or_cons\t\tPROTO((tree));\n extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n extern tree reverse_path\t\t\tPROTO((tree));\n-extern tree virtual_member\t\t\tPROTO((tree, tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n extern int decl_list_length\t\t\tPROTO((tree));\n extern int count_functions\t\t\tPROTO((tree));\n-extern tree decl_value_member\t\t\tPROTO((tree, tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n extern tree get_first_fn\t\t\tPROTO((tree));\n extern tree fnaddr_from_vtable_entry\t\tPROTO((tree));\n-extern void set_fnaddr_from_vtable_entry\tPROTO((tree, tree));\n extern tree function_arg_chain\t\t\tPROTO((tree));\n extern int promotes_to_aggr_type\t\tPROTO((tree, enum tree_code));\n extern int is_aggr_type_2\t\t\tPROTO((tree, tree));"}, {"sha": "f793bce9105e3deac163e0fe62274163a4d3c22a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -590,15 +590,7 @@ build_up_reference (type, arg, flags, checkconst)\n     {\n       tree temp;\n \n-      if (flags&INDIRECT_BIND)\n-\t{\n-\t  tree slot = build (VAR_DECL, argtype);\n-\t  layout_decl (slot, 0);\n-\t  rval = build (TARGET_EXPR, argtype, slot, arg, 0);\n-\t  rval = build1 (ADDR_EXPR, type, rval);\n-\t  goto done;\n-\t}\n-      else if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n+      if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n \t{\n \t  temp = build_cplus_new (argtype, targ, 1);\n \t  if (TREE_CODE (temp) == WITH_CLEANUP_EXPR)\n@@ -609,6 +601,17 @@ build_up_reference (type, arg, flags, checkconst)\n \t    rval = build1 (ADDR_EXPR, type, temp);\n \t  goto done;\n \t}\n+      else if (flags&INDIRECT_BIND)\n+\t{\n+\t  /* This should be the default, not the below code.  */\n+\t  /* All callers except grok_reference_init should probably\n+             use INDIRECT_BIND.  */\n+\t  tree slot = build (VAR_DECL, argtype);\n+\t  layout_decl (slot, 0);\n+\t  rval = build (TARGET_EXPR, argtype, slot, arg, 0);\n+\t  rval = build1 (ADDR_EXPR, type, rval);\n+\t  goto done;\n+\t}\n       else\n \t{\n \t  temp = get_temp_name (argtype, 0);"}, {"sha": "8becd0f9809ce04a89d922c55be5cc34c44c470b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 582, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -260,7 +260,6 @@ tree class_type_node, record_type_node, union_type_node, enum_type_node;\n tree unknown_type_node;\n tree opaque_type_node, signature_type_node;\n tree sigtable_entry_type;\n-tree maybe_gc_cleanup;\n \n /* Array type `vtable_entry_type[]' */\n tree vtbl_type_node;\n@@ -383,13 +382,6 @@ static tree named_labels;\n \n static tree shadowed_labels;\n \n-#if 0 /* Not needed by C++ */\n-/* Nonzero when store_parm_decls is called indicates a varargs function.\n-   Value not meaningful after store_parm_decls.  */\n-\n-static int c_function_varargs;\n-#endif\n-\n /* The FUNCTION_DECL for the function currently being compiled,\n    or 0 if between functions.  */\n tree current_function_decl;\n@@ -461,14 +453,6 @@ int current_function_just_assigned_this;\n    if this flag is non-zero!  */\n int current_function_parms_stored;\n \n-/* Current end of entries in the gc obstack for stack pointer variables.  */\n-\n-int current_function_obstack_index;\n-\n-/* Flag saying whether we have used the obstack in this function or not.  */\n-\n-int current_function_obstack_usage;\n-\n /* Flag used when debugging spew.c */\n \n extern int spew_debug;\n@@ -707,14 +691,10 @@ pop_binding_level ()\n \t  (is_class_level) ? \"class\" : \"block\",\n \t  current_binding_level, lineno);\n   if (is_class_level != (current_binding_level == class_binding_level))\n-#if 0 /* XXX Don't abort when we're watching how things are being managed.  */\n-    abort ();\n-#else\n-  {\n-    indent ();\n-    fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n-  }\n-#endif\n+    {\n+      indent ();\n+      fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n+    }\n   is_class_level = 0;\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n   {\n@@ -755,14 +735,10 @@ suspend_binding_level ()\n \t  (is_class_level) ? \"class\" : \"block\",\n \t  current_binding_level, lineno);\n   if (is_class_level != (current_binding_level == class_binding_level))\n-#if 0 /* XXX Don't abort when we're watching how things are being managed.  */\n-    abort ();\n-#else\n-  {\n-    indent ();\n-    fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n-  }\n-#endif\n+    {\n+      indent ();\n+      fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n+    }\n   is_class_level = 0;\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n   {\n@@ -1026,35 +1002,6 @@ poplevel (keep, reverse, functionbody)\n   if (current_binding_level->keep == 1)\n     keep = 1;\n \n-  /* This warning is turned off because it causes warnings for\n-     declarations like `extern struct foo *x'.  */\n-#if 0\n-  /* Warn about incomplete structure types in this level.  */\n-  for (link = tags; link; link = TREE_CHAIN (link))\n-    if (TYPE_SIZE (TREE_VALUE (link)) == NULL_TREE)\n-      {\n-\ttree type = TREE_VALUE (link);\n-\tchar *errmsg;\n-\tswitch (TREE_CODE (type))\n-\t  {\n-\t  case RECORD_TYPE:\n-\t    errmsg = \"`struct %s' incomplete in scope ending here\";\n-\t    break;\n-\t  case UNION_TYPE:\n-\t    errmsg = \"`union %s' incomplete in scope ending here\";\n-\t    break;\n-\t  case ENUMERAL_TYPE:\n-\t    errmsg = \"`enum %s' incomplete in scope ending here\";\n-\t    break;\n-\t  }\n-\tif (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type)));\n-\telse\n-\t  /* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */\n-\t  error (errmsg, TYPE_NAME_STRING (type));\n-      }\n-#endif /* 0 */\n-\n   /* Get the decls in the order they were written.\n      Usually current_binding_level->names is in reverse order.\n      But parameter decls were previously put in forward order.  */\n@@ -1305,11 +1252,6 @@ poplevel (keep, reverse, functionbody)\n   /* Take care of compiler's internal binding structures.  */\n   if (tmp == 2)\n     {\n-#if 0\n-      /* We did not call push_momentary for this\n-\t binding contour, so there is nothing to pop.  */\n-      pop_momentary ();\n-#endif\n       expand_end_bindings (getdecls (), keep, 1);\n       /* Each and every BLOCK node created here in `poplevel' is important\n \t (e.g. for proper debugging information) so if we created one\n@@ -1613,17 +1555,7 @@ print_binding_level (lvl)\n       fprintf (stderr, \" type-shadowed:\");\n       for (t = lvl->type_shadowed; t; t = TREE_CHAIN (t))\n         {\n-#if 0\n-          fprintf (stderr, \"\\n\\t\");\n-          print_node_brief (stderr, \"<\", TREE_PURPOSE (t), 0);\n-          if (TREE_VALUE (t))\n-            print_node_brief (stderr, \" \", TREE_VALUE (t), 0);\n-          else\n-            fprintf (stderr, \" (none)\");\n-          fprintf (stderr, \">\");\n-#else\n \t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-#endif\n         }\n       fprintf (stderr, \"\\n\");\n     }\n@@ -1700,11 +1632,6 @@ get_unique_name ()\n     {\n       for (p = buf+11; *p; p++)\n \tif (! ((*p >= '0' && *p <= '9')\n-#if 0 /* we always want labels, which are valid C++ identifiers (+ `$') */\n-#ifndef ASM_IDENTIFY_GCC\t/* this is required if `.' is invalid -- k. raeburn */\n-\t       || *p == '.'\n-#endif\n-#endif\n #ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n \t       || *p == '$'\n #endif\n@@ -2093,37 +2020,6 @@ pop_everything ()\n #endif\n }\n \n-#if 0 /* not yet, should get fixed properly later */\n-/* Create a TYPE_DECL node with the correct DECL_ASSEMBLER_NAME.\n-   Other routines shouldn't use build_decl directly; they'll produce\n-   incorrect results with `-g' unless they duplicate this code.\n-\n-   This is currently needed mainly for dbxout.c, but we can make\n-   use of it in method.c later as well.  */\n-tree\n-make_type_decl (name, type)\n-     tree name, type;\n-{\n-  tree decl, id;\n-  decl = build_decl (TYPE_DECL, name, type);\n-  if (TYPE_NAME (type) == name)\n-    /* Class/union/enum definition, or a redundant typedef for same.  */\n-    {\n-      id = get_identifier (build_overload_name (type, 1, 1));\n-      DECL_ASSEMBLER_NAME (decl) = id;\n-    }\n-  else if (TYPE_NAME (type) != NULL_TREE)\n-    /* Explicit typedef, or implicit typedef for template expansion.  */\n-    DECL_ASSEMBLER_NAME (decl) = DECL_ASSEMBLER_NAME (TYPE_NAME (type));\n-  else\n-    {\n-      /* XXX: Typedef for unnamed struct; some other situations.\n-\t TYPE_NAME is null; what's right here?  */\n-    }\n-  return decl;\n-}\n-#endif\n-\n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n    Normally put into into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n@@ -2157,12 +2053,6 @@ pushtag (name, type, globalize)\n \tc_decl = TREE_CODE (context) == FUNCTION_DECL\n \t  ? context : TYPE_MAIN_DECL (context);\n \n-#if 0\n-      /* Record the identifier as the type's name if it has none.  */\n-      if (TYPE_NAME (type) == NULL_TREE)\n-        TYPE_NAME (type) = name;\n-#endif\n-      \n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n@@ -2177,12 +2067,8 @@ pushtag (name, type, globalize)\n \t      if (d == NULL_TREE)\n \t\t{\n \t\t  newdecl = 1;\n-#if 0 /* not yet, should get fixed properly later */\n-\t\t  d = make_type_decl (name, type);\n-#else\n \t\t  d = build_decl (TYPE_DECL, name, type);\n \t\t  DECL_ASSEMBLER_NAME (d) = current_namespace_id (DECL_ASSEMBLER_NAME (d));\n-#endif\n \t\t  SET_DECL_ARTIFICIAL (d);\n #ifdef DWARF_DEBUGGING_INFO\n \t\t  if (write_symbols == DWARF_DEBUG)\n@@ -2287,11 +2173,7 @@ pushtag (name, type, globalize)\n \t convenient place to record the \"scope start\" address for\n \t the tagged type.  */\n \n-#if 0 /* not yet, should get fixed properly later */\n-      tree d = make_type_decl (NULL_TREE, type);\n-#else\n       tree d = build_decl (TYPE_DECL, NULL_TREE, type);\n-#endif\n       TYPE_STUB_DECL (type) = pushdecl_with_scope (d, b);\n     }\n }\n@@ -2799,18 +2681,6 @@ duplicate_decls (newdecl, olddecl)\n \t  CLASSTYPE_FRIEND_CLASSES (newtype)\n \t    = CLASSTYPE_FRIEND_CLASSES (oldtype);\n \t}\n-#if 0\n-      /* why assert here?  Just because debugging information is\n-\t messed up? (mrs) */\n-      /* it happens on something like:\n-\t \ttypedef struct Thing {\n-                \tThing();\n-\t\t        int     x;\n-\t\t} Thing;\n-      */\n-      my_friendly_assert (DECL_IGNORED_P (olddecl) == DECL_IGNORED_P (newdecl),\n-\t\t\t  139);\n-#endif\n     }\n \n   /* Special handling ensues if new decl is a function definition.  */\n@@ -3098,23 +2968,9 @@ pushdecl (x)\n      tree x;\n {\n   register tree t;\n-#if 0 /* not yet, should get fixed properly later */\n-  register tree name;\n-#else\n   register tree name = DECL_ASSEMBLER_NAME (x);\n-#endif\n   register struct binding_level *b = current_binding_level;\n \n-#if 0\n-  static int nglobals; int len;\n-\n-  len = list_length (global_binding_level->names);\n-  if (len < nglobals)\n-    my_friendly_abort (8);\n-  else if (len > nglobals)\n-    nglobals = len;\n-#endif\n-\n   if (x != current_function_decl\n       /* Don't change DECL_CONTEXT of virtual methods.  */\n       && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n@@ -3124,21 +2980,11 @@ pushdecl (x)\n   if (TREE_CODE (x) == FUNCTION_DECL && DECL_INITIAL (x) == 0)\n     DECL_CONTEXT (x) = 0;\n \n-#if 0 /* not yet, should get fixed properly later */\n-  /* For functions and class static data, we currently look up the encoded\n-     form of the name.  For types, we want the real name.  The former will\n-     probably be changed soon, according to MDT.  */\n-  if (TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)\n-    name = DECL_ASSEMBLER_NAME (x);\n-  else\n-    name = DECL_NAME (x);\n-#else\n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use. */\n   if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n       || TREE_CODE (x) == NAMESPACE_DECL)\n     name = DECL_NAME (x);\n-#endif\n \n   if (name)\n     {\n@@ -3544,13 +3390,6 @@ pushdecl_top_level (x)\n \t}\n       else\n         {\n-#if 0\n-\t  /* Disabled this 11/10/92, since there are many cases which\n-\t     behave just fine when *ptr doesn't satisfy either of these.\n-\t     For example, nested classes declared as friends of their enclosing\n-\t     class will not meet this criteria.  (bpk) */\n-\t  my_friendly_assert (*ptr == NULL_TREE || *ptr == newval, 141);\n-#endif\n \t  *ptr = newval;\n         }\n     }\n@@ -3626,14 +3465,7 @@ pushdecl_nonclass_level (x)\n {\n   struct binding_level *b = current_binding_level;\n \n-#if 0\n-  /* Get out of class scope -- this isn't necessary, because class scope\n-     doesn't make it into current_binding_level.  */\n-  while (b->parm_flag == 2)\n-    b = b->level_chain;\n-#else\n   my_friendly_assert (b->parm_flag != 2, 180);\n-#endif\n \n   /* Get out of template binding levels */\n   while (b->pseudo_global)\n@@ -3728,14 +3560,6 @@ push_overloaded_decl (decl, forgettable)\n \n   if (old)\n     {\n-#if 0\n-      /* We cache the value of builtin functions as ADDR_EXPRs\n-\t in the name space.  Convert it to some kind of _DECL after\n-\t remembering what to forget.  */\n-      if (TREE_CODE (old) == ADDR_EXPR)\n-\told = TREE_OPERAND (old, 0);\n-      else\n-#endif\n       if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n \t{\n \t  tree t = TREE_TYPE (old);\n@@ -4664,11 +4488,7 @@ record_builtin_type (rid_index, name, type)\n   \n   if (tname)\n     {\n-#if 0 /* not yet, should get fixed properly later */\n-      tdecl = pushdecl (make_type_decl (tname, type));\n-#else\n       tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n-#endif\n       set_identifier_type_value (tname, NULL_TREE);\n       if ((int) rid_index < (int) RID_MAX)\n \tIDENTIFIER_GLOBAL_VALUE (tname) = tdecl;\n@@ -4682,11 +4502,7 @@ record_builtin_type (rid_index, name, type)\n \t}\n       else\n \t{\n-#if 0 /* not yet, should get fixed properly later */\n-\t  tdecl = pushdecl (make_type_decl (rname, type));\n-#else\n \t  tdecl = pushdecl (build_decl (TYPE_DECL, rname, type));\n-#endif\n \t  set_identifier_type_value (rname, NULL_TREE);\n \t}\n     }\n@@ -4718,28 +4534,6 @@ record_builtin_type (rid_index, name, type)\n     }\n }\n \n-static void\n-output_builtin_tdesc_entries ()\n-{\n-  extern struct obstack permanent_obstack;\n-\n-  /* If there's more than one main in this file, don't crash.  */\n-  if (builtin_type_tdescs_arr == 0)\n-    return;\n-\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-  while (builtin_type_tdescs_len > 0)\n-    {\n-      tree type = builtin_type_tdescs_arr[--builtin_type_tdescs_len];\n-      tree tdesc = build_t_desc (type, 0);\n-      TREE_ASM_WRITTEN (tdesc) = 0;\n-      build_t_desc (type, 2);\n-    }\n-  free (builtin_type_tdescs_arr);\n-  builtin_type_tdescs_arr = 0;\n-  pop_obstacks ();\n-}\n-\n /* Push overloaded decl, in global scope, with one argument so it\n    can be used as a callback from define_function.  */\n static void\n@@ -4777,10 +4571,6 @@ init_decl_processing ()\n   tree traditional_ptr_type_node;\n   /* Data type of memcpy.  */\n   tree memcpy_ftype;\n-#if 0 /* Not yet.  */\n-  /* Data type of strncpy.  */\n-  tree strncpy_ftype;\n-#endif\n   int wchar_type_size;\n   tree temp;\n   tree array_domain_type;\n@@ -5078,17 +4868,6 @@ init_decl_processing ()\n \t\t\t\t\t\t const_string_type_node,\n \t\t\t\t\t\t endlink)));\n \n-#if 0\n-  /* Not yet.  */\n-  strncpy_ftype\t\t\t/* strncpy prototype */\n-    = build_function_type (string_type_node,\n-\t\t\t   tree_cons (NULL_TREE, string_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, const_string_type_node,\n-\t\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t    sizetype,\n-\t\t\t\t\t\t\t    endlink))));\n-#endif\n-\n   int_ftype_string_string\t/* strcmp prototype */\n     = build_function_type (integer_type_node,\n \t\t\t   tree_cons (NULL_TREE, const_string_type_node,\n@@ -5183,15 +4962,6 @@ init_decl_processing ()\n   builtin_function (\"__builtin_saveregs\",\n \t\t    build_function_type (ptr_type_node, NULL_TREE),\n \t\t    BUILT_IN_SAVEREGS, NULL_PTR);\n-/* EXPAND_BUILTIN_VARARGS is obsolete.  */\n-#if 0\n-  builtin_function (\"__builtin_varargs\",\n-\t\t    build_function_type (ptr_type_node,\n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    integer_type_node,\n-\t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_VARARGS, NULL_PTR);\n-#endif\n   builtin_function (\"__builtin_classify_type\", default_function_type,\n \t\t    BUILT_IN_CLASSIFY_TYPE, NULL_PTR);\n   builtin_function (\"__builtin_next_arg\",\n@@ -5236,11 +5006,6 @@ init_decl_processing ()\n \t\t    BUILT_IN_STRCMP, \"strcmp\");\n   builtin_function (\"__builtin_strcpy\", string_ftype_ptr_ptr,\n \t\t    BUILT_IN_STRCPY, \"strcpy\");\n-#if 0\n-  /* Not yet.  */\n-  builtin_function (\"__builtin_strncpy\", strncpy_ftype,\n-\t\t    BUILT_IN_STRNCPY, \"strncpy\");\n-#endif\n   builtin_function (\"__builtin_strlen\", sizet_ftype_string,\n \t\t    BUILT_IN_STRLEN, \"strlen\");\n \n@@ -5257,10 +5022,6 @@ init_decl_processing ()\n       builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP, NULL_PTR);\n       builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY,\n \t\t\tNULL_PTR);\n-#if 0\n-      /* Not yet.  */\n-      builtin_function (\"strncpy\", strncpy_ftype, BUILT_IN_STRNCPY, NULL_PTR);\n-#endif\n       builtin_function (\"strlen\", sizet_ftype_string, BUILT_IN_STRLEN, NULL_PTR);\n       builtin_function (\"sin\", double_ftype_double, BUILT_IN_SIN, NULL_PTR);\n       builtin_function (\"cos\", double_ftype_double, BUILT_IN_COS, NULL_PTR);\n@@ -5306,16 +5067,11 @@ init_decl_processing ()\n   /* C++ extensions */\n \n   unknown_type_node = make_node (UNKNOWN_TYPE);\n-#if 0 /* not yet, should get fixed properly later */\n-  pushdecl (make_type_decl (get_identifier (\"unknown type\"),\n-\t\t       unknown_type_node));\n-#else\n   decl = pushdecl (build_decl (TYPE_DECL, get_identifier (\"unknown type\"),\n \t\t\tunknown_type_node));\n   /* Make sure the \"unknown type\" typedecl gets ignored for debug info.  */\n   DECL_IGNORED_P (decl) = 1;\n   TYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n-#endif\n   TYPE_SIZE (unknown_type_node) = TYPE_SIZE (void_type_node);\n   TYPE_ALIGN (unknown_type_node) = 1;\n   TYPE_MODE (unknown_type_node) = TYPE_MODE (void_type_node);\n@@ -5351,14 +5107,6 @@ init_decl_processing ()\n   wchar_array_type_node\n     = build_array_type (wchar_type_node, array_domain_type);\n \n-  /* This is a hack that should go away when we deliver the\n-     real gc code.  */\n-  if (flag_gc)\n-    {\n-      builtin_function (\"__gc_main\", default_function_type, NOT_BUILT_IN, NULL_PTR);\n-      pushdecl (lookup_name (get_identifier (\"__gc_main\"), 0));\n-    }\n-\n   if (flag_vtable_thunks)\n     {\n       /* Make sure we get a unique function type, so we can give\n@@ -5597,18 +5345,11 @@ init_decl_processing ()\n \n   if (flag_handle_exceptions)\n     init_exception_processing ();\n-  if (flag_gc)\n-    init_gc_processing ();\n   if (flag_no_inline)\n     {\n       flag_inline_functions = 0;\n-#if 0\n-      /* This causes unnecessary emission of inline functions.  */\n-      flag_default_inline = 0;\n-#endif\n     }\n-  if (flag_cadillac)\n-    init_cadillac ();\n+\n   if (! SUPPORTS_WEAK)\n     flag_weak = 0;\n \n@@ -6090,23 +5831,6 @@ start_decl (declarator, declspecs, initialized, raises)\n      save some disk space.  */\n   DECL_COMMON (tem) = flag_conserve_space || ! TREE_PUBLIC (tem);\n \n-#if 0\n-  /* We don't do this yet for GNU C++.  */\n-  /* For a local variable, define the RTL now.  */\n-  if (! toplevel_bindings_p ()\n-      /* But not if this is a duplicate decl\n-\t and we preserved the rtl from the previous one\n-\t (which may or may not happen).  */\n-      && DECL_RTL (tem) == NULL_RTX)\n-    {\n-      if (TYPE_SIZE (TREE_TYPE (tem)) != NULL_TREE)\n-\texpand_decl (tem);\n-      else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n-\t       && DECL_INITIAL (tem) != NULL_TREE)\n-\texpand_decl (tem);\n-    }\n-#endif\n-\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n       tree result = DECL_TEMPLATE_RESULT (decl);\n@@ -6126,21 +5850,8 @@ start_decl (declarator, declspecs, initialized, raises)\n \t    return tem;\n \t  else if (TREE_CODE (result) == VAR_DECL)\n \t    {\n-#if 0\n-              tree tmpl = UPT_TEMPLATE (type);\n-\t      \n-\t      fprintf (stderr, \"%s:%d: adding \", __FILE__, __LINE__);\n-\t      print_node_brief (stderr, \"\", DECL_NAME (tem), 0);\n-\t      fprintf (stderr, \" to class %s\\n\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (tmpl)));\n-              DECL_TEMPLATE_MEMBERS (tmpl)\n-                = perm_tree_cons (DECL_NAME (tem), tem,\n-\t\t\t\t  DECL_TEMPLATE_MEMBERS (tmpl));\n-\t      return tem;\n-#else\n \t      sorry (\"static data member templates\");\n \t      return NULL_TREE;\n-#endif\n \t    }\n \t  else\n \t    my_friendly_abort (13);\n@@ -6182,72 +5893,9 @@ start_decl (declarator, declspecs, initialized, raises)\n \t}\n     }\n \n-  if (flag_cadillac)\n-    cadillac_start_decl (tem);\n-\n   return tem;\n }\n \n-#if 0\t\t\t\t/* unused */\n-static void\n-make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n-     tree decl, ctor_call, init;\n-     tree *cleanupp;\n-{\n-  tree type = TREE_TYPE (decl);\n-  tree target_type = TREE_TYPE (type);\n-  tree tmp, tmp_addr;\n-\n-  if (ctor_call)\n-    {\n-      tmp_addr = TREE_VALUE (TREE_OPERAND (ctor_call, 1));\n-      if (TREE_CODE (tmp_addr) == NOP_EXPR)\n-\ttmp_addr = TREE_OPERAND (tmp_addr, 0);\n-      my_friendly_assert (TREE_CODE (tmp_addr) == ADDR_EXPR, 146);\n-      tmp = TREE_OPERAND (tmp_addr, 0);\n-    }\n-  else\n-    {\n-      tmp = get_temp_name (target_type, toplevel_bindings_p ());\n-      tmp_addr = build_unary_op (ADDR_EXPR, tmp, 0);\n-    }\n-\n-  TREE_TYPE (tmp_addr) = build_pointer_type (target_type);\n-  DECL_INITIAL (decl) = convert (build_pointer_type (target_type), tmp_addr);\n-  TREE_TYPE (DECL_INITIAL (decl)) = type;\n-  if (TYPE_NEEDS_CONSTRUCTING (target_type))\n-    {\n-      if (toplevel_bindings_p ())\n-\t{\n-\t  /* lay this variable out now.  Otherwise `output_addressed_constants'\n-\t     gets confused by its initializer.  */\n-\t  make_decl_rtl (tmp, NULL_PTR, 1);\n-\t  static_aggregates = perm_tree_cons (init, tmp, static_aggregates);\n-\t}\n-      else\n-\t{\n-\t  if (ctor_call != NULL_TREE)\n-\t    init = ctor_call;\n-\t  else\n-\t    init = build_method_call (tmp, constructor_name_full (target_type),\n-\t\t\t\t      build_tree_list (NULL_TREE, init),\n-\t\t\t\t      NULL_TREE, LOOKUP_NORMAL);\n-\t  DECL_INITIAL (decl) = build (COMPOUND_EXPR, type, init,\n-\t\t\t\t       DECL_INITIAL (decl));\n-\t  *cleanupp = maybe_build_cleanup (tmp);\n-\t}\n-    }\n-  else\n-    {\n-      DECL_INITIAL (tmp) = init;\n-      TREE_STATIC (tmp) = toplevel_bindings_p ();\n-      cp_finish_decl (tmp, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n-    }\n-  if (TREE_STATIC (tmp))\n-    preserve_initializer ();\n-}\n-#endif\n-\n /* Handle initialization of references.\n    These three arguments from from `cp_finish_decl', and have the\n    same meaning here that they do there.  */\n@@ -6476,28 +6124,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n       ttype = target_type (type);\n-#if 0 /* WTF?  -KR\n-\t Leave this out until we can figure out why it was\n-\t needed/desirable in the first place.  Then put a comment\n-\t here explaining why.  Or just delete the code if no ill\n-\t effects arise.  */\n-      if (TYPE_NAME (ttype)\n-\t  && TREE_CODE (TYPE_NAME (ttype)) == TYPE_DECL\n-\t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (ttype)))\n-\t{\n-\t  tree old_id = TYPE_IDENTIFIER (ttype);\n-\t  char *newname = (char *)alloca (IDENTIFIER_LENGTH (old_id) + 2);\n-\t  /* Need to preserve template data for UPT nodes.  */\n-\t  tree old_template = IDENTIFIER_TEMPLATE (old_id);\n-\t  newname[0] = '_';\n-\t  bcopy (IDENTIFIER_POINTER (old_id), newname + 1,\n-\t\t IDENTIFIER_LENGTH (old_id) + 1);\n-\t  old_id = get_identifier (newname);\n-\t  lookup_tag_reverse (ttype, old_id);\n-\t  TYPE_IDENTIFIER (ttype) = old_id;\n-\t  IDENTIFIER_TEMPLATE (old_id) = old_template;\n-\t}\n-#endif\n     }\n \n   if (! DECL_EXTERNAL (decl) && TREE_READONLY (decl)\n@@ -6762,12 +6388,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       if (was_temp)\n \tend_temporary_allocation ();\n \n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && ! toplevel_bindings_p ()\n-\t  && ! TREE_STATIC (decl)\n-\t  && type_needs_gc_entry (type))\n-\tDECL_GC_OFFSET (decl) = size_int (++current_function_obstack_index);\n-\n       if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n \tmake_decl_rtl (decl, NULL_PTR, toplev);\n       else if (TREE_CODE (decl) == VAR_DECL\n@@ -6870,10 +6490,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t  if (TYPE_NEEDS_CONSTRUCTING (type) || init != NULL_TREE\n \t      || TYPE_NEEDS_DESTRUCTOR (type))\n \t    expand_static_init (decl, init);\n-\n-\t  /* Make entry in appropriate vector.  */\n-\t  if (flag_gc && type_needs_gc_entry (type))\n-\t    build_static_gc_entry (decl, type);\n \t}\n       else if (! toplev)\n \t{\n@@ -7012,9 +6628,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \n   if (was_readonly)\n     TREE_READONLY (decl) = 1;\n-\n-  if (flag_cadillac)\n-    cadillac_finish_decl (decl);\n }\n \n /* This is here for a midend callback from c-common.c */\n@@ -8288,13 +7901,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n   volatilep = !! RIDBIT_SETP (RID_VOLATILE, specbits) + TYPE_VOLATILE (type);\n   staticp = 0;\n   inlinep = !! RIDBIT_SETP (RID_INLINE, specbits);\n-#if 0\n-  /* This sort of redundancy is blessed in a footnote to the Sep 94 WP.  */\n-  if (constp > 1)\n-    warning (\"duplicate `const'\");\n-  if (volatilep > 1)\n-    warning (\"duplicate `volatile'\");\n-#endif\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n   RIDBIT_RESET (RID_VIRTUAL, specbits);\n   explicitp = RIDBIT_SETP (RID_EXPLICIT, specbits) != 0;\n@@ -8324,20 +7930,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n-#if 0\n-      if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n-\t{\n-\t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n-\t}\n-      /* Because local typedefs are parsed twice, we don't want this\n-\t message here. */\n-      else if (decl_context != FIELD)\n-\t{\n-\t  error (\"non-member `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n-\t}\n-#endif\n     }\n \n   /* Warn if two storage classes are given. Default to `auto'.  */\n@@ -8517,7 +8109,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \n \t      if (declarator)\n \t\t{\n-\t\t  tmp = TREE_OPERAND (declarator, 0);\n+\t\t  /* Avoid trying to get an operand off an identifier node.  */ \n+\t\t  if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n+\t\t    tmp = declarator;\n+\t\t  else\n+\t\t    tmp = TREE_OPERAND (declarator, 0);\n \t\t  op = IDENTIFIER_OPNAME_P (tmp);\n \t\t}\n \t      error (\"storage class specified for %s `%s'\",\n@@ -8562,21 +8158,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n     {\n       if (RIDBIT_SETP (RID_AUTO, specbits))\n \terror (\"top-level declaration of `%s' specifies `auto'\", name);\n-#if 0\n-      if (RIDBIT_SETP (RID_REGISTER, specbits))\n-\terror (\"top-level declaration of `%s' specifies `register'\", name);\n-#endif\n-#if 0\n-      /* I'm not sure under what circumstances we should turn\n-\t on the extern bit, and under what circumstances we should\n-\t warn if other bits are turned on.  */\n-      if (decl_context == NORMAL\n-\t  && RIDBIT_NOSETP (RID_EXTERN, specbits)\n-\t  && ! root_lang_context_p ())\n-\t{\n-\t  RIDBIT_SET (RID_EXTERN, specbits);\n-\t}\n-#endif\n     }\n \n   /* Now figure out the structure of the declarator proper.\n@@ -8622,11 +8203,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    ctype = TYPE_METHOD_BASETYPE (type);\n \t  if (ctype != NULL_TREE)\n \t    {\n-#if 0 /* not yet, should get fixed properly later */\n-\t      tree dummy = make_type_decl (NULL_TREE, type);\n-#else\n \t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n-#endif\n \t      ctype = grok_method_quals (ctype, dummy, quals);\n \t      type = TREE_TYPE (dummy);\n \t      quals = NULL_TREE;\n@@ -9360,11 +8937,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  }\n \t}\n \n-#if 0 /* not yet, should get fixed properly later */\n-      decl = make_type_decl (declarator, type);\n-#else\n       decl = build_decl (TYPE_DECL, declarator, type);\n-#endif\n       if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)\n \t{\n \t  cp_error_at (\"typedef name may not be class-qualified\", decl);\n@@ -9448,11 +9021,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t}\n       else if (quals)\n \t{\n-#if 0 /* not yet, should get fixed properly later */\n-\t  tree dummy = make_type_decl (declarator, type);\n-#else\n \t  tree dummy = build_decl (TYPE_DECL, declarator, type);\n-#endif\n \t  if (ctype == NULL_TREE)\n \t    {\n \t      my_friendly_assert (TREE_CODE (type) == METHOD_TYPE, 159);\n@@ -9485,12 +9054,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n       else if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n \t{\n \t  if (IDENTIFIER_OPNAME_P (declarator))\n-#if 0\t\t\t\t/* How could this happen? */\n-\t    error (\"operator `%s' declared void\",\n-\t\t   operator_name_string (declarator));\n-#else\n \t    my_friendly_abort (356);\n-#endif\n \t  else\n \t    error (\"variable or field `%s' declared void\", name);\n \t}\n@@ -10198,15 +9762,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t}\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n-\t    }\n-#if 0 /* This is too early to check; trailing parms might be merged in by\n-\t duplicate_decls.  */\n-\t\t  else if (any_init)\n-\t\t    {\n-\t\t      error (\"all trailing parameters must have default arguments\");\n-\t\t      any_error = 1;\n \t\t    }\n-#endif\n \t\t}\n \t      else\n \t\tinit = NULL_TREE;\n@@ -10502,10 +10058,6 @@ grok_op_properties (decl, virtualp, friendp)\n \t      if (TREE_CODE (parmtype) != REFERENCE_TYPE\n \t\t  || TYPE_READONLY (TREE_TYPE (parmtype)))\n \t\tTYPE_HAS_CONST_ASSIGN_REF (current_class_type) = 1;\n-#if 0 /* Too soon; done in grok_function_init */\n-\t      if (DECL_ABSTRACT_VIRTUAL_P (decl))\n-\t\tTYPE_HAS_ABSTRACT_ASSIGN_REF (current_class_type) = 1;\n-#endif\n \t    }\n \t}\n       else if (name == ansi_opname[(int) COND_EXPR])\n@@ -10697,8 +10249,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t     done in `start_enum'.  */\n \n \t  pushtag (name, ref, globalize);\n-\t  if (flag_cadillac)\n-\t    cadillac_start_enum (ref);\n \t}\n       else\n \t{\n@@ -10723,9 +10273,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n #endif\n \t  pushtag (name, ref, globalize);\n \t  class_binding_level = old_b;\n-\n-\t  if (flag_cadillac)\n-\t    cadillac_start_struct (ref);\n \t}\n     }\n   else\n@@ -10735,31 +10282,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n       if (b == global_binding_level && !class_binding_level\n \t  && IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE)\n \tIDENTIFIER_GLOBAL_VALUE (name) = TYPE_NAME (ref);\n-\n-#if 0\n-      if (binfo)\n-\t{\n-\t  tree tt1 = binfo;\n-\t  tree tt2 = TYPE_BINFO_BASETYPES (ref);\n-\n-\t  if (TYPE_BINFO_BASETYPES (ref))\n-\t    for (i = 0; tt1; i++, tt1 = TREE_CHAIN (tt1))\n-\t      if (TREE_VALUE (tt1) != TYPE_IDENTIFIER (BINFO_TYPE (TREE_VEC_ELT (tt2, i))))\n-\t\t{\n-\t\t  cp_error (\"redeclaration of derivation chain of type `%#T'\",\n-\t\t\t    ref);\n-\t\t  break;\n-\t\t}\n-\n-\t  if (tt1 == NULL_TREE)\n-\t    /* The user told us something we already knew.  */\n-\t    goto just_return;\n-\n-\t  /* In C++, since these migrate into the global scope, we must\n-\t     build them on the permanent obstack.  */\n-\t  end_temporary_allocation ();\n-\t}\n-#endif\n     }\n \n   if (binfo)\n@@ -10876,17 +10398,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t  BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n \n \t  SET_CLASSTYPE_MARKED (basetype);\n-#if 0\n-\t  /* XYZZY TEST VIRTUAL BASECLASSES */\n-\t  if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE\n-\t      && TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)\n-\t      && via_virtual == 0)\n-\t    {\n-\t      warning (\"making type `%s' a virtual baseclass\",\n-\t\t       TYPE_NAME_STRING (basetype));\n-\t      via_virtual = 1;\n-\t    }\n-#endif\n+\n \t  /* We are free to modify these bits because they are meaningless\n \t     at top level, and BASETYPE is a top-level type.  */\n \t  if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n@@ -10958,22 +10470,6 @@ start_enum (name)\n     TREE_ADDRESSABLE (b->tags) = 1;\n   current_local_enum = NULL_TREE;\n \n-#if 0 /* This stuff gets cleared in finish_enum anyway.  */\n-  if (TYPE_VALUES (enumtype) != NULL_TREE)\n-    /* Completely replace its old definition.\n-       The old enumerators remain defined, however.  */\n-    TYPE_VALUES (enumtype) = NULL_TREE;\n-\n-  /* Initially, set up this enum as like `int'\n-     so that we can create the enumerators' declarations and values.\n-     Later on, the precision of the type may be changed and\n-     it may be laid out again.  */\n-\n-  TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n-  TYPE_SIZE (enumtype) = NULL_TREE;\n-  fixup_signed_type (enumtype);\n-#endif\n-\n   /* We copy this value because enumerated type constants\n      are really of the type of the enumerator, not integer_type_node.  */\n   enum_next_value = copy_node (integer_zero_node);\n@@ -11050,9 +10546,6 @@ finish_enum (enumtype, values)\n     layout_type (enumtype);\n   }\n \n-  if (flag_cadillac)\n-    cadillac_finish_enum (enumtype);\n-\n   {\n     register tree tem;\n     \n@@ -11072,12 +10565,7 @@ finish_enum (enumtype, values)\n   }\n \n   /* Finish debugging output for this type.  */\n-#if 0\n-  /* @@ Do we ever generate generate ENUMERAL_TYPE nodes for which debugging\n-     information should *not* be generated?  I think not.  */\n-  if (! DECL_IGNORED_P (TYPE_NAME (enumtype)))\n-#endif\n-    rest_of_type_compilation (enumtype, global_bindings_p ());\n+  rest_of_type_compilation (enumtype, global_bindings_p ());\n \n   return enumtype;\n }\n@@ -11259,8 +10747,6 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n   current_function_just_assigned_this = 0;\n   current_function_parms_stored = 0;\n   original_result_rtx = NULL_RTX;\n-  current_function_obstack_index = 0;\n-  current_function_obstack_usage = 0;\n   base_init_expr = NULL_TREE;\n   protect_list = NULL_TREE;\n   current_base_init_list = NULL_TREE;\n@@ -11390,10 +10876,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \n   current_function_decl = decl1;\n \n-  if (flag_cadillac)\n-    cadillac_start_function (decl1);\n-  else\n-    announce_function (decl1);\n+  announce_function (decl1);\n \n   if (TYPE_SIZE (TREE_TYPE (fntype)) == NULL_TREE)\n     {\n@@ -11683,12 +11166,7 @@ store_parm_decls ()\n \t      tree cleanup = maybe_build_cleanup (parm);\n \t      if (DECL_NAME (parm) == NULL_TREE)\n \t\t{\n-#if 0\n-\t\t  cp_error_at (\"parameter name omitted\", parm);\n-#else\n-\t\t  /* for C++, this is not an error.  */\n \t\t  pushdecl (parm);\n-#endif\n \t\t}\n \t      else if (TYPE_MAIN_VARIANT (TREE_TYPE (parm)) == void_type_node)\n \t\tcp_error (\"parameter `%D' declared void\", parm);\n@@ -11763,13 +11241,6 @@ store_parm_decls ()\n \n   current_function_parms_stored = 1;\n \n-  if (flag_gc)\n-    {\n-      maybe_gc_cleanup = build_tree_list (NULL_TREE, error_mark_node);\n-      if (! cp_expand_decl_cleanup (NULL_TREE, maybe_gc_cleanup))\n-\tcp_error (\"parser lost in parsing declaration of `%D'\", fndecl);\n-    }\n-\n   /* If this function is `main', emit a call to `__main'\n      to run global initializers, etc.  */\n   if (DECL_NAME (fndecl)\n@@ -11778,15 +11249,6 @@ store_parm_decls ()\n       && DECL_CONTEXT (fndecl) == NULL_TREE)\n     {\n       expand_main_function ();\n-\n-      if (flag_gc)\n-\texpand_expr (build_function_call (lookup_name (get_identifier (\"__gc_main\"), 0), NULL_TREE),\n-\t\t     0, VOIDmode, 0);\n-#if 0\n-      /* done at a different time */\n-      if (flag_rtti)\n-\toutput_builtin_tdesc_entries ();\n-#endif\n     }\n \n   /* Take care of exception handling things. */\n@@ -12085,7 +11547,7 @@ finish_function (lineno, call_poplevel, nested)\n \t  expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_decl);\n \n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t    expand_indirect_vtbls_init (binfo, C_C_D, current_class_decl, 0);\n+\t    expand_indirect_vtbls_init (binfo, C_C_D, current_class_decl);\n \t}\n \n       if (! ok_to_optimize_dtor)\n@@ -12168,12 +11630,6 @@ finish_function (lineno, call_poplevel, nested)\n \t  expand_end_cond ();\n \t}\n \n-#if 0\n-      if (DECL_NAME (fndecl) == NULL_TREE\n-\t  && TREE_CHAIN (DECL_ARGUMENTS (fndecl)) != NULL_TREE)\n-\tbuild_default_constructor (fndecl);\n-#endif\n-\n       /* Emit insns from `emit_base_init' which sets up virtual\n \t function table pointer(s).  */\n       if (base_init_expr)\n@@ -12233,9 +11689,6 @@ finish_function (lineno, call_poplevel, nested)\n \t   && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n     no_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n-  if (flag_gc)\n-    expand_gc_prologue_and_epilogue ();\n-\n   /* If this function is supposed to return a value, ensure that\n      we do not fall into the cleanups by mistake.  The end of our\n      function will look like this:\n@@ -12378,9 +11831,6 @@ finish_function (lineno, call_poplevel, nested)\n   if (! nested)\n     permanent_allocation (1);\n \n-  if (flag_cadillac)\n-    cadillac_finish_function (fndecl);\n-\n   if (DECL_SAVED_INSNS (fndecl) == NULL_RTX)\n     {\n       /* Stop pointing to the local nodes about to be freed.  */\n@@ -12781,9 +12231,6 @@ finish_stmt ()\n       check_base_init (current_class_type);\n     }\n   current_function_assigns_this = 1;\n-\n-  if (flag_cadillac)\n-    cadillac_finish_stmt ();\n }\n \n /* Change a static member function definition into a FUNCTION_TYPE, instead\n@@ -12915,17 +12362,6 @@ pop_cp_function_context (context)\n       SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link)),\n \t\t\t\t  TREE_VALUE (link));\n \n-#if 0\n-  if (DECL_SAVED_INSNS (current_function_decl) == 0)\n-    {\n-      /* Stop pointing to the local nodes about to be freed.  */\n-      /* But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition.  */\n-      DECL_INITIAL (current_function_decl) = error_mark_node;\n-      DECL_ARGUMENTS (current_function_decl) = 0;\n-    }\n-#endif\n-\n   pop_function_context_from (context);\n \n   cp_function_chain = p->next;"}, {"sha": "58cdf5cca35eb1c95524250b281d98160c4667ac", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -306,14 +306,6 @@ int flag_default_inline = 1;\n    0 means enums can convert to ints, but not vice-versa.  */\n int flag_int_enum_equivalence;\n \n-/* Controls whether compiler is operating under LUCID's Cadillac\n-   system.  1 means yes, 0 means no.  */\n-int flag_cadillac;\n-\n-/* Controls whether compiler generates code to build objects\n-   that can be collected when they become garbage.  */\n-int flag_gc;\n-\n /* Controls whether compiler generates 'type descriptor' that give\n    run-time type information.  */\n int flag_rtti;\n@@ -404,7 +396,6 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"default-inline\", &flag_default_inline, 1},\n   {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n   {\"enum-int-equiv\", &flag_int_enum_equivalence, 1},\n-  {\"gc\", &flag_gc, 1},\n   {\"rtti\", &flag_rtti, 1},\n   {\"xref\", &flag_gnu_xref, 1},\n   {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n@@ -474,30 +465,6 @@ lang_decode_option (p)\n \t  flag_save_memoized_contexts = 0;\n \t  found = 1;\n \t}\n-      else if (! strncmp (p, \"cadillac\", 8))\n-\t{\n-\t  flag_cadillac = atoi (p+9);\n-\t  found = 1;\n-\t}\n-      else if (! strncmp (p, \"no-cadillac\", 11))\n-\t{\n-\t  flag_cadillac = 0;\n-\t  found = 1;\n-\t}\n-      else if (! strcmp (p, \"gc\"))\n-\t{\n-\t  flag_gc = 1;\n-\t  /* This must come along for the ride.  */\n-\t  flag_rtti = 1;\n-\t  found = 1;\n-\t}\n-      else if (! strcmp (p, \"no-gc\"))\n-\t{\n-\t  flag_gc = 0;\n-\t  /* This must come along for the ride.  */\n-\t  flag_rtti = 0;\n-\t  found = 1;\n-\t}\n       else if (! strcmp (p, \"alt-external-templates\"))\n \t{\n \t  flag_external_templates = 1;\n@@ -1411,9 +1378,6 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n       return void_type_node;\n     }\n \n-  if (flag_cadillac)\n-    cadillac_start_decl (value);\n-\n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n@@ -1955,57 +1919,6 @@ grok_function_init (decl, init)\n     cp_error (\"invalid initializer for virtual method `%D'\", decl);\n }\n \f\n-/* When we get a declaration of the form\n-\n-   type cname::fname ...\n-\n-   the node for `cname::fname' gets built here in a special way.\n-   Namely, we push into `cname's scope.  When this declaration is\n-   processed, we pop back out.  */\n-tree\n-build_push_scope (cname, name)\n-     tree cname;\n-     tree name;\n-{\n-  extern int current_class_depth;\n-  tree ctype, rval;\n-  int is_ttp = 0;\n-\n-  if (cname == error_mark_node)\n-    return error_mark_node;\n-\n-  ctype = IDENTIFIER_TYPE_VALUE (cname);\n-\n-  if (TREE_CODE (ctype) == TEMPLATE_TYPE_PARM)\n-    is_ttp = 1;\n-  else if (ctype == NULL_TREE || ! IS_AGGR_TYPE (ctype))\n-    {\n-      cp_error (\"`%T' not defined as aggregate type\", cname);\n-      return name;\n-    }\n-  else if (IS_SIGNATURE (ctype))\n-    {\n-      error (\"cannot push into signature scope, scope resolution operator ignored\");\n-      return name;\n-    }\n-\n-  rval = build_parse_node (SCOPE_REF, cname, name);\n-\n-  /* Don't need to push the scope if we're already in it.\n-     We also don't need to push the scope for a ptr-to-member/method.  */\n-\n-  if (ctype == current_class_type || TREE_CODE (name) != IDENTIFIER_NODE\n-      || is_ttp)\n-    return rval;\n-\n-  /* We do need to push the scope in this case, since CTYPE helps\n-     determine subsequent initializers (i.e., Foo::Bar x = foo_enum_1;).  */\n-\n-  push_nested_class (ctype, 3);\n-  TREE_COMPLEXITY (rval) = current_class_depth;\n-  return rval;\n-}\n-\n void\n cplus_decl_attributes (decl, attributes, prefix_attributes)\n      tree decl, attributes, prefix_attributes;\n@@ -2189,9 +2102,6 @@ get_temp_regvar (type, init)\n   expand_decl (decl);\n   expand_decl_init (decl);\n \n-  if (type_needs_gc_entry (type))\n-    DECL_GC_OFFSET (decl) = size_int (++current_function_obstack_index);\n-\n   return decl;\n }\n \n@@ -2287,9 +2197,6 @@ finish_anon_union (anon_union_decl)\n   /* The following call assumes that there are never any cleanups\n      for anonymous unions--a reasonable assumption.  */\n   expand_anon_union_decl (anon_union_decl, NULL_TREE, elems);\n-\n-  if (flag_cadillac)\n-    cadillac_finish_anon_union (anon_union_decl);\n }\n \n /* Finish and output a table which is generated by the compiler."}, {"sha": "2fd5e6e6e99c1f01150b21af427bfdf4a6ddace5", "filename": "gcc/cp/except.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -481,12 +481,6 @@ push_eh_entry (stack)\n   struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));\n   struct ehEntry *entry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));\n \n-  if (stack == NULL) {\n-    free (node);\n-    free (entry);\n-    return NULL_RTX;\n-  }\n-\n   /* These are saved for the exception table.  */\n   push_rtl_perm ();\n   entry->start_label = gen_label_rtx ();\n@@ -510,22 +504,20 @@ push_eh_entry (stack)\n   return entry->start_label;\n }\n \n+/* Pop an entry from the given STACK.  */\n static struct ehEntry *\n pop_eh_entry (stack)\n      struct ehStack *stack;\n {\n   struct ehNode *tempnode;\n   struct ehEntry *tempentry;\n+  \n+  tempnode = stack->top;\n+  tempentry = tempnode->entry;\n+  stack->top = stack->top->chain;\n+  free (tempnode);\n \n-  if (stack && (tempnode = stack->top)) {\n-    tempentry = tempnode->entry;\n-    stack->top = stack->top->chain;\n-    free (tempnode);\n-\n-    return tempentry;\n-  }\n-\n-  return NULL;\n+  return tempentry;\n }\n \n static struct ehEntry *\n@@ -742,29 +734,29 @@ init_exception_processing ()\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_pc\"));\n   d = start_decl (d, declspecs, 0, NULL_TREE);\n   DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_pc = lookup_name (get_identifier (\"__eh_pc\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_type\"));\n   d = start_decl (d, declspecs, 0, NULL_TREE);\n   DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_throw_type = lookup_name (get_identifier (\"__eh_type\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_value\"));\n   d = start_decl (d, declspecs, 0, NULL_TREE);\n   DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_throw_value = lookup_name (get_identifier (\"__eh_value\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_cleanup\"));\n   d = build_parse_node (CALL_EXPR, d, void_list_node, NULL_TREE);\n   d = start_decl (d, declspecs, 0, NULL_TREE);\n   DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_cleanup = lookup_name (get_identifier (\"__eh_cleanup\"), 0);\n }\n "}, {"sha": "814aa3862de973c3a288e511ea8e01c2211ccc76", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -358,6 +358,7 @@ extract_init (decl, init)\n {\n   return 0;\n \n+#if 0\n   if (IS_AGGR_TYPE (TREE_TYPE (decl))\n       || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n     init = extract_aggr_init (decl, init);\n@@ -369,4 +370,5 @@ extract_init (decl, init)\n \n   DECL_INITIAL (decl) = init;\n   return 1;\n+#endif\n }"}, {"sha": "bc0dc51c54ae16a97590ab7f9bdf1d4bc81b664e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 317, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -62,11 +62,8 @@ static void add_friend (), add_friends ();\n /* Cache _builtin_new and _builtin_delete exprs.  */\n static tree BIN, BID, BIVN, BIVD;\n \n-/* Cache the identifier nodes for the two magic field of a new cookie.  */\n+/* Cache the identifier nodes for the magic field of a new cookie.  */\n static tree nc_nelts_field_id;\n-#if 0\n-static tree nc_ptr_2comp_field_id;\n-#endif\n \n static tree minus_one;\n \n@@ -582,7 +579,7 @@ emit_base_init (t, immediately)\n \tcontinue;\n \n #if 0 /* Once unsharing happens soon enough.  */\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo);\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo, 999);\n #else\n       BINFO_INHERITANCE_CHAIN (base_binfo) = t_binfo;\n #endif\n@@ -632,7 +629,7 @@ emit_base_init (t, immediately)\n   /* Initialize all the virtual function table fields that\n      do come from virtual base classes. */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    expand_indirect_vtbls_init (t_binfo, C_C_D, current_class_decl, 0);\n+    expand_indirect_vtbls_init (t_binfo, C_C_D, current_class_decl);\n \n   /* Initialize all the virtual function table fields that\n      do not come from virtual base classes.  */\n@@ -1375,12 +1372,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t  if (TREE_CODE (init_type) == ERROR_MARK)\n \t    return;\n \n-#if 0\n-\t  /* These lines are found troublesome 5/11/89.  */\n-\t  if (TREE_CODE (init_type) == REFERENCE_TYPE)\n-\t    init_type = TREE_TYPE (init_type);\n-#endif\n-\n \t  /* This happens when we use C++'s functional cast notation.\n \t     If the types match, then just use the TARGET_EXPR\n \t     directly.  Otherwise, we need to create the initializer\n@@ -1399,35 +1390,13 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t  expand_expr_stmt (init);\n \t\t  return;\n \t\t}\n-\t      else\n-\t\t{\n-#if 0\n-\t\t  /* This causes testcase return2.C to fail.  */\n-\t\t  init = TREE_OPERAND (init, 1);\n-\t\t  init = build (CALL_EXPR, init_type,\n-\t\t\t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), 0);\n-\t\t  TREE_SIDE_EFFECTS (init) = 1;\n-\t\t    if (init_list)\n-\t\t      TREE_VALUE (init_list) = init;\n-#endif\n-\t\t}\n \t    }\n \n-\t  if (init_type == type && TREE_CODE (init) == CALL_EXPR\n-#if 0\n-\t      /* It is valid to directly initialize from a CALL_EXPR\n-\t\t without going through X(X&), apparently.  */\n-\t      && ! TYPE_GETS_INIT_REF (type)\n-#endif\n-\t      )\n+\t  if (init_type == type && TREE_CODE (init) == CALL_EXPR)\n \t    {\n \t      /* A CALL_EXPR is a legitimate form of initialization, so\n \t\t we should not print this warning message.  */\n-#if 0\n-\t      /* Should have gone away due to 5/11/89 change.  */\n-\t      if (TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE)\n-\t\tinit = convert_from_reference (init);\n-#endif\n+\n \t      expand_assignment (exp, init, 0, 0);\n \t      if (exp == DECL_RESULT (current_function_decl))\n \t\t{\n@@ -1565,148 +1534,9 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t}\n     }\n \n-  /* Handle default copy constructors here, does not matter if there is\n-     a constructor or not.  */\n-  if (type == init_type && IS_AGGR_TYPE (type)\n-      && init && TREE_CODE (init) != TREE_LIST)\n-    expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags);\n-  /* Not sure why this is here... */\n-  else if (TYPE_HAS_CONSTRUCTOR (type))\n-    expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags);\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type)))\n-\texpand_vec_init (exp, exp, array_type_nelts (type), init, 0);\n-      else if (TYPE_VIRTUAL_P (TREE_TYPE (type)))\n-\tsorry (\"arrays of objects with virtual functions but no constructors\");\n-    }\n-  else\n-    expand_recursive_init (binfo, true_exp, exp, init,\n-\t\t\t   CLASSTYPE_BASE_INIT_LIST (type), alias_this);\n-}\n-\n-/* A pointer which holds the initializer.  First call to\n-   expand_aggr_init gets this value pointed to, and sets it to init_null.  */\n-static tree *init_ptr, init_null;\n-\n-/* Subroutine of expand_recursive_init:\n-\n-   ADDR is the address of the expression being initialized.\n-   INIT_LIST is the cons-list of initializations to be performed.\n-   ALIAS_THIS is its same, lovable self.  */\n-static void\n-expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this)\n-     tree binfo, true_exp, addr;\n-     tree init_list;\n-     int alias_this;\n-{\n-  while (init_list)\n-    {\n-      if (TREE_PURPOSE (init_list))\n-\t{\n-\t  if (TREE_CODE (TREE_PURPOSE (init_list)) == FIELD_DECL)\n-\t    {\n-\t      tree member = TREE_PURPOSE (init_list);\n-\t      tree subexp = build_indirect_ref (convert_pointer_to (TREE_VALUE (init_list), addr), NULL_PTR);\n-\t      tree member_base = build (COMPONENT_REF, TREE_TYPE (member), subexp, member);\n-\t      if (IS_AGGR_TYPE (TREE_TYPE (member)))\n-\t\texpand_aggr_init (member_base, DECL_INITIAL (member), 0, 0);\n-\t      else if (TREE_CODE (TREE_TYPE (member)) == ARRAY_TYPE\n-\t\t       && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (member)))\n-\t\t{\n-\t\t  member_base = save_expr (default_conversion (member_base));\n-\t\t  expand_vec_init (member, member_base,\n-\t\t\t\t   array_type_nelts (TREE_TYPE (member)),\n-\t\t\t\t   DECL_INITIAL (member), 0);\n-\t\t}\n-\t      else\n-\t\texpand_expr_stmt (build_modify_expr (member_base, INIT_EXPR, DECL_INITIAL (member)));\n-\t    }\n-\t  else if (TREE_CODE (TREE_PURPOSE (init_list)) == TREE_LIST)\n-\t    {\n-\t      expand_recursive_init_1 (binfo, true_exp, addr, TREE_PURPOSE (init_list), alias_this);\n-\t      expand_recursive_init_1 (binfo, true_exp, addr, TREE_VALUE (init_list), alias_this);\n-\t    }\n-\t  else if (TREE_CODE (TREE_PURPOSE (init_list)) == ERROR_MARK)\n-\t    {\n-\t      /* Only initialize the virtual function tables if we\n-\t\t are initializing the ultimate users of those vtables.  */\n-\t      if (TREE_VALUE (init_list))\n-\t\t{\n-\t\t  /* We have to ensure that the first argment to\n-\t\t     expand_virtual_init is in binfo's hierarchy.  */\n-\t\t  /* Is it the case that this is exactly the right binfo? */\n-\t\t  /* If it is ok, then fixup expand_virtual_init, to make\n-\t\t     it much simpler. */\n-\t\t  expand_virtual_init (get_binfo (TREE_VALUE (init_list), binfo, 0),\n-\t\t\t\t      addr);\n-\t\t  if (TREE_VALUE (init_list) == binfo\n-\t\t      && TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n-\t\t    expand_indirect_vtbls_init (binfo, true_exp, addr, 1);\n-\t\t}\n-\t    }\n-\t  else\n-\t    my_friendly_abort (49);\n-\t}\n-      else if (TREE_VALUE (init_list)\n-\t       && TREE_CODE (TREE_VALUE (init_list)) == TREE_VEC)\n-\t{\n-\t  tree subexp = build_indirect_ref (convert_pointer_to (TREE_VALUE (init_list), addr), NULL_PTR);\n-\t  expand_aggr_init_1 (binfo, true_exp, subexp, *init_ptr,\n-\t\t\t      alias_this && BINFO_OFFSET_ZEROP (TREE_VALUE (init_list)),\n-\t\t\t      LOOKUP_COMPLAIN);\n-\n-\t  /* INIT_PTR is used up.  */\n-\t  init_ptr = &init_null;\n-\t}\n-      else\n-\tmy_friendly_abort (50);\n-      init_list = TREE_CHAIN (init_list);\n-    }\n-}\n-\n-/* Initialize EXP with INIT.  Type EXP does not have a constructor,\n-   but it has a baseclass with a constructor or a virtual function\n-   table which needs initializing.\n-\n-   INIT_LIST is a cons-list describing what parts of EXP actually\n-   need to be initialized.  INIT is given to the *unique*, first\n-   constructor within INIT_LIST.  If there are multiple first\n-   constructors, such as with multiple inheritance, INIT must\n-   be zero or an ambiguity error is reported.\n-\n-   ALIAS_THIS is passed from `expand_aggr_init'.  See comments\n-   there.  */\n-\n-static void\n-expand_recursive_init (binfo, true_exp, exp, init, init_list, alias_this)\n-     tree binfo, true_exp, exp, init;\n-     tree init_list;\n-     int alias_this;\n-{\n-  tree *old_init_ptr = init_ptr;\n-  tree addr = build_unary_op (ADDR_EXPR, exp, 0);\n-  init_ptr = &init;\n-\n-  if (true_exp == exp && TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n-    {\n-      expand_aggr_vbase_init (binfo, exp, addr, init_list);\n-      expand_indirect_vtbls_init (binfo, true_exp, addr, 1);\n-    }\n-  expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this);\n-\n-  if (*init_ptr)\n-    {\n-      tree type = TREE_TYPE (exp);\n-\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\ttype = TREE_TYPE (type);\n-      if (IS_AGGR_TYPE (type))\n-\tcp_error (\"unexpected argument to constructor `%T'\", type);\n-      else\n-\terror (\"unexpected argument to constructor\");\n-    }\n-  init_ptr = old_init_ptr;\n+  /* We know that expand_default_init can handle everything we want\n+     at this point.  */\n+  expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags);\n }\n \n /* Report an error if NAME is not the name of a user-defined,\n@@ -1846,12 +1676,6 @@ build_member_call (type, name, parmlist)\n \n   if (dtor)\n     {\n-#if 0\n-      /* Everything can explicitly call a destructor; see 12.4 */\n-      if (! TYPE_HAS_DESTRUCTOR (type))\n-\tcp_error (\"type `%#T' does not have a destructor\", type);\n-      else\n-#endif\n       cp_error (\"cannot call destructor `%T::~%T' without object\", type,\n \t\tmethod_name);\n       return error_mark_node;\n@@ -2092,11 +1916,6 @@ build_offset_ref (type, name)\n \t\t  || ! allocation_temporary_p ()))\n \t    fnfields = copy_list (fnfields);\n \n-#if 0\n-\t  for (t = TREE_VALUE (fnfields); t; t = DECL_CHAIN (t))\n-\t    assemble_external (t);\n-#endif\n-\n \t  t = build_tree_list (error_mark_node, fnfields);\n \t  TREE_TYPE (t) = build_offset_type (type, unknown_type_node);\n \t  return t;\n@@ -2148,72 +1967,6 @@ build_offset_ref (type, name)\n   return build (OFFSET_REF, build_offset_type (type, TREE_TYPE (t)), decl, t);\n }\n \n-/* Given an object EXP and a member function reference MEMBER,\n-   return the address of the actual member function.  */\n-tree\n-get_member_function (exp_addr_ptr, exp, member)\n-     tree *exp_addr_ptr;\n-     tree exp, member;\n-{\n-  tree ctype = TREE_TYPE (exp);\n-  tree function = save_expr (build_unary_op (ADDR_EXPR, member, 0));\n-\n-  if (TYPE_VIRTUAL_P (ctype)\n-      || (flag_all_virtual == 1 && TYPE_OVERLOADS_METHOD_CALL_EXPR (ctype)))\n-    {\n-      tree e0, e1, e3;\n-      tree exp_addr;\n-\n-      /* Save away the unadulterated `this' pointer.  */\n-      exp_addr = save_expr (*exp_addr_ptr);\n-\n-      /* Cast function to signed integer.  */\n-      e0 = build1 (NOP_EXPR, integer_type_node, function);\n-\n-      /* There is a hack here that takes advantage of\n-\t twos complement arithmetic, and the fact that\n-\t there are more than one UNITS to the WORD.\n-\t If the high bit is set for the `function',\n-\t then we pretend it is a virtual function,\n-\t and the array indexing will knock this bit\n-\t out the top, leaving a valid index.  */\n-      if (UNITS_PER_WORD <= 1)\n-\tmy_friendly_abort (54);\n-\n-      e1 = build (GT_EXPR, boolean_type_node, e0, integer_zero_node);\n-      e1 = build_compound_expr (tree_cons (NULL_TREE, exp_addr,\n-\t\t\t\t\t   build_tree_list (NULL_TREE, e1)));\n-      e1 = save_expr (e1);\n-\n-      if (TREE_SIDE_EFFECTS (*exp_addr_ptr))\n-\t{\n-\t  exp = build_indirect_ref (exp_addr, NULL_PTR);\n-\t  *exp_addr_ptr = exp_addr;\n-\t}\n-\n-      /* This is really hairy: if the function pointer is a pointer\n-\t to a non-virtual member function, then we can't go mucking\n-\t with the `this' pointer (any more than we already have to\n-\t this point).  If it is a pointer to a virtual member function,\n-\t then we have to adjust the `this' pointer according to\n-\t what the virtual function table tells us.  */\n-\n-      e3 = build_vfn_ref (exp_addr_ptr, exp, e0);\n-      my_friendly_assert (e3 != error_mark_node, 213);\n-\n-      /* Change this pointer type from `void *' to the\n-\t type it is really supposed to be.  */\n-      TREE_TYPE (e3) = TREE_TYPE (function);\n-\n-      /* If non-virtual, use what we had originally.  Otherwise,\n-\t use the value we get from the virtual function table.  */\n-      *exp_addr_ptr = build_conditional_expr (e1, exp_addr, *exp_addr_ptr);\n-\n-      function = build_conditional_expr (e1, function, e3);\n-    }\n-  return build_indirect_ref (function, NULL_PTR);\n-}\n-\n /* If a OFFSET_REF made it through to here, then it did\n    not have its address taken.  */\n \n@@ -2317,13 +2070,7 @@ resolve_offset_ref (exp)\n      for the dereferenced pointer-to-member construct.  */\n   addr = build_unary_op (ADDR_EXPR, base, 0);\n \n-  if (TREE_CODE (TREE_TYPE (member)) == METHOD_TYPE)\n-    {\n-      basetype = DECL_CLASS_CONTEXT (member);\n-      addr = convert_pointer_to (basetype, addr);\n-      return build_unary_op (ADDR_EXPR, get_member_function (&addr, build_indirect_ref (addr, NULL_PTR), member), 0);\n-    }\n-  else if (TREE_CODE (TREE_TYPE (member)) == OFFSET_TYPE)\n+  if (TREE_CODE (TREE_TYPE (member)) == OFFSET_TYPE)\n     {\n       basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (member));\n       addr = convert_pointer_to (basetype, addr);\n@@ -2573,14 +2320,8 @@ xref_friend (type, decl, ctype)\n      tree type, decl, ctype;\n {\n   tree friend_decl = TYPE_NAME (ctype);\n-#if 0\n-  tree typedecl = TYPE_NAME (type);\n-  tree t = tree_cons (NULL_TREE, ctype, DECL_UNDEFINED_FRIENDS (typedecl));\n-\n-  DECL_UNDEFINED_FRIENDS (typedecl) = t;\n-#else\n   tree t = 0;\n-#endif\n+\n   SET_DECL_WAITING_FRIENDS (friend_decl,\n \t\t\t    tree_cons (type, t,\n \t\t\t\t       DECL_WAITING_FRIENDS (friend_decl)));\n@@ -2767,9 +2508,6 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n       add_friend (current_class_type, decl);\n \n       DECL_FRIEND_P (decl) = 1;\n-#if 0\n-      TREE_OVERLOADED (declarator) = 1;\n-#endif\n     }\n   else\n     {\n@@ -2820,9 +2558,6 @@ embrace_waiting_friends (type)\n        waiters = TREE_CHAIN (waiters))\n     {\n       tree waiter = TREE_PURPOSE (waiters);\n-#if 0\n-      tree waiter_prev = TREE_VALUE (waiters);\n-#endif\n       tree decl = TREE_TYPE (waiters);\n       tree name = decl ? (TREE_CODE (decl) == IDENTIFIER_NODE\n \t\t\t  ? decl : DECL_NAME (decl)) : NULL_TREE;\n@@ -2846,13 +2581,6 @@ embrace_waiting_friends (type)\n \t}\n       else\n \tmake_friend_class (type, waiter);\n-\n-#if 0\n-      if (TREE_CHAIN (waiter_prev))\n-\tTREE_CHAIN (waiter_prev) = TREE_CHAIN (TREE_CHAIN (waiter_prev));\n-      else\n-\tDECL_UNDEFINED_FRIENDS (TYPE_NAME (waiter)) = NULL_TREE;\n-#endif\n     }\n }\n \f\n@@ -3131,17 +2859,6 @@ build_new (placement, decl, init, use_global_new)\n       rval = build_builtin_call (build_pointer_type (true_type),\n \t\t\t\t has_array ? BIVN : BIN,\n \t\t\t\t build_tree_list (NULL_TREE, size));\n-#if 0\n-      /* See comment above as to why this is disabled.  */\n-      if (alignment)\n-\t{\n-\t  rval = build (PLUS_EXPR, build_pointer_type (true_type), rval,\n-\t\t\talignment);\n-\t  rval = build (BIT_AND_EXPR, build_pointer_type (true_type),\n-\t\t\trval, build1 (BIT_NOT_EXPR, integer_type_node,\n-\t\t\t\t      alignment));\n-\t}\n-#endif\n       TREE_CALLS_NEW (rval) = 1;\n     }\n \n@@ -3361,24 +3078,6 @@ build_new (placement, decl, init, use_global_new)\n     rval = build_compound_expr (chainon (pending_sizes,\n \t\t\t\t\t build_tree_list (NULL_TREE, rval)));\n \n-  if (flag_gc)\n-    {\n-      extern tree gc_visible;\n-      tree objbits;\n-      tree update_expr;\n-\n-      rval = save_expr (rval);\n-      /* We don't need a `headof' operation to do this because\n-\t we know where the object starts.  */\n-      objbits = build1 (INDIRECT_REF, unsigned_type_node,\n-\t\t\tbuild (MINUS_EXPR, ptr_type_node,\n-\t\t\t       rval, c_sizeof_nowarn (unsigned_type_node)));\n-      update_expr = build_modify_expr (objbits, BIT_IOR_EXPR, gc_visible);\n-      rval = build_compound_expr (tree_cons (NULL_TREE, rval,\n-\t\t\t\t\t     tree_cons (NULL_TREE, update_expr,\n-\t\t\t\t\t\t\tbuild_tree_list (NULL_TREE, rval))));\n-    }\n-\n   return rval;\n }\n \f\n@@ -3988,11 +3687,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n \t\t @@ Does this really need to be done?  */\n \t      tree ifexp = build_binary_op(NE_EXPR, addr, integer_zero_node,1);\n-#if 0\n-\t      if (TREE_CODE (ref) == VAR_DECL\n-\t\t  || TREE_CODE (ref) == COMPONENT_REF)\n-\t\twarning (\"losing in build_delete\");\n-#endif\n+\n \t      expr = build (COND_EXPR, void_type_node,\n \t\t\t    ifexp, expr, void_zero_node);\n \t    }\n@@ -4228,7 +3923,8 @@ build_vec_delete (base, maxindex, elt_size, auto_delete_vec, auto_delete,\n     }\n   else\n     {\n-      error (\"type to vector delete is neither pointer or array type\");\n+      if (base != error_mark_node)\n+\terror (\"type to vector delete is neither pointer or array type\");\n       return error_mark_node;\n     }\n "}, {"sha": "627189cb3d7e59cf5099afefbc0419e36e1a25bd", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -32,8 +32,6 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-alt-external-templates\",\n   \"-fansi-overloading\",\n   \"-fno-ansi-overloading\",\n-  \"-fcadillac\",\n-  \"-fno-cadillac\",\n   \"-fcheck-new\",\n   \"-fno-check-new\",\n   \"-fconserve-space\",\n@@ -50,8 +48,6 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-external-templates\",\n   \"-ffor-scope\",\n   \"-fno-for-scope\",\n-  \"-fgc\",\n-  \"-fno-gc\",\n   \"-fgnu-keywords\",\n   \"-fno-gnu-keywords\",\n   \"-fhandle-exceptions\","}, {"sha": "8fca04ff769bf5051c18b5ffc2d900b66671ad68", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -360,9 +360,6 @@ lang_init ()\n   /* With luck, we discover the real source file's name from that\n      and put it in input_filename.  */\n   put_back (check_newline ());\n-\n-  if (flag_cadillac)\n-    cadillac_start ();\n   if (flag_gnu_xref) GNU_xref_begin (input_filename);\n   init_repo (input_filename);\n }\n@@ -793,7 +790,7 @@ init_lex ()\n     }\n #endif\n \n-  if (! (flag_gc || flag_rtti) || flag_no_gnu_keywords)\n+  if (!flag_rtti || flag_no_gnu_keywords)\n     {\n       UNSET_RESERVED_WORD (\"classof\");\n       UNSET_RESERVED_WORD (\"headof\");\n@@ -1129,7 +1126,7 @@ do_pending_inlines ()\n   /* Reverse the pending inline functions, since\n      they were cons'd instead of appended.  */\n   {\n-    struct pending_inline *prev = 0, *tail, *bottom = 0;\n+    struct pending_inline *prev = 0, *tail;\n     t = pending_inlines;\n     pending_inlines = 0;\n \n@@ -1140,33 +1137,6 @@ do_pending_inlines ()\n \tt->deja_vu = 1;\n \tprev = t;\n       }\n-\n-    /* This kludge should go away when synthesized methods are handled\n-       properly, i.e. only when needed.  */\n-    for (t = prev; t; t = t->next)\n-      {\n-\tif (t->lineno <= 0)\n-\t  {\n-\t    tree f = t->fndecl;\n-\t    DECL_PENDING_INLINE_INFO (f) = 0;\n-\t    interface_unknown = t->interface == 1;\n-\t    interface_only = t->interface == 0;\n-\t    synthesize_method (f);\n-\t    if (tail)\n-\t      tail->next = t->next;\n-\t    else\n-\t      prev = t->next;\n-\t    if (! bottom)\n-\t      bottom = t;\n-\t  }\n-\telse\n-\t  tail = t;\n-      }\n-    if (bottom)\n-      {\n-\tobstack_free (&synth_obstack, bottom);\n-\textract_interface_info ();\n-      }\n     t = prev;\n   }\n \n@@ -2491,9 +2461,6 @@ check_newline ()\n \t  body_time = this_time;\n \t}\n \n-      if (flag_cadillac)\n-\tcadillac_note_source ();\n-\n       input_filename\n \t= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);\n       strcpy (input_filename, TREE_STRING_POINTER (yylval.ttype));\n@@ -2607,8 +2574,6 @@ check_newline ()\n \t\t  && write_symbols == DWARF_DEBUG)\n \t\tdwarfout_start_new_source_file (input_filename);\n #endif /* DWARF_DEBUGGING_INFO */\n-\t      if (flag_cadillac)\n-\t\tcadillac_push_source ();\n \t      in_system_header = entering_system_header;\n \t      if (c_header_level)\n \t\t++c_header_level;\n@@ -2631,8 +2596,6 @@ check_newline ()\n \t\t\twarning (\"badly nested C headers from preprocessor\");\n \t\t      --pending_lang_change;\n \t\t    }\n-\t\t  if (flag_cadillac)\n-\t\t    cadillac_pop_source ();\n \t\t  in_system_header = entering_system_header;\n \n \t\t  p = input_file_stack;\n@@ -2653,11 +2616,7 @@ check_newline ()\n \t\terror (\"#-lines for entering and leaving files don't match\");\n \t    }\n \t  else\n-\t    {\n-\t      in_system_header = entering_system_header;\n-\t      if (flag_cadillac)\n-\t\tcadillac_switch_source (-1);\n-\t    }\n+\t    in_system_header = entering_system_header;\n \t}\n \n       /* If NEXTCHAR is not end of line, we don't care what it is.  */"}, {"sha": "7d9497257280dd7fe8e1f500bed8c9bb26c4123c", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -929,21 +929,6 @@ build_static_name (basetype, name)\n   return get_identifier (buf);\n }  \n \f\n-/* Generate an identifier that encodes the (ANSI) exception TYPE. */\n-\n-/* This should be part of `ansi_opname', or at least be defined by the std.  */\n-#define EXCEPTION_NAME_PREFIX \"__ex\"\n-#define EXCEPTION_NAME_LENGTH 4\n-\n-tree\n-cplus_exception_name (type)\n-     tree type;\n-{\n-  OB_INIT ();\n-  OB_PUTS (EXCEPTION_NAME_PREFIX);\n-  return get_identifier (build_overload_name (type, 0, 1));\n-}\n-\f\n /* Change the name of a function definition so that it may be\n    overloaded. NAME is the name of the function to overload,\n    PARMS is the parameter list (which determines what name the"}, {"sha": "d40424c78e98d35ba1dc4450edb4dbc94082df19", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -510,7 +510,7 @@ template_def:\n \t\t  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0,\n \t\t\t\t  $3);\n \t\t  cplus_decl_attributes (d, $5, /*prefix_attributes*/NULL_TREE);\n-\t\t  cp_finish_decl (d, NULL_TREE, $4, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, $4, 1, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    reinit_parse_for_template ((int) $6, $1, d);\n@@ -527,7 +527,7 @@ template_def:\n \t\t  momentary = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>3, specs, 0, $<ttype>4);\n \t\t  cplus_decl_attributes (d, $6, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, $5, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, $5, 1, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    {\n@@ -544,7 +544,7 @@ template_def:\n \t\t  split_specs_attrs ($2, &specs, &attrs);\n \t\t  d = start_decl ($<ttype>3, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    reinit_parse_for_template ((int) $4, $1, d);\n@@ -572,7 +572,7 @@ datadef:\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n \t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n@@ -584,7 +584,7 @@ datadef:\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n \t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t  note_list_got_semicolon ($<ttype>$);\n \t\t}\n         | declmods ';'\n@@ -996,7 +996,7 @@ condition:\n \t\t}\n \tinit\n \t\t{ \n-\t\t  cp_finish_decl ($<ttype>7, $8, $5, 0, LOOKUP_ONLYCONVERTING);\n+\t\t  cp_finish_decl ($<ttype>7, $8, $5, 1, LOOKUP_ONLYCONVERTING);\n \t\t  resume_momentary ($<itype>6);\n \t\t  $$ = $<ttype>7; \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n@@ -1729,7 +1729,7 @@ decl:\n \t\t{ tree d = get_decl_list ($1);\n \t\t  int yes = suspend_momentary ();\n \t\t  d = start_decl ($2, d, 0, NULL_TREE);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t  resume_momentary (yes);\n \t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n \t\t    note_got_semicolon ($1);\n@@ -1741,7 +1741,7 @@ decl:\n \t\t  yes = suspend_momentary ();\n \t\t  d = start_decl ($2, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t  resume_momentary (yes);\n \t\t  note_list_got_semicolon ($1);\n \t\t}\n@@ -1985,7 +1985,7 @@ initdcl0:\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n+\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n \t| declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n@@ -2003,7 +2003,7 @@ initdcl0:\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $3, 0, 0); }\n+\t\t  cp_finish_decl (d, NULL_TREE, $3, 1, 0); }\n \t;\n \n initdcl:\n@@ -2012,11 +2012,11 @@ initdcl:\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING); }\n+\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING); }\n \t| declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes);\n-\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $3, 0, 0); }\n+\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $3, 1, 0); }\n \t;\n \n notype_initdcl0:\n@@ -2028,7 +2028,7 @@ notype_initdcl0:\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n+\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n@@ -2037,7 +2037,7 @@ notype_initdcl0:\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $3, 0, 0); }\n+\t\t  cp_finish_decl (d, NULL_TREE, $3, 1, 0); }\n \t;\n \n nomods_initdcl0:\n@@ -2049,7 +2049,7 @@ nomods_initdcl0:\n \t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n+\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n \t\t{ tree d;\n@@ -2058,7 +2058,7 @@ nomods_initdcl0:\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $3, 0, 0); }\n+\t\t  cp_finish_decl (d, NULL_TREE, $3, 1, 0); }\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax"}, {"sha": "97160ad1c4889263b36c057b59eb06d56ab55efe", "filename": "gcc/cp/search.c", "status": "modified", "additions": 13, "deletions": 105, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -440,34 +440,6 @@ convert_pointer_to_vbase (type, expr)\n   return convert_pointer_to_real (vb, expr);\n }\n \n-/* This is the newer recursive depth first search routine. */\n-#if 0\t\t\t\t/* unused */\n-/* Return non-zero if PARENT is directly derived from TYPE.  By directly\n-   we mean it's only one step up the inheritance lattice.  We check this\n-   by walking horizontally across the types that TYPE directly inherits\n-   from, to see if PARENT is among them.  This is used by get_binfo and\n-   by compute_access.  */\n-static int\n-immediately_derived (parent, type)\n-     tree parent, type;\n-{\n-  if (TYPE_BINFO (type))\n-    {\n-      tree binfos = BINFO_BASETYPES (TYPE_BINFO (type));\n-      int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-      for (i = 0; i < n_baselinks; i++)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-\t  if (parent == BINFO_TYPE (base_binfo))\n-\t    return 1;\n-\t}\n-    }\n-  return 0;\n-}\n-#endif\n-\n /* Check whether the type given in BINFO is derived from PARENT.  If\n    it isn't, return 0.  If it is, but the derivation is MI-ambiguous\n    AND protect != 0, emit an error message and return error_mark_node.\n@@ -1320,7 +1292,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    {\n \t      /* This is ambiguous. */\n \t      errstr = \"request for member `%D' is ambiguous\";\n-\t      protect = 2;\n+\t      protect += 2;\n \t      break;\n \t    }\n \t}\n@@ -1426,6 +1398,14 @@ lookup_field (xbasetype, name, protect, want_type)\n \t}\n     }\n \n+  if (protect == 2)\n+    {\n+      /* If we are not interested in ambiguities, don't report them,\n+\t just return NULL_TREE.  */\n+      rval = NULL_TREE;\n+      protect = 0;\n+    }\n+\n   if (errstr && protect)\n     {\n       cp_error (errstr, name, type);\n@@ -1911,16 +1891,6 @@ breadth_first_search (binfo, testfn, qfn)\n typedef tree (*pft)();\n typedef int (*pfi)();\n \n-int tree_needs_constructor_p (binfo, i)\n-     tree binfo;\n-     int i;\n-{\n-  tree basetype;\n-  my_friendly_assert (i != 0, 296);\n-  basetype = BINFO_TYPE (BINFO_BASETYPE (binfo, i));\n-  return TYPE_NEEDS_CONSTRUCTING (basetype);\n-}\n-\n static tree declarator;\n \n static tree\n@@ -2098,8 +2068,6 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t      break;\n \t    }\n \t}\n-      if (best == NULL_TREE && warn_overloaded_virtual)\n-\tcp_warning_at (\"conflicting specification deriving virtual function `%D'\", fndecl);\n \n       return best;\n     }\n@@ -2836,76 +2804,35 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n    ICK!  */\n \n void\n-expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n+expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n      tree binfo;\n      tree true_exp, decl_ptr;\n-     int use_computed_offsets;\n {\n   tree type = BINFO_TYPE (binfo);\n+\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       rtx fixup_insns = NULL_RTX;\n-      int old_flag = flag_this_is_variable;\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n       vbase_types = vbases;\n       vbase_decl_ptr = true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) : decl_ptr;\n       vbase_decl = true_exp ? true_exp : build_indirect_ref (decl_ptr, NULL_PTR);\n \n-      if (use_computed_offsets)\n-\t{\n-\t  /* This is an object of type IN_TYPE,  */\n-\t  flag_this_is_variable = -2;\n-\t}\n-\n       dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep);\n \n       /* Initialized with vtables of type TYPE.  */\n       for (; vbases; vbases = TREE_CHAIN (vbases))\n \t{\n \t  tree addr;\n-\t  if (use_computed_offsets)\n-\t    addr = (tree)CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbases));\n-\t  else\n-\t    {\n-#if 1\n-\t      addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vbase_decl_ptr);\n-#else\n-\t      /* This should should never work better than the above.  (mrs) */\n-\t      tree vbinfo = get_binfo (TREE_TYPE (vbases),\n-\t\t\t\t       TREE_TYPE (vbase_decl),\n-\t\t\t\t       0);\n-\n-\t      /* See is we can get lucky.  */\n-\t      if (TREE_VIA_VIRTUAL (vbinfo))\n-\t\taddr = convert_pointer_to_real (vbinfo, vbase_decl_ptr);\n-\t      else\n-\t\t{\n-\t\t  /* We go through all these contortions to avoid this\n-\t\t     call, as it will fail when the virtual base type\n-\t\t     is ambiguous from here.  We don't yet have a way\n-\t\t     to search for and find just an instance of the\n-\t\t     virtual base class.  Searching for the binfo in\n-\t\t     vbases won't work, as we don't have the vbase\n-\t\t     pointer field, for all vbases in the main class,\n-\t\t     only direct vbases.  */\n-\t\t  addr = convert_pointer_to_real (TREE_TYPE (vbases),\n-\t\t\t\t\t\t  vbase_decl_ptr);\n-\t\t  if (addr == error_mark_node)\n-\t\t    continue;\n-\t\t}\n-#endif\n-\t    }\n+\n+\t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vbase_decl_ptr);\n \n \t  /* Do all vtables from this virtual base. */\n \t  /* This assumes that virtual bases can never serve as parent\n \t     binfos.  (in the CLASSTPE_VFIELD_PARENT sense)  */\n \t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n \t\t\t\t    1, 0, addr);\n \n-\t  /* If we are using computed offsets we can skip fixups.  */\n-\t  if (use_computed_offsets)\n-\t    continue;\n-\n \t  /* Now we adjust the offsets for virtual functions that cross\n \t     virtual boundaries on an implicit upcast on vf call so that\n \t     the layout of the most complete type is used, instead of\n@@ -2944,19 +2871,9 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr, use_computed_offsets)\n \t}\n \n       dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep);\n-\n-      flag_this_is_variable = old_flag;\n     }\n }\n \n-void\n-clear_search_slots (type)\n-     tree type;\n-{\n-  dfs_walk (TYPE_BINFO (type),\n-\t    dfs_clear_search_slot, dfs_search_slot_nonempty_p);\n-}\n-\n /* get virtual base class types.\n    This adds type to the vbase_types list in reverse dfs order.\n    Ordering is very important, so don't change it.  */\n@@ -3359,15 +3276,6 @@ push_class_decls (type)\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n   id = TYPE_IDENTIFIER (type);\n-#if 0\n-  if (IDENTIFIER_TEMPLATE (id) != 0)\n-    {\n-      tree tmpl = IDENTIFIER_TEMPLATE (id);\n-      push_template_decls (DECL_ARGUMENTS (TREE_PURPOSE (tmpl)),\n-\t\t\t   TREE_VALUE (tmpl), 1);\n-      overload_template_name (id, 1);\n-    }\n-#endif\n \n   /* Push class fields into CLASS_VALUE scope, and mark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarkedp);"}, {"sha": "a0250e575863cfadf2f1e4d27777dc869b2cd315", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -182,36 +182,6 @@ scan_tokens (n)\n     }\n }\n \n-/* Create room for N tokens at the front of the fifo.  This is used\n-   to insert new tokens into the stream ahead of the current token.  */\n-\n-static void\n-shift_tokens (n)\n-     int n;\n-{\n-  if (first_token >= n)\n-    first_token -= n;\n-  else\n-    {\n-      int old_token_count = num_tokens ();\n-      char *tmp;\n-\n-      obstack_blank (&token_obstack, (n-first_token) * sizeof (struct token));\n-      if (old_token_count)\n-\t{\n-\t  tmp = (char *)alloca ((num_tokens () + (n-first_token))\n-\t\t\t\t* sizeof (struct token));\n-\t  /* This move does not rely on the system being able to handle\n-\t     overlapping moves.  */\n-\t  bcopy ((char *) nth_token (0), tmp,\n-\t\t old_token_count * sizeof (struct token));\n-\t  bcopy (tmp, (char *) nth_token (n),\n-\t\t old_token_count * sizeof (struct token));\n-\t}\n-      first_token = 0;\n-    }\n-}\n-\n static int\n probe_obstack (h, obj, nlevels)\n      struct obstack *h;\n@@ -360,10 +330,12 @@ yylex()\n       break;\n \n     case SCSPEC:\n-      /* do_aggr needs to check if the previous token was RID_FRIEND,\n-\t so just increment first_token instead of calling consume_token. */\n-      first_token++;\n+    case NEW:\n+      /* do_aggr needs to check if the previous token was RID_NEW,\n+\t so just increment first_token instead of calling consume_token.  */\n+      ++first_token;\n       break;\n+\n     case TYPESPEC:\n       consume_token ();\n       break;\n@@ -394,7 +366,7 @@ yylex()\n  * Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n  * If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n  * It's also a definition if it's a forward declaration (as in 'struct Foo;')\n- * which we can tell lf token[2] == ';' *and* token[-1] != FRIEND.\n+ * which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.\n  */\n static int\n do_aggr ()\n@@ -408,10 +380,16 @@ do_aggr ()\n   yc2 = nth_token (2)->yychar;\n   if (yc2 == ';')\n     {\n-      /* It's a forward declaration iff we were not preceded by 'friend'. */\n-      if (first_token > 0 && nth_token (-1)->yychar == SCSPEC\n-\t  && nth_token (-1)->yylval.ttype == ridpointers[(int) RID_FRIEND])\n-\treturn 0;\n+      /* It's a forward declaration iff we were not preceded by\n+         'friend' or `new'. */\n+      if (first_token > 0)\n+\t{\n+\t  if (nth_token (-1)->yychar == SCSPEC\n+\t      && nth_token (-1)->yylval.ttype == ridpointers[(int) RID_FRIEND])\n+\t    return 0;\n+\t  if (nth_token (-1)->yychar == NEW)\n+\t    return 0;\n+\t}\n     }\n   else if (yc2 != '{' && yc2 != ':')\n     return 0;"}, {"sha": "85f07cc14fe162d2fb0b0fb836c8538cdc875f33", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -418,32 +418,6 @@ build_cplus_method_type (basetype, rettype, argtypes)\n   return t;\n }\n \n-tree\n-build_cplus_staticfn_type (basetype, rettype, argtypes)\n-     tree basetype, rettype, argtypes;\n-{\n-  register tree t;\n-  int hashcode;\n-\n-  /* Make a node of the sort we want.  */\n-  t = make_node (FUNCTION_TYPE);\n-\n-  TYPE_METHOD_BASETYPE (t) = TYPE_MAIN_VARIANT (basetype);\n-  TREE_TYPE (t) = rettype;\n-\n-  TYPE_ARG_TYPES (t) = argtypes;\n-\n-  /* If we already have such a type, use the old one and free this one.\n-     Note that it also frees up the above cons cell if found.  */\n-  hashcode = TYPE_HASH (basetype) + TYPE_HASH (rettype) + type_hash_list (argtypes);\n-  t = type_hash_canon (hashcode, t);\n-\n-  if (TYPE_SIZE (t) == 0)\n-    layout_type (t);\n-\n-  return t;\n-}\n-\n tree\n build_cplus_array_type (elt_type, index_type)\n      tree elt_type;\n@@ -1149,59 +1123,6 @@ get_decl_list (value)\n \n   return build_decl_list (NULL_TREE, value);\n }\n-\n-/* Look in the type hash table for a type isomorphic to\n-   `build_tree_list (NULL_TREE, VALUE)'.\n-   If one is found, return it.  Otherwise return 0.  */\n-\n-tree\n-list_hash_lookup_or_cons (value)\n-     tree value;\n-{\n-  register int hashcode = TYPE_HASH (value);\n-  register struct list_hash *h;\n-  struct obstack *ambient_obstack;\n-  tree list = NULL_TREE;\n-\n-  if (TREE_CODE (value) == IDENTIFIER_NODE)\n-    list = get_identifier_list (value);\n-  else if (TREE_CODE (value) == TYPE_DECL\n-\t   && TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE\n-\t   && TYPE_LANG_SPECIFIC (TREE_TYPE (value)))\n-    list = CLASSTYPE_ID_AS_LIST (TREE_TYPE (value));\n-  else if (TREE_CODE (value) == RECORD_TYPE\n-\t   && TYPE_LANG_SPECIFIC (value))\n-    list = CLASSTYPE_AS_LIST (value);\n-\n-  if (list != NULL_TREE)\n-    {\n-      my_friendly_assert (TREE_CHAIN (list) == NULL_TREE, 302);\n-      return list;\n-    }\n-\n-  if (debug_no_list_hash)\n-    return hash_tree_chain (value, NULL_TREE);\n-\n-  for (h = list_hash_table[hashcode % TYPE_HASH_SIZE]; h; h = h->next)\n-    if (h->hashcode == hashcode\n-\t&& TREE_VIA_VIRTUAL (h->list) == 0\n-\t&& TREE_VIA_PUBLIC (h->list) == 0\n-\t&& TREE_VIA_PROTECTED (h->list) == 0\n-\t&& TREE_PURPOSE (h->list) == 0\n-\t&& TREE_VALUE (h->list) == value)\n-      {\n-\tmy_friendly_assert (TREE_TYPE (h->list) == 0, 303);\n-\tmy_friendly_assert (TREE_CHAIN (h->list) == 0, 304);\n-\treturn h->list;\n-      }\n-\n-  ambient_obstack = current_obstack;\n-  current_obstack = &class_obstack;\n-  list = build_tree_list (NULL_TREE, value);\n-  list_hash_add (hashcode, list);\n-  current_obstack = ambient_obstack;\n-  return list;\n-}\n \f\n /* Build an association between TYPE and some parameters:\n \n@@ -1283,38 +1204,6 @@ reverse_path (path)\n   return prev;\n }\n \n-tree\n-virtual_member (elem, list)\n-     tree elem;\n-     tree list;\n-{\n-  tree t;\n-  tree rval, nval;\n-\n-  for (t = list; t; t = TREE_CHAIN (t))\n-    if (elem == BINFO_TYPE (t))\n-      return t;\n-  rval = 0;\n-  for (t = list; t; t = TREE_CHAIN (t))\n-    {\n-      tree binfos = BINFO_BASETYPES (t);\n-      int i;\n-\n-      if (binfos != NULL_TREE)\n-\tfor (i = TREE_VEC_LENGTH (binfos)-1; i >= 0; i--)\n-\t  {\n-\t    nval = binfo_value (elem, BINFO_TYPE (TREE_VEC_ELT (binfos, i)));\n-\t    if (nval)\n-\t      {\n-\t\tif (rval && BINFO_OFFSET (nval) != BINFO_OFFSET (rval))\n-\t\t  my_friendly_abort (104);\n-\t\trval = nval;\n-\t      }\n-\t  }\n-    }\n-  return rval;\n-}\n-\n void\n debug_binfo (elem)\n      tree elem;\n@@ -1379,20 +1268,6 @@ count_functions (t)\n   return 0;\n }\n \n-/* Like value_member, but for DECL_CHAINs.  */\n-tree\n-decl_value_member (elem, list)\n-     tree elem, list;\n-{\n-  while (list)\n-    {\n-      if (elem == list)\n-\treturn list;\n-      list = DECL_CHAIN (list);\n-    }\n-  return NULL_TREE;\n-}\n-\n int\n is_overloaded_fn (x)\n      tree x;\n@@ -1450,16 +1325,6 @@ fnaddr_from_vtable_entry (entry)\n     return TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (entry))));\n }\n \n-void\n-set_fnaddr_from_vtable_entry (entry, value)\n-     tree entry, value;\n-{\n-  if (flag_vtable_thunks)\n-    abort ();\n-  else\n-  TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (entry)))) = value;\n-}\n-\n tree\n function_arg_chain (t)\n      tree t;\n@@ -1555,16 +1420,6 @@ lang_printable_name (decl)\n   return print_ring[ring_counter];\n }\n \f\n-/* Comparison function for sorting identifiers in RAISES lists.\n-   Note that because IDENTIFIER_NODEs are unique, we can sort\n-   them by address, saving an indirection.  */\n-static int\n-id_cmp (p1, p2)\n-     tree *p1, *p2;\n-{\n-  return (HOST_WIDE_INT)TREE_VALUE (*p1) - (HOST_WIDE_INT)TREE_VALUE (*p2);\n-}\n-\n /* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n    listed in RAISES.  */\n tree"}, {"sha": "e1825636abc2812687c84e4fda12b4ed59476a79", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 69, "deletions": 655, "changes": 724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ff70986960f763c364b25c47de7da238eb5e2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9e9ff70986960f763c364b25c47de7da238eb5e2", "patch": "@@ -397,15 +397,6 @@ common_type (t1, t2)\n \n \treturn t1;\n       }\n-#if 0\n-    case POINTER_TYPE:\n-      t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n-      return build_type_attribute_variant (t1, attributes);\n-\n-    case REFERENCE_TYPE:\n-      t1 = build_reference_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n-      return build_type_attribute_variant (t1, attributes);\n-#endif\n \n     case ARRAY_TYPE:\n       {\n@@ -905,15 +896,6 @@ common_base_type (tt1, tt2)\n   if (UNIQUELY_DERIVED_FROM_P (tt2, tt1))\n     return tt2;\n \n-#if 0\n-  /* If they share a virtual baseclass, that's good enough.  */\n-  for (tmp = CLASSTYPE_VBASECLASSES (tt1); tmp; tmp = TREE_CHAIN (tmp))\n-    {\n-      if (binfo_member (BINFO_TYPE (tmp), CLASSTYPE_VBASECLASSES (tt2)))\n-\treturn BINFO_TYPE (tmp);\n-    }\n-#endif\n-\n   /* Otherwise, try to find a unique baseclass of TT1\n      that is shared by TT2, and follow that down.  */\n   for (i = CLASSTYPE_N_BASECLASSES (tt1)-1; i >= 0; i--)\n@@ -998,17 +980,6 @@ compparms (parms1, parms2, strict)\n \t    return t2 == void_list_node && TREE_PURPOSE (t1);\n \t  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);\n \t}\n-#if 0\n-      /* Default parms are not part of the type of a function.  */\n-      if (strict != 3 && TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n-\t{\n-\t  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n-\t  if (cmp < 0)\n-\t    my_friendly_abort (113);\n-\t  if (cmp == 0)\n-\t    return 0;\n-\t}\n-#endif\n \n       t1 = TREE_CHAIN (t1);\n       t2 = TREE_CHAIN (t2);\n@@ -1096,12 +1067,6 @@ comp_target_parms (parms1, parms2, strict)\n \t    }\n \t  if (strict != 0)\n \t    return 0;\n-#if 0\n-\t  /* What good do these cases do?  */\n-\t  if (strict == 0)\n-\t    return p2 == void_type_node && TREE_PURPOSE (t1);\n-\t  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);\n-#endif\n \t}\n       /* Target types are compatible--just make sure that if\n \t we use parameter lists, that they are ok as well.  */\n@@ -1305,14 +1270,7 @@ c_sizeof_nowarn (type)\n     type = TREE_TYPE (type);\n \n   if (TYPE_SIZE (type) == 0)\n-    {\n-#if 0\n-      /* ??? Tiemann, why have any diagnostic here?\n-\t There is none in the corresponding function for C.  */\n-      warning (\"sizeof applied to an incomplete type\");\n-#endif\n-      return size_int (0);\n-    }\n+    return size_int (0);\n \n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n@@ -1410,6 +1368,8 @@ decay_conversion (exp)\n     {\n       if (TREE_CODE (exp) == OFFSET_REF)\n \t{\n+\t  /* FIXME: We should emit an error here about using a ptrmemfunc\n+\t     for something other than a function call.  */\n \t  my_friendly_assert (TREE_CODE (TREE_OPERAND (exp, 1)) == FUNCTION_DECL,\n \t\t\t      308);\n \t  return build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 1), 0);\n@@ -1632,6 +1592,45 @@ rationalize_conditional_expr (code, t)\n \t\t\t    build_unary_op (code, TREE_OPERAND (t, 2), 0));\n }\n \n+/* Given the TYPE of an anonymous union field inside T, return the\n+   FIELD_DECL for the field.  If not found return NULL_TREE.  Because\n+   anonymous unions can nest, we must also search all anonymous unions\n+   that are directly reachable.  */\n+static tree\n+lookup_anon_field (t, type)\n+     tree t, type;\n+{\n+  tree field;\n+\n+  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_STATIC (field))\n+\tcontinue;\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      /* If we find it directly, return the field.  */\n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && type == TREE_TYPE (field))\n+\t{\n+\t  return field;\n+\t}\n+\n+      /* Otherwise, it could be nested, search harder.  */\n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t{\n+\t  tree subfield = lookup_anon_field (TREE_TYPE (field), type);\n+\t  if (subfield)\n+\t    return subfield;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Build a COMPONENT_REF for a given DATUM, and it's member COMPONENT.\n+   COMPONENT can be an IDENTIFIER_NODE that is the name of the member\n+   that we are interested in, or it can be a FIELD_DECL.  */\n tree\n build_component_ref (datum, component, basetype_path, protect)\n      tree datum, component, basetype_path;\n@@ -1663,14 +1662,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \n   if (code == REFERENCE_TYPE)\n     {\n-#if 0\n-      /* TREE_REFERENCE_EXPRs are not converted by `convert_from_reference'.\n-\t @@ Maybe that is not right.  */\n-      if (TREE_REFERENCE_EXPR (datum))\n-\tdatum = build1 (INDIRECT_REF, TREE_TYPE (basetype), datum);\n-      else\n-#endif\n-\tdatum = convert_from_reference (datum);\n+      datum = convert_from_reference (datum);\n       basetype = TREE_TYPE (datum);\n       code = TREE_CODE (basetype);\n     }\n@@ -1682,10 +1674,6 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t&& DECL_CHAIN (TREE_VALUE (component)) == NULL_TREE), 309);\n       return build (COMPONENT_REF, TREE_TYPE (component), datum, component);\n     }\n-#if 0\n-  if (TREE_CODE (component) == TYPE_EXPR)\n-    return build_component_type_expr (datum, component, NULL_TREE, protect);\n-#endif\n \n   if (! IS_AGGR_TYPE_CODE (code))\n     {\n@@ -1724,6 +1712,10 @@ build_component_ref (datum, component, basetype_path, protect)\n        hierarchy, the compiler will abort (because vptr lookups are\n        not supposed to be ambiguous.  */\n     field = CLASSTYPE_VFIELD (basetype);\n+  else if (TREE_CODE (component) == FIELD_DECL)\n+    {\n+      field = component;\n+    }\n   else\n     {\n       if (basetype_path == NULL_TREE)\n@@ -1778,24 +1770,14 @@ build_component_ref (datum, component, basetype_path, protect)\n                      not matter unless we're actually calling the function.  */\n \t\t  tree t;\n \n-#if 0\n-\t\t  for (t = TREE_VALUE (fndecls); t; t = DECL_CHAIN (t))\n-\t\t    assemble_external (t);\n-#endif\n-\n \t\t  t = build_tree_list (error_mark_node, fndecls);\n \t\t  TREE_TYPE (t) = build_offset_type (basetype,\n \t\t\t\t\t\t     unknown_type_node);\n \t\t  return t;\n \t\t}\n \t    }\n \n-#if 0\n-\t  if (component == ansi_opname[(int) TYPE_EXPR])\n-\t    cp_error (\"`%#T' has no such type conversion operator\", basetype);\n-\t  else\n-#endif\n-\t    cp_error (\"`%#T' has no member named `%D'\", basetype, component);\n+\t  cp_error (\"`%#T' has no member named `%D'\", basetype, component);\n \t  return error_mark_node;\n \t}\n       else if (TREE_TYPE (field) == error_mark_node)\n@@ -1816,6 +1798,18 @@ build_component_ref (datum, component, basetype_path, protect)\n \t}\n     }\n \n+  if (DECL_FIELD_CONTEXT (field) != basetype)\n+    {\n+      tree context = DECL_FIELD_CONTEXT (field);\n+      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n+\t{\n+\t  tree subfield = lookup_anon_field (basetype, context);\n+\t  tree subdatum = build_component_ref (datum, subfield,\n+\t\t\t\t\t       basetype_path, protect);\n+\t  return build_component_ref (subdatum, field, basetype_path, protect);\n+\t}\n+    }\n+\n   if (DECL_FIELD_CONTEXT (field) != basetype\n       && TYPE_USES_COMPLEX_INHERITANCE (basetype))\n     {\n@@ -2140,15 +2134,8 @@ build_x_function_call (function, params, decl)\n \t}\n       else if (TREE_CODE (function) == TREE_LIST)\n \t{\n-#if 0\n-\t  if (TREE_CODE (TREE_VALUE (function)) == TREE_LIST)\n-\t    function = TREE_PURPOSE (TREE_VALUE (function));\n-\t  else\n-\t    function = TREE_PURPOSE (function);\n-#else\n \t  my_friendly_assert (TREE_CODE (TREE_VALUE (function)) == FUNCTION_DECL, 312);\n \t  function = TREE_PURPOSE (function);\n-#endif\n \t}\n       else if (TREE_CODE (function) != IDENTIFIER_NODE)\n \t{\n@@ -2543,14 +2530,6 @@ build_function_call (function, params)\n {\n   return build_function_call_real (function, params, 1, LOOKUP_NORMAL);\n }\n-     \n-tree\n-build_function_call_maybe (function, params)\n-     tree function, params;\n-{\n-  return build_function_call_real (function, params, 0, 0);\n-}\n-\n \f\n /* Convert the actual parameter expressions in the list VALUES\n    to the types in the list TYPELIST.\n@@ -2580,7 +2559,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n      tree return_loc, typelist, values, fndecl;\n      int flags;\n {\n-  extern tree gc_protect_fndecl;\n   register tree typetail, valtail;\n   register tree result = NULL_TREE;\n   char *called_thing;\n@@ -2664,22 +2642,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       else if (TREE_CODE (val) == OFFSET_REF)\n \tval = resolve_offset_ref (val);\n \n-      {\n-#if 0\n-\t/* This code forces the assumption that if we have a ptr-to-func\n-\t   type in an arglist, that every routine that wants to check\n-\t   its validity has done so, and thus we need not do any\n-\t   more conversion.  I don't remember why this is necessary.  */\n-\telse if (TREE_CODE (ttype) == FUNCTION_TYPE\n-\t\t && (type == NULL\n-\t\t     || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t\t     || TREE_CODE (TREE_TYPE (type)) == VOID_TYPE))\n-\t  {\n-\t    type = build_pointer_type (ttype);\n-\t  }\n-#endif\n-      }\n-\n       /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n \t Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */\n       if (TREE_CODE (val) == NOP_EXPR\n@@ -2712,16 +2674,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    }\n \t  else\n \t    {\n-#if 0 && defined (PROMOTE_PROTOTYPES)\n-\t      /* This breaks user-defined conversions.  */\n-\t      /* Rather than truncating and then reextending,\n-\t\t convert directly to int, if that's the type we will want.  */\n-\t      if (! flag_traditional\n-\t\t  && (TREE_CODE (type) == INTEGER_TYPE\n-\t\t      || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\t\ttype = integer_type_node;\n-#endif\n \t      parmval = convert_for_initialization (return_loc, type, val,\n \t\t\t\t\t\t    flags|INDIRECT_BIND,\n \t\t\t\t\t\t    \"argument passing\", fndecl, i);\n@@ -2760,17 +2712,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    result = tree_cons (NULL_TREE, default_conversion (val), result);\n \t}\n \n-      if (flag_gc\n-\t  /* There are certain functions for which we don't need\n-\t     to protect our arguments.  GC_PROTECT_FNDECL is one.  */\n-\t  && fndecl != gc_protect_fndecl\n-\t  && type_needs_gc_entry (TREE_TYPE (TREE_VALUE (result)))\n-\t  && ! value_safe_from_gc (NULL_TREE, TREE_VALUE (result)))\n-\t/* This will build a temporary variable whose cleanup is\n-\t   to clear the obstack entry.  */\n-\tTREE_VALUE (result) = protect_value_from_gc (NULL_TREE,\n-\t\t\t\t\t\t     TREE_VALUE (result));\n-\n       if (typetail)\n \ttypetail = TREE_CHAIN (typetail);\n     }\n@@ -2813,11 +2754,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      if (parmval == error_mark_node)\n \t\treturn error_mark_node;\n \n-\t      if (flag_gc\n-\t\t  && type_needs_gc_entry (TREE_TYPE (parmval))\n-\t\t  && ! value_safe_from_gc (NULL_TREE, parmval))\n-\t\tparmval = protect_value_from_gc (NULL_TREE, parmval);\n-\n \t      result = tree_cons (0, parmval, result);\n \t      typetail = TREE_CHAIN (typetail);\n \t      /* ends with `...'.  */\n@@ -3764,11 +3700,11 @@ pointer_int_sum (resultcode, ptrop, intop)\n       intop = TREE_OPERAND (intop, 0);\n     }\n \n-  /* Convert the integer argument to a type the same size as a pointer\n+  /* Convert the integer argument to a type the same size as sizetype\n      so the multiply won't overflow spuriously.  */\n \n-  if (TYPE_PRECISION (TREE_TYPE (intop)) != POINTER_SIZE)\n-    intop = convert (type_for_size (POINTER_SIZE, 0), intop);\n+  if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype))\n+    intop = convert (type_for_size (TYPE_PRECISION (sizetype), 0), intop);\n \n   /* Replace the integer argument with a suitable product by the object size.\n      Do this multiplication as signed, then convert to the appropriate\n@@ -3861,9 +3797,6 @@ build_component_addr (arg, argtype, msg)\n       return error_mark_node;\n     }\n \n-  if (flag_gc)\n-    cp_warning (\"address of `%T::%D' taken\", basetype, field);\n-\n   if (TREE_CODE (field) == FIELD_DECL\n       && TYPE_USES_COMPLEX_INHERITANCE (basetype))\n     {\n@@ -4645,17 +4578,12 @@ build_conditional_expr (ifexp, op1, op2)\n       code2 = TREE_CODE (type2);\n     }\n \n-#if 1 /* Produces wrong result if within sizeof.  Sorry.  */\n   /* Don't promote the operands separately if they promote\n      the same way.  Return the unpromoted type and let the combined\n      value get promoted if necessary.  */\n \n   if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2)\n       && code2 != ARRAY_TYPE\n-#if 0\n-      /* For C++, let the enumeral type come through.  */\n-      && code2 != ENUMERAL_TYPE\n-#endif\n       && code2 != FUNCTION_TYPE\n       && code2 != METHOD_TYPE)\n     {\n@@ -4686,7 +4614,6 @@ build_conditional_expr (ifexp, op1, op2)\n \tresult = build1 (NOP_EXPR, type1, result);\n       return result;\n     }\n-#endif\n \n   /* They don't match; promote them both and then try to reconcile them.\n      But don't permit mismatching enum types.  */\n@@ -4815,27 +4742,17 @@ build_conditional_expr (ifexp, op1, op2)\n       if (!integer_zerop (op2))\n \tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n-\t{\n-\t  op2 = null_pointer_node;\n-#if 0\t\t\t\t/* Sez who? */\n-\t  if (pedantic && TREE_CODE (type1) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids conditional expr between 0 and function pointer\");\n-#endif\n-\t}\n+\top2 = null_pointer_node;\n+\n       result_type = type1;\n     }\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n       if (!integer_zerop (op1))\n \tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n-\t{\n-\t  op1 = null_pointer_node;\n-#if 0\t\t\t\t/* Sez who? */\n-\t  if (pedantic && TREE_CODE (type2) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids conditional expr between 0 and function pointer\");\n-#endif\n-\t}\n+\top1 = null_pointer_node;\n+\n       result_type = type2;\n     }\n \n@@ -4892,43 +4809,6 @@ build_conditional_expr (ifexp, op1, op2)\n   if (result_type != TREE_TYPE (op2))\n     op2 = convert_and_check (result_type, op2);\n \n-#if 0\n-  /* XXX delete me, I've been here for years.  */\n-  if (IS_AGGR_TYPE_CODE (code1))\n-    {\n-      result_type = TREE_TYPE (op1);\n-      if (TREE_CONSTANT (ifexp))\n-\treturn (integer_zerop (ifexp) ? op2 : op1);\n-\n-      if (TYPE_MODE (result_type) == BLKmode)\n-\t{\n-\t  register tree tempvar\n-\t    = build_decl (VAR_DECL, NULL_TREE, result_type);\n-\t  register tree xop1 = build_modify_expr (tempvar, NOP_EXPR, op1);\n-\t  register tree xop2 = build_modify_expr (tempvar, NOP_EXPR, op2);\n-\t  register tree result = fold (build (COND_EXPR, result_type,\n-\t\t\t\t\t      ifexp, xop1, xop2));\n-\n-\t  layout_decl (tempvar, 0);\n-\t  /* No way to handle variable-sized objects here.\n-\t     I fear that the entire handling of BLKmode conditional exprs\n-\t     needs to be redone.  */\n-\t  my_friendly_assert (TREE_CONSTANT (DECL_SIZE (tempvar)), 315);\n-\t  DECL_RTL (tempvar)\n-\t    = assign_stack_local (DECL_MODE (tempvar),\n-\t\t\t\t  (TREE_INT_CST_LOW (DECL_SIZE (tempvar))\n-\t\t\t\t   + BITS_PER_UNIT - 1)\n-\t\t\t\t  / BITS_PER_UNIT,\n-\t\t\t\t  0);\n-\n-\t  TREE_SIDE_EFFECTS (result)\n-\t    = TREE_SIDE_EFFECTS (ifexp) | TREE_SIDE_EFFECTS (op1)\n-\t      | TREE_SIDE_EFFECTS (op2);\n-\t  return build (COMPOUND_EXPR, result_type, result, tempvar);\n-\t}\n-    }\n-#endif /* 0 */\n-\n   if (TREE_CONSTANT (ifexp))\n     return integer_zerop (ifexp) ? op2 : op1;\n \n@@ -5009,16 +4889,6 @@ build_compound_expr (list)\n \t\tbreak_out_cleanups (TREE_VALUE (list)), rest);\n }\n \n-#ifdef __GNUC__\n-__inline\n-#endif\n-int\n-null_ptr_cst_p (t)\n-     tree t;\n-{\n-  return (TREE_CODE (t) == INTEGER_CST && integer_zerop (t));\n-}\n-\n tree build_static_cast (type, expr)\n    tree type, expr;\n {\n@@ -5248,6 +5118,8 @@ build_c_cast (type, expr, allow_nonconverting)\n \twarning (\"cast increases required alignment of target type\");\n \n #if 0\n+      /* We should see about re-enabling these, they seem useful to\n+         me.  */\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n@@ -5302,282 +5174,6 @@ build_c_cast (type, expr, allow_nonconverting)\n   return value;\n }\n \f\n-#if 0\n-/* Build an assignment expression of lvalue LHS from value RHS.\n-\n-   In C++, if the left hand side of the assignment is a REFERENCE_TYPE,\n-   that reference becomes deferenced down to it base type. */\n-\n-/* Return a reference to the BASE_INDEX part of EXPR.  TYPE is\n-   the type to which BASE_INDEX applies.  */\n-static tree\n-get_base_ref (type, base_index, expr)\n-     tree type;\n-     int base_index;\n-     tree expr;\n-{\n-  tree binfos = TYPE_BINFO_BASETYPES (type);\n-  tree base_binfo = TREE_VEC_ELT (binfos, base_index);\n-  tree ref;\n-\n-  if (TREE_CODE (expr) == ARRAY_REF\n-      || ! BINFO_OFFSET_ZEROP (base_binfo)\n-      || TREE_VIA_VIRTUAL (base_binfo)\n-      || TYPE_MODE (type) != TYPE_MODE (BINFO_TYPE (base_binfo)))\n-    {\n-      tree addr = build_unary_op (ADDR_EXPR, expr, 0);\n-      ref = build_indirect_ref (convert_pointer_to (base_binfo, addr),\n-\t\t\t\tNULL_PTR);\n-    }\n-  else\n-    {\n-      ref = copy_node (expr);\n-      TREE_TYPE (ref) = BINFO_TYPE (base_binfo);\n-    }\n-  return ref;\n-}\n-\n-/* Build an assignment expression of lvalue LHS from value RHS.\n-   MODIFYCODE is the code for a binary operator that we use\n-   to combine the old value of LHS with RHS to get the new value.\n-   Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.\n-\n-   C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.\n-\n-   `build_modify_expr_1' implements recursive part of memberwise\n-   assignment operation.  */\n-static tree\n-build_modify_expr_1 (lhs, modifycode, rhs, basetype_path)\n-     tree lhs, rhs;\n-     enum tree_code modifycode;\n-     tree basetype_path;\n-{\n-  register tree result;\n-  tree newrhs = rhs;\n-  tree lhstype = TREE_TYPE (lhs);\n-  tree olhstype = lhstype;\n-\n-  /* Avoid duplicate error messages from operands that had errors.  */\n-  if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  /* If a binary op has been requested, combine the old LHS value with the RHS\n-     producing the value we should actually store into the LHS.  */\n-\n-  if (modifycode == INIT_EXPR)\n-    ;\n-  else if (modifycode == NOP_EXPR)\n-    {\n-      /* must deal with overloading of `operator=' here.  */\n-      if (TREE_CODE (lhstype) == REFERENCE_TYPE)\n-\tlhstype = TREE_TYPE (lhstype);\n-      else\n-\tlhstype = olhstype;\n-    }\n-  else\n-    {\n-      lhs = stabilize_reference (lhs);\n-      newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n-      modifycode = NOP_EXPR;\n-    }\n-\n-  /* If storing into a structure or union member,\n-     it has probably been given type `int'.\n-     Compute the type that would go with\n-     the actual amount of storage the member occupies.  */\n-\n-  if (TREE_CODE (lhs) == COMPONENT_REF\n-      && (TREE_CODE (lhstype) == INTEGER_TYPE\n-\t  || TREE_CODE (lhstype) == REAL_TYPE\n-\t  || TREE_CODE (lhstype) == ENUMERAL_TYPE))\n-    lhstype = TREE_TYPE (get_unwidened (lhs, 0));\n-\n-  /* C++: The semantics of C++ differ from those of C when an\n-     assignment of an aggregate is desired.  Assignment in C++ is\n-     now defined as memberwise assignment of non-static members\n-     and base class objects.  This rule applies recursively\n-     until a member of a built-in type is found.\n-\n-     Also, we cannot do a bit-wise copy of aggregates which\n-     contain virtual function table pointers.  Those\n-     pointer values must be preserved through the copy.\n-     However, this is handled in expand_expr, and not here.\n-     This is because much better code can be generated at\n-     that stage than this one.  */\n-  if (TREE_CODE (lhstype) == RECORD_TYPE\n-      && TYPE_LANG_SPECIFIC (lhstype)\n-      && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n-    {\n-      register tree elt;\n-      int i;\n-\n-      /* Perform operation on object.  */\n-      if (modifycode == INIT_EXPR && TYPE_HAS_INIT_REF (lhstype))\n-\t{\n-\t  result = build_method_call (lhs, constructor_name_full (lhstype),\n-\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t      basetype_path, LOOKUP_NORMAL);\n-\t  return build_indirect_ref (result, NULL_PTR);\n-\t}\n-      else if (modifycode == NOP_EXPR)\n-\t{\n-\t  /* `operator=' is not an inheritable operator; see 13.4.3.  */\n-\t  if (TYPE_LANG_SPECIFIC (lhstype) && TYPE_HAS_ASSIGNMENT (lhstype))\n-\t    {\n-\t      result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t       lhs, rhs, make_node (NOP_EXPR));\n-\t      if (result == NULL_TREE)\n-\t\treturn error_mark_node;\n-\t      return result;\n-\t    }\n-\t}\n-\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (lhstype)\n-\t  || (modifycode == NOP_EXPR && TYPE_GETS_ASSIGNMENT (lhstype))\n-\t  || (modifycode == INIT_EXPR && TYPE_GETS_INIT_REF (lhstype)))\n-\t{\n-\t  tree binfos = BINFO_BASETYPES (TYPE_BINFO (lhstype));\n-\t  result = NULL_TREE;\n-\n-\t  if (binfos != NULL_TREE)\n-\t    /* Perform operation on each member, depth-first, left-right.  */\n-\t    for (i = 0; i <= TREE_VEC_LENGTH (binfos)-1; i++)\n-\t      {\n-\t\ttree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t\ttree base_lhs, base_rhs;\n-\t\ttree new_result;\n-\n-\t\t/* Assignments from virtual baseclasses handled elsewhere.  */\n-\t\tif (TREE_VIA_VIRTUAL (base_binfo))\n-\t\t  continue;\n-\n-\t\tbase_lhs = get_base_ref (lhstype, i, lhs);\n-\t\tbase_rhs = get_base_ref (lhstype, i, newrhs);\n-\n-\t\tBINFO_INHERITANCE_CHAIN (base_binfo) = basetype_path;\n-\t\tnew_result\n-\t\t  = build_modify_expr_1 (base_lhs, modifycode, base_rhs,\n-\t\t\t\t\t base_binfo);\n-\n-\t\t/* We either get back a compound stmt, or a simple one.  */\n-\t\tif (new_result && TREE_CODE (new_result) == TREE_LIST)\n-\t\t  new_result = build_compound_expr (new_result);\n-\t\tresult = tree_cons (NULL_TREE, new_result, result);\n-\t      }\n-\n-\t  for (elt = TYPE_FIELDS (lhstype); elt; elt = TREE_CHAIN (elt))\n-\t    {\n-\t      tree vbases = NULL_TREE;\n-\t      tree elt_lhs, elt_rhs;\n-\n-\t      if (TREE_CODE (elt) != FIELD_DECL)\n-\t\tcontinue;\n-\t      if (DECL_NAME (elt)\n-\t\t  && (VFIELD_NAME_P (DECL_NAME (elt))\n-\t\t      || VBASE_NAME_P (DECL_NAME (elt))))\n-\t\tcontinue;\n-\n-\t      if (TREE_READONLY (elt)\n-\t\t  || TREE_CODE (TREE_TYPE (elt)) == REFERENCE_TYPE)\n-\t\t{\n-\t\t  cp_error (\"cannot generate default `%T::operator ='\",\n-\t\t\t    lhstype);\n-\t\t  if (TREE_CODE (TREE_TYPE (elt)) == REFERENCE_TYPE)\n-\t\t    cp_error_at (\"because member `%#D' is a reference\", elt);\n-\t\t  else\n-\t\t    cp_error_at (\"because member `%#D' is const\", elt);\n-\n-\t\t  return error_mark_node;\n-\t\t}\n-\n-\t      if (IS_AGGR_TYPE (TREE_TYPE (elt))\n-\t\t  && TYPE_LANG_SPECIFIC (TREE_TYPE (elt)))\n-\t\tvbases = CLASSTYPE_VBASECLASSES (TREE_TYPE (elt));\n-\n-\t      elt_lhs = build (COMPONENT_REF, TREE_TYPE (elt), lhs, elt);\n-\t      elt_rhs = build (COMPONENT_REF, TREE_TYPE (elt), newrhs, elt);\n-\t      /* It is not always safe to go through `build_modify_expr_1'\n-\t\t when performing element-wise copying.  This is because\n-\t\t an element may be of ARRAY_TYPE, which will not\n-\t\t be properly copied as a naked element.  */\n-\t      if (TREE_CODE (TREE_TYPE (elt)) == RECORD_TYPE\n-\t\t  && TYPE_LANG_SPECIFIC (TREE_TYPE (elt)))\n-\t\tbasetype_path = TYPE_BINFO (TREE_TYPE (elt));\n-\n-\t      while (vbases)\n-\t\t{\n-\t\t  tree elt_lhs_addr = build_unary_op (ADDR_EXPR, elt_lhs, 0);\n-\t\t  tree elt_rhs_addr = build_unary_op (ADDR_EXPR, elt_rhs, 0);\n-\n-\t\t  elt_lhs_addr = convert_pointer_to (vbases, elt_lhs_addr);\n-\t\t  elt_rhs_addr = convert_pointer_to (vbases, elt_rhs_addr);\n-\t\t  result\n-\t\t    = tree_cons (NULL_TREE,\n-\t\t\t\t build_modify_expr_1\n-\t\t\t\t (build_indirect_ref (elt_lhs_addr, NULL_PTR),\n-\t\t\t\t  modifycode,\n-\t\t\t\t  build_indirect_ref (elt_rhs_addr, NULL_PTR),\n-\t\t\t\t  basetype_path),\n-\t\t\t\t result);\n-\t\t  if (TREE_VALUE (result) == error_mark_node)\n-\t\t    return error_mark_node;\n-\t\t  vbases = TREE_CHAIN (vbases);\n-\t\t}\n-\t      elt_lhs = build_modify_expr_1 (elt_lhs, modifycode, elt_rhs,\n-\t\t\t\t\t     basetype_path);\n-\t      result = tree_cons (NULL_TREE, elt_lhs, result);\n-\t    }\n-\n-\t  if (result)\n-\t    return build_compound_expr (result);\n-\t  /* No fields to move.  */\n-\t  return integer_zero_node;\n-\t}\n-      else\n-\t{\n-\t  result = build (modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR,\n-\t\t\t  void_type_node, lhs, rhs);\n-\t  TREE_SIDE_EFFECTS (result) = 1;\n-\t  return result;\n-\t}\n-    }\n-\n-  result = build_modify_expr (lhs, modifycode, newrhs);\n-  /* ARRAY_TYPEs cannot be converted to anything meaningful,\n-     and leaving it there screws up `build_compound_expr' when\n-     it tries to defaultly convert everything.  */\n-  if (TREE_CODE (TREE_TYPE (result)) == ARRAY_TYPE)\n-    TREE_TYPE (result) = void_type_node;\n-  return result;\n-}\n-#endif\n-\n-/* Taken from expr.c:\n-   Subroutine of expand_expr:\n-   record the non-copied parts (LIST) of an expr (LHS), and return a list\n-   which specifies the initial values of these parts.  */\n-\n-static tree\n-init_noncopied_parts (lhs, list)\n-     tree lhs;\n-     tree list;\n-{\n-  tree tail;\n-  tree parts = 0;\n-\n-  for (tail = list; tail; tail = TREE_CHAIN (tail))\n-    if (TREE_CODE (TREE_VALUE (tail)) == TREE_LIST)\n-      parts = chainon (parts, init_noncopied_parts (lhs, TREE_VALUE (tail)));\n-    else\n-      {\n-\ttree part = TREE_VALUE (tail);\n-\ttree part_type = TREE_TYPE (part);\n-\ttree to_be_initialized = build (COMPONENT_REF, part_type, lhs, part);\n-\tparts = tree_cons (TREE_PURPOSE (tail), to_be_initialized, parts);\n-      }\n-  return parts;\n-}\n-\n tree\n expand_target_expr (t)\n      tree t;\n@@ -5638,12 +5234,6 @@ build_modify_expr (lhs, modifycode, rhs)\n   /* Types that aren't fully specified cannot be used in assignments.  */\n   lhs = require_complete_type (lhs);\n \n-  /* Decide early if we are going to protect RHS from GC\n-     before assigning it to LHS.  */\n-  if (type_needs_gc_entry (TREE_TYPE (rhs))\n-      && ! value_safe_from_gc (lhs, rhs))\n-    rhs = protect_value_from_gc (lhs, rhs);\n-\n   newrhs = rhs;\n \n   /* Handle assignment to signature pointers/refs.  */\n@@ -5762,7 +5352,6 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n   else if (modifycode == NOP_EXPR)\n     {\n-#if 1\n       /* `operator=' is not an inheritable operator.  */\n       if (! IS_AGGR_TYPE (lhstype))\n \t/* Do the default thing */;\n@@ -5789,46 +5378,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \t    return error_mark_node;\n \t  return result;\n \t}\n-#else\n-      /* Treat `operator=' as an inheritable operator.  */\n-      if (TYPE_LANG_SPECIFIC (lhstype) && TYPE_GETS_ASSIGNMENT (lhstype))\n-\t{\n-\t  tree orig_lhstype = lhstype;\n-\t  while (! TYPE_HAS_ASSIGNMENT (lhstype))\n-\t    {\n-\t      int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (lhstype);\n-\t      tree basetype = NULL_TREE;\n-\t      for (i = 0; i < n_baseclasses; i++)\n-\t\tif (TYPE_GETS_ASSIGNMENT (TYPE_BINFO_BASETYPE (lhstype, i)))\n-\t\t  {\n-\t\t    if (basetype != NULL_TREE)\n-\t\t      {\n-\t\t\tmessage_2_types (error, \"base classes `%s' and `%s' both have operator ='\",\n-\t\t\t\t\t basetype,\n-\t\t\t\t\t TYPE_BINFO_BASETYPE (lhstype, i));\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t    basetype = TYPE_BINFO_BASETYPE (lhstype, i);\n-\t\t  }\n-\t      lhstype = basetype;\n-\t    }\n-\t  if (orig_lhstype != lhstype)\n-\t    {\n-\t      lhs = build_indirect_ref (convert_pointer_to (lhstype,\n-\t\t\t\t\t\t\t    build_unary_op (ADDR_EXPR, lhs, 0)), NULL_PTR);\n-\t      if (lhs == error_mark_node)\n-\t\t{\n-\t\t  cp_error (\"conversion to private basetype `%T'\", lhstype);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t    }\n-\t  result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t   lhs, rhs, make_node (NOP_EXPR));\n-\t  if (result == NULL_TREE)\n-\t    return error_mark_node;\n-\t  return result;\n-\t}\n-#endif\n       lhstype = olhstype;\n     }\n   else if (PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE))\n@@ -5992,104 +5541,6 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (TREE_SIDE_EFFECTS (newrhs))\n     newrhs = stabilize_reference (newrhs);\n \n-#if 0\n-  /* This is now done by generating X(X&) and operator=(X&). */\n-  /* C++: The semantics of C++ differ from those of C when an\n-     assignment of an aggregate is desired.  Assignment in C++ is\n-     now defined as memberwise assignment of non-static members\n-     and base class objects.  This rule applies recursively\n-     until a member of a built-in type is found.\n-\n-     Also, we cannot do a bit-wise copy of aggregates which\n-     contain virtual function table pointers.  Those\n-     pointer values must be preserved through the copy.\n-     However, this is handled in expand_expr, and not here.\n-     This is because much better code can be generated at\n-     that stage than this one.  */\n-  if (TREE_CODE (lhstype) == RECORD_TYPE\n-      && ! TYPE_PTRMEMFUNC_P (lhstype)\n-      && (TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs))\n-\t  || (TREE_CODE (TREE_TYPE (newrhs)) == RECORD_TYPE\n-\t      && UNIQUELY_DERIVED_FROM_P (lhstype, TREE_TYPE (newrhs)))))\n-    {\n-      tree vbases = CLASSTYPE_VBASECLASSES (lhstype);\n-      tree lhs_addr = build_unary_op (ADDR_EXPR, lhs, 0);\n-      tree rhs_addr;\n-\t  \n-      /* Memberwise assignment would cause NEWRHS to be\n-\t evaluated for every member that gets assigned.\n-\t By wrapping side-effecting exprs in a SAVE_EXPR,\n-\t NEWRHS will only be evaluated once.  */\n-      if (IS_AGGR_TYPE (TREE_TYPE (newrhs))\n-\t  && TREE_SIDE_EFFECTS (newrhs)\n-\t  /* This are things we don't have to save.  */\n-\t  && TREE_CODE (newrhs) != COND_EXPR\n-\t  && TREE_CODE (newrhs) != TARGET_EXPR\n-\t  && TREE_CODE (newrhs) != WITH_CLEANUP_EXPR)\n-\t/* Call `break_out_cleanups' on NEWRHS in case there are cleanups.\n-\t   If NEWRHS is a CALL_EXPR that needs a cleanup, failure to do so\n-\t   will result in expand_expr expanding the call without knowing\n-\t   that it should run the cleanup.  */\n-\tnewrhs = save_expr (break_out_cleanups (newrhs));\n-\t  \n-      if (TREE_CODE (newrhs) == COND_EXPR)\n-\trhs_addr = rationalize_conditional_expr (ADDR_EXPR, newrhs);\n-      else\n-\trhs_addr = build_unary_op (ADDR_EXPR, newrhs, 0);\n-\n-      result = tree_cons (NULL_TREE,\n-\t\t\t  convert (build_reference_type (lhstype), lhs),\n-\t\t\t  NULL_TREE);\n-\n-      if (! comptypes (TREE_TYPE (lhs_addr), TREE_TYPE (rhs_addr), 1))\n-\trhs_addr = convert_pointer_to (TREE_TYPE (TREE_TYPE (lhs_addr)), rhs_addr);\n-      {\n-\ttree noncopied_parts = NULL_TREE;\n-\n-\tif (TYPE_NONCOPIED_PARTS (lhstype) != 0)\n-\t  noncopied_parts = init_noncopied_parts (lhs,\n-\t\t\t\t\t\t  TYPE_NONCOPIED_PARTS (lhstype));\n-\twhile (noncopied_parts != 0)\n-\t  {\n-\t    result = tree_cons (NULL_TREE,\n-\t\t\t\tbuild_modify_expr (convert (ptr_type_node, TREE_VALUE (noncopied_parts)),\n-\t\t\t\t\t\t   NOP_EXPR,\n-\t\t\t\t\t\t   TREE_PURPOSE (noncopied_parts)),\n-\t\t\t\tresult);\n-\t    noncopied_parts = TREE_CHAIN (noncopied_parts);\n-\t  }\n-      }\n-      /* Once we have our hands on an address, we must change NEWRHS\n-\t to work from there.  Otherwise we can get multiple evaluations\n-\t of NEWRHS.  */\n-      if (TREE_CODE (newrhs) != SAVE_EXPR)\n-\tnewrhs = build_indirect_ref (rhs_addr, NULL_PTR);\n-\n-      while (vbases)\n-\t{\n-\t  tree elt_lhs = convert_pointer_to (vbases, lhs_addr);\n-\t  tree elt_rhs = convert_pointer_to (vbases, rhs_addr);\n-\t  result\n-\t    = tree_cons (NULL_TREE,\n-\t\t\t build_modify_expr_1 (build_indirect_ref (elt_lhs, NULL_PTR),\n-\t\t\t\t\t      modifycode,\n-\t\t\t\t\t      build_indirect_ref (elt_rhs, NULL_PTR),\n-\t\t\t\t\t      TYPE_BINFO (lhstype)),\n-\t\t\t result);\n-\t  if (TREE_VALUE (result) == error_mark_node)\n-\t    return error_mark_node;\n-\t  vbases = TREE_CHAIN (vbases);\n-\t}\n-      result = tree_cons (NULL_TREE,\n-\t\t\t  build_modify_expr_1 (lhs,\n-\t\t\t\t\t       modifycode,\n-\t\t\t\t\t       newrhs,\n-\t\t\t\t\t       TYPE_BINFO (lhstype)),\n-\t\t\t  result);\n-      return build_compound_expr (result);\n-    }\n-#endif\n-\n   /* Convert new value to destination type.  */\n \n   if (TREE_CODE (lhstype) == ARRAY_TYPE)\n@@ -6148,15 +5599,6 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n   else\n     {\n-#if 0\n-      if (IS_AGGR_TYPE (lhstype))\n-\t{\n-\t  if (result = build_opfncall (MODIFY_EXPR,\n-\t\t\t\t       LOOKUP_NORMAL, lhs, newrhs,\n-\t\t\t\t       make_node (NOP_EXPR)))\n-\t    return result;\n-\t}\n-#endif\n       /* Avoid warnings on enum bit fields. */\n       if (TREE_CODE (olhstype) == ENUMERAL_TYPE\n \t  && TREE_CODE (lhstype) == INTEGER_TYPE)\n@@ -6371,22 +5813,8 @@ build_ptrmemfunc (type, pfn, force)\n     {\n       tree ndelta, ndelta2, nindex;\n       /* Is is already the right type? */\n-#if 0\n-      /* Sorry, can't do this, the backend is too stupid. */\n-      if (TYPE_METHOD_BASETYPE (TREE_TYPE (type))\n-\t  == TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))))\n-\t{\n-\t  if (type != TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n-\t    {\n-\t      npfn = build1 (NOP_EXPR, TYPE_GET_PTRMEMFUNC_TYPE (type), pfn);\n-\t      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n-\t    }\n-\t  return pfn;\n-\t}\n-#else\n       if (type == TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n \treturn pfn;\n-#endif\n \n       if (TREE_CODE (pfn) != CONSTRUCTOR)\n \t{\n@@ -7063,12 +6491,6 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n   if (coder == ERROR_MARK)\n     return error_mark_node;\n \n-#if 0\n-  /* This is *not* the quick way out!  It is the way to disaster.  */\n-  if (type == rhstype)\n-    goto converted;\n-#endif\n-\n   /* We accept references to incomplete types, so we can\n      return here before checking if RHS is of complete type.  */\n      \n@@ -7536,14 +6958,6 @@ c_expand_return (retval)\n     }\n \n   current_function_returns_value = returns_value;\n-#if 0\n-  /* These wind up after the BARRIER, which causes problems for\n-     expand_end_binding.  What purpose were they supposed to serve?  */\n-  if (original_result_rtx)\n-    use_variable (original_result_rtx);\n-  if (use_temp)\n-    use_variable (DECL_RTL (DECL_RESULT (current_function_decl)));\n-#endif\n \n   /* One way to clear out cleanups that EXPR might\n      generate.  Note that this code will really be"}]}