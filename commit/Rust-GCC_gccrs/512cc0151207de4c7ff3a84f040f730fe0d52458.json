{"sha": "512cc0151207de4c7ff3a84f040f730fe0d52458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyY2MwMTUxMjA3ZGU0YzdmZjNhODRmMDQwZjczMGZlMGQ1MjQ1OA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-09-21T08:41:17Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-09-21T08:41:17Z"}, "message": "Remove arc profile histogram in non-LTO mode.\n\n2018-09-21  Martin Liska  <mliska@suse.cz>\n\n\t* auto-profile.c (autofdo_source_profile::read): Do not\n\tset sum_all.\n\t(read_profile): Do not add working sets.\n\t(read_autofdo_file): Remove sum_all.\n\t(afdo_callsite_hot_enough_for_early_inline): Remove const\n\tqualifier.\n\t* coverage.c (struct counts_entry): Remove gcov_summary.\n\t(read_counts_file): Read new GCOV_TAG_OBJECT_SUMMARY,\n\tdo not support GCOV_TAG_PROGRAM_SUMMARY.\n\t(get_coverage_counts): Remove summary and expected\n\targuments.\n\t* coverage.h (get_coverage_counts): Likewise.\n\t* doc/gcov-dump.texi: Remove -w option.\n\t* gcov-dump.c (dump_working_sets): Remove.\n\t(main): Do not support '-w' option.\n\t(print_usage): Likewise.\n\t(tag_summary): Likewise.\n\t* gcov-io.c (gcov_write_summary): Do not dump\n\thistogram.\n\t(gcov_read_summary): Likewise.\n\t(gcov_histo_index): Remove.\n\t(gcov_histogram_merge): Likewise.\n\t(compute_working_sets): Likewise.\n\t* gcov-io.h (GCOV_TAG_OBJECT_SUMMARY): Mark\n\tit not obsolete.\n\t(GCOV_TAG_PROGRAM_SUMMARY): Mark it obsolete.\n\t(GCOV_TAG_SUMMARY_LENGTH): Adjust.\n\t(GCOV_HISTOGRAM_SIZE): Remove.\n\t(GCOV_HISTOGRAM_BITVECTOR_SIZE): Likewise.\n\t(struct gcov_summary): Simplify rapidly just\n\tto runs and sum_max fields.\n\t(gcov_histo_index): Remove.\n\t(NUM_GCOV_WORKING_SETS): Likewise.\n\t(compute_working_sets): Likewise.\n\t* gcov-tool.c (print_overlap_usage_message): Remove\n\ttrailing empty line.\n\t* gcov.c (read_count_file): Read GCOV_TAG_OBJECT_SUMMARY.\n\t(output_lines): Remove program related line.\n\t* ipa-profile.c (ipa_profile): Do not consider GCOV histogram.\n\t* lto-cgraph.c (output_profile_summary): Do not stream GCOV\n\thistogram.\n\t(input_profile_summary): Do not read it.\n\t(merge_profile_summaries): And do not merge it.\n\t(input_symtab): Do not call removed function.\n\t* modulo-sched.c (sms_schedule): Do not print sum_max.\n\t* params.def (HOT_BB_COUNT_FRACTION): Reincarnate param that was\n\tremoved when histogram method was invented.\n\t(HOT_BB_COUNT_WS_PERMILLE): Mention that it's used only in LTO\n\tmode.\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Fix\n\tGCOV coding style.\n\t* predict.c (get_hot_bb_threshold): Use HOT_BB_COUNT_FRACTION\n\tand dump selected value.\n\t* profile.c (add_working_set): Remove.\n\t(get_working_sets): Likewise.\n\t(find_working_set): Likewise.\n\t(get_exec_counts): Do not work with working sets.\n\t(read_profile_edge_counts): Do not inform as sum_max is removed.\n\t(compute_branch_probabilities): Likewise.\n\t(compute_value_histograms): Remove argument for call of\n\tget_coverage_counts.\n\t* profile.h: Do not make gcov_summary const.\n2018-09-21  Martin Liska  <mliska@suse.cz>\n\n\t* libgcov-driver.c (crc32_unsigned): Remove.\n\t(gcov_histogram_insert): Likewise.\n\t(gcov_compute_histogram): Likewise.\n\t(compute_summary): Simplify rapidly.\n\t(merge_one_data): Do not handle PROGRAM_SUMMARY tag.\n\t(merge_summary): Rapidly simplify.\n\t(dump_one_gcov): Ignore gcov_summary.\n\t(gcov_do_dump): Do not handle program summary, it's not\n\tused.\n\t* libgcov-util.c (tag_summary): Remove.\n\t(read_gcda_finalize): Fix coding style.\n\t(read_gcda_file): Initialize curr_object_summary.\n\t(compute_summary): Remove.\n\t(calculate_overlap): Remove settings of run_max.\n\nFrom-SVN: r264462", "tree": {"sha": "d3237cdec0d5acc77939322658f0dc8de1d5a5be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3237cdec0d5acc77939322658f0dc8de1d5a5be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/512cc0151207de4c7ff3a84f040f730fe0d52458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/512cc0151207de4c7ff3a84f040f730fe0d52458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/512cc0151207de4c7ff3a84f040f730fe0d52458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/512cc0151207de4c7ff3a84f040f730fe0d52458/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36ff254bf63f21dd8fc7a353c8b8f3aa08018654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ff254bf63f21dd8fc7a353c8b8f3aa08018654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ff254bf63f21dd8fc7a353c8b8f3aa08018654"}], "stats": {"total": 1399, "additions": 183, "deletions": 1216}, "files": [{"sha": "97e75ec34b2808b9566fccc02854ce40e0c5eec8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -1,3 +1,68 @@\n+2018-09-21  Martin Liska  <mliska@suse.cz>\n+\n+\t* auto-profile.c (autofdo_source_profile::read): Do not\n+\tset sum_all.\n+\t(read_profile): Do not add working sets.\n+\t(read_autofdo_file): Remove sum_all.\n+\t(afdo_callsite_hot_enough_for_early_inline): Remove const\n+\tqualifier.\n+\t* coverage.c (struct counts_entry): Remove gcov_summary.\n+\t(read_counts_file): Read new GCOV_TAG_OBJECT_SUMMARY,\n+\tdo not support GCOV_TAG_PROGRAM_SUMMARY.\n+\t(get_coverage_counts): Remove summary and expected\n+\targuments.\n+\t* coverage.h (get_coverage_counts): Likewise.\n+\t* doc/gcov-dump.texi: Remove -w option.\n+\t* gcov-dump.c (dump_working_sets): Remove.\n+\t(main): Do not support '-w' option.\n+\t(print_usage): Likewise.\n+\t(tag_summary): Likewise.\n+\t* gcov-io.c (gcov_write_summary): Do not dump\n+\thistogram.\n+\t(gcov_read_summary): Likewise.\n+\t(gcov_histo_index): Remove.\n+\t(gcov_histogram_merge): Likewise.\n+\t(compute_working_sets): Likewise.\n+\t* gcov-io.h (GCOV_TAG_OBJECT_SUMMARY): Mark\n+\tit not obsolete.\n+\t(GCOV_TAG_PROGRAM_SUMMARY): Mark it obsolete.\n+\t(GCOV_TAG_SUMMARY_LENGTH): Adjust.\n+\t(GCOV_HISTOGRAM_SIZE): Remove.\n+\t(GCOV_HISTOGRAM_BITVECTOR_SIZE): Likewise.\n+\t(struct gcov_summary): Simplify rapidly just\n+\tto runs and sum_max fields.\n+\t(gcov_histo_index): Remove.\n+\t(NUM_GCOV_WORKING_SETS): Likewise.\n+\t(compute_working_sets): Likewise.\n+\t* gcov-tool.c (print_overlap_usage_message): Remove\n+\ttrailing empty line.\n+\t* gcov.c (read_count_file): Read GCOV_TAG_OBJECT_SUMMARY.\n+\t(output_lines): Remove program related line.\n+\t* ipa-profile.c (ipa_profile): Do not consider GCOV histogram.\n+\t* lto-cgraph.c (output_profile_summary): Do not stream GCOV\n+\thistogram.\n+\t(input_profile_summary): Do not read it.\n+\t(merge_profile_summaries): And do not merge it.\n+\t(input_symtab): Do not call removed function.\n+\t* modulo-sched.c (sms_schedule): Do not print sum_max.\n+\t* params.def (HOT_BB_COUNT_FRACTION): Reincarnate param that was\n+\tremoved when histogram method was invented.\n+\t(HOT_BB_COUNT_WS_PERMILLE): Mention that it's used only in LTO\n+\tmode.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Fix\n+\tGCOV coding style.\n+\t* predict.c (get_hot_bb_threshold): Use HOT_BB_COUNT_FRACTION\n+\tand dump selected value.\n+\t* profile.c (add_working_set): Remove.\n+\t(get_working_sets): Likewise.\n+\t(find_working_set): Likewise.\n+\t(get_exec_counts): Do not work with working sets.\n+\t(read_profile_edge_counts): Do not inform as sum_max is removed.\n+\t(compute_branch_probabilities): Likewise.\n+\t(compute_value_histograms): Remove argument for call of\n+\tget_coverage_counts.\n+\t* profile.h: Do not make gcov_summary const.\n+\n 2018-09-21  Monk Chiang  <sh.chiang04@gmail.com>\n \n \t* config.gcc (nds32*-*-*): Set TARGET_DEFAULT_TLSDESC_TRAMPOLINE=0."}, {"sha": "68abe327cce9da174e166c18224f53750a2817dc", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -867,7 +867,6 @@ autofdo_source_profile::read ()\n       function_instance::function_instance_stack stack;\n       function_instance *s = function_instance::read_function_instance (\n           &stack, gcov_read_counter ());\n-      afdo_profile_info->sum_all += s->total_count ();\n       map_[s->name ()] = s;\n     }\n   return true;\n@@ -958,23 +957,6 @@ read_profile (void)\n \n   /* autofdo_module_profile.  */\n   fake_read_autofdo_module_profile ();\n-\n-  /* Read in the working set.  */\n-  if (gcov_read_unsigned () != GCOV_TAG_AFDO_WORKING_SET)\n-    {\n-      error (\"cannot read working set from %s\", auto_profile_file);\n-      return;\n-    }\n-\n-  /* Skip the length of the section.  */\n-  gcov_read_unsigned ();\n-  gcov_working_set_t set[128];\n-  for (unsigned i = 0; i < 128; i++)\n-    {\n-      set[i].num_counters = gcov_read_unsigned ();\n-      set[i].min_counter = gcov_read_counter ();\n-    }\n-  add_working_set (set);\n }\n \n /* From AutoFDO profiles, find values inside STMT for that we want to measure\n@@ -1685,7 +1667,6 @@ read_autofdo_file (void)\n   autofdo::afdo_profile_info = XNEW (gcov_summary);\n   autofdo::afdo_profile_info->runs = 1;\n   autofdo::afdo_profile_info->sum_max = 0;\n-  autofdo::afdo_profile_info->sum_all = 0;\n \n   /* Read the profile from the profile file.  */\n   autofdo::read_profile ();\n@@ -1712,7 +1693,7 @@ afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *edge)\n   if (count > 0)\n     {\n       bool is_hot;\n-      const gcov_summary *saved_profile_info = profile_info;\n+      gcov_summary *saved_profile_info = profile_info;\n       /* At early inline stage, profile_info is not set yet. We need to\n          temporarily set it to afdo_profile_info to calculate hotness.  */\n       profile_info = autofdo::afdo_profile_info;"}, {"sha": "26cce2bc63ac4ea50e3848184d11a1f20fdd235a", "filename": "gcc/coverage.c", "status": "modified", "additions": 9, "deletions": 50, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"params.h\"\n #include \"auto-profile.h\"\n+#include \"profile.h\"\n \n #include \"gcov-io.c\"\n \n@@ -73,7 +74,6 @@ struct counts_entry : pointer_hash <counts_entry>\n   unsigned lineno_checksum;\n   unsigned cfg_checksum;\n   gcov_type *counts;\n-  gcov_summary summary;\n \n   /* hash_table support.  */\n   static inline hashval_t hash (const counts_entry *);\n@@ -185,8 +185,6 @@ static void\n read_counts_file (void)\n {\n   gcov_unsigned_t fn_ident = 0;\n-  gcov_summary summary;\n-  unsigned new_summary = 1;\n   gcov_unsigned_t tag;\n   int is_error = 0;\n   unsigned lineno_checksum = 0;\n@@ -236,27 +234,12 @@ read_counts_file (void)\n \t    }\n \t  else\n \t    fn_ident = lineno_checksum = cfg_checksum = 0;\n-\t  new_summary = 1;\n \t}\n-      else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n+      else if (tag == GCOV_TAG_OBJECT_SUMMARY)\n \t{\n-\t  struct gcov_summary sum;\n-\n-\t  if (new_summary)\n-\t    memset (&summary, 0, sizeof (summary));\n-\n-\t  gcov_read_summary (&sum);\n-\t  summary.runs += sum.runs;\n-\t  summary.sum_all += sum.sum_all;\n-\t  if (summary.run_max < sum.run_max)\n-\t    summary.run_max = sum.run_max;\n-\t  summary.sum_max += sum.sum_max;\n-          if (new_summary)\n-\t    memcpy (summary.histogram, sum.histogram,\n-\t\tsizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-          else\n-\t    gcov_histogram_merge (summary.histogram, sum.histogram);\n-\t  new_summary = 0;\n+\t  profile_info = XCNEW (gcov_summary);\n+\t  profile_info->runs = gcov_read_unsigned ();\n+\t  profile_info->sum_max = gcov_read_unsigned ();\n \t}\n       else if (GCOV_TAG_IS_COUNTER (tag) && fn_ident)\n \t{\n@@ -276,9 +259,6 @@ read_counts_file (void)\n \t      entry->ctr = elt.ctr;\n \t      entry->lineno_checksum = lineno_checksum;\n \t      entry->cfg_checksum = cfg_checksum;\n-\t      if (elt.ctr == GCOV_COUNTER_ARCS)\n-\t\tentry->summary = summary;\n-              entry->summary.num = n_counts;\n \t      entry->counts = XCNEWVEC (gcov_type, n_counts);\n \t    }\n \t  else if (entry->lineno_checksum != lineno_checksum\n@@ -292,22 +272,6 @@ read_counts_file (void)\n \t      counts_hash = NULL;\n \t      break;\n \t    }\n-\t  else if (entry->summary.num != n_counts)\n-\t    {\n-\t      error (\"Profile data for function %u is corrupted\", fn_ident);\n-\t      error (\"number of counters is %d instead of %d\", entry->summary.num, n_counts);\n-\t      delete counts_hash;\n-\t      counts_hash = NULL;\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      entry->summary.runs += summary.runs;\n-\t      entry->summary.sum_all += summary.sum_all;\n-\t      if (entry->summary.run_max < summary.run_max)\n-\t\tentry->summary.run_max = summary.run_max;\n-\t      entry->summary.sum_max += summary.sum_max;\n-\t    }\n \t  for (ix = 0; ix != n_counts; ix++)\n \t    entry->counts[ix] += gcov_read_counter ();\n \t}\n@@ -330,9 +294,8 @@ read_counts_file (void)\n /* Returns the counters for a particular tag.  */\n \n gcov_type *\n-get_coverage_counts (unsigned counter, unsigned expected,\n-                     unsigned cfg_checksum, unsigned lineno_checksum,\n-\t\t     const gcov_summary **summary)\n+get_coverage_counts (unsigned counter, unsigned cfg_checksum,\n+\t\t     unsigned lineno_checksum)\n {\n   counts_entry *entry, elt;\n \n@@ -363,14 +326,13 @@ get_coverage_counts (unsigned counter, unsigned expected,\n     }\n   elt.ctr = counter;\n   entry = counts_hash->find (&elt);\n-  if (!entry || !entry->summary.num)\n+  if (!entry)\n     /* The function was not emitted, or is weak and not chosen in the\n        final executable.  Silently fail, because there's nothing we\n        can do about it.  */\n     return NULL;\n   \n-  if (entry->cfg_checksum != cfg_checksum\n-      || entry->summary.num != expected)\n+  if (entry->cfg_checksum != cfg_checksum)\n     {\n       static int warned = 0;\n       bool warning_printed = false;\n@@ -414,9 +376,6 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \t       DECL_ASSEMBLER_NAME (current_function_decl));\n     }\n \n-  if (summary)\n-    *summary = &entry->summary;\n-\n   return entry->counts;\n }\n "}, {"sha": "d612c38d1592a80d8f70627f3a5b45e8ef033b15", "filename": "gcc/coverage.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -51,10 +51,8 @@ extern tree tree_coverage_counter_addr (unsigned /*counter*/, unsigned/*num*/);\n \n /* Get all the counters for the current function.  */\n extern gcov_type *get_coverage_counts (unsigned /*counter*/,\n-\t\t\t\t       unsigned /*expected*/,\n \t\t\t\t       unsigned /*cfg_checksum*/,\n-\t\t\t\t       unsigned /*lineno_checksum*/,\n-\t\t\t\t       const gcov_summary **);\n+\t\t\t\t       unsigned /*lineno_checksum*/);\n \n extern tree get_gcov_type (void);\n extern bool coverage_node_map_initialized_p (void);"}, {"sha": "0313358cdb029b1f0bc66a0df3227017eb5b795b", "filename": "gcc/doc/gcov-dump.texi", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fdoc%2Fgcov-dump.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fdoc%2Fgcov-dump.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov-dump.texi?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -61,7 +61,7 @@ gcov-dump [@option{-v}|@option{--version}]\n      [@option{-h}|@option{--help}]\n      [@option{-l}|@option{--long}]\n      [@option{-p}|@option{--positions}]\n-     [@option{-w}|@option{--working-sets}] @var{gcovfiles}\n+     @var{gcovfiles}\n @c man end\n @end ignore\n \n@@ -84,10 +84,6 @@ Dump positions of records.\n @itemx --version\n Display the @command{gcov-dump} version number (on the standard output),\n and exit without doing any further processing.\n-\n-@item -w\n-@itemx --working-sets\n-Dump working set computed from summary.\n @end table\n \n @c man end"}, {"sha": "7762e4e819088ffd2950b4e3d0d139d6ec42e591", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 3, "deletions": 78, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -38,9 +38,6 @@ static void tag_arcs (const char *, unsigned, unsigned, unsigned);\n static void tag_lines (const char *, unsigned, unsigned, unsigned);\n static void tag_counters (const char *, unsigned, unsigned, unsigned);\n static void tag_summary (const char *, unsigned, unsigned, unsigned);\n-static void dump_working_sets (const char *filename ATTRIBUTE_UNUSED,\n-\t\t\t       const gcov_summary *summary,\n-\t\t\t       unsigned depth);\n extern int main (int, char **);\n \n typedef struct tag_format\n@@ -52,15 +49,13 @@ typedef struct tag_format\n \n static int flag_dump_contents = 0;\n static int flag_dump_positions = 0;\n-static int flag_dump_working_sets = 0;\n \n static const struct option options[] =\n {\n   { \"help\",                 no_argument,       NULL, 'h' },\n   { \"version\",              no_argument,       NULL, 'v' },\n   { \"long\",                 no_argument,       NULL, 'l' },\n   { \"positions\",\t    no_argument,       NULL, 'o' },\n-  { \"working-sets\",\t    no_argument,       NULL, 'w' },\n   { 0, 0, 0, 0 }\n };\n \n@@ -77,7 +72,6 @@ static const tag_format_t tag_table[] =\n   {GCOV_TAG_ARCS, \"ARCS\", tag_arcs},\n   {GCOV_TAG_LINES, \"LINES\", tag_lines},\n   {GCOV_TAG_OBJECT_SUMMARY, \"OBJECT_SUMMARY\", tag_summary},\n-  {GCOV_TAG_PROGRAM_SUMMARY, \"PROGRAM_SUMMARY\", tag_summary},\n   {0, NULL, NULL}\n };\n \n@@ -117,9 +111,6 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n \tcase 'p':\n \t  flag_dump_positions = 1;\n \t  break;\n-\tcase 'w':\n-\t  flag_dump_working_sets = 1;\n-\t  break;\n \tdefault:\n \t  fprintf (stderr, \"unknown flag `%c'\\n\", opt);\n \t}\n@@ -139,7 +130,6 @@ print_usage (void)\n   printf (\"  -l, --long           Dump record contents too\\n\");\n   printf (\"  -p, --positions      Dump record positions\\n\");\n   printf (\"  -v, --version        Print version number\\n\");\n-  printf (\"  -w, --working-sets   Dump working set computed from summary\\n\");\n   printf (\"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n \t   bug_report_url);\n }\n@@ -465,75 +455,10 @@ tag_counters (const char *filename ATTRIBUTE_UNUSED,\n static void\n tag_summary (const char *filename ATTRIBUTE_UNUSED,\n \t     unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED,\n-\t     unsigned depth)\n+\t     unsigned depth ATTRIBUTE_UNUSED)\n {\n   gcov_summary summary;\n-  unsigned h_ix;\n-  gcov_bucket_type *histo_bucket;\n-\n   gcov_read_summary (&summary);\n-  printf (\" checksum=0x%08x\", summary.checksum);\n-\n-  printf (\"\\n\");\n-  print_prefix (filename, depth, 0);\n-  printf (VALUE_PADDING_PREFIX \"counts=%u, runs=%u\",\n-\t  summary.num, summary.runs);\n-\n-  printf (\", sum_all=%\" PRId64,\n-\t  (int64_t)summary.sum_all);\n-  printf (\", run_max=%\" PRId64,\n-\t  (int64_t)summary.run_max);\n-  printf (\", sum_max=%\" PRId64,\n-\t  (int64_t)summary.sum_max);\n-  printf (\"\\n\");\n-  print_prefix (filename, depth, 0);\n-  printf (VALUE_PADDING_PREFIX \"counter histogram:\");\n-  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    {\n-      histo_bucket = &summary.histogram[h_ix];\n-      if (!histo_bucket->num_counters)\n-\tcontinue;\n-      printf (\"\\n\");\n-      print_prefix (filename, depth, 0);\n-      printf (VALUE_PADDING_PREFIX VALUE_PREFIX \"num counts=%u, \"\n-\t      \"min counter=%\" PRId64 \", cum_counter=%\" PRId64,\n-\t      h_ix, histo_bucket->num_counters,\n-\t      (int64_t)histo_bucket->min_value,\n-\t      (int64_t)histo_bucket->cum_value);\n-    }\n-  if (flag_dump_working_sets)\n-    dump_working_sets (filename, &summary, depth);\n-}\n-\n-static void\n-dump_working_sets (const char *filename ATTRIBUTE_UNUSED,\n-\t\t   const gcov_summary *summary,\n-\t\t   unsigned depth)\n-{\n-  gcov_working_set_t gcov_working_sets[NUM_GCOV_WORKING_SETS];\n-  unsigned ws_ix, pctinc, pct;\n-  gcov_working_set_t *ws_info;\n-\n-  compute_working_sets (summary, gcov_working_sets);\n-\n-  printf (\"\\n\");\n-  print_prefix (filename, depth, 0);\n-  printf (VALUE_PADDING_PREFIX \"counter working sets:\");\n-  /* Multiply the percentage by 100 to avoid float.  */\n-  pctinc = 100 * 100 / NUM_GCOV_WORKING_SETS;\n-  for (ws_ix = 0, pct = pctinc; ws_ix < NUM_GCOV_WORKING_SETS;\n-       ws_ix++, pct += pctinc)\n-    {\n-      if (ws_ix == NUM_GCOV_WORKING_SETS - 1)\n-        pct = 9990;\n-      ws_info = &gcov_working_sets[ws_ix];\n-      /* Print out the percentage using int arithmatic to avoid float.  */\n-      printf (\"\\n\");\n-      print_prefix (filename, depth + 1, 0);\n-      printf (VALUE_PADDING_PREFIX \"%u.%02u%%: num counts=%u, min counter=\"\n-               \"%\" PRId64,\n-               pct / 100, pct - (pct / 100 * 100),\n-               ws_info->num_counters,\n-               (int64_t)ws_info->min_counter);\n-    }\n+  printf (\" runs=%d, sum_max=%\" PRId64,\n+\t  summary.runs, summary.sum_max);\n }"}, {"sha": "63cc7fcb048b1d645b4730d26f338b98ab7ed4e9", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 4, "deletions": 394, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -446,39 +446,11 @@ gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n GCOV_LINKAGE void\n gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n {\n-  unsigned h_ix, bv_ix, h_cnt = 0;\n-  unsigned histo_bitvector[GCOV_HISTOGRAM_BITVECTOR_SIZE];\n-\n-  /* Count number of non-zero histogram entries, and fill in a bit vector\n-     of non-zero indices. The histogram is only currently computed for arc\n-     counters.  */\n-  for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n-    histo_bitvector[bv_ix] = 0;\n-  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    if (summary->histogram[h_ix].num_counters)\n-      {\n-\thisto_bitvector[h_ix / 32] |= 1 << (h_ix % 32);\n-\th_cnt++;\n-      }\n-  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH (h_cnt));\n-  gcov_write_unsigned (summary->checksum);\n-\n-  gcov_write_unsigned (summary->num);\n+  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH);\n   gcov_write_unsigned (summary->runs);\n-  gcov_write_counter (summary->sum_all);\n-  gcov_write_counter (summary->run_max);\n-  gcov_write_counter (summary->sum_max);\n-  for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n-    gcov_write_unsigned (histo_bitvector[bv_ix]);\n-  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    {\n-      if (!summary->histogram[h_ix].num_counters)\n-\tcontinue;\n-      gcov_write_unsigned (summary->histogram[h_ix].num_counters);\n-      gcov_write_counter (summary->histogram[h_ix].min_value);\n-      gcov_write_counter (summary->histogram[h_ix].cum_value);\n-    }\n+  gcov_write_unsigned (summary->sum_max);\n }\n+\n #endif /* IN_LIBGCOV */\n \n #endif /*!IN_GCOV */\n@@ -637,65 +609,8 @@ gcov_read_string (void)\n GCOV_LINKAGE void\n gcov_read_summary (struct gcov_summary *summary)\n {\n-  unsigned h_ix, bv_ix, h_cnt = 0;\n-  unsigned histo_bitvector[GCOV_HISTOGRAM_BITVECTOR_SIZE];\n-  unsigned cur_bitvector;\n-\n-  summary->checksum = gcov_read_unsigned ();\n-  summary->num = gcov_read_unsigned ();\n   summary->runs = gcov_read_unsigned ();\n-  summary->sum_all = gcov_read_counter ();\n-  summary->run_max = gcov_read_counter ();\n-  summary->sum_max = gcov_read_counter ();\n-  memset (summary->histogram, 0,\n-\t  sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-  for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n-    {\n-      histo_bitvector[bv_ix] = gcov_read_unsigned ();\n-#if IN_LIBGCOV\n-      /* When building libgcov we don't include system.h, which includes\n-\t hwint.h (where popcount_hwi is declared). However, libgcov.a\n-\t is built by the bootstrapped compiler and therefore the builtins\n-\t are always available.  */\n-      h_cnt += __builtin_popcount (histo_bitvector[bv_ix]);\n-#else\n-      h_cnt += popcount_hwi (histo_bitvector[bv_ix]);\n-#endif\n-    }\n-  bv_ix = 0;\n-  h_ix = 0;\n-  cur_bitvector = 0;\n-  while (h_cnt--)\n-    {\n-      /* Find the index corresponding to the next entry we will read in.\n-\t First find the next non-zero bitvector and re-initialize\n-\t the histogram index accordingly, then right shift and increment\n-\t the index until we find a set bit.  */\n-      while (!cur_bitvector)\n-\t{\n-\t  h_ix = bv_ix * 32;\n-\t  if (bv_ix >= GCOV_HISTOGRAM_BITVECTOR_SIZE)\n-\t    gcov_error (\"corrupted profile info: summary histogram \"\n-\t\t\t\"bitvector is corrupt\");\n-\t  cur_bitvector = histo_bitvector[bv_ix++];\n-\t}\n-      while (!(cur_bitvector & 0x1))\n-\t{\n-\t  h_ix++;\n-\t  cur_bitvector >>= 1;\n-\t}\n-      if (h_ix >= GCOV_HISTOGRAM_SIZE)\n-\tgcov_error (\"corrupted profile info: summary histogram \"\n-\t\t    \"index is corrupt\");\n-\n-      summary->histogram[h_ix].num_counters = gcov_read_unsigned ();\n-      summary->histogram[h_ix].min_value = gcov_read_counter ();\n-      summary->histogram[h_ix].cum_value = gcov_read_counter ();\n-      /* Shift off the index we are done with and increment to the\n-\t corresponding next histogram entry.  */\n-      cur_bitvector >>= 1;\n-      h_ix++;\n-    }\n+  summary->sum_max = gcov_read_unsigned ();\n }\n \n /* We need to expose the below function when compiling for gcov-tool.  */\n@@ -747,308 +662,3 @@ gcov_time (void)\n     return status.st_mtime;\n }\n #endif /* IN_GCOV */\n-\n-#if !IN_GCOV\n-/* Determine the index into histogram for VALUE. */\n-\n-#if IN_LIBGCOV\n-static unsigned\n-#else\n-GCOV_LINKAGE unsigned\n-#endif\n-gcov_histo_index (gcov_type value)\n-{\n-  gcov_type_unsigned v = (gcov_type_unsigned)value;\n-  unsigned r = 0;\n-  unsigned prev2bits = 0;\n-\n-  /* Find index into log2 scale histogram, where each of the log2\n-     sized buckets is divided into 4 linear sub-buckets for better\n-     focus in the higher buckets.  */\n-\n-  /* Find the place of the most-significant bit set.  */\n-  if (v > 0)\n-    {\n-#if IN_LIBGCOV\n-      /* When building libgcov we don't include system.h, which includes\n-         hwint.h (where floor_log2 is declared). However, libgcov.a\n-         is built by the bootstrapped compiler and therefore the builtins\n-         are always available.  */\n-      r = sizeof (long long) * __CHAR_BIT__ - 1 - __builtin_clzll (v);\n-#else\n-      /* We use floor_log2 from hwint.c, which takes a HOST_WIDE_INT\n-         that is 64 bits and gcov_type_unsigned is 64 bits.  */\n-      r = floor_log2 (v);\n-#endif\n-    }\n-\n-  /* If at most the 2 least significant bits are set (value is\n-     0 - 3) then that value is our index into the lowest set of\n-     four buckets.  */\n-  if (r < 2)\n-    return (unsigned)value;\n-\n-  gcov_nonruntime_assert (r < 64);\n-\n-  /* Find the two next most significant bits to determine which\n-     of the four linear sub-buckets to select.  */\n-  prev2bits = (v >> (r - 2)) & 0x3;\n-  /* Finally, compose the final bucket index from the log2 index and\n-     the next 2 bits. The minimum r value at this point is 2 since we\n-     returned above if r was 2 or more, so the minimum bucket at this\n-     point is 4.  */\n-  return (r - 1) * 4 + prev2bits;\n-}\n-\n-/* Merge SRC_HISTO into TGT_HISTO. The counters are assumed to be in\n-   the same relative order in both histograms, and are matched up\n-   and merged in reverse order. Each counter is assigned an equal portion of\n-   its entry's original cumulative counter value when computing the\n-   new merged cum_value.  */\n-\n-static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n-                                  gcov_bucket_type *src_histo)\n-{\n-  int src_i, tgt_i, tmp_i = 0;\n-  unsigned src_num, tgt_num, merge_num;\n-  gcov_type src_cum, tgt_cum, merge_src_cum, merge_tgt_cum, merge_cum;\n-  gcov_type merge_min;\n-  gcov_bucket_type tmp_histo[GCOV_HISTOGRAM_SIZE];\n-  int src_done = 0;\n-\n-  memset (tmp_histo, 0, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-\n-  /* Assume that the counters are in the same relative order in both\n-     histograms. Walk the histograms from largest to smallest entry,\n-     matching up and combining counters in order.  */\n-  src_num = 0;\n-  src_cum = 0;\n-  src_i = GCOV_HISTOGRAM_SIZE - 1;\n-  for (tgt_i = GCOV_HISTOGRAM_SIZE - 1; tgt_i >= 0 && !src_done; tgt_i--)\n-    {\n-      tgt_num = tgt_histo[tgt_i].num_counters;\n-      tgt_cum = tgt_histo[tgt_i].cum_value;\n-      /* Keep going until all of the target histogram's counters at this\n-         position have been matched and merged with counters from the\n-         source histogram.  */\n-      while (tgt_num > 0 && !src_done)\n-        {\n-          /* If this is either the first time through this loop or we just\n-             exhausted the previous non-zero source histogram entry, look\n-             for the next non-zero source histogram entry.  */\n-          if (!src_num)\n-            {\n-              /* Locate the next non-zero entry.  */\n-              while (src_i >= 0 && !src_histo[src_i].num_counters)\n-                src_i--;\n-              /* If source histogram has fewer counters, then just copy over the\n-                 remaining target counters and quit.  */\n-              if (src_i < 0)\n-                {\n-                  tmp_histo[tgt_i].num_counters += tgt_num;\n-                  tmp_histo[tgt_i].cum_value += tgt_cum;\n-                  if (!tmp_histo[tgt_i].min_value ||\n-                      tgt_histo[tgt_i].min_value < tmp_histo[tgt_i].min_value)\n-                    tmp_histo[tgt_i].min_value = tgt_histo[tgt_i].min_value;\n-                  while (--tgt_i >= 0)\n-                    {\n-                      tmp_histo[tgt_i].num_counters\n-                          += tgt_histo[tgt_i].num_counters;\n-                      tmp_histo[tgt_i].cum_value += tgt_histo[tgt_i].cum_value;\n-                      if (!tmp_histo[tgt_i].min_value ||\n-                          tgt_histo[tgt_i].min_value\n-                          < tmp_histo[tgt_i].min_value)\n-                        tmp_histo[tgt_i].min_value = tgt_histo[tgt_i].min_value;\n-                    }\n-\n-                  src_done = 1;\n-                  break;\n-                }\n-\n-              src_num = src_histo[src_i].num_counters;\n-              src_cum = src_histo[src_i].cum_value;\n-            }\n-\n-          /* The number of counters to merge on this pass is the minimum\n-             of the remaining counters from the current target and source\n-             histogram entries.  */\n-          merge_num = tgt_num;\n-          if (src_num < merge_num)\n-            merge_num = src_num;\n-\n-          /* The merged min_value is the sum of the min_values from target\n-             and source.  */\n-          merge_min = tgt_histo[tgt_i].min_value + src_histo[src_i].min_value;\n-\n-          /* Compute the portion of source and target entries' cum_value\n-             that will be apportioned to the counters being merged.\n-             The total remaining cum_value from each entry is divided\n-             equally among the counters from that histogram entry if we\n-             are not merging all of them.  */\n-          merge_src_cum = src_cum;\n-          if (merge_num < src_num)\n-            merge_src_cum = merge_num * src_cum / src_num;\n-          merge_tgt_cum = tgt_cum;\n-          if (merge_num < tgt_num)\n-            merge_tgt_cum = merge_num * tgt_cum / tgt_num;\n-          /* The merged cum_value is the sum of the source and target\n-             components.  */\n-          merge_cum = merge_src_cum + merge_tgt_cum;\n-\n-          /* Update the remaining number of counters and cum_value left\n-             to be merged from this source and target entry.  */\n-          src_cum -= merge_src_cum;\n-          tgt_cum -= merge_tgt_cum;\n-          src_num -= merge_num;\n-          tgt_num -= merge_num;\n-\n-          /* The merged counters get placed in the new merged histogram\n-             at the entry for the merged min_value.  */\n-          tmp_i = gcov_histo_index (merge_min);\n-          gcov_nonruntime_assert (tmp_i < GCOV_HISTOGRAM_SIZE);\n-          tmp_histo[tmp_i].num_counters += merge_num;\n-          tmp_histo[tmp_i].cum_value += merge_cum;\n-          if (!tmp_histo[tmp_i].min_value ||\n-              merge_min < tmp_histo[tmp_i].min_value)\n-            tmp_histo[tmp_i].min_value = merge_min;\n-\n-          /* Ensure the search for the next non-zero src_histo entry starts\n-             at the next smallest histogram bucket.  */\n-          if (!src_num)\n-            src_i--;\n-        }\n-    }\n-\n-  gcov_nonruntime_assert (tgt_i < 0);\n-\n-  /* In the case where there were more counters in the source histogram,\n-     accumulate the remaining unmerged cumulative counter values. Add\n-     those to the smallest non-zero target histogram entry. Otherwise,\n-     the total cumulative counter values in the histogram will be smaller\n-     than the sum_all stored in the summary, which will complicate\n-     computing the working set information from the histogram later on.  */\n-  if (src_num)\n-    src_i--;\n-  while (src_i >= 0)\n-    {\n-      src_cum += src_histo[src_i].cum_value;\n-      src_i--;\n-    }\n-  /* At this point, tmp_i should be the smallest non-zero entry in the\n-     tmp_histo.  */\n-  gcov_nonruntime_assert (tmp_i >= 0 && tmp_i < GCOV_HISTOGRAM_SIZE\n-                          && tmp_histo[tmp_i].num_counters > 0);\n-  tmp_histo[tmp_i].cum_value += src_cum;\n-\n-  /* Finally, copy the merged histogram into tgt_histo.  */\n-  memcpy (tgt_histo, tmp_histo,\n-\t  sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-}\n-#endif /* !IN_GCOV */\n-\n-/* This is used by gcov-dump (IN_GCOV == -1) and in the compiler\n-   (!IN_GCOV && !IN_LIBGCOV).  */\n-#if IN_GCOV <= 0 && !IN_LIBGCOV\n-/* Compute the working set information from the counter histogram in\n-   the profile summary. This is an array of information corresponding to a\n-   range of percentages of the total execution count (sum_all), and includes\n-   the number of counters required to cover that working set percentage and\n-   the minimum counter value in that working set.  */\n-\n-GCOV_LINKAGE void\n-compute_working_sets (const gcov_summary *summary,\n-                      gcov_working_set_t *gcov_working_sets)\n-{\n-  gcov_type working_set_cum_values[NUM_GCOV_WORKING_SETS];\n-  gcov_type ws_cum_hotness_incr;\n-  gcov_type cum, tmp_cum;\n-  const gcov_bucket_type *histo_bucket;\n-  unsigned ws_ix, c_num, count;\n-  int h_ix;\n-\n-  /* Compute the amount of sum_all that the cumulative hotness grows\n-     by in each successive working set entry, which depends on the\n-     number of working set entries.  */\n-  ws_cum_hotness_incr = summary->sum_all / NUM_GCOV_WORKING_SETS;\n-\n-  /* Next fill in an array of the cumulative hotness values corresponding\n-     to each working set summary entry we are going to compute below.\n-     Skip 0% statistics, which can be extrapolated from the\n-     rest of the summary data.  */\n-  cum = ws_cum_hotness_incr;\n-  for (ws_ix = 0; ws_ix < NUM_GCOV_WORKING_SETS;\n-       ws_ix++, cum += ws_cum_hotness_incr)\n-    working_set_cum_values[ws_ix] = cum;\n-  /* The last summary entry is reserved for (roughly) 99.9% of the\n-     working set. Divide by 1024 so it becomes a shift, which gives\n-     almost exactly 99.9%.  */\n-  working_set_cum_values[NUM_GCOV_WORKING_SETS-1]\n-      = summary->sum_all - summary->sum_all/1024;\n-\n-  /* Next, walk through the histogram in decending order of hotness\n-     and compute the statistics for the working set summary array.\n-     As histogram entries are accumulated, we check to see which\n-     working set entries have had their expected cum_value reached\n-     and fill them in, walking the working set entries in increasing\n-     size of cum_value.  */\n-  ws_ix = 0; /* The current entry into the working set array.  */\n-  cum = 0; /* The current accumulated counter sum.  */\n-  count = 0; /* The current accumulated count of block counters.  */\n-  for (h_ix = GCOV_HISTOGRAM_SIZE - 1;\n-       h_ix >= 0 && ws_ix < NUM_GCOV_WORKING_SETS; h_ix--)\n-    {\n-      histo_bucket = &summary->histogram[h_ix];\n-\n-      /* If we haven't reached the required cumulative counter value for\n-         the current working set percentage, simply accumulate this histogram\n-         entry into the running sums and continue to the next histogram\n-         entry.  */\n-      if (cum + histo_bucket->cum_value < working_set_cum_values[ws_ix])\n-        {\n-          cum += histo_bucket->cum_value;\n-          count += histo_bucket->num_counters;\n-          continue;\n-        }\n-\n-      /* If adding the current histogram entry's cumulative counter value\n-         causes us to exceed the current working set size, then estimate\n-         how many of this histogram entry's counter values are required to\n-         reach the working set size, and fill in working set entries\n-         as we reach their expected cumulative value.  */\n-      for (c_num = 0, tmp_cum = cum;\n-           c_num < histo_bucket->num_counters && ws_ix < NUM_GCOV_WORKING_SETS;\n-           c_num++)\n-        {\n-          count++;\n-          /* If we haven't reached the last histogram entry counter, add\n-             in the minimum value again. This will underestimate the\n-             cumulative sum so far, because many of the counter values in this\n-             entry may have been larger than the minimum. We could add in the\n-             average value every time, but that would require an expensive\n-             divide operation.  */\n-          if (c_num + 1 < histo_bucket->num_counters)\n-            tmp_cum += histo_bucket->min_value;\n-          /* If we have reached the last histogram entry counter, then add\n-             in the entire cumulative value.  */\n-          else\n-            tmp_cum = cum + histo_bucket->cum_value;\n-\n-\t  /* Next walk through successive working set entries and fill in\n-\t     the statistics for any whose size we have reached by accumulating\n-\t     this histogram counter.  */\n-\t  while (ws_ix < NUM_GCOV_WORKING_SETS\n-\t\t && tmp_cum >= working_set_cum_values[ws_ix])\n-            {\n-              gcov_working_sets[ws_ix].num_counters = count;\n-              gcov_working_sets[ws_ix].min_counter\n-                  = histo_bucket->min_value;\n-              ws_ix++;\n-            }\n-        }\n-      /* Finally, update the running cumulative value since we were\n-         using a temporary above.  */\n-      cum += histo_bucket->cum_value;\n-    }\n-  gcov_nonruntime_assert (ws_ix == NUM_GCOV_WORKING_SETS);\n-}\n-#endif /* IN_GCOV <= 0 && !IN_LIBGCOV */"}, {"sha": "1fc31f52eeefb302cf8a9e4feb6c09cb6f134e00", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 7, "deletions": 64, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -133,17 +133,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    blocks they are for.\n \n    The data file contains the following records.\n-        data: {unit summary:object summary:program* function-data*}*\n+\tdata: {unit summary:object function-data*}*\n \tunit: header int32:checksum\n-        function-data:\tannounce_function present counts\n+\tfunction-data:\tannounce_function present counts\n \tannounce_function: header int32:ident\n \t\tint32:lineno_checksum int32:cfg_checksum\n \tpresent: header int32:present\n \tcounts: header int64:count*\n-\tsummary: int32:checksum int32:num int32:runs int64:sum\n-\t\t int64:max int64:sum_max histogram\n-        histogram: {int32:bitvector}8 histogram-buckets*\n-        histogram-buckets: int32:num int64:min int64:sum\n+\tsummary: int32:checksum int32:runs int32:sum_max\n \n    The ANNOUNCE_FUNCTION record is the same as that in the note file,\n    but without the source location.  The COUNTS gives the\n@@ -190,7 +187,7 @@ typedef uint64_t gcov_type_unsigned;\n \n #define ATTRIBUTE_HIDDEN\n \n-#endif /* !IN_LIBGOCV */\n+#endif /* !IN_LIBGCOV */\n \n #ifndef GCOV_LINKAGE\n #define GCOV_LINKAGE extern\n@@ -240,9 +237,9 @@ typedef uint64_t gcov_type_unsigned;\n #define GCOV_TAG_COUNTER_BASE \t ((gcov_unsigned_t)0x01a10000)\n #define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 2)\n #define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n-#define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000) /* Obsolete */\n-#define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n-#define GCOV_TAG_SUMMARY_LENGTH(NUM) (1 + (10 + 3 * 2) + (NUM) * 5)\n+#define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000)\n+#define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000) /* Obsolete */\n+#define GCOV_TAG_SUMMARY_LENGTH (2)\n #define GCOV_TAG_AFDO_FILE_NAMES ((gcov_unsigned_t)0xaa000000)\n #define GCOV_TAG_AFDO_FUNCTION ((gcov_unsigned_t)0xac000000)\n #define GCOV_TAG_AFDO_WORKING_SET ((gcov_unsigned_t)0xaf000000)\n@@ -307,43 +304,12 @@ GCOV_COUNTERS\n #define GCOV_ARC_FAKE\t\t(1 << 1)\n #define GCOV_ARC_FALLTHROUGH\t(1 << 2)\n \n-/* Structured records.  */\n-\n-/* Structure used for each bucket of the log2 histogram of counter values.  */\n-typedef struct\n-{\n-  /* Number of counters whose profile count falls within the bucket.  */\n-  gcov_unsigned_t num_counters;\n-  /* Smallest profile count included in this bucket.  */\n-  gcov_type min_value;\n-  /* Cumulative value of the profile counts in this bucket.  */\n-  gcov_type cum_value;\n-} gcov_bucket_type;\n-\n-/* For a log2 scale histogram with each range split into 4\n-   linear sub-ranges, there will be at most 64 (max gcov_type bit size) - 1 log2\n-   ranges since the lowest 2 log2 values share the lowest 4 linear\n-   sub-range (values 0 - 3).  This is 252 total entries (63*4).  */\n-\n-#define GCOV_HISTOGRAM_SIZE 252\n-\n-/* How many unsigned ints are required to hold a bit vector of non-zero\n-   histogram entries when the histogram is written to the gcov file.\n-   This is essentially a ceiling divide by 32 bits.  */\n-#define GCOV_HISTOGRAM_BITVECTOR_SIZE (GCOV_HISTOGRAM_SIZE + 31) / 32\n-\n /* Object & program summary record.  */\n \n struct gcov_summary\n {\n-  gcov_unsigned_t checksum;\t/* Checksum of program.  */\n-  gcov_unsigned_t num;\t\t/* Number of counters.  */\n   gcov_unsigned_t runs;\t\t/* Number of program runs.  */\n-  gcov_type sum_all;\t\t/* Sum of all counters accumulated.  */\n-  gcov_type run_max;\t\t/* Maximum value on a single run.  */\n   gcov_type sum_max;    \t/* Sum of individual run max values.  */\n-  gcov_bucket_type histogram[GCOV_HISTOGRAM_SIZE]; /* Histogram of\n-\t\t\t\t\t\t      counter values.  */\n };\n \n #if !defined(inhibit_libc)\n@@ -380,35 +346,12 @@ GCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t) ATTRIBUTE_HIDDEN;\n \n #if !IN_GCOV && !IN_LIBGCOV\n /* Available only in compiler */\n-GCOV_LINKAGE unsigned gcov_histo_index (gcov_type value);\n GCOV_LINKAGE void gcov_write_string (const char *);\n GCOV_LINKAGE void gcov_write_filename (const char *);\n GCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\n GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n #endif\n \n-#if IN_GCOV <= 0 && !IN_LIBGCOV\n-/* Available in gcov-dump and the compiler.  */\n-\n-/* Number of data points in the working set summary array. Using 128\n-   provides information for at least every 1% increment of the total\n-   profile size. The last entry is hardwired to 99.9% of the total.  */\n-#define NUM_GCOV_WORKING_SETS 128\n-\n-/* Working set size statistics for a given percentage of the entire\n-   profile (sum_all from the counter summary).  */\n-typedef struct gcov_working_set_info\n-{\n-  /* Number of hot counters included in this working set.  */\n-  unsigned num_counters;\n-  /* Smallest counter included in this working set.  */\n-  gcov_type min_counter;\n-} gcov_working_set_t;\n-\n-GCOV_LINKAGE void compute_working_sets (const gcov_summary *summary,\n-                                        gcov_working_set_t *gcov_working_sets);\n-#endif\n-\n #if IN_GCOV > 0\n /* Available in gcov */\n GCOV_LINKAGE time_t gcov_time (void);"}, {"sha": "88539f9647f143fedf6e34e27a3bde6c1506b8d2", "filename": "gcc/gcov-tool.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-tool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov-tool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-tool.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -423,7 +423,6 @@ print_overlap_usage_message (int error_p)\n   fnotice (file, \"    -o, --object                        Print object level info\\n\");\n   fnotice (file, \"    -t <float>, --hot_threshold <float> Set the threshold for hotness\\n\");\n   fnotice (file, \"    -v, --verbose                       Verbose mode\\n\");\n-\n }\n \n static const struct option overlap_options[] ="}, {"sha": "922e2de2646bf37c0573ad28e49091341a307e03", "filename": "gcc/gcov.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -418,7 +418,6 @@ static vector<char *> processed_files;\n /* This holds data summary information.  */\n \n static unsigned object_runs;\n-static unsigned program_count;\n \n static unsigned total_lines;\n static unsigned total_executed;\n@@ -1829,12 +1828,11 @@ read_count_file (void)\n       unsigned length = gcov_read_unsigned ();\n       unsigned long base = gcov_position ();\n \n-      if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n+      if (tag == GCOV_TAG_OBJECT_SUMMARY)\n \t{\n \t  struct gcov_summary summary;\n \t  gcov_read_summary (&summary);\n-\t  object_runs += summary.runs;\n-\t  program_count++;\n+\t  object_runs = summary.runs;\n \t}\n       else if (tag == GCOV_TAG_FUNCTION && !length)\n \t; /* placeholder  */\n@@ -2952,7 +2950,6 @@ output_lines (FILE *gcov_file, const source_info *src)\n \t       no_data_file ? \"-\" : da_file_name);\n       fprintf (gcov_file, DEFAULT_LINE_START \"Runs:%u\\n\", object_runs);\n     }\n-  fprintf (gcov_file, DEFAULT_LINE_START \"Programs:%u\\n\", program_count);\n \n   source_file = fopen (src->name, \"r\");\n   if (!source_file)"}, {"sha": "c74f4a4a41df7dc9b29a20b6fe48ab2ef8f3b8f1", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -25,13 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n      from profile feedback. This histogram is complete only with LTO,\n      otherwise it contains information only about the current unit.\n \n-     Similar histogram is also estimated by coverage runtime.  This histogram\n-     is not dependent on LTO, but it suffers from various defects; first\n-     gcov runtime is not weighting individual basic block by estimated execution\n-     time and second the merging of multiple runs makes assumption that the\n-     histogram distribution did not change.  Consequentely histogram constructed\n-     here may be more precise.\n-\n      The information is used to set hot/cold thresholds.\n    - Next speculative indirect call resolution is performed:  the local\n      profile pass assigns profile-id to each function and provide us with a\n@@ -512,25 +505,7 @@ ipa_profile (void)\n       gcov_type threshold;\n \n       gcc_assert (overall_size);\n-      if (dump_file)\n-\t{\n-\t  gcov_type min, cumulated_time = 0, cumulated_size = 0;\n \n-\t  fprintf (dump_file, \"Overall time: %\" PRId64\"\\n\",\n-\t\t   (int64_t)overall_time);\n-\t  min = get_hot_bb_threshold ();\n-          for (i = 0; i < (int)histogram.length () && histogram[i]->count >= min;\n-\t       i++)\n-\t    {\n-\t      cumulated_time += histogram[i]->count * histogram[i]->time;\n-\t      cumulated_size += histogram[i]->size;\n-\t    }\n-\t  fprintf (dump_file, \"GCOV min count: %\" PRId64\n-\t\t   \" Time:%3.2f%% Size:%3.2f%%\\n\", \n-\t\t   (int64_t)min,\n-\t\t   cumulated_time * 100.0 / overall_time,\n-\t\t   cumulated_size * 100.0 / overall_size);\n-\t}\n       cutoff = (overall_time * PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE) + 500) / 1000;\n       threshold = 0;\n       for (i = 0; cumulated < cutoff; i++)\n@@ -557,6 +532,7 @@ ipa_profile (void)\n \t\t   cumulated_time * 100.0 / overall_time,\n \t\t   cumulated_size * 100.0 / overall_size);\n \t}\n+\n       if (threshold > get_hot_bb_threshold ()\n \t  || in_lto_p)\n \t{"}, {"sha": "6d9eea13f223098f23cd41920e7ebbbb9b8a7dd7", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 6, "deletions": 130, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -693,39 +693,14 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n static void\n output_profile_summary (struct lto_simple_output_block *ob)\n {\n-  unsigned h_ix;\n-  struct bitpack_d bp;\n-\n   if (profile_info)\n     {\n       /* We do not output num and run_max, they are not used by\n          GCC profile feedback and they are difficult to merge from multiple\n          units.  */\n-      gcc_assert (profile_info->runs);\n-      streamer_write_uhwi_stream (ob->main_stream, profile_info->runs);\n-      streamer_write_gcov_count_stream (ob->main_stream, profile_info->sum_max);\n+      unsigned runs = (profile_info->runs);\n+      streamer_write_uhwi_stream (ob->main_stream, runs);\n \n-      /* sum_all is needed for computing the working set with the\n-         histogram.  */\n-      streamer_write_gcov_count_stream (ob->main_stream, profile_info->sum_all);\n-\n-      /* Create and output a bitpack of non-zero histogram entries indices.  */\n-      bp = bitpack_create (ob->main_stream);\n-      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-        bp_pack_value (&bp, profile_info->histogram[h_ix].num_counters > 0, 1);\n-      streamer_write_bitpack (&bp);\n-      /* Now stream out only those non-zero entries.  */\n-      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-        {\n-          if (!profile_info->histogram[h_ix].num_counters)\n-            continue;\n-          streamer_write_gcov_count_stream (ob->main_stream,\n-                                      profile_info->histogram[h_ix].num_counters);\n-          streamer_write_gcov_count_stream (ob->main_stream,\n-                                      profile_info->histogram[h_ix].min_value);\n-          streamer_write_gcov_count_stream (ob->main_stream,\n-                                      profile_info->histogram[h_ix].cum_value);\n-         }\n       /* IPA-profile computes hot bb threshold based on cumulated\n \t whole program profile.  We need to stream it down to ltrans.  */\n        if (flag_wpa)\n@@ -1591,46 +1566,16 @@ input_refs (struct lto_input_block *ib,\n     }\n }\n \t    \n-\n-static gcov_summary lto_gcov_summary;\n-\n /* Input profile_info from IB.  */\n static void\n input_profile_summary (struct lto_input_block *ib,\n \t\t       struct lto_file_decl_data *file_data)\n {\n-  unsigned h_ix;\n-  struct bitpack_d bp;\n   unsigned int runs = streamer_read_uhwi (ib);\n   if (runs)\n     {\n       file_data->profile_info.runs = runs;\n-      file_data->profile_info.sum_max = streamer_read_gcov_count (ib);\n-      file_data->profile_info.sum_all = streamer_read_gcov_count (ib);\n-\n-      memset (file_data->profile_info.histogram, 0,\n-              sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-      /* Input the bitpack of non-zero histogram indices.  */\n-      bp = streamer_read_bitpack (ib);\n-      /* Read in and unpack the full bitpack, flagging non-zero\n-         histogram entries by setting the num_counters non-zero.  */\n-      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-        {\n-          file_data->profile_info.histogram[h_ix].num_counters\n-              = bp_unpack_value (&bp, 1);\n-        }\n-      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-        {\n-          if (!file_data->profile_info.histogram[h_ix].num_counters)\n-            continue;\n-\n-          file_data->profile_info.histogram[h_ix].num_counters\n-              = streamer_read_gcov_count (ib);\n-          file_data->profile_info.histogram[h_ix].min_value\n-              = streamer_read_gcov_count (ib);\n-          file_data->profile_info.histogram[h_ix].cum_value\n-              = streamer_read_gcov_count (ib);\n-        }\n+\n       /* IPA-profile computes hot bb threshold based on cumulated\n \t whole program profile.  We need to stream it down to ltrans.  */\n       if (flag_ltrans)\n@@ -1645,13 +1590,10 @@ static void\n merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n {\n   struct lto_file_decl_data *file_data;\n-  unsigned int j, h_ix;\n+  unsigned int j;\n   gcov_unsigned_t max_runs = 0;\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n-  gcov_type saved_sum_all = 0;\n-  gcov_summary *saved_profile_info = 0;\n-  int saved_scale = 0;\n \n   /* Find unit with maximal number of runs.  If we ever get serious about\n      roundoff errors, we might also consider computing smallest common\n@@ -1672,70 +1614,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n       return;\n     }\n \n-  profile_info = &lto_gcov_summary;\n-  lto_gcov_summary.runs = max_runs;\n-  lto_gcov_summary.sum_max = 0;\n-  memset (lto_gcov_summary.histogram, 0,\n-          sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-\n-  /* Rescale all units to the maximal number of runs.\n-     sum_max can not be easily merged, as we have no idea what files come from\n-     the same run.  We do not use the info anyway, so leave it 0.  */\n-  for (j = 0; (file_data = file_data_vec[j]) != NULL; j++)\n-    if (file_data->profile_info.runs)\n-      {\n-\tint scale = GCOV_COMPUTE_SCALE (max_runs,\n-                                        file_data->profile_info.runs);\n-\tlto_gcov_summary.sum_max\n-            = MAX (lto_gcov_summary.sum_max,\n-                   apply_scale (file_data->profile_info.sum_max, scale));\n-\tlto_gcov_summary.sum_all\n-            = MAX (lto_gcov_summary.sum_all,\n-                   apply_scale (file_data->profile_info.sum_all, scale));\n-        /* Save a pointer to the profile_info with the largest\n-           scaled sum_all and the scale for use in merging the\n-           histogram.  */\n-        if (!saved_profile_info\n-            || lto_gcov_summary.sum_all > saved_sum_all)\n-          {\n-            saved_profile_info = &file_data->profile_info;\n-            saved_sum_all = lto_gcov_summary.sum_all;\n-            saved_scale = scale;\n-          }\n-      }\n-\n-  gcc_assert (saved_profile_info);\n-\n-  /* Scale up the histogram from the profile that had the largest\n-     scaled sum_all above.  */\n-  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    {\n-      /* Scale up the min value as we did the corresponding sum_all\n-         above. Use that to find the new histogram index.  */\n-      gcov_type scaled_min\n-          = apply_scale (saved_profile_info->histogram[h_ix].min_value,\n-                         saved_scale);\n-      /* The new index may be shared with another scaled histogram entry,\n-         so we need to account for a non-zero histogram entry at new_ix.  */\n-      unsigned new_ix = gcov_histo_index (scaled_min);\n-      lto_gcov_summary.histogram[new_ix].min_value\n-          = (lto_gcov_summary.histogram[new_ix].num_counters\n-             ? MIN (lto_gcov_summary.histogram[new_ix].min_value, scaled_min)\n-             : scaled_min);\n-      /* Some of the scaled counter values would ostensibly need to be placed\n-         into different (larger) histogram buckets, but we keep things simple\n-         here and place the scaled cumulative counter value in the bucket\n-         corresponding to the scaled minimum counter value.  */\n-      lto_gcov_summary.histogram[new_ix].cum_value\n-          += apply_scale (saved_profile_info->histogram[h_ix].cum_value,\n-                          saved_scale);\n-      lto_gcov_summary.histogram[new_ix].num_counters\n-          += saved_profile_info->histogram[h_ix].num_counters;\n-    }\n-\n-  /* Watch roundoff errors.  */\n-  if (lto_gcov_summary.sum_max < max_runs)\n-    lto_gcov_summary.sum_max = max_runs;\n+  profile_info = XCNEW (gcov_summary);\n+  profile_info->runs = max_runs;\n \n   /* If merging already happent at WPA time, we are done.  */\n   if (flag_ltrans)\n@@ -1814,10 +1694,6 @@ input_symtab (void)\n \n   merge_profile_summaries (file_data_vec);\n \n-  if (!flag_auto_profile)\n-    get_working_sets ();\n-\n-\n   /* Clear out the aux field that was used to store enough state to\n      tell which nodes should be overwritten.  */\n   FOR_EACH_FUNCTION (node)"}, {"sha": "121e6191afd30a61afde4d89eb5a53a5d26cdadc", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -1449,10 +1449,6 @@ sms_schedule (void)\n                   fprintf (dump_file, \"%\" PRId64 \"max %\" PRId64,\n                            (int64_t) trip_count, (int64_t) max_trip_count);\n                   fprintf (dump_file, \"\\n\");\n-\t      \t  fprintf (dump_file, \"SMS profile-sum-max \");\n-\t      \t  fprintf (dump_file, \"%\" PRId64,\n-\t          \t   (int64_t) profile_info->sum_max);\n-\t      \t  fprintf (dump_file, \"\\n\");\n \t    \t}\n \t    }\n           continue;\n@@ -1567,10 +1563,6 @@ sms_schedule (void)\n \t      fprintf (dump_file, \"%\" PRId64,\n \t               (int64_t) bb->count.to_gcov_type ());\n \t      fprintf (dump_file, \"\\n\");\n-\t      fprintf (dump_file, \"SMS profile-sum-max \");\n-\t      fprintf (dump_file, \"%\" PRId64,\n-\t               (int64_t) profile_info->sum_max);\n-\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  fprintf (dump_file, \"SMS doloop\\n\");\n \t  fprintf (dump_file, \"SMS built-ddg %d\\n\", g->num_nodes);"}, {"sha": "9f0697327d4220937ed66f855e1607cfe0d2eb52", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -393,10 +393,15 @@ DEFPARAM(PARAM_SMS_LOOP_AVERAGE_COUNT_THRESHOLD,\n \t \"A threshold on the average loop count considered by the swing modulo scheduler.\",\n \t 0, 0, 0)\n \n+DEFPARAM(HOT_BB_COUNT_FRACTION,\n+\t \"hot-bb-count-fraction\",\n+\t \"Select fraction of the maximal count of repetitions of basic block in program given basic \"\n+\t \"block needs to have to be considered hot (used in non-LTO mode)\",\n+\t 10000, 0, 0)\n DEFPARAM(HOT_BB_COUNT_WS_PERMILLE,\n \t \"hot-bb-count-ws-permille\",\n          \"A basic block profile count is considered hot if it contributes to \"\n-         \"the given permillage of the entire profiled execution.\",\n+         \"the given permillage of the entire profiled execution (used in LTO mode).\",\n \t 999, 0, 1000)\n DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n \t \"hot-bb-frequency-fraction\","}, {"sha": "b56993183d02294b9a2ea108fafa633ca1b57bd1", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -1161,7 +1161,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n       || (optimize_bb_for_size_p (bb) && npred_ok > 1)\n       /* If we don't have profile information we cannot tell if splitting\n          a critical edge is profitable or not so don't do it.  */\n-      || ((! profile_info || profile_status_for_fn (cfun) != PROFILE_READ\n+      || ((!profile_info || profile_status_for_fn (cfun) != PROFILE_READ\n \t   || targetm.cannot_modify_jumps_p ())\n \t  && critical_edge_split))\n     goto cleanup;"}, {"sha": "ab2dc8ed0316df9e126fdcac13913d21913f43bf", "filename": "gcc/predict.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -129,12 +129,13 @@ static gcov_type min_count = -1;\n gcov_type\n get_hot_bb_threshold ()\n {\n-  gcov_working_set_t *ws;\n   if (min_count == -1)\n     {\n-      ws = find_working_set (PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE));\n-      gcc_assert (ws);\n-      min_count = ws->min_counter;\n+      min_count\n+\t= profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Setting hotness threshold to %\" PRId64 \".\\n\",\n+\t\t min_count);\n     }\n   return min_count;\n }"}, {"sha": "2130319b081644698eab5b45cc85dd2b560429e0", "filename": "gcc/profile.c", "status": "modified", "additions": 7, "deletions": 109, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -84,11 +84,7 @@ struct bb_profile_info {\n \n /* Counter summary from the last set of coverage counts read.  */\n \n-const gcov_summary *profile_info;\n-\n-/* Counter working set information computed from the current counter\n-   summary. Not initialized unless profile_info summary is non-NULL.  */\n-static gcov_working_set_t gcov_working_sets[NUM_GCOV_WORKING_SETS];\n+gcov_summary *profile_info;\n \n /* Collect statistics on the performance of this pass for the entire source\n    file.  */\n@@ -103,14 +99,6 @@ static int total_num_times_called;\n static int total_hist_br_prob[20];\n static int total_num_branches;\n \n-/* Helper function to update gcov_working_sets.  */\n-\n-void add_working_set (gcov_working_set_t *set) {\n-  int i = 0;\n-  for (; i < NUM_GCOV_WORKING_SETS; i++)\n-    gcov_working_sets[i] = set[i];\n-}\n-\n /* Forward declarations.  */\n static void find_spanning_tree (struct edge_list *);\n \n@@ -207,60 +195,6 @@ instrument_values (histogram_values values)\n }\n \f\n \n-/* Fill the working set information into the profile_info structure.  */\n-\n-void\n-get_working_sets (void)\n-{\n-  unsigned ws_ix, pctinc, pct;\n-  gcov_working_set_t *ws_info;\n-\n-  if (!profile_info)\n-    return;\n-\n-  compute_working_sets (profile_info, gcov_working_sets);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Counter working sets:\\n\");\n-      /* Multiply the percentage by 100 to avoid float.  */\n-      pctinc = 100 * 100 / NUM_GCOV_WORKING_SETS;\n-      for (ws_ix = 0, pct = pctinc; ws_ix < NUM_GCOV_WORKING_SETS;\n-           ws_ix++, pct += pctinc)\n-        {\n-          if (ws_ix == NUM_GCOV_WORKING_SETS - 1)\n-            pct = 9990;\n-          ws_info = &gcov_working_sets[ws_ix];\n-          /* Print out the percentage using int arithmatic to avoid float.  */\n-          fprintf (dump_file, \"\\t\\t%u.%02u%%: num counts=%u, min counter=\"\n-                   \"%\" PRId64 \"\\n\",\n-                   pct / 100, pct - (pct / 100 * 100),\n-                   ws_info->num_counters,\n-                   (int64_t)ws_info->min_counter);\n-        }\n-    }\n-}\n-\n-/* Given a the desired percentage of the full profile (sum_all from the\n-   summary), multiplied by 10 to avoid float in PCT_TIMES_10, returns\n-   the corresponding working set information. If an exact match for\n-   the percentage isn't found, the closest value is used.  */\n-\n-gcov_working_set_t *\n-find_working_set (unsigned pct_times_10)\n-{\n-  unsigned i;\n-  if (!profile_info)\n-    return NULL;\n-  gcc_assert (pct_times_10 <= 1000);\n-  if (pct_times_10 >= 999)\n-    return &gcov_working_sets[NUM_GCOV_WORKING_SETS - 1];\n-  i = pct_times_10 * NUM_GCOV_WORKING_SETS / 1000;\n-  if (!i)\n-    return &gcov_working_sets[0];\n-  return &gcov_working_sets[i - 1];\n-}\n-\n /* Computes hybrid profile for all matching entries in da_file.  \n    \n    CFG_CHECKSUM is the precomputed checksum for the CFG.  */\n@@ -283,21 +217,14 @@ get_exec_counts (unsigned cfg_checksum, unsigned lineno_checksum)\n \t  num_edges++;\n     }\n \n-  counts = get_coverage_counts (GCOV_COUNTER_ARCS, num_edges, cfg_checksum,\n-\t\t\t\tlineno_checksum, &profile_info);\n+  counts = get_coverage_counts (GCOV_COUNTER_ARCS, cfg_checksum,\n+\t\t\t\tlineno_checksum);\n   if (!counts)\n     return NULL;\n \n-  get_working_sets ();\n-\n-  if (dump_file && profile_info)\n-    fprintf (dump_file, \"Merged %u profiles with maximal count %u.\\n\",\n-\t     profile_info->runs, (unsigned) profile_info->sum_max);\n-\n   return counts;\n }\n \n-\n static bool\n is_edge_inconsistent (vec<edge, va_gc> *edges)\n {\n@@ -439,29 +366,7 @@ read_profile_edge_counts (gcov_type *exec_counts)\n \t  {\n \t    num_edges++;\n \t    if (exec_counts)\n-\t      {\n-\t\tedge_gcov_count (e) = exec_counts[exec_counts_pos++];\n-\t\tif (edge_gcov_count (e) > profile_info->sum_max)\n-\t\t  {\n-\t\t    if (flag_profile_correction)\n-\t\t      {\n-\t\t\tstatic bool informed = 0;\n-\t\t\tif (dump_enabled_p () && !informed)\n-\t\t\t  {\n-\t\t\t    dump_location_t loc\n-\t\t\t      = dump_location_t::from_location_t\n-\t\t\t        (input_location);\n-\t\t\t    dump_printf_loc (MSG_NOTE, loc,\n-\t\t\t\t\t     \"corrupted profile info: edge count\"\n-\t\t\t\t\t     \" exceeds maximal count\\n\");\n-\t\t\t  }\n-\t\t\tinformed = 1;\n-\t\t      }\n-\t\t    else\n-\t\t      error (\"corrupted profile info: edge from %i to %i exceeds maximal count\",\n-\t\t\t     bb->index, e->dest->index);\n-\t\t  }\n-\t      }\n+\t      edge_gcov_count (e) = exec_counts[exec_counts_pos++];\n \t    else\n \t      edge_gcov_count (e) = 0;\n \n@@ -511,12 +416,6 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n   bb_gcov_counts.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   edge_gcov_counts = new hash_map<edge,gcov_type>;\n \n-  if (profile_info->sum_all < profile_info->sum_max)\n-    {\n-      error (\"corrupted profile info: sum_all is smaller than sum_max\");\n-      exec_counts = NULL;\n-    }\n-\n   /* Attach extra info block to each bb.  */\n   alloc_aux_for_blocks (sizeof (struct bb_profile_info));\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n@@ -871,10 +770,9 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n \t  continue;\n \t}\n \n-      histogram_counts[t] =\n-\tget_coverage_counts (COUNTER_FOR_HIST_TYPE (t),\n-\t\t\t     n_histogram_counters[t], cfg_checksum,\n-\t\t\t     lineno_checksum, NULL);\n+      histogram_counts[t] = get_coverage_counts (COUNTER_FOR_HIST_TYPE (t),\n+\t\t\t\t\t\t cfg_checksum,\n+\t\t\t\t\t\t lineno_checksum);\n       if (histogram_counts[t])\n \tany = 1;\n       act_count[t] = histogram_counts[t];"}, {"sha": "183e8d83b65e851a90968442113b5cec66ea020d", "filename": "gcc/profile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -75,6 +75,6 @@ extern void get_working_sets (void);\n \n /* Counter summary from the last set of coverage counts read by\n    profile.c.  */\n-extern const struct gcov_summary *profile_info;\n+extern struct gcov_summary *profile_info;\n \n #endif /* PROFILE_H */"}, {"sha": "b172d714851585633c2a4bb1ede7b026cccc13a0", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -1,3 +1,20 @@\n+2018-09-21  Martin Liska  <mliska@suse.cz>\n+\n+\t* libgcov-driver.c (crc32_unsigned): Remove.\n+\t(gcov_histogram_insert): Likewise.\n+\t(gcov_compute_histogram): Likewise.\n+\t(compute_summary): Simplify rapidly.\n+\t(merge_one_data): Do not handle PROGRAM_SUMMARY tag.\n+\t(merge_summary): Rapidly simplify.\n+\t(dump_one_gcov): Ignore gcov_summary.\n+\t(gcov_do_dump): Do not handle program summary, it's not\n+\tused.\n+\t* libgcov-util.c (tag_summary): Remove.\n+\t(read_gcda_finalize): Fix coding style.\n+\t(read_gcda_file): Initialize curr_object_summary.\n+\t(compute_summary): Remove.\n+\t(calculate_overlap): Remove settings of run_max.\n+\n 2018-09-21  Monk Chiang  <sh.chiang04@gmail.com>\n \n \t* config/nds32/linux-unwind.h (struct _rt_sigframe): Use struct"}, {"sha": "cdebb7473262665e4c589f70b3db0e0d08b1acd7", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 38, "deletions": 286, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -24,6 +24,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"libgcov.h\"\n+#include \"gcov-io.h\"\n \n #if defined(inhibit_libc)\n /* If libc and its header files are not available, provide dummy functions.  */\n@@ -156,25 +157,6 @@ buffer_fn_data (const char *filename, const struct gcov_info *gi_ptr,\n   return (struct gcov_fn_buffer **)free_fn_data (gi_ptr, fn_buffer, ix);\n }\n \n-/* Add an unsigned value to the current crc */\n-\n-static gcov_unsigned_t\n-crc32_unsigned (gcov_unsigned_t crc32, gcov_unsigned_t value)\n-{\n-  unsigned ix;\n-\n-  for (ix = 32; ix--; value <<= 1)\n-    {\n-      unsigned feedback;\n-\n-      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n-      crc32 <<= 1;\n-      crc32 ^= feedback;\n-    }\n-\n-  return crc32;\n-}\n-\n /* Check if VERSION of the info block PTR matches libgcov one.\n    Return 1 on success, or zero in case of versions mismatch.\n    If FILENAME is not NULL, its value used for reporting purposes\n@@ -198,117 +180,8 @@ gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,\n   return 1;\n }\n \n-/* Insert counter VALUE into HISTOGRAM.  */\n-\n-static void\n-gcov_histogram_insert(gcov_bucket_type *histogram, gcov_type value)\n-{\n-  unsigned i;\n-\n-  i = gcov_histo_index(value);\n-  histogram[i].num_counters++;\n-  histogram[i].cum_value += value;\n-  if (value < histogram[i].min_value)\n-    histogram[i].min_value = value;\n-}\n-\n-/* Computes a histogram of the arc counters to place in the summary SUM.  */\n-\n-static void\n-gcov_compute_histogram (struct gcov_info *list, struct gcov_summary *sum)\n-{\n-  struct gcov_info *gi_ptr;\n-  const struct gcov_fn_info *gfi_ptr;\n-  const struct gcov_ctr_info *ci_ptr;\n-  unsigned f_ix, ix;\n-  int h_ix;\n-\n-  /* First check if there are any counts recorded for this counter.  */\n-  if (!sum->num)\n-    return;\n-\n-  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    {\n-      sum->histogram[h_ix].num_counters = 0;\n-      sum->histogram[h_ix].min_value = sum->run_max;\n-      sum->histogram[h_ix].cum_value = 0;\n-    }\n-\n-  /* Walk through all the per-object structures and record each of\n-     the count values in histogram.  */\n-  for (gi_ptr = list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n-        {\n-          gfi_ptr = gi_ptr->functions[f_ix];\n-\n-          if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n-            continue;\n-\n-\t  ci_ptr = &gfi_ptr->ctrs[0];\n-\t  for (ix = 0; ix < ci_ptr->num; ix++)\n-\t    gcov_histogram_insert (sum->histogram, ci_ptr->values[ix]);\n-        }\n-    }\n-}\n-\n /* buffer for the fn_data from another program.  */\n static struct gcov_fn_buffer *fn_buffer;\n-/* buffer for summary from other programs to be written out. */\n-static struct gcov_summary_buffer *sum_buffer;\n-\n-/* This function computes the program level summary and the histo-gram.\n-   It computes and returns CRC32 and stored summary in THIS_PRG.  */\n-\n-#if !IN_GCOV_TOOL\n-static\n-#endif\n-gcov_unsigned_t\n-compute_summary (struct gcov_info *list, struct gcov_summary *this_prg)\n-{\n-  struct gcov_info *gi_ptr;\n-  const struct gcov_fn_info *gfi_ptr;\n-  const struct gcov_ctr_info *ci_ptr;\n-  int f_ix;\n-  gcov_unsigned_t c_num;\n-  gcov_unsigned_t crc32 = 0;\n-\n-  /* Find the totals for this execution.  */\n-  memset (this_prg, 0, sizeof (*this_prg));\n-  for (gi_ptr = list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      crc32 = crc32_unsigned (crc32, gi_ptr->stamp);\n-      crc32 = crc32_unsigned (crc32, gi_ptr->n_functions);\n-\n-      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n-        {\n-          gfi_ptr = gi_ptr->functions[f_ix];\n-\n-          if (gfi_ptr && gfi_ptr->key != gi_ptr)\n-            gfi_ptr = 0;\n-\n-          crc32 = crc32_unsigned (crc32, gfi_ptr ? gfi_ptr->cfg_checksum : 0);\n-          crc32 = crc32_unsigned (crc32,\n-                                  gfi_ptr ? gfi_ptr->lineno_checksum : 0);\n-          if (!gfi_ptr)\n-            continue;\n-\n-\t  ci_ptr = gfi_ptr->ctrs;\n-\t  this_prg->num += ci_ptr->num;\n-\t  crc32 = crc32_unsigned (crc32, ci_ptr->num);\n-\n-\t  for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-\t    {\n-\t      this_prg->sum_all += ci_ptr->values[c_num];\n-\t      if (this_prg->run_max < ci_ptr->values[c_num])\n-\t\tthis_prg->run_max = ci_ptr->values[c_num];\n-\t    }\n-\t  ci_ptr++;\n-\t}\n-    }\n-  gcov_compute_histogram (list, this_prg);\n-  return crc32;\n-}\n \n /* Including system dependent components. */\n #include \"libgcov-driver-system.c\"\n@@ -320,18 +193,13 @@ compute_summary (struct gcov_info *list, struct gcov_summary *this_prg)\n static int\n merge_one_data (const char *filename,\n \t\tstruct gcov_info *gi_ptr,\n-\t\tstruct gcov_summary *prg_p,\n-\t\tstruct gcov_summary *this_prg,\n-\t\tgcov_position_t *summary_pos_p,\n-\t\tgcov_position_t *eof_pos_p,\n-\t\tgcov_unsigned_t crc32)\n+\t\tstruct gcov_summary *summary)\n {\n   gcov_unsigned_t tag, length;\n   unsigned t_ix;\n-  int f_ix;\n+  int f_ix = -1;\n   int error = 0;\n   struct gcov_fn_buffer **fn_tail = &fn_buffer;\n-  struct gcov_summary_buffer **sum_tail = &sum_buffer;\n \n   length = gcov_read_unsigned ();\n   if (!gcov_version (gi_ptr, length, filename))\n@@ -346,46 +214,14 @@ merge_one_data (const char *filename,\n       return 0;\n     }\n \n-  /* Look for program summary.  */\n-  for (f_ix = 0;;)\n-    {\n-      struct gcov_summary tmp;\n-\n-      *eof_pos_p = gcov_position ();\n-      tag = gcov_read_unsigned ();\n-      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n-        break;\n-\n-      f_ix--;\n-      length = gcov_read_unsigned ();\n-      gcov_read_summary (&tmp);\n-      if ((error = gcov_is_error ()))\n-        goto read_error;\n-      if (*summary_pos_p)\n-        {\n-          /* Save all summaries after the one that will be\n-             merged into below. These will need to be rewritten\n-             as histogram merging may change the number of non-zero\n-             histogram entries that will be emitted, and thus the\n-             size of the merged summary.  */\n-          (*sum_tail) = (struct gcov_summary_buffer *)\n-              xmalloc (sizeof(struct gcov_summary_buffer));\n-          (*sum_tail)->summary = tmp;\n-          (*sum_tail)->next = 0;\n-          sum_tail = &((*sum_tail)->next);\n-          goto next_summary;\n-        }\n-      if (tmp.checksum != crc32)\n-        goto next_summary;\n-\n-      if (tmp.num != this_prg->num)\n-\tgoto next_summary;\n-      *prg_p = tmp;\n-      *summary_pos_p = *eof_pos_p;\n-\n-    next_summary:;\n-    }\n+  tag = gcov_read_unsigned ();\n+  if (tag != GCOV_TAG_OBJECT_SUMMARY)\n+    goto read_mismatch;\n+  length = gcov_read_unsigned ();\n+  gcc_assert (length > 0);\n+  gcov_read_summary (summary);\n \n+  tag = gcov_read_unsigned ();\n   /* Merge execution counts for each function.  */\n   for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions;\n        f_ix++, tag = gcov_read_unsigned ())\n@@ -472,38 +308,15 @@ merge_one_data (const char *filename,\n \n static void\n write_one_data (const struct gcov_info *gi_ptr,\n-\t\tconst struct gcov_summary *prg_p,\n-\t\tconst gcov_position_t eof_pos,\n-\t\tconst gcov_position_t summary_pos)\n+\t\tconst struct gcov_summary *prg_p)\n {\n   unsigned f_ix;\n-  struct gcov_summary_buffer *next_sum_buffer;\n \n-  /* Write out the data.  */\n-  if (!eof_pos)\n-    {\n-      gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n-      gcov_write_unsigned (gi_ptr->stamp);\n-    }\n-\n-  if (summary_pos)\n-    gcov_seek (summary_pos);\n+  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n+  gcov_write_unsigned (gi_ptr->stamp);\n \n   /* Generate whole program statistics.  */\n-  gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, prg_p);\n-\n-  /* Rewrite all the summaries that were after the summary we merged\n-     into. This is necessary as the merged summary may have a different\n-     size due to the number of non-zero histogram entries changing after\n-     merging.  */\n-\n-  while (sum_buffer)\n-    {\n-      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &sum_buffer->summary);\n-      next_sum_buffer = sum_buffer->next;\n-      free (sum_buffer);\n-      sum_buffer = next_sum_buffer;\n-    }\n+  gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, prg_p);\n \n   /* Write execution counts for each function.  */\n   for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n@@ -562,70 +375,19 @@ write_one_data (const struct gcov_info *gi_ptr,\n   gcov_write_unsigned (0);\n }\n \n-/* Helper function for merging summary.\n-   Return -1 on error. Return 0 on success.  */\n+/* Helper function for merging summary.  */\n \n-static int\n-merge_summary (const char *filename __attribute__ ((unused)), int run_counted,\n-\t       struct gcov_summary *prg,\n-\t       struct gcov_summary *this_prg, gcov_unsigned_t crc32,\n-\t       struct gcov_summary *all_prg __attribute__ ((unused)))\n+static void\n+merge_summary (int run_counted, struct gcov_summary *summary,\n+\t      gcov_type run_max)\n {\n-#if !GCOV_LOCKED \n-  /* summary for all instances of program.  */ \n-  struct gcov_summary *all;\n-#endif \n-\n-  /* Merge the summary.  */\n-  int first = !prg->runs;\n-\n   if (!run_counted)\n-    prg->runs++;\n-  if (first)\n-    prg->num = this_prg->num;\n-  prg->sum_all += this_prg->sum_all;\n-  if (prg->run_max < this_prg->run_max)\n-    prg->run_max = this_prg->run_max;\n-  prg->sum_max += this_prg->run_max;\n-  if (first)\n-    memcpy (prg->histogram, this_prg->histogram,\n-\t    sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-  else\n-    gcov_histogram_merge (prg->histogram, this_prg->histogram);\n-#if !GCOV_LOCKED\n-  all = all_prg;\n-  if (!all->runs && prg->runs)\n-    {\n-      all->num = prg->num;\n-      all->runs = prg->runs;\n-      all->sum_all = prg->sum_all;\n-      all->run_max = prg->run_max;\n-      all->sum_max = prg->sum_max;\n-    }\n-  else if (!all_prg->checksum\n-\t   /* Don't compare the histograms, which may have slight\n-\t      variations depending on the order they were updated\n-\t      due to the truncating integer divides used in the\n-\t      merge.  */\n-\t   && (all->num != prg->num\n-\t       || all->runs != prg->runs\n-\t       || all->sum_all != prg->sum_all\n-\t       || all->run_max != prg->run_max\n-\t       || all->sum_max != prg->sum_max))\n     {\n-      gcov_error (\"profiling:%s:Data file mismatch - some \"\n-\t\t  \"data files may have been concurrently \"\n-\t\t  \"updated without locking support\\n\", filename);\n-      all_prg->checksum = ~0u;\n+      summary->runs++;\n+      summary->sum_max += run_max;\n     }\n-#endif\n-\n-  prg->checksum = crc32;\n-\n-  return 0;\n }\n \n-\n /* Sort N entries in VALUE_ARRAY in descending order.\n    Each entry in VALUE_ARRAY has two values. The sorting\n    is based on the second value.  */\n@@ -713,18 +475,13 @@ gcov_sort_topn_counter_arrays (const struct gcov_info *gi_ptr)\n \n static void\n dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n-\t       unsigned run_counted,\n-\t       gcov_unsigned_t crc32, struct gcov_summary *all_prg,\n-\t       struct gcov_summary *this_prg)\n+\t       unsigned run_counted, gcov_type run_max)\n {\n-  struct gcov_summary prg; /* summary for this object over all program.  */\n+  struct gcov_summary summary = {};\n   int error;\n   gcov_unsigned_t tag;\n-  gcov_position_t summary_pos = 0;\n-  gcov_position_t eof_pos = 0;\n \n   fn_buffer = 0;\n-  sum_buffer = 0;\n \n   gcov_sort_topn_counter_arrays (gi_ptr);\n \n@@ -741,26 +498,16 @@ dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n           gcov_error (\"profiling:%s:Not a gcov data file\\n\", gf->filename);\n           goto read_fatal;\n         }\n-      error = merge_one_data (gf->filename, gi_ptr, &prg, this_prg,\n-\t\t\t      &summary_pos, &eof_pos, crc32);\n+      error = merge_one_data (gf->filename, gi_ptr, &summary);\n       if (error == -1)\n         goto read_fatal;\n     }\n \n   gcov_rewrite ();\n \n-  if (!summary_pos)\n-    {\n-      memset (&prg, 0, sizeof (prg));\n-      summary_pos = eof_pos;\n-    }\n-\n-  error = merge_summary (gf->filename, run_counted, &prg, this_prg,\n-\t\t\t crc32, all_prg);\n-  if (error == -1)\n-    goto read_fatal;\n+  merge_summary (run_counted, &summary, run_max);\n \n-  write_one_data (gi_ptr, &prg, eof_pos, summary_pos);\n+  write_one_data (gi_ptr, &summary);\n   /* fall through */\n \n read_fatal:;\n@@ -787,21 +534,26 @@ gcov_do_dump (struct gcov_info *list, int run_counted)\n {\n   struct gcov_info *gi_ptr;\n   struct gcov_filename gf;\n-  gcov_unsigned_t crc32;\n-  struct gcov_summary all_prg;\n-  struct gcov_summary this_prg;\n \n-  crc32 = compute_summary (list, &this_prg);\n+  /* Compute run_max of this program run.  */\n+  gcov_type run_max = 0;\n+  for (gi_ptr = list; gi_ptr; gi_ptr = gi_ptr->next)\n+    for (unsigned f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n+      {\n+\tconst struct gcov_ctr_info *cinfo\n+\t  = &gi_ptr->functions[f_ix]->ctrs[GCOV_COUNTER_ARCS];\n+\n+\tfor (unsigned i = 0; i < cinfo->num; i++)\n+\t  if (run_max < cinfo->values[i])\n+\t    run_max = cinfo->values[i];\n+      }\n \n   allocate_filename_struct (&gf);\n-#if !GCOV_LOCKED\n-  memset (&all_prg, 0, sizeof (all_prg));\n-#endif\n \n   /* Now merge each file.  */\n   for (gi_ptr = list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      dump_one_gcov (gi_ptr, &gf, run_counted, crc32, &all_prg, &this_prg);\n+      dump_one_gcov (gi_ptr, &gf, run_counted, run_max);\n       free (gf.filename);\n     }\n "}, {"sha": "408bda82236acdd50468a2bdc1eea67a79190258", "filename": "libgcc/libgcov-util.c", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512cc0151207de4c7ff3a84f040f730fe0d52458/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512cc0151207de4c7ff3a84f040f730fe0d52458/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=512cc0151207de4c7ff3a84f040f730fe0d52458", "patch": "@@ -32,6 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"diagnostic.h\"\n #include \"version.h\"\n #include \"demangle.h\"\n+#include \"gcov-io.h\"\n \n /* Borrowed from basic-block.h.  */\n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n@@ -79,6 +80,8 @@ static int k_ctrs_mask[GCOV_COUNTERS];\n static struct gcov_ctr_info k_ctrs[GCOV_COUNTERS];\n /* Number of kind of counters that have been seen.  */\n static int k_ctrs_types;\n+/* The object summary being processed.  */\n+static struct gcov_summary *curr_object_summary;\n \n /* Merge functions for counters.  */\n #define DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE) __gcov_merge ## FN_TYPE,\n@@ -131,7 +134,6 @@ static const tag_format_t tag_table[] =\n   {GCOV_TAG_ARCS, \"ARCS\", tag_arcs},\n   {GCOV_TAG_LINES, \"LINES\", tag_lines},\n   {GCOV_TAG_OBJECT_SUMMARY, \"OBJECT_SUMMARY\", tag_summary},\n-  {GCOV_TAG_PROGRAM_SUMMARY, \"PROGRAM_SUMMARY\", tag_summary},\n   {0, NULL, NULL}\n };\n \n@@ -223,9 +225,8 @@ tag_counters (unsigned tag, unsigned length)\n static void\n tag_summary (unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n-  struct gcov_summary summary;\n-\n-  gcov_read_summary (&summary);\n+  curr_object_summary = (gcov_summary *) xcalloc (sizeof (gcov_summary), 1);\n+  gcov_read_summary (curr_object_summary);\n }\n \n /* This function is called at the end of reading a gcda file.\n@@ -239,7 +240,8 @@ read_gcda_finalize (struct gcov_info *obj_info)\n   set_fn_ctrs (curr_fn_info);\n   obstack_ptr_grow (&fn_info, curr_fn_info);\n \n-  /* We set the following fields: merge, n_functions, and functions.  */\n+  /* We set the following fields: merge, n_functions, functions\n+     and summary.  */\n   obj_info->n_functions = num_fn_info;\n   obj_info->functions = (const struct gcov_fn_info**) obstack_finish (&fn_info);\n \n@@ -299,6 +301,7 @@ read_gcda_file (const char *filename)\n   obstack_init (&fn_info);\n   num_fn_info = 0;\n   curr_fn_info = 0;\n+  curr_object_summary = NULL;\n   {\n     size_t len = strlen (filename) + 1;\n     char *str_dup = (char*) xmalloc (len);\n@@ -892,8 +895,6 @@ calculate_2_entries (const unsigned long v1, const unsigned long v2,\n }\n \n /*  Compute the overlap score between GCOV_INFO1 and GCOV_INFO2.\n-    SUM_1 is the sum_all for profile1 where GCOV_INFO1 belongs.\n-    SUM_2 is the sum_all for profile2 where GCOV_INFO2 belongs.\n     This function also updates cumulative score CUM_1_RESULT and\n     CUM_2_RESULT.  */\n \n@@ -1048,12 +1049,6 @@ struct overlap_t {\n /* Cumlative overlap dscore for profile1 and profile2.  */\n static double overlap_sum_1, overlap_sum_2;\n \n-/* sum_all for profile1 and profile2.  */\n-static gcov_type p1_sum_all, p2_sum_all;\n-\n-/* run_max for profile1 and profile2.  */\n-static gcov_type p1_run_max, p2_run_max;\n-\n /* The number of gcda files in the profiles.  */\n static unsigned gcda_files[2];\n \n@@ -1200,10 +1195,6 @@ matched_gcov_info (const struct gcov_info *info1, const struct gcov_info *info2)\n   return 1;\n }\n \n-/* Defined in libgcov-driver.c.  */\n-extern gcov_unsigned_t compute_summary (struct gcov_info *,\n-\t\t\t\t\tstruct gcov_summary *);\n-\n /* Compute the overlap score of two profiles with the head of GCOV_LIST1 and\n    GCOV_LIST1. Return a number ranging from [0.0, 1.0], with 0.0 meaning no\n    match and 1.0 meaning a perfect match.  */\n@@ -1212,21 +1203,11 @@ static double\n calculate_overlap (struct gcov_info *gcov_list1,\n                    struct gcov_info *gcov_list2)\n {\n-  struct gcov_summary this_prg;\n   unsigned list1_cnt = 0, list2_cnt= 0, all_cnt;\n   unsigned int i, j;\n   const struct gcov_info *gi_ptr;\n   struct overlap_t *all_infos;\n \n-  compute_summary (gcov_list1, &this_prg);\n-  overlap_sum_1 = (double) (this_prg.sum_all);\n-  p1_sum_all = this_prg.sum_all;\n-  p1_run_max = this_prg.run_max;\n-  compute_summary (gcov_list2, &this_prg);\n-  overlap_sum_2 = (double) (this_prg.sum_all);\n-  p2_sum_all = this_prg.sum_all;\n-  p2_run_max = this_prg.run_max;\n-\n   for (gi_ptr = gcov_list1; gi_ptr; gi_ptr = gi_ptr->next)\n     list1_cnt++;\n   for (gi_ptr = gcov_list2; gi_ptr; gi_ptr = gi_ptr->next)\n@@ -1334,10 +1315,6 @@ calculate_overlap (struct gcov_info *gcov_list1,\n \t  cold_gcda_files[1], both_cold_cnt);\n   printf (\"    zero files:  %12u\\t%12u\\t%12u\\n\", zero_gcda_files[0],\n \t  zero_gcda_files[1], both_zero_cnt);\n-  printf (\"       sum_all:  %12\" PRId64 \"\\t%12\" PRId64 \"\\n\",\n-\t  p1_sum_all, p2_sum_all);\n-  printf (\"       run_max:  %12\" PRId64 \"\\t%12\" PRId64 \"\\n\",\n-\t  p1_run_max, p2_run_max);\n \n   return prg_val;\n }"}]}