{"sha": "555c3771903cc461949f06acf28f92fc067b6a1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU1YzM3NzE5MDNjYzQ2MTk0OWYwNmFjZjI4ZjkyZmMwNjdiNmExYw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-05-21T13:08:18Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-05-21T13:08:18Z"}, "message": "In gcc/: 2011-05-21 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2011-05-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* gengtype.c (walk_type): Implemented \"atomic\" GTY option.\n\t* doc/gty.texi (GTY Options): Document \"atomic\" GTY option.\n\nFrom-SVN: r173996", "tree": {"sha": "e136d30b104f44338a700f48d44e05ba3ce0609b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e136d30b104f44338a700f48d44e05ba3ce0609b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/555c3771903cc461949f06acf28f92fc067b6a1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/555c3771903cc461949f06acf28f92fc067b6a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/555c3771903cc461949f06acf28f92fc067b6a1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/555c3771903cc461949f06acf28f92fc067b6a1c/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fa5de4fc7a62813adacf107775d3ebc9bb65c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fa5de4fc7a62813adacf107775d3ebc9bb65c2"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "21204a009ecc848e327b5a06612663c60d028fe5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/555c3771903cc461949f06acf28f92fc067b6a1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/555c3771903cc461949f06acf28f92fc067b6a1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=555c3771903cc461949f06acf28f92fc067b6a1c", "patch": "@@ -1,3 +1,8 @@\n+2011-05-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* gengtype.c (walk_type): Implemented \"atomic\" GTY option.\n+\t* doc/gty.texi (GTY Options): Document \"atomic\" GTY option.\n+\n 2011-05-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* opt-read.awk: New.  Split out of optc-gen.awk and opth-gen.awk."}, {"sha": "03bcbf813cd1485efd54d31052ca012a5e759bdc", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/555c3771903cc461949f06acf28f92fc067b6a1c/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/555c3771903cc461949f06acf28f92fc067b6a1c/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=555c3771903cc461949f06acf28f92fc067b6a1c", "patch": "@@ -383,6 +383,51 @@ could be calculated as follows:\n   size_t size = sizeof (struct sorted_fields_type) + n * sizeof (tree);\n @end smallexample\n \n+@findex atomic\n+@item atomic\n+\n+The @code{atomic} option can only be used with pointers.  It informs\n+the GC machinery that the memory that the pointer points to does not\n+contain any pointers, and hence it should be treated by the GC and PCH\n+machinery as an ``atomic'' block of memory that does not need to be\n+examined when scanning memory for pointers.  In particular, the\n+machinery will not scan that memory for pointers to mark them as\n+reachable (when marking pointers for GC) or to relocate them (when\n+writing a PCH file).\n+\n+The @code{atomic} option differs from the @code{skip} option.\n+@code{atomic} keeps the memory under Garbage Collection, but makes the\n+GC ignore the contents of the memory.  @code{skip} is more drastic in\n+that it causes the pointer and the memory to be completely ignored by\n+the Garbage Collector.  So, memory marked as @code{atomic} is\n+automatically freed when no longer reachable, while memory marked as\n+@code{skip} is not.\n+\n+The @code{atomic} option must be used with great care, because all\n+sorts of problem can occur if used incorrectly, that is, if the memory\n+the pointer points to does actually contain a pointer.\n+\n+Here is an example of how to use it:\n+@smallexample\n+struct GTY(()) my_struct @{\n+  int number_of_elements;\n+  unsigned int GTY ((atomic)) * elements;\n+@};\n+@end smallexample\n+In this case, @code{elements} is a pointer under GC, and the memory it\n+points to needs to be allocated using the Garbage Collector, and will\n+be freed automatically by the Garbage Collector when it is no longer\n+referenced.  But the memory that the pointer points to is an array of\n+@code{unsigned int} elements, and the GC must not try to scan it to\n+find pointers to mark or relocate, which is why it is marked with the\n+@code{atomic} option.\n+\n+Note that, currently, global variables can not be marked with\n+@code{atomic}; only fields of a struct can.  This is a known\n+limitation.  It would be useful to be able to mark global pointers\n+with @code{atomic} to make the PCH machinery aware of them so that\n+they are saved and restored correctly to PCH files.\n+\n @findex special\n @item special (\"@var{name}\")\n "}, {"sha": "85832d34fa20c5cafa0b30bbcd0aba0087581170", "filename": "gcc/gengtype.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/555c3771903cc461949f06acf28f92fc067b6a1c/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/555c3771903cc461949f06acf28f92fc067b6a1c/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=555c3771903cc461949f06acf28f92fc067b6a1c", "patch": "@@ -2386,6 +2386,7 @@ walk_type (type_p t, struct walk_type_data *d)\n   int maybe_undef_p = 0;\n   int use_param_num = -1;\n   int use_params_p = 0;\n+  int atomic_p = 0;\n   options_p oo;\n   const struct nested_ptr_data *nested_ptr_d = NULL;\n \n@@ -2415,6 +2416,8 @@ walk_type (type_p t, struct walk_type_data *d)\n       ;\n     else if (strcmp (oo->name, \"skip\") == 0)\n       ;\n+    else if (strcmp (oo->name, \"atomic\") == 0)\n+      atomic_p = 1;\n     else if (strcmp (oo->name, \"default\") == 0)\n       ;\n     else if (strcmp (oo->name, \"param_is\") == 0)\n@@ -2480,6 +2483,12 @@ walk_type (type_p t, struct walk_type_data *d)\n       return;\n     }\n \n+  if (atomic_p && (t->kind != TYPE_POINTER))\n+    {\n+      error_at_line (d->line, \"field `%s' has invalid option `atomic'\\n\", d->val);\n+      return;\n+    }\n+\n   switch (t->kind)\n     {\n     case TYPE_SCALAR:\n@@ -2495,6 +2504,25 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    break;\n \t  }\n \n+\t/* If a pointer type is marked as \"atomic\", we process the\n+\t   field itself, but we don't walk the data that they point to.\n+\t   \n+\t   There are two main cases where we walk types: to mark\n+\t   pointers that are reachable, and to relocate pointers when\n+\t   writing a PCH file.  In both cases, an atomic pointer is\n+\t   itself marked or relocated, but the memory that it points\n+\t   to is left untouched.  In the case of PCH, that memory will\n+\t   be read/written unchanged to the PCH file.  */\n+\tif (atomic_p)\n+\t  {\n+\t    oprintf (d->of, \"%*sif (%s != NULL) {\\n\", d->indent, \"\", d->val);\n+\t    d->indent += 2;\n+\t    d->process_field (t, d);\n+\t    d->indent -= 2;\n+\t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\t    break;\n+\t  }\n+\n \tif (!length)\n \t  {\n \t    if (!UNION_OR_STRUCT_P (t->u.p)"}]}