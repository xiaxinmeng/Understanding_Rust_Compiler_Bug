{"sha": "a981b74355fa292aafc277543f678b56b9871247", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk4MWI3NDM1NWZhMjkyYWFmYzI3NzU0M2Y2NzhiNTZiOTg3MTI0Nw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-09-27T11:55:55Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-09-27T11:55:55Z"}, "message": "re PR target/67391 ([SH] Convert clrt addc to normal add insn)\n\ngcc/\n\tPR target/67391\n\t* config/sh/sh-protos.h (sh_lra_p): Declare.\n\t* config/sh/sh.c (sh_lra_p): Make non-static.\n\t* config/sh/sh.md (addsi3): Use arith_reg_dest for operands[0] and\n\tarith_reg_operand for operands[1].  Remove TARGET_SHMEDIA case.\n\tExpand into addsi3_scr if operands[2] if needed.\n\t(*addsi3_compact): Rename to *addsi3_compact_lra.  Use\n\tarith_reg_operand for operands[1].  Allow it only when LRA is enabled.\n\t(addsi3_scr, *addsi3): New insn_and_split patterns.\n\nCo-Authored-By: Kaz Kojima <kkojima@gcc.gnu.org>\n\nFrom-SVN: r228176", "tree": {"sha": "4fa085f3255ae67192e23e273788e277cb1897f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fa085f3255ae67192e23e273788e277cb1897f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a981b74355fa292aafc277543f678b56b9871247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a981b74355fa292aafc277543f678b56b9871247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a981b74355fa292aafc277543f678b56b9871247", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a981b74355fa292aafc277543f678b56b9871247/comments", "author": null, "committer": null, "parents": [{"sha": "f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11a7b6d57f6fcba1bf2e5a0403dc49120195320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f11a7b6d57f6fcba1bf2e5a0403dc49120195320"}], "stats": {"total": 100, "additions": 89, "deletions": 11}, "files": [{"sha": "9734b08547e405193a4357058d5b4dfc30510f10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a981b74355fa292aafc277543f678b56b9871247/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a981b74355fa292aafc277543f678b56b9871247/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a981b74355fa292aafc277543f678b56b9871247", "patch": "@@ -1,3 +1,16 @@\n+2015-09-27  Oleg Endo  <olegendo@gcc.gnu.org>\n+\t    Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/67391\n+\t* config/sh/sh-protos.h (sh_lra_p): Declare.\n+\t* config/sh/sh.c (sh_lra_p): Make non-static.\n+\t* config/sh/sh.md (addsi3): Use arith_reg_dest for operands[0] and\n+\tarith_reg_operand for operands[1].  Remove TARGET_SHMEDIA case.\n+\tExpand into addsi3_scr if operands[2] if needed.\n+\t(*addsi3_compact): Rename to *addsi3_compact_lra.  Use\n+\tarith_reg_operand for operands[1].  Allow it only when LRA is enabled.\n+\t(addsi3_scr, *addsi3): New insn_and_split patterns.\n+\n 2015-09-27  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR rtl-optimization/64164"}, {"sha": "f94459f0e4c3ae8931fc322e0fe12c50176f7e8c", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a981b74355fa292aafc277543f678b56b9871247/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a981b74355fa292aafc277543f678b56b9871247/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=a981b74355fa292aafc277543f678b56b9871247", "patch": "@@ -93,6 +93,7 @@ extern rtx sh_fsca_sf2int (void);\n extern rtx sh_fsca_int2sf (void);\n \n /* Declare functions defined in sh.c and used in templates.  */\n+extern bool sh_lra_p (void);\n \n extern const char *output_branch (int, rtx_insn *, rtx *);\n extern const char *output_ieee_ccmpeq (rtx_insn *, rtx *);"}, {"sha": "1a859724ff174301a6942eab0086a0f44e0211f1", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a981b74355fa292aafc277543f678b56b9871247/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a981b74355fa292aafc277543f678b56b9871247/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a981b74355fa292aafc277543f678b56b9871247", "patch": "@@ -216,7 +216,6 @@ static int sh_mode_after (int, int, rtx_insn *);\n static int sh_mode_entry (int);\n static int sh_mode_exit (int);\n static int sh_mode_priority (int entity, int n);\n-static bool sh_lra_p (void);\n \n static rtx mark_constant_pool_use (rtx);\n static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree,\n@@ -14507,7 +14506,7 @@ sh_mode_priority (int entity ATTRIBUTE_UNUSED, int n)\n */\n \n /* Return true if we use LRA instead of reload pass.  */\n-static bool\n+bool\n sh_lra_p (void)\n {\n   return sh_lra_flag;"}, {"sha": "8a388bc6b69da8a6fb3cbc01f1bab2bb326357ce", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a981b74355fa292aafc277543f678b56b9871247/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a981b74355fa292aafc277543f678b56b9871247/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=a981b74355fa292aafc277543f678b56b9871247", "patch": "@@ -2122,13 +2122,19 @@\n })\n \n (define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"\")\n-\t\t (match_operand:SI 2 \"arith_or_int_operand\" \"\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t (match_operand:SI 2 \"arith_or_int_operand\")))]\n   \"\"\n {\n-  if (TARGET_SHMEDIA)\n-    operands[1] = force_reg (SImode, operands[1]);\n+  if (TARGET_SH1 && !arith_operand (operands[2], SImode))\n+    {\n+      if (!sh_lra_p () || reg_overlap_mentioned_p (operands[0], operands[1]))\n+\t{\n+\t  emit_insn (gen_addsi3_scr (operands[0], operands[1], operands[2]));\n+\t  DONE;\n+\t}\n+    }\n })\n \n (define_insn \"addsi3_media\"\n@@ -2163,15 +2169,22 @@\n ;; copy or constant load before the actual add insn.\n ;; Use u constraint for that case to avoid the invalid value in the stack\n ;; pointer.\n-(define_insn_and_split \"*addsi3_compact\"\n+;; This also results in better code when LRA is not used.  However, we have\n+;; to use different sets of patterns and the order of these patterns is\n+;; important.\n+;; In some cases the constant zero might end up in operands[2] of the\n+;; patterns.  We have to accept that and convert it into a reg-reg move.\n+(define_insn_and_split \"*addsi3_compact_lra\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,&u\")\n-\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0,r\")\n+\t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,r\")\n \t\t (match_operand:SI 2 \"arith_or_int_operand\" \"rI08,rn\")))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && sh_lra_p ()\n+   && (! reg_overlap_mentioned_p (operands[0], operands[1])\n+       || arith_operand (operands[2], SImode))\"\n   \"@\n \tadd\t%2,%0\n \t#\"\n-  \"reload_completed\n+  \"&& reload_completed\n    && ! reg_overlap_mentioned_p (operands[0], operands[1])\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))]\n@@ -2182,6 +2195,58 @@\n }\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn_and_split \"addsi3_scr\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,&u,&u\")\n+\t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,r,r\")\n+\t\t (match_operand:SI 2 \"arith_or_int_operand\" \"rI08,r,n\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,&u\"))]\n+  \"TARGET_SH1\"\n+  \"@\n+\tadd\t%2,%0\n+\t#\n+\t#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]\n+{\n+  if (operands[2] == const0_rtx)\n+    {\n+      emit_move_insn (operands[0], operands[1]);\n+      DONE;\n+    }\n+\n+  if (CONST_INT_P (operands[2]) && !satisfies_constraint_I08 (operands[2]))\n+    {\n+      if (reg_overlap_mentioned_p (operands[0], operands[1]))\n+\t{\n+\t  emit_move_insn (operands[3], operands[2]);\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  operands[2] = operands[3];\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (operands[0], operands[2]);\n+\t  operands[2] = operands[1];\n+\t}\n+    }\n+  else if (!reg_overlap_mentioned_p (operands[0], operands[1]))\n+    emit_move_insn (operands[0], operands[1]);\n+}\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn_and_split \"*addsi3\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI08,Z\")))]\n+  \"TARGET_SH1 && !sh_lra_p ()\"\n+  \"@\n+\tadd\t%2,%0\n+\t#\"\n+  \"&& operands[2] == const0_rtx\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+}\n+  [(set_attr \"type\" \"arith\")])\n+\n ;; -------------------------------------------------------------------------\n ;; Subtraction instructions\n ;; -------------------------------------------------------------------------"}]}