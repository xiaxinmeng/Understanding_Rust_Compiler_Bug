{"sha": "4dda30e9910c4f04a6258b053401249e213f29be", "node_id": "C_kwDOANBUbNoAKDRkZGEzMGU5OTEwYzRmMDRhNjI1OGIwNTM0MDEyNDllMjEzZjI5YmU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-18T08:31:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-18T08:39:09Z"}, "message": "middle-end IFN_ASSUME support [PR106654]\n\nMy earlier patches gimplify the simplest non-side-effects assumptions\ninto if (cond) ; else __builtin_unreachable (); and throw the rest\non the floor.\nThe following patch attempts to do something with the rest too.\nFor -O0, it throws the more complex assumptions on the floor,\nwe don't expect optimizations and the assumptions are there to allow\noptimizations.  Otherwise arranges for the assumptions to be\nvisible in the IL as\n  .ASSUME (_Z2f4i._assume.0, i_1(D));\ncall where there is an artificial function like:\nbool _Z2f4i._assume.0 (int i)\n{\n  bool _2;\n\n  <bb 2> [local count: 1073741824]:\n  _2 = i_1(D) == 43;\n  return _2;\n\n}\nwith the semantics that there is UB unless the assumption function\nwould return true.\n\nAldy, could ranger handle this?  If it sees .ASSUME call,\nwalk the body of such function from the edge(s) to exit with the\nassumption that the function returns true, so above set _2 [true, true]\nand from there derive that i_1(D) [43, 43] and then map the argument\nin the assumption function to argument passed to IFN_ASSUME (note,\nargs there are shifted by 1)?\n\nDuring gimplification it actually gimplifies it into\n  [[assume (D.2591)]]\n    {\n      {\n        i = i + 1;\n        D.2591 = i == 44;\n      }\n    }\nwhich is a new GIMPLE_ASSUME statement wrapping a GIMPLE_BIND and\nspecifying a boolean_type_node variable which contains the result.\nThe GIMPLE_ASSUME then survives just a couple of passes and is lowered\nduring gimple lowering into an outlined separate function and\nIFN_ASSUME call.  Variables declared inside of the\ncondition (both static and automatic) just change context, automatic\nvariables from the caller are turned into parameters (note, as the code\nis never executed, I handle this way even non-POD types, we don't need to\nbother pretending there would be user copy constructors etc. involved).\n\nThe assume_function artificial functions are then optimized until the\nnew assumptions pass which doesn't do much right now but I'd like to see\nthere the backwards ranger walk and filling up of SSA_NAME_RANGE_INFO\nfor the parameters.\n\nThere are a few further changes I'd like to do, like ignoring the\n.ASSUME calls in inlining size estimations (but haven't figured out where\nit is done), or for LTO arrange for the assume functions to be emitted\nin all partitions that reference those (usually there will be just one,\nunless code with the assumption got inlined, versioned etc.).\n\n2022-10-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/106654\ngcc/\n\t* gimple.def (GIMPLE_ASSUME): New statement kind.\n\t* gimple.h (struct gimple_statement_assume): New type.\n\t(is_a_helper <gimple_statement_assume *>::test,\n\tis_a_helper <const gimple_statement_assume *>::test): New.\n\t(gimple_build_assume): Declare.\n\t(gimple_has_substatements): Return true for GIMPLE_ASSUME.\n\t(gimple_assume_guard, gimple_assume_set_guard,\n\tgimple_assume_guard_ptr, gimple_assume_body_ptr, gimple_assume_body):\n\tNew inline functions.\n\t* gsstruct.def (GSS_ASSUME): New.\n\t* gimple.cc (gimple_build_assume): New function.\n\t(gimple_copy): Handle GIMPLE_ASSUME.\n\t* gimple-pretty-print.cc (dump_gimple_assume): New function.\n\t(pp_gimple_stmt_1): Handle GIMPLE_ASSUME.\n\t* gimple-walk.cc (walk_gimple_op): Handle GIMPLE_ASSUME.\n\t* omp-low.cc (WALK_SUBSTMTS): Likewise.\n\t(lower_omp_1): Likewise.\n\t* omp-oacc-kernels-decompose.cc (adjust_region_code_walk_stmt_fn):\n\tLikewise.\n\t* tree-cfg.cc (verify_gimple_stmt, verify_gimple_in_seq_2): Likewise.\n\t* function.h (struct function): Add assume_function bitfield.\n\t* gimplify.cc (gimplify_call_expr): If the assumption isn't\n\tsimple enough, expand it into GIMPLE_ASSUME wrapped block or\n\tfor -O0 drop it.\n\t* gimple-low.cc: Include attribs.h.\n\t(create_assumption_fn): New function.\n\t(struct lower_assumption_data): New type.\n\t(find_assumption_locals_r, assumption_copy_decl,\n\tadjust_assumption_stmt_r, adjust_assumption_stmt_op,\n\tlower_assumption): New functions.\n\t(lower_stmt): Handle GIMPLE_ASSUME.\n\t* tree-ssa-ccp.cc (pass_fold_builtins::execute): Remove\n\tIFN_ASSUME calls.\n\t* lto-streamer-out.cc (output_struct_function_base): Pack\n\tassume_function bit.\n\t* lto-streamer-in.cc (input_struct_function_base): And unpack it.\n\t* cgraphunit.cc (cgraph_node::expand): Don't verify assume_function\n\thas TREE_ASM_WRITTEN set and don't release its body.\n\t(symbol_table::compile): Allow assume functions not to have released\n\tbody.\n\t* internal-fn.cc (expand_ASSUME): Remove gcc_unreachable.\n\t* passes.cc (execute_one_pass): For TODO_discard_function don't\n\trelease body of assume functions.\n\t* cgraph.cc (cgraph_node::verify_node): Don't verify cgraph nodes\n\tof PROP_assumptions_done functions.\n\t* tree-pass.h (PROP_assumptions_done): Define.\n\t(TODO_discard_function): Adjust comment.\n\t(make_pass_assumptions): Declare.\n\t* passes.def (pass_assumptions): Add.\n\t* timevar.def (TV_TREE_ASSUMPTIONS): New.\n\t* tree-inline.cc (remap_gimple_stmt): Handle GIMPLE_ASSUME.\n\t* tree-vrp.cc (pass_data_assumptions): New variable.\n\t(pass_assumptions): New class.\n\t(make_pass_assumptions): New function.\ngcc/cp/\n\t* cp-tree.h (build_assume_call): Declare.\n\t* parser.cc (cp_parser_omp_assumption_clauses): Use build_assume_call.\n\t* cp-gimplify.cc (build_assume_call): New function.\n\t(process_stmt_assume_attribute): Use build_assume_call.\n\t* pt.cc (tsubst_copy_and_build): Likewise.\ngcc/testsuite/\n\t* g++.dg/cpp23/attr-assume5.C: New test.\n\t* g++.dg/cpp23/attr-assume6.C: New test.\n\t* g++.dg/cpp23/attr-assume7.C: New test.", "tree": {"sha": "4c7ad9e81387b5f56bd856017a40638c32fdb033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c7ad9e81387b5f56bd856017a40638c32fdb033"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dda30e9910c4f04a6258b053401249e213f29be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dda30e9910c4f04a6258b053401249e213f29be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dda30e9910c4f04a6258b053401249e213f29be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dda30e9910c4f04a6258b053401249e213f29be/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ad3cc1ecc3c7c61d5e319f74cb7287fb80944fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad3cc1ecc3c7c61d5e319f74cb7287fb80944fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad3cc1ecc3c7c61d5e319f74cb7287fb80944fd"}], "stats": {"total": 761, "additions": 745, "deletions": 16}, "files": [{"sha": "0417b059965da2405580b7044460965a8480f49e", "filename": "gcc/cgraph.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -3751,7 +3751,9 @@ cgraph_node::verify_node (void)\n \t   && (!DECL_EXTERNAL (decl) || inlined_to)\n \t   && !flag_wpa)\n     {\n-      if (this_cfun->cfg)\n+      if ((this_cfun->curr_properties & PROP_assumptions_done) != 0)\n+\t;\n+      else if (this_cfun->cfg)\n \t{\n \t  hash_set<gimple *> stmts;\n "}, {"sha": "b05d790bf8da82b74252b7afe876a2a7a092eebb", "filename": "gcc/cgraphunit.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcgraphunit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcgraphunit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -1882,6 +1882,16 @@ cgraph_node::expand (void)\n   ggc_collect ();\n   timevar_pop (TV_REST_OF_COMPILATION);\n \n+  if (DECL_STRUCT_FUNCTION (decl)\n+      && DECL_STRUCT_FUNCTION (decl)->assume_function)\n+    {\n+      /* Assume functions aren't expanded into RTL, on the other side\n+\t we don't want to release their body.  */\n+      if (cfun)\n+\tpop_cfun ();\n+      return;\n+    }\n+\n   /* Make sure that BE didn't give up on compiling.  */\n   gcc_assert (TREE_ASM_WRITTEN (decl));\n   if (cfun)\n@@ -2373,6 +2383,10 @@ symbol_table::compile (void)\n \tif (node->inlined_to\n \t    || gimple_has_body_p (node->decl))\n \t  {\n+\t    if (DECL_STRUCT_FUNCTION (node->decl)\n+\t\t&& (DECL_STRUCT_FUNCTION (node->decl)->curr_properties\n+\t\t    & PROP_assumptions_done) != 0)\n+\t      continue;\n \t    error_found = true;\n \t    node->debug ();\n \t  }"}, {"sha": "28c339869b83d1d401d661351e18e694c1de8f4d", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -3101,6 +3101,17 @@ process_stmt_hotness_attribute (tree std_attrs, location_t attrs_loc)\n   return std_attrs;\n }\n \n+/* Build IFN_ASSUME internal call for assume condition ARG.  */\n+\n+tree\n+build_assume_call (location_t loc, tree arg)\n+{\n+  if (!processing_template_decl)\n+    arg = fold_build_cleanup_point_expr (TREE_TYPE (arg), arg);\n+  return build_call_expr_internal_loc (loc, IFN_ASSUME, void_type_node,\n+\t\t\t\t       1, arg);\n+}\n+\n /* If [[assume (cond)]] appears on this statement, handle it.  */\n \n tree\n@@ -3137,9 +3148,7 @@ process_stmt_assume_attribute (tree std_attrs, tree statement,\n \t    arg = contextual_conv_bool (arg, tf_warning_or_error);\n \t  if (error_operand_p (arg))\n \t    continue;\n-\t  statement = build_call_expr_internal_loc (attrs_loc, IFN_ASSUME,\n-\t\t\t\t\t\t    void_type_node, 1, arg);\n-\t  finish_expr_stmt (statement);\n+\t  finish_expr_stmt (build_assume_call (attrs_loc, arg));\n \t}\n     }\n   return remove_attribute (\"gnu\", \"assume\", std_attrs);"}, {"sha": "60a251010493d483ae1ca4584f2d38601ffca197", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -8280,6 +8280,7 @@ extern tree predeclare_vla\t\t\t(tree);\n extern void clear_fold_cache\t\t\t(void);\n extern tree lookup_hotness_attribute\t\t(tree);\n extern tree process_stmt_hotness_attribute\t(tree, location_t);\n+extern tree build_assume_call\t\t\t(location_t, tree);\n extern tree process_stmt_assume_attribute\t(tree, tree, location_t);\n extern bool simple_empty_class_p\t\t(tree, tree, tree_code);\n extern tree fold_builtin_source_location\t(location_t);"}, {"sha": "a39c5f0d24b54f0f58831bdc5b6a70675786e32d", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -46012,11 +46012,7 @@ cp_parser_omp_assumption_clauses (cp_parser *parser, cp_token *pragma_tok,\n \t      if (!type_dependent_expression_p (t))\n \t\tt = contextual_conv_bool (t, tf_warning_or_error);\n \t      if (is_assume && !error_operand_p (t))\n-\t\t{\n-\t\t  t = build_call_expr_internal_loc (eloc, IFN_ASSUME,\n-\t\t\t\t\t\t    void_type_node, 1, t);\n-\t\t  finish_expr_stmt (t);\n-\t\t}\n+\t\tfinish_expr_stmt (build_assume_call (eloc, t));\n \t      if (!parens.require_close (parser))\n \t\tcp_parser_skip_to_closing_parenthesis (parser,\n \t\t\t\t\t\t       /*recovering=*/true,"}, {"sha": "5eddad900eae1e27ebe31eaf6db7d59a6dff605e", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -21140,10 +21140,7 @@ tsubst_copy_and_build (tree t,\n \t\t      ret = error_mark_node;\n \t\t      break;\n \t\t    }\n-\t\t  ret = build_call_expr_internal_loc (EXPR_LOCATION (t),\n-\t\t\t\t\t\t      IFN_ASSUME,\n-\t\t\t\t\t\t      void_type_node, 1,\n-\t\t\t\t\t\t      arg);\n+\t\t  ret = build_assume_call (EXPR_LOCATION (t), arg);\n \t\t  RETURN (ret);\n \t\t}\n \t      break;"}, {"sha": "d7deaebee9c40785eca6df2e5e772ba3c54f8901", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -438,6 +438,10 @@ struct GTY(()) function {\n \n   /* Set if there are any OMP_TARGET regions in the function.  */\n   unsigned int has_omp_target : 1;\n+\n+  /* Set for artificial function created for [[assume (cond)]].\n+     These should be GIMPLE optimized, but not expanded to RTL.  */\n+  unsigned int assume_function : 1;\n };\n \n /* Add the decl D to the local_decls list of FUN.  */"}, {"sha": "512aa9feadad60a7a42ab9e735d5f63d38eb8d28", "filename": "gcc/gimple-low.cc", "status": "modified", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -33,6 +33,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"gimple-predict.h\"\n #include \"gimple-fold.h\"\n+#include \"cgraph.h\"\n+#include \"tree-ssa.h\"\n+#include \"value-range.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssanames.h\"\n+#include \"tree-inline.h\"\n+#include \"gimple-walk.h\"\n+#include \"attribs.h\"\n \n /* The differences between High GIMPLE and Low GIMPLE are the\n    following:\n@@ -237,6 +245,389 @@ lower_omp_directive (gimple_stmt_iterator *gsi, struct lower_data *data)\n   gsi_next (gsi);\n }\n \n+/* Create an artificial FUNCTION_DECL for assumption at LOC.  */\n+\n+static tree\n+create_assumption_fn (location_t loc)\n+{\n+  tree name = clone_function_name_numbered (current_function_decl, \"_assume\");\n+  /* Temporarily, until we determine all the arguments.  */\n+  tree type = build_varargs_function_type_list (boolean_type_node, NULL_TREE);\n+  tree decl = build_decl (loc, FUNCTION_DECL, name, type);\n+  TREE_STATIC (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  DECL_NAMELESS (decl) = 1;\n+  TREE_PUBLIC (decl) = 0;\n+  DECL_UNINLINABLE (decl) = 1;\n+  DECL_EXTERNAL (decl) = 0;\n+  DECL_CONTEXT (decl) = NULL_TREE;\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+  tree attributes = DECL_ATTRIBUTES (current_function_decl);\n+  if (lookup_attribute (\"noipa\", attributes) == NULL)\n+    {\n+      attributes = tree_cons (get_identifier (\"noipa\"), NULL, attributes);\n+      if (lookup_attribute (\"noinline\", attributes) == NULL)\n+\tattributes = tree_cons (get_identifier (\"noinline\"), NULL, attributes);\n+      if (lookup_attribute (\"noclone\", attributes) == NULL)\n+\tattributes = tree_cons (get_identifier (\"noclone\"), NULL, attributes);\n+      if (lookup_attribute (\"no_icf\", attributes) == NULL)\n+\tattributes = tree_cons (get_identifier (\"no_icf\"), NULL, attributes);\n+    }\n+  DECL_ATTRIBUTES (decl) = attributes;\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (decl)) = decl;\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl)\n+    = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (current_function_decl);\n+  DECL_FUNCTION_SPECIFIC_TARGET (decl)\n+    = DECL_FUNCTION_SPECIFIC_TARGET (current_function_decl);\n+  tree t = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t       RESULT_DECL, NULL_TREE, boolean_type_node);\n+  DECL_ARTIFICIAL (t) = 1;\n+  DECL_IGNORED_P (t) = 1;\n+  DECL_CONTEXT (t) = decl;\n+  DECL_RESULT (decl) = t;\n+  push_struct_function (decl);\n+  cfun->function_end_locus = loc;\n+  init_tree_ssa (cfun);\n+  return decl;\n+}\n+\n+struct lower_assumption_data\n+{\n+  copy_body_data id;\n+  tree return_false_label;\n+  tree guard_copy;\n+  auto_vec<tree> decls;\n+};\n+\n+/* Helper function for lower_assumptions.  Find local vars and labels\n+   in the assumption sequence and remove debug stmts.  */\n+\n+static tree\n+find_assumption_locals_r (gimple_stmt_iterator *gsi_p, bool *,\n+\t\t\t  struct walk_stmt_info *wi)\n+{\n+  lower_assumption_data *data = (lower_assumption_data *) wi->info;\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+  tree lhs = gimple_get_lhs (stmt);\n+  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      gcc_assert (SSA_NAME_VAR (lhs) == NULL_TREE);\n+      data->id.decl_map->put (lhs, NULL_TREE);\n+      data->decls.safe_push (lhs);\n+    }\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_BIND:\n+      for (tree var = gimple_bind_vars (as_a <gbind *> (stmt));\n+\t   var; var = DECL_CHAIN (var))\n+\tif (VAR_P (var)\n+\t    && !DECL_EXTERNAL (var)\n+\t    && DECL_CONTEXT (var) == data->id.src_fn)\n+\t  {\n+\t    data->id.decl_map->put (var, var);\n+\t    data->decls.safe_push (var);\n+\t  }\n+      break;\n+    case GIMPLE_LABEL:\n+      {\n+\ttree label = gimple_label_label (as_a <glabel *> (stmt));\n+\tdata->id.decl_map->put (label, label);\n+\tbreak;\n+      }\n+    case GIMPLE_RETURN:\n+      /* If something in assumption tries to return from parent function,\n+\t if it would be reached in hypothetical evaluation, it would be UB,\n+\t so transform such returns into return false;  */\n+      {\n+\tgimple *g = gimple_build_assign (data->guard_copy, boolean_false_node);\n+\tgsi_insert_before (gsi_p, g, GSI_SAME_STMT);\n+\tgimple_return_set_retval (as_a <greturn *> (stmt), data->guard_copy);\n+\tbreak;\n+      }\n+    case GIMPLE_DEBUG:\n+      /* As assumptions won't be emitted, debug info stmts in them\n+\t are useless.  */\n+      gsi_remove (gsi_p, true);\n+      wi->removed_stmt = true;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Create a new PARM_DECL that is indentical in all respect to DECL except that\n+   DECL can be either a VAR_DECL, a PARM_DECL or RESULT_DECL.  The original\n+   DECL must come from ID->src_fn and the copy will be part of ID->dst_fn.  */\n+\n+static tree\n+assumption_copy_decl (tree decl, copy_body_data *id)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (is_global_var (decl))\n+    return decl;\n+\n+  gcc_assert (VAR_P (decl)\n+\t      || TREE_CODE (decl) == PARM_DECL\n+\t      || TREE_CODE (decl) == RESULT_DECL);\n+  tree copy = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t  PARM_DECL, DECL_NAME (decl), type);\n+  if (DECL_PT_UID_SET_P (decl))\n+    SET_DECL_PT_UID (copy, DECL_PT_UID (decl));\n+  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n+  TREE_READONLY (copy) = TREE_READONLY (decl);\n+  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+  DECL_NOT_GIMPLE_REG_P (copy) = DECL_NOT_GIMPLE_REG_P (decl);\n+  DECL_BY_REFERENCE (copy) = DECL_BY_REFERENCE (decl);\n+  DECL_ARG_TYPE (copy) = type;\n+  ((lower_assumption_data *) id)->decls.safe_push (decl);\n+  return copy_decl_for_dup_finish (id, decl, copy);\n+}\n+\n+/* Transform gotos out of the assumption into return false.  */\n+\n+static tree\n+adjust_assumption_stmt_r (gimple_stmt_iterator *gsi_p, bool *,\n+\t\t\t  struct walk_stmt_info *wi)\n+{\n+  lower_assumption_data *data = (lower_assumption_data *) wi->info;\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+  tree lab = NULL_TREE;\n+  unsigned int idx = 0;\n+  if (gimple_code (stmt) == GIMPLE_GOTO)\n+    lab = gimple_goto_dest (stmt);\n+  else if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+     repeat:\n+      if (idx == 0)\n+\tlab = gimple_cond_true_label (as_a <gcond *> (stmt));\n+      else\n+\tlab = gimple_cond_false_label (as_a <gcond *> (stmt));\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_LABEL)\n+    {\n+      tree label = gimple_label_label (as_a <glabel *> (stmt));\n+      DECL_CONTEXT (label) = current_function_decl;\n+    }\n+  if (lab)\n+    {\n+      if (!data->id.decl_map->get (lab))\n+\t{\n+\t  if (!data->return_false_label)\n+\t    data->return_false_label\n+\t      = create_artificial_label (UNKNOWN_LOCATION);\n+\t  if (gimple_code (stmt) == GIMPLE_GOTO)\n+\t    gimple_goto_set_dest (as_a <ggoto *> (stmt),\n+\t\t\t\t  data->return_false_label);\n+\t  else if (idx == 0)\n+\t    gimple_cond_set_true_label (as_a <gcond *> (stmt),\n+\t\t\t\t\tdata->return_false_label);\n+\t  else\n+\t    gimple_cond_set_false_label (as_a <gcond *> (stmt),\n+\t\t\t\t\t data->return_false_label);\n+\t}\n+      if (gimple_code (stmt) == GIMPLE_COND && idx == 0)\n+\t{\n+\t  idx = 1;\n+\t  goto repeat;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Adjust trees in the assumption body.  Called through walk_tree.  */\n+\n+static tree\n+adjust_assumption_stmt_op (tree *tp, int *, void *datap)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) datap;\n+  lower_assumption_data *data = (lower_assumption_data *) wi->info;\n+  tree t = *tp;\n+  tree *newt;\n+  switch (TREE_CODE (t))\n+    {\n+    case SSA_NAME:\n+      newt = data->id.decl_map->get (t);\n+      /* There shouldn't be SSA_NAMEs other than ones defined in the\n+\t assumption's body.  */\n+      gcc_assert (newt);\n+      *tp = *newt;\n+      break;\n+    case LABEL_DECL:\n+      newt = data->id.decl_map->get (t);\n+      if (newt)\n+\t*tp = *newt;\n+      break;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+      *tp = remap_decl (t, &data->id);\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Lower assumption.\n+   The gimplifier transformed:\n+   .ASSUME (cond);\n+   into:\n+   [[assume (guard)]]\n+   {\n+     guard = cond;\n+   }\n+   which we should transform into:\n+   .ASSUME (&artificial_fn, args...);\n+   where artificial_fn will look like:\n+   bool artificial_fn (args...)\n+   {\n+     guard = cond;\n+     return guard;\n+   }\n+   with any debug stmts in the block removed and jumps out of\n+   the block or return stmts replaced with return false;  */\n+\n+static void\n+lower_assumption (gimple_stmt_iterator *gsi, struct lower_data *data)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree guard = gimple_assume_guard (stmt);\n+  gimple *bind = gimple_assume_body (stmt);\n+  location_t loc = gimple_location (stmt);\n+  gcc_assert (gimple_code (bind) == GIMPLE_BIND);\n+\n+  lower_assumption_data lad;\n+  hash_map<tree, tree> decl_map;\n+  memset (&lad.id, 0, sizeof (lad.id));\n+  lad.return_false_label = NULL_TREE;\n+  lad.id.src_fn = current_function_decl;\n+  lad.id.dst_fn = create_assumption_fn (loc);\n+  lad.id.src_cfun = DECL_STRUCT_FUNCTION (lad.id.src_fn);\n+  lad.id.decl_map = &decl_map;\n+  lad.id.copy_decl = assumption_copy_decl;\n+  lad.id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  lad.id.transform_parameter = true;\n+  lad.id.do_not_unshare = true;\n+  lad.id.do_not_fold = true;\n+  cfun->curr_properties = lad.id.src_cfun->curr_properties;\n+  lad.guard_copy = create_tmp_var (boolean_type_node);\n+  decl_map.put (lad.guard_copy, lad.guard_copy);\n+  decl_map.put (guard, lad.guard_copy);\n+  cfun->assume_function = 1;\n+\n+  /* Find variables, labels and SSA_NAMEs local to the assume GIMPLE_BIND.  */\n+  gimple_stmt_iterator gsi2 = gsi_start (*gimple_assume_body_ptr (stmt));\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = (void *) &lad;\n+  walk_gimple_stmt (&gsi2, find_assumption_locals_r, NULL, &wi);\n+  unsigned int sz = lad.decls.length ();\n+  for (unsigned i = 0; i < sz; ++i)\n+    {\n+      tree v = lad.decls[i];\n+      tree newv;\n+      /* SSA_NAMEs defined in the assume condition should be replaced\n+\t by new SSA_NAMEs in the artificial function.  */\n+      if (TREE_CODE (v) == SSA_NAME)\n+\t{\n+\t  newv = make_ssa_name (remap_type (TREE_TYPE (v), &lad.id));\n+\t  decl_map.put (v, newv);\n+\t}\n+      /* Local vars should have context and type adjusted to the\n+\t new artificial function.  */\n+      else if (VAR_P (v))\n+\t{\n+\t  if (is_global_var (v) && !DECL_ASSEMBLER_NAME_SET_P (v))\n+\t    DECL_ASSEMBLER_NAME (v);\n+\t  TREE_TYPE (v) = remap_type (TREE_TYPE (v), &lad.id);\n+\t  DECL_CONTEXT (v) = current_function_decl;\n+\t}\n+    }\n+  /* References to other automatic vars should be replaced by\n+     PARM_DECLs to the artificial function.  */\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = (void *) &lad;\n+  walk_gimple_stmt (&gsi2, adjust_assumption_stmt_r,\n+\t\t    adjust_assumption_stmt_op, &wi);\n+\n+  /* At the start prepend guard = false;  */\n+  gimple_seq body = NULL;\n+  gimple *g = gimple_build_assign (lad.guard_copy, boolean_false_node);\n+  gimple_seq_add_stmt (&body, g);\n+  gimple_seq_add_stmt (&body, bind);\n+  /* At the end add return guard;  */\n+  greturn *gr = gimple_build_return (lad.guard_copy);\n+  gimple_seq_add_stmt (&body, gr);\n+  /* If there were any jumps to labels outside of the condition,\n+     replace them with a jump to\n+     return_false_label:\n+     guard = false;\n+     return guard;  */\n+  if (lad.return_false_label)\n+    {\n+      g = gimple_build_label (lad.return_false_label);\n+      gimple_seq_add_stmt (&body, g);\n+      g = gimple_build_assign (lad.guard_copy, boolean_false_node);\n+      gimple_seq_add_stmt (&body, g);\n+      gr = gimple_build_return (lad.guard_copy);\n+      gimple_seq_add_stmt (&body, gr);\n+    }\n+  bind = gimple_build_bind (NULL_TREE, body, NULL_TREE);\n+  body = NULL;\n+  gimple_seq_add_stmt (&body, bind);\n+  gimple_set_body (current_function_decl, body);\n+  pop_cfun ();\n+\n+  tree parms = NULL_TREE;\n+  tree parmt = void_list_node;\n+  auto_vec<tree, 8> vargs;\n+  vargs.safe_grow (1 + (lad.decls.length () - sz), true);\n+  /* First argument to IFN_ASSUME will be address of the\n+     artificial function.  */\n+  vargs[0] = build_fold_addr_expr (lad.id.dst_fn);\n+  for (unsigned i = lad.decls.length (); i > sz; --i)\n+    {\n+      tree *v = decl_map.get (lad.decls[i - 1]);\n+      gcc_assert (v && TREE_CODE (*v) == PARM_DECL);\n+      DECL_CHAIN (*v) = parms;\n+      parms = *v;\n+      parmt = tree_cons (NULL_TREE, TREE_TYPE (*v), parmt);\n+      /* Remaining arguments will be the variables/parameters\n+\t mentioned in the condition.  */\n+      vargs[i - sz] = lad.decls[i - 1];\n+      /* If they have gimple types, we might need to regimplify\n+\t them to make the IFN_ASSUME call valid.  */\n+      if (is_gimple_reg_type (TREE_TYPE (vargs[i - sz]))\n+\t  && !is_gimple_val (vargs[i - sz]))\n+\t{\n+\t  tree t = make_ssa_name (TREE_TYPE (vargs[i - sz]));\n+\t  g = gimple_build_assign (t, vargs[i - sz]);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  vargs[i - sz] = t;\n+\t}\n+    }\n+  DECL_ARGUMENTS (lad.id.dst_fn) = parms;\n+  TREE_TYPE (lad.id.dst_fn) = build_function_type (boolean_type_node, parmt);\n+\n+  cgraph_node::add_new_function (lad.id.dst_fn, false);\n+\n+  for (unsigned i = 0; i < sz; ++i)\n+    {\n+      tree v = lad.decls[i];\n+      if (TREE_CODE (v) == SSA_NAME)\n+\trelease_ssa_name (v);\n+    }\n+\n+  data->cannot_fallthru = false;\n+  /* Replace GIMPLE_ASSUME statement with IFN_ASSUME call.  */\n+  gcall *call = gimple_build_call_internal_vec (IFN_ASSUME, vargs);\n+  gimple_set_location (call, loc);\n+  gsi_replace (gsi, call, true);\n+}\n \n /* Lower statement GSI.  DATA is passed through the recursion.  We try to\n    track the fallthruness of statements and get rid of unreachable return\n@@ -403,6 +794,10 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       data->cannot_fallthru = false;\n       return;\n \n+    case GIMPLE_ASSUME:\n+      lower_assumption (gsi, data);\n+      return;\n+\n     case GIMPLE_TRANSACTION:\n       lower_sequence (gimple_transaction_body_ptr (\n \t\t\tas_a <gtransaction *> (stmt)),"}, {"sha": "7ec079f15c638cf64c1a4a93b27edd83b7a3fbf1", "filename": "gcc/gimple-pretty-print.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -2052,6 +2052,31 @@ dump_gimple_omp_return (pretty_printer *buffer, const gimple *gs, int spc,\n     }\n }\n \n+/* Dump a GIMPLE_ASSUME tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_assume (pretty_printer *buffer, const gimple *gs,\n+\t\t    int spc, dump_flags_t flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags,\n+\t\t     \"%G [GUARD=%T] <%+BODY <%S> >\",\n+\t\t     gs, gimple_assume_guard (gs),\n+\t\t     gimple_assume_body (gs));\n+  else\n+    {\n+      pp_string (buffer, \"[[assume (\");\n+      dump_generic_node (buffer, gimple_assume_guard (gs), spc, flags, false);\n+      pp_string (buffer, \")]]\");\n+      newline_and_indent (buffer, spc + 2);\n+      pp_left_brace (buffer);\n+      pp_newline (buffer);\n+      dump_gimple_seq (buffer, gimple_assume_body (gs), spc + 4, flags);\n+      newline_and_indent (buffer, spc + 2);\n+      pp_right_brace (buffer);\n+    }\n+}\n+\n /* Dump a GIMPLE_TRANSACTION tuple on the pretty_printer BUFFER.  */\n \n static void\n@@ -2841,6 +2866,10 @@ pp_gimple_stmt_1 (pretty_printer *buffer, const gimple *gs, int spc,\n       pp_string (buffer, \" predictor.\");\n       break;\n \n+    case GIMPLE_ASSUME:\n+      dump_gimple_assume (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_TRANSACTION:\n       dump_gimple_transaction (buffer, as_a <const gtransaction *> (gs), spc,\n \t\t\t       flags);"}, {"sha": "cad36f76e904a155a00d4329036b84332773c172", "filename": "gcc/gimple-walk.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple-walk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple-walk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -485,6 +485,12 @@ walk_gimple_op (gimple *stmt, walk_tree_fn callback_op,\n       }\n       break;\n \n+    case GIMPLE_ASSUME:\n+      ret = walk_tree (gimple_assume_guard_ptr (stmt), callback_op, wi, pset);\n+      if (ret)\n+\treturn ret;\n+      break;\n+\n     case GIMPLE_TRANSACTION:\n       {\n \tgtransaction *txn = as_a <gtransaction *> (stmt);\n@@ -707,6 +713,13 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n \treturn wi->callback_result;\n       break;\n \n+    case GIMPLE_ASSUME:\n+      ret = walk_gimple_seq_mod (gimple_assume_body_ptr (stmt),\n+\t\t\t\t callback_stmt, callback_op, wi);\n+      if (ret)\n+\treturn wi->callback_result;\n+      break;\n+\n     case GIMPLE_TRANSACTION:\n       ret = walk_gimple_seq_mod (gimple_transaction_body_ptr (\n \t\t\t\t   as_a <gtransaction *> (stmt)),"}, {"sha": "6c23dd77609396624c225a83b6717b3d2c06ae91", "filename": "gcc/gimple.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -1290,6 +1290,18 @@ gimple_build_omp_atomic_store (tree val, enum omp_memory_order mo)\n   return p;\n }\n \n+/* Build a GIMPLE_ASSUME statement.  */\n+\n+gimple *\n+gimple_build_assume (tree guard, gimple_seq body)\n+{\n+  gimple_statement_assume *p\n+    = as_a <gimple_statement_assume *> (gimple_alloc (GIMPLE_ASSUME, 0));\n+  gimple_assume_set_guard (p, guard);\n+  *gimple_assume_body_ptr (p) = body;\n+  return p;\n+}\n+\n /* Build a GIMPLE_TRANSACTION statement.  */\n \n gtransaction *\n@@ -2135,6 +2147,13 @@ gimple_copy (gimple *stmt)\n \t  gimple_omp_masked_set_clauses (copy, t);\n \t  goto copy_omp_body;\n \n+\tcase GIMPLE_ASSUME:\n+\t  new_seq = gimple_seq_copy (gimple_assume_body (stmt));\n+\t  *gimple_assume_body_ptr (copy) = new_seq;\n+\t  gimple_assume_set_guard (copy,\n+\t\t\t\t   unshare_expr (gimple_assume_guard (stmt)));\n+\t  break;\n+\n \tcase GIMPLE_TRANSACTION:\n \t  new_seq = gimple_seq_copy (gimple_transaction_body (\n \t\t\t\t       as_a <gtransaction *> (stmt)));"}, {"sha": "7c617cdccc4219d21bd7ef372459e8f6ce267ff4", "filename": "gcc/gimple.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -406,3 +406,8 @@ DEFGSCODE(GIMPLE_PREDICT, \"gimple_predict\", GSS_BASE)\n \n     This tuple should not exist outside of the gimplifier proper.  */\n DEFGSCODE(GIMPLE_WITH_CLEANUP_EXPR, \"gimple_with_cleanup_expr\", GSS_WCE)\n+\n+/* GIMPLE_ASSUME <GUARD, BODY> represents [[assume(cond)]].\n+   BODY is the GIMPLE_BIND with the condition which sets GUARD to true\n+   (otherwise UB).  */\n+DEFGSCODE(GIMPLE_ASSUME, \"gimple_assume\", GSS_ASSUME)"}, {"sha": "adbeb063186d4a8e009e4dd184d73609d2c5d78c", "filename": "gcc/gimple.h", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -825,6 +825,20 @@ struct GTY((tag(\"GSS_OMP_ATOMIC_STORE_LAYOUT\")))\n          stmt->code == GIMPLE_OMP_RETURN.  */\n };\n \n+/* Assumptions.  */\n+\n+struct GTY((tag(\"GSS_ASSUME\")))\n+  gimple_statement_assume : public gimple\n+{\n+  /* [ WORD 1-6 ] : base class */\n+\n+  /* [ WORD 7 ]  */\n+  tree guard;\n+\n+  /* [ WORD 8 ]  */\n+  gimple_seq body;\n+};\n+\n /* GIMPLE_TRANSACTION.  */\n \n /* Bits to be stored in the GIMPLE_TRANSACTION subcode.  */\n@@ -1268,6 +1282,14 @@ is_a_helper <const gswitch *>::test (const gimple *gs)\n   return gs->code == GIMPLE_SWITCH;\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <gimple_statement_assume *>::test (gimple *gs)\n+{\n+  return gs->code == GIMPLE_ASSUME;\n+}\n+\n template <>\n template <>\n inline bool\n@@ -1494,6 +1516,14 @@ is_a_helper <const greturn *>::test (const gimple *gs)\n   return gs->code == GIMPLE_RETURN;\n }\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <const gimple_statement_assume *>::test (const gimple *gs)\n+{\n+  return gs->code == GIMPLE_ASSUME;\n+}\n+\n template <>\n template <>\n inline bool\n@@ -1577,6 +1607,7 @@ gomp_teams *gimple_build_omp_teams (gimple_seq, tree);\n gomp_atomic_load *gimple_build_omp_atomic_load (tree, tree,\n \t\t\t\t\t\tenum omp_memory_order);\n gomp_atomic_store *gimple_build_omp_atomic_store (tree, enum omp_memory_order);\n+gimple *gimple_build_assume (tree, gimple_seq);\n gtransaction *gimple_build_transaction (gimple_seq);\n extern void gimple_seq_add_stmt (gimple_seq *, gimple *);\n extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple *);\n@@ -1835,6 +1866,7 @@ gimple_has_substatements (gimple *g)\n {\n   switch (gimple_code (g))\n     {\n+    case GIMPLE_ASSUME:\n     case GIMPLE_BIND:\n     case GIMPLE_CATCH:\n     case GIMPLE_EH_FILTER:\n@@ -6520,6 +6552,52 @@ gimple_omp_continue_set_control_use (gomp_continue *cont_stmt, tree use)\n   cont_stmt->control_use = use;\n }\n \n+/* Return the guard associated with the GIMPLE_ASSUME statement GS.  */\n+\n+static inline tree\n+gimple_assume_guard (const gimple *gs)\n+{\n+  const gimple_statement_assume *assume_stmt\n+    = as_a <const gimple_statement_assume *> (gs);\n+  return assume_stmt->guard;\n+}\n+\n+/* Set the guard associated with the GIMPLE_ASSUME statement GS.  */\n+\n+static inline void\n+gimple_assume_set_guard (gimple *gs, tree guard)\n+{\n+  gimple_statement_assume *assume_stmt = as_a <gimple_statement_assume *> (gs);\n+  assume_stmt->guard = guard;\n+}\n+\n+static inline tree *\n+gimple_assume_guard_ptr (gimple *gs)\n+{\n+  gimple_statement_assume *assume_stmt = as_a <gimple_statement_assume *> (gs);\n+  return &assume_stmt->guard;\n+}\n+\n+/* Return the address of the GIMPLE sequence contained in the GIMPLE_ASSUME\n+   statement GS.  */\n+\n+static inline gimple_seq *\n+gimple_assume_body_ptr (gimple *gs)\n+{\n+  gimple_statement_assume *assume_stmt = as_a <gimple_statement_assume *> (gs);\n+  return &assume_stmt->body;\n+}\n+\n+/* Return the GIMPLE sequence contained in the GIMPLE_ASSUME statement GS.  */\n+\n+static inline gimple_seq\n+gimple_assume_body (const gimple *gs)\n+{\n+  const gimple_statement_assume *assume_stmt\n+    = as_a <const gimple_statement_assume *> (gs);\n+  return assume_stmt->body;\n+}\n+\n /* Return a pointer to the body for the GIMPLE_TRANSACTION statement\n    TRANSACTION_STMT.  */\n "}, {"sha": "42a996dfeb911002692a983715ea0f6d268452bb", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -3569,7 +3569,33 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t\t\t\t\t\t     fndecl, 0));\n \t      return GS_OK;\n \t    }\n-\t  /* FIXME: Otherwise expand it specially.  */\n+\t  /* If not optimizing, ignore the assumptions.  */\n+\t  if (!optimize)\n+\t    {\n+\t      *expr_p = NULL_TREE;\n+\t      return GS_ALL_DONE;\n+\t    }\n+\t  /* Temporarily, until gimple lowering, transform\n+\t     .ASSUME (cond);\n+\t     into:\n+\t     [[assume (guard)]]\n+\t     {\n+\t       guard = cond;\n+\t     }\n+\t     such that gimple lowering can outline the condition into\n+\t     a separate function easily.  */\n+\t  tree guard = create_tmp_var (boolean_type_node);\n+\t  *expr_p = build2 (MODIFY_EXPR, void_type_node, guard,\n+\t\t\t    CALL_EXPR_ARG (*expr_p, 0));\n+\t  *expr_p = build3 (BIND_EXPR, void_type_node, NULL, *expr_p, NULL);\n+\t  push_gimplify_context ();\n+\t  gimple_seq body = NULL;\n+\t  gimple *g = gimplify_and_return_first (*expr_p, &body);\n+\t  pop_gimplify_context (g);\n+\t  g = gimple_build_assume (guard, body);\n+\t  gimple_set_location (g, loc);\n+\t  gimplify_seq_add_stmt (pre_p, g);\n+\t  *expr_p = NULL_TREE;\n \t  return GS_ALL_DONE;\n \t}\n "}, {"sha": "c3f64ef1ad3cd877103eeaadab563ad5aee6271b", "filename": "gcc/gsstruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -50,4 +50,5 @@ DEFGSSTRUCT(GSS_OMP_SINGLE_LAYOUT, gimple_statement_omp_single_layout, false)\n DEFGSSTRUCT(GSS_OMP_CONTINUE, gomp_continue, false)\n DEFGSSTRUCT(GSS_OMP_ATOMIC_LOAD, gomp_atomic_load, false)\n DEFGSSTRUCT(GSS_OMP_ATOMIC_STORE_LAYOUT, gomp_atomic_store, false)\n+DEFGSSTRUCT(GSS_ASSUME, gimple_statement_assume, false)\n DEFGSSTRUCT(GSS_TRANSACTION, gtransaction, false)"}, {"sha": "9471f543191edf0aea125ff0fc426511b2306169", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -4526,5 +4526,4 @@ expand_TRAP (internal_fn, gcall *)\n void\n expand_ASSUME (internal_fn, gcall *)\n {\n-  gcc_unreachable ();\n }"}, {"sha": "5439651a576c0bbfc46f14cae65e8600051a0e6f", "filename": "gcc/lto-streamer-in.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Flto-streamer-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Flto-streamer-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -1318,6 +1318,7 @@ input_struct_function_base (struct function *fn, class data_in *data_in,\n   fn->calls_eh_return = bp_unpack_value (&bp, 1);\n   fn->has_force_vectorize_loops = bp_unpack_value (&bp, 1);\n   fn->has_simduid_loops = bp_unpack_value (&bp, 1);\n+  fn->assume_function = bp_unpack_value (&bp, 1);\n   fn->va_list_fpr_size = bp_unpack_value (&bp, 8);\n   fn->va_list_gpr_size = bp_unpack_value (&bp, 8);\n   fn->last_clique = bp_unpack_value (&bp, sizeof (short) * 8);"}, {"sha": "1e3890490626af7c212732aeb7e6e562c2280d22", "filename": "gcc/lto-streamer-out.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Flto-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Flto-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -2278,6 +2278,7 @@ output_struct_function_base (struct output_block *ob, struct function *fn)\n   bp_pack_value (&bp, fn->calls_eh_return, 1);\n   bp_pack_value (&bp, fn->has_force_vectorize_loops, 1);\n   bp_pack_value (&bp, fn->has_simduid_loops, 1);\n+  bp_pack_value (&bp, fn->assume_function, 1);\n   bp_pack_value (&bp, fn->va_list_fpr_size, 8);\n   bp_pack_value (&bp, fn->va_list_gpr_size, 8);\n   bp_pack_value (&bp, fn->last_clique, sizeof (short) * 8);"}, {"sha": "a8809739001cc4e4a7f3c904e0bfe479cfec3369", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -202,6 +202,7 @@ static bool omp_maybe_offloaded_ctx (omp_context *ctx);\n     case GIMPLE_TRY: \\\n     case GIMPLE_CATCH: \\\n     case GIMPLE_EH_FILTER: \\\n+    case GIMPLE_ASSUME: \\\n     case GIMPLE_TRANSACTION: \\\n       /* The sub-statements for these should be walked.  */ \\\n       *handled_ops_p = false; \\\n@@ -14413,6 +14414,9 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       lower_omp (gimple_try_eval_ptr (stmt), ctx);\n       lower_omp (gimple_try_cleanup_ptr (stmt), ctx);\n       break;\n+    case GIMPLE_ASSUME:\n+      lower_omp (gimple_assume_body_ptr (stmt), ctx);\n+      break;\n     case GIMPLE_TRANSACTION:\n       lower_omp (gimple_transaction_body_ptr (as_a <gtransaction *> (stmt)),\n \t\t ctx);"}, {"sha": "df333ba34ab261924ee7865760a0abaebdca7716", "filename": "gcc/omp-oacc-kernels-decompose.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fomp-oacc-kernels-decompose.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fomp-oacc-kernels-decompose.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-oacc-kernels-decompose.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -189,6 +189,7 @@ adjust_region_code_walk_stmt_fn (gimple_stmt_iterator *gsi_p,\n     case GIMPLE_GOTO:\n     case GIMPLE_SWITCH:\n     case GIMPLE_ASM:\n+    case GIMPLE_ASSUME:\n     case GIMPLE_TRANSACTION:\n     case GIMPLE_RETURN:\n       /* Statement that might constitute some looping/control flow pattern.  */"}, {"sha": "3bbf525ac801a37c45b57bad9b4690e9cb0c18d9", "filename": "gcc/passes.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fpasses.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fpasses.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -2660,6 +2660,15 @@ execute_one_pass (opt_pass *pass)\n       if (dom_info_available_p (CDI_POST_DOMINATORS))\n        free_dominance_info (CDI_POST_DOMINATORS);\n \n+      if (cfun->assume_function)\n+\t{\n+\t  /* For assume functions, don't release body, keep it around.  */\n+\t  cfun->curr_properties |= PROP_assumptions_done;\n+\t  pop_cfun ();\n+\t  current_pass = NULL;\n+\t  return true;\n+\t}\n+\n       tree fn = cfun->decl;\n       pop_cfun ();\n       gcc_assert (!cfun);"}, {"sha": "193b579474962f862cd66080f0d867f68b64c934", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -407,6 +407,7 @@ along with GCC; see the file COPYING3.  If not see\n \t and thus it should be run last.  */\n       NEXT_PASS (pass_uncprop);\n   POP_INSERT_PASSES ()\n+  NEXT_PASS (pass_assumptions);\n   NEXT_PASS (pass_tm_init);\n   PUSH_INSERT_PASSES_WITHIN (pass_tm_init)\n       NEXT_PASS (pass_tm_mark);"}, {"sha": "fec220925c52a91b4848814dba45730004d27ae0", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume5.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume5.C?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -0,0 +1,5 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O2\" }\n+\n+#include \"attr-assume1.C\""}, {"sha": "4a81df175443187b216ac560a75fd52502a21794", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume6.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume6.C?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -0,0 +1,5 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O2\" }\n+\n+#include \"attr-assume3.C\""}, {"sha": "441242ce05004eb238f8892a621541ea683a1d32", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume7.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume7.C?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -0,0 +1,56 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2\" }\n+\n+int\n+foo (int x)\n+{\n+  [[assume (x == 42)]];\n+  return x;\n+}\n+\n+int\n+bar (int x)\n+{\n+  [[assume (++x == 43)]];\n+  return x;\n+}\n+\n+int\n+baz (int x)\n+{\n+  [[assume (({ int z = ++x; static int w; ++w; if (z == 51) return -1; if (z == 53) goto lab1; if (z == 64) throw 1; z == 43; }))]];\n+lab1:\n+  return x;\n+}\n+\n+struct S { S (); S (const S &); ~S (); int a, b; int foo (); };\n+\n+int\n+qux ()\n+{\n+  S s;\n+  [[assume (s.a == 42 && s.b == 43)]];\n+  return s.a + s.b;\n+}\n+\n+int\n+S::foo ()\n+{\n+  [[assume (a == 42 && b == 43)]];\n+  return a + b;\n+}\n+\n+int\n+corge (int x)\n+{\n+  [[assume (({ [[assume (x < 42)]]; x > -42; }))]];\n+  return x < 42;\n+}\n+\n+int\n+garply (int x)\n+{\n+  [[assume (({ [[assume (++x < 43)]]; x > -42; }))]];\n+  return x < 42;\n+}"}, {"sha": "63d9b005180eea2e64e15b0788f817e16060fc20", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -226,6 +226,7 @@ DEFTIMEVAR (TV_TREE_WIDEN_MUL        , \"gimple widening/fma detection\")\n DEFTIMEVAR (TV_TRANS_MEM             , \"transactional memory\")\n DEFTIMEVAR (TV_TREE_STRLEN           , \"tree strlen optimization\")\n DEFTIMEVAR (TV_TREE_MODREF\t     , \"tree modref\")\n+DEFTIMEVAR (TV_TREE_ASSUMPTIONS      , \"tree assumptions\")\n DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")\n DEFTIMEVAR (TV_DOM_FRONTIERS         , \"dominance frontiers\")\n DEFTIMEVAR (TV_DOMINANCE             , \"dominance computation\")"}, {"sha": "9b2c0f6956c41471cb25dae1c939b5c86ea54335", "filename": "gcc/tree-cfg.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-cfg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-cfg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -5139,6 +5139,9 @@ verify_gimple_stmt (gimple *stmt)\n \t how to setup the parallel iteration.  */\n       return false;\n \n+    case GIMPLE_ASSUME:\n+      return false;\n+\n     case GIMPLE_DEBUG:\n       return verify_gimple_debug (stmt);\n \n@@ -5252,6 +5255,10 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n \t\t\t\t\t   as_a <gcatch *> (stmt)));\n \t  break;\n \n+\tcase GIMPLE_ASSUME:\n+\t  err |= verify_gimple_in_seq_2 (gimple_assume_body (stmt));\n+\t  break;\n+\n \tcase GIMPLE_TRANSACTION:\n \t  err |= verify_gimple_transaction (as_a <gtransaction *> (stmt));\n \t  break;"}, {"sha": "8091ba8f13bd792869ca1526aa71b082a81147ed", "filename": "gcc/tree-inline.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-inline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-inline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -1736,6 +1736,11 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t\t\t\t\t      (as_a <gomp_critical *> (stmt)));\n \t  break;\n \n+\tcase GIMPLE_ASSUME:\n+\t  s1 = remap_gimple_seq (gimple_assume_body (stmt), id);\n+\t  copy = gimple_build_assume (gimple_assume_guard (stmt), s1);\n+\t  break;\n+\n \tcase GIMPLE_TRANSACTION:\n \t  {\n \t    gtransaction *old_trans_stmt = as_a <gtransaction *> (stmt);"}, {"sha": "8480d41384b7a6287fd794bc05a57f65d5898ab1", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -227,6 +227,8 @@ class simple_ipa_opt_pass : public opt_pass\n #define PROP_rtl_split_insns\t(1 << 17)\t/* RTL has insns split.  */\n #define PROP_loop_opts_done\t(1 << 18)\t/* SSA loop optimizations\n \t\t\t\t\t\t   have completed.  */\n+#define PROP_assumptions_done\t(1 << 19)\t/* Assume function kept\n+\t\t\t\t\t\t   around.  */\n \n #define PROP_gimple \\\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh | PROP_gimple_lomp)\n@@ -301,7 +303,8 @@ class simple_ipa_opt_pass : public opt_pass\n /* Rebuild the callgraph edges.  */\n #define TODO_rebuild_cgraph_edges       (1 << 22)\n \n-/* Release function body and stop pass manager.  */\n+/* Release function body (unless assumption function)\n+   and stop pass manager.  */\n #define TODO_discard_function\t\t(1 << 23)\n \n /* Internally used in execute_function_todo().  */\n@@ -465,6 +468,7 @@ extern gimple_opt_pass *make_pass_copy_prop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_isolate_erroneous_paths (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_early_vrp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_vrp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_assumptions (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_uncprop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_return_slot (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_reassoc (gcc::context *ctxt);"}, {"sha": "9778e776cf27f992f61a709842a7dbf895697067", "filename": "gcc/tree-ssa-ccp.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-ssa-ccp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-ssa-ccp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -4253,6 +4253,12 @@ pass_fold_builtins::execute (function *fun)\n \t    }\n \n \t  callee = gimple_call_fndecl (stmt);\n+\t  if (!callee\n+\t      && gimple_call_internal_p (stmt, IFN_ASSUME))\n+\t    {\n+\t      gsi_remove (&i, true);\n+\t      continue;\n+\t    }\n \t  if (!callee || !fndecl_built_in_p (callee, BUILT_IN_NORMAL))\n \t    {\n \t      gsi_next (&i);"}, {"sha": "1adb15c99344b9f923292b1f7c9e6ca6f0a8a58f", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dda30e9910c4f04a6258b053401249e213f29be/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=4dda30e9910c4f04a6258b053401249e213f29be", "patch": "@@ -4441,6 +4441,35 @@ class pass_vrp : public gimple_opt_pass\n   int my_pass;\n }; // class pass_vrp\n \n+const pass_data pass_data_assumptions =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"assumptions\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_ASSUMPTIONS, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  PROP_assumptions_done, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_end */\n+};\n+\n+class pass_assumptions : public gimple_opt_pass\n+{\n+public:\n+  pass_assumptions (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_assumptions, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *fun) final override { return fun->assume_function; }\n+  unsigned int execute (function *) final override\n+    {\n+      return TODO_discard_function;\n+    }\n+\n+}; // class pass_assumptions\n+\n } // anon namespace\n \n gimple_opt_pass *\n@@ -4454,3 +4483,9 @@ make_pass_early_vrp (gcc::context *ctxt)\n {\n   return new pass_vrp (ctxt, pass_data_early_vrp);\n }\n+\n+gimple_opt_pass *\n+make_pass_assumptions (gcc::context *ctx)\n+{\n+  return new pass_assumptions (ctx);\n+}"}]}