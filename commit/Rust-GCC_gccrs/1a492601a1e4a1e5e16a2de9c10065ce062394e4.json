{"sha": "1a492601a1e4a1e5e16a2de9c10065ce062394e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0OTI2MDFhMWU0YTFlNWUxNmEyZGU5YzEwMDY1Y2UwNjIzOTRlNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-09T22:16:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-09T22:16:08Z"}, "message": "re PR fortran/24558 (ENTRY doesn't work in module procedures)\n\n2006-06-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24558\n\tPR fortran/20877\n\tPR fortran/25047\n\t* decl.c (get_proc_name): Add new argument to flag that a\n\tmodule function entry is being treated. If true, correct\n\terror condition, add symtree to module namespace and add\n\ta module procedure.\n\t(gfc_match_function_decl, gfc_match_entry,\n\tgfc_match_subroutine): Use the new argument in calls to\n\tget_proc_name.\n\t* resolve.c (resolve_entries): ENTRY symbol reference to\n\tto master entry namespace if a module function.\n\t* trans-decl.c (gfc_create_module_variable): Return if\n\tthe symbol is an entry.\n\t* trans-exp.c (gfc_conv_variable): Check that parent_decl\n\tis not NULL.\n\n2006-06-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/24558\n\t* gfortran.dg/entry_6.f90: New test.\n\n\tPR fortran/20877\n\tPR fortran/25047\n\t* gfortran.dg/entry_7.f90: New test.\n\nFrom-SVN: r114526", "tree": {"sha": "8d0fb7320d34f476c6bd5691f92ac2df98f1fb3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d0fb7320d34f476c6bd5691f92ac2df98f1fb3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a492601a1e4a1e5e16a2de9c10065ce062394e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a492601a1e4a1e5e16a2de9c10065ce062394e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a492601a1e4a1e5e16a2de9c10065ce062394e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a492601a1e4a1e5e16a2de9c10065ce062394e4/comments", "author": null, "committer": null, "parents": [{"sha": "d0d1b24d8989e0f293291e6f31f08c40f332484c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d1b24d8989e0f293291e6f31f08c40f332484c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d1b24d8989e0f293291e6f31f08c40f332484c"}], "stats": {"total": 175, "additions": 162, "deletions": 13}, "files": [{"sha": "c68fd8c72d438566f35b1b683e984622266bae1c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -1,3 +1,22 @@\n+2006-06-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24558\n+\tPR fortran/20877\n+\tPR fortran/25047\n+\t* decl.c (get_proc_name): Add new argument to flag that a\n+\tmodule function entry is being treated. If true, correct\n+\terror condition, add symtree to module namespace and add\n+\ta module procedure.\n+\t(gfc_match_function_decl, gfc_match_entry,\n+\tgfc_match_subroutine): Use the new argument in calls to\n+\tget_proc_name.\n+\t* resolve.c (resolve_entries): ENTRY symbol reference to\n+\tto master entry namespace if a module function.\n+\t* trans-decl.c (gfc_create_module_variable): Return if\n+\tthe symbol is an entry.\n+\t* trans-exp.c (gfc_conv_variable): Check that parent_decl\n+\tis not NULL.\n+\n 2006-06-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/27916"}, {"sha": "e8b1626609ae12f7549d53bbef5190e54a74bcdc", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -596,13 +596,20 @@ find_special (const char *name, gfc_symbol ** result)\n    parent, then the symbol is just created in the current unit.  */\n \n static int\n-get_proc_name (const char *name, gfc_symbol ** result)\n+get_proc_name (const char *name, gfc_symbol ** result,\n+\t       bool module_fcn_entry)\n {\n   gfc_symtree *st;\n   gfc_symbol *sym;\n   int rc;\n \n-  if (gfc_current_ns->parent == NULL)\n+  /* Module functions have to be left in their own namespace because\n+     they have potentially (almost certainly!) already been referenced.\n+     In this sense, they are rather like external functions.  This is\n+     fixed up in resolve.c(resolve_entries), where the symbol name-\n+     space is set to point to the master function, so that the fake\n+     result mechanism can work.  */\n+  if (module_fcn_entry)\n     rc = gfc_get_symbol (name, NULL, result);\n   else\n     rc = gfc_get_symbol (name, gfc_current_ns->parent, result);\n@@ -628,7 +635,8 @@ get_proc_name (const char *name, gfc_symbol ** result)\n       if (sym->ts.kind != 0\n \t    && sym->attr.proc == 0\n \t    && gfc_current_ns->parent != NULL\n-\t    && sym->attr.access == 0)\n+\t    && sym->attr.access == 0\n+\t    && !module_fcn_entry)\n \tgfc_error_now (\"Procedure '%s' at %C has an explicit interface\"\n \t\t       \" and must not have attributes declared at %L\",\n \t\t       name, &sym->declared_at);\n@@ -637,18 +645,23 @@ get_proc_name (const char *name, gfc_symbol ** result)\n   if (gfc_current_ns->parent == NULL || *result == NULL)\n     return rc;\n \n-  st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n+  /* Module function entries will already have a symtree in\n+     the current namespace but will need one at module level.  */\n+  if (module_fcn_entry)\n+    st = gfc_new_symtree (&gfc_current_ns->parent->sym_root, name);\n+  else\n+    st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n \n   st->n.sym = sym;\n   sym->refs++;\n \n   /* See if the procedure should be a module procedure */\n \n-  if (sym->ns->proc_name != NULL\n-      && sym->ns->proc_name->attr.flavor == FL_MODULE\n-      && sym->attr.proc != PROC_MODULE\n-      && gfc_add_procedure (&sym->attr, PROC_MODULE,\n-\t\t\t    sym->name, NULL) == FAILURE)\n+  if (((sym->ns->proc_name != NULL\n+\t  && sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t  && sym->attr.proc != PROC_MODULE) || module_fcn_entry)\n+\t&& gfc_add_procedure (&sym->attr, PROC_MODULE,\n+\t\t\t      sym->name, NULL) == FAILURE)\n     rc = 2;\n \n   return rc;\n@@ -2564,7 +2577,7 @@ gfc_match_function_decl (void)\n       return MATCH_NO;\n     }\n \n-  if (get_proc_name (name, &sym))\n+  if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n   gfc_new_block = sym;\n \n@@ -2667,6 +2680,7 @@ gfc_match_entry (void)\n   match m;\n   gfc_entry_list *el;\n   locus old_loc;\n+  bool module_procedure;\n \n   m = gfc_match_name (name);\n   if (m != MATCH_YES)\n@@ -2727,16 +2741,26 @@ gfc_match_entry (void)\n       return MATCH_ERROR;\n     }\n \n+  module_procedure = gfc_current_ns->parent != NULL\n+      && gfc_current_ns->parent->proc_name\n+      && gfc_current_ns->parent->proc_name->attr.flavor == FL_MODULE;\n+\n   if (gfc_current_ns->parent != NULL\n       && gfc_current_ns->parent->proc_name\n-      && gfc_current_ns->parent->proc_name->attr.flavor != FL_MODULE)\n+      && !module_procedure)\n     {\n       gfc_error(\"ENTRY statement at %C cannot appear in a \"\n \t\t\"contained procedure\");\n       return MATCH_ERROR;\n     }\n \n-  if (get_proc_name (name, &entry))\n+  /* Module function entries need special care in get_proc_name\n+     because previous references within the function will have\n+     created symbols attached to the current namespace.  */\n+  if (get_proc_name (name, &entry,\n+\t\t     gfc_current_ns->parent != NULL\n+\t\t     && module_procedure\n+\t\t     && gfc_current_ns->proc_name->attr.function))\n     return MATCH_ERROR;\n \n   proc = gfc_current_block ();\n@@ -2865,7 +2889,7 @@ gfc_match_subroutine (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (get_proc_name (name, &sym))\n+  if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n   gfc_new_block = sym;\n "}, {"sha": "384b5a4e343de8dea44c582764e78ba48b8d8e08", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -385,6 +385,16 @@ resolve_entries (gfc_namespace * ns)\n   ns->entries = el;\n   ns->proc_name->attr.entry = 1;\n \n+  /* If it is a module function, it needs to be in the right namespace\n+     so that gfc_get_fake_result_decl can gather up the results. The\n+     need for this arose in get_proc_name, where these beasts were\n+     left in their own namespace, to keep prior references linked to\n+     the entry declaration.*/\n+  if (ns->proc_name->attr.function\n+\t&& ns->parent\n+\t&& ns->parent->proc_name->attr.flavor == FL_MODULE)\n+    el->sym->ns = ns;\n+\n   /* Add an entry statement for it.  */\n   c = gfc_get_code ();\n   c->op = EXEC_ENTRY;"}, {"sha": "b4fa7f503a9a570e94ea2791152db5ad80c9a442", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -2653,6 +2653,11 @@ gfc_create_module_variable (gfc_symbol * sym)\n {\n   tree decl;\n \n+  /* Module functions with alternate entries are dealt with later and\n+     would get caught by the next condition.  */\n+  if (sym->attr.entry)\n+    return;\n+\n   /* Only output symbols from this module.  */\n   if (sym->ns != module_namespace)\n     {"}, {"sha": "44143d168e2e6c1e90bf3f7b60ee62d9132743f0", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -361,6 +361,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \n       if ((se->expr == parent_decl && return_value)\n \t   || (sym->ns && sym->ns->proc_name\n+\t       && parent_decl\n \t       && sym->ns->proc_name->backend_decl == parent_decl\n \t       && (alternate_entry || entry_master)))\n \tparent_flag = 1;"}, {"sha": "04f2d73d61b711cef4772b6714a6f1ddabb9c321", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -1,3 +1,12 @@\n+2006-06-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/24558\n+\t* gfortran.dg/entry_6.f90: New test.\n+\n+\tPR fortran/20877\n+\tPR fortran/25047\n+\t* gfortran.dg/entry_7.f90: New test.\n+\n 2006-06-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/27747"}, {"sha": "103392606b990bd6b0b6aff7cd7dc463f2e461d0", "filename": "gcc/testsuite/gfortran.dg/entry_6.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_6.f90?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+! Tests the fix for PR24558, which reported that module\n+! alternate function entries did not work.\n+!\n+! Contributed by Erik Edelmann  <eedelman@gcc.gnu.org>\n+!\n+module foo\n+contains\n+    function n1 (a)\n+        integer :: n1, n2, a, b\n+        integer, save :: c\n+        c = a\n+        n1 = c**3\n+        return\n+    entry n2 (b)\n+        n2 = c * b\n+        n2 = n2**2\n+        return\n+    end function n1\n+    function z1 (u)\n+        complex :: z1, z2, u, v\n+        z1 = (1.0, 2.0) * u\n+        return\n+    entry z2 (v)\n+        z2 = (3, 4) * v\n+        return\n+    end function z1\n+    function n3 (d)\n+        integer :: n3, d\n+        n3 = n2(d) * n1(d) ! Check sibling references.\n+        return\n+    end function n3\n+    function c1 (a)\n+        character(4) :: c1, c2, a, b\n+        c1 = a\n+        if (a .eq. \"abcd\") c1 = \"ABCD\"\n+        return\n+    entry c2 (b)\n+        c2 = b\n+        if (b .eq. \"wxyz\") c2 = \"WXYZ\"\n+        return\n+    end function c1\n+end module foo\n+    use foo\n+    if (n1(9) .ne. 729) call abort ()\n+    if (n2(2) .ne. 324) call abort ()\n+    if (n3(19) .ne. 200564019) call abort ()\n+    if (c1(\"lmno\") .ne. \"lmno\") call abort ()\n+    if (c1(\"abcd\") .ne. \"ABCD\") call abort ()\n+    if (c2(\"lmno\") .ne. \"lmno\") call abort ()\n+    if (c2(\"wxyz\") .ne. \"WXYZ\") call abort ()\n+    if (z1((3,4)) .ne. (-5, 10)) call abort ()\n+    if (z2((5,6)) .ne. (-9, 38)) call abort ()\n+ end\n+\n+! { dg-final { cleanup-modules \"foo\" } }"}, {"sha": "fbe4b8e2af15dbbe5edcefaf5aaac6b93b0119aa", "filename": "gcc/testsuite/gfortran.dg/entry_7.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a492601a1e4a1e5e16a2de9c10065ce062394e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_7.f90?ref=1a492601a1e4a1e5e16a2de9c10065ce062394e4", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! Check that PR20877 and PR25047 are fixed by the patch for\n+! PR24558. Both modules would emit the error:\n+! insert_bbt(): Duplicate key found!\n+! because of the prior references to a module function entry.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE TT\n+CONTAINS\n+  FUNCTION K(I) RESULT(J)\n+    ENTRY J() ! { dg-error \"conflicts with PROCEDURE attribute\" }\n+  END FUNCTION K\n+\n+  integer function foo ()\n+    character*4 bar ! { dg-error \"type CHARACTER\" }\n+    foo = 21\n+    return\n+  entry bar ()\n+    bar = \"abcd\"\n+  end function\n+END MODULE TT\n+\n+\n+! { dg-final { cleanup-modules \"TT\" } }"}]}