{"sha": "b0ad2d78b237380c47f92a8f61e257a1e434a3fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBhZDJkNzhiMjM3MzgwYzQ3ZjkyYThmNjFlMjU3YTFlNDM0YTNmZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-07-05T10:32:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-07-05T10:32:43Z"}, "message": "decl.c (gnat_to_gnu_entity): Invoke global_bindings_p last when possible.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Invoke global_bindings_p\n\tlast when possible.  Do not call elaborate_expression_2 on offsets in\n\tlocal record types and avoid useless processing for constant offsets.\n\nFrom-SVN: r238001", "tree": {"sha": "c3d49018b89d5d29b8ceb1ac06d77899941b73ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d49018b89d5d29b8ceb1ac06d77899941b73ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0ad2d78b237380c47f92a8f61e257a1e434a3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ad2d78b237380c47f92a8f61e257a1e434a3fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ad2d78b237380c47f92a8f61e257a1e434a3fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ad2d78b237380c47f92a8f61e257a1e434a3fe/comments", "author": null, "committer": null, "parents": [{"sha": "f723a43cbcb734e6bb93ef55c36d87a8e03235f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f723a43cbcb734e6bb93ef55c36d87a8e03235f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f723a43cbcb734e6bb93ef55c36d87a8e03235f0"}], "stats": {"total": 41, "additions": 23, "deletions": 18}, "files": [{"sha": "9ddf035e6988ec0d3a6ccb7918c0ce20bdc20840", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ad2d78b237380c47f92a8f61e257a1e434a3fe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ad2d78b237380c47f92a8f61e257a1e434a3fe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b0ad2d78b237380c47f92a8f61e257a1e434a3fe", "patch": "@@ -1,3 +1,9 @@\n+2016-07-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Invoke global_bindings_p\n+\tlast when possible.  Do not call elaborate_expression_2 on offsets in\n+\tlocal record types and avoid useless processing for constant offsets.\n+\n 2016-07-04  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat_rm.texi, gnat_ugn.texi,"}, {"sha": "67ba6121c56bdf5c89d3a5786e5d94fc8bfcab20", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ad2d78b237380c47f92a8f61e257a1e434a3fe/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ad2d78b237380c47f92a8f61e257a1e434a3fe/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b0ad2d78b237380c47f92a8f61e257a1e434a3fe", "patch": "@@ -798,10 +798,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\tmutable_p = true;\n \t      }\n \n-\t    /* If we are at global level and the size isn't constant, call\n+\t    /* If the size isn't constant and we are at global level, call\n \t       elaborate_expression_1 to make a variable for it rather than\n \t       calculating it each time.  */\n-\t    if (global_bindings_p () && !TREE_CONSTANT (gnu_size))\n+\t    if (!TREE_CONSTANT (gnu_size) && global_bindings_p ())\n \t      gnu_size = elaborate_expression_1 (gnu_size, gnat_entity,\n \t\t\t\t\t\t \"SIZE\", definition, false);\n \t  }\n@@ -1366,10 +1366,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   than the largest stack alignment the back-end can honor, resort to\n \t   a variable of \"aligning type\".  */\n \tif (definition\n-\t    && !global_bindings_p ()\n-\t    && !static_flag\n+\t    && TYPE_ALIGN (gnu_type) > BIGGEST_ALIGNMENT\n \t    && !imported_p\n-\t    && TYPE_ALIGN (gnu_type) > BIGGEST_ALIGNMENT)\n+\t    && !static_flag\n+\t    && !global_bindings_p ())\n \t  {\n \t    /* Create the new variable.  No need for extra room before the\n \t       aligned field as this is in automatic storage.  */\n@@ -2679,10 +2679,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  TYPE_STUB_DECL (gnu_type)\n \t    = create_type_stub_decl (gnu_entity_name, gnu_type);\n \n-\t  /* If we are at file level and this is a multi-dimensional array,\n+\t  /* If this is a multi-dimensional array and we are at global level,\n \t     we need to make a variable corresponding to the stride of the\n \t     inner dimensions.   */\n-\t  if (global_bindings_p () && ndim > 1)\n+\t  if (ndim > 1 && global_bindings_p ())\n \t    {\n \t      tree gnu_arr_type;\n \n@@ -4587,10 +4587,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t a constant or self-referential, call elaborate_expression_1 to\n \t make a variable for the size rather than calculating it each time.\n \t Handle both the RM size and the actual size.  */\n-      if (global_bindings_p ()\n-\t  && TYPE_SIZE (gnu_type)\n+      if (TYPE_SIZE (gnu_type)\n \t  && !TREE_CONSTANT (TYPE_SIZE (gnu_type))\n-\t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n+\t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n+\t  && global_bindings_p ())\n \t{\n \t  tree size = TYPE_SIZE (gnu_type);\n \n@@ -4672,11 +4672,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \t}\n \n-      /* If this is a record type or subtype, call elaborate_expression_2 on\n-\t any field position.  Do this for both global and local types.\n-\t Skip any fields that we haven't made trees for to avoid problems with\n-\t class wide types.  */\n-      if (IN (kind, Record_Kind))\n+      /* Similarly, if this is a record type or subtype at global level, call\n+\t elaborate_expression_2 on any field position.  Skip any fields that\n+\t we haven't made trees for to avoid problems with class-wide types.  */\n+      if (IN (kind, Record_Kind) && global_bindings_p ())\n \tfor (gnat_temp = First_Entity (gnat_entity); Present (gnat_temp);\n \t     gnat_temp = Next_Entity (gnat_temp))\n \t  if (Ekind (gnat_temp) == E_Component && present_gnu_tree (gnat_temp))\n@@ -4685,7 +4684,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t      /* ??? For now, store the offset as a multiple of the alignment\n \t\t in bytes so that we can see the alignment from the tree.  */\n-\t      if (!CONTAINS_PLACEHOLDER_P (DECL_FIELD_OFFSET (gnu_field)))\n+\t      if (!TREE_CONSTANT (DECL_FIELD_OFFSET (gnu_field))\n+\t\t  && !CONTAINS_PLACEHOLDER_P (DECL_FIELD_OFFSET (gnu_field)))\n \t\t{\n \t\t  DECL_FIELD_OFFSET (gnu_field)\n \t\t    = elaborate_expression_2 (DECL_FIELD_OFFSET (gnu_field),\n@@ -4696,8 +4696,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  /* ??? The context of gnu_field is not necessarily gnu_type\n \t\t     so the MULT_EXPR node built above may not be marked by\n \t\t     the call to create_type_decl below.  */\n-\t\t  if (global_bindings_p ())\n-\t\t    MARK_VISITED (DECL_FIELD_OFFSET (gnu_field));\n+\t\t  MARK_VISITED (DECL_FIELD_OFFSET (gnu_field));\n \t\t}\n \t    }\n "}]}