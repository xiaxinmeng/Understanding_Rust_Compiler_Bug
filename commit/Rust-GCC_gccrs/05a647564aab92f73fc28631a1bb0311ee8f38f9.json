{"sha": "05a647564aab92f73fc28631a1bb0311ee8f38f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVhNjQ3NTY0YWFiOTJmNzNmYzI4NjMxYTFiYjAzMTFlZThmMzhmOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-09-02T02:14:50Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-09-02T02:14:50Z"}, "message": "PR tree-optimization/71831 - __builtin_object_size poor results with no\n\nPR tree-optimization/71831 - __builtin_object_size poor results with no\n\toptimization\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/71831\n\t* gcc.dg/builtin-object-size-16.c: New test.\n\t* gcc.dg/builtin-object-size-17.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/71831\n\t* tree-object-size.h: Return bool instead of the size and add\n\targument for the size.\n\t* tree-object-size.c (compute_object_offset): Update signature.\n\t(addr_object_size): Same.\n\t(compute_builtin_object_size): Return bool instead of the size\n\tand add argument for the size.  Handle POINTER_PLUS_EXPR when\n\toptimization is disabled.\n\t(expr_object_size): Adjust.\n\t(plus_stmt_object_size): Adjust.\n\t(pass_object_sizes::execute): Adjust.\n\t* builtins.c (fold_builtin_object_size): Adjust.\n\t* doc/extend.texi (Object Size Checking): Update.\n\t* ubsan.c (instrument_object_size): Adjust.\n\nFrom-SVN: r239953", "tree": {"sha": "8330dbb112ec47bbcf763663d1bd7051721bb3a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8330dbb112ec47bbcf763663d1bd7051721bb3a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05a647564aab92f73fc28631a1bb0311ee8f38f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a647564aab92f73fc28631a1bb0311ee8f38f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a647564aab92f73fc28631a1bb0311ee8f38f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a647564aab92f73fc28631a1bb0311ee8f38f9/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "910f2f3d8a3bccb6f65b9a99e6c36f409829f4f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910f2f3d8a3bccb6f65b9a99e6c36f409829f4f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910f2f3d8a3bccb6f65b9a99e6c36f409829f4f8"}], "stats": {"total": 697, "additions": 563, "deletions": 134}, "files": [{"sha": "bda43a58a03395a539fb7425c4e09a32ce7c1dbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -1,3 +1,20 @@\n+2016-09-01 Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/71831\n+\t* tree-object-size.h: Return bool instead of the size and add\n+\targument for the size.\n+\t* tree-object-size.c (compute_object_offset): Update signature.\n+\t(addr_object_size): Same.\n+\t(compute_builtin_object_size): Return bool instead of the size\n+\tand add argument for the size.  Handle POINTER_PLUS_EXPR when\n+\toptimization is disabled.\n+\t(expr_object_size): Adjust.\n+\t(plus_stmt_object_size): Adjust.\n+\t(pass_object_sizes::execute): Adjust.\n+\t* builtins.c (fold_builtin_object_size): Adjust.\n+\t* doc/extend.texi (Object Size Checking): Update.\n+\t* ubsan.c (instrument_object_size): Adjust.\n+\n 2016-09-01 Martin Sebor  <msebor@redhat.com>\n \n \t* genmatch.c (parser::parse_expr): Increase buffer size to guarantee"}, {"sha": "1073e35b17b1bc1f6974c71c940bd9d82bbbfc0f", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -9615,7 +9615,7 @@ fold_builtin_object_size (tree ptr, tree ost)\n \n   if (TREE_CODE (ptr) == ADDR_EXPR)\n     {\n-      bytes = compute_builtin_object_size (ptr, object_size_type);\n+      compute_builtin_object_size (ptr, object_size_type, &bytes);\n       if (wi::fits_to_tree_p (bytes, size_type_node))\n \treturn build_int_cstu (size_type_node, bytes);\n     }\n@@ -9624,9 +9624,8 @@ fold_builtin_object_size (tree ptr, tree ost)\n       /* If object size is not known yet, delay folding until\n        later.  Maybe subsequent passes will help determining\n        it.  */\n-      bytes = compute_builtin_object_size (ptr, object_size_type);\n-      if (bytes != (unsigned HOST_WIDE_INT) (object_size_type < 2 ? -1 : 0)\n-          && wi::fits_to_tree_p (bytes, size_type_node))\n+      if (compute_builtin_object_size (ptr, object_size_type, &bytes)\n+\t  && wi::fits_to_tree_p (bytes, size_type_node))\n \treturn build_int_cstu (size_type_node, bytes);\n     }\n "}, {"sha": "aba3b9056d64f74c7f5bf15d23387b9e582405b3", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -10030,8 +10030,15 @@ __atomic_store_n(&lockvar, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);\n @findex __builtin___fprintf_chk\n @findex __builtin___vfprintf_chk\n \n-GCC implements a limited buffer overflow protection mechanism\n-that can prevent some buffer overflow attacks.\n+GCC implements a limited buffer overflow protection mechanism that can\n+prevent some buffer overflow attacks by determining the sizes of objects\n+into which data is about to be written and preventing the writes when\n+the size isn't sufficient.  The built-in functions described below yield\n+the best results when used together and when optimization is enabled.\n+For example, to detect object sizes across function boundaries or to\n+follow pointer assignments through non-trivial control flow they rely\n+on various optimization passes enabled with @option{-O2}.  However, to\n+a limited extent, they can be used without optimization as well.\n \n @deftypefn {Built-in Function} {size_t} __builtin_object_size (void * @var{ptr}, int @var{type})\n is a built-in construct that returns a constant number of bytes from"}, {"sha": "cda58733fa942bc06aa5716bc29e8f171cebce04", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -1,3 +1,9 @@\n+2016-09-01 Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/71831\n+\t* gcc.dg/builtin-object-size-16.c: New test.\n+\t* gcc.dg/builtin-object-size-17.c: New test.\n+\n 2016-09-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/77393"}, {"sha": "15721e5ce897d5309d6ec6b201fefe5c6b1cf58c", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-16.c", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-16.c?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -0,0 +1,201 @@\n+/* PR 71831 - __builtin_object_size poor results with no optimization\n+   Verify that even without optimization __builtin_object_size returns\n+   a meaningful result for a subset of simple expressins.  In cases\n+   where the result could not easily be made to match the one obtained\n+   with optimization the built-in was made to fail instead.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0\" } */\n+\n+static int nfails;\n+\n+#define TEST_FAILURE(line, obj, type, expect, result)\t\t\\\n+  __builtin_printf (\"FAIL: line %i: __builtin_object_size(\"\t\\\n+\t\t    #obj \", %i) == %zu, got %zu\\n\",\t\t\\\n+\t\t    line, type, expect, result), ++nfails\n+\n+#define bos(obj, type) __builtin_object_size (obj, type)\n+#define size(obj, n) ((size_t)n == X ? sizeof *obj : (size_t)n)\n+\n+#define test(expect, type, obj)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (bos (obj, type)\t!= size (obj, expect))\t\t\t\t\\\n+      TEST_FAILURE (__LINE__, obj, type, size (obj, expect), bos (obj, type)); \\\n+  } while (0)\n+\n+#define T(r0, r1, r2, r3, obj)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    test (r0, 0, obj);\t\t\t\t\\\n+    test (r1, 1, obj);\t\t\t\t\\\n+    test (r2, 2, obj);\t\t\t\t\\\n+    test (r3, 3, obj);\t\t\t\t\\\n+  } while (0)\n+\n+/* For convenience.  Substitute for 'sizeof object' in test cases where\n+   the size can vary from target to target.  */\n+#define X  (size_t)0xdeadbeef\n+\n+/* __builtin_object_size checking results are inconsistent for equivalent\n+   expressions (see bug 71831).  To avoid having duplicate the inconsistency\n+   at -O0 the built-in simply fails.  The results hardcoded in this test\n+   are those obtained with optimization (for easy comparison) but without\n+   optimization the macros below turn them into expected failures .  */\n+#if __OPTIMIZE__\n+#  define F0(n)    n\n+#  define F1(n)    n\n+#  define F2(n)    n\n+#  define F3(n)    n\n+#else\n+#  define F0(n)   -1\n+#  define F1(n)   -1\n+#  define F2(n)    0\n+#  define F3(n)    0\n+#endif\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern char ax[];\n+char ax2[];               /* { dg-warning \"assumed to have one element\" } */\n+\n+extern char a0[0];\n+static char a1[1];\n+static char a2[2];\n+static char a9[9];\n+\n+#if __SIZEOF_SHORT__ == 4\n+extern short ia0[0];\n+static short ia1[1];\n+static short ia9[9];\n+#elif __SIZEOF_INT__ == 4\n+extern int ia0[0];\n+static int ia1[1];\n+static int ia9[9];\n+#endif\n+\n+static char a2x2[2][2];\n+static char a3x5[3][5];\n+\n+struct Sx { char n, a[]; } sx;\n+struct S0 { char n, a[0]; } s0;\n+struct S1 { char n, a[1]; } s1;\n+struct S2 { char n, a[2]; } s2;\n+struct S9 { char n, a[9]; } s9;\n+\n+struct S2x2 { char n, a[2][2]; } s2x2;\n+struct S3x5 { char n, a[3][5]; } s3x5;\n+\n+static __attribute__ ((noclone, noinline)) void\n+test_arrays ()\n+{\n+  T (    -1,      -1,       0,       0,   ax);\n+\n+  T (     0,       0,       0,       0,   a0);\n+  T (     1,       1,       1,       1,   ax2);\n+\n+  T (     1,       1,       1,       1,   a1);\n+  T (     2,       2,       2,       2,   a2);\n+  T (     9,       9,       9,       9,   a9);\n+\n+  T (     0,       0,       0,       0,   a0);\n+  T (     1,       1,       1,       1,   ax2);\n+\n+  T (     0,       0,       0,       0,   ia0);\n+  T (     4,       4,       4,       4,   ia1);\n+  T (    36,      36,      36,      36,   ia9);\n+\n+  /* Not all results for multidimensional arrays make sense (see\n+     bug 77293).  The expected results below simply reflect those\n+     obtained at -O2 (modulo the known limitations at -O1).  */\n+  T (     4,       4,       4,       4,   a2x2);\n+  T (     4,       4,       4,       4,   &a2x2[0]);\n+  T (     4,       2,       4,       2,   &a2x2[0][0]);\n+  T (     0,  F1  (0),      0,       0,   &a2x2 + 1);\n+  T (     2,  F1 ( 2),      2,  F3 ( 2),  &a2x2[0] + 1);\n+  T (     3,  F1 ( 1),      3,  F3 ( 3),  &a2x2[0][0] + 1);\n+\n+  T (    15,      15,      15,      15,   a3x5);\n+  T (    15,       5,      15,       5,   &a3x5[0][0] + 0);\n+  T (    14,  F1 ( 4),     14,  F3 (14),  &a3x5[0][0] + 1);\n+\n+  T (     1,       1,       1,       1,   a1 + 0);\n+  T (     0,  F1  (0),      0,       0,   a1 + 1);\n+  T (     0,  F1 ( 0),      0,       0,   &a1 + 1);\n+  /* In the following the offset is out of bounds which makes\n+     the expression undefined.  Still, verify that the returned\n+     size is zero (and not some large number).  */\n+  T (     0,  F1  (0),      0,       0,   a1 + 2);\n+\n+  T (     2,       2,       2,       2,   a2 + 0);\n+  T (     1,  F1 ( 1),      1, F3 ( 1),   a2 + 1);\n+  T (     0,  F1 ( 0),      0,       0,   a2 + 2);\n+}\n+\n+static __attribute__ ((noclone, noinline)) void\n+test_structs (struct Sx *psx, struct S0 *ps0, struct S1 *ps1, struct S9 *ps9)\n+{\n+  /* The expected size of a declared object with a flexible array member\n+     is sizeof sx in all __builtin_object_size types.  */\n+  T (     X,       X,       X,       X,   &sx);\n+\n+  /* The expected size of an unknown object with a flexible array member\n+     is unknown in all __builtin_object_size types.  */\n+  T (    -1,      -1,       0,       0,   psx);\n+\n+  /* The expected size of a flexible array member of a declared object\n+     is zero.  */\n+  T (     0,       0,       0,       0,   sx.a);\n+\n+  /* The expected size of a flexible array member of an unknown object\n+     is unknown.  */\n+  T (    -1,      -1,       0,       0,   psx->a);\n+\n+  /* The expected size of a declared object with a zero-length array member\n+     is sizeof sx in all __builtin_object_size types.  */\n+  T (     X,       X,       X,       X,   &s0);\n+\n+  /* The expected size of an unknown object with a zero-length array member\n+     is unknown in all __builtin_object_size types.  */\n+  T (    -1,      -1,       0,       0,   ps0);\n+\n+  /* The expected size of a zero-length array member of a declared object\n+     is zero.  */\n+  T (     0,       0,       0,       0,   s0.a);\n+\n+  /* The expected size of a zero-length array member of an unknown object\n+     is unknown.  */\n+  T (    -1,      -1,       0,       0,   ps0->a);\n+\n+  T (     X,       X,       X,       X,   &s1);\n+  T (     1,       1,       1,       1,   s1.a);\n+  T (     0,  F1 (0),       0,       0,   s1.a + 1);\n+\n+  /* GCC treats arrays of all sizes that are the last member of a struct\n+     as flexible array members.  */\n+  T (    -1,      -1,       0,       0,   ps1);\n+  T (    -1,      -1,       0,       0,   ps1->a);\n+  T (    -1,      -1,       0,       0,   ps1->a + 1);\n+\n+  T (     X,       X,       X,       X,   &s9);\n+  T (     9,       9,       9,       9,   s9.a);\n+  T (     9,       9,       9,       9,   s9.a + 0);\n+  T (     8,  F1 ( 8),      8, F3 (  8),  s9.a + 1);\n+  T (     7,  F1 ( 7),      7, F3 (  7),  s9.a + 2);\n+  T (     0,  F1 ( 0),      0, F3 (  0),  s9.a + 9);\n+\n+  /* The following make little sense but see bug 77301.  */\n+  T (    -1,      -1,       0,       0,   ps9);\n+  T (    -1,      -1,       0,       0,   ps9->a);\n+  T (    -1,      -1,       0,       0,   ps9->a + 1);\n+}\n+\n+int\n+main()\n+{\n+  test_arrays ();\n+\n+  test_structs (&sx, &s0, &s1, &s9);\n+\n+  if (nfails)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "03664d5d9a5dd4f2c38471e0ce30ec3bcf6a8073", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-17.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-17.c?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -0,0 +1,158 @@\n+/* PR 71831 - __builtin_object_size poor results with no optimization\n+   Verify that even without optimization __builtin_object_size result\n+   is folded into a constant and dead code that depends on it is\n+   eliminated.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -fdump-tree-ssa\" } */\n+\n+#define concat(a, b)   a ## b\n+#define CAT(a, b)      concat (a, b)\n+\n+/* Create a symbol name unique to each tes and object size type.  */\n+#define SYM(type)      CAT (CAT (CAT (failure_on_line_, __LINE__), _type_), type)\n+\n+/* References to the following undefined symbol which is unique for each\n+   test case are expected to be eliminated.  */\n+#define TEST_FAILURE(type)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern void SYM (type)(void);\t\t\\\n+    SYM (type)();\t\t\t\t\\\n+  } while (0)\n+\n+#define bos(obj, type) __builtin_object_size (obj, type)\n+#define size(obj, n) ((size_t)n == X ? sizeof *obj : (size_t)n)\n+\n+#define test(expect, type, obj)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (bos (obj, type)\t!= size (obj, expect))\t\\\n+      TEST_FAILURE (type);\t\t\t\\\n+  } while (0)\n+\n+#define FOLD_ALL(r0, r1, r2, r3, obj)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    test (r0, 0, obj);\t\t\t\t\\\n+    test (r1, 1, obj);\t\t\t\t\\\n+    test (r2, 2, obj);\t\t\t\t\\\n+    test (r3, 3, obj);\t\t\t\t\\\n+  } while (0)\n+\n+#define FOLD_0_2(r0, r1, r2, r3, obj)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    test (r0, 0, obj);\t\t\t\t\\\n+    test (r2, 2, obj);\t\t\t\t\\\n+  } while (0)\n+\n+/* For convenience.  Substitute for 'sizeof object' in test cases where\n+   the size can vary from target to target.  */\n+#define X  (size_t)0xdeadbeef\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern char ax[];\n+char ax2[];               /* { dg-warning \"assumed to have one element\" } */\n+\n+extern char a0[0];\n+static char a1[1];\n+static char a2[2];\n+static char a9[9];\n+\n+#if __SIZEOF_SHORT__ == 4\n+extern short ia0[0];\n+static short ia1[1];\n+static short ia9[9];\n+#elif __SIZEOF_INT__ == 4\n+extern int ia0[0];\n+static int ia1[1];\n+static int ia9[9];\n+#endif\n+\n+static char a2x2[2][2];\n+static char a3x5[3][5];\n+\n+struct Sx { char n, a[]; } sx;\n+struct S0 { char n, a[0]; } s0;\n+struct S1 { char n, a[1]; } s1;\n+struct S2 { char n, a[2]; } s2;\n+struct S9 { char n, a[9]; } s9;\n+\n+struct S2x2 { char n, a[2][2]; } s2x2;\n+struct S3x5 { char n, a[3][5]; } s3x5;\n+\n+static __attribute__ ((noclone, noinline)) void\n+test_arrays ()\n+{\n+  FOLD_ALL (     1,       1,       1,       1,   ax2);\n+\n+  FOLD_ALL (     1,       1,       1,       1,   a1);\n+  FOLD_ALL (     2,       2,       2,       2,   a2);\n+  FOLD_ALL (     9,       9,       9,       9,   a9);\n+\n+  FOLD_ALL (     0,       0,       0,       0,   a0);\n+  FOLD_ALL (     1,       1,       1,       1,   ax2);\n+\n+  FOLD_ALL (     0,       0,       0,       0,   ia0);\n+  FOLD_ALL (     4,       4,       4,       4,   ia1);\n+  FOLD_ALL (    36,      36,      36,      36,   ia9);\n+\n+  /* Not all results for multidimensional arrays make sense (see\n+     bug 77293).  The expected results below simply reflect those\n+     obtained at -O2 (modulo the known limitations at -O1).  */\n+  FOLD_ALL (     4,       4,       4,       4,   a2x2);\n+  FOLD_ALL (     4,       4,       4,       4,   &a2x2[0]);\n+  FOLD_ALL (     4,       2,       4,       2,   &a2x2[0][0]);\n+  FOLD_0_2 (     0,  F1  (0),      0,       0,   &a2x2 + 1);\n+  FOLD_0_2 (     2,  F1 ( 2),      2,  F3 ( 2),  &a2x2[0] + 1);\n+  FOLD_0_2 (     3,  F1 ( 1),      3,  F3 ( 3),  &a2x2[0][0] + 1);\n+\n+  FOLD_ALL (    15,      15,      15,      15,   a3x5);\n+  FOLD_ALL (    15,       5,      15,       5,   &a3x5[0][0] + 0);\n+  FOLD_0_2 (    14,  F1 ( 4),     14,  F3 (14),  &a3x5[0][0] + 1);\n+\n+  FOLD_ALL (     1,       1,       1,       1,   a1 + 0);\n+  FOLD_0_2 (     0,  F1 ( 0),      0,       0,   &a1 + 1);\n+  FOLD_ALL (     2,       2,       2,       2,   a2 + 0);\n+  FOLD_0_2 (     1,  F1 ( 1),      1, F3 ( 1),   a2 + 1);\n+  FOLD_0_2 (     0,  F1 ( 0),      0,       0,   a2 + 2);\n+}\n+\n+static __attribute__ ((noclone, noinline)) void\n+test_structs (void)\n+{\n+  /* The expected size of a declared object with a flexible array member\n+     is sizeof sx in all __builtin_object_size types.  */\n+  FOLD_ALL (     X,       X,       X,       X,   &sx);\n+\n+  /* The expected size of a flexible array member of a declared object\n+     is zero.  */\n+  FOLD_ALL (     0,       0,       0,       0,   sx.a);\n+\n+  /* The expected size of a declared object with a zero-length array member\n+     is sizeof sx in all __builtin_object_size types.  */\n+  FOLD_ALL (     X,       X,       X,       X,   &s0);\n+\n+  /* The expected size of a zero-length array member of a declared object\n+     is zero.  */\n+  FOLD_ALL (     0,       0,       0,       0,   s0.a);\n+\n+  FOLD_ALL (     X,       X,       X,       X,   &s1);\n+  FOLD_ALL (     1,       1,       1,       1,   s1.a);\n+  FOLD_0_2 (     0,  F1 (0),       0,       0,   s1.a + 1);\n+\n+  FOLD_ALL (     X,       X,       X,       X,   &s9);\n+  FOLD_ALL (     9,       9,       9,       9,   s9.a);\n+  FOLD_ALL (     9,       9,       9,       9,   s9.a + 0);\n+  FOLD_0_2 (     8,  F1 ( 8),      8, F3 (  8),  s9.a + 1);\n+  FOLD_0_2 (     7,  F1 ( 7),      7, F3 (  7),  s9.a + 2);\n+  FOLD_0_2 (     0,  F1 ( 0),      0, F3 (  0),  s9.a + 9);\n+}\n+\n+int\n+main()\n+{\n+  test_arrays ();\n+  test_structs ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"failure_on_line\" \"ssa\" } } */"}, {"sha": "1317ad7ee9a768d296042806ae7afb37fccd2635", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 166, "deletions": 125, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -51,8 +51,8 @@ static const unsigned HOST_WIDE_INT unknown[4] = {\n };\n \n static tree compute_object_offset (const_tree, const_tree);\n-static unsigned HOST_WIDE_INT addr_object_size (struct object_size_info *,\n-\t\t\t\t\t\tconst_tree, int);\n+static bool addr_object_size (struct object_size_info *,\n+\t\t\t      const_tree, int, unsigned HOST_WIDE_INT *);\n static unsigned HOST_WIDE_INT alloc_object_size (const gcall *, int);\n static tree pass_through_call (const gcall *);\n static void collect_object_sizes_for (struct object_size_info *, tree);\n@@ -163,14 +163,18 @@ compute_object_offset (const_tree expr, const_tree var)\n    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n    If unknown, return unknown[object_size_type].  */\n \n-static unsigned HOST_WIDE_INT\n+static bool\n addr_object_size (struct object_size_info *osi, const_tree ptr,\n-\t\t  int object_size_type)\n+\t\t  int object_size_type, unsigned HOST_WIDE_INT *psize)\n {\n   tree pt_var, pt_var_size = NULL_TREE, var_size, bytes;\n \n   gcc_assert (TREE_CODE (ptr) == ADDR_EXPR);\n \n+  /* Set to unknown and overwrite just before returning if the size\n+     could be determined.  */\n+  *psize = unknown[object_size_type];\n+\n   pt_var = TREE_OPERAND (ptr, 0);\n   while (handled_component_p (pt_var))\n     pt_var = TREE_OPERAND (pt_var, 0);\n@@ -183,8 +187,8 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n       if (!osi || (object_size_type & 1) != 0\n \t  || TREE_CODE (TREE_OPERAND (pt_var, 0)) != SSA_NAME)\n \t{\n-\t  sz = compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n-\t\t\t\t\t    object_size_type & ~1);\n+\t  compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n+\t\t\t\t       object_size_type & ~1, &sz);\n \t}\n       else\n \t{\n@@ -224,7 +228,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t      < offset_limit)\n     pt_var_size = TYPE_SIZE_UNIT (TREE_TYPE (pt_var));\n   else\n-    return unknown[object_size_type];\n+    return false;\n \n   if (pt_var != TREE_OPERAND (ptr, 0))\n     {\n@@ -339,7 +343,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n       if (var != pt_var)\n \tvar_size = TYPE_SIZE_UNIT (TREE_TYPE (var));\n       else if (!pt_var_size)\n-\treturn unknown[object_size_type];\n+\treturn false;\n       else\n \tvar_size = pt_var_size;\n       bytes = compute_object_offset (TREE_OPERAND (ptr, 0), var);\n@@ -369,14 +373,17 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t}\n     }\n   else if (!pt_var_size)\n-    return unknown[object_size_type];\n+    return false;\n   else\n     bytes = pt_var_size;\n \n   if (tree_fits_uhwi_p (bytes))\n-    return tree_to_uhwi (bytes);\n+    {\n+      *psize = tree_to_uhwi (bytes);\n+      return true;\n+    }\n \n-  return unknown[object_size_type];\n+  return false;\n }\n \n \n@@ -484,142 +491,177 @@ pass_through_call (const gcall *call)\n }\n \n \n-/* Compute __builtin_object_size value for PTR.  OBJECT_SIZE_TYPE is the\n-   second argument from __builtin_object_size.  */\n+/* Compute __builtin_object_size value for PTR and set *PSIZE to\n+   the resulting value.  OBJECT_SIZE_TYPE is the second argument\n+   to __builtin_object_size.  Return true on success and false\n+   when the object size could not be determined.  */\n \n-unsigned HOST_WIDE_INT\n-compute_builtin_object_size (tree ptr, int object_size_type)\n+bool\n+compute_builtin_object_size (tree ptr, int object_size_type,\n+\t\t\t     unsigned HOST_WIDE_INT *psize)\n {\n   gcc_assert (object_size_type >= 0 && object_size_type <= 3);\n \n+  /* Set to unknown and overwrite just before returning if the size\n+     could be determined.  */\n+  *psize = unknown[object_size_type];\n+\n   if (! offset_limit)\n     init_offset_limit ();\n \n   if (TREE_CODE (ptr) == ADDR_EXPR)\n-    return addr_object_size (NULL, ptr, object_size_type);\n+    return addr_object_size (NULL, ptr, object_size_type, psize);\n+\n+  if (TREE_CODE (ptr) != SSA_NAME\n+      || !POINTER_TYPE_P (TREE_TYPE (ptr)))\n+      return false;\n \n-  if (TREE_CODE (ptr) == SSA_NAME\n-      && POINTER_TYPE_P (TREE_TYPE (ptr))\n-      && computed[object_size_type] != NULL)\n+  if (computed[object_size_type] == NULL)\n     {\n-      if (!bitmap_bit_p (computed[object_size_type], SSA_NAME_VERSION (ptr)))\n+      if (optimize || object_size_type & 1)\n+\treturn false;\n+\n+      /* When not optimizing, rather than failing, make a small effort\n+\t to determine the object size without the full benefit of\n+\t the (costly) computation below.  */\n+      gimple *def = SSA_NAME_DEF_STMT (ptr);\n+      if (gimple_code (def) == GIMPLE_ASSIGN)\n \t{\n-\t  struct object_size_info osi;\n-\t  bitmap_iterator bi;\n-\t  unsigned int i;\n-\n-\t  if (num_ssa_names > object_sizes[object_size_type].length ())\n-\t    object_sizes[object_size_type].safe_grow (num_ssa_names);\n-\t  if (dump_file)\n+\t  tree_code code = gimple_assign_rhs_code (def);\n+\t  if (code == POINTER_PLUS_EXPR)\n \t    {\n-\t      fprintf (dump_file, \"Computing %s %sobject size for \",\n-\t\t       (object_size_type & 2) ? \"minimum\" : \"maximum\",\n-\t\t       (object_size_type & 1) ? \"sub\" : \"\");\n-\t      print_generic_expr (dump_file, ptr, dump_flags);\n-\t      fprintf (dump_file, \":\\n\");\n-\t    }\n+\t      tree offset = gimple_assign_rhs2 (def);\n+\t      ptr = gimple_assign_rhs1 (def);\n \n-\t  osi.visited = BITMAP_ALLOC (NULL);\n-\t  osi.reexamine = BITMAP_ALLOC (NULL);\n-\t  osi.object_size_type = object_size_type;\n-\t  osi.depths = NULL;\n-\t  osi.stack = NULL;\n-\t  osi.tos = NULL;\n-\n-\t  /* First pass: walk UD chains, compute object sizes that\n-\t     can be computed.  osi.reexamine bitmap at the end will\n-\t     contain what variables were found in dependency cycles\n-\t     and therefore need to be reexamined.  */\n-\t  osi.pass = 0;\n-\t  osi.changed = false;\n-\t  collect_object_sizes_for (&osi, ptr);\n-\n-\t  /* Second pass: keep recomputing object sizes of variables\n-\t     that need reexamination, until no object sizes are\n-\t     increased or all object sizes are computed.  */\n-\t  if (! bitmap_empty_p (osi.reexamine))\n-\t    {\n-\t      bitmap reexamine = BITMAP_ALLOC (NULL);\n-\n-\t      /* If looking for minimum instead of maximum object size,\n-\t\t detect cases where a pointer is increased in a loop.\n-\t\t Although even without this detection pass 2 would eventually\n-\t\t terminate, it could take a long time.  If a pointer is\n-\t\t increasing this way, we need to assume 0 object size.\n-\t\t E.g. p = &buf[0]; while (cond) p = p + 4;  */\n-\t      if (object_size_type & 2)\n+\t      if (cst_and_fits_in_hwi (offset)\n+\t\t  && compute_builtin_object_size (ptr, object_size_type, psize))\n \t\t{\n-\t\t  osi.depths = XCNEWVEC (unsigned int, num_ssa_names);\n-\t\t  osi.stack = XNEWVEC (unsigned int, num_ssa_names);\n-\t\t  osi.tos = osi.stack;\n-\t\t  osi.pass = 1;\n-\t\t  /* collect_object_sizes_for is changing\n-\t\t     osi.reexamine bitmap, so iterate over a copy.  */\n-\t\t  bitmap_copy (reexamine, osi.reexamine);\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n-\t\t    if (bitmap_bit_p (osi.reexamine, i))\n-\t\t      check_for_plus_in_loops (&osi, ssa_name (i));\n-\n-\t\t  free (osi.depths);\n-\t\t  osi.depths = NULL;\n-\t\t  free (osi.stack);\n-\t\t  osi.stack = NULL;\n-\t\t  osi.tos = NULL;\n+\t\t  /* Return zero when the offset is out of bounds.  */\n+\t\t  unsigned HOST_WIDE_INT off = tree_to_shwi (offset);\n+\t\t  *psize = off < *psize ? *psize - off : 0;\n+\t\t  return true;\n \t\t}\n+\t    }\n+\t}\n+      return false;\n+    }\n \n-\t      do\n-\t\t{\n-\t\t  osi.pass = 2;\n-\t\t  osi.changed = false;\n-\t\t  /* collect_object_sizes_for is changing\n-\t\t     osi.reexamine bitmap, so iterate over a copy.  */\n-\t\t  bitmap_copy (reexamine, osi.reexamine);\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n-\t\t    if (bitmap_bit_p (osi.reexamine, i))\n-\t\t      {\n-\t\t\tcollect_object_sizes_for (&osi, ssa_name (i));\n-\t\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t  {\n-\t\t\t    fprintf (dump_file, \"Reexamining \");\n-\t\t\t    print_generic_expr (dump_file, ssa_name (i),\n-\t\t\t\t\t\tdump_flags);\n-\t\t\t    fprintf (dump_file, \"\\n\");\n-\t\t\t  }\n-\t\t      }\n-\t\t}\n-\t      while (osi.changed);\n+  if (!bitmap_bit_p (computed[object_size_type], SSA_NAME_VERSION (ptr)))\n+    {\n+      struct object_size_info osi;\n+      bitmap_iterator bi;\n+      unsigned int i;\n+\n+      if (num_ssa_names > object_sizes[object_size_type].length ())\n+\tobject_sizes[object_size_type].safe_grow (num_ssa_names);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Computing %s %sobject size for \",\n+\t\t   (object_size_type & 2) ? \"minimum\" : \"maximum\",\n+\t\t   (object_size_type & 1) ? \"sub\" : \"\");\n+\t  print_generic_expr (dump_file, ptr, dump_flags);\n+\t  fprintf (dump_file, \":\\n\");\n+\t}\n \n-\t      BITMAP_FREE (reexamine);\n+      osi.visited = BITMAP_ALLOC (NULL);\n+      osi.reexamine = BITMAP_ALLOC (NULL);\n+      osi.object_size_type = object_size_type;\n+      osi.depths = NULL;\n+      osi.stack = NULL;\n+      osi.tos = NULL;\n+\n+      /* First pass: walk UD chains, compute object sizes that\n+\t can be computed.  osi.reexamine bitmap at the end will\n+\t contain what variables were found in dependency cycles\n+\t and therefore need to be reexamined.  */\n+      osi.pass = 0;\n+      osi.changed = false;\n+      collect_object_sizes_for (&osi, ptr);\n+\n+      /* Second pass: keep recomputing object sizes of variables\n+\t that need reexamination, until no object sizes are\n+\t increased or all object sizes are computed.  */\n+      if (! bitmap_empty_p (osi.reexamine))\n+\t{\n+\t  bitmap reexamine = BITMAP_ALLOC (NULL);\n+\n+\t  /* If looking for minimum instead of maximum object size,\n+\t     detect cases where a pointer is increased in a loop.\n+\t     Although even without this detection pass 2 would eventually\n+\t     terminate, it could take a long time.  If a pointer is\n+\t     increasing this way, we need to assume 0 object size.\n+\t     E.g. p = &buf[0]; while (cond) p = p + 4;  */\n+\t  if (object_size_type & 2)\n+\t    {\n+\t      osi.depths = XCNEWVEC (unsigned int, num_ssa_names);\n+\t      osi.stack = XNEWVEC (unsigned int, num_ssa_names);\n+\t      osi.tos = osi.stack;\n+\t      osi.pass = 1;\n+\t      /* collect_object_sizes_for is changing\n+\t\t osi.reexamine bitmap, so iterate over a copy.  */\n+\t      bitmap_copy (reexamine, osi.reexamine);\n+\t      EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n+\t\tif (bitmap_bit_p (osi.reexamine, i))\n+\t\t  check_for_plus_in_loops (&osi, ssa_name (i));\n+\n+\t      free (osi.depths);\n+\t      osi.depths = NULL;\n+\t      free (osi.stack);\n+\t      osi.stack = NULL;\n+\t      osi.tos = NULL;\n \t    }\n-\t  EXECUTE_IF_SET_IN_BITMAP (osi.reexamine, 0, i, bi)\n-\t    bitmap_set_bit (computed[object_size_type], i);\n \n-\t  /* Debugging dumps.  */\n-\t  if (dump_file)\n+\t  do\n \t    {\n-\t      EXECUTE_IF_SET_IN_BITMAP (osi.visited, 0, i, bi)\n-\t\tif (object_sizes[object_size_type][i]\n-\t\t    != unknown[object_size_type])\n+\t      osi.pass = 2;\n+\t      osi.changed = false;\n+\t      /* collect_object_sizes_for is changing\n+\t\t osi.reexamine bitmap, so iterate over a copy.  */\n+\t      bitmap_copy (reexamine, osi.reexamine);\n+\t      EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n+\t\tif (bitmap_bit_p (osi.reexamine, i))\n \t\t  {\n-\t\t    print_generic_expr (dump_file, ssa_name (i),\n-\t\t\t\t\tdump_flags);\n-\t\t    fprintf (dump_file,\n-\t\t\t     \": %s %sobject size \"\n-\t\t\t     HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n-\t\t\t     (object_size_type & 2) ? \"minimum\" : \"maximum\",\n-\t\t\t     (object_size_type & 1) ? \"sub\" : \"\",\n-\t\t\t     object_sizes[object_size_type][i]);\n+\t\t    collect_object_sizes_for (&osi, ssa_name (i));\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      {\n+\t\t\tfprintf (dump_file, \"Reexamining \");\n+\t\t\tprint_generic_expr (dump_file, ssa_name (i),\n+\t\t\t\t\t    dump_flags);\n+\t\t\tfprintf (dump_file, \"\\n\");\n+\t\t      }\n \t\t  }\n \t    }\n+\t  while (osi.changed);\n \n-\t  BITMAP_FREE (osi.reexamine);\n-\t  BITMAP_FREE (osi.visited);\n+\t  BITMAP_FREE (reexamine);\n \t}\n+      EXECUTE_IF_SET_IN_BITMAP (osi.reexamine, 0, i, bi)\n+\tbitmap_set_bit (computed[object_size_type], i);\n \n-      return object_sizes[object_size_type][SSA_NAME_VERSION (ptr)];\n+      /* Debugging dumps.  */\n+      if (dump_file)\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (osi.visited, 0, i, bi)\n+\t    if (object_sizes[object_size_type][i]\n+\t\t!= unknown[object_size_type])\n+\t      {\n+\t\tprint_generic_expr (dump_file, ssa_name (i),\n+\t\t\t\t    dump_flags);\n+\t\tfprintf (dump_file,\n+\t\t\t \": %s %sobject size \"\n+\t\t\t HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n+\t\t\t (object_size_type & 2) ? \"minimum\" : \"maximum\",\n+\t\t\t (object_size_type & 1) ? \"sub\" : \"\",\n+\t\t\t object_sizes[object_size_type][i]);\n+\t      }\n+\t}\n+\n+      BITMAP_FREE (osi.reexamine);\n+      BITMAP_FREE (osi.visited);\n     }\n \n-  return unknown[object_size_type];\n+  *psize = object_sizes[object_size_type][SSA_NAME_VERSION (ptr)];\n+  return *psize != unknown[object_size_type];\n }\n \n /* Compute object_sizes for PTR, defined to VALUE, which is not an SSA_NAME.  */\n@@ -643,7 +685,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n \t      || !POINTER_TYPE_P (TREE_TYPE (value)));\n \n   if (TREE_CODE (value) == ADDR_EXPR)\n-    bytes = addr_object_size (osi, value, object_size_type);\n+    addr_object_size (osi, value, object_size_type, &bytes);\n   else\n     bytes = unknown[object_size_type];\n \n@@ -809,7 +851,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n \t  unsigned HOST_WIDE_INT off = tree_to_uhwi (op1);\n \n           /* op0 will be ADDR_EXPR here.  */\n-\t  bytes = addr_object_size (osi, op0, object_size_type);\n+\t  addr_object_size (osi, op0, object_size_type, &bytes);\n \t  if (bytes == unknown[object_size_type])\n \t    ;\n \t  else if (off > offset_limit)\n@@ -1282,10 +1324,9 @@ pass_object_sizes::execute (function *fun)\n \t\t      && lhs)\n \t\t    {\n \t\t      tree type = TREE_TYPE (lhs);\n-\t\t      unsigned HOST_WIDE_INT bytes\n-\t\t\t= compute_builtin_object_size (ptr, object_size_type);\n-\t\t      if (bytes != (unsigned HOST_WIDE_INT) (object_size_type == 1\n-\t\t\t\t\t\t\t     ? -1 : 0)\n+\t\t      unsigned HOST_WIDE_INT bytes;\n+\t\t      if (compute_builtin_object_size (ptr, object_size_type,\n+\t\t\t\t\t\t       &bytes)\n \t\t\t  && wi::fits_to_tree_p (bytes, type))\n \t\t\t{\n \t\t\t  tree tem = make_ssa_name (type);"}, {"sha": "38c3e07332761197cc3c7dff5fb48cec04e82696", "filename": "gcc/tree-object-size.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftree-object-size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Ftree-object-size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.h?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -21,6 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_OBJECT_SIZE_H\n \n extern void init_object_sizes (void);\n-extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n+extern bool compute_builtin_object_size (tree, int, unsigned HOST_WIDE_INT *);\n \n #endif  // GCC_TREE_OBJECT_SIZE_H"}, {"sha": "5cbc98dbabb296afc13b0b8c0286c07f78f6280f", "filename": "gcc/ubsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a647564aab92f73fc28631a1bb0311ee8f38f9/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=05a647564aab92f73fc28631a1bb0311ee8f38f9", "patch": "@@ -1826,8 +1826,8 @@ instrument_object_size (gimple_stmt_iterator *gsi, bool is_lhs)\n   if (decl_p)\n     base_addr = build1 (ADDR_EXPR,\n \t\t\tbuild_pointer_type (TREE_TYPE (base)), base);\n-  unsigned HOST_WIDE_INT size = compute_builtin_object_size (base_addr, 0);\n-  if (size != HOST_WIDE_INT_M1U)\n+  unsigned HOST_WIDE_INT size;\n+  if (compute_builtin_object_size (base_addr, 0, &size))\n     sizet = build_int_cst (sizetype, size);\n   else if (optimize)\n     {"}]}