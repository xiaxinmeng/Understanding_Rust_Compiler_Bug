{"sha": "c8427bff140cfe0c3a749a32ee531314f19e178a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg0MjdiZmYxNDBjZmUwYzNhNzQ5YTMyZWU1MzEzMTRmMTllMTc4YQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-03-15T16:10:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T16:10:45Z"}, "message": "Make-lang.in: Add g-utf_32 unit for gnat and gnatbind\n\n2005-03-08  Robert Dewar  <dewar@adacore.com>\n\n\t* Make-lang.in: Add g-utf_32 unit for gnat and gnatbind\n\n\t* impunit.adb: Add GNAT.UTF_32\n\n\t* scng.adb: Use gnat.utf_32 instead of widechar for utf_32 stuff\n\n\t* widechar.ads, widechar.adb: Remove redundant UTF-32 tables (scng\n\tnow uses GNAT.UTF_32).\n\n\t* g-utf_32.ads, g-utf_32.adb: This is a new unit with full\n\tcapabilities for categorizing characters using Unicode categories\n\nFrom-SVN: r96501", "tree": {"sha": "4f5eb72a81692323ac08f26f3c009091d857d189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f5eb72a81692323ac08f26f3c009091d857d189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8427bff140cfe0c3a749a32ee531314f19e178a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8427bff140cfe0c3a749a32ee531314f19e178a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8427bff140cfe0c3a749a32ee531314f19e178a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8427bff140cfe0c3a749a32ee531314f19e178a/comments", "author": null, "committer": null, "parents": [{"sha": "73f0204748dd2267f80150edd8cf9fcdf768b571", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73f0204748dd2267f80150edd8cf9fcdf768b571", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73f0204748dd2267f80150edd8cf9fcdf768b571"}], "stats": {"total": 5510, "additions": 3798, "deletions": 1712}, "files": [{"sha": "36ea71882dd1057027589cc09565c93e3bd59fb2", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=c8427bff140cfe0c3a749a32ee531314f19e178a", "patch": "@@ -123,7 +123,8 @@ GNAT_ADA_OBJS = ada/ada.o ada/a-charac.o ada/a-chlat1.o ada/a-except.o \\\n  ada/exp_prag.o ada/exp_smem.o ada/exp_strm.o ada/exp_tss.o ada/exp_util.o \\\n  ada/exp_vfpt.o ada/expander.o ada/fname.o ada/fname-uf.o ada/fmap.o \\\n  ada/freeze.o ada/frontend.o ada/gnat.o ada/g-hesora.o ada/g-htable.o \\\n- ada/g-os_lib.o ada/g-speche.o ada/g-string.o ada/s-crc32.o ada/get_targ.o \\\n+ ada/g-os_lib.o ada/g-speche.o ada/g-string.o ada/g-utf_32.o \\\n+ ada/s-crc32.o ada/get_targ.o \\\n  ada/gnatvsn.o ada/hlo.o ada/hostparm.o ada/impunit.o ada/interfac.o \\\n  ada/itypes.o ada/inline.o ada/krunch.o ada/lib.o ada/layout.o ada/lib-load.o \\\n  ada/lib-util.o ada/lib-xref.o ada/lib-writ.o ada/live.o ada/namet.o \\\n@@ -192,6 +193,7 @@ GNATBIND_OBJS = \\\n  ada/g-htable.o   \\\n  ada/g-os_lib.o   \\\n  ada/g-string.o   \\\n+ ada/g-utf_32.o   \\\n  ada/gnat.o       \\\n  ada/gnatbind.o   \\\n  ada/gnatvsn.o    \\\n@@ -2132,6 +2134,8 @@ ada/g-speche.o : ada/gnat.ads ada/g-speche.ads ada/g-speche.adb \\\n ada/g-string.o : ada/gnat.ads ada/g-string.ads ada/g-string.adb \\\n    ada/system.ads ada/unchdeal.ads \n \n+ada/g-utf_32.o : ada/gnat.ads ada/g-utf_32.ads ada/g-utf_32.adb\n+\n ada/get_targ.o : ada/get_targ.ads ada/get_targ.adb ada/system.ads \\\n    ada/s-exctab.ads ada/s-stalib.ads ada/s-unstyp.ads ada/types.ads \\\n    ada/unchconv.ads ada/unchdeal.ads "}, {"sha": "277a7c2c471ccff7c3784c5b3f65289d8d7c4e46", "filename": "gcc/ada/g-utf_32.adb", "status": "modified", "additions": 3671, "deletions": 2, "changes": 3673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fg-utf_32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fg-utf_32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-utf_32.adb?ref=c8427bff140cfe0c3a749a32ee531314f19e178a"}, {"sha": "e236d5ea17b0181f8a0139d15b1ecfb3410d261f", "filename": "gcc/ada/g-utf_32.ads", "status": "modified", "additions": 90, "deletions": 27, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fg-utf_32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fg-utf_32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-utf_32.ads?ref=c8427bff140cfe0c3a749a32ee531314f19e178a", "patch": "@@ -44,66 +44,119 @@\n \n package GNAT.UTF_32 is\n \n-   type UTF_32 is mod 2 ** 32;\n-   --  The actual allowed range is 16#00_0000# .. 16#01_FFFF#\n+   type UTF_32 is range 0 .. 16#7FFF_FFFF#;\n+   --  So far, the only defined character codes are in 0 .. 16#01_FFFF#\n \n-   function Is_UTF_32_Letter (U : UTF_32) return Boolean;\n+   type Category is (\n+     Cc,   --  Other, Control\n+     Cf,   --  Other, Format\n+     Cn,   --  Other, Not Assigned\n+     Co,   --  Other, Private Use\n+     Cs,   --  Other, Surrogate\n+     Ll,   --  Letter, Lowercase\n+     Lm,   --  Letter, Modifier\n+     Lo,   --  Letter, Other\n+     Lt,   --  Letter, Titlecase\n+     Lu,   --  Letter, Uppercase\n+     Mc,   --  Mark, Spacing Combining\n+     Me,   --  Mark, Enclosing\n+     Mn,   --  Mark, Nonspacing\n+     Nd,   --  Number, Decimal Digit\n+     Nl,   --  Number, Letter\n+     No,   --  Number, Other\n+     Pc,   --  Punctuation, Connector\n+     Pd,   --  Punctuation, Dash\n+     Pe,   --  Punctuation, Close\n+     Pf,   --  Punctuation, Final quote\n+     Pi,   --  Punctuation, Initial quote\n+     Po,   --  Punctuation, Other\n+     Ps,   --  Punctuation, Open\n+     Sc,   --  Symbol, Currency\n+     Sk,   --  Symbol, Modifier\n+     Sm,   --  Symbol, Math\n+     So,   --  Symbol, Other\n+     Zl,   --  Separator, Line\n+     Zp,   --  Separator, Paragraph\n+     Zs);  --  Separator, Space\n+\n+   function Get_Category (U : UTF_32) return Category;\n+   --  Given a UTF32 code, returns corresponding Category, or Cn if\n+   --  the code does not have an assigned unicode category.\n+\n+   --  The following functions perform category tests corresponding to lexical\n+   --  classes defined in the Ada standard. There are two interfaces for each\n+   --  function. The first takes a Category (e.g. returned by Get_Category).\n+   --  The second takes a UTF_32 code. The form taking the UTF_32 code is\n+   --  typically more efficient than calling Get_Category, but if several\n+   --  different tests are to be performed on the same code, it is more\n+   --  efficient to use Get_Category to get the category, then test the\n+   --  resulting category.\n+\n+   function Is_UTF_32_Letter (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Letter (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Letter);\n-   --  Returns true iff U is a letter that can be used to start an identifier.\n-   --  This means that it is in one of the following categories:\n+   --  Returns true iff U is a letter that can be used to start an identifier,\n+   --  or if C is one of the corresponding categories, which are the following:\n    --    Letter, Uppercase (Lu)\n    --    Letter, Lowercase (Ll)\n    --    Letter, Titlecase (Lt)\n    --    Letter, Modifier  (Lm)\n    --    Letter, Other     (Lo)\n    --    Number, Letter    (Nl)\n \n-   function Is_UTF_32_Digit (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Digit (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Digit (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Digit);\n    --  Returns true iff U is a digit that can be used to extend an identifer,\n-   --  which means it is in one of the following categories:\n+   --  or if C is one of the corresponding categories, which are the following:\n    --    Number, Decimal_Digit (Nd)\n \n-   function Is_UTF_32_Line_Terminator (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Line_Terminator (U : UTF_32)   return Boolean;\n    pragma Inline (Is_UTF_32_Line_Terminator);\n    --  Returns true iff U is an allowed line terminator for source programs,\n-   --  which means it is in one of the following categories:\n-   --    Separator, Line (Zl)\n-   --    Separator, Paragraph (Zp)\n-   --  or that it is a conventional line terminator (CR, LF, VT, FF)\n+   --  if U is in the category Zp (Separator, Paragaph), or Zs (Separator,\n+   --  Line), or if U is a conventional line terminator (CR, LF, VT, FF).\n+   --  There is no category version for this function, since the set of\n+   --  characters does not correspond to a set of Unicode categories.\n \n-   function Is_UTF_32_Mark (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Mark (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Mark (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Mark);\n-   --  Returns true iff U is a mark character which can be used to extend\n-   --  an identifier. This means it is in one of the following categories:\n+   --  Returns true iff U is a mark character which can be used to extend an\n+   --  identifier, or if C is one of the corresponding categories, which are\n+   --  the following:\n    --    Mark, Non-Spacing (Mn)\n    --    Mark, Spacing Combining (Mc)\n \n-   function Is_UTF_32_Other (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Other (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Other (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Other);\n    --  Returns true iff U is an other format character, which means that it\n    --  can be used to extend an identifier, but is ignored for the purposes of\n-   --  matching of identiers. This means that it is in one of the following\n-   --  categories:\n+   --  matching of identiers, or if C is one of the corresponding categories,\n+   --  which are the following:\n    --    Other, Format (Cf)\n \n-   function Is_UTF_32_Punctuation (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Punctuation (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Punctuation (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Punctuation);\n    --  Returns true iff U is a punctuation character that can be used to\n-   --  separate pices of an identifier. This means that it is in one of the\n-   --  following categories:\n+   --  separate pices of an identifier, or if C is one of the corresponding\n+   --  categories, which are the following:\n    --    Punctuation, Connector (Pc)\n \n-   function Is_UTF_32_Space (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Space (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Space (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Space);\n-   --  Returns true iff U is considered a space to be ignored, which means\n-   --  that it is in one of the following categories:\n+   --  Returns true iff U is considered a space to be ignored, or if C is one\n+   --  of the corresponding categories, which are the following:\n    --    Separator, Space (Zs)\n \n-   function Is_UTF_32_Non_Graphic (U : UTF_32) return Boolean;\n+   function Is_UTF_32_Non_Graphic (U : UTF_32)   return Boolean;\n+   function Is_UTF_32_Non_Graphic (C : Category) return Boolean;\n    pragma Inline (Is_UTF_32_Non_Graphic);\n-   --  Returns true iff U is considered to be a non-graphic character,\n-   --  which means that it is in one of the following categories:\n+   --  Returns true iff U is considered to be a non-graphic character, or if C\n+   --  is one of the corresponding categories, which are the following:\n    --    Other, Control (Cc)\n    --    Other, Private Use (Co)\n    --    Other, Surrogate (Cs)\n@@ -113,6 +166,16 @@ package GNAT.UTF_32 is\n    --\n    --  Note that the Ada category format effector is subsumed by the above\n    --  list of Unicode categories.\n+   --\n+   --  Note that Other, Unassiged (Cn) is quite deliberately not included\n+   --  in the list of categories above. This means that should any of these\n+   --  code positions be defined in future with graphic characters they will\n+   --  be allowed without a need to change implementations or the standard.\n+\n+   --  The following function is used to fold to upper case, as required by\n+   --  the Ada 2005 standard rules for identifier case folding. Two\n+   --  identifiers are equivalent if they are identical after folding all\n+   --  letters to upper case using this routine.\n \n    function UTF_32_To_Upper_Case (U : UTF_32) return UTF_32;\n    pragma Inline (UTF_32_To_Upper_Case);"}, {"sha": "9aae8522193b76a4b9f84f6421ce048f0bc9c4f5", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=c8427bff140cfe0c3a749a32ee531314f19e178a", "patch": "@@ -250,6 +250,7 @@ package body Impunit is\n      \"g-thread\",    -- GNAT.Threads\n      \"g-traceb\",    -- GNAT.Traceback\n      \"g-trasym\",    -- GNAT.Traceback.Symbolic\n+     \"g-utf_32\",    -- GNAT.UTF_32\n      \"g-wistsp\",    -- GNAT.Wide_String_Split\n \n    -----------------------------------------------------"}, {"sha": "5621ff602babe006fbc227a7d4e4ded6ae1ec2d7", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=c8427bff140cfe0c3a749a32ee531314f19e178a", "patch": "@@ -40,6 +40,8 @@ with Widechar; use Widechar;\n with System.CRC32;\n with System.WCh_Con; use System.WCh_Con;\n \n+with GNAT.UTF_32; use GNAT.UTF_32;\n+\n package body Scng is\n \n    use ASCII;\n@@ -1103,7 +1105,7 @@ package body Scng is\n                   Accumulate_Checksum (Code);\n \n                   if Ada_Version >= Ada_05\n-                    and then Is_UTF_32_Non_Graphic (Code)\n+                    and then Is_UTF_32_Non_Graphic (UTF_32 (Code))\n                   then\n                      Error_Msg\n                        (\"(Ada 2005) non-graphic character not permitted \" &\n@@ -1515,7 +1517,7 @@ package body Scng is\n \n                         --  If UTF_32 terminator, terminate comment scan\n \n-                        elsif Is_UTF_32_Line_Terminator (Code) then\n+                        elsif Is_UTF_32_Line_Terminator (UTF_32 (Code)) then\n                            Scan_Ptr := Wptr;\n                            exit;\n                         end if;\n@@ -1639,7 +1641,7 @@ package body Scng is\n                      Code := Character'Pos (' ');\n \n                   elsif Ada_Version >= Ada_05\n-                    and then Is_UTF_32_Non_Graphic (Code)\n+                    and then Is_UTF_32_Non_Graphic (UTF_32 (Code))\n                   then\n                      Error_Msg\n                        (\"(Ada 2005) non-graphic character not permitted \" &\n@@ -1899,7 +1901,7 @@ package body Scng is\n \n          --  Invalid control characters\n \n-         when NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS  | SO  |\n+         when NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS  | ASCII.SO |\n               SI  | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN |\n               EM  | FS  | GS  | RS  | US  | DEL\n          =>\n@@ -1942,6 +1944,7 @@ package body Scng is\n \n          declare\n             Code : Char_Code;\n+            Cat  : Category;\n             Err  : Boolean;\n \n          begin\n@@ -1953,10 +1956,13 @@ package body Scng is\n             if Err then\n                Error_Illegal_Wide_Character;\n                goto Scan_Next_Character;\n+            end if;\n+\n+            Cat := Get_Category (UTF_32 (Code));\n \n             --  If OK letter, reset scan ptr and go scan identifier\n \n-            elsif Is_UTF_32_Letter (Code) then\n+            if Is_UTF_32_Letter (Cat) then\n                Scan_Ptr := Wptr;\n                Name_Len := 0;\n                Underline_Found := False;\n@@ -1965,18 +1971,18 @@ package body Scng is\n             --  If OK wide space, ignore and keep scanning (we do not include\n             --  any ignored spaces in checksum)\n \n-            elsif Is_UTF_32_Space (Code) then\n+            elsif Is_UTF_32_Space (Cat) then\n                goto Scan_Next_Character;\n \n             --  If OK wide line terminator, terminate current line\n \n-            elsif Is_UTF_32_Line_Terminator (Code) then\n+            elsif Is_UTF_32_Line_Terminator (UTF_32 (Code)) then\n                Scan_Ptr := Wptr;\n                goto Scan_Line_Terminator;\n \n             --  Punctuation is an error (at start of identifier)\n \n-            elsif Is_UTF_32_Punctuation (Code) then\n+            elsif Is_UTF_32_Punctuation (Cat) then\n                Error_Msg\n                  (\"identifier cannot start with punctuation\", Wptr);\n                Scan_Ptr := Wptr;\n@@ -1986,7 +1992,7 @@ package body Scng is\n \n             --  Mark character is an error (at start of identifer)\n \n-            elsif Is_UTF_32_Mark (Code) then\n+            elsif Is_UTF_32_Mark (Cat) then\n                Error_Msg\n                  (\"identifier cannot start with mark character\", Wptr);\n                Scan_Ptr := Wptr;\n@@ -1996,7 +2002,7 @@ package body Scng is\n \n             --  Other format character is an error (at start of identifer)\n \n-            elsif Is_UTF_32_Other (Code) then\n+            elsif Is_UTF_32_Other (Cat) then\n                Error_Msg\n                  (\"identifier cannot start with other format character\", Wptr);\n                Scan_Ptr := Wptr;\n@@ -2008,7 +2014,7 @@ package body Scng is\n             --  identifier or bad literal. Not worth doing too much to try to\n             --  distinguish these cases, but we will do a little bit.\n \n-            elsif Is_UTF_32_Digit (Code) then\n+            elsif Is_UTF_32_Digit (Cat) then\n                Error_Msg\n                  (\"identifier cannot start with digit character\", Wptr);\n                Scan_Ptr := Wptr;\n@@ -2155,9 +2161,10 @@ package body Scng is\n                --  encoding into the name table entry for the identifier.\n \n                declare\n-                  Code   : Char_Code;\n-                  Err    : Boolean;\n-                  Chr    : Character;\n+                  Code : Char_Code;\n+                  Err  : Boolean;\n+                  Chr  : Character;\n+                  Cat  : Category;\n \n                begin\n                   Wptr := Scan_Ptr;\n@@ -2198,19 +2205,22 @@ package body Scng is\n                        (\"wide character not allowed in identifier\", Wptr);\n                      end if;\n \n+                     Cat := Get_Category (UTF_32 (Code));\n+\n                      --  If OK letter, store it folding to upper case. Note\n                      --  that we include the folded letter in the checksum.\n \n-                     if Is_UTF_32_Letter (Code) then\n-                        Code := UTF_32_To_Upper_Case (Code);\n+                     if Is_UTF_32_Letter (Cat) then\n+                        Code :=\n+                          Char_Code (UTF_32_To_Upper_Case (UTF_32 (Code)));\n                         Accumulate_Checksum (Code);\n                         Store_Encoded_Character (Code);\n                         Underline_Found := False;\n \n                      --  If OK extended digit or mark, then store it\n \n-                     elsif Is_UTF_32_Digit (Code)\n-                       or else Is_UTF_32_Mark (Code)\n+                     elsif Is_UTF_32_Digit (Cat)\n+                       or else Is_UTF_32_Mark (Cat)\n                      then\n                         Accumulate_Checksum (Code);\n                         Store_Encoded_Character (Code);\n@@ -2219,7 +2229,7 @@ package body Scng is\n                      --  Wide punctuation is also stored, but counts as an\n                      --  underline character for error checking purposes.\n \n-                     elsif Is_UTF_32_Punctuation (Code) then\n+                     elsif Is_UTF_32_Punctuation (Cat) then\n                         Accumulate_Checksum (Code);\n \n                         if Underline_Found then\n@@ -2241,12 +2251,12 @@ package body Scng is\n                      --  stored. It seems reasonable to exclude it from the\n                      --  checksum.\n \n-                     elsif Is_UTF_32_Other (Code) then\n+                     elsif Is_UTF_32_Other (Cat) then\n                         null;\n \n                      --  Wide character in category Separator,Space terminates\n \n-                     elsif Is_UTF_32_Space (Code) then\n+                     elsif Is_UTF_32_Space (Cat) then\n                         goto Scan_Identifier_Complete;\n \n                      --  Any other wide character is not acceptable"}, {"sha": "a74ee4374024fb96a62d7c44143fcb8c224ad2f3", "filename": "gcc/ada/widechar.adb", "status": "modified", "additions": 0, "deletions": 1587, "changes": 1587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fwidechar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fwidechar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwidechar.adb?ref=c8427bff140cfe0c3a749a32ee531314f19e178a"}, {"sha": "7b7f52076324ad0f1d6e5d8e68225ed7e5d7c442", "filename": "gcc/ada/widechar.ads", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fwidechar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8427bff140cfe0c3a749a32ee531314f19e178a/gcc%2Fada%2Fwidechar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwidechar.ads?ref=c8427bff140cfe0c3a749a32ee531314f19e178a", "patch": "@@ -90,78 +90,4 @@ package Widechar is\n       P : Source_Ptr) return Boolean;\n    --  Determines if S (P) is the start of a wide character sequence\n \n-   function Is_UTF_32_Letter (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Letter);\n-   --  Returns true iff U is a letter that can be used to start an identifier.\n-   --  This means that it is in one of the following categories:\n-   --    Letter, Uppercase (Lu)\n-   --    Letter, Lowercase (Ll)\n-   --    Letter, Titlecase (Lt)\n-   --    Letter, Modifier  (Lm)\n-   --    Letter, Other     (Lo)\n-   --    Number, Letter    (Nl)\n-\n-   function Is_UTF_32_Digit (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Digit);\n-   --  Returns true iff U is a digit that can be used to extend an identifer,\n-   --  which means it is in one of the following categories:\n-   --    Number, Decimal_Digit (Nd)\n-\n-   function Is_UTF_32_Line_Terminator (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Line_Terminator);\n-   --  Returns true iff U is an allowed line terminator for source programs,\n-   --  which means it is in one of the following categories:\n-   --    Separator, Line (Zl)\n-   --    Separator, Paragraph (Zp)\n-   --  or that it is a conventional line terminator (CR, LF, VT, FF)\n-\n-   function Is_UTF_32_Mark (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Mark);\n-   --  Returns true iff U is a mark character which can be used to extend\n-   --  an identifier. This means it is in one of the following categories:\n-   --    Mark, Non-Spacing (Mn)\n-   --    Mark, Spacing Combining (Mc)\n-\n-   function Is_UTF_32_Other (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Other);\n-   --  Returns true iff U is an other format character, which means that it\n-   --  can be used to extend an identifier, but is ignored for the purposes of\n-   --  matching of identiers. This means that it is in one of the following\n-   --  categories:\n-   --    Other, Format (Cf)\n-\n-   function Is_UTF_32_Punctuation (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Punctuation);\n-   --  Returns true iff U is a punctuation character that can be used to\n-   --  separate pices of an identifier. This means that it is in one of the\n-   --  following categories:\n-   --    Punctuation, Connector (Pc)\n-\n-   function Is_UTF_32_Space (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Space);\n-   --  Returns true iff U is considered a space to be ignored, which means\n-   --  that it is in one of the following categories:\n-   --    Separator, Space (Zs)\n-\n-   function Is_UTF_32_Non_Graphic (U : Char_Code) return Boolean;\n-   pragma Inline (Is_UTF_32_Non_Graphic);\n-   --  Returns true iff U is considered to be a non-graphic character,\n-   --  which means that it is in one of the following categories:\n-   --    Other, Control (Cc)\n-   --    Other, Private Use (Co)\n-   --    Other, Surrogate (Cs)\n-   --    Other, Format (Cf)\n-   --    Separator, Line (Zl)\n-   --    Separator, Paragraph (Zp)\n-   --\n-   --  Note that the Ada category format effector is subsumed by the above\n-   --  list of Unicode categories.\n-\n-   function UTF_32_To_Upper_Case (U : Char_Code) return Char_Code;\n-   pragma Inline (UTF_32_To_Upper_Case);\n-   --  If U represents a lower case letter, returns the corresponding upper\n-   --  case letter, otherwise U is returned unchanged. The folding is locale\n-   --  independent as defined by documents referenced in the note in section\n-   --  1 of ISO/IEC 10646:2003\n-\n end Widechar;"}]}