{"sha": "c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg2YWY3ZjNlNDlkMDIwOWQ4YmYzZTU0YTNkMDY0Zjk4ZTMyZGViZA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-11-02T12:56:38Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-11-02T12:56:38Z"}, "message": "PR 45629 Remove usage of setjmp/longjmp\n\nFrom-SVN: r166180", "tree": {"sha": "b51f35ef09ae01a2522589a5142acc1588ac2f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51f35ef09ae01a2522589a5142acc1588ac2f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/comments", "author": null, "committer": null, "parents": [{"sha": "6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1abb06a628f1b0abd1a85b78cb68666bcb3b23"}], "stats": {"total": 453, "additions": 274, "deletions": 179}, "files": [{"sha": "4a67c8f2d1ee38632b7e4dbcee8097b046cd2944", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "patch": "@@ -1,3 +1,32 @@\n+2010-11-02  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/45629\n+\t* io/io.h: Remove setjmp.h include.\n+\t(st_parameter_dt): Change last_char to int, remove eof_jump.\n+\t* io/list_read.c (next_char): Return EOF instead of jumping.\n+\t(unget_char): Use int to be able to handle EOF.\n+\t(eat_spaces): Handle EOF return from next_char.\n+\t(eat_line): Likewise.\n+\t(eat_separator): Handle EOF return from next_char, eat_spaces,\n+\teat_line.\n+\t(finish_separator): Likewise.\n+\t(convert_integer): Likewise.\n+\t(read_logical): Likewise.\n+\t(read_integer): Likewise.\n+\t(read_character): Likewise.\n+\t(parse_real): Likewise.\n+\t(read_complex): Likewise.\n+\t(read_real): Likewise.\n+\t(list_formatted_read_scalar): Likewise.\n+\t(list_formatted_read): Likewise.\n+\t(finish_list_read): Likewise.\n+\t(nml_parse_qualifier): Likewise.\n+\t(nml_match_name): Likewise.\n+\t(nml_get_obj_data): Likewise.\n+\t(namelist_read): Likewise.\n+\t* io/transfer.c (data_transfer_init): Initialize last_char.\n+\t(finalize_transfer): Remove jmp_buf setup.\n+\n 2010-10-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/46010"}, {"sha": "ebe7f7cc1f0ed24e2a5426f3a0a9cc4c56775856", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "patch": "@@ -31,7 +31,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"libgfortran.h\"\n \n-#include <setjmp.h>\n #include <gthr.h>\n \n /* Forward declarations.  */\n@@ -427,7 +426,10 @@ typedef struct st_parameter_dt\n \t  unsigned format_not_saved : 1;\n \t  /* 14 unused bits.  */\n \n-\t  char last_char;\n+\t  /* Used for ungetc() style functionality. Possible values\n+\t     are an unsigned char, EOF, or EOF - 1 used to mark the\n+\t     field as not valid.  */\n+\t  int last_char;\n \t  char nml_delim;\n \n \t  int repeat_count;\n@@ -438,7 +440,6 @@ typedef struct st_parameter_dt\n \t  char *scratch;\n \t  char *line_buffer;\n \t  struct format_data *fmt;\n-\t  jmp_buf *eof_jump;\n \t  namelist_info *ionml;\n \t  /* A flag used to identify when a non-standard expanded namelist read\n \t     has occurred.  */"}, {"sha": "34514ca0c5425ae49e69eb74c2d7fad205b99716", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 237, "deletions": 167, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "patch": "@@ -133,19 +133,18 @@ free_line (st_parameter_dt *dtp)\n }\n \n \n-static char\n+static int\n next_char (st_parameter_dt *dtp)\n {\n   ssize_t length;\n   gfc_offset record;\n-  char c;\n-  int cc;\n+  int c;\n \n-  if (dtp->u.p.last_char != '\\0')\n+  if (dtp->u.p.last_char != EOF - 1)\n     {\n       dtp->u.p.at_eol = 0;\n       c = dtp->u.p.last_char;\n-      dtp->u.p.last_char = '\\0';\n+      dtp->u.p.last_char = EOF - 1;\n       goto done;\n     }\n \n@@ -172,7 +171,7 @@ next_char (st_parameter_dt *dtp)\n   if (is_array_io (dtp))\n     {\n       if (dtp->u.p.at_eof)\n-\tlongjmp (*dtp->u.p.eof_jump, 1);\n+\treturn EOF;\n \n       /* Check for \"end-of-record\" condition.  */\n       if (dtp->u.p.current_unit->bytes_left == 0)\n@@ -192,7 +191,7 @@ next_char (st_parameter_dt *dtp)\n \n \t  record *= dtp->u.p.current_unit->recl;\n \t  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n-\t    longjmp (*dtp->u.p.eof_jump, 1);\n+\t    return EOF;\n \n \t  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t  goto done;\n@@ -203,7 +202,9 @@ next_char (st_parameter_dt *dtp)\n \n   if (is_internal_unit (dtp))\n     {\n-      length = sread (dtp->u.p.current_unit->s, &c, 1);\n+      char cc;\n+      length = sread (dtp->u.p.current_unit->s, &cc, 1);\n+      c = cc;\n       if (length < 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n@@ -223,7 +224,7 @@ next_char (st_parameter_dt *dtp)\n       else\n \t{\n \t  if (dtp->u.p.at_eof) \n-\t    longjmp (*dtp->u.p.eof_jump, 1);\n+\t    return EOF;\n \t  if (length == 0)\n \t    {\n \t      c = '\\n';\n@@ -233,31 +234,20 @@ next_char (st_parameter_dt *dtp)\n     }\n   else\n     {\n-      cc = fbuf_getc (dtp->u.p.current_unit);\n-\n-      if (cc == EOF)\n-\t{\n-\t  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-\t    longjmp (*dtp->u.p.eof_jump, 1);\n-\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t  c = '\\n';\n-\t}\n-      else\n-\tc = (char) cc;\n-      if (is_stream_io (dtp) && cc != EOF)\n+      c = fbuf_getc (dtp->u.p.current_unit);\n+      if (c != EOF && is_stream_io (dtp))\n \tdtp->u.p.current_unit->strm_pos++;\n-\n     }\n done:\n-  dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n+  dtp->u.p.at_eol = (c == '\\n' || c == '\\r' || c == EOF);\n   return c;\n }\n \n \n /* Push a character back onto the input.  */\n \n static void\n-unget_char (st_parameter_dt *dtp, char c)\n+unget_char (st_parameter_dt *dtp, int c)\n {\n   dtp->u.p.last_char = c;\n }\n@@ -266,33 +256,35 @@ unget_char (st_parameter_dt *dtp, char c)\n /* Skip over spaces in the input.  Returns the nonspace character that\n    terminated the eating and also places it back on the input.  */\n \n-static char\n+static int\n eat_spaces (st_parameter_dt *dtp)\n {\n-  char c;\n+  int c;\n \n   do\n-    {\n-      c = next_char (dtp);\n-    }\n-  while (c == ' ' || c == '\\t');\n+    c = next_char (dtp);\n+  while (c != EOF && (c == ' ' || c == '\\t'));\n \n   unget_char (dtp, c);\n   return c;\n }\n \n \n-/* This function reads characters through to the end of the current line and\n-   just ignores them.  */\n+/* This function reads characters through to the end of the current\n+   line and just ignores them.  Returns 0 for success and LIBERROR_END\n+   if it hit EOF.  */\n \n-static void\n+static int\n eat_line (st_parameter_dt *dtp)\n {\n-  char c;\n+  int c;\n \n   do\n     c = next_char (dtp);\n-  while (c != '\\n');\n+  while (c != EOF && c != '\\n');\n+  if (c == EOF)\n+    return LIBERROR_END;\n+  return 0;\n }\n \n \n@@ -305,17 +297,21 @@ eat_line (st_parameter_dt *dtp)\n    separator, we stop reading.  If there are more input items, we\n    continue reading the separator with finish_separator() which takes\n    care of the fact that we may or may not have seen a comma as part\n-   of the separator.  */\n+   of the separator. \n \n-static void\n+   Returns 0 for success, and non-zero error code otherwise.  */\n+\n+static int\n eat_separator (st_parameter_dt *dtp)\n {\n-  char c, n;\n+  int c, n;\n+  int err = 0;\n \n   eat_spaces (dtp);\n   dtp->u.p.comma_flag = 0;\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    return LIBERROR_END;\n   switch (c)\n     {\n     case ',':\n@@ -336,7 +332,8 @@ eat_separator (st_parameter_dt *dtp)\n \n     case '\\r':\n       dtp->u.p.at_eol = 1;\n-      n = next_char(dtp);\n+      if ((n = next_char(dtp)) == EOF)\n+\treturn LIBERROR_END;\n       if (n != '\\n')\n \t{\n \t  unget_char (dtp, n);\n@@ -349,15 +346,22 @@ eat_separator (st_parameter_dt *dtp)\n \t{\n \t  do\n \t    {\n-\t      c = next_char (dtp);\n+\t      if ((c = next_char (dtp)) == EOF)\n+\t\t  return LIBERROR_END;\n \t      if (c == '!')\n \t\t{\n-\t\t  eat_line (dtp);\n-\t\t  c = next_char (dtp);\n+\t\t  err = eat_line (dtp);\n+\t\t  if (err)\n+\t\t    return err;\n+\t\t  if ((c = next_char (dtp)) == EOF)\n+\t\t    return LIBERROR_END;\n \t\t  if (c == '!')\n \t\t    {\n-\t\t      eat_line (dtp);\n-\t\t      c = next_char (dtp);\n+\t\t      err = eat_line (dtp);\n+\t\t      if (err)\n+\t\t\treturn err;\n+\t\t      if ((c = next_char (dtp)) == EOF)\n+\t\t\treturn LIBERROR_END;\n \t\t    }\n \t\t}\n \t    }\n@@ -369,9 +373,9 @@ eat_separator (st_parameter_dt *dtp)\n     case '!':\n       if (dtp->u.p.namelist_mode)\n \t{\t\t\t/* Eat a namelist comment.  */\n-\t  do\n-\t    c = next_char (dtp);\n-\t  while (c != '\\n');\n+\t  err = eat_line (dtp);\n+\t  if (err)\n+\t    return err;\n \n \t  break;\n \t}\n@@ -382,30 +386,35 @@ eat_separator (st_parameter_dt *dtp)\n       unget_char (dtp, c);\n       break;\n     }\n+  return err;\n }\n \n \n /* Finish processing a separator that was interrupted by a newline.\n    If we're here, then another data item is present, so we finish what\n-   we started on the previous line.  */\n+   we started on the previous line.  Return 0 on success, error code\n+   on failure.  */\n \n-static void\n+static int\n finish_separator (st_parameter_dt *dtp)\n {\n-  char c;\n+  int c;\n+  int err;\n \n  restart:\n   eat_spaces (dtp);\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    return LIBERROR_END;\n   switch (c)\n     {\n     case ',':\n       if (dtp->u.p.comma_flag)\n \tunget_char (dtp, c);\n       else\n \t{\n-\t  c = eat_spaces (dtp);\n+\t  if ((c = eat_spaces (dtp)) == EOF)\n+\t    return LIBERROR_END;\n \t  if (c == '\\n' || c == '\\r')\n \t    goto restart;\n \t}\n@@ -415,7 +424,7 @@ finish_separator (st_parameter_dt *dtp)\n     case '/':\n       dtp->u.p.input_complete = 1;\n       if (!dtp->u.p.namelist_mode)\n-\treturn;\n+\treturn err;\n       break;\n \n     case '\\n':\n@@ -425,17 +434,17 @@ finish_separator (st_parameter_dt *dtp)\n     case '!':\n       if (dtp->u.p.namelist_mode)\n \t{\n-\t  do\n-\t    c = next_char (dtp);\n-\t  while (c != '\\n');\n-\n+\t  err = eat_line (dtp);\n+\t  if (err)\n+\t    return err;\n \t  goto restart;\n \t}\n \n     default:\n       unget_char (dtp, c);\n       break;\n     }\n+  return err;\n }\n \n \n@@ -535,10 +544,11 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n static int\n parse_repeat (st_parameter_dt *dtp)\n {\n-  char c, message[100];\n-  int repeat;\n+  char message[100];\n+  int c, repeat;\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto bad_repeat;\n   switch (c)\n     {\n     CASE_DIGITS:\n@@ -599,8 +609,14 @@ parse_repeat (st_parameter_dt *dtp)\n \n  bad_repeat:\n \n-  eat_line (dtp);\n   free_saved (dtp);\n+  if (c == EOF)\n+    {\n+      hit_eof (dtp);\n+      return 1;\n+    }\n+  else\n+    eat_line (dtp);\n   sprintf (message, \"Bad repeat count in item %d of list input\",\n \t   dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -631,8 +647,8 @@ l_push_char (st_parameter_dt *dtp, char c)\n static void\n read_logical (st_parameter_dt *dtp, int length)\n {\n-  char c, message[100];\n-  int i, v;\n+  char message[100];\n+  int c, i, v;\n \n   if (parse_repeat (dtp))\n     return;\n@@ -643,7 +659,8 @@ read_logical (st_parameter_dt *dtp, int length)\n     {\n     case 't':\n       v = 1;\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad_logical;\n       l_push_char (dtp, c);\n \n       if (!is_separator(c))\n@@ -653,7 +670,8 @@ read_logical (st_parameter_dt *dtp, int length)\n       break;\n     case 'f':\n       v = 0;\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad_logical;\n       l_push_char (dtp, c);\n \n       if (!is_separator(c))\n@@ -695,10 +713,8 @@ read_logical (st_parameter_dt *dtp, int length)\n \n   /* Eat trailing garbage.  */\n   do\n-    {\n-      c = next_char (dtp);\n-    }\n-  while (!is_separator (c));\n+    c = next_char (dtp);\n+  while (c != EOF && !is_separator (c));\n \n   unget_char (dtp, c);\n   eat_separator (dtp);\n@@ -746,8 +762,14 @@ read_logical (st_parameter_dt *dtp, int length)\n   if (nml_bad_return (dtp, c))\n     return;\n \n-  eat_line (dtp);\n   free_saved (dtp);\n+  if (c == EOF)\n+    {\n+      hit_eof (dtp);\n+      return;\n+    }\n+  else\n+    eat_line (dtp);\n   sprintf (message, \"Bad logical value while reading item %d\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -771,8 +793,8 @@ read_logical (st_parameter_dt *dtp, int length)\n static void\n read_integer (st_parameter_dt *dtp, int length)\n {\n-  char c, message[100];\n-  int negative;\n+  char message[100];\n+  int c, negative;\n \n   negative = 0;\n \n@@ -784,7 +806,8 @@ read_integer (st_parameter_dt *dtp, int length)\n       /* Fall through...  */\n \n     case '+':\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad_integer;\n       goto get_integer;\n \n     CASE_SEPARATORS:\t\t/* Single null.  */\n@@ -829,7 +852,8 @@ read_integer (st_parameter_dt *dtp, int length)\n \n   /* Get the real integer.  */\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto bad_integer;\n   switch (c)\n     {\n     CASE_DIGITS:\n@@ -875,9 +899,15 @@ read_integer (st_parameter_dt *dtp, int length)\n \n   if (nml_bad_return (dtp, c))\n     return;\n-  \n-  eat_line (dtp);\n-  free_saved (dtp);\n+\n+  free_saved (dtp);  \n+  if (c == EOF)\n+    {\n+      hit_eof (dtp);\n+      return;\n+    }\n+  else\n+    eat_line (dtp);\n   sprintf (message, \"Bad integer for item %d in list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -905,11 +935,13 @@ read_integer (st_parameter_dt *dtp, int length)\n static void\n read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n {\n-  char c, quote, message[100];\n+  char quote, message[100];\n+  int c;\n \n   quote = ' ';\t\t\t/* Space means no quote character.  */\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto eof;\n   switch (c)\n     {\n     CASE_DIGITS:\n@@ -941,7 +973,8 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \n   for (;;)\n     {\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto eof;\n       switch (c)\n \t{\n \tCASE_DIGITS:\n@@ -968,7 +1001,8 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \n   /* Now get the real string.  */\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto eof;\n   switch (c)\n     {\n     CASE_SEPARATORS:\n@@ -989,7 +1023,8 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n  get_string:\n   for (;;)\n     {\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto eof;\n       switch (c)\n \t{\n \tcase '\"':\n@@ -1003,7 +1038,8 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \t  /* See if we have a doubled quote character or the end of\n \t     the string.  */\n \n-\t  c = next_char (dtp);\n+\t  if ((c = next_char (dtp)) == EOF)\n+\t    goto eof;\n \t  if (c == quote)\n \t    {\n \t      push_char (dtp, quote);\n@@ -1034,6 +1070,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n      invalid.  */\n  done:\n   c = next_char (dtp);\n+ eof:\n   if (is_separator (c) || c == '!')\n     {\n       unget_char (dtp, c);\n@@ -1044,6 +1081,11 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n   else\n     {\n       free_saved (dtp);\n+      if (c == EOF)\n+\t{\n+\t  hit_eof (dtp);\n+\t  return;\n+\t}\n       sprintf (message, \"Invalid string input in item %d\",\n \t\t  dtp->u.p.item_count);\n       generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -1057,14 +1099,16 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n static int\n parse_real (st_parameter_dt *dtp, void *buffer, int length)\n {\n-  char c, message[100];\n-  int m, seen_dp;\n+  char message[100];\n+  int c, m, seen_dp;\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto bad;\n   if (c == '-' || c == '+')\n     {\n       push_char (dtp, c);\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad;\n     }\n \n   if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n@@ -1084,7 +1128,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \n   for (;;)\n     {\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad;\n       if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n \tc = '.';\n       switch (c)\n@@ -1112,7 +1157,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \tcase '+':\n \t  push_char (dtp, 'e');\n \t  push_char (dtp, c);\n-\t  c = next_char (dtp);\n+\t  if ((c = next_char (dtp)) == EOF)\n+\t    goto bad;\n \t  goto exp2;\n \n \tCASE_SEPARATORS:\n@@ -1125,7 +1171,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n     }\n \n  exp1:\n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto bad;\n   if (c != '-' && c != '+')\n     push_char (dtp, '+');\n   else\n@@ -1142,7 +1189,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \n   for (;;)\n     {\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad;\n       switch (c)\n \t{\n \tCASE_DIGITS:\n@@ -1219,8 +1267,14 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n   if (nml_bad_return (dtp, c))\n     return 0;\n \n-  eat_line (dtp);\n   free_saved (dtp);\n+  if (c == EOF)\n+    {\n+      hit_eof (dtp);\n+      return 1;\n+    }\n+  else\n+    eat_line (dtp);\n   sprintf (message, \"Bad floating point number for item %d\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -1236,7 +1290,7 @@ static void\n read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n {\n   char message[100];\n-  char c;\n+  int c;\n \n   if (parse_repeat (dtp))\n     return;\n@@ -1303,8 +1357,14 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n   if (nml_bad_return (dtp, c))\n     return;\n \n-  eat_line (dtp);\n   free_saved (dtp);\n+  if (c == EOF)\n+    {\n+      hit_eof (dtp);\n+      return;\n+    }\n+  else    \n+    eat_line (dtp);\n   sprintf (message, \"Bad complex value in item %d of list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -1316,7 +1376,8 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n static void\n read_real (st_parameter_dt *dtp, void * dest, int length)\n {\n-  char c, message[100];\n+  char message[100];\n+  int c;\n   int seen_dp;\n   int is_inf;\n \n@@ -1409,7 +1470,8 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \n   /* Now get the number itself.  */\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto bad_real;\n   if (is_separator (c))\n     {\t\t\t\t/* Repeated null value.  */\n       unget_char (dtp, c);\n@@ -1423,7 +1485,8 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n     {\n     got_sign:\n       push_char (dtp, c);\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto bad_real;\n     }\n \n   if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n@@ -1460,6 +1523,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t  break;\n \n \tCASE_SEPARATORS:\n+\tcase EOF:\n \t  goto done;\n \n \tcase '.':\n@@ -1491,7 +1555,8 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n  exp1:\n   push_char (dtp, 'e');\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto bad_real;\n   if (c != '+' && c != '-')\n     push_char (dtp, '+');\n   else\n@@ -1612,7 +1677,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n       if (c == ' ' || c =='\\n' || c == '\\r')\n \t{\n \t  do\n-\t    c = next_char (dtp);\n+\t    {\n+\t      if ((c = next_char (dtp)) == EOF)\n+\t\tgoto bad_real;\n+\t    }\n \t  while (c == ' ' || c =='\\n' || c == '\\r');\n \n \t  l_push_char (dtp, c);\n@@ -1652,8 +1720,14 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n   if (nml_bad_return (dtp, c))\n     return;\n \n-  eat_line (dtp);\n   free_saved (dtp);\n+  if (c == EOF)\n+    {\n+      hit_eof (dtp);\n+      return;\n+    }\n+  else\n+    eat_line (dtp);\n   sprintf (message, \"Bad real number in item %d of list input\",\n \t      dtp->u.p.item_count);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n@@ -1700,37 +1774,28 @@ check_type (st_parameter_dt *dtp, bt type, int len)\n    reading, usually in the dtp->u.p.value[] array.  If a repeat count is\n    greater than one, we copy the data item multiple times.  */\n \n-static void\n-list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n+static int\n+list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \t\t\t    int kind, size_t size)\n {\n-  char c;\n   gfc_char4_t *q;\n-  int i, m;\n-  jmp_buf eof_jump;\n+  int c, i, m;\n+  int err = 0;\n \n   dtp->u.p.namelist_mode = 0;\n \n-  dtp->u.p.eof_jump = &eof_jump;\n-  if (setjmp (eof_jump))\n-    {\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      if (!is_internal_unit (dtp))\n-\t{\n-\t  dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n-\t  dtp->u.p.current_unit->current_record = 0;\n-\t}\n-      goto cleanup;\n-    }\n-\n   if (dtp->u.p.first_item)\n     {\n       dtp->u.p.first_item = 0;\n       dtp->u.p.input_complete = 0;\n       dtp->u.p.repeat_count = 1;\n       dtp->u.p.at_eol = 0;\n       \n-      c = eat_spaces (dtp);\n+      if ((c = eat_spaces (dtp)) == EOF)\n+\t{\n+\t  err = LIBERROR_END;\n+\t  goto cleanup;\n+\t}\n       if (is_separator (c))\n \t{\n \t  /* Found a null value.  */\n@@ -1754,7 +1819,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n       if (dtp->u.p.repeat_count > 0)\n \t{\n \t  if (check_type (dtp, type, kind))\n-\t    return;\n+\t    return err;\n \t  goto set_value;\n \t}\n \t\n@@ -1864,7 +1929,9 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n     free_saved (dtp);\n \n cleanup:\n-  dtp->u.p.eof_jump = NULL;\n+  if (err == LIBERROR_END)\n+    hit_eof (dtp);\n+  return err;\n }\n \n \n@@ -1876,14 +1943,18 @@ list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n   char *tmp;\n   size_t stride = type == BT_CHARACTER ?\n \t\t  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;\n+  int err;\n \n   tmp = (char *) p;\n \n   /* Big loop over all the elements.  */\n   for (elem = 0; elem < nelems; elem++)\n     {\n       dtp->u.p.item_count++;\n-      list_formatted_read_scalar (dtp, type, tmp + stride*elem, kind, size);\n+      err = list_formatted_read_scalar (dtp, type, tmp + stride*elem, \n+\t\t\t\t\tkind, size);\n+      if (err)\n+\tbreak;\n     }\n }\n \n@@ -1893,7 +1964,7 @@ list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n void\n finish_list_read (st_parameter_dt *dtp)\n {\n-  char c;\n+  int err;\n \n   free_saved (dtp);\n \n@@ -1905,18 +1976,9 @@ finish_list_read (st_parameter_dt *dtp)\n       return;\n     }\n \n-  do\n-    {\n-      c = next_char (dtp);\n-    }\n-  while (c != '\\n');\n-\n-  if (dtp->u.p.current_unit->endfile != NO_ENDFILE)\n-    {\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n-      dtp->u.p.current_unit->current_record = 0;\n-    }\n+  err = eat_line (dtp);\n+  if (err == LIBERROR_END)\n+    hit_eof (dtp);\n }\n \n /*\t\t\tNAMELIST INPUT\n@@ -1953,7 +2015,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n   int neg;\n   int null_flag;\n   int is_array_section, is_char;\n-  char c;\n+  int c;\n \n   is_char = 0;\n   is_array_section = 0;\n@@ -1968,7 +2030,8 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \n   /* The next character in the stream should be the '('.  */\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    return FAILURE;\n \n   /* Process the qualifier, by dimension and triplet.  */\n \n@@ -1981,7 +2044,8 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t  neg = 0;\n \n \t  /* Process a potential sign.  */\n-\t  c = next_char (dtp);\n+\t  if ((c = next_char (dtp)) == EOF)\n+\t    return FAILURE;\n \t  switch (c)\n \t    {\n \t    case '-':\n@@ -1999,7 +2063,8 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t  /* Process characters up to the next ':' , ',' or ')'.  */\n \t  for (;;)\n \t    {\n-\t      c = next_char (dtp);\n+\t      if ((c = next_char (dtp)) == EOF)\n+\t\treturn FAILURE;\n \n \t      switch (c)\n \t\t{\n@@ -2025,7 +2090,8 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \n \t\tcase ' ': case '\\t':\n \t\t  eat_spaces (dtp);\n-\t\t  c = next_char (dtp);\n+\t\t  if ((c = next_char (dtp) == EOF))\n+\t\t    return FAILURE;\n \t\t  break;\n \n \t\tdefault:\n@@ -2229,12 +2295,13 @@ static void\n nml_match_name (st_parameter_dt *dtp, const char *name, index_type len)\n {\n   index_type i;\n-  char c;\n+  int c;\n+\n   dtp->u.p.nml_read_error = 0;\n   for (i = 0; i < len; i++)\n     {\n       c = next_char (dtp);\n-      if (tolower (c) != tolower (name[i]))\n+      if (c == EOF || (tolower (c) != tolower (name[i])))\n \t{\n \t  dtp->u.p.nml_read_error = 1;\n \t  break;\n@@ -2591,7 +2658,7 @@ static try\n nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t\t  char *nml_err_msg, size_t nml_err_msg_size)\n {\n-  char c;\n+  int c;\n   namelist_info * nl;\n   namelist_info * first_nl = NULL;\n   namelist_info * root_nl = NULL;\n@@ -2612,11 +2679,13 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   if (dtp->u.p.input_complete)\n     return SUCCESS;\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    return FAILURE;\n   switch (c)\n     {\n     case '=':\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\treturn FAILURE;\n       if (c != '?')\n \t{\n \t  sprintf (nml_err_msg, \"namelist read: misplaced = sign\");\n@@ -2663,7 +2732,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n     {\n       if (!is_separator (c))\n \tpush_char (dtp, tolower(c));\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\treturn FAILURE;\n     } while (!( c=='=' || c==' ' || c=='\\t' || c =='(' || c =='%' ));\n \n   unget_char (dtp, c);\n@@ -2737,7 +2807,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       qualifier_flag = 1;\n \n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\treturn FAILURE;\n       unget_char (dtp, c);\n     }\n   else if (nl->var_rank > 0)\n@@ -2762,8 +2833,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       root_nl = nl;\n \n       component_flag = 1;\n-\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\treturn FAILURE;\n       goto get_name;\n     }\n \n@@ -2799,7 +2870,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t  goto nml_err_ret;\n \t}\n \n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\treturn FAILURE;\n       unget_char (dtp, c);\n     }\n \n@@ -2838,7 +2910,8 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   if (dtp->u.p.input_complete)\n     return SUCCESS;\n \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    return FAILURE;\n \n   if (c != '=')\n     {\n@@ -2883,8 +2956,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n void\n namelist_read (st_parameter_dt *dtp)\n {\n-  char c;\n-  jmp_buf eof_jump;\n+  int c;\n   char nml_err_msg[200];\n   /* Pointer to the previously read object, in case attempt is made to read\n      new object name.  Should this fail, error message can give previous\n@@ -2895,31 +2967,27 @@ namelist_read (st_parameter_dt *dtp)\n   dtp->u.p.input_complete = 0;\n   dtp->u.p.expanded_read = 0;\n \n-  dtp->u.p.eof_jump = &eof_jump;\n-  if (setjmp (eof_jump))\n-    {\n-      dtp->u.p.eof_jump = NULL;\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      return;\n-    }\n-\n   /* Look for &namelist_name .  Skip all characters, testing for $nmlname.\n      Exit on success or EOF. If '?' or '=?' encountered in stdin, print\n      node names or namelist on stdout.  */\n \n find_nml_name:\n-  switch (c = next_char (dtp))\n+  if ((c = next_char (dtp)) == EOF)\n+    goto nml_err_eof;\n+  switch (c)\n     {\n     case '$':\n     case '&':\n           break;\n \n     case '!':\n-      eat_line (dtp);\n+      if (eat_line (dtp))\n+\tgoto nml_err_eof;\n       goto find_nml_name;\n \n     case '=':\n-      c = next_char (dtp);\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto nml_err_eof;\n       if (c == '?')\n \tnml_query (dtp, '=');\n       else\n@@ -2941,7 +3009,8 @@ namelist_read (st_parameter_dt *dtp)\n     goto find_nml_name;\n \n   /* A trailing space is required, we give a little lattitude here, 10.9.1.  */ \n-  c = next_char (dtp);\n+  if ((c = next_char (dtp)) == EOF)\n+    goto nml_err_eof;\n   if (!is_separator(c) && c != '!')\n     {\n       unget_char (dtp, c);\n@@ -2965,16 +3034,17 @@ namelist_read (st_parameter_dt *dtp)\n         }\n     }\n \n-  dtp->u.p.eof_jump = NULL;\n   free_saved (dtp);\n   free_line (dtp);\n   return;\n \n   /* All namelist error calls return from here */\n \n+nml_err_eof:\n+  hit_eof (dtp);\n+\n nml_err_ret:\n \n-  dtp->u.p.eof_jump = NULL;\n   free_saved (dtp);\n   free_line (dtp);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, nml_err_msg);"}, {"sha": "05425ca2515bb7b0ebca5146871e3dd95727e9b5", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c86af7f3e49d0209d8bf3e54a3d064f98e32debd/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=c86af7f3e49d0209d8bf3e54a3d064f98e32debd", "patch": "@@ -2666,7 +2666,10 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       else\n \t{\n \t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n-\t    dtp->u.p.transfer = list_formatted_read;\n+\t    {\n+\t        dtp->u.p.last_char = EOF - 1;\n+\t\tdtp->u.p.transfer = list_formatted_read;\n+\t    }\n \t  else\n \t    dtp->u.p.transfer = formatted_transfer;\n \t}\n@@ -3362,7 +3365,6 @@ next_record (st_parameter_dt *dtp, int done)\n static void\n finalize_transfer (st_parameter_dt *dtp)\n {\n-  jmp_buf eof_jump;\n   GFC_INTEGER_4 cf = dtp->common.flags;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n@@ -3394,13 +3396,6 @@ finalize_transfer (st_parameter_dt *dtp)\n   if (dtp->u.p.current_unit == NULL)\n     return;\n \n-  dtp->u.p.eof_jump = &eof_jump;\n-  if (setjmp (eof_jump))\n-    {\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      return;\n-    }\n-\n   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n     {\n       finish_list_read (dtp);"}]}