{"sha": "933a2c39fd3778d46305894d55fca0dd584acefa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzYTJjMzlmZDM3NzhkNDYzMDU4OTRkNTVmY2EwZGQ1ODRhY2VmYQ==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2012-07-25T18:26:12Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2012-07-25T18:26:12Z"}, "message": "re PR tree-optimization/30318 (VRP does not create ANTI_RANGEs on overflow)\n\n2012-07-25 Marc Glisse <marc.glisse@inria.fr>\n\n\tPR tree-optimization/30318\n\t* tree-vrp.c (extract_range_from_binary_expr_1) [PLUS_EXPR]:\n\tHandle __int128.\n\t[MINUS_EXPR]: Merge with PLUS_EXPR.\n\nFrom-SVN: r189861", "tree": {"sha": "684b59775092277392e3d13d5be703374335159d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/684b59775092277392e3d13d5be703374335159d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/933a2c39fd3778d46305894d55fca0dd584acefa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933a2c39fd3778d46305894d55fca0dd584acefa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933a2c39fd3778d46305894d55fca0dd584acefa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933a2c39fd3778d46305894d55fca0dd584acefa/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d45eae79db3e8c41ac1f307b267179498a636e0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45eae79db3e8c41ac1f307b267179498a636e0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45eae79db3e8c41ac1f307b267179498a636e0b"}], "stats": {"total": 132, "additions": 78, "deletions": 54}, "files": [{"sha": "1e12fb689ecdc37b9763ca400b4acb10dd1da1b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a2c39fd3778d46305894d55fca0dd584acefa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a2c39fd3778d46305894d55fca0dd584acefa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=933a2c39fd3778d46305894d55fca0dd584acefa", "patch": "@@ -1,3 +1,10 @@\n+2012-07-25 Marc Glisse <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/30318\n+\t* tree-vrp.c (extract_range_from_binary_expr_1) [PLUS_EXPR]:\n+\tHandle __int128.\n+\t[MINUS_EXPR]: Merge with PLUS_EXPR.\n+\n 2012-07-25  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Paul Brook  <paul@codesourcery.com>\n "}, {"sha": "2d1628dee3d48d25663e4357033897c6f7b819c5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933a2c39fd3778d46305894d55fca0dd584acefa/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933a2c39fd3778d46305894d55fca0dd584acefa/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=933a2c39fd3778d46305894d55fca0dd584acefa", "patch": "@@ -2352,15 +2352,14 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \n   /* For integer ranges, apply the operation to each end of the\n      range and see what we end up with.  */\n-  if (code == PLUS_EXPR)\n+  if (code == PLUS_EXPR || code == MINUS_EXPR)\n     {\n       /* If we have a PLUS_EXPR with two VR_RANGE integer constant\n          ranges compute the precise range for such case if possible.  */\n       if (range_int_cst_p (&vr0)\n \t  && range_int_cst_p (&vr1)\n-\t  /* We attempt to do infinite precision signed integer arithmetic,\n-\t     thus we need two more bits than the possibly unsigned inputs.  */\n-\t  && TYPE_PRECISION (expr_type) < HOST_BITS_PER_DOUBLE_INT - 1)\n+\t  /* We need as many bits as the possibly unsigned inputs.  */\n+\t  && TYPE_PRECISION (expr_type) <= HOST_BITS_PER_DOUBLE_INT)\n \t{\n \t  double_int min0 = tree_to_double_int (vr0.min);\n \t  double_int max0 = tree_to_double_int (vr0.max);\n@@ -2372,9 +2371,60 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t  double_int type_max\n \t    = double_int_max_value (TYPE_PRECISION (expr_type), uns);\n \t  double_int dmin, dmax;\n+\t  int min_ovf = 0;\n+\t  int max_ovf = 0;\n \n-\t  dmin = double_int_add (min0, min1);\n-\t  dmax = double_int_add (max0, max1);\n+\t  if (code == PLUS_EXPR)\n+\t    {\n+\t      dmin = double_int_add (min0, min1);\n+\t      dmax = double_int_add (max0, max1);\n+\n+\t      /* Check for overflow in double_int.  */\n+\t      if (double_int_cmp (min1, double_int_zero, uns)\n+\t\t  != double_int_cmp (dmin, min0, uns))\n+\t\tmin_ovf = double_int_cmp (min0, dmin, uns);\n+\t      if (double_int_cmp (max1, double_int_zero, uns)\n+\t\t  != double_int_cmp (dmax, max0, uns))\n+\t\tmax_ovf = double_int_cmp (max0, dmax, uns);\n+\t    }\n+\t  else /* if (code == MINUS_EXPR) */\n+\t    {\n+\t      dmin = double_int_sub (min0, max1);\n+\t      dmax = double_int_sub (max0, min1);\n+\n+\t      if (double_int_cmp (double_int_zero, max1, uns)\n+\t\t  != double_int_cmp (dmin, min0, uns))\n+\t\tmin_ovf = double_int_cmp (min0, max1, uns);\n+\t      if (double_int_cmp (double_int_zero, min1, uns)\n+\t\t  != double_int_cmp (dmax, max0, uns))\n+\t\tmax_ovf = double_int_cmp (max0, min1, uns);\n+\t    }\n+\n+\t  /* For non-wrapping arithmetic look at possibly smaller\n+\t     value-ranges of the type.  */\n+\t  if (!TYPE_OVERFLOW_WRAPS (expr_type))\n+\t    {\n+\t      if (vrp_val_min (expr_type))\n+\t\ttype_min = tree_to_double_int (vrp_val_min (expr_type));\n+\t      if (vrp_val_max (expr_type))\n+\t\ttype_max = tree_to_double_int (vrp_val_max (expr_type));\n+\t    }\n+\n+\t  /* Check for type overflow.  */\n+\t  if (min_ovf == 0)\n+\t    {\n+\t      if (double_int_cmp (dmin, type_min, uns) == -1)\n+\t\tmin_ovf = -1;\n+\t      else if (double_int_cmp (dmin, type_max, uns) == 1)\n+\t\tmin_ovf = 1;\n+\t    }\n+\t  if (max_ovf == 0)\n+\t    {\n+\t      if (double_int_cmp (dmax, type_min, uns) == -1)\n+\t\tmax_ovf = -1;\n+\t      else if (double_int_cmp (dmax, type_max, uns) == 1)\n+\t\tmax_ovf = 1;\n+\t    }\n \n \t  if (TYPE_OVERFLOW_WRAPS (expr_type))\n \t    {\n@@ -2384,21 +2434,15 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\t= double_int_ext (dmin, TYPE_PRECISION (expr_type), uns);\n \t      double_int tmax\n \t\t= double_int_ext (dmax, TYPE_PRECISION (expr_type), uns);\n-\t      gcc_assert (double_int_scmp (dmin, dmax) <= 0);\n-\t      if ((double_int_scmp (dmin, type_min) == -1\n-\t\t   && double_int_scmp (dmax, type_min) == -1)\n-\t\t  || (double_int_scmp (dmin, type_max) == 1\n-\t\t      && double_int_scmp (dmax, type_max) == 1)\n-\t\t  || (double_int_scmp (type_min, dmin) <= 0\n-\t\t      && double_int_scmp (dmax, type_max) <= 0))\n+\t      if (min_ovf == max_ovf)\n \t\t{\n \t\t  /* No overflow or both overflow or underflow.  The\n \t\t     range kind stays VR_RANGE.  */\n \t\t  min = double_int_to_tree (expr_type, tmin);\n \t\t  max = double_int_to_tree (expr_type, tmax);\n \t\t}\n-\t      else if (double_int_scmp (dmin, type_min) == -1\n-\t\t       && double_int_scmp (dmax, type_max) == 1)\n+\t      else if (min_ovf == -1\n+\t\t       && max_ovf == 1)\n \t\t{\n \t\t  /* Underflow and overflow, drop to VR_VARYING.  */\n \t\t  set_value_range_to_varying (vr);\n@@ -2409,12 +2453,8 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\t  /* Min underflow or max overflow.  The range kind\n \t\t     changes to VR_ANTI_RANGE.  */\n \t\t  double_int tem = tmin;\n-\t\t  gcc_assert ((double_int_scmp (dmin, type_min) == -1\n-\t\t\t       && double_int_scmp (dmax, type_min) >= 0\n-\t\t\t       && double_int_scmp (dmax, type_max) <= 0)\n-\t\t\t      || (double_int_scmp (dmax, type_max) == 1\n-\t\t\t\t  && double_int_scmp (dmin, type_min) >= 0\n-\t\t\t\t  && double_int_scmp (dmin, type_max) <= 0));\n+\t\t  gcc_assert ((min_ovf == -1 && max_ovf == 0)\n+\t\t\t      || (max_ovf == 1 && min_ovf == 0));\n \t\t  type = VR_ANTI_RANGE;\n \t\t  tmin = double_int_add (tmax, double_int_one);\n \t\t  tmax = double_int_add (tem, double_int_minus_one);\n@@ -2434,24 +2474,17 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t    }\n \t  else\n \t    {\n-\t      /* For non-wrapping arithmetic look at possibly smaller\n-\t\t value-ranges of the type.  */\n-\t      if (vrp_val_min (expr_type))\n-\t\ttype_min = tree_to_double_int (vrp_val_min (expr_type));\n-\t      if (vrp_val_max (expr_type))\n-\t\ttype_max = tree_to_double_int (vrp_val_max (expr_type));\n-\n \t      /* If overflow does not wrap, saturate to the types min/max\n \t         value.  */\n-\t      if (double_int_scmp (dmin, type_min) == -1)\n+\t      if (min_ovf == -1)\n \t\t{\n \t\t  if (needs_overflow_infinity (expr_type)\n \t\t      && supports_overflow_infinity (expr_type))\n \t\t    min = negative_overflow_infinity (expr_type);\n \t\t  else\n \t\t    min = double_int_to_tree (expr_type, type_min);\n \t\t}\n-\t      else if (double_int_scmp (dmin, type_max) == 1)\n+\t      else if (min_ovf == 1)\n \t\t{\n \t\t  if (needs_overflow_infinity (expr_type)\n \t\t      && supports_overflow_infinity (expr_type))\n@@ -2462,15 +2495,15 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t      else\n \t\tmin = double_int_to_tree (expr_type, dmin);\n \n-\t      if (double_int_scmp (dmax, type_min) == -1)\n+\t      if (max_ovf == -1)\n \t\t{\n \t\t  if (needs_overflow_infinity (expr_type)\n \t\t      && supports_overflow_infinity (expr_type))\n \t\t    max = negative_overflow_infinity (expr_type);\n \t\t  else\n \t\t    max = double_int_to_tree (expr_type, type_min);\n \t\t}\n-\t      else if (double_int_scmp (dmax, type_max) == 1)\n+\t      else if (max_ovf == 1)\n \t\t{\n \t\t  if (needs_overflow_infinity (expr_type)\n \t\t      && supports_overflow_infinity (expr_type))\n@@ -2485,10 +2518,14 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t      && supports_overflow_infinity (expr_type))\n \t    {\n \t      if (is_negative_overflow_infinity (vr0.min)\n-\t\t  || is_negative_overflow_infinity (vr1.min))\n+\t\t  || (code == PLUS_EXPR\n+\t\t      ? is_negative_overflow_infinity (vr1.min)\n+\t\t      : is_positive_overflow_infinity (vr1.max)))\n \t\tmin = negative_overflow_infinity (expr_type);\n \t      if (is_positive_overflow_infinity (vr0.max)\n-\t\t  || is_positive_overflow_infinity (vr1.max))\n+\t\t  || (code == PLUS_EXPR\n+\t\t      ? is_positive_overflow_infinity (vr1.max)\n+\t\t      : is_negative_overflow_infinity (vr1.min)))\n \t\tmax = positive_overflow_infinity (expr_type);\n \t    }\n \t}\n@@ -2717,26 +2754,6 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n       else\n \tmin = fold_unary_to_constant (NEGATE_EXPR, expr_type, max);\n     }\n-  else if (code == MINUS_EXPR)\n-    {\n-      /* If we have a MINUS_EXPR with two VR_ANTI_RANGEs, drop to\n-\t VR_VARYING.  It would take more effort to compute a precise\n-\t range for such a case.  For example, if we have op0 == 1 and\n-\t op1 == 1 with their ranges both being ~[0,0], we would have\n-\t op0 - op1 == 0, so we cannot claim that the difference is in\n-\t ~[0,0].  Note that we are guaranteed to have\n-\t vr0.type == vr1.type at this point.  */\n-      if (vr0.type == VR_ANTI_RANGE)\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n-      /* For MINUS_EXPR, apply the operation to the opposite ends of\n-\t each range.  */\n-      min = vrp_int_const_binop (code, vr0.min, vr1.max);\n-      max = vrp_int_const_binop (code, vr0.max, vr1.min);\n-    }\n   else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR)\n     {\n       bool int_cst_range0, int_cst_range1;"}]}