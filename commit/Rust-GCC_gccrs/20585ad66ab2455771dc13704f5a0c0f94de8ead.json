{"sha": "20585ad66ab2455771dc13704f5a0c0f94de8ead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA1ODVhZDY2YWIyNDU1NzcxZGMxMzcwNGY1YTBjMGY5NGRlOGVhZA==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2007-05-28T18:20:29Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-05-28T18:20:29Z"}, "message": "gfortran.h (gfc_expr): Remove from_H, add \"representation\" struct.\n\n* gfortran.h (gfc_expr): Remove from_H, add \"representation\"\nstruct.\n* primary.c (match_hollerith_constant): Store the representation\nof the Hollerith in representation, not in value.character.\n* arith.c: Add dependency on target-memory.h.\n(eval_intrinsic): Remove check for from_H.\n(hollerith2representation): New function.\n(gfc_hollerith2int): Determine value of the new constant.\n(gfc_hollerith2real): Likewise.\n(gfc_hollerith2complex): Likewise.\n(gfc_hollerith2logical): Likewise.\n(gfc_hollerith2character): Point both representation.string and\nvalue.character.string at the value string.\n* data.c (create_character_initializer): For BT_HOLLERITH\nrvalues, get the value from the representation rather than\nvalue.character.\n* expr.c (free_expr0): Update handling of BT_HOLLERITH values\nand values with representation.string.\n(gfc_copy_expr): Likewise.\n* intrinsic.c (do_simplify): Remove special treatement of\nvariables resulting from Hollerith constants.\n* dump-parse-trees.c (gfc_show_expr): Update handling of\nHolleriths.\n* trans-const.c (gfc_conv_constant_to_tree): Replace from_H\ncheck with check for representation.string; get Hollerith\nrepresentation from representation.string, not value.character.\n* trans-expr.c (is_zero_initializer_p): Replace from_H check\nwith check for representation.string.\n* trans-stmt.c (gfc_trans_integer_select): Use\ngfc_conv_mpz_to_tree for case values, so as to avoid picking up\nthe memory representation if the case is given by a transfer\nexpression.\n* target-memory.c (gfc_target_encode_expr): Use the known memory\nrepresentation rather than the value, if it exists.\n(gfc_target_interpret_expr): Store the memory representation of\nthe interpreted expression as well as its value.\n(interpret_integer): Move to gfc_interpret_integer, make\nnon-static.\n(interpret_float): Move to gfc_interpret_float, make non-static.\n(interpret_complex): Move to gfc_interpret_complex, make\nnon-static.\n(interpret_logical): Move to gfc_interpret_logical, make\nnon-static.\n(interpret_character): Move to gfc_interpret_character, make\nnon-static.\n(interpret_derived): Move to gfc_interpret_derived, make\nnon-static.\n* target-memory.h: Add prototypes for newly-exported\ngfc_interpret_* functions.\n\nFrom-SVN: r125135", "tree": {"sha": "285e1933957cc1ea01f2d184aeb1656b76b6b3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/285e1933957cc1ea01f2d184aeb1656b76b6b3cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20585ad66ab2455771dc13704f5a0c0f94de8ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20585ad66ab2455771dc13704f5a0c0f94de8ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20585ad66ab2455771dc13704f5a0c0f94de8ead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20585ad66ab2455771dc13704f5a0c0f94de8ead/comments", "author": null, "committer": null, "parents": [{"sha": "0258dc3a2c897ba06499af1493aac7e736adbbb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0258dc3a2c897ba06499af1493aac7e736adbbb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0258dc3a2c897ba06499af1493aac7e736adbbb9"}], "stats": {"total": 459, "additions": 287, "deletions": 172}, "files": [{"sha": "e1265a6353119284984909fb4bab4feb4e8c9347", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -1,3 +1,55 @@\n+2007-05-27  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\t* gfortran.h (gfc_expr): Remove from_H, add \"representation\"\n+\tstruct.\n+\t* primary.c (match_hollerith_constant): Store the representation\n+ \tof the Hollerith in representation, not in value.character.\n+\t* arith.c: Add dependency on target-memory.h.\n+\t(eval_intrinsic): Remove check for from_H.\n+\t(hollerith2representation): New function.\n+\t(gfc_hollerith2int): Determine value of the new constant.\n+\t(gfc_hollerith2real): Likewise.\n+\t(gfc_hollerith2complex): Likewise.\n+\t(gfc_hollerith2logical): Likewise.\n+\t(gfc_hollerith2character): Point both representation.string and\n+\tvalue.character.string at the value string.\n+\t* data.c (create_character_initializer): For BT_HOLLERITH\n+\trvalues, get the value from the representation rather than\n+\tvalue.character.\n+\t* expr.c (free_expr0): Update handling of BT_HOLLERITH values\n+\tand values with representation.string.\n+\t(gfc_copy_expr): Likewise.\n+\t* intrinsic.c (do_simplify): Remove special treatement of\n+\tvariables resulting from Hollerith constants.\n+\t* dump-parse-trees.c (gfc_show_expr): Update handling of\n+\tHolleriths.\n+\t* trans-const.c (gfc_conv_constant_to_tree): Replace from_H\n+\tcheck with check for representation.string; get Hollerith\n+\trepresentation from representation.string, not value.character.\n+\t* trans-expr.c (is_zero_initializer_p): Replace from_H check\n+\twith check for representation.string.\n+\t* trans-stmt.c (gfc_trans_integer_select): Use\n+\tgfc_conv_mpz_to_tree for case values, so as to avoid picking up\n+\tthe memory representation if the case is given by a transfer\n+\texpression.\n+\t* target-memory.c (gfc_target_encode_expr): Use the known memory\n+\trepresentation rather than the value, if it exists.\n+\t(gfc_target_interpret_expr): Store the memory representation of\n+\tthe interpreted expression as well as its value.\n+\t(interpret_integer): Move to gfc_interpret_integer, make\n+\tnon-static.\n+\t(interpret_float): Move to gfc_interpret_float, make non-static.\n+\t(interpret_complex): Move to gfc_interpret_complex, make\n+\tnon-static.\n+\t(interpret_logical): Move to gfc_interpret_logical, make\n+\tnon-static.\n+\t(interpret_character): Move to gfc_interpret_character, make\n+\tnon-static.\n+\t(interpret_derived): Move to gfc_interpret_derived, make\n+\tnon-static.\n+\t* target-memory.h: Add prototypes for newly-exported\n+\tgfc_interpret_* functions.\n+\n 2007-05-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/31812"}, {"sha": "9d8428ddca00e04b76fc4879e8123add18eebd80", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 53, "deletions": 74, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"flags.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"\n+#include \"target-memory.h\"\n \n /* MPFR does not have a direct replacement for mpz_set_f() from GMP.\n    It's easily implemented with a few calls though.  */\n@@ -1613,17 +1614,15 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   if (operator == INTRINSIC_POWER && op2->ts.type != BT_INTEGER)\n     goto runtime;\n \n-  if (op1->from_H\n-      || (op1->expr_type != EXPR_CONSTANT\n-\t  && (op1->expr_type != EXPR_ARRAY\n-\t      || !gfc_is_constant_expr (op1) || !gfc_expanded_ac (op1))))\n+  if (op1->expr_type != EXPR_CONSTANT\n+      && (op1->expr_type != EXPR_ARRAY\n+\t  || !gfc_is_constant_expr (op1) || !gfc_expanded_ac (op1)))\n     goto runtime;\n \n   if (op2 != NULL\n-      && (op2->from_H\n-\t  || (op2->expr_type != EXPR_CONSTANT\n-\t      && (op2->expr_type != EXPR_ARRAY\n-\t\t  || !gfc_is_constant_expr (op2) || !gfc_expanded_ac (op2)))))\n+      && op2->expr_type != EXPR_CONSTANT\n+\t && (op2->expr_type != EXPR_ARRAY\n+\t     || !gfc_is_constant_expr (op2) || !gfc_expanded_ac (op2)))\n     goto runtime;\n \n   if (unary)\n@@ -2307,37 +2306,52 @@ gfc_int2log (gfc_expr *src, int kind)\n }\n \n \n+/* Helper function to set the representation in a Hollerith conversion.  \n+   This assumes that the ts.type and ts.kind of the result have already\n+   been set.  */\n+\n+static void\n+hollerith2representation (gfc_expr *result, gfc_expr *src)\n+{\n+  int src_len, result_len;\n+\n+  src_len = src->representation.length;\n+  result_len = gfc_target_expr_size (result);\n+\n+  if (src_len > result_len)\n+    {\n+      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n+\t\t   &src->where, gfc_typename(&result->ts));\n+    }\n+\n+  result->representation.string = gfc_getmem (result_len + 1);\n+  memcpy (result->representation.string, src->representation.string,\n+\tMIN (result_len, src_len));\n+\n+  if (src_len < result_len)\n+    memset (&result->representation.string[src_len], ' ', result_len - src_len);\n+\n+  result->representation.string[result_len] = '\\0'; /* For debugger  */\n+  result->representation.length = result_len;\n+}\n+\n+\n /* Convert Hollerith to integer. The constant will be padded or truncated.  */\n \n gfc_expr *\n gfc_hollerith2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n-  int len;\n-\n-  len = src->value.character.length;\n \n   result = gfc_get_expr ();\n   result->expr_type = EXPR_CONSTANT;\n   result->ts.type = BT_INTEGER;\n   result->ts.kind = kind;\n   result->where = src->where;\n-  result->from_H = 1;\n-\n-  if (len > kind)\n-    {\n-      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t   &src->where, gfc_typename(&result->ts));\n-    }\n-  result->value.character.string = gfc_getmem (kind + 1);\n-  memcpy (result->value.character.string, src->value.character.string,\n-\tMIN (kind, len));\n-\n-  if (len < kind)\n-    memset (&result->value.character.string[len], ' ', kind - len);\n \n-  result->value.character.string[kind] = '\\0'; /* For debugger  */\n-  result->value.character.length = kind;\n+  hollerith2representation (result, src);\n+  gfc_interpret_integer(kind, (unsigned char *) result->representation.string,\n+\t\t\tresult->representation.length, result->value.integer);\n \n   return result;\n }\n@@ -2358,22 +2372,10 @@ gfc_hollerith2real (gfc_expr *src, int kind)\n   result->ts.type = BT_REAL;\n   result->ts.kind = kind;\n   result->where = src->where;\n-  result->from_H = 1;\n \n-  if (len > kind)\n-    {\n-      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t   &src->where, gfc_typename(&result->ts));\n-    }\n-  result->value.character.string = gfc_getmem (kind + 1);\n-  memcpy (result->value.character.string, src->value.character.string,\n-\tMIN (kind, len));\n-\n-  if (len < kind)\n-    memset (&result->value.character.string[len], ' ', kind - len);\n-\n-  result->value.character.string[kind] = '\\0'; /* For debugger.  */\n-  result->value.character.length = kind;\n+  hollerith2representation (result, src);\n+  gfc_interpret_float(kind, (unsigned char *) result->representation.string,\n+\t\t      result->representation.length, result->value.real);\n \n   return result;\n }\n@@ -2394,24 +2396,11 @@ gfc_hollerith2complex (gfc_expr *src, int kind)\n   result->ts.type = BT_COMPLEX;\n   result->ts.kind = kind;\n   result->where = src->where;\n-  result->from_H = 1;\n-\n-  kind = kind * 2;\n-\n-  if (len > kind)\n-    {\n-      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t   &src->where, gfc_typename(&result->ts));\n-    }\n-  result->value.character.string = gfc_getmem (kind + 1);\n-  memcpy (result->value.character.string, src->value.character.string,\n-\t  MIN (kind, len));\n \n-  if (len < kind)\n-    memset (&result->value.character.string[len], ' ', kind - len);\n-\n-  result->value.character.string[kind] = '\\0'; /* For debugger  */\n-  result->value.character.length = kind;\n+  hollerith2representation (result, src);\n+  gfc_interpret_complex(kind, (unsigned char *) result->representation.string,\n+\t\t\tresult->representation.length, result->value.complex.r,\n+\t\t\tresult->value.complex.i);\n \n   return result;\n }\n@@ -2427,7 +2416,9 @@ gfc_hollerith2character (gfc_expr *src, int kind)\n   result = gfc_copy_expr (src);\n   result->ts.type = BT_CHARACTER;\n   result->ts.kind = kind;\n-  result->from_H = 1;\n+\n+  result->value.character.string = result->representation.string;\n+  result->value.character.length = result->representation.length;\n \n   return result;\n }\n@@ -2448,22 +2439,10 @@ gfc_hollerith2logical (gfc_expr *src, int kind)\n   result->ts.type = BT_LOGICAL;\n   result->ts.kind = kind;\n   result->where = src->where;\n-  result->from_H = 1;\n-\n-  if (len > kind)\n-    {\n-      gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t   &src->where, gfc_typename(&result->ts));\n-    }\n-  result->value.character.string = gfc_getmem (kind + 1);\n-  memcpy (result->value.character.string, src->value.character.string,\n-\tMIN (kind, len));\n-\n-  if (len < kind)\n-    memset (&result->value.character.string[len], ' ', kind - len);\n \n-  result->value.character.string[kind] = '\\0'; /* For debugger  */\n-  result->value.character.length = kind;\n+  hollerith2representation (result, src);\n+  gfc_interpret_logical(kind, (unsigned char *) result->representation.string,\n+\t\t\tresult->representation.length, &result->value.logical);\n \n   return result;\n }"}, {"sha": "75e4241e059da842b87de176ca63d43f37038a80", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -154,7 +154,7 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n   int len;\n   int start;\n   int end;\n-  char *dest;\n+  char *dest, *rvalue_string;\n \t    \n   gfc_extract_int (ts->cl->length, &len);\n \n@@ -207,22 +207,35 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n     }\n \n   /* Copy the initial value.  */\n-  len = rvalue->value.character.length;\n+  if (rvalue->ts.type == BT_HOLLERITH)\n+    {\n+      len = rvalue->representation.length;\n+      rvalue_string = rvalue->representation.string;\n+    }\n+  else\n+    {\n+      len = rvalue->value.character.length;\n+      rvalue_string = rvalue->value.character.string;\n+    }\n+\n   if (len > end - start)\n     {\n       len = end - start;\n       gfc_warning_now (\"initialization string truncated to match variable \"\n \t\t       \"at %L\", &rvalue->where);\n     }\n \n-  memcpy (&dest[start], rvalue->value.character.string, len);\n+  memcpy (&dest[start], rvalue_string, len);\n \n   /* Pad with spaces.  Substrings will already be blanked.  */\n   if (len < end - start && ref == NULL)\n     memset (&dest[start + len], ' ', end - (start + len));\n \n   if (rvalue->ts.type == BT_HOLLERITH)\n-    init->from_H = 1;\n+    {\n+      init->representation.length = init->value.character.length;\n+      init->representation.string = init->value.character.string;\n+    }\n \n   return init;\n }"}, {"sha": "51af1c401f2152e91a3e1235d4bbbd5427921930", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -340,16 +340,6 @@ gfc_show_expr (gfc_expr *p)\n       break;\n \n     case EXPR_CONSTANT:\n-      if (p->from_H || p->ts.type == BT_HOLLERITH)\n-\t{\n-\t  gfc_status (\"%dH\", p->value.character.length);\n-\t  c = p->value.character.string;\n-\t  for (i = 0; i < p->value.character.length; i++, c++)\n-\t    {\n-\t      gfc_status_char (*c);\n-\t    }\n-\t  break;\n-\t}\n       switch (p->ts.type)\n \t{\n \tcase BT_INTEGER:\n@@ -405,11 +395,33 @@ gfc_show_expr (gfc_expr *p)\n \t  gfc_status (\")\");\n \t  break;\n \n+\tcase BT_HOLLERITH:\n+\t  gfc_status (\"%dH\", p->representation.length);\n+\t  c = p->representation.string;\n+\t  for (i = 0; i < p->representation.length; i++, c++)\n+\t    {\n+\t      gfc_status_char (*c);\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  gfc_status (\"???\");\n \t  break;\n \t}\n \n+      if (p->representation.string)\n+\t{\n+\t  gfc_status (\" {\");\n+\t  c = p->representation.string;\n+\t  for (i = 0; i < p->representation.length; i++, c++)\n+\t    {\n+\t      gfc_status (\"%.2x\", (unsigned int) *c);\n+\t      if (i < p->representation.length - 1)\n+\t\tgfc_status_char (',');\n+\t    }\n+\t  gfc_status_char ('}');\n+\t}\n+\n       break;\n \n     case EXPR_VARIABLE:"}, {"sha": "849b406ea457b82655f5abc7d31e19e1e5504258", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -140,12 +140,7 @@ free_expr0 (gfc_expr *e)\n   switch (e->expr_type)\n     {\n     case EXPR_CONSTANT:\n-      if (e->from_H)\n-\t{\n-\t  gfc_free (e->value.character.string);\n-\t  break;\n-\t}\n-\n+      /* Free any parts of the value that need freeing.  */\n       switch (e->ts.type)\n \t{\n \tcase BT_INTEGER:\n@@ -157,7 +152,6 @@ free_expr0 (gfc_expr *e)\n \t  break;\n \n \tcase BT_CHARACTER:\n-\tcase BT_HOLLERITH:\n \t  gfc_free (e->value.character.string);\n \t  break;\n \n@@ -170,6 +164,11 @@ free_expr0 (gfc_expr *e)\n \t  break;\n \t}\n \n+      /* Free the representation, except in character constants where it\n+\t is the same as value.character.string and thus already freed.  */\n+      if (e->representation.string && e->ts.type != BT_CHARACTER)\n+\tgfc_free (e->representation.string);\n+\n       break;\n \n     case EXPR_OP:\n@@ -413,14 +412,16 @@ gfc_copy_expr (gfc_expr *p)\n       break;\n \n     case EXPR_CONSTANT:\n-      if (p->from_H)\n+      /* Copy target representation, if it exists.  */\n+      if (p->representation.string)\n \t{\n-\t  s = gfc_getmem (p->value.character.length + 1);\n-\t  q->value.character.string = s;\n+\t  s = gfc_getmem (p->representation.length + 1);\n+\t  q->representation.string = s;\n \n-\t  memcpy (s, p->value.character.string, p->value.character.length + 1);\n-\t  break;\n+\t  memcpy (s, p->representation.string, p->representation.length + 1);\n \t}\n+\n+      /* Copy the values of any pointer components of p->value.  */\n       switch (q->ts.type)\n \t{\n \tcase BT_INTEGER:\n@@ -442,13 +443,18 @@ gfc_copy_expr (gfc_expr *p)\n \t  break;\n \n \tcase BT_CHARACTER:\n-\tcase BT_HOLLERITH:\n-\t  s = gfc_getmem (p->value.character.length + 1);\n-\t  q->value.character.string = s;\n+\t  if (p->representation.string)\n+\t    q->value.character.string = q->representation.string;\n+\t  else\n+\t    {\n+\t      s = gfc_getmem (p->value.character.length + 1);\n+\t      q->value.character.string = s;\n \n-\t  memcpy (s, p->value.character.string, p->value.character.length + 1);\n+\t      memcpy (s, p->value.character.string, p->value.character.length + 1);\n+\t    }\n \t  break;\n \n+\tcase BT_HOLLERITH:\n \tcase BT_LOGICAL:\n \tcase BT_DERIVED:\n \t  break;\t\t/* Already done */"}, {"sha": "c7fa5f8403c46a52cb9fa57716bc89a0141f042b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -1290,17 +1290,28 @@ typedef struct gfc_expr\n \n   locus where;\n \n-  /* True if it is converted from Hollerith constant.  */\n-  unsigned int from_H : 1;\n   /* True if the expression is a call to a function that returns an array,\n      and if we have decided not to allocate temporary data for that array.  */\n   unsigned int inline_noncopying_intrinsic : 1;\n-  /* Used to quickly find a given constructor by it's offset.  */\n+\n+  /* Used to quickly find a given constructor by its offset.  */\n   splay_tree con_by_offset;\n \n+  /* If an expression comes from a Hollerith constant or compile-time\n+     evaluation of a transfer statement, it may have a prescribed target-\n+     memory representation, and these cannot always be backformed from\n+     the value.  */\n+  struct\n+  {\n+    int length;\n+    char *string;\n+  }\n+  representation;\n+\n   union\n   {\n     int logical;\n+\n     mpz_t integer;\n \n     mpfr_t real;"}, {"sha": "d3392b085c3022e6fbca4cdbc29af28365daca2c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -3065,16 +3065,6 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n   gfc_expr *result, *a1, *a2, *a3, *a4, *a5;\n   gfc_actual_arglist *arg;\n \n-  /* Check the arguments if there are Hollerith constants. We deal with\n-     them at run-time.  */\n-  for (arg = e->value.function.actual; arg != NULL; arg = arg->next)\n-    {\n-      if (arg->expr && arg->expr->from_H)\n-\t{\n-\t  result = NULL;\n-\t  goto finish;\n-\t}\n-    }\n   /* Max and min require special handling due to the variable number\n      of args.  */\n   if (specific->simplify.f1 == gfc_simplify_min)"}, {"sha": "ce81f44fd2d1da36a3c594e29222088ad7911a6b", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -236,7 +236,6 @@ match_hollerith_constant (gfc_expr **result)\n   locus old_loc;\n   gfc_expr *e = NULL;\n   const char *msg;\n-  char *buffer;\n   int num;\n   int i;  \n \n@@ -270,18 +269,18 @@ match_hollerith_constant (gfc_expr **result)\n \t}\n       else\n \t{\n-\t  buffer = (char *) gfc_getmem (sizeof(char) * num + 1);\n-\t  for (i = 0; i < num; i++)\n-\t    {\n-\t      buffer[i] = gfc_next_char_literal (1);\n-\t    }\n \t  gfc_free_expr (e);\n \t  e = gfc_constant_result (BT_HOLLERITH, gfc_default_character_kind,\n \t\t\t\t   &gfc_current_locus);\n-\t  e->value.character.string = gfc_getmem (num + 1);\n-\t  memcpy (e->value.character.string, buffer, num);\n-\t  e->value.character.string[num] = '\\0';\n-\t  e->value.character.length = num;\n+\n+\t  e->representation.string = gfc_getmem (num + 1);\n+\t  for (i = 0; i < num; i++)\n+\t    {\n+\t      e->representation.string[i] = gfc_next_char_literal (1);\n+\t    }\n+\t  e->representation.string[num] = '\\0';\n+\t  e->representation.length = num;\n+\n \t  *result = e;\n \t  return MATCH_YES;\n \t}"}, {"sha": "194bc0bc52da48b7dd7e5487def283c60df93643", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 66, "deletions": 26, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -220,6 +220,15 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n   gcc_assert (source->expr_type == EXPR_CONSTANT\n \t      || source->expr_type == EXPR_STRUCTURE);\n \n+  /* If we already have a target-memory representation, we use that rather \n+     than recreating one.  */\n+  if (source->representation.string)\n+    {\n+      memcpy (buffer, source->representation.string,\n+\t      source->representation.length);\n+      return source->representation.length;\n+    }\n+\n   switch (source->ts.type)\n     {\n     case BT_INTEGER:\n@@ -289,8 +298,8 @@ interpret_array (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n }\n \n \n-static int\n-interpret_integer (int kind, unsigned char *buffer, size_t buffer_size,\n+int\n+gfc_interpret_integer (int kind, unsigned char *buffer, size_t buffer_size,\n \t\t   mpz_t integer)\n {\n   mpz_init (integer);\n@@ -301,8 +310,8 @@ interpret_integer (int kind, unsigned char *buffer, size_t buffer_size,\n }\n \n \n-static int\n-interpret_float (int kind, unsigned char *buffer, size_t buffer_size,\n+int\n+gfc_interpret_float (int kind, unsigned char *buffer, size_t buffer_size,\n \t\t mpfr_t real)\n {\n   mpfr_init (real);\n@@ -314,19 +323,19 @@ interpret_float (int kind, unsigned char *buffer, size_t buffer_size,\n }\n \n \n-static int\n-interpret_complex (int kind, unsigned char *buffer, size_t buffer_size,\n+int\n+gfc_interpret_complex (int kind, unsigned char *buffer, size_t buffer_size,\n \t\t   mpfr_t real, mpfr_t imaginary)\n {\n   int size;\n-  size = interpret_float (kind, &buffer[0], buffer_size, real);\n-  size += interpret_float (kind, &buffer[size], buffer_size - size, imaginary);\n+  size = gfc_interpret_float (kind, &buffer[0], buffer_size, real);\n+  size += gfc_interpret_float (kind, &buffer[size], buffer_size - size, imaginary);\n   return size;\n }\n \n \n-static int\n-interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n+int\n+gfc_interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n \t\t   int *logical)\n {\n   tree t = native_interpret_expr (gfc_get_logical_type (kind), buffer,\n@@ -337,8 +346,8 @@ interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n }\n \n \n-static int\n-interpret_character (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n+int\n+gfc_interpret_character (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n {\n   if (result->ts.cl && result->ts.cl->length)\n     result->value.character.length =\n@@ -355,8 +364,8 @@ interpret_character (unsigned char *buffer, size_t buffer_size, gfc_expr *result\n }\n \n \n-static int\n-interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n+int\n+gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n {\n   gfc_component *cmp;\n   gfc_constructor *head = NULL, *tail = NULL;\n@@ -428,24 +437,55 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n   switch (result->ts.type)\n     {\n     case BT_INTEGER:\n-      return interpret_integer (result->ts.kind, buffer, buffer_size,\n-\t\t\t\tresult->value.integer);\n+      result->representation.length = \n+        gfc_interpret_integer (result->ts.kind, buffer, buffer_size,\n+\t\t\t       result->value.integer);\n+      break;\n+\n     case BT_REAL:\n-      return interpret_float (result->ts.kind, buffer, buffer_size,\n-\t\t\t      result->value.real);\n+      result->representation.length = \n+        gfc_interpret_float (result->ts.kind, buffer, buffer_size,\n+    \t\t\t     result->value.real);\n+      break;\n+\n     case BT_COMPLEX:\n-      return interpret_complex (result->ts.kind, buffer, buffer_size,\n-\t\t\t\tresult->value.complex.r,\n-\t\t\t\tresult->value.complex.i);\n+      result->representation.length = \n+        gfc_interpret_complex (result->ts.kind, buffer, buffer_size,\n+\t\t\t       result->value.complex.r,\n+\t\t\t       result->value.complex.i);\n+      break;\n+\n     case BT_LOGICAL:\n-      return interpret_logical (result->ts.kind, buffer, buffer_size,\n-\t\t\t\t&result->value.logical);\n+      result->representation.length = \n+        gfc_interpret_logical (result->ts.kind, buffer, buffer_size,\n+\t\t\t       &result->value.logical);\n+      break;\n+\n     case BT_CHARACTER:\n-      return interpret_character (buffer, buffer_size, result);\n+      result->representation.length = \n+        gfc_interpret_character (buffer, buffer_size, result);\n+      break;\n+\n     case BT_DERIVED:\n-      return interpret_derived (buffer, buffer_size, result);\n+      result->representation.length = \n+        gfc_interpret_derived (buffer, buffer_size, result);\n+      break;\n+\n     default:\n       gfc_internal_error (\"Invalid expression in gfc_target_interpret_expr.\");\n+      break;\n+    }\n+\n+  if (result->ts.type == BT_CHARACTER)\n+    result->representation.string = result->value.character.string;\n+  else\n+    {\n+      result->representation.string =\n+        gfc_getmem (result->representation.length + 1);\n+      memcpy (result->representation.string, buffer,\n+\t      result->representation.length);\n+      result->representation.string[result->representation.length] = '\\0';\n     }\n-  return 0;\n+\n+  return result->representation.length;\n }"}, {"sha": "8e35e69bd0ba11cd16b84284f6d99c35412b69aa", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -32,6 +32,13 @@ size_t gfc_target_expr_size (gfc_expr *);\n int gfc_target_encode_expr (gfc_expr *, unsigned char *, size_t);\n \n /* Read a target buffer into a constant expression.  */\n+\n+int gfc_interpret_integer (int, unsigned char *, size_t, mpz_t);\n+int gfc_interpret_float (int, unsigned char *, size_t, mpfr_t);\n+int gfc_interpret_complex (int, unsigned char *, size_t, mpfr_t, mpfr_t);\n+int gfc_interpret_logical (int, unsigned char *, size_t, int *);\n+int gfc_interpret_character (unsigned char *, size_t, gfc_expr *);\n+int gfc_interpret_derived (unsigned char *, size_t, gfc_expr *);\n int gfc_target_interpret_expr (unsigned char *, size_t, gfc_expr *);\n \n #endif /* GFC_TARGET_MEMORY_H  */"}, {"sha": "24aa809be5a27420fcdcf49e2f2c2022644c2752", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -209,45 +209,45 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n {\n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n-  /* If it is converted from Hollerith constant, we build string constant\n-     and VIEW_CONVERT to its type.  */\n+  /* If it is has a prescribed memory representation, we build a string\n+     constant and VIEW_CONVERT to its type.  */\n  \n   switch (expr->ts.type)\n     {\n     case BT_INTEGER:\n-      if (expr->from_H)\n+      if (expr->representation.string)\n \treturn build1 (VIEW_CONVERT_EXPR,\n \t\t\tgfc_get_int_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->value.character.length,\n-\t\t\t\texpr->value.character.string));\n+\t\t\tgfc_build_string_const (expr->representation.length,\n+\t\t\t\texpr->representation.string));\n       else\n \treturn gfc_conv_mpz_to_tree (expr->value.integer, expr->ts.kind);\n \n     case BT_REAL:\n-      if (expr->from_H)\n+      if (expr->representation.string)\n \treturn build1 (VIEW_CONVERT_EXPR,\n \t\t\tgfc_get_real_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->value.character.length,\n-\t\t\t\texpr->value.character.string));\n+\t\t\tgfc_build_string_const (expr->representation.length,\n+\t\t\t\texpr->representation.string));\n       else\n \treturn gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind);\n \n     case BT_LOGICAL:\n-      if (expr->from_H)\n+      if (expr->representation.string)\n \treturn build1 (VIEW_CONVERT_EXPR,\n \t\t\tgfc_get_logical_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->value.character.length,\n-\t\t\t\texpr->value.character.string));\n+\t\t\tgfc_build_string_const (expr->representation.length,\n+\t\t\t\texpr->representation.string));\n       else\n \treturn build_int_cst (gfc_get_logical_type (expr->ts.kind),\n \t\t\t    expr->value.logical);\n \n     case BT_COMPLEX:\n-      if (expr->from_H)\n+      if (expr->representation.string)\n \treturn build1 (VIEW_CONVERT_EXPR,\n \t\t\tgfc_get_complex_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->value.character.length,\n-\t\t\t\texpr->value.character.string));\n+\t\t\tgfc_build_string_const (expr->representation.length,\n+\t\t\t\texpr->representation.string));\n       else\n \t{\n \t  tree real = gfc_conv_mpfr_to_tree (expr->value.complex.r,\n@@ -260,10 +260,13 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n \t}\n \n     case BT_CHARACTER:\n-    case BT_HOLLERITH:\n       return gfc_build_string_const (expr->value.character.length,\n \t\t\t\t     expr->value.character.string);\n \n+    case BT_HOLLERITH:\n+      return gfc_build_string_const (expr->representation.length,\n+\t\t\t\t     expr->representation.string);\n+\n     default:\n       fatal_error (\"gfc_conv_constant_to_tree(): invalid type: %s\",\n \t\t   gfc_typename (&expr->ts));"}, {"sha": "c8f801262e248a6b3362e653b35150bcccd5f219", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -3567,8 +3567,9 @@ is_zero_initializer_p (gfc_expr * expr)\n {\n   if (expr->expr_type != EXPR_CONSTANT)\n     return false;\n-  /* We ignore Hollerith constants for the time being.  */\n-  if (expr->from_H)\n+\n+  /* We ignore constants with prescribed memory representations for now.  */\n+  if (expr->representation.string)\n     return false;\n \n   switch (expr->ts.type)"}, {"sha": "b1cd029280d3736c3cbedce4d70e9e226b6c7d53", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20585ad66ab2455771dc13704f5a0c0f94de8ead/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=20585ad66ab2455771dc13704f5a0c0f94de8ead", "patch": "@@ -1139,7 +1139,8 @@ gfc_trans_integer_select (gfc_code * code)\n \n \t  if (cp->low)\n \t    {\n-\t      low = gfc_conv_constant_to_tree (cp->low);\n+\t      low = gfc_conv_mpz_to_tree (cp->low->value.integer,\n+\t\t\t\t\t  cp->low->ts.kind);\n \n \t      /* If there's only a lower bound, set the high bound to the\n \t\t maximum value of the case expression.  */\n@@ -1169,7 +1170,8 @@ gfc_trans_integer_select (gfc_code * code)\n \t\t  || (cp->low\n \t\t      && mpz_cmp (cp->low->value.integer,\n \t\t\t\t  cp->high->value.integer) != 0))\n-\t\thigh = gfc_conv_constant_to_tree (cp->high);\n+\t\thigh = gfc_conv_mpz_to_tree (cp->high->value.integer,\n+\t\t\t\t\t     cp->high->ts.kind);\n \n \t      /* Unbounded case.  */\n \t      if (!cp->low)"}]}