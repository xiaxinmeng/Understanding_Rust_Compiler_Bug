{"sha": "dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJiZjg4ZDFiODFhNzFjNTM3NmZiNGRiZjBlOTUyY2I3ODM0ZGNjNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-02-20T17:51:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-02-20T17:51:46Z"}, "message": "Change base class access representation.\n\n\t* tree.h (TREE_VIA_PUBLIC, TREE_VIA_PROTECTED,\n\tTREE_VIA_PRIVATE): Remove.\n\t(BINFO_BASEACCESSES): New binfo elt.\n\t(BINFO_BASEACCESS): New accessor.\n\t(BINFO_ELTS): Increase.\n\t(TI_ACCESS_PUBLIC, TI_ACCESS_PROTECTED, TI_ACCESS_PRIVATE): New.\n\t(access_public_node, access_protected_node,\n\taccess_private_node): New global nodes.\n\t* tree.c (build_common_tree_nodes_2): Initialize access nodes.\n\t* dbxout.c (dbxout_type): Adjust.\n\t* dwarf2out.c (gen_inheritance_die): Add access parameter.\n\t(gen_member_die): Adjust.\n\t* dwarfout.c (output_inheritance_die): ARG is array of two trees.\n\t(output_type): Adjust.\n\t* tree-dump.c (dequeue_and_dump): Adjust binfo dumping.\n\n\tChange base class access representation. Share virtual base\n\tbinfos.\n\t* cp/call.c (build_special_member_call): Remove binfo_for_vbase\n\tcall.\n\t* cp/class.c (build_base_path): Likewise.\n\t(build_primary_vtable): Adjust BINFO_NEW_VTABLE_MARKED use.\n\t(build_secondary_vtable): Remove FOR_TYPE arg. Adjust.\n\t(make_new_vtable): Adjust.\n\t(force_canonical_binfo_r): Delete.\n\t(force_canonical_binfo): Delete.\n\t(mark_primary_virtual_base): Delete.\n\t(dfs_unshared_virtual_bases): Delete.\n\t(mark_primary_bases): Adjust.\n\t(maybe_warn_about_overly_private_class): Adjust.\n\t(dfs_base_derived_from): Delete.\n\t(base_derived_from): Follow the inheritance chain.\n\t(struct find_final_overrider_data): Add vpath member.\n\t(dfs_find_final_overrider): Adjust.\n\t(dfs_find_final_overrider_q, dfs_find_final_overrider_post): New.\n\t(find_final_overrider): Adjust.\n\t(update_vtable_entry_for_fn): Adjust.\n\t(modify_all_vtables): Adjust.\n\t(walk_subobject_offsets): Adjust.\n\t(layout_nonempty_base_or_field): Adjust.\n\t(layout_empty_base): Remove last parameter. Adjust.\n\t(build_base_field): Adjust.\n\t(build_base_fields): Adjust.\n\t(propagate_binfo_offsets): Remove last parameter. Adjust.\n\t(dfs_set_offset_for_unshared_vbases): Delete.\n\t(layout_virtual_bases): Adjust.\n\t(finish_struct_1): Adjust.\n\t(init_class_processing): Don't init access nodes.\n\t(dfs_get_primary_binfo): Delete.\n\t(get_primary_binfo): Adjust.\n\t(dump_class_hierarchy_r): Remove most derived arg, add IGO\n\tparameter. Adjust.\n\t(dump_class_hierarchy): Adjust.\n\t(finish_vtbls): Adjust.\n\t(get_original_base): Delete.\n\t(build_vtt_inits): Adjust.\n\t(dfs_build_secondary_vptr_vtt_inits): Adjust.\n\t(dfs_ctor_vtable_bases_queue_p): Adjust.\n\t(build_ctor_vtbl_group): Adjust.\n\t(dfs_accumulate_vtbl_inits): Adjust.\n\t(build_vtbl_initializer): Adjust.\n\t(build_vbase_offset_vtbl_entries): Adjust.\n\t(add_vcall_offset_vtbl_entries_1): Adjust.\n\t* cp/cp-tree.h (CPTI_ACCESS_*): Remove.\n\t(access_*_node): Remove.\n\t(CANONICAL_BINFO): Delete.\n\t(BINFO_UNSHARED_MARKED): Remove.\n\t(BINFO_MARKED): Set LANG_FLAG_0 directly.\n\t(SET_BINFO_MARKED, CLEAR_BINFO_MARKED): Delete.\n\t(BINFO_VTABLE_PATH_MARKED): Set LANG_FLAG_3 directly.\n\t(SET_BINFO_VTABLE_PATH_MARKED, CLEAR_BINFO_VTABLE_PATH_MARKED):\n\tDelete.\n\t(BINFO_NEW_VTABLE_MARKED): Set LANG_FLAG_4 directly.\n\t(SET_BINFO_NEW_VTABLE_MARKED): Adjust.\n\t(SET_BINFO_PUSHDECLS_MARKED, CLEAR_BINFO_PUSHDECLS_MARKED):\n\tDelete.\n\t(BINFO_DEPENDENT_BASE_P): New.\n\t(dfs_walk, dfs_walk_real): Queue function takes derived binfo and\n\tindex.\n\t(markedp, unmarkedp): Adjust.\n\t(dfs_unmarked_real_bases_queue_p, dfs_marked_real_bases_queue_p,\n\tdfs_skip_vbases, marked_vtable_pathp, unmarked_vtable_pathp,\n\tfind_vbase_instance, binfo_for_vbase): Delete.\n\t(copied_binfo, original_binfo): Declare.\n\t(finish_base_specifier): Add virtual_p arg.\n\t(unshare_base_binfos): Delete.\n\t(copy_base_binfos): Declare.\n\t(reverse_path): Delete.\n\t* cp/decl.c (xref_basetypes): Access and virtuality passed\n\tdifferently. Don't copy direct base binfos here. Call\n\tcopy_base_binfos.\n\t* cp/init.c (dfs_initialize_vtbl_ptrs): Adjust.\n\t(initialize_vtbl_ptrs): Adjust.\n\t(expand_member_init): Adjust.\n\t* cp/parser.c (cp_parser_base_specifier): Adjust.\n\t* cp/pt.c (instantiate_class_template): Adjust.\n\t(get_template_base_recursive): Adjust.\n\t* cp/rtti.c (get_pseudo_ti_init): Adjust.\n\t(get_pseudo_ti_desc): Adjust.\n\t* cp/tree.c (unshare_base_binfos): Rename to ...\n\t(copy_base_binfos): ... here, reimplement.\n\t(make_binfo): Set BINFO_DEPENDENT_BASE_P.\n\t(reverse_path): Remove.\n\t* cp/typeck.c (get_delta_difference): Adjust error messages.\n\t* cp/semantics.c (finish_base_specifier): Add virtual arg, adjust.\n\t* cp/search.c (lookup_base_r): Adjust.\n\t(dynamic_cast_base_recurse): Adjust.\n\t(canonical_binfo): Remove.\n\t(dfs_canonical_queue): Remove.\n\t(dfs_assert_unmarked_p): Remove.\n\t(assert_canonical_unmarked): Remove.\n\t(shared_marked_p, shared_unmarked_p): Remove.\n\t(BINFO_ACCESS, SET_BINFO_ACCESS): Use TREE_PUBLIC & TREE_PRIVATE.\n\t(dfs_access_in_type): Adjust.\n\t(access_in_type): Adjust.\n\t(dfs_accessible_queue_p): Adjust.\n\t(dfs_accessible_p): Adjust.\n\t(is_subobject_of_p_1, is_subobject_of_p): Remove.\n\t(struct lookup_field_info): Remove from_dep_base_p field.\n\t(lookup_field_queue_p): Adjust, test BINFO_DEPENDENT_BASE_P.\n\t(lookup_field_r): Remove dependent base code.\n\t(lookup_member): Likewise.\n\t(dfs_walk, dfs_walk_real): Add access arg to queue fn.\n\t(dfs_unmarked_real_bases_queue_p): Remove.\n\t(dfs_marked_real_bases_queue_p): Remove.\n\t(dfs_skip_vbases): Remove.\n\t(dfs_get_pure_virtuals): Adjust.\n\t(markedp, unmarkedp): Adjust.\n\t(marked_vtable_pathp, unmarked_vtable_pathp): Remove.\n\t(marked_pushdecls_p, unmarked_pushdecls_p): Adjust.\n\t(dfs_unmark): Adjust.\n\t(dfs_get_vbase_types):Remove.\n\t(dfs_build_inheritance_graph_order): Remove.\n\t(get_vbase_types): Remove\n\t(dfs_find_vbase_instance): Remove.\n\t(find_vbase_instance): Remove.\n\t(dfs_debug_unmarkedp): Adjust.\n\t(dependent_base_p): Remove.\n\t(dfs_push_type_decls): Adjust.\n\t(dfs_push_decls): Adjust.\n\t(dfs_no_overlap_yet): Adjust.\n\t(copied_binfo): New function.\n\t(original_binfo): New function.\n\t(binfo_for_vbase): Remove.\n\n\tChange base class access representation.\n\t* java/class.c (set_super_info): Don't set TREE_VIA_PUBLIC.\n\t(add_interface_do): Likewise.\n\nFrom-SVN: r63172", "tree": {"sha": "59b3a49cfb69cf0f41e79b337be18633389fe99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59b3a49cfb69cf0f41e79b337be18633389fe99f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/comments", "author": null, "committer": null, "parents": [{"sha": "4c24ac2716caccb1d44ae7018e831e53fd4b79c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c24ac2716caccb1d44ae7018e831e53fd4b79c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c24ac2716caccb1d44ae7018e831e53fd4b79c1"}], "stats": {"total": 2678, "additions": 1169, "deletions": 1509}, "files": [{"sha": "9a3464e924a586756ff387e658db334b4b70fbf3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,3 +1,155 @@\n+2003-02-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tChange base class access representation.\n+\t* tree.h (TREE_VIA_PUBLIC, TREE_VIA_PROTECTED,\n+\tTREE_VIA_PRIVATE): Remove.\n+\t(BINFO_BASEACCESSES): New binfo elt.\n+\t(BINFO_BASEACCESS): New accessor.\n+\t(BINFO_ELTS): Increase.\n+\t(TI_ACCESS_PUBLIC, TI_ACCESS_PROTECTED, TI_ACCESS_PRIVATE): New.\n+\t(access_public_node, access_protected_node,\n+\taccess_private_node): New global nodes.\n+\t* tree.c (build_common_tree_nodes_2): Initialize access nodes.\n+\t* dbxout.c (dbxout_type): Adjust.\n+\t* dwarf2out.c (gen_inheritance_die): Add access parameter.\n+\t(gen_member_die): Adjust.\n+\t* dwarfout.c (output_inheritance_die): ARG is array of two trees.\n+\t(output_type): Adjust.\n+\t* tree-dump.c (dequeue_and_dump): Adjust binfo dumping.\n+\n+\tChange base class access representation. Share virtual base\n+\tbinfos.\n+\t* cp/call.c (build_special_member_call): Remove binfo_for_vbase\n+\tcall.\n+\t* cp/class.c (build_base_path): Likewise.\n+\t(build_primary_vtable): Adjust BINFO_NEW_VTABLE_MARKED use.\n+\t(build_secondary_vtable): Remove FOR_TYPE arg. Adjust.\n+\t(make_new_vtable): Adjust.\n+\t(force_canonical_binfo_r): Delete.\n+\t(force_canonical_binfo): Delete.\n+\t(mark_primary_virtual_base): Delete.\n+\t(dfs_unshared_virtual_bases): Delete.\n+\t(mark_primary_bases): Adjust.\n+\t(maybe_warn_about_overly_private_class): Adjust.\n+\t(dfs_base_derived_from): Delete.\n+\t(base_derived_from): Follow the inheritance chain.\n+\t(struct find_final_overrider_data): Add vpath member.\n+\t(dfs_find_final_overrider): Adjust.\n+\t(dfs_find_final_overrider_q, dfs_find_final_overrider_post): New.\n+\t(find_final_overrider): Adjust.\n+\t(update_vtable_entry_for_fn): Adjust.\n+\t(modify_all_vtables): Adjust.\n+\t(walk_subobject_offsets): Adjust.\n+\t(layout_nonempty_base_or_field): Adjust.\n+\t(layout_empty_base): Remove last parameter. Adjust.\n+\t(build_base_field): Adjust.\n+\t(build_base_fields): Adjust.\n+\t(propagate_binfo_offsets): Remove last parameter. Adjust.\n+\t(dfs_set_offset_for_unshared_vbases): Delete.\n+\t(layout_virtual_bases): Adjust.\n+\t(finish_struct_1): Adjust.\n+\t(init_class_processing): Don't init access nodes.\n+\t(dfs_get_primary_binfo): Delete.\n+\t(get_primary_binfo): Adjust.\n+\t(dump_class_hierarchy_r): Remove most derived arg, add IGO\n+\tparameter. Adjust.\n+\t(dump_class_hierarchy): Adjust.\n+\t(finish_vtbls): Adjust.\n+\t(get_original_base): Delete.\n+\t(build_vtt_inits): Adjust.\n+\t(dfs_build_secondary_vptr_vtt_inits): Adjust.\n+\t(dfs_ctor_vtable_bases_queue_p): Adjust.\n+\t(build_ctor_vtbl_group): Adjust.\n+\t(dfs_accumulate_vtbl_inits): Adjust.\n+\t(build_vtbl_initializer): Adjust.\n+\t(build_vbase_offset_vtbl_entries): Adjust.\n+\t(add_vcall_offset_vtbl_entries_1): Adjust.\n+\t* cp/cp-tree.h (CPTI_ACCESS_*): Remove.\n+\t(access_*_node): Remove.\n+\t(CANONICAL_BINFO): Delete.\n+\t(BINFO_UNSHARED_MARKED): Remove.\n+\t(BINFO_MARKED): Set LANG_FLAG_0 directly.\n+\t(SET_BINFO_MARKED, CLEAR_BINFO_MARKED): Delete.\n+\t(BINFO_VTABLE_PATH_MARKED): Set LANG_FLAG_3 directly.\n+\t(SET_BINFO_VTABLE_PATH_MARKED, CLEAR_BINFO_VTABLE_PATH_MARKED):\n+\tDelete.\n+\t(BINFO_NEW_VTABLE_MARKED): Set LANG_FLAG_4 directly.\n+\t(SET_BINFO_NEW_VTABLE_MARKED): Adjust.\n+\t(SET_BINFO_PUSHDECLS_MARKED, CLEAR_BINFO_PUSHDECLS_MARKED):\n+\tDelete.\n+\t(BINFO_DEPENDENT_BASE_P): New.\n+\t(dfs_walk, dfs_walk_real): Queue function takes derived binfo and\n+\tindex.\n+\t(markedp, unmarkedp): Adjust.\n+\t(dfs_unmarked_real_bases_queue_p, dfs_marked_real_bases_queue_p,\n+\tdfs_skip_vbases, marked_vtable_pathp, unmarked_vtable_pathp,\n+\tfind_vbase_instance, binfo_for_vbase): Delete.\n+\t(copied_binfo, original_binfo): Declare.\n+\t(finish_base_specifier): Add virtual_p arg.\n+\t(unshare_base_binfos): Delete.\n+\t(copy_base_binfos): Declare.\n+\t(reverse_path): Delete.\n+\t* cp/decl.c (xref_basetypes): Access and virtuality passed\n+\tdifferently. Don't copy direct base binfos here. Call\n+\tcopy_base_binfos.\n+\t* cp/init.c (dfs_initialize_vtbl_ptrs): Adjust.\n+\t(initialize_vtbl_ptrs): Adjust.\n+\t(expand_member_init): Adjust.\n+\t* cp/parser.c (cp_parser_base_specifier): Adjust.\n+\t* cp/pt.c (instantiate_class_template): Adjust.\n+\t(get_template_base_recursive): Adjust.\n+\t* cp/rtti.c (get_pseudo_ti_init): Adjust.\n+\t(get_pseudo_ti_desc): Adjust.\n+\t* cp/tree.c (unshare_base_binfos): Rename to ...\n+\t(copy_base_binfos): ... here, reimplement.\n+\t(make_binfo): Set BINFO_DEPENDENT_BASE_P.\n+\t(reverse_path): Remove.\n+\t* cp/typeck.c (get_delta_difference): Adjust error messages.\n+\t* cp/semantics.c (finish_base_specifier): Add virtual arg, adjust.\n+\t* cp/search.c (lookup_base_r): Adjust.\n+\t(dynamic_cast_base_recurse): Adjust.\n+\t(canonical_binfo): Remove.\n+\t(dfs_canonical_queue): Remove.\n+\t(dfs_assert_unmarked_p): Remove.\n+\t(assert_canonical_unmarked): Remove.\n+\t(shared_marked_p, shared_unmarked_p): Remove.\n+\t(BINFO_ACCESS, SET_BINFO_ACCESS): Use TREE_PUBLIC & TREE_PRIVATE.\n+\t(dfs_access_in_type): Adjust.\n+\t(access_in_type): Adjust.\n+\t(dfs_accessible_queue_p): Adjust.\n+\t(dfs_accessible_p): Adjust.\n+\t(is_subobject_of_p_1, is_subobject_of_p): Remove.\n+\t(struct lookup_field_info): Remove from_dep_base_p field.\n+\t(lookup_field_queue_p): Adjust, test BINFO_DEPENDENT_BASE_P.\n+\t(lookup_field_r): Remove dependent base code.\n+\t(lookup_member): Likewise.\n+\t(dfs_walk, dfs_walk_real): Add access arg to queue fn.\n+\t(dfs_unmarked_real_bases_queue_p): Remove.\n+\t(dfs_marked_real_bases_queue_p): Remove.\n+\t(dfs_skip_vbases): Remove.\n+\t(dfs_get_pure_virtuals): Adjust.\n+\t(markedp, unmarkedp): Adjust.\n+\t(marked_vtable_pathp, unmarked_vtable_pathp): Remove.\n+\t(marked_pushdecls_p, unmarked_pushdecls_p): Adjust.\n+\t(dfs_unmark): Adjust.\n+\t(dfs_get_vbase_types):Remove.\n+\t(dfs_build_inheritance_graph_order): Remove.\n+\t(get_vbase_types): Remove\n+\t(dfs_find_vbase_instance): Remove.\n+\t(find_vbase_instance): Remove.\n+\t(dfs_debug_unmarkedp): Adjust.\n+\t(dependent_base_p): Remove.\n+\t(dfs_push_type_decls): Adjust.\n+\t(dfs_push_decls): Adjust.\n+\t(dfs_no_overlap_yet): Adjust.\n+\t(copied_binfo): New function.\n+\t(original_binfo): New function.\n+\t(binfo_for_vbase): Remove.\n+\n+\tChange base class access representation.\n+\t* java/class.c (set_super_info): Don't set TREE_VIA_PUBLIC.\n+\t(add_interface_do): Likewise.\n+\n 2003-02-20  David Edelsohn  <edelsohn@gnu.org>\n \n         * config/rs6000/sysv4.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Define."}, {"sha": "e013cf02e191efd96ced14c0256e6de2af026ba0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,3 +1,134 @@\n+2003-02-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tChange base class access representation. Share virtual base\n+\tbinfos.\n+\t* cp/call.c (build_special_member_call): Remove binfo_for_vbase\n+\tcall.\n+\t* cp/class.c (build_base_path): Likewise.\n+\t(build_primary_vtable): Adjust BINFO_NEW_VTABLE_MARKED use.\n+\t(build_secondary_vtable): Remove FOR_TYPE arg. Adjust.\n+\t(make_new_vtable): Adjust.\n+\t(force_canonical_binfo_r): Delete.\n+\t(force_canonical_binfo): Delete.\n+\t(mark_primary_virtual_base): Delete.\n+\t(dfs_unshared_virtual_bases): Delete.\n+\t(mark_primary_bases): Adjust.\n+\t(maybe_warn_about_overly_private_class): Adjust.\n+\t(dfs_base_derived_from): Delete.\n+\t(base_derived_from): Follow the inheritance chain.\n+\t(struct find_final_overrider_data): Add vpath member.\n+\t(dfs_find_final_overrider): Adjust.\n+\t(dfs_find_final_overrider_q, dfs_find_final_overrider_post): New.\n+\t(find_final_overrider): Adjust.\n+\t(update_vtable_entry_for_fn): Adjust.\n+\t(modify_all_vtables): Adjust.\n+\t(walk_subobject_offsets): Adjust.\n+\t(layout_nonempty_base_or_field): Adjust.\n+\t(layout_empty_base): Remove last parameter. Adjust.\n+\t(build_base_field): Adjust.\n+\t(build_base_fields): Adjust.\n+\t(propagate_binfo_offsets): Remove last parameter. Adjust.\n+\t(dfs_set_offset_for_unshared_vbases): Delete.\n+\t(layout_virtual_bases): Adjust.\n+\t(finish_struct_1): Adjust.\n+\t(init_class_processing): Don't init access nodes.\n+\t(dfs_get_primary_binfo): Delete.\n+\t(get_primary_binfo): Adjust.\n+\t(dump_class_hierarchy_r): Remove most derived arg, add IGO\n+\tparameter. Adjust.\n+\t(dump_class_hierarchy): Adjust.\n+\t(finish_vtbls): Adjust.\n+\t(get_original_base): Delete.\n+\t(build_vtt_inits): Adjust.\n+\t(dfs_build_secondary_vptr_vtt_inits): Adjust.\n+\t(dfs_ctor_vtable_bases_queue_p): Adjust.\n+\t(build_ctor_vtbl_group): Adjust.\n+\t(dfs_accumulate_vtbl_inits): Adjust.\n+\t(build_vtbl_initializer): Adjust.\n+\t(build_vbase_offset_vtbl_entries): Adjust.\n+\t(add_vcall_offset_vtbl_entries_1): Adjust.\n+\t* cp/cp-tree.h (CPTI_ACCESS_*): Remove.\n+\t(access_*_node): Remove.\n+\t(CANONICAL_BINFO): Delete.\n+\t(BINFO_UNSHARED_MARKED): Remove.\n+\t(BINFO_MARKED): Set LANG_FLAG_0 directly.\n+\t(SET_BINFO_MARKED, CLEAR_BINFO_MARKED): Delete.\n+\t(BINFO_VTABLE_PATH_MARKED): Set LANG_FLAG_3 directly.\n+\t(SET_BINFO_VTABLE_PATH_MARKED, CLEAR_BINFO_VTABLE_PATH_MARKED):\n+\tDelete.\n+\t(BINFO_NEW_VTABLE_MARKED): Set LANG_FLAG_4 directly.\n+\t(SET_BINFO_NEW_VTABLE_MARKED): Adjust.\n+\t(SET_BINFO_PUSHDECLS_MARKED, CLEAR_BINFO_PUSHDECLS_MARKED):\n+\tDelete.\n+\t(BINFO_DEPENDENT_BASE_P): New.\n+\t(dfs_walk, dfs_walk_real): Queue function takes derived binfo and\n+\tindex.\n+\t(markedp, unmarkedp): Adjust.\n+\t(dfs_unmarked_real_bases_queue_p, dfs_marked_real_bases_queue_p,\n+\tdfs_skip_vbases, marked_vtable_pathp, unmarked_vtable_pathp,\n+\tfind_vbase_instance, binfo_for_vbase): Delete.\n+\t(copied_binfo, original_binfo): Declare.\n+\t(finish_base_specifier): Add virtual_p arg.\n+\t(unshare_base_binfos): Delete.\n+\t(copy_base_binfos): Declare.\n+\t(reverse_path): Delete.\n+\t* cp/decl.c (xref_basetypes): Access and virtuality passed\n+\tdifferently. Don't copy direct base binfos here. Call\n+\tcopy_base_binfos.\n+\t* cp/init.c (dfs_initialize_vtbl_ptrs): Adjust.\n+\t(initialize_vtbl_ptrs): Adjust.\n+\t(expand_member_init): Adjust.\n+\t* cp/parser.c (cp_parser_base_specifier): Adjust.\n+\t* cp/pt.c (instantiate_class_template): Adjust.\n+\t(get_template_base_recursive): Adjust.\n+\t* cp/rtti.c (get_pseudo_ti_init): Adjust.\n+\t(get_pseudo_ti_desc): Adjust.\n+\t* cp/tree.c (unshare_base_binfos): Rename to ...\n+\t(copy_base_binfos): ... here, reimplement.\n+\t(make_binfo): Set BINFO_DEPENDENT_BASE_P.\n+\t(reverse_path): Remove.\n+\t* cp/typeck.c (get_delta_difference): Adjust error messages.\n+\t* cp/semantics.c (finish_base_specifier): Add virtual arg, adjust.\n+\t* cp/search.c (lookup_base_r): Adjust.\n+\t(dynamic_cast_base_recurse): Adjust.\n+\t(canonical_binfo): Remove.\n+\t(dfs_canonical_queue): Remove.\n+\t(dfs_assert_unmarked_p): Remove.\n+\t(assert_canonical_unmarked): Remove.\n+\t(shared_marked_p, shared_unmarked_p): Remove.\n+\t(BINFO_ACCESS, SET_BINFO_ACCESS): Use TREE_PUBLIC & TREE_PRIVATE.\n+\t(dfs_access_in_type): Adjust.\n+\t(access_in_type): Adjust.\n+\t(dfs_accessible_queue_p): Adjust.\n+\t(dfs_accessible_p): Adjust.\n+\t(is_subobject_of_p_1, is_subobject_of_p): Remove.\n+\t(struct lookup_field_info): Remove from_dep_base_p field.\n+\t(lookup_field_queue_p): Adjust, test BINFO_DEPENDENT_BASE_P.\n+\t(lookup_field_r): Remove dependent base code.\n+\t(lookup_member): Likewise.\n+\t(dfs_walk, dfs_walk_real): Add access arg to queue fn.\n+\t(dfs_unmarked_real_bases_queue_p): Remove.\n+\t(dfs_marked_real_bases_queue_p): Remove.\n+\t(dfs_skip_vbases): Remove.\n+\t(dfs_get_pure_virtuals): Adjust.\n+\t(markedp, unmarkedp): Adjust.\n+\t(marked_vtable_pathp, unmarked_vtable_pathp): Remove.\n+\t(marked_pushdecls_p, unmarked_pushdecls_p): Adjust.\n+\t(dfs_unmark): Adjust.\n+\t(dfs_get_vbase_types):Remove.\n+\t(dfs_build_inheritance_graph_order): Remove.\n+\t(get_vbase_types): Remove\n+\t(dfs_find_vbase_instance): Remove.\n+\t(find_vbase_instance): Remove.\n+\t(dfs_debug_unmarkedp): Adjust.\n+\t(dependent_base_p): Remove.\n+\t(dfs_push_type_decls): Adjust.\n+\t(dfs_push_decls): Adjust.\n+\t(dfs_no_overlap_yet): Adjust.\n+\t(copied_binfo): New function.\n+\t(original_binfo): New function.\n+\t(binfo_for_vbase): Remove.\n+\n 2003-02-18  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cp/search.c (grow_bfs_bases): New subroutine of bfs_walk."}, {"sha": "98b60a10a535803f2dfda31779311e64cc641e46", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -4653,8 +4653,6 @@ build_special_member_call (tree instance, tree name, tree args,\n \t\t\t  current_in_charge_parm, integer_zero_node),\n \t\t   current_vtt_parm,\n \t\t   vtt);\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\tbinfo = binfo_for_vbase (class_type, current_class_type);\n       my_friendly_assert (BINFO_SUBVTT_INDEX (binfo), 20010110);\n       sub_vtt = build (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n \t\t       BINFO_SUBVTT_INDEX (binfo));"}, {"sha": "89c11e653a002af6e9078a56d056cb9b1de28951", "filename": "gcc/cp/class.c", "status": "modified", "additions": 226, "deletions": 565, "changes": 791, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -110,7 +110,7 @@ static void finish_struct_anon (tree);\n static tree get_vtable_name (tree);\n static tree get_basefndecls (tree, tree);\n static int build_primary_vtable (tree, tree);\n-static int build_secondary_vtable (tree, tree);\n+static int build_secondary_vtable (tree);\n static void finish_vtbls (tree);\n static void modify_vtable_entry (tree, tree, tree, tree, tree *);\n static tree delete_duplicate_fields_1 (tree, tree);\n@@ -152,20 +152,21 @@ static void layout_class_type (tree, tree *);\n static void fixup_pending_inline (tree);\n static void fixup_inline_methods (tree);\n static void set_primary_base (tree, tree);\n-static void propagate_binfo_offsets (tree, tree, tree);\n+static void propagate_binfo_offsets (tree, tree);\n static void layout_virtual_bases (record_layout_info, splay_tree);\n-static tree dfs_set_offset_for_unshared_vbases (tree, void *);\n static void build_vbase_offset_vtbl_entries (tree, vtbl_init_data *);\n static void add_vcall_offset_vtbl_entries_r (tree, vtbl_init_data *);\n static void add_vcall_offset_vtbl_entries_1 (tree, vtbl_init_data *);\n static void build_vcall_offset_vtbl_entries (tree, vtbl_init_data *);\n static void add_vcall_offset (tree, tree, vtbl_init_data *);\n static void layout_vtable_decl (tree, int);\n static tree dfs_find_final_overrider (tree, void *);\n+static tree dfs_find_final_overrider_post (tree, void *);\n+static tree dfs_find_final_overrider_q (tree, int, void *);\n static tree find_final_overrider (tree, tree, tree);\n static int make_new_vtable (tree, tree);\n static int maybe_indent_hierarchy (FILE *, int, int);\n-static void dump_class_hierarchy_r (FILE *, int, tree, tree, int);\n+static tree dump_class_hierarchy_r (FILE *, int, tree, tree, int);\n static void dump_class_hierarchy (tree);\n static void dump_array (FILE *, tree);\n static void dump_vtable (tree, tree, tree);\n@@ -176,18 +177,14 @@ static void initialize_array (tree, tree);\n static void layout_nonempty_base_or_field (record_layout_info,\n \t\t\t\t\t\t   tree, tree, splay_tree);\n static tree end_of_class (tree, int);\n-static bool layout_empty_base (tree, tree, splay_tree, tree);\n+static bool layout_empty_base (tree, tree, splay_tree);\n static void accumulate_vtbl_inits (tree, tree, tree, tree, tree);\n static tree dfs_accumulate_vtbl_inits (tree, tree, tree, tree,\n \t\t\t\t\t       tree);\n static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n static void build_vcall_and_vbase_vtbl_entries (tree, \n \t\t\t\t\t\t\tvtbl_init_data *);\n-static void force_canonical_binfo_r (tree, tree, tree, tree);\n-static void force_canonical_binfo (tree, tree, tree, tree);\n-static tree dfs_unshared_virtual_bases (tree, void *);\n static void mark_primary_bases (tree);\n-static tree mark_primary_virtual_base (tree, tree);\n static void clone_constructors_and_destructors (tree);\n static tree build_clone (tree, tree);\n static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n@@ -197,10 +194,8 @@ static void build_vtt (tree);\n static tree binfo_ctor_vtable (tree);\n static tree *build_vtt_inits (tree, tree, tree *, tree *);\n static tree dfs_build_secondary_vptr_vtt_inits (tree, void *);\n-static tree dfs_ctor_vtable_bases_queue_p (tree, void *data);\n+static tree dfs_ctor_vtable_bases_queue_p (tree, int, void *data);\n static tree dfs_fixup_binfo_vtbls (tree, void *);\n-static tree get_original_base (tree, tree);\n-static tree dfs_get_primary_binfo (tree, void*);\n static int record_subobject_offset (tree, tree, splay_tree);\n static int check_subobject_offset (tree, tree, splay_tree);\n static int walk_subobject_offsets (tree, subobject_offset_fn,\n@@ -212,7 +207,6 @@ static int splay_tree_compare_integer_csts (splay_tree_key k1,\n static void warn_about_ambiguous_bases (tree);\n static bool type_requires_array_cookie (tree);\n static bool contains_empty_class_p (tree);\n-static tree dfs_base_derived_from (tree, void *);\n static bool base_derived_from (tree, tree);\n static int empty_base_at_nonzero_offset_p (tree, tree, splay_tree);\n static tree end_of_base (tree);\n@@ -311,8 +305,6 @@ build_base_path (enum tree_code code,\n       tree v_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n \t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)));\n       \n-      v_binfo = binfo_for_vbase (BINFO_TYPE (v_binfo), BINFO_TYPE (d_binfo));\n-      \n       v_offset = build (PLUS_EXPR, TREE_TYPE (v_offset),\n \t\t\tv_offset,  BINFO_VPTR_FIELD (v_binfo));\n       v_offset = build1 (NOP_EXPR, \n@@ -443,10 +435,8 @@ build_vtbl_ref_1 (tree instance, tree idx)\n     }\n \n   if (!vtbl)\n-    {\n-      vtbl = build_vfield_ref (instance, basetype);\n-    }\n-\n+    vtbl = build_vfield_ref (instance, basetype);\n+  \n   assemble_external (vtbl);\n \n   aref = build_array_ref (vtbl, idx);\n@@ -592,7 +582,7 @@ build_primary_vtable (tree binfo, tree type)\n   \n   if (binfo)\n     {\n-      if (BINFO_NEW_VTABLE_MARKED (binfo, type))\n+      if (BINFO_NEW_VTABLE_MARKED (binfo))\n \t/* We have already created a vtable for this base, so there's\n \t   no need to do it again.  */\n \treturn 0;\n@@ -618,7 +608,7 @@ build_primary_vtable (tree binfo, tree type)\n      on our first approximation.  */\n   TYPE_BINFO_VTABLE (type) = decl;\n   TYPE_BINFO_VIRTUALS (type) = virtuals;\n-  SET_BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (type), type);\n+  SET_BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (type));\n   return 1;\n }\n \n@@ -637,18 +627,16 @@ build_primary_vtable (tree binfo, tree type)\n    can result.  */\n \n static int\n-build_secondary_vtable (tree binfo, tree for_type)\n+build_secondary_vtable (tree binfo)\n {\n-  my_friendly_assert (binfo == CANONICAL_BINFO (binfo, for_type), 20010605);\n-\n-  if (BINFO_NEW_VTABLE_MARKED (binfo, for_type))\n+  if (BINFO_NEW_VTABLE_MARKED (binfo))\n     /* We already created a vtable for this base.  There's no need to\n        do it again.  */\n     return 0;\n \n   /* Remember that we've created a vtable for this BINFO, so that we\n      don't try to do so again.  */\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo, for_type);\n+  SET_BINFO_NEW_VTABLE_MARKED (binfo);\n   \n   /* Make fresh virtual list, so we can smash it later.  */\n   BINFO_VIRTUALS (binfo) = copy_virtuals (binfo);\n@@ -678,7 +666,7 @@ make_new_vtable (tree t, tree binfo)\n        we will fill in all the virtual functions that override the\n        virtual functions in these base classes which are not defined\n        by the current type.  */\n-    return build_secondary_vtable (binfo, t);\n+    return build_secondary_vtable (binfo);\n }\n \n /* Make *VIRTUALS, an entry on the BINFO_VIRTUALS list for BINFO\n@@ -692,7 +680,7 @@ modify_vtable_entry (tree t,\n                      tree binfo, \n                      tree fndecl, \n                      tree delta, \n-                     tree* virtuals)\n+                     tree *virtuals)\n {\n   tree v;\n \n@@ -1296,170 +1284,6 @@ check_bases (tree t,\n     }\n }\n \n-/* Binfo FROM is within a virtual hierarchy which is being reseated to\n-   TO. Move primary information from FROM to TO, and recursively traverse\n-   into FROM's bases. The hierarchy is dominated by TYPE.  MAPPINGS is an\n-   assoc list of binfos that have already been reseated.  */\n-\n-static void\n-force_canonical_binfo_r (tree to, tree from, tree type, tree mappings)\n-{\n-  int i, n_baseclasses = BINFO_N_BASETYPES (from);\n-\n-  my_friendly_assert (to != from, 20010905);\n-  BINFO_INDIRECT_PRIMARY_P (to)\n-          = BINFO_INDIRECT_PRIMARY_P (from);\n-  BINFO_INDIRECT_PRIMARY_P (from) = 0;\n-  BINFO_UNSHARED_MARKED (to) = BINFO_UNSHARED_MARKED (from);\n-  BINFO_UNSHARED_MARKED (from) = 0;\n-  BINFO_LOST_PRIMARY_P (to) = BINFO_LOST_PRIMARY_P (from);\n-  BINFO_LOST_PRIMARY_P (from) = 0;\n-  if (BINFO_PRIMARY_P (from))\n-    {\n-      tree primary = BINFO_PRIMARY_BASE_OF (from);\n-      tree assoc;\n-      \n-      /* We might have just moved the primary base too, see if it's on our\n-         mappings.  */\n-      assoc = purpose_member (primary, mappings);\n-      if (assoc)\n-        primary = TREE_VALUE (assoc);\n-      BINFO_PRIMARY_BASE_OF (to) = primary;\n-      BINFO_PRIMARY_BASE_OF (from) = NULL_TREE;\n-    }\n-  my_friendly_assert (same_type_p (BINFO_TYPE (to), BINFO_TYPE (from)),\n-\t\t      20010104);\n-  mappings = tree_cons (from, to, mappings);\n-\n-  if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (from))\n-      && TREE_VIA_VIRTUAL (CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (from))))\n-    {\n-      tree from_primary = get_primary_binfo (from);\n-      \n-      if (BINFO_PRIMARY_BASE_OF (from_primary) == from)\n-\tforce_canonical_binfo (get_primary_binfo (to), from_primary,\n-\t\t\t       type, mappings);\n-    }\n-  \n-  for (i = 0; i != n_baseclasses; i++)\n-    {\n-      tree from_binfo = BINFO_BASETYPE (from, i);\n-      tree to_binfo = BINFO_BASETYPE (to, i);\n-\n-      if (TREE_VIA_VIRTUAL (from_binfo))\n-        {\n-\t  if (BINFO_PRIMARY_P (from_binfo) &&\n-\t      purpose_member (BINFO_PRIMARY_BASE_OF (from_binfo), mappings))\n-\t    /* This base is a primary of some binfo we have already\n-\t       reseated. We must reseat this one too.  */\n-            force_canonical_binfo (to_binfo, from_binfo, type, mappings);\n-        }\n-      else\n-        force_canonical_binfo_r (to_binfo, from_binfo, type, mappings);\n-    }\n-}\n-\n-/* FROM is the canonical binfo for a virtual base. It is being reseated to\n-   make TO the canonical binfo, within the hierarchy dominated by TYPE.\n-   MAPPINGS is an assoc list of binfos that have already been reseated.\n-   Adjust any non-virtual bases within FROM, and also move any virtual bases\n-   which are canonical.  This complication arises because selecting primary\n-   bases walks in inheritance graph order, but we don't share binfos for\n-   virtual bases, hence we can fill in the primaries for a virtual base,\n-   and then discover that a later base requires the virtual as its\n-   primary.  */\n-\n-static void\n-force_canonical_binfo (tree to, tree from, tree type, tree mappings)\n-{\n-  tree assoc = purpose_member (BINFO_TYPE (to),\n-\t\t               CLASSTYPE_VBASECLASSES (type));\n-  if (TREE_VALUE (assoc) != to)\n-    {\n-      TREE_VALUE (assoc) = to;\n-      force_canonical_binfo_r (to, from, type, mappings);\n-    }\n-}\n-\n-/* Make BASE_BINFO the a primary virtual base within the hierarchy\n-   dominated by TYPE. Returns BASE_BINFO, if it is not already one, NULL\n-   otherwise (because something else has already made it primary).  */\n-\n-static tree\n-mark_primary_virtual_base (tree base_binfo, tree type)\n-{\n-  tree shared_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), type);\n-\n-  if (BINFO_PRIMARY_P (shared_binfo))\n-    {\n-      /* It's already allocated in the hierarchy. BINFO won't have a\n-         primary base in this hierarchy, even though the complete object\n-         BINFO is for, would do.  */\n-      return NULL_TREE;\n-    }\n-     \n-  /* We need to make sure that the assoc list\n-     CLASSTYPE_VBASECLASSES of TYPE, indicates this particular\n-     primary BINFO for the virtual base, as this is the one\n-     that'll really exist.  */\n-  if (base_binfo != shared_binfo)\n-    force_canonical_binfo (base_binfo, shared_binfo, type, NULL);\n-\n-  return base_binfo;\n-}\n-\n-/* If BINFO is an unmarked virtual binfo for a class with a primary virtual\n-   base, then BINFO has no primary base in this graph.  Called from\n-   mark_primary_bases.  DATA is the most derived type.  */\n-\n-static tree\n-dfs_unshared_virtual_bases (tree binfo, void* data)\n-{\n-  tree t = (tree) data;\n-  \n-  if (!BINFO_UNSHARED_MARKED (binfo)\n-      && CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n-    {\n-      /* This morally virtual base has a primary base when it\n-         is a complete object. We need to locate the shared instance\n-         of this binfo in the type dominated by T. We duplicate the\n-         primary base information from there to here.  */\n-      tree vbase;\n-      tree unshared_base;\n-      \n-      for (vbase = binfo; !TREE_VIA_VIRTUAL (vbase);\n-\t   vbase = BINFO_INHERITANCE_CHAIN (vbase))\n-\tcontinue;\n-      unshared_base = get_original_base (binfo,\n-\t\t\t\t\t binfo_for_vbase (BINFO_TYPE (vbase),\n-\t\t\t\t\t\t\t  t));\n-      my_friendly_assert (unshared_base != binfo, 20010612);\n-      BINFO_LOST_PRIMARY_P (binfo) = BINFO_LOST_PRIMARY_P (unshared_base);\n-      if (!BINFO_LOST_PRIMARY_P (binfo))\n-\tBINFO_PRIMARY_BASE_OF (get_primary_binfo (binfo)) = binfo;\n-    }\n-  \n-  if (binfo != TYPE_BINFO (t))\n-    /* The vtable fields will have been copied when duplicating the\n-       base binfos. That information is bogus, make sure we don't try\n-       and use it.  */\n-    BINFO_VTABLE (binfo) = NULL_TREE;\n-\n-  /* If this is a virtual primary base, make sure its offset matches\n-     that which it is primary for.  */\n-  if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo) &&\n-      binfo_for_vbase (BINFO_TYPE (binfo), t) == binfo)\n-    {\n-      tree delta = size_diffop (BINFO_OFFSET (BINFO_PRIMARY_BASE_OF (binfo)),\n-\t\t\t\tBINFO_OFFSET (binfo));\n-      if (!integer_zerop (delta))\n-\tpropagate_binfo_offsets (binfo, delta, t);\n-    }\n-  \n-  BINFO_UNSHARED_MARKED (binfo) = 0;\n-  return NULL;\n-}\n-\n /* Set BINFO_PRIMARY_BASE_OF for all binfos in the hierarchy\n    dominated by TYPE that are primary bases.  */\n \n@@ -1471,33 +1295,29 @@ mark_primary_bases (tree type)\n   /* Walk the bases in inheritance graph order.  */\n   for (binfo = TYPE_BINFO (type); binfo; binfo = TREE_CHAIN (binfo))\n     {\n-      tree base_binfo;\n-      \n-      if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n-        /* Not a dynamic base.  */\n-        continue;\n-\n-      base_binfo = get_primary_binfo (binfo);\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-        base_binfo = mark_primary_virtual_base (base_binfo, type);\n+      tree base_binfo = get_primary_binfo (binfo);\n \n-      if (base_binfo)\n-        BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n-      else\n+      if (!base_binfo)\n+\t/* Not a dynamic base.  */;\n+      else if (BINFO_PRIMARY_P (base_binfo))\n \tBINFO_LOST_PRIMARY_P (binfo) = 1;\n-      \n-      BINFO_UNSHARED_MARKED (binfo) = 1;\n+      else\n+\t{\n+\t  BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n+\t  /* A virtual binfo might have been copied from within\n+  \t     another hierarchy. As we're about to use it as a primary\n+  \t     base, make sure the offsets match.  */\n+\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t    {\n+\t      tree delta = size_diffop (convert (ssizetype,\n+\t\t\t\t\t\t BINFO_OFFSET (binfo)),\n+\t\t\t\t\tconvert (ssizetype,\n+\t\t\t\t\t\t BINFO_OFFSET (base_binfo)));\n+\t  \n+\t      propagate_binfo_offsets (base_binfo, delta);\n+\t    }\n+\t}\n     }\n-  /* There could remain unshared morally virtual bases which were not\n-     visited in the inheritance graph walk. These bases will have lost\n-     their virtual primary base (should they have one). We must now\n-     find them. Also we must fix up the BINFO_OFFSETs of primary\n-     virtual bases. We could not do that as we went along, as they\n-     were originally copied from the bases we inherited from by\n-     unshare_base_binfos. That may have decided differently about\n-     where a virtual primary base went.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_unshared_virtual_bases, NULL, type);\n }\n \n /* Make the BINFO the primary base of T.  */\n@@ -1802,10 +1622,10 @@ maybe_warn_about_overly_private_class (tree t)\n \t issues error messages specifically referring to\n \t constructors/destructors.)  */\n       int i;\n-      tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n-      for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n-\tif (TREE_VIA_PUBLIC (TREE_VEC_ELT (binfos, i))\n-\t    || TREE_VIA_PROTECTED (TREE_VEC_ELT (binfos, i)))\n+      tree binfo = TYPE_BINFO (t);\n+      \n+      for (i = 0; i < BINFO_N_BASETYPES (binfo); i++)\n+\tif (BINFO_BASEACCESS (binfo, i) != access_private_node)\n \t  {\n \t    has_nonprivate_method = 1;\n \t    break;\n@@ -2220,27 +2040,27 @@ same_signature_p (tree fndecl, tree base_fndecl)\n   return 0;\n }\n \n-/* Called from base_derived_from via dfs_walk.  */\n-\n-static tree\n-dfs_base_derived_from (tree binfo, void *data)\n-{\n-  tree base = (tree) data;\n-\n-  if (same_type_p (TREE_TYPE (base), TREE_TYPE (binfo))\n-      && tree_int_cst_equal (BINFO_OFFSET (base), BINFO_OFFSET (binfo)))\n-    return error_mark_node;\n-\n-  return NULL_TREE;\n-}\n-\n /* Returns TRUE if DERIVED is a binfo containing the binfo BASE as a\n    subobject.  */\n  \n static bool\n base_derived_from (tree derived, tree base)\n {\n-  return dfs_walk (derived, dfs_base_derived_from, NULL, base) != NULL_TREE;\n+  tree probe;\n+\n+  for (probe = base; probe; probe = BINFO_INHERITANCE_CHAIN (probe))\n+    {\n+      if (probe == derived)\n+\treturn true;\n+      else if (TREE_VIA_VIRTUAL (probe))\n+\t/* If we meet a virtual base, we can't follow the inheritance\n+\t   any more.  See if the complete type of DERIVED contains\n+\t   such a virtual base.  */\n+\treturn purpose_member (BINFO_TYPE (probe),\n+\t\t\t       CLASSTYPE_VBASECLASSES (BINFO_TYPE (derived)))\n+\t  != NULL_TREE;\n+    }\n+  return false;\n }\n \n typedef struct find_final_overrider_data_s {\n@@ -2252,6 +2072,8 @@ typedef struct find_final_overrider_data_s {\n   tree most_derived_type;\n   /* The candidate overriders.  */\n   tree candidates;\n+  /* Binfos which inherited virtually on the currrent path.  */\n+  tree vpath;\n } find_final_overrider_data;\n \n /* Called from find_final_overrider via dfs_walk.  */\n@@ -2261,61 +2083,82 @@ dfs_find_final_overrider (tree binfo, void* data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-  if (same_type_p (BINFO_TYPE (binfo), \n-\t\t   BINFO_TYPE (ffod->declaring_base))\n-      && tree_int_cst_equal (BINFO_OFFSET (binfo),\n-\t\t\t     BINFO_OFFSET (ffod->declaring_base)))\n-    {\n-      tree path;\n-      tree method;\n-\n-      /* We haven't found an overrider yet.  */\n-      method = NULL_TREE;\n-      /* We've found a path to the declaring base.  Walk down the path\n-\t looking for an overrider for FN.  */\n-      path = reverse_path (binfo);\n-      while (!same_type_p (BINFO_TYPE (TREE_VALUE (path)),\n-\t\t\t   ffod->most_derived_type))\n-\tpath = TREE_CHAIN (path);\n-      while (path)\n+  if (binfo == ffod->declaring_base)\n+    {\n+      /* We've found a path to the declaring base.  Walk the path from\n+\t derived to base, looking for an overrider for FN.  */\n+      tree path, probe, vpath;\n+\n+      /* Build the path, using the inheritance chain and record of\n+\t virtual inheritance.  */\n+      for (path = NULL_TREE, probe = binfo, vpath = ffod->vpath;;)\n \t{\n-\t  method = look_for_overrides_here (BINFO_TYPE (TREE_VALUE (path)),\n-\t\t\t\t\t    ffod->fn);\n+\t  path = tree_cons (NULL_TREE, probe, path);\n+\t  if (same_type_p (BINFO_TYPE (probe), ffod->most_derived_type))\n+\t    break;\n+\t  if (TREE_VIA_VIRTUAL (probe))\n+\t    {\n+\t      probe = TREE_VALUE (vpath);\n+\t      vpath = TREE_CHAIN (vpath);\n+\t    }\n+\t  else\n+\t    probe = BINFO_INHERITANCE_CHAIN (probe);\n+\t}\n+      /* Now walk path, looking for overrides.  */\n+      for (; path; path = TREE_CHAIN (path))\n+\t{\n+\t  tree method = look_for_overrides_here\n+\t    (BINFO_TYPE (TREE_VALUE (path)), ffod->fn);\n+\t  \n \t  if (method)\n \t    {\n+\t      tree *candidate = &ffod->candidates;\n \t      path = TREE_VALUE (path);\n+\n+\t      /* Remove any candidates overridden by this new function.  */\n+\t      while (*candidate)\n+\t\t{\n+\t\t  /* If *CANDIDATE overrides METHOD, then METHOD\n+\t\t     cannot override anything else on the list.  */\n+\t\t  if (base_derived_from (TREE_VALUE (*candidate), path))\n+\t\t    return NULL_TREE;\n+\t\t  /* If METHOD overrides *CANDIDATE, remove *CANDIDATE.  */\n+\t\t  if (base_derived_from (path, TREE_VALUE (*candidate)))\n+\t\t    *candidate = TREE_CHAIN (*candidate);\n+\t\t  else\n+\t\t    candidate = &TREE_CHAIN (*candidate);\n+\t\t}\n+\t      \n+\t      /* Add the new function.  */\n+\t      ffod->candidates = tree_cons (method, path, ffod->candidates);\n \t      break;\n \t    }\n-\n-\t  path = TREE_CHAIN (path);\n \t}\n+    }\n \n-      /* If we found an overrider, record the overriding function, and\n-\t the base from which it came.  */\n-      if (path)\n-\t{\n-\t  tree *candidate;\n+  return NULL_TREE;\n+}\n \n-\t  /* Remove any candidates overridden by this new function.  */\n-\t  candidate = &ffod->candidates;\n-\t  while (*candidate)\n-\t    {\n-\t      /* If *CANDIDATE overrides METHOD, then METHOD\n-\t\t cannot override anything else on the list.  */\n-\t      if (base_derived_from (TREE_VALUE (*candidate), path))\n-\t\t  return NULL_TREE;\n-\t      /* If METHOD overrides *CANDIDATE, remove *CANDIDATE.  */\n-\t      if (base_derived_from (path, TREE_VALUE (*candidate)))\n-\t\t*candidate = TREE_CHAIN (*candidate);\n-\t      else\n-\t\tcandidate = &TREE_CHAIN (*candidate);\n-\t    }\n+static tree\n+dfs_find_final_overrider_q (tree derived, int ix, void *data)\n+{\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-\t  /* Add the new function.  */\n-\t  ffod->candidates = tree_cons (method, path, ffod->candidates);\n-\t}\n-    }\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    ffod->vpath = tree_cons (NULL_TREE, derived, ffod->vpath);\n+  \n+  return binfo;\n+}\n \n+static tree\n+dfs_find_final_overrider_post (tree binfo, void *data)\n+{\n+  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n+\n+  if (TREE_VIA_VIRTUAL (binfo) && TREE_CHAIN (ffod->vpath))\n+    ffod->vpath = TREE_CHAIN (ffod->vpath);\n+  \n   return NULL_TREE;\n }\n \n@@ -2354,11 +2197,13 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n   ffod.declaring_base = binfo;\n   ffod.most_derived_type = BINFO_TYPE (derived);\n   ffod.candidates = NULL_TREE;\n+  ffod.vpath = NULL_TREE;\n \n-  dfs_walk (derived,\n-\t    dfs_find_final_overrider,\n-\t    NULL,\n-\t    &ffod);\n+  dfs_walk_real (derived,\n+\t\t dfs_find_final_overrider,\n+\t\t dfs_find_final_overrider_post,\n+\t\t dfs_find_final_overrider_q,\n+\t\t &ffod);\n \n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n@@ -2448,9 +2293,6 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t{\n \t  fixed_offset = ssize_int (THUNK_FIXED_OFFSET (fn));\n \t  virtual_offset = THUNK_VIRTUAL_OFFSET (fn);\n-\t  if (virtual_offset)\n-\t    virtual_offset = binfo_for_vbase (BINFO_TYPE (virtual_offset),\n-\t\t\t\t\t      TREE_TYPE (over_return));\n \t}\n       else\n \tfixed_offset = virtual_offset = NULL_TREE;\n@@ -2477,11 +2319,10 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t\t     base and adjust the fixed offset to be from there.  */\n \t\t  while (!TREE_VIA_VIRTUAL (thunk_binfo))\n \t\t    thunk_binfo = BINFO_INHERITANCE_CHAIN (thunk_binfo);\n-\t      \n-\t\t  virtual_offset = binfo_for_vbase (BINFO_TYPE (thunk_binfo),\n-\t\t\t\t\t\t    TREE_TYPE (over_return));\n+\n+\t\t  virtual_offset = thunk_binfo;\n \t\t  offset = size_binop (MINUS_EXPR, offset,\n-\t\t\t\t\tBINFO_OFFSET (virtual_offset));\n+\t\t\t\t       BINFO_OFFSET (virtual_offset));\n \t\t}\n \t      if (fixed_offset)\n \t\t/* There was an existing fixed offset, this must be\n@@ -2520,8 +2361,11 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       /* If we find a virtual base, and we haven't yet found the\n \t overrider, then there is a virtual base between the\n \t declaring base (first_defn) and the final overrider.  */\n-      if (!virtual_base && TREE_VIA_VIRTUAL (b))\n-\tvirtual_base = b;\n+      if (TREE_VIA_VIRTUAL (b))\n+\t{\n+\t  virtual_base = b;\n+\t  break;\n+\t}\n     }\n \n   if (overrider_fn != overrider_target && !virtual_base)\n@@ -2619,7 +2463,7 @@ dfs_modify_vtables (tree binfo, void* data)\n \t\t\t\t    &virtuals, ix);\n     }\n \n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 1;\n \n   return NULL_TREE;\n }\n@@ -2640,11 +2484,8 @@ modify_all_vtables (tree t, tree virtuals)\n   tree *fnsp;\n \n   /* Update all of the vtables.  */\n-  dfs_walk (binfo, \n-\t    dfs_modify_vtables, \n-\t    dfs_unmarked_real_bases_queue_p,\n-\t    t);\n-  dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n+  dfs_walk (binfo, dfs_modify_vtables, unmarkedp, t);\n+  dfs_walk (binfo, dfs_unmark, markedp, t);\n \n   /* Add virtual functions not already in our primary vtable. These\n      will be both those introduced by this class, and those overridden\n@@ -3639,22 +3480,14 @@ walk_subobject_offsets (tree type,\n \t\t virtual.  (If it is non-virtual, then it was walked\n \t\t above.)  */\n \t      vbase = get_primary_binfo (type_binfo);\n-\t      if (vbase && TREE_VIA_VIRTUAL (vbase))\n+\t      if (vbase && TREE_VIA_VIRTUAL (vbase)\n+\t\t  && BINFO_PRIMARY_BASE_OF (vbase) == type_binfo)\n \t\t{\n-\t\t  tree derived = type_binfo;\n-\t\t  while (BINFO_INHERITANCE_CHAIN (derived))\n-\t\t    derived = BINFO_INHERITANCE_CHAIN (derived);\n-\t\t  derived = TREE_TYPE (derived);\n-\t\t  vbase = binfo_for_vbase (TREE_TYPE (vbase), derived);\n-\n-\t\t  if (BINFO_PRIMARY_BASE_OF (vbase) == type_binfo)\n-\t\t    {\n-\t\t      r = (walk_subobject_offsets \n-\t\t\t   (vbase, f, offset,\n-\t\t\t    offsets, max_offset, /*vbases_p=*/0));\n-\t\t      if (r)\n-\t\t\treturn r;\n-\t\t    }\n+\t\t  r = (walk_subobject_offsets \n+\t\t       (vbase, f, offset,\n+\t\t\toffsets, max_offset, /*vbases_p=*/0));\n+\t\t  if (r)\n+\t\t    return r;\n \t\t}\n \t    }\n \t}\n@@ -3774,7 +3607,6 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t\t\t       tree binfo, \n \t\t\t       splay_tree offsets)\n {\n-  tree t = rli->t;\n   tree offset = NULL_TREE;\n   bool field_p;\n   tree type;\n@@ -3855,8 +3687,7 @@ layout_nonempty_base_or_field (record_layout_info rli,\n     propagate_binfo_offsets (binfo, \n \t\t\t     size_diffop (convert (ssizetype, offset),\n \t\t\t\t\t  convert (ssizetype, \n-\t\t\t\t\t\t   BINFO_OFFSET (binfo))),\n-\t\t\t     t);\n+\t\t\t\t\t\t   BINFO_OFFSET (binfo))));\n }\n \n /* Returns true if TYPE is empty and OFFSET is nonzero.  */\n@@ -3876,7 +3707,7 @@ empty_base_at_nonzero_offset_p (tree type,\n    type.  Return nonzero iff we added it at the end.  */\n \n static bool\n-layout_empty_base (tree binfo, tree eoc, splay_tree offsets, tree t)\n+layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n {\n   tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n@@ -3903,7 +3734,7 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets, tree t)\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n       atend = true;\n-      propagate_binfo_offsets (binfo, convert (ssizetype, eoc), t);\n+      propagate_binfo_offsets (binfo, convert (ssizetype, eoc));\n       while (1) \n \t{\n \t  if (!layout_conflict_p (binfo,\n@@ -3914,7 +3745,7 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets, tree t)\n \t    break;\n \n \t  /* There's overlap here, too.  Bump along to the next spot.  */\n-\t  propagate_binfo_offsets (binfo, alignment, t);\n+\t  propagate_binfo_offsets (binfo, alignment);\n \t}\n     }\n   return atend;\n@@ -3978,7 +3809,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t byte-aligned.  */\n       eoc = round_up (rli_size_unit_so_far (rli),\n \t\t      CLASSTYPE_ALIGN_UNIT (basetype));\n-      atend = layout_empty_base (binfo, eoc, offsets, t);\n+      atend = layout_empty_base (binfo, eoc, offsets);\n       /* A nearly-empty class \"has no proper base class that is empty,\n \t not morally virtual, and at an offset other than zero.\"  */\n       if (!TREE_VIA_VIRTUAL (binfo) && CLASSTYPE_NEARLY_EMPTY_P (t))\n@@ -4057,11 +3888,9 @@ build_base_fields (record_layout_info rli,\n       if (base_binfo == CLASSTYPE_PRIMARY_BINFO (t))\n \tcontinue;\n \n-      /* A primary virtual base class is allocated just like any other\n-\t base class, but a non-primary virtual base is allocated\n-\t later, in layout_virtual_bases.  */\n-      if (TREE_VIA_VIRTUAL (base_binfo) \n-\t  && !BINFO_PRIMARY_P (base_binfo))\n+      /* Virtual bases are added at the end (a primary virtual base\n+\t will have already been added).  */\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n \n       next_field = build_base_field (rli, base_binfo,\n@@ -4658,7 +4487,7 @@ fixup_inline_methods (tree type)\n    OFFSET, which is a type offset, is number of bytes.  */\n \n static void\n-propagate_binfo_offsets (tree binfo, tree offset, tree t)\n+propagate_binfo_offsets (tree binfo, tree offset)\n {\n   int i;\n   tree primary_binfo;\n@@ -4699,47 +4528,21 @@ propagate_binfo_offsets (tree binfo, tree offset, tree t)\n \n       /* Skip virtual bases that aren't our canonical primary base.  */\n       if (TREE_VIA_VIRTUAL (base_binfo)\n-\t  && (BINFO_PRIMARY_BASE_OF (base_binfo) != binfo\n-\t      || base_binfo != binfo_for_vbase (BINFO_TYPE (base_binfo), t)))\n+\t  && BINFO_PRIMARY_BASE_OF (base_binfo) != binfo)\n \tcontinue;\n \n-      propagate_binfo_offsets (base_binfo, offset, t);\n+      propagate_binfo_offsets (base_binfo, offset);\n     }\n }\n \n-/* Called via dfs_walk from layout_virtual bases.  */\n-\n-static tree\n-dfs_set_offset_for_unshared_vbases (tree binfo, void* data)\n-{\n-  /* If this is a virtual base, make sure it has the same offset as\n-     the shared copy.  If it's a primary base, then we know it's\n-     correct.  */\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree t = (tree) data;\n-      tree vbase;\n-      tree offset;\n-      \n-      vbase = binfo_for_vbase (BINFO_TYPE (binfo), t);\n-      if (vbase != binfo)\n-\t{\n-\t  offset = size_diffop (BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n-\t  propagate_binfo_offsets (binfo, offset, t);\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Set BINFO_OFFSET for all of the virtual bases for RLI->T.  Update\n    TYPE_ALIGN and TYPE_SIZE for T.  OFFSETS gives the location of\n    empty subobjects of T.  */\n \n static void\n layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n {\n-  tree vbases;\n+  tree vbase;\n   tree t = rli->t;\n   bool first_vbase = true;\n   tree *next_field;\n@@ -4771,17 +4574,11 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n   /* Go through the virtual bases, allocating space for each virtual\n      base that is not already a primary base class.  These are\n      allocated in inheritance graph order.  */\n-  for (vbases = TYPE_BINFO (t);\n-       vbases; \n-       vbases = TREE_CHAIN (vbases))\n+  for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n     {\n-      tree vbase;\n-\n-      if (!TREE_VIA_VIRTUAL (vbases))\n+      if (!TREE_VIA_VIRTUAL (vbase))\n \tcontinue;\n \n-      vbase = binfo_for_vbase (BINFO_TYPE (vbases), t);\n-\n       if (!BINFO_PRIMARY_P (vbase))\n \t{\n \t  tree basetype = TREE_TYPE (vbase);\n@@ -4812,13 +4609,6 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t  first_vbase = false;\n \t}\n     }\n-\n-  /* Now, go through the TYPE_BINFO hierarchy, setting the\n-     BINFO_OFFSETs correctly for all non-primary copies of the virtual\n-     bases and their direct and indirect bases.  The ambiguity checks\n-     in lookup_base depend on the BINFO_OFFSETs being set\n-     correctly.  */\n-  dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n }\n \n /* Returns the offset of the byte just past the end of the base class\n@@ -5391,7 +5181,7 @@ finish_struct_1 (tree t)\n       /* We must enter these virtuals into the table.  */\n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \tbuild_primary_vtable (NULL_TREE, t);\n-      else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t), t))\n+      else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n \t/* Here we know enough to change the type of our virtual\n \t   function table, but we will wait until later this function.  */\n \tbuild_primary_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n@@ -5729,15 +5519,6 @@ init_class_processing (void)\n \t\t\t\t    * sizeof (struct class_stack_node));\n   VARRAY_TREE_INIT (local_classes, 8, \"local_classes\");\n \n-  access_default_node = build_int_2 (0, 0);\n-  access_public_node = build_int_2 (ak_public, 0);\n-  access_protected_node = build_int_2 (ak_protected, 0);\n-  access_private_node = build_int_2 (ak_private, 0);\n-  access_default_virtual_node = build_int_2 (4, 0);\n-  access_public_virtual_node = build_int_2 (4 | ak_public, 0);\n-  access_protected_virtual_node = build_int_2 (4 | ak_protected, 0);\n-  access_private_virtual_node = build_int_2 (4 | ak_private, 0);\n-\n   ridpointers[(int) RID_PUBLIC] = access_public_node;\n   ridpointers[(int) RID_PRIVATE] = access_private_node;\n   ridpointers[(int) RID_PROTECTED] = access_protected_node;\n@@ -6778,102 +6559,24 @@ get_vtbl_decl_for_binfo (tree binfo)\n   return decl;\n }\n \n-/* Called from get_primary_binfo via dfs_walk.  DATA is a TREE_LIST\n-   who's TREE_PURPOSE is the TYPE of the required primary base and\n-   who's TREE_VALUE is a list of candidate binfos that we fill in.  */\n-\n-static tree\n-dfs_get_primary_binfo (tree binfo, void* data)\n-{\n-  tree cons = (tree) data;\n-  tree primary_base = TREE_PURPOSE (cons);\n \n-  if (TREE_VIA_VIRTUAL (binfo) \n-      && same_type_p (BINFO_TYPE (binfo), primary_base))\n-    /* This is the right type of binfo, but it might be an unshared\n-       instance, and the shared instance is later in the dfs walk.  We\n-       must keep looking.  */\n-    TREE_VALUE (cons) = tree_cons (NULL, binfo, TREE_VALUE (cons));\n-  \n-  return NULL_TREE;\n-}\n-\n-/* Returns the unshared binfo for the primary base of BINFO.  Note\n-   that in a complex hierarchy the resulting BINFO may not actually\n-   *be* primary.  In particular if the resulting BINFO is a virtual\n-   base, and it occurs elsewhere in the hierarchy, then this\n-   occurrence may not actually be a primary base in the complete\n-   object.  Check BINFO_PRIMARY_P to be sure.  */\n+/* Returns the binfo for the primary base of BINFO.  If the resulting\n+   BINFO is a virtual base, and it is inherited elsewhere in the\n+   hierarchy, then the returned binfo might not be the primary base of\n+   BINFO in the complete object.  Check BINFO_PRIMARY_P or\n+   BINFO_LOST_PRIMARY_P to be sure.  */\n \n tree\n get_primary_binfo (tree binfo)\n {\n   tree primary_base;\n-  tree result = NULL_TREE;\n-  tree virtuals;\n+  tree result;\n   \n   primary_base = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (binfo));\n   if (!primary_base)\n     return NULL_TREE;\n \n-  /* A non-virtual primary base is always a direct base, and easy to\n-     find.  */\n-  if (!TREE_VIA_VIRTUAL (primary_base))\n-    {\n-      int i;\n-\n-      /* Scan the direct basetypes until we find a base with the same\n-\t type as the primary base.  */\n-      for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-\t{\n-\t  tree base_binfo = BINFO_BASETYPE (binfo, i);\n-\t  \n-\t  if (same_type_p (BINFO_TYPE (base_binfo),\n-\t\t\t   BINFO_TYPE (primary_base)))\n-\t    return base_binfo;\n-\t}\n-\n-      /* We should always find the primary base.  */\n-      abort ();\n-    }\n-\n-  /* For a primary virtual base, we have to scan the entire hierarchy\n-     rooted at BINFO; the virtual base could be an indirect virtual\n-     base.  There could be more than one instance of the primary base\n-     in the hierarchy, and if one is the canonical binfo we want that\n-     one.  If it exists, it should be the first one we find, but as a\n-     consistency check we find them all and make sure.  */\n-  virtuals = build_tree_list (BINFO_TYPE (primary_base), NULL_TREE);\n-  dfs_walk (binfo, dfs_get_primary_binfo, NULL, virtuals);\n-  virtuals = TREE_VALUE (virtuals);\n-  \n-  /* We must have found at least one instance.  */\n-  my_friendly_assert (virtuals, 20010612);\n-\n-  if (TREE_CHAIN (virtuals))\n-    {\n-      /* We found more than one instance of the base.  If one is the\n-\t canonical one, choose that one.  */\n-      tree complete_binfo;\n-      tree canonical;\n-      \n-      for (complete_binfo = binfo;\n-\t   BINFO_INHERITANCE_CHAIN (complete_binfo);\n-\t   complete_binfo = BINFO_INHERITANCE_CHAIN (complete_binfo))\n-\tcontinue;\n-      canonical = binfo_for_vbase (BINFO_TYPE (primary_base),\n-\t\t\t\t   BINFO_TYPE (complete_binfo));\n-      \n-      for (; virtuals; virtuals = TREE_CHAIN (virtuals))\n-\t{\n-\t  result = TREE_VALUE (virtuals);\n-\n-\t  if (canonical == result)\n-\t    break;\n-\t}\n-    }\n-  else\n-    result = TREE_VALUE (virtuals);\n+  result = copied_binfo (primary_base, binfo);\n   return result;\n }\n \n@@ -6887,40 +6590,40 @@ maybe_indent_hierarchy (FILE * stream, int indent, int indented_p)\n   return 1;\n }\n \n-/* Dump the offsets of all the bases rooted at BINFO (in the hierarchy\n-   dominated by T) to stderr.  INDENT should be zero when called from\n-   the top level; it is incremented recursively.  */\n+/* Dump the offsets of all the bases rooted at BINFO to STREAM.\n+   INDENT should be zero when called from the top level; it is\n+   incremented recursively.  IGO indicates the next expected BINFO in\n+   inheritance graph ordering. */\n \n-static void\n-dump_class_hierarchy_r (FILE * stream,\n+static tree\n+dump_class_hierarchy_r (FILE *stream,\n                         int flags,\n-                        tree t,\n                         tree binfo,\n+                        tree igo,\n                         int indent)\n {\n-  int i;\n   int indented = 0;\n+  tree base_binfos;\n   \n   indented = maybe_indent_hierarchy (stream, indent, 0);\n   fprintf (stream, \"%s (0x%lx) \",\n \t   type_as_string (binfo, TFF_PLAIN_IDENTIFIER),\n \t   (unsigned long) binfo);\n+  if (binfo != igo)\n+    {\n+      fprintf (stream, \"alternative-path\\n\");\n+      return igo;\n+    }\n+  igo = TREE_CHAIN (binfo);\n+  \n   fprintf (stream, HOST_WIDE_INT_PRINT_DEC,\n \t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n   if (is_empty_class (BINFO_TYPE (binfo)))\n     fprintf (stream, \" empty\");\n   else if (CLASSTYPE_NEARLY_EMPTY_P (BINFO_TYPE (binfo)))\n     fprintf (stream, \" nearly-empty\");\n   if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree canonical = binfo_for_vbase (BINFO_TYPE (binfo), t);\n-\n-      fprintf (stream, \" virtual\");\n-      if (canonical == binfo)\n-        fprintf (stream, \" canonical\");\n-      else\n-        fprintf (stream, \" non-canonical\");\n-    }\n+    fprintf (stream, \" virtual\");\n   fprintf (stream, \"\\n\");\n \n   indented = 0;\n@@ -6977,11 +6680,22 @@ dump_class_hierarchy_r (FILE * stream,\n \tfprintf (stream, \"\\n\");\n     }\n   \n+  base_binfos = BINFO_BASETYPES (binfo);\n+  if (base_binfos)\n+    {\n+      int ix, n;\n \n-  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-    dump_class_hierarchy_r (stream, flags,\n-\t\t\t    t, BINFO_BASETYPE (binfo, i),\n-\t\t\t    indent + 2);\n+      n = TREE_VEC_LENGTH (base_binfos);\n+      for (ix = 0; ix != n; ix++)\n+\t{\n+\t  tree base_binfo = TREE_VEC_ELT (base_binfos, ix);\n+\n+\t  igo = dump_class_hierarchy_r (stream, flags, base_binfo,\n+\t\t\t\t\tigo, indent + 2);\n+\t}\n+    }\n+  \n+  return igo;\n }\n \n /* Dump the BINFO hierarchy for T.  */\n@@ -6999,7 +6713,12 @@ dump_class_hierarchy (tree t)\n   fprintf (stream, \"   size=%lu align=%lu\\n\",\n \t   (unsigned long)(tree_low_cst (TYPE_SIZE (t), 0) / BITS_PER_UNIT),\n \t   (unsigned long)(TYPE_ALIGN (t) / BITS_PER_UNIT));\n-  dump_class_hierarchy_r (stream, flags, t, TYPE_BINFO (t), 0);\n+  fprintf (stream, \"   base size=%lu base align=%lu\\n\",\n+\t   (unsigned long)(tree_low_cst (TYPE_SIZE (CLASSTYPE_AS_BASE (t)), 0)\n+\t\t\t   / BITS_PER_UNIT),\n+\t   (unsigned long)(TYPE_ALIGN (CLASSTYPE_AS_BASE (t))\n+\t\t\t   / BITS_PER_UNIT));\n+  dump_class_hierarchy_r (stream, flags, TYPE_BINFO (t), TYPE_BINFO (t), 0);\n   fprintf (stream, \"\\n\");\n   dump_end (TDI_class, stream);\n }\n@@ -7085,7 +6804,6 @@ finish_vtbls (tree t)\n {\n   tree list;\n   tree vbase;\n-  int i;\n \n   /* We lay out the primary and secondary vtables in one contiguous\n      vtable.  The primary vtable is first, followed by the non-virtual\n@@ -7097,29 +6815,9 @@ finish_vtbls (tree t)\n   /* Then come the virtual bases, also in inheritance graph order.  */\n   for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n     {\n-      tree real_base;\n-\t  \n       if (!TREE_VIA_VIRTUAL (vbase))\n \tcontinue;\n-          \n-      /* Although we walk in inheritance order, that might not get the\n-         canonical base.  */\n-      real_base = binfo_for_vbase (BINFO_TYPE (vbase), t);\n-          \n-      accumulate_vtbl_inits (real_base, real_base,\n-\t\t\t     TYPE_BINFO (t), t, list);\n-    }\n-\n-  /* Fill in BINFO_VPTR_FIELD in the immediate binfos for our virtual\n-     base classes, for the benefit of the debugging backends.  */\n-  for (i = 0; i < BINFO_N_BASETYPES (TYPE_BINFO (t)); ++i)\n-    {\n-      tree base = BINFO_BASETYPE (TYPE_BINFO (t), i);\n-      if (TREE_VIA_VIRTUAL (base))\n-\t{\n-\t  vbase = binfo_for_vbase (BINFO_TYPE (base), t);\n-\t  BINFO_VPTR_FIELD (base) = BINFO_VPTR_FIELD (vbase);\n-\t}\n+      accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), t, list);\n     }\n \n   if (TYPE_BINFO_VTABLE (t))\n@@ -7199,31 +6897,6 @@ build_vtt (tree t)\n   dump_vtt (t, vtt);\n }\n \n-/* The type corresponding to BASE_BINFO is a base of the type of BINFO, but\n-   from within some hierarchy which is inherited from the type of BINFO.\n-   Return BASE_BINFO's equivalent binfo from the hierarchy dominated by\n-   BINFO.  */\n-\n-static tree\n-get_original_base (tree base_binfo, tree binfo)\n-{\n-  tree derived;\n-  int ix;\n-  \n-  if (same_type_p (BINFO_TYPE (base_binfo), BINFO_TYPE (binfo)))\n-    return binfo;\n-  if (TREE_VIA_VIRTUAL (base_binfo))\n-    return binfo_for_vbase (BINFO_TYPE (base_binfo), BINFO_TYPE (binfo));\n-  derived = get_original_base (BINFO_INHERITANCE_CHAIN (base_binfo), binfo);\n-  \n-  for (ix = 0; ix != BINFO_N_BASETYPES (derived); ix++)\n-    if (same_type_p (BINFO_TYPE (base_binfo),\n-                     BINFO_TYPE (BINFO_BASETYPE (derived, ix))))\n-      return BINFO_BASETYPE (derived, ix);\n-  abort ();\n-  return NULL;\n-}\n-\n /* When building a secondary VTT, BINFO_VTABLE is set to a TREE_LIST with\n    PURPOSE the RTTI_BINFO, VALUE the real vtable pointer for this binfo,\n    and CHAIN the vtable pointer for this binfo after construction is\n@@ -7333,13 +7006,10 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   if (top_level_p)\n     for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n       {\n-\ttree vbase;\n-\t\n \tif (!TREE_VIA_VIRTUAL (b))\n \t  continue;\n \t\n-\tvbase = binfo_for_vbase (BINFO_TYPE (b), t);\n-\tinits = build_vtt_inits (vbase, t, inits, index);\n+\tinits = build_vtt_inits (b, t, inits, index);\n       }\n \n   if (!top_level_p)\n@@ -7376,7 +7046,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void* data)\n   t = TREE_CHAIN (l);\n   top_level_p = VTT_TOP_LEVEL_P (l);\n   \n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 1;\n \n   /* We don't care about bases that don't have vtables.  */\n   if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n@@ -7427,12 +7097,11 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void* data)\n    hierarchy.  */\n \n static tree\n-dfs_ctor_vtable_bases_queue_p (tree binfo, void* data)\n+dfs_ctor_vtable_bases_queue_p (tree derived, int ix,\n+\t\t\t       void* data)\n {\n-  if (TREE_VIA_VIRTUAL (binfo))\n-     /* Get the shared version.  */\n-    binfo = binfo_for_vbase (BINFO_TYPE (binfo), TREE_PURPOSE ((tree) data));\n-\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n   if (!BINFO_MARKED (binfo) == VTT_MARKED_BINFO_P ((tree) data))\n     return NULL_TREE;\n   return binfo;\n@@ -7446,7 +7115,7 @@ dfs_ctor_vtable_bases_queue_p (tree binfo, void* data)\n static tree\n dfs_fixup_binfo_vtbls (tree binfo, void* data)\n {\n-  CLEAR_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 0;\n \n   /* We don't care about bases that don't have vtables.  */\n   if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n@@ -7497,14 +7166,12 @@ build_ctor_vtbl_group (tree binfo, tree t)\n        vbase = TREE_CHAIN (vbase))\n     {\n       tree b;\n-      tree orig_base;\n \n       if (!TREE_VIA_VIRTUAL (vbase))\n \tcontinue;\n-      b = binfo_for_vbase (BINFO_TYPE (vbase), t);\n-      orig_base = binfo_for_vbase (BINFO_TYPE (vbase), BINFO_TYPE (binfo));\n+      b = copied_binfo (vbase, binfo);\n       \n-      accumulate_vtbl_inits (b, orig_base, binfo, t, list);\n+      accumulate_vtbl_inits (b, vbase, binfo, t, list);\n     }\n   inits = TREE_VALUE (list);\n \n@@ -7634,16 +7301,16 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \t either case, we share our vtable with LAST, i.e. the\n \t derived-most base within B of which we are a primary.  */\n       if (b == rtti_binfo\n-\t  || (b && binfo_for_vbase (BINFO_TYPE (b),\n-\t\t\t\t    BINFO_TYPE (rtti_binfo))))\n+\t  || (b && purpose_member (BINFO_TYPE (b),\n+\t\t\t\t   CLASSTYPE_VBASECLASSES (BINFO_TYPE (rtti_binfo)))))\n \t/* Just set our BINFO_VTABLE to point to LAST, as we may not have\n \t   set LAST's BINFO_VTABLE yet.  We'll extract the actual vptr in\n \t   binfo_ctor_vtable after everything's been set up.  */\n \tvtbl = last;\n \n       /* Otherwise, this is case 3 and we get our own.  */\n     }\n-  else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo, BINFO_TYPE (rtti_binfo)))\n+  else if (!BINFO_NEW_VTABLE_MARKED (orig_binfo))\n     return inits;\n \n   if (!vtbl)\n@@ -7746,7 +7413,7 @@ build_vtbl_initializer (tree binfo,\n   for (vbase = CLASSTYPE_VBASECLASSES (t); \n        vbase; \n        vbase = TREE_CHAIN (vbase))\n-    CLEAR_BINFO_VTABLE_PATH_MARKED (TREE_VALUE (vbase));\n+    BINFO_VTABLE_PATH_MARKED (TREE_VALUE (vbase)) = 0;\n \n   /* If the target requires padding between data entries, add that now.  */\n   if (TARGET_VTABLE_DATA_ENTRY_DISTANCE > 1)\n@@ -7950,13 +7617,13 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \n       /* Find the instance of this virtual base in the complete\n \t object.  */\n-      b = binfo_for_vbase (BINFO_TYPE (vbase), t);\n+      b = copied_binfo (vbase, binfo);\n \n       /* If we've already got an offset for this virtual base, we\n \t don't need another one.  */\n       if (BINFO_VTABLE_PATH_MARKED (b))\n \tcontinue;\n-      SET_BINFO_VTABLE_PATH_MARKED (b);\n+      BINFO_VTABLE_PATH_MARKED (b) = 1;\n \n       /* Figure out where we can find this vbase offset.  */\n       delta = size_binop (MULT_EXPR, \n@@ -7968,16 +7635,10 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \n       if (binfo != TYPE_BINFO (t))\n \t{\n-\t  tree orig_vbase;\n-\n-\t  /* Find the instance of this virtual base in the type of BINFO.  */\n-\t  orig_vbase = binfo_for_vbase (BINFO_TYPE (vbase),\n-\t\t\t\t\tBINFO_TYPE (binfo));\n-\n \t  /* The vbase offset had better be the same.  */\n-\t  if (!tree_int_cst_equal (delta,\n-\t\t\t\t   BINFO_VPTR_FIELD (orig_vbase)))\n-\t    abort ();\n+\t  my_friendly_assert (tree_int_cst_equal (delta,\n+\t\t\t\t\t\t  BINFO_VPTR_FIELD (vbase)),\n+\t\t\t      20030202);\n \t}\n \n       /* The next vbase will come at a more negative offset.  */\n@@ -8131,8 +7792,8 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n       if (vid->ctor_vtbl_p)\n \t/* For a ctor vtable we need the equivalent binfo within the hierarchy\n \t   where rtti_binfo is the most derived type.  */\n-\tnon_primary_binfo = get_original_base\n-          (non_primary_binfo, TYPE_BINFO (BINFO_TYPE (vid->rtti_binfo)));\n+\tnon_primary_binfo\n+\t  = original_binfo (non_primary_binfo, vid->rtti_binfo);\n       \n       for (base_virtuals = BINFO_VIRTUALS (binfo),\n \t     derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),"}, {"sha": "e463fb4b68c5f7a76c348ce2c3a320171dd786ad", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 41, "deletions": 108, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -58,7 +58,7 @@ struct diagnostic_context;\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (in _TYPE).\n       INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n       ICS_ELLIPSIS_FLAG (in _CONV)\n-      BINFO_ACCESS (in BINFO)\n+      BINFO_DEPENDENT_BASE_P (in BINFO)\n       DECL_INITIALIZED_P (in VAR_DECL)\n    2: IDENTIFIER_OPNAME_P.\n       TYPE_POLYMORPHIC_P (in _TYPE)\n@@ -79,7 +79,7 @@ struct diagnostic_context;\n       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n-   6: BINFO_ACCESS (in BINFO)\n+   6: For future expansion\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n@@ -592,15 +592,6 @@ enum cp_tree_index\n     CPTI_GLOBAL_DELETE_FNDECL,\n     CPTI_AGGR_TAG,\n \n-    CPTI_ACCESS_DEFAULT,\n-    CPTI_ACCESS_PUBLIC,\n-    CPTI_ACCESS_PROTECTED,\n-    CPTI_ACCESS_PRIVATE,\n-    CPTI_ACCESS_DEFAULT_VIRTUAL,\n-    CPTI_ACCESS_PUBLIC_VIRTUAL,\n-    CPTI_ACCESS_PROTECTED_VIRTUAL,\n-    CPTI_ACCESS_PRIVATE_VIRTUAL,\n-\n     CPTI_CTOR_IDENTIFIER,\n     CPTI_COMPLETE_CTOR_IDENTIFIER,\n     CPTI_BASE_CTOR_IDENTIFIER,\n@@ -682,19 +673,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n \n-/* Define the sets of attributes that member functions and baseclasses\n-   can have.  These are sensible combinations of {public,private,protected}\n-   cross {virtual,non-virtual}.  */\n-\n-#define access_default_node             cp_global_trees[CPTI_ACCESS_DEFAULT]\n-#define access_public_node              cp_global_trees[CPTI_ACCESS_PUBLIC]\n-#define access_protected_node           cp_global_trees[CPTI_ACCESS_PROTECTED]\n-#define access_private_node             cp_global_trees[CPTI_ACCESS_PRIVATE]\n-#define access_default_virtual_node     cp_global_trees[CPTI_ACCESS_DEFAULT_VIRTUAL]\n-#define access_public_virtual_node      cp_global_trees[CPTI_ACCESS_PUBLIC_VIRTUAL]\n-#define access_protected_virtual_node   cp_global_trees[CPTI_ACCESS_PROTECTED_VIRTUAL]\n-#define access_private_virtual_node     cp_global_trees[CPTI_ACCESS_PRIVATE_VIRTUAL]\n-\n /* We cache these tree nodes so as to call get_identifier less\n    frequently.  */\n \n@@ -768,6 +746,11 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n #define keyed_classes                   cp_global_trees[CPTI_KEYED_CLASSES]\n \n+/* Node to indicate default access. This must be distinct from the\n+   access nodes in tree.h.  */\n+\n+#define access_default_node\t\tnull_node\n+\n /* Global state.  */\n \n struct saved_scope GTY(())\n@@ -1414,21 +1397,9 @@ struct lang_type GTY(())\n /* A chain of BINFOs for the direct and indirect virtual base classes\n    that this type uses in a post-order depth-first left-to-right\n    order.  (In other words, these bases appear in the order that they\n-   should be initialized.)  If a virtual base is primary, then the\n-   primary copy will appear on this list.  Thus, the BINFOs on this\n-   list are all \"real\"; they are the same BINFOs that will be\n-   encountered when using dfs_unmarked_real_bases_queue_p and related\n-   functions.  */\n+   should be initialized.)  */\n #define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n \n-/* For a non-virtual BINFO, the BINFO itself; for a virtual BINFO, the\n-   binfo_for_vbase.  C is the most derived class for the hierarchy\n-   containing BINFO.  */\n-#define CANONICAL_BINFO(BINFO, C)\t\t\\\n-  (TREE_VIA_VIRTUAL (BINFO)\t\t\t\\\n-   ? binfo_for_vbase (BINFO_TYPE (BINFO), C)\t\\\n-   : (BINFO))\n-\n /* Number of direct baseclasses of NODE.  */\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n@@ -1551,72 +1522,35 @@ struct lang_type GTY(())\n /* Additional macros for inheritance information.  */\n \n /* The BINFO_INHERITANCE_CHAIN is used opposite to the description in\n-   gcc/tree.h.  In particular if D is derived from B then the BINFO\n-   for B (in D) will have a BINFO_INHERITANCE_CHAIN pointing to\n-   D.  In tree.h, this pointer is described as pointing in other\n-   direction.  There is a different BINFO for each path to a virtual\n-   base; BINFOs for virtual bases are not shared.\n-\n-   We use TREE_VIA_PROTECTED and TREE_VIA_PUBLIC, but private\n-   inheritance is indicated by the absence of the other two flags, not\n-   by TREE_VIA_PRIVATE, which is unused.  */\n-\n-/* Mark the binfo, whether shared or not. Each instance of a virtual\n-   base can be separately marked.  */\n-#define BINFO_UNSHARED_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n+   gcc/tree.h.  In particular if D is non-virtually derived from B\n+   then the BINFO for B (in D) will have a BINFO_INHERITANCE_CHAIN\n+   pointing to D.  If D is virtually derived, its\n+   BINFO_INHERITANCE_CHAIN will point to the most derived binfo. In\n+   tree.h, this pointer is described as pointing in other\n+   direction.  The binfos of virtual bases are shared.  */\n \n /* Nonzero means marked by DFS or BFS search.  */\n-#define BINFO_MARKED(NODE)\t\t\t\\\n-  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n-   ? CLASSTYPE_MARKED (BINFO_TYPE (NODE))\t\\\n-   : TREE_LANG_FLAG_0 (NODE))\n-/* Macros needed because of C compilers that don't allow conditional\n-   expressions to be lvalues.  Grr!  */\n-#define SET_BINFO_MARKED(NODE)\t\t\t\\\n-  (TREE_VIA_VIRTUAL(NODE)\t\t\t\\\n-   ? SET_CLASSTYPE_MARKED (BINFO_TYPE (NODE))\t\\\n-   : (void)(TREE_LANG_FLAG_0 (NODE) = 1))\n-#define CLEAR_BINFO_MARKED(NODE)\t\t\\\n-  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n-   ? CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (NODE))\t\\\n-   : (void)(TREE_LANG_FLAG_0 (NODE) = 0))\n+#define BINFO_MARKED(NODE)   TREE_LANG_FLAG_0 (NODE)\n \n /* Nonzero means that this class is on a path leading to a new vtable.  */\n-#define BINFO_VTABLE_PATH_MARKED(NODE)\t\t\\\n-  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n-   ? CLASSTYPE_MARKED3 (BINFO_TYPE (NODE))\t\\\n-   : TREE_LANG_FLAG_3 (NODE))\n-#define SET_BINFO_VTABLE_PATH_MARKED(NODE)\t\\\n-  (TREE_VIA_VIRTUAL(NODE)\t\t\t\\\n-   ? SET_CLASSTYPE_MARKED3 (BINFO_TYPE (NODE))\t\\\n-   : (TREE_LANG_FLAG_3 (NODE) = 1))\n-#define CLEAR_BINFO_VTABLE_PATH_MARKED(NODE)\t\\\n-  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n-   ? CLEAR_CLASSTYPE_MARKED3 (BINFO_TYPE (NODE))\\\n-   : (TREE_LANG_FLAG_3 (NODE) = 0))\n-\n-/* Nonzero means B (a BINFO) has its own vtable.  Under the old ABI,\n-   secondary vtables are sometimes shared.  Any copies will not have\n-   this flag set.\n-\n-   B is part of the hierarchy dominated by C.  */\n-#define BINFO_NEW_VTABLE_MARKED(B, C) \\\n-  (TREE_LANG_FLAG_4 (CANONICAL_BINFO (B, C)))\n+#define BINFO_VTABLE_PATH_MARKED(NODE) TREE_LANG_FLAG_3 (NODE)\n+\n+/* Nonzero means B (a BINFO) has its own vtable.  Any copies will not\n+   have this flag set. */\n+#define BINFO_NEW_VTABLE_MARKED(B) (TREE_LANG_FLAG_4 (B))\n \n /* Any subobject that needs a new vtable must have a vptr and must not\n    be a non-virtual primary base (since it would then use the vtable from a\n    derived class and never become non-primary.)  */\n-#define SET_BINFO_NEW_VTABLE_MARKED(B, C)\t\t\t\t \\\n-  (BINFO_NEW_VTABLE_MARKED (B, C) = 1,\t\t\t\t\t \\\n+#define SET_BINFO_NEW_VTABLE_MARKED(B)\t\t\t\t\t \\\n+  (BINFO_NEW_VTABLE_MARKED (B) = 1,\t\t\t\t\t \\\n    my_friendly_assert (!BINFO_PRIMARY_P (B)\t\t\t\t \\\n \t\t       || TREE_VIA_VIRTUAL (B), 20000517),\t\t \\\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n \t\t       20000517))\n \n /* Nonzero means this class has done dfs_pushdecls.  */\n #define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n-#define SET_BINFO_PUSHDECLS_MARKED(NODE) SET_BINFO_VTABLE_PATH_MARKED (NODE)\n-#define CLEAR_BINFO_PUSHDECLS_MARKED(NODE) CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n \n /* Nonzero if this BINFO is a primary base class.  Note, this can be\n    set for non-canononical virtual bases. For a virtual primary base\n@@ -1643,6 +1577,10 @@ struct lang_type GTY(())\n \n #define BINFO_LANG_ELTS (BINFO_ELTS + 3)\n \n+/* Nonzero if this binfo is for a dependent base - one that should not\n+   be searched.  */\n+#define BINFO_DEPENDENT_BASE_P(NODE) TREE_LANG_FLAG_1(NODE)\n+\n /* Nonzero if this binfo has lost its primary base binfo (because that\n    is a nearly-empty virtual base that has been taken by some other\n    base in the complete hierarchy.  */\n@@ -3077,7 +3015,7 @@ typedef enum tmpl_spec_kind {\n /* The various kinds of access.  BINFO_ACCESS depends on these being\n    two bit quantities.  The numerical values are important; they are\n    used to initialize RTTI data structures, so changing them changes\n-   the ABI.  */\n+   the ABI.   */\n typedef enum access_kind {\n   ak_none = 0,             /* Inaccessible.  */\n   ak_public = 1,           /* Accessible, as a `public' thing.  */\n@@ -4142,28 +4080,24 @@ extern tree binfo_from_vbase\t\t\t(tree);\n extern tree look_for_overrides_here\t\t(tree, tree);\n extern int check_final_overrider\t\t(tree, tree);\n extern tree dfs_walk                            (tree,\n-\t\t\t\t\t\t       tree (*) (tree, void *),\n-\t\t\t\t\t\t       tree (*) (tree, void *),\n-\t\t\t\t\t\t       void *);\n+\t\t\t\t\t\t tree (*) (tree, void *),\n+\t\t\t\t\t\t tree (*) (tree, int, void *),\n+\t\t\t\t\t\t void *);\n extern tree dfs_walk_real                      (tree,\n-\t\t\t\t\t\t       tree (*) (tree, void *),\n-\t\t\t\t\t\t       tree (*) (tree, void *),\n-\t\t\t\t\t\t       tree (*) (tree, void *),\n-\t\t\t\t\t\t       void *);\n+\t\t\t\t\t\ttree (*) (tree, void *),\n+\t\t\t\t\t\ttree (*) (tree, void *),\n+\t\t\t\t\t\ttree (*) (tree, int, void *),\n+\t\t\t\t\t\tvoid *);\n extern tree dfs_unmark                          (tree, void *);\n-extern tree markedp                             (tree, void *);\n-extern tree unmarkedp                           (tree, void *);\n-extern tree dfs_unmarked_real_bases_queue_p     (tree, void *);\n-extern tree dfs_marked_real_bases_queue_p       (tree, void *);\n-extern tree dfs_skip_vbases                     (tree, void *);\n-extern tree marked_vtable_pathp                 (tree, void *);\n-extern tree unmarked_vtable_pathp               (tree, void *);\n-extern tree find_vbase_instance                 (tree, tree);\n-extern tree binfo_for_vbase                     (tree, tree);\n+extern tree markedp                             (tree, int, void *);\n+extern tree unmarkedp                           (tree, int, void *);\n extern tree binfo_via_virtual                   (tree, tree);\n extern tree build_baselink                      (tree, tree, tree, tree);\n extern tree adjust_result_of_qualified_name_lookup\n                                                 (tree, tree, tree);\n+extern tree copied_binfo\t\t\t(tree, tree);\n+extern tree original_binfo\t\t\t(tree, tree);\n+\n /* in semantics.c */\n extern void push_deferring_access_checks\t(bool defer_p);\n extern void resume_deferring_access_checks\t(void);\n@@ -4245,7 +4179,7 @@ extern void finish_default_args                 (void);\n extern tree finish_member_class_template        (tree);\n extern void finish_template_decl                (tree);\n extern tree finish_template_type                (tree, tree, int);\n-extern tree finish_base_specifier               (tree, tree);\n+extern tree finish_base_specifier               (tree, tree, bool);\n extern void finish_member_declaration           (tree);\n extern void check_multiple_declarators          (void);\n extern tree finish_typeof\t\t\t(tree);\n@@ -4275,7 +4209,7 @@ extern void init_tree\t\t\t        (void);\n extern int pod_type_p\t\t\t\t(tree);\n extern int zero_init_p\t\t\t\t(tree);\n extern tree canonical_type_variant              (tree);\n-extern void unshare_base_binfos\t\t\t(tree);\n+extern tree copy_base_binfos\t\t\t(tree, tree, tree);\n extern int member_p\t\t\t\t(tree);\n extern cp_lvalue_kind real_lvalue_p\t\t(tree);\n extern int non_cast_lvalue_p\t\t\t(tree);\n@@ -4293,7 +4227,6 @@ extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern tree hash_chainon\t\t\t(tree, tree);\n extern tree make_binfo\t\t\t\t(tree, tree, tree, tree);\n-extern tree reverse_path\t\t\t(tree);\n extern int count_functions\t\t\t(tree);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree get_first_fn\t\t\t(tree);"}, {"sha": "3f22b748618b2be598dba8214669093cf4d3f5c1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 124, "deletions": 122, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -12829,17 +12829,17 @@ xref_tag_from_type (tree old, tree id, int globalize)\n }\n \n /* REF is a type (named NAME), for which we have just seen some\n-   baseclasses.  BINFO is a list of those baseclasses; the\n+   baseclasses.  BASE_LIST is a list of those baseclasses; the\n    TREE_PURPOSE is an access_* node, and the TREE_VALUE is the type of\n-   the base-class.  CODE_TYPE_NODE indicates whether REF is a class,\n+   the base-class.  TREE_VIA_VIRTUAL indicates virtual\n+   inheritance. CODE_TYPE_NODE indicates whether REF is a class,\n    struct, or union.  */\n \n void\n-xref_basetypes (tree ref, tree binfo)\n+xref_basetypes (tree ref, tree base_list)\n {\n   /* In the declaration `A : X, Y, ... Z' we mark all the types\n      (A, X, Y, ..., Z) so we can check for duplicates.  */\n-  tree binfos;\n   tree *basep;\n \n   int i;\n@@ -12857,145 +12857,147 @@ xref_basetypes (tree ref, tree binfo)\n      instantiated.  This ensures that if we call ourselves recursively\n      we do not get confused about which classes are marked and which\n      are not.  */\n-  basep = &binfo; \n+  basep = &base_list; \n   while (*basep) \n     {\n       tree basetype = TREE_VALUE (*basep);\n       if (!(processing_template_decl && uses_template_parms (basetype))\n \t  && !complete_type_or_else (basetype, NULL))\n-\t/* An incomplete type.  Remove it form the list.  */\n+\t/* An incomplete type.  Remove it from the list.  */\n \t*basep = TREE_CHAIN (*basep);\n       else\n \tbasep = &TREE_CHAIN (*basep);\n     }\n \n   SET_CLASSTYPE_MARKED (ref);\n-  BINFO_BASETYPES (TYPE_BINFO (ref)) = binfos \n-    = make_tree_vec (list_length (binfo));\n-\n-  for (i = 0; binfo; binfo = TREE_CHAIN (binfo))\n-    {\n-      /* The base of a derived struct is public by default.  */\n-      int via_public\n-\t= (TREE_PURPOSE (binfo) == access_public_node\n-\t   || TREE_PURPOSE (binfo) == access_public_virtual_node\n-\t   || (tag_code != class_type\n-\t       && (TREE_PURPOSE (binfo) == access_default_node\n-\t\t   || TREE_PURPOSE (binfo) == access_default_virtual_node)));\n-      int via_protected\n-\t= (TREE_PURPOSE (binfo) == access_protected_node\n-\t   || TREE_PURPOSE (binfo) == access_protected_virtual_node);\n-      int via_virtual\n-\t= (TREE_PURPOSE (binfo) == access_private_virtual_node\n-\t   || TREE_PURPOSE (binfo) == access_protected_virtual_node\n-\t   || TREE_PURPOSE (binfo) == access_public_virtual_node\n-\t   || TREE_PURPOSE (binfo) == access_default_virtual_node);\n-      tree basetype = TREE_VALUE (binfo);\n-      tree base_binfo;\n-\n-      if (basetype && TREE_CODE (basetype) == TYPE_DECL)\n-\tbasetype = TREE_TYPE (basetype);\n-      if (!basetype\n-\t  || (TREE_CODE (basetype) != RECORD_TYPE\n-\t      && TREE_CODE (basetype) != TYPENAME_TYPE\n-\t      && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n-\t      && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM))\n-\t{\n-\t  error (\"base type `%T' fails to be a struct or class type\",\n-\t\t    TREE_VALUE (binfo));\n-\t  continue;\n-\t}\n-\n-      if (CLASSTYPE_MARKED (basetype))\n+  i = list_length (base_list);\n+  if (i)\n+    {\n+      tree binfo = TYPE_BINFO (ref);\n+      tree binfos = make_tree_vec (i);\n+      tree accesses = make_tree_vec (i);\n+      \n+      BINFO_BASETYPES (binfo) = binfos;\n+      BINFO_BASEACCESSES (binfo) = accesses;\n+  \n+      for (i = 0; base_list; base_list = TREE_CHAIN (base_list))\n \t{\n-\t  if (basetype == ref)\n-\t    error (\"recursive type `%T' undefined\", basetype);\n+\t  tree access = TREE_PURPOSE (base_list);\n+\t  int via_virtual = TREE_VIA_VIRTUAL (base_list);\n+\t  tree basetype = TREE_VALUE (base_list);\n+\t  tree base_binfo;\n+\t  \n+\t  if (access == access_default_node)\n+\t    /* The base of a derived struct is public by default.  */\n+\t    access = (tag_code == class_type\n+\t\t      ? access_private_node : access_public_node);\n+\t  \n+\t  if (basetype && TREE_CODE (basetype) == TYPE_DECL)\n+\t    basetype = TREE_TYPE (basetype);\n+\t  if (!basetype\n+\t      || (TREE_CODE (basetype) != RECORD_TYPE\n+\t\t  && TREE_CODE (basetype) != TYPENAME_TYPE\n+\t\t  && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n+\t\t  && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM))\n+\t    {\n+\t      error (\"base type `%T' fails to be a struct or class type\",\n+\t\t     basetype);\n+\t      continue;\n+\t    }\n+\t  \n+\t  if (CLASSTYPE_MARKED (basetype))\n+\t    {\n+\t      if (basetype == ref)\n+\t\terror (\"recursive type `%T' undefined\", basetype);\n+\t      else\n+\t\terror (\"duplicate base type `%T' invalid\", basetype);\n+\t      continue;\n+\t    }\n+\t  \n+\t  if (TYPE_FOR_JAVA (basetype)\n+\t      && (current_lang_depth () == 0))\n+\t    TYPE_FOR_JAVA (ref) = 1;\n+\t  \n+\t  if (CLASS_TYPE_P (basetype))\n+\t    {\n+\t      base_binfo = TYPE_BINFO (basetype);\n+\t      /* This flag will be in the binfo of the base type, we must\n+\t     \t clear it after copying the base binfos.  */\n+\t      BINFO_DEPENDENT_BASE_P (base_binfo)\n+\t\t= dependent_type_p (basetype);\n+\t    }\n \t  else\n-\t    error (\"duplicate base type `%T' invalid\", basetype);\n-\t  continue;\n+\t    base_binfo = make_binfo (size_zero_node, basetype,\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t  \n+\t  TREE_VEC_ELT (binfos, i) = base_binfo;\n+\t  TREE_VEC_ELT (accesses, i) = access;\n+\t  /* This flag will be in the binfo of the base type, we must\n+\t     clear it after copying the base binfos.  */\n+\t  TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n+\t  \n+\t  SET_CLASSTYPE_MARKED (basetype);\n+\t  \n+\t  /* We are free to modify these bits because they are meaningless\n+\t     at top level, and BASETYPE is a top-level type.  */\n+\t  if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t    {\n+\t      TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n+\t      /* Converting to a virtual base class requires looking\n+\t     \t up the offset of the virtual base.  */\n+\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n+\t    }\n+\t  \n+\t  if (CLASS_TYPE_P (basetype))\n+\t    {\n+\t      TYPE_HAS_NEW_OPERATOR (ref)\n+\t\t|= TYPE_HAS_NEW_OPERATOR (basetype);\n+\t      TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n+\t\t|= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n+\t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n+\t      /* If the base-class uses multiple inheritance, so do we.  */\n+\t      TYPE_USES_MULTIPLE_INHERITANCE (ref)\n+\t\t|= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n+\t      /* Likewise, if converting to a base of the base may require\n+\t     \t code, then we may need to generate code to convert to a\n+\t     \t base as well.  */\n+\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n+\t\t|= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n+\t    }\n+\t  i++;\n \t}\n-\n-      if (TYPE_FOR_JAVA (basetype)\n-\t  && (current_lang_depth () == 0))\n-\tTYPE_FOR_JAVA (ref) = 1;\n-\n-      /* Note that the BINFO records which describe individual\n-\t inheritances are *not* shared in the lattice!  They\n-\t cannot be shared because a given baseclass may be\n-\t inherited with different `accessibility' by different\n-\t derived classes.  (Each BINFO record describing an\n-\t individual inheritance contains flags which say what\n-\t the `accessibility' of that particular inheritance is.)  */\n-\n-      base_binfo\n-\t= make_binfo (size_zero_node, basetype,\n-\t\t      CLASS_TYPE_P (basetype)\n-\t\t      ? TYPE_BINFO_VTABLE (basetype) : NULL_TREE,\n-\t\t      CLASS_TYPE_P (basetype)\n-\t\t      ? TYPE_BINFO_VIRTUALS (basetype) : NULL_TREE);\n-\n-      TREE_VEC_ELT (binfos, i) = base_binfo;\n-      TREE_VIA_PUBLIC (base_binfo) = via_public;\n-      TREE_VIA_PROTECTED (base_binfo) = via_protected;\n-      TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n-      BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n-\n-      /* We need to unshare the binfos now so that lookups during class\n-\t definition work.  */\n-      unshare_base_binfos (base_binfo);\n-\n-      SET_CLASSTYPE_MARKED (basetype);\n-\n-      /* We are free to modify these bits because they are meaningless\n-\t at top level, and BASETYPE is a top-level type.  */\n-      if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t{\n-\t  TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n-\t  /* Converting to a virtual base class requires looking\n-\t     up the offset of the virtual base.  */\n+      if (i)\n+\tTREE_VEC_LENGTH (accesses) = TREE_VEC_LENGTH (binfos) = i;\n+      else\n+\tBINFO_BASEACCESSES (binfo) = BINFO_BASETYPES (binfo) = NULL_TREE;\n+      \n+      if (i > 1)\n+\t{\n+\t  TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n+\t  /* If there is more than one non-empty they cannot be at the same\n+\t     address.  */\n \t  TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n \t}\n-\n+    }\n+  \n+  /* Copy the base binfos, collect the virtual bases and set the\n+     inheritance order chain.  */\n+  copy_base_binfos (TYPE_BINFO (ref), ref, NULL_TREE);\n+  CLASSTYPE_VBASECLASSES (ref) = nreverse (CLASSTYPE_VBASECLASSES (ref));\n+  \n+  /* Unmark all the types.  */\n+  while (i--)\n+    {\n+      tree basetype = BINFO_TYPE (BINFO_BASETYPE (TYPE_BINFO (ref), i));\n+      \n+      CLEAR_CLASSTYPE_MARKED (basetype);\n       if (CLASS_TYPE_P (basetype))\n \t{\n-\t  TYPE_HAS_NEW_OPERATOR (ref)\n-\t    |= TYPE_HAS_NEW_OPERATOR (basetype);\n-\t  TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n-\t    |= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n-\t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n-\t  /* If the base-class uses multiple inheritance, so do we.  */\n-\t  TYPE_USES_MULTIPLE_INHERITANCE (ref)\n-\t    |= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n-\t  /* Likewise, if converting to a base of the base may require\n-\t     code, then we may need to generate code to convert to a\n-\t     base as well.  */\n-\t  TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n-\t    |= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n+\t  TREE_VIA_VIRTUAL (TYPE_BINFO (basetype)) = 0;\n+\t  BINFO_DEPENDENT_BASE_P (TYPE_BINFO (basetype)) = 0;\n \t}\n-\n-      i += 1;\n-    }\n-  if (i)\n-    TREE_VEC_LENGTH (binfos) = i;\n-  else\n-    BINFO_BASETYPES (TYPE_BINFO (ref)) = NULL_TREE;\n-\n-  if (i > 1)\n-    {\n-      TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n-      /* If there is more than one non-empty they cannot be at the same\n-\t address.  */\n-      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n     }\n-\n-  /* Unmark all the types.  */\n-  while (--i >= 0)\n-    CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (TREE_VEC_ELT (binfos, i)));\n   CLEAR_CLASSTYPE_MARKED (ref);\n-\n-  /* Now that we know all the base-classes, set up the list of virtual\n-     bases.  */\n-  get_vbase_types (ref);\n }\n \n \f"}, {"sha": "7036aa02fb6475617a08bf0dc3afe264eeb560b3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,6 +1,6 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -127,7 +127,7 @@ dfs_initialize_vtbl_ptrs (binfo, data)\n       expand_virtual_init (binfo, base_ptr);\n     }\n \n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 1;\n \n   return NULL_TREE;\n }\n@@ -149,10 +149,9 @@ initialize_vtbl_ptrs (addr)\n      class.  We do these in pre-order because can't find the virtual\n      bases for a class until we've initialized the vtbl for that\n      class.  */\n-  dfs_walk_real (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs, \n-\t\t NULL, dfs_unmarked_real_bases_queue_p, list);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark,\n-\t    dfs_marked_real_bases_queue_p, type);\n+  dfs_walk_real (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs,\n+\t\t NULL, unmarkedp, list);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, type);\n }\n \n /* Return an expression for the zero-initialization of an object with\n@@ -1001,15 +1000,9 @@ expand_member_init (tree name, tree init)\n \n       binfo = lookup_base (current_class_type, basetype, \n \t\t\t   ba_ignore, NULL);\n-      if (binfo)\n-\t{\n-\t  if (TREE_VIA_VIRTUAL (binfo))\n-\t    binfo = binfo_for_vbase (basetype, current_class_type);\n-\t  else if (BINFO_INHERITANCE_CHAIN (binfo) \n-\t\t   != TYPE_BINFO (current_class_type))\n-\t    binfo = NULL_TREE;\n-\t}\n-      if (!binfo)\n+      if (!binfo || (!TREE_VIA_VIRTUAL (binfo)\n+\t\t     && (BINFO_INHERITANCE_CHAIN (binfo)\n+\t\t\t != TYPE_BINFO (current_class_type))))\n \t{\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n \t    error (\"type `%D' is not a direct or virtual base of `%T'\",\n@@ -1019,9 +1012,7 @@ expand_member_init (tree name, tree init)\n \t\t   name, current_class_type);\n \t  return NULL_TREE;\n \t}\n-\n-      if (binfo)\n-\treturn build_tree_list (binfo, init);\n+      return build_tree_list (binfo, init);\n     }\n   else\n     {"}, {"sha": "79ec8be641790196cdad2d081a8bec948394b800", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -12419,22 +12419,13 @@ cp_parser_base_clause (cp_parser* parser)\n static tree\n cp_parser_base_specifier (cp_parser* parser)\n {\n-  static const tree *const access_nodes[][2] =\n-  {\n-    /* This ordering must match the access_kind enumeration.  */\n-    {&access_default_node,   &access_default_virtual_node},\n-    {&access_public_node,    &access_public_virtual_node},\n-    {&access_protected_node, &access_protected_virtual_node},\n-    {&access_private_node,   &access_private_virtual_node}\n-  };\n   cp_token *token;\n   bool done = false;\n   bool virtual_p = false;\n   bool duplicate_virtual_error_issued_p = false;\n   bool duplicate_access_error_issued_p = false;\n   bool class_scope_p, template_p;\n-  access_kind access = ak_none;\n-  tree access_node;\n+  tree access = access_default_node;\n   tree type;\n \n   /* Process the optional `virtual' and `access-specifier'.  */\n@@ -12466,16 +12457,15 @@ cp_parser_base_specifier (cp_parser* parser)\n \tcase RID_PRIVATE:\n \t  /* If more than one access specifier appears, issue an\n \t     error.  */\n-\t  if (access != ak_none && !duplicate_access_error_issued_p)\n+\t  if (access != access_default_node\n+\t      && !duplicate_access_error_issued_p)\n \t    {\n \t      cp_parser_error (parser,\n \t\t\t       \"more than one access specifier in base-specified\");\n \t      duplicate_access_error_issued_p = true;\n \t    }\n \n-\t  access = ((access_kind) \n-\t\t    tree_low_cst (ridpointers[(int) token->keyword],\n-\t\t\t\t  /*pos=*/1));\n+\t  access = ridpointers[(int) token->keyword];\n \n \t  /* Consume the access-specifier.  */\n \t  cp_lexer_consume_token (parser->lexer);\n@@ -12488,9 +12478,6 @@ cp_parser_base_specifier (cp_parser* parser)\n \t}\n     }\n \n-  /* Map `virtual_p' and `access' onto one of the access tree-nodes.  */\n-  access_node = *access_nodes[access][virtual_p];\n-  \n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n   /* Look for the nested-name-specifier.  The simplest way to\n@@ -12526,7 +12513,7 @@ cp_parser_base_specifier (cp_parser* parser)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  return finish_base_specifier (access_node, TREE_TYPE (type));\n+  return finish_base_specifier (TREE_TYPE (type), access, virtual_p);\n }\n \n /* Exception handling [gram.exception] */"}, {"sha": "add427d4ed1b8b541ef57a0856340d67863d7968", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -5146,7 +5146,8 @@ instantiate_class_template (type)\n {\n   tree template, args, pattern, t, member;\n   tree typedecl;\n-\n+  tree pbinfo;\n+  \n   if (type == error_mark_node)\n     return error_mark_node;\n \n@@ -5277,10 +5278,13 @@ instantiate_class_template (type)\n   if (ANON_AGGR_TYPE_P (pattern))\n     SET_ANON_AGGR_TYPE_P (type);\n \n-  if (TYPE_BINFO_BASETYPES (pattern))\n+  pbinfo = TYPE_BINFO (pattern);\n+  \n+  if (BINFO_BASETYPES (pbinfo))\n     {\n       tree base_list = NULL_TREE;\n-      tree pbases = TYPE_BINFO_BASETYPES (pattern);\n+      tree pbases = BINFO_BASETYPES (pbinfo);\n+      tree paccesses = BINFO_BASEACCESSES (pbinfo);\n       int i;\n \n       /* Substitute into each of the bases to determine the actual\n@@ -5292,33 +5296,15 @@ instantiate_class_template (type)\n \t  tree pbase;\n \n \t  pbase = TREE_VEC_ELT (pbases, i);\n+\t  access = TREE_VEC_ELT (paccesses, i);\n \n \t  /* Substitute to figure out the base class.  */\n \t  base = tsubst (BINFO_TYPE (pbase), args, tf_error, NULL_TREE);\n \t  if (base == error_mark_node)\n \t    continue;\n-\n-\t  /* Calculate the correct access node.  */\n-\t  if (TREE_VIA_VIRTUAL (pbase)) \n-\t    {\n-\t      if (TREE_VIA_PUBLIC (pbase))\n-\t\taccess = access_public_virtual_node;\n-\t      else if (TREE_VIA_PROTECTED (pbase))\n-\t\taccess = access_protected_virtual_node;\n-\t      else \n-\t\taccess = access_private_virtual_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TREE_VIA_PUBLIC (pbase))\n-\t\taccess = access_public_node;\n-\t      else if (TREE_VIA_PROTECTED (pbase))\n-\t\taccess = access_protected_node;\n-\t      else \n-\t\taccess = access_private_node;\n-\t    }\n-\n+\t  \n \t  base_list = tree_cons (access, base, base_list);\n+\t  TREE_VIA_VIRTUAL (base_list) = TREE_VIA_VIRTUAL (pbase);\n \t}\n \n       /* The list is now in reverse order; correct that.  */\n@@ -9161,7 +9147,7 @@ get_template_base_recursive (tparms, targs, parm,\n       /* When searching for a non-virtual, we cannot mark virtually\n \t found binfos.  */\n       if (! this_virtual)\n-\tSET_BINFO_MARKED (base_binfo);\n+\tBINFO_MARKED (base_binfo) = 1;\n       \n       rval = get_template_base_recursive (tparms, targs,\n \t\t\t\t\t  parm,"}, {"sha": "9ebae8b5448e302429faf4e1c75db84cfd3daae5", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1039,6 +1039,7 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n \t  tree binfo = TYPE_BINFO (type);\n           int nbases = BINFO_N_BASETYPES (binfo);\n           tree base_binfos = BINFO_BASETYPES (binfo);\n+\t  tree base_accesses = BINFO_BASEACCESSES (binfo);\n           tree base_inits = NULL_TREE;\n           int ix;\n           \n@@ -1051,15 +1052,14 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n               tree tinfo;\n               tree offset;\n               \n-              if (TREE_PUBLIC (base_binfo))\n+              if (TREE_VEC_ELT (base_accesses, ix) == access_public_node)\n                 flags |= 2;\n               tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n \t\t{\n \t\t   /* We store the vtable offset at which the virtual\n        \t\t      base offset can be found.  */\n-\t\t  offset = BINFO_VPTR_FIELD\n-\t\t    (binfo_for_vbase (BINFO_TYPE (base_binfo), type));\n+\t\t  offset = BINFO_VPTR_FIELD (base_binfo);\n \t\t  offset = convert (sizetype, offset);\n \t\t  flags |= 1;\n \t\t}\n@@ -1187,12 +1187,14 @@ get_pseudo_ti_desc (tree type)\n \treturn class_desc_type_node;\n       else\n \t{\n-\t  tree base_binfo =\n-\t    TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), 0);\n-\t  int num_bases = BINFO_N_BASETYPES (TYPE_BINFO (type));\n+\t  tree binfo = TYPE_BINFO (type);\n+\t  tree base_binfos = BINFO_BASETYPES (binfo);\n+\t  tree base_accesses = BINFO_BASEACCESSES (binfo);\n+\t  tree base_binfo = TREE_VEC_ELT (base_binfos, 0);\n+\t  int num_bases = TREE_VEC_LENGTH (base_binfos);\n \t  \n \t  if (num_bases == 1\n-\t      && TREE_PUBLIC (base_binfo)\n+\t      && TREE_VEC_ELT (base_accesses, 0) == access_public_node\n \t      && !TREE_VIA_VIRTUAL (base_binfo)\n \t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n \t    /* single non-virtual public.  */"}, {"sha": "8fd1ee52e72ad846f1d0aef897735341f00f249f", "filename": "gcc/cp/search.c", "status": "modified", "additions": 277, "deletions": 520, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -82,18 +82,15 @@ struct vbase_info\n };\n \n static tree lookup_field_1 (tree, tree);\n-static int is_subobject_of_p (tree, tree, tree);\n-static int is_subobject_of_p_1 (tree, tree, tree);\n static tree dfs_check_overlap (tree, void *);\n-static tree dfs_no_overlap_yet (tree, void *);\n+static tree dfs_no_overlap_yet (tree, int, void *);\n static base_kind lookup_base_r (tree, tree, base_access,\n \t\t\t\tbool, bool, bool, tree *);\n static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n-static tree marked_pushdecls_p (tree, void *);\n-static tree unmarked_pushdecls_p (tree, void *);\n-static tree dfs_debug_unmarkedp (tree, void *);\n+static tree marked_pushdecls_p (tree, int, void *);\n+static tree unmarked_pushdecls_p (tree, int, void *);\n+static tree dfs_debug_unmarkedp (tree, int, void *);\n static tree dfs_debug_mark (tree, void *);\n-static tree dfs_get_vbase_types (tree, void *);\n static tree dfs_push_type_decls (tree, void *);\n static tree dfs_push_decls (tree, void *);\n static tree dfs_unuse_fields (tree, void *);\n@@ -104,28 +101,19 @@ static struct search_level *push_search_level (struct stack_level *,\n static struct search_level *pop_search_level (struct stack_level *);\n static void grow_bfs_bases (tree **, size_t *, size_t *);\n static tree bfs_walk (tree, tree (*) (tree, void *),\n-\t\t      tree (*) (tree, void *), void *);\n-static tree lookup_field_queue_p (tree, void *);\n+\t\t      tree (*) (tree, int, void *), void *);\n+static tree lookup_field_queue_p (tree, int, void *);\n static int shared_member_p (tree);\n static tree lookup_field_r (tree, void *);\n-static tree canonical_binfo (tree);\n-static tree shared_marked_p (tree, void *);\n-static tree shared_unmarked_p (tree, void *);\n-static int  dependent_base_p (tree);\n-static tree dfs_accessible_queue_p (tree, void *);\n+static tree dfs_accessible_queue_p (tree, int, void *);\n static tree dfs_accessible_p (tree, void *);\n static tree dfs_access_in_type (tree, void *);\n static access_kind access_in_type (tree, tree);\n-static tree dfs_canonical_queue (tree, void *);\n-static tree dfs_assert_unmarked_p (tree, void *);\n-static void assert_canonical_unmarked (tree);\n static int protected_accessible_p (tree, tree, tree);\n static int friend_accessible_p (tree, tree, tree);\n static void setup_class_bindings (tree, int);\n static int template_self_reference_p (tree, tree);\n-static tree dfs_find_vbase_instance (tree, void *);\n static tree dfs_get_pure_virtuals (tree, void *);\n-static tree dfs_build_inheritance_graph_order (tree, void *);\n \n /* Allocate a level of searching.  */\n \n@@ -183,7 +171,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \t       tree *binfo_ptr)\n {\n   int i;\n-  tree bases;\n+  tree bases, accesses;\n   base_kind found = bk_not_base;\n   \n   if (access == ba_check\n@@ -207,8 +195,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n       \n       if (!*binfo_ptr)\n \t*binfo_ptr = binfo;\n-      else if (!is_virtual || !tree_int_cst_equal (BINFO_OFFSET (binfo),\n-\t\t\t\t\t\t   BINFO_OFFSET (*binfo_ptr)))\n+      else if (binfo != *binfo_ptr)\n \t{\n \t  if (access != ba_any)\n \t    *binfo_ptr = NULL;\n@@ -222,23 +209,26 @@ lookup_base_r (tree binfo, tree base, base_access access,\n     }\n   \n   bases = BINFO_BASETYPES (binfo);\n+  accesses = BINFO_BASEACCESSES (binfo);\n   if (!bases)\n     return bk_not_base;\n   \n   for (i = TREE_VEC_LENGTH (bases); i--;)\n     {\n       tree base_binfo = TREE_VEC_ELT (bases, i);\n+      tree base_access = TREE_VEC_ELT (accesses, i);\n+      \n       int this_non_public = is_non_public;\n       int this_virtual = is_virtual;\n       base_kind bk;\n \n       if (access <= ba_ignore)\n \t; /* no change */\n-      else if (TREE_VIA_PUBLIC (base_binfo))\n+      else if (base_access == access_public_node)\n \t; /* no change */\n       else if (access == ba_not_special)\n \tthis_non_public = 1;\n-      else if (TREE_VIA_PROTECTED (base_binfo) && within_current_scope)\n+      else if (base_access == access_protected_node && within_current_scope)\n \t; /* no change */\n       else if (is_friend (BINFO_TYPE (binfo), current_scope ()))\n \t; /* no change */\n@@ -290,9 +280,9 @@ lookup_base_r (tree binfo, tree base, base_access access,\n }\n \n /* Lookup BASE in the hierarchy dominated by T.  Do access checking as\n-   ACCESS specifies.  Return the binfo we discover (which might not be\n-   canonical).  If KIND_PTR is non-NULL, fill with information about\n-   what kind of base we discovered.\n+   ACCESS specifies.  Return the binfo we discover.  If KIND_PTR is\n+   non-NULL, fill with information about what kind of base we\n+   discovered.\n \n    If the base is inaccessible, or ambiguous, and the ba_quiet bit is\n    not set in ACCESS, then an error is issued and error_mark_node is\n@@ -365,7 +355,7 @@ static int\n dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n \t\t\t   tree *offset_ptr)\n {\n-  tree binfos;\n+  tree binfos, accesses;\n   int i, n_baselinks;\n   int worst = -2;\n   \n@@ -381,13 +371,15 @@ dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n     }\n   \n   binfos = BINFO_BASETYPES (binfo);\n+  accesses = BINFO_BASEACCESSES (binfo);\n   n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree base_access = TREE_VEC_ELT (accesses, i);\n       int rval;\n       \n-      if (!TREE_VIA_PUBLIC (base_binfo))\n+      if (base_access != access_public_node)\n         continue;\n       rval = dynamic_cast_base_recurse\n              (subtype, base_binfo,\n@@ -603,74 +595,17 @@ context_for_name_lookup (tree decl)\n   return context;\n }\n \n-/* Return a canonical BINFO if BINFO is a virtual base, or just BINFO\n-   otherwise.  */\n-\n-static tree\n-canonical_binfo (tree binfo)\n-{\n-  return (TREE_VIA_VIRTUAL (binfo)\n-\t  ? TYPE_BINFO (BINFO_TYPE (binfo)) : binfo);\n-}\n-\n-/* A queue function that simply ensures that we walk into the\n-   canonical versions of virtual bases.  */\n-\n-static tree\n-dfs_canonical_queue (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  return canonical_binfo (binfo);\n-}\n-\n-/* Called via dfs_walk from assert_canonical_unmarked.  */\n-\n-static tree\n-dfs_assert_unmarked_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  my_friendly_assert (!BINFO_MARKED (binfo), 0);\n-  return NULL_TREE;\n-}\n-\n-/* Asserts that all the nodes below BINFO (using the canonical\n-   versions of virtual bases) are unmarked.  */\n-\n-static void\n-assert_canonical_unmarked (tree binfo)\n-{\n-  dfs_walk (binfo, dfs_assert_unmarked_p, dfs_canonical_queue, 0);\n-}\n-\n-/* If BINFO is marked, return a canonical version of BINFO.\n-   Otherwise, return NULL_TREE.  */\n-\n-static tree\n-shared_marked_p (tree binfo, void *data)\n-{\n-  binfo = canonical_binfo (binfo);\n-  return markedp (binfo, data);\n-}\n-\n-/* If BINFO is not marked, return a canonical version of BINFO.\n-   Otherwise, return NULL_TREE.  */\n-\n-static tree\n-shared_unmarked_p (tree binfo, void *data)\n-{\n-  binfo = canonical_binfo (binfo);\n-  return unmarkedp (binfo, data);\n-}\n-\n /* The accessibility routines use BINFO_ACCESS for scratch space\n    during the computation of the accssibility of some declaration.  */\n \n #define BINFO_ACCESS(NODE) \\\n-  ((access_kind) ((TREE_LANG_FLAG_1 (NODE) << 1) | TREE_LANG_FLAG_6 (NODE)))\n+  ((access_kind) ((TREE_PUBLIC (NODE) << 1) | TREE_PRIVATE (NODE)))\n \n /* Set the access associated with NODE to ACCESS.  */\n \n #define SET_BINFO_ACCESS(NODE, ACCESS)\t\t\t\\\n-  ((TREE_LANG_FLAG_1 (NODE) = ((ACCESS) & 2) != 0),\t\\\n-   (TREE_LANG_FLAG_6 (NODE) = ((ACCESS) & 1) != 0))\n+  ((TREE_PUBLIC (NODE) = ((ACCESS) & 2) != 0),\t\\\n+   (TREE_PRIVATE (NODE) = ((ACCESS) & 1) != 0))\n \n /* Called from access_in_type via dfs_walk.  Calculate the access to\n    DATA (which is really a DECL) in BINFO.  */\n@@ -702,51 +637,59 @@ dfs_access_in_type (tree binfo, void *data)\n       if (DECL_LANG_SPECIFIC (decl) && !DECL_DISCRIMINATOR_P (decl))\n \t{\n \t  tree decl_access = purpose_member (type, DECL_ACCESS (decl));\n+\t  \n \t  if (decl_access)\n-\t    access = ((access_kind) \n-\t\t      TREE_INT_CST_LOW (TREE_VALUE (decl_access)));\n+\t    {\n+\t      decl_access = TREE_VALUE (decl_access);\n+\t      \n+\t      if (decl_access == access_public_node)\n+\t\taccess = ak_public;\n+\t      else if (decl_access == access_protected_node)\n+\t\taccess = ak_protected;\n+\t      else if (decl_access == access_private_node)\n+\t\taccess = ak_private;\n+\t      else\n+\t\tmy_friendly_assert (false, 20030217);\n+\t    }\n \t}\n \n       if (!access)\n \t{\n \t  int i;\n \t  int n_baselinks;\n-\t  tree binfos;\n+\t  tree binfos, accesses;\n \t  \n \t  /* Otherwise, scan our baseclasses, and pick the most favorable\n \t     access.  */\n \t  binfos = BINFO_BASETYPES (binfo);\n+\t  accesses = BINFO_BASEACCESSES (binfo);\n \t  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \t  for (i = 0; i < n_baselinks; ++i)\n \t    {\n \t      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t      access_kind base_access \n-\t\t= BINFO_ACCESS (canonical_binfo (base_binfo));\n+\t      tree base_access = TREE_VEC_ELT (accesses, i);\n+\t      access_kind base_access_now = BINFO_ACCESS (base_binfo);\n \n-\t      if (base_access == ak_none || base_access == ak_private)\n+\t      if (base_access_now == ak_none || base_access_now == ak_private)\n \t\t/* If it was not accessible in the base, or only\n \t\t   accessible as a private member, we can't access it\n \t\t   all.  */\n-\t\tbase_access = ak_none;\n-\t      else if (TREE_VIA_PROTECTED (base_binfo))\n-\t\t/* Public and protected members in the base are\n+\t\tbase_access_now = ak_none;\n+\t      else if (base_access == access_protected_node)\n+\t\t/* Public and protected members in the base become\n \t\t   protected here.  */\n-\t\tbase_access = ak_protected;\n-\t      else if (!TREE_VIA_PUBLIC (base_binfo))\n-\t\t/* Public and protected members in the base are\n+\t\tbase_access_now = ak_protected;\n+\t      else if (base_access == access_private_node)\n+\t\t/* Public and protected members in the base become\n \t\t   private here.  */\n-\t\tbase_access = ak_private;\n+\t\tbase_access_now = ak_private;\n \n \t      /* See if the new access, via this base, gives more\n \t\t access than our previous best access.  */\n-\t      if (base_access != ak_none\n-\t\t  && (base_access == ak_public\n-\t\t      || (base_access == ak_protected\n-\t\t\t  && access != ak_public)\n-\t\t      || (base_access == ak_private \n-\t\t\t  && access == ak_none)))\n+\t      if (base_access_now != ak_none\n+\t\t  && (access == ak_none || base_access_now < access))\n \t\t{\n-\t\t  access = base_access;\n+\t\t  access = base_access_now;\n \n \t\t  /* If the new access is public, we can't do better.  */\n \t\t  if (access == ak_public)\n@@ -761,7 +704,7 @@ dfs_access_in_type (tree binfo, void *data)\n \n   /* Mark TYPE as visited so that if we reach it again we do not\n      duplicate our efforts here.  */\n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 1;\n \n   return NULL_TREE;\n }\n@@ -784,29 +727,29 @@ access_in_type (tree type, tree decl)\n     The algorithm we use is to make a post-order depth-first traversal\n     of the base-class hierarchy.  As we come up the tree, we annotate\n     each node with the most lenient access.  */\n-  dfs_walk_real (binfo, 0, dfs_access_in_type, shared_unmarked_p, decl);\n-  dfs_walk (binfo, dfs_unmark, shared_marked_p,  0);\n-  assert_canonical_unmarked (binfo);\n+  dfs_walk_real (binfo, 0, dfs_access_in_type, unmarkedp, decl);\n+  dfs_walk (binfo, dfs_unmark, markedp,  0);\n \n   return BINFO_ACCESS (binfo);\n }\n \n /* Called from dfs_accessible_p via dfs_walk.  */\n \n static tree\n-dfs_accessible_queue_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n+dfs_accessible_queue_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n {\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n   if (BINFO_MARKED (binfo))\n     return NULL_TREE;\n \n   /* If this class is inherited via private or protected inheritance,\n-     then we can't see it, unless we are a friend of the subclass.  */\n-  if (!TREE_VIA_PUBLIC (binfo)\n-      && !is_friend (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo)),\n-\t\t     current_scope ()))\n+     then we can't see it, unless we are a friend of the derived class.  */\n+  if (BINFO_BASEACCESS (derived, ix) != access_public_node\n+      && !is_friend (BINFO_TYPE (derived), current_scope ()))\n     return NULL_TREE;\n \n-  return canonical_binfo (binfo);\n+  return binfo;\n }\n \n /* Called from dfs_accessible_p via dfs_walk.  */\n@@ -817,7 +760,7 @@ dfs_accessible_p (tree binfo, void *data)\n   int protected_ok = data != 0;\n   access_kind access;\n \n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 1;\n   access = BINFO_ACCESS (binfo);\n   if (access == ak_public || (access == ak_protected && protected_ok))\n     return binfo;\n@@ -1015,75 +958,11 @@ accessible_p (tree type, tree decl)\n   /* Clear any mark bits.  Note that we have to walk the whole tree\n      here, since we have aborted the previous walk from some point\n      deep in the tree.  */\n-  dfs_walk (binfo, dfs_unmark, dfs_canonical_queue,  0);\n-  assert_canonical_unmarked (binfo);\n+  dfs_walk (binfo, dfs_unmark, 0,  0);\n \n   return t != NULL_TREE;\n }\n \n-/* Recursive helper funciton for is_subobject_of_p; see that routine\n-   for documentation of the parameters.  */\n-\n-static int\n-is_subobject_of_p_1 (tree parent, tree binfo, tree most_derived)\n-{\n-  tree binfos;\n-  int i, n_baselinks;\n-\n-  if (parent == binfo)\n-    return 1;\n-\n-  binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  /* Iterate through the base types.  */\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree base_type;\n-\n-      base_type = TREE_TYPE (base_binfo);\n-      if (!CLASS_TYPE_P (base_type))\n-\t/* If we see a TEMPLATE_TYPE_PARM, or some such, as a base\n-\t   class there's no way to descend into it.  */\n-\tcontinue;\n-\n-      /* Avoid walking into the same virtual base more than once.  */\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  if (CLASSTYPE_MARKED4 (base_type))\n-\t    continue;\n-\t  SET_CLASSTYPE_MARKED4 (base_type);\n-\t  base_binfo = binfo_for_vbase (base_type, most_derived);\n-\t}\n-\n-      if (is_subobject_of_p_1 (parent, base_binfo, most_derived))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Routine to see if the sub-object denoted by the binfo PARENT can be\n-   found as a base class and sub-object of the object denoted by\n-   BINFO.  MOST_DERIVED is the most derived type of the hierarchy being\n-   searched.  */\n-\n-static int\n-is_subobject_of_p (tree parent, tree binfo, tree most_derived)\n-{\n-  int result;\n-  tree vbase;\n-\n-  result = is_subobject_of_p_1 (parent, binfo, most_derived);\n-  /* Clear the mark bits on virtual bases.  */\n-  for (vbase = CLASSTYPE_VBASECLASSES (most_derived);\n-       vbase;\n-       vbase = TREE_CHAIN (vbase))\n-    CLEAR_CLASSTYPE_MARKED4 (TREE_TYPE (TREE_VALUE (vbase)));\n-\n-  return result;\n-}\n-\n struct lookup_field_info {\n   /* The type in which we're looking.  */\n   tree type;\n@@ -1098,8 +977,6 @@ struct lookup_field_info {\n   tree ambiguous;\n   /* If nonzero, we are looking for types, not data members.  */\n   int want_type;\n-  /* If nonzero, RVAL was found by looking through a dependent base.  */\n-  int from_dep_base_p;\n   /* If something went wrong, a message indicating what.  */\n   const char *errstr;\n };\n@@ -1110,8 +987,9 @@ struct lookup_field_info {\n    lookup_field via breadth_first_search.  */\n \n static tree\n-lookup_field_queue_p (tree binfo, void *data)\n+lookup_field_queue_p (tree derived, int ix, void *data)\n {\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n \n   /* Don't look for constructors or destructors in base classes.  */\n@@ -1120,11 +998,13 @@ lookup_field_queue_p (tree binfo, void *data)\n \n   /* If this base class is hidden by the best-known value so far, we\n      don't need to look.  */\n-  binfo = CANONICAL_BINFO (binfo, lfi->type);\n-  if (!lfi->from_dep_base_p && lfi->rval_binfo\n-      && is_subobject_of_p (binfo, lfi->rval_binfo, lfi->type))\n+  if (lfi->rval_binfo && original_binfo (binfo, lfi->rval_binfo))\n     return NULL_TREE;\n \n+  /* If this is a dependent base, don't look in it.  */\n+  if (BINFO_DEPENDENT_BASE_P (binfo))\n+    return NULL_TREE;\n+  \n   return binfo;\n }\n \n@@ -1187,7 +1067,6 @@ lookup_field_r (tree binfo, void *data)\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n   tree type = BINFO_TYPE (binfo);\n   tree nval = NULL_TREE;\n-  int from_dep_base_p;\n \n   /* First, look for a function.  There can't be a function and a data\n      member with the same name, and if there's a function and a type\n@@ -1241,40 +1120,14 @@ lookup_field_r (tree binfo, void *data)\n       && template_self_reference_p (type, nval))\n     return NULL_TREE;\n \n-  from_dep_base_p = dependent_base_p (binfo);\n-  if (lfi->from_dep_base_p && !from_dep_base_p)\n-    {\n-      /* If the new declaration is not found via a dependent base, and\n-\t the old one was, then we must prefer the new one.  We weren't\n-\t really supposed to be able to find the old one, so we don't\n-\t want to be affected by a specialization.  Consider:\n-\n-\t   struct B { typedef int I; };\n-\t   template <typename T> struct D1 : virtual public B {}; \n-\t   template <typename T> struct D :\n-\t   public D1, virtual pubic B { I i; };\n-\n-\t The `I' in `D<T>' is unambigousuly `B::I', regardless of how\n-\t D1 is specialized.  */\n-      lfi->from_dep_base_p = 0;\n-      lfi->rval = NULL_TREE;\n-      lfi->rval_binfo = NULL_TREE;\n-      lfi->ambiguous = NULL_TREE;\n-      lfi->errstr = 0;\n-    }\n-  else if (lfi->rval_binfo && !lfi->from_dep_base_p && from_dep_base_p)\n-    /* Similarly, if the old declaration was not found via a dependent\n-       base, and the new one is, ignore the new one.  */\n-    return NULL_TREE;\n-\n   /* If the lookup already found a match, and the new value doesn't\n      hide the old one, we might have an ambiguity.  */\n-  if (lfi->rval_binfo && !is_subobject_of_p (lfi->rval_binfo, binfo, lfi->type))\n+  if (lfi->rval_binfo && !original_binfo (lfi->rval_binfo, binfo))\n     {\n       if (nval == lfi->rval && shared_member_p (nval))\n \t/* The two things are really the same.  */\n \t;\n-      else if (is_subobject_of_p (binfo, lfi->rval_binfo, lfi->type))\n+      else if (original_binfo (binfo, lfi->rval_binfo))\n \t/* The previous value hides the new one.  */\n \t;\n       else\n@@ -1298,18 +1151,7 @@ lookup_field_r (tree binfo, void *data)\n     }\n   else\n     {\n-      if (from_dep_base_p && TREE_CODE (nval) == TYPE_DECL\n-\t  /* We need to return a member template class so we can\n-\t     define partial specializations.  Is there a better\n-\t     way?  */\n-\t  && !DECL_CLASS_TEMPLATE_P (nval))\n-\t/* The thing we're looking for isn't a type, so the implicit\n-\t   typename extension doesn't apply, so we just pretend we\n-\t   didn't find anything.  */\n-\treturn NULL_TREE;\n-\n       lfi->rval = nval;\n-      lfi->from_dep_base_p = from_dep_base_p;\n       lfi->rval_binfo = binfo;\n     }\n \n@@ -1443,11 +1285,6 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n       rval = error_mark_node;\n     }\n \n-  /* If the thing we found was found via the implicit typename\n-     extension, build the typename type.  */\n-  if (rval && lfi.from_dep_base_p && !DECL_CLASS_TEMPLATE_P (rval))\n-    abort ();\n-\n   if (rval && is_overloaded_fn (rval)) \n     rval = build_baselink (rval_binfo, basetype_path, rval,\n \t\t\t   (IDENTIFIER_TYPENAME_P (name)\n@@ -1679,8 +1516,10 @@ grow_bfs_bases (tree **basep, size_t *sizep, size_t *headp)\n    use do-while for the inner loop.  */\n \n static tree\n-bfs_walk (tree binfo, tree (*fn) (tree, void *),\n-\t  tree (*qfn) (tree, void *), void *data)\n+bfs_walk (tree binfo,\n+\t  tree (*fn) (tree, void *),\n+\t  tree (*qfn) (tree, int, void *),\n+\t  void *data)\n {\n   tree rval = NULL_TREE;\n \n@@ -1698,54 +1537,50 @@ bfs_walk (tree binfo, tree (*fn) (tree, void *),\n     return rval;\n \n   /* If it has no base types, we are also done.  */\n-  if (BINFO_BASETYPES (binfo) == 0\n-      || TREE_VEC_LENGTH (BINFO_BASETYPES (binfo)) == 0)\n+  if (!BINFO_BASETYPES (binfo))\n     return 0;\n \n   /* Otherwise, initialize the queue with its basetypes vector\n      and proceed.  */\n \n   head = tail = 0;\n-  bfs_bases[tail++] = BINFO_BASETYPES (binfo);\n+  bfs_bases[tail++] = binfo;\n \n-  do\n+  while (head != tail)\n     {\n-      int i, n_baselinks;\n-      tree binfos;\n-      \n-      binfos = bfs_bases[head++];\n+      int n_bases, ix;\n+      tree binfo = bfs_bases[head++];\n       if (head == bfs_bases_size)\n \thead = 0;\n \n-      i = 0;\n-      n_baselinks = TREE_VEC_LENGTH (binfos);\n-      do\n-\t{\n-\t  binfo = TREE_VEC_ELT (binfos, i);\n-\t  i++;\n-\n-\t  if (qfn)\n-\t    binfo = qfn (binfo, data);\n-\t  if (!binfo)\n-\t    continue;\n+      /* Is this the one we're looking for?  If so, we're done.  */\n+      rval = fn (binfo, data);\n+      if (rval)\n+\tgoto done;\n \n-\t  rval = fn (binfo, data);\n-\t  if (rval)\n-\t    goto done;\n+      n_bases = BINFO_N_BASETYPES (binfo);\n+      if (n_bases)\n+\t{\n+\t  for (ix = 0; ix != n_bases; ix++)\n+\t    {\n+\t      tree base_binfo;\n \n-\t  if (BINFO_BASETYPES (binfo) == 0\n-\t      || TREE_VEC_LENGTH (BINFO_BASETYPES (binfo)) == 0)\n-\t    continue;\n+\t      if (qfn)\n+\t\tbase_binfo = (*qfn) (binfo, ix, data);\n+ \t      else\n+ \t\tbase_binfo = BINFO_BASETYPE (binfo, ix);\n \n-\t  bfs_bases[tail++] = BINFO_BASETYPES (binfo);\n-\t  if (tail == bfs_bases_size)\n-\t    tail = 0;\n-\t  if (tail == head)\n-\t    grow_bfs_bases (&bfs_bases, &bfs_bases_size, &head);\n+\t      if (base_binfo)\n+\t\t{\n+\t\t  bfs_bases[tail++] = base_binfo;\n+\t\t  if (tail == bfs_bases_size)\n+\t\t    tail = 0;\n+\t\t  if (tail == head)\n+\t\t    grow_bfs_bases (&bfs_bases, &bfs_bases_size, &head);\n+\t\t}\n+\t    }\n \t}\n-      while (i < n_baselinks);\n     }\n-  while (head != tail);\n \n  done:\n   if (bfs_bases != bfs_bases_initial)\n@@ -1758,13 +1593,12 @@ bfs_walk (tree binfo, tree (*fn) (tree, void *),\n    in postorder.  */\n \n tree\n-dfs_walk_real (tree binfo, \n-\t       tree (*prefn) (tree, void *), tree (*postfn) (tree, void *),\n-\t       tree (*qfn) (tree, void *), void *data)\n+dfs_walk_real (tree binfo,\n+\t       tree (*prefn) (tree, void *),\n+\t       tree (*postfn) (tree, void *),\n+\t       tree (*qfn) (tree, int, void *),\n+\t       void *data)\n {\n-  int i;\n-  int n_baselinks;\n-  tree binfos;\n   tree rval = NULL_TREE;\n \n   /* Call the pre-order walking function.  */\n@@ -1776,20 +1610,24 @@ dfs_walk_real (tree binfo,\n     }\n \n   /* Process the basetypes.  */\n-  binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = BINFO_N_BASETYPES (binfo);\n-  for (i = 0; i < n_baselinks; i++)\n+  if (BINFO_BASETYPES (binfo))\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      \n-      if (qfn)\n-\tbase_binfo = (*qfn) (base_binfo, data);\n-\n-      if (base_binfo)\n+      int i, n = TREE_VEC_LENGTH (BINFO_BASETYPES (binfo));\n+      for (i = 0; i != n; i++)\n \t{\n-\t  rval = dfs_walk_real (base_binfo, prefn, postfn, qfn, data);\n-\t  if (rval)\n-\t    return rval;\n+\t  tree base_binfo;\n+      \n+\t  if (qfn)\n+\t    base_binfo = (*qfn) (binfo, i, data);\n+\t  else\n+\t    base_binfo = BINFO_BASETYPE (binfo, i);\n+\t  \n+\t  if (base_binfo)\n+\t    {\n+\t      rval = dfs_walk_real (base_binfo, prefn, postfn, qfn, data);\n+\t      if (rval)\n+\t\treturn rval;\n+\t    }\n \t}\n     }\n \n@@ -1804,8 +1642,10 @@ dfs_walk_real (tree binfo,\n    performed.  */\n \n tree\n-dfs_walk (tree binfo, tree (*fn) (tree, void *),\n-\t  tree (*qfn) (tree, void *), void *data)\n+dfs_walk (tree binfo,\n+\t  tree (*fn) (tree, void *),\n+\t  tree (*qfn) (tree, int, void *),\n+\t  void *data)\n {\n   return dfs_walk_real (binfo, 0, fn, qfn, data);\n }\n@@ -2007,59 +1847,6 @@ look_for_overrides_r (tree type, tree fndecl)\n   return look_for_overrides (type, fndecl);\n }\n \n-/* A queue function to use with dfs_walk that only walks into\n-   canonical bases.  DATA should be the type of the complete object,\n-   or a TREE_LIST whose TREE_PURPOSE is the type of the complete\n-   object.  By using this function as a queue function, you will walk\n-   over exactly those BINFOs that actually exist in the complete\n-   object, including those for virtual base classes.  If you\n-   SET_BINFO_MARKED for each binfo you process, you are further\n-   guaranteed that you will walk into each virtual base class exactly\n-   once.  */\n-\n-tree\n-dfs_unmarked_real_bases_queue_p (tree binfo, void *data)\n-{\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree type = (tree) data;\n-\n-      if (TREE_CODE (type) == TREE_LIST)\n-\ttype = TREE_PURPOSE (type);\n-      binfo = binfo_for_vbase (BINFO_TYPE (binfo), type);\n-    }\n-  return unmarkedp (binfo, NULL);\n-}\n-\n-/* Like dfs_unmarked_real_bases_queue_p but walks only into things\n-   that are marked, rather than unmarked.  */\n-\n-tree\n-dfs_marked_real_bases_queue_p (tree binfo, void *data)\n-{\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree type = (tree) data;\n-\n-      if (TREE_CODE (type) == TREE_LIST)\n-\ttype = TREE_PURPOSE (type);\n-      binfo = binfo_for_vbase (BINFO_TYPE (binfo), type);\n-    }\n-  return markedp (binfo, NULL);\n-}\n-\n-/* A queue function that skips all virtual bases (and their \n-   bases).  */\n-\n-tree\n-dfs_skip_vbases (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    return NULL_TREE;\n-\n-  return binfo;\n-}\n-\n /* Called via dfs_walk from dfs_get_pure_virtuals.  */\n \n static tree\n@@ -2083,7 +1870,7 @@ dfs_get_pure_virtuals (tree binfo, void *data)\n \t\t\t CLASSTYPE_PURE_VIRTUALS (type));\n     }\n   \n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 1;\n \n   return NULL_TREE;\n }\n@@ -2104,10 +1891,8 @@ get_pure_virtuals (tree type)\n      (A primary base is not interesting because the derived class of\n      which it is a primary base will contain vtable entries for the\n      pure virtuals in the base class.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, \n-\t    dfs_unmarked_real_bases_queue_p, type);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, \n-\t    dfs_marked_real_bases_queue_p, type);\n+  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, unmarkedp, type);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, type);\n \n   /* Put the pure virtuals in dfs order.  */\n   CLASSTYPE_PURE_VIRTUALS (type) = nreverse (CLASSTYPE_PURE_VIRTUALS (type));\n@@ -2132,42 +1917,36 @@ get_pure_virtuals (tree type)\n /* DEPTH-FIRST SEARCH ROUTINES.  */\n \n tree \n-markedp (tree binfo, void *data ATTRIBUTE_UNUSED)\n+markedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED) \n {\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n   return BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n tree\n-unmarkedp (tree binfo, void *data ATTRIBUTE_UNUSED)\n+unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED) \n {\n-  return !BINFO_MARKED (binfo) ? binfo : NULL_TREE;\n-}\n-\n-tree\n-marked_vtable_pathp (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{ \n-  return BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n-}\n-\n-tree\n-unmarked_vtable_pathp (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{ \n-  return !BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n+  return !BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n static tree\n-marked_pushdecls_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n+marked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n {\n-  return (CLASS_TYPE_P (BINFO_TYPE (binfo))\n-\t  && !dependent_base_p (binfo)\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n+  return (!BINFO_DEPENDENT_BASE_P (binfo)\n \t  && BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE; \n }\n \n static tree\n-unmarked_pushdecls_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n+unmarked_pushdecls_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n { \n-  return (CLASS_TYPE_P (BINFO_TYPE (binfo))\n-\t  && !dependent_base_p (binfo)\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n+  return (!BINFO_DEPENDENT_BASE_P (binfo)\n \t  && !BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE;\n }\n \n@@ -2177,99 +1956,11 @@ unmarked_pushdecls_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n \n tree\n dfs_unmark (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{ \n-  CLEAR_BINFO_MARKED (binfo); \n-  return NULL_TREE;\n-}\n-\n-/* get virtual base class types.\n-   This adds type to the vbase_types list in reverse dfs order.\n-   Ordering is very important, so don't change it.  */\n-\n-static tree\n-dfs_get_vbase_types (tree binfo, void *data)\n-{\n-  tree type = (tree) data;\n-\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    CLASSTYPE_VBASECLASSES (type)\n-      = tree_cons (BINFO_TYPE (binfo), \n-\t\t   binfo, \n-\t\t   CLASSTYPE_VBASECLASSES (type));\n-  SET_BINFO_MARKED (binfo);\n-  return NULL_TREE;\n-}\n-\n-/* Called via dfs_walk from mark_primary_bases.  Builds the\n-   inheritance graph order list of BINFOs.  */\n-\n-static tree\n-dfs_build_inheritance_graph_order (tree binfo, void *data)\n {\n-  tree *last_binfo = (tree *) data;\n-\n-  if (*last_binfo)\n-    TREE_CHAIN (*last_binfo) = binfo;\n-  *last_binfo = binfo;\n-  SET_BINFO_MARKED (binfo);\n+  BINFO_MARKED (binfo) = 0;\n   return NULL_TREE;\n }\n \n-/* Set CLASSTYPE_VBASECLASSES for TYPE.  */\n-\n-void\n-get_vbase_types (tree type)\n-{\n-  tree last_binfo;\n-\n-  CLASSTYPE_VBASECLASSES (type) = NULL_TREE;\n-  dfs_walk (TYPE_BINFO (type), dfs_get_vbase_types, unmarkedp, type);\n-  /* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now\n-     reverse it so that we get normal dfs ordering.  */\n-  CLASSTYPE_VBASECLASSES (type) = nreverse (CLASSTYPE_VBASECLASSES (type));\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, 0);\n-  /* Thread the BINFOs in inheritance-graph order.  */\n-  last_binfo = NULL;\n-  dfs_walk_real (TYPE_BINFO (type),\n-\t\t dfs_build_inheritance_graph_order,\n-\t\t NULL,\n-\t\t unmarkedp,\n-\t\t &last_binfo);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, NULL);\n-}\n-\n-/* Called from find_vbase_instance via dfs_walk.  */\n-\n-static tree\n-dfs_find_vbase_instance (tree binfo, void *data)\n-{\n-  tree base = TREE_VALUE ((tree) data);\n-\n-  if (BINFO_PRIMARY_P (binfo)\n-      && same_type_p (BINFO_TYPE (binfo), base))\n-    return binfo;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Find the real occurrence of the virtual BASE (a class type) in the\n-   hierarchy dominated by TYPE.  */\n-\n-tree\n-find_vbase_instance (tree base, tree type)\n-{\n-  tree instance;\n-\n-  instance = binfo_for_vbase (base, type);\n-  if (!BINFO_PRIMARY_P (instance))\n-    return instance;\n-\n-  return dfs_walk (TYPE_BINFO (type), \n-\t\t   dfs_find_vbase_instance, \n-\t\t   NULL,\n-\t\t   build_tree_list (type, base));\n-}\n-\n \f\n /* Debug info for C++ classes can get very large; try to avoid\n    emitting it everywhere.\n@@ -2334,8 +2025,10 @@ dfs_debug_mark (tree binfo, void *data ATTRIBUTE_UNUSED)\n    info for this base class.  */\n \n static tree \n-dfs_debug_unmarkedp (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{ \n+dfs_debug_unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n+  \n   return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n \t  ? binfo : NULL_TREE);\n }\n@@ -2361,22 +2054,6 @@ note_debug_info_needed (tree type)\n \f\n /* Subroutines of push_class_decls ().  */\n \n-/* Returns 1 iff BINFO is a base we shouldn't really be able to see into,\n-   because it (or one of the intermediate bases) depends on template parms.  */\n-\n-static int\n-dependent_base_p (tree binfo)\n-{\n-  for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n-    {\n-      if (currently_open_class (TREE_TYPE (binfo)))\n-\tbreak;\n-      if (dependent_type_p (TREE_TYPE (binfo)))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n static void\n setup_class_bindings (tree name, int type_binding_p)\n {\n@@ -2449,7 +2126,7 @@ dfs_push_type_decls (tree binfo, void *data ATTRIBUTE_UNUSED)\n \n   /* We can't just use BINFO_MARKED because envelope_add_decl uses\n      DERIVED_FROM_P, which calls get_base_distance.  */\n-  SET_BINFO_PUSHDECLS_MARKED (binfo);\n+  BINFO_PUSHDECLS_MARKED (binfo) = 1;\n \n   return NULL_TREE;\n }\n@@ -2460,46 +2137,39 @@ dfs_push_type_decls (tree binfo, void *data ATTRIBUTE_UNUSED)\n static tree\n dfs_push_decls (tree binfo, void *data)\n {\n-  tree type;\n+  tree type = BINFO_TYPE (binfo);\n   tree method_vec;\n-  int dep_base_p;\n-\n-  type = BINFO_TYPE (binfo);\n-  dep_base_p = (processing_template_decl && type != current_class_type\n-\t\t&& dependent_base_p (binfo));\n-  if (!dep_base_p)\n+  tree fields;\n+  \n+  for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+    if (DECL_NAME (fields) \n+\t&& TREE_CODE (fields) != TYPE_DECL\n+\t&& TREE_CODE (fields) != USING_DECL\n+\t&& !DECL_ARTIFICIAL (fields))\n+      setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/0);\n+    else if (TREE_CODE (fields) == FIELD_DECL\n+\t     && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n+      dfs_push_decls (TYPE_BINFO (TREE_TYPE (fields)), data);\n+  \n+  method_vec = (CLASS_TYPE_P (type) \n+\t\t? CLASSTYPE_METHOD_VEC (type) : NULL_TREE);\n+  \n+  if (method_vec && TREE_VEC_LENGTH (method_vec) >= 3)\n     {\n-      tree fields;\n-      for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n-\tif (DECL_NAME (fields) \n-\t    && TREE_CODE (fields) != TYPE_DECL\n-\t    && TREE_CODE (fields) != USING_DECL\n-\t    && !DECL_ARTIFICIAL (fields))\n-\t  setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/0);\n-\telse if (TREE_CODE (fields) == FIELD_DECL\n-\t\t && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n-\t  dfs_push_decls (TYPE_BINFO (TREE_TYPE (fields)), data);\n-\t  \n-      method_vec = (CLASS_TYPE_P (type) \n-\t\t    ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE);\n-\n-      if (method_vec && TREE_VEC_LENGTH (method_vec) >= 3)\n-\t{\n-\t  tree *methods;\n-\t  tree *end;\n-\n-\t  /* Farm out constructors and destructors.  */\n-\t  end = TREE_VEC_END (method_vec);\n-\n-\t  for (methods = &TREE_VEC_ELT (method_vec, 2);\n-\t       methods < end && *methods;\n-\t       methods++)\n-\t    setup_class_bindings (DECL_NAME (OVL_CURRENT (*methods)), \n-\t\t\t\t  /*type_binding_p=*/0);\n-\t}\n+      tree *methods;\n+      tree *end;\n+      \n+      /* Farm out constructors and destructors.  */\n+      end = TREE_VEC_END (method_vec);\n+      \n+      for (methods = &TREE_VEC_ELT (method_vec, 2);\n+\t   methods < end && *methods;\n+\t   methods++)\n+\tsetup_class_bindings (DECL_NAME (OVL_CURRENT (*methods)), \n+\t\t\t      /*type_binding_p=*/0);\n     }\n \n-  CLEAR_BINFO_PUSHDECLS_MARKED (binfo);\n+  BINFO_PUSHDECLS_MARKED (binfo) = 0;\n \n   return NULL_TREE;\n }\n@@ -2678,9 +2348,11 @@ dfs_check_overlap (tree empty_binfo, void *data)\n /* Trivial function to stop base traversal when we find something.  */\n \n static tree\n-dfs_no_overlap_yet (tree binfo, void *data)\n+dfs_no_overlap_yet (tree derived, int ix, void *data)\n {\n+  tree binfo = BINFO_BASETYPE (derived, ix);\n   struct overlap_info *oi = (struct overlap_info *) data;\n+  \n   return !oi->found_overlap ? binfo : NULL_TREE;\n }\n \n@@ -2759,14 +2431,99 @@ binfo_via_virtual (tree binfo, tree limit)\n   return NULL_TREE;\n }\n \n-/* Returns the BINFO (if any) for the virtual baseclass T of the class\n-   C from the CLASSTYPE_VBASECLASSES list.  */\n+/* BINFO is a base binfo in the complete type BINFO_TYPE (HERE).\n+   Find the equivalent binfo within whatever graph HERE is located.\n+   This is the inverse of original_binfo. */\n \n tree\n-binfo_for_vbase (tree basetype, tree classtype)\n+copied_binfo (tree binfo, tree here)\n {\n-  tree binfo;\n+  tree result = NULL_TREE;\n+  \n+  if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      tree t;\n \n-  binfo = purpose_member (basetype, CLASSTYPE_VBASECLASSES (classtype));\n-  return binfo ? TREE_VALUE (binfo) : NULL_TREE;\n+      for (t = here; BINFO_INHERITANCE_CHAIN (t);\n+\t   t = BINFO_INHERITANCE_CHAIN (t))\n+\tcontinue;\n+      \n+      result = purpose_member (BINFO_TYPE (binfo),\n+\t\t\t       CLASSTYPE_VBASECLASSES (BINFO_TYPE (t)));\n+      result = TREE_VALUE (result);\n+    }\n+  else if (BINFO_INHERITANCE_CHAIN (binfo))\n+    {\n+      tree base_binfos;\n+      int ix, n;\n+      \n+      base_binfos = copied_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n+      base_binfos = BINFO_BASETYPES (base_binfos);\n+      n = TREE_VEC_LENGTH (base_binfos);\n+      for (ix = 0; ix != n; ix++)\n+\t{\n+\t  tree base = TREE_VEC_ELT (base_binfos, ix);\n+\t  \n+\t  if (BINFO_TYPE (base) == BINFO_TYPE (binfo))\n+\t    {\n+\t      result = base;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      my_friendly_assert (BINFO_TYPE (here) == BINFO_TYPE (binfo), 20030202);\n+      result = here;\n+    }\n+\n+  my_friendly_assert (result, 20030202);\n+  return result;\n }\n+\n+/* BINFO is some base binfo of HERE, within some other\n+   hierachy. Return the equivalent binfo, but in the hierarchy\n+   dominated by HERE.  This is the inverse of copied_binfo.  If BINFO\n+   is not a base binfo of HERE, returns NULL_TREE. */\n+\n+tree\n+original_binfo (tree binfo, tree here)\n+{\n+  tree result = NULL;\n+  \n+  if (BINFO_TYPE (binfo) == BINFO_TYPE (here))\n+    result = here;\n+  else if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      result = purpose_member (BINFO_TYPE (binfo),\n+\t\t\t       CLASSTYPE_VBASECLASSES (BINFO_TYPE (here)));\n+      if (result)\n+\tresult = TREE_VALUE (result);\n+    }\n+  else if (BINFO_INHERITANCE_CHAIN (binfo))\n+    {\n+      tree base_binfos;\n+      \n+      base_binfos = original_binfo (BINFO_INHERITANCE_CHAIN (binfo), here);\n+      if (base_binfos)\n+\t{\n+\t  int ix, n;\n+\t  \n+\t  base_binfos = BINFO_BASETYPES (base_binfos);\n+\t  n = TREE_VEC_LENGTH (base_binfos);\n+\t  for (ix = 0; ix != n; ix++)\n+\t    {\n+\t      tree base = TREE_VEC_ELT (base_binfos, ix);\n+\t      \n+\t      if (BINFO_TYPE (base) == BINFO_TYPE (binfo))\n+\t\t{\n+\t\t  result = base;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  \n+  return result;\n+}\n+"}, {"sha": "cf0bec7249bf96ad2b88e7cba4c70385e09d860c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -3,7 +3,8 @@\n    building RTL.  These routines are used both during actual parsing\n    and during the instantiation of template functions. \n \n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002,\n+   2003 Free Software Foundation, Inc.\n    Written by Mark Mitchell (mmitchell@usa.net) based on code found\n    formerly in parse.y and pt.c.  \n \n@@ -2038,27 +2039,26 @@ finish_template_type (name, args, entering_scope)\n    access_{default,public,protected_private}[_virtual]_node.*/\n \n tree \n-finish_base_specifier (access_specifier, base_class)\n-     tree access_specifier;\n-     tree base_class;\n+finish_base_specifier (tree base, tree access, bool virtual_p)\n {\n   tree result;\n \n-  if (base_class == error_mark_node)\n+  if (base == error_mark_node)\n     {\n       error (\"invalid base-class specification\");\n       result = NULL_TREE;\n     }\n-  else if (! is_aggr_type (base_class, 1))\n+  else if (! is_aggr_type (base, 1))\n     result = NULL_TREE;\n   else\n     {\n-      if (cp_type_quals (base_class) != 0)\n+      if (cp_type_quals (base) != 0)\n         {\n-          error (\"base class `%T' has cv qualifiers\", base_class);\n-          base_class = TYPE_MAIN_VARIANT (base_class);\n+          error (\"base class `%T' has cv qualifiers\", base);\n+          base = TYPE_MAIN_VARIANT (base);\n         }\n-      result = build_tree_list (access_specifier, base_class);\n+      result = build_tree_list (access, base);\n+      TREE_VIA_VIRTUAL (result) = virtual_p;\n     }\n \n   return result;"}, {"sha": "520aa164572126143fb5eb1cd24328592b52a002", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 80, "deletions": 49, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,6 +1,6 @@\n /* Language-dependent node constructors for parse phase of GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -714,37 +714,81 @@ canonical_type_variant (t)\n   return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), cp_type_quals (t));\n }\n \f\n-/* Makes new binfos for the indirect bases under BINFO, and updates\n-   BINFO_OFFSET for them and their bases.  */\n+/* Makes new binfos for the indirect bases under BINFO. T is the most\n+   derived TYPE. PREV is the previous binfo, whose TREE_CHAIN we make\n+   point to this binfo. We return the last BINFO created.\n \n-void\n-unshare_base_binfos (binfo)\n-     tree binfo;\n+   The CLASSTYPE_VBASECLASSES list of T is constructed in reverse\n+   order (pre-order, depth-first, right-to-left). You must nreverse it.\n+\n+   The BINFO_INHERITANCE of a virtual base class points to the binfo\n+   og the most derived type.\n+\n+   The binfo's TREE_CHAIN is set to inheritance graph order, but bases\n+   for non-class types are not included (i.e. those which are\n+   dependent bases in non-instantiated templates).  */\n+\n+tree\n+copy_base_binfos (binfo, t, prev)\n+     tree binfo, t, prev;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n-  tree new_binfo;\n-  int j;\n+  int n, ix;\n \n+  if (prev)\n+    TREE_CHAIN (prev) = binfo;\n+  prev = binfo;\n+  \n   if (binfos == NULL_TREE)\n-    return;\n+    return prev;\n \n-  /* Now unshare the structure beneath BINFO.  */\n-  for (j = TREE_VEC_LENGTH (binfos)-1;\n-       j >= 0; j--)\n+  n = TREE_VEC_LENGTH (binfos);\n+  \n+  /* Now copy the structure beneath BINFO.  */\n+  for (ix = 0; ix != n; ix++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, j);\n-      new_binfo = TREE_VEC_ELT (binfos, j)\n-\t= make_binfo (BINFO_OFFSET (base_binfo),\n-\t\t      base_binfo,\n-\t\t      BINFO_VTABLE (base_binfo),\n-\t\t      BINFO_VIRTUALS (base_binfo));\n-      TREE_VIA_PUBLIC (new_binfo) = TREE_VIA_PUBLIC (base_binfo);\n-      TREE_VIA_PROTECTED (new_binfo) = TREE_VIA_PROTECTED (base_binfo);\n-      TREE_VIA_VIRTUAL (new_binfo) = TREE_VIA_VIRTUAL (base_binfo);\n-      BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n-      BINFO_PRIMARY_BASE_OF (new_binfo) = NULL_TREE;\n-      unshare_base_binfos (new_binfo);\n+      tree base_binfo = TREE_VEC_ELT (binfos, ix);\n+      tree new_binfo = NULL_TREE;\n+\n+      if (!CLASS_TYPE_P (BINFO_TYPE (base_binfo)))\n+\t{\n+\t  my_friendly_assert (binfo == TYPE_BINFO (t), 20030204);\n+\t  \n+\t  new_binfo = base_binfo;\n+\t  TREE_CHAIN (prev) = new_binfo;\n+\t  prev = new_binfo;\n+\t  BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n+\t  BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n+\t}\n+      else if (TREE_VIA_VIRTUAL (base_binfo))\n+\t{\n+\t  new_binfo = purpose_member (BINFO_TYPE (base_binfo),\n+\t\t\t\t      CLASSTYPE_VBASECLASSES (t));\n+\t  if (new_binfo)\n+\t    new_binfo = TREE_VALUE (new_binfo);\n+\t}\n+      \n+      if (!new_binfo)\n+\t{\n+\t  new_binfo = make_binfo (BINFO_OFFSET (base_binfo),\n+\t\t\t\t  base_binfo, NULL_TREE,\n+\t\t\t\t  BINFO_VIRTUALS (base_binfo));\n+\t  prev = copy_base_binfos (new_binfo, t, prev);\n+\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t    {\n+\t      CLASSTYPE_VBASECLASSES (t)\n+\t\t= tree_cons (BINFO_TYPE (new_binfo), new_binfo,\n+\t\t\t     CLASSTYPE_VBASECLASSES (t));\n+\t      TREE_VIA_VIRTUAL (new_binfo) = 1;\n+\t      BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n+\t    }\n+\t  else\n+\t    BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n+\t}\n+      TREE_VEC_ELT (binfos, ix) = new_binfo;\n     }\n+\n+  return prev;\n }\n \n \f\n@@ -897,43 +941,30 @@ make_binfo (offset, binfo, vtable, virtuals)\n   tree type;\n \n   if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n+    {\n+      type = BINFO_TYPE (binfo);\n+      BINFO_DEPENDENT_BASE_P (new_binfo) = BINFO_DEPENDENT_BASE_P (binfo);\n+    }\n   else\n     {\n       type = binfo;\n-      binfo = CLASS_TYPE_P (type) ? TYPE_BINFO (binfo) : NULL_TREE;\n+      binfo = NULL_TREE;\n+      BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n     }\n \n   TREE_TYPE (new_binfo) = TYPE_MAIN_VARIANT (type);\n   BINFO_OFFSET (new_binfo) = offset;\n   BINFO_VTABLE (new_binfo) = vtable;\n   BINFO_VIRTUALS (new_binfo) = virtuals;\n \n-  if (binfo && BINFO_BASETYPES (binfo) != NULL_TREE)\n-    BINFO_BASETYPES (new_binfo) = copy_node (BINFO_BASETYPES (binfo));      \n-  return new_binfo;\n-}\n-\n-/* Return a TREE_LIST whose TREE_VALUE nodes along the\n-   BINFO_INHERITANCE_CHAIN for BINFO, but in the opposite order.  In\n-   other words, while the BINFO_INHERITANCE_CHAIN goes from base\n-   classes to derived classes, the reversed path goes from derived\n-   classes to base classes.  */\n-\n-tree\n-reverse_path (binfo)\n-     tree binfo;\n-{\n-  tree reversed_path;\n-\n-  reversed_path = NULL_TREE;\n-  while (binfo) \n+  if (binfo && !BINFO_DEPENDENT_BASE_P (binfo)\n+      && BINFO_BASETYPES (binfo) != NULL_TREE)\n     {\n-      reversed_path = tree_cons (NULL_TREE, binfo, reversed_path);\n-      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+      BINFO_BASETYPES (new_binfo) = copy_node (BINFO_BASETYPES (binfo));\n+      /* We do not need to copy the accesses, as they are read only.  */\n+      BINFO_BASEACCESSES (new_binfo) = BINFO_BASEACCESSES (binfo);\n     }\n-\n-  return reversed_path;\n+  return new_binfo;\n }\n \n void"}, {"sha": "06a0b420705b5eae348aa0b352f3a60fb72e783f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -5720,9 +5720,8 @@ get_delta_difference (from, to, force)\n       if (virt_binfo)\n         {\n           /* This is a reinterpret cast, we choose to do nothing.  */\n-          warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n-\t              BINFO_TYPE (virt_binfo),\n-\t              BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n+          warning (\"pointer to member cast via virtual base `%T'\",\n+\t\t   BINFO_TYPE (virt_binfo));\n           return delta;\n         }\n       delta = BINFO_OFFSET (binfo);\n@@ -5739,13 +5738,11 @@ get_delta_difference (from, to, force)\n     {\n       /* This is a reinterpret cast, we choose to do nothing.  */\n       if (force)\n-        warning (\"pointer to member cast via virtual base `%T' of `%T'\",\n-                    BINFO_TYPE (virt_binfo),\n-                    BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n+        warning (\"pointer to member cast via virtual base `%T'\",\n+\t\t BINFO_TYPE (virt_binfo));\n       else\n-\terror (\"pointer to member conversion via virtual base `%T' of `%T'\",\n-\t\t  BINFO_TYPE (virt_binfo),\n-                  BINFO_TYPE (BINFO_INHERITANCE_CHAIN (virt_binfo)));\n+\terror (\"pointer to member conversion via virtual base `%T'\",\n+\t       BINFO_TYPE (virt_binfo));\n       return delta;\n     }\n   delta = BINFO_OFFSET (binfo);"}, {"sha": "683745fc56b54c899a350254f4a5a2c7ea7959d8", "filename": "gcc/dbxout.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,6 +1,6 @@\n /* Output dbx-format symbol table information from GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1577,15 +1577,19 @@ dbxout_type (type, full)\n \t  }\n \tfor (i = 0; i < n_baseclasses; i++)\n \t  {\n-\t    tree child = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), i);\n-\n+\t    tree binfo = TYPE_BINFO (type);\n+\t    tree child = BINFO_BASETYPE (binfo, i);\n+\t    tree access = (BINFO_BASEACCESSES (binfo)\n+\t\t\t   ? BINFO_BASEACCESS (binfo, i) : access_public_node);\n+\t    \n \t    if (use_gnu_debug_info_extensions)\n \t      {\n \t\thave_used_extensions = 1;\n \t\tputc (TREE_VIA_VIRTUAL (child) ? '1' : '0', asmfile);\n-\t\tputc (TREE_VIA_PUBLIC (child) ? '2' : '0', asmfile);\n+\t\tputc (access == access_public_node ? '2' : '0', asmfile);\n \t\tCHARS (2);\n-\t\tif (TREE_VIA_VIRTUAL (child) && strcmp (lang_hooks.name, \"GNU C++\") == 0)\n+\t\tif (TREE_VIA_VIRTUAL (child)\n+\t\t    && strcmp (lang_hooks.name, \"GNU C++\") == 0)\n \t\t  /* For a virtual base, print the (negative) offset within\n \t\t     the vtable where we must look to find the necessary\n \t\t     adjustment.  */"}, {"sha": "ff0b8b0bdbbe21a2026f3859cb6d71faccacc96b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -3818,7 +3818,7 @@ static void gen_field_die\t\tPARAMS ((tree, dw_die_ref));\n static void gen_ptr_to_mbr_type_die\tPARAMS ((tree, dw_die_ref));\n static dw_die_ref gen_compile_unit_die\tPARAMS ((const char *));\n static void gen_string_type_die\t\tPARAMS ((tree, dw_die_ref));\n-static void gen_inheritance_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_inheritance_die\t\tPARAMS ((tree, tree, dw_die_ref));\n static void gen_member_die\t\tPARAMS ((tree, dw_die_ref));\n static void gen_struct_or_union_type_die PARAMS ((tree, dw_die_ref));\n static void gen_subroutine_type_die\tPARAMS ((tree, dw_die_ref));\n@@ -11363,8 +11363,8 @@ gen_string_type_die (type, context_die)\n /* Generate the DIE for a base class.  */\n \n static void\n-gen_inheritance_die (binfo, context_die)\n-     tree binfo;\n+gen_inheritance_die (binfo, access, context_die)\n+     tree binfo, access;\n      dw_die_ref context_die;\n {\n   dw_die_ref die = new_die (DW_TAG_inheritance, context_die, binfo);\n@@ -11375,9 +11375,9 @@ gen_inheritance_die (binfo, context_die)\n   if (TREE_VIA_VIRTUAL (binfo))\n     add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n \n-  if (TREE_VIA_PUBLIC (binfo))\n+  if (access == access_public_node)\n     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_public);\n-  else if (TREE_VIA_PROTECTED (binfo))\n+  else if (access == access_protected_node)\n     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_protected);\n }\n \n@@ -11389,6 +11389,7 @@ gen_member_die (type, context_die)\n      dw_die_ref context_die;\n {\n   tree member;\n+  tree binfo = TYPE_BINFO (type);\n   dw_die_ref child;\n \n   /* If this is not an incomplete type, output descriptions of each of its\n@@ -11404,14 +11405,17 @@ gen_member_die (type, context_die)\n      the TREE node representing the appropriate (containing) type.  */\n \n   /* First output info about the base classes.  */\n-  if (TYPE_BINFO (type) && TYPE_BINFO_BASETYPES (type))\n+  if (binfo && BINFO_BASETYPES (binfo))\n     {\n-      tree bases = TYPE_BINFO_BASETYPES (type);\n+      tree bases = BINFO_BASETYPES (binfo);\n+      tree accesses = BINFO_BASEACCESSES (binfo);\n       int n_bases = TREE_VEC_LENGTH (bases);\n       int i;\n \n       for (i = 0; i < n_bases; i++)\n-\tgen_inheritance_die (TREE_VEC_ELT (bases, i), context_die);\n+\tgen_inheritance_die (TREE_VEC_ELT (bases, i),\n+\t\t\t     (accesses ? TREE_VEC_ELT (accesses, i)\n+\t\t\t      : access_public_node), context_die);\n     }\n \n   /* Now output info about the data members and type members.  */"}, {"sha": "8f456f7ee7e6b6f4c6e058a0b5de0bb3fe2d743f", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -4179,7 +4179,8 @@ static void\n output_inheritance_die (arg)\n      void *arg;\n {\n-  tree binfo = arg;\n+  tree binfo = ((tree *)arg)[0];\n+  tree access = ((tree *)arg)[1];\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_inheritance);\n   sibling_attribute ();\n@@ -4190,12 +4191,12 @@ output_inheritance_die (arg)\n       ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_virtual);\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n     }\n-  if (TREE_VIA_PUBLIC (binfo))\n+  if (access == access_public_node)\n     {\n       ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_public);\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n     }\n-  else if (TREE_VIA_PROTECTED (binfo))\n+  else if (access == access_protected_node)\n     {\n       ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_protected);\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n@@ -4896,18 +4897,25 @@ output_type (type, containing_scope)\n \n \tif (COMPLETE_TYPE_P (type))\n \t  {\n+\t    tree binfo = TYPE_BINFO (type);\n+\t    \n \t    /* First output info about the base classes.  */\n-\t    if (TYPE_BINFO (type) && TYPE_BINFO_BASETYPES (type))\n+\t    if (binfo)\n \t      {\n-\t\tregister tree bases = TYPE_BINFO_BASETYPES (type);\n-\t\tregister int n_bases = TREE_VEC_LENGTH (bases);\n+\t\ttree bases = BINFO_BASETYPES (binfo);\n+\t\ttree accesses = BINFO_BASEACCESSES (binfo);\n+\t\tregister int n_bases = BINFO_N_BASETYPES (binfo);\n \t\tregister int i;\n \n \t\tfor (i = 0; i < n_bases; i++)\n \t\t  {\n-\t\t    tree binfo = TREE_VEC_ELT (bases, i);\n+\t\t    tree arg[2];\n+\n+\t\t    arg[0] = TREE_VEC_ELT (bases, i);\n+\t\t    arg[1] = (accesses ? TREE_VEC_ELT (accesses, i)\n+\t\t\t      : access_public_node);\n \t\t    output_type (BINFO_TYPE (binfo), containing_scope);\n-\t\t    output_die (output_inheritance_die, binfo);\n+\t\t    output_die (output_inheritance_die, arg);\n \t\t  }\n \t      }\n "}, {"sha": "44dbbce9f881716013a22f0026b6c45c2ed8bcc6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,3 +1,9 @@\n+2003-02-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tChange base class access representation.\n+\t* java/class.c (set_super_info): Don't set TREE_VIA_PUBLIC.\n+\t(add_interface_do): Likewise.\n+\n 2003-02-12  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* decl.c (java_init_decl_processing): Change "}, {"sha": "a58f604da35bc614721f5f160bbfb19cd58ca88b", "filename": "gcc/java/class.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -363,7 +363,6 @@ set_super_info (int access_flags, tree this_class,\n       tree super_binfo = make_tree_vec (BINFO_ELTS);\n       BINFO_TYPE (super_binfo) = super_class;\n       BINFO_OFFSET (super_binfo) = integer_zero_node;\n-      TREE_VIA_PUBLIC (super_binfo) = 1;\n       TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (this_class)), 0)\n \t= super_binfo;\n       CLASS_HAS_SUPER (this_class) = 1;\n@@ -497,7 +496,6 @@ add_interface_do (tree basetype_vec, tree interface_class, int i)\n   BINFO_OFFSET (interface_binfo) = integer_zero_node;\n   BINFO_VPTR_FIELD (interface_binfo) = integer_zero_node;\n   TREE_VIA_VIRTUAL (interface_binfo) = 1;\n-  TREE_VIA_PUBLIC (interface_binfo) = 1;\n   TREE_VEC_ELT (basetype_vec, i) = interface_binfo;\n }\n "}, {"sha": "4e360602b058da1bef263c76c29ea86465d26319", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,5 +1,5 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n This file is part of GCC.\n@@ -273,18 +273,37 @@ dequeue_and_dump (di)\n      more informative.  */\n   if (dni->binfo_p)\n     {\n-      if (TREE_VIA_PUBLIC (t))\n-\tdump_string (di, \"pub\");\n-      else if (TREE_VIA_PROTECTED (t))\n-\tdump_string (di, \"prot\");\n-      else if (TREE_VIA_PRIVATE (t))\n-\tdump_string (di, \"priv\");\n+      unsigned ix;\n+      tree bases = BINFO_BASETYPES (t);\n+      unsigned n_bases = bases ? TREE_VEC_LENGTH (bases): 0;\n+      tree accesses = BINFO_BASEACCESSES (t);\n+      \n+      dump_child (\"type\", BINFO_TYPE (t));\n+\n       if (TREE_VIA_VIRTUAL (t))\n \tdump_string (di, \"virt\");\n \n-      dump_child (\"type\", BINFO_TYPE (t));\n-      dump_child (\"base\", BINFO_BASETYPES (t));\n-\n+      dump_int (di, \"bases\", n_bases);\n+      for (ix = 0; ix != n_bases; ix++)\n+\t{\n+\t  tree base = TREE_VEC_ELT (bases, ix);\n+\t  tree access = (accesses ? TREE_VEC_ELT (accesses, ix)\n+\t\t\t : access_public_node);\n+\t  const char *string = NULL;\n+\n+\t  if (access == access_public_node)\n+\t    string = \"pub\";\n+\t  else if (access == access_protected_node)\n+\t    string = \"prot\";\n+\t  else if (access == access_private_node)\n+\t    string = \"priv\";\n+\t  else\n+\t    abort ();\n+\t  \n+\t  dump_string (di, string);\n+\t  queue_and_dump_index (di, \"binf\", base, DUMP_BINFO);\n+\t}\n+      \n       goto done;\n     }\n "}, {"sha": "7b714b17aafa601e2d6e9eaea3c6a3bd7a2a66cb", "filename": "gcc/tree.h", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dbbf88d1b81a71c5376fb4dbf0e952cb7834dcc7", "patch": "@@ -1,6 +1,6 @@\n /* Front-end tree definitions for GNU compiler.\n    Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002 Free Software Foundation, Inc.\n+   2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -192,25 +192,18 @@ struct tree_common GTY(())\n            INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n        TREE_PUBLIC in\n            VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n-       TREE_VIA_PUBLIC in\n-           TREE_LIST or TREE_VEC\n        EXPR_WFL_EMIT_LINE_NOTE in\n            EXPR_WITH_FILE_LOCATION\n \n    private_flag:\n \n-       TREE_VIA_PRIVATE in\n-           TREE_LIST or TREE_VEC\n        TREE_PRIVATE in\n            ..._DECL\n        CALL_EXPR_HAS_RETURN_SLOT_ADDR in\n            CALL_EXPR\n \n    protected_flag:\n \n-       TREE_VIA_PROTECTED in\n-           TREE_LIST\n-\t   TREE_VEC\n        TREE_PROTECTED in\n            BLOCK\n \t   ..._DECL\n@@ -565,20 +558,6 @@ extern void tree_vec_elt_check_failed PARAMS ((int, int, const char *,\n    for this name in an inner scope.  */\n #define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n \n-/* Nonzero for TREE_LIST or TREE_VEC node means that the path to the\n-   base class is via a `public' declaration, which preserves public\n-   fields from the base class as public.  */\n-#define TREE_VIA_PUBLIC(NODE) ((NODE)->common.public_flag)\n-\n-/* Ditto, for `private' declarations.  */\n-#define TREE_VIA_PRIVATE(NODE) ((NODE)->common.private_flag)\n-\n-/* Nonzero for TREE_LIST or TREE_VEC node means that the path to the\n-   base class is via a `protected' declaration, which preserves\n-   protected fields from the base class as protected.\n-   OVERLOADED.  */\n-#define TREE_VIA_PROTECTED(NODE) ((NODE)->common.protected_flag)\n-\n /* In any expression, nonzero means it has side effects or reevaluation\n    of the whole expression could produce a different value.\n    This is set if any subexpression is a function call, a side effect\n@@ -1362,7 +1341,16 @@ struct tree_type GTY(())\n    vtable where the offset to the virtual base can be found.  */\n #define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT (NODE, 5)\n \n-#define BINFO_ELTS 6\n+/* Indicates the accesses this binfo has to its bases. The values are\n+   access_public_node, access_protected_node or access_private_node.\n+   If this array is not present, public access is implied.  */\n+#define BINFO_BASEACCESSES(NODE) TREE_VEC_ELT ((NODE), 6)\n+#define BINFO_BASEACCESS(NODE,N) TREE_VEC_ELT (BINFO_BASEACCESSES(NODE), (N))\n+\n+/* Number of language independent elements in a binfo.  Languages may\n+   add additional trailing elements.  */\n+\n+#define BINFO_ELTS 7\n \n /* Slot used to build a chain that represents a use of inheritance.\n    For example, if X is derived from Y, and Y is derived from Z,\n@@ -2028,6 +2016,11 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define bitsize_one_node\t\tglobal_trees[TI_BITSIZE_ONE]\n #define bitsize_unit_node\t\tglobal_trees[TI_BITSIZE_UNIT]\n \n+/* Base access nodes.  */\n+#define access_public_node\t\tNULL_TREE\n+#define access_protected_node\t\tsize_zero_node\n+#define access_private_node\t\tsize_one_node\n+\n #define null_pointer_node\t\tglobal_trees[TI_NULL_POINTER]\n \n #define float_type_node\t\t\tglobal_trees[TI_FLOAT_TYPE]"}]}