{"sha": "c5cdb03fb9e13c384901671a424555550ed098f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjZGIwM2ZiOWUxM2MzODQ5MDE2NzFhNDI0NTU1NTUwZWQwOThmMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-03-23T21:05:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-03-23T21:05:30Z"}, "message": "re PR c/39495 (OMP parallel loop w/ unsigned index var rejected)\n\n\tPR c/39495\n\t* c-parser.c (c_parser_omp_for_loop): Call c_parser_binary_expression\n\tinstead of c_parser_expression_conv, if original_code isn't one of the\n\t4 allowed comparison codes, fail.\n\n\t* semantics.c (handle_omp_for_class_iterator): Swap cond operands and\n\tcode if iter is the second operand.\n\t* parser.c (cp_parser_binary_expression): Add no_toplevel_fold_p\n\targument.  If it is set, don't build the toplevel expression with\n\tbuild_x_binary_op, but build2.\n\t(cp_parser_assignment_expression,  cp_parser_omp_for_incr): Adjust\n\tcallers.\n\t(cp_parser_omp_for_cond): Don't assume the first operand of the\n\tcomparison must be decl.\n\n\t* gcc.dg/gomp/pr39495-2.c: Remove xfails.\n\n\t* testsuite/libgomp.c/loop-12.c: New test.\n\t* testsuite/libgomp.c/loop-11.c: New test.\n\t* testsuite/libgomp.c++/loop-11.C: New test.\n\t* testsuite/libgomp.c++/loop-12.C: New test.\n\t* testsuite/libgomp.c++/for-8.C: New test.\n\nFrom-SVN: r145014", "tree": {"sha": "a9fdfdfd88e5b8dd5deaf726ac04e0979d9d8ed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9fdfdfd88e5b8dd5deaf726ac04e0979d9d8ed9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5cdb03fb9e13c384901671a424555550ed098f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cdb03fb9e13c384901671a424555550ed098f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5cdb03fb9e13c384901671a424555550ed098f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cdb03fb9e13c384901671a424555550ed098f1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6afcfe0a8080cf3816e841f0f1c2b96a73baed43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6afcfe0a8080cf3816e841f0f1c2b96a73baed43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6afcfe0a8080cf3816e841f0f1c2b96a73baed43"}], "stats": {"total": 1737, "additions": 1706, "deletions": 31}, "files": [{"sha": "c1f7e6f0129784f88c37084ebb17c087a41e2acd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -1,3 +1,10 @@\n+2009-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/39495\n+\t* c-parser.c (c_parser_omp_for_loop): Call c_parser_binary_expression\n+\tinstead of c_parser_expression_conv, if original_code isn't one of the\n+\t4 allowed comparison codes, fail.\n+\n 2009-03-23  Richard Guenther  <rguenther@suse.de>\n \n \t* cgraph.h (struct cgraph_node): Reorder fields for 64-bit hosts."}, {"sha": "ea0036c0ba247ec80a57a7cc6ab8fad44b50c778", "filename": "gcc/c-parser.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -7652,9 +7652,23 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n       if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n \t{\n \t  location_t cond_loc = c_parser_peek_token (parser)->location;\n+\t  struct c_expr cond_expr = c_parser_binary_expression (parser, NULL);\n \n-\t  cond = c_parser_expression_conv (parser).value;\n+\t  cond = cond_expr.value;\n \t  cond = c_objc_common_truthvalue_conversion (cond_loc, cond);\n+\t  switch (cond_expr.original_code)\n+\t    {\n+\t    case GT_EXPR:\n+\t    case GE_EXPR:\n+\t    case LT_EXPR:\n+\t    case LE_EXPR:\n+\t      break;\n+\t    default:\n+\t      /* Can't be cond = error_mark_node, because we want to preserve\n+\t\t the location until c_finish_omp_for.  */\n+\t      cond = build1 (NOP_EXPR, boolean_type_node, error_mark_node);\n+\t      break;\n+\t    }\n \t  protected_set_expr_location (cond, cond_loc);\n \t}\n       c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");"}, {"sha": "3f1017477776c53c30d6aa94aba6906f2348bf6d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -1,3 +1,16 @@\n+2009-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/39495\n+\t* semantics.c (handle_omp_for_class_iterator): Swap cond operands and\n+\tcode if iter is the second operand.\n+\t* parser.c (cp_parser_binary_expression): Add no_toplevel_fold_p\n+\targument.  If it is set, don't build the toplevel expression with\n+\tbuild_x_binary_op, but build2.\n+\t(cp_parser_assignment_expression,  cp_parser_omp_for_incr): Adjust\n+\tcallers.\n+\t(cp_parser_omp_for_cond): Don't assume the first operand of the\n+\tcomparison must be decl.\n+\n 2009-03-23  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (make_fnparm_pack): Split out from..."}, {"sha": "02a96ccc4a4eb5ae3e721fc87929a85f7ddd05ec", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -1615,7 +1615,7 @@ static tree cp_parser_delete_expression\n static tree cp_parser_cast_expression\n   (cp_parser *, bool, bool, cp_id_kind *);\n static tree cp_parser_binary_expression\n-  (cp_parser *, bool, enum cp_parser_prec, cp_id_kind *);\n+  (cp_parser *, bool, bool, enum cp_parser_prec, cp_id_kind *);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n@@ -6215,6 +6215,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n static tree\n cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n+\t\t\t     bool no_toplevel_fold_p,\n \t\t\t     enum cp_parser_prec prec,\n \t\t\t     cp_id_kind * pidk)\n {\n@@ -6297,6 +6298,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t  goto get_rhs;\n \n \t pop:\n+\t  lookahead_prec = new_prec;\n \t  /* If the stack is not empty, we have parsed into LHS the right side\n \t     (`4' in the example above) of an expression we had suspended.\n \t     We can use the information on the stack to recover the LHS (`3')\n@@ -6321,8 +6323,14 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t pass the correct tree_code unless the unary expression was\n \t surrounded by parentheses.\n       */\n-      lhs = build_x_binary_op (tree_type, lhs, lhs_type, rhs, rhs_type,\n-\t\t\t       &overloaded_p, tf_warning_or_error);\n+      if (no_toplevel_fold_p\n+\t  && lookahead_prec <= prec\n+\t  && sp == stack\n+\t  && TREE_CODE_CLASS (tree_type) == tcc_comparison)\n+\tlhs = build2 (tree_type, boolean_type_node, lhs, rhs);\n+      else\n+\tlhs = build_x_binary_op (tree_type, lhs, lhs_type, rhs, rhs_type,\n+\t\t\t\t &overloaded_p, tf_warning_or_error);\n       lhs_type = tree_type;\n \n       /* If the binary operator required the use of an overloaded operator,\n@@ -6408,7 +6416,8 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n   else\n     {\n       /* Parse the binary expressions (logical-or-expression).  */\n-      expr = cp_parser_binary_expression (parser, cast_p, PREC_NOT_OPERATOR, pidk);\n+      expr = cp_parser_binary_expression (parser, cast_p, false,\n+\t\t\t\t\t  PREC_NOT_OPERATOR, pidk);\n       /* If the next token is a `?' then we're actually looking at a\n \t conditional-expression.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n@@ -21015,41 +21024,39 @@ cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n static tree\n cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n {\n-  tree lhs = cp_parser_cast_expression (parser, false, false, NULL), rhs;\n-  enum tree_code op;\n-  cp_token *token;\n+  tree cond = cp_parser_binary_expression (parser, false, true,\n+\t\t\t\t\t   PREC_NOT_OPERATOR, NULL);\n+  bool overloaded_p;\n \n-  if (decl && lhs != decl)\n+  if (cond == error_mark_node\n+      || cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     {\n       cp_parser_skip_to_end_of_statement (parser);\n       return error_mark_node;\n     }\n \n-  token = cp_lexer_peek_token (parser->lexer);\n-  op = binops_by_token [token->type].tree_type;\n-  switch (op)\n+  switch (TREE_CODE (cond))\n     {\n-    case LT_EXPR:\n-    case LE_EXPR:\n     case GT_EXPR:\n     case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n       break;\n     default:\n-      cp_parser_skip_to_end_of_statement (parser);\n       return error_mark_node;\n     }\n \n-  cp_lexer_consume_token (parser->lexer);\n-  rhs = cp_parser_binary_expression (parser, false,\n-\t\t\t\t     PREC_RELATIONAL_EXPRESSION, NULL);\n-  if (rhs == error_mark_node\n-      || cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    {\n-      cp_parser_skip_to_end_of_statement (parser);\n-      return error_mark_node;\n-    }\n+  /* If decl is an iterator, preserve LHS and RHS of the relational\n+     expr until finish_omp_for.  */\n+  if (decl\n+      && (type_dependent_expression_p (decl)\n+\t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n+    return cond;\n \n-  return build2 (op, boolean_type_node, lhs, rhs);\n+  return build_x_binary_op (TREE_CODE (cond),\n+\t\t\t    TREE_OPERAND (cond, 0), ERROR_MARK,\n+\t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,\n+\t\t\t    &overloaded_p, tf_warning_or_error);\n }\n \n /* Helper function, to parse omp for increment expression.  */\n@@ -21098,7 +21105,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n       return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);\n     }\n \n-  lhs = cp_parser_binary_expression (parser, false,\n+  lhs = cp_parser_binary_expression (parser, false, false,\n \t\t\t\t     PREC_ADDITIVE_EXPRESSION, NULL);\n   token = cp_lexer_peek_token (parser->lexer);\n   decl_first = lhs == decl;\n@@ -21112,7 +21119,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n     {\n       op = token->type == CPP_PLUS ? PLUS_EXPR : MINUS_EXPR;\n       cp_lexer_consume_token (parser->lexer);\n-      rhs = cp_parser_binary_expression (parser, false,\n+      rhs = cp_parser_binary_expression (parser, false, false,\n \t\t\t\t\t PREC_ADDITIVE_EXPRESSION, NULL);\n       token = cp_lexer_peek_token (parser->lexer);\n       if (token->type == CPP_PLUS || token->type == CPP_MINUS || decl_first)"}, {"sha": "71fc43e855a3b8290ee1db15ba0805da17b812af", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -3921,6 +3921,9 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n     case GE_EXPR:\n     case LT_EXPR:\n     case LE_EXPR:\n+      if (TREE_OPERAND (cond, 1) == iter)\n+\tcond = build2 (swap_tree_comparison (TREE_CODE (cond)),\n+\t\t       TREE_TYPE (cond), iter, TREE_OPERAND (cond, 0));\n       if (TREE_OPERAND (cond, 0) != iter)\n \tcond = error_mark_node;\n       else"}, {"sha": "cced718e42185a9696357efb09e3338cc04a0a84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -1,3 +1,8 @@\n+2009-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/39495\n+\t* gcc.dg/gomp/pr39495-2.c: Remove xfails.\n+\n 2009-03-23  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/auto12.C: Add variadic test."}, {"sha": "a276c24ed982a3e4e88e02faaf1aedd254fb0978", "filename": "gcc/testsuite/gcc.dg/gomp/pr39495-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr39495-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr39495-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr39495-2.c?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -13,25 +13,25 @@ foo (void)\n   unsigned int u;\n \n #pragma omp for\n-  for (i = INT_MIN + 6; i != INT_MIN; i--)\t/* { dg-error \"invalid controlling predicate\" \"\" { xfail *-*-* } } */\n+  for (i = INT_MIN + 6; i != INT_MIN; i--)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n   for (i = INT_MIN + 6; i == INT_MIN; i--)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n-  for (i = INT_MAX - 6; i != INT_MAX; i++)\t/* { dg-error \"invalid controlling predicate\" \"\" { xfail *-*-* }  } */\n+  for (i = INT_MAX - 6; i != INT_MAX; i++)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n   for (i = INT_MAX - 6; i == INT_MAX; i++)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n-  for (u = 6; u != 0; u--)\t\t\t/* { dg-error \"invalid controlling predicate\" \"\" { xfail *-*-* }  } */\n+  for (u = 6; u != 0; u--)\t\t\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n   for (u = 6; u == 0; u--)\t\t\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n-  for (u = UINT_MAX - 6; u != UINT_MAX; u++)\t/* { dg-error \"invalid controlling predicate\" \"\" { xfail *-*-* }  } */\n+  for (u = UINT_MAX - 6; u != UINT_MAX; u++)\t/* { dg-error \"invalid controlling predicate\" } */\n     ;\n #pragma omp for\n   for (u = UINT_MAX - 6; u == UINT_MAX; u++)\t/* { dg-error \"invalid controlling predicate\" } */"}, {"sha": "205bcceaaee43686873c8fd67cdb33759c4d837f", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -1,3 +1,12 @@\n+2009-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/39495\n+\t* testsuite/libgomp.c/loop-12.c: New test.\n+\t* testsuite/libgomp.c/loop-11.c: New test.\n+\t* testsuite/libgomp.c++/loop-11.C: New test.\n+\t* testsuite/libgomp.c++/loop-12.C: New test.\n+\t* testsuite/libgomp.c++/for-8.C: New test.\n+\n 2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure: Regenerate."}, {"sha": "918de7cc85171e955f775aa2486015b7adf0ef01", "filename": "libgomp/testsuite/libgomp.c++/for-8.C", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-8.C?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -0,0 +1,291 @@\n+// { dg-do run }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+void\n+baz (I<T> &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    abort ();\n+  results[*i]++;\n+}\n+\n+void\n+f1 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x; y >= i; i += 6)\n+    baz (i);\n+}\n+\n+void\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for private(i)\n+  for (i = x; y - 1 > i; i = 1 - 6 + 7 + i)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x; y >= i; i = i + 9 - 8)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for lastprivate(i)\n+  for (i = x + 2000 - 64; y + 10 < i; --i)\n+    baz (i);\n+}\n+\n+void\n+f5 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x + 2000 - 64; y + 10 < i; i -= 10)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f6 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x + 2000 - 64; y + 10 < i; i = i - 12 + 2)\n+    {\n+      I<int> j = i + N;\n+      baz (j);\n+    }\n+}\n+\n+template <int N>\n+void\n+f7 (I<int> i, const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (i = x - 10; y + 10 >= i; i += N)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f8 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp parallel for\n+  for (i = j.begin (); j.end () + N >= i; i += 2)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f9 (const I<T> &x, const I<T> &y)\n+{\n+#pragma omp parallel for\n+  for (I<T> i = x; y >= i; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f10 (const I<T> &x, const I<T> &y)\n+{\n+  I<T> i;\n+#pragma omp parallel for\n+  for (i = x; y < i; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f11 (const T &x, const T &y)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp for nowait\n+    for (T i = x; y >= i; i += 3)\n+      baz (i);\n+#pragma omp single\n+    {\n+      T j = y + 3;\n+      baz (j);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp parallel for\n+  for (i = x; y < i; --i)\n+    baz (i);\n+}\n+\n+template <int N>\n+struct K\n+{\n+  template <typename T>\n+  static void\n+  f13 (const T &x, const T &y)\n+  {\n+#pragma omp parallel for\n+    for (T i = x; y + N >= i; i += N)\n+      baz (i);\n+  }\n+};\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  f1 (&a[10], &a[1990]);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  f2 (&a[0], &a[1999]);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<char> (&a[20], &a[1837]);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (&a[0], &a[30]);\n+  check (i > 40 && i <= 2000 - 64);\n+  f5 (&a[0], &a[100]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (&a[10], &a[110]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f7<6> (I<int> (), &a[12], &a[1800]);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  f8<121> (J<int> (&a[14], &a[1803]));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  f9<int, 7> (&a[33], &a[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<int, -7> (&a[1939], &a[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<int> > (&a[16], &a[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<int> > (&a[1761], &a[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<int> > (&a[1], &a[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+  f9<long, 7> (&b[33], &b[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<long, -7> (&b[1939], &b[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<long> > (&b[16], &b[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<long> > (&b[1761], &b[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<long> > (&b[1], &b[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+}"}, {"sha": "7775b86b8182469c408fe02cbabf1f71be86837c", "filename": "libgomp/testsuite/libgomp.c++/loop-11.C", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-11.C?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -0,0 +1,276 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int\n+test1 ()\n+{\n+  short int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test2 ()\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test3 ()\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test4 ()\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test4 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test4 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test4 ();\n+  return 0;\n+}"}, {"sha": "f8aca92b8aee62d7591fb0f42890f2e33a943c55", "filename": "libgomp/testsuite/libgomp.c++/loop-12.C", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-12.C?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -0,0 +1,387 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+\n+extern \"C\" void abort ();\n+\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n+#define INT_MAX __INT_MAX__\n+\n+int arr[6 * 5];\n+\n+void\n+set (int loopidx, int idx)\n+{\n+#pragma omp atomic\n+  arr[loopidx * 5 + idx]++;\n+}\n+\n+#define check(var, val, loopidx, idx) \\\n+  if (var == (val)) set (loopidx, idx); else\n+#define test(loopidx, count) \\\n+  for (idx = 0; idx < 5; idx++) \\\n+    if (arr[loopidx * 5 + idx] != idx < count) \\\n+      abort (); \\\n+    else \\\n+      arr[loopidx * 5 + idx] = 0\n+\n+int\n+test1 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test2 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test3 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test4 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test5 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  if (2 * sizeof (int) != sizeof (long long))\n+    return 0;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test5 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test5 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test5 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test5 ();\n+  return 0;\n+}"}, {"sha": "c5ac3c4348a8f037e8ff4f5d6ba9f8d6c9fbaac2", "filename": "libgomp/testsuite/libgomp.c/loop-11.c", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-11.c?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -0,0 +1,276 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int\n+test1 (void)\n+{\n+  short int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test2 (void)\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test3 (void)\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test4 (void)\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[10]; &buf[54] > p; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[3]; &buf[63] >= p; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; &buf[51] > p; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; &buf[40] >= p; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[53]; &buf[9] < p; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[63]; &buf[3] <= p; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[48]; &buf[15] < p; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[40]; &buf[16] <= p; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test4 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test4 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test4 ();\n+  return 0;\n+}"}, {"sha": "395da363e4898de03700d2381821b3e47755a5d8", "filename": "libgomp/testsuite/libgomp.c/loop-12.c", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cdb03fb9e13c384901671a424555550ed098f1/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-12.c?ref=c5cdb03fb9e13c384901671a424555550ed098f1", "patch": "@@ -0,0 +1,387 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+\n+extern void abort (void);\n+\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n+#define INT_MAX __INT_MAX__\n+\n+int arr[6 * 5];\n+\n+void\n+set (int loopidx, int idx)\n+{\n+#pragma omp atomic\n+  arr[loopidx * 5 + idx]++;\n+}\n+\n+#define check(var, val, loopidx, idx) \\\n+  if (var == (val)) set (loopidx, idx); else\n+#define test(loopidx, count) \\\n+  for (idx = 0; idx < 5; idx++) \\\n+    if (arr[loopidx * 5 + idx] != idx < count) \\\n+      abort (); \\\n+    else \\\n+      arr[loopidx * 5 + idx] = 0\n+\n+int\n+test1 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test2 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test3 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test4 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test5 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = LLONG_MAX - 30001; LLONG_MAX - 10001 >= i; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -LLONG_MAX + 30000; -LLONG_MAX + 10000 <= i; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = 20; LLONG_MAX - 70 >= j; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = ULLONG_MAX - 3; LLONG_MAX + 70ULL <= j; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = LLONG_MAX - 20000ULL; LLONG_MAX + 10000ULL >= j; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; INT_MAX + 10000LL >= i; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  if (2 * sizeof (int) != sizeof (long long))\n+    return 0;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test5 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test5 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test5 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test5 ();\n+  return 0;\n+}"}]}