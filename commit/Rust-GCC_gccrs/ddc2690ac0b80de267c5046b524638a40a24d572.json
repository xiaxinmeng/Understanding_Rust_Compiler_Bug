{"sha": "ddc2690ac0b80de267c5046b524638a40a24d572", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRjMjY5MGFjMGI4MGRlMjY3YzUwNDZiNTI0NjM4YTQwYTI0ZDU3Mg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2009-05-03T23:31:18Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2009-05-03T23:31:18Z"}, "message": "expmed.c (synth_mult): When trying out a shift, pass the result of a signed shift.\n\n\t* expmed.c (synth_mult): When trying out a shift, pass the result\n\tof a signed shift.\n\nFrom-SVN: r147087", "tree": {"sha": "5f5db59d20cd73e728d53fddc169aa78116c6f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f5db59d20cd73e728d53fddc169aa78116c6f00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddc2690ac0b80de267c5046b524638a40a24d572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc2690ac0b80de267c5046b524638a40a24d572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc2690ac0b80de267c5046b524638a40a24d572", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc2690ac0b80de267c5046b524638a40a24d572/comments", "author": null, "committer": null, "parents": [{"sha": "ef268d34b78bed8d3e253fa00143b16817f68816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef268d34b78bed8d3e253fa00143b16817f68816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef268d34b78bed8d3e253fa00143b16817f68816"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "dcc0070b23207f5d28d0f068d8b6d25da04d938c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc2690ac0b80de267c5046b524638a40a24d572/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc2690ac0b80de267c5046b524638a40a24d572/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddc2690ac0b80de267c5046b524638a40a24d572", "patch": "@@ -1,3 +1,8 @@\n+2009-05-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* expmed.c (synth_mult): When trying out a shift, pass the result\n+\tof a signed shift.\n+\n 2009-05-04  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* expmed.c (shiftsub_cost): Rename to shiftsub0_cost."}, {"sha": "d0c1621cc5e2655813f7d3e1972267cc69b9690a", "filename": "gcc/expmed.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc2690ac0b80de267c5046b524638a40a24d572/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc2690ac0b80de267c5046b524638a40a24d572/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ddc2690ac0b80de267c5046b524638a40a24d572", "patch": "@@ -2551,6 +2551,38 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      best_alg->log[best_alg->ops] = m;\n \t      best_alg->op[best_alg->ops] = alg_shift;\n \t    }\n+\n+\t  /* See if treating ORIG_T as a signed number yields a better\n+\t     sequence.  Try this sequence only for a negative ORIG_T\n+\t     as it would be useless for a non-negative ORIG_T.  */\n+\t  if ((HOST_WIDE_INT) orig_t < 0)\n+\t    {\n+\t      /* Shift ORIG_T as follows because a right shift of a\n+\t\t negative-valued signed type is implementation\n+\t\t defined.  */\n+\t      q = ~(~orig_t >> m);\n+\t      /* The function expand_shift will choose between a shift\n+\t\t and a sequence of additions, so the observed cost is\n+\t\t given as MIN (m * add_cost[speed][mode],\n+\t\t shift_cost[speed][mode][m]).  */\n+\t      op_cost = m * add_cost[speed][mode];\n+\t      if (shift_cost[speed][mode][m] < op_cost)\n+\t\top_cost = shift_cost[speed][mode][m];\n+\t      new_limit.cost = best_cost.cost - op_cost;\n+\t      new_limit.latency = best_cost.latency - op_cost;\n+\t      synth_mult (alg_in, q, &new_limit, mode);\n+\n+\t      alg_in->cost.cost += op_cost;\n+\t      alg_in->cost.latency += op_cost;\n+\t      if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n+\t\t{\n+\t\t  struct algorithm *x;\n+\t\t  best_cost = alg_in->cost;\n+\t\t  x = alg_in, alg_in = best_alg, best_alg = x;\n+\t\t  best_alg->log[best_alg->ops] = m;\n+\t\t  best_alg->op[best_alg->ops] = alg_shift;\n+\t\t}\n+\t    }\n \t}\n       if (cache_hit)\n \tgoto done;"}]}