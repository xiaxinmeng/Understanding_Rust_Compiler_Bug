{"sha": "e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ2NmUyY2ViOWQ4ZmRiN2E2YmMxNDYzMjg4YTNmYzZkOThiYmNjMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-27T02:07:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-27T02:07:01Z"}, "message": "cgraphunit.c (verify_cgraph_node): Do checking that DECL match edge only when checking is enabled...\n\n\t* cgraphunit.c (verify_cgraph_node): Do checking that DECL match\n\tedge only when checking is enabled; check using former_clone_of;\n\tcheck inline clones too.\n\t(cgraph_materialize_clone): Record former_clone_of pointer.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Assert that we are not\n\tcombining redirections; dump args_to_skip bitmap\n\t(cgraph_materialize_all_clones): Do no redirection here.\n\t* ipa-inline.c (inline_transform): Do redirection here.\n\t* cgraph.h (struct cgraph_node): Add former_clone_of filed (enabled\n\tcheking only).\n\nFrom-SVN: r159907", "tree": {"sha": "fda3a71a120f0aa875aaa5fd29137598b8654835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fda3a71a120f0aa875aaa5fd29137598b8654835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/comments", "author": null, "committer": null, "parents": [{"sha": "fc7e91eb97a4ffbf4f48adc89b6c6e70f28c74dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7e91eb97a4ffbf4f48adc89b6c6e70f28c74dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7e91eb97a4ffbf4f48adc89b6c6e70f28c74dc"}], "stats": {"total": 71, "additions": 42, "deletions": 29}, "files": [{"sha": "3469a72d22a30e816dbdfbf8036eb3a004b6d079", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "patch": "@@ -1,3 +1,16 @@\n+2010-05-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (verify_cgraph_node): Do checking that DECL match\n+\tedge only when checking is enabled; check using former_clone_of;\n+\tcheck inline clones too.\n+\t(cgraph_materialize_clone): Record former_clone_of pointer.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Assert that we are not\n+\tcombining redirections; dump args_to_skip bitmap\n+\t(cgraph_materialize_all_clones): Do no redirection here.\n+\t* ipa-inline.c (inline_transform): Do redirection here.\n+\t* cgraph.h (struct cgraph_node): Add former_clone_of filed (enabled\n+\tcheking only).\n+\n 2010-05-26  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* config/avr/avr-c.c: Do not include regs.h."}, {"sha": "1080c4452c64603d73b9f478b3caeba8666ab4ab", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "patch": "@@ -226,6 +226,10 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n+#ifdef ENABLE_CHECKING\n+  /* Declaration node used to be clone of.  Used for checking only.  */\n+  tree former_clone_of;\n+#endif\n \n   PTR GTY ((skip)) aux;\n "}, {"sha": "f10d47185dcca351b962786c612a358e5a53ae35", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "patch": "@@ -801,9 +801,12 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t\tdebug_tree (e->callee->decl);\n \t\t\t\terror_found = true;\n \t\t\t      }\n-\t\t\t    else if (!node->global.inlined_to\n-\t\t\t\t     && !e->callee->global.inlined_to\n+#ifdef ENABLE_CHECKING\n+\t\t\t    else if (!e->callee->global.inlined_to\n \t\t\t\t     && decl\n+\t\t\t\t     && cgraph_get_node (decl)\n+\t\t\t\t     && (e->callee->former_clone_of\n+\t\t\t\t\t != cgraph_get_node (decl)->decl)\n \t\t\t\t     && !clone_of_p (cgraph_node (decl),\n \t\t\t\t\t\t     e->callee))\n \t\t\t      {\n@@ -813,6 +816,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t\tdebug_tree (decl);\n \t\t\t\terror_found = true;\n \t\t\t      }\n+#endif\n \t\t\t  }\n \t\t\telse if (decl)\n \t\t\t  {\n@@ -2284,6 +2288,11 @@ static void\n cgraph_materialize_clone (struct cgraph_node *node)\n {\n   bitmap_obstack_initialize (NULL);\n+#ifdef ENABLE_CHECKING\n+  node->former_clone_of = node->clone_of->decl;\n+  if (node->clone_of->former_clone_of)\n+    node->former_clone_of = node->clone_of->former_clone_of;\n+#endif\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (node->clone_of->decl, node->decl,\n   \t\t\t    node->clone.tree_map, true,\n@@ -2324,12 +2333,19 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       || cgraph_get_node (decl) == cgraph_get_node (e->callee->decl))\n     return e->call_stmt;\n \n+  gcc_assert (!cgraph_node (decl)->clone.combined_args_to_skip);\n+\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"updating call of %s/%i -> %s/%i: \",\n \t       cgraph_node_name (e->caller), e->caller->uid,\n \t       cgraph_node_name (e->callee), e->callee->uid);\n       print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+      if (e->callee->clone.combined_args_to_skip)\n+        {\n+          fprintf (cgraph_dump_file, \" combined args to skip: \");\n+          dump_bitmap (cgraph_dump_file, e->callee->clone.combined_args_to_skip);\n+\t}\n     }\n \n   if (e->callee->clone.combined_args_to_skip)\n@@ -2435,32 +2451,8 @@ cgraph_materialize_all_clones (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     if (!node->analyzed && node->callees)\n       cgraph_node_remove_callees (node);\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Updating call sites\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && !node->clone_of\n-\t&& gimple_has_body_p (node->decl))\n-      {\n-        struct cgraph_edge *e;\n-\n-\tcurrent_function_decl = node->decl;\n-        push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\tfor (e = node->callees; e; e = e->next_callee)\n-\t  cgraph_redirect_edge_call_stmt_to_callee (e);\n-\tgcc_assert (!need_ssa_update_p (cfun));\n-\tpop_cfun ();\n-\tcurrent_function_decl = NULL;\n-#ifdef ENABLE_CHECKING\n-        verify_cgraph_node (node);\n-#endif\n-      }\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n-  /* All changes to parameters have been performed.  In order not to\n-     incorrectly repeat them, we simply dispose of the bitmaps that drive the\n-     changes. */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    node->clone.combined_args_to_skip = NULL;\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif"}, {"sha": "d5f48bdbc4c85bf73c295cdec66ed59c502eeab5", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e466e2ceb9d8fdb7a6bc1463288a3fc6d98bbcc1", "patch": "@@ -2035,6 +2035,7 @@ inline_transform (struct cgraph_node *node)\n {\n   unsigned int todo = 0;\n   struct cgraph_edge *e;\n+  bool inline_p = false;\n \n   /* FIXME: Currently the passmanager is adding inline transform more than once to some\n      clones.  This needs revisiting after WPA cleanups.  */\n@@ -2047,10 +2048,13 @@ inline_transform (struct cgraph_node *node)\n     save_inline_function_body (node);\n \n   for (e = node->callees; e; e = e->next_callee)\n-    if (!e->inline_failed || warn_inline)\n-      break;\n+    {\n+      cgraph_redirect_edge_call_stmt_to_callee (e);\n+      if (!e->inline_failed || warn_inline)\n+        inline_p = true;\n+    }\n \n-  if (e)\n+  if (inline_p)\n     {\n       timevar_push (TV_INTEGRATION);\n       todo = optimize_inline_calls (current_function_decl);"}]}