{"sha": "0bd38d942cf03bc447d09bce4045369eccfa9431", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkMzhkOTQyY2YwM2JjNDQ3ZDA5YmNlNDA0NTM2OWVjY2ZhOTQzMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-24T14:01:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-24T14:01:57Z"}, "message": "[multiple changes]\n\n2014-01-24  Vincent Celier  <celier@adacore.com>\n\n\t* projects.texi: Document that aggregate projects are only\n\tsupported by gprbuild, but not by gnatmake.  Document that the\n\tonly attribute Switches in package Binder of aggregate projects\n\twill be ignored if its index is not others.  Document that\n\tattribute Global_Config_File is allowed in package Binder of\n\taggregate projects.\n\n2014-01-24  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb: Minor code reorganization.\n\t* sem_util.adb: Minor fix of potential latent bug in Is_LHS.\n\nFrom-SVN: r207029", "tree": {"sha": "162a1bb2e682eb7e7d618fb73ada5d4b9b1ca3b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/162a1bb2e682eb7e7d618fb73ada5d4b9b1ca3b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bd38d942cf03bc447d09bce4045369eccfa9431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd38d942cf03bc447d09bce4045369eccfa9431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd38d942cf03bc447d09bce4045369eccfa9431", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd38d942cf03bc447d09bce4045369eccfa9431/comments", "author": null, "committer": null, "parents": [{"sha": "0567ae8de77473e32db5942220bf06ec54c57a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0567ae8de77473e32db5942220bf06ec54c57a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0567ae8de77473e32db5942220bf06ec54c57a0d"}], "stats": {"total": 104, "additions": 77, "deletions": 27}, "files": [{"sha": "a21fe7cdd2b45442f508aa81c46422c6afd0160c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0bd38d942cf03bc447d09bce4045369eccfa9431", "patch": "@@ -1,3 +1,17 @@\n+2014-01-24  Vincent Celier  <celier@adacore.com>\n+\n+\t* projects.texi: Document that aggregate projects are only\n+\tsupported by gprbuild, but not by gnatmake.  Document that the\n+\tonly attribute Switches in package Binder of aggregate projects\n+\twill be ignored if its index is not others.  Document that\n+\tattribute Global_Config_File is allowed in package Binder of\n+\taggregate projects.\n+\n+2014-01-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb: Minor code reorganization.\n+\t* sem_util.adb: Minor fix of potential latent bug in Is_LHS.\n+\n 2014-01-24  Pascal Obry  <obry@adacore.com>\n \n \t* prj-attr.adb, projects.texi, snames.ads-tmpl: Add Excluded_Patterns"}, {"sha": "e9011e18bbc8f36e1fd276d7257de289d53a34da", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=0bd38d942cf03bc447d09bce4045369eccfa9431", "patch": "@@ -2365,6 +2365,9 @@ aggregate project, you will need to add \"p.gpr\" in the list of project\n files for the aggregate project, or the main will not be built when\n building the aggregate project.\n \n+Aggregate projects are only supported with @command{gprbuild}, but not with\n+@command{gnatmake}.\n+\n @c ---------------------------------------------------------\n @node Building a set of projects with a single command\n @subsection Building a set of projects with a single command\n@@ -2404,8 +2407,8 @@ with Annex E.\n @subsection Define a build environment\n @c ---------------------------------------------\n \n-The environment variables at the time you launch @command{gprbuild} or\n-@command{gnatmake} will influence the view these tools have of the project\n+The environment variables at the time you launch @command{gprbuild}\n+will influence the view these tools have of the project\n (PATH to find the compiler, ADA_PROJECT_PATH or GPR_PROJECT_PATH to find the\n projects, environment variables that are referenced in project files\n through the \"external\" statement,...). Several command line switches\n@@ -2462,12 +2465,12 @@ end MyProject;\n @subsection Performance improvements in builder\n @c --------------------------------------------\n \n-The loading of aggregate projects is optimized in @command{gprbuild} and\n-@command{gnatmake}, so that all files are searched for only once on the disk\n+The loading of aggregate projects is optimized in @command{gprbuild},\n+so that all files are searched for only once on the disk\n (thus reducing the number of system calls and contributing to faster\n compilation times especially on systems with sources on remote\n-servers). As part of the loading, @command{gprbuild} and @command{gnatmake}\n-compute how and where a source file should be compiled, and even if it is found\n+servers). As part of the loading, @command{gprbuild}\n+computes how and where a source file should be compiled, and even if it is found\n several times in the aggregated projects it will be compiled only\n once.\n \n@@ -2663,15 +2666,15 @@ These override the value given by the attribute, so that\n users can override the value set in the (presumably shared\n with others in his team) aggregate project.\n \n-@item The -X command line switch to @command{gprbuild} and @command{gnatmake}\n+@item The -X command line switch to @command{gprbuild}\n \n This always takes precedence.\n \n @end itemize\n \n This attribute is only taken into account in the main aggregate\n-project (i.e. the one specified on the command line to @command{gprbuild} or\n-@command{gnatmake}), and ignored in other aggregate projects. It is invalid\n+project (i.e. the one specified on the command line to @command{gprbuild}),\n+and ignored in other aggregate projects. It is invalid\n in standard projects.\n The goal is to have a consistent value in all\n projects that are built through the aggregate, which would not\n@@ -2695,13 +2698,15 @@ are valid:\n @table @asis\n @item @b{^Switches^Switches^}:\n @cindex @code{^Switches^Switches^}\n-This attribute gives the list of switches to use for the builder\n-(@command{gprbuild} or @command{gnatmake}), depending on the language of the\n-main file. For instance,\n+This attribute gives the list of switches to use for @command{gprbuild}.\n+Because no mains can be specified for aggregate projects, the only possible\n+index for attribute @code{Switches} is @code{others}. All other indexes will\n+be ignored.\n+\n+Example:\n \n @smallexample @c projectfile\n-for ^Switches^Switches^ (\"Ada\") use (\"-d\", \"-p\");\n-for ^Switches^Switches^ (\"C\")   use (\"-p\");\n+for ^Switches^Switches^ (other) use (\"-v\", \"-k\", \"-j8\");\n @end smallexample\n \n These switches are only read from the main aggregate project (the\n@@ -2797,14 +2802,21 @@ B), the switches used by the compiler are unambiguous.\n @cindex @code{Global_Configuration_Pragmas}\n \n This attribute can be used to specify a file containing\n-configuration pragmas, to be passed to the compiler.  Since we\n+configuration pragmas, to be passed to the Ada compiler.  Since we\n ignore the package Builder in other aggregate projects and projects,\n only those pragmas defined in the main aggregate project will be\n taken into account.\n \n Projects can locally add to those by using the\n @code{Compiler.Local_Configuration_Pragmas} attribute if they need.\n \n+@item @b{Global_Config_File}\n+@cindex @code{Global_Config_File}\n+\n+This attribute, indexed with a language name, can be used to specify a config\n+when compiling sources of the language. For Ada, these files are configuration\n+pragmas files.\n+\n @end table\n \n For projects that are built through the aggregate, the package Builder"}, {"sha": "e76e68872e2dd479f74d315db3db6577e0598c18", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0bd38d942cf03bc447d09bce4045369eccfa9431", "patch": "@@ -15565,14 +15565,10 @@ package body Sem_Prag is\n \n             case Ekind (Ent) is\n \n-               --  Objects (constants and variables)\n+               --  Objects (constants and variables) and types. For these cases\n+               --  all we need to do is to set the Linker_Section_pragma field.\n \n-               when E_Constant | E_Variable =>\n-                  Set_Linker_Section_Pragma (Ent, N);\n-\n-               --  Types\n-\n-               when Type_Kind =>\n+               when E_Constant | E_Variable | Type_Kind =>\n                   Set_Linker_Section_Pragma (Ent, N);\n \n                --  Subprograms"}, {"sha": "b5bb307e8e5dc78b8efaf6d0462ec348ade4e7ed", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd38d942cf03bc447d09bce4045369eccfa9431/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0bd38d942cf03bc447d09bce4045369eccfa9431", "patch": "@@ -9850,20 +9850,48 @@ package body Sem_Util is\n    ------------\n \n    --  We seem to have a lot of overlapping functions that do similar things\n-   --  (testing for left hand sides or lvalues???). Anyway, since this one is\n-   --  purely syntactic, it should be in Sem_Aux I would think???\n+   --  (testing for left hand sides or lvalues???).\n \n    function Is_LHS (N : Node_Id) return Boolean is\n       P : constant Node_Id := Parent (N);\n \n    begin\n+      --  Return True if we are the left hand side of an assignment statement\n+\n       if Nkind (P) = N_Assignment_Statement then\n          return Name (P) = N;\n \n-      elsif\n-        Nkind_In (P, N_Indexed_Component, N_Selected_Component, N_Slice)\n+      --  Case of prefix of indexed or selected component or slice\n+\n+      elsif Nkind_In (P, N_Indexed_Component, N_Selected_Component, N_Slice)\n+        and then N = Prefix (P)\n       then\n-         return N = Prefix (P) and then Is_LHS (P);\n+         --  Here we have the case where the parent P is N.Q or N(Q .. R).\n+         --  If P is an LHS, then N is also effectively an LHS, but there\n+         --  is an important exception. If N is of an access type, then\n+         --  what we really have is N.all.Q (or N.all(Q .. R)). In either\n+         --  case this makes N.all a left hand side but not N itself!\n+\n+         --  Here follows a worrisome kludge. If Etype (N) is not set, which\n+         --  for sure happens in the call from Find_Direct_Name, that means we\n+         --  don't know if N is of an access type, so we can't give an accurate\n+         --  answer. For now, we assume we do not have an access type, which\n+         --  means for example that P.Q.R := X will look like a modification\n+         --  of P, even if P.Q eventually turns out to be an access type. The\n+         --  consequence is at least that in some cases we incorrectly identify\n+         --  a reference as a modification. It is not clear if there are any\n+         --  other bad consequences. ???\n+\n+         if Present (Etype (N)) and then Is_Access_Type (Etype (N)) then\n+            return False;\n+\n+         --  OK, not access type case, so just test whole expression\n+\n+         else\n+            return Is_LHS (P);\n+         end if;\n+\n+      --  All other cases are not left hand sides\n \n       else\n          return False;"}]}