{"sha": "89ac681e18c3eace27e14bf03ff028bacd37e841", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlhYzY4MWUxOGMzZWFjZTI3ZTE0YmYwM2ZmMDI4YmFjZDM3ZTg0MQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-07-28T14:21:57Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-07-28T14:21:57Z"}, "message": "This patch improves the readability of the prolog and epilog code by moving some code into separate functions.\n\nThis patch improves the readability of the prolog and epilog code by moving\nsome code into separate functions.  There is no difference in generated code.\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_pushwb_pair_reg): Rename.\n\t(aarch64_push_reg): New function to push 1 or 2 registers.\n\t(aarch64_pop_reg): New function to pop 1 or 2 registers.\n\t(aarch64_expand_prologue): Use aarch64_push_regs.\n\t(aarch64_expand_epilogue): Use aarch64_pop_regs.\n\nFrom-SVN: r238818", "tree": {"sha": "5450f51cdbccd150dbfbc2ce4c10be10216498bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5450f51cdbccd150dbfbc2ce4c10be10216498bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89ac681e18c3eace27e14bf03ff028bacd37e841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ac681e18c3eace27e14bf03ff028bacd37e841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ac681e18c3eace27e14bf03ff028bacd37e841", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ac681e18c3eace27e14bf03ff028bacd37e841/comments", "author": null, "committer": null, "parents": [{"sha": "513d866d5b3b2b62fce9ad91fd032a02f17ed6eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/513d866d5b3b2b62fce9ad91fd032a02f17ed6eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/513d866d5b3b2b62fce9ad91fd032a02f17ed6eb"}], "stats": {"total": 79, "additions": 43, "deletions": 36}, "files": [{"sha": "16db0abc10583508bc7342e3b7f2b879e2a05734", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ac681e18c3eace27e14bf03ff028bacd37e841/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ac681e18c3eace27e14bf03ff028bacd37e841/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89ac681e18c3eace27e14bf03ff028bacd37e841", "patch": "@@ -1,3 +1,11 @@\n+2016-07-28  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_pushwb_pair_reg): Rename.\n+\t(aarch64_push_reg): New function to push 1 or 2 registers.\n+\t(aarch64_pop_reg): New function to pop 1 or 2 registers.\n+\t(aarch64_expand_prologue): Use aarch64_push_regs.\n+\t(aarch64_expand_epilogue): Use aarch64_pop_regs.\n+\n 2016-07-28  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \tPR tree-optimization/71734"}, {"sha": "d456670b7fe92ae4d00b92d05e7a12ec2bb98c20", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ac681e18c3eace27e14bf03ff028bacd37e841/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ac681e18c3eace27e14bf03ff028bacd37e841/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=89ac681e18c3eace27e14bf03ff028bacd37e841", "patch": "@@ -2861,10 +2861,14 @@ aarch64_gen_storewb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n }\n \n static void\n-aarch64_pushwb_pair_reg (machine_mode mode, unsigned regno1,\n-\t\t\t unsigned regno2, HOST_WIDE_INT adjustment)\n+aarch64_push_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment)\n {\n   rtx_insn *insn;\n+  machine_mode mode = (regno1 <= R30_REGNUM) ? DImode : DFmode;\n+\n+  if (regno2 == FIRST_PSEUDO_REGISTER)\n+    return aarch64_pushwb_single_reg (mode, regno1, adjustment);\n+\n   rtx reg1 = gen_rtx_REG (mode, regno1);\n   rtx reg2 = gen_rtx_REG (mode, regno2);\n \n@@ -2892,6 +2896,30 @@ aarch64_gen_loadwb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n     }\n }\n \n+static void\n+aarch64_pop_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment,\n+\t\t  rtx *cfi_ops)\n+{\n+  machine_mode mode = (regno1 <= R30_REGNUM) ? DImode : DFmode;\n+  rtx reg1 = gen_rtx_REG (mode, regno1);\n+\n+  *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg1, *cfi_ops);\n+\n+  if (regno2 == FIRST_PSEUDO_REGISTER)\n+    {\n+      rtx mem = plus_constant (Pmode, stack_pointer_rtx, adjustment);\n+      mem = gen_rtx_POST_MODIFY (Pmode, stack_pointer_rtx, mem);\n+      emit_move_insn (reg1, gen_rtx_MEM (mode, mem));\n+    }\n+  else\n+    {\n+      rtx reg2 = gen_rtx_REG (mode, regno2);\n+      *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg2, *cfi_ops);\n+      emit_insn (aarch64_gen_loadwb_pair (mode, stack_pointer_rtx, reg1,\n+\t\t\t\t\t  reg2, adjustment));\n+    }\n+}\n+\n static rtx\n aarch64_gen_store_pair (machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n \t\t\trtx reg2)\n@@ -3150,7 +3178,7 @@ aarch64_expand_prologue (void)\n \t\t\t\t\t R30_REGNUM, false);\n \t    }\n \t  else\n-\t    aarch64_pushwb_pair_reg (DImode, R29_REGNUM, R30_REGNUM, offset);\n+\t    aarch64_push_regs (R29_REGNUM, R30_REGNUM, offset);\n \n \t  /* Set up frame pointer to point to the location of the\n \t     previous frame pointer on the stack.  */\n@@ -3176,14 +3204,8 @@ aarch64_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n-\n+\t      aarch64_push_regs (reg1, reg2, offset);\n \t      skip_wb = true;\n-\n-\t      if (reg2 == FIRST_PSEUDO_REGISTER)\n-\t\taarch64_pushwb_single_reg (mode1, reg1, offset);\n-\t      else\n-\t\taarch64_pushwb_pair_reg (mode1, reg1, reg2, offset);\n \t    }\n \t}\n \n@@ -3305,39 +3327,16 @@ aarch64_expand_epilogue (bool for_sibcall)\n \temit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n \n       if (skip_wb)\n-\t{\n-\t  machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n-\t  rtx rreg1 = gen_rtx_REG (mode1, reg1);\n-\n-\t  cfi_ops = alloc_reg_note (REG_CFA_RESTORE, rreg1, cfi_ops);\n-\t  if (reg2 == FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      rtx mem = plus_constant (Pmode, stack_pointer_rtx, offset);\n-\t      mem = gen_rtx_POST_MODIFY (Pmode, stack_pointer_rtx, mem);\n-\t      mem = gen_rtx_MEM (mode1, mem);\n-\t      insn = emit_move_insn (rreg1, mem);\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx rreg2 = gen_rtx_REG (mode1, reg2);\n-\n-\t      cfi_ops = alloc_reg_note (REG_CFA_RESTORE, rreg2, cfi_ops);\n-\t      insn = emit_insn (aarch64_gen_loadwb_pair\n-\t\t\t\t(mode1, stack_pointer_rtx, rreg1,\n-\t\t\t\t rreg2, offset));\n-\t    }\n-\t}\n+\taarch64_pop_regs (reg1, reg2, offset, &cfi_ops);\n       else\n-\t{\n-\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t\t   GEN_INT (offset)));\n-\t}\n+\temit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (offset)));\n \n       /* Reset the CFA to be SP + FRAME_SIZE.  */\n       rtx new_cfa = stack_pointer_rtx;\n       if (frame_size > 0)\n \tnew_cfa = plus_constant (Pmode, new_cfa, frame_size);\n       cfi_ops = alloc_reg_note (REG_CFA_DEF_CFA, new_cfa, cfi_ops);\n+      insn = get_last_insn ();\n       REG_NOTES (insn) = cfi_ops;\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }"}]}