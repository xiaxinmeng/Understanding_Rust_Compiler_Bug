{"sha": "20906c66f2433627f139df6dbaf0bb1efd0da626", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5MDZjNjZmMjQzMzYyN2YxMzlkZjZkYmFmMGJiMWVmZDBkYTYyNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-08-02T16:13:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-08-02T16:13:29Z"}, "message": "backport: re PR fortran/46752 (OpenMP - Seg fault for unallocated allocatable array in firstprivate clause)\n\nMerge from gomp-3_1-branch branch:\n\n2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* c-parser.c (enum c_parser_prec): New enum, moved from within\n\tc_parser_binary_expression.\n\t(c_parser_binary_expression): Add PREC argument.  Stop parsing\n\tif operator has lower or equal precedence than PREC.\n\t(c_parser_conditional_expression, c_parser_omp_for_loop): Adjust\n\tcallers.\n\t(c_parser_omp_atomic): Handle parsing OpenMP 3.1 atomics.\n\tAdjust c_finish_omp_atomic caller.\n\t(c_parser_omp_taskyield): New function.\n\t(c_parser_pragma): Handle PRAGMA_OMP_TASKYIELD.\n\t(c_parser_omp_clause_name): Handle final and mergeable clauses.\n\t(c_parser_omp_clause_final, c_parser_omp_clause_mergeable): New\n\tfunctions.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_FINAL\n\tand PRAGMA_OMP_CLAUSE_MERGEABLE.\n\t(OMP_TASK_CLAUSE_MASK): Allow final and mergeable clauses.\n\t(c_parser_omp_clause_reduction): Handle min and max.\n\t* c-typeck.c (c_finish_omp_clauses): Don't complain about\n\tconst qualified predetermined vars in firstprivate clause.\n\tandle OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n\tHandle MIN_EXPR and MAX_EXPR.\n\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_FINAL\n\tand OMP_CLAUSE_MERGEABLE.\n\t(dump_generic_node): Handle OMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD\n\tand OMP_ATOMIC_CAPTURE_NEW.\n\t* tree.c (omp_clause_num_ops): Add OMP_CLAUSE_FINAL and\n\tOMP_CLAUSE_MERGEABLE.\n\t(omp_clause_code_name): Likewise.\n\t(walk_tree_1): Handle OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n\t* tree.h (enum omp_clause_code): Add OMP_CLAUSE_FINAL\n\tand OMP_CLAUSE_MERGEABLE.\n\t(OMP_CLAUSE_FINAL_EXPR): Define.\n\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE_FINAL and\n\tOMP_CLAUSE_MERGEABLE.\n\t(expand_task_call): Likewise.\n\t(expand_omp_atomic_load, expand_omp_atomic_store): New functions.\n\t(expand_omp_atomic_fetch_op): Handle cases where old or new\n\tvalue is needed afterwards.\n\t(expand_omp_atomic): Call expand_omp_atomic_load resp.\n\texpand_omp_atomic_store.\n\t* gimplify.c (gimplify_omp_atomic, gimplify_expr): Handle\n\tOMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD and OMP_ATOMIC_CAPTURE_NEW.\n\t(gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses): Handle\n\tOMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Likewise.\n\t* tree.def (OMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD,\n\tOMP_ATOMIC_CAPTURE_NEW): New.\n\t* gimple.h (GF_OMP_ATOMIC_NEED_VALUE): New.\n\t(gimple_omp_atomic_need_value_p, gimple_omp_atomic_set_need_value):\n\tNew inlines.\n\t* omp-builtins.def (BUILT_IN_GOMP_TASKYIELD): New builtin.\n\t* doc/generic.texi: Mention OMP_CLAUSE_COLLAPSE,\n\tOMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\ngcc/c-family/\n\t* c-common.h (c_finish_omp_atomic): Adjust prototype.\n\t(c_finish_omp_taskyield): New prototype.\n\t* c-omp.c (c_finish_omp_atomic): Add OPCODE, V, LHS1 and RHS1\n\targuments. Handle OMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD and\n\tOMP_ATOMIC_CAPTURE_NEW in addition to OMP_ATOMIC.  If LHS1\n\tor RHS1 have side-effects, evaluate those too in the right spot,\n\tif it is a decl and LHS is also a decl, error out if they\n\taren't the same.\n\t(c_finish_omp_taskyield): New function.\n\t* c-cppbuiltin.c (c_cpp_builtins): Change _OPENMP to 201107.\n\t* c-pragma.c (omp_pragmas): Add taskyield.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_TASKYIELD.\n\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_FINAL and\n\tPRAGMA_OMP_CLAUSE_MERGEABLE.\ngcc/cp/\n\t* cp-tree.h (finish_omp_atomic): Adjust prototype.\n\t(cxx_omp_const_qual_no_mutable): New prototype.\n\t(finish_omp_taskyield): New prototype.\n\t* parser.c (cp_parser_omp_atomic): (cp_parser_omp_atomic): Handle\n\tparsing OpenMP 3.1 atomics.  Adjust finish_omp_atomic caller.\n\t(cp_parser_omp_clause_name): Handle final and mergeable clauses.\n\t(cp_parser_omp_clause_final, cp_parser_omp_clause_mergeable): New\n\tfunctions.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_FINAL\n\tand PRAGMA_OMP_CLAUSE_MERGEABLE.\n\t(OMP_TASK_CLAUSE_MASK): Allow final and mergeable clauses.\n\t(cp_parser_omp_taskyield): New function.\n\t(cp_parser_pragma): Handle PRAGMA_OMP_TASKYIELD.\n\t(cp_parser_omp_clause_reduction): Handle min and max.\n\t* pt.c (tsubst_expr) <case OMP_ATOMIC>: Handle OpenMP 3.1 atomics.\n\t(tsubst_omp_clauses): Handle OMP_CLAUSE_FINAL and\n\tOMP_CLAUSE_MERGEABLE.\n\t* semantics.c (finish_omp_atomic): Add OPCODE, V, LHS1 and RHS1\n\targuments.  Handle OpenMP 3.1 atomics.  Adjust c_finish_omp_atomic\n\tcaller.\n\t(finish_omp_clauses): Don't complain about const qualified\n\tpredetermined vars and static data members in firstprivate clause.\n\tHandle OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE. Handle MIN_EXPR\n\tand MAX_EXPR.\n\t(finish_omp_taskyield): New function.\n\t* cp-gimplify.c (cxx_omp_const_qual_no_mutable): New function.\n\t(cxx_omp_predetermined_sharing): Use it.\ngcc/fortran/\n\tPR fortran/46752\n\t* cpp.c (cpp_define_builtins): Change _OPENMP to 201107.\n\t* openmp.c (gfc_free_omp_clauses): Free also final_expr.\n\t(OMP_CLAUSE_FINAL, OMP_CLAUSE_MERGEABLE): Define.\n\t(gfc_match_omp_clauses): Handle parsing final and mergeable\n\tclauses.\n\t(OMP_TASK_CLAUSES): Allow final and mergeable clauses.\n\t(gfc_match_omp_taskyield): New function.\n\t(resolve_omp_clauses): Resolve final clause.  Allow POINTERs and\n\tCray pointers in clauses other than REDUCTION.\n\t(gfc_match_omp_atomic): Match optional\n\tread/write/update/capture keywords after !$omp atomic.\n\t(resolve_omp_atomic): Handle all OpenMP 3.1 atomic forms.\n\t* dump-parse-tree.c (show_omp_node): Handle EXEC_OMP_TASKYIELD,\n\tprint final and mergeable clauses.\n\t(show_code_node): Handle EXEC_OMP_TASKYIELD.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Handle final and\n\tmergeable clauses.\n\t(gfc_trans_omp_taskyield): New function.\n\t(gfc_trans_omp_directive): Handle EXEC_OMP_TASKYIELD.\n\t(gfc_trans_omp_atomic): Handle all OpenMP 3.1 atomic forms.\n\t(gfc_omp_clause_copy_ctor): Handle non-allocated allocatable.\n\t(gfc_omp_predetermined_sharing): Adjust comment.\n\t* gfortran.h (gfc_statement): Add ST_OMP_TASKYIELD and\n\tST_OMP_END_ATOMIC.\n\t(gfc_omp_clauses): Add final_expr and mergeable fields.\n\t(gfc_exec_op): Add EXEC_OMP_TASKYIELD.\n\t(gfc_omp_atomic_op): New enum typedef.\n\t(struct gfc_code): Add ext.omp_atomic.\n\t* trans.c (trans_code): Handle EXEC_OMP_TASKYIELD.\n\t* frontend-passes.c (gfc_code_walker): Also walk final_expr.\n\t* resolve.c (gfc_resolve_blocks, resolve_code): Handle\n\tEXEC_OMP_TASKYIELD.\n\t* st.c (gfc_free_statement): Likewise.\n\t* match.h (gfc_match_omp_taskyield): New prototype.\n\t* parse.c (decode_omp_directive): Handle taskyield directive.\n\tHandle !$omp end atomic.\n\t(case_executable): Add ST_OMP_TASKYIELD case.\n\t(gfc_ascii_statement): Handle ST_OMP_TASKYIELD.\n\t(parse_omp_atomic): Return gfc_statement instead of void.\n\tFor !$omp atomic capture parse two assignments instead of\n\tjust one and require !$omp end atomic afterwards, for\n\tother !$omp atomic forms just allow !$omp end atomic at the\n\tend.\n\t(parse_omp_structured_block, parse_executable): Adjust\n\tparse_omp_atomic callers.\n\n2011-08-02  Tobias Burnus  <burnus@net-b.de>\n\n\t* intrinsic.c (OMP_LIB): Updated openmp_version's\n\tvalue to 201107.\n\t* gfortran.texi (OpenMP): Update ref to OpenMP 3.1.\n\t* intrinsic.texi (OpenMP Modules): Update ref to OpenMP 3.1;\n\tremove deleted omp_integer_kind and omp_logical_kind constants.\ngcc/testsuite/\n\tPR fortran/46752\n\t* gcc.dg/gomp/atomic-5.c: Adjust expected diagnostics.\n\t* gcc.dg/gomp/atomic-15.c: New test.\n\t* g++.dg/gomp/atomic-5.C: Adjust expected diagnostics.\n\t* g++.dg/gomp/atomic-15.C: New test.\n\t* g++.dg/gomp/private-1.C: New test.\n\t* g++.dg/gomp/sharing-2.C: New test.\n\t* gfortran.dg/gomp/crayptr1.f90: Don't expect error\n\tabout Cray pointer in FIRSTPRIVATE/LASTPRIVATE.\n\t* gfortran.dg/gomp/omp_atomic2.f90: New test.\nlibgomp/\n\tPR fortran/42041\n\tPR fortran/46752\n\t* omp.h.in (omp_in_final): New prototype.\n\t* omp_lib.f90.in (omp_in_final): New interface.\n\t(omp_integer_kind, omp_logical_kind): Remove\n\tand replace all its uses in the module with 4.\n\t(openmp_version): Change to 201107.\n\t* omp_lib.h.in (omp_sched_static, omp_sched_dynamic,\n\tomp_sched_guided, omp_sched_auto): Use omp_sched_kind\n\tkind for the parameters.\n\t(omp_in_final): New external.\n\t(openmp_version): Change to 201107.\n\t* task.c (omp_in_final): New function.\n\t(gomp_init_task): Initialize final_task.\n\t(GOMP_task): Remove unused attribute from flags.  Handle final\n\ttasks.\n\t(GOMP_taskyield): New function.\n\t(omp_in_final): Return true if if (false) or final (true) task\n\tor descendant of final (true).\n\t* fortran.c (omp_in_final_): New function.\n\t* libgomp.map (OMP_3.1): Export omp_in_final and omp_in_final_.\n\t(GOMP_3.0): Export GOMP_taskyield.\n\t* env.c (gomp_nthreads_var_list, gomp_nthreads_var_list_len): New\n\tvariables.\n\t(parse_unsigned_long_list): New function.\n\t(initialize_env): Use it for OMP_NUM_THREADS.  Call parse_boolean\n\twith \"OMP_PROC_BIND\".  If OMP_PROC_BIND=true, call gomp_init_affinity\n\teven if parse_affinity returned false.\n\t* config/linux/affinity.c (gomp_init_affinity): Handle\n\tgomp_cpu_affinity_len == 0.\n\t* libgomp_g.h (GOMP_taskyield): New prototype.\n\t* libgomp.h (struct gomp_task): Add final_task field.\n\t(gomp_nthreads_var_list, gomp_nthreads_var_list_len): New externs.\n\t* team.c (gomp_team_start): Override new task's nthreads_var icv\n\tif list form OMP_NUM_THREADS has been used and it has value for\n\tthe new nesting level.\n\n\t* testsuite/libgomp.c/atomic-11.c: New test.\n\t* testsuite/libgomp.c/atomic-12.c: New test.\n\t* testsuite/libgomp.c/atomic-13.c: New test.\n\t* testsuite/libgomp.c/atomic-14.c: New test.\n\t* testsuite/libgomp.c/reduction-6.c: New test.\n\t* testsuite/libgomp.c/task-5.c: New test.\n\t* testsuite/libgomp.c++/atomic-2.C: New test.\n\t* testsuite/libgomp.c++/atomic-3.C: New test.\n\t* testsuite/libgomp.c++/atomic-4.C: New test.\n\t* testsuite/libgomp.c++/atomic-5.C: New test.\n\t* testsuite/libgomp.c++/atomic-6.C: New test.\n\t* testsuite/libgomp.c++/atomic-7.C: New test.\n\t* testsuite/libgomp.c++/atomic-8.C: New test.\n\t* testsuite/libgomp.c++/atomic-9.C: New test.\n\t* testsuite/libgomp.c++/task-8.C: New test.\n\t* testsuite/libgomp.c++/reduction-4.C: New test.\n\t* testsuite/libgomp.fortran/allocatable7.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable8.f90: New test.\n\t* testsuite/libgomp.fortran/crayptr3.f90: New test.\n\t* testsuite/libgomp.fortran/omp_atomic3.f90: New test.\n\t* testsuite/libgomp.fortran/omp_atomic4.f90: New test.\n\t* testsuite/libgomp.fortran/pointer1.f90: New test.\n\t* testsuite/libgomp.fortran/pointer2.f90: New test.\n\t* testsuite/libgomp.fortran/task4.f90: New test.\n\n2011-08-02  Tobias Burnus  <burnus@net-b.de>\n\n\t* libgomp.texi: Update OpenMP spec references to 3.1.\n\t(omp_in_final,OMP_PROC_BIND): New sections.\n\t(OMP_NUM_THREADS): Document that the value can be now a list.\n\t(GOMP_STACKSIZE,GOMP_CPU_AFFINITY): Update @ref.\n\nFrom-SVN: r177194", "tree": {"sha": "2f3013a777c51a67a52b10f839e1bd56903dc5ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f3013a777c51a67a52b10f839e1bd56903dc5ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20906c66f2433627f139df6dbaf0bb1efd0da626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20906c66f2433627f139df6dbaf0bb1efd0da626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20906c66f2433627f139df6dbaf0bb1efd0da626", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20906c66f2433627f139df6dbaf0bb1efd0da626/comments", "author": null, "committer": null, "parents": [{"sha": "113430e542916eb563a5cb770470cdf562856836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113430e542916eb563a5cb770470cdf562856836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/113430e542916eb563a5cb770470cdf562856836"}], "stats": {"total": 4654, "additions": 4321, "deletions": 333}, "files": [{"sha": "18e0107d71ed1e36cb3479f1f6656c61c66498b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,3 +1,60 @@\n+2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-parser.c (enum c_parser_prec): New enum, moved from within\n+\tc_parser_binary_expression.\n+\t(c_parser_binary_expression): Add PREC argument.  Stop parsing\n+\tif operator has lower or equal precedence than PREC.\n+\t(c_parser_conditional_expression, c_parser_omp_for_loop): Adjust\n+\tcallers.\n+\t(c_parser_omp_atomic): Handle parsing OpenMP 3.1 atomics.\n+\tAdjust c_finish_omp_atomic caller.\n+\t(c_parser_omp_taskyield): New function.\n+\t(c_parser_pragma): Handle PRAGMA_OMP_TASKYIELD.\n+\t(c_parser_omp_clause_name): Handle final and mergeable clauses.\n+\t(c_parser_omp_clause_final, c_parser_omp_clause_mergeable): New\n+\tfunctions.\n+\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_FINAL\n+\tand PRAGMA_OMP_CLAUSE_MERGEABLE.\n+\t(OMP_TASK_CLAUSE_MASK): Allow final and mergeable clauses.\n+\t(c_parser_omp_clause_reduction): Handle min and max.\n+\t* c-typeck.c (c_finish_omp_clauses): Don't complain about\n+\tconst qualified predetermined vars in firstprivate clause.\n+\tandle OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n+\tHandle MIN_EXPR and MAX_EXPR.\n+\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_FINAL\n+\tand OMP_CLAUSE_MERGEABLE.\n+\t(dump_generic_node): Handle OMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD\n+\tand OMP_ATOMIC_CAPTURE_NEW.\n+\t* tree.c (omp_clause_num_ops): Add OMP_CLAUSE_FINAL and\n+\tOMP_CLAUSE_MERGEABLE.\n+\t(omp_clause_code_name): Likewise.\n+\t(walk_tree_1): Handle OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n+\t* tree.h (enum omp_clause_code): Add OMP_CLAUSE_FINAL\n+\tand OMP_CLAUSE_MERGEABLE.\n+\t(OMP_CLAUSE_FINAL_EXPR): Define.\n+\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE_FINAL and\n+\tOMP_CLAUSE_MERGEABLE.\n+\t(expand_task_call): Likewise.\n+\t(expand_omp_atomic_load, expand_omp_atomic_store): New functions.\n+\t(expand_omp_atomic_fetch_op): Handle cases where old or new\n+\tvalue is needed afterwards.\n+\t(expand_omp_atomic): Call expand_omp_atomic_load resp.\n+\texpand_omp_atomic_store.\n+\t* gimplify.c (gimplify_omp_atomic, gimplify_expr): Handle\n+\tOMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD and OMP_ATOMIC_CAPTURE_NEW.\n+\t(gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses): Handle\n+\tOMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Likewise.\n+\t* tree.def (OMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD,\n+\tOMP_ATOMIC_CAPTURE_NEW): New.\n+\t* gimple.h (GF_OMP_ATOMIC_NEED_VALUE): New.\n+\t(gimple_omp_atomic_need_value_p, gimple_omp_atomic_set_need_value):\n+\tNew inlines.\n+\t* omp-builtins.def (BUILT_IN_GOMP_TASKYIELD): New builtin.\n+\t* doc/generic.texi: Mention OMP_CLAUSE_COLLAPSE,\n+\tOMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE.\n+\n 2011-08-02  Kai Tietz  <ktietz@redhat.com>\n \n \t* gimple.c (canonicalize_cond_expr_cond): Handle cast from"}, {"sha": "91ed861b5b34073cf74c6470ab298448b858f6cd", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,3 +1,20 @@\n+2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (c_finish_omp_atomic): Adjust prototype.\n+\t(c_finish_omp_taskyield): New prototype.\n+\t* c-omp.c (c_finish_omp_atomic): Add OPCODE, V, LHS1 and RHS1\n+\targuments. Handle OMP_ATOMIC_READ, OMP_ATOMIC_CAPTURE_OLD and\n+\tOMP_ATOMIC_CAPTURE_NEW in addition to OMP_ATOMIC.  If LHS1\n+\tor RHS1 have side-effects, evaluate those too in the right spot,\n+\tif it is a decl and LHS is also a decl, error out if they\n+\taren't the same.\n+\t(c_finish_omp_taskyield): New function.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Change _OPENMP to 201107.\n+\t* c-pragma.c (omp_pragmas): Add taskyield.\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_TASKYIELD.\n+\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_FINAL and\n+\tPRAGMA_OMP_CLAUSE_MERGEABLE.\n+\n 2011-07-25  Dodji Seketeli  <dodji@redhat.com>\n \n \t* c-common.h (set_underlying_type): Remove parm name from"}, {"sha": "3a4977929d91b735af4e06b2eb6b5f016043c93b", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1029,9 +1029,11 @@ extern tree c_finish_omp_master (location_t, tree);\n extern tree c_finish_omp_critical (location_t, tree, tree);\n extern tree c_finish_omp_ordered (location_t, tree);\n extern void c_finish_omp_barrier (location_t);\n-extern tree c_finish_omp_atomic (location_t, enum tree_code, tree, tree);\n+extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,\n+\t\t\t\t tree, tree, tree, tree, tree);\n extern void c_finish_omp_flush (location_t);\n extern void c_finish_omp_taskwait (location_t);\n+extern void c_finish_omp_taskyield (location_t);\n extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);\n extern void c_split_parallel_clauses (location_t, tree, tree *, tree *);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);"}, {"sha": "a960cbea8743d8fa4b1231df3efce00e5e3dcfac", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -807,7 +807,7 @@ c_cpp_builtins (cpp_reader *pfile)\n     cpp_define (pfile, \"__SSP__=1\");\n \n   if (flag_openmp)\n-    cpp_define (pfile, \"_OPENMP=200805\");\n+    cpp_define (pfile, \"_OPENMP=201107\");\n \n   if (int128_integer_type_node != NULL_TREE)\n     builtin_define_type_sizeof (\"__SIZEOF_INT128__\","}, {"sha": "4a5b0ca928b01552540983afb0419c668596e196", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 101, "deletions": 10, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,7 +1,8 @@\n /* This file contains routines to construct GNU OpenMP constructs,\n    called from parsing in the C and C++ front ends.\n \n-   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>,\n \t\t  Diego Novillo <dnovillo@redhat.com>.\n \n@@ -96,18 +97,39 @@ c_finish_omp_taskwait (location_t loc)\n }\n \n \n-/* Complete a #pragma omp atomic construct.  The expression to be\n-   implemented atomically is LHS code= RHS.  LOC is the location of\n-   the atomic statement.  The value returned is either error_mark_node\n-   (if the construct was erroneous) or an OMP_ATOMIC node which should\n-   be added to the current statement tree with add_stmt.*/\n+/* Complete a #pragma omp taskyield construct.  LOC is the location of the\n+   pragma.  */\n+\n+void\n+c_finish_omp_taskyield (location_t loc)\n+{\n+  tree x;\n+\n+  x = built_in_decls[BUILT_IN_GOMP_TASKYIELD];\n+  x = build_call_expr_loc (loc, x, 0);\n+  add_stmt (x);\n+}\n+\n+\n+/* Complete a #pragma omp atomic construct.  For CODE OMP_ATOMIC\n+   the expression to be implemented atomically is LHS opcode= RHS. \n+   For OMP_ATOMIC_READ V = LHS, for OMP_ATOMIC_CAPTURE_{NEW,OLD} LHS\n+   opcode= RHS with the new or old content of LHS returned.\n+   LOC is the location of the atomic statement.  The value returned\n+   is either error_mark_node (if the construct was erroneous) or an\n+   OMP_ATOMIC* node which should be added to the current statement\n+   tree with add_stmt.  */\n \n tree\n-c_finish_omp_atomic (location_t loc, enum tree_code code, tree lhs, tree rhs)\n+c_finish_omp_atomic (location_t loc, enum tree_code code,\n+\t\t     enum tree_code opcode, tree lhs, tree rhs,\n+\t\t     tree v, tree lhs1, tree rhs1)\n {\n   tree x, type, addr;\n \n-  if (lhs == error_mark_node || rhs == error_mark_node)\n+  if (lhs == error_mark_node || rhs == error_mark_node\n+      || v == error_mark_node || lhs1 == error_mark_node\n+      || rhs1 == error_mark_node)\n     return error_mark_node;\n \n   /* ??? According to one reading of the OpenMP spec, complex type are\n@@ -143,19 +165,88 @@ c_finish_omp_atomic (location_t loc, enum tree_code code, tree lhs, tree rhs)\n     }\n   lhs = build_indirect_ref (loc, addr, RO_NULL);\n \n+  if (code == OMP_ATOMIC_READ)\n+    {\n+      x = build1 (OMP_ATOMIC_READ, type, addr);\n+      SET_EXPR_LOCATION (x, loc);\n+      return build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n+\t\t\t\tloc, x, NULL_TREE);\n+      return x;\n+    }\n+\n   /* There are lots of warnings, errors, and conversions that need to happen\n      in the course of interpreting a statement.  Use the normal mechanisms\n      to do this, and then take it apart again.  */\n-  x = build_modify_expr (input_location, lhs, NULL_TREE, code,\n+  x = build_modify_expr (input_location, lhs, NULL_TREE, opcode,\n       \t\t\t input_location, rhs, NULL_TREE);\n   if (x == error_mark_node)\n     return error_mark_node;\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);\n   rhs = TREE_OPERAND (x, 1);\n \n   /* Punt the actual generation of atomic operations to common code.  */\n-  x = build2 (OMP_ATOMIC, void_type_node, addr, rhs);\n+  if (code == OMP_ATOMIC)\n+    type = void_type_node;\n+  x = build2 (code, type, addr, rhs);\n   SET_EXPR_LOCATION (x, loc);\n+\n+  /* Generally it is hard to prove lhs1 and lhs are the same memory\n+     location, just diagnose different variables.  */\n+  if (rhs1\n+      && TREE_CODE (rhs1) == VAR_DECL\n+      && TREE_CODE (lhs) == VAR_DECL\n+      && rhs1 != lhs)\n+    {\n+      if (code == OMP_ATOMIC)\n+\terror_at (loc, \"%<#pragma omp atomic update%> uses two different variables for memory\");\n+      else\n+\terror_at (loc, \"%<#pragma omp atomic capture%> uses two different variables for memory\");\n+      return error_mark_node;\n+    }\n+\n+  if (code != OMP_ATOMIC)\n+    {\n+      /* Generally it is hard to prove lhs1 and lhs are the same memory\n+\t location, just diagnose different variables.  */\n+      if (lhs1 && TREE_CODE (lhs1) == VAR_DECL && TREE_CODE (lhs) == VAR_DECL)\n+\t{\n+\t  if (lhs1 != lhs)\n+\t    {\n+\t      error_at (loc, \"%<#pragma omp atomic capture%> uses two different variables for memory\");\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      x = build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n+\t\t\t     loc, x, NULL_TREE);\n+      if (rhs1 && rhs1 != lhs)\n+\t{\n+\t  tree rhs1addr = build_unary_op (loc, ADDR_EXPR, rhs1, 0);\n+\t  if (rhs1addr == error_mark_node)\n+\t    return error_mark_node;\n+\t  x = omit_one_operand_loc (loc, type, x, rhs1addr);\n+\t}\n+      if (lhs1 && lhs1 != lhs)\n+\t{\n+\t  tree lhs1addr = build_unary_op (loc, ADDR_EXPR, lhs1, 0);\n+\t  if (lhs1addr == error_mark_node)\n+\t    return error_mark_node;\n+\t  if (code == OMP_ATOMIC_CAPTURE_OLD)\n+\t    x = omit_one_operand_loc (loc, type, x, lhs1addr);\n+\t  else\n+\t    {\n+\t      x = save_expr (x);\n+\t      x = omit_two_operands_loc (loc, type, x, x, lhs1addr);\n+\t    }\n+\t}\n+    }\n+  else if (rhs1 && rhs1 != lhs)\n+    {\n+      tree rhs1addr = build_unary_op (loc, ADDR_EXPR, rhs1, 0);\n+      if (rhs1addr == error_mark_node)\n+\treturn error_mark_node;\n+      x = omit_one_operand_loc (loc, type, x, rhs1addr);\n+    }\n+\n   return x;\n }\n "}, {"sha": "7622f0b155e7d7d4ab44cceebfaaf5af7d521bfd", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1196,6 +1196,7 @@ static const struct omp_pragma_def omp_pragmas[] = {\n   { \"single\", PRAGMA_OMP_SINGLE },\n   { \"task\", PRAGMA_OMP_TASK },\n   { \"taskwait\", PRAGMA_OMP_TASKWAIT },\n+  { \"taskyield\", PRAGMA_OMP_TASKYIELD },\n   { \"threadprivate\", PRAGMA_OMP_THREADPRIVATE }\n };\n "}, {"sha": "04af94f3ddfec0512089ac11556808a48420c4d8", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -43,6 +43,7 @@ typedef enum pragma_kind {\n   PRAGMA_OMP_SINGLE,\n   PRAGMA_OMP_TASK,\n   PRAGMA_OMP_TASKWAIT,\n+  PRAGMA_OMP_TASKYIELD,\n   PRAGMA_OMP_THREADPRIVATE,\n \n   PRAGMA_GCC_PCH_PREPROCESS,\n@@ -70,7 +71,9 @@ typedef enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_REDUCTION,\n   PRAGMA_OMP_CLAUSE_SCHEDULE,\n   PRAGMA_OMP_CLAUSE_SHARED,\n-  PRAGMA_OMP_CLAUSE_UNTIED\n+  PRAGMA_OMP_CLAUSE_UNTIED,\n+  PRAGMA_OMP_CLAUSE_FINAL,\n+  PRAGMA_OMP_CLAUSE_MERGEABLE\n } pragma_omp_clause;\n \n extern struct cpp_reader* parse_in;"}, {"sha": "0d2a1b7dfca075640c70c711e11e07804e3abcf6", "filename": "gcc/c-parser.c", "status": "modified", "additions": 399, "deletions": 50, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1090,6 +1090,23 @@ typedef enum c_dtr_syn {\n   C_DTR_PARM\n } c_dtr_syn;\n \n+/* The binary operation precedence levels, where 0 is a dummy lowest level\n+   used for the bottom of the stack.  */\n+enum c_parser_prec {\n+  PREC_NONE,\n+  PREC_LOGOR,\n+  PREC_LOGAND,\n+  PREC_BITOR,\n+  PREC_BITXOR,\n+  PREC_BITAND,\n+  PREC_EQ,\n+  PREC_REL,\n+  PREC_SHIFT,\n+  PREC_ADD,\n+  PREC_MULT,\n+  NUM_PRECS\n+};\n+\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n@@ -1138,7 +1155,8 @@ static tree c_parser_asm_clobbers (c_parser *);\n static struct c_expr c_parser_expr_no_commas (c_parser *, struct c_expr *);\n static struct c_expr c_parser_conditional_expression (c_parser *,\n \t\t\t\t\t\t      struct c_expr *);\n-static struct c_expr c_parser_binary_expression (c_parser *, struct c_expr *);\n+static struct c_expr c_parser_binary_expression (c_parser *, struct c_expr *,\n+\t\t\t\t\t\t enum c_parser_prec);\n static struct c_expr c_parser_cast_expression (c_parser *, struct c_expr *);\n static struct c_expr c_parser_unary_expression (c_parser *);\n static struct c_expr c_parser_sizeof_expression (c_parser *);\n@@ -1159,6 +1177,7 @@ static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n static void c_parser_omp_flush (c_parser *);\n static void c_parser_omp_taskwait (c_parser *);\n+static void c_parser_omp_taskyield (c_parser *);\n \n enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n static bool c_parser_pragma (c_parser *, enum pragma_context);\n@@ -5308,7 +5327,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \n   gcc_assert (!after || c_dialect_objc ());\n \n-  cond = c_parser_binary_expression (parser, after);\n+  cond = c_parser_binary_expression (parser, after, PREC_NONE);\n \n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n@@ -5393,7 +5412,8 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n /* Parse a binary expression; that is, a logical-OR-expression (C90\n    6.3.5-6.3.14, C99 6.5.5-6.5.14).  If AFTER is not NULL then it is\n    an Objective-C message expression which is the primary-expression\n-   starting the expression as an initializer.\n+   starting the expression as an initializer.  PREC is the starting\n+   precedence, usually PREC_NONE.\n \n    multiplicative-expression:\n      cast-expression\n@@ -5445,7 +5465,8 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n */\n \n static struct c_expr\n-c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n+c_parser_binary_expression (c_parser *parser, struct c_expr *after,\n+\t\t\t    enum c_parser_prec prec)\n {\n   /* A binary expression is parsed using operator-precedence parsing,\n      with the operands being cast expressions.  All the binary\n@@ -5468,28 +5489,12 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n      expressions, we also need to adjust c_inhibit_evaluation_warnings\n      as appropriate when the operators are pushed and popped.  */\n \n-  /* The precedence levels, where 0 is a dummy lowest level used for\n-     the bottom of the stack.  */\n-  enum prec {\n-    PREC_NONE,\n-    PREC_LOGOR,\n-    PREC_LOGAND,\n-    PREC_BITOR,\n-    PREC_BITXOR,\n-    PREC_BITAND,\n-    PREC_EQ,\n-    PREC_REL,\n-    PREC_SHIFT,\n-    PREC_ADD,\n-    PREC_MULT,\n-    NUM_PRECS\n-  };\n   struct {\n     /* The expression at this stack level.  */\n     struct c_expr expr;\n     /* The precedence of the operator on its left, PREC_NONE at the\n        bottom of the stack.  */\n-    enum prec prec;\n+    enum c_parser_prec prec;\n     /* The operation on its left.  */\n     enum tree_code op;\n     /* The source location of this operation.  */\n@@ -5528,11 +5533,11 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n   gcc_assert (!after || c_dialect_objc ());\n   stack[0].loc = c_parser_peek_token (parser)->location;\n   stack[0].expr = c_parser_cast_expression (parser, after);\n-  stack[0].prec = PREC_NONE;\n+  stack[0].prec = prec;\n   sp = 0;\n   while (true)\n     {\n-      enum prec oprec;\n+      enum c_parser_prec oprec;\n       enum tree_code ocode;\n       if (parser->error)\n \tgoto out;\n@@ -5616,9 +5621,13 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \t  goto out;\n \t}\n       binary_loc = c_parser_peek_token (parser)->location;\n-      c_parser_consume_token (parser);\n       while (oprec <= stack[sp].prec)\n-\tPOP;\n+\t{\n+\t  if (sp == 0)\n+\t    goto out;\n+\t  POP;\n+\t}\n+      c_parser_consume_token (parser);\n       switch (ocode)\n \t{\n \tcase TRUTH_ANDIF_EXPR:\n@@ -8243,6 +8252,17 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       c_parser_omp_taskwait (parser);\n       return false;\n \n+    case PRAGMA_OMP_TASKYIELD:\n+      if (context != pragma_compound)\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    c_parser_error (parser, \"%<#pragma omp taskyield%> may only be \"\n+\t\t\t    \"used in compound statements\");\n+\t  goto bad_stmt;\n+\t}\n+      c_parser_omp_taskyield (parser);\n+      return false;\n+\n     case PRAGMA_OMP_THREADPRIVATE:\n       c_parser_omp_threadprivate (parser);\n       return false;\n@@ -8358,13 +8378,19 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n \t  break;\n \tcase 'f':\n-\t  if (!strcmp (\"firstprivate\", p))\n+\t  if (!strcmp (\"final\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_FINAL;\n+\t  else if (!strcmp (\"firstprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE;\n \t  break;\n \tcase 'l':\n \t  if (!strcmp (\"lastprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;\n \t  break;\n+\tcase 'm':\n+\t  if (!strcmp (\"mergeable\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_MERGEABLE;\n+\t  break;\n \tcase 'n':\n \t  if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n@@ -8606,6 +8632,31 @@ c_parser_omp_clause_firstprivate (c_parser *parser, tree list)\n   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_FIRSTPRIVATE, list);\n }\n \n+/* OpenMP 3.1:\n+   final ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_final (c_parser *parser, tree list)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    {\n+      tree t = c_parser_paren_condition (parser);\n+      tree c;\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_FINAL, \"final\");\n+\n+      c = build_omp_clause (loc, OMP_CLAUSE_FINAL);\n+      OMP_CLAUSE_FINAL_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+  else\n+    c_parser_error (parser, \"expected %<(%>\");\n+\n+  return list;\n+}\n+\n /* OpenMP 2.5:\n    if ( expression ) */\n \n@@ -8640,6 +8691,24 @@ c_parser_omp_clause_lastprivate (c_parser *parser, tree list)\n   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_LASTPRIVATE, list);\n }\n \n+/* OpenMP 3.1:\n+   mergeable */\n+\n+static tree\n+c_parser_omp_clause_mergeable (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  /* FIXME: Should we allow duplicates?  */\n+  check_no_duplicate_clause (list, OMP_CLAUSE_MERGEABLE, \"mergeable\");\n+\n+  c = build_omp_clause (c_parser_peek_token (parser)->location,\n+\t\t\tOMP_CLAUSE_MERGEABLE);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n /* OpenMP 2.5:\n    nowait */\n \n@@ -8730,7 +8799,12 @@ c_parser_omp_clause_private (c_parser *parser, tree list)\n    reduction ( reduction-operator : variable-list )\n \n    reduction-operator:\n-     One of: + * - & ^ | && || */\n+     One of: + * - & ^ | && ||\n+     \n+   OpenMP 3.1:\n+   \n+   reduction-operator:\n+     One of: + * - & ^ | && || max min  */\n \n static tree\n c_parser_omp_clause_reduction (c_parser *parser, tree list)\n@@ -8766,10 +8840,26 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \tcase CPP_OR_OR:\n \t  code = TRUTH_ORIF_EXPR;\n \t  break;\n+        case CPP_NAME:\n+\t  {\n+\t    const char *p\n+\t      = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\t    if (strcmp (p, \"min\") == 0)\n+\t      {\n+\t\tcode = MIN_EXPR;\n+\t\tbreak;\n+\t      }\n+\t    if (strcmp (p, \"max\") == 0)\n+\t      {\n+\t\tcode = MAX_EXPR;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  /* FALLTHRU */\n \tdefault:\n \t  c_parser_error (parser,\n \t\t\t  \"expected %<+%>, %<*%>, %<-%>, %<&%>, \"\n-\t\t\t  \"%<^%>, %<|%>, %<&&%>, or %<||%>\");\n+\t\t\t  \"%<^%>, %<|%>, %<&&%>, %<||%>, %<min%> or %<max%>\");\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);\n \t  return list;\n \t}\n@@ -8957,6 +9047,10 @@ c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n \t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n \t  c_name = \"firstprivate\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_FINAL:\n+\t  clauses = c_parser_omp_clause_final (parser, clauses);\n+\t  c_name = \"final\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_IF:\n \t  clauses = c_parser_omp_clause_if (parser, clauses);\n \t  c_name = \"if\";\n@@ -8965,6 +9059,10 @@ c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n \t  clauses = c_parser_omp_clause_lastprivate (parser, clauses);\n \t  c_name = \"lastprivate\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_MERGEABLE:\n+\t  clauses = c_parser_omp_clause_mergeable (parser, clauses);\n+\t  c_name = \"mergeable\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOWAIT:\n \t  clauses = c_parser_omp_clause_nowait (parser, clauses);\n \t  c_name = \"nowait\";\n@@ -9044,38 +9142,158 @@ c_parser_omp_structured_block (c_parser *parser)\n \n   where x is an lvalue expression with scalar type.\n \n+   OpenMP 3.1:\n+   # pragma omp atomic new-line\n+     update-stmt\n+\n+   # pragma omp atomic read new-line\n+     read-stmt\n+\n+   # pragma omp atomic write new-line\n+     write-stmt\n+\n+   # pragma omp atomic update new-line\n+     update-stmt\n+\n+   # pragma omp atomic capture new-line\n+     capture-stmt\n+\n+   # pragma omp atomic capture new-line\n+     capture-block\n+\n+   read-stmt:\n+     v = x\n+   write-stmt:\n+     x = expr\n+   update-stmt:\n+     expression-stmt | x = x binop expr\n+   capture-stmt:\n+     v = x binop= expr | v = x++ | v = ++x | v = x-- | v = --x\n+   capture-block:\n+     { v = x; update-stmt; } | { update-stmt; v = x; }\n+\n+  where x and v are lvalue expressions with scalar type.\n+\n   LOC is the location of the #pragma token.  */\n \n static void\n c_parser_omp_atomic (location_t loc, c_parser *parser)\n {\n-  tree lhs, rhs;\n-  tree stmt;\n-  enum tree_code code;\n+  tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE;\n+  tree lhs1 = NULL_TREE, rhs1 = NULL_TREE;\n+  tree stmt, orig_lhs;\n+  enum tree_code code = OMP_ATOMIC, opcode = NOP_EXPR;\n   struct c_expr rhs_expr;\n+  bool structured_block = false;\n \n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      if (!strcmp (p, \"read\"))\n+\tcode = OMP_ATOMIC_READ;\n+      else if (!strcmp (p, \"write\"))\n+\tcode = NOP_EXPR;\n+      else if (!strcmp (p, \"update\"))\n+\tcode = OMP_ATOMIC;\n+      else if (!strcmp (p, \"capture\"))\n+\tcode = OMP_ATOMIC_CAPTURE_NEW;\n+      else\n+\tp = NULL;\n+      if (p)\n+\tc_parser_consume_token (parser);\n+    }\n   c_parser_skip_to_pragma_eol (parser);\n \n+  switch (code)\n+    {\n+    case OMP_ATOMIC_READ:\n+    case NOP_EXPR: /* atomic write */\n+      v = c_parser_unary_expression (parser).value;\n+      v = c_fully_fold (v, false, NULL);\n+      if (v == error_mark_node)\n+\tgoto saw_error;\n+      loc = c_parser_peek_token (parser)->location;\n+      if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+\tgoto saw_error;\n+      if (code == NOP_EXPR)\n+\tlhs = c_parser_expression (parser).value;\n+      else\n+\tlhs = c_parser_unary_expression (parser).value;\n+      lhs = c_fully_fold (lhs, false, NULL);\n+      if (lhs == error_mark_node)\n+\tgoto saw_error;\n+      if (code == NOP_EXPR)\n+\t{\n+\t  /* atomic write is represented by OMP_ATOMIC with NOP_EXPR\n+\t     opcode.  */\n+\t  code = OMP_ATOMIC;\n+\t  rhs = lhs;\n+\t  lhs = v;\n+\t  v = NULL_TREE;\n+\t}\n+      goto done;\n+    case OMP_ATOMIC_CAPTURE_NEW:\n+      if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  structured_block = true;\n+\t}\n+      else\n+\t{\n+\t  v = c_parser_unary_expression (parser).value;\n+\t  v = c_fully_fold (v, false, NULL);\n+\t  if (v == error_mark_node)\n+\t    goto saw_error;\n+\t  if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+\t    goto saw_error;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  /* For structured_block case we don't know yet whether\n+     old or new x should be captured.  */\n+restart:\n   lhs = c_parser_unary_expression (parser).value;\n   lhs = c_fully_fold (lhs, false, NULL);\n+  orig_lhs = lhs;\n   switch (TREE_CODE (lhs))\n     {\n     case ERROR_MARK:\n     saw_error:\n       c_parser_skip_to_end_of_block_or_statement (parser);\n+      if (structured_block)\n+\t{\n+\t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n+\t    c_parser_consume_token (parser);\n+\t  else if (code == OMP_ATOMIC_CAPTURE_NEW)\n+\t    {\n+\t      c_parser_skip_to_end_of_block_or_statement (parser);\n+\t      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n+\t\tc_parser_consume_token (parser);\n+\t    }\n+\t}\n       return;\n \n-    case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n+      if (code == OMP_ATOMIC_CAPTURE_NEW && !structured_block)\n+\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+      /* FALLTHROUGH */\n+    case PREINCREMENT_EXPR:\n       lhs = TREE_OPERAND (lhs, 0);\n-      code = PLUS_EXPR;\n+      opcode = PLUS_EXPR;\n       rhs = integer_one_node;\n       break;\n \n-    case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n+      if (code == OMP_ATOMIC_CAPTURE_NEW && !structured_block)\n+\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+      /* FALLTHROUGH */\n+    case PREDECREMENT_EXPR:\n       lhs = TREE_OPERAND (lhs, 0);\n-      code = MINUS_EXPR;\n+      opcode = MINUS_EXPR;\n       rhs = integer_one_node;\n       break;\n \n@@ -9100,7 +9318,11 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n \t      /* This is pre or post increment.  */\n \t      rhs = TREE_OPERAND (lhs, 1);\n \t      lhs = TREE_OPERAND (lhs, 0);\n-\t      code = NOP_EXPR;\n+\t      opcode = NOP_EXPR;\n+\t      if (code == OMP_ATOMIC_CAPTURE_NEW\n+\t\t  && !structured_block\n+\t\t  && TREE_CODE (orig_lhs) == COMPOUND_EXPR)\n+\t\tcode = OMP_ATOMIC_CAPTURE_OLD;\n \t      break;\n \t    }\n \t  if (TREE_CODE (TREE_OPERAND (lhs, 1)) == TRUTH_NOT_EXPR\n@@ -9110,7 +9332,11 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n \t      /* This is pre or post decrement.  */\n \t      rhs = TREE_OPERAND (lhs, 1);\n \t      lhs = TREE_OPERAND (lhs, 0);\n-\t      code = NOP_EXPR;\n+\t      opcode = NOP_EXPR;\n+\t      if (code == OMP_ATOMIC_CAPTURE_NEW\n+\t\t  && !structured_block\n+\t\t  && TREE_CODE (orig_lhs) == COMPOUND_EXPR)\n+\t\tcode = OMP_ATOMIC_CAPTURE_OLD;\n \t      break;\n \t    }\n \t}\n@@ -9119,32 +9345,114 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_MULT_EQ:\n-\t  code = MULT_EXPR;\n+\t  opcode = MULT_EXPR;\n \t  break;\n \tcase CPP_DIV_EQ:\n-\t  code = TRUNC_DIV_EXPR;\n+\t  opcode = TRUNC_DIV_EXPR;\n \t  break;\n \tcase CPP_PLUS_EQ:\n-\t  code = PLUS_EXPR;\n+\t  opcode = PLUS_EXPR;\n \t  break;\n \tcase CPP_MINUS_EQ:\n-\t  code = MINUS_EXPR;\n+\t  opcode = MINUS_EXPR;\n \t  break;\n \tcase CPP_LSHIFT_EQ:\n-\t  code = LSHIFT_EXPR;\n+\t  opcode = LSHIFT_EXPR;\n \t  break;\n \tcase CPP_RSHIFT_EQ:\n-\t  code = RSHIFT_EXPR;\n+\t  opcode = RSHIFT_EXPR;\n \t  break;\n \tcase CPP_AND_EQ:\n-\t  code = BIT_AND_EXPR;\n+\t  opcode = BIT_AND_EXPR;\n \t  break;\n \tcase CPP_OR_EQ:\n-\t  code = BIT_IOR_EXPR;\n+\t  opcode = BIT_IOR_EXPR;\n \t  break;\n \tcase CPP_XOR_EQ:\n-\t  code = BIT_XOR_EXPR;\n+\t  opcode = BIT_XOR_EXPR;\n \t  break;\n+\tcase CPP_EQ:\n+\t  if (structured_block || code == OMP_ATOMIC)\n+\t    {\n+\t      location_t aloc = c_parser_peek_token (parser)->location;\n+\t      location_t rhs_loc;\n+\t      enum c_parser_prec oprec = PREC_NONE;\n+\n+\t      c_parser_consume_token (parser);\n+\t      rhs1 = c_parser_unary_expression (parser).value;\n+\t      rhs1 = c_fully_fold (rhs1, false, NULL);\n+\t      if (rhs1 == error_mark_node)\n+\t\tgoto saw_error;\n+\t      switch (c_parser_peek_token (parser)->type)\n+\t\t{\n+\t\tcase CPP_SEMICOLON:\n+\t\t  if (code == OMP_ATOMIC_CAPTURE_NEW)\n+\t\t    {\n+\t\t      code = OMP_ATOMIC_CAPTURE_OLD;\n+\t\t      v = lhs;\n+\t\t      lhs = NULL_TREE;\n+\t\t      lhs1 = rhs1;\n+\t\t      rhs1 = NULL_TREE;\n+\t\t      c_parser_consume_token (parser);\n+\t\t      goto restart;\n+\t\t    }\n+\t\t  c_parser_error (parser,\n+\t\t\t\t  \"invalid form of %<#pragma omp atomic%>\");\n+\t\t  goto saw_error;\n+\t\tcase CPP_MULT:\n+\t\t  opcode = MULT_EXPR;\n+\t\t  oprec = PREC_MULT;\n+\t\t  break;\n+\t\tcase CPP_DIV:\n+\t\t  opcode = TRUNC_DIV_EXPR;\n+\t\t  oprec = PREC_MULT;\n+\t\t  break;\n+\t\tcase CPP_PLUS:\n+\t\t  opcode = PLUS_EXPR;\n+\t\t  oprec = PREC_ADD;\n+\t\t  break;\n+\t\tcase CPP_MINUS:\n+\t\t  opcode = MINUS_EXPR;\n+\t\t  oprec = PREC_ADD;\n+\t\t  break;\n+\t\tcase CPP_LSHIFT:\n+\t\t  opcode = LSHIFT_EXPR;\n+\t\t  oprec = PREC_SHIFT;\n+\t\t  break;\n+\t\tcase CPP_RSHIFT:\n+\t\t  opcode = RSHIFT_EXPR;\n+\t\t  oprec = PREC_SHIFT;\n+\t\t  break;\n+\t\tcase CPP_AND:\n+\t\t  opcode = BIT_AND_EXPR;\n+\t\t  oprec = PREC_BITAND;\n+\t\t  break;\n+\t\tcase CPP_OR:\n+\t\t  opcode = BIT_IOR_EXPR;\n+\t\t  oprec = PREC_BITOR;\n+\t\t  break;\n+\t\tcase CPP_XOR:\n+\t\t  opcode = BIT_XOR_EXPR;\n+\t\t  oprec = PREC_BITXOR;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  c_parser_error (parser,\n+\t\t\t\t  \"invalid operator for %<#pragma omp atomic%>\");\n+\t\t  goto saw_error;\n+\t\t}\n+\t      loc = aloc;\n+\t      c_parser_consume_token (parser);\n+\t      rhs_loc = c_parser_peek_token (parser)->location;\n+\t      if (commutative_tree_code (opcode))\n+\t\toprec = (enum c_parser_prec) (oprec - 1);\n+\t      rhs_expr = c_parser_binary_expression (parser, NULL, oprec);\n+\t      rhs_expr = default_function_array_read_conversion (rhs_loc,\n+\t\t\t\t\t\t\t\t rhs_expr);\n+\t      rhs = rhs_expr.value;\n+\t      rhs = c_fully_fold (rhs, false, NULL);\n+\t      goto stmt_done; \n+\t    }\n+\t  /* FALLTHROUGH */\n \tdefault:\n \t  c_parser_error (parser,\n \t\t\t  \"invalid operator for %<#pragma omp atomic%>\");\n@@ -9164,10 +9472,34 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n       rhs = c_fully_fold (rhs, false, NULL);\n       break;\n     }\n-  stmt = c_finish_omp_atomic (loc, code, lhs, rhs);\n+stmt_done:\n+  if (structured_block && code == OMP_ATOMIC_CAPTURE_NEW)\n+    {\n+      if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\tgoto saw_error;\n+      v = c_parser_unary_expression (parser).value;\n+      v = c_fully_fold (v, false, NULL);\n+      if (v == error_mark_node)\n+\tgoto saw_error;\n+      if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+\tgoto saw_error;\n+      lhs1 = c_parser_unary_expression (parser).value;\n+      lhs1 = c_fully_fold (lhs1, false, NULL);\n+      if (lhs1 == error_mark_node)\n+\tgoto saw_error;\n+    }\n+  if (structured_block)\n+    {\n+      c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+      c_parser_require (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n+    }\n+done:\n+  stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs, v, lhs1, rhs1);\n   if (stmt != error_mark_node)\n     add_stmt (stmt);\n-  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\n+  if (!structured_block)\n+    c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n \n \n@@ -9330,7 +9662,8 @@ c_parser_omp_for_loop (location_t loc,\n       if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n \t{\n \t  location_t cond_loc = c_parser_peek_token (parser)->location;\n-\t  struct c_expr cond_expr = c_parser_binary_expression (parser, NULL);\n+\t  struct c_expr cond_expr = c_parser_binary_expression (parser, NULL,\n+\t\t\t\t\t\t\t\tPREC_NONE);\n \n \t  cond = cond_expr.value;\n \t  cond = c_objc_common_truthvalue_conversion (cond_loc, cond);\n@@ -9827,7 +10160,9 @@ c_parser_omp_single (location_t loc, c_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_DEFAULT)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n-\t| (1u << PRAGMA_OMP_CLAUSE_SHARED))\n+\t| (1u << PRAGMA_OMP_CLAUSE_SHARED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FINAL)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_MERGEABLE))\n \n static tree\n c_parser_omp_task (location_t loc, c_parser *parser)\n@@ -9856,6 +10191,20 @@ c_parser_omp_taskwait (c_parser *parser)\n   c_finish_omp_taskwait (loc);\n }\n \n+/* OpenMP 3.1:\n+   # pragma omp taskyield new-line\n+*/\n+\n+static void\n+c_parser_omp_taskyield (c_parser *parser)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  c_parser_consume_pragma (parser);\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  c_finish_omp_taskyield (loc);\n+}\n+\n /* Main entry point to parsing most OpenMP pragmas.  */\n \n static void"}, {"sha": "f7f782440946f2199a9e9b10346c22db8dc47a23", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -10451,6 +10451,8 @@ c_finish_omp_clauses (tree clauses)\n \t\tcase PLUS_EXPR:\n \t\tcase MULT_EXPR:\n \t\tcase MINUS_EXPR:\n+\t\tcase MIN_EXPR:\n+\t\tcase MAX_EXPR:\n \t\t  break;\n \t\tcase BIT_AND_EXPR:\n \t\t  r_name = \"&\";\n@@ -10567,6 +10569,8 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_FINAL:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n@@ -10596,6 +10600,10 @@ c_finish_omp_clauses (tree clauses)\n \t\tcase OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n \t\t  break;\n \t\tcase OMP_CLAUSE_DEFAULT_SHARED:\n+\t\t  /* const vars may be specified in firstprivate clause.  */\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t      && TREE_READONLY (t))\n+\t\t    break;\n \t\t  share_name = \"shared\";\n \t\t  break;\n \t\tcase OMP_CLAUSE_DEFAULT_PRIVATE:"}, {"sha": "bc972a2ac81aa7aef48cf0c3b35f65e58374e381", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,3 +1,33 @@\n+2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (finish_omp_atomic): Adjust prototype.\n+\t(cxx_omp_const_qual_no_mutable): New prototype.\n+\t(finish_omp_taskyield): New prototype.\n+\t* parser.c (cp_parser_omp_atomic): (cp_parser_omp_atomic): Handle\n+\tparsing OpenMP 3.1 atomics.  Adjust finish_omp_atomic caller.\n+\t(cp_parser_omp_clause_name): Handle final and mergeable clauses.\n+\t(cp_parser_omp_clause_final, cp_parser_omp_clause_mergeable): New\n+\tfunctions.\n+\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_FINAL\n+\tand PRAGMA_OMP_CLAUSE_MERGEABLE.\n+\t(OMP_TASK_CLAUSE_MASK): Allow final and mergeable clauses.\n+\t(cp_parser_omp_taskyield): New function.\n+\t(cp_parser_pragma): Handle PRAGMA_OMP_TASKYIELD.\n+\t(cp_parser_omp_clause_reduction): Handle min and max.\n+\t* pt.c (tsubst_expr) <case OMP_ATOMIC>: Handle OpenMP 3.1 atomics.\n+\t(tsubst_omp_clauses): Handle OMP_CLAUSE_FINAL and\n+\tOMP_CLAUSE_MERGEABLE.\n+\t* semantics.c (finish_omp_atomic): Add OPCODE, V, LHS1 and RHS1\n+\targuments.  Handle OpenMP 3.1 atomics.  Adjust c_finish_omp_atomic\n+\tcaller.\n+\t(finish_omp_clauses): Don't complain about const qualified\n+\tpredetermined vars and static data members in firstprivate clause.\n+\tHandle OMP_CLAUSE_FINAL and OMP_CLAUSE_MERGEABLE. Handle MIN_EXPR\n+\tand MAX_EXPR.\n+\t(finish_omp_taskyield): New function.\n+\t* cp-gimplify.c (cxx_omp_const_qual_no_mutable): New function.\n+\t(cxx_omp_predetermined_sharing): Use it.\n+\n 2011-08-02  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (build_call_a): Also check at_function_scope_p."}, {"sha": "6aeae75b06336d60c56c194691c28494deafbdf0", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1365,26 +1365,15 @@ cxx_omp_privatize_by_reference (const_tree decl)\n   return is_invisiref_parm (decl);\n }\n \n-/* True if OpenMP sharing attribute of DECL is predetermined.  */\n-\n-enum omp_clause_default_kind\n-cxx_omp_predetermined_sharing (tree decl)\n+/* Return true if DECL is const qualified var having no mutable member.  */\n+bool\n+cxx_omp_const_qual_no_mutable (tree decl)\n {\n-  tree type;\n-\n-  /* Static data members are predetermined as shared.  */\n-  if (TREE_STATIC (decl))\n-    {\n-      tree ctx = CP_DECL_CONTEXT (decl);\n-      if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))\n-\treturn OMP_CLAUSE_DEFAULT_SHARED;\n-    }\n-\n-  type = TREE_TYPE (decl);\n+  tree type = TREE_TYPE (decl);\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (!is_invisiref_parm (decl))\n-\treturn OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+\treturn false;\n       type = TREE_TYPE (type);\n \n       if (TREE_CODE (decl) == RESULT_DECL && DECL_NAME (decl))\n@@ -1408,11 +1397,32 @@ cxx_omp_predetermined_sharing (tree decl)\n     }\n \n   if (type == error_mark_node)\n-    return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+    return false;\n \n   /* Variables with const-qualified type having no mutable member\n      are predetermined shared.  */\n   if (TYPE_READONLY (type) && !cp_has_mutable_p (type))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* True if OpenMP sharing attribute of DECL is predetermined.  */\n+\n+enum omp_clause_default_kind\n+cxx_omp_predetermined_sharing (tree decl)\n+{\n+  /* Static data members are predetermined shared.  */\n+  if (TREE_STATIC (decl))\n+    {\n+      tree ctx = CP_DECL_CONTEXT (decl);\n+      if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))\n+\treturn OMP_CLAUSE_DEFAULT_SHARED;\n+    }\n+\n+  /* Const qualified vars having no mutable member are predetermined\n+     shared.  */\n+  if (cxx_omp_const_qual_no_mutable (decl))\n     return OMP_CLAUSE_DEFAULT_SHARED;\n \n   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;"}, {"sha": "ff5509e5b3f58d78c35ade379215e1d34bb5ce0e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -5454,10 +5454,12 @@ extern tree begin_omp_task\t\t\t(void);\n extern tree finish_omp_task\t\t\t(tree, tree);\n extern tree finish_omp_for\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tree, tree, tree, tree, tree);\n-extern void finish_omp_atomic\t\t\t(enum tree_code, tree, tree);\n+extern void finish_omp_atomic\t\t\t(enum tree_code, enum tree_code,\n+\t\t\t\t\t\t tree, tree, tree, tree, tree);\n extern void finish_omp_barrier\t\t\t(void);\n extern void finish_omp_flush\t\t\t(void);\n extern void finish_omp_taskwait\t\t\t(void);\n+extern void finish_omp_taskyield\t\t(void);\n extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool, bool);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n@@ -5765,6 +5767,7 @@ extern void init_shadowed_var_for_decl\t\t(void);\n extern int cp_gimplify_expr\t\t\t(tree *, gimple_seq *,\n \t\t\t\t\t\t gimple_seq *);\n extern void cp_genericize\t\t\t(tree);\n+extern bool cxx_omp_const_qual_no_mutable\t(tree);\n extern enum omp_clause_default_kind cxx_omp_predetermined_sharing (tree);\n extern tree cxx_omp_clause_default_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_copy_ctor\t\t(tree, tree, tree);"}, {"sha": "576c842e89fca486e8f50cc3db987a3b01803a96", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 358, "deletions": 33, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -23600,13 +23600,19 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n \t  break;\n \tcase 'f':\n-\t  if (!strcmp (\"firstprivate\", p))\n+\t  if (!strcmp (\"final\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_FINAL;\n+\t  else if (!strcmp (\"firstprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE;\n \t  break;\n \tcase 'l':\n \t  if (!strcmp (\"lastprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;\n \t  break;\n+\tcase 'm':\n+\t  if (!strcmp (\"mergeable\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_MERGEABLE;\n+\t  break;\n \tcase 'n':\n \t  if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n@@ -23836,6 +23842,34 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list, location_t location)\n   return c;\n }\n \n+/* OpenMP 3.1:\n+   final ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_final (cp_parser *parser, tree list, location_t location)\n+{\n+  tree t, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_condition (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_FINAL, \"final\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_FINAL);\n+  OMP_CLAUSE_FINAL_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n /* OpenMP 2.5:\n    if ( expression ) */\n \n@@ -23864,6 +23898,23 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location)\n   return c;\n }\n \n+/* OpenMP 3.1:\n+   mergeable */\n+\n+static tree\n+cp_parser_omp_clause_mergeable (cp_parser *parser ATTRIBUTE_UNUSED,\n+\t\t\t\ttree list, location_t location)\n+{\n+  tree c;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_MERGEABLE, \"mergeable\",\n+\t\t\t     location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_MERGEABLE);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n /* OpenMP 2.5:\n    nowait */\n \n@@ -23931,7 +23982,12 @@ cp_parser_omp_clause_ordered (cp_parser *parser ATTRIBUTE_UNUSED,\n    reduction ( reduction-operator : variable-list )\n \n    reduction-operator:\n-     One of: + * - & ^ | && || */\n+     One of: + * - & ^ | && ||\n+\n+   OpenMP 3.1:\n+\n+   reduction-operator:\n+     One of: + * - & ^ | && || min max  */\n \n static tree\n cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n@@ -23968,9 +24024,26 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n     case CPP_OR_OR:\n       code = TRUTH_ORIF_EXPR;\n       break;\n+    case CPP_NAME:\n+      {\n+\ttree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\tconst char *p = IDENTIFIER_POINTER (id);\n+\n+\tif (strcmp (p, \"min\") == 0)\n+\t  {\n+\t    code = MIN_EXPR;\n+\t    break;\n+\t  }\n+\tif (strcmp (p, \"max\") == 0)\n+\t  {\n+\t    code = MAX_EXPR;\n+\t    break;\n+\t  }\n+      }\n+      /* FALLTHROUGH */\n     default:\n       cp_parser_error (parser, \"expected %<+%>, %<*%>, %<-%>, %<&%>, %<^%>, \"\n-\t\t\t       \"%<|%>, %<&&%>, or %<||%>\");\n+\t\t\t       \"%<|%>, %<&&%>, %<||%>, %<min%> or %<max%>\");\n     resync_fail:\n       cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t     /*or_comma=*/false,\n@@ -24143,6 +24216,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t\t\t\t\t\t  token->location);\n \t  c_name = \"default\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_FINAL:\n+\t  clauses = cp_parser_omp_clause_final (parser, clauses, token->location);\n+\t  c_name = \"final\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:\n \t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,\n \t\t\t\t\t    clauses);\n@@ -24157,6 +24234,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t\t\t\t\t    clauses);\n \t  c_name = \"lastprivate\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_MERGEABLE:\n+\t  clauses = cp_parser_omp_clause_mergeable (parser, clauses,\n+\t\t\t\t\t\t    token->location);\n+\t  c_name = \"mergeable\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOWAIT:\n \t  clauses = cp_parser_omp_clause_nowait (parser, clauses, token->location);\n \t  c_name = \"nowait\";\n@@ -24267,34 +24349,140 @@ cp_parser_omp_structured_block (cp_parser *parser)\n    binop:\n      +, *, -, /, &, ^, |, <<, >>\n \n-  where x is an lvalue expression with scalar type.  */\n+  where x is an lvalue expression with scalar type.\n+\n+   OpenMP 3.1:\n+   # pragma omp atomic new-line\n+     update-stmt\n+\n+   # pragma omp atomic read new-line\n+     read-stmt\n+\n+   # pragma omp atomic write new-line\n+     write-stmt\n+\n+   # pragma omp atomic update new-line\n+     update-stmt\n+\n+   # pragma omp atomic capture new-line\n+     capture-stmt\n+\n+   # pragma omp atomic capture new-line\n+     capture-block\n+\n+   read-stmt:\n+     v = x\n+   write-stmt:\n+     x = expr\n+   update-stmt:\n+     expression-stmt | x = x binop expr\n+   capture-stmt:\n+     v = x binop= expr | v = x++ | v = ++x | v = x-- | v = --x\n+   capture-block:\n+     { v = x; update-stmt; } | { update-stmt; v = x; }\n+\n+  where x and v are lvalue expressions with scalar type.  */\n \n static void\n cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n {\n-  tree lhs, rhs;\n-  enum tree_code code;\n+  tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE, lhs1 = NULL_TREE;\n+  tree rhs1 = NULL_TREE, orig_lhs;\n+  enum tree_code code = OMP_ATOMIC, opcode = NOP_EXPR;\n+  bool structured_block = false;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n \n+      if (!strcmp (p, \"read\"))\n+\tcode = OMP_ATOMIC_READ;\n+      else if (!strcmp (p, \"write\"))\n+\tcode = NOP_EXPR;\n+      else if (!strcmp (p, \"update\"))\n+\tcode = OMP_ATOMIC;\n+      else if (!strcmp (p, \"capture\"))\n+\tcode = OMP_ATOMIC_CAPTURE_NEW;\n+      else\n+\tp = NULL;\n+      if (p)\n+\tcp_lexer_consume_token (parser->lexer);\n+    }\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n+  switch (code)\n+    {\n+    case OMP_ATOMIC_READ:\n+    case NOP_EXPR: /* atomic write */\n+      v = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t      /*cast_p=*/false, NULL);\n+      if (v == error_mark_node)\n+\tgoto saw_error;\n+      if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+\tgoto saw_error;\n+      if (code == NOP_EXPR)\n+\tlhs = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      else\n+\tlhs = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t\t  /*cast_p=*/false, NULL);\n+      if (lhs == error_mark_node)\n+\tgoto saw_error;\n+      if (code == NOP_EXPR)\n+\t{\n+\t  /* atomic write is represented by OMP_ATOMIC with NOP_EXPR\n+\t     opcode.  */\n+\t  code = OMP_ATOMIC;\n+\t  rhs = lhs;\n+\t  lhs = v;\n+\t  v = NULL_TREE;\n+\t}\n+      goto done;\n+    case OMP_ATOMIC_CAPTURE_NEW:\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  structured_block = true;\n+\t}\n+      else\n+\t{\n+\t  v = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t\t  /*cast_p=*/false, NULL);\n+\t  if (v == error_mark_node)\n+\t    goto saw_error;\n+\t  if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+\t    goto saw_error;\n+\t}\n+    default:\n+      break;\n+    }\n+\n+restart:\n   lhs = cp_parser_unary_expression (parser, /*address_p=*/false,\n \t\t\t\t    /*cast_p=*/false, NULL);\n+  orig_lhs = lhs;\n   switch (TREE_CODE (lhs))\n     {\n     case ERROR_MARK:\n       goto saw_error;\n \n-    case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n+      if (code == OMP_ATOMIC_CAPTURE_NEW && !structured_block)\n+\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+      /* FALLTHROUGH */\n+    case PREINCREMENT_EXPR:\n       lhs = TREE_OPERAND (lhs, 0);\n-      code = PLUS_EXPR;\n+      opcode = PLUS_EXPR;\n       rhs = integer_one_node;\n       break;\n \n-    case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n+      if (code == OMP_ATOMIC_CAPTURE_NEW && !structured_block)\n+\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+      /* FALLTHROUGH */\n+    case PREDECREMENT_EXPR:\n       lhs = TREE_OPERAND (lhs, 0);\n-      code = MINUS_EXPR;\n+      opcode = MINUS_EXPR;\n       rhs = integer_one_node;\n       break;\n \n@@ -24312,48 +24500,123 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n     case MODIFY_EXPR:\n       if (TREE_CODE (lhs) == MODIFY_EXPR\n \t && TREE_CODE (TREE_TYPE (TREE_OPERAND (lhs, 0))) == BOOLEAN_TYPE)\n-       {\n-\t /* Undo effects of boolean_increment.  */\n-\t if (integer_onep (TREE_OPERAND (lhs, 1)))\n-\t   {\n-\t     /* This is pre or post increment.  */\n-\t     rhs = TREE_OPERAND (lhs, 1);\n-\t     lhs = TREE_OPERAND (lhs, 0);\n-\t     code = NOP_EXPR;\n-\t     break;\n-\t   }\n-       }\n+\t{\n+\t  /* Undo effects of boolean_increment.  */\n+\t  if (integer_onep (TREE_OPERAND (lhs, 1)))\n+\t    {\n+\t      /* This is pre or post increment.  */\n+\t      rhs = TREE_OPERAND (lhs, 1);\n+\t      lhs = TREE_OPERAND (lhs, 0);\n+\t      opcode = NOP_EXPR;\n+\t      if (code == OMP_ATOMIC_CAPTURE_NEW\n+\t\t  && !structured_block\n+\t\t  && TREE_CODE (orig_lhs) == COMPOUND_EXPR)\n+\t\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+\t      break;\n+\t    }\n+\t}\n       /* FALLTHRU */\n     default:\n       switch (cp_lexer_peek_token (parser->lexer)->type)\n \t{\n \tcase CPP_MULT_EQ:\n-\t  code = MULT_EXPR;\n+\t  opcode = MULT_EXPR;\n \t  break;\n \tcase CPP_DIV_EQ:\n-\t  code = TRUNC_DIV_EXPR;\n+\t  opcode = TRUNC_DIV_EXPR;\n \t  break;\n \tcase CPP_PLUS_EQ:\n-\t  code = PLUS_EXPR;\n+\t  opcode = PLUS_EXPR;\n \t  break;\n \tcase CPP_MINUS_EQ:\n-\t  code = MINUS_EXPR;\n+\t  opcode = MINUS_EXPR;\n \t  break;\n \tcase CPP_LSHIFT_EQ:\n-\t  code = LSHIFT_EXPR;\n+\t  opcode = LSHIFT_EXPR;\n \t  break;\n \tcase CPP_RSHIFT_EQ:\n-\t  code = RSHIFT_EXPR;\n+\t  opcode = RSHIFT_EXPR;\n \t  break;\n \tcase CPP_AND_EQ:\n-\t  code = BIT_AND_EXPR;\n+\t  opcode = BIT_AND_EXPR;\n \t  break;\n \tcase CPP_OR_EQ:\n-\t  code = BIT_IOR_EXPR;\n+\t  opcode = BIT_IOR_EXPR;\n \t  break;\n \tcase CPP_XOR_EQ:\n-\t  code = BIT_XOR_EXPR;\n+\t  opcode = BIT_XOR_EXPR;\n \t  break;\n+\tcase CPP_EQ:\n+\t  if (structured_block || code == OMP_ATOMIC)\n+\t    {\n+\t      enum cp_parser_prec oprec;\n+\t      cp_token *token;\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      rhs1 = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t\t\t /*cast_p=*/false, NULL);\n+\t      if (rhs1 == error_mark_node)\n+\t\tgoto saw_error;\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t      switch (token->type)\n+\t\t{\n+\t\tcase CPP_SEMICOLON:\n+\t\t  if (code == OMP_ATOMIC_CAPTURE_NEW)\n+\t\t    {\n+\t\t      code = OMP_ATOMIC_CAPTURE_OLD;\n+\t\t      v = lhs;\n+\t\t      lhs = NULL_TREE;\n+\t\t      lhs1 = rhs1;\n+\t\t      rhs1 = NULL_TREE;\n+\t\t      cp_lexer_consume_token (parser->lexer);\n+\t\t      goto restart;\n+\t\t    }\n+\t\t  cp_parser_error (parser,\n+\t\t\t\t   \"invalid form of %<#pragma omp atomic%>\");\n+\t\t  goto saw_error;\n+\t\tcase CPP_MULT:\n+\t\t  opcode = MULT_EXPR;\n+\t\t  break;\n+\t\tcase CPP_DIV:\n+\t\t  opcode = TRUNC_DIV_EXPR;\n+\t\t  break;\n+\t\tcase CPP_PLUS:\n+\t\t  opcode = PLUS_EXPR;\n+\t\t  break;\n+\t\tcase CPP_MINUS:\n+\t\t  opcode = MINUS_EXPR;\n+\t\t  break;\n+\t\tcase CPP_LSHIFT:\n+\t\t  opcode = LSHIFT_EXPR;\n+\t\t  break;\n+\t\tcase CPP_RSHIFT:\n+\t\t  opcode = RSHIFT_EXPR;\n+\t\t  break;\n+\t\tcase CPP_AND:\n+\t\t  opcode = BIT_AND_EXPR;\n+\t\t  break;\n+\t\tcase CPP_OR:\n+\t\t  opcode = BIT_IOR_EXPR;\n+\t\t  break;\n+\t\tcase CPP_XOR:\n+\t\t  opcode = BIT_XOR_EXPR;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  cp_parser_error (parser,\n+\t\t\t\t   \"invalid operator for %<#pragma omp atomic%>\");\n+\t\t  goto saw_error;\n+\t\t}\n+\t      oprec = TOKEN_PRECEDENCE (token);\n+\t      gcc_assert (oprec != PREC_NOT_OPERATOR);\n+\t      if (commutative_tree_code (opcode))\n+\t\toprec = (enum cp_parser_prec) (oprec - 1);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      rhs = cp_parser_binary_expression (parser, false, false,\n+\t\t\t\t\t\t oprec, NULL);\n+\t      if (rhs == error_mark_node)\n+\t\tgoto saw_error;\n+\t      goto stmt_done;\n+\t    }\n+\t  /* FALLTHROUGH */\n \tdefault:\n \t  cp_parser_error (parser,\n \t\t\t   \"invalid operator for %<#pragma omp atomic%>\");\n@@ -24366,12 +24629,46 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n \tgoto saw_error;\n       break;\n     }\n-  finish_omp_atomic (code, lhs, rhs);\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+stmt_done:\n+  if (structured_block && code == OMP_ATOMIC_CAPTURE_NEW)\n+    {\n+      if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+\tgoto saw_error;\n+      v = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t      /*cast_p=*/false, NULL);\n+      if (v == error_mark_node)\n+\tgoto saw_error;\n+      if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+\tgoto saw_error;\n+      lhs1 = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t\t /*cast_p=*/false, NULL);\n+      if (lhs1 == error_mark_node)\n+\tgoto saw_error;\n+    }\n+  if (structured_block)\n+    {\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+    }\n+done:\n+  finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1);\n+  if (!structured_block)\n+    cp_parser_consume_semicolon_at_end_of_statement (parser);\n   return;\n \n  saw_error:\n   cp_parser_skip_to_end_of_block_or_statement (parser);\n+  if (structured_block)\n+    {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+        cp_lexer_consume_token (parser->lexer);\n+      else if (code == OMP_ATOMIC_CAPTURE_NEW)\n+\t{\n+\t  cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t}\n+    }\n }\n \n \n@@ -25233,7 +25530,9 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok)\n \t| (1u << PRAGMA_OMP_CLAUSE_DEFAULT)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n-\t| (1u << PRAGMA_OMP_CLAUSE_SHARED))\n+\t| (1u << PRAGMA_OMP_CLAUSE_SHARED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FINAL)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_MERGEABLE))\n \n static tree\n cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok)\n@@ -25260,6 +25559,16 @@ cp_parser_omp_taskwait (cp_parser *parser, cp_token *pragma_tok)\n   finish_omp_taskwait ();\n }\n \n+/* OpenMP 3.1:\n+   # pragma omp taskyield new-line  */\n+\n+static void\n+cp_parser_omp_taskyield (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  finish_omp_taskyield ();\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp threadprivate (variable-list) */\n \n@@ -25435,6 +25744,22 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t}\n       break;\n \n+    case PRAGMA_OMP_TASKYIELD:\n+      switch (context)\n+\t{\n+\tcase pragma_compound:\n+\t  cp_parser_omp_taskyield (parser, pragma_tok);\n+\t  return false;\n+\tcase pragma_stmt:\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma omp taskyield%> may only be \"\n+\t\t    \"used in compound statements\");\n+\t  break;\n+\tdefault:\n+\t  goto bad_stmt;\n+\t}\n+      break;\n+\n     case PRAGMA_OMP_THREADPRIVATE:\n       cp_parser_omp_threadprivate (parser, pragma_tok);\n       return false;"}, {"sha": "3131e613882fa85016397b32c13ab333678d7159", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -12181,6 +12181,7 @@ tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_FINAL:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, \n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n@@ -12189,6 +12190,7 @@ tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -12819,12 +12821,56 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case OMP_ATOMIC:\n       gcc_assert (OMP_ATOMIC_DEPENDENT_P (t));\n-      {\n-\ttree op1 = TREE_OPERAND (t, 1);\n-\ttree lhs = RECUR (TREE_OPERAND (op1, 0));\n-\ttree rhs = RECUR (TREE_OPERAND (op1, 1));\n-\tfinish_omp_atomic (TREE_CODE (op1), lhs, rhs);\n-      }\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) != MODIFY_EXPR)\n+\t{\n+\t  tree op1 = TREE_OPERAND (t, 1);\n+\t  tree rhs1 = NULL_TREE;\n+\t  tree lhs, rhs;\n+\t  if (TREE_CODE (op1) == COMPOUND_EXPR)\n+\t    {\n+\t      rhs1 = RECUR (TREE_OPERAND (op1, 0));\n+\t      op1 = TREE_OPERAND (op1, 1);\n+\t    }\n+\t  lhs = RECUR (TREE_OPERAND (op1, 0));\n+\t  rhs = RECUR (TREE_OPERAND (op1, 1));\n+\t  finish_omp_atomic (OMP_ATOMIC, TREE_CODE (op1), lhs, rhs,\n+\t\t\t     NULL_TREE, NULL_TREE, rhs1);\n+\t}\n+      else\n+\t{\n+\t  tree op1 = TREE_OPERAND (t, 1);\n+\t  tree v = NULL_TREE, lhs, rhs = NULL_TREE, lhs1 = NULL_TREE;\n+\t  tree rhs1 = NULL_TREE;\n+\t  enum tree_code code = TREE_CODE (TREE_OPERAND (op1, 1));\n+\t  enum tree_code opcode = NOP_EXPR;\n+\t  if (code == OMP_ATOMIC_READ)\n+\t    {\n+\t      v = RECUR (TREE_OPERAND (op1, 0));\n+\t      lhs = RECUR (TREE_OPERAND (TREE_OPERAND (op1, 1), 0));\n+\t    }\n+\t  else if (code == OMP_ATOMIC_CAPTURE_OLD\n+\t\t   || code == OMP_ATOMIC_CAPTURE_NEW)\n+\t    {\n+\t      tree op11 = TREE_OPERAND (TREE_OPERAND (op1, 1), 1);\n+\t      v = RECUR (TREE_OPERAND (op1, 0));\n+\t      lhs1 = RECUR (TREE_OPERAND (TREE_OPERAND (op1, 1), 0));\n+\t      if (TREE_CODE (op11) == COMPOUND_EXPR)\n+\t\t{\n+\t\t  rhs1 = RECUR (TREE_OPERAND (op11, 0));\n+\t\t  op11 = TREE_OPERAND (op11, 1);\n+\t\t}\n+\t      lhs = RECUR (TREE_OPERAND (op11, 0));\n+\t      rhs = RECUR (TREE_OPERAND (op11, 1));\n+\t      opcode = TREE_CODE (op11);\n+\t    }\n+\t  else\n+\t    {\n+\t      code = OMP_ATOMIC;\n+\t      lhs = RECUR (TREE_OPERAND (op1, 0));\n+\t      rhs = RECUR (TREE_OPERAND (op1, 1));\n+\t    }\n+\t  finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1);\n+\t}\n       break;\n \n     case EXPR_PACK_EXPANSION:"}, {"sha": "a52847733e63f644d6950687bf8648613160011d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -3905,6 +3905,14 @@ finish_omp_clauses (tree clauses)\n \t  OMP_CLAUSE_IF_EXPR (c) = t;\n \t  break;\n \n+\tcase OMP_CLAUSE_FINAL:\n+\t  t = OMP_CLAUSE_FINAL_EXPR (c);\n+\t  t = maybe_convert_cond (t);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  OMP_CLAUSE_FINAL_EXPR (c) = t;\n+\t  break;\n+\n \tcase OMP_CLAUSE_NUM_THREADS:\n \t  t = OMP_CLAUSE_NUM_THREADS_EXPR (c);\n \t  if (t == error_mark_node)\n@@ -3936,6 +3944,7 @@ finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tdefault:\n@@ -4030,6 +4039,8 @@ finish_omp_clauses (tree clauses)\n \t\tcase PLUS_EXPR:\n \t\tcase MULT_EXPR:\n \t\tcase MINUS_EXPR:\n+\t\tcase MIN_EXPR:\n+\t\tcase MAX_EXPR:\n \t\t  break;\n \t\tdefault:\n \t\t  error (\"%qE has invalid type for %<reduction(%s)%>\",\n@@ -4074,6 +4085,10 @@ finish_omp_clauses (tree clauses)\n \t    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n \t      break;\n \t    case OMP_CLAUSE_DEFAULT_SHARED:\n+\t      /* const vars may be specified in firstprivate clause.  */\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t  && cxx_omp_const_qual_no_mutable (t))\n+\t\tbreak;\n \t      share_name = \"shared\";\n \t      break;\n \t    case OMP_CLAUSE_DEFAULT_PRIVATE:\n@@ -4697,15 +4712,22 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n }\n \n void\n-finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n+finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n+\t\t   tree rhs, tree v, tree lhs1, tree rhs1)\n {\n   tree orig_lhs;\n   tree orig_rhs;\n+  tree orig_v;\n+  tree orig_lhs1;\n+  tree orig_rhs1;\n   bool dependent_p;\n   tree stmt;\n \n   orig_lhs = lhs;\n   orig_rhs = rhs;\n+  orig_v = v;\n+  orig_lhs1 = lhs1;\n+  orig_rhs1 = rhs1;\n   dependent_p = false;\n   stmt = NULL_TREE;\n \n@@ -4714,22 +4736,53 @@ finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n   if (processing_template_decl)\n     {\n       dependent_p = (type_dependent_expression_p (lhs)\n-\t\t     || type_dependent_expression_p (rhs));\n+\t\t     || (rhs && type_dependent_expression_p (rhs))\n+\t\t     || (v && type_dependent_expression_p (v))\n+\t\t     || (lhs1 && type_dependent_expression_p (lhs1))\n+\t\t     || (rhs1 && type_dependent_expression_p (rhs1)));\n       if (!dependent_p)\n \t{\n \t  lhs = build_non_dependent_expr (lhs);\n-\t  rhs = build_non_dependent_expr (rhs);\n+\t  if (rhs)\n+\t    rhs = build_non_dependent_expr (rhs);\n+\t  if (v)\n+\t    v = build_non_dependent_expr (v);\n+\t  if (lhs1)\n+\t    lhs1 = build_non_dependent_expr (lhs1);\n+\t  if (rhs1)\n+\t    rhs1 = build_non_dependent_expr (rhs1);\n \t}\n     }\n   if (!dependent_p)\n     {\n-      stmt = c_finish_omp_atomic (input_location, code, lhs, rhs);\n+      stmt = c_finish_omp_atomic (input_location, code, opcode, lhs, rhs,\n+\t\t\t\t  v, lhs1, rhs1);\n       if (stmt == error_mark_node)\n \treturn;\n     }\n   if (processing_template_decl)\n-    stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node,\n-\t\t   build2 (code, void_type_node, orig_lhs, orig_rhs));\n+    {\n+      if (code == OMP_ATOMIC_READ)\n+\t{\n+\t  stmt = build_min_nt (OMP_ATOMIC_READ, orig_lhs);\n+\t  stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n+\t}\n+      else\n+\t{\n+\t  if (opcode == NOP_EXPR)\n+\t    stmt = build2 (MODIFY_EXPR, void_type_node, orig_lhs, orig_rhs);\n+\t  else \n+\t    stmt = build2 (opcode, void_type_node, orig_lhs, orig_rhs);\n+\t  if (orig_rhs1)\n+\t    stmt = build_min_nt (COMPOUND_EXPR, orig_rhs1, stmt);\n+\t  if (code != OMP_ATOMIC)\n+\t    {\n+\t      stmt = build_min_nt (code, orig_lhs1, stmt);\n+\t      stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n+\t    }\n+\t}\n+      stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node, stmt);\n+    }\n   add_stmt (stmt);\n }\n \n@@ -4762,6 +4815,16 @@ finish_omp_taskwait (void)\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n }\n+\n+void\n+finish_omp_taskyield (void)\n+{\n+  tree fn = built_in_decls[BUILT_IN_GOMP_TASKYIELD];\n+  VEC(tree,gc) *vec = make_tree_vector ();\n+  tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n+  release_tree_vector (vec);\n+  finish_expr_stmt (stmt);\n+}\n \f\n void\n init_cp_semantics (void)"}, {"sha": "dba71e2e0ee66480fb7882e0c2e61efe4ca4a1b0", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -2210,7 +2210,9 @@ Clauses are represented by separate sub-codes defined in\n @code{OMP_CLAUSE_COPYPRIVATE}, @code{OMP_CLAUSE_IF},\n @code{OMP_CLAUSE_NUM_THREADS}, @code{OMP_CLAUSE_SCHEDULE},\n @code{OMP_CLAUSE_NOWAIT}, @code{OMP_CLAUSE_ORDERED},\n-@code{OMP_CLAUSE_DEFAULT}, and @code{OMP_CLAUSE_REDUCTION}.  Each code\n+@code{OMP_CLAUSE_DEFAULT}, @code{OMP_CLAUSE_REDUCTION},\n+@code{OMP_CLAUSE_COLLAPSE}, @code{OMP_CLAUSE_UNTIED},\n+@code{OMP_CLAUSE_FINAL}, and @code{OMP_CLAUSE_MERGEABLE}.  Each code\n represents the corresponding OpenMP clause.\n \n Clauses associated with the same directive are chained together"}, {"sha": "123990f66b00893e6cfb13c514032b0601b6618b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,3 +1,60 @@\n+2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/46752\n+\t* cpp.c (cpp_define_builtins): Change _OPENMP to 201107.\n+\t* openmp.c (gfc_free_omp_clauses): Free also final_expr.\n+\t(OMP_CLAUSE_FINAL, OMP_CLAUSE_MERGEABLE): Define.\n+\t(gfc_match_omp_clauses): Handle parsing final and mergeable\n+\tclauses.\n+\t(OMP_TASK_CLAUSES): Allow final and mergeable clauses.\n+\t(gfc_match_omp_taskyield): New function.\n+\t(resolve_omp_clauses): Resolve final clause.  Allow POINTERs and\n+\tCray pointers in clauses other than REDUCTION.\n+\t(gfc_match_omp_atomic): Match optional\n+\tread/write/update/capture keywords after !$omp atomic.\n+\t(resolve_omp_atomic): Handle all OpenMP 3.1 atomic forms.\n+\t* dump-parse-tree.c (show_omp_node): Handle EXEC_OMP_TASKYIELD,\n+\tprint final and mergeable clauses.\n+\t(show_code_node): Handle EXEC_OMP_TASKYIELD.\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Handle final and\n+\tmergeable clauses.\n+\t(gfc_trans_omp_taskyield): New function.\n+\t(gfc_trans_omp_directive): Handle EXEC_OMP_TASKYIELD.\n+\t(gfc_trans_omp_atomic): Handle all OpenMP 3.1 atomic forms.\n+\t(gfc_omp_clause_copy_ctor): Handle non-allocated allocatable.\n+\t(gfc_omp_predetermined_sharing): Adjust comment.\n+\t* gfortran.h (gfc_statement): Add ST_OMP_TASKYIELD and\n+\tST_OMP_END_ATOMIC.\n+\t(gfc_omp_clauses): Add final_expr and mergeable fields.\n+\t(gfc_exec_op): Add EXEC_OMP_TASKYIELD.\n+\t(gfc_omp_atomic_op): New enum typedef.\n+\t(struct gfc_code): Add ext.omp_atomic.\n+\t* trans.c (trans_code): Handle EXEC_OMP_TASKYIELD.\n+\t* frontend-passes.c (gfc_code_walker): Also walk final_expr.\n+\t* resolve.c (gfc_resolve_blocks, resolve_code): Handle\n+\tEXEC_OMP_TASKYIELD.\n+\t* st.c (gfc_free_statement): Likewise.\n+\t* match.h (gfc_match_omp_taskyield): New prototype.\n+\t* parse.c (decode_omp_directive): Handle taskyield directive.\n+\tHandle !$omp end atomic.\n+\t(case_executable): Add ST_OMP_TASKYIELD case.\n+\t(gfc_ascii_statement): Handle ST_OMP_TASKYIELD.\n+\t(parse_omp_atomic): Return gfc_statement instead of void.\n+\tFor !$omp atomic capture parse two assignments instead of\n+\tjust one and require !$omp end atomic afterwards, for\n+\tother !$omp atomic forms just allow !$omp end atomic at the\n+\tend.\n+\t(parse_omp_structured_block, parse_executable): Adjust\n+\tparse_omp_atomic callers.\n+\n+2011-08-02  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* intrinsic.c (OMP_LIB): Updated openmp_version's\n+\tvalue to 201107.\n+\t* gfortran.texi (OpenMP): Update ref to OpenMP 3.1.\n+\t* intrinsic.texi (OpenMP Modules): Update ref to OpenMP 3.1;\n+\tremove deleted omp_integer_kind and omp_logical_kind constants.\n+\n 2011-07-31  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/49112"}, {"sha": "a40442ee4d7be92df536b24902f7e0b2d00046ee", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n+/* Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -166,7 +166,7 @@ cpp_define_builtins (cpp_reader *pfile)\n   cpp_define (pfile, \"_LANGUAGE_FORTRAN=1\");\n \n   if (gfc_option.gfc_flag_openmp)\n-    cpp_define (pfile, \"_OPENMP=200805\");\n+    cpp_define (pfile, \"_OPENMP=201107\");\n \n   /* The defines below are necessary for the TARGET_* macros.\n "}, {"sha": "ad8b5548071ce1b7041d866113b51c6a9fb471de", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1039,6 +1039,7 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_SINGLE: name = \"SINGLE\"; break;\n     case EXEC_OMP_TASK: name = \"TASK\"; break;\n     case EXEC_OMP_TASKWAIT: name = \"TASKWAIT\"; break;\n+    case EXEC_OMP_TASKYIELD: name = \"TASKYIELD\"; break;\n     case EXEC_OMP_WORKSHARE: name = \"WORKSHARE\"; break;\n     default:\n       gcc_unreachable ();\n@@ -1071,6 +1072,7 @@ show_omp_node (int level, gfc_code *c)\n       return;\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_TASKWAIT:\n+    case EXEC_OMP_TASKYIELD:\n       return;\n     default:\n       break;\n@@ -1085,6 +1087,12 @@ show_omp_node (int level, gfc_code *c)\n \t  show_expr (omp_clauses->if_expr);\n \t  fputc (')', dumpfile);\n \t}\n+      if (omp_clauses->final_expr)\n+\t{\n+\t  fputs (\" FINAL(\", dumpfile);\n+\t  show_expr (omp_clauses->final_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n       if (omp_clauses->num_threads)\n \t{\n \t  fputs (\" NUM_THREADS(\", dumpfile);\n@@ -1130,6 +1138,8 @@ show_omp_node (int level, gfc_code *c)\n \tfputs (\" ORDERED\", dumpfile);\n       if (omp_clauses->untied)\n \tfputs (\" UNTIED\", dumpfile);\n+      if (omp_clauses->mergeable)\n+\tfputs (\" MERGEABLE\", dumpfile);\n       if (omp_clauses->collapse)\n \tfprintf (dumpfile, \" COLLAPSE(%d)\", omp_clauses->collapse);\n       for (list_type = 0; list_type < OMP_LIST_NUM; list_type++)\n@@ -2167,6 +2177,7 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_TASK:\n     case EXEC_OMP_TASKWAIT:\n+    case EXEC_OMP_TASKYIELD:\n     case EXEC_OMP_WORKSHARE:\n       show_omp_node (level, c);\n       break;"}, {"sha": "8ab46f6e457bc104c0b554b8b386cdbd8f1d99d0", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1235,6 +1235,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      if (co->ext.omp_clauses)\n \t\t{\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->if_expr);\n+\t\t  WALK_SUBEXPR (co->ext.omp_clauses->final_expr);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->num_threads);\n \t\t  WALK_SUBEXPR (co->ext.omp_clauses->chunk_size);\n \t\t}"}, {"sha": "acfa9d4c555b683842c10c299f16aafd3d27c9dd", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -199,16 +199,16 @@ typedef enum\n   ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n   ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n-  ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_CRITICAL,\n-  ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED, ST_OMP_END_PARALLEL,\n-  ST_OMP_END_PARALLEL_DO, ST_OMP_END_PARALLEL_SECTIONS,\n+  ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_ATOMIC,\n+  ST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED,\n+  ST_OMP_END_PARALLEL, ST_OMP_END_PARALLEL_DO, ST_OMP_END_PARALLEL_SECTIONS,\n   ST_OMP_END_PARALLEL_WORKSHARE, ST_OMP_END_SECTIONS, ST_OMP_END_SINGLE,\n   ST_OMP_END_WORKSHARE, ST_OMP_DO, ST_OMP_FLUSH, ST_OMP_MASTER, ST_OMP_ORDERED,\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,\n-  ST_OMP_TASKWAIT, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n-  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n+  ST_OMP_TASKWAIT, ST_OMP_TASKYIELD, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL,\n+  ST_END_CRITICAL, ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n }\n gfc_statement;\n \n@@ -1050,13 +1050,14 @@ enum gfc_omp_default_sharing\n typedef struct gfc_omp_clauses\n {\n   struct gfc_expr *if_expr;\n+  struct gfc_expr *final_expr;\n   struct gfc_expr *num_threads;\n   gfc_namelist *lists[OMP_LIST_NUM];\n   enum gfc_omp_sched_kind sched_kind;\n   struct gfc_expr *chunk_size;\n   enum gfc_omp_default_sharing default_sharing;\n   int collapse;\n-  bool nowait, ordered, untied;\n+  bool nowait, ordered, untied, mergeable;\n }\n gfc_omp_clauses;\n \n@@ -2064,10 +2065,20 @@ typedef enum\n   EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n   EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n   EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n-  EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT\n+  EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT,\n+  EXEC_OMP_TASKYIELD\n }\n gfc_exec_op;\n \n+typedef enum\n+{\n+  GFC_OMP_ATOMIC_UPDATE,\n+  GFC_OMP_ATOMIC_READ,\n+  GFC_OMP_ATOMIC_WRITE,\n+  GFC_OMP_ATOMIC_CAPTURE\n+}\n+gfc_omp_atomic_op;\n+\n typedef struct gfc_code\n {\n   gfc_exec_op op;\n@@ -2118,6 +2129,7 @@ typedef struct gfc_code\n     const char *omp_name;\n     gfc_namelist *omp_namelist;\n     bool omp_bool;\n+    gfc_omp_atomic_op omp_atomic;\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n "}, {"sha": "389c05bfaab10ba0255aadfbba902e71f646052a", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -530,7 +530,7 @@ support is reported in the @ref{Fortran 2003 status} and\n @ref{Fortran 2008 status} sections of the documentation.\n \n Additionally, the GNU Fortran compilers supports the OpenMP specification\n-(version 3.0, @url{http://openmp.org/@/wp/@/openmp-specifications/}).\n+(version 3.1, @url{http://openmp.org/@/wp/@/openmp-specifications/}).\n \n @node Varying Length Character Strings\n @subsection Varying Length Character Strings\n@@ -1762,8 +1762,8 @@ It consists of a set of compiler directives, library routines,\n and environment variables that influence run-time behavior.\n \n GNU Fortran strives to be compatible to the \n-@uref{http://www.openmp.org/mp-documents/spec30.pdf,\n-OpenMP Application Program Interface v3.0}.\n+@uref{http://www.openmp.org/mp-documents/spec31.pdf,\n+OpenMP Application Program Interface v3.1}.\n \n To enable the processing of the OpenMP directive @code{!$omp} in\n free-form source code; the @code{c$omp}, @code{*$omp} and @code{!$omp}"}, {"sha": "9adeeabf60dcde853e14932e39fc7befb0842e3b", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -13072,7 +13072,7 @@ Both are equivalent to the value @code{NULL} in C.\n @section OpenMP Modules @code{OMP_LIB} and @code{OMP_LIB_KINDS}\n @table @asis\n @item @emph{Standard}:\n-OpenMP Application Program Interface v3.0\n+OpenMP Application Program Interface v3.1\n @end table\n \n \n@@ -13085,15 +13085,13 @@ the named constants defined in the modules are listed\n below.\n \n For details refer to the actual\n-@uref{http://www.openmp.org/mp-documents/spec30.pdf,\n-OpenMP Application Program Interface v3.0}.\n+@uref{http://www.openmp.org/mp-documents/spec31.pdf,\n+OpenMP Application Program Interface v3.1}.\n \n @code{OMP_LIB_KINDS} provides the following scalar default-integer\n named constants:\n \n @table @asis\n-@item @code{omp_integer_kind}\n-@item @code{omp_logical_kind}\n @item @code{omp_lock_kind}\n @item @code{omp_nest_lock_kind}\n @item @code{omp_sched_kind}\n@@ -13102,7 +13100,7 @@ named constants:\n @code{OMP_LIB} provides the scalar default-integer\n named constant @code{openmp_version} with a value of the form\n @var{yyyymm}, where @code{yyyy} is the year and @var{mm} the month\n-of the OpenMP version; for OpenMP v3.0 the value is @code{200805}.\n+of the OpenMP version; for OpenMP v3.1 the value is @code{201107}.\n \n And the following scalar integer named constants of the\n kind @code{omp_sched_kind}:"}, {"sha": "0d841044b98ed3373afbd52fa10c00789d6eaed6", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -138,6 +138,7 @@ match gfc_match_omp_sections (void);\n match gfc_match_omp_single (void);\n match gfc_match_omp_task (void);\n match gfc_match_omp_taskwait (void);\n+match gfc_match_omp_taskyield (void);\n match gfc_match_omp_threadprivate (void);\n match gfc_match_omp_workshare (void);\n match gfc_match_omp_end_nowait (void);"}, {"sha": "f5a58779c0cc463058748c1d6d43d1f5ebd49ccc", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 191, "deletions": 10, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,5 +1,5 @@\n /* OpenMP directive matching and resolving.\n-   Copyright (C) 2005, 2006, 2007, 2008, 2010\n+   Copyright (C) 2005, 2006, 2007, 2008, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek\n \n@@ -66,6 +66,7 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n     return;\n \n   gfc_free_expr (c->if_expr);\n+  gfc_free_expr (c->final_expr);\n   gfc_free_expr (c->num_threads);\n   gfc_free_expr (c->chunk_size);\n   for (i = 0; i < OMP_LIST_NUM; i++)\n@@ -182,6 +183,8 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n #define OMP_CLAUSE_ORDERED\t(1 << 11)\n #define OMP_CLAUSE_COLLAPSE\t(1 << 12)\n #define OMP_CLAUSE_UNTIED\t(1 << 13)\n+#define OMP_CLAUSE_FINAL\t(1 << 14)\n+#define OMP_CLAUSE_MERGEABLE\t(1 << 15)\n \n /* Match OpenMP directive clauses. MASK is a bitmask of\n    clauses that are allowed for a particular directive.  */\n@@ -205,6 +208,9 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n       if ((mask & OMP_CLAUSE_IF) && c->if_expr == NULL\n \t  && gfc_match (\"if ( %e )\", &c->if_expr) == MATCH_YES)\n \tcontinue;\n+      if ((mask & OMP_CLAUSE_FINAL) && c->final_expr == NULL\n+\t  && gfc_match (\"final ( %e )\", &c->final_expr) == MATCH_YES)\n+\tcontinue;\n       if ((mask & OMP_CLAUSE_NUM_THREADS) && c->num_threads == NULL\n \t  && gfc_match (\"num_threads ( %e )\", &c->num_threads) == MATCH_YES)\n \tcontinue;\n@@ -383,6 +389,12 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n \t  c->untied = needs_space = true;\n \t  continue;\n \t}\n+      if ((mask & OMP_CLAUSE_MERGEABLE) && !c->mergeable\n+\t  && gfc_match (\"mergeable\") == MATCH_YES)\n+\t{\n+\t  c->mergeable = needs_space = true;\n+\t  continue;\n+\t}\n       if ((mask & OMP_CLAUSE_COLLAPSE) && !c->collapse)\n \t{\n \t  gfc_expr *cexpr = NULL;\n@@ -435,7 +447,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n #define OMP_TASK_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n-   | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED)\n+   | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED\t\t\\\n+   | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE)\n \n match\n gfc_match_omp_parallel (void)\n@@ -475,6 +488,20 @@ gfc_match_omp_taskwait (void)\n }\n \n \n+match\n+gfc_match_omp_taskyield (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after TASKYIELD clause at %C\");\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_TASKYIELD;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_critical (void)\n {\n@@ -700,13 +727,22 @@ gfc_match_omp_ordered (void)\n match\n gfc_match_omp_atomic (void)\n {\n+  gfc_omp_atomic_op op = GFC_OMP_ATOMIC_UPDATE;\n+  if (gfc_match (\"% update\") == MATCH_YES)\n+    op = GFC_OMP_ATOMIC_UPDATE;\n+  else if (gfc_match (\"% read\") == MATCH_YES)\n+    op = GFC_OMP_ATOMIC_READ;\n+  else if (gfc_match (\"% write\") == MATCH_YES)\n+    op = GFC_OMP_ATOMIC_WRITE;\n+  else if (gfc_match (\"% capture\") == MATCH_YES)\n+    op = GFC_OMP_ATOMIC_CAPTURE;\n   if (gfc_match_omp_eos () != MATCH_YES)\n     {\n       gfc_error (\"Unexpected junk after $OMP ATOMIC statement at %C\");\n       return MATCH_ERROR;\n     }\n   new_st.op = EXEC_OMP_ATOMIC;\n-  new_st.ext.omp_clauses = NULL;\n+  new_st.ext.omp_atomic = op;\n   return MATCH_YES;\n }\n \n@@ -783,6 +819,14 @@ resolve_omp_clauses (gfc_code *code)\n \tgfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n \t\t   &expr->where);\n     }\n+  if (omp_clauses->final_expr)\n+    {\n+      gfc_expr *expr = omp_clauses->final_expr;\n+      if (gfc_resolve_expr (expr) == FAILURE\n+\t  || expr->ts.type != BT_LOGICAL || expr->rank != 0)\n+\tgfc_error (\"FINAL clause at %L requires a scalar LOGICAL expression\",\n+\t\t   &expr->where);\n+    }\n   if (omp_clauses->num_threads)\n     {\n       gfc_expr *expr = omp_clauses->num_threads;\n@@ -940,15 +984,20 @@ resolve_omp_clauses (gfc_code *code)\n \t\t\t    n->sym->name, name, &code->loc);\n \t\tif (list != OMP_LIST_PRIVATE)\n \t\t  {\n-\t\t    if (n->sym->attr.pointer)\n+\t\t    if (n->sym->attr.pointer\n+\t\t\t&& list >= OMP_LIST_REDUCTION_FIRST\n+\t\t\t&& list <= OMP_LIST_REDUCTION_LAST)\n \t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, &code->loc);\n \t\t    /* Variables in REDUCTION-clauses must be of intrinsic type (flagged below).  */\n-\t\t    if ((list < OMP_LIST_REDUCTION_FIRST || list > OMP_LIST_REDUCTION_LAST) &&\n-\t\t        n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n+\t\t    if ((list < OMP_LIST_REDUCTION_FIRST || list > OMP_LIST_REDUCTION_LAST)\n+\t\t\t && n->sym->ts.type == BT_DERIVED\n+\t\t\t && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t      gfc_error (\"%s clause object '%s' has ALLOCATABLE components at %L\",\n \t\t\t\t name, n->sym->name, &code->loc);\n-\t\t    if (n->sym->attr.cray_pointer)\n+\t\t    if (n->sym->attr.cray_pointer\n+\t\t\t&& list >= OMP_LIST_REDUCTION_FIRST\n+\t\t\t&& list <= OMP_LIST_REDUCTION_LAST)\n \t\t      gfc_error (\"Cray pointer '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, &code->loc);\n \t\t  }\n@@ -1095,12 +1144,18 @@ is_conversion (gfc_expr *expr, bool widening)\n static void\n resolve_omp_atomic (gfc_code *code)\n {\n+  gfc_code *atomic_code = code;\n   gfc_symbol *var;\n-  gfc_expr *expr2;\n+  gfc_expr *expr2, *expr2_tmp;\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n-  gcc_assert (code->next == NULL);\n+  gcc_assert ((atomic_code->ext.omp_atomic != GFC_OMP_ATOMIC_CAPTURE\n+\t       && code->next == NULL)\n+\t      || (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE\n+\t\t  && code->next != NULL\n+\t\t  && code->next->op == EXEC_ASSIGN\n+\t\t  && code->next->next == NULL));\n \n   if (code->expr1->expr_type != EXPR_VARIABLE\n       || code->expr1->symtree == NULL\n@@ -1118,7 +1173,86 @@ resolve_omp_atomic (gfc_code *code)\n   var = code->expr1->symtree->n.sym;\n   expr2 = is_conversion (code->expr2, false);\n   if (expr2 == NULL)\n-    expr2 = code->expr2;\n+    {\n+      if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_READ\n+\t  || atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_WRITE)\n+\texpr2 = is_conversion (code->expr2, true);\n+      if (expr2 == NULL)\n+\texpr2 = code->expr2;\n+    }\n+\n+  switch (atomic_code->ext.omp_atomic)\n+    {\n+    case GFC_OMP_ATOMIC_READ:\n+      if (expr2->expr_type != EXPR_VARIABLE\n+\t  || expr2->symtree == NULL\n+\t  || expr2->rank != 0\n+\t  || (expr2->ts.type != BT_INTEGER\n+\t      && expr2->ts.type != BT_REAL\n+\t      && expr2->ts.type != BT_COMPLEX\n+\t      && expr2->ts.type != BT_LOGICAL))\n+\tgfc_error (\"!$OMP ATOMIC READ statement must read from a scalar \"\n+\t\t   \"variable of intrinsic type at %L\", &expr2->where);\n+      return;\n+    case GFC_OMP_ATOMIC_WRITE:\n+      if (expr2->rank != 0 || expr_references_sym (code->expr2, var, NULL))\n+\tgfc_error (\"expr in !$OMP ATOMIC WRITE assignment var = expr \"\n+\t\t   \"must be scalar and cannot reference var at %L\",\n+\t\t   &expr2->where);\n+      return;\n+    case GFC_OMP_ATOMIC_CAPTURE:\n+      expr2_tmp = expr2;\n+      if (expr2 == code->expr2)\n+\t{\n+\t  expr2_tmp = is_conversion (code->expr2, true);\n+\t  if (expr2_tmp == NULL)\n+\t    expr2_tmp = expr2;\n+\t}\n+      if (expr2_tmp->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  if (expr2_tmp->symtree == NULL\n+\t      || expr2_tmp->rank != 0\n+\t      || (expr2_tmp->ts.type != BT_INTEGER\n+\t\t  && expr2_tmp->ts.type != BT_REAL\n+\t\t  && expr2_tmp->ts.type != BT_COMPLEX\n+\t\t  && expr2_tmp->ts.type != BT_LOGICAL)\n+\t      || expr2_tmp->symtree->n.sym == var)\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC CAPTURE capture statement must read from \"\n+\t\t\t \"a scalar variable of intrinsic type at %L\",\n+\t\t\t &expr2_tmp->where);\n+\t      return;\n+\t    }\n+\t  var = expr2_tmp->symtree->n.sym;\n+\t  code = code->next;\n+\t  if (code->expr1->expr_type != EXPR_VARIABLE\n+\t      || code->expr1->symtree == NULL\n+\t      || code->expr1->rank != 0\n+\t      || (code->expr1->ts.type != BT_INTEGER\n+\t\t  && code->expr1->ts.type != BT_REAL\n+\t\t  && code->expr1->ts.type != BT_COMPLEX\n+\t\t  && code->expr1->ts.type != BT_LOGICAL))\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC CAPTURE update statement must set \"\n+\t\t\t \"a scalar variable of intrinsic type at %L\",\n+\t\t\t &code->expr1->where);\n+\t      return;\n+\t    }\n+\t  if (code->expr1->symtree->n.sym != var)\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC CAPTURE capture statement reads from \"\n+\t\t\t \"different variable than update statement writes \"\n+\t\t\t \"into at %L\", &code->expr1->where);\n+\t      return;\n+\t    }\n+\t  expr2 = is_conversion (code->expr2, false);\n+\t  if (expr2 == NULL)\n+\t    expr2 = code->expr2;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n \n   if (expr2->expr_type == EXPR_OP)\n     {\n@@ -1320,6 +1454,53 @@ resolve_omp_atomic (gfc_code *code)\n   else\n     gfc_error (\"!$OMP ATOMIC assignment must have an operator or intrinsic \"\n \t       \"on right hand side at %L\", &expr2->where);\n+\n+  if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE && code->next)\n+    {\n+      code = code->next;\n+      if (code->expr1->expr_type != EXPR_VARIABLE\n+\t  || code->expr1->symtree == NULL\n+\t  || code->expr1->rank != 0\n+\t  || (code->expr1->ts.type != BT_INTEGER\n+\t      && code->expr1->ts.type != BT_REAL\n+\t      && code->expr1->ts.type != BT_COMPLEX\n+\t      && code->expr1->ts.type != BT_LOGICAL))\n+\t{\n+\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement must set \"\n+\t\t     \"a scalar variable of intrinsic type at %L\",\n+\t\t     &code->expr1->where);\n+\t  return;\n+\t}\n+\n+      expr2 = is_conversion (code->expr2, false);\n+      if (expr2 == NULL)\n+\t{\n+\t  expr2 = is_conversion (code->expr2, true);\n+\t  if (expr2 == NULL)\n+\t    expr2 = code->expr2;\n+\t}\n+\n+      if (expr2->expr_type != EXPR_VARIABLE\n+\t  || expr2->symtree == NULL\n+\t  || expr2->rank != 0\n+\t  || (expr2->ts.type != BT_INTEGER\n+\t      && expr2->ts.type != BT_REAL\n+\t      && expr2->ts.type != BT_COMPLEX\n+\t      && expr2->ts.type != BT_LOGICAL))\n+\t{\n+\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement must read \"\n+\t\t     \"from a scalar variable of intrinsic type at %L\",\n+\t\t     &expr2->where);\n+\t  return;\n+\t}\n+      if (expr2->symtree->n.sym != var)\n+\t{\n+\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement reads from \"\n+\t\t     \"different variable than update statement writes \"\n+\t\t     \"into at %L\", &expr2->where);\n+\t  return;\n+\t}\n+    }\n }\n \n "}, {"sha": "2910ab513188d0ceea106c8c2bc1602aedf7d40f", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -526,6 +526,7 @@ decode_omp_directive (void)\n       match (\"do\", gfc_match_omp_do, ST_OMP_DO);\n       break;\n     case 'e':\n+      match (\"end atomic\", gfc_match_omp_eos, ST_OMP_END_ATOMIC);\n       match (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n       match (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n       match (\"end master\", gfc_match_omp_eos, ST_OMP_END_MASTER);\n@@ -567,6 +568,7 @@ decode_omp_directive (void)\n     case 't':\n       match (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n       match (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n+      match (\"taskyield\", gfc_match_omp_taskyield, ST_OMP_TASKYIELD);\n       match (\"threadprivate\", gfc_match_omp_threadprivate,\n \t     ST_OMP_THREADPRIVATE);\n     case 'w':\n@@ -957,9 +959,9 @@ next_statement (void)\n   case ST_POINTER_ASSIGNMENT: case ST_EXIT: case ST_CYCLE: \\\n   case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n-  case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_ERROR_STOP: \\\n-  case ST_SYNC_ALL: case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: \\\n-  case ST_LOCK: case ST_UNLOCK\n+  case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \\\n+  case ST_ERROR_STOP: case ST_SYNC_ALL: case ST_SYNC_IMAGES: \\\n+  case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK\n \n /* Statements that mark other executable statements.  */\n \n@@ -1470,6 +1472,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_DO:\n       p = \"!$OMP DO\";\n       break;\n+    case ST_OMP_END_ATOMIC:\n+      p = \"!$OMP END ATOMIC\";\n+      break;\n     case ST_OMP_END_CRITICAL:\n       p = \"!$OMP END CRITICAL\";\n       break;\n@@ -1542,6 +1547,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_TASKWAIT:\n       p = \"!$OMP TASKWAIT\";\n       break;\n+    case ST_OMP_TASKYIELD:\n+      p = \"!$OMP TASKYIELD\";\n+      break;\n     case ST_OMP_THREADPRIVATE:\n       p = \"!$OMP THREADPRIVATE\";\n       break;\n@@ -3420,12 +3428,13 @@ parse_omp_do (gfc_statement omp_st)\n \n /* Parse the statements of OpenMP atomic directive.  */\n \n-static void\n+static gfc_statement\n parse_omp_atomic (void)\n {\n   gfc_statement st;\n   gfc_code *cp, *np;\n   gfc_state_data s;\n+  int count;\n \n   accept_statement (ST_OMP_ATOMIC);\n \n@@ -3434,21 +3443,35 @@ parse_omp_atomic (void)\n   np = new_level (cp);\n   np->op = cp->op;\n   np->block = NULL;\n+  count = 1 + (cp->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE);\n \n-  for (;;)\n+  while (count)\n     {\n       st = next_statement ();\n       if (st == ST_NONE)\n \tunexpected_eof ();\n       else if (st == ST_ASSIGNMENT)\n-\tbreak;\n+\t{\n+\t  accept_statement (st);\n+\t  count--;\n+\t}\n       else\n \tunexpected_statement (st);\n     }\n \n-  accept_statement (st);\n-\n   pop_state ();\n+\n+  st = next_statement ();\n+  if (st == ST_OMP_END_ATOMIC)\n+    {\n+      gfc_clear_new_st ();\n+      gfc_commit_symbols ();\n+      gfc_warning_check ();\n+      st = next_statement ();\n+    }\n+  else if (cp->ext.omp_atomic == GFC_OMP_ATOMIC_CAPTURE)\n+    gfc_error (\"Missing !$OMP END ATOMIC after !$OMP ATOMIC CAPTURE at %C\");\n+  return st;\n }\n \n \n@@ -3558,8 +3581,8 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n \t\t  continue;\n \n \t\tcase ST_OMP_ATOMIC:\n-\t\t  parse_omp_atomic ();\n-\t\t  break;\n+\t\t  st = parse_omp_atomic ();\n+\t\t  continue;\n \n \t\tdefault:\n \t\t  cycle = false;\n@@ -3739,8 +3762,8 @@ parse_executable (gfc_statement st)\n \t  continue;\n \n \tcase ST_OMP_ATOMIC:\n-\t  parse_omp_atomic ();\n-\t  break;\n+\t  st = parse_omp_atomic ();\n+\t  continue;\n \n \tdefault:\n \t  return st;"}, {"sha": "b8a8ebb8a34391f4aaad3286e5da4239af60e92a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -8824,6 +8824,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKWAIT:\n+\tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_WORKSHARE:\n \t  break;\n \n@@ -9390,6 +9391,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TASKWAIT:\n+\tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_WORKSHARE:\n \t  gfc_resolve_omp_directive (code, ns);\n \t  break;"}, {"sha": "c051d6a0c97a3afe47350523d345f1abe67d4462", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -208,6 +208,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OMP_ORDERED:\n     case EXEC_OMP_END_NOWAIT:\n     case EXEC_OMP_TASKWAIT:\n+    case EXEC_OMP_TASKYIELD:\n       break;\n \n     default:"}, {"sha": "b1f8e09a1b96a71d93abb70da1c2f566247736af", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 147, "deletions": 24, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -88,9 +88,7 @@ gfc_omp_predetermined_sharing (tree decl)\n   if (GFC_DECL_CRAY_POINTEE (decl))\n     return OMP_CLAUSE_DEFAULT_PRIVATE;\n \n-  /* Assumed-size arrays are predetermined to inherit sharing\n-     attributes of the associated actual argument, which is shared\n-     for all we care.  */\n+  /* Assumed-size arrays are predetermined shared.  */\n   if (TREE_CODE (decl) == PARM_DECL\n       && GFC_ARRAY_TYPE_P (TREE_TYPE (decl))\n       && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_UNKNOWN\n@@ -215,7 +213,8 @@ tree\n gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n {\n   tree type = TREE_TYPE (dest), ptr, size, esize, rank, call;\n-  stmtblock_t block;\n+  tree cond, then_b, else_b;\n+  stmtblock_t block, cond_block;\n \n   if (! GFC_DESCRIPTOR_TYPE_P (type)\n       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n@@ -227,7 +226,9 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n      and copied from SRC.  */\n   gfc_start_block (&block);\n \n-  gfc_add_modify (&block, dest, src);\n+  gfc_init_block (&cond_block);\n+\n+  gfc_add_modify (&cond_block, dest, src);\n   rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n   size = gfc_conv_descriptor_ubound_get (dest, rank);\n   size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n@@ -241,18 +242,30 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n   size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t  size, esize);\n-  size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n+  size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n \n   ptr = gfc_create_var (pvoid_type_node, NULL);\n-  gfc_allocate_using_malloc (&block, ptr, size, NULL_TREE);\n-  gfc_conv_descriptor_data_set (&block, dest, ptr);\n+  gfc_allocate_using_malloc (&cond_block, ptr, size, NULL_TREE);\n+  gfc_conv_descriptor_data_set (&cond_block, dest, ptr);\n \n   call = build_call_expr_loc (input_location,\n \t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n \t\t\t  fold_convert (pvoid_type_node,\n \t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n \t\t\t  size);\n-  gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n+  gfc_add_expr_to_block (&cond_block, fold_convert (void_type_node, call));\n+  then_b = gfc_finish_block (&cond_block);\n+\n+  gfc_init_block (&cond_block);\n+  gfc_conv_descriptor_data_set (&cond_block, dest, null_pointer_node);\n+  else_b = gfc_finish_block (&cond_block);\n+\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t  fold_convert (pvoid_type_node,\n+\t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n+\t\t\t  null_pointer_node);\n+  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n+\t\t\t void_type_node, cond, then_b, else_b));\n \n   return gfc_finish_block (&block);\n }\n@@ -855,6 +868,21 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->final_expr)\n+    {\n+      tree final_var;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->final_expr);\n+      gfc_add_block_to_block (block, &se.pre);\n+      final_var = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_FINAL);\n+      OMP_CLAUSE_FINAL_EXPR (c) = final_var;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n   if (clauses->num_threads)\n     {\n       tree num_threads;\n@@ -948,6 +976,12 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->mergeable)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_MERGEABLE);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n   if (clauses->collapse)\n     {\n       c = build_omp_clause (where.lb->location, OMP_CLAUSE_COLLAPSE);\n@@ -990,35 +1024,85 @@ static tree gfc_trans_omp_workshare (gfc_code *, gfc_omp_clauses *);\n static tree\n gfc_trans_omp_atomic (gfc_code *code)\n {\n+  gfc_code *atomic_code = code;\n   gfc_se lse;\n   gfc_se rse;\n+  gfc_se vse;\n   gfc_expr *expr2, *e;\n   gfc_symbol *var;\n   stmtblock_t block;\n   tree lhsaddr, type, rhs, x;\n   enum tree_code op = ERROR_MARK;\n+  enum tree_code aop = OMP_ATOMIC;\n   bool var_on_left = false;\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n-  gcc_assert (code->next == NULL);\n   var = code->expr1->symtree->n.sym;\n \n   gfc_init_se (&lse, NULL);\n   gfc_init_se (&rse, NULL);\n+  gfc_init_se (&vse, NULL);\n   gfc_start_block (&block);\n \n-  gfc_conv_expr (&lse, code->expr1);\n-  gfc_add_block_to_block (&block, &lse.pre);\n-  type = TREE_TYPE (lse.expr);\n-  lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n-\n   expr2 = code->expr2;\n   if (expr2->expr_type == EXPR_FUNCTION\n       && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n     expr2 = expr2->value.function.actual->expr;\n \n-  if (expr2->expr_type == EXPR_OP)\n+  switch (atomic_code->ext.omp_atomic)\n+    {\n+    case GFC_OMP_ATOMIC_READ:\n+      gfc_conv_expr (&vse, code->expr1);\n+      gfc_add_block_to_block (&block, &vse.pre);\n+\n+      gfc_conv_expr (&lse, expr2);\n+      gfc_add_block_to_block (&block, &lse.pre);\n+      type = TREE_TYPE (lse.expr);\n+      lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n+\n+      x = build1 (OMP_ATOMIC_READ, type, lhsaddr);\n+      x = convert (TREE_TYPE (vse.expr), x);\n+      gfc_add_modify (&block, vse.expr, x);\n+\n+      gfc_add_block_to_block (&block, &lse.pre);\n+      gfc_add_block_to_block (&block, &rse.pre);\n+\n+      return gfc_finish_block (&block);\n+    case GFC_OMP_ATOMIC_CAPTURE:\n+      aop = OMP_ATOMIC_CAPTURE_NEW;\n+      if (expr2->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  aop = OMP_ATOMIC_CAPTURE_OLD;\n+\t  gfc_conv_expr (&vse, code->expr1);\n+\t  gfc_add_block_to_block (&block, &vse.pre);\n+\n+\t  gfc_conv_expr (&lse, expr2);\n+\t  gfc_add_block_to_block (&block, &lse.pre);\n+\t  gfc_init_se (&lse, NULL);\n+\t  code = code->next;\n+\t  var = code->expr1->symtree->n.sym;\n+\t  expr2 = code->expr2;\n+\t  if (expr2->expr_type == EXPR_FUNCTION\n+\t      && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n+\t    expr2 = expr2->value.function.actual->expr;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  gfc_conv_expr (&lse, code->expr1);\n+  gfc_add_block_to_block (&block, &lse.pre);\n+  type = TREE_TYPE (lse.expr);\n+  lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n+\n+  if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_WRITE)\n+    {\n+      gfc_conv_expr (&rse, expr2);\n+      gfc_add_block_to_block (&block, &rse.pre);\n+    }\n+  else if (expr2->expr_type == EXPR_OP)\n     {\n       gfc_expr *e;\n       switch (expr2->value.op.op)\n@@ -1134,25 +1218,55 @@ gfc_trans_omp_atomic (gfc_code *code)\n \n   lhsaddr = save_expr (lhsaddr);\n   rhs = gfc_evaluate_now (rse.expr, &block);\n-  x = convert (TREE_TYPE (rhs), build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t\t lhsaddr));\n \n-  if (var_on_left)\n-    x = fold_build2_loc (input_location, op, TREE_TYPE (rhs), x, rhs);\n+  if (atomic_code->ext.omp_atomic == GFC_OMP_ATOMIC_WRITE)\n+    x = rhs;\n   else\n-    x = fold_build2_loc (input_location, op, TREE_TYPE (rhs), rhs, x);\n+    {\n+      x = convert (TREE_TYPE (rhs),\n+\t\t   build_fold_indirect_ref_loc (input_location, lhsaddr));\n+      if (var_on_left)\n+\tx = fold_build2_loc (input_location, op, TREE_TYPE (rhs), x, rhs);\n+      else\n+\tx = fold_build2_loc (input_location, op, TREE_TYPE (rhs), rhs, x);\n+    }\n \n   if (TREE_CODE (TREE_TYPE (rhs)) == COMPLEX_TYPE\n       && TREE_CODE (type) != COMPLEX_TYPE)\n     x = fold_build1_loc (input_location, REALPART_EXPR,\n \t\t\t TREE_TYPE (TREE_TYPE (rhs)), x);\n \n-  x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n-  gfc_add_expr_to_block (&block, x);\n-\n   gfc_add_block_to_block (&block, &lse.pre);\n   gfc_add_block_to_block (&block, &rse.pre);\n \n+  if (aop == OMP_ATOMIC)\n+    {\n+      x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n+      gfc_add_expr_to_block (&block, x);\n+    }\n+  else\n+    {\n+      if (aop == OMP_ATOMIC_CAPTURE_NEW)\n+\t{\n+\t  code = code->next;\n+\t  expr2 = code->expr2;\n+\t  if (expr2->expr_type == EXPR_FUNCTION\n+\t      && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n+\t    expr2 = expr2->value.function.actual->expr;\n+\n+\t  gcc_assert (expr2->expr_type == EXPR_VARIABLE);\n+\t  gfc_conv_expr (&vse, code->expr1);\n+\t  gfc_add_block_to_block (&block, &vse.pre);\n+\n+\t  gfc_init_se (&lse, NULL);\n+\t  gfc_conv_expr (&lse, expr2);\n+\t  gfc_add_block_to_block (&block, &lse.pre);\n+\t}\n+      x = build2 (aop, type, lhsaddr, convert (type, x));\n+      x = convert (TREE_TYPE (vse.expr), x);\n+      gfc_add_modify (&block, vse.expr, x);\n+    }\n+\n   return gfc_finish_block (&block);\n }\n \n@@ -1628,6 +1742,13 @@ gfc_trans_omp_taskwait (void)\n   return build_call_expr_loc (input_location, decl, 0);\n }\n \n+static tree\n+gfc_trans_omp_taskyield (void)\n+{\n+  tree decl = built_in_decls [BUILT_IN_GOMP_TASKYIELD];\n+  return build_call_expr_loc (input_location, decl, 0);\n+}\n+\n static tree\n gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n {\n@@ -1821,6 +1942,8 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_task (code);\n     case EXEC_OMP_TASKWAIT:\n       return gfc_trans_omp_taskwait ();\n+    case EXEC_OMP_TASKYIELD:\n+      return gfc_trans_omp_taskyield ();\n     case EXEC_OMP_WORKSHARE:\n       return gfc_trans_omp_workshare (code, code->ext.omp_clauses);\n     default:"}, {"sha": "19f215cd54db8e9c923b84f25ad5fc25cda2e33c", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1410,6 +1410,7 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OMP_SINGLE:\n \tcase EXEC_OMP_TASK:\n \tcase EXEC_OMP_TASKWAIT:\n+\tcase EXEC_OMP_TASKYIELD:\n \tcase EXEC_OMP_WORKSHARE:\n \t  res = gfc_trans_omp_directive (code);\n \t  break;"}, {"sha": "27b20482876acf9455abede717b4865cbcad3a8e", "filename": "gcc/gimple.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -114,6 +114,7 @@ enum gf_mask {\n     GF_OMP_RETURN_NOWAIT\t= 1 << 0,\n \n     GF_OMP_SECTION_LAST\t\t= 1 << 0,\n+    GF_OMP_ATOMIC_NEED_VALUE\t= 1 << 0,\n     GF_PREDICT_TAKEN\t\t= 1 << 15\n };\n \n@@ -1634,6 +1635,29 @@ gimple_omp_parallel_set_combined_p (gimple g, bool combined_p)\n }\n \n \n+/* Return true if OMP atomic load/store statement G has the\n+   GF_OMP_ATOMIC_NEED_VALUE flag set.  */\n+\n+static inline bool\n+gimple_omp_atomic_need_value_p (const_gimple g)\n+{\n+  if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n+    GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n+  return (gimple_omp_subcode (g) & GF_OMP_ATOMIC_NEED_VALUE) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_ATOMIC_NEED_VALUE flag on G.  */\n+\n+static inline void\n+gimple_omp_atomic_set_need_value (gimple g)\n+{\n+  if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n+    GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n+  g->gsbase.subcode |= GF_OMP_ATOMIC_NEED_VALUE;\n+}\n+\n+\n /* Return the number of operands for statement GS.  */\n \n static inline unsigned"}, {"sha": "5376ca361bfdcbfe3f855c7751cce86ee9ce50e2", "filename": "gcc/gimplify.c", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -5932,6 +5932,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \t  OMP_CLAUSE_OPERAND (c, 0)\n \t    = gimple_boolify (OMP_CLAUSE_OPERAND (c, 0));\n@@ -5948,6 +5949,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tcase OMP_CLAUSE_DEFAULT:\n@@ -6088,6 +6090,8 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_FINAL:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tdefault:\n@@ -6490,24 +6494,45 @@ static enum gimplify_status\n gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n {\n   tree addr = TREE_OPERAND (*expr_p, 0);\n-  tree rhs = TREE_OPERAND (*expr_p, 1);\n+  tree rhs = TREE_CODE (*expr_p) == OMP_ATOMIC_READ\n+\t     ? NULL : TREE_OPERAND (*expr_p, 1);\n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n   tree tmp_load;\n+  gimple loadstmt, storestmt;\n \n-   tmp_load = create_tmp_reg (type, NULL);\n-   if (goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)\n-     return GS_ERROR;\n+  tmp_load = create_tmp_reg (type, NULL);\n+  if (rhs && goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)\n+    return GS_ERROR;\n+\n+  if (gimplify_expr (&addr, pre_p, NULL, is_gimple_val, fb_rvalue)\n+      != GS_ALL_DONE)\n+    return GS_ERROR;\n \n-   if (gimplify_expr (&addr, pre_p, NULL, is_gimple_val, fb_rvalue)\n-       != GS_ALL_DONE)\n-     return GS_ERROR;\n+  loadstmt = gimple_build_omp_atomic_load (tmp_load, addr);\n+  gimplify_seq_add_stmt (pre_p, loadstmt);\n+  if (rhs && gimplify_expr (&rhs, pre_p, NULL, is_gimple_val, fb_rvalue)\n+      != GS_ALL_DONE)\n+    return GS_ERROR;\n \n-   gimplify_seq_add_stmt (pre_p, gimple_build_omp_atomic_load (tmp_load, addr));\n-   if (gimplify_expr (&rhs, pre_p, NULL, is_gimple_val, fb_rvalue)\n-       != GS_ALL_DONE)\n-     return GS_ERROR;\n-   gimplify_seq_add_stmt (pre_p, gimple_build_omp_atomic_store (rhs));\n-   *expr_p = NULL;\n+  if (TREE_CODE (*expr_p) == OMP_ATOMIC_READ)\n+    rhs = tmp_load;\n+  storestmt = gimple_build_omp_atomic_store (rhs);\n+  gimplify_seq_add_stmt (pre_p, storestmt);\n+  switch (TREE_CODE (*expr_p))\n+    {\n+    case OMP_ATOMIC_READ:\n+    case OMP_ATOMIC_CAPTURE_OLD:\n+      *expr_p = tmp_load;\n+      gimple_omp_atomic_set_need_value (loadstmt);\n+      break;\n+    case OMP_ATOMIC_CAPTURE_NEW:\n+      *expr_p = rhs;\n+      gimple_omp_atomic_set_need_value (storestmt);\n+      break;\n+    default:\n+      *expr_p = NULL;\n+      break;\n+    }\n \n    return GS_ALL_DONE;\n }\n@@ -7230,6 +7255,9 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  }\n \n \tcase OMP_ATOMIC:\n+\tcase OMP_ATOMIC_READ:\n+\tcase OMP_ATOMIC_CAPTURE_OLD:\n+\tcase OMP_ATOMIC_CAPTURE_NEW:\n \t  ret = gimplify_omp_atomic (expr_p, pre_p);\n \t  break;\n "}, {"sha": "a56fa61d929b72112fb6cf62dac033711858fd67", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -37,6 +37,8 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_BARRIER, \"GOMP_barrier\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT, \"GOMP_taskwait\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKYIELD, \"GOMP_taskyield\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_START, \"GOMP_critical_start\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_END, \"GOMP_critical_end\","}, {"sha": "fbbef9c785cc7551b4e37f8e8db873d8a5e38931", "filename": "gcc/omp-low.c", "status": "modified", "additions": 124, "deletions": 16, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1443,6 +1443,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  ctx->default_kind = OMP_CLAUSE_DEFAULT_KIND (c);\n \t  break;\n \n+\tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n@@ -1454,6 +1455,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tdefault:\n@@ -1504,6 +1506,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_FINAL:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tdefault:\n@@ -3081,7 +3085,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n static void\n expand_task_call (basic_block bb, gimple entry_stmt)\n {\n-  tree t, t1, t2, t3, flags, cond, c, clauses;\n+  tree t, t1, t2, t3, flags, cond, c, c2, clauses;\n   gimple_stmt_iterator gsi;\n   location_t loc = gimple_location (entry_stmt);\n \n@@ -3094,7 +3098,19 @@ expand_task_call (basic_block bb, gimple entry_stmt)\n     cond = boolean_true_node;\n \n   c = find_omp_clause (clauses, OMP_CLAUSE_UNTIED);\n-  flags = build_int_cst (unsigned_type_node, (c ? 1 : 0));\n+  c2 = find_omp_clause (clauses, OMP_CLAUSE_MERGEABLE);\n+  flags = build_int_cst (unsigned_type_node,\n+\t\t\t (c ? 1 : 0) + (c2 ? 4 : 0));\n+\n+  c = find_omp_clause (clauses, OMP_CLAUSE_FINAL);\n+  if (c)\n+    {\n+      c = gimple_boolify (OMP_CLAUSE_FINAL_EXPR (c));\n+      c = fold_build3_loc (loc, COND_EXPR, unsigned_type_node, c,\n+\t\t\t   build_int_cst (unsigned_type_node, 2),\n+\t\t\t   build_int_cst (unsigned_type_node, 0));\n+      flags = fold_build2_loc (loc, PLUS_EXPR, unsigned_type_node, flags, c);\n+    }\n \n   gsi = gsi_last_bb (bb);\n   t = gimple_omp_task_data_arg (entry_stmt);\n@@ -4944,6 +4960,31 @@ expand_omp_synch (struct omp_region *region)\n     }\n }\n \n+/* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n+   operation as a normal volatile load.  */\n+\n+static bool\n+expand_omp_atomic_load (basic_block load_bb, tree addr, tree loaded_val)\n+{\n+  /* FIXME */\n+  (void) load_bb;\n+  (void) addr;\n+  (void) loaded_val;\n+  return false;\n+}\n+\n+/* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n+   operation as a normal volatile store.  */\n+\n+static bool\n+expand_omp_atomic_store (basic_block load_bb, tree addr)\n+{\n+  /* FIXME */\n+  (void) load_bb;\n+  (void) addr;\n+  return false;\n+}\n+\n /* A subroutine of expand_omp_atomic.  Attempt to implement the atomic\n    operation as a __sync_fetch_and_op builtin.  INDEX is log2 of the\n    size of the data type, and thus usable to find the index of the builtin\n@@ -4954,14 +4995,15 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n \t\t\t    tree addr, tree loaded_val,\n \t\t\t    tree stored_val, int index)\n {\n-  enum built_in_function base;\n+  enum built_in_function oldbase, newbase;\n   tree decl, itype, call;\n-  direct_optab optab;\n-  tree rhs;\n+  direct_optab optab, oldoptab, newoptab;\n+  tree lhs, rhs;\n   basic_block store_bb = single_succ (load_bb);\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n   location_t loc;\n+  bool need_old, need_new;\n \n   /* We expect to find the following sequences:\n \n@@ -4985,6 +5027,9 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   gsi_next (&gsi);\n   if (gimple_code (gsi_stmt (gsi)) != GIMPLE_OMP_ATOMIC_STORE)\n     return false;\n+  need_new = gimple_omp_atomic_need_value_p (gsi_stmt (gsi));\n+  need_old = gimple_omp_atomic_need_value_p (last_stmt (load_bb));\n+  gcc_checking_assert (!need_old || !need_new);\n \n   if (!operand_equal_p (gimple_assign_lhs (stmt), stored_val, 0))\n     return false;\n@@ -4994,24 +5039,39 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n     {\n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n-      base = BUILT_IN_SYNC_FETCH_AND_ADD_N;\n+      oldbase = BUILT_IN_SYNC_FETCH_AND_ADD_N;\n+      newbase = BUILT_IN_SYNC_ADD_AND_FETCH_N;\n       optab = sync_add_optab;\n+      oldoptab = sync_old_add_optab;\n+      newoptab = sync_new_add_optab;\n       break;\n     case MINUS_EXPR:\n-      base = BUILT_IN_SYNC_FETCH_AND_SUB_N;\n+      oldbase = BUILT_IN_SYNC_FETCH_AND_SUB_N;\n+      newbase = BUILT_IN_SYNC_SUB_AND_FETCH_N;\n       optab = sync_add_optab;\n+      oldoptab = sync_old_add_optab;\n+      newoptab = sync_new_add_optab;\n       break;\n     case BIT_AND_EXPR:\n-      base = BUILT_IN_SYNC_FETCH_AND_AND_N;\n+      oldbase = BUILT_IN_SYNC_FETCH_AND_AND_N;\n+      newbase = BUILT_IN_SYNC_AND_AND_FETCH_N;\n       optab = sync_and_optab;\n+      oldoptab = sync_old_and_optab;\n+      newoptab = sync_new_and_optab;\n       break;\n     case BIT_IOR_EXPR:\n-      base = BUILT_IN_SYNC_FETCH_AND_OR_N;\n+      oldbase = BUILT_IN_SYNC_FETCH_AND_OR_N;\n+      newbase = BUILT_IN_SYNC_OR_AND_FETCH_N;\n       optab = sync_ior_optab;\n+      oldoptab = sync_old_ior_optab;\n+      newoptab = sync_new_ior_optab;\n       break;\n     case BIT_XOR_EXPR:\n-      base = BUILT_IN_SYNC_FETCH_AND_XOR_N;\n+      oldbase = BUILT_IN_SYNC_FETCH_AND_XOR_N;\n+      newbase = BUILT_IN_SYNC_XOR_AND_FETCH_N;\n       optab = sync_xor_optab;\n+      oldoptab = sync_old_xor_optab;\n+      newoptab = sync_new_xor_optab;\n       break;\n     default:\n       return false;\n@@ -5025,20 +5085,49 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   else\n     return false;\n \n-  decl = built_in_decls[base + index + 1];\n+  decl = built_in_decls[(need_new ? newbase : oldbase) + index + 1];\n   if (decl == NULL_TREE)\n     return false;\n   itype = TREE_TYPE (TREE_TYPE (decl));\n \n-  if (direct_optab_handler (optab, TYPE_MODE (itype)) == CODE_FOR_nothing)\n+  if (need_new)\n+    {\n+      /* expand_sync_fetch_operation can always compensate when interested\n+\t in the new value.  */\n+      if (direct_optab_handler (newoptab, TYPE_MODE (itype))\n+\t  == CODE_FOR_nothing\n+\t  && direct_optab_handler (oldoptab, TYPE_MODE (itype))\n+\t     == CODE_FOR_nothing)\n+\treturn false;\n+    }\n+  else if (need_old)\n+    {\n+      /* When interested in the old value, expand_sync_fetch_operation\n+\t can compensate only if the operation is reversible.  AND and OR\n+\t are not reversible.  */\n+      if (direct_optab_handler (oldoptab, TYPE_MODE (itype))\n+\t  == CODE_FOR_nothing\n+\t  && (oldbase == BUILT_IN_SYNC_FETCH_AND_AND_N\n+\t      || oldbase == BUILT_IN_SYNC_FETCH_AND_OR_N\n+\t      || direct_optab_handler (newoptab, TYPE_MODE (itype))\n+\t\t == CODE_FOR_nothing))\n+\treturn false;\n+    }\n+  else if (direct_optab_handler (optab, TYPE_MODE (itype)) == CODE_FOR_nothing)\n     return false;\n \n   gsi = gsi_last_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_LOAD);\n-  call = build_call_expr_loc (loc,\n-\t\t\t  decl, 2, addr,\n-\t\t\t  fold_convert_loc (loc, itype, rhs));\n-  call = fold_convert_loc (loc, void_type_node, call);\n+  call = build_call_expr_loc (loc, decl, 2, addr,\n+\t\t\t      fold_convert_loc (loc, itype, rhs));\n+  if (need_old || need_new)\n+    {\n+      lhs = need_old ? loaded_val : stored_val;\n+      call = fold_convert_loc (loc, TREE_TYPE (lhs), call);\n+      call = build2_loc (loc, MODIFY_EXPR, void_type_node, lhs, call);\n+    }\n+  else\n+    call = fold_convert_loc (loc, void_type_node, call);\n   force_gimple_operand_gsi (&gsi, call, true, NULL_TREE, true, GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n \n@@ -5319,6 +5408,25 @@ expand_omp_atomic (struct omp_region *region)\n       /* __sync builtins require strict data alignment.  */\n       if (exact_log2 (align) >= index)\n \t{\n+\t  /* Atomic load.  FIXME: have some target hook signalize what loads\n+\t     are actually atomic?  */\n+\t  if (loaded_val == stored_val\n+\t      && (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT\n+\t\t  || GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT)\n+\t      && GET_MODE_BITSIZE (TYPE_MODE (type)) <= BITS_PER_WORD\n+\t      && expand_omp_atomic_load (load_bb, addr, loaded_val))\n+\t    return;\n+\n+\t  /* Atomic store.  FIXME: have some target hook signalize what\n+\t     stores are actually atomic?  */\n+\t  if ((GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT\n+\t       || GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT)\n+\t      && GET_MODE_BITSIZE (TYPE_MODE (type)) <= BITS_PER_WORD\n+\t      && store_bb == single_succ (load_bb)\n+\t      && first_stmt (store_bb) == store\n+\t      && expand_omp_atomic_store (load_bb, addr))\n+\t    return;\n+\n \t  /* When possible, use specialized atomic update functions.  */\n \t  if ((INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n \t      && store_bb == single_succ (load_bb))"}, {"sha": "fc949f94257436ed7dd831a4635eb30f321ebda6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,3 +1,16 @@\n+2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/46752\n+\t* gcc.dg/gomp/atomic-5.c: Adjust expected diagnostics.\n+\t* gcc.dg/gomp/atomic-15.c: New test.\n+\t* g++.dg/gomp/atomic-5.C: Adjust expected diagnostics.\n+\t* g++.dg/gomp/atomic-15.C: New test.\n+\t* g++.dg/gomp/private-1.C: New test.\n+\t* g++.dg/gomp/sharing-2.C: New test.\n+\t* gfortran.dg/gomp/crayptr1.f90: Don't expect error\n+\tabout Cray pointer in FIRSTPRIVATE/LASTPRIVATE.\n+\t* gfortran.dg/gomp/omp_atomic2.f90: New test.\n+\n 2011-08-02  Tobias Burnus  <burnus@net-b.de>\n \n \t* trim_optimize_5.f90: Remove spurious \"use foo\"."}, {"sha": "95eb8b4534d31db5ea4e71b60e90f9783cf29da4", "filename": "gcc/testsuite/g++.dg/gomp/atomic-15.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-15.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  int v;\n+  #pragma omp atomic\n+    x = x * 7 + 6;\t// { dg-error \"expected\" }\n+  #pragma omp atomic\n+    x = x * 7 ^ 6;\t// { dg-error \"expected\" }\n+  #pragma omp atomic update\n+    x = x - 8 + 6;\t// { dg-error \"expected\" }\n+  #pragma omp atomic\n+    x = x ^ 7 | 2;\t// { dg-error \"expected\" }\n+  #pragma omp atomic\n+    x = x / 7 * 2;\t// { dg-error \"expected\" }\n+  #pragma omp atomic\n+    x = x / 7 / 2;\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    v = x = x | 6;\t// { dg-error \"invalid operator\" }\n+  #pragma omp atomic capture\n+    { v = x; x = x * 7 + 6; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { v = x; x = x * 7 ^ 6; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { v = x; x = x - 8 + 6; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { v = x; x = x ^ 7 | 2; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { v = x; x = x / 7 * 2; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { v = x; x = x / 7 / 2; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { x = x * 7 + 6; v = x; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { x = x * 7 ^ 6; v = x; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { x = x - 8 + 6; v = x; }\t// { dg-error \"expected\" }\n+  #pragma omp atomic capture\n+    { x = x ^ 7 | 2; v = x; }\t// { dg-error \"expected\" }\n+  (void) v;\n+  return 0;\n+}"}, {"sha": "b277ebf3ddef6ab047418241ded987bc910a0226", "filename": "gcc/testsuite/g++.dg/gomp/atomic-5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -9,9 +9,9 @@ void f1(void)\n   #pragma omp atomic\n     x %= 2;\t\t/* { dg-error \"invalid operator\" } */\n   #pragma omp atomic\n-    x = x + 1;\t\t/* { dg-error \"invalid operator\" } */\n+    x = x + 1;\n   #pragma omp atomic\n-    x = 1;\t\t/* { dg-error \"invalid operator\" } */\n+    x = 1;\t\t/* { dg-error \"invalid form\" } */\n   #pragma omp atomic\n     ++y;\t\t/* { dg-error \"read-only variable\" } */\n   #pragma omp atomic"}, {"sha": "a048c60b8af950543b3da3b7295bb2c6601e87bc", "filename": "gcc/testsuite/g++.dg/gomp/clause-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -84,7 +84,7 @@ foo (int x)\n     ;\n #pragma omp p private (c) // { dg-error \"predetermined 'shared'\" }\n     ;\n-#pragma omp p firstprivate (c) // { dg-error \"predetermined 'shared'\" }\n+#pragma omp p firstprivate (c)\n     ;\n #pragma omp p for lastprivate (c) // { dg-error \"predetermined 'shared'\" }\n   for (i = 0; i < 10; i++)"}, {"sha": "09f15e39661d06d040b867f6a43aabc8d95512a7", "filename": "gcc/testsuite/g++.dg/gomp/private-1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fprivate-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fprivate-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fprivate-1.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct A { int i; A (); ~A (); };\n+struct B { int i; };\n+struct C { int i; mutable int j; C (); ~C (); };\n+\n+template <typename T> void bar (const T *);\n+\n+const A a;\n+const C c;\n+\n+const A foo (const A d, const C e)\n+{\n+  const A f;\n+  const B b = { 4 };\n+  A g;\n+  #pragma omp parallel private (a)\t// { dg-error \"predetermined\" }\n+    bar (&a);\n+  #pragma omp parallel private (b)\t// { dg-error \"predetermined\" }\n+    bar (&b);\n+  #pragma omp parallel private (c)\n+    bar (&c);\n+  #pragma omp parallel private (d)\t// { dg-error \"predetermined\" }\n+    bar (&d);\n+  #pragma omp parallel private (e)\n+    bar (&e);\n+  #pragma omp parallel private (f)\t// { dg-error \"predetermined\" }\n+    bar (&f);\n+  #pragma omp parallel private (g)\n+    bar (&g);\n+  return f;\n+}"}, {"sha": "6145b92fcf8183d05400ce35ac5349f66f2d4ff8", "filename": "gcc/testsuite/g++.dg/gomp/sharing-2.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-2.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile }\n+\n+struct T\n+{\n+  int i;\n+  mutable int j;\n+};\n+struct S\n+{\n+  const static int d = 1;\n+  const static T e;\n+  void foo (int, T);\n+};\n+\n+const int S::d;\n+const T S::e = { 2, 3 };\n+\n+void bar (const int &);\n+\n+void\n+S::foo (const int x, const T y)\n+{\n+  #pragma omp parallel firstprivate (x)\n+    bar (x);\n+  #pragma omp parallel firstprivate (d)\n+    bar (d);\n+  #pragma omp parallel firstprivate (y)\n+    bar (y.i);\n+  #pragma omp parallel firstprivate (e)\t// { dg-error \"is predetermined\" }\n+    bar (e.i);\n+  #pragma omp parallel shared (x)\t// { dg-error \"is predetermined\" }\n+    bar (x);\n+  #pragma omp parallel shared (d)\t// { dg-error \"is predetermined\" }\n+    bar (d);\n+  #pragma omp parallel shared (e)\t// { dg-error \"is predetermined\" }\n+    bar (e.i);\n+  #pragma omp parallel shared (y)\n+    bar (y.i);\n+  #pragma omp parallel private (x)\t// { dg-error \"is predetermined\" }\n+    bar (x);\n+  #pragma omp parallel private (d)\t// { dg-error \"is predetermined\" }\n+    bar (d);\n+  #pragma omp parallel private (y)\n+    bar (y.i);\n+  #pragma omp parallel private (e)\t// { dg-error \"is predetermined\" }\n+    bar (e.i);\n+}"}, {"sha": "13a9e0ce48a15a8d911fd26648968b55f7e213a7", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-15.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-15.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  int v;\n+  #pragma omp atomic\n+    x = x * 7 + 6;\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic\n+    x = x * 7 ^ 6;\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic update\n+    x = x - 8 + 6;\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic\n+    x = x ^ 7 | 2;\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic\n+    x = x / 7 * 2;\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic\n+    x = x / 7 / 2;\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    v = x = x | 6;\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic capture\n+    { v = x; x = x * 7 + 6; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { v = x; x = x * 7 ^ 6; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { v = x; x = x - 8 + 6; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { v = x; x = x ^ 7 | 2; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { v = x; x = x / 7 * 2; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { v = x; x = x / 7 / 2; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { x = x * 7 + 6; v = x; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { x = x * 7 ^ 6; v = x; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { x = x - 8 + 6; v = x; }\t/* { dg-error \"expected\" } */\n+  #pragma omp atomic capture\n+    { x = x ^ 7 | 2; v = x; }\t/* { dg-error \"expected\" } */\n+  (void) v;\n+  return 0;\n+}"}, {"sha": "0ad9d3b48c26bda90231d93e6354c9e24cd20c2d", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -11,9 +11,9 @@ void f1(void)\n   #pragma omp atomic\n     x %= 2;\t\t/* { dg-error \"invalid operator\" } */\n   #pragma omp atomic\n-    x = x + 1;\t\t/* { dg-error \"invalid operator\" } */\n+    x = x + 1;\n   #pragma omp atomic\n-    x = 1;\t\t/* { dg-error \"invalid operator\" } */\n+    x = 1;\t\t/* { dg-error \"invalid form\" } */\n   #pragma omp atomic\n     ++y;\t\t/* { dg-error \"read-only variable\" } */\n   #pragma omp atomic"}, {"sha": "ba189896c62701ff832d75a9c3576851c377be6d", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -84,7 +84,7 @@ foo (int x)\n     ;\n #pragma omp p private (c) /* { dg-error \"predetermined 'shared'\" } */\n     ;\n-#pragma omp p firstprivate (c) /* { dg-error \"predetermined 'shared'\" } */\n+#pragma omp p firstprivate (c)\n     ;\n #pragma omp p for lastprivate (c) /* { dg-error \"predetermined 'shared'\" } */\n   for (i = 0; i < 10; i++)"}, {"sha": "d246e8f04cf0bb3f0d27361f9e47423b2e15e06b", "filename": "gcc/testsuite/gfortran.dg/gomp/crayptr1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr1.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -36,10 +36,10 @@\n !$omp end parallel\n \n   ip3 = loc (i)\n-!$omp parallel firstprivate (ip3) ! { dg-error \"Cray pointer 'ip3' in FIRSTPRIVATE clause\" }\n+!$omp parallel firstprivate (ip3)\n !$omp end parallel\n \n-!$omp parallel do lastprivate (ip4) ! { dg-error \"Cray pointer 'ip4' in LASTPRIVATE clause\" }\n+!$omp parallel do lastprivate (ip4)\n   do i = 1, 10\n     if (i .eq. 10) ip4 = loc (i)\n   end do"}, {"sha": "7dcfe414120bc7f1588deb33b636aed55e71e97d", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_atomic2.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_atomic2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_atomic2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_atomic2.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,54 @@\n+  real :: r1, r2\n+  complex :: c1, c2\n+  integer :: i1, i2\n+!$omp atomic write\n+  c1 = 0\n+!$omp atomic write\n+  r2 = 0\n+!$omp atomic write\n+  i2 = 0\n+!$omp atomic read\n+  r1 = c1\n+!$omp atomic read\n+  c2 = r2\n+!$omp atomic read\n+  i1 = r2\n+!$omp atomic read\n+  c2 = i2\n+!$omp atomic write\n+  c1 = r1\n+!$omp atomic write\n+  r2 = c2\n+!$omp atomic write\n+  r2 = i1\n+!$omp atomic write\n+  i2 = c2\n+!$omp end atomic\n+!$omp atomic write\n+  c1 = 1 + 2 + r1\n+!$omp atomic write\n+  r2 = c2 + 2 + 3\n+!$omp atomic write\n+  r2 = 3 + 4 + i1\n+!$omp atomic write\n+  i2 = c2 + 4 + 5\n+!$omp atomic\n+  c1 = c1 * 2.\n+!$omp atomic update\n+  r2 = r2 / 4\n+!$omp end atomic\n+!$omp atomic update\n+  i2 = i2 + 8\n+!$omp atomic capture\n+  c1 = c1 * 2.\n+  r1 = c1\n+!$omp end atomic\n+!$omp atomic capture\n+  c2 = r2\n+  r2 = r2 / 4\n+!$omp end atomic\n+!$omp atomic capture\n+  i2 = i2 + 8\n+  c2 = i2\n+!$omp end atomic\n+end"}, {"sha": "ef51ff48882e89f9109feba259bdef1271ddbd4d", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1097,6 +1097,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t  if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause) == NULL)\n \t    break;\n \t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \t  wi->val_only = true;\n@@ -1111,6 +1112,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tdefault:\n@@ -1594,6 +1596,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t  if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause) == NULL)\n \t    break;\n \t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \t  wi->val_only = true;\n@@ -1608,6 +1611,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  break;\n \n \tdefault:"}, {"sha": "e24c7866208ff0831d2751946319bca0990eac93", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -421,6 +421,17 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_character (buffer, ')');\n       break;\n \n+    case OMP_CLAUSE_FINAL:\n+      pp_string (buffer, \"final(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_FINAL_EXPR (clause),\n+\t  spc, flags, false);\n+      pp_character (buffer, ')');\n+      break;\n+\n+    case OMP_CLAUSE_MERGEABLE:\n+      pp_string (buffer, \"mergeable\");\n+      break;\n+\n     default:\n       /* Should never happen.  */\n       dump_generic_node (buffer, clause, spc, flags, false);\n@@ -2208,6 +2219,24 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n       break;\n \n+    case OMP_ATOMIC_READ:\n+      pp_string (buffer, \"#pragma omp atomic read\");\n+      newline_and_indent (buffer, spc + 2);\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_space (buffer);\n+      break;\n+\n+    case OMP_ATOMIC_CAPTURE_OLD:\n+    case OMP_ATOMIC_CAPTURE_NEW:\n+      pp_string (buffer, \"#pragma omp atomic capture\");\n+      newline_and_indent (buffer, spc + 2);\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_space (buffer);\n+      pp_character (buffer, '=');\n+      pp_space (buffer);\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      break;\n+\n     case OMP_SINGLE:\n       pp_string (buffer, \"#pragma omp single\");\n       dump_omp_clauses (buffer, OMP_SINGLE_CLAUSES (node), spc, flags);"}, {"sha": "d20751a9c7b055eeb8f4901aad729954cf3e956b", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -247,7 +247,9 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_ORDERED  */\n   0, /* OMP_CLAUSE_DEFAULT  */\n   3, /* OMP_CLAUSE_COLLAPSE  */\n-  0  /* OMP_CLAUSE_UNTIED   */\n+  0, /* OMP_CLAUSE_UNTIED   */\n+  1, /* OMP_CLAUSE_FINAL  */\n+  0  /* OMP_CLAUSE_MERGEABLE  */\n };\n \n const char * const omp_clause_code_name[] =\n@@ -267,7 +269,9 @@ const char * const omp_clause_code_name[] =\n   \"ordered\",\n   \"default\",\n   \"collapse\",\n-  \"untied\"\n+  \"untied\",\n+  \"final\",\n+  \"mergeable\"\n };\n \n \n@@ -10546,6 +10550,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n+\tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n@@ -10556,6 +10561,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_MERGEABLE:\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n \tcase OMP_CLAUSE_LASTPRIVATE:"}, {"sha": "d4b3cb98d6e3279083dd0a54b84c6b1c5e5ea160", "filename": "gcc/tree.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1040,6 +1040,22 @@ DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n \tbuild_fold_indirect_ref of the address.  */\n DEFTREECODE (OMP_ATOMIC, \"omp_atomic\", tcc_statement, 2)\n \n+/* OpenMP - #pragma omp atomic read\n+   Operand 0: The address at which the atomic operation is to be performed.\n+\tThis address should be stabilized with save_expr.  */\n+DEFTREECODE (OMP_ATOMIC_READ, \"omp_atomic_read\", tcc_statement, 1)\n+\n+/* OpenMP - #pragma omp atomic capture\n+   Operand 0: The address at which the atomic operation is to be performed.\n+\tThis address should be stabilized with save_expr.\n+   Operand 1: The expression to evaluate.  When the old value of the object\n+\tat the address is used in the expression, it should appear as if\n+\tbuild_fold_indirect_ref of the address.\n+   OMP_ATOMIC_CAPTURE_OLD returns the old memory content,\n+   OMP_ATOMIC_CAPTURE_NEW the new value.  */\n+DEFTREECODE (OMP_ATOMIC_CAPTURE_OLD, \"omp_atomic_capture_old\", tcc_statement, 2)\n+DEFTREECODE (OMP_ATOMIC_CAPTURE_NEW, \"omp_atomic_capture_new\", tcc_statement, 2)\n+\n /* OpenMP clauses.  */\n DEFTREECODE (OMP_CLAUSE, \"omp_clause\", tcc_exceptional, 0)\n "}, {"sha": "6b13a2a5c51e05628690b87168f453cf6f368d2a", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -403,7 +403,13 @@ enum omp_clause_code\n   OMP_CLAUSE_COLLAPSE,\n \n   /* OpenMP clause: untied.  */\n-  OMP_CLAUSE_UNTIED\n+  OMP_CLAUSE_UNTIED,\n+\n+  /* OpenMP clause: final (scalar-expression).  */\n+  OMP_CLAUSE_FINAL,\n+\n+  /* OpenMP clause: mergeable.  */\n+  OMP_CLAUSE_MERGEABLE\n };\n \f\n /* The definition of tree nodes fills the next several pages.  */\n@@ -1879,6 +1885,8 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ(NODE) \\\n   (OMP_CLAUSE_CHECK (NODE))->omp_clause.gimple_reduction_init\n \n+#define OMP_CLAUSE_FINAL_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FINAL), 0)\n #define OMP_CLAUSE_IF_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF), 0)\n #define OMP_CLAUSE_NUM_THREADS_EXPR(NODE) \\"}, {"sha": "b26dcd54cd670bc8178676d9c2f745d2edecc8ad", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,3 +1,74 @@\n+2011-08-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/42041\n+\tPR fortran/46752\n+\t* omp.h.in (omp_in_final): New prototype.\n+\t* omp_lib.f90.in (omp_in_final): New interface.\n+\t(omp_integer_kind, omp_logical_kind): Remove\n+\tand replace all its uses in the module with 4.\n+\t(openmp_version): Change to 201107.\n+\t* omp_lib.h.in (omp_sched_static, omp_sched_dynamic,\n+\tomp_sched_guided, omp_sched_auto): Use omp_sched_kind\n+\tkind for the parameters.\n+\t(omp_in_final): New external.\n+\t(openmp_version): Change to 201107.\n+\t* task.c (omp_in_final): New function.\n+\t(gomp_init_task): Initialize final_task.\n+\t(GOMP_task): Remove unused attribute from flags.  Handle final\n+\ttasks.\n+\t(GOMP_taskyield): New function.\n+\t(omp_in_final): Return true if if (false) or final (true) task\n+\tor descendant of final (true).\n+\t* fortran.c (omp_in_final_): New function.\n+\t* libgomp.map (OMP_3.1): Export omp_in_final and omp_in_final_.\n+\t(GOMP_3.0): Export GOMP_taskyield.\n+\t* env.c (gomp_nthreads_var_list, gomp_nthreads_var_list_len): New\n+\tvariables.\n+\t(parse_unsigned_long_list): New function.\n+\t(initialize_env): Use it for OMP_NUM_THREADS.  Call parse_boolean\n+\twith \"OMP_PROC_BIND\".  If OMP_PROC_BIND=true, call gomp_init_affinity\n+\teven if parse_affinity returned false.\n+\t* config/linux/affinity.c (gomp_init_affinity): Handle\n+\tgomp_cpu_affinity_len == 0.\n+\t* libgomp_g.h (GOMP_taskyield): New prototype.\n+\t* libgomp.h (struct gomp_task): Add final_task field.\n+\t(gomp_nthreads_var_list, gomp_nthreads_var_list_len): New externs.\n+\t* team.c (gomp_team_start): Override new task's nthreads_var icv\n+\tif list form OMP_NUM_THREADS has been used and it has value for\n+\tthe new nesting level.\n+\n+\t* testsuite/libgomp.c/atomic-11.c: New test.\n+\t* testsuite/libgomp.c/atomic-12.c: New test.\n+\t* testsuite/libgomp.c/atomic-13.c: New test.\n+\t* testsuite/libgomp.c/atomic-14.c: New test.\n+\t* testsuite/libgomp.c/reduction-6.c: New test.\n+\t* testsuite/libgomp.c/task-5.c: New test.\n+\t* testsuite/libgomp.c++/atomic-2.C: New test.\n+\t* testsuite/libgomp.c++/atomic-3.C: New test.\n+\t* testsuite/libgomp.c++/atomic-4.C: New test.\n+\t* testsuite/libgomp.c++/atomic-5.C: New test.\n+\t* testsuite/libgomp.c++/atomic-6.C: New test.\n+\t* testsuite/libgomp.c++/atomic-7.C: New test.\n+\t* testsuite/libgomp.c++/atomic-8.C: New test.\n+\t* testsuite/libgomp.c++/atomic-9.C: New test.\n+\t* testsuite/libgomp.c++/task-8.C: New test.\n+\t* testsuite/libgomp.c++/reduction-4.C: New test.\n+\t* testsuite/libgomp.fortran/allocatable7.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable8.f90: New test.\n+\t* testsuite/libgomp.fortran/crayptr3.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_atomic3.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_atomic4.f90: New test.\n+\t* testsuite/libgomp.fortran/pointer1.f90: New test.\n+\t* testsuite/libgomp.fortran/pointer2.f90: New test.\n+\t* testsuite/libgomp.fortran/task4.f90: New test.\n+\n+2011-08-02  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* libgomp.texi: Update OpenMP spec references to 3.1.\n+\t(omp_in_final,OMP_PROC_BIND): New sections.\n+\t(OMP_NUM_THREADS): Document that the value can be now a list.\n+\t(GOMP_STACKSIZE,GOMP_CPU_AFFINITY): Update @ref.\n+\n 2011-08-02  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/linux/x86/futex.h: Check __x86_64__ instead of"}, {"sha": "d8d575628ff487adff150528380e312d90bf846f", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -53,17 +54,36 @@ gomp_init_affinity (void)\n     }\n \n   CPU_ZERO (&cpusetnew);\n-  for (widx = idx = 0; idx < gomp_cpu_affinity_len; idx++)\n-    if (gomp_cpu_affinity[idx] < CPU_SETSIZE\n-        && CPU_ISSET (gomp_cpu_affinity[idx], &cpuset))\n-      {\n-\tif (! CPU_ISSET (gomp_cpu_affinity[idx], &cpusetnew))\n+  if (gomp_cpu_affinity_len == 0)\n+    {\n+      unsigned long count = CPU_COUNT (&cpuset);\n+      if (count >= 65536)\n+\tcount = 65536;\n+      gomp_cpu_affinity = malloc (count * sizeof (unsigned short));\n+      if (gomp_cpu_affinity == NULL)\n+\t{\n+\t  gomp_error (\"not enough memory to store CPU affinity list\");\n+\t  return;\n+\t}\n+      for (widx = idx = 0; widx < count && idx < 65536; idx++)\n+\tif (CPU_ISSET (idx, &cpuset))\n \t  {\n \t    cpus++;\n-\t    CPU_SET (gomp_cpu_affinity[idx], &cpusetnew);\n+\t    gomp_cpu_affinity[widx++] = idx;\n \t  }\n-\tgomp_cpu_affinity[widx++] = gomp_cpu_affinity[idx];\n-      }\n+    }\n+  else\n+    for (widx = idx = 0; idx < gomp_cpu_affinity_len; idx++)\n+      if (gomp_cpu_affinity[idx] < CPU_SETSIZE\n+\t  && CPU_ISSET (gomp_cpu_affinity[idx], &cpuset))\n+\t{\n+\t  if (! CPU_ISSET (gomp_cpu_affinity[idx], &cpusetnew))\n+\t    {\n+\t      cpus++;\n+\t      CPU_SET (gomp_cpu_affinity[idx], &cpusetnew);\n+\t    }\n+\t  gomp_cpu_affinity[widx++] = gomp_cpu_affinity[idx];\n+\t}\n \n   if (widx == 0)\n     {"}, {"sha": "aff7490a8b71f6b2d6321f3df3501c9a61919b87", "filename": "libgomp/env.c", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -67,6 +67,7 @@ gomp_mutex_t gomp_remaining_threads_lock;\n #endif\n unsigned long gomp_available_cpus = 1, gomp_managed_threads = 1;\n unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n+unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n \n /* Parse the OMP_SCHEDULE environment variable.  */\n \n@@ -184,6 +185,95 @@ parse_unsigned_long (const char *name, unsigned long *pvalue, bool allow_zero)\n   return false;\n }\n \n+/* Parse an unsigned long list environment variable.  Return true if one was\n+   present and it was successfully parsed.  */\n+\n+static bool\n+parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n+\t\t\t  unsigned long **pvalues,\n+\t\t\t  unsigned long *pnvalues)\n+{\n+  char *env, *end;\n+  unsigned long value, *values = NULL;\n+\n+  env = getenv (name);\n+  if (env == NULL)\n+    return false;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '\\0')\n+    goto invalid;\n+\n+  errno = 0;\n+  value = strtoul (env, &end, 10);\n+  if (errno || (long) value <= 0)\n+    goto invalid;\n+\n+  while (isspace ((unsigned char) *end))\n+    ++end;\n+  if (*end != '\\0')\n+    {\n+      if (*end == ',')\n+\t{\n+\t  unsigned long nvalues = 0, nalloced = 0;\n+\n+\t  do\n+\t    {\n+\t      env = end + 1;\n+\t      if (nvalues == nalloced)\n+\t\t{\n+\t\t  unsigned long *n;\n+\t\t  nalloced = nalloced ? nalloced * 2 : 16;\n+\t\t  n = realloc (values, nalloced * sizeof (unsigned long));\n+\t\t  if (n == NULL)\n+\t\t    {\n+\t\t      free (values);\n+\t\t      gomp_error (\"Out of memory while trying to parse\"\n+\t\t\t\t  \" environment variable %s\", name);\n+\t\t      return false;\n+\t\t    }\n+\t\t  values = n;\n+\t\t  if (nvalues == 0)\n+\t\t    values[nvalues++] = value;\n+\t\t}\n+\n+\t      while (isspace ((unsigned char) *env))\n+\t\t++env;\n+\t      if (*env == '\\0')\n+\t\tgoto invalid;\n+\n+\t      errno = 0;\n+\t      value = strtoul (env, &end, 10);\n+\t      if (errno || (long) value <= 0)\n+\t\tgoto invalid;\n+\n+\t      values[nvalues++] = value;\n+\t      while (isspace ((unsigned char) *end))\n+\t\t++end;\n+\t      if (*end == '\\0')\n+\t\tbreak;\n+\t      if (*end != ',')\n+\t\tgoto invalid;\n+\t    }\n+\t  while (1);\n+\t  *p1stvalue = values[0];\n+\t  *pvalues = values;\n+\t  *pnvalues = nvalues;\n+\t  return true;\n+\t}\n+      goto invalid;\n+    }\n+\n+  *p1stvalue = value;\n+  return true;\n+\n+ invalid:\n+  free (values);\n+  gomp_error (\"Invalid value for environment variable %s\", name);\n+  return false;\n+}\n+\n /* Parse the OMP_STACKSIZE environment varible.  Return true if one was\n    present and it was successfully parsed.  */\n \n@@ -481,13 +571,15 @@ initialize_env (void)\n {\n   unsigned long stacksize;\n   int wait_policy;\n+  bool bind_var = false;\n \n   /* Do a compile time check that mkomp_h.pl did good job.  */\n   omp_check_defines ();\n \n   parse_schedule ();\n   parse_boolean (\"OMP_DYNAMIC\", &gomp_global_icv.dyn_var);\n   parse_boolean (\"OMP_NESTED\", &gomp_global_icv.nest_var);\n+  parse_boolean (\"OMP_PROC_BIND\", &bind_var);\n   parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\", &gomp_max_active_levels_var,\n \t\t       true);\n   parse_unsigned_long (\"OMP_THREAD_LIMIT\", &gomp_thread_limit_var, false);\n@@ -498,10 +590,12 @@ initialize_env (void)\n #endif\n   gomp_init_num_threads ();\n   gomp_available_cpus = gomp_global_icv.nthreads_var;\n-  if (!parse_unsigned_long (\"OMP_NUM_THREADS\", &gomp_global_icv.nthreads_var,\n-\t\t\t    false))\n+  if (!parse_unsigned_long_list (\"OMP_NUM_THREADS\",\n+\t\t\t\t &gomp_global_icv.nthreads_var,\n+\t\t\t\t &gomp_nthreads_var_list,\n+\t\t\t\t &gomp_nthreads_var_list_len))\n     gomp_global_icv.nthreads_var = gomp_available_cpus;\n-  if (parse_affinity ())\n+  if (parse_affinity () || bind_var)\n     gomp_init_affinity ();\n   wait_policy = parse_wait_policy ();\n   if (!parse_spincount (\"GOMP_SPINCOUNT\", &gomp_spin_count_var))"}, {"sha": "de806f8aba4a001131445fcbd78da88b6481baa4", "filename": "libgomp/fortran.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -69,6 +69,7 @@ ialias_redirect (omp_get_level)\n ialias_redirect (omp_get_ancestor_thread_num)\n ialias_redirect (omp_get_team_size)\n ialias_redirect (omp_get_active_level)\n+ialias_redirect (omp_in_final)\n #endif\n \n #ifndef LIBGOMP_GNU_SYMBOL_VERSIONING\n@@ -428,3 +429,9 @@ omp_get_active_level_ (void)\n {\n   return omp_get_active_level ();\n }\n+\n+int32_t\n+omp_in_final_ (void)\n+{\n+  return omp_in_final ();\n+}"}, {"sha": "9cf9d3221c5ee2d481d8c14ec4709fd5551a1524", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -226,6 +227,7 @@ extern gomp_mutex_t gomp_remaining_threads_lock;\n extern unsigned long gomp_max_active_levels_var;\n extern unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n extern unsigned long gomp_available_cpus, gomp_managed_threads;\n+extern unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n \n enum gomp_task_kind\n {\n@@ -251,6 +253,7 @@ struct gomp_task\n   enum gomp_task_kind kind;\n   bool in_taskwait;\n   bool in_tied_task;\n+  bool final_task;\n   gomp_sem_t taskwait_sem;\n };\n "}, {"sha": "7b051f96aabb2e4ba61a34ec03ba48d5cd6baff9", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -107,6 +107,12 @@ OMP_3.0 {\n \tomp_unset_nest_lock_;\n } OMP_2.0;\n \n+OMP_3.1 {\n+  global:\n+\tomp_in_final;\n+\tomp_in_final_;\n+} OMP_3.0;\n+\n GOMP_1.0 {\n   global:\n \tGOMP_atomic_end;\n@@ -173,3 +179,8 @@ GOMP_2.0 {\n \tGOMP_loop_ull_static_next;\n \tGOMP_loop_ull_static_start;\n } GOMP_1.0;\n+\n+GOMP_3.0 {\n+  global:\n+\tGOMP_taskyield;\n+} GOMP_2.0;"}, {"sha": "29c078b668e8f1fa67c4d150745719cea2984c52", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 103, "deletions": 58, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -116,7 +116,7 @@ arranges for automatic linking of the OpenMP runtime library\n \n A complete description of all OpenMP directives accepted may be found in \n the @uref{http://www.openmp.org, OpenMP Application Program Interface} manual,\n-version 3.0.\n+version 3.1.\n \n \n @c ---------------------------------------------------------------------\n@@ -127,7 +127,7 @@ version 3.0.\n @chapter Runtime Library Routines\n \n The runtime routines described here are defined by section 3 of the OpenMP \n-specifications in version 3.0. The routines are structured in following\n+specifications in version 3.1. The routines are structured in following\n three parts:\n \n Control threads, processors and the parallel environment.\n@@ -147,6 +147,7 @@ Control threads, processors and the parallel environment.\n * omp_get_thread_limit::        Maximum number of threads\n * omp_get_thread_num::          Current thread ID\n * omp_in_parallel::             Whether a parallel region is active\n+* omp_in_final::                Whether in final or included task region\n * omp_set_dynamic::             Enable/disable dynamic teams\n * omp_set_max_active_levels::   Limits the number of active parallel regions\n * omp_set_nested::              Enable/disable nested parallel regions\n@@ -199,7 +200,7 @@ which enclose the calling call.\n @ref{omp_get_level}, @ref{omp_get_max_active_levels}, @ref{omp_set_max_active_levels}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.19.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.19.\n @end table\n \n \n@@ -228,7 +229,7 @@ zero to @code{omp_get_level} -1 is returned; if @var{level} is\n @ref{omp_get_level}, @ref{omp_get_thread_num}, @ref{omp_get_team_size}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.17.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.17.\n @end table\n \n \n@@ -260,7 +261,7 @@ disabled by default.\n @ref{omp_set_dynamic}, @ref{OMP_DYNAMIC}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.8.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.8.\n @end table\n \n \n@@ -286,7 +287,7 @@ which enclose the calling call.\n @ref{omp_get_active_level}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.16.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.16.\n @end table\n \n \n@@ -311,7 +312,7 @@ This function obtains the maximum allowed number of nested, active parallel regi\n @ref{omp_set_max_active_levels}, @ref{omp_get_active_level}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.14.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.15.\n @end table\n \n \n@@ -337,7 +338,7 @@ that does not use the clause @code{num_threads}.\n @ref{omp_set_num_threads}, @ref{omp_set_dynamic}, @ref{omp_get_thread_limit}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.3.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.3.\n @end table\n \n \n@@ -369,7 +370,7 @@ disabled by default.\n @ref{omp_set_nested}, @ref{OMP_NESTED}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.10.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.10.\n @end table\n \n \n@@ -391,7 +392,7 @@ Returns the number of processors online.\n @end multitable\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.5.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.5.\n @end table\n \n \n@@ -424,7 +425,7 @@ one thread per CPU online is used.\n @ref{omp_get_max_threads}, @ref{omp_set_num_threads}, @ref{OMP_NUM_THREADS}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.2.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.2.\n @end table\n \n \n@@ -440,7 +441,7 @@ set to the value @code{omp_sched_static}, @code{omp_sched_dynamic},\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{omp_schedule(omp_sched_t *kind, int *modifier);}\n+@item @emph{Prototype}: @tab @code{void omp_schedule(omp_sched_t *kind, int *modifier);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -454,7 +455,7 @@ set to the value @code{omp_sched_static}, @code{omp_sched_dynamic},\n @ref{omp_set_schedule}, @ref{OMP_SCHEDULE}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.12.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.12.\n @end table\n \n \n@@ -484,7 +485,7 @@ to @code{omp_get_num_threads}.\n @ref{omp_get_num_threads}, @ref{omp_get_level}, @ref{omp_get_ancestor_thread_num}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.18.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.18.\n @end table\n \n \n@@ -509,7 +510,7 @@ Return the maximum number of threads of the program.\n @ref{omp_get_max_threads}, @ref{OMP_THREAD_LIMIT}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.13.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.13.\n @end table\n \n \n@@ -538,7 +539,7 @@ value of the master thread of a team is always 0.\n @ref{omp_get_num_threads}, @ref{omp_get_ancestor_thread_num}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.4.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.4.\n @end table\n \n \n@@ -562,7 +563,30 @@ their language-specific counterparts.\n @end multitable\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.6.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.6.\n+@end table\n+\n+\n+@node omp_in_final\n+@section @code{omp_in_final} -- Whether in final or included task region\n+@table @asis\n+@item @emph{Description}:\n+This function returns @code{true} if currently running in a final\n+or included task region, @code{false} otherwise. Here, @code{true}\n+and @code{false} represent their language-specific counterparts.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_in_final(void);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{logical function omp_in_final()}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.20.\n @end table\n \n \n@@ -590,7 +614,7 @@ adjustment of team sizes and @code{false} disables it.\n @ref{OMP_DYNAMIC}, @ref{omp_get_dynamic}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.7.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.7.\n @end table\n \n \n@@ -617,7 +641,7 @@ parallel regions.\n @ref{omp_get_max_active_levels}, @ref{omp_get_active_level}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.14.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.14.\n @end table\n \n \n@@ -646,7 +670,7 @@ dynamic adjustment of team sizes and @code{false} disables it.\n @ref{OMP_NESTED}, @ref{omp_get_nested}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.9.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.9.\n @end table\n \n \n@@ -674,7 +698,7 @@ argument of @code{omp_set_num_threads} shall be a positive integer.\n @ref{OMP_NUM_THREADS}, @ref{omp_get_num_threads}, @ref{omp_get_max_threads}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.1.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.1.\n @end table\n \n \n@@ -692,7 +716,7 @@ For @code{omp_sched_auto} the @var{modifier} argument is ignored.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_set_schedule(omp_sched_t *kind, int *modifier);}\n+@item @emph{Prototype}: @tab @code{void omp_set_schedule(omp_sched_t *kind, int *modifier);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -707,7 +731,7 @@ For @code{omp_sched_auto} the @var{modifier} argument is ignored.\n @ref{OMP_SCHEDULE}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.2.11.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.2.11.\n @end table\n \n \n@@ -734,7 +758,7 @@ an unlocked state.\n @ref{omp_destroy_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.1.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.1.\n @end table\n \n \n@@ -763,7 +787,7 @@ a deadlock occurs.\n @ref{omp_init_lock}, @ref{omp_test_lock}, @ref{omp_unset_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.3.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.3.\n @end table\n \n \n@@ -785,16 +809,15 @@ does not block if the lock is not available. This function returns\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_test_lock(lock)}\n-@item                   @tab @code{logical(omp_logical_kind) :: omp_test_lock}\n+@item @emph{Interface}: @tab @code{logical function omp_test_lock(lock)}\n @item                   @tab @code{integer(omp_lock_kind), intent(inout) :: lock}\n @end multitable\n \n @item @emph{See also}:\n @ref{omp_init_lock}, @ref{omp_set_lock}, @ref{omp_set_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.5.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.5.\n @end table\n \n \n@@ -807,7 +830,7 @@ A simple lock about to be unset must have been locked by @code{omp_set_lock}\n or @code{omp_test_lock} before. In addition, the lock must be held by the \n thread calling @code{omp_unset_lock}. Then, the lock becomes unlocked. If one \n or more threads attempted to set the lock before, one of them is chosen to, \n-again, set the lock for itself.\n+again, set the lock to itself.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n@@ -824,7 +847,7 @@ again, set the lock for itself.\n @ref{omp_set_lock}, @ref{omp_test_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.4.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.4.\n @end table\n \n \n@@ -851,7 +874,7 @@ in the unlocked state.\n @ref{omp_init_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.2.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.2.\n @end table\n \n \n@@ -878,7 +901,7 @@ an unlocked state and the nesting count is set to zero.\n @ref{omp_destroy_nest_lock}\n \n @item @emph{Reference}:\n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.1.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.1.\n @end table\n \n \n@@ -889,7 +912,7 @@ an unlocked state and the nesting count is set to zero.\n Before setting a nested lock, the lock variable must be initialized by \n @code{omp_init_nest_lock}. The calling thread is blocked until the lock \n is available. If the lock is already held by the current thread, the \n-nesting count for the lock in incremented.\n+nesting count for the lock is incremented.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n@@ -906,7 +929,7 @@ nesting count for the lock in incremented.\n @ref{omp_init_nest_lock}, @ref{omp_unset_nest_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.3.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.3.\n @end table\n \n \n@@ -928,8 +951,7 @@ is returned. Otherwise, the return value equals zero.\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{integer function omp_test_nest_lock(lock)}\n-@item                   @tab @code{integer(omp_integer_kind) :: omp_test_nest_lock}\n+@item @emph{Interface}: @tab @code{logical function omp_test_nest_lock(lock)}\n @item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n @end multitable\n \n@@ -938,7 +960,7 @@ is returned. Otherwise, the return value equals zero.\n @ref{omp_init_lock}, @ref{omp_set_lock}, @ref{omp_set_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.5.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.5.\n @end table\n \n \n@@ -951,7 +973,7 @@ A nested lock about to be unset must have been locked by @code{omp_set_nested_lo\n or @code{omp_test_nested_lock} before. In addition, the lock must be held by the \n thread calling @code{omp_unset_nested_lock}. If the nesting count drops to zero, the \n lock becomes unlocked. If one ore more threads attempted to set the lock before, \n-one of them is chosen to, again, set the lock for itself.\n+one of them is chosen to, again, set the lock to itself.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n@@ -968,7 +990,7 @@ one of them is chosen to, again, set the lock for itself.\n @ref{omp_set_nest_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.4.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.4.\n @end table\n \n \n@@ -995,7 +1017,7 @@ in the unlocked state and its nesting count must equal zero.\n @ref{omp_init_lock}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.3.2.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.3.2.\n @end table\n \n \n@@ -1021,7 +1043,7 @@ successive clock ticks.\n @ref{omp_get_wtime}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.4.2.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.4.2.\n @end table\n \n \n@@ -1049,7 +1071,7 @@ guaranteed not to change during the execution of the program.\n @ref{omp_get_wtick}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 3.4.1.\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 3.4.1.\n @end table\n \n \n@@ -1064,7 +1086,7 @@ guaranteed not to change during the execution of the program.\n The variables @env{OMP_DYNAMIC}, @env{OMP_MAX_ACTIVE_LEVELS},\n @env{OMP_NESTED}, @env{OMP_NUM_THREADS}, @env{OMP_SCHEDULE},\n @env{OMP_STACKSIZE},@env{OMP_THREAD_LIMIT} and @env{OMP_WAIT_POLICY}\n-are defined by section 4 of the OpenMP specifications in version 3.0,\n+are defined by section 4 of the OpenMP specifications in version 3.1,\n while @env{GOMP_CPU_AFFINITY} and @env{GOMP_STACKSIZE} are GNU \n extensions.\n \n@@ -1077,6 +1099,7 @@ extensions.\n * OMP_SCHEDULE::          How threads are scheduled\n * OMP_THREAD_LIMIT::      Set the maximum number of threads\n * OMP_WAIT_POLICY::       How waiting threads are handled\n+* OMP_PROC_BIND::         Whether theads may be moved between CPUs\n * GOMP_CPU_AFFINITY::     Bind threads to specific CPUs\n * GOMP_STACKSIZE::        Set default thread stack size\n @end menu\n@@ -1096,7 +1119,7 @@ disabled by default.\n @ref{omp_set_dynamic}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 4.3\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.3\n @end table\n \n \n@@ -1107,14 +1130,14 @@ disabled by default.\n @table @asis\n @item @emph{Description}:\n Specifies the initial value for the maximum number of nested parallel\n-regions. The value of this variable shall be positive integer.\n+regions. The value of this variable shall be a positive integer.\n If undefined, the number of active levels is unlimited.\n \n @item @emph{See also}:\n @ref{omp_set_max_active_levels}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 4.7\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.8\n @end table\n \n \n@@ -1134,7 +1157,7 @@ regions are disabled by default.\n @ref{omp_set_nested}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 4.4\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.5\n @end table\n \n \n@@ -1146,14 +1169,15 @@ regions are disabled by default.\n @table @asis\n @item @emph{Description}:\n Specifies the default number of threads to use in parallel regions. The \n-value of this variable shall be a positive integer. If undefined one thread \n-per CPU is used.\n+value of this variable shall be a comma-separated list of positive integers;\n+the value specified the number of threads to use for the corresponding nested\n+level. If undefined one thread per CPU is used.\n \n @item @emph{See also}:\n @ref{omp_set_num_threads}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 4.2\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.2\n @end table\n \n \n@@ -1174,7 +1198,7 @@ dynamic scheduling and a chunk size of 1 is used.\n @ref{omp_set_schedule}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, sections 2.5.1 and 4.1\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 2.5.1 and 4.1\n @end table\n \n \n@@ -1188,13 +1212,13 @@ Set the default thread stack size in kilobytes, unless the number\n is suffixed by @code{B}, @code{K}, @code{M} or @code{G}, in which\n case the size is, respectively, in bytes, kilobytes, megabytes\n or gigabytes. This is different from @code{pthread_attr_setstacksize}\n-which gets the number of bytes as an argument. If the stacksize cannot\n+which gets the number of bytes as an argument. If the stack size cannot\n be set due to system constraints, an error is reported and the initial\n-stacksize is left unchanged. If undefined, the stack size is system\n+stack size is left unchanged. If undefined, the stack size is system\n dependent.\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, sections 4.5\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 4.6\n @end table\n \n \n@@ -1213,7 +1237,7 @@ the number of threads is not limited.\n @ref{omp_get_thread_limit}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, section 4.8\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.9\n @end table\n \n \n@@ -1229,7 +1253,25 @@ power while waiting; while the value is @code{ACTIVE} specifies that\n they should.\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.0}, sections 4.6\n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 4.7\n+@end table\n+\n+\n+\n+@node OMP_PROC_BIND\n+@section @env{OMP_PROC_BIND} -- Whether theads may be moved between CPUs\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Specifies whether threads may be moved between processors. If set to\n+@code{true}, OpenMP theads should not be moved, if set to @code{false}\n+they may be moved.\n+\n+@item @emph{See also}:\n+@ref{GOMP_CPU_AFFINITY}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 4.4\n @end table\n \n \n@@ -1258,6 +1300,9 @@ or disabled during the runtime of the application.\n \n If this environment variable is omitted, the host system will handle the \n assignment of threads to CPUs. \n+\n+@item @emph{See also}:\n+@ref{OMP_PROC_BIND}\n @end table\n \n \n@@ -1270,8 +1315,8 @@ assignment of threads to CPUs.\n @item @emph{Description}:\n Set the default thread stack size in kilobytes. This is different from\n @code{pthread_attr_setstacksize} which gets the number of bytes as an \n-argument. If the stacksize cannot be set due to system constraints, an \n-error is reported and the initial stacksize is left unchanged. If undefined,\n+argument. If the stack size cannot be set due to system constraints, an \n+error is reported and the initial stack size is left unchanged. If undefined,\n the stack size is system dependent.\n \n @item @emph{See also}:"}, {"sha": "8a7c31f0d2abb73770e87fcf7cda5abd141c6cce", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -158,11 +158,12 @@ extern void GOMP_ordered_end (void);\n extern void GOMP_parallel_start (void (*) (void *), void *, unsigned);\n extern void GOMP_parallel_end (void);\n \n-/* team.c */\n+/* task.c */\n \n extern void GOMP_task (void (*) (void *), void *, void (*) (void *, void *),\n \t\t       long, long, bool, unsigned);\n extern void GOMP_taskwait (void);\n+extern void GOMP_taskyield (void);\n \n /* sections.c */\n "}, {"sha": "f2d7ba4e1157e3bc5f5d3ec058ba776504b38851", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -98,6 +98,8 @@ int omp_get_ancestor_thread_num (int) __GOMP_NOTHROW;\n int omp_get_team_size (int) __GOMP_NOTHROW;\n int omp_get_active_level (void) __GOMP_NOTHROW;\n \n+int omp_in_final (void) __GOMP_NOTHROW;\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "d00fa0551f681a34c436d9cbc798500c200f09e9", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,4 @@\n-!  Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n+!  Copyright (C) 2005, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.\n !  Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n !  This file is part of the GNU OpenMP Library (libgomp).\n@@ -24,8 +24,6 @@\n \n       module omp_lib_kinds\n         implicit none\n-        integer, parameter :: omp_integer_kind = 4\n-        integer, parameter :: omp_logical_kind = 4\n         integer, parameter :: omp_lock_kind = @OMP_LOCK_KIND@\n         integer, parameter :: omp_nest_lock_kind = @OMP_NEST_LOCK_KIND@\n         integer, parameter :: omp_sched_kind = 4\n@@ -34,7 +32,7 @@\n       module omp_lib\n         use omp_lib_kinds\n         implicit none\n-        integer, parameter :: openmp_version = 200805\n+        integer, parameter :: openmp_version = 201107\n         integer (omp_sched_kind), parameter :: omp_sched_static = 1\n         integer (omp_sched_kind), parameter :: omp_sched_dynamic = 2\n         integer (omp_sched_kind), parameter :: omp_sched_guided = 3\n@@ -126,64 +124,64 @@\n         interface\n           function omp_get_dynamic ()\n             use omp_lib_kinds\n-            logical (omp_logical_kind) :: omp_get_dynamic\n+            logical (4) :: omp_get_dynamic\n           end function omp_get_dynamic\n         end interface\n \n         interface\n           function omp_get_nested ()\n             use omp_lib_kinds\n-            logical (omp_logical_kind) :: omp_get_nested\n+            logical (4) :: omp_get_nested\n           end function omp_get_nested\n         end interface\n \n         interface\n           function omp_in_parallel ()\n             use omp_lib_kinds\n-            logical (omp_logical_kind) :: omp_in_parallel\n+            logical (4) :: omp_in_parallel\n           end function omp_in_parallel\n         end interface\n \n         interface\n           function omp_test_lock (lock)\n             use omp_lib_kinds\n-            logical (omp_logical_kind) :: omp_test_lock\n+            logical (4) :: omp_test_lock\n             integer (omp_lock_kind), intent (inout) :: lock\n           end function omp_test_lock\n         end interface\n \n         interface\n           function omp_get_max_threads ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_max_threads\n+            integer (4) :: omp_get_max_threads\n           end function omp_get_max_threads\n         end interface\n \n         interface\n           function omp_get_num_procs ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_num_procs\n+            integer (4) :: omp_get_num_procs\n           end function omp_get_num_procs\n         end interface\n \n         interface\n           function omp_get_num_threads ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_num_threads\n+            integer (4) :: omp_get_num_threads\n           end function omp_get_num_threads\n         end interface\n \n         interface\n           function omp_get_thread_num ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_thread_num\n+            integer (4) :: omp_get_thread_num\n           end function omp_get_thread_num\n         end interface\n \n         interface\n           function omp_test_nest_lock (lock)\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_test_nest_lock\n+            integer (4) :: omp_test_nest_lock\n             integer (omp_nest_lock_kind), intent (inout) :: lock\n           end function omp_test_nest_lock\n         end interface\n@@ -229,7 +227,7 @@\n         interface\n           function omp_get_thread_limit ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_thread_limit\n+            integer (4) :: omp_get_thread_limit\n           end function omp_get_thread_limit\n         end interface\n \n@@ -247,48 +245,55 @@\n         interface\n           function omp_get_max_active_levels ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_max_active_levels\n+            integer (4) :: omp_get_max_active_levels\n           end function omp_get_max_active_levels\n         end interface\n \n         interface\n           function omp_get_level ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_level\n+            integer (4) :: omp_get_level\n           end function omp_get_level\n         end interface\n \n         interface omp_get_ancestor_thread_num\n           function omp_get_ancestor_thread_num (level)\n             use omp_lib_kinds\n             integer (4), intent (in) :: level\n-            integer (omp_integer_kind) :: omp_get_ancestor_thread_num\n+            integer (4) :: omp_get_ancestor_thread_num\n           end function omp_get_ancestor_thread_num\n           function omp_get_ancestor_thread_num_8 (level)\n             use omp_lib_kinds\n             integer (8), intent (in) :: level\n-            integer (omp_integer_kind) :: omp_get_ancestor_thread_num_8\n+            integer (4) :: omp_get_ancestor_thread_num_8\n           end function omp_get_ancestor_thread_num_8\n         end interface\n \n         interface omp_get_team_size\n           function omp_get_team_size (level)\n             use omp_lib_kinds\n             integer (4), intent (in) :: level\n-            integer (omp_integer_kind) :: omp_get_team_size\n+            integer (4) :: omp_get_team_size\n           end function omp_get_team_size\n           function omp_get_team_size_8 (level)\n             use omp_lib_kinds\n             integer (8), intent (in) :: level\n-            integer (omp_integer_kind) :: omp_get_team_size_8\n+            integer (4) :: omp_get_team_size_8\n           end function omp_get_team_size_8\n         end interface\n \n         interface\n           function omp_get_active_level ()\n             use omp_lib_kinds\n-            integer (omp_integer_kind) :: omp_get_active_level\n+            integer (4) :: omp_get_active_level\n           end function omp_get_active_level\n         end interface\n \n+        interface\n+          function omp_in_final ()\n+            use omp_lib_kinds\n+            logical (4) :: omp_in_final\n+          end function omp_in_final\n+        end interface\n+\n       end module omp_lib"}, {"sha": "c583ba3d24a36dfbc6ca4a720ae694814f7cb338", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,4 @@\n-!  Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n+!  Copyright (C) 2005, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.\n !  Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n !  This file is part of the GNU OpenMP Library (libgomp).\n@@ -23,16 +23,17 @@\n !  <http://www.gnu.org/licenses/>.\n \n       integer omp_lock_kind, omp_nest_lock_kind, openmp_version\n-      integer omp_sched_kind, omp_sched_static, omp_sched_dynamic\n-      integer omp_sched_guided, omp_sched_auto\n       parameter (omp_lock_kind = @OMP_LOCK_KIND@)\n       parameter (omp_nest_lock_kind = @OMP_NEST_LOCK_KIND@)\n+      integer omp_sched_kind\n       parameter (omp_sched_kind = 4)\n+      integer (omp_sched_kind) omp_sched_static, omp_sched_dynamic\n+      integer (omp_sched_kind) omp_sched_guided, omp_sched_auto\n       parameter (omp_sched_static = 1)\n       parameter (omp_sched_dynamic = 2)\n       parameter (omp_sched_guided = 3)\n       parameter (omp_sched_auto = 4)\n-      parameter (openmp_version = 200805)\n+      parameter (openmp_version = 201107)\n \n       external omp_init_lock, omp_init_nest_lock\n       external omp_destroy_lock, omp_destroy_nest_lock\n@@ -64,3 +65,6 @@\n       integer(4) omp_get_thread_limit, omp_get_max_active_levels\n       integer(4) omp_get_level, omp_get_ancestor_thread_num\n       integer(4) omp_get_team_size, omp_get_active_level\n+\n+      external omp_in_final\n+      logical(4) omp_in_final"}, {"sha": "b93f77a38167e613235b3f5a14ef3588a9e2e5d1", "filename": "libgomp/task.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2007, 2008, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -41,6 +41,7 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n   task->kind = GOMP_TASK_IMPLICIT;\n   task->in_taskwait = false;\n   task->in_tied_task = false;\n+  task->final_task = false;\n   task->children = NULL;\n   gomp_sem_init (&task->taskwait_sem, 0);\n }\n@@ -77,8 +78,7 @@ gomp_clear_parent (struct gomp_task *children)\n \n void\n GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n-\t   long arg_size, long arg_align, bool if_clause,\n-\t   unsigned flags __attribute__((unused)))\n+\t   long arg_size, long arg_align, bool if_clause, unsigned flags)\n {\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_team *team = thr->ts.team;\n@@ -95,12 +95,14 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n #endif\n \n   if (!if_clause || team == NULL\n+      || (thr->task && thr->task->final_task)\n       || team->task_count > 64 * team->nthreads)\n     {\n       struct gomp_task task;\n \n       gomp_init_task (&task, thr->task, gomp_icv (false));\n       task.kind = GOMP_TASK_IFFALSE;\n+      task.final_task = (thr->task && thr->task->final_task) || (flags & 2);\n       if (thr->task)\n \ttask.in_tied_task = thr->task->in_tied_task;\n       thr->task = &task;\n@@ -145,6 +147,7 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       task->fn = fn;\n       task->fn_data = arg;\n       task->in_tied_task = true;\n+      task->final_task = (flags & 2) >> 1;\n       gomp_mutex_lock (&team->task_lock);\n       if (parent->children)\n \t{\n@@ -362,3 +365,20 @@ GOMP_taskwait (void)\n \t}\n     }\n }\n+\n+/* Called when encountering a taskyield directive.  */\n+\n+void\n+GOMP_taskyield (void)\n+{\n+  /* Nothing at the moment.  */\n+}\n+\n+int\n+omp_in_final (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  return thr->task && thr->task->final_task;\n+}\n+\n+ialias (omp_in_final)"}, {"sha": "633902ca5679a23f6ae2efc08ba4194d9637b728", "filename": "libgomp/team.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2006, 2007, 2008, 2009, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -260,6 +261,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   struct gomp_thread_pool *pool;\n   unsigned i, n, old_threads_used = 0;\n   pthread_attr_t thread_attr, *attr;\n+  unsigned long nthreads_var;\n \n   thr = gomp_thread ();\n   nested = thr->ts.team != NULL;\n@@ -289,7 +291,12 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n #endif\n   thr->ts.static_trip = 0;\n   thr->task = &team->implicit_task[0];\n+  nthreads_var = icv->nthreads_var;\n+  if (__builtin_expect (gomp_nthreads_var_list != NULL, 0)\n+      && thr->ts.level < gomp_nthreads_var_list_len)\n+    nthreads_var = gomp_nthreads_var_list[thr->ts.level];\n   gomp_init_task (thr->task, task, icv);\n+  team->implicit_task[0].icv.nthreads_var = nthreads_var;\n \n   if (nthreads == 1)\n     return;\n@@ -342,6 +349,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \t  nthr->ts.static_trip = 0;\n \t  nthr->task = &team->implicit_task[i];\n \t  gomp_init_task (nthr->task, task, icv);\n+\t  team->implicit_task[i].icv.nthreads_var = nthreads_var;\n \t  nthr->fn = fn;\n \t  nthr->data = data;\n \t  team->ordered_release[i] = &nthr->release;\n@@ -413,6 +421,7 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       start_data->ts.static_trip = 0;\n       start_data->task = &team->implicit_task[i];\n       gomp_init_task (start_data->task, task, icv);\n+      team->implicit_task[i].icv.nthreads_var = nthreads_var;\n       start_data->thread_pool = pool;\n       start_data->nested = nested;\n "}, {"sha": "e7217590a3690f1fc44d63fc6c12d26a0a1fb1c3", "filename": "libgomp/testsuite/libgomp.c++/atomic-2.C", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-2.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,156 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+int x = 6;\n+float y;\n+\n+int\n+main (void)\n+{\n+  int v;\n+  float f;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic write\n+    x = 17;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 17)\n+    abort ();\n+  #pragma omp atomic update\n+    x++;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 18)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x++;\n+  if (v != 18)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 19)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = ++x;\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x *= 3; }\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 60)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      x |= 2;\n+      v = x;\n+    }\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x++; }\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; ++x; }\n+  if (v != 63)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      ++x;\n+      v = x;\n+    }\n+  if (v != 65)\n+    abort ();\n+#pragma omp atomic capture\n+{x++;v=x;}if (v != 66)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 66)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x--; }\n+  if (v != 66)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; --x; }\n+  if (v != 65)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      --x;\n+      v = x;\n+    }\n+  if (v != 63)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x--; v = x; } if (v != 62)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic write\n+    y = 17.5f;\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 17.5)\n+    abort ();\n+  #pragma omp atomic update\n+    y *= 2.0f;\n+  #pragma omp atomic read\n+    f = y;\n+  if (y != 35.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = y *= 2.0f;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = y++;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 71.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = --y;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    { f = y; y /= 2.0f; }\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 35.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    { y /= 2.0f; f = y; }\n+  if (f != 17.5)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 17.5)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "660b260e19fb46ec7cfc4e10ec0f602d65dae2fb", "filename": "libgomp/testsuite/libgomp.c++/atomic-3.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-3.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+bool v, x1, x2, x3, x4, x5, x6;\n+\n+void\n+foo ()\n+{\n+  #pragma omp atomic capture\n+  v = ++x1;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  v = x2++;\n+  if (v)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x3;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x4;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x5; x5 |= 1; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x6 |= 1; v = x6; }\n+  if (!v)\n+    abort ();\n+}\n+\n+void\n+bar ()\n+{\n+  #pragma omp atomic write\n+  x1 = false;\n+  #pragma omp atomic write\n+  x2 = false;\n+  #pragma omp atomic capture\n+  { ++x1; v = x1; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x2; x2++; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic write\n+  x1 = false;\n+  #pragma omp atomic write\n+  x2 = false;\n+  #pragma omp atomic capture\n+  { x1++; v = x1; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x2; ++x2; }\n+  if (v)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp atomic write\n+  x3 = true;\n+  #pragma omp atomic write\n+  x4 = true;\n+  foo ();\n+  bar ();\n+  return 0;\n+}"}, {"sha": "82439df2bb2c02619043b35b1a2dd45c61533275", "filename": "libgomp/testsuite/libgomp.c++/atomic-4.C", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-4.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,166 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+template <typename T, typename T2>\n+int\n+foo (void)\n+{\n+  extern T x;\n+  extern T2 y;\n+  T v;\n+  T2 f;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic write\n+    x = 17;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 17)\n+    abort ();\n+  #pragma omp atomic update\n+    x++;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 18)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x++;\n+  if (v != 18)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 19)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = ++x;\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x *= 3; }\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 60)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      x |= 2;\n+      v = x;\n+    }\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x++; }\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; ++x; }\n+  if (v != 63)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      ++x;\n+      v = x;\n+    }\n+  if (v != 65)\n+    abort ();\n+#pragma omp atomic capture\n+{x++;v=x;}if (v != 66)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 66)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x--; }\n+  if (v != 66)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; --x; }\n+  if (v != 65)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      --x;\n+      v = x;\n+    }\n+  if (v != 63)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x--; v = x; } if (v != 62)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic write\n+    y = 17.5f;\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 17.5)\n+    abort ();\n+  #pragma omp atomic update\n+    y *= 2.0f;\n+  #pragma omp atomic read\n+    f = y;\n+  if (y != 35.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = y *= 2.0f;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = y++;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 71.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = --y;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    { f = y; y /= 2.0f; }\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 35.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    { y /= 2.0f; f = y; }\n+  if (f != 17.5)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 17.5)\n+    abort ();\n+  return 0;\n+}\n+\n+int x = 6;\n+float y;\n+\n+int\n+main ()\n+{\n+  foo <int, float> ();\n+  return 0;\n+}"}, {"sha": "e9bd2cc1cbda107be61e53d09f6f66b3af8ebabf", "filename": "libgomp/testsuite/libgomp.c++/atomic-5.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-5.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,79 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+template <typename T>\n+void\n+foo ()\n+{\n+  extern T v, x1, x2, x3, x4, x5, x6;\n+  #pragma omp atomic capture\n+  v = ++x1;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  v = x2++;\n+  if (v)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x3;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x4;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x5; x5 |= 1; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x6 |= 1; v = x6; }\n+  if (!v)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+bar ()\n+{\n+  extern T v, x1, x2;\n+  #pragma omp atomic write\n+  x1 = false;\n+  #pragma omp atomic write\n+  x2 = false;\n+  #pragma omp atomic capture\n+  { ++x1; v = x1; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x2; x2++; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic write\n+  x1 = false;\n+  #pragma omp atomic write\n+  x2 = false;\n+  #pragma omp atomic capture\n+  { x1++; v = x1; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x2; ++x2; }\n+  if (v)\n+    abort ();\n+}\n+\n+bool v, x1, x2, x3, x4, x5, x6;\n+\n+int\n+main ()\n+{\n+  #pragma omp atomic write\n+  x3 = true;\n+  #pragma omp atomic write\n+  x4 = true;\n+  foo <bool> ();\n+  bar <bool> ();\n+  return 0;\n+}"}, {"sha": "d7d0eb981f75593c1c65c3e42810e8850ea5e199", "filename": "libgomp/testsuite/libgomp.c++/atomic-6.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-6.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+long long l, m;\n+int i, j;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp atomic read\n+    i = l;\n+  #pragma omp atomic read\n+    m = j;\n+  if (i != 77 || m != 88)\n+    abort ();\n+  #pragma omp atomic write\n+    l = 1 + i + 6 * 1;\n+  #pragma omp atomic write\n+    j = 170 - 170 + m + 1 * 7;\n+  #pragma omp atomic capture\n+    i = l += 4;\n+  #pragma omp atomic capture\n+    m = j += 4;\n+  if (i != 88 || m != 99)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      i = l;\n+      l += 4;\n+    }\n+  #pragma omp atomic capture\n+    {\n+      m = j;\n+      j += 4;\n+    }\n+  if (i != 88 || m != 99)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      l += 4;\n+      i = l;\n+    }\n+  #pragma omp atomic capture\n+    {\n+      j += 4;\n+      m = j;\n+    }\n+  if (i != 96 || m != 107)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  l = 77;\n+  j = 88;\n+  foo ();\n+}"}, {"sha": "fe1b4d7aa9e399049413d85c89d274a94606b397", "filename": "libgomp/testsuite/libgomp.c++/atomic-7.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-7.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+template <typename S, typename T>\n+void\n+foo (void)\n+{\n+  extern S l, m;\n+  extern T i, j;\n+\n+  #pragma omp atomic read\n+    i = l;\n+  #pragma omp atomic read\n+    m = j;\n+  if (i != 77 || m != 88)\n+    abort ();\n+  #pragma omp atomic write\n+    l = 1 + i + 6 * 1;\n+  #pragma omp atomic write\n+    j = 170 - 170 + m + 1 * 7;\n+  #pragma omp atomic capture\n+    i = l += 4;\n+  #pragma omp atomic capture\n+    m = j += 4;\n+  if (i != 88 || m != 99)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      i = l;\n+      l += 4;\n+    }\n+  #pragma omp atomic capture\n+    {\n+      m = j;\n+      j += 4;\n+    }\n+  if (i != 88 || m != 99)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      l += 4;\n+      i = l;\n+    }\n+  #pragma omp atomic capture\n+    {\n+      j += 4;\n+      m = j;\n+    }\n+  if (i != 96 || m != 107)\n+    abort ();\n+}\n+\n+long long l, m;\n+int i, j;\n+\n+int\n+main ()\n+{\n+  l = 77;\n+  j = 88;\n+  foo <long long, int> ();\n+}"}, {"sha": "744b3409c97d175d353dd135c815a693b88fe2ec", "filename": "libgomp/testsuite/libgomp.c++/atomic-8.C", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-8.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,137 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+int x = 6, cnt;\n+\n+int\n+foo ()\n+{\n+  return cnt++;\n+}\n+\n+int\n+main ()\n+{\n+  int v, *p;\n+  #pragma omp atomic update\n+    x = x + 7;\n+  #pragma omp atomic\n+    x = x + 7 + 6;\n+  #pragma omp atomic update\n+    x = x + 2 * 3;\n+  #pragma omp atomic\n+    x = x * (2 - 1);\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic write\n+    x = 0;\n+  #pragma omp atomic capture\n+    {\n+      v = x;\n+      x = x | 1 ^ 2;\n+    }\n+  if (v != 0)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = x;\n+      x = x | 4 | 2;\n+    }\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 7)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      x = x ^ 6 & 2;\n+      v = x;\n+    }\n+  if (v != 5)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = x - (6 + 4); v = x; }\n+  if (v != -5)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = x - (1 | 2); }\n+  if (v != -5)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic\n+    x = x * -4 / 2;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 16)\n+    abort ();\n+  p = &x;\n+  #pragma omp atomic update\n+    p[foo (), 0] = p[foo (), 0] - 16;\n+  #pragma omp atomic read\n+    v = x;\n+  if (cnt != 2 || v != 0)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[foo (), 0] += 6;\n+      v = p[foo (), 0];\n+    }\n+  if (cnt != 4 || v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0];\n+      p[foo (), 0] += 6;\n+    }\n+  if (cnt != 6 || v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[foo (), 0] = p[foo (), 0] + 6;\n+      v = p[foo (), 0];\n+    }\n+  if (cnt != 9 || v != 18)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0];\n+      p[foo (), 0] = p[foo (), 0] + 6;\n+    }\n+  if (cnt != 12 || v != 18)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 24)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; p[foo (), 0]++; }\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; ++p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { p[foo (), 0]++; v = p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { ++p[foo (), 0]; v = p[foo (), 0]; }\n+  if (cnt != 20 || v != 28)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; p[foo (), 0]--; }\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; --p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { p[foo (), 0]--; v = p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { --p[foo (), 0]; v = p[foo (), 0]; }\n+  if (cnt != 28 || v != 24)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "ece1bf3f02905a781ac22976ee1703c57693f6c2", "filename": "libgomp/testsuite/libgomp.c++/atomic-9.C", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-9.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,148 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+int cnt;\n+\n+int\n+foo ()\n+{\n+  return cnt++;\n+}\n+\n+template <typename T>\n+void\n+bar ()\n+{\n+  extern T x;\n+  T v, *p;\n+  #pragma omp atomic update\n+    x = x + 7;\n+  #pragma omp atomic\n+    x = x + 7 + 6;\n+  #pragma omp atomic update\n+    x = x + 2 * 3;\n+  #pragma omp atomic\n+    x = x * (2 - 1);\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic write\n+    x = 0;\n+  #pragma omp atomic capture\n+    {\n+      v = x;\n+      x = x | 1 ^ 2;\n+    }\n+  if (v != 0)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = x;\n+      x = x | 4 | 2;\n+    }\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 7)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      x = x ^ 6 & 2;\n+      v = x;\n+    }\n+  if (v != 5)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = x - (6 + 4); v = x; }\n+  if (v != -5)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = x - (1 | 2); }\n+  if (v != -5)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic\n+    x = x * -4 / 2;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 16)\n+    abort ();\n+  p = &x;\n+  #pragma omp atomic update\n+    p[foo (), 0] = p[foo (), 0] - 16;\n+  #pragma omp atomic read\n+    v = x;\n+  if (cnt != 2 || v != 0)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[foo (), 0] += 6;\n+      v = p[foo (), 0];\n+    }\n+  if (cnt != 4 || v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0];\n+      p[foo (), 0] += 6;\n+    }\n+  if (cnt != 6 || v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[foo (), 0] = p[foo (), 0] + 6;\n+      v = p[foo (), 0];\n+    }\n+  if (cnt != 9 || v != 18)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0];\n+      p[foo (), 0] = p[foo (), 0] + 6;\n+    }\n+  if (cnt != 12 || v != 18)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 24)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; p[foo (), 0]++; }\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; ++p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { p[foo (), 0]++; v = p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { ++p[foo (), 0]; v = p[foo (), 0]; }\n+  if (cnt != 20 || v != 28)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; p[foo (), 0]--; }\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; --p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { p[foo (), 0]--; v = p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { --p[foo (), 0]; v = p[foo (), 0]; }\n+  if (cnt != 28 || v != 24)\n+    abort ();\n+}\n+\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  bar <int> ();\n+  return 0;\n+}"}, {"sha": "e7ef8a13c2acb843a14a77fe9ff3b95313f60371", "filename": "libgomp/testsuite/libgomp.c++/reduction-4.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-4.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+template <typename I, typename F>\n+void\n+foo ()\n+{\n+  I j = -10000;\n+  F f = 1024.0;\n+  int i;\n+  #pragma omp parallel for reduction (min:f) reduction (max:j)\n+    for (i = 0; i < 4; i++)\n+      switch (i)\n+\t{\n+\tcase 0:\n+\t  if (j < -16) j = -16; break;\n+\tcase 1:\n+\t  if (f > -2.0) f = -2.0; break;\n+\tcase 2:\n+\t  if (j < 8) j = 8; if (f > 9.0) f = 9.0; break;\n+\tcase 3:\n+\t  break;\n+\t}\n+  if (j != 8 || f != -2.0)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int j = -10000;\n+  float f = 1024.0;\n+  int i;\n+  #pragma omp parallel for reduction (min:f) reduction (max:j)\n+    for (i = 0; i < 4; i++)\n+      switch (i)\n+\t{\n+\tcase 0:\n+\t  if (j < -16) j = -16; break;\n+\tcase 1:\n+\t  if (f > -2.0) f = -2.0; break;\n+\tcase 2:\n+\t  if (j < 8) j = 8; if (f > 9.0) f = 9.0; break;\n+\tcase 3:\n+\t  break;\n+\t}\n+  if (j != 8 || f != -2.0)\n+    abort ();\n+  foo <int, float> ();\n+  foo <long, double> ();\n+  foo <long long, long double> ();\n+  return 0;\n+}"}, {"sha": "3e1b4696b084afc2f33807b432e63ac7758431f6", "filename": "libgomp/testsuite/libgomp.c++/task-8.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-8.C?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <cstdlib>\n+\n+int err;\n+\n+int\n+main ()\n+{\n+  int e;\n+#pragma omp parallel shared(err)\n+  {\n+    if (omp_in_final ())\n+      #pragma omp atomic write\n+\terr = 1;\n+    #pragma omp task if (0) shared(err)\n+      {\n+\tif (omp_in_final ())\n+\t  #pragma omp atomic write\n+\t    err = 1;\n+\t#pragma omp task if (0) shared(err)\n+\t  if (omp_in_final ())\n+\t    #pragma omp atomic write\n+\t      err = 1;\n+      }\n+    #pragma omp task final (1) shared(err)\n+      {\n+\tif (!omp_in_final ())\n+\t  #pragma omp atomic write\n+\t    err = 1;\n+\t#pragma omp taskyield\n+\t#pragma omp taskwait\n+\t#pragma omp task shared(err)\n+\t  if (!omp_in_final ())\n+\t    #pragma omp atomic write\n+\t      err = 1;\n+      }\n+  }\n+  #pragma omp atomic read\n+    e = err;\n+  if (e)\n+    abort ();\n+}"}, {"sha": "d1d6ca53a305dbcacc72d7a1a2e628062874d883", "filename": "libgomp/testsuite/libgomp.c/atomic-11.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-11.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,156 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+int x = 6;\n+float y;\n+\n+int\n+main (void)\n+{\n+  int v;\n+  float f;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic write\n+    x = 17;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 17)\n+    abort ();\n+  #pragma omp atomic update\n+    x++;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 18)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x++;\n+  if (v != 18)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 19)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = ++x;\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x *= 3; }\n+  if (v != 20)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 60)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      x |= 2;\n+      v = x;\n+    }\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x++; }\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; ++x; }\n+  if (v != 63)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      ++x;\n+      v = x;\n+    }\n+  if (v != 65)\n+    abort ();\n+#pragma omp atomic capture\n+{x++;v=x;}if (v != 66)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 66)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x--; }\n+  if (v != 66)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; --x; }\n+  if (v != 65)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      --x;\n+      v = x;\n+    }\n+  if (v != 63)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x--; v = x; } if (v != 62)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 62)\n+    abort ();\n+  #pragma omp atomic write\n+    y = 17.5f;\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 17.5)\n+    abort ();\n+  #pragma omp atomic update\n+    y *= 2.0f;\n+  #pragma omp atomic read\n+    f = y;\n+  if (y != 35.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = y *= 2.0f;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = y++;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 71.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    f = --y;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    { f = y; y /= 2.0f; }\n+  if (f != 70.0)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 35.0)\n+    abort ();\n+  #pragma omp atomic capture\n+    { y /= 2.0f; f = y; }\n+  if (f != 17.5)\n+    abort ();\n+  #pragma omp atomic read\n+    f = y;\n+  if (f != 17.5)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "a9fe5606538f695ef8a5438482ce12e5eea7e6a7", "filename": "libgomp/testsuite/libgomp.c/atomic-12.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-12.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,98 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+_Bool v, x1, x2, x3, x4, x5, x6;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp atomic capture\n+  v = ++x1;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  v = x2++;\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  v = --x3;\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  v = x4--;\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x5; x5 |= 1; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x6 |= 1; v = x6; }\n+  if (!v)\n+    abort ();\n+}\n+\n+void\n+bar (void)\n+{\n+  #pragma omp atomic write\n+  x1 = 0;\n+  #pragma omp atomic write\n+  x2 = 0;\n+  #pragma omp atomic write\n+  x3 = 1;\n+  #pragma omp atomic write\n+  x4 = 1;\n+  #pragma omp atomic capture\n+  { ++x1; v = x1; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x2; x2++; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { --x3; v = x3; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x4; x4--; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic write\n+  x1 = 0;\n+  #pragma omp atomic write\n+  x2 = 0;\n+  #pragma omp atomic write\n+  x3 = 1;\n+  #pragma omp atomic write\n+  x4 = 1;\n+  #pragma omp atomic capture\n+  { x1++; v = x1; }\n+  if (!v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x2; ++x2; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { x3--; v = x3; }\n+  if (v)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = x4; --x4; }\n+  if (!v)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp atomic write\n+  x3 = 1;\n+  #pragma omp atomic write\n+  x4 = 1;\n+  foo ();\n+  bar ();\n+  return 0;\n+}"}, {"sha": "52800fc7192dee59b2ee5c6374d3cd7d4f128bb3", "filename": "libgomp/testsuite/libgomp.c/atomic-13.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-13.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+long long l, m;\n+int i, j;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp atomic read\n+    i = l;\n+  #pragma omp atomic read\n+    m = j;\n+  if (i != 77 || m != 88)\n+    abort ();\n+  #pragma omp atomic write\n+    l = 1 + i + 6 * 1;\n+  #pragma omp atomic write\n+    j = 170 - 170 + m + 1 * 7;\n+  #pragma omp atomic capture\n+    i = l += 4;\n+  #pragma omp atomic capture\n+    m = j += 4;\n+  if (i != 88 || m != 99)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      i = l;\n+      l += 4;\n+    }\n+  #pragma omp atomic capture\n+    {\n+      m = j;\n+      j += 4;\n+    }\n+  if (i != 88 || m != 99)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      l += 4;\n+      i = l;\n+    }\n+  #pragma omp atomic capture\n+    {\n+      j += 4;\n+      m = j;\n+    }\n+  if (i != 96 || m != 107)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  l = 77;\n+  j = 88;\n+  foo ();\n+  return 0;\n+}"}, {"sha": "593665046c5c3e9e6cadba51b36f700465c0453a", "filename": "libgomp/testsuite/libgomp.c/atomic-14.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-14.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,137 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+int x = 6, cnt;\n+\n+int\n+foo (void)\n+{\n+  return cnt++;\n+}\n+\n+int\n+main ()\n+{\n+  int v, *p;\n+  #pragma omp atomic update\n+    x = x + 7;\n+  #pragma omp atomic\n+    x = x + 7 + 6;\n+  #pragma omp atomic update\n+    x = x + 2 * 3;\n+  #pragma omp atomic\n+    x = x * (2 - 1);\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic write\n+    x = 0;\n+  #pragma omp atomic capture\n+    {\n+      v = x;\n+      x = x | 1 ^ 2;\n+    }\n+  if (v != 0)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = x;\n+      x = x | 4 | 2;\n+    }\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 7)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      x = x ^ 6 & 2;\n+      v = x;\n+    }\n+  if (v != 5)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = x - (6 + 4); v = x; }\n+  if (v != -5)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = x - (1 | 2); }\n+  if (v != -5)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic\n+    x = x * -4 / 2;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 16)\n+    abort ();\n+  p = &x;\n+  #pragma omp atomic update\n+    p[foo (), 0] = p[foo (), 0] - 16;\n+  #pragma omp atomic read\n+    v = x;\n+  if (cnt != 2 || v != 0)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[foo (), 0] += 6;\n+      v = p[foo (), 0];\n+    }\n+  if (cnt != 4 || v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0];\n+      p[foo (), 0] += 6;\n+    }\n+  if (cnt != 6 || v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[foo (), 0] = p[foo (), 0] + 6;\n+      v = p[foo (), 0];\n+    }\n+  if (cnt != 9 || v != 18)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0];\n+      p[foo (), 0] = p[foo (), 0] + 6;\n+    }\n+  if (cnt != 12 || v != 18)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 24)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; p[foo (), 0]++; }\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; ++p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { p[foo (), 0]++; v = p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { ++p[foo (), 0]; v = p[foo (), 0]; }\n+  if (cnt != 20 || v != 28)\n+    abort ();\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; p[foo (), 0]--; }\n+  #pragma omp atomic capture\n+  { v = p[foo (), 0]; --p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { p[foo (), 0]--; v = p[foo (), 0]; }\n+  #pragma omp atomic capture\n+  { --p[foo (), 0]; v = p[foo (), 0]; }\n+  if (cnt != 28 || v != 24)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "d378bad9a6aa7ebabc16719173628fcf9bb28eb6", "filename": "libgomp/testsuite/libgomp.c/reduction-6.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-6.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+int j;\n+float f;\n+\n+int\n+main ()\n+{\n+  j = -10000;\n+  f = 1024.0;\n+  int i;\n+  #pragma omp parallel for reduction (min:f) reduction (max:j)\n+    for (i = 0; i < 4; i++)\n+      switch (i)\n+\t{\n+\tcase 0:\n+\t  if (j < -16) j = -16; break;\n+\tcase 1:\n+\t  if (f > -2.0) f = -2.0; break;\n+\tcase 2:\n+\t  if (j < 8) j = 8; if (f > 9.0) f = 9.0; break;\n+\tcase 3:\n+\t  break;\n+\t}\n+  if (j != 8 || f != -2.0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "b15237127608545c8ada030354ad055810bf1f58", "filename": "libgomp/testsuite/libgomp.c/task-5.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-5.c?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int err;\n+\n+int\n+main ()\n+{\n+  int e;\n+#pragma omp parallel shared(err)\n+  {\n+    if (omp_in_final ())\n+      #pragma omp atomic write\n+\terr = 1;\n+    #pragma omp task if (0) shared(err)\n+      {\n+\tif (omp_in_final ())\n+\t  #pragma omp atomic write\n+\t    err = 1;\n+\t#pragma omp task if (0) shared(err)\n+\t  if (omp_in_final ())\n+\t    #pragma omp atomic write\n+\t      err = 1;\n+      }\n+    #pragma omp task final (1) shared(err)\n+      {\n+\tif (!omp_in_final ())\n+\t  #pragma omp atomic write\n+\t    err = 1;\n+\t#pragma omp taskyield\n+\t#pragma omp taskwait\n+\t#pragma omp task shared(err)\n+\t  if (!omp_in_final ())\n+\t    #pragma omp atomic write\n+\t      err = 1;\n+      }\n+  }\n+  #pragma omp atomic read\n+    e = err;\n+  if (e)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "dc68baa754207066933673a55642f9e9273bc2f6", "filename": "libgomp/testsuite/libgomp.fortran/allocatable7.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable7.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+\n+  integer, allocatable :: a(:)\n+  logical :: l\n+  l = .false.\n+!$omp parallel firstprivate (a) reduction (.or.:l)\n+  l = allocated (a)\n+  allocate (a(10))\n+  l = l .or. .not. allocated (a)\n+  a = 10\n+  if (any (a .ne. 10)) l = .true.\n+  deallocate (a)\n+  l = l .or. allocated (a)\n+!$omp end parallel\n+  if (l) call abort\n+end"}, {"sha": "209378259e36fa78586e6a43584c79f2ab37ff91", "filename": "libgomp/testsuite/libgomp.fortran/allocatable8.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable8.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+!$ use omp_lib\n+\n+  integer, save, allocatable :: a(:, :)\n+  logical :: l\n+!$omp threadprivate (a)\n+  if (allocated (a)) call abort\n+  l = .false.\n+!$omp parallel copyin (a) num_threads (4) reduction(.or.:l)\n+  l = l.or.allocated (a)\n+!$omp end parallel\n+  if (l.or.allocated (a)) call abort\n+end"}, {"sha": "9777c6b22cc6b0960c3d6386ac775fa3e25a692f", "filename": "libgomp/testsuite/libgomp.fortran/crayptr3.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcrayptr3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcrayptr3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcrayptr3.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+\n+  use omp_lib\n+  integer :: a, b, c, i, p\n+  logical :: l\n+  pointer (ip, p)\n+  a = 1\n+  b = 2\n+  c = 3\n+  l = .false.\n+  ip = loc (a)\n+\n+!$omp parallel num_threads (2) reduction (.or.:l) firstprivate (ip)\n+  l = p .ne. 1\n+  ip = loc (b)\n+  if (omp_get_thread_num () .eq. 1) ip = loc (c)\n+  l = l .or. (p .ne. (2 + omp_get_thread_num ()))\n+!$omp end parallel\n+\n+  if (l) call abort\n+\n+  l = .false.\n+  ip = loc (a)\n+!$omp parallel do num_threads (2) reduction (.or.:l) &\n+!$omp & firstprivate (ip) lastprivate (ip)\n+  do i = 0, 1\n+    l = l .or. (p .ne. 1)\n+    ip = loc (b)\n+    if (i .eq. 1) ip = loc (c)\n+    l = l .or. (p .ne. (2 + i))\n+  end do\n+\n+  if (l) call abort\n+  if (p .ne. 3) call abort\n+end"}, {"sha": "e8923d1f21468e91091fc8c6f03a925e8fffc438", "filename": "libgomp/testsuite/libgomp.fortran/omp_atomic3.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic3.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+    integer (kind = 4) :: a, a2\n+    integer (kind = 2) :: b, b2\n+    real :: c, f\n+    double precision :: d, d2, c2\n+    integer, dimension (10) :: e\n+!$omp atomic write\n+    a = 1\n+!$omp atomic write\n+    b = 2\n+!$omp end atomic\n+!$omp atomic write\n+    c = 3\n+!$omp atomic write\n+    d = 1 + 2 + 3 - 2\n+    e = 5\n+!$omp atomic write\n+    f = 6\n+!$omp end atomic\n+!$omp atomic\n+    a = a + 4\n+!$omp end atomic\n+!$omp atomic update\n+    b = 4 - b\n+!$omp atomic\n+    c = c * 2\n+!$omp atomic update\n+    d = 2 / d\n+!$omp end atomic\n+!$omp atomic read\n+    a2 = a\n+!$omp atomic read\n+    b2 = b\n+!$omp end atomic\n+!$omp atomic read\n+    c2 = c\n+!$omp atomic read\n+    d2 = d\n+    if (a2 .ne. 5 .or. b2 .ne. 2 .or. c2 .ne. 6 .or. d2 .ne. 0.5) call abort\n+!$omp atomic write\n+    d = 1.2\n+!$omp atomic\n+    a = a + c + d\n+!$omp atomic\n+    b = b - (a + c + d)\n+    if (a .ne. 12 .or. b .ne. -17) call abort\n+!$omp atomic\n+    a = c + d + a\n+!$omp atomic\n+    b = a + c + d - b\n+    if (a .ne. 19 .or. b .ne. 43) call abort\n+!$omp atomic\n+    b = (a + c + d) - b\n+    a = 32\n+!$omp atomic\n+    a = a / 3.4\n+    if (a .ne. 9 .or. b .ne. -16) call abort\n+end"}, {"sha": "725a3bc24eee309fb057167bc4f43aef59fb811b", "filename": "libgomp/testsuite/libgomp.fortran/omp_atomic4.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic4.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+    integer (kind = 4) :: a, a2\n+    integer (kind = 2) :: b, b2\n+    real :: c\n+    double precision :: d, d2, c2\n+    integer, dimension (10) :: e\n+!$omp atomic write\n+    a = 1\n+!$omp atomic write\n+    b = 2\n+!$omp atomic write\n+    c = 3\n+!$omp atomic write\n+    d = 4\n+!$omp atomic capture\n+    a2 = a\n+    a = a + 4\n+!$omp end atomic\n+!$omp atomic capture\n+    b = b - 18\n+    b2 = b\n+!$omp end atomic\n+!$omp atomic capture\n+    c2 = c\n+    c = 2.0 * c\n+!$omp end atomic\n+!$omp atomic capture\n+    d = d / 2.0\n+    d2 = d\n+!$omp end atomic\n+    if (a2 .ne. 1 .or. b2 .ne. -16 .or. c2 .ne. 3 .or. d2 .ne. 2) call abort\n+!$omp atomic read\n+    a2 = a\n+!$omp atomic read\n+    c2 = c\n+    if (a2 .ne. 5 .or. b2 .ne. -16 .or. c2 .ne. 6 .or. d2 .ne. 2) call abort\n+end"}, {"sha": "d55ef35f4a539012ad109c35220899103e2e69e7", "filename": "libgomp/testsuite/libgomp.fortran/pointer1.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpointer1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpointer1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpointer1.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do run }\n+  integer, pointer :: a, c(:)\n+  integer, target :: b, d(10)\n+  b = 0\n+  a => b\n+  d = 0\n+  c => d\n+  call foo (a, c)\n+  b = 0\n+  d = 0\n+  call bar (a, c)\n+contains\n+  subroutine foo (a, c)\n+    integer, pointer :: a, c(:), b, d(:)\n+    integer :: r, r2\n+    r = 0\n+    !$omp parallel firstprivate (a, c) reduction (+:r)\n+      !$omp atomic\n+        a = a + 1\n+      !$omp atomic\n+        c(1) = c(1) + 1\n+      r = r + 1\n+    !$omp end parallel\n+    if (a.ne.r.or.c(1).ne.r) call abort\n+    r2 = r\n+    b => a\n+    d => c\n+    r = 0\n+    !$omp parallel firstprivate (b, d) reduction (+:r)\n+      !$omp atomic\n+        b = b + 1\n+      !$omp atomic\n+        d(1) = d(1) + 1\n+      r = r + 1\n+    !$omp end parallel\n+    if (b.ne.r+r2.or.d(1).ne.r+r2) call abort\n+  end subroutine foo\n+  subroutine bar (a, c)\n+    integer, pointer :: a, c(:), b, d(:)\n+    integer, target :: q, r(5)\n+    integer :: i\n+    q = 17\n+    r = 21\n+    b => a\n+    d => c\n+    !$omp parallel do firstprivate (a, c) lastprivate (a, c)\n+      do i = 1, 100\n+        !$omp atomic\n+          a = a + 1\n+        !$omp atomic\n+          c((i+9)/10) = c((i+9)/10) + 1\n+        if (i.eq.100) then\n+          a => q\n+          c => r\n+\tend if\n+      end do\n+    !$omp end parallel do\n+    if (b.ne.100.or.any(d.ne.10)) call abort\n+    if (a.ne.17.or.any(c.ne.21)) call abort\n+    a => b\n+    c => d\n+    !$omp parallel do firstprivate (b, d) lastprivate (b, d)\n+      do i = 1, 100\n+        !$omp atomic\n+          b = b + 1\n+        !$omp atomic\n+          d((i+9)/10) = d((i+9)/10) + 1\n+        if (i.eq.100) then\n+          b => q\n+          d => r\n+\tend if\n+      end do\n+    !$omp end parallel do\n+    if (a.ne.200.or.any(c.ne.20)) call abort\n+    if (b.ne.17.or.any(d.ne.21)) call abort\n+  end subroutine bar\n+end"}, {"sha": "f172aed4b1259924abbd2bf0c4198c5cc5602531", "filename": "libgomp/testsuite/libgomp.fortran/pointer2.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpointer2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpointer2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpointer2.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+  integer, pointer, save :: thr(:)\n+!$omp threadprivate (thr)\n+  integer, target :: s(3), t(3), u(3)\n+  integer :: i\n+  logical :: l\n+  s = 2\n+  t = 7\n+  u = 13\n+  thr => t\n+  l = .false.\n+  i = 0\n+!$omp parallel copyin (thr) reduction(.or.:l) reduction(+:i)\n+  if (any (thr.ne.7)) l = .true.\n+  thr => s\n+!$omp master\n+  thr => u\n+!$omp end master\n+!$omp atomic\n+  thr(1) = thr(1) + 1\n+  i = i + 1\n+!$omp end parallel\n+  if (l) call abort\n+  if (thr(1).ne.14) call abort\n+  if (s(1).ne.1+i) call abort\n+  if (u(1).ne.14) call abort\n+end"}, {"sha": "9fa67d95baa8fd27e20c7f9170c473ca13ba8e8b", "filename": "libgomp/testsuite/libgomp.fortran/task4.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20906c66f2433627f139df6dbaf0bb1efd0da626/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask4.f90?ref=20906c66f2433627f139df6dbaf0bb1efd0da626", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+\n+  use omp_lib\n+  integer :: err, e\n+\n+!$omp atomic write\n+  err = 0\n+!$omp parallel shared(err) private(e)\n+  if (omp_in_final ()) then\n+!$omp atomic write\n+    err = 1\n+  endif\n+!$omp task if (.false.) shared(err)\n+  if (omp_in_final ()) then\n+!$omp atomic write\n+    err = 1\n+  endif\n+!$omp task if (.false.) shared(err)\n+  if (omp_in_final ()) then\n+!$omp atomic write\n+    err = 1\n+  endif\n+!$omp end task\n+!$omp end task\n+!$omp atomic read\n+  e = err\n+!$omp task final (e .eq. 0) shared(err)\n+  if (.not.omp_in_final ()) then\n+!$omp atomic write\n+    err = 1\n+  endif\n+!$omp taskyield\n+!$omp taskwait\n+!$omp task shared(err)\n+  if (.not.omp_in_final ()) then\n+!$omp atomic write\n+    err = 1\n+  endif\n+!$omp end task\n+!$omp end task\n+!$omp end parallel\n+!$omp atomic read\n+  e = err\n+  if (e .ne. 0) call abort\n+end"}]}