{"sha": "8b404dac662e36a1dcce3f48b06a04a13ab48fae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI0MDRkYWM2NjJlMzZhMWRjY2UzZjQ4YjA2YTA0YTEzYWI0OGZhZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:42:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:42:01Z"}, "message": "[multiple changes]\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb: Add with and use clause for Stringt.\n\t(Expand_Contract_Cases): Moved from sem_ch6. Add formal parameters\n\tDecls and Stmts along with comments on their usage.\n\t* exp_ch6.ads (Expand_Contract_Cases): Moved from sem_ch6.\n\t* sem_ch6.adb (Expand_Contract_Cases): Moved to exp_ch6.\n\t(Process_Contract_Cases): Update the call to Expand_Contract_Cases.\n\n2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat_rm.texi: Minor editing, to clarify use of dimension aspects.\n\t* sem_util.adb (Is_OK_Variable_For_Out_Formal): Reject an\n\taggregate for a packed type, which may be converted into an\n\tunchecked conversion of an object.\n\nFrom-SVN: r198292", "tree": {"sha": "d837d4449d002f3e4cd86f10b669bbf2bd037dd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d837d4449d002f3e4cd86f10b669bbf2bd037dd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b404dac662e36a1dcce3f48b06a04a13ab48fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b404dac662e36a1dcce3f48b06a04a13ab48fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b404dac662e36a1dcce3f48b06a04a13ab48fae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b404dac662e36a1dcce3f48b06a04a13ab48fae/comments", "author": null, "committer": null, "parents": [{"sha": "7be8338dbcc4e915333cf484eec6ab61ff923aac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7be8338dbcc4e915333cf484eec6ab61ff923aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7be8338dbcc4e915333cf484eec6ab61ff923aac"}], "stats": {"total": 1037, "additions": 551, "deletions": 486}, "files": [{"sha": "1071a704da3636b227d81f655fabb6688089a840", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8b404dac662e36a1dcce3f48b06a04a13ab48fae", "patch": "@@ -1,3 +1,19 @@\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb: Add with and use clause for Stringt.\n+\t(Expand_Contract_Cases): Moved from sem_ch6. Add formal parameters\n+\tDecls and Stmts along with comments on their usage.\n+\t* exp_ch6.ads (Expand_Contract_Cases): Moved from sem_ch6.\n+\t* sem_ch6.adb (Expand_Contract_Cases): Moved to exp_ch6.\n+\t(Process_Contract_Cases): Update the call to Expand_Contract_Cases.\n+\n+2013-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat_rm.texi: Minor editing, to clarify use of dimension aspects.\n+\t* sem_util.adb (Is_OK_Variable_For_Out_Formal): Reject an\n+\taggregate for a packed type, which may be converted into an\n+\tunchecked conversion of an object.\n+\n 2013-04-25  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb: Minor code reorganization (correct misspelling"}, {"sha": "34f61c894d61909bb52377e3f9d932c93a2bd39a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8b404dac662e36a1dcce3f48b06a04a13ab48fae", "patch": "@@ -74,6 +74,7 @@ with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -4117,6 +4118,476 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Call;\n \n+   ---------------------------\n+   -- Expand_Contract_Cases --\n+   ---------------------------\n+\n+   --  Pragma Contract_Cases is expanded in the following manner:\n+\n+   --    subprogram S is\n+   --       Flag_1   : Boolean := False;\n+   --       . . .\n+   --       Flag_N   : Boolean := False;\n+   --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n+   --       Count    : Natural := 0;\n+\n+   --       <preconditions (if any)>\n+\n+   --       if Case_Guard_1 then\n+   --          Flag_1 := True;\n+   --          Count  := Count + 1;\n+   --       end if;\n+   --       . . .\n+   --       if Case_Guard_N then\n+   --          Flag_N := True;\n+   --          Count  := Count + 1;\n+   --       end if;\n+\n+   --       if Count = 0 then\n+   --          raise Assertion_Error with \"xxx contract cases incomplete\";\n+   --            <or>\n+   --          Flag_N+1 := True;  --  when \"others\" present\n+\n+   --       elsif Count > 1 then\n+   --          declare\n+   --             Str0 : constant String :=\n+   --                      \"contract cases overlap for subprogram ABC\";\n+   --             Str1 : constant String :=\n+   --                      (if Flag_1 then\n+   --                         Str0 & \"case guard at xxx evaluates to True\"\n+   --                       else Str0);\n+   --             StrN : constant String :=\n+   --                      (if Flag_N then\n+   --                         StrN-1 & \"case guard at xxx evaluates to True\"\n+   --                       else StrN-1);\n+   --          begin\n+   --             raise Assertion_Error with StrN;\n+   --          end;\n+   --       end if;\n+\n+   --       procedure _Postconditions is\n+   --       begin\n+   --          <postconditions (if any)>\n+\n+   --          if Flag_1 and then not Consequence_1 then\n+   --             raise Assertion_Error with \"failed contract case at xxx\";\n+   --          end if;\n+   --          . . .\n+   --          if Flag_N[+1] and then not Consequence_N[+1] then\n+   --             raise Assertion_Error with \"failed contract case at xxx\";\n+   --          end if;\n+   --       end _Postconditions;\n+   --    begin\n+   --       . . .\n+   --    end S;\n+\n+   procedure Expand_Contract_Cases\n+     (CCs     : Node_Id;\n+      Subp_Id : Entity_Id;\n+      Decls   : List_Id;\n+      Stmts   : in out List_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (CCs);\n+\n+      procedure Case_Guard_Error\n+        (Decls     : List_Id;\n+         Flag      : Entity_Id;\n+         Error_Loc : Source_Ptr;\n+         Msg       : in out Entity_Id);\n+      --  Given a declarative list Decls, status flag Flag, the location of the\n+      --  error and a string Msg, construct the following check:\n+      --    Msg : constant String :=\n+      --            (if Flag then\n+      --                Msg & \"case guard at Error_Loc evaluates to True\"\n+      --             else Msg);\n+      --  The resulting code is added to Decls\n+\n+      procedure Consequence_Error\n+        (Checks : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id);\n+      --  Given an if statement Checks, status flag Flag and a consequence\n+      --  Conseq, construct the following check:\n+      --    [els]if Flag and then not Conseq then\n+      --       raise Assertion_Error\n+      --         with \"failed contract case at Sloc (Conseq)\";\n+      --    [end if;]\n+      --  The resulting code is added to Checks\n+\n+      function Declaration_Of (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a boolean flag, generate:\n+      --    Id : Boolean := False;\n+\n+      function Increment (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a numerical variable, generate:\n+      --    Id := Id + 1;\n+\n+      function Set (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a boolean variable, generate:\n+      --    Id := True;\n+\n+      ----------------------\n+      -- Case_Guard_Error --\n+      ----------------------\n+\n+      procedure Case_Guard_Error\n+        (Decls     : List_Id;\n+         Flag      : Entity_Id;\n+         Error_Loc : Source_Ptr;\n+         Msg       : in out Entity_Id)\n+      is\n+         New_Line : constant Character := Character'Val (10);\n+         New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n+\n+      begin\n+         Start_String;\n+         Store_String_Char  (New_Line);\n+         Store_String_Chars (\"  case guard at \");\n+         Store_String_Chars (Build_Location_String (Error_Loc));\n+         Store_String_Chars (\" evaluates to True\");\n+\n+         --  Generate:\n+         --    New_Msg : constant String :=\n+         --      (if Flag then\n+         --          Msg & \"case guard at Error_Loc evaluates to True\"\n+         --       else Msg);\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => New_Msg,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Standard_String, Loc),\n+             Expression          =>\n+               Make_If_Expression (Loc,\n+                 Expressions => New_List (\n+                   New_Reference_To (Flag, Loc),\n+\n+                   Make_Op_Concat (Loc,\n+                     Left_Opnd  => New_Reference_To (Msg, Loc),\n+                     Right_Opnd => Make_String_Literal (Loc, End_String)),\n+\n+                   New_Reference_To (Msg, Loc)))));\n+\n+         Msg := New_Msg;\n+      end Case_Guard_Error;\n+\n+      -----------------------\n+      -- Consequence_Error --\n+      -----------------------\n+\n+      procedure Consequence_Error\n+        (Checks : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id)\n+      is\n+         Cond  : Node_Id;\n+         Error : Node_Id;\n+\n+      begin\n+         --  Generate:\n+         --    Flag and then not Conseq\n+\n+         Cond :=\n+           Make_And_Then (Loc,\n+             Left_Opnd  => New_Reference_To (Flag, Loc),\n+             Right_Opnd =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd => Relocate_Node (Conseq)));\n+\n+         --  Generate:\n+         --    raise Assertion_Error\n+         --      with \"failed contract case at Sloc (Conseq)\";\n+\n+         Start_String;\n+         Store_String_Chars (\"failed contract case at \");\n+         Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n+\n+         Error :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+             Parameter_Associations => New_List (\n+               Make_String_Literal (Loc, End_String)));\n+\n+         if No (Checks) then\n+            Checks :=\n+              Make_If_Statement (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Error));\n+\n+         else\n+            if No (Elsif_Parts (Checks)) then\n+               Set_Elsif_Parts (Checks, New_List);\n+            end if;\n+\n+            Append_To (Elsif_Parts (Checks),\n+              Make_Elsif_Part (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Error)));\n+         end if;\n+      end Consequence_Error;\n+\n+      --------------------\n+      -- Declaration_Of --\n+      --------------------\n+\n+      function Declaration_Of (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Id,\n+             Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n+             Expression          => New_Reference_To (Standard_False, Loc));\n+      end Declaration_Of;\n+\n+      ---------------\n+      -- Increment --\n+      ---------------\n+\n+      function Increment (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Id, Loc),\n+             Expression =>\n+               Make_Op_Add (Loc,\n+                 Left_Opnd  => New_Reference_To (Id, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+      end Increment;\n+\n+      ---------\n+      -- Set --\n+      ---------\n+\n+      function Set (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Id, Loc),\n+             Expression => New_Reference_To (Standard_True, Loc));\n+      end Set;\n+\n+      --  Local variables\n+\n+      Aggr          : constant Node_Id :=\n+                        Expression (First\n+                          (Pragma_Argument_Associations (CCs)));\n+      Case_Guard    : Node_Id;\n+      CG_Checks     : Node_Id;\n+      CG_Stmts      : List_Id;\n+      Conseq        : Node_Id;\n+      Conseq_Checks : Node_Id := Empty;\n+      Count         : Entity_Id;\n+      Error_Decls   : List_Id;\n+      Flag          : Entity_Id;\n+      Msg_Str       : Entity_Id;\n+      Multiple_PCs  : Boolean;\n+      Others_Flag   : Entity_Id := Empty;\n+      Post_Case     : Node_Id;\n+\n+   --  Start of processing for Expand_Contract_Cases\n+\n+   begin\n+      --  Do nothing if pragma is not enabled. If pragma is disabled, it has\n+      --  already been rewritten as a Null statement.\n+\n+      if Is_Ignored (CCs) then\n+         return;\n+\n+      --  Guard against malformed contract cases\n+\n+      elsif Nkind (Aggr) /= N_Aggregate then\n+         return;\n+      end if;\n+\n+      Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n+\n+      --  Create the counter which tracks the number of case guards that\n+      --  evaluate to True.\n+\n+      --    Count : Natural := 0;\n+\n+      Count := Make_Temporary (Loc, 'C');\n+\n+      Prepend_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Count,\n+          Object_Definition   => New_Reference_To (Standard_Natural, Loc),\n+          Expression          => Make_Integer_Literal (Loc, 0)));\n+\n+      --  Create the base error message for multiple overlapping case guards\n+\n+      --    Msg_Str : constant String :=\n+      --                \"contract cases overlap for subprogram Subp_Id\";\n+\n+      if Multiple_PCs then\n+         Msg_Str := Make_Temporary (Loc, 'S');\n+\n+         Start_String;\n+         Store_String_Chars (\"contract cases overlap for subprogram \");\n+         Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n+\n+         Error_Decls := New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Msg_Str,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Standard_String, Loc),\n+             Expression          => Make_String_Literal (Loc, End_String)));\n+      end if;\n+\n+      --  Process individual post cases\n+\n+      Post_Case := First (Component_Associations (Aggr));\n+      while Present (Post_Case) loop\n+         Case_Guard := First (Choices (Post_Case));\n+         Conseq     := Expression (Post_Case);\n+\n+         --  The \"others\" choice requires special processing\n+\n+         if Nkind (Case_Guard) = N_Others_Choice then\n+            Others_Flag := Make_Temporary (Loc, 'F');\n+            Prepend_To (Decls, Declaration_Of (Others_Flag));\n+\n+            --  Check possible overlap between a case guard and \"others\"\n+\n+            if Multiple_PCs and Exception_Extra_Info then\n+               Case_Guard_Error\n+                 (Decls     => Error_Decls,\n+                  Flag      => Others_Flag,\n+                  Error_Loc => Sloc (Case_Guard),\n+                  Msg       => Msg_Str);\n+            end if;\n+\n+            --  Check the corresponding consequence of \"others\"\n+\n+            Consequence_Error\n+              (Checks => Conseq_Checks,\n+               Flag   => Others_Flag,\n+               Conseq => Conseq);\n+\n+         --  Regular post case\n+\n+         else\n+            --  Create the flag which tracks the state of its associated case\n+            --  guard.\n+\n+            Flag := Make_Temporary (Loc, 'F');\n+            Prepend_To (Decls, Declaration_Of (Flag));\n+\n+            --  The flag is set when the case guard is evaluated to True\n+            --    if Case_Guard then\n+            --       Flag  := True;\n+            --       Count := Count + 1;\n+            --    end if;\n+\n+            Append_To (Decls,\n+              Make_If_Statement (Loc,\n+                Condition       => Relocate_Node (Case_Guard),\n+                Then_Statements => New_List (\n+                  Set (Flag),\n+                  Increment (Count))));\n+\n+            --  Check whether this case guard overlaps with another one\n+\n+            if Multiple_PCs and Exception_Extra_Info then\n+               Case_Guard_Error\n+                 (Decls     => Error_Decls,\n+                  Flag      => Flag,\n+                  Error_Loc => Sloc (Case_Guard),\n+                  Msg       => Msg_Str);\n+            end if;\n+\n+            --  The corresponding consequence of the case guard which evaluated\n+            --  to True must hold on exit from the subprogram.\n+\n+            Consequence_Error\n+              (Checks => Conseq_Checks,\n+               Flag   => Flag,\n+               Conseq => Conseq);\n+         end if;\n+\n+         Next (Post_Case);\n+      end loop;\n+\n+      --  Raise Assertion_Error when none of the case guards evaluate to True.\n+      --  The only exception is when we have \"others\", in which case there is\n+      --  no error because \"others\" acts as a default True.\n+\n+      --  Generate:\n+      --    Flag := True;\n+\n+      if Present (Others_Flag) then\n+         CG_Stmts := New_List (Set (Others_Flag));\n+\n+      --  Generate:\n+      --    raise Assertion_Error with \"xxx contract cases incomplete\";\n+\n+      else\n+         Start_String;\n+         Store_String_Chars (Build_Location_String (Loc));\n+         Store_String_Chars (\" contract cases incomplete\");\n+\n+         CG_Stmts := New_List (\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+             Parameter_Associations => New_List (\n+               Make_String_Literal (Loc, End_String))));\n+      end if;\n+\n+      CG_Checks :=\n+        Make_If_Statement (Loc,\n+          Condition       =>\n+            Make_Op_Eq (Loc,\n+              Left_Opnd  => New_Reference_To (Count, Loc),\n+              Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+          Then_Statements => CG_Stmts);\n+\n+      --  Detect a possible failure due to several case guards evaluating to\n+      --  True.\n+\n+      --  Generate:\n+      --    elsif Count > 0 then\n+      --       declare\n+      --          <Error_Decls>\n+      --       begin\n+      --          raise Assertion_Error with <Msg_Str>;\n+      --    end if;\n+\n+      if Multiple_PCs then\n+         Set_Elsif_Parts (CG_Checks, New_List (\n+           Make_Elsif_Part (Loc,\n+             Condition       =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd  => New_Reference_To (Count, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)),\n+\n+             Then_Statements => New_List (\n+               Make_Block_Statement (Loc,\n+                 Declarations               => Error_Decls,\n+                 Handled_Statement_Sequence =>\n+                   Make_Handled_Sequence_Of_Statements (Loc,\n+                     Statements => New_List (\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name                   =>\n+                           New_Reference_To\n+                             (RTE (RE_Raise_Assert_Failure), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Reference_To (Msg_Str, Loc))))))))));\n+      end if;\n+\n+      Append_To (Decls, CG_Checks);\n+\n+      --  Raise Assertion_Error when the corresponding consequence of a case\n+      --  guard that evaluated to True fails.\n+\n+      if No (Stmts) then\n+         Stmts := New_List;\n+      end if;\n+\n+      Append_To (Stmts, Conseq_Checks);\n+   end Expand_Contract_Cases;\n+\n    -------------------------------\n    -- Expand_Ctrl_Function_Call --\n    -------------------------------"}, {"sha": "f9829f52b34b8e338da408ae6d82bf876148f7de", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=8b404dac662e36a1dcce3f48b06a04a13ab48fae", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,6 +71,17 @@ package Exp_Ch6 is\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call.\n \n+   procedure Expand_Contract_Cases\n+     (CCs     : Node_Id;\n+      Subp_Id : Entity_Id;\n+      Decls   : List_Id;\n+      Stmts   : in out List_Id);\n+   --  Given pragma Contract_Cases CCs, create the circuitry needed to evaluate\n+   --  case guards and trigger consequence expressions. Subp_Id is the related\n+   --  subprogram for which the pragma applies. Decls are the declarations of\n+   --  Subp_Id's body. All generated code is added to list Stmts. If Stmts is\n+   --  empty, a new list is created.\n+\n    procedure Freeze_Subprogram (N : Node_Id);\n    --  generate the appropriate expansions related to Subprogram freeze\n    --  nodes (e.g. the filling of the corresponding Dispatch Table for"}, {"sha": "5c1a5475c035f0825a5cae51e445297be0a8b359", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8b404dac662e36a1dcce3f48b06a04a13ab48fae", "patch": "@@ -992,6 +992,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Optimize_Alignment::\n * Pragma Ordered::\n * Pragma Overflow_Mode::\n+* Pragma Overriding_Renamings::\n * Pragma Partition_Elaboration_Policy::\n * Pragma Passive::\n * Pragma Persistent_BSS::\n@@ -4698,6 +4699,25 @@ overflow checking, but does not affect the overflow mode.\n The pragma @code{Unsuppress (Overflow_Check)} unsuppresses (enables)\n overflow checking, but does not affect the overflow mode.\n \n+@node Pragma Overriding_Renamings\n+@unnumberedsec Pragma Overriding_Renamings\n+@findex Overriding_Renamings\n+@cindex Rational profile\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Overriding_Renamings;\n+@end smallexample\n+\n+@noindent\n+\n+This is a GNAT pragma to simplify porting legacy code accepted by the Rational\n+Ada compiler. In the presence of this pragma, a renaming declaration that\n+renames an inherited operation declared in the same scope is legal, even though\n+RM 8.3 (15) stipulates that an overridden operation is not visible within the\n+declaration of the overriding operation.\n+\n @node Pragma Partition_Elaboration_Policy\n @unnumberedsec Pragma Partition_Elaboration_Policy\n @findex Partition_Elaboration_Policy\n@@ -5205,6 +5225,7 @@ The Rational profile is intended to facilitate porting legacy code that\n compiles with the Rational APEX compiler, even when the code includes non-\n conforming Ada constructs.  The profile enables the following three pragmas:\n \n+\n @itemize @bullet\n @item pragma Implicit_Packing\n @item pragma Overriding_Renamings\n@@ -6814,9 +6835,9 @@ This aspect is equivalent to pragma @code{Depends}.\n @unnumberedsec Aspect Dimension\n @findex Dimension\n @noindent\n-The @code{Dimension} aspect is used to define a system of\n-dimensions that will be used in subsequent subtype declarations with\n-@code{Dimension} aspects that reference this system. The syntax is:\n+The @code{Dimension} aspect is used to specify the dimensions of a given\n+subtype of a dimensioned numeric type. The aspect also specifies a symbol\n+used when doing formatted output of dimensioned quantities. The syntax is:\n \n @smallexample @c ada\n with Dimension =>\n@@ -6833,9 +6854,13 @@ RATIONAL ::= [-] NUMERIC_LITERAL [/ NUMERIC_LITERAL]\n @end smallexample\n \n @noindent\n-This aspect can only be applied to a subtype where the parent type has\n-a @code{Dimension_Systen} aspect. It specifies which units apply to\n-the subtype, and the corresponding powers. For examples of the usage\n+This aspect can only be applied to a subtype whose parent type has\n+a @code{Dimension_Systen} aspect. The aspect must specify values for\n+all dimensions of the system. The rational values are the powers of the\n+corresponding dimensions that are used by the compiler to verify that\n+physical (numeric) computations are dimensionally consistent. For example,\n+the computation of a force must result in dimensions (L => 1, M => 1, T => -2).\n+For further examples of the usage\n of this aspect, see package @code{System.Dim.Mks}.\n Note that when the dimensioned type is an integer type, then any\n dimension value must be an integer literal.\n@@ -6864,15 +6889,19 @@ This aspect is applied to a type, which must be a numeric derived type\n will represent values within the dimension system. Each @code{DIMENSION}\n corresponds to one particular dimension. A maximum of 7 dimensions may\n be specified. @code{Unit_Name} is the name of the dimension (for example\n-@code{Meter}). @code{Unit_Symbol} is the short hand used for quantities\n+@code{Meter}). @code{Unit_Symbol} is the shorthand used for quantities\n of this dimension (for example 'm' for Meter). @code{Dim_Symbol} gives\n the identification within the dimension system (typically this is a\n-single letter, e.g. 'L' standing for length for unit name Meter).\n+single letter, e.g. 'L' standing for length for unit name Meter). The\n+Unit_Smbol is used in formatted output of dimensioned quantities. The\n+Dim_Symbol is used in error messages when numeric operations have\n+inconsistent dimensions.\n \n-Although the implementation allows multiple different dimension systems\n-to be defined using this aspect, in practice, nearly all usage of the\n-dimension system will use the standard definition in the run-time\n-package @code{System.Dim.Mks}:\n+GNAT provides the standard definition of the International MKS system in\n+the run-time package @code{System.Dim.Mks}. You can easily define\n+similar packages for cgs units or British units, and define conversion factors\n+between values in different systems. The MKS system is characterized by the\n+following aspect:\n \n @smallexample @c ada\n    type Mks_Type is new Long_Long_Float\n@@ -6888,9 +6917,7 @@ package @code{System.Dim.Mks}:\n @end smallexample\n \n @noindent\n-which correspond to the standard 7-unit dimension system typically\n-used in physical calculations. See section\n-\"Performing Dimensionality Analysis in GNAT\" in the GNAT Users\n+See section \"Performing Dimensionality Analysis in GNAT\" in the GNAT Users\n Guide for detailed examples of use of the dimension system.\n \n @node Aspect Favor_Top_Level"}, {"sha": "0e56e1638863d76e15915e5fc6cb4fd7e165d197", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 468, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8b404dac662e36a1dcce3f48b06a04a13ab48fae", "patch": "@@ -11228,11 +11228,6 @@ package body Sem_Ch6 is\n       --  under the same visibility conditions as for other invariant checks,\n       --  the type invariant must be applied to the returned value.\n \n-      procedure Expand_Contract_Cases (CCs : Node_Id; Subp_Id : Entity_Id);\n-      --  Given pragma Contract_Cases CCs, create the circuitry needed to\n-      --  evaluate case guards and trigger consequence expressions. Subp_Id\n-      --  denotes the related subprogram.\n-\n       function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id;\n       --  Prag contains an analyzed precondition or postcondition pragma. This\n       --  function copies the pragma, changes it to the corresponding Check\n@@ -11324,468 +11319,6 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Access_Invariants;\n \n-      ---------------------------\n-      -- Expand_Contract_Cases --\n-      ---------------------------\n-\n-      --  Pragma Contract_Cases is expanded in the following manner:\n-\n-      --    subprogram S is\n-      --       Flag_1   : Boolean := False;\n-      --       . . .\n-      --       Flag_N   : Boolean := False;\n-      --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n-      --       Count    : Natural := 0;\n-\n-      --       <preconditions (if any)>\n-\n-      --       if Case_Guard_1 then\n-      --          Flag_1 := True;\n-      --          Count  := Count + 1;\n-      --       end if;\n-      --       . . .\n-      --       if Case_Guard_N then\n-      --          Flag_N := True;\n-      --          Count  := Count + 1;\n-      --       end if;\n-\n-      --       if Count = 0 then\n-      --          raise Assertion_Error with \"xxx contract cases incomplete\";\n-      --            <or>\n-      --          Flag_N+1 := True;  --  when \"others\" present\n-\n-      --       elsif Count > 1 then\n-      --          declare\n-      --             Str0 : constant String :=\n-      --                      \"contract cases overlap for subprogram ABC\";\n-      --             Str1 : constant String :=\n-      --                      (if Flag_1 then\n-      --                         Str0 & \"case guard at xxx evaluates to True\"\n-      --                       else Str0);\n-      --             StrN : constant String :=\n-      --                      (if Flag_N then\n-      --                         StrN-1 & \"case guard at xxx evaluates to True\"\n-      --                       else StrN-1);\n-      --          begin\n-      --             raise Assertion_Error with StrN;\n-      --          end;\n-      --       end if;\n-\n-      --       procedure _Postconditions is\n-      --       begin\n-      --          <postconditions (if any)>\n-\n-      --          if Flag_1 and then not Consequence_1 then\n-      --             raise Assertion_Error with \"failed contract case at xxx\";\n-      --          end if;\n-      --          . . .\n-      --          if Flag_N[+1] and then not Consequence_N[+1] then\n-      --             raise Assertion_Error with \"failed contract case at xxx\";\n-      --          end if;\n-      --       end _Postconditions;\n-      --    begin\n-      --       . . .\n-      --    end S;\n-\n-      procedure Expand_Contract_Cases (CCs : Node_Id; Subp_Id : Entity_Id) is\n-         Loc : constant Source_Ptr := Sloc (CCs);\n-\n-         procedure Case_Guard_Error\n-           (Decls     : List_Id;\n-            Flag      : Entity_Id;\n-            Error_Loc : Source_Ptr;\n-            Msg       : in out Entity_Id);\n-         --  Given a declarative list Decls, status flag Flag, the location of\n-         --  the error and a string Msg, construct the following check:\n-         --    Msg : constant String :=\n-         --            (if Flag then\n-         --                Msg & \"case guard at Error_Loc evaluates to True\"\n-         --             else Msg);\n-         --  The resulting code is added to Decls\n-\n-         procedure Consequence_Error\n-           (Checks : in out Node_Id;\n-            Flag   : Entity_Id;\n-            Conseq : Node_Id);\n-         --  Given an if statement Checks, status flag Flag and a consequence\n-         --  Conseq, construct the following check:\n-         --    [els]if Flag and then not Conseq then\n-         --       raise Assertion_Error\n-         --         with \"failed contract case at Sloc (Conseq)\";\n-         --    [end if;]\n-         --  The resulting code is added to Checks\n-\n-         function Declaration_Of (Id : Entity_Id) return Node_Id;\n-         --  Given the entity Id of a boolean flag, generate:\n-         --    Id : Boolean := False;\n-\n-         function Increment (Id : Entity_Id) return Node_Id;\n-         --  Given the entity Id of a numerical variable, generate:\n-         --    Id := Id + 1;\n-\n-         function Set (Id : Entity_Id) return Node_Id;\n-         --  Given the entity Id of a boolean variable, generate:\n-         --    Id := True;\n-\n-         ----------------------\n-         -- Case_Guard_Error --\n-         ----------------------\n-\n-         procedure Case_Guard_Error\n-           (Decls     : List_Id;\n-            Flag      : Entity_Id;\n-            Error_Loc : Source_Ptr;\n-            Msg       : in out Entity_Id)\n-         is\n-            New_Line : constant Character := Character'Val (10);\n-            New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n-\n-         begin\n-            Start_String;\n-            Store_String_Char  (New_Line);\n-            Store_String_Chars (\"  case guard at \");\n-            Store_String_Chars (Build_Location_String (Error_Loc));\n-            Store_String_Chars (\" evaluates to True\");\n-\n-            --  Generate:\n-            --    New_Msg : constant String :=\n-            --      (if Flag then\n-            --          Msg & \"case guard at Error_Loc evaluates to True\"\n-            --       else Msg);\n-\n-            Append_To (Decls,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => New_Msg,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (Standard_String, Loc),\n-                Expression          =>\n-                  Make_If_Expression (Loc,\n-                    Expressions => New_List (\n-                      New_Reference_To (Flag, Loc),\n-\n-                      Make_Op_Concat (Loc,\n-                        Left_Opnd  => New_Reference_To (Msg, Loc),\n-                        Right_Opnd => Make_String_Literal (Loc, End_String)),\n-\n-                      New_Reference_To (Msg, Loc)))));\n-\n-            Msg := New_Msg;\n-         end Case_Guard_Error;\n-\n-         -----------------------\n-         -- Consequence_Error --\n-         -----------------------\n-\n-         procedure Consequence_Error\n-           (Checks : in out Node_Id;\n-            Flag   : Entity_Id;\n-            Conseq : Node_Id)\n-         is\n-            Cond  : Node_Id;\n-            Error : Node_Id;\n-\n-         begin\n-            --  Generate:\n-            --    Flag and then not Conseq\n-\n-            Cond :=\n-              Make_And_Then (Loc,\n-                Left_Opnd  => New_Reference_To (Flag, Loc),\n-                Right_Opnd =>\n-                  Make_Op_Not (Loc,\n-                    Right_Opnd => Relocate_Node (Conseq)));\n-\n-            --  Generate:\n-            --    raise Assertion_Error\n-            --      with \"failed contract case at Sloc (Conseq)\";\n-\n-            Start_String;\n-            Store_String_Chars (\"failed contract case at \");\n-            Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n-\n-            Error :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-                Parameter_Associations => New_List (\n-                  Make_String_Literal (Loc, End_String)));\n-\n-            if No (Checks) then\n-               Checks :=\n-                 Make_If_Statement (Loc,\n-                   Condition       => Cond,\n-                   Then_Statements => New_List (Error));\n-\n-            else\n-               if No (Elsif_Parts (Checks)) then\n-                  Set_Elsif_Parts (Checks, New_List);\n-               end if;\n-\n-               Append_To (Elsif_Parts (Checks),\n-                 Make_Elsif_Part (Loc,\n-                   Condition       => Cond,\n-                   Then_Statements => New_List (Error)));\n-            end if;\n-         end Consequence_Error;\n-\n-         --------------------\n-         -- Declaration_Of --\n-         --------------------\n-\n-         function Declaration_Of (Id : Entity_Id) return Node_Id is\n-         begin\n-            return\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Id,\n-                Object_Definition   =>\n-                  New_Reference_To (Standard_Boolean, Loc),\n-                Expression          =>\n-                  New_Reference_To (Standard_False, Loc));\n-         end Declaration_Of;\n-\n-         ---------------\n-         -- Increment --\n-         ---------------\n-\n-         function Increment (Id : Entity_Id) return Node_Id is\n-         begin\n-            return\n-              Make_Assignment_Statement (Loc,\n-                Name       => New_Reference_To (Id, Loc),\n-                Expression =>\n-                  Make_Op_Add (Loc,\n-                    Left_Opnd  => New_Reference_To (Id, Loc),\n-                    Right_Opnd => Make_Integer_Literal (Loc, 1)));\n-         end Increment;\n-\n-         ---------\n-         -- Set --\n-         ---------\n-\n-         function Set (Id : Entity_Id) return Node_Id is\n-         begin\n-            return\n-              Make_Assignment_Statement (Loc,\n-                Name       => New_Reference_To (Id, Loc),\n-                Expression => New_Reference_To (Standard_True, Loc));\n-         end Set;\n-\n-         --  Local variables\n-\n-         Aggr          : constant Node_Id :=\n-                           Expression (First\n-                             (Pragma_Argument_Associations (CCs)));\n-         Decls         : constant List_Id := Declarations (N);\n-         Case_Guard    : Node_Id;\n-         CG_Checks     : Node_Id;\n-         CG_Stmts      : List_Id;\n-         Conseq        : Node_Id;\n-         Conseq_Checks : Node_Id := Empty;\n-         Count         : Entity_Id;\n-         Error_Decls   : List_Id;\n-         Flag          : Entity_Id;\n-         Msg_Str       : Entity_Id;\n-         Multiple_PCs  : Boolean;\n-         Others_Flag   : Entity_Id := Empty;\n-         Post_Case     : Node_Id;\n-\n-      --  Start of processing for Expand_Contract_Cases\n-\n-      begin\n-         --  Do nothing if pragma is not enabled. If pragma is disabled, it has\n-         --  already been rewritten as a Null statement.\n-\n-         if Is_Ignored (CCs) then\n-            return;\n-\n-         --  Guard against malformed contract cases\n-\n-         elsif Nkind (Aggr) /= N_Aggregate then\n-            return;\n-         end if;\n-\n-         Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n-\n-         --  Create the counter which tracks the number of case guards that\n-         --  evaluate to True.\n-\n-         --    Count : Natural := 0;\n-\n-         Count := Make_Temporary (Loc, 'C');\n-\n-         Prepend_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Count,\n-             Object_Definition   => New_Reference_To (Standard_Natural, Loc),\n-             Expression          => Make_Integer_Literal (Loc, 0)));\n-\n-         --  Create the base error message for multiple overlapping case\n-         --  guards.\n-\n-         --    Msg_Str : constant String :=\n-         --                \"contract cases overlap for subprogram Subp_Id\";\n-\n-         if Multiple_PCs then\n-            Msg_Str := Make_Temporary (Loc, 'S');\n-\n-            Start_String;\n-            Store_String_Chars (\"contract cases overlap for subprogram \");\n-            Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n-\n-            Error_Decls := New_List (\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Msg_Str,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (Standard_String, Loc),\n-                Expression          => Make_String_Literal (Loc, End_String)));\n-         end if;\n-\n-         --  Process individual post cases\n-\n-         Post_Case := First (Component_Associations (Aggr));\n-         while Present (Post_Case) loop\n-            Case_Guard := First (Choices (Post_Case));\n-            Conseq     := Expression (Post_Case);\n-\n-            --  The \"others\" choice requires special processing\n-\n-            if Nkind (Case_Guard) = N_Others_Choice then\n-               Others_Flag := Make_Temporary (Loc, 'F');\n-               Prepend_To (Decls, Declaration_Of (Others_Flag));\n-\n-               --  Check possible overlap between a case guard and \"others\"\n-\n-               if Multiple_PCs and Exception_Extra_Info then\n-                  Case_Guard_Error\n-                    (Decls     => Error_Decls,\n-                     Flag      => Others_Flag,\n-                     Error_Loc => Sloc (Case_Guard),\n-                     Msg       => Msg_Str);\n-               end if;\n-\n-               --  Check the corresponding consequence of \"others\"\n-\n-               Consequence_Error\n-                 (Checks => Conseq_Checks,\n-                  Flag   => Others_Flag,\n-                  Conseq => Conseq);\n-\n-            --  Regular post case\n-\n-            else\n-               --  Create the flag which tracks the state of its associated\n-               --  case guard.\n-\n-               Flag := Make_Temporary (Loc, 'F');\n-               Prepend_To (Decls, Declaration_Of (Flag));\n-\n-               --  The flag is set when the case guard is evaluated to True\n-               --    if Case_Guard then\n-               --       Flag  := True;\n-               --       Count := Count + 1;\n-               --    end if;\n-\n-               Append_To (Decls,\n-                 Make_If_Statement (Loc,\n-                   Condition       => Relocate_Node (Case_Guard),\n-                   Then_Statements => New_List (\n-                     Set (Flag),\n-                     Increment (Count))));\n-\n-               --  Check whether this case guard overlaps with another one\n-\n-               if Multiple_PCs and Exception_Extra_Info then\n-                  Case_Guard_Error\n-                    (Decls     => Error_Decls,\n-                     Flag      => Flag,\n-                     Error_Loc => Sloc (Case_Guard),\n-                     Msg       => Msg_Str);\n-               end if;\n-\n-               --  The corresponding consequence of the case guard which\n-               --  evaluated to True must hold on exit from the subprogram.\n-\n-               Consequence_Error (Conseq_Checks, Flag, Conseq);\n-            end if;\n-\n-            Next (Post_Case);\n-         end loop;\n-\n-         --  Raise Assertion_Error when none of the case guards evaluate to\n-         --  True. The only exception is when we have \"others\", in which case\n-         --  there is no error because \"others\" acts as a default True.\n-\n-         --  Generate:\n-         --    Flag := True;\n-\n-         if Present (Others_Flag) then\n-            CG_Stmts := New_List (Set (Others_Flag));\n-\n-         --  Generate:\n-         --    raise Assertion_Error with \"xxx contract cases incomplete\";\n-\n-         else\n-            Start_String;\n-            Store_String_Chars (Build_Location_String (Loc));\n-            Store_String_Chars (\" contract cases incomplete\");\n-\n-            CG_Stmts := New_List (\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-                Parameter_Associations => New_List (\n-                  Make_String_Literal (Loc, End_String))));\n-         end if;\n-\n-         CG_Checks :=\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               Make_Op_Eq (Loc,\n-                 Left_Opnd  => New_Reference_To (Count, Loc),\n-                 Right_Opnd => Make_Integer_Literal (Loc, 0)),\n-             Then_Statements => CG_Stmts);\n-\n-         --  Detect a possible failure due to several case guards evaluating to\n-         --  True.\n-\n-         --  Generate:\n-         --    elsif Count > 0 then\n-         --       declare\n-         --          <Error_Decls>\n-         --       begin\n-         --          raise Assertion_Error with <Msg_Str>;\n-         --    end if;\n-\n-         if Multiple_PCs then\n-            Set_Elsif_Parts (CG_Checks, New_List (\n-              Make_Elsif_Part (Loc,\n-                Condition       =>\n-                  Make_Op_Gt (Loc,\n-                    Left_Opnd  => New_Reference_To (Count, Loc),\n-                    Right_Opnd => Make_Integer_Literal (Loc, 1)),\n-\n-                Then_Statements => New_List (\n-                  Make_Block_Statement (Loc,\n-                    Declarations               => Error_Decls,\n-                    Handled_Statement_Sequence =>\n-                      Make_Handled_Sequence_Of_Statements (Loc,\n-                        Statements => New_List (\n-                          Make_Procedure_Call_Statement (Loc,\n-                            Name                   =>\n-                              New_Reference_To\n-                                (RTE (RE_Raise_Assert_Failure), Loc),\n-                            Parameter_Associations => New_List (\n-                              New_Reference_To (Msg_Str, Loc))))))))));\n-         end if;\n-\n-         Append_To (Decls, CG_Checks);\n-\n-         --  Raise Assertion_Error when the corresponding consequence of a case\n-         --  guard that evaluated to True fails.\n-\n-         Append_Enabled_Item (Conseq_Checks, Plist);\n-      end Expand_Contract_Cases;\n-\n       --------------\n       -- Grab_PPC --\n       --------------\n@@ -12288,7 +11821,11 @@ package body Sem_Ch6 is\n                Prag := Contract_Test_Cases (Contract (Spec));\n                loop\n                   if Pragma_Name (Prag) = Name_Contract_Cases then\n-                     Expand_Contract_Cases (Prag, Spec_Id);\n+                     Expand_Contract_Cases\n+                       (CCs     => Prag,\n+                        Subp_Id => Spec_Id,\n+                        Decls   => Declarations (N),\n+                        Stmts   => Plist);\n                   end if;\n \n                   Prag := Next_Pragma (Prag);"}, {"sha": "653a6ba0a267598b74a62ffc318091eff423cb0c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b404dac662e36a1dcce3f48b06a04a13ab48fae/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8b404dac662e36a1dcce3f48b06a04a13ab48fae", "patch": "@@ -8909,10 +8909,13 @@ package body Sem_Util is\n       --  parameters in cases where code generation is unaffected. We tell\n       --  source unchecked conversions by seeing if they are rewrites of an\n       --  original Unchecked_Conversion function call, or of an explicit\n-      --  conversion of a function call.\n+      --  conversion of a function call or an aggregate (as may happen in the\n+      --  expansion of a packed array aggregate).\n \n       elsif Nkind (AV) = N_Unchecked_Type_Conversion then\n-         if Nkind (Original_Node (AV)) = N_Function_Call then\n+         if Nkind_In (Original_Node (AV),\n+                        N_Function_Call, N_Aggregate)\n+         then\n             return False;\n \n          elsif Comes_From_Source (AV)"}]}