{"sha": "6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "node_id": "C_kwDOANBUbNoAKDZmNzk4NjE4YzA3MGUyY2E1MDVlMzljM2ZjYzBjM2NhNDc4YWM4MWI", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:28Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:28Z"}, "message": "vect: Use generalised accessors to build SLP nodes\n\nThis patch adds:\n\n- gimple_num_args\n- gimple_arg\n- gimple_arg_ptr\n\nfor accessing rhs operands of an assignment, call or PHI.  This is\nsimilar to the existing gimple_get_lhs.\n\nI guess there's a danger that these routines could be overused,\nsuch as in cases where gimple_assign_rhs1 etc. would be more\nappropriate.  I think the routines are still worth having though.\nThese days, most new operations are added as internal functions rather\nthan tree codes, so it's useful to be able to handle assignments and\ncalls in a consistent way.\n\nThe patch also generalises the way that SLP child nodes map\nto gimple stmt operands.  This is useful for later patches.\n\ngcc/\n\t* gimple.h (gimple_num_args, gimple_arg, gimple_arg_ptr): New\n\tfunctions.\n\t* tree-vect-slp.c (cond_expr_maps, arg2_map): New variables.\n\t(vect_get_operand_map): New function.\n\t(vect_get_and_check_slp_defs): Fix outdated comment.\n\tUse vect_get_operand_map and new gimple argument accessors.\n\t(vect_build_slp_tree_2): Likewise.", "tree": {"sha": "868d81e39387ac14d9b90c36a68ae530c235bd1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/868d81e39387ac14d9b90c36a68ae530c235bd1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f798618c070e2ca505e39c3fcc0c3ca478ac81b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8de7958fbd126528c5a5a95a068c0692f6a643cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de7958fbd126528c5a5a95a068c0692f6a643cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de7958fbd126528c5a5a95a068c0692f6a643cc"}], "stats": {"total": 186, "additions": 114, "deletions": 72}, "files": [{"sha": "f7fdefc53625d5b9f9dd59a617d4900c0a7e73ec", "filename": "gcc/gimple.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f798618c070e2ca505e39c3fcc0c3ca478ac81b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f798618c070e2ca505e39c3fcc0c3ca478ac81b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "patch": "@@ -4692,6 +4692,44 @@ gimple_phi_arg_has_location (const gphi *phi, size_t i)\n   return gimple_phi_arg_location (phi, i) != UNKNOWN_LOCATION;\n }\n \n+/* Return the number of arguments that can be accessed by gimple_arg.  */\n+\n+static inline unsigned\n+gimple_num_args (const gimple *gs)\n+{\n+  if (auto phi = dyn_cast<const gphi *> (gs))\n+    return gimple_phi_num_args (phi);\n+  if (auto call = dyn_cast<const gcall *> (gs))\n+    return gimple_call_num_args (call);\n+  return gimple_num_ops (as_a <const gassign *> (gs)) - 1;\n+}\n+\n+/* GS must be an assignment, a call, or a PHI.\n+   If it's an assignment, return rhs operand I.\n+   If it's a call, return function argument I.\n+   If it's a PHI, return the value of PHI argument I.  */\n+\n+static inline tree\n+gimple_arg (const gimple *gs, unsigned int i)\n+{\n+  if (auto phi = dyn_cast<const gphi *> (gs))\n+    return gimple_phi_arg_def (phi, i);\n+  if (auto call = dyn_cast<const gcall *> (gs))\n+    return gimple_call_arg (call, i);\n+  return gimple_op (as_a <const gassign *> (gs), i + 1);\n+}\n+\n+/* Return a pointer to gimple_arg (GS, I).  */\n+\n+static inline tree *\n+gimple_arg_ptr (gimple *gs, unsigned int i)\n+{\n+  if (auto phi = dyn_cast<gphi *> (gs))\n+    return gimple_phi_arg_def_ptr (phi, i);\n+  if (auto call = dyn_cast<gcall *> (gs))\n+    return gimple_call_arg_ptr (call, i);\n+  return gimple_op_ptr (as_a <gassign *> (gs), i + 1);\n+}\n \n /* Return the region number for GIMPLE_RESX RESX_STMT.  */\n "}, {"sha": "2cd0b854708f56484c4e66b7eb61ef0ec252e859", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f798618c070e2ca505e39c3fcc0c3ca478ac81b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f798618c070e2ca505e39c3fcc0c3ca478ac81b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "patch": "@@ -454,15 +454,57 @@ vect_def_types_match (enum vect_def_type dta, enum vect_def_type dtb)\n \t      && (dtb == vect_external_def || dtb == vect_constant_def)));\n }\n \n+static const int cond_expr_maps[3][5] = {\n+  { 4, -1, -2, 1, 2 },\n+  { 4, -2, -1, 1, 2 },\n+  { 4, -1, -2, 2, 1 }\n+};\n+static const int arg2_map[] = { 1, 2 };\n+\n+/* For most SLP statements, there is a one-to-one mapping between\n+   gimple arguments and child nodes.  If that is not true for STMT,\n+   return an array that contains:\n+\n+   - the number of child nodes, followed by\n+   - for each child node, the index of the argument associated with that node.\n+     The special index -1 is the first operand of an embedded comparison and\n+     the special index -2 is the second operand of an embedded comparison.\n+\n+   SWAP is as for vect_get_and_check_slp_defs.  */\n+\n+static const int *\n+vect_get_operand_map (const gimple *stmt, unsigned char swap = 0)\n+{\n+  if (auto assign = dyn_cast<const gassign *> (stmt))\n+    {\n+      if (gimple_assign_rhs_code (assign) == COND_EXPR\n+\t  && COMPARISON_CLASS_P (gimple_assign_rhs1 (assign)))\n+\treturn cond_expr_maps[swap];\n+    }\n+  gcc_assert (!swap);\n+  if (auto call = dyn_cast<const gcall *> (stmt))\n+    {\n+      if (gimple_call_internal_p (call))\n+\tswitch (gimple_call_internal_fn (call))\n+\t  {\n+\t  case IFN_MASK_LOAD:\n+\t    return arg2_map;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+    }\n+  return nullptr;\n+}\n+\n /* Get the defs for the rhs of STMT (collect them in OPRNDS_INFO), check that\n    they are of a valid type and that they match the defs of the first stmt of\n    the SLP group (stored in OPRNDS_INFO).  This function tries to match stmts\n-   by swapping operands of STMTS[STMT_NUM] when possible.  Non-zero *SWAP\n-   indicates swap is required for cond_expr stmts.  Specifically, *SWAP\n+   by swapping operands of STMTS[STMT_NUM] when possible.  Non-zero SWAP\n+   indicates swap is required for cond_expr stmts.  Specifically, SWAP\n    is 1 if STMT is cond and operands of comparison need to be swapped;\n-   *SWAP is 2 if STMT is cond and code of comparison needs to be inverted.\n-   If there is any operand swap in this function, *SWAP is set to non-zero\n-   value.\n+   SWAP is 2 if STMT is cond and code of comparison needs to be inverted.\n+\n    If there was a fatal error return -1; if the error could be corrected by\n    swapping operands of father node of this one, return 1; if everything is\n    ok return 0.  */\n@@ -477,76 +519,48 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n   unsigned int i, number_of_oprnds;\n   enum vect_def_type dt = vect_uninitialized_def;\n   slp_oprnd_info oprnd_info;\n-  int first_op_idx = 1;\n   unsigned int commutative_op = -1U;\n-  bool first_op_cond = false;\n   bool first = stmt_num == 0;\n \n+  if (!is_a<gcall *> (stmt_info->stmt)\n+      && !is_a<gassign *> (stmt_info->stmt)\n+      && !is_a<gphi *> (stmt_info->stmt))\n+    return -1;\n+\n+  number_of_oprnds = gimple_num_args (stmt_info->stmt);\n+  const int *map = vect_get_operand_map (stmt_info->stmt, swap);\n+  if (map)\n+    number_of_oprnds = *map++;\n   if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n     {\n-      number_of_oprnds = gimple_call_num_args (stmt);\n-      first_op_idx = 3;\n       if (gimple_call_internal_p (stmt))\n \t{\n \t  internal_fn ifn = gimple_call_internal_fn (stmt);\n \t  commutative_op = first_commutative_argument (ifn);\n-\n-\t  /* Masked load, only look at mask.  */\n-\t  if (ifn == IFN_MASK_LOAD)\n-\t    {\n-\t      number_of_oprnds = 1;\n-\t      /* Mask operand index.  */\n-\t      first_op_idx = 5;\n-\t    }\n \t}\n     }\n   else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n-      enum tree_code code = gimple_assign_rhs_code (stmt);\n-      number_of_oprnds = gimple_num_ops (stmt) - 1;\n-      /* Swap can only be done for cond_expr if asked to, otherwise we\n-\t could result in different comparison code to the first stmt.  */\n-      if (code == COND_EXPR\n-\t  && COMPARISON_CLASS_P (gimple_assign_rhs1 (stmt)))\n-\t{\n-\t  first_op_cond = true;\n-\t  number_of_oprnds++;\n-\t}\n-      else\n-\tcommutative_op = commutative_tree_code (code) ? 0U : -1U;\n+      if (commutative_tree_code (gimple_assign_rhs_code (stmt)))\n+\tcommutative_op = 0;\n     }\n-  else if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n-    number_of_oprnds = gimple_phi_num_args (stmt);\n-  else\n-    return -1;\n \n   bool swapped = (swap != 0);\n   bool backedge = false;\n-  gcc_assert (!swapped || first_op_cond);\n   enum vect_def_type *dts = XALLOCAVEC (enum vect_def_type, number_of_oprnds);\n   for (i = 0; i < number_of_oprnds; i++)\n     {\n-      if (first_op_cond)\n-\t{\n-\t  /* Map indicating how operands of cond_expr should be swapped.  */\n-\t  int maps[3][4] = {{0, 1, 2, 3}, {1, 0, 2, 3}, {0, 1, 3, 2}};\n-\t  int *map = maps[swap];\n-\n-\t  if (i < 2)\n-\t    oprnd = TREE_OPERAND (gimple_op (stmt_info->stmt,\n-\t\t\t\t\t     first_op_idx), map[i]);\n-\t  else\n-\t    oprnd = gimple_op (stmt_info->stmt, map[i]);\n-\t}\n-      else if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n+      int opno = map ? map[i] : int (i);\n+      if (opno < 0)\n+\toprnd = TREE_OPERAND (gimple_arg (stmt_info->stmt, 0), -1 - opno);\n+      else\n \t{\n-\t  oprnd = gimple_phi_arg_def (stmt, i);\n-\t  backedge = dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t     gimple_phi_arg_edge (stmt, i)->src,\n-\t\t\t\t     gimple_bb (stmt_info->stmt));\n+\t  oprnd = gimple_arg (stmt_info->stmt, opno);\n+\t  if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n+\t    backedge = dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t       gimple_phi_arg_edge (stmt, opno)->src,\n+\t\t\t\t       gimple_bb (stmt_info->stmt));\n \t}\n-      else\n-\toprnd = gimple_op (stmt_info->stmt, first_op_idx + (swapped ? !i : i));\n       if (TREE_CODE (oprnd) == VIEW_CONVERT_EXPR)\n \toprnd = TREE_OPERAND (oprnd, 0);\n \n@@ -1140,9 +1154,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n \t  if (need_same_oprnds)\n \t    {\n-\t      tree other_op1 = (call_stmt\n-\t\t\t\t? gimple_call_arg (call_stmt, 1)\n-\t\t\t\t: gimple_assign_rhs2 (stmt));\n+\t      tree other_op1 = gimple_arg (stmt, 1);\n \t      if (!operand_equal_p (first_op1, other_op1, 0))\n \t\t{\n \t\t  if (dump_enabled_p ())\n@@ -1601,19 +1613,15 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n   matches[0] = false;\n \n   stmt_vec_info stmt_info = stmts[0];\n-  if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n-    nops = gimple_call_num_args (stmt);\n-  else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n-    {\n-      nops = gimple_num_ops (stmt) - 1;\n-      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n-\tnops++;\n-    }\n-  else if (gphi *phi = dyn_cast <gphi *> (stmt_info->stmt))\n-    nops = gimple_phi_num_args (phi);\n-  else\n+  if (!is_a<gcall *> (stmt_info->stmt)\n+      && !is_a<gassign *> (stmt_info->stmt)\n+      && !is_a<gphi *> (stmt_info->stmt))\n     return NULL;\n \n+  nops = gimple_num_args (stmt_info->stmt);\n+  if (const int *map = vect_get_operand_map (stmt_info->stmt))\n+    nops = map[0];\n+\n   /* If the SLP node is a PHI (induction or reduction), terminate\n      the recursion.  */\n   bool *skip_args = XALLOCAVEC (bool, nops);\n@@ -1684,11 +1692,7 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n       && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n     {\n       if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n-\t{\n-\t  /* Masked load.  */\n-\t  gcc_assert (gimple_call_internal_p (stmt, IFN_MASK_LOAD));\n-\t  nops = 1;\n-\t}\n+\tgcc_assert (gimple_call_internal_p (stmt, IFN_MASK_LOAD));\n       else\n \t{\n \t  *max_nunits = this_max_nunits;"}]}