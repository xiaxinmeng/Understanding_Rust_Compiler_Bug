{"sha": "f1526062d9c16d3224d350967788dec9e4e2bbee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1MjYwNjJkOWMxNmQzMjI0ZDM1MDk2Nzc4OGRlYzllNGUyYmJlZQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-05T15:40:13Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-05T15:40:13Z"}, "message": "Add initial name resolution for traits and trait impls\n\nWe need to add name resolution for traits and trait impls. We cannot start\nworking with trait obligations untill we can actually implment a basic trait first.\n\nAddresses: #395", "tree": {"sha": "aa26273a573d9308a63f0a753ab7c06fe21b19b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa26273a573d9308a63f0a753ab7c06fe21b19b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1526062d9c16d3224d350967788dec9e4e2bbee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1526062d9c16d3224d350967788dec9e4e2bbee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1526062d9c16d3224d350967788dec9e4e2bbee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1526062d9c16d3224d350967788dec9e4e2bbee/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b3d621f215c8dfe39f43b0c25f72a29aea89908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b3d621f215c8dfe39f43b0c25f72a29aea89908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b3d621f215c8dfe39f43b0c25f72a29aea89908"}], "stats": {"total": 292, "additions": 292, "deletions": 0}, "files": [{"sha": "a9da33734143282b040eb057a41ce59d6e3e3f70", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=f1526062d9c16d3224d350967788dec9e4e2bbee", "patch": "@@ -3420,6 +3420,8 @@ class Trait : public VisItem\n   // Returns whether trait has inner attributes.\n   bool has_inner_attrs () const { return !inner_attrs.empty (); }\n \n+  Identifier get_identifier () const { return name; }\n+\n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n \t std::vector<std::unique_ptr<GenericParam> > generic_params,"}, {"sha": "576cd3e585dd47eb0f2f168dcc7ca171e7017b8f", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=f1526062d9c16d3224d350967788dec9e4e2bbee", "patch": "@@ -37,6 +37,12 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n+  static void go (AST::TraitImplItem *item, const CanonicalPath &prefix)\n+  {\n+    ResolveToplevelImplItem resolver (prefix);\n+    item->accept_vis (resolver);\n+  }\n+\n   void visit (AST::ConstantItem &constant) override\n   {\n     auto path\n@@ -95,6 +101,90 @@ class ResolveToplevelImplItem : public ResolverBase\n   const CanonicalPath &prefix;\n };\n \n+class ResolveTopLevelTraitItems : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::TraitItem *item,\n+\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  {\n+    ResolveTopLevelTraitItems resolver (prefix);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::TraitItemFunc &function) override\n+  {\n+    auto path = prefix.append (\n+      ResolveTraitItemFunctionToCanonicalPath::resolve (function));\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (function.get_node_id (),\n+\t\t\t\t     Definition{function.get_node_id (),\n+\t\t\t\t\t\tfunction.get_node_id ()});\n+  }\n+\n+  void visit (AST::TraitItemMethod &method) override\n+  {\n+    auto path\n+      = prefix.append (ResolveTraitItemMethodToCanonicalPath::resolve (method));\n+    resolver->get_name_scope ().insert (\n+      path, method.get_node_id (), method.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (method.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (method.get_node_id (),\n+\t\t\t\t     Definition{method.get_node_id (),\n+\t\t\t\t\t\tmethod.get_node_id ()});\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    auto path = prefix.append (\n+      ResolveTraitItemConstToCanonicalPath::resolve (constant));\n+    resolver->get_name_scope ().insert (\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (constant.get_node_id (),\n+\t\t\t\t     Definition{constant.get_node_id (),\n+\t\t\t\t\t\tconstant.get_node_id ()});\n+  }\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    auto path\n+      = prefix.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n+    resolver->get_name_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (type.get_node_id (),\n+\t\t\t\t     Definition{type.get_node_id (),\n+\t\t\t\t\t\ttype.get_node_id ()});\n+  }\n+\n+private:\n+  ResolveTopLevelTraitItems (const CanonicalPath &prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "38003505ef914b957922d8a9c9a511b1311b88cf", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=f1526062d9c16d3224d350967788dec9e4e2bbee", "patch": "@@ -259,6 +259,133 @@ class ResolveItem : public ResolverBase\n     resolver->get_label_scope ().pop ();\n   }\n \n+  void visit (AST::TraitImpl &impl_block) override\n+  {\n+    NodeId scope_node_id = impl_block.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (impl_block.has_generics ())\n+      {\n+\tfor (auto &generic : impl_block.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t  }\n+      }\n+\n+    bool canonicalize_type_with_generics = false;\n+    NodeId trait_resolved_node\n+      = ResolveType::go (&impl_block.get_trait_path (),\n+\t\t\t impl_block.get_node_id (),\n+\t\t\t canonicalize_type_with_generics);\n+    if (trait_resolved_node == UNKNOWN_NODEID)\n+      {\n+\tresolver->get_type_scope ().pop ();\n+\treturn;\n+      }\n+\n+    NodeId type_resolved_node\n+      = ResolveType::go (impl_block.get_type ().get (),\n+\t\t\t impl_block.get_node_id (),\n+\t\t\t canonicalize_type_with_generics);\n+    if (type_resolved_node == UNKNOWN_NODEID)\n+      {\n+\tresolver->get_type_scope ().pop ();\n+\treturn;\n+      }\n+\n+    resolver->get_type_scope ().insert (\n+      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id (),\n+      impl_block.get_type ()->get_locus_slow ());\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      impl_item->accept_vis (*this);\n+\n+    resolver->get_type_scope ().peek ()->clear_name (\n+      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id ());\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::Trait &trait) override\n+  {\n+    NodeId scope_node_id = trait.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    // TODO\n+    // we need to inject an implicit self TypeParam here\n+    // see: https://doc.rust-lang.org/reference/items/traits.html\n+\n+    if (trait.has_generics ())\n+      {\n+\tfor (auto &generic : trait.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n+\t  }\n+      }\n+\n+    for (auto &item : trait.get_trait_items ())\n+      item->accept_vis (*this);\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemFunc &func) override\n+  {\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemMethod &) override\n+  {\n+    // TODO\n+  }\n+\n+  void visit (AST::TraitItemConst &) override\n+  {\n+    // TODO\n+  }\n+\n+  void visit (AST::TraitItemType &) override\n+  {\n+    // TODO\n+  }\n+\n private:\n   ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "95685bc92ca5156ee89b9acda71bdbf4c754f29b", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=f1526062d9c16d3224d350967788dec9e4e2bbee", "patch": "@@ -145,6 +145,36 @@ class ResolveTopLevel : public ResolverBase\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n   }\n \n+  void visit (AST::TraitImpl &impl_block) override\n+  {\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+    CanonicalPath impl_type\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+  }\n+\n+  void visit (AST::Trait &trait) override\n+  {\n+    CanonicalPath path\n+      = prefix.append (CanonicalPath (trait.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, trait.get_node_id (), trait.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (trait.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &item : trait.get_trait_items ())\n+      ResolveTopLevelTraitItems::go (item.get ());\n+  }\n+\n private:\n   ResolveTopLevel (const CanonicalPath &prefix)\n     : ResolverBase (UNKNOWN_NODEID), prefix (prefix)"}, {"sha": "05b347c3fca1376ed7b510d7fca0806b6428d6d7", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=f1526062d9c16d3224d350967788dec9e4e2bbee", "patch": "@@ -52,6 +52,43 @@ class ResolveMethodItemToCanonicalPath\n   }\n };\n \n+class ResolveTraitItemFunctionToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemFunc &function)\n+  {\n+    return CanonicalPath (\n+      function.get_trait_function_decl ().get_identifier ());\n+  }\n+};\n+\n+class ResolveTraitItemMethodToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemMethod &method)\n+  {\n+    return CanonicalPath (method.get_trait_method_decl ().get_identifier ());\n+  }\n+};\n+\n+class ResolveTraitItemConstToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemConst &constant)\n+  {\n+    return CanonicalPath (constant.get_identifier ());\n+  }\n+};\n+\n+class ResolveTraitItemTypeToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemType &type)\n+  {\n+    return CanonicalPath (type.get_identifier ());\n+  }\n+};\n+\n class ResolveTypeToCanonicalPath : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;"}, {"sha": "f97c97b1d930c750e0fdd92ad5dc76bdd559d700", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1526062d9c16d3224d350967788dec9e4e2bbee/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=f1526062d9c16d3224d350967788dec9e4e2bbee", "patch": "@@ -41,6 +41,9 @@\n     }                                                                          \\\n   while (0)\n \n+extern bool\n+saw_errors (void);\n+\n namespace Rust {\n namespace Resolver {\n \n@@ -322,6 +325,9 @@ NameResolution::go (AST::Crate &crate)\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveTopLevel::go (it->get ());\n \n+  if (saw_errors ())\n+    return;\n+\n   // next we can drill down into the items and their scopes\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveItem::go (it->get ());"}]}