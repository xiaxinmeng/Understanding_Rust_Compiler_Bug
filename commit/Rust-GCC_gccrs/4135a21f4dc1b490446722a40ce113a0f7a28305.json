{"sha": "4135a21f4dc1b490446722a40ce113a0f7a28305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEzNWEyMWY0ZGMxYjQ5MDQ0NjcyMmE0MGNlMTEzYTBmN2EyODMwNQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-01-08T12:12:05Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-01-08T12:12:05Z"}, "message": "PR 78534 Regression on 32-bit targets\n\nBy switching from int to size_t in order to handle larger values,\nr256322 introduced a bug that manifested itself on 32-bit\ntargets. Fixed by using the correct type to store the result of a\nnext_array_record call.\n\nRegtested on x86_64-pc-linux-gnu and i686-pc-linux-gnu, committed to\ntrunk as obvious.\n\nlibgfortran/ChangeLog:\n\n2018-01-08  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR 78534, bugfix for r256322\n\t* io/transfer.c (next_record_w): Use correct type for return value\n\tof next_array_record.\n\nFrom-SVN: r256337", "tree": {"sha": "076c38c37b3cc831ebb83bdb854df64797ba6b08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/076c38c37b3cc831ebb83bdb854df64797ba6b08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4135a21f4dc1b490446722a40ce113a0f7a28305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4135a21f4dc1b490446722a40ce113a0f7a28305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4135a21f4dc1b490446722a40ce113a0f7a28305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4135a21f4dc1b490446722a40ce113a0f7a28305/comments", "author": null, "committer": null, "parents": [{"sha": "4c035a2394ef0cebb22128e6cf14428c47ec20fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c035a2394ef0cebb22128e6cf14428c47ec20fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c035a2394ef0cebb22128e6cf14428c47ec20fe"}], "stats": {"total": 18, "additions": 13, "deletions": 5}, "files": [{"sha": "022725fdcdca6533a2f7a70933c87c45a86f58a9", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4135a21f4dc1b490446722a40ce113a0f7a28305/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4135a21f4dc1b490446722a40ce113a0f7a28305/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4135a21f4dc1b490446722a40ce113a0f7a28305", "patch": "@@ -1,3 +1,9 @@\n+2018-01-08  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR 78534, bugfix for r256322\n+\t* io/transfer.c (next_record_w): Use correct type for return value\n+\tof next_array_record.\n+\n 2018-01-07  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* libgfortran.h (GFC_DTYPE_COPY): New macro."}, {"sha": "7e076de84fa798041ac609717450b1693f6ea77c", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4135a21f4dc1b490446722a40ce113a0f7a28305/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4135a21f4dc1b490446722a40ce113a0f7a28305/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=4135a21f4dc1b490446722a40ce113a0f7a28305", "patch": "@@ -3691,7 +3691,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t{\n \t  char *p;\n \t  /* Internal unit, so must fit in memory.  */\n-\t  size_t length, m, record;\n+\t  size_t length, m;\n \t  size_t max_pos = max_pos_off;\n \t  if (is_array_io (dtp))\n \t    {\n@@ -3730,14 +3730,16 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\tmemset (p, ' ', length);\n \n \t      /* Now that the current record has been padded out,\n-\t\t determine where the next record in the array is. */\n-\t      record = next_array_record (dtp, dtp->u.p.current_unit->ls,\n-\t\t\t\t\t  &finished);\n+\t\t determine where the next record in the array is.\n+\t\t Note that this can return a negative value, so it\n+\t\t needs to be assigned to a signed value.  */\n+\t      gfc_offset record = next_array_record\n+\t\t(dtp, dtp->u.p.current_unit->ls, &finished);\n \t      if (finished)\n \t\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \n \t      /* Now seek to this record */\n-\t      record = record * ((size_t) dtp->u.p.current_unit->recl);\n+\t      record = record * dtp->u.p.current_unit->recl;\n \n \t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t\t{"}]}