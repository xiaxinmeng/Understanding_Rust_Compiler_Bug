{"sha": "825dda426b6951e40f7b0f6c8ef86e6aad86740a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1ZGRhNDI2YjY5NTFlNDBmN2IwZjZjOGVmODZlNmFhZDg2NzQwYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-17T23:10:04Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-17T23:10:04Z"}, "message": "alpha.c: Follow spelling conventions.\n\n\t* config/alpha/alpha.c: Follow spelling conventions.\n\t* config/alpha/alpha.h: Likewise.\n\t* config/alpha/alpha.md: Likewise.\n\t* config/arc/arc.h: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/arm/arm.h: Likewise.\n\t* config/arm/arm.md: Likewise.\n\t* config/arm/pe.c: Likewise.\n\t* config/arm/unknown-elf.h: Likewise.\n\t* config/avr/avr.c: Likewise.\n\t* config/avr/avr.h: Likewise.\n\t* config/c4x/c4x.c: Likewise.\n\t* config/cris/cris.c: Likewise.\n\t* config/cris/cris.h: Likewise.\n\nFrom-SVN: r57266", "tree": {"sha": "8bbd60963b5ab609c8683955c3761d6dde0daf0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bbd60963b5ab609c8683955c3761d6dde0daf0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/825dda426b6951e40f7b0f6c8ef86e6aad86740a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825dda426b6951e40f7b0f6c8ef86e6aad86740a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825dda426b6951e40f7b0f6c8ef86e6aad86740a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825dda426b6951e40f7b0f6c8ef86e6aad86740a/comments", "author": null, "committer": null, "parents": [{"sha": "8e16ab99953149a0936735618e6d26b79651a1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e16ab99953149a0936735618e6d26b79651a1b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e16ab99953149a0936735618e6d26b79651a1b3"}], "stats": {"total": 109, "additions": 64, "deletions": 45}, "files": [{"sha": "bf8601c745852f568d8987bc1442438414e089b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -1,9 +1,28 @@\n+2002-09-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/alpha/alpha.c: Follow spelling conventions.\n+\t* config/alpha/alpha.h: Likewise.\n+\t* config/alpha/alpha.md: Likewise.\n+\t* config/arc/arc.h: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/arm/arm.h: Likewise.\n+\t* config/arm/arm.md: Likewise.\n+\t* config/arm/pe.c: Likewise.\n+\t* config/arm/unknown-elf.h: Likewise.\n+\t* config/avr/avr.c: Likewise.\n+\t* config/avr/avr.h: Likewise.\n+\t* config/c4x/c4x.c: Likewise.\n+\t* config/cris/cris.c: Likewise.\n+\t* config/cris/cris.h: Likewise.\n+\n 2002-09-17  Samuel Figueroa  <figueroa@apple.com>\n+\n \t* final.c (final_scan_insn): Use new macro ASM_OUTPUT_ALIGN_WITH_NOP.\n \t* config/sparc/sparc.h (ASM_OUTPUT_ALIGN_WITH_NOP) New macro.\n \t* doc/tm.texi (ASM_OUTPUT_ALIGN_WITH_NOP) New description.\n \n 2002-09-17  Dale Johannesen  <dalej@apple.com>\n+\n \t* cfgcleanup.c (try_forward_edges):  Do not forward a\n \tbranch to just after a loop exit before loop optimization;\n \tthis interfered with doloop detection."}, {"sha": "f7963be43c6ed1f14b6001ec89790acbc0692f01", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -88,7 +88,7 @@ const char *alpha_tls_size_string; /* -mtls-size=[16|32|64] */\n \n struct alpha_compare alpha_compare;\n \n-/* Non-zero if inside of a function, because the Alpha asm can't\n+/* Nonzero if inside of a function, because the Alpha asm can't\n    handle .files inside of functions.  */\n \n static int inside_function = FALSE;\n@@ -3478,7 +3478,7 @@ alpha_emit_setcc (code)\n /* Rewrite a comparison against zero CMP of the form\n    (CODE (cc0) (const_int 0)) so it can be written validly in\n    a conditional move (if_then_else CMP ...).\n-   If both of the operands that set cc0 are non-zero we must emit\n+   If both of the operands that set cc0 are nonzero we must emit\n    an insn to perform the compare (it can't be done within\n    the conditional move).  */\n rtx\n@@ -3510,7 +3510,7 @@ alpha_emit_conditional_move (cmp, mode)\n \n       /* If we have fp<->int register move instructions, do a cmov by\n \t performing the comparison in fp registers, and move the\n-\t zero/non-zero value to integer registers, where we can then\n+\t zero/nonzero value to integer registers, where we can then\n \t use a normal cmov, or vice-versa.  */\n \n       switch (code)\n@@ -4042,7 +4042,7 @@ alpha_split_tfmode_frobsign (operands, operation)\n \n   alpha_split_tfmode_pair (operands);\n \n-  /* Detect three flavours of operand overlap.  */\n+  /* Detect three flavors of operand overlap.  */\n   move = 1;\n   if (rtx_equal_p (operands[0], operands[2]))\n     move = 0;"}, {"sha": "cf203838da0c466eb5065eaad1d2f9e86e7d2e37", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -508,14 +508,14 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n #define DATA_ALIGNMENT(EXP, ALIGN) MAX ((ALIGN), BITS_PER_WORD)\n #endif\n \n-/* Set this non-zero if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.\n \n    Since we get an error message when we do one, call them invalid.  */\n \n #define STRICT_ALIGNMENT 1\n \n-/* Set this non-zero if unaligned move instructions are extremely slow.\n+/* Set this nonzero if unaligned move instructions are extremely slow.\n \n    On the Alpha, they trap.  */\n \n@@ -1468,7 +1468,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n #define MAX_FIXED_MODE_SIZE\tGET_MODE_BITSIZE (TImode)\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n-   Also non-zero if doing byte operations (specifically shifts) in registers\n+   Also nonzero if doing byte operations (specifically shifts) in registers\n    is undesirable. \n \n    On the Alpha, we want to not use the byte operation and instead use"}, {"sha": "ed1ebf5335977ba23a5fa95bb17b0161ba381f22", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -1733,7 +1733,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   \"ext%M2l %r1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-;; Combine has some strange notion of preserving existing undefined behaviour\n+;; Combine has some strange notion of preserving existing undefined behavior\n ;; in shifts larger than a word size.  So capture these patterns that it\n ;; should have turned into zero_extracts.\n "}, {"sha": "95bfef7366327c0a8ca3510f9156d3c8589464c1", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -131,7 +131,7 @@ extern int target_flags;\n /* Instruction set characteristics.\n    These are internal macros, set by the appropriate -mcpu= option.  */\n \n-/* Non-zero means the cpu has a barrel shifter.  */\n+/* Nonzero means the cpu has a barrel shifter.  */\n #define TARGET_SHIFTER 0\n \n extern const char *arc_cpu_string;\n@@ -149,7 +149,7 @@ extern const char *arc_text_string,*arc_data_string,*arc_rodata_string;\n extern int arc_cpu_type;\n \n /* Check if CPU is an extension and set `arc_cpu_type' and `arc_mangle_cpu'\n-   appropriately.  The result should be non-zero if the cpu is recognized,\n+   appropriately.  The result should be nonzero if the cpu is recognized,\n    otherwise zero.  This is intended to be redefined in a cover file.\n    This is used by arc_init.  */\n #define ARC_EXTENSION_CPU(cpu) 0\n@@ -989,7 +989,7 @@ do { \\\n #define SELECT_CC_MODE(OP, X, Y) \\\n arc_select_cc_mode (OP, X, Y)\n \n-/* Return non-zero if SELECT_CC_MODE will never return MODE for a\n+/* Return nonzero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n #define REVERSIBLE_CC_MODE(MODE) 1 /*???*/\n \f"}, {"sha": "06f54c0a69410391d34ac515b171da99204ce34b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -2207,7 +2207,7 @@ current_file_function_operand (sym_ref)\n   return 0;\n }\n \n-/* Return non-zero if a 32 bit \"long_call\" should be generated for\n+/* Return nonzero if a 32 bit \"long_call\" should be generated for\n    this call.  We generate a long_call if the function:\n \n         a.  has an __attribute__((long call))\n@@ -2260,7 +2260,7 @@ arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n     || TARGET_LONG_CALLS;\n }\n \n-/* Return non-zero if it is ok to make a tail-call to DECL.  */\n+/* Return nonzero if it is ok to make a tail-call to DECL.  */\n \n int\n arm_function_ok_for_sibcall (decl)\n@@ -8059,7 +8059,7 @@ emit_sfm (base_reg, count)\n   may not be needed, giving rise to the possibility of\n   eliminating some of the registers.\n \n-  The values returned by this function must reflect the behaviour\n+  The values returned by this function must reflect the behavior\n   of arm_expand_prologue() and arm_compute_save_reg_mask().\n \n   The sign of the number returned reflects the direction of stack\n@@ -9872,7 +9872,7 @@ thumb_shiftable_const (val)\n   return 0;\n }\n \n-/* Returns non-zero if the current function contains,\n+/* Returns nonzero if the current function contains,\n    or might contain a far jump.  */\n \n int\n@@ -9942,7 +9942,7 @@ thumb_far_jump_used_p (in_prologue)\n   return 0;\n }\n \n-/* Return non-zero if FUNC must be entered in ARM mode.  */\n+/* Return nonzero if FUNC must be entered in ARM mode.  */\n \n int\n is_called_in_ARM_mode (func)"}, {"sha": "bd19a09d4ad8380c589829593c116440435dce2c", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -728,7 +728,7 @@ extern int arm_structure_size_boundary;\n /* Used when parsing command line option -mstructure_size_boundary.  */\n extern const char * structure_size_string;\n \n-/* Non-zero if move instructions will actually fail to work\n+/* Nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n "}, {"sha": "b56955d3b80bd2174626cbd4c788b37255d13529", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -8427,7 +8427,7 @@\n ; We must watch to see that the source/destination register isn't also the\n ; same as the base address register, and that if the index is a register,\n ; that it is not the same as the base address register.  In such cases the\n-; instruction that we would generate would have UNPREDICTABLE behaviour so \n+; instruction that we would generate would have UNPREDICTABLE behavior so \n ; we cannot use it.\n \n (define_peephole"}, {"sha": "ee3da8fd4110b39eeca691efc95d7dfb1b571a50", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n extern int current_function_anonymous_args;\n \n \f\n-/* Return non-zero if DECL is a dllexport'd object.  */\n+/* Return nonzero if DECL is a dllexport'd object.  */\n \n tree current_class_type; /* FIXME */\n \n@@ -52,7 +52,7 @@ arm_dllexport_p (decl)\n   return 0;\n }\n \n-/* Return non-zero if DECL is a dllimport'd object.  */\n+/* Return nonzero if DECL is a dllimport'd object.  */\n \n int\n arm_dllimport_p (decl)\n@@ -74,7 +74,7 @@ arm_dllimport_p (decl)\n   return 0;\n }\n \n-/* Return non-zero if SYMBOL is marked as being dllexport'd.  */\n+/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n \n int\n arm_dllexport_name_p (symbol)\n@@ -83,7 +83,7 @@ arm_dllexport_name_p (symbol)\n   return symbol[0] == ARM_PE_FLAG_CHAR && symbol[1] == 'e' && symbol[2] == '.';\n }\n \n-/* Return non-zero if SYMBOL is marked as being dllimport'd.  */\n+/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n \n int\n arm_dllimport_name_p (symbol)"}, {"sha": "ade3f4889135f465d1c3ab8155fc50661fbc77b7", "filename": "gcc/config/arm/unknown-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Funknown-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Farm%2Funknown-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf.h?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -47,7 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #undef  PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n-/* Return a non-zero value if DECL has a section attribute.  */\n+/* Return a nonzero value if DECL has a section attribute.  */\n #define IN_NAMED_SECTION(DECL)\t\t\t\t\t\t\\\n   ((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL)\t\\\n    && DECL_SECTION_NAME (DECL) != NULL_TREE)"}, {"sha": "09ab9e0d35c6238e96f25bea09e6dba6f13a93db", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -338,7 +338,7 @@ avr_reg_class_from_letter  (c)\n   return NO_REGS;\n }\n \n-/* Return non-zero if FUNC is a naked function.  */\n+/* Return nonzero if FUNC is a naked function.  */\n \n static int\n avr_naked_function_p (func)\n@@ -4433,7 +4433,7 @@ adjust_insn_length (insn, len)\n   return len;\n }\n \n-/* Return non-zero if register REG dead after INSN */\n+/* Return nonzero if register REG dead after INSN */\n \n int\n reg_unused_after (insn, reg)\n@@ -4444,7 +4444,7 @@ reg_unused_after (insn, reg)\n \t  || (REG_P(reg) && _reg_unused_after (insn, reg)));\n }\n \n-/* Return non-zero if REG is not used after INSN.\n+/* Return nonzero if REG is not used after INSN.\n    We assume REG is a reload reg, and therefore does\n    not live past labels.  It may live past calls or jumps though.  */\n \n@@ -5250,7 +5250,7 @@ avr_function_value (type, func)\n   return gen_rtx (REG, BLKmode, RET_REGISTER + 2 - offs);\n }\n \n-/* Returns non-zero if the number MASK has only one bit set.  */\n+/* Returns nonzero if the number MASK has only one bit set.  */\n \n int\n mask_one_bit_p (mask)"}, {"sha": "555bbdec8aa5cc05e5dd4c735954d3a21046ac2a", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -731,7 +731,7 @@ enum reg_class {\n /* `SECONDARY_MEMORY_NEEDED (CLASS1, CLASS2, M)'\n    Certain machines have the property that some registers cannot be\n    copied to some other registers without using memory.  Define this\n-   macro on those machines to be a C expression that is non-zero if\n+   macro on those machines to be a C expression that is nonzero if\n    objects of mode M in registers of CLASS1 can only be copied to\n    registers of class CLASS2 by storing a register of CLASS1 into\n    memory and loading that memory location into a register of CLASS2.\n@@ -755,16 +755,16 @@ enum reg_class {\n    classes that there would not be enough registers to use as spill\n    registers if this were done.\n \n-   Define `SMALL_REGISTER_CLASSES' to be an expression with a non-zero\n-   value on these machines.  When this macro has a non-zero value, the\n+   Define `SMALL_REGISTER_CLASSES' to be an expression with a nonzero\n+   value on these machines.  When this macro has a nonzero value, the\n    compiler allows registers explicitly used in the rtl to be used as\n    spill registers but avoids extending the lifetime of these\n    registers.\n \n-   It is always safe to define this macro with a non-zero value, but\n+   It is always safe to define this macro with a nonzero value, but\n    if you unnecessarily define it, you will reduce the amount of\n    optimizations that can be performed in some cases.  If you do not\n-   define this macro with a non-zero value when it is required, the\n+   define this macro with a nonzero value when it is required, the\n    compiler will run out of spill registers and print a fatal error\n    message.  For most machines, you should not define this macro at\n    all.  */\n@@ -999,7 +999,7 @@ enum reg_class {\n \t\t\t\t      || (FROM) == FRAME_POINTER_REGNUM+1) \\\n \t\t\t\t     && ! FRAME_POINTER_REQUIRED\t   \\\n \t\t\t\t     ))\n-/* A C expression that returns non-zero if the compiler is allowed to\n+/* A C expression that returns nonzero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n    defined, and will usually be the constant 1, since most of the\n@@ -1115,7 +1115,7 @@ enum reg_class {\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the\n    definition of this macro to determine if this argument is of a\n    type that must be passed in the stack.  If `REG_PARM_STACK_SPACE'\n-   is not defined and `FUNCTION_ARG' returns non-zero for such an\n+   is not defined and `FUNCTION_ARG' returns nonzero for such an\n    argument, the compiler will abort.  If `REG_PARM_STACK_SPACE' is\n    defined, the argument will be computed in the stack and then\n    loaded into a register.  */\n@@ -1679,10 +1679,10 @@ do {\t\t\t\t\t\t\t\t\t    \\\n    cost many times greater than aligned accesses, for example if they\n    are emulated in a trap handler.\n \n-   When this macro is non-zero, the compiler will act as if\n-   `STRICT_ALIGNMENT' were non-zero when generating code for block\n+   When this macro is nonzero, the compiler will act as if\n+   `STRICT_ALIGNMENT' were nonzero when generating code for block\n    moves.  This can cause significantly more instructions to be\n-   produced.  Therefore, do not set this macro non-zero if unaligned\n+   produced.  Therefore, do not set this macro nonzero if unaligned\n    accesses only add a cycle or two to the time for a memory access.\n \n    If the value of this macro is always zero, it need not be defined."}, {"sha": "83ab33124ff39742e1b29fa999df63b66a92aea6", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -436,7 +436,7 @@ c4x_hard_regno_mode_ok (regno, mode)\n   return 0;\n }\n \n-/* Return non-zero if REGNO1 can be renamed to REGNO2.  */\n+/* Return nonzero if REGNO1 can be renamed to REGNO2.  */\n int\n c4x_hard_regno_rename_ok (regno1, regno2)\n      unsigned int regno1;\n@@ -3366,10 +3366,10 @@ src_operand (op, mode)\n       || GET_CODE (op) == CONST)\n     return 0;\n \n-  /* If TARGET_LOAD_DIRECT_MEMS is non-zero, disallow direct memory\n+  /* If TARGET_LOAD_DIRECT_MEMS is nonzero, disallow direct memory\n      access to symbolic addresses.  These operands will get forced\n      into a register and the movqi expander will generate a\n-     HIGH/LO_SUM pair if TARGET_EXPOSE_LDP is non-zero.  */\n+     HIGH/LO_SUM pair if TARGET_EXPOSE_LDP is nonzero.  */\n   if (GET_CODE (op) == MEM\n       && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n \t   || GET_CODE (XEXP (op, 0)) == LABEL_REF"}, {"sha": "7edd8bd1916addbae596928357de4ff864bc87f3", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -2315,7 +2315,7 @@ cris_legitimate_pic_operand (x)\n   return ! cris_symbol (x) || cris_got_symbol (x);\n }\n \n-/* Return non-zero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n+/* Return nonzero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n    CONSTANT_P.  */\n \n int\n@@ -2352,7 +2352,7 @@ cris_symbol (x)\n   return 1;\n }\n \n-/* Return non-zero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n+/* Return nonzero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n    CONSTANT_P, and the symbol does not need a GOT entry.  Also set\n    current_function_uses_pic_offset_table if we're generating PIC and ever\n    see something that would need one.  */\n@@ -2410,7 +2410,7 @@ cris_gotless_symbol (x)\n   return 1;\n }\n \n-/* Return non-zero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n+/* Return nonzero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n    CONSTANT_P, and the symbol needs a GOT entry.  */\n \n int"}, {"sha": "ddf84e53c7f73a091fcd1f935f565a5315e54ba4", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825dda426b6951e40f7b0f6c8ef86e6aad86740a/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=825dda426b6951e40f7b0f6c8ef86e6aad86740a", "patch": "@@ -1030,7 +1030,7 @@ struct cum_args {int regs;};\n \n /* We save the register number of the first anonymous argument in\n    first_vararg_reg, and take care of this in the function prologue.\n-   This behaviour is used by at least one more port (the ARM?), but\n+   This behavior is used by at least one more port (the ARM?), but\n    may be unsafe when compiling nested functions.  (With varargs? Hairy.)\n    Note that nested-functions is a GNU C extension.\n \n@@ -1242,7 +1242,7 @@ struct cum_args {int regs;};\n \n /* For now, don't do anything.  GCC does a good job most often.\n \n-    Maybe we could do something about gcc:s misbehaviour when it\n+    Maybe we could do something about gcc:s misbehavior when it\n    recalculates frame offsets for local variables, from fp+offs to\n    sp+offs.  The resulting address expression gets screwed up\n    sometimes, but I'm not sure that it may be fixed here, since it is"}]}