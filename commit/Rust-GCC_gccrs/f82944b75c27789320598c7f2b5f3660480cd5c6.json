{"sha": "f82944b75c27789320598c7f2b5f3660480cd5c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyOTQ0Yjc1YzI3Nzg5MzIwNTk4YzdmMmI1ZjM2NjA0ODBjZDVjNg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-02-17T16:06:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-17T16:06:16Z"}, "message": "exp_ch4.adb (Expand_N_Allocator): If the allocated object is accessed through an access to class-wide interface...\n\n2006-02-17  Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Allocator): If the allocated object is accessed\n\tthrough an access to class-wide interface we force the displacement of\n\tthe pointer to the allocated object to reference the corresponding\n\tsecondary dispatch table.\n\t(Expand_N_Op_Divide): Allow 64 bit divisions by small power of 2,\n\tif Long_Shifts are supported on the target, even if 64 bit divides\n\tare not supported (configurable run time mode).\n\t(Expand_N_Type_Conversion): Do validity check if validity checks on\n\toperands are enabled.\n\t(Expand_N_Qualified_Expression): Do validity check if validity checks\n\ton operands are enabled.\n\nFrom-SVN: r111185", "tree": {"sha": "06644d0228adf557185524f557b21d96e1011cac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06644d0228adf557185524f557b21d96e1011cac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f82944b75c27789320598c7f2b5f3660480cd5c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82944b75c27789320598c7f2b5f3660480cd5c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82944b75c27789320598c7f2b5f3660480cd5c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82944b75c27789320598c7f2b5f3660480cd5c6/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72774950676b37f320c6cd60ff1789da1106f3dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72774950676b37f320c6cd60ff1789da1106f3dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72774950676b37f320c6cd60ff1789da1106f3dd"}], "stats": {"total": 121, "additions": 98, "deletions": 23}, "files": [{"sha": "9eaeda66c7c2f6b77e1f18984c89b183b05e1bc7", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 98, "deletions": 23, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82944b75c27789320598c7f2b5f3660480cd5c6/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82944b75c27789320598c7f2b5f3660480cd5c6/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f82944b75c27789320598c7f2b5f3660480cd5c6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2448,8 +2448,9 @@ package body Exp_Ch4 is\n    procedure Expand_N_Allocator (N : Node_Id) is\n       PtrT  : constant Entity_Id  := Etype (N);\n       Dtyp  : constant Entity_Id  := Designated_Type (PtrT);\n-      Desig : Entity_Id;\n+      Etyp  : constant Entity_Id  := Etype (Expression (N));\n       Loc   : constant Source_Ptr := Sloc (N);\n+      Desig : Entity_Id;\n       Temp  : Entity_Id;\n       Node  : Node_Id;\n \n@@ -2851,6 +2852,44 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n+      --  Ada 2005 (AI-251): If the allocated object is accessed through an\n+      --  access to class-wide interface we force the displacement of the\n+      --  pointer to the allocated object to reference the corresponding\n+      --  secondary dispatch table.\n+\n+      if Is_Class_Wide_Type (Dtyp)\n+        and then Is_Interface (Dtyp)\n+      then\n+         declare\n+            Saved_Typ : constant Entity_Id := Etype (N);\n+\n+         begin\n+            --  1) Get access to the allocated object\n+\n+            Rewrite (N,\n+              Make_Explicit_Dereference (Loc,\n+                Relocate_Node (N)));\n+            Set_Etype (N, Etyp);\n+            Set_Analyzed (N);\n+\n+            --  2) Add the conversion to displace the pointer to reference\n+            --     the secondary dispatch table.\n+\n+            Rewrite (N, Convert_To (Dtyp, Relocate_Node (N)));\n+            Analyze_And_Resolve (N, Dtyp);\n+\n+            --  3) The 'access to the secondary dispatch table will be used as\n+            --     the value returned by the allocator.\n+\n+            Rewrite (N,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => Relocate_Node (N),\n+                Attribute_Name => Name_Access));\n+            Set_Etype (N, Saved_Typ);\n+            Set_Analyzed (N);\n+         end;\n+      end if;\n+\n    exception\n       when RE_Not_Available =>\n          return;\n@@ -3865,30 +3904,37 @@ package body Exp_Ch4 is\n    ------------------------\n \n    procedure Expand_N_Op_Divide (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Ltyp : constant Entity_Id  := Etype (Left_Opnd (N));\n-      Rtyp : constant Entity_Id  := Etype (Right_Opnd (N));\n-      Typ  : Entity_Id           := Etype (N);\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Lopnd : constant Node_Id    := Left_Opnd (N);\n+      Ropnd : constant Node_Id    := Right_Opnd (N);\n+      Ltyp  : constant Entity_Id  := Etype (Lopnd);\n+      Rtyp  : constant Entity_Id  := Etype (Ropnd);\n+      Typ   : Entity_Id           := Etype (N);\n+      Rknow : constant Boolean    := Is_Integer_Type (Typ)\n+                                       and then\n+                                         Compile_Time_Known_Value (Ropnd);\n+      Rval  : Uint;\n \n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      if Rknow then\n+         Rval := Expr_Value (Ropnd);\n+      end if;\n+\n       --  N / 1 = N for integer types\n \n-      if Is_Integer_Type (Typ)\n-        and then Compile_Time_Known_Value (Right_Opnd (N))\n-        and then Expr_Value (Right_Opnd (N)) = Uint_1\n-      then\n-         Rewrite (N, Left_Opnd (N));\n+      if Rknow and then Rval = Uint_1 then\n+         Rewrite (N, Lopnd);\n          return;\n       end if;\n \n       --  Convert x / 2 ** y to Shift_Right (x, y). Note that the fact that\n       --  Is_Power_Of_2_For_Shift is set means that we know that our left\n       --  operand is an unsigned integer, as required for this to work.\n \n-      if Nkind (Right_Opnd (N)) = N_Op_Expon\n-        and then Is_Power_Of_2_For_Shift (Right_Opnd (N))\n+      if Nkind (Ropnd) = N_Op_Expon\n+        and then Is_Power_Of_2_For_Shift (Ropnd)\n \n       --  We cannot do this transformation in configurable run time mode if we\n       --  have 64-bit --  integers and long shifts are not available.\n@@ -3899,9 +3945,9 @@ package body Exp_Ch4 is\n       then\n          Rewrite (N,\n            Make_Op_Shift_Right (Loc,\n-             Left_Opnd  => Left_Opnd (N),\n+             Left_Opnd  => Lopnd,\n              Right_Opnd =>\n-               Convert_To (Standard_Natural, Right_Opnd (Right_Opnd (N)))));\n+               Convert_To (Standard_Natural, Right_Opnd (Ropnd))));\n          Analyze_And_Resolve (N, Typ);\n          return;\n       end if;\n@@ -3950,28 +3996,39 @@ package body Exp_Ch4 is\n       elsif Typ = Universal_Real\n         and then Is_Integer_Type (Rtyp)\n       then\n-         Rewrite (Right_Opnd (N),\n-           Convert_To (Universal_Real, Relocate_Node (Right_Opnd (N))));\n+         Rewrite (Ropnd,\n+           Convert_To (Universal_Real, Relocate_Node (Ropnd)));\n \n-         Analyze_And_Resolve (Right_Opnd (N), Universal_Real);\n+         Analyze_And_Resolve (Ropnd, Universal_Real);\n \n       elsif Typ = Universal_Real\n         and then Is_Integer_Type (Ltyp)\n       then\n-         Rewrite (Left_Opnd (N),\n-           Convert_To (Universal_Real, Relocate_Node (Left_Opnd (N))));\n+         Rewrite (Lopnd,\n+           Convert_To (Universal_Real, Relocate_Node (Lopnd)));\n \n-         Analyze_And_Resolve (Left_Opnd (N), Universal_Real);\n+         Analyze_And_Resolve (Lopnd, Universal_Real);\n \n       --  Non-fixed point cases, do integer zero divide and overflow checks\n \n       elsif Is_Integer_Type (Typ) then\n          Apply_Divide_Check (N);\n \n-         --  Check for 64-bit division available\n+         --  Check for 64-bit division available, or long shifts if the divisor\n+         --  is a small power of 2 (since such divides will be converted into\n+         --  long shifts.\n \n          if Esize (Ltyp) > 32\n            and then not Support_64_Bit_Divides_On_Target\n+           and then\n+             (not Rknow\n+                or else not Support_Long_Shifts_On_Target\n+                or else (Rval /= Uint_2  and then\n+                         Rval /= Uint_4  and then\n+                         Rval /= Uint_8  and then\n+                         Rval /= Uint_16 and then\n+                         Rval /= Uint_32 and then\n+                         Rval /= Uint_64))\n          then\n             Error_Msg_CRT (\"64-bit division\", N);\n          end if;\n@@ -5929,6 +5986,16 @@ package body Exp_Ch4 is\n       Target_Type : constant Entity_Id := Entity (Subtype_Mark (N));\n \n    begin\n+      --  Do validity check if validity checking operands\n+\n+      if Validity_Checks_On\n+        and then Validity_Check_Operands\n+      then\n+         Ensure_Valid (Operand);\n+      end if;\n+\n+      --  Apply possible constraint check\n+\n       Apply_Constraint_Check (Operand, Target_Type, No_Sliding => True);\n    end Expand_N_Qualified_Expression;\n \n@@ -6367,7 +6434,7 @@ package body Exp_Ch4 is\n          Cons : List_Id;\n \n       begin\n-         --  Nothing to do if no change of representation\n+         --  Nothing else to do if no change of representation\n \n          if Same_Representation (Operand_Type, Target_Type) then\n             return;\n@@ -6663,6 +6730,14 @@ package body Exp_Ch4 is\n \n       --  Here if we may need to expand conversion\n \n+      --  Do validity check if validity checking operands\n+\n+      if Validity_Checks_On\n+        and then Validity_Check_Operands\n+      then\n+         Ensure_Valid (Operand);\n+      end if;\n+\n       --  Special case of converting from non-standard boolean type\n \n       if Is_Boolean_Type (Operand_Type)"}]}