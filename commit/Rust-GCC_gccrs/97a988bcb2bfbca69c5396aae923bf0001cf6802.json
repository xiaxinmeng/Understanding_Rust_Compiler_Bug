{"sha": "97a988bcb2bfbca69c5396aae923bf0001cf6802", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdhOTg4YmNiMmJmYmNhNjljNTM5NmFhZTkyM2JmMDAwMWNmNjgwMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-04-29T14:13:30Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-04-29T14:13:30Z"}, "message": "bfin.h (splitting_loops): Declare.\n\n\t* config/bfin/bfin.h (splitting_loops): Declare.\n\t* config/bfin/bfin-protos.h (WA_05000257, WA_05000283, WA_05000315):\n\tReorder bit definitions to be ascending.\n\t(WA_LOAD_LCREGS, ENABLE_WA_LOAD_LCREGS): New macros.\n\t* config/bfin/bfin.c (splitting_loops): New variable.\n\t(bfin_cpus): Add WA_LOAD_LCREGS as needed.\n\t(struct loop_info): Remove members INIT and LOOP_INIT.\n\t(bfin_optimize_loop): Don't set them.  Reorder the code that generates\n\tthe LSETUP sequence.  Allow LC to be loaded from any register, but also\n\tadd a case to push/pop a PREG scratch if ENABLE_WA_LOAD_LCREGS.\n\t(bfin_reorg_loops): When done, split all BB_ENDs with splitting_loops\n\tset to 1.\n\t* config/bfin/bfin.md (loop_end splitter): Use splitting_loops instead\n\tof reload_completed.\n\tFrom Jie Zhang:\n\t* config/bfin/bfin.md (movsi_insn): Refine constraints.\n\nFrom-SVN: r146971", "tree": {"sha": "605b2645dd503827a41c1698cdd031e1168173e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/605b2645dd503827a41c1698cdd031e1168173e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97a988bcb2bfbca69c5396aae923bf0001cf6802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a988bcb2bfbca69c5396aae923bf0001cf6802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a988bcb2bfbca69c5396aae923bf0001cf6802", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a988bcb2bfbca69c5396aae923bf0001cf6802/comments", "author": null, "committer": null, "parents": [{"sha": "1933c4977eeaa926e06ee032f0335a2abf53958a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1933c4977eeaa926e06ee032f0335a2abf53958a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1933c4977eeaa926e06ee032f0335a2abf53958a"}], "stats": {"total": 233, "additions": 152, "deletions": 81}, "files": [{"sha": "7d36429973c5a015995567e545bab7b3d1120e93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97a988bcb2bfbca69c5396aae923bf0001cf6802", "patch": "@@ -1,3 +1,22 @@\n+2009-04-29  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.h (splitting_loops): Declare.\n+\t* config/bfin/bfin-protos.h (WA_05000257, WA_05000283, WA_05000315):\n+\tReorder bit definitions to be ascending.\n+\t(WA_LOAD_LCREGS, ENABLE_WA_LOAD_LCREGS): New macros.\n+\t* config/bfin/bfin.c (splitting_loops): New variable.\n+\t(bfin_cpus): Add WA_LOAD_LCREGS as needed.\n+\t(struct loop_info): Remove members INIT and LOOP_INIT.\n+\t(bfin_optimize_loop): Don't set them.  Reorder the code that generates\n+\tthe LSETUP sequence.  Allow LC to be loaded from any register, but also\n+\tadd a case to push/pop a PREG scratch if ENABLE_WA_LOAD_LCREGS.\n+\t(bfin_reorg_loops): When done, split all BB_ENDs with splitting_loops\n+\tset to 1.\n+\t* config/bfin/bfin.md (loop_end splitter): Use splitting_loops instead\n+\tof reload_completed.\n+\tFrom Jie Zhang:\n+\t* config/bfin/bfin.md (movsi_insn): Refine constraints.\n+\n 2009-04-29  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* Makefile.in (PLUGIN_VERSION_H): New."}, {"sha": "e92a7b6e48d072d95fbe8a54996417f4b5685063", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=97a988bcb2bfbca69c5396aae923bf0001cf6802", "patch": "@@ -80,18 +80,23 @@ extern unsigned int bfin_workarounds;\n #define ENABLE_WA_INDIRECT_CALLS \\\n   ((bfin_workarounds & WA_INDIRECT_CALLS) && !TARGET_ICPLB)\n \n-#define WA_05000257 0x00000040\n+#define WA_05000257 0x00000010\n #define ENABLE_WA_05000257 \\\n   (bfin_workarounds & WA_05000257)\n \n-#define WA_05000283 0x00000010\n+#define WA_05000283 0x00000020\n #define ENABLE_WA_05000283 \\\n   (bfin_workarounds & WA_05000283)\n \n-#define WA_05000315 0x00000020\n+#define WA_05000315 0x00000040\n #define ENABLE_WA_05000315 \\\n   (bfin_workarounds & WA_05000315)\n \n+/* For the anomaly 05-00-0312 */\n+#define WA_LOAD_LCREGS 0x00000080\n+#define ENABLE_WA_LOAD_LCREGS \\\n+  (bfin_workarounds & WA_LOAD_LCREGS)\n+\n #define Mmode enum machine_mode\n \n extern rtx function_arg (CUMULATIVE_ARGS *, Mmode, tree, int);"}, {"sha": "14f7f51931707d65d8e384abe9a65a86ca8af832", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 117, "deletions": 72, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=97a988bcb2bfbca69c5396aae923bf0001cf6802", "patch": "@@ -173,134 +173,135 @@ struct bfin_cpu bfin_cpus[] =\n    WA_SPECULATIVE_LOADS | WA_RETS},\n \n   {\"bf531\", BFIN_CPU_BF531, 0x0006,\n-   WA_SPECULATIVE_LOADS},\n+   WA_SPECULATIVE_LOADS | WA_LOAD_LCREGS},\n   {\"bf531\", BFIN_CPU_BF531, 0x0005,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000315},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf531\", BFIN_CPU_BF531, 0x0004,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf531\", BFIN_CPU_BF531, 0x0003,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf532\", BFIN_CPU_BF532, 0x0006,\n-   WA_SPECULATIVE_LOADS},\n+   WA_SPECULATIVE_LOADS | WA_LOAD_LCREGS},\n   {\"bf532\", BFIN_CPU_BF532, 0x0005,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000315},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf532\", BFIN_CPU_BF532, 0x0004,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf532\", BFIN_CPU_BF532, 0x0003,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf533\", BFIN_CPU_BF533, 0x0006,\n-   WA_SPECULATIVE_LOADS},\n+   WA_SPECULATIVE_LOADS | WA_LOAD_LCREGS},\n   {\"bf533\", BFIN_CPU_BF533, 0x0005,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000315},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf533\", BFIN_CPU_BF533, 0x0004,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf533\", BFIN_CPU_BF533, 0x0003,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf534\", BFIN_CPU_BF534, 0x0003,\n-   WA_SPECULATIVE_LOADS | WA_RETS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_LOAD_LCREGS},\n   {\"bf534\", BFIN_CPU_BF534, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf534\", BFIN_CPU_BF534, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf536\", BFIN_CPU_BF536, 0x0003,\n-   WA_SPECULATIVE_LOADS | WA_RETS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_LOAD_LCREGS},\n   {\"bf536\", BFIN_CPU_BF536, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf536\", BFIN_CPU_BF536, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf537\", BFIN_CPU_BF537, 0x0003,\n-   WA_SPECULATIVE_LOADS | WA_RETS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_LOAD_LCREGS},\n   {\"bf537\", BFIN_CPU_BF537, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf537\", BFIN_CPU_BF537, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf538\", BFIN_CPU_BF538, 0x0005,\n-   WA_SPECULATIVE_LOADS},\n+   WA_SPECULATIVE_LOADS | WA_LOAD_LCREGS},\n   {\"bf538\", BFIN_CPU_BF538, 0x0004,\n-   WA_SPECULATIVE_LOADS | WA_RETS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_LOAD_LCREGS},\n   {\"bf538\", BFIN_CPU_BF538, 0x0003,\n    WA_SPECULATIVE_LOADS | WA_RETS\n-   | WA_05000283 | WA_05000315},\n+   | WA_05000283 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf538\", BFIN_CPU_BF538, 0x0002,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_05000283 | WA_05000257 | WA_05000315},\n+   WA_SPECULATIVE_LOADS | WA_RETS\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf539\", BFIN_CPU_BF539, 0x0005,\n-   WA_SPECULATIVE_LOADS},\n+   WA_SPECULATIVE_LOADS | WA_LOAD_LCREGS},\n   {\"bf539\", BFIN_CPU_BF539, 0x0004,\n-   WA_SPECULATIVE_LOADS | WA_RETS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_LOAD_LCREGS},\n   {\"bf539\", BFIN_CPU_BF539, 0x0003,\n    WA_SPECULATIVE_LOADS | WA_RETS\n-   | WA_05000283 | WA_05000315},\n+   | WA_05000283 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf539\", BFIN_CPU_BF539, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {\"bf542\", BFIN_CPU_BF542, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_INDIRECT_CALLS},\n   {\"bf542\", BFIN_CPU_BF542, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n   {\"bf542\", BFIN_CPU_BF542, 0x0000,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS | WA_LOAD_LCREGS},\n \n   {\"bf544\", BFIN_CPU_BF544, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_INDIRECT_CALLS},\n   {\"bf544\", BFIN_CPU_BF544, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n   {\"bf544\", BFIN_CPU_BF544, 0x0000,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS | WA_LOAD_LCREGS},\n \n   {\"bf547\", BFIN_CPU_BF547, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_INDIRECT_CALLS},\n   {\"bf547\", BFIN_CPU_BF547, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n   {\"bf547\", BFIN_CPU_BF547, 0x0000,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS | WA_LOAD_LCREGS},\n \n   {\"bf548\", BFIN_CPU_BF548, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_INDIRECT_CALLS},\n   {\"bf548\", BFIN_CPU_BF548, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n   {\"bf548\", BFIN_CPU_BF548, 0x0000,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS | WA_LOAD_LCREGS},\n \n   {\"bf549\", BFIN_CPU_BF549, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_INDIRECT_CALLS},\n   {\"bf549\", BFIN_CPU_BF549, 0x0001,\n    WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n   {\"bf549\", BFIN_CPU_BF549, 0x0000,\n-   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS},\n+   WA_SPECULATIVE_LOADS | WA_RETS | WA_INDIRECT_CALLS | WA_LOAD_LCREGS},\n \n   {\"bf561\", BFIN_CPU_BF561, 0x0005, WA_RETS\n-   | WA_05000283 | WA_05000315},\n+   | WA_05000283 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf561\", BFIN_CPU_BF561, 0x0003,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n   {\"bf561\", BFIN_CPU_BF561, 0x0002,\n    WA_SPECULATIVE_LOADS | WA_SPECULATIVE_SYNCS | WA_RETS\n-   | WA_05000283 | WA_05000257 | WA_05000315},\n+   | WA_05000283 | WA_05000257 | WA_05000315 | WA_LOAD_LCREGS},\n \n   {NULL, 0, 0, 0}\n };\n \n-int splitting_for_sched;\n+int splitting_for_sched, splitting_loops;\n \n static void\n bfin_globalize_label (FILE *stream, const char *name)\n@@ -3640,12 +3641,6 @@ struct GTY (()) loop_info\n   /* The iteration register.  */\n   rtx iter_reg;\n \n-  /* The new initialization insn.  */\n-  rtx init;\n-\n-  /* The new initialization instruction.  */\n-  rtx loop_init;\n-\n   /* The new label placed at the beginning of the loop. */\n   rtx start_label;\n \n@@ -3786,10 +3781,10 @@ bfin_optimize_loop (loop_info loop)\n {\n   basic_block bb;\n   loop_info inner;\n-  rtx insn, init_insn, last_insn;\n+  rtx insn, last_insn;\n   rtx loop_init, start_label, end_label;\n   rtx reg_lc0, reg_lc1, reg_lt0, reg_lt1, reg_lb0, reg_lb1;\n-  rtx iter_reg;\n+  rtx iter_reg, scratchreg;\n   rtx lc_reg, lt_reg, lb_reg;\n   rtx seq, seq_end;\n   int length;\n@@ -3835,13 +3830,27 @@ bfin_optimize_loop (loop_info loop)\n   /* Get the loop iteration register.  */\n   iter_reg = loop->iter_reg;\n \n-  if (!DPREG_P (iter_reg))\n+  if (!REG_P (iter_reg))\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \";; loop %d iteration count NOT in PREG or DREG\\n\",\n+\tfprintf (dump_file, \";; loop %d iteration count not in a register\\n\",\n \t\t loop->loop_no);\n       goto bad_loop;\n     }\n+  scratchreg = NULL_RTX;\n+  if (!PREG_P (iter_reg) && loop->incoming_src)\n+    {\n+      int i;\n+      for (i = REG_P0; i <= REG_P5; i++)\n+\tif ((df_regs_ever_live_p (i)\n+\t     || (funkind (TREE_TYPE (current_function_decl)) == SUBROUTINE\n+\t\t && call_used_regs[i]))\n+\t    && !REGNO_REG_SET_P (df_get_live_out (loop->incoming_src), i))\n+\t  {\n+\t    scratchreg = gen_rtx_REG (SImode, i);\n+\t    break;\n+\t  }\n+    }\n \n   if (loop->incoming_src)\n     {\n@@ -3860,7 +3869,7 @@ bfin_optimize_loop (loop_info loop)\n \n       for (; insn && insn != loop->start_label; insn = NEXT_INSN (insn))\n \tlength += length_for_loop (insn);\n-      \n+\n       if (!insn)\n \t{\n \t  if (dump_file)\n@@ -3869,6 +3878,11 @@ bfin_optimize_loop (loop_info loop)\n \t  goto bad_loop;\n \t}\n \n+      /* Account for the pop of a scratch register where necessary.  */\n+      if (!PREG_P (iter_reg) && scratchreg == NULL_RTX\n+\t  && ENABLE_WA_LOAD_LCREGS)\n+\tlength += 2;\n+\n       if (length > MAX_LSETUP_DISTANCE)\n \t{\n \t  if (dump_file)\n@@ -4049,46 +4063,67 @@ bfin_optimize_loop (loop_info loop)\n       loop->clobber_loop0 = 1;\n     }\n \n-  /* If iter_reg is a DREG, we need generate an instruction to load\n-     the loop count into LC register. */\n-  if (D_REGNO_P (REGNO (iter_reg)))\n+  loop->end_label = end_label;\n+\n+  /* Create a sequence containing the loop setup.  */\n+  start_sequence ();\n+\n+  /* LSETUP only accepts P registers.  If we have one, we can use it,\n+     otherwise there are several ways of working around the problem.\n+     If we're not affected by anomaly 312, we can load the LC register\n+     from any iteration register, and use LSETUP without initialization.\n+     If we've found a P scratch register that's not live here, we can\n+     instead copy the iter_reg into that and use an initializing LSETUP.\n+     If all else fails, push and pop P0 and use it as a scratch.  */\n+  if (P_REGNO_P (REGNO (iter_reg)))\n+    {\n+      loop_init = gen_lsetup_with_autoinit (lt_reg, start_label,\n+\t\t\t\t\t    lb_reg, end_label,\n+\t\t\t\t\t    lc_reg, iter_reg);\n+      seq_end = emit_insn (loop_init);\n+    }\n+  else if (!ENABLE_WA_LOAD_LCREGS && DPREG_P (iter_reg))\n     {\n-      init_insn = gen_movsi (lc_reg, iter_reg);\n+      emit_insn (gen_movsi (lc_reg, iter_reg));\n       loop_init = gen_lsetup_without_autoinit (lt_reg, start_label,\n \t\t\t\t\t       lb_reg, end_label,\n \t\t\t\t\t       lc_reg);\n+      seq_end = emit_insn (loop_init);\n     }\n-  else if (P_REGNO_P (REGNO (iter_reg)))\n+  else if (scratchreg != NULL_RTX)\n     {\n-      init_insn = NULL_RTX;\n+      emit_insn (gen_movsi (scratchreg, iter_reg));\n       loop_init = gen_lsetup_with_autoinit (lt_reg, start_label,\n \t\t\t\t\t    lb_reg, end_label,\n-\t\t\t\t\t    lc_reg, iter_reg);\n+\t\t\t\t\t    lc_reg, scratchreg);\n+      seq_end = emit_insn (loop_init);\n     }\n   else\n-    gcc_unreachable ();\n-\n-  loop->init = init_insn;\n-  loop->end_label = end_label;\n-  loop->loop_init = loop_init;\n+    {\n+      rtx p0reg = gen_rtx_REG (SImode, REG_P0);\n+      rtx push = gen_frame_mem (SImode,\n+\t\t\t\tgen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n+      rtx pop = gen_frame_mem (SImode,\n+\t\t\t       gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n+      emit_insn (gen_movsi (push, p0reg));\n+      emit_insn (gen_movsi (p0reg, iter_reg));\n+      loop_init = gen_lsetup_with_autoinit (lt_reg, start_label,\n+\t\t\t\t\t    lb_reg, end_label,\n+\t\t\t\t\t    lc_reg, p0reg);\n+      emit_insn (loop_init);\n+      seq_end = emit_insn (gen_movsi (p0reg, pop));\n+    }\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \";; replacing loop %d initializer with\\n\",\n \t       loop->loop_no);\n-      print_rtl_single (dump_file, loop->loop_init);\n+      print_rtl_single (dump_file, loop_init);\n       fprintf (dump_file, \";; replacing loop %d terminator with\\n\",\n \t       loop->loop_no);\n       print_rtl_single (dump_file, loop->loop_end);\n     }\n \n-  /* Create a sequence containing the loop setup.  */\n-  start_sequence ();\n-\n-  if (loop->init != NULL_RTX)\n-    emit_insn (loop->init);\n-  seq_end = emit_insn (loop->loop_init);\n-\n   /* If the loop isn't entered at the top, also create a jump to the entry\n      point.  */\n   if (!loop->incoming_src && loop->head != loop->incoming_dest)\n@@ -4106,7 +4141,7 @@ bfin_optimize_loop (loop_info loop)\n \t  seq_end = emit_insn (copy_rtx (PATTERN (last_insn)));\n \t}\n       else\n-\tseq_end = emit_insn (gen_jump (label));\n+\tseq_end = emit_jump_insn (gen_jump (label));\n     }\n \n   seq = get_insns ();\n@@ -4216,7 +4251,6 @@ bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n   loop->outer = NULL;\n   loop->loops = NULL;\n   loop->incoming = VEC_alloc (edge, gc, 2);\n-  loop->init = loop->loop_init = NULL_RTX;\n   loop->start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (tail_insn), 0, 0)), 1), 0);\n   loop->end_label = NULL_RTX;\n   loop->bad = 0;\n@@ -4590,7 +4624,7 @@ bfin_reorg_loops (FILE *dump_file)\n       fprintf (dump_file, \";; All loops found:\\n\\n\");\n       bfin_dump_loops (loops);\n     }\n-  \n+\n   /* Now apply the optimizations.  */\n   for (loop = loops; loop; loop = loop->next)\n     bfin_optimize_loop (loop);\n@@ -4608,6 +4642,17 @@ bfin_reorg_loops (FILE *dump_file)\n \n   FOR_EACH_BB (bb)\n     bb->aux = NULL;\n+\n+  splitting_loops = 1;\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn = BB_END (bb);\n+      if (!JUMP_P (insn))\n+\tcontinue;\n+\n+      try_split (PATTERN (insn), insn, 1);\n+    }\n+  splitting_loops = 0;\n }\n \f\n /* Possibly generate a SEQUENCE out of three insns found in SLOT."}, {"sha": "f7f2cd492eb870a24ca4db234fc087ea22b3c205", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=97a988bcb2bfbca69c5396aae923bf0001cf6802", "patch": "@@ -1322,7 +1322,7 @@ extern struct rtx_def *bfin_cc_rtx, *bfin_rets_rtx;\n \n #define SIZE_ASM_OP     \"\\t.size\\t\"\n \n-extern int splitting_for_sched;\n+extern int splitting_for_sched, splitting_loops;\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) ((CHAR) == '!')\n "}, {"sha": "4397b7a139ab3e5b8bd91cda18992c61d477cde6", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a988bcb2bfbca69c5396aae923bf0001cf6802/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=97a988bcb2bfbca69c5396aae923bf0001cf6802", "patch": "@@ -532,10 +532,12 @@\n ;; with a PLUS.  We generally require fewer secondary reloads this way.\n \n (define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=da,x*y,da,x,x,x,da,mr\")\n-\t(match_operand:SI 1 \"general_operand\" \"da,x*y,xKs7,xKsh,xKuh,ix,mr,da\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=da,x,da,y,da,x,x,x,da,mr\")\n+\t(match_operand:SI 1 \"general_operand\" \"da,x,y,da,xKs7,xKsh,xKuh,ix,mr,da\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) == REG\"\n  \"@\n+   %0 = %1;\n+   %0 = %1;\n    %0 = %1;\n    %0 = %1;\n    %0 = %1 (X);\n@@ -544,8 +546,8 @@\n    #\n    %0 = %1%!\n    %0 = %1%!\"\n-  [(set_attr \"type\" \"move,move,mvi,mvi,mvi,*,mcld,mcst\")\n-   (set_attr \"length\" \"2,2,2,4,4,*,*,*\")])\n+  [(set_attr \"type\" \"move,move,move,move,mvi,mvi,mvi,*,mcld,mcst\")\n+   (set_attr \"length\" \"2,2,2,2,2,4,4,*,*,*\")])\n \n (define_insn \"*movsi_insn32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n@@ -1908,7 +1910,7 @@\n \t      (const_int -1)))\n    (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"reload_completed\"\n+  \"splitting_loops\"\n   [(set (match_dup 2) (match_dup 0))\n    (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n    (set (match_dup 0) (match_dup 2))"}]}