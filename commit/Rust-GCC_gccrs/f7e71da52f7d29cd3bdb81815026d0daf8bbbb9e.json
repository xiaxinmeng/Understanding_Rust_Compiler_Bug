{"sha": "f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlNzFkYTUyZjdkMjljZDNiZGI4MTgxNTAyNmQwZGFmOGJiYmI5ZQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-09-28T21:02:38Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-09-28T21:02:38Z"}, "message": "add parsing for ObjC* method & method parm attributes\n\ngcc/cp:\n\t\n\tPartially merged from apple/trunk branch on FSF servers:\n\t2006-04-26 Fariborz Jahanian <fjahanian@apple.com>\n\tRadar 3803157 (method attributes)\n\n\t* parser.c (cp_parser_objc_method_keyword_params): Handle attributes.\n\t(cp_parser_objc_method_tail_params_opt): Likewise.\n\t(cp_parser_objc_method_signature): Likewise.\n\t(cp_parser_objc_method_maybe_bad_prefix_attributes): New.\n\t(cp_parser_objc_method_prototype_list): Handle attributes.\n\t(cp_parser_objc_method_definition_list): Likewise.\n\ngcc/objc:\n\t\n\t* objc-act.c (objc_add_method_declaration): Handle attributes.\n\t(objc_start_method_definition): Likewise.\n\t(objc_generate_cxx_ctor_or_dtor): Pass NULL attributes to ctor/dtor.\n\t(objc_build_keyword_decl): Handle attributes.\n\ngcc:\n\n\t* c-parser.c (c_parser_declaration_or_fndef): Diagnose incorrect prefix\n\tattributes on methods.\n\t (c_parser_objc_method_definition): Handle attributes.\n\t(c_parser_objc_methodproto): Likewise.\n\t(c_parser_objc_maybe_method_attributes): New.\n\t(c_parser_objc_method_decl): Handle attributes, add a similar diagnostic\n\tto ObjC++ for a missing definition.\n\ngcc/c-family:\n\t\n\t* c-common.h: Update declarations to include attributes.\n\t* stub-objc.c: Likewise.\n\ntestsuite:\n\n\t* objc.dg/attributes/method-attribute-1.m: New.\n\t* objc.dg/attributes/method-attribute-2.m: New.\n\n\t* obj-c++.dg/attributes/method-attribute-1.m: New.\n\t* obj-c++.dg/attributes/method-attribute-2.m: New.\n\nFrom-SVN: r164702", "tree": {"sha": "0b58ec78878b5ec817b8d9d6545ff6e30a03c52c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b58ec78878b5ec817b8d9d6545ff6e30a03c52c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a0390e691ece0d859b7d87c6e6617d227cb8dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0a0390e691ece0d859b7d87c6e6617d227cb8dd"}], "stats": {"total": 496, "additions": 455, "deletions": 41}, "files": [{"sha": "2aded9728623f9b5ff0efc82ad18b4fadd05365a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -1,3 +1,13 @@\n+2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* c-parser.c (c_parser_declaration_or_fndef): Diagnose incorrect prefix\n+\tattributes on methods.\n+\t (c_parser_objc_method_definition): Handle attributes.\n+\t(c_parser_objc_methodproto): Likewise.\n+\t(c_parser_objc_maybe_method_attributes): New.\n+\t(c_parser_objc_method_decl): Handle attributes, add a diagnostic for a\n+\tmissing definition, similar to that in ObjC++.\n+\n 2010-09-28  Richard Henderson  <rth@redhat.com>\n \n \t* defaults.h (DWARF2_UNWIND_INFO): Don't depend on TARGET_UNWIND_INFO.\n@@ -62,7 +72,7 @@\n \t(TARGET_UNWIND_INFO): Remove.\n \n \t* config/pa/pa.c (pa_option_override): Use targetm.except_unwind_info.\n-\n+\t\n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* c-parser.c (c_parser_objc_class_definition): Adjust prototype."}, {"sha": "7480f63f3218f5183ffedd43b4961327ddff31dc", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -1,3 +1,13 @@\n+2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* c-common.h (objc_add_method_declaration): Adjust prototype to \n+\tinclude attributes.\n+\t(objc_start_method_definition): Likewise.\n+\t(objc_build_keyword_decl): Likewise.\n+\t* stub-objc.c:(objc_add_method_declaration): Handle attributes.\n+\t(objc_start_method_definition): Likewise.\n+\t(objc_build_keyword_decl): Likewise.\n+\n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* c-common.h (objc_start_class_interface): Adjust prototype."}, {"sha": "45ec999745e2aaacc9dd68fabaa5252c8cf0f6e8", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -977,11 +977,11 @@ extern void objc_finish_implementation (void);\n extern void objc_set_visibility (int);\n extern void objc_set_method_type (enum tree_code);\n extern tree objc_build_method_signature (tree, tree, tree, bool);\n-extern void objc_add_method_declaration (tree);\n-extern bool objc_start_method_definition (tree);\n+extern void objc_add_method_declaration (tree, tree);\n+extern bool objc_start_method_definition (tree, tree);\n extern void objc_finish_method_definition (tree);\n extern void objc_add_instance_variable (tree);\n-extern tree objc_build_keyword_decl (tree, tree, tree);\n+extern tree objc_build_keyword_decl (tree, tree, tree, tree);\n extern tree objc_build_throw_stmt (location_t, tree);\n extern void objc_begin_try_stmt (location_t, tree);\n extern tree objc_finish_try_stmt (void);"}, {"sha": "6e205bfb1789cb65d5f75e99b688486efb50a451", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -196,12 +196,14 @@ objc_finish_implementation (void)\n }\n \n void\n-objc_add_method_declaration (tree ARG_UNUSED (signature))\n+objc_add_method_declaration (tree ARG_UNUSED (signature),\n+\t\t\t     tree ARG_UNUSED (attributes))\n {\n }\n \n bool\n-objc_start_method_definition (tree ARG_UNUSED (signature))\n+objc_start_method_definition (tree ARG_UNUSED (signature),\n+\t\t\t      tree ARG_UNUSED (attributes))\n {\n   return true;\n }\n@@ -214,7 +216,8 @@ objc_finish_method_definition (tree ARG_UNUSED (fndecl))\n tree\n objc_build_keyword_decl (tree ARG_UNUSED (selector),\n \t\t\t tree ARG_UNUSED (type),\n-\t\t\t tree ARG_UNUSED (identifier))\n+\t\t\t tree ARG_UNUSED (identifier),\n+\t\t\t tree ARG_UNUSED (attributes))\n {\n   return 0;\n }"}, {"sha": "5d0f36bacb29b30f7ee7b9bb539cd891f58728ec", "filename": "gcc/c-parser.c", "status": "modified", "additions": 109, "deletions": 10, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -986,7 +986,7 @@ static enum tree_code c_parser_objc_method_type (c_parser *);\n static void c_parser_objc_method_definition (c_parser *);\n static void c_parser_objc_methodprotolist (c_parser *);\n static void c_parser_objc_methodproto (c_parser *);\n-static tree c_parser_objc_method_decl (c_parser *);\n+static tree c_parser_objc_method_decl (c_parser *, tree *);\n static tree c_parser_objc_type_name (c_parser *);\n static tree c_parser_objc_protocol_refs (c_parser *);\n static void c_parser_objc_try_catch_statement (c_parser *);\n@@ -1244,6 +1244,29 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n     }\n   else if (c_dialect_objc ())\n     {\n+      /* Prefix attributes are an error on method decls.  */\n+      switch (c_parser_peek_token (parser)->type)\n+\t{\n+\t  case CPP_PLUS:\n+\t  case CPP_MINUS:\n+\t    if (c_parser_objc_diagnose_bad_element_prefix (parser, specs))\n+\t      return;\n+\t    if (specs->attrs)\n+\t      {\n+\t\twarning_at (c_parser_peek_token (parser)->location, \n+\t\t\t    OPT_Wattributes,\n+\t       \t\t    \"prefix attributes are ignored for methods\");\n+\t\tspecs->attrs = NULL_TREE;\n+\t      }\n+\t    if (fndef_ok)\n+\t      c_parser_objc_method_definition (parser);\n+\t    else\n+\t      c_parser_objc_methodproto (parser);\n+\t    return;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t}\n       /* This is where we parse 'attributes @interface ...',\n \t 'attributes @implementation ...', 'attributes @protocol ...'\n \t (where attributes could be, for example, __attribute__\n@@ -6635,23 +6658,28 @@ static void\n c_parser_objc_method_definition (c_parser *parser)\n {\n   enum tree_code type = c_parser_objc_method_type (parser);\n-  tree decl;\n+  tree decl, attributes = NULL_TREE;\n   objc_set_method_type (type);\n   parser->objc_pq_context = true;\n-  decl = c_parser_objc_method_decl (parser);\n+  decl = c_parser_objc_method_decl (parser, &attributes);\n+  if (decl == error_mark_node)\n+    return;  /* Bail here. */\n+\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       c_parser_consume_token (parser);\n       pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t       \"extra semicolon in method definition specified\");\n     }\n+\n   if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n       c_parser_error (parser, \"expected %<{%>\");\n       return;\n     }\n+\n   parser->objc_pq_context = false;\n-  if (objc_start_method_definition (decl))\n+  if (objc_start_method_definition (decl, attributes))\n     {\n       add_stmt (c_parser_compound_statement (parser));\n       objc_finish_method_definition (current_function_decl);\n@@ -6722,24 +6750,72 @@ static void\n c_parser_objc_methodproto (c_parser *parser)\n {\n   enum tree_code type = c_parser_objc_method_type (parser);\n-  tree decl;\n+  tree decl, attributes = NULL_TREE;\n   objc_set_method_type (type);\n   /* Remember protocol qualifiers in prototypes.  */\n   parser->objc_pq_context = true;\n-  decl = c_parser_objc_method_decl (parser);\n-  /* Forget protocol qualifiers here.  */\n+  decl = c_parser_objc_method_decl (parser, &attributes);\n+  /* Forget protocol qualifiers now.  */\n   parser->objc_pq_context = false;\n-  objc_add_method_declaration (decl);\n+\n+  /* Do not allow the presence of attributes to hide an erroneous \n+     method implementation in the interface section.  */\n+  if (!c_parser_next_token_is (parser, CPP_SEMICOLON))\n+    {\n+      c_parser_error (parser, \"expected %<;%>\");\n+      return;\n+    }\n+  \n+  if (decl != error_mark_node)\n+    objc_add_method_declaration (decl, attributes);\n+\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n \n+/* If we are at a position that method attributes may be present, check that \n+   there are not any parsed already (a syntax error) and then collect any \n+   specified at the current location.  Finally, if new attributes were present,\n+   check that the next token is legal ( ';' for decls and '{' for defs).  */\n+   \n+static bool \n+c_parser_objc_maybe_method_attributes (c_parser* parser, tree* attributes)\n+{\n+  bool bad = false;\n+  if (*attributes)\n+    {\n+      c_parser_error (parser, \n+\t\t    \"method attributes must be specified at the end only\");\n+      *attributes = NULL_TREE;\n+      bad = true;\n+    }\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+    *attributes = c_parser_attributes (parser);\n+\n+  /* If there were no attributes here, just report any earlier error.  */\n+  if (*attributes == NULL_TREE || bad)\n+    return bad;\n+\n+  /* If the attributes are followed by a ; or {, then just report any earlier\n+     error.  */\n+  if (c_parser_next_token_is (parser, CPP_SEMICOLON)\n+      || c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n+    return bad;\n+\n+  /* We've got attributes, but not at the end.  */\n+  c_parser_error (parser, \n+\t\t  \"expected %<;%> or %<{%> after method attribute definition\");\n+  return true;\n+}\n+\n /* Parse an objc-method-decl.\n \n    objc-method-decl:\n      ( objc-type-name ) objc-selector\n      objc-selector\n      ( objc-type-name ) objc-keyword-selector objc-optparmlist\n      objc-keyword-selector objc-optparmlist\n+     attributes\n \n    objc-keyword-selector:\n      objc-keyword-decl\n@@ -6764,13 +6840,15 @@ c_parser_objc_methodproto (c_parser *parser)\n */\n \n static tree\n-c_parser_objc_method_decl (c_parser *parser)\n+c_parser_objc_method_decl (c_parser *parser, tree *attributes)\n {\n   tree type = NULL_TREE;\n   tree sel;\n   tree parms = NULL_TREE;\n   bool ellipsis = false;\n+  bool attr_err = false;\n \n+  *attributes = NULL_TREE;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n       c_parser_consume_token (parser);\n@@ -6788,6 +6866,7 @@ c_parser_objc_method_decl (c_parser *parser)\n       while (true)\n \t{\n \t  tree atype = NULL_TREE, id, keyworddecl;\n+\t  tree param_attr = NULL_TREE;\n \t  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n \t    break;\n \t  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n@@ -6797,19 +6876,25 @@ c_parser_objc_method_decl (c_parser *parser)\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t\t \"expected %<)%>\");\n \t    }\n+\t  /* New ObjC allows attributes on method parameters.  */\n+\t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+\t    param_attr = c_parser_attributes (parser);\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME))\n \t    {\n \t      c_parser_error (parser, \"expected identifier\");\n \t      return error_mark_node;\n \t    }\n \t  id = c_parser_peek_token (parser)->value;\n \t  c_parser_consume_token (parser);\n-\t  keyworddecl = objc_build_keyword_decl (tsel, atype, id);\n+\t  keyworddecl = objc_build_keyword_decl (tsel, atype, id, param_attr);\n \t  list = chainon (list, keyworddecl);\n \t  tsel = c_parser_objc_selector (parser);\n \t  if (!tsel && c_parser_next_token_is_not (parser, CPP_COLON))\n \t    break;\n \t}\n+\n+      attr_err |= c_parser_objc_maybe_method_attributes (parser, attributes) ;\n+\n       /* Parse the optional parameter list.  Optional Objective-C\n \t method parameters follow the C syntax, and may include '...'\n \t to denote a variable number of arguments.  */\n@@ -6822,6 +6907,8 @@ c_parser_objc_method_decl (c_parser *parser)\n \t    {\n \t      ellipsis = true;\n \t      c_parser_consume_token (parser);\n+\t      attr_err |= c_parser_objc_maybe_method_attributes \n+\t\t\t\t\t\t(parser, attributes) ;\n \t      break;\n \t    }\n \t  parm = c_parser_parameter_declaration (parser, NULL_TREE);\n@@ -6832,6 +6919,18 @@ c_parser_objc_method_decl (c_parser *parser)\n \t}\n       sel = list;\n     }\n+  else\n+    attr_err |= c_parser_objc_maybe_method_attributes (parser, attributes) ;\n+\n+  if (sel == NULL)\n+    {\n+      c_parser_error (parser, \"objective-c method declaration is expected\");\n+      return error_mark_node;\n+    }\n+\n+  if (attr_err)\n+    return error_mark_node;\n+\n   return objc_build_method_signature (type, sel, parms, ellipsis);\n }\n "}, {"sha": "1776ee6fba8cd5083b49973471399b4874c6ce49", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -1,3 +1,16 @@\n+2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n+\t\n+\tPartially merged from apple/trunk branch on FSF servers:\n+\t2006-04-26 Fariborz Jahanian <fjahanian@apple.com>\n+\tRadar 3803157 (method attributes)\n+\t\n+\t* parser.c (cp_parser_objc_method_keyword_params): Handle attributes.\n+\t(cp_parser_objc_method_tail_params_opt): Likewise.\n+\t(cp_parser_objc_method_signature): Likewise.\n+\t(cp_parser_objc_method_maybe_bad_prefix_attributes): New.\n+\t(cp_parser_objc_method_prototype_list): Handle attributes.\n+\t(cp_parser_objc_method_definition_list): Likewise.\n+\n 2010-09-28  Richard Henderson  <rth@redhat.com>\n \n \t* cp-lang.c: Include \"target.h\"."}, {"sha": "b622613d3cafc0b083a7fdf2f11ebe08f164cfdc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 122, "deletions": 19, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -21449,7 +21449,7 @@ cp_parser_objc_selector (cp_parser* parser)\n /* Parse an Objective-C params list.  */\n \n static tree\n-cp_parser_objc_method_keyword_params (cp_parser* parser)\n+cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n {\n   tree params = NULL_TREE;\n   bool maybe_unary_selector_p = true;\n@@ -21458,36 +21458,66 @@ cp_parser_objc_method_keyword_params (cp_parser* parser)\n   while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n     {\n       tree selector = NULL_TREE, type_name, identifier;\n+      tree parm_attr = NULL_TREE;\n+\n+      if (token->keyword == RID_ATTRIBUTE)\n+\tbreak;\n \n       if (token->type != CPP_COLON)\n \tselector = cp_parser_objc_selector (parser);\n \n       /* Detect if we have a unary selector.  */\n       if (maybe_unary_selector_p\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\treturn selector;\n+\t{\n+\t  params = selector; /* Might be followed by attributes.  */\n+\t  break;\n+\t}\n \n       maybe_unary_selector_p = false;\n       cp_parser_require (parser, CPP_COLON, RT_COLON);\n       type_name = cp_parser_objc_typename (parser);\n+      /* New ObjC allows attributes on parameters too.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n+\tparm_attr = cp_parser_attributes_opt (parser);\n       identifier = cp_parser_identifier (parser);\n \n       params\n \t= chainon (params,\n \t\t   objc_build_keyword_decl (selector,\n \t\t\t\t\t    type_name,\n-\t\t\t\t\t    identifier));\n+\t\t\t\t\t    identifier,\n+\t\t\t\t\t    parm_attr));\n \n       token = cp_lexer_peek_token (parser->lexer);\n     }\n \n+  if (params == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n+      return error_mark_node;\n+    }\n+\n+  /* We allow tail attributes for the method.  */\n+  if (token->keyword == RID_ATTRIBUTE)\n+    {\n+      *attributes = cp_parser_attributes_opt (parser);\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\treturn params;\n+      cp_parser_error (parser, \n+\t\t       \"method attributes must be specified at the end\");\n+      return error_mark_node;\n+    }\n+\n   return params;\n }\n \n /* Parse the non-keyword Objective-C params.  */\n \n static tree\n-cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp)\n+cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, \n+\t\t\t\t       tree* attributes)\n {\n   tree params = make_node (TREE_LIST);\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n@@ -21508,6 +21538,7 @@ cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp)\n \t  break;\n \t}\n \n+      /* TODO: parse attributes for tail parameters.  */\n       parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n       parm = grokdeclarator (parmdecl->declarator,\n \t\t\t     &parmdecl->decl_specifiers,\n@@ -21518,6 +21549,26 @@ cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp)\n       token = cp_lexer_peek_token (parser->lexer);\n     }\n \n+  /* We allow tail attributes for the method.  */\n+  if (token->keyword == RID_ATTRIBUTE)\n+    {\n+      if (*attributes == NULL_TREE)\n+\t{\n+\t  *attributes = cp_parser_attributes_opt (parser);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t    return params;\n+\t}\n+      else        \n+\t/* We have an error, but parse the attributes, so that we can \n+\t   carry on.  */\n+\t*attributes = cp_parser_attributes_opt (parser);\n+\n+      cp_parser_error (parser, \n+\t\t       \"method attributes must be specified at the end\");\n+      return error_mark_node;\n+    }\n+\n   return params;\n }\n \n@@ -21547,34 +21598,70 @@ cp_parser_objc_interstitial_code (cp_parser* parser)\n /* Parse a method signature.  */\n \n static tree\n-cp_parser_objc_method_signature (cp_parser* parser)\n+cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)\n {\n   tree rettype, kwdparms, optparms;\n   bool ellipsis = false;\n \n   cp_parser_objc_method_type (parser);\n   rettype = cp_parser_objc_typename (parser);\n-  kwdparms = cp_parser_objc_method_keyword_params (parser);\n-  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis);\n+  *attributes = NULL_TREE;\n+  kwdparms = cp_parser_objc_method_keyword_params (parser, attributes);\n+  if (kwdparms == error_mark_node)\n+    return error_mark_node;\n+  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis, attributes);\n+  if (optparms == error_mark_node)\n+    return error_mark_node;\n \n   return objc_build_method_signature (rettype, kwdparms, optparms, ellipsis);\n }\n \n-/* Pars an Objective-C method prototype list.  */\n+static bool\n+cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n+{\n+  tree tattr;  \n+  cp_lexer_save_tokens (parser->lexer);\n+  tattr = cp_parser_attributes_opt (parser);\n+  gcc_assert (tattr) ;\n+  \n+  /* If the attributes are followed by a method introducer, this is not allowed.\n+     Dump the attributes and flag the situation.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_PLUS)\n+      || cp_lexer_next_token_is (parser->lexer, CPP_MINUS))\n+    return true;\n+\n+  /* Otherwise, the attributes introduce some interstitial code, possibly so\n+     rewind to allow that check.  */\n+  cp_lexer_rollback_tokens (parser->lexer);\n+  return false;  \n+}\n+\n+/* Parse an Objective-C method prototype list.  */\n \n static void\n cp_parser_objc_method_prototype_list (cp_parser* parser)\n {\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-  while (token->keyword != RID_AT_END)\n+  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n     {\n       if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n \t{\n-\t  objc_add_method_declaration\n-\t   (cp_parser_objc_method_signature (parser));\n+\t  tree attributes, sig;\n+\t  sig = cp_parser_objc_method_signature (parser, &attributes);\n+\t  if (sig == error_mark_node)\n+\t    {\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      continue;\n+\t    }\n+\t  objc_add_method_declaration (sig, attributes);\n \t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n \t}\n+      else if (token->keyword == RID_ATTRIBUTE \n+      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n+\twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n+\t\t    OPT_Wattributes, \n+\t\t    \"prefix attributes are ignored for methods\");\n       else\n \t/* Allow for interspersed non-ObjC++ code.  */\n \tcp_parser_objc_interstitial_code (parser);\n@@ -21593,27 +21680,43 @@ cp_parser_objc_method_definition_list (cp_parser* parser)\n {\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-  while (token->keyword != RID_AT_END)\n+  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n     {\n       tree meth;\n \n       if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n \t{\n+\t  cp_token *ptk;\n+\t  tree sig, attribute;\n \t  push_deferring_access_checks (dk_deferred);\n-\t  objc_start_method_definition\n-\t   (cp_parser_objc_method_signature (parser));\n+\t  sig = cp_parser_objc_method_signature (parser, &attribute);\n+\t  if (sig == error_mark_node)\n+\t    {\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      continue;\n+\t    }\n+\t  objc_start_method_definition (sig, attribute);\n \n \t  /* For historical reasons, we accept an optional semicolon.  */\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n \t    cp_lexer_consume_token (parser->lexer);\n \n-\t  perform_deferred_access_checks ();\n-\t  stop_deferring_access_checks ();\n-\t  meth = cp_parser_function_definition_after_declarator (parser,\n+\t  ptk = cp_lexer_peek_token (parser->lexer);\n+\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n+\t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n+\t    {\n+\t      perform_deferred_access_checks ();\n+\t      stop_deferring_access_checks ();\n+\t      meth = cp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t\t\t false);\n-\t  pop_deferring_access_checks ();\n-\t  objc_finish_method_definition (meth);\n+\t      pop_deferring_access_checks ();\n+\t      objc_finish_method_definition (meth);\n+\t    }\n \t}\n+      else if (token->keyword == RID_ATTRIBUTE \n+      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n+\twarning_at (token->location, OPT_Wattributes,\n+\t       \t    \"prefix attributes are ignored for methods\");\n       else\n \t/* Allow for interspersed non-ObjC++ code.  */\n \tcp_parser_objc_interstitial_code (parser);"}, {"sha": "26be691cc371efb8bde61279070d1b73c8657753", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -1,3 +1,11 @@\n+2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n+\t\n+\t* objc-act.c (objc_add_method_declaration): Handle and ignore \n+\tattributes.\n+\t(objc_start_method_definition): Likewise.\n+\t(objc_generate_cxx_ctor_or_dtor): Pass NULL attributes to ctor/dtor.\n+\t(objc_build_keyword_decl): Handle and ignore attributes.\n+\n 2010-09-28  Richard Henderson  <rth@redhat.com>\n \n \t* objc-act.c (objc_eh_personality): Use targetm.except_unwind_info."}, {"sha": "02c60ab0bdd9919bc8f161fef39c1631fd46fa77", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -769,7 +769,7 @@ objc_build_method_signature (tree rettype, tree selector,\n }\n \n void\n-objc_add_method_declaration (tree decl)\n+objc_add_method_declaration (tree decl, tree attributes)\n {\n   if (!objc_interface_context)\n     {\n@@ -780,6 +780,11 @@ objc_add_method_declaration (tree decl)\n       fatal_error (\"method declaration not in @interface context\");\n     }\n \n+  if (attributes)\n+    warning_at (input_location, OPT_Wattributes, \n+\t\t\"method attributes are not available in this version\"\n+\t\t\" of the compiler, (ignored)\");\n+\n   objc_add_method (objc_interface_context,\n \t\t   decl,\n \t\t   objc_inherit_code == CLASS_METHOD_DECL);\n@@ -789,14 +794,19 @@ objc_add_method_declaration (tree decl)\n    'false' if not (because we are outside an @implementation context).\n */\n bool\n-objc_start_method_definition (tree decl)\n+objc_start_method_definition (tree decl, tree attributes)\n {\n   if (!objc_implementation_context)\n     {\n       error (\"method definition not in @implementation context\");\n       return false;\n     }\n \n+  if (attributes)\n+    warning_at (input_location, OPT_Wattributes, \n+\t\t\"method attributes are not available in this version\"\n+\t\t\" of the compiler, (ignored)\");\n+\n #ifndef OBJCPLUS\n   /* Indicate no valid break/continue context by setting these variables\n      to some non-null, non-label value.  We'll notice and emit the proper\n@@ -4644,7 +4654,7 @@ objc_generate_cxx_ctor_or_dtor (bool dtor)\n \t\t\t\t\t\t ? TAG_CXX_DESTRUCT\n \t\t\t\t\t\t : TAG_CXX_CONSTRUCT),\n \t\t\t\t make_node (TREE_LIST),\n-\t\t\t\t false));\n+\t\t\t\t false), NULL);\n   body = begin_function_body ();\n   compound_stmt = begin_compound_stmt (0);\n \n@@ -5976,6 +5986,7 @@ adjust_type_for_id_default (tree type)\n      In:\tkey_name, an \"identifier_node\" (optional).\n \t\targ_type, a  \"tree_list\" (optional).\n \t\targ_name, an \"identifier_node\".\n+\t\tattributes, a optional tree containing param attributes.\n \n      Note:\tIt would be really nice to strongly type the preceding\n \t\targuments in the function prototype; however, then I\n@@ -5984,10 +5995,16 @@ adjust_type_for_id_default (tree type)\n      Out:\tan instance of \"keyword_decl\".  */\n \n tree\n-objc_build_keyword_decl (tree key_name, tree arg_type, tree arg_name)\n+objc_build_keyword_decl (tree key_name, tree arg_type, \n+\t\t\t tree arg_name, tree attributes)\n {\n   tree keyword_decl;\n \n+  if (attributes)\n+    warning_at (input_location, OPT_Wattributes, \n+\t\t\"method parameter attributes are not available in this \"\n+\t\t\"version of the compiler, (ignored)\");\n+\n   /* If no type is specified, default to \"id\".  */\n   arg_type = adjust_type_for_id_default (arg_type);\n \n@@ -8128,7 +8145,7 @@ encode_array (tree type, int curtype, int format)\n   tree an_int_cst = TYPE_SIZE (type);\n   tree array_of = TREE_TYPE (type);\n   char buffer[40];\n-\n+  \n   if (an_int_cst == NULL)\n     {\n       /* We are trying to encode an incomplete array.  An incomplete"}, {"sha": "4cbe57b18de614691602485aaf498e0a3e226fcb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -1,3 +1,11 @@\n+2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* objc.dg/attributes/method-attribute-1.m: New.\n+\t* objc.dg/attributes/method-attribute-2.m: New.\n+\n+\t* obj-c++.dg/attributes/method-attribute-1.m: New.\n+\t* obj-c++.dg/attributes/method-attribute-2.m: New.\n+\n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* objc.dg/attributes: New."}, {"sha": "2e2326c13b5fb69ecd800a5e8b24774980eb1968", "filename": "gcc/testsuite/obj-c++.dg/attributes/method-attribute-1.mm", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-attribute-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-attribute-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-attribute-1.mm?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n+\n+@interface obj : Object {\n+@public \n+  int var; \n+} \n+- (int) mth;\n++ (id) dep_cls_mth __attribute__((deprecated)) ;/* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) dep_ins_mth __attribute__((deprecated)) ;/* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) dep_ins_mtharg: (int) i __attribute__((deprecated)) ;/* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) dep_ins_mtharg1: (int) i __attribute__((deprecated)) add: (int) j;/* { dg-error \"method attributes must be specified at the end \" } */\n+- (int) nodef __attribute__((deprecated)) { return var-2; } ; /* { dg-error \"expected ';' before '\\{' token\" } */\n+\t\t/* { dg-warning \"method attributes are not available in this version\" \"\" { target *-*-* } 15 } */\n+__attribute__((deprecated)) \n+- (int) bad_pref_mth; /* { dg-warning \"prefix attributes are ignored for methods\" } */\n+@end\n+\n+@implementation obj\n+- (int) mth { return var; }\n++ (id) dep_cls_mth { return self; }\n+- (int) dep_ins_mth  { return var ; }\n+- (int) dep_ins_mtharg: (int) i { return var + i ; }\n+- (int) dep_ins_mtharg1: (int) i add: (int) j { return var + i + j ; } \n+- (int) bad_pref_mth { return var; };\n+- (int) nodef { return var-2; } ; \n+@end \n+\n+int foo (void)\n+{\n+  obj *p = [obj new];\n+  id n = [obj dep_cls_mth];\n+  \n+  [p dep_ins_mth];\n+  [p dep_ins_mtharg:2];\n+  [p dep_ins_mtharg1:3 add:3];\n+\n+  return [p mth];    \n+}"}, {"sha": "f02149e3332722083b386c0dc6d59f807f7e4a19", "filename": "gcc/testsuite/obj-c++.dg/attributes/method-attribute-2.mm", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-attribute-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-attribute-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-attribute-2.mm?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n+\n+@interface obj : Object {\n+@public \n+  int var; \n+} \n+- (int) depmtharg:(int) iarg __attribute__((deprecated)); /* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) unusedarg:(int) __attribute__((unused)) uarg ; /* { dg-warning \"method parameter attributes are not available in this version\" } */\n+- (int) depunusedarg:(int) __attribute__((unused)) uarg __attribute__((deprecated)) ; /* { dg-warning \"method attributes are not available in this version\" } */\n+\t\t\t\t/* { dg-warning \"method parameter attributes are not available in this version\" \"\" { target *-*-* } 12 } */\n+@end\n+\n+@implementation obj\n+- (int) depmtharg:(int) iarg { return var + iarg ; };\n+- (int) unusedarg:(int) __attribute__((unused)) uarg { return var; } ; /* { dg-warning \"method parameter attributes are not available in this version\" } */\n+- (int) depunusedarg:(int) __attribute__((unused)) uarg { return var; }; /* { dg-warning \"method parameter attributes are not available in this version\" } */\n+@end \n+\n+int foo (void)\n+{\n+  obj *p = [obj new];\n+  \n+  [p depmtharg:1];\n+  [p unusedarg:2];\n+  [p depunusedarg:3 ];\n+\n+  return [p depmtharg:0];    \n+}"}, {"sha": "83bc1c02468cfff2abe015d915df3cf63e2b235f", "filename": "gcc/testsuite/objc.dg/attributes/method-attribute-1.m", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-attribute-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-attribute-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-attribute-1.m?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n+\n+@interface obj : Object {\n+@public \n+  int var; \n+} \n+- (int) mth;\n++ (id) dep_cls_mth __attribute__((deprecated)) ;/* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) dep_ins_mth __attribute__((deprecated)) ;/* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) dep_ins_mtharg: (int) i __attribute__((deprecated)) ;/* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) dep_ins_mtharg1: (int) i __attribute__((deprecated)) add: (int) j;/* { dg-error \"expected ';' or '\\{' after method attribute definition\" } */\n+- (int) nodef __attribute__((deprecated)) { return var-2; } ; /* { dg-error \"expected ';' before '\\{' token\" } */\n+__attribute__((deprecated))\n+- (int) bad_pref_mth; /* { dg-warning \"prefix attributes are ignored for methods\" } */\n+@end\n+\n+@implementation obj\n+- (int) mth { return var; }\n++ (id) dep_cls_mth { return self; }\n+- (int) dep_ins_mth  { return var ; }\n+- (int) dep_ins_mtharg: (int) i { return var + i ; }\n+- (int) dep_ins_mtharg1: (int) i add: (int) j { return var + i + j ; } \n+- (int) bad_pref_mth { return var; };\n+- (int) nodef { return var-2; } ; \n+@end \n+\n+int foo (void)\n+{\n+  obj *p = [obj new];\n+  id n = [obj dep_cls_mth];\n+  \n+  [p dep_ins_mth];\n+  [p dep_ins_mtharg:2];\n+  [p dep_ins_mtharg1:3 add:3];\n+\n+  return [p mth];    \n+}"}, {"sha": "f02149e3332722083b386c0dc6d59f807f7e4a19", "filename": "gcc/testsuite/objc.dg/attributes/method-attribute-2.m", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-attribute-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-attribute-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-attribute-2.m?ref=f7e71da52f7d29cd3bdb81815026d0daf8bbbb9e", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+#include \"../../objc-obj-c++-shared/Object1.h\"\n+\n+@interface obj : Object {\n+@public \n+  int var; \n+} \n+- (int) depmtharg:(int) iarg __attribute__((deprecated)); /* { dg-warning \"method attributes are not available in this version\" } */\n+- (int) unusedarg:(int) __attribute__((unused)) uarg ; /* { dg-warning \"method parameter attributes are not available in this version\" } */\n+- (int) depunusedarg:(int) __attribute__((unused)) uarg __attribute__((deprecated)) ; /* { dg-warning \"method attributes are not available in this version\" } */\n+\t\t\t\t/* { dg-warning \"method parameter attributes are not available in this version\" \"\" { target *-*-* } 12 } */\n+@end\n+\n+@implementation obj\n+- (int) depmtharg:(int) iarg { return var + iarg ; };\n+- (int) unusedarg:(int) __attribute__((unused)) uarg { return var; } ; /* { dg-warning \"method parameter attributes are not available in this version\" } */\n+- (int) depunusedarg:(int) __attribute__((unused)) uarg { return var; }; /* { dg-warning \"method parameter attributes are not available in this version\" } */\n+@end \n+\n+int foo (void)\n+{\n+  obj *p = [obj new];\n+  \n+  [p depmtharg:1];\n+  [p unusedarg:2];\n+  [p depunusedarg:3 ];\n+\n+  return [p depmtharg:0];    \n+}"}]}