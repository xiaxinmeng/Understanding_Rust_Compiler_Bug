{"sha": "2b54c30fb0d5947b296e97191c4758864acfc976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1NGMzMGZiMGQ1OTQ3YjI5NmU5NzE5MWM0NzU4ODY0YWNmYzk3Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-02-03T23:24:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-02-03T23:24:05Z"}, "message": "lower-subreg.c (simple_move_operand): New static function, broken out of simple_move.\n\n\t* lower-subreg.c (simple_move_operand): New static function,\n\tbroken out of simple_move.  Reject LABEL_REF, SYMBOL_REF, and HIGH\n\toperands.\n\t(simple_move): Call simple_move_operand.\n\t(find_decomposable_subregs): Add special handling of MEMs.\n\t(can_decompose_p): Rename from cannot_decompose_p.  Reverse\n\tmeaning of return value.  If we see a hard register, test whether\n\tit can store a word_mode value.  Change all callers.\n\nFrom-SVN: r121553", "tree": {"sha": "db3f29175ce934413da3dd780817932fff7c451e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db3f29175ce934413da3dd780817932fff7c451e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b54c30fb0d5947b296e97191c4758864acfc976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b54c30fb0d5947b296e97191c4758864acfc976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b54c30fb0d5947b296e97191c4758864acfc976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b54c30fb0d5947b296e97191c4758864acfc976/comments", "author": null, "committer": null, "parents": [{"sha": "7fcc8dcf4ab3c136141f16251bb32124c63c2024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcc8dcf4ab3c136141f16251bb32124c63c2024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fcc8dcf4ab3c136141f16251bb32124c63c2024"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "77e9964be1997f2701e6bff8c798f9f77e1caca2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b54c30fb0d5947b296e97191c4758864acfc976/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b54c30fb0d5947b296e97191c4758864acfc976/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b54c30fb0d5947b296e97191c4758864acfc976", "patch": "@@ -1,3 +1,14 @@\n+2007-02-03  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lower-subreg.c (simple_move_operand): New static function,\n+\tbroken out of simple_move.  Reject LABEL_REF, SYMBOL_REF, and HIGH\n+\toperands.\n+\t(simple_move): Call simple_move_operand.\n+\t(find_decomposable_subregs): Add special handling of MEMs.\n+\t(can_decompose_p): Rename from cannot_decompose_p.  Reverse\n+\tmeaning of return value.  If we see a hard register, test whether\n+\tit can store a word_mode value.  Change all callers.\n+\n 2007-02-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.md (addvdi3, addvsi3, subvdi3, subvsi3, negvdi2, negvsi2): New"}, {"sha": "62bfea0a100760a156f5fafa76d1163a3f797ab0", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b54c30fb0d5947b296e97191c4758864acfc976/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b54c30fb0d5947b296e97191c4758864acfc976/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=2b54c30fb0d5947b296e97191c4758864acfc976", "patch": "@@ -66,6 +66,31 @@ static bitmap non_decomposable_context;\n    copy from reg M to reg N.  */\n static VEC(bitmap,heap) *reg_copy_graph;\n \n+/* Return whether X is a simple object which we can take a word_mode\n+   subreg of.  */\n+\n+static bool\n+simple_move_operand (rtx x)\n+{\n+  if (GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  if (!OBJECT_P (x))\n+    return false;\n+\n+  if (GET_CODE (x) == LABEL_REF\n+      || GET_CODE (x) == SYMBOL_REF\n+      || GET_CODE (x) == HIGH)\n+    return false;\n+\n+  if (MEM_P (x)\n+      && (MEM_VOLATILE_P (x)\n+\t  || mode_dependent_address_p (XEXP (x, 0))))\n+    return false;\n+\n+  return true;\n+}\n+\n /* If INSN is a single set between two objects, return the single set.\n    Such an insn can always be decomposed.  INSN should have been\n    passed to recog and extract_insn before this is called.  */\n@@ -87,25 +112,16 @@ simple_move (rtx insn)\n   x = SET_DEST (set);\n   if (x != recog_data.operand[0] && x != recog_data.operand[1])\n     return NULL_RTX;\n-  if (GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-  if (!OBJECT_P (x))\n-    return NULL_RTX;\n-  if (MEM_P (x)\n-      && (MEM_VOLATILE_P (x)\n-\t  || mode_dependent_address_p (XEXP (x, 0))))\n+  if (!simple_move_operand (x))\n     return NULL_RTX;\n \n   x = SET_SRC (set);\n   if (x != recog_data.operand[0] && x != recog_data.operand[1])\n     return NULL_RTX;\n-  if (GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-  if (!OBJECT_P (x) && GET_CODE (x) != ASM_OPERANDS)\n-    return NULL_RTX;\n-  if (MEM_P (x)\n-      && (MEM_VOLATILE_P (x)\n-\t  || mode_dependent_address_p (XEXP (x, 0))))\n+  /* For the src we can handle ASM_OPERANDS, and it is beneficial for\n+     things like x86 rdtsc which returns a DImode value.  */\n+  if (GET_CODE (x) != ASM_OPERANDS\n+      && !simple_move_operand (x))\n     return NULL_RTX;\n \n   /* We try to decompose in integer modes, to avoid generating\n@@ -259,7 +275,7 @@ find_decomposable_subregs (rtx *px, void *data)\n \t  return -1;\n \t}\n     }\n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     {\n       unsigned int regno;\n \n@@ -299,6 +315,16 @@ find_decomposable_subregs (rtx *px, void *data)\n \t    }\n \t}\n     }\n+  else if (MEM_P (x))\n+    {\n+      enum classify_move_insn cmi_mem = NOT_SIMPLE_MOVE;\n+\n+      /* Any registers used in a MEM do not participate in a\n+\t SIMPLE_MOVE or SIMPLE_PSEUDO_REG_MOVE.  Do our own recursion\n+\t here, and return -1 to block the parent's recursion.  */\n+      for_each_rtx (&XEXP (x, 0), find_decomposable_subregs, &cmi_mem);\n+      return -1;\n+    }\n \n   return 0;\n }\n@@ -585,22 +611,23 @@ resolve_reg_notes (rtx insn)\n     }\n }\n \n-/* Return whether X can not be decomposed into subwords.  */\n+/* Return whether X can be decomposed into subwords.  */\n \n static bool\n-cannot_decompose_p (rtx x)\n+can_decompose_p (rtx x)\n {\n   if (REG_P (x))\n     {\n       unsigned int regno = REGNO (x);\n \n       if (HARD_REGISTER_NUM_P (regno))\n-\treturn !validate_subreg (word_mode, GET_MODE (x), x, UNITS_PER_WORD);\n+\treturn (validate_subreg (word_mode, GET_MODE (x), x, UNITS_PER_WORD)\n+\t\t&& HARD_REGNO_MODE_OK (regno, word_mode));\n       else\n-\treturn bitmap_bit_p (non_decomposable_context, regno);\n+\treturn !bitmap_bit_p (non_decomposable_context, regno);\n     }\n \n-  return false;\n+  return true;\n }\n \n /* Decompose the registers used in a simple move SET within INSN.  If\n@@ -681,7 +708,7 @@ resolve_simple_move (rtx set, rtx insn)\n   /* If SRC is a register which we can't decompose, or has side\n      effects, we need to move via a temporary register.  */\n \n-  if (cannot_decompose_p (src)\n+  if (!can_decompose_p (src)\n       || side_effects_p (src)\n       || GET_CODE (src) == ASM_OPERANDS)\n     {\n@@ -701,7 +728,7 @@ resolve_simple_move (rtx set, rtx insn)\n \n   dest_mode = orig_mode;\n   pushing = push_operand (dest, dest_mode);\n-  if (cannot_decompose_p (dest)\n+  if (!can_decompose_p (dest)\n       || (side_effects_p (dest) && !pushing)\n       || (!SCALAR_INT_MODE_P (dest_mode)\n \t  && !resolve_reg_p (dest)"}]}