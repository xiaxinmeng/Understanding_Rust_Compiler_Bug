{"sha": "a25f3e8efbbc7182fa58c445574848a73856e9b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1ZjNlOGVmYmJjNzE4MmZhNThjNDQ1NTc0ODQ4YTczODU2ZTliNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-31T07:33:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-31T07:33:11Z"}, "message": "Make lra use per-alternative earlyclobber info\n\nlra_insn_reg and lra_operand_data have both a bitmask of earlyclobber\nalternatives and an overall boolean.  The danger is that we then test\nthe overall boolean when really we should be testing for a particular\nalternative.  This patch gets rid of the boolean and tests the mask\nagainst zero when we really do need to test \"any alternative might\nbe earlyclobber\".  (I think the only instance of that is the\nLRA_UNKNOWN_ALT handling in lra-lives.c:reg_early_clobber_p.)\n\nThis is needed (and tested) by an upcoming SVE patch.\n\n2019-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* lra-int.h (lra_operand_data): Remove early_clobber field.\n\t(lra_insn_reg): Likewise.\n\t* lra.c (debug_operand_data): Update accordingly.\n\t(setup_operand_alternative): Likewise.\n\t(new_insn_reg): Likewise.  Remove early_clobber parameter.\n\t(collect_non_operand_hard_regs): Update call accordingly.\n\tDon't assign to lra_insn_reg::early_clobber.\n\t(add_regs_to_insn_regno_info): Remove early_clobber parameter\n\tand update calls to new_insn_reg.\n\t(lra_update_insn_regno_info): Update calls accordingly.\n\t* lra-constraints.c (update_and_check_small_class_inputs): Take the\n\talternative number as a parameter and test whether the operand\n\tis earlyclobbered in that particular alternative.\n\t(process_alt_operands): Update call accordingly.  Use per-alternative\n\tchecks for earyclobber here too.\n\t* lra-lives.c (reg_early_clobber_p): Check early_clobber_alts\n\tagainst zero for IRA_UNKNOWN_ALT.\n\nFrom-SVN: r273921", "tree": {"sha": "42b669136d615c100af11e64f472bc253a61d708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b669136d615c100af11e64f472bc253a61d708"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25f3e8efbbc7182fa58c445574848a73856e9b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25f3e8efbbc7182fa58c445574848a73856e9b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25f3e8efbbc7182fa58c445574848a73856e9b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25f3e8efbbc7182fa58c445574848a73856e9b4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "68c86af248f736a7fa3c8059c7df41ed5d6dff37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c86af248f736a7fa3c8059c7df41ed5d6dff37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68c86af248f736a7fa3c8059c7df41ed5d6dff37"}], "stats": {"total": 115, "additions": 58, "deletions": 57}, "files": [{"sha": "c946bbad68e926c074aeed9d37fef14a65074a97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a25f3e8efbbc7182fa58c445574848a73856e9b4", "patch": "@@ -1,3 +1,23 @@\n+2019-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* lra-int.h (lra_operand_data): Remove early_clobber field.\n+\t(lra_insn_reg): Likewise.\n+\t* lra.c (debug_operand_data): Update accordingly.\n+\t(setup_operand_alternative): Likewise.\n+\t(new_insn_reg): Likewise.  Remove early_clobber parameter.\n+\t(collect_non_operand_hard_regs): Update call accordingly.\n+\tDon't assign to lra_insn_reg::early_clobber.\n+\t(add_regs_to_insn_regno_info): Remove early_clobber parameter\n+\tand update calls to new_insn_reg.\n+\t(lra_update_insn_regno_info): Update calls accordingly.\n+\t* lra-constraints.c (update_and_check_small_class_inputs): Take the\n+\talternative number as a parameter and test whether the operand\n+\tis earlyclobbered in that particular alternative.\n+\t(process_alt_operands): Update call accordingly.  Use per-alternative\n+\tchecks for earyclobber here too.\n+\t* lra-lives.c (reg_early_clobber_p): Check early_clobber_alts\n+\tagainst zero for IRA_UNKNOWN_ALT.\n+\n 2019-07-30  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_option_override): Quote a C type."}, {"sha": "f258407593745663febfbcd3b8e58c074a0a372b", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=a25f3e8efbbc7182fa58c445574848a73856e9b4", "patch": "@@ -1866,11 +1866,12 @@ prohibited_class_reg_set_mode_p (enum reg_class rclass,\n    alternative.  */\n static unsigned int curr_small_class_check = 0;\n \n-/* Update number of used inputs of class OP_CLASS for operand NOP.\n-   Return true if we have more such class operands than the number of\n-   available regs.  */\n+/* Update number of used inputs of class OP_CLASS for operand NOP\n+   of alternative NALT.  Return true if we have more such class operands\n+   than the number of available regs.  */\n static bool\n-update_and_check_small_class_inputs (int nop, enum reg_class op_class)\n+update_and_check_small_class_inputs (int nop, int nalt,\n+\t\t\t\t     enum reg_class op_class)\n {\n   static unsigned int small_class_check[LIM_REG_CLASSES];\n   static int small_class_input_nums[LIM_REG_CLASSES];\n@@ -1881,7 +1882,7 @@ update_and_check_small_class_inputs (int nop, enum reg_class op_class)\n       && hard_reg_set_intersect_p (reg_class_contents[op_class],\n \t\t\t\t   ira_no_alloc_regs)\n       && (curr_static_id->operand[nop].type != OP_OUT\n-\t  || curr_static_id->operand[nop].early_clobber))\n+\t  || TEST_BIT (curr_static_id->operand[nop].early_clobber_alts, nalt)))\n     {\n       if (small_class_check[op_class] == curr_small_class_check)\n \tsmall_class_input_nums[op_class]++;\n@@ -2150,7 +2151,8 @@ process_alt_operands (int only_alternative)\n \t\t\t/* We should reject matching of an early\n \t\t\t   clobber operand if the matching operand is\n \t\t\t   not dying in the insn.  */\n-\t\t\tif (! curr_static_id->operand[m].early_clobber\n+\t\t\tif (!TEST_BIT (curr_static_id->operand[m]\n+\t\t\t\t       .early_clobber_alts, nalt)\n \t\t\t    || operand_reg[nop] == NULL_RTX\n \t\t\t    || (find_regno_note (curr_insn, REG_DEAD,\n \t\t\t\t\t\t REGNO (op))\n@@ -2234,7 +2236,8 @@ process_alt_operands (int only_alternative)\n \t\t\t   it results in less hard regs required for\n \t\t\t   the insn than a non-matching earlyclobber\n \t\t\t   alternative.  */\n-\t\t\tif (curr_static_id->operand[m].early_clobber)\n+\t\t\tif (TEST_BIT (curr_static_id->operand[m]\n+\t\t\t\t      .early_clobber_alts, nalt))\n \t\t\t  {\n \t\t\t    if (lra_dump_file != NULL)\n \t\t\t      fprintf\n@@ -2875,7 +2878,8 @@ process_alt_operands (int only_alternative)\n               goto fail;\n             }\n \n-\t  if (update_and_check_small_class_inputs (nop, this_alternative))\n+\t  if (update_and_check_small_class_inputs (nop, nalt,\n+\t\t\t\t\t\t   this_alternative))\n \t    {\n \t      if (lra_dump_file != NULL)\n \t\tfprintf (lra_dump_file,"}, {"sha": "a87a51e47a94922e5778eb16e33490a0ed132e1b", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=a25f3e8efbbc7182fa58c445574848a73856e9b4", "patch": "@@ -142,10 +142,6 @@ struct lra_operand_data\n   unsigned int strict_low : 1;\n   /* True if the operand is an operator.  */\n   unsigned int is_operator : 1;\n-  /* True if there is an early clobber alternative for this operand.\n-     This field is set up every time when corresponding\n-     operand_alternative in lra_static_insn_data is set up.  */\n-  unsigned int early_clobber : 1;\n   /* True if the operand is an address.  */\n   unsigned int is_address : 1;\n };\n@@ -164,9 +160,6 @@ struct lra_insn_reg\n   /* True if the reg is accessed through a subreg and the subreg is\n      just a part of the register.  */\n   unsigned int subreg_p : 1;\n-  /* True if there is an early clobber alternative for this\n-     operand.  */\n-  unsigned int early_clobber : 1;\n   /* True if the reg is clobber highed by the operand.  */\n   unsigned int clobber_high : 1;\n   /* The corresponding regno of the register.  */"}, {"sha": "057ef8cab4d83a83c0fcec61406b48d671b2d67e", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=a25f3e8efbbc7182fa58c445574848a73856e9b4", "patch": "@@ -624,10 +624,10 @@ check_pseudos_live_through_calls (int regno,\n static inline bool\n reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)\n {\n-  return (reg->early_clobber\n-\t  && (n_alt == LRA_UNKNOWN_ALT\n-\t      || (n_alt != LRA_NON_CLOBBERED_ALT\n-\t\t  && TEST_BIT (reg->early_clobber_alts, n_alt))));\n+  return (n_alt == LRA_UNKNOWN_ALT\n+\t  ? reg->early_clobber_alts != 0\n+\t  : (n_alt != LRA_NON_CLOBBERED_ALT\n+\t     && TEST_BIT (reg->early_clobber_alts, n_alt)));\n }\n \n /* Return true if call instructions CALL1 and CALL2 use ABIs that"}, {"sha": "d7593998f9709ee8bfaf688af739f72788292c7b", "filename": "gcc/lra.c", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f3e8efbbc7182fa58c445574848a73856e9b4/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=a25f3e8efbbc7182fa58c445574848a73856e9b4", "patch": "@@ -536,16 +536,14 @@ object_allocator<lra_insn_reg> lra_insn_reg_pool (\"insn regs\");\n \n /* Create LRA insn related info about a reference to REGNO in INSN\n    with TYPE (in/out/inout), biggest reference mode MODE, flag that it\n-   is reference through subreg (SUBREG_P), flag that is early\n-   clobbered in the insn (EARLY_CLOBBER), and reference to the next\n+   is reference through subreg (SUBREG_P), and reference to the next\n    insn reg info (NEXT).  If REGNO can be early clobbered,\n    alternatives in which it can be early clobbered are given by\n    EARLY_CLOBBER_ALTS.  CLOBBER_HIGH marks if reference is a clobber\n    high.  */\n static struct lra_insn_reg *\n new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n-\t      machine_mode mode,\n-\t      bool subreg_p, bool early_clobber,\n+\t      machine_mode mode, bool subreg_p,\n \t      alternative_mask early_clobber_alts,\n \t      struct lra_insn_reg *next, bool clobber_high)\n {\n@@ -556,7 +554,6 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n       && partial_subreg_p (lra_reg_info[regno].biggest_mode, mode))\n     lra_reg_info[regno].biggest_mode = mode;\n   ir->subreg_p = subreg_p;\n-  ir->early_clobber = early_clobber;\n   ir->early_clobber_alts = early_clobber_alts;\n   ir->clobber_high = clobber_high;\n   ir->regno = regno;\n@@ -605,7 +602,7 @@ static struct lra_operand_data debug_operand_data =\n     0, /* early_clobber_alts */\n     E_VOIDmode, /* We are not interesting in the operand mode.  */\n     OP_IN,\n-    0, 0, 0, 0\n+    0, 0, 0\n   };\n \n /* The following data are used as static insn data for all debug\n@@ -801,7 +798,6 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n   for (i = 0; i < nop; i++)\n     {\n       static_data->operand[i].early_clobber_alts = 0;\n-      static_data->operand[i].early_clobber = false;\n       static_data->operand[i].is_address = false;\n       if (static_data->operand[i].constraint[0] == '%')\n \t{\n@@ -817,7 +813,6 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n   for (j = 0; j < nalt; j++)\n     for (i = 0; i < nop; i++, op_alt++)\n       {\n-\tstatic_data->operand[i].early_clobber |= op_alt->earlyclobber;\n \tif (op_alt->earlyclobber)\n \t  static_data->operand[i].early_clobber_alts |= (alternative_mask) 1 << j;\n \tstatic_data->operand[i].is_address |= op_alt->is_address;\n@@ -878,10 +873,7 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n \t\tif (curr->type != type)\n \t\t  curr->type = OP_INOUT;\n \t\tif (early_clobber)\n-\t\t  {\n-\t\t    curr->early_clobber = true;\n-\t\t    curr->early_clobber_alts = ALL_ALTERNATIVES;\n-\t\t  }\n+\t\t  curr->early_clobber_alts = ALL_ALTERNATIVES;\n \t\tbreak;\n \t      }\n \t  if (curr == NULL)\n@@ -897,7 +889,6 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n \t\t\t && regno <= LAST_STACK_REG));\n #endif\n \t      list = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t   early_clobber,\n \t\t\t\t   early_clobber ? ALL_ALTERNATIVES : 0, list,\n \t\t\t\t   clobber_high);\n \t    }\n@@ -1449,15 +1440,13 @@ lra_get_copy (int n)\n /* This page contains code dealing with info about registers in\n    insns.  */\n \n-/* Process X of INSN recursively and add info (operand type is\n-   given by TYPE, flag of that it is early clobber is EARLY_CLOBBER)\n-   about registers in X to the insn DATA.  If X can be early clobbered,\n-   alternatives in which it can be early clobbered are given by\n-   EARLY_CLOBBER_ALTS.  */\n+/* Process X of INSN recursively and add info (operand type is given\n+   by TYPE) about registers in X to the insn DATA.  If X can be early\n+   clobbered, alternatives in which it can be early clobbered are given\n+   by EARLY_CLOBBER_ALTS.  */\n static void\n add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n-\t\t\t     rtx_insn *insn,\n-\t\t\t     enum op_type type, bool early_clobber,\n+\t\t\t     rtx_insn *insn, enum op_type type,\n \t\t\t     alternative_mask early_clobber_alts)\n {\n   int i, j, regno;\n@@ -1487,8 +1476,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n       if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, INSN_UID (insn)))\n \t{\n \t  data->regs = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t     early_clobber, early_clobber_alts,\n-\t\t\t\t     data->regs, false);\n+\t\t\t\t     early_clobber_alts, data->regs, false);\n \t  return;\n \t}\n       else\n@@ -1500,15 +1488,12 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n \t\t  /* The info cannot be integrated into the found\n \t\t     structure.  */\n \t\t  data->regs = new_insn_reg (data->insn, regno, type, mode,\n-\t\t\t\t\t     subreg_p, early_clobber,\n-\t\t\t\t\t     early_clobber_alts, data->regs,\n-\t\t\t\t\t     false);\n+\t\t\t\t\t     subreg_p, early_clobber_alts,\n+\t\t\t\t\t     data->regs, false);\n \t\telse\n \t\t  {\n \t\t    if (curr->type != type)\n \t\t      curr->type = OP_INOUT;\n-\t\t    if (curr->early_clobber != early_clobber)\n-\t\t      curr->early_clobber = true;\n \t\t    curr->early_clobber_alts |= early_clobber_alts;\n \t\t  }\n \t\treturn;\n@@ -1520,23 +1505,23 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n   switch (code)\n     {\n     case SET:\n-      add_regs_to_insn_regno_info (data, SET_DEST (x), insn, OP_OUT, false, 0);\n-      add_regs_to_insn_regno_info (data, SET_SRC (x), insn, OP_IN, false, 0);\n+      add_regs_to_insn_regno_info (data, SET_DEST (x), insn, OP_OUT, 0);\n+      add_regs_to_insn_regno_info (data, SET_SRC (x), insn, OP_IN, 0);\n       break;\n     case CLOBBER:\n       /* We treat clobber of non-operand hard registers as early\n \t clobber.  */\n       add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_OUT,\n-\t\t\t\t   true, ALL_ALTERNATIVES);\n+\t\t\t\t   ALL_ALTERNATIVES);\n       break;\n     case CLOBBER_HIGH:\n       gcc_unreachable ();\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, false, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, 0);\n       break;\n     case PRE_MODIFY: case POST_MODIFY:\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, false, 0);\n-      add_regs_to_insn_regno_info (data, XEXP (x, 1), insn, OP_IN, false, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 1), insn, OP_IN, 0);\n       break;\n     default:\n       if ((code != PARALLEL && code != EXPR_LIST) || type != OP_OUT)\n@@ -1557,12 +1542,12 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n-\t    add_regs_to_insn_regno_info (data, XEXP (x, i), insn, type, false, 0);\n+\t    add_regs_to_insn_regno_info (data, XEXP (x, i), insn, type, 0);\n \t  else if (fmt[i] == 'E')\n \t    {\n \t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t\tadd_regs_to_insn_regno_info (data, XVECEXP (x, i, j), insn,\n-\t\t\t\t\t     type, false, 0);\n+\t\t\t\t\t     type, 0);\n \t    }\n \t}\n     }\n@@ -1652,11 +1637,10 @@ lra_update_insn_regno_info (rtx_insn *insn)\n   for (i = static_data->n_operands - 1; i >= 0; i--)\n     add_regs_to_insn_regno_info (data, *data->operand_loc[i], insn,\n \t\t\t\t static_data->operand[i].type,\n-\t\t\t\t static_data->operand[i].early_clobber,\n \t\t\t\t static_data->operand[i].early_clobber_alts);\n   if ((code = GET_CODE (PATTERN (insn))) == CLOBBER || code == USE)\n     add_regs_to_insn_regno_info (data, XEXP (PATTERN (insn), 0), insn,\n-\t\t\t\t code == USE ? OP_IN : OP_OUT, false, 0);\n+\t\t\t\t code == USE ? OP_IN : OP_OUT, 0);\n   if (CALL_P (insn))\n     /* On some targets call insns can refer to pseudos in memory in\n        CALL_INSN_FUNCTION_USAGE list.  Process them in order to\n@@ -1673,7 +1657,7 @@ lra_update_insn_regno_info (rtx_insn *insn)\n \tif ((code == USE || code == CLOBBER)\n \t    && MEM_P (XEXP (XEXP (link, 0), 0)))\n \t  add_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), insn,\n-\t\t\t\t       code == USE ? OP_IN : OP_OUT, false, 0);\n+\t\t\t\t       code == USE ? OP_IN : OP_OUT, 0);\n       }\n   if (NONDEBUG_INSN_P (insn))\n     setup_insn_reg_info (data, freq);"}]}