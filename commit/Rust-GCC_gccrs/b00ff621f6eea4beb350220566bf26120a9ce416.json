{"sha": "b00ff621f6eea4beb350220566bf26120a9ce416", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAwZmY2MjFmNmVlYTRiZWIzNTAyMjA1NjZiZjI2MTIwYTljZTQxNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-16T16:41:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-16T16:41:22Z"}, "message": "predict.c (combine_predictions_for_bb): Preserve zero predicted eges.\n\n\n\t* predict.c (combine_predictions_for_bb): Preserve zero predicted\t\n\teges.\n\t(expensive_function_p): Remove useless assert.\n\t(determine_unlikely_bbs): Propagate also forward; determine cold blocks\n\nFrom-SVN: r254832", "tree": {"sha": "34b29b690d7572417e7d122768c9dff10a2402b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34b29b690d7572417e7d122768c9dff10a2402b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b00ff621f6eea4beb350220566bf26120a9ce416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00ff621f6eea4beb350220566bf26120a9ce416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00ff621f6eea4beb350220566bf26120a9ce416", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00ff621f6eea4beb350220566bf26120a9ce416/comments", "author": null, "committer": null, "parents": [{"sha": "aef0c806ebe4fc7b55af9a164769ac81d63506ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef0c806ebe4fc7b55af9a164769ac81d63506ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef0c806ebe4fc7b55af9a164769ac81d63506ed"}], "stats": {"total": 78, "additions": 60, "deletions": 18}, "files": [{"sha": "5ad2d99455bd09582312665782632f9921f248fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00ff621f6eea4beb350220566bf26120a9ce416/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00ff621f6eea4beb350220566bf26120a9ce416/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b00ff621f6eea4beb350220566bf26120a9ce416", "patch": "@@ -1,3 +1,10 @@\n+2017-11-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (combine_predictions_for_bb): Preserve zero predicted\t\n+\teges.\n+\t(expensive_function_p): Remove useless assert.\n+\t(determine_unlikely_bbs): Propagate also forward; determine cold blocks\n+\n 2017-11-16  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/82588"}, {"sha": "7404f1af1fa17859d66dbe473c6c556ca841f252", "filename": "gcc/predict.c", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00ff621f6eea4beb350220566bf26120a9ce416/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00ff621f6eea4beb350220566bf26120a9ce416/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b00ff621f6eea4beb350220566bf26120a9ce416", "patch": "@@ -1118,18 +1118,26 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n   int nedges = 0;\n   edge e, first = NULL, second = NULL;\n   edge_iterator ei;\n+  int nzero = 0;\n+  int nunknown = 0;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!unlikely_executed_edge_p (e))\n-      {\n-\tnedges ++;\n-\tif (first && !second)\n-\t  second = e;\n-\tif (!first)\n-\t  first = e;\n-      }\n-    else if (!e->probability.initialized_p ())\n-      e->probability = profile_probability::never ();\n+    {\n+      if (!unlikely_executed_edge_p (e))\n+        {\n+\t  nedges ++;\n+\t  if (first && !second)\n+\t    second = e;\n+\t  if (!first)\n+\t    first = e;\n+        }\n+      else if (!e->probability.initialized_p ())\n+        e->probability = profile_probability::never ();\n+     if (!e->probability.initialized_p ())\n+        nunknown++;\n+     else if (e->probability == profile_probability::never ())\n+\tnzero++;\n+    }\n \n   /* When there is no successor or only one choice, prediction is easy.\n \n@@ -1283,8 +1291,27 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n     }\n   clear_bb_predictions (bb);\n \n-  if ((!bb->count.nonzero_p () || !first->probability.initialized_p ())\n-      && !dry_run)\n+\n+  /* If we have only one successor which is unknown, we can compute missing\n+     probablity.  */\n+  if (nunknown == 1)\n+    {\n+      profile_probability prob = profile_probability::always ();\n+      edge missing = NULL;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->probability.initialized_p ())\n+\t  prob -= e->probability;\n+\telse if (missing == NULL)\n+\t  missing = e;\n+\telse\n+\t  gcc_unreachable ();\n+       missing->probability = prob;\n+    }\n+  /* If nothing is unknown, we have nothing to update.  */\n+  else if (!nunknown && nzero != (int)EDGE_COUNT (bb->succs))\n+    ;\n+  else if (!dry_run)\n     {\n       first->probability\n \t = profile_probability::from_reg_br_prob_base (combined_probability);\n@@ -3334,16 +3361,11 @@ expensive_function_p (int threshold)\n {\n   basic_block bb;\n \n-  /* We can not compute accurately for large thresholds due to scaled\n-     frequencies.  */\n-  gcc_assert (threshold <= BB_FREQ_MAX);\n-\n   /* If profile was scaled in a way entry block has count 0, then the function\n      is deifnitly taking a lot of time.  */\n   if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.nonzero_p ())\n     return true;\n \n-  /* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */\n   profile_count limit = ENTRY_BLOCK_PTR_FOR_FN\n \t\t\t   (cfun)->count.apply_scale (threshold, 1);\n   profile_count sum = profile_count::zero ();\n@@ -3453,6 +3475,7 @@ determine_unlikely_bbs ()\n \n       gcc_checking_assert (!bb->aux);\n     }\n+  propagate_unlikely_bbs_forward ();\n \n   auto_vec<int, 64> nsuccs;\n   nsuccs.safe_grow_cleared (last_basic_block_for_fn (cfun));\n@@ -3498,7 +3521,6 @@ determine_unlikely_bbs ()\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (!(e->probability == profile_probability::never ()))\n \t  {\n-\t    e->probability = profile_probability::never ();\n \t    if (!(e->src->count == profile_count::zero ()))\n \t      {\n \t        nsuccs[e->src->index]--;\n@@ -3507,6 +3529,19 @@ determine_unlikely_bbs ()\n \t      }\n \t  }\n     }\n+  /* Finally all edges from non-0 regions to 0 are unlikely.  */\n+  FOR_ALL_BB_FN (bb, cfun)\n+    if (!(bb->count == profile_count::zero ()))\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (!(e->probability == profile_probability::never ())\n+\t    && e->dest->count == profile_count::zero ())\n+\t   {\n+\t     if (dump_file && (dump_flags & TDF_DETAILS))\n+\t       fprintf (dump_file, \"Edge %i->%i is unlikely because \"\n+\t\t \t\"it enters unlikely block\\n\",\n+\t\t\tbb->index, e->dest->index);\n+\t     e->probability = profile_probability::never ();\n+\t   }\n }\n \n /* Estimate and propagate basic block frequencies using the given branch"}]}