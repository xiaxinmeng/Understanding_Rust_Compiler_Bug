{"sha": "b4ff394c548414d6594170573c1cea89b91968e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmZjM5NGM1NDg0MTRkNjU5NDE3MDU3M2MxY2VhODliOTE5NjhlMQ==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2016-11-07T15:37:51Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2016-11-07T15:37:51Z"}, "message": "target.def (compute_pressure_classes): New target hook.\n\n\t* target.def (compute_pressure_classes): New target hook.\n\t* doc/tm.texi.in: Document it.\n\t* doc/tm.texi: Regenerate.\n\t* ira.c (setup_pressure_classes): Call target hook if defined.\n\nFrom-SVN: r241911", "tree": {"sha": "d5b5f42b4d7a57750e4eea4ccfb2aaddb9c89e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5b5f42b4d7a57750e4eea4ccfb2aaddb9c89e95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4ff394c548414d6594170573c1cea89b91968e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ff394c548414d6594170573c1cea89b91968e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ff394c548414d6594170573c1cea89b91968e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ff394c548414d6594170573c1cea89b91968e1/comments", "author": null, "committer": null, "parents": [{"sha": "c939044ae59e3dad0b3967e64173cd3fb717129b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c939044ae59e3dad0b3967e64173cd3fb717129b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c939044ae59e3dad0b3967e64173cd3fb717129b"}], "stats": {"total": 158, "additions": 94, "deletions": 64}, "files": [{"sha": "c237044b0dde4273a13765a411f316dae49e6870", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4ff394c548414d6594170573c1cea89b91968e1", "patch": "@@ -1,3 +1,10 @@\n+2016-11-07  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* target.def (compute_pressure_classes): New target hook.\n+\t* doc/tm.texi.in: Document it.\n+\t* doc/tm.texi: Regenerate.\n+\t* ira.c (setup_pressure_classes): Call target hook if defined.\n+\n 2016-11-07  David Malcolm  <dmalcolm@redhat.com>\n \n \t* print-rtl.c (rtx_writer::operand_has_default_value_p): New"}, {"sha": "81c63b71bffa9b23de4cc9c3c22bb074521c6090", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b4ff394c548414d6594170573c1cea89b91968e1", "patch": "@@ -2903,6 +2903,10 @@ This hook defines a class of registers which could be used for spilling  pseudos\n This hook defines the machine mode to use for the boolean result of  conditional store patterns.  The ICODE argument is the instruction code  for the cstore being performed.  Not definiting this hook is the same  as accepting the mode encoded into operand 0 of the cstore expander  patterns.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_COMPUTE_PRESSURE_CLASSES (enum reg_class *@var{pressure_classes})\n+A target hook which lets a backend compute the set of pressure classes to  be used by those optimization passes which take register pressure into  account, as opposed to letting IRA compute them.  It returns the number of  register classes stored in the array @var{pressure_classes}.\n+@end deftypefn\n+\n @node Stack and Calling\n @section Stack Layout and Calling Conventions\n @cindex calling conventions"}, {"sha": "74e9200f749b799e7c6b9858169fbe65bdf11b47", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=b4ff394c548414d6594170573c1cea89b91968e1", "patch": "@@ -2509,6 +2509,8 @@ value that the middle-end intended.\n \n @hook TARGET_CSTORE_MODE\n \n+@hook TARGET_COMPUTE_PRESSURE_CLASSES\n+\n @node Stack and Calling\n @section Stack Layout and Calling Conventions\n @cindex calling conventions"}, {"sha": "f453ea9e60445bfead0d75738010a8d80a0f1452", "filename": "gcc/ira.c", "status": "modified", "additions": 71, "deletions": 64, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b4ff394c548414d6594170573c1cea89b91968e1", "patch": "@@ -792,78 +792,85 @@ setup_pressure_classes (void)\n   HARD_REG_SET temp_hard_regset2;\n   bool insert_p;\n \n-  n = 0;\n-  for (cl = 0; cl < N_REG_CLASSES; cl++)\n-    {\n-      if (ira_class_hard_regs_num[cl] == 0)\n-\tcontinue;\n-      if (ira_class_hard_regs_num[cl] != 1\n-\t  /* A register class without subclasses may contain a few\n-\t     hard registers and movement between them is costly\n-\t     (e.g. SPARC FPCC registers).  We still should consider it\n-\t     as a candidate for a pressure class.  */\n-\t  && alloc_reg_class_subclasses[cl][0] < cl)\n+  if (targetm.compute_pressure_classes)\n+    n = targetm.compute_pressure_classes (pressure_classes);\n+  else\n+    { \n+      n = 0;\n+      for (cl = 0; cl < N_REG_CLASSES; cl++)\n \t{\n-\t  /* Check that the moves between any hard registers of the\n-\t     current class are not more expensive for a legal mode\n-\t     than load/store of the hard registers of the current\n-\t     class.  Such class is a potential candidate to be a\n-\t     register pressure class.  */\n-\t  for (m = 0; m < NUM_MACHINE_MODES; m++)\n+\t  if (ira_class_hard_regs_num[cl] == 0)\n+\t    continue;\n+\t  if (ira_class_hard_regs_num[cl] != 1\n+\t      /* A register class without subclasses may contain a few\n+\t\t hard registers and movement between them is costly\n+\t\t (e.g. SPARC FPCC registers).  We still should consider it\n+\t\t as a candidate for a pressure class.  */\n+\t      && alloc_reg_class_subclasses[cl][0] < cl)\n \t    {\n-\t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-\t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t      AND_COMPL_HARD_REG_SET (temp_hard_regset,\n-\t\t\t\t      ira_prohibited_class_mode_regs[cl][m]);\n-\t      if (hard_reg_set_empty_p (temp_hard_regset))\n+\t      /* Check that the moves between any hard registers of the\n+\t\t current class are not more expensive for a legal mode\n+\t\t than load/store of the hard registers of the current\n+\t\t class.  Such class is a potential candidate to be a\n+\t\t register pressure class.  */\n+\t      for (m = 0; m < NUM_MACHINE_MODES; m++)\n+\t\t{\n+\t\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t\t  AND_COMPL_HARD_REG_SET (temp_hard_regset,\n+\t\t\t\t\t  ira_prohibited_class_mode_regs[cl][m]);\n+\t\t  if (hard_reg_set_empty_p (temp_hard_regset))\n+\t\t    continue;\n+\t\t  ira_init_register_move_cost_if_necessary ((machine_mode) m);\n+\t\t  cost = ira_register_move_cost[m][cl][cl];\n+\t\t  if (cost <= ira_max_memory_move_cost[m][cl][1]\n+\t\t      || cost <= ira_max_memory_move_cost[m][cl][0])\n+\t\t    break;\n+\t\t}\n+\t      if (m >= NUM_MACHINE_MODES)\n \t\tcontinue;\n-\t      ira_init_register_move_cost_if_necessary ((machine_mode) m);\n-\t      cost = ira_register_move_cost[m][cl][cl];\n-\t      if (cost <= ira_max_memory_move_cost[m][cl][1]\n-\t\t  || cost <= ira_max_memory_move_cost[m][cl][0])\n-\t\tbreak;\n \t    }\n-\t  if (m >= NUM_MACHINE_MODES)\n-\t    continue;\n-\t}\n-      curr = 0;\n-      insert_p = true;\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      /* Remove so far added pressure classes which are subset of the\n-\t current candidate class.  Prefer GENERAL_REGS as a pressure\n-\t register class to another class containing the same\n-\t allocatable hard registers.  We do this because machine\n-\t dependent cost hooks might give wrong costs for the latter\n-\t class but always give the right cost for the former class\n-\t (GENERAL_REGS).  */\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  cl2 = pressure_classes[i];\n-\t  COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\t  if (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n-\t      && (! hard_reg_set_equal_p (temp_hard_regset, temp_hard_regset2)\n-\t\t  || cl2 == (int) GENERAL_REGS))\n+\t  curr = 0;\n+\t  insert_p = true;\n+\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t  /* Remove so far added pressure classes which are subset of the\n+\t     current candidate class.  Prefer GENERAL_REGS as a pressure\n+\t     register class to another class containing the same\n+\t     allocatable hard registers.  We do this because machine\n+\t     dependent cost hooks might give wrong costs for the latter\n+\t     class but always give the right cost for the former class\n+\t     (GENERAL_REGS).  */\n+\t  for (i = 0; i < n; i++)\n \t    {\n+\t      cl2 = pressure_classes[i];\n+\t      COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t      if (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n+\t\t  && (! hard_reg_set_equal_p (temp_hard_regset,\n+\t\t\t\t\t      temp_hard_regset2)\n+\t\t      || cl2 == (int) GENERAL_REGS))\n+\t\t{\n+\t\t  pressure_classes[curr++] = (enum reg_class) cl2;\n+\t\t  insert_p = false;\n+\t\t  continue;\n+\t\t}\n+\t      if (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset)\n+\t\t  && (! hard_reg_set_equal_p (temp_hard_regset2,\n+\t\t\t\t\t      temp_hard_regset)\n+\t\t      || cl == (int) GENERAL_REGS))\n+\t\tcontinue;\n+\t      if (hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset))\n+\t\tinsert_p = false;\n \t      pressure_classes[curr++] = (enum reg_class) cl2;\n-\t      insert_p = false;\n-\t      continue;\n \t    }\n-\t  if (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset)\n-\t      && (! hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset)\n-\t\t  || cl == (int) GENERAL_REGS))\n-\t    continue;\n-\t  if (hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset))\n-\t    insert_p = false;\n-\t  pressure_classes[curr++] = (enum reg_class) cl2;\n+\t  /* If the current candidate is a subset of a so far added\n+\t     pressure class, don't add it to the list of the pressure\n+\t     classes.  */\n+\t  if (insert_p)\n+\t    pressure_classes[curr++] = (enum reg_class) cl;\n+\t  n = curr;\n \t}\n-      /* If the current candidate is a subset of a so far added\n-\t pressure class, don't add it to the list of the pressure\n-\t classes.  */\n-      if (insert_p)\n-\tpressure_classes[curr++] = (enum reg_class) cl;\n-      n = curr;\n     }\n #ifdef ENABLE_IRA_CHECKING\n   {"}, {"sha": "bcdbc0e245258a3c23a952bdffae7009b39f671a", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ff394c548414d6594170573c1cea89b91968e1/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=b4ff394c548414d6594170573c1cea89b91968e1", "patch": "@@ -5039,6 +5039,16 @@ DEFHOOK\n   machine_mode, (enum insn_code icode),\n   default_cstore_mode)\n \n+/* This target hook allows the backend to compute the register pressure\n+   classes to use.  */\n+DEFHOOK\n+(compute_pressure_classes,\n+ \"A target hook which lets a backend compute the set of pressure classes to\\\n+  be used by those optimization passes which take register pressure into\\\n+  account, as opposed to letting IRA compute them.  It returns the number of\\\n+  register classes stored in the array @var{pressure_classes}.\",\n+ int, (enum reg_class *pressure_classes), NULL)\n+\n /* True if a structure, union or array with MODE containing FIELD should\n    be accessed using BLKmode.  */\n DEFHOOK"}]}