{"sha": "a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMyYjk3YTIwZDY2MzhmM2NlZTI4OTE5ZjRlNmJkN2IxZDliMzllOA==", "commit": {"author": {"name": "Brian Booth", "email": "bbooth@redhat.com", "date": "2004-06-10T21:41:08Z"}, "committer": {"name": "Brian Booth", "email": "bbooth@gcc.gnu.org", "date": "2004-06-10T21:41:08Z"}, "message": "tree-ssa.texi: Remove references to VDEF and add descriptions of V_MAY_DEF and V_MUST_DEF.\n\n\t* doc/tree-ssa.texi: Remove references to VDEF and add descriptions\n\tof V_MAY_DEF and V_MUST_DEF.\n\t* tree-dfa.c (dfa_stats_d): Add num_v_must_defs and rename\n\tnum_vdefs to num_v_may_defs.\n\t(compute_immediate_uses_for_stmt): Rename occurences of vdef\n\tto v_may_def.\n\t(redirect_immediate_uses): Ditto.\n\t(dump_dfa_stats): Ditto. Also added code to dump num_v_must_defs.\n\t(collect_dfa_stats_r): Rename occurences of vdef to v_may_def.\n\tAlso add code to sum up the number of v_must_defs.\n\t(vdefs_disappeared_p): Replace with...\n\t(v_may_defs_disappeared_p): This.\n\t(v_must_defs_disappeared_p): New function.\n\t(mark_new_vars_to_rename): Rename occurences of vdef to v_may_def.\n\tAlso add code to mark new variables found in V_MUST_DEFs for\n\trenameing.\n\t* tree-flow.h (stmt_ann_d): Add v_must_def_ops and replace\n\tvdef_ops to v_may_def_ops.\n\t(get_vdef_ops): Replace with...\n\t(get_v_may_def_ops): This.\n\t* tree-flow-inline.h (get_vdef_ops): Replace with...\n\t(get_v_may_def_ops): This.\n\t(get_v_must_def_ops): New function.\n\t(get_vdef_result_ptr): Replace with...\n\t(get_v_may_def_result_ptr): This.\n\t(get_vdef_op_ptr): Ditto with...\n\t(get_v_may_def_op_ptr); This.\n\t(get_v_must_def_op_ptr): New function.\n\t* tree-into-ssa.c (mark_def_sites): Rename occurences of vdef\n\tto v_may_def. Also add code to mark statements with\n\tV_MUST_DEFs as definition sites.\n\t(rewrite_stmt): Rename occurences of vdef to v_may_def. Also\n\tadd code to register new V_MUST_DEFs made by the statement.\n\t* tree-outof-ssa.c (VIRTUAL_PARTITION): Update comments.\n\t(check_replaceable): Rename occurences of vdef to v_may_def. Also\n\tadd check for V_MUST_DEFs.\n\t(find_replaceable_in_bb): Ditto.\n\t* tree-pretty-print.c (dump_vops): Rename occurences of vdef\n\tto v_may_def. Also add code to dump V_MUST_DEFs.\n\t* tree-sra.c (mark_all_vdefs): Replace with...\n\t(mark_all_v_may_defs): This.\n\t(mark_all_v_must_defs): New function.\n\t(create_scalar_copies): Replace call to mark_all_vdefs with\n\tcalls to mark_all_v_may_defs and mark_all_v_must_defs.\n\t(scalarize_structures): Rename occurences of vdef to v_may_def.\n\tAlso add a check for V_MUST_DEFs.\n\t(scalarize_modify_expr): Rename occurences of vdef to v_may_def.\n\t* tree-ssa-alias.c (global_var): Update comment.\n\t(compute_may_aliases): Ditto.\n\t(compute_points_to_and_addr_escape): Rename occurences of vdef\n\tto v_may_def. Also add code to mark variables in V_MUST_DEF\n\toperands as being written to.\n\t(group_aliases): Update comment.\n\t(maybe_create_global_var): Ditto.\n\t* tree-ssa.c (verify_ssa): Rename occurences of vdef to v_may_def.\n\tAlso add a check for V_MUST_DEFs on GIMPLE registers.\n\t(replace_immediate_uses): Rename occurences of vdef to v_may_def.\n\t* tree-ssa-ccp.c (visit_stmt): Rename occurences of vdef\n\tto v_may_def. Also add code to mark all V_MUST_DEF operands\n\tVARYING.\n\t(initialize): Ditto.\n\t(set_rhs): Rename occurences of vdef to v_may_def. Also add\n\tcode to update SSA_NAMEs in V_MUST_DEFs.\n\t* tree-ssa-copy.c (cprop_into_stmt): Rename occurences of vdef\n\tto v_may_def.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Rename\n\toccurences of vdef to v_may_def. Also add code to mark statements\n\twith V_MUST_DEFs as necessary.\n\t(propagate_necessity): Rename occurences of vdef to v_may_def.\n\t* tree-ssa-dom.c (redirect_edges_and_update_ssa_graph): Rename\n\toccurences of vdef to v_may_def. Also add code to mark operands\n\tin V_MUST_DEFs for renaming.\n\t(eliminate_redundant_computations): Rename occurences of vdef\n\tto v_may_def.\n\t(record_equivalences_from_stmt): Rename occurences of vdef\n\tto v_may_def. Also add code to record VUSEs for V_MUST_DEFs.\n\t(optimize_stmt): Remove unnesessary variable vdefs. Update\n\tcomment.\n\t(register_definitions_for_stmt): Rename occurences of vdef\n\tto v_may_def. Also add code to register definitions made with\n\tV_MUST_DEFs.\n\t* tree-ssa-dse.c (fix_stmt_vdefs): Replace with...\n\t(fix_stmt_v_may_defs): This.\n\t(fix_phi_uses): Rename occurences of vdef to v_may_def.\n\t(dse_optimize_stmt): Ditto.\n\t* tree-ssa-live.c (create_ssa_var_map): Rename occurences of vdef\n\tto v_may_def. Also add code to mark V_MUST_DEF operands as being\n\tused in virtual operators.\n\t* tree-ssa-loop.c (mark_defs_for_rewrite): Rename occurences of\n\tvdef to v_may_def. Also add code to mark V_MUST_DEF operands for\n\trenaming.\n\t* tree-ssa-operands.c (opf_kill_def): New flag for killing\n\tdefinitions.\n\t(build_vdefs): Renamed to...\n\t(build_v_may_defs): This.\n\t(build_v_must_defs): New variable.\n\t(voperands_d): Add v_must_def_ops and replace vdef_ops with\n\tv_may_def_ops.\n\t(append_vdef): Replace with...\n\t(append_v_may_def): This.\n\t(append_v_must_def): New function.\n\t(NUM_FREE): Increment for V_MUST_DEF\n\t(optype_freelist): Increment its size for V_MUST_DEF\n\t(allocate_vdef_optype): Replace with...\n\t(allocate_v_may_def_optype): This.\n\t(allocate_v_must_def_optype): New function.\n\t(free_vdefs): Replace with...\n\t(free_v_may_defs): This.\n\t(free_v_must_defs): New function.\n\t(remove_vdefs): Replace with...\n\t(remove_v_may_defs): This.\n\t(remove_v_must_defs): New function.\n\t(init_ssa_operands): Rename occurences of vdef to v_may_def. Also\n\tadd code to initialize build_v_must_defs.\n\t(finalize_ssa_vdefs): Replace with...\n\t(finalize_ssa_v_may_defs): This.\n\t(finalize_ssa_vuses): Rename occurences of vdef to v_may_def.\n\t(finalize_ssa_v_must_defs): New function.\n\t(finalize_ssa_stmt_operands): Replace call to finalize_ssa_vdefs\n\twith calls to finalize_ssa_v_may_defs and finalize_ssa_v_must_defs.\n\t(verify_start_operands): Rename occurences of vdef to v_may_def.\n\tAlso add check for build_v_must_defs.\n\t(get_stmt_operands): Rename occurences of vdef to v_may_def.\n\tAlso add code to handle V_MUST_DEFs and to use opf_kill_def for\n\tkilling definitions.\n\t(get_expr_operands): Update comment and use opf_kill_def for\n\tkilling definitions.\n\t(add_stmt_operand): Replace code that appends VDEFs with code\n\tthat appends V_MUST_DEFs when opf_kill_def is set and V_MAY_DEFs\n\totherwise.\n\t(add_call_clobber_ops): Update comments.\n\t* tree-ssa-operands.h (vdef_optype_d): Replace with...\n\t(v_may_def_optype_d): This.\n\t(v_must_def_optype_d): New structure.\n\t(VDEF_OPS): Replace with...\n\t(V_MAY_DEF_OPS): This.\n\t(STMT_VDEF_OPS): Same with...\n\t(STMT_V_MAY_DEF_OPS): This.\n\t(NUM_VDEFS): And...\n\t(NUM_V_MAY_DEFS): This.\n\t(VDEF_RESULT_PTR): As well as...\n\t(V_MAY_DEF_RESULT_PTR): This.\n\t(VDEF_RESULT): Same goes for...\n\t(V_MAY_DEF_RESULT): This.\n\t(VDEF_OP_PTR): And...\n\t(V_MAY_DEF_OP_PTR): This.\n\t(VDEF_OP): And...\n\t(V_MAY_DEF_OP): This.\n\t(V_MUST_DEF_OPS): New macro.\n\t(STMT_V_MUST_DEF_OPS): Ditto.\n\t(NUM_V_MUST_DEFS): Ditto.\n\t(V_MUST_DEF_OP_PTR): Ditto.\n\t(V_MUST_DEF_OP): Ditto.\n\t(remove_vdefs): Replace signature with...\n\t(remove_v_may_defs): This.\n\t(remove_v_must_defs): New function signature.\n\t* tree-ssa-pre.c (subst_phis): Replace call to remove_vdefs\n\twith calls to remove_v_may_defs and remove_v_must_defs.\n\t(process_left_occs_and_kills): Rename occurences of vdef to v_may_def.\n\tAlso add code that marks left occurences of operands in V_MUST_DEFs.\n\t* tree-tailcall.c (find_tail_calls): Rename occurences of vdef\n\tto v_may_def. Also add check for V_MUST_DEFs.\n\t(eliminate_tail_call):Rename occurences of vdef to v_may_def.\n\ntestsuite:\n\n\t* gcc.dg/tree-ssa/20031015-1.c: Scan for\n\tV_MAY_DEF instead of VDEF.\n\t* gcc.dg/tree-ssa/20040517-1.c: Ditto.\n\nFrom-SVN: r82947", "tree": {"sha": "390a758454170e0dc2e6aea71342ec3d64fd2501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/390a758454170e0dc2e6aea71342ec3d64fd2501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/comments", "author": null, "committer": null, "parents": [{"sha": "d57f1617211f3309887c6ee18fca97ea7029ebc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d57f1617211f3309887c6ee18fca97ea7029ebc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d57f1617211f3309887c6ee18fca97ea7029ebc7"}], "stats": {"total": 1307, "additions": 972, "deletions": 335}, "files": [{"sha": "0075059953b7dea1397ffd52f8372d9ed6d16964", "filename": "gcc/ChangeLog", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -1,3 +1,169 @@\n+2004-06-10  Brian Booth  <bbooth@redhat.com>\n+\n+\t* doc/tree-ssa.texi: Remove references to VDEF and add descriptions\n+\tof V_MAY_DEF and V_MUST_DEF.\n+\t* tree-dfa.c (dfa_stats_d): Add num_v_must_defs and rename\n+\tnum_vdefs to num_v_may_defs.\n+\t(compute_immediate_uses_for_stmt): Rename occurences of vdef\n+\tto v_may_def.\n+\t(redirect_immediate_uses): Ditto.\n+\t(dump_dfa_stats): Ditto. Also added code to dump num_v_must_defs.\n+\t(collect_dfa_stats_r): Rename occurences of vdef to v_may_def.\n+\tAlso add code to sum up the number of v_must_defs.\n+\t(vdefs_disappeared_p): Replace with...\n+\t(v_may_defs_disappeared_p): This.\n+\t(v_must_defs_disappeared_p): New function.\n+\t(mark_new_vars_to_rename): Rename occurences of vdef to v_may_def.\n+\tAlso add code to mark new variables found in V_MUST_DEFs for\n+\trenameing.\n+\t* tree-flow.h (stmt_ann_d): Add v_must_def_ops and replace\n+\tvdef_ops to v_may_def_ops.\n+\t(get_vdef_ops): Replace with...\n+\t(get_v_may_def_ops): This.\n+\t* tree-flow-inline.h (get_vdef_ops): Replace with...\n+\t(get_v_may_def_ops): This.\n+\t(get_v_must_def_ops): New function.\n+\t(get_vdef_result_ptr): Replace with...\n+\t(get_v_may_def_result_ptr): This.\n+\t(get_vdef_op_ptr): Ditto with...\n+\t(get_v_may_def_op_ptr); This.\n+\t(get_v_must_def_op_ptr): New function.\n+\t* tree-into-ssa.c (mark_def_sites): Rename occurences of vdef\n+\tto v_may_def. Also add code to mark statements with\n+\tV_MUST_DEFs as definition sites.\n+\t(rewrite_stmt): Rename occurences of vdef to v_may_def. Also \n+\tadd code to register new V_MUST_DEFs made by the statement.\n+\t* tree-outof-ssa.c (VIRTUAL_PARTITION): Update comments.\n+\t(check_replaceable): Rename occurences of vdef to v_may_def. Also \n+\tadd check for V_MUST_DEFs.\n+\t(find_replaceable_in_bb): Ditto.\n+\t* tree-pretty-print.c (dump_vops): Rename occurences of vdef\n+\tto v_may_def. Also add code to dump V_MUST_DEFs.\n+\t* tree-sra.c (mark_all_vdefs): Replace with...\n+\t(mark_all_v_may_defs): This.\n+\t(mark_all_v_must_defs): New function.\n+\t(create_scalar_copies): Replace call to mark_all_vdefs with\n+\tcalls to mark_all_v_may_defs and mark_all_v_must_defs.\n+\t(scalarize_structures): Rename occurences of vdef to v_may_def. \n+\tAlso add a check for V_MUST_DEFs.\n+\t(scalarize_modify_expr): Rename occurences of vdef to v_may_def.\n+\t* tree-ssa-alias.c (global_var): Update comment.\n+\t(compute_may_aliases): Ditto.\n+\t(compute_points_to_and_addr_escape): Rename occurences of vdef\n+\tto v_may_def. Also add code to mark variables in V_MUST_DEF \n+\toperands as being written to.\n+\t(group_aliases): Update comment.\n+\t(maybe_create_global_var): Ditto.\n+\t* tree-ssa.c (verify_ssa): Rename occurences of vdef to v_may_def.\n+\tAlso add a check for V_MUST_DEFs on GIMPLE registers.\n+\t(replace_immediate_uses): Rename occurences of vdef to v_may_def.\n+\t* tree-ssa-ccp.c (visit_stmt): Rename occurences of vdef\n+\tto v_may_def. Also add code to mark all V_MUST_DEF operands \n+\tVARYING.\n+\t(initialize): Ditto.\n+\t(set_rhs): Rename occurences of vdef to v_may_def. Also add\n+\tcode to update SSA_NAMEs in V_MUST_DEFs.\n+\t* tree-ssa-copy.c (cprop_into_stmt): Rename occurences of vdef\n+\tto v_may_def.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Rename \n+\toccurences of vdef to v_may_def. Also add code to mark statements\n+\twith V_MUST_DEFs as necessary.\n+\t(propagate_necessity): Rename occurences of vdef to v_may_def.\n+\t* tree-ssa-dom.c (redirect_edges_and_update_ssa_graph): Rename \n+\toccurences of vdef to v_may_def. Also add code to mark operands\n+\tin V_MUST_DEFs for renaming.\n+\t(eliminate_redundant_computations): Rename occurences of vdef\n+\tto v_may_def.\n+\t(record_equivalences_from_stmt): Rename occurences of vdef\n+\tto v_may_def. Also add code to record VUSEs for V_MUST_DEFs.\n+\t(optimize_stmt): Remove unnesessary variable vdefs. Update\n+\tcomment.\n+\t(register_definitions_for_stmt): Rename occurences of vdef\n+\tto v_may_def. Also add code to register definitions made with\n+\tV_MUST_DEFs.\n+\t* tree-ssa-dse.c (fix_stmt_vdefs): Replace with...\n+\t(fix_stmt_v_may_defs): This.\n+\t(fix_phi_uses): Rename occurences of vdef to v_may_def.\n+\t(dse_optimize_stmt): Ditto.\n+\t* tree-ssa-live.c (create_ssa_var_map): Rename occurences of vdef\n+\tto v_may_def. Also add code to mark V_MUST_DEF operands as being\n+\tused in virtual operators.\n+\t* tree-ssa-loop.c (mark_defs_for_rewrite): Rename occurences of \n+\tvdef to v_may_def. Also add code to mark V_MUST_DEF operands for\n+\trenaming.\n+\t* tree-ssa-operands.c (opf_kill_def): New flag for killing \n+\tdefinitions.\n+\t(build_vdefs): Renamed to...\n+\t(build_v_may_defs): This.\n+\t(build_v_must_defs): New variable.\n+\t(voperands_d): Add v_must_def_ops and replace vdef_ops with\n+\tv_may_def_ops.\n+\t(append_vdef): Replace with...\n+\t(append_v_may_def): This.\n+\t(append_v_must_def): New function.\n+\t(NUM_FREE): Increment for V_MUST_DEF\n+\t(optype_freelist): Increment its size for V_MUST_DEF\n+\t(allocate_vdef_optype): Replace with...\n+\t(allocate_v_may_def_optype): This.\n+\t(allocate_v_must_def_optype): New function.\n+\t(free_vdefs): Replace with...\n+\t(free_v_may_defs): This.\n+\t(free_v_must_defs): New function.\n+\t(remove_vdefs): Replace with...\n+\t(remove_v_may_defs): This.\n+\t(remove_v_must_defs): New function.\n+\t(init_ssa_operands): Rename occurences of vdef to v_may_def. Also\n+\tadd code to initialize build_v_must_defs.\n+\t(finalize_ssa_vdefs): Replace with...\n+\t(finalize_ssa_v_may_defs): This.\n+\t(finalize_ssa_vuses): Rename occurences of vdef to v_may_def.\n+\t(finalize_ssa_v_must_defs): New function.\n+\t(finalize_ssa_stmt_operands): Replace call to finalize_ssa_vdefs\n+\twith calls to finalize_ssa_v_may_defs and finalize_ssa_v_must_defs.\n+\t(verify_start_operands): Rename occurences of vdef to v_may_def.\n+\tAlso add check for build_v_must_defs.\n+\t(get_stmt_operands): Rename occurences of vdef to v_may_def.\n+\tAlso add code to handle V_MUST_DEFs and to use opf_kill_def for\n+\tkilling definitions.\n+\t(get_expr_operands): Update comment and use opf_kill_def for\n+\tkilling definitions.\n+\t(add_stmt_operand): Replace code that appends VDEFs with code\n+\tthat appends V_MUST_DEFs when opf_kill_def is set and V_MAY_DEFs\n+\totherwise.\n+\t(add_call_clobber_ops): Update comments.\n+\t* tree-ssa-operands.h (vdef_optype_d): Replace with...\n+\t(v_may_def_optype_d): This.\n+\t(v_must_def_optype_d): New structure.\n+\t(VDEF_OPS): Replace with...\n+\t(V_MAY_DEF_OPS): This.\n+\t(STMT_VDEF_OPS): Same with...\n+\t(STMT_V_MAY_DEF_OPS): This.\n+\t(NUM_VDEFS): And...\n+\t(NUM_V_MAY_DEFS): This.\n+\t(VDEF_RESULT_PTR): As well as...\n+\t(V_MAY_DEF_RESULT_PTR): This.\n+\t(VDEF_RESULT): Same goes for...\n+\t(V_MAY_DEF_RESULT): This.\n+\t(VDEF_OP_PTR): And...\n+\t(V_MAY_DEF_OP_PTR): This.\n+\t(VDEF_OP): And...\n+\t(V_MAY_DEF_OP): This.\n+\t(V_MUST_DEF_OPS): New macro.\n+\t(STMT_V_MUST_DEF_OPS): Ditto.\n+\t(NUM_V_MUST_DEFS): Ditto.\n+\t(V_MUST_DEF_OP_PTR): Ditto.\n+\t(V_MUST_DEF_OP): Ditto.\n+\t(remove_vdefs): Replace signature with...\n+\t(remove_v_may_defs): This.\n+\t(remove_v_must_defs): New function signature.\n+\t* tree-ssa-pre.c (subst_phis): Replace call to remove_vdefs\n+\twith calls to remove_v_may_defs and remove_v_must_defs.\n+\t(process_left_occs_and_kills): Rename occurences of vdef to v_may_def.\n+\tAlso add code that marks left occurences of operands in V_MUST_DEFs.\n+\t* tree-tailcall.c (find_tail_calls): Rename occurences of vdef \n+\tto v_may_def. Also add check for V_MUST_DEFs.\n+\t(eliminate_tail_call):Rename occurences of vdef to v_may_def.\n+\n 2004-06-10  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/15653"}, {"sha": "a22b4948f3b928943a41d66a4512545bd264b52f", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -697,8 +697,17 @@ variable @code{b} is completely modified with the contents of\n variable @code{a}.  Real definition are also known as @dfn{killing\n definitions}.  Similarly, the use of @code{a} reads all its bits.\n \n-In contrast, virtual operands represent partial or ambiguous\n-references to a variable.  For instance, given\n+In contrast, virtual operands are used with variables that can have\n+a partial or ambiguous reference. This includes structures, arrays,\n+globals, and aliased variables. In these cases, we have two types of\n+definitions. For globals, structures, and arrays, we can determine from\n+a statement whether a variable of these types has a killing definition. \n+If the variable does, then the statement is marked as having a\n+@dfn{must definition} of that variable. However, if a statement is only\n+defining a part of the variable (ie. a field in a structure), or if we\n+know that a statement might define the variable but we cannot say for sure,\n+then we mark that statement as having a @dfn{may definition}.  For \n+instance, given\n \n @smallexample\n @{\n@@ -730,8 +739,8 @@ operands, use the @option{-vops} option to @option{-fdump-tree}:\n     p = &a;\n   else\n     p = &b;\n-  # a = VDEF <a>\n-  # b = VDEF <b>\n+  # a = V_MAY_DEF <a>\n+  # b = V_MAY_DEF <b>\n   *p = 5;\n \n   # VUSE <a>\n@@ -740,21 +749,21 @@ operands, use the @option{-vops} option to @option{-fdump-tree}:\n @}\n @end smallexample\n \n-Notice that @code{VDEF} operands have two copies of the referenced\n+Notice that @code{V_MAY_DEF} operands have two copies of the referenced\n variable.  This indicates that this is not a killing definition of\n that variable.  In this case we refer to it as a @dfn{may definition}\n or @dfn{aliased store}.  The presence of the second copy of the\n-variable in the @code{VDEF} operand will become important when the\n+variable in the @code{V_MAY_DEF} operand will become important when the\n function is converted into SSA form.  This will be used to link all\n the non-killing definitions to prevent optimizations from making\n incorrect assumptions about them.\n \n Operands are collected by @file{tree-ssa-operands.c}.  They are stored\n inside each statement's annotation and can be accessed with\n-@code{DEF_OPS}, @code{USE_OPS}, @code{VDEF_OPS} and @code{VUSE_OPS}.\n-The following are all the accessor macros available to access USE\n-operands.  To access all the other operand arrays, just change the\n-name accordingly:\n+@code{DEF_OPS}, @code{USE_OPS}, @code{V_MAY_DEF_OPS}, \n+@code{V_MUST_DEF_OPS} and @code{VUSE_OPS}. The following are all the \n+accessor macros available to access USE operands.  To access all the \n+other operand arrays, just change the name accordingly:\n \n @defmac USE_OPS (@var{ann})\n Returns the array of operands used by the statement with annotation\n@@ -786,7 +795,8 @@ void\n print_ops (tree stmt)\n @{\n   vuse_optype vuses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   def_optype defs;\n   use_optype uses;\n   stmt_ann_t ann;\n@@ -803,9 +813,13 @@ print_ops (tree stmt)\n   for (i = 0; i < NUM_USES (uses); i++)\n     print_generic_expr (stderr, USE_OP (uses, i), 0);\n   \n-  vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n-    print_generic_expr (stderr, VDEF_OP (vdefs, i), 0);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    print_generic_expr (stderr, V_MAY_DEF_OP (v_may_defs, i), 0);\n+\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    print_generic_expr (stderr, V_MUST_DEF_OP (v_must_defs, i), 0);\n   \n   vuses = VUSE_OPS (ann);\n   for (i = 0; i < NUM_VUSES (vuses); i++)\n@@ -1095,11 +1109,11 @@ foo (int i)\n     p_6 = &b;\n   # p_1 = PHI <p_4(1), p_6(2)>;\n \n-  # a_7 = VDEF <a_3>;\n-  # b_8 = VDEF <b_5>;\n+  # a_7 = V_MAY_DEF <a_3>;\n+  # b_8 = V_MAY_DEF <b_5>;\n   *p_1 = 3;\n \n-  # a_9 = VDEF <a_7>\n+  # a_9 = V_MAY_DEF <a_7>\n   # VUSE <b_8>\n   a_9 = b_8 + 2;\n "}, {"sha": "b8514dc0cd9ae69d44cac38b8f29c077e9df129f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -1,3 +1,9 @@\n+2004-06-10  Brian Booth  <bbooth@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20031015-1.c: Scan for\n+\tV_MAY_DEF instead of VDEF.\n+\t* gcc.dg/tree-ssa/20040517-1.c: Ditto.\n+\n 2004-06-10  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/14957"}, {"sha": "74109e1c4519afecbf824a7ce87abf1874bd0457", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20031015-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -13,4 +13,4 @@ main(void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"VDEF\" 2 \"alias\" } } */\n+/* { dg-final { scan-tree-dump-times \"V_MAY_DEF\" 2 \"alias\" } } */"}, {"sha": "d3d0100a02cbaef718dd014b80829da907c557a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040517-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040517-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040517-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040517-1.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -16,5 +16,5 @@ void bar (void)\n    malloc functions may clobber global memory.  Only the function result\n    does not alias any other pointer.\n    Hence, we must have a VDEF for a before and after the call to foo().  */\n-/* { dg-final { scan-tree-dump-times \"VDEF\" 2 \"ssa\"} } */\n+/* { dg-final { scan-tree-dump-times \"V_MAY_DEF\" 1 \"ssa\"} } */\n "}, {"sha": "3bcf1d525c978897175eb448cb1ff75993107e87", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 81, "deletions": 27, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -59,8 +59,9 @@ struct dfa_stats_d\n   long num_phis;\n   long num_phi_args;\n   int max_num_phi_args;\n-  long num_vdefs;\n+  long num_v_may_defs;\n   long num_vuses;\n+  long num_v_must_defs;\n };\n \n \n@@ -280,7 +281,7 @@ compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n   size_t i;\n   use_optype uses;\n   vuse_optype vuses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   stmt_ann_t ann;\n \n #ifdef ENABLE_CHECKING\n@@ -314,10 +315,10 @@ compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n \t    add_immediate_use (imm_rdef_stmt, stmt);\n \t}\n \n-      vdefs = VDEF_OPS (ann);\n-      for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+      v_may_defs = V_MAY_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n \t{\n-\t  tree vuse = VDEF_OP (vdefs, i);\n+\t  tree vuse = V_MAY_DEF_OP (v_may_defs, i);\n \t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (vuse);\n \t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (vuse)))\n \t    add_immediate_use (imm_rdef_stmt, stmt);\n@@ -390,7 +391,7 @@ redirect_immediate_uses (tree old, tree new)\n   stmt_ann_t ann = get_stmt_ann (old);\n   use_optype uses = USE_OPS (ann);\n   vuse_optype vuses = VUSE_OPS (ann);\n-  vdef_optype vdefs = VDEF_OPS (ann);\n+  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n   unsigned int i;\n \n   /* Look at USE_OPS or VUSE_OPS according to FLAGS.  */\n@@ -400,8 +401,8 @@ redirect_immediate_uses (tree old, tree new)\n   for (i = 0; i < NUM_VUSES (vuses); i++)\n     redirect_immediate_use (VUSE_OP (vuses, i), old, new);\n \n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n-    redirect_immediate_use (VDEF_OP (vdefs, i), old, new);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    redirect_immediate_use (V_MAY_DEF_OP (v_may_defs, i), old, new);\n }\n \n \n@@ -699,9 +700,14 @@ dump_dfa_stats (FILE *file)\n   fprintf (file, fmt_str_1, \"VUSE operands\", dfa_stats.num_vuses,\n \t   SCALE (size), LABEL (size));\n \n-  size = dfa_stats.num_vdefs * sizeof (tree *);\n+  size = dfa_stats.num_v_may_defs * sizeof (tree *);\n   total += size;\n-  fprintf (file, fmt_str_1, \"VDEF operands\", dfa_stats.num_vdefs,\n+  fprintf (file, fmt_str_1, \"V_MAY_DEF operands\", dfa_stats.num_v_may_defs,\n+\t   SCALE (size), LABEL (size));\n+\t   \n+  size = dfa_stats.num_v_must_defs * sizeof (tree *);\n+  total += size;\n+  fprintf (file, fmt_str_1, \"V_MUST_DEF operands\", dfa_stats.num_v_must_defs,\n \t   SCALE (size), LABEL (size));\n \n   size = dfa_stats.num_phis * sizeof (struct tree_phi_node);\n@@ -797,8 +803,11 @@ collect_dfa_stats_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t    dfa_stats_p->num_stmt_anns++;\n \t    dfa_stats_p->num_defs += NUM_DEFS (DEF_OPS (ann));\n \t    dfa_stats_p->num_uses += NUM_USES (USE_OPS (ann));\n-\t    dfa_stats_p->num_vdefs += NUM_VDEFS (VDEF_OPS (ann));\n+\t    dfa_stats_p->num_v_may_defs += \n+\t                 NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann));\n \t    dfa_stats_p->num_vuses += NUM_VUSES (VUSE_OPS (ann));\n+\t    dfa_stats_p->num_v_must_defs += \n+\t                 NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann));\n \t    break;\n \t  }\n \n@@ -1012,21 +1021,43 @@ add_referenced_tmp_var (tree var)\n   add_referenced_var (var, NULL);\n }\n \n+/* Return true if V_MAY_DEFS_AFTER contains fewer entries than \n+   V_MAY_DEFS_BEFORE. Note that this assumes that both varrays \n+   are V_MAY_DEF operands for the same statement.  */\n+\n+static inline bool\n+v_may_defs_disappeared_p (v_may_def_optype v_may_defs_before, \n+                          v_may_def_optype v_may_defs_after)\n+{\n+  /* If there was nothing before, nothing could've disappeared.  */\n+  if (v_may_defs_before == NULL)\n+    return false;\n+     \n+  /* All/some of them gone.  */\n+  if (v_may_defs_after == NULL\n+      || NUM_V_MAY_DEFS (v_may_defs_before) > \n+         NUM_V_MAY_DEFS (v_may_defs_after))\n+    return true;\n+\n+  return false;\n+}\n \n-/* Return true if VDEFS_AFTER contains fewer entries than VDEFS_BEFORE.\n-   Note that this assumes that both varrays are VDEF operands for the same\n-   statement.  */\n+/* Return true if V_MUST_DEFS_AFTER contains fewer entries than \n+   V_MUST_DEFS_BEFORE. Note that this assumes that both varrays \n+   are V_MUST_DEF operands for the same statement.  */\n \n static inline bool\n-vdefs_disappeared_p (vdef_optype vdefs_before, vdef_optype vdefs_after)\n+v_must_defs_disappeared_p (v_must_def_optype v_must_defs_before, \n+                           v_must_def_optype v_must_defs_after)\n {\n   /* If there was nothing before, nothing could've disappeared.  */\n-  if (vdefs_before == NULL)\n+  if (v_must_defs_before == NULL)\n     return false;\n      \n   /* All/some of them gone.  */\n-  if (vdefs_after == NULL\n-      || NUM_VDEFS (vdefs_before) > NUM_VDEFS (vdefs_after))\n+  if (v_must_defs_after == NULL\n+      || NUM_V_MUST_DEFS (v_must_defs_before) > \n+         NUM_V_MUST_DEFS (v_must_defs_after))\n     return true;\n \n   return false;\n@@ -1041,12 +1072,14 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n {\n   def_optype defs;\n   use_optype uses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   vuse_optype vuses;\n+  v_must_def_optype v_must_defs;\n   size_t i;\n   bitmap vars_in_vops_to_rename;\n   bool found_exposed_symbol = false;\n-  vdef_optype vdefs_before, vdefs_after;\n+  v_may_def_optype v_may_defs_before, v_may_defs_after;\n+  v_must_def_optype v_must_defs_before, v_must_defs_after;\n   stmt_ann_t ann;\n \n   vars_in_vops_to_rename = BITMAP_XMALLOC ();\n@@ -1061,10 +1094,10 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n      rename them if there are not any newly exposed symbols in the\n      statement operands.  */\n   ann = stmt_ann (stmt);\n-  vdefs_before = vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  v_may_defs_before = v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      tree var = VDEF_RESULT (vdefs, i);\n+      tree var = V_MAY_DEF_RESULT (v_may_defs, i);\n       if (!DECL_P (var))\n \tvar = SSA_NAME_VAR (var);\n       bitmap_set_bit (vars_in_vops_to_rename, var_ann (var)->uid);\n@@ -1079,6 +1112,15 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n       bitmap_set_bit (vars_in_vops_to_rename, var_ann (var)->uid);\n     }\n \n+  v_must_defs_before = v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      tree var = V_MUST_DEF_OP (v_must_defs, i);\n+      if (!DECL_P (var))\n+\tvar = SSA_NAME_VAR (var);\n+      bitmap_set_bit (vars_in_vops_to_rename, var_ann (var)->uid);\n+    }\n+\n   /* Now force an operand re-scan on the statement and mark any newly\n      exposed variables.  */\n   modify_stmt (stmt);\n@@ -1106,10 +1148,10 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n \t}\n     }\n \n-  vdefs_after = vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  v_may_defs_after = v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      tree var = VDEF_RESULT (vdefs, i);\n+      tree var = V_MAY_DEF_RESULT (v_may_defs, i);\n       if (DECL_P (var))\n \t{\n \t  found_exposed_symbol = true;\n@@ -1127,14 +1169,26 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n \t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t}\n     }\n+    \n+  v_must_defs_after = v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      tree var = V_MUST_DEF_OP (v_must_defs, i);\n+      if (DECL_P (var))\n+\t{\n+\t  found_exposed_symbol = true;\n+\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t}\n+    }  \n \n   /* If we found any newly exposed symbols, or if there are fewer VDEF\n      operands in the statement, add the variables we had set in\n      VARS_IN_VOPS_TO_RENAME to VARS_TO_RENAME.  We need to check for\n      vanishing VDEFs because in those cases, the names that were formerly\n      generated by this statement are not going to be available anymore.  */\n   if (found_exposed_symbol\n-      || vdefs_disappeared_p (vdefs_before, vdefs_after))\n+      || v_may_defs_disappeared_p (v_may_defs_before, v_may_defs_after)\n+      || v_must_defs_disappeared_p (v_must_defs_before, v_must_defs_after))\n     bitmap_a_or_b (vars_to_rename, vars_to_rename, vars_in_vops_to_rename);\n \n   BITMAP_XFREE (vars_in_vops_to_rename);"}, {"sha": "4bb5e41d3189b1f77281ea8a8c4164eeafb9c916", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -172,10 +172,10 @@ get_use_ops (stmt_ann_t ann)\n   return ann ? ann->use_ops : NULL;\n }\n \n-static inline vdef_optype\n-get_vdef_ops (stmt_ann_t ann)\n+static inline v_may_def_optype\n+get_v_may_def_ops (stmt_ann_t ann)\n {\n-  return ann ? ann->vdef_ops : NULL;\n+  return ann ? ann->v_may_def_ops : NULL;\n }\n \n static inline vuse_optype\n@@ -184,6 +184,12 @@ get_vuse_ops (stmt_ann_t ann)\n   return ann ? ann->vuse_ops : NULL;\n }\n \n+static inline v_must_def_optype\n+get_v_must_def_ops (stmt_ann_t ann)\n+{\n+  return ann ? ann->v_must_def_ops : NULL;\n+}\n+\n static inline tree *\n get_use_op_ptr (use_optype uses, unsigned int index)\n {\n@@ -205,23 +211,23 @@ get_def_op_ptr (def_optype defs, unsigned int index)\n }\n \n static inline tree *\n-get_vdef_result_ptr(vdef_optype vdefs, unsigned int index)\n+get_v_may_def_result_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n #ifdef ENABLE_CHECKING\n-  if (index >= vdefs->num_vdefs)\n+  if (index >= v_may_defs->num_v_may_defs)\n     abort();\n #endif\n-  return &(vdefs->vdefs[index * 2]);\n+  return &(v_may_defs->v_may_defs[index * 2]);\n }\n \n static inline tree *\n-get_vdef_op_ptr(vdef_optype vdefs, unsigned int index)\n+get_v_may_def_op_ptr(v_may_def_optype v_may_defs, unsigned int index)\n {\n #ifdef ENABLE_CHECKING\n-  if (index >= vdefs->num_vdefs)\n+  if (index >= v_may_defs->num_v_may_defs)\n     abort();\n #endif\n-  return &(vdefs->vdefs[index * 2 + 1]);\n+  return &(v_may_defs->v_may_defs[index * 2 + 1]);\n }\n \n static inline tree *\n@@ -234,6 +240,16 @@ get_vuse_op_ptr(vuse_optype vuses, unsigned int index)\n   return &(vuses->vuses[index]);\n }\n \n+static inline tree *\n+get_v_must_def_op_ptr (v_must_def_optype v_must_defs, unsigned int index)\n+{\n+#ifdef ENABLE_CHECKING\n+  if (index >= v_must_defs->num_v_must_defs)\n+    abort();\n+#endif\n+  return &(v_must_defs->v_must_defs[index]);\n+}\n+\n static inline void\n start_ssa_stmt_operands (tree stmt ATTRIBUTE_UNUSED)\n {"}, {"sha": "57271113e01074a69edd47ec5a96c911056b761a", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -238,9 +238,10 @@ struct stmt_ann_d GTY(())\n   struct def_optype_d * GTY (()) def_ops;\n   struct use_optype_d * GTY (()) use_ops;\n \n-  /* Virtual operands (VDEF and VUSE).  */\n-  struct vdef_optype_d * GTY (()) vdef_ops;\n+  /* Virtual operands (V_MAY_DEF, VUSE, and V_MUST_DEF).  */\n+  struct v_may_def_optype_d * GTY (()) v_may_def_ops;\n   struct vuse_optype_d * GTY (()) vuse_ops;\n+  struct v_must_def_optype_d * GTY (()) v_must_def_ops;\n \n   /* Dataflow information.  */\n   dataflow_t df;\n@@ -281,7 +282,7 @@ static inline int get_lineno (tree);\n static inline const char *get_filename (tree);\n static inline bool is_exec_stmt (tree);\n static inline bool is_label_stmt (tree);\n-static inline vdef_optype get_vdef_ops (stmt_ann_t);\n+static inline v_may_def_optype get_v_may_def_ops (stmt_ann_t);\n static inline vuse_optype get_vuse_ops (stmt_ann_t);\n static inline use_optype get_use_ops (stmt_ann_t);\n static inline def_optype get_def_ops (stmt_ann_t);"}, {"sha": "e07258a28941bb3cc33fc3933dc14e3c1a02aa6a", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -211,7 +211,8 @@ mark_def_sites (struct dom_walk_data *walk_data,\n {\n   struct mark_def_sites_global_data *gd = walk_data->global_data;\n   sbitmap kills = gd->kills;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   vuse_optype vuses;\n   def_optype defs;\n   use_optype uses;\n@@ -248,22 +249,36 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     }\n \n   /* Note that virtual definitions are irrelevant for computing KILLS\n-     because a VDEF does not constitute a killing definition of the\n+     because a V_MAY_DEF does not constitute a killing definition of the\n      variable.  However, the operand of a virtual definitions is a use\n      of the variable, so it may cause the variable to be considered\n      live-on-entry.  */\n-  vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      if (prepare_operand_for_rename (VDEF_OP_PTR (vdefs, i), &uid, true))\n+      if (prepare_operand_for_rename (V_MAY_DEF_OP_PTR (v_may_defs, i), \n+                                      &uid, true))\n \t{\n \t  /* If we do not already have an SSA_NAME for our destination,\n \t     then set the destination to the source.  */\n-\t  if (TREE_CODE (VDEF_RESULT (vdefs, i)) != SSA_NAME)\n-\t    VDEF_RESULT (vdefs, i) = VDEF_OP (vdefs, i);\n+\t  if (TREE_CODE (V_MAY_DEF_RESULT (v_may_defs, i)) != SSA_NAME)\n+\t    V_MAY_DEF_RESULT (v_may_defs, i) = V_MAY_DEF_OP (v_may_defs, i);\n+\t    \n+          set_livein_block (V_MAY_DEF_OP (v_may_defs, i), bb);\n+\t  set_def_block (V_MAY_DEF_RESULT (v_may_defs, i), bb);\n+\t}\n+    }\n+\n+  /* Now process the virtual must-defs made by this statement.  */\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      tree *def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n \n-\t  set_livein_block (VDEF_OP (vdefs, i), bb);\n-\t  set_def_block (VDEF_RESULT (vdefs, i), bb);\n+      if (prepare_operand_for_rename (def_p, &uid, false))\n+\t{\n+\t  set_def_block (*def_p, bb);\n+\t  SET_BIT (kills, uid);\n \t}\n     }\n \n@@ -717,7 +732,8 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n   stmt_ann_t ann;\n   tree stmt;\n   vuse_optype vuses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   def_optype defs;\n   use_optype uses;\n   struct rewrite_block_data *bd;\n@@ -744,7 +760,8 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n   defs = DEF_OPS (ann);\n   uses = USE_OPS (ann);\n   vuses = VUSE_OPS (ann);\n-  vdefs = VDEF_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n \n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n   for (i = 0; i < NUM_USES (uses); i++)\n@@ -768,18 +785,32 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n     }\n \n   /* Register new virtual definitions made by the statement.  */\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      rewrite_operand (VDEF_OP_PTR (vdefs, i));\n+      rewrite_operand (V_MAY_DEF_OP_PTR (v_may_defs, i));\n \n-      if (TREE_CODE (VDEF_RESULT (vdefs, i)) != SSA_NAME)\n-\t*VDEF_RESULT_PTR (vdefs, i)\n-\t  = make_ssa_name (VDEF_RESULT (vdefs, i), stmt);\n+      if (TREE_CODE (V_MAY_DEF_RESULT (v_may_defs, i)) != SSA_NAME)\n+\t*V_MAY_DEF_RESULT_PTR (v_may_defs, i)\n+\t  = make_ssa_name (V_MAY_DEF_RESULT (v_may_defs, i), stmt);\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n-      register_new_def (VDEF_RESULT (vdefs, i), &bd->block_defs);\n+      register_new_def (V_MAY_DEF_RESULT (v_may_defs, i), &bd->block_defs);\n+    }\n+        \n+  /* Register new virtual mustdefs made by the statement.  */\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      tree *v_must_def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n+\n+      if (TREE_CODE (*v_must_def_p) != SSA_NAME)\n+\t*v_must_def_p = make_ssa_name (*v_must_def_p, stmt);\n+\n+      /* FIXME: We shouldn't be registering new mustdefs if the variable\n+\t doesn't need to be renamed.  */\n+      register_new_def (*v_must_def_p, &bd->block_defs);\n     }\n+    \n }\n \n "}, {"sha": "eee24c4a7b866f4b49fbc9ff08f873d5639aa554", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -1134,8 +1134,8 @@ coalesce_vars (var_map map, tree_live_info_p liveinfo)\n    dependent on any virtual variable (via a VUSE) has a dependence added\n    to the special partition defined by VIRTUAL_PARTITION.\n \n-   Whenever a VDEF is seen, all expressions dependent this VIRTUAL_PARTITION\n-   are removed from consideration.\n+   Whenever a V_MAY_DEF is seen, all expressions dependent this \n+   VIRTUAL_PARTITION are removed from consideration.\n \n    At the end of a basic block, all expression are removed from consideration\n    in preparation for the next block.  \n@@ -1171,7 +1171,7 @@ typedef struct temp_expr_table_d\n   value_expr_p pending_dependence;\n } *temp_expr_table_p;\n \n-/* Used to indicate a dependancy on VDEFs.  */\n+/* Used to indicate a dependancy on V_MAY_DEFs.  */\n #define VIRTUAL_PARTITION(table)\t(table->virtual_partition)\n \n static temp_expr_table_p new_temp_expr_table (var_map);\n@@ -1437,8 +1437,12 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n   if (DECL_HARD_REGISTER (SSA_NAME_VAR (def)))\n     return false;\n \n-  /* There must be no VDEFS.  */\n-  if (NUM_VDEFS (VDEF_OPS (ann)) != 0)\n+  /* There must be no V_MAY_DEFS.  */\n+  if (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) != 0)\n+    return false;\n+\n+  /* There must be no V_MUST_DEFS.  */\n+  if (NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) != 0)\n     return false;\n \n   /* Float expressions must go through memory if float-store is on.  */\n@@ -1646,8 +1650,12 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t  free_value_expr (tab, p);\n \t}\n \n-      /* A VDEF kills any expression using a virtual operand.  */\n-      if (NUM_VDEFS (VDEF_OPS (ann)) > 0)\n+      /* A V_MAY_DEF kills any expression using a virtual operand.  */\n+      if (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0)\n+        kill_virtual_exprs (tab, true);\n+\t\n+      /* A V_MUST_DEF kills any expression using a virtual operand.  */\n+      if (NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0)\n         kill_virtual_exprs (tab, true);\n     }\n }"}, {"sha": "b550fc9870df76e51c60779893249525cf6ad7be", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -2061,15 +2061,27 @@ dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n {\n   size_t i;\n   stmt_ann_t ann = stmt_ann (stmt);\n-  vdef_optype vdefs = VDEF_OPS (ann);\n+  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n+  v_must_def_optype v_must_defs = V_MUST_DEF_OPS (ann);\n   vuse_optype vuses = VUSE_OPS (ann);\n \n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n       pp_string (buffer, \"#   \");\n-      dump_generic_node (buffer, VDEF_RESULT (vdefs, i), spc + 2, flags, false);\n-      pp_string (buffer, \" = VDEF <\");\n-      dump_generic_node (buffer, VDEF_OP (vdefs, i), spc + 2, flags, false);\n+      dump_generic_node (buffer, V_MAY_DEF_RESULT (v_may_defs, i), \n+                         spc + 2, flags, false);\n+      pp_string (buffer, \" = V_MAY_DEF <\");\n+      dump_generic_node (buffer, V_MAY_DEF_OP (v_may_defs, i), \n+                         spc + 2, flags, false);\n+      pp_string (buffer, \">;\");\n+      newline_and_indent (buffer, spc);\n+    }\n+\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      tree v_must_def = V_MUST_DEF_OP (v_must_defs, i);\n+      pp_string (buffer, \"#   V_MUST_DEF <\");\n+      dump_generic_node (buffer, v_must_def, spc + 2, flags, false);\n       pp_string (buffer, \">;\");\n       newline_and_indent (buffer, spc);\n     }"}, {"sha": "219c8148985bc42c12f4021c8d97bf1905dd4683", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -112,22 +112,42 @@ sra_elt_eq (const void *x, const void *y)\n   return true;\n }\n \n-/* Mark all the variables in VDEF operands for STMT for renaming.\n+/* Mark all the variables in V_MAY_DEF operands for STMT for renaming.\n    This becomes necessary when we modify all of a non-scalar.  */\n \n static void\n-mark_all_vdefs (tree stmt)\n+mark_all_v_may_defs (tree stmt)\n {\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   size_t i, n;\n \n   get_stmt_operands (stmt);\n-  vdefs = VDEF_OPS (stmt_ann (stmt));\n-  n = NUM_VDEFS (vdefs);\n+  v_may_defs = V_MAY_DEF_OPS (stmt_ann (stmt));\n+  n = NUM_V_MAY_DEFS (v_may_defs);\n \n   for (i = 0; i < n; i++)\n     {\n-      tree sym = VDEF_RESULT (vdefs, i);\n+      tree sym = V_MAY_DEF_RESULT (v_may_defs, i);\n+      bitmap_set_bit (vars_to_rename, var_ann (sym)->uid);\n+    }\n+}\n+\n+/* Mark all the variables in V_MUST_DEF operands for STMT for renaming.\n+   This becomes necessary when we modify all of a non-scalar.  */\n+\n+static void\n+mark_all_v_must_defs (tree stmt)\n+{\n+  v_must_def_optype v_must_defs;\n+  size_t i, n;\n+\n+  get_stmt_operands (stmt);\n+  v_must_defs = V_MUST_DEF_OPS (stmt_ann (stmt));\n+  n = NUM_V_MUST_DEFS (v_must_defs);\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      tree sym = V_MUST_DEF_OP (v_must_defs, i);\n       bitmap_set_bit (vars_to_rename, var_ann (sym)->uid);\n     }\n }\n@@ -685,7 +705,8 @@ create_scalar_copies (tree lhs, tree rhs, enum sra_copy_mode mode)\n \n       /* Mark all the variables in VDEF operands for renaming, because\n \t the VA_ARG_EXPR will now be in a different statement.  */\n-      mark_all_vdefs (stmt);\n+      mark_all_v_may_defs (stmt);\n+      mark_all_v_must_defs (stmt);\n \n       /* Set RHS to be the new temporary TMP.  */\n       rhs = tmp;\n@@ -784,7 +805,8 @@ create_scalar_copies (tree lhs, tree rhs, enum sra_copy_mode mode)\n \t  /* Otherwise, mark all the symbols in the VDEFs for the last\n \t     scalarized statement just created.  Since all the statements\n \t     introduce the same VDEFs, we only need to check the last one.  */\n-\t  mark_all_vdefs (tsi_stmt (tsi));\n+\t  mark_all_v_may_defs (tsi_stmt (tsi));\n+\t  mark_all_v_must_defs (tsi_stmt (tsi));\n \t}\n       else\n \tabort ();\n@@ -830,8 +852,9 @@ scalarize_structures (void)\n \n \t/* If the statement has no virtual operands, then it doesn't make\n \t   structure references that we care about.  */\n-\tif (NUM_VDEFS (VDEF_OPS (ann)) == 0\n-\t    && NUM_VUSES (VUSE_OPS (ann)) == 0)\n+\tif (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n+\t    && NUM_VUSES (VUSE_OPS (ann)) == 0\n+\t    && NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) == 0)\n \t  continue;\n \n \t/* Structure references may only appear in certain statements.  */\n@@ -899,17 +922,17 @@ scalarize_modify_expr (block_stmt_iterator *si_p)\n   if (is_sra_candidate_ref (lhs, false))\n     {\n       tree sym;\n-      vdef_optype vdefs;\n+      v_may_def_optype v_may_defs;\n \n       scalarize_component_ref (stmt, &TREE_OPERAND (stmt, 0));\n \n       /* Mark the LHS to be renamed, as we have just removed the previous\n-\t VDEF for AGGREGATE.  The statement should have exactly one VDEF\n-\t for variable AGGREGATE.  */\n-      vdefs = STMT_VDEF_OPS (stmt);\n-      if (NUM_VDEFS (vdefs) != 1)\n+\t V_MAY_DEF for AGGREGATE.  The statement should have exactly one \n+\t V_MAY_DEF for variable AGGREGATE.  */\n+      v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n+      if (NUM_V_MAY_DEFS (v_may_defs) != 1)\n \tabort ();\n-      sym = SSA_NAME_VAR (VDEF_RESULT (vdefs, 0));\n+      sym = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, 0));\n       bitmap_set_bit (vars_to_rename, var_ann (sym)->uid);\n     }\n "}, {"sha": "e980aa2d3a712c24c8c64f38abb38e2e343b5a60", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -174,7 +174,7 @@ bool aliases_computed_p;\n    this variable is used to represent the clobbering effects of function\n    calls.  In these cases, all the call clobbered variables in the program\n    are forced to alias this variable.  This reduces compile times by not\n-   having to keep track of too many VDEF expressions at call sites.  */\n+   having to keep track of too many V_MAY_DEF expressions at call sites.  */\n tree global_var;\n \n \n@@ -264,11 +264,11 @@ tree global_var;\n \t\tp_6 = &b;\n \t      # p_1 = PHI <p_4(1), p_6(2)>;\n \n-\t      # a_7 = VDEF <a_3>;\n-\t      # b_8 = VDEF <b_5>;\n+\t      # a_7 = V_MAY_DEF <a_3>;\n+\t      # b_8 = V_MAY_DEF <b_5>;\n \t      *p_1 = 3;\n \n-\t      # a_9 = VDEF <a_7>\n+\t      # a_9 = V_MAY_DEF <a_7>\n \t      # VUSE <b_8>\n \t      a_9 = b_8 + 2;\n \n@@ -536,7 +536,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t{\n \t  use_optype uses;\n \t  def_optype defs;\n-\t  vdef_optype vdefs;\n+\t  v_may_def_optype v_may_defs;\n+\t  v_must_def_optype v_must_defs;\n \t  stmt_ann_t ann;\n \t  bitmap addr_taken;\n \t  tree stmt = bsi_stmt (si);\n@@ -658,11 +659,21 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t(VARRAY_UINT (ai->num_references, ann->uid))++;\n \t    }\n \n-\t  /* Mark variables in VDEF operands as being written to.  */\n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+\t  /* Mark variables in V_MAY_DEF operands as being written to.  */\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n \t    {\n-\t      tree op = VDEF_OP (vdefs, i);\n+\t      tree op = V_MAY_DEF_OP (v_may_defs, i);\n+\t      tree var = SSA_NAME_VAR (op);\n+\t      var_ann_t ann = var_ann (var);\n+\t      bitmap_set_bit (ai->written_vars, ann->uid);\n+\t    }\n+\t    \n+\t  /* Mark variables in V_MUST_DEF operands as being written to.  */\n+\t  v_must_defs = V_MUST_DEF_OPS (ann);\n+\t  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\t    {\n+\t      tree op = V_MUST_DEF_OP (v_must_defs, i);\n \t      tree var = SSA_NAME_VAR (op);\n \t      var_ann_t ann = var_ann (var);\n \t      bitmap_set_bit (ai->written_vars, ann->uid);\n@@ -1040,7 +1051,7 @@ group_aliases (struct alias_info *ai)\n \n      \tp_5 = &a;\n \t...\n-\t# a_9 = VDEF <a_8>\n+\t# a_9 = V_MAY_DEF <a_8>\n \tp_5->field = 0\n \t... Several modifications to TMT.20 ... \n \t# VUSE <a_9>\n@@ -1273,8 +1284,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n }\n \n \n-/* Determine whether to use .GLOBAL_VAR to model call clobbering semantics.  At\n-   every call site, we need to emit VDEF expressions to represent the\n+/* Determine whether to use .GLOBAL_VAR to model call clobbering semantics. At\n+   every call site, we need to emit V_MAY_DEF expressions to represent the\n    clobbering effects of the call for variables whose address escapes the\n    current function.\n \n@@ -1283,10 +1294,11 @@ setup_pointers_and_addressables (struct alias_info *ai)\n    (.GLOBAL_VAR).  This works well, but it ties the optimizer hands because\n    references to any call clobbered variable is a reference to .GLOBAL_VAR.\n \n-   The second approach is to emit a clobbering VDEF for every call-clobbered\n-   variable at call sites.  This is the preferred way in terms of optimization\n-   opportunities but it may create too many VDEF operands if there are many\n-   call clobbered variables and function calls in the function.\n+   The second approach is to emit a clobbering V_MAY_DEF for every \n+   call-clobbered variable at call sites.  This is the preferred way in terms \n+   of optimization opportunities but it may create too many V_MAY_DEF operands\n+   if there are many call clobbered variables and function calls in the \n+   function.\n \n    To decide whether or not to use .GLOBAL_VAR we multiply the number of\n    function calls found by the number of call-clobbered variables.  If that"}, {"sha": "4f5612b6f079f04358b34994d0575234b26f59c1", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -610,7 +610,8 @@ visit_stmt (tree stmt)\n   size_t i;\n   stmt_ann_t ann;\n   def_optype defs;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n \n   /* If the statement has already been deemed to be VARYING, don't simulate\n      it again.  */\n@@ -669,10 +670,15 @@ visit_stmt (tree stmt)\n \tadd_outgoing_control_edges (bb_for_stmt (stmt));\n     }\n \n-  /* Mark all VDEF operands VARYING.  */\n-  vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n-    def_to_varying (VDEF_RESULT (vdefs, i));\n+  /* Mark all V_MAY_DEF operands VARYING.  */\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    def_to_varying (V_MAY_DEF_RESULT (v_may_defs, i));\n+    \n+  /* Mark all V_MUST_DEF operands VARYING.  */\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    def_to_varying (V_MUST_DEF_OP (v_must_defs, i));\n }\n \n \n@@ -1129,7 +1135,8 @@ initialize (void)\n       tree stmt;\n       stmt_ann_t ann;\n       def_optype defs;\n-      vdef_optype vdefs;\n+      v_may_def_optype v_may_defs;\n+      v_must_def_optype v_must_defs;\n       size_t x;\n       int vary;\n \n@@ -1149,14 +1156,23 @@ initialize (void)\n \t    }\n \t  DONT_SIMULATE_AGAIN (stmt) = vary;\n \n-\t  /* Mark all VDEF operands VARYING.  */\n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (x = 0; x < NUM_VDEFS (vdefs); x++)\n+\t  /* Mark all V_MAY_DEF operands VARYING.  */\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (x = 0; x < NUM_V_MAY_DEFS (v_may_defs); x++)\n \t    {\n-\t      tree res = VDEF_RESULT (vdefs, x);\n+\t      tree res = V_MAY_DEF_RESULT (v_may_defs, x);\n \t      get_value (res)->lattice_val = VARYING;\n \t      SET_BIT (virtual_var, SSA_NAME_VERSION (res));\n \t    }\n+\t    \n+\t  /* Mark all V_MUST_DEF operands VARYING.  */\n+\t  v_must_defs = V_MUST_DEF_OPS (ann);\n+\t  for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n+\t    {\n+\t      tree v_must_def = V_MUST_DEF_OP (v_must_defs, x);\n+\t      get_value (v_must_def)->lattice_val = VARYING;\n+\t      SET_BIT (virtual_var, SSA_NAME_VERSION (v_must_def));\n+\t    }\n \t}\n \n       for (e = bb->succ; e; e = e->succ_next)\n@@ -2064,7 +2080,8 @@ set_rhs (tree *stmt_p, tree expr)\n       if (TREE_SIDE_EFFECTS (expr))\n \t{\n \t  def_optype defs;\n-\t  vdef_optype vdefs;\n+\t  v_may_def_optype v_may_defs;\n+\t  v_must_def_optype v_must_defs;\n \t  size_t i;\n \n \t  /* Fix all the SSA_NAMEs created by *STMT_P to point to its new\n@@ -2077,10 +2094,18 @@ set_rhs (tree *stmt_p, tree expr)\n \t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n \t    }\n \n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t    {\n+\t      tree var = V_MAY_DEF_RESULT (v_may_defs, i);\n+\t      if (TREE_CODE (var) == SSA_NAME)\n+\t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n+\t    }\n+\t    \n+\t  v_must_defs = V_MUST_DEF_OPS (ann);\n+\t  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n \t    {\n-\t      tree var = VDEF_RESULT (vdefs, i);\n+\t      tree var = V_MUST_DEF_OP (v_must_defs, i);\n \t      if (TREE_CODE (var) == SSA_NAME)\n \t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n \t    }"}, {"sha": "753a6772ea0a84c99a224ed4640081f2a128ce57", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -225,16 +225,16 @@ cprop_operand (stmt_ann_t ann, tree *op_p, varray_type const_and_copies)\n    known value for that SSA_NAME (or NULL if no value is known).  \n \n    Propagate values from CONST_AND_COPIES into the uses, vuses and\n-   vdef_ops of STMT.  */\n+   v_may_def_ops of STMT.  */\n \n bool\n cprop_into_stmt (tree stmt, varray_type const_and_copies)\n {\n   bool may_have_exposed_new_symbols = false;\n   stmt_ann_t ann = stmt_ann (stmt);\n-  size_t i, num_uses, num_vuses, num_vdefs;\n+  size_t i, num_uses, num_vuses, num_v_may_defs;\n   vuse_optype vuses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   use_optype uses;\n \n   uses = USE_OPS (ann);\n@@ -257,11 +257,11 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n \t  |= cprop_operand (ann, op_p, const_and_copies);\n     }\n \n-  vdefs = VDEF_OPS (ann);\n-  num_vdefs = NUM_VDEFS (vdefs);\n-  for (i = 0; i < num_vdefs; i++)\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  num_v_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n+  for (i = 0; i < num_v_may_defs; i++)\n     {\n-      tree *op_p = VDEF_OP_PTR (vdefs, i);\n+      tree *op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n       if (TREE_CODE (*op_p) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n \t  |= cprop_operand (ann, op_p, const_and_copies);"}, {"sha": "90bcf2116122ce4bde4c50aab8cb11c60e7ca755", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -286,7 +286,8 @@ static void\n mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n {\n   def_optype defs;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   stmt_ann_t ann;\n   size_t i;\n \n@@ -387,11 +388,22 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n         }\n     }\n \n-  vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      tree vdef = VDEF_RESULT (vdefs, i);\n-      if (need_to_preserve_store (vdef))\n+      tree v_may_def = V_MAY_DEF_RESULT (v_may_defs, i);\n+      if (need_to_preserve_store (v_may_def))\n+\t{\n+\t  mark_stmt_necessary (stmt, true);\n+\t  return;\n+        }\n+    }\n+    \n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      tree v_must_def = V_MUST_DEF_OP (v_must_defs, i);\n+      if (need_to_preserve_store (v_must_def))\n \t{\n \t  mark_stmt_necessary (stmt, true);\n \t  return;\n@@ -558,10 +570,10 @@ propagate_necessity (struct edge_list *el)\n       else\n \t{\n \t  /* Propagate through the operands.  Examine all the USE, VUSE and\n-\t     VDEF operands in this statement.  Mark all the statements which\n-\t     feed this statement's uses as necessary.  */\n+\t     V_MAY_DEF operands in this statement.  Mark all the statements \n+\t     which feed this statement's uses as necessary.  */\n \t  vuse_optype vuses;\n-\t  vdef_optype vdefs;\n+\t  v_may_def_optype v_may_defs;\n \t  use_optype uses;\n \t  stmt_ann_t ann;\n \t  size_t k;\n@@ -577,12 +589,13 @@ propagate_necessity (struct edge_list *el)\n \t  for (k = 0; k < NUM_VUSES (vuses); k++)\n \t    mark_operand_necessary (VUSE_OP (vuses, k));\n \n-\t  /* The operands of VDEF expressions are also needed as they\n+\t  /* The operands of V_MAY_DEF expressions are also needed as they\n \t     represent potential definitions that may reach this\n-\t     statement (VDEF operands allow us to follow def-def links).  */\n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (k = 0; k < NUM_VDEFS (vdefs); k++)\n-\t    mark_operand_necessary (VDEF_OP (vdefs, k));\n+\t     statement (V_MAY_DEF operands allow us to follow def-def \n+\t     links).  */\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (k = 0; k < NUM_V_MAY_DEFS (v_may_defs); k++)\n+\t    mark_operand_necessary (V_MAY_DEF_OP (v_may_defs, k));\n \t}\n     }\n }"}, {"sha": "688de2a2d486bbcc047edd68096f79c58de107fd", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -347,7 +347,8 @@ redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n \t{\n \t  unsigned int j;\n \t  def_optype defs;\n-\t  vdef_optype vdefs;\n+\t  v_may_def_optype v_may_defs;\n+\t  v_must_def_optype v_must_defs;\n \t  tree stmt = bsi_stmt (bsi);\n \t  stmt_ann_t ann = stmt_ann (stmt);\n \n@@ -363,11 +364,18 @@ redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n \t      bitmap_set_bit (vars_to_rename, var_ann (op)->uid);\n \t    }\n \n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (j = 0; j < NUM_VDEFS (vdefs); j++)\n+\t  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n+\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n-\t      tree op = VDEF_RESULT (vdefs, j);\n-\t      bitmap_set_bit (virtuals_to_rename, var_ann (op)->uid);\n+\t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n+\t      bitmap_set_bit (vars_to_rename, var_ann (op)->uid);\n+\t    }\n+\t    \n+\t  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n+\t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n+\t    {\n+\t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n+\t      bitmap_set_bit (vars_to_rename, var_ann (op)->uid);\n \t    }\n \t}\n \n@@ -2289,7 +2297,7 @@ static bool\n eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \t\t\t\t  tree stmt, stmt_ann_t ann)\n {\n-  vdef_optype vdefs = VDEF_OPS (ann);\n+  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n   tree *expr_p, def = NULL_TREE;\n   bool insert = true;\n   tree cached_lhs;\n@@ -2306,7 +2314,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n       || ! def\n       || TREE_CODE (def) != SSA_NAME\n       || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def)\n-      || NUM_VDEFS (vdefs) != 0)\n+      || NUM_V_MAY_DEFS (v_may_defs) != 0)\n     insert = false;\n \n   /* Check if the expression has been computed before.  */\n@@ -2511,7 +2519,8 @@ record_equivalences_from_stmt (tree stmt,\n \n       if (rhs)\n \t{\n-\t  vdef_optype vdefs = VDEF_OPS (ann);\n+\t  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  v_must_def_optype v_must_defs = V_MUST_DEF_OPS (ann);\n \n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n \t  new = build (MODIFY_EXPR, TREE_TYPE (stmt), rhs, lhs);\n@@ -2523,14 +2532,22 @@ record_equivalences_from_stmt (tree stmt,\n \t  /* Clear out the virtual operands on the new statement, we are\n \t     going to set them explicitly below.  */\n \t  remove_vuses (new);\n-\t  remove_vdefs (new);\n+\t  remove_v_may_defs (new);\n+\t  remove_v_must_defs (new);\n \n \t  start_ssa_stmt_operands (new);\n \t  /* For each VDEF on the original statement, we want to create a\n-\t     VUSE of the VDEF result on the new statement.  */\n-\t  for (j = 0; j < NUM_VDEFS (vdefs); j++)\n+\t     VUSE of the V_MAY_DEF result or V_MUST_DEF op on the new \n+\t     statement.  */\n+\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n-\t      tree op = VDEF_RESULT (vdefs, j);\n+\t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n+\t      add_vuse (op, new);\n+\t    }\n+\t    \n+\t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n+\t    {\n+\t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n \t      add_vuse (op, new);\n \t    }\n \n@@ -2565,7 +2582,6 @@ optimize_stmt (struct dom_walk_data *walk_data,\n {\n   stmt_ann_t ann;\n   tree stmt;\n-  vdef_optype vdefs;\n   bool may_optimize_p;\n   bool may_have_exposed_new_symbols = false;\n   struct dom_walk_block_data *bd\n@@ -2575,7 +2591,6 @@ optimize_stmt (struct dom_walk_data *walk_data,\n \n   get_stmt_operands (stmt);\n   ann = stmt_ann (stmt);\n-  vdefs = VDEF_OPS (ann);\n   opt_stats.num_stmts++;\n   may_have_exposed_new_symbols = false;\n \n@@ -2585,7 +2600,7 @@ optimize_stmt (struct dom_walk_data *walk_data,\n       print_generic_stmt (dump_file, stmt, TDF_SLIM);\n     }\n \n-  /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */\n+  /* Const/copy propagate into USES, VUSES and the RHS of V_MAY_DEFs.  */\n   may_have_exposed_new_symbols = cprop_into_stmt (stmt, const_and_copies);\n \n   /* If the statement has been modified with constant replacements,\n@@ -3171,7 +3186,8 @@ static void\n register_definitions_for_stmt (stmt_ann_t ann, varray_type *block_defs_p)\n {\n   def_optype defs;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   unsigned int i;\n \n   defs = DEF_OPS (ann);\n@@ -3185,12 +3201,21 @@ register_definitions_for_stmt (stmt_ann_t ann, varray_type *block_defs_p)\n     }\n \n   /* Register new virtual definitions made by the statement.  */\n-  vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    {\n+      /* FIXME: We shouldn't be registering new defs if the variable\n+\t doesn't need to be renamed.  */\n+      register_new_def (V_MAY_DEF_RESULT (v_may_defs, i), block_defs_p);\n+    }\n+    \n+  /* Register new virtual mustdefs made by the statement.  */\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n     {\n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n-      register_new_def (VDEF_RESULT (vdefs, i), block_defs_p);\n+      register_new_def (V_MUST_DEF_OP (v_must_defs, i), block_defs_p);\n     }\n }\n "}, {"sha": "88ca1363c875f009f305851001460d231f29657c", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -95,7 +95,7 @@ static void dse_optimize_stmt (struct dom_walk_data *,\n static void dse_record_phis (struct dom_walk_data *, basic_block);\n static void dse_finalize_block (struct dom_walk_data *, basic_block);\n static void fix_phi_uses (tree, tree);\n-static void fix_stmt_vdefs (tree, tree);\n+static void fix_stmt_v_may_defs (tree, tree);\n static void record_voperand_set (bitmap, bitmap *, unsigned int);\n \n /* Function indicating whether we ought to include information for 'var'\n@@ -109,70 +109,71 @@ need_imm_uses_for (tree var)\n }\n \n \n-/* Replace uses in PHI which match VDEF_RESULTs in STMT with the \n-   corresponding VDEF_OP in STMT.  */\n+/* Replace uses in PHI which match V_MAY_DEF_RESULTs in STMT with the \n+   corresponding V_MAY_DEF_OP in STMT.  */\n \n static void\n fix_phi_uses (tree phi, tree stmt)\n {\n   stmt_ann_t ann = stmt_ann (stmt);\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   unsigned int i;\n   int j;\n \n   get_stmt_operands (stmt);\n-  vdefs = VDEF_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n \n-  /* Walk each VDEF in STMT.  */\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  /* Walk each V_MAY_DEF in STMT.  */\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      tree vdef = VDEF_RESULT (vdefs, i);\n+      tree v_may_def = V_MAY_DEF_RESULT (v_may_defs, i);\n \n-      /* Find any uses in the PHI which match VDEF and replace\n-\t them with the appropriate VDEF_OP.  */\n+      /* Find any uses in the PHI which match V_MAY_DEF and replace\n+\t them with the appropriate V_MAY_DEF_OP.  */\n       for (j = 0; j < PHI_NUM_ARGS (phi); j++)\n-\tif (vdef == PHI_ARG_DEF (phi, j))\n-\t  PHI_ARG_DEF (phi, j) = VDEF_OP (vdefs, i);\n+\tif (v_may_def == PHI_ARG_DEF (phi, j))\n+\t  PHI_ARG_DEF (phi, j) = V_MAY_DEF_OP (v_may_defs, i);\n     }\n }\n \n-/* Replace the VDEF_OPs in STMT1 which match VDEF_RESULTs in STMT2 with\n-   the appropriate VDEF_OPs from STMT2.  */\n+/* Replace the V_MAY_DEF_OPs in STMT1 which match V_MAY_DEF_RESULTs \n+   in STMT2 with the appropriate V_MAY_DEF_OPs from STMT2.  */\n \n static void\n-fix_stmt_vdefs (tree stmt1, tree stmt2)\n+fix_stmt_v_may_defs (tree stmt1, tree stmt2)\n {\n   stmt_ann_t ann1 = stmt_ann (stmt1);\n   stmt_ann_t ann2 = stmt_ann (stmt2);\n-  vdef_optype vdefs1;\n-  vdef_optype vdefs2;\n+  v_may_def_optype v_may_defs1;\n+  v_may_def_optype v_may_defs2;\n   unsigned int i, j;\n \n   get_stmt_operands (stmt1);\n   get_stmt_operands (stmt2);\n-  vdefs1 = VDEF_OPS (ann1);\n-  vdefs2 = VDEF_OPS (ann2);\n+  v_may_defs1 = V_MAY_DEF_OPS (ann1);\n+  v_may_defs2 = V_MAY_DEF_OPS (ann2);\n \n-  /* Walk each VDEF_OP in stmt1.  */\n-  for (i = 0; i < NUM_VDEFS (vdefs1); i++)\n+  /* Walk each V_MAY_DEF_OP in stmt1.  */\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs1); i++)\n     {\n-      tree vdef1 = VDEF_OP (vdefs1, i);\n+      tree v_may_def1 = V_MAY_DEF_OP (v_may_defs1, i);\n \n-      /* Find the appropriate VDEF_RESULT in STMT2.  */\n-      for (j = 0; j < NUM_VDEFS (vdefs2); j++)\n+      /* Find the appropriate V_MAY_DEF_RESULT in STMT2.  */\n+      for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs2); j++)\n \t{\n-\t  if (vdef1 == VDEF_RESULT (vdefs2, j))\n+\t  if (v_may_def1 == V_MAY_DEF_RESULT (v_may_defs2, j))\n \t    {\n \t      /* Update.  */\n-\t      *VDEF_OP_PTR (vdefs1, i) = VDEF_OP (vdefs2, j);\n+\t      *V_MAY_DEF_OP_PTR (v_may_defs1, i) = \n+\t                        V_MAY_DEF_OP (v_may_defs2, j);\n \t      break;\n \t    }\n \t}\n \n #ifdef ENABLE_CHECKING\n-      /* If we did not find a corresponding VDEF_RESULT, then something\n+      /* If we did not find a corresponding V_MAY_DEF_RESULT, then something\n \t has gone terribly wrong.  */\n-      if (j == NUM_VDEFS (vdefs2))\n+      if (j == NUM_V_MAY_DEFS (v_may_defs2))\n \tabort ();\n #endif\n \n@@ -234,14 +235,14 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n   struct dse_global_data *dse_gd = walk_data->global_data;\n   tree stmt = bsi_stmt (bsi);\n   stmt_ann_t ann = stmt_ann (stmt);\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n \n   get_stmt_operands (stmt);\n-  vdefs = VDEF_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n \n   /* If this statement has no virtual uses, then there is nothing\n      to do.  */\n-  if (NUM_VDEFS (vdefs) == 0)\n+  if (NUM_V_MAY_DEFS (v_may_defs) == 0)\n     return;\n \n   /* We know we have virtual definitions.  If this is a MODIFY_EXPR, then\n@@ -269,7 +270,7 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t represents the only use of this store.\n \n \t Note this does not handle the case where the store has\n-\t multiple VDEFs which all reach a set of PHI nodes in the\n+\t multiple V_MAY_DEFs which all reach a set of PHI nodes in the\n \t same block.  */\n       while (num_uses == 1\n \t     && TREE_CODE (use) == PHI_NODE\n@@ -300,7 +301,7 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t  if (skipped_phi)\n \t    fix_phi_uses (skipped_phi, stmt);\n \t  else\n-\t    fix_stmt_vdefs (use, stmt);\n+\t    fix_stmt_v_may_defs (use, stmt);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n             {"}, {"sha": "388e2e37cc691f284510a4f9fe71b5b37e9bcd69", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -298,7 +298,8 @@ create_ssa_var_map (int flags)\n   tree stmt;\n   stmt_ann_t ann;\n   vuse_optype vuses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   use_optype uses;\n   def_optype defs;\n   unsigned x;\n@@ -383,16 +384,26 @@ create_ssa_var_map (int flags)\n #endif\n \t    }\n \n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (x = 0; x < NUM_VDEFS (vdefs); x++)\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (x = 0; x < NUM_V_MAY_DEFS (v_may_defs); x++)\n \t    {\n-\t      tree var = VDEF_OP (vdefs, x);\n+\t      tree var = V_MAY_DEF_OP (v_may_defs, x);\n \t      set_is_used (var);\n \n #if defined ENABLE_CHECKING\n \t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (var))->uid);\n #endif\n \t    }\n+\t    \n+\t  v_must_defs = V_MUST_DEF_OPS (ann);\n+\t  for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n+\t    {\n+\t      tree var = V_MUST_DEF_OP (v_must_defs, x);\n+\t      set_is_used (var);\n+#if defined ENABLE_CHECKING\n+\t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (var))->uid);\n+#endif\n+\t    }\t    \n \t}\n     }\n "}, {"sha": "bbcba9c98db4907d859c2653d71a0556009ef76f", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -104,8 +104,9 @@ mark_defs_for_rewrite (basic_block bb)\n   block_stmt_iterator bsi;\n   stmt_ann_t ann;\n   def_optype defs;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   vuse_optype vuses;\n+  v_must_def_optype v_must_defs;\n   unsigned i;\n \n   for (stmt = phi_nodes (bb); stmt; stmt = TREE_CHAIN (stmt))\n@@ -141,16 +142,23 @@ mark_defs_for_rewrite (basic_block bb)\n \t    bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t}\n \n-      vdefs = VDEF_OPS (ann);\n-      for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+      v_may_defs = V_MAY_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n \t{\n-\t  var = SSA_NAME_VAR (VDEF_RESULT (vdefs, i));\n+\t  var = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, i));\n+\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t}\n+\t\n+      v_must_defs = V_MUST_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\t{\n+\t  var = SSA_NAME_VAR (V_MUST_DEF_OP (v_must_defs, i));\n \t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t}\n \n       /* We also need to rewrite vuses, since we will copy the statements\n \t and the ssa versions could not be recovered in the copy.  We do\n-\t not have to do this for operands of VDEFS explicitly, since\n+\t not have to do this for operands of V_MAY_DEFS explicitly, since\n \t they have the same underlying variable as the results.  */\n       vuses = VUSE_OPS (ann);\n       for (i = 0; i < NUM_VUSES (vuses); i++)"}, {"sha": "eae021ecf80f17d91eefb62bbf425b161fca6ff3", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 234, "deletions": 75, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -37,9 +37,13 @@ Boston, MA 02111-1307, USA.  */\n /* By default, operands are loaded.  */\n #define opf_none\t0\n \n-/* Operand is the target of an assignment expression.  */\n+/* Operand is the target of an assignment expression or a \n+   call-clobbered variable  */\n #define opf_is_def \t(1 << 0)\n \n+/* Operand is the target of an assignment expression.  */\n+#define opf_kill_def \t(1 << 2)\n+\n /* No virtual operands should be created in the expression.  This is used\n    when traversing ADDR_EXPR nodes which have different semantics than\n    other expressions.  Inside an ADDR_EXPR node, the only operands that we\n@@ -54,27 +58,32 @@ static GTY (()) varray_type build_defs;\n /* Array for building all the use operands.  */\n static GTY (()) varray_type build_uses;\n \n-/* Array for building all the vdef operands.  */\n-static GTY (()) varray_type build_vdefs;\n+/* Array for building all the v_may_def operands.  */\n+static GTY (()) varray_type build_v_may_defs;\n \n /* Array for building all the vuse operands.  */\n static GTY (()) varray_type build_vuses;\n \n+/* Array for building all the v_must_def operands.  */\n+static GTY (()) varray_type build_v_must_defs;\n+\n #ifdef ENABLE_CHECKING\n tree check_build_stmt;\n #endif\n \n typedef struct voperands_d \n {\n-  vdef_optype vdef_ops;\n+  v_may_def_optype v_may_def_ops;\n   vuse_optype vuse_ops;\n+  v_must_def_optype v_must_def_ops;\n } *voperands_t;\n \n static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int, voperands_t);\n static inline void append_def (tree *, tree);\n static inline void append_use (tree *, tree);\n-static void append_vdef (tree, tree, voperands_t);\n+static void append_v_may_def (tree, tree, voperands_t);\n+static void append_v_must_def (tree, tree, voperands_t);\n static void add_call_clobber_ops (tree, voperands_t);\n static void add_call_read_ops (tree, voperands_t);\n static void add_stmt_operand (tree *, tree, int, voperands_t);\n@@ -85,8 +94,8 @@ struct freelist_d GTY((chain_next (\"%h.next\")))\n    struct freelist_d *next;\n };\n \n-#define NUM_FREE\t4\n-static GTY ((length (\"NUM_FREE\"))) struct freelist_d optype_freelist[NUM_FREE] = { {0}, {0}, {0}, {0} };\n+#define NUM_FREE\t5\n+static GTY ((length (\"NUM_FREE\"))) struct freelist_d optype_freelist[NUM_FREE] = { {0}, {0}, {0}, {0}, {0} };\n \n \n static inline void *\n@@ -155,17 +164,17 @@ allocate_use_optype (unsigned num)\n   return use_ops;\n }\n \n-static inline vdef_optype\n-allocate_vdef_optype (unsigned num)\n+static inline v_may_def_optype\n+allocate_v_may_def_optype (unsigned num)\n {\n-  vdef_optype vdef_ops;\n+  v_may_def_optype v_may_def_ops;\n   unsigned size;\n-  size = sizeof (struct vdef_optype_d) + sizeof (tree) * ((num * 2) - 1);\n-  vdef_ops = check_optype_freelist (num * 2);\n-  if (!vdef_ops)\n-    vdef_ops =  ggc_alloc (size);\n-  vdef_ops->num_vdefs = num;\n-  return vdef_ops;\n+  size = sizeof (struct v_may_def_optype_d) + sizeof (tree) * ((num * 2) - 1);\n+  v_may_def_ops = check_optype_freelist (num * 2);\n+  if (!v_may_def_ops)\n+    v_may_def_ops =  ggc_alloc (size);\n+  v_may_def_ops->num_v_may_defs = num;\n+  return v_may_def_ops;\n }\n \n static inline vuse_optype\n@@ -181,6 +190,19 @@ allocate_vuse_optype (unsigned num)\n   return vuse_ops;\n }\n \n+static inline v_must_def_optype\n+allocate_v_must_def_optype (unsigned num)\n+{\n+  v_must_def_optype v_must_def_ops;\n+  unsigned size;\n+  size = sizeof (struct v_must_def_optype_d) + sizeof (tree *) * (num - 1);\n+  v_must_def_ops = check_optype_freelist (num);\n+  if (!v_must_def_ops)\n+    v_must_def_ops =  ggc_alloc (size);\n+  v_must_def_ops->num_v_must_defs = num;\n+  return v_must_def_ops;\n+}\n+\n static inline void\n free_uses (use_optype *uses, bool dealloc)\n {\n@@ -215,13 +237,24 @@ free_vuses (vuse_optype *vuses, bool dealloc)\n }\n \n static inline void\n-free_vdefs (vdef_optype *vdefs, bool dealloc)\n+free_v_may_defs (v_may_def_optype *v_may_defs, bool dealloc)\n+{\n+  if (*v_may_defs)\n+    {\n+      if (dealloc)\n+\tadd_optype_freelist (*v_may_defs, (*v_may_defs)->num_v_may_defs);\n+      *v_may_defs = NULL;\n+    }\n+}\n+\n+static inline void\n+free_v_must_defs (v_must_def_optype *v_must_defs, bool dealloc)\n {\n-  if (*vdefs)\n+  if (*v_must_defs)\n     {\n       if (dealloc)\n-\tadd_optype_freelist (*vdefs, (*vdefs)->num_vdefs);\n-      *vdefs = NULL;\n+\tadd_optype_freelist (*v_must_defs, (*v_must_defs)->num_v_must_defs);\n+      *v_must_defs = NULL;\n     }\n }\n \n@@ -236,15 +269,24 @@ remove_vuses (tree stmt)\n }\n \n void\n-remove_vdefs (tree stmt)\n+remove_v_may_defs (tree stmt)\n {\n   stmt_ann_t ann;\n \n   ann = stmt_ann (stmt);\n   if (ann)\n-    free_vdefs (&(ann->vdef_ops), true);\n+    free_v_may_defs (&(ann->v_may_def_ops), true);\n }\n \n+void\n+remove_v_must_defs (tree stmt)\n+{\n+  stmt_ann_t ann;\n+\n+  ann = stmt_ann (stmt);\n+  if (ann)\n+    free_v_must_defs (&(ann->v_must_def_ops), true);\n+}\n \n void\n init_ssa_operands (void)\n@@ -253,8 +295,9 @@ init_ssa_operands (void)\n \n   VARRAY_TREE_PTR_INIT (build_defs, 5, \"build defs\");\n   VARRAY_TREE_PTR_INIT (build_uses, 10, \"build uses\");\n-  VARRAY_TREE_INIT (build_vdefs, 10, \"build vdefs\");\n+  VARRAY_TREE_INIT (build_v_may_defs, 10, \"build v_may_defs\");\n   VARRAY_TREE_INIT (build_vuses, 10, \"build vuses\");\n+  VARRAY_TREE_INIT (build_v_must_defs, 10, \"build v_must_defs\");\n \n   for (x = 0; x < NUM_FREE; x++)\n     optype_freelist[x].next = NULL;\n@@ -328,29 +371,29 @@ finalize_ssa_uses (tree stmt)\n }\n \n static void\n-finalize_ssa_vdefs (tree stmt)\n+finalize_ssa_v_may_defs (tree stmt)\n {\n   unsigned num, x;\n-  vdef_optype vdef_ops;\n+  v_may_def_optype v_may_def_ops;\n   stmt_ann_t ann;\n \n-  num = VARRAY_ACTIVE_SIZE (build_vdefs);\n+  num = VARRAY_ACTIVE_SIZE (build_v_may_defs);\n   if (num == 0)\n     return;\n \n #ifdef ENABLE_CHECKING\n-  /* VDEFs must be entered in pairs of result/uses.  */\n+  /* V_MAY_DEFs must be entered in pairs of result/uses.  */\n   if (num % 2 != 0)\n     abort();\n #endif\n \n-  vdef_ops = allocate_vdef_optype (num / 2);\n+  v_may_def_ops = allocate_v_may_def_optype (num / 2);\n   for (x = 0; x < num; x++)\n-    vdef_ops->vdefs[x] = VARRAY_TREE (build_vdefs, x);\n-  VARRAY_CLEAR (build_vdefs);\n+    v_may_def_ops->v_may_defs[x] = VARRAY_TREE (build_v_may_defs, x);\n+  VARRAY_CLEAR (build_v_may_defs);\n \n   ann = stmt_ann (stmt);\n-  ann->vdef_ops = vdef_ops;\n+  ann->v_may_def_ops = v_may_def_ops;\n }\n \n static inline void\n@@ -359,12 +402,12 @@ finalize_ssa_vuses (tree stmt)\n   unsigned num, x;\n   stmt_ann_t ann;\n   vuse_optype vuse_ops;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n \n #ifdef ENABLE_CHECKING\n-  if (VARRAY_ACTIVE_SIZE (build_vdefs) > 0)\n+  if (VARRAY_ACTIVE_SIZE (build_v_may_defs) > 0)\n     {\n-      fprintf (stderr, \"Please finalize VDEFs before finalize VUSES.\\n\");\n+      fprintf (stderr, \"Please finalize V_MAY_DEFs before finalize VUSES.\\n\");\n       abort ();\n     }\n #endif\n@@ -374,42 +417,42 @@ finalize_ssa_vuses (tree stmt)\n     return;\n \n   /* Remove superfluous VUSE operands.  If the statement already has a\n-   VDEF operation for a variable 'a', then a VUSE for 'a' is not\n-   needed because VDEFs imply a VUSE of the variable.  For instance,\n+   V_MAY_DEF operation for a variable 'a', then a VUSE for 'a' is not\n+   needed because V_MAY_DEFs imply a VUSE of the variable.  For instance,\n    suppose that variable 'a' is aliased:\n \n \t      # VUSE <a_2>\n-\t      # a_3 = VDEF <a_2>\n+\t      # a_3 = V_MAY_DEF <a_2>\n \t      a = a + 1;\n \n-  The VUSE <a_2> is superfluous because it is implied by the VDEF\n+  The VUSE <a_2> is superfluous because it is implied by the V_MAY_DEF\n   operation.  */\n \n   ann = stmt_ann (stmt);\n-  vdefs = VDEF_OPS (ann);\n-  if (NUM_VDEFS (vdefs) > 0)\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  if (NUM_V_MAY_DEFS (v_may_defs) > 0)\n     {\n       size_t i, j;\n       for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vuses); i++)\n \t{\n \t  bool found = false;\n-\t  for (j = 0; j < NUM_VDEFS (vdefs); j++)\n+\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n-\t      tree vuse_var, vdef_var;\n+\t      tree vuse_var, v_may_def_var;\n \t      tree vuse = VARRAY_TREE (build_vuses, i);\n-\t      tree vdef = VDEF_OP (vdefs, j);\n+\t      tree v_may_def = V_MAY_DEF_OP (v_may_defs, j);\n \n \t      if (TREE_CODE (vuse) == SSA_NAME)\n \t\tvuse_var = SSA_NAME_VAR (vuse);\n \t      else\n \t\tvuse_var = vuse;\n \n-\t      if (TREE_CODE (vdef) == SSA_NAME)\n-\t\tvdef_var = SSA_NAME_VAR (vdef);\n+\t      if (TREE_CODE (v_may_def) == SSA_NAME)\n+\t\tv_may_def_var = SSA_NAME_VAR (v_may_def);\n \t      else\n-\t\tvdef_var = vdef;\n+\t\tv_may_def_var = v_may_def;\n \n-\t    if (vuse_var == vdef_var)\n+\t    if (vuse_var == v_may_def_var)\n \t      {\n \t\tfound = true;\n \t\tbreak;\n@@ -450,6 +493,32 @@ finalize_ssa_vuses (tree stmt)\n   ann->vuse_ops = vuse_ops;\n }\n \n+static void\n+finalize_ssa_v_must_defs (tree stmt)\n+{\n+  unsigned num, x;\n+  stmt_ann_t ann;\n+  v_must_def_optype v_must_def_ops;\n+\n+  num = VARRAY_ACTIVE_SIZE (build_v_must_defs);\n+  if (num == 0)\n+    return;\n+\n+#ifdef ENABLE_CHECKING\n+  /* There should only be a single V_MUST_DEF per assignment.  */\n+  if (TREE_CODE (stmt) == MODIFY_EXPR && num > 1)\n+    abort ();\n+#endif\n+\n+  v_must_def_ops = allocate_v_must_def_optype (num);\n+  for (x = 0; x < num ; x++)\n+    v_must_def_ops->v_must_defs[x] = VARRAY_TREE (build_v_must_defs, x);\n+  VARRAY_POP_ALL (build_v_must_defs);\n+\n+  ann = stmt_ann (stmt);\n+  ann->v_must_def_ops = v_must_def_ops;\n+}\n+\n extern void\n finalize_ssa_stmt_operands (tree stmt)\n {\n@@ -460,7 +529,8 @@ finalize_ssa_stmt_operands (tree stmt)\n \n   finalize_ssa_defs (stmt);\n   finalize_ssa_uses (stmt);\n-  finalize_ssa_vdefs (stmt);\n+  finalize_ssa_v_must_defs (stmt);\n+  finalize_ssa_v_may_defs (stmt);\n   finalize_ssa_vuses (stmt);\n \n #ifdef ENABLE_CHECKING\n@@ -476,7 +546,8 @@ verify_start_operands (tree stmt ATTRIBUTE_UNUSED)\n   if (VARRAY_ACTIVE_SIZE (build_defs) > 0 \n       || VARRAY_ACTIVE_SIZE (build_uses) > 0\n       || VARRAY_ACTIVE_SIZE (build_vuses) > 0\n-      || VARRAY_ACTIVE_SIZE (build_vdefs) > 0)\n+      || VARRAY_ACTIVE_SIZE (build_v_may_defs) > 0\n+      || VARRAY_ACTIVE_SIZE (build_v_must_defs) > 0)\n     abort ();\n   if (check_build_stmt != NULL)\n     abort();\n@@ -517,7 +588,7 @@ append_use (tree *use_p, tree stmt ATTRIBUTE_UNUSED)\n    operands.  */\n \n static void\n-append_vdef (tree var, tree stmt, voperands_t prev_vops)\n+append_v_may_def (tree var, tree stmt, voperands_t prev_vops)\n {\n   stmt_ann_t ann;\n   size_t i;\n@@ -532,42 +603,42 @@ append_vdef (tree var, tree stmt, voperands_t prev_vops)\n \n   /* Don't allow duplicate entries.  */\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_vdefs); i += 2)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_may_defs); i += 2)\n     {\n-      tree result = VARRAY_TREE (build_vdefs, i);\n+      tree result = VARRAY_TREE (build_v_may_defs, i);\n       if (var == result\n \t  || (TREE_CODE (result) == SSA_NAME\n \t      && var == SSA_NAME_VAR (result)))\n \treturn;\n     }\n \n   /* If the statement already had virtual definitions, see if any of the\n-     existing VDEFs matches VAR.  If so, re-use it, otherwise add a new\n-     VDEF for VAR.  */\n+     existing V_MAY_DEFs matches VAR.  If so, re-use it, otherwise add a new\n+     V_MAY_DEF for VAR.  */\n   result = NULL_TREE;\n   source = NULL_TREE;\n   if (prev_vops)\n-    for (i = 0; i < NUM_VDEFS (prev_vops->vdef_ops); i++)\n+    for (i = 0; i < NUM_V_MAY_DEFS (prev_vops->v_may_def_ops); i++)\n       {\n-\tresult = VDEF_RESULT (prev_vops->vdef_ops, i);\n+\tresult = V_MAY_DEF_RESULT (prev_vops->v_may_def_ops, i);\n \tif (result == var\n \t    || (TREE_CODE (result) == SSA_NAME\n \t\t&& SSA_NAME_VAR (result) == var))\n \t  {\n-\t    source = VDEF_OP (prev_vops->vdef_ops, i);\n+\t    source = V_MAY_DEF_OP (prev_vops->v_may_def_ops, i);\n \t    break;\n \t  }\n       }\n \n-  /* If no previous VDEF operand was found for VAR, create one now.  */\n+  /* If no previous V_MAY_DEF operand was found for VAR, create one now.  */\n   if (source == NULL_TREE)\n     {\n       result = var;\n       source = var;\n     }\n \n-  VARRAY_PUSH_TREE (build_vdefs, result);\n-  VARRAY_PUSH_TREE (build_vdefs, source);\n+  VARRAY_PUSH_TREE (build_v_may_defs, result);\n+  VARRAY_PUSH_TREE (build_v_may_defs, source);\n }\n \n \n@@ -626,6 +697,61 @@ append_vuse (tree var, tree stmt, voperands_t prev_vops)\n   VARRAY_PUSH_TREE (build_vuses, var);\n }\n \n+/* Add VAR to the list of virtual must definitions for STMT.  If PREV_VOPS\n+   is not NULL, the existing entries are preserved and no new entries are\n+   added here.  This is done to preserve the SSA numbering of virtual\n+   operands.  */\n+\n+static void\n+append_v_must_def (tree var, tree stmt, voperands_t prev_vops)\n+{\n+  stmt_ann_t ann;\n+  size_t i;\n+  bool found;\n+  tree v_must_def;\n+\n+#ifdef ENABLE_CHECKING\n+  if (check_build_stmt != stmt)\n+    abort();\n+#endif\n+\n+  ann = stmt_ann (stmt);\n+\n+  /* Don't allow duplicate entries.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (build_v_must_defs); i++)\n+    {\n+      tree v_must_def_var = VARRAY_TREE (build_v_must_defs, i);\n+      if (var == v_must_def_var\n+\t  || (TREE_CODE (v_must_def_var) == SSA_NAME\n+\t      && var == SSA_NAME_VAR (v_must_def_var)))\n+\treturn;\n+    }\n+\n+  /* If the statement already had virtual must defs, see if any of the\n+     existing V_MUST_DEFs matches VAR.  If so, re-use it, otherwise add a new\n+     V_MUST_DEF for VAR.  */\n+  found = false;\n+  v_must_def = NULL_TREE;\n+  if (prev_vops)\n+    for (i = 0; i < NUM_V_MUST_DEFS (prev_vops->v_must_def_ops); i++)\n+      {\n+\tv_must_def = V_MUST_DEF_OP (prev_vops->v_must_def_ops, i);\n+\tif (v_must_def == var\n+\t    || (TREE_CODE (v_must_def) == SSA_NAME\n+\t\t&& SSA_NAME_VAR (v_must_def) == var))\n+\t  {\n+\t    found = true;\n+\t    break;\n+\t  }\n+      }\n+\n+  /* If VAR existed already in PREV_VOPS, re-use it.  */\n+  if (found)\n+    var = v_must_def;\n+\n+  VARRAY_PUSH_TREE (build_v_must_defs, var);\n+}\n+\n \n /* External entry point which by-passes the previous vops mechanism.  */\n void\n@@ -676,12 +802,14 @@ get_stmt_operands (tree stmt)\n \n   /* Before removing existing virtual operands, save them in PREV_VOPS so \n      that we can re-use their SSA versions.  */\n-  prev_vops.vdef_ops = VDEF_OPS (ann);\n+  prev_vops.v_may_def_ops = V_MAY_DEF_OPS (ann);\n   prev_vops.vuse_ops = VUSE_OPS (ann);\n+  prev_vops.v_must_def_ops = V_MUST_DEF_OPS (ann);\n \n   /* Dont free the previous values to memory since we're still using them.  */\n-  free_vdefs (&(ann->vdef_ops), false);\n+  free_v_may_defs (&(ann->v_may_def_ops), false);\n   free_vuses (&(ann->vuse_ops), false);\n+  free_v_must_defs (&(ann->v_must_def_ops), false);\n \n   start_ssa_stmt_operands (stmt);\n \n@@ -690,7 +818,15 @@ get_stmt_operands (tree stmt)\n     {\n     case MODIFY_EXPR:\n       get_expr_operands (stmt, &TREE_OPERAND (stmt, 1), opf_none, &prev_vops);\n-      get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_is_def, &prev_vops);\n+      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_REF \n+          || TREE_CODE (TREE_OPERAND (stmt, 0)) == COMPONENT_REF\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == REALPART_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == IMAGPART_EXPR)\n+        get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), opf_is_def, \n+\t                   &prev_vops);\n+      else\n+        get_expr_operands (stmt, &TREE_OPERAND (stmt, 0), \n+\t                   opf_is_def | opf_kill_def, &prev_vops);\n       break;\n \n     case COND_EXPR:\n@@ -792,8 +928,9 @@ get_stmt_operands (tree stmt)\n   finalize_ssa_stmt_operands (stmt);\n \n   /* Now free the previous virtual ops to memory.  */\n-  free_vdefs (&(prev_vops.vdef_ops), true);\n+  free_v_may_defs (&(prev_vops.v_may_def_ops), true);\n   free_vuses (&(prev_vops.vuse_ops), true);\n+  free_v_must_defs (&(prev_vops.v_must_def_ops), true);\n \n   /* Clear the modified bit for STMT.  Subsequent calls to\n      get_stmt_operands for this statement will do nothing until the\n@@ -806,7 +943,7 @@ get_stmt_operands (tree stmt)\n \n /* Recursively scan the expression pointed by EXPR_P in statement STMT.\n    FLAGS is one of the OPF_* constants modifying how to interpret the\n-   operands found.  PREV_VOPS is as in append_vdef and append_vuse.  */\n+   operands found.  PREV_VOPS is as in append_v_may_def and append_vuse.  */\n \n static void\n get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n@@ -1053,7 +1190,15 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n   if (code == MODIFY_EXPR)\n     {\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none, prev_vops);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_is_def, prev_vops);\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == ARRAY_REF \n+          || TREE_CODE (TREE_OPERAND (expr, 0)) == COMPONENT_REF\n+\t  || TREE_CODE (TREE_OPERAND (expr, 0)) == REALPART_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (expr, 0)) == IMAGPART_EXPR)\n+        get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_is_def, \n+\t                   prev_vops);\n+      else\n+        get_expr_operands (stmt, &TREE_OPERAND (expr, 0), \n+\t                   opf_is_def | opf_kill_def, prev_vops);\n       return;\n     }\n \n@@ -1104,7 +1249,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n    operands.\n \n    PREV_VOPS is used when adding virtual operands to statements that\n-      already had them (See append_vdef and append_vuse).  */\n+      already had them (See append_v_may_def and append_vuse).  */\n \n static void\n add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n@@ -1193,9 +1338,21 @@ add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n \t  /* The variable is not aliased or it is an alias tag.  */\n \t  if (flags & opf_is_def)\n \t    {\n-\t      append_vdef (var, stmt, prev_vops);\n \t      if (v_ann->is_alias_tag)\n-\t\ts_ann->makes_aliased_stores = 1;\n+\t        {\n+\t\t  /* Alias tagged vars get regular V_MAY_DEF  */\n+\t\t  s_ann->makes_aliased_stores = 1;\n+\t\t  append_v_may_def (var, stmt, prev_vops);\n+\t\t}\n+\t      else if ((flags & opf_kill_def) \n+\t                && v_ann->mem_tag_kind == NOT_A_TAG)\n+\t        /* V_MUST_DEF for non-aliased non-GIMPLE register \n+\t\t   variable definitions. Avoid memory tags.  */\n+\t        append_v_must_def (var, stmt, prev_vops);\n+\t      else\n+\t        /* Call-clobbered variables & memory tags get \n+\t\t   V_MAY_DEF  */\n+\t\tappend_v_may_def (var, stmt, prev_vops);\n \t    }\n \t  else\n \t    {\n@@ -1220,10 +1377,10 @@ add_stmt_operand (tree *var_p, tree stmt, int flags, voperands_t prev_vops)\n \t\t references to the members of the variable's alias set.\n \t\t This fixes the bug in gcc.c-torture/execute/20020503-1.c.  */\n \t      if (v_ann->is_alias_tag)\n-\t\tappend_vdef (var, stmt, prev_vops);\n+\t\tappend_v_may_def (var, stmt, prev_vops);\n \n \t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\tappend_vdef (VARRAY_TREE (aliases, i), stmt, prev_vops);\n+\t\tappend_v_may_def (VARRAY_TREE (aliases, i), stmt, prev_vops);\n \n \t      s_ann->makes_aliased_stores = 1;\n \t    }\n@@ -1267,9 +1424,10 @@ add_call_clobber_ops (tree stmt, voperands_t prev_vops)\n      call-clobbered variables.  */\n   stmt_ann (stmt)->makes_clobbering_call = true;\n \n-  /* If we had created .GLOBAL_VAR earlier, use it.  Otherwise, add a VDEF\n-     operand for every call clobbered variable.  See compute_may_aliases for\n-     the heuristic used to decide whether to create .GLOBAL_VAR or not.  */\n+  /* If we had created .GLOBAL_VAR earlier, use it.  Otherwise, add \n+     a V_MAY_DEF operand for every call clobbered variable.  See \n+     compute_may_aliases for the heuristic used to decide whether \n+     to create .GLOBAL_VAR or not.  */\n   if (global_var)\n     add_stmt_operand (&global_var, stmt, opf_is_def, prev_vops);\n   else\n@@ -1280,7 +1438,8 @@ add_call_clobber_ops (tree stmt, voperands_t prev_vops)\n \t{\n \t  tree var = referenced_var (i);\n \n-\t  /* If VAR is read-only, don't add a VDEF, just a VUSE operand.  */\n+\t  /* If VAR is read-only, don't add a V_MAY_DEF, just a \n+\t     VUSE operand.  */\n \t  if (!TREE_READONLY (var))\n \t    add_stmt_operand (&var, stmt, opf_is_def, prev_vops);\n \t  else"}, {"sha": "e83c776d11fef1fe3f9dae0137a4f1083b773726", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -39,13 +39,13 @@ typedef struct use_optype_d GTY(())\n \n typedef use_optype_t *use_optype;\n \n-typedef struct vdef_optype_d GTY(())\n+typedef struct v_may_def_optype_d GTY(())\n {\n-  unsigned num_vdefs; \n-  tree GTY((length (\"%h.num_vdefs * 2\"))) vdefs[1];\n-} vdef_optype_t;\n+  unsigned num_v_may_defs; \n+  tree GTY((length (\"%h.num_v_may_defs * 2\"))) v_may_defs[1];\n+} v_may_def_optype_t;\n \n-typedef vdef_optype_t *vdef_optype;\n+typedef v_may_def_optype_t *v_may_def_optype;\n \n typedef struct vuse_optype_d GTY(()) \n {\n@@ -55,6 +55,14 @@ typedef struct vuse_optype_d GTY(())\n \n typedef vuse_optype_t *vuse_optype;\n \n+typedef struct v_must_def_optype_d GTY(())\n+{\n+  unsigned num_v_must_defs; \n+  tree GTY((length(\"%h.num_v_must_defs\"))) v_must_defs[1];\n+} v_must_def_optype_t;\n+\n+typedef v_must_def_optype_t *v_must_def_optype;\n+\n #define USE_OPS(ANN)\t\tget_use_ops (ANN)\n #define STMT_USE_OPS(STMT)\tget_use_ops (stmt_ann (STMT))\n #define NUM_USES(OPS)\t\t((OPS) ? (OPS)->num_uses : 0)\n@@ -69,13 +77,13 @@ typedef vuse_optype_t *vuse_optype;\n #define DEF_OP(OPS, I)\t\t(*(DEF_OP_PTR ((OPS), (I))))\n \n \n-#define VDEF_OPS(ANN)\t\tget_vdef_ops (ANN)\n-#define STMT_VDEF_OPS(STMT)\tget_vdef_ops (stmt_ann(STMT))\n-#define NUM_VDEFS(OPS)\t\t((OPS) ? (OPS)->num_vdefs : 0)\n-#define VDEF_RESULT_PTR(OPS, I)\tget_vdef_result_ptr ((OPS), (I))\n-#define VDEF_RESULT(OPS, I)\t(*(VDEF_RESULT_PTR ((OPS), (I))))\n-#define VDEF_OP_PTR(OPS, I)\tget_vdef_op_ptr ((OPS), (I))\n-#define VDEF_OP(OPS, I)\t\t(*(VDEF_OP_PTR ((OPS), (I))))\n+#define V_MAY_DEF_OPS(ANN)\t\tget_v_may_def_ops (ANN)\n+#define STMT_V_MAY_DEF_OPS(STMT)\tget_v_may_def_ops (stmt_ann(STMT))\n+#define NUM_V_MAY_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_may_defs : 0)\n+#define V_MAY_DEF_RESULT_PTR(OPS, I)\tget_v_may_def_result_ptr ((OPS), (I))\n+#define V_MAY_DEF_RESULT(OPS, I)\t(*(V_MAY_DEF_RESULT_PTR ((OPS), (I))))\n+#define V_MAY_DEF_OP_PTR(OPS, I)\tget_v_may_def_op_ptr ((OPS), (I))\n+#define V_MAY_DEF_OP(OPS, I)\t\t(*(V_MAY_DEF_OP_PTR ((OPS), (I))))\n \n \n #define VUSE_OPS(ANN)\t\tget_vuse_ops (ANN)\n@@ -85,13 +93,20 @@ typedef vuse_optype_t *vuse_optype;\n #define VUSE_OP(OPS, I)  \t(*(VUSE_OP_PTR ((OPS), (I))))\n \n \n+#define V_MUST_DEF_OPS(ANN)\t\tget_v_must_def_ops (ANN)\n+#define STMT_V_MUST_DEF_OPS(STMT)\tget_v_must_def_ops (stmt_ann (STMT))\n+#define NUM_V_MUST_DEFS(OPS)\t\t((OPS) ? (OPS)->num_v_must_defs : 0)\n+#define V_MUST_DEF_OP_PTR(OPS, I)\tget_v_must_def_op_ptr ((OPS), (I))\n+#define V_MUST_DEF_OP(OPS, I)\t\t(*(V_MUST_DEF_OP_PTR ((OPS), (I))))\n+\n extern void init_ssa_operands (void);\n extern void fini_ssa_operands (void);\n extern void verify_start_operands (tree);\n extern void finalize_ssa_stmt_operands (tree);\n void add_vuse (tree, tree);\n extern void get_stmt_operands (tree);\n extern void remove_vuses (tree);\n-extern void remove_vdefs (tree);\n+extern void remove_v_may_defs (tree);\n+extern void remove_v_must_defs (tree);\n \n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "aa45e10ea79954164f1b49dc7a44ac8451329950", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -1312,7 +1312,8 @@ subst_phis (struct expr_info *ei, tree Z, basic_block pred, basic_block bb)\n   else\n     {\n       remove_vuses (stmt_copy);\n-      remove_vdefs (stmt_copy);\n+      remove_v_may_defs (stmt_copy);\n+      remove_v_must_defs (stmt_copy);\n     }\n \n   if (pred->index < n_phi_preds)\n@@ -3016,13 +3017,16 @@ process_left_occs_and_kills (varray_type bexprs, tree expr)\n {\n   size_t i, j, k;\n   \n-  stmt_ann_t ann = stmt_ann (expr);\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n   vuse_optype vuses;\n   def_optype defs;\n-  defs = DEF_OPS (ann);\n-  vdefs = VDEF_OPS (ann);\n-  if (NUM_DEFS (defs) == 0 && NUM_VDEFS (vdefs) == 0)\n+  defs = STMT_DEF_OPS (expr);\n+  v_may_defs = STMT_V_MAY_DEF_OPS (expr);\n+  v_must_defs = STMT_V_MUST_DEF_OPS (expr);\n+  if (NUM_DEFS (defs) == 0 \n+      && NUM_V_MAY_DEFS (v_may_defs) == 0 \n+      && NUM_V_MUST_DEFS (v_must_defs) == 0)\n     return;\n \n   for (j = 0; j < VARRAY_ACTIVE_SIZE (bexprs); j++)\n@@ -3052,19 +3056,36 @@ process_left_occs_and_kills (varray_type bexprs, tree expr)\n \t    }\n \t}\n       \n-      /* If we VDEF the VUSE of the expression, it's also a left\n+      /* If we virtually define the variable itself,\n+\t it's a left occurrence.  */\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\t{\n+\t  if (names_match_p (V_MUST_DEF_OP (v_must_defs, i), ei->expr))    \n+\t    {\n+\t      if (TREE_CODE (expr) == ASM_EXPR)\n+\t\t{\n+\t\t  ei->loadpre_cand = false;\n+\t\t  continue;\n+\t\t}\n+\t      VARRAY_PUSH_TREE (ei->lefts, expr);\n+\t      VARRAY_PUSH_TREE (ei->occurs, NULL);\n+\t      VARRAY_PUSH_TREE (ei->kills, NULL);\n+\t    }\n+\t}\n+      \n+      /* If we V_MAY_DEF the VUSE of the expression, it's also a left\n \t occurrence.  */\n       random_occur = VARRAY_TREE (ei->occurs, 0);\n       ann = stmt_ann (random_occur);\n       vuses = VUSE_OPS (ann);\n-      if (NUM_VDEFS (vdefs) != 0)\n+      if (NUM_V_MAY_DEFS (v_may_defs) != 0)\n \t{\n \t  for (k = 0; k < NUM_VUSES (vuses); k++)\n \t    {\n \t      vuse_name = VUSE_OP (vuses, k);\n-\t      for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+\t      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n \t\t{\n-\t\t  if (names_match_p (VDEF_OP (vdefs, i), vuse_name))\n+\t\t  if (names_match_p (V_MAY_DEF_OP (v_may_defs, i), vuse_name))\n \t\t    {\n \t\t      VARRAY_PUSH_TREE (ei->lefts, expr);\n \t\t      VARRAY_PUSH_TREE (ei->occurs, NULL);"}, {"sha": "52a61944e6efd9d16cebef48f20011828ec7b100", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -314,20 +314,21 @@ verify_ssa (void)\n \t  tree stmt;\n \t  stmt_ann_t ann;\n \t  unsigned int j;\n-\t  vdef_optype vdefs;\n+\t  v_may_def_optype v_may_defs;\n+\t  v_must_def_optype v_must_defs;\n \t  def_optype defs;\n \n \t  stmt = bsi_stmt (bsi);\n \t  ann = stmt_ann (stmt);\n \t  get_stmt_operands (stmt);\n \n-\t  vdefs = VDEF_OPS (ann);\n-\t  if (ann->makes_aliased_stores && NUM_VDEFS (vdefs) == 0)\n-\t    error (\"Makes aliased stores, but no VDEFS\");\n-\n-\t  for (j = 0; j < NUM_VDEFS (vdefs); j++)\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  if (ann->makes_aliased_stores && NUM_V_MAY_DEFS (v_may_defs) == 0)\n+\t    error (\"Makes aliased stores, but no V_MAY_DEFS\");\n+\t    \n+\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n-\t      tree op = VDEF_RESULT (vdefs, j);\n+\t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n \t      if (is_gimple_reg (op))\n \t\t{\n \t\t  error (\"Found a virtual definition for a GIMPLE register\");\n@@ -337,6 +338,20 @@ verify_ssa (void)\n \t\t}\n \t      err |= verify_def (bb, definition_block, op, stmt);\n \t    }\n+          \n+\t  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n+\t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n+\t    {\n+\t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n+\t      if (is_gimple_reg (op))\n+\t\t{\n+\t\t  error (\"Found a virtual must-def for a GIMPLE register\");\n+\t\t  debug_generic_stmt (op);\n+\t\t  debug_generic_stmt (stmt);\n+\t\t  err = true;\n+\t\t}\n+\t      err |= verify_def (bb, definition_block, op, stmt);\n+\t    }\n \n \t  defs = DEF_OPS (ann);\n \t  for (j = 0; j < NUM_DEFS (defs); j++)\n@@ -380,14 +395,14 @@ verify_ssa (void)\n \n       /* Now verify all the uses and vuses in every statement of the block. \n \n-\t Remember, the RHS of a VDEF is a use as well.  */\n+\t Remember, the RHS of a V_MAY_DEF is a use as well.  */\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \t  stmt_ann_t ann = stmt_ann (stmt);\n \t  unsigned int j;\n \t  vuse_optype vuses;\n-\t  vdef_optype vdefs;\n+\t  v_may_def_optype v_may_defs;\n \t  use_optype uses;\n \n \t  vuses = VUSE_OPS (ann); \n@@ -406,10 +421,10 @@ verify_ssa (void)\n \t\t\t\t op, stmt, false);\n \t    }\n \n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (j = 0; j < NUM_VDEFS (vdefs); j++)\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n \t    {\n-\t      tree op = VDEF_OP (vdefs, j);\n+\t      tree op = V_MAY_DEF_OP (v_may_defs, j);\n \n \t      if (is_gimple_reg (op))\n \t\t{\n@@ -699,7 +714,7 @@ replace_immediate_uses (tree var, tree repl)\n {\n   use_optype uses;\n   vuse_optype vuses;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   int i, j, n;\n   dataflow_t df;\n   tree stmt;\n@@ -742,10 +757,10 @@ replace_immediate_uses (tree var, tree repl)\n \t    if (VUSE_OP (vuses, j) == var)\n \t      propagate_value (VUSE_OP_PTR (vuses, j), repl);\n \n-\t  vdefs = VDEF_OPS (ann);\n-\t  for (j = 0; j < (int) NUM_VDEFS (vdefs); j++)\n-\t    if (VDEF_OP (vdefs, j) == var)\n-\t      propagate_value (VDEF_OP_PTR (vdefs, j), repl);\n+\t  v_may_defs = V_MAY_DEF_OPS (ann);\n+\t  for (j = 0; j < (int) NUM_V_MAY_DEFS (v_may_defs); j++)\n+\t    if (V_MAY_DEF_OP (v_may_defs, j) == var)\n+\t      propagate_value (V_MAY_DEF_OP_PTR (v_may_defs, j), repl);\n \t}\n \n       modify_stmt (stmt);"}, {"sha": "92626860f23b1426703f4dda0a0408a3cd89323c", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=a32b97a20d6638f3cee28919f4e6bd7b1d9b39e8", "patch": "@@ -391,7 +391,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \n       /* If the statement has virtual operands, fail.  */\n       ann = stmt_ann (stmt);\n-      if (NUM_VDEFS (VDEF_OPS (ann))\n+      if (NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann))\n+          || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann))\n \t  || NUM_VUSES (VUSE_OPS (ann)))\n \treturn;\n     }\n@@ -644,7 +645,7 @@ eliminate_tail_call (struct tailcall *t)\n   edge e;\n   tree phi;\n   stmt_ann_t ann;\n-  vdef_optype vdefs;\n+  v_may_def_optype v_may_defs;\n   unsigned i;\n \n   stmt = bsi_stmt (t->call_bsi);\n@@ -696,10 +697,10 @@ eliminate_tail_call (struct tailcall *t)\n     }\n \n   /* Add phi nodes for the call clobbered variables.  */\n-  vdefs = VDEF_OPS (ann);\n-  for (i = 0; i < NUM_VDEFS (vdefs); i++)\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n-      param = SSA_NAME_VAR (VDEF_RESULT (vdefs, i));\n+      param = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, i));\n       for (phi = phi_nodes (first); phi; phi = TREE_CHAIN (phi))\n \tif (param == SSA_NAME_VAR (PHI_RESULT (phi)))\n \t  break;\n@@ -721,7 +722,7 @@ eliminate_tail_call (struct tailcall *t)\n \t    abort ();\n \t}\n \n-      add_phi_arg (&phi, VDEF_OP (vdefs, i), e);\n+      add_phi_arg (&phi, V_MAY_DEF_OP (v_may_defs, i), e);\n     }\n \n   /* Update the values of accumulators.  */"}]}