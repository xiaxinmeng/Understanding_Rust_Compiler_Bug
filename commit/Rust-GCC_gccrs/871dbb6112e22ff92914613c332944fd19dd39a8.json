{"sha": "871dbb6112e22ff92914613c332944fd19dd39a8", "node_id": "C_kwDOANBUbNoAKDg3MWRiYjYxMTJlMjJmZjkyOTE0NjEzYzMzMjk0NGZkMTlkZDM5YTg", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2022-05-28T20:02:20Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2022-05-30T20:31:34Z"}, "message": "Fortran: improve runtime error message with ALLOCATE and ERRMSG= [PR91300]\n\nALLOCATE: generate different STAT,ERRMSG results for failures from\nallocation of already allocated objects or insufficient virtual memory.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/91300\n\t* libgfortran.h: Define new error code LIBERROR_NO_MEMORY.\n\t* trans-stmt.cc (gfc_trans_allocate): Generate code for setting\n\tERRMSG depending on result of STAT result of ALLOCATE.\n\t* trans.cc (gfc_allocate_using_malloc): Use STAT value of\n\tLIBERROR_NO_MEMORY in case of failed malloc.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/91300\n\t* gfortran.dg/allocate_alloc_opt_15.f90: New test.", "tree": {"sha": "a7e1aefb4901b2e443d8858908331132950b0883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7e1aefb4901b2e443d8858908331132950b0883"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/871dbb6112e22ff92914613c332944fd19dd39a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871dbb6112e22ff92914613c332944fd19dd39a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/871dbb6112e22ff92914613c332944fd19dd39a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871dbb6112e22ff92914613c332944fd19dd39a8/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1652e3343b1ec47035370801d9b9aca1f8b613f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1652e3343b1ec47035370801d9b9aca1f8b613f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1652e3343b1ec47035370801d9b9aca1f8b613f"}], "stats": {"total": 87, "additions": 82, "deletions": 5}, "files": [{"sha": "4328447be04b8e02d82fb66f4b5d984ba2bb2ac8", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=871dbb6112e22ff92914613c332944fd19dd39a8", "patch": "@@ -133,6 +133,7 @@ typedef enum\n   LIBERROR_CORRUPT_FILE,\n   LIBERROR_INQUIRE_INTERNAL_UNIT, /* Must be different from STAT_STOPPED_IMAGE.  */\n   LIBERROR_BAD_WAIT_ID,\n+  LIBERROR_NO_MEMORY,\n   LIBERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n }\n libgfortran_error_codes;"}, {"sha": "fd6d294147e21bc6ab40fefb5841b6fa205528e3", "filename": "gcc/fortran/trans-stmt.cc", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ffortran%2Ftrans-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ffortran%2Ftrans-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.cc?ref=871dbb6112e22ff92914613c332944fd19dd39a8", "patch": "@@ -7130,7 +7130,8 @@ gfc_trans_allocate (gfc_code * code)\n   if (code->expr1 && code->expr2)\n     {\n       const char *msg = \"Attempt to allocate an allocated object\";\n-      tree slen, dlen, errmsg_str;\n+      const char *oommsg = \"Insufficient virtual memory\";\n+      tree slen, dlen, errmsg_str, oom_str, oom_loc;\n       stmtblock_t errmsg_block;\n \n       gfc_init_block (&errmsg_block);\n@@ -7151,8 +7152,34 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t     gfc_default_character_kind);\n       dlen = gfc_finish_block (&errmsg_block);\n \n-      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n-\t\t\t     stat, build_int_cst (TREE_TYPE (stat), 0));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n+\t\t\t     stat, build_int_cst (TREE_TYPE (stat),\n+\t\t\t\t\t\t  LIBERROR_ALLOCATION));\n+\n+      tmp = build3_v (COND_EXPR, tmp,\n+\t\t      dlen, build_empty_stmt (input_location));\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      oom_str = gfc_create_var (pchar_type_node, \"OOMMSG\");\n+      oom_loc = gfc_build_localized_cstring_const (oommsg);\n+      gfc_add_modify (&errmsg_block, oom_str,\n+\t\t      gfc_build_addr_expr (pchar_type_node, oom_loc));\n+\n+      slen = build_int_cst (gfc_charlen_type_node, strlen (oommsg));\n+      dlen = gfc_get_expr_charlen (code->expr2);\n+      slen = fold_build2_loc (input_location, MIN_EXPR,\n+\t\t\t      TREE_TYPE (slen), dlen, slen);\n+\n+      gfc_trans_string_copy (&errmsg_block, dlen, errmsg,\n+\t\t\t     code->expr2->ts.kind,\n+\t\t\t     slen, oom_str,\n+\t\t\t     gfc_default_character_kind);\n+      dlen = gfc_finish_block (&errmsg_block);\n+\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n+\t\t\t     stat, build_int_cst (TREE_TYPE (stat),\n+\t\t\t\t\t\t  LIBERROR_NO_MEMORY));\n \n       tmp = build3_v (COND_EXPR, tmp,\n \t\t      dlen, build_empty_stmt (input_location));"}, {"sha": "912a206f2ed75d952d692217e960d3aa4eb78760", "filename": "gcc/fortran/trans.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ffortran%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ffortran%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.cc?ref=871dbb6112e22ff92914613c332944fd19dd39a8", "patch": "@@ -772,7 +772,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       if (newmem == NULL)\n       {\n         if (stat)\n-          *stat = LIBERROR_ALLOCATION;\n+\t  *stat = LIBERROR_NO_MEMORY;\n         else\n \t  runtime_error (\"Allocation would exceed memory limit\");\n       }\n@@ -807,7 +807,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n   if (status != NULL_TREE)\n     {\n       tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type, status,\n-\t\t\t     build_int_cst (status_type, LIBERROR_ALLOCATION));\n+\t\t\t     build_int_cst (status_type, LIBERROR_NO_MEMORY));\n       gfc_add_expr_to_block (&on_error, tmp);\n     }\n   else"}, {"sha": "3c26e8179cb9e66acaf0457ab183c36718437b25", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_15.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/871dbb6112e22ff92914613c332944fd19dd39a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_15.f90?ref=871dbb6112e22ff92914613c332944fd19dd39a8", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! PR fortran/91300 - runtime error message with allocate and errmsg=\n+! Contributed by zed.three\n+\n+program bigarray_prog\n+  use, intrinsic :: iso_c_binding, only: C_INTPTR_T\n+  implicit none\n+  real(4), dimension(:), allocatable :: array, bigarray\n+  integer                 :: stat1, stat2\n+  character(len=100)      :: errmsg1, errmsg2\n+  character(*), parameter :: no_error = \"no error\"\n+  integer(8), parameter :: n1 = huge (1_4) / 3          ! request more than 2GB\n+  integer(8), parameter :: n2 = huge (1_C_INTPTR_T) / 4 ! \"safe\" for 64bit\n+  integer(8), parameter :: bignumber = max (n1, n2)\n+\n+  stat1   = -1\n+  stat2   = -1\n+  errmsg1 = no_error\n+  errmsg2 = no_error\n+  allocate (array(1), stat=stat1, errmsg=errmsg1)\n+  if (stat1   /= 0       ) stop 1\n+  if (errmsg1 /= no_error) stop 1\n+\n+  ! Obtain stat, errmsg for attempt to allocate an allocated object\n+  allocate (array(1), stat=stat1, errmsg=errmsg1)\n+  if (stat1   == 0       ) stop 2\n+  if (errmsg1 == no_error) stop 2\n+\n+  ! Try to allocate very large object\n+  allocate (bigarray(bignumber), stat=stat2, errmsg=errmsg2)\n+  if (stat2 /= 0) then\n+     print *, \"stat1 =\", stat1\n+     print *, \"errmsg: \", trim (errmsg1)\n+     print *, \"stat2 =\", stat2\n+     print *, \"errmsg: \", trim (errmsg2)\n+     ! Ensure different results for stat, errmsg variables (all compilers)\n+     if (stat2   == stat1                           ) stop 3\n+     if (errmsg2 == no_error .or. errmsg2 == errmsg1) stop 4\n+\n+     ! Finally verify gfortran-specific error messages\n+     if (errmsg1 /= \"Attempt to allocate an allocated object\") stop 5\n+     if (errmsg2 /= \"Insufficient virtual memory\"            ) stop 6\n+  end if\n+\n+end program bigarray_prog\n+\n+! { dg-final { scan-tree-dump-times \"Attempt to allocate an allocated object\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"Insufficient virtual memory\" 4 \"original\" } }"}]}