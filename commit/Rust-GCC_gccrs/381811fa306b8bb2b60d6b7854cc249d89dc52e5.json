{"sha": "381811fa306b8bb2b60d6b7854cc249d89dc52e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxODExZmEzMDZiOGJiMmI2MGQ2Yjc4NTRjYzI0OWQ4OWRjNTJlNQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-04-23T16:19:26Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-04-23T16:19:26Z"}, "message": "[ARM] Rewrite vc<cond> NEON patterns to use RTL operations rather than UNSPECs\n\n\t* config/arm/iterators.md (GTGE, GTUGEU, COMPARISONS): New code\n\titerators.\n\t(cmp_op, cmp_type): New code attributes.\n\t(NEON_VCMP, NEON_VACMP): New int iterators.\n\t(cmp_op_unsp): New int attribute.\n\t* config/arm/neon.md (neon_vc<cmp_op><mode>): New define_expand.\n\t(neon_vceq<mode>): Delete.\n\t(neon_vc<cmp_op><mode>_insn): New pattern.\n\t(neon_vc<cmp_op_unsp><mode>_insn_unspec): Likewise.\n\t(neon_vcgeu<mode>): Delete.\n\t(neon_vcle<mode>): Likewise.\n\t(neon_vclt<mode>: Likewise.\n\t(neon_vcage<mode>): Likewise.\n\t(neon_vcagt<mode>): Likewise.\n\t(neon_vca<cmp_op><mode>): New define_expand.\n\t(neon_vca<cmp_op><mode>_insn): New pattern.\n\t(neon_vca<cmp_op_unsp><mode>_insn_unspec): Likewise.\n\n\t* gcc.target/arm/neon/pr51534.c: Update vcg* scan-assembly patterns\n\tto look for vcl* where appropriate.\n\nFrom-SVN: r222379", "tree": {"sha": "6dcaaaa4874067350a9fb8c452f51fccac53dd6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dcaaaa4874067350a9fb8c452f51fccac53dd6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/381811fa306b8bb2b60d6b7854cc249d89dc52e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381811fa306b8bb2b60d6b7854cc249d89dc52e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/381811fa306b8bb2b60d6b7854cc249d89dc52e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381811fa306b8bb2b60d6b7854cc249d89dc52e5/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14336fe34bde33193d5d28c432ff411ce3a2c507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14336fe34bde33193d5d28c432ff411ce3a2c507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14336fe34bde33193d5d28c432ff411ce3a2c507"}], "stats": {"total": 276, "additions": 165, "deletions": 111}, "files": [{"sha": "d36bae7c25171dc3e81611af5a9666841d52130e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=381811fa306b8bb2b60d6b7854cc249d89dc52e5", "patch": "@@ -1,3 +1,23 @@\n+2015-04-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/iterators.md (GTGE, GTUGEU, COMPARISONS): New code\n+\titerators.\n+\t(cmp_op, cmp_type): New code attributes.\n+\t(NEON_VCMP, NEON_VACMP): New int iterators.\n+\t(cmp_op_unsp): New int attribute.\n+\t* config/arm/neon.md (neon_vc<cmp_op><mode>): New define_expand.\n+\t(neon_vceq<mode>): Delete.\n+\t(neon_vc<cmp_op><mode>_insn): New pattern.\n+\t(neon_vc<cmp_op_unsp><mode>_insn_unspec): Likewise.\n+\t(neon_vcgeu<mode>): Delete.\n+\t(neon_vcle<mode>): Likewise.\n+\t(neon_vclt<mode>: Likewise.\n+\t(neon_vcage<mode>): Likewise.\n+\t(neon_vcagt<mode>): Likewise.\n+\t(neon_vca<cmp_op><mode>): New define_expand.\n+\t(neon_vca<cmp_op><mode>_insn): New pattern.\n+\t(neon_vca<cmp_op_unsp><mode>_insn_unspec): Likewise.\n+\n 2015-04-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-icf.c (sem_item::compare_attributes): New function."}, {"sha": "66f3f4d7d9fe7843ea1ec279d539019c4a52b5df", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=381811fa306b8bb2b60d6b7854cc249d89dc52e5", "patch": "@@ -181,6 +181,15 @@\n ;; compare a second time.\n (define_code_iterator LTUGEU [ltu geu])\n \n+;; The signed gt, ge comparisons\n+(define_code_iterator GTGE [gt ge])\n+\n+;; The unsigned gt, ge comparisons\n+(define_code_iterator GTUGEU [gtu geu])\n+\n+;; Comparisons for vc<cmp>\n+(define_code_iterator COMPARISONS [eq gt ge le lt])\n+\n ;; A list of ...\n (define_code_iterator ior_xor [ior xor])\n \n@@ -214,13 +223,22 @@\n (define_code_attr arith_shift_insn\n   [(plus \"add\") (minus \"rsb\") (ior \"orr\") (xor \"eor\") (and \"and\")])\n \n+(define_code_attr cmp_op [(eq \"eq\") (gt \"gt\") (ge \"ge\") (lt \"lt\") (le \"le\")\n+                          (gtu \"gt\") (geu \"ge\")])\n+\n+(define_code_attr cmp_type [(eq \"i\") (gt \"s\") (ge \"s\") (lt \"s\") (le \"s\")])\n+\n ;;----------------------------------------------------------------------------\n ;; Int iterators\n ;;----------------------------------------------------------------------------\n \n (define_int_iterator VRINT [UNSPEC_VRINTZ UNSPEC_VRINTP UNSPEC_VRINTM\n                             UNSPEC_VRINTR UNSPEC_VRINTX UNSPEC_VRINTA])\n \n+(define_int_iterator NEON_VCMP [UNSPEC_VCEQ UNSPEC_VCGT UNSPEC_VCGE UNSPEC_VCLT UNSPEC_VCLE])\n+\n+(define_int_iterator NEON_VACMP [UNSPEC_VCAGE UNSPEC_VCAGT])\n+\n (define_int_iterator VCVT [UNSPEC_VRINTP UNSPEC_VRINTM UNSPEC_VRINTA])\n \n (define_int_iterator NEON_VRINT [UNSPEC_NVRINTP UNSPEC_NVRINTZ UNSPEC_NVRINTM\n@@ -677,6 +695,11 @@\n \n ])\n \n+(define_int_attr cmp_op_unsp [(UNSPEC_VCEQ \"eq\") (UNSPEC_VCGT \"gt\")\n+                              (UNSPEC_VCGE \"ge\") (UNSPEC_VCLE \"le\")\n+                              (UNSPEC_VCLT \"lt\") (UNSPEC_VCAGE \"ge\")\n+                              (UNSPEC_VCAGT \"gt\")])\n+\n (define_int_attr r [\n   (UNSPEC_VRHADD_S \"r\") (UNSPEC_VRHADD_U \"r\")\n   (UNSPEC_VHADD_S \"\") (UNSPEC_VHADD_U \"\")"}, {"sha": "445df2ad0bd631cbf00f5a966e46e1e829ab6918", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 105, "deletions": 99, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=381811fa306b8bb2b60d6b7854cc249d89dc52e5", "patch": "@@ -2200,134 +2200,140 @@\n   [(set_attr \"type\" \"neon_sub_halve_narrow_q\")]\n )\n \n-(define_insn \"neon_vceq<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n-\t   (match_operand:VDQW 2 \"reg_or_zero_operand\" \"w,Dz\")]\n-          UNSPEC_VCEQ))]\n+;; These may expand to an UNSPEC pattern when a floating point mode is used\n+;; without unsafe math optimizations.\n+(define_expand \"neon_vc<cmp_op><mode>\"\n+  [(match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n+     (neg:<V_cmp_result>\n+       (COMPARISONS:VDQW (match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n+                         (match_operand:VDQW 2 \"reg_or_zero_operand\" \"w,Dz\")))]\n   \"TARGET_NEON\"\n-  \"@\n-  vceq.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n-  vceq.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n-  [(set (attr \"type\")\n-      (if_then_else (match_test \"<Is_float_mode>\")\n-                    (const_string \"neon_fp_compare_s<q>\")\n-                    (if_then_else (match_operand 2 \"zero_operand\")\n-                      (const_string \"neon_compare_zero<q>\")\n-                      (const_string \"neon_compare<q>\"))))]\n+  {\n+    /* For FP comparisons use UNSPECS unless -funsafe-math-optimizations\n+       are enabled.  */\n+    if (GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT\n+        && !flag_unsafe_math_optimizations)\n+      {\n+        /* We don't just emit a gen_neon_vc<cmp_op><mode>_insn_unspec because\n+           we define gen_neon_vceq<mode>_insn_unspec only for float modes\n+           whereas this expander iterates over the integer modes as well,\n+           but we will never expand to UNSPECs for the integer comparisons.  */\n+        switch (<MODE>mode)\n+          {\n+            case V2SFmode:\n+              emit_insn (gen_neon_vc<cmp_op>v2sf_insn_unspec (operands[0],\n+                                                              operands[1],\n+                                                              operands[2]));\n+              break;\n+            case V4SFmode:\n+              emit_insn (gen_neon_vc<cmp_op>v4sf_insn_unspec (operands[0],\n+                                                              operands[1],\n+                                                              operands[2]));\n+              break;\n+            default:\n+              gcc_unreachable ();\n+          }\n+      }\n+    else\n+      emit_insn (gen_neon_vc<cmp_op><mode>_insn (operands[0],\n+                                                 operands[1],\n+                                                 operands[2]));\n+    DONE;\n+  }\n )\n \n-(define_insn \"neon_vcge<mode>\"\n+(define_insn \"neon_vc<cmp_op><mode>_insn\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n-\t   (match_operand:VDQW 2 \"reg_or_zero_operand\" \"w,Dz\")]\n-          UNSPEC_VCGE))]\n-  \"TARGET_NEON\"\n-  \"@\n-  vcge.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n-  vcge.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n+        (neg:<V_cmp_result>\n+          (COMPARISONS:<V_cmp_result>\n+            (match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n+            (match_operand:VDQW 2 \"reg_or_zero_operand\" \"w,Dz\"))))]\n+  \"TARGET_NEON && !(GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT\n+                    && !flag_unsafe_math_optimizations)\"\n+  {\n+    char pattern[100];\n+    sprintf (pattern, \"vc<cmp_op>.%s%%#<V_sz_elem>\\t%%<V_reg>0,\"\n+                      \" %%<V_reg>1, %s\",\n+                       GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT\n+                         ? \"f\" : \"<cmp_type>\",\n+                       which_alternative == 0\n+                         ? \"%<V_reg>2\" : \"#0\");\n+    output_asm_insn (pattern, operands);\n+    return \"\";\n+  }\n   [(set (attr \"type\")\n-     (if_then_else (match_test \"<Is_float_mode>\")\n-                   (const_string \"neon_fp_compare_s<q>\")\n-                    (if_then_else (match_operand 2 \"zero_operand\")\n+        (if_then_else (match_operand 2 \"zero_operand\")\n                       (const_string \"neon_compare_zero<q>\")\n-                      (const_string \"neon_compare<q>\"))))]\n-)\n-\n-(define_insn \"neon_vcgeu<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n-\t   (match_operand:VDQIW 2 \"s_register_operand\" \"w\")]\n-          UNSPEC_VCGEU))]\n-  \"TARGET_NEON\"\n-  \"vcge.u%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n-  [(set_attr \"type\" \"neon_compare<q>\")]\n+                      (const_string \"neon_compare<q>\")))]\n )\n \n-(define_insn \"neon_vcgt<mode>\"\n+(define_insn \"neon_vc<cmp_op_unsp><mode>_insn_unspec\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n         (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w,w\")\n-\t   (match_operand:VDQW 2 \"reg_or_zero_operand\" \"w,Dz\")]\n-          UNSPEC_VCGT))]\n+\t  [(match_operand:VCVTF 1 \"s_register_operand\" \"w,w\")\n+\t   (match_operand:VCVTF 2 \"reg_or_zero_operand\" \"w,Dz\")]\n+          NEON_VCMP))]\n   \"TARGET_NEON\"\n-  \"@\n-  vcgt.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\n-  vcgt.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n-  [(set (attr \"type\")\n-     (if_then_else (match_test \"<Is_float_mode>\")\n-                   (const_string \"neon_fp_compare_s<q>\")\n-                    (if_then_else (match_operand 2 \"zero_operand\")\n-                      (const_string \"neon_compare_zero<q>\")\n-                      (const_string \"neon_compare<q>\"))))]\n+  {\n+    char pattern[100];\n+    sprintf (pattern, \"vc<cmp_op_unsp>.f%%#<V_sz_elem>\\t%%<V_reg>0,\"\n+                       \" %%<V_reg>1, %s\",\n+                       which_alternative == 0\n+                         ? \"%<V_reg>2\" : \"#0\");\n+    output_asm_insn (pattern, operands);\n+    return \"\";\n+}\n+  [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n )\n \n-(define_insn \"neon_vcgtu<mode>\"\n+(define_insn \"neon_vc<cmp_op>u<mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n-\t   (match_operand:VDQIW 2 \"s_register_operand\" \"w\")]\n-          UNSPEC_VCGTU))]\n+        (neg:<V_cmp_result>\n+          (GTUGEU:<V_cmp_result>\n+\t    (match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n+\t    (match_operand:VDQIW 2 \"s_register_operand\" \"w\"))))]\n   \"TARGET_NEON\"\n-  \"vcgt.u%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  \"vc<cmp_op>.u%#<V_sz_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n   [(set_attr \"type\" \"neon_compare<q>\")]\n )\n \n-;; VCLE and VCLT only support comparisons with immediate zero (register\n-;; variants are VCGE and VCGT with operands reversed).\n-\n-(define_insn \"neon_vcle<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n-\t   (match_operand:VDQW 2 \"zero_operand\" \"Dz\")]\n-          UNSPEC_VCLE))]\n+(define_expand \"neon_vca<cmp_op><mode>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+        (neg:<V_cmp_result>\n+          (GTGE:<V_cmp_result>\n+            (abs:VCVTF (match_operand:VCVTF 1 \"s_register_operand\"))\n+            (abs:VCVTF (match_operand:VCVTF 2 \"s_register_operand\")))))]\n   \"TARGET_NEON\"\n-  \"vcle.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n-  [(set (attr \"type\")\n-      (if_then_else (match_test \"<Is_float_mode>\")\n-                    (const_string \"neon_fp_compare_s<q>\")\n-                    (if_then_else (match_operand 2 \"zero_operand\")\n-                      (const_string \"neon_compare_zero<q>\")\n-                      (const_string \"neon_compare<q>\"))))]\n-)\n-\n-(define_insn \"neon_vclt<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VDQW 1 \"s_register_operand\" \"w\")\n-\t   (match_operand:VDQW 2 \"zero_operand\" \"Dz\")]\n-          UNSPEC_VCLT))]\n-  \"TARGET_NEON\"\n-  \"vclt.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, #0\"\n-  [(set (attr \"type\")\n-      (if_then_else (match_test \"<Is_float_mode>\")\n-                    (const_string \"neon_fp_compare_s<q>\")\n-                    (if_then_else (match_operand 2 \"zero_operand\")\n-                      (const_string \"neon_compare_zero<q>\")\n-                      (const_string \"neon_compare<q>\"))))]\n+  {\n+    if (flag_unsafe_math_optimizations)\n+      emit_insn (gen_neon_vca<cmp_op><mode>_insn (operands[0], operands[1],\n+                                                  operands[2]));\n+    else\n+      emit_insn (gen_neon_vca<cmp_op><mode>_insn_unspec (operands[0],\n+                                                         operands[1],\n+                                                         operands[2]));\n+    DONE;\n+  }\n )\n \n-(define_insn \"neon_vcage<mode>\"\n+(define_insn \"neon_vca<cmp_op><mode>_insn\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n-        (unspec:<V_cmp_result> [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")\n-\t\t                (match_operand:VCVTF 2 \"s_register_operand\" \"w\")]\n-                               UNSPEC_VCAGE))]\n-  \"TARGET_NEON\"\n-  \"vacge.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+        (neg:<V_cmp_result>\n+          (GTGE:<V_cmp_result>\n+            (abs:VCVTF (match_operand:VCVTF 1 \"s_register_operand\" \"w\"))\n+            (abs:VCVTF (match_operand:VCVTF 2 \"s_register_operand\" \"w\")))))]\n+  \"TARGET_NEON && flag_unsafe_math_optimizations\"\n+  \"vac<cmp_op>.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n   [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n )\n \n-(define_insn \"neon_vcagt<mode>\"\n+(define_insn \"neon_vca<cmp_op_unsp><mode>_insn_unspec\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n         (unspec:<V_cmp_result> [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")\n \t\t                (match_operand:VCVTF 2 \"s_register_operand\" \"w\")]\n-                               UNSPEC_VCAGT))]\n+                               NEON_VACMP))]\n   \"TARGET_NEON\"\n-  \"vacgt.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  \"vac<cmp_op_unsp>.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n   [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n )\n "}, {"sha": "2a0850fb2e4ae7b8de321ae11024e232802ee7e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=381811fa306b8bb2b60d6b7854cc249d89dc52e5", "patch": "@@ -1,3 +1,8 @@\n+2015-04-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.target/arm/neon/pr51534.c: Update vcg* scan-assembly patterns\n+\tto look for vcl* where appropriate.\n+\n 2015-04-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c: Replace"}, {"sha": "074bbd42040497d18d561767a431d65d63a2d0c7", "filename": "gcc/testsuite/gcc.target/arm/neon/pr51534.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fpr51534.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381811fa306b8bb2b60d6b7854cc249d89dc52e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fpr51534.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fpr51534.c?ref=381811fa306b8bb2b60d6b7854cc249d89dc52e5", "patch": "@@ -58,18 +58,18 @@ GEN_COND_TESTS(vceq)\n /* { dg-final { scan-assembler-times \"vcge\\.u16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" 2 } } */\n /* { dg-final { scan-assembler \"vcge\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n /* { dg-final { scan-assembler-times \"vcge\\.u32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" 2 } } */\n-/* { dg-final { scan-assembler \"vcgt\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcgt\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcgt\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcgt\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcgt\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcgt\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler \"vclt\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vclt\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vclt\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vclt\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vclt\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vclt\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\.s8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\.s16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\.s32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\.s8\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\.s16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\.s32\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+, #0\" } } */\n /* { dg-final { scan-assembler-times \"vceq\\.i8\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" 2 } } */\n /* { dg-final { scan-assembler-times \"vceq\\.i16\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" 2 } } */\n /* { dg-final { scan-assembler-times \"vceq\\.i32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+, #0\" 2 } } */"}]}