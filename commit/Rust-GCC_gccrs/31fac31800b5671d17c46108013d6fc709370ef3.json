{"sha": "31fac31800b5671d17c46108013d6fc709370ef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFmYWMzMTgwMGI1NjcxZDE3YzQ2MTA4MDEzZDZmYzcwOTM3MGVmMw==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:58:12Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-14T20:58:12Z"}, "message": "slp: support complex FMA and complex FMA conjugate\n\nThis adds support for FMA and FMA conjugated to the slp pattern matcher.\n\nExample of instructions matched:\n\n#include <stdio.h>\n#include <complex.h>\n\n#define N 200\n#define ROT\n#define TYPE float\n#define TYPE2 float\n\nvoid g (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] +=  a[i] * (b[i] ROT);\n    }\n}\n\nvoid g_f1 (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] +=  conjf (a[i]) * (b[i] ROT);\n    }\n}\n\nvoid g_s1 (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n{\n  for (int i=0; i < N; i++)\n    {\n      c[i] +=  a[i] * conjf (b[i] ROT);\n    }\n}\n\nvoid caxpy_add(double complex * restrict y, double complex * restrict x, size_t N, double complex f) {\n  for (size_t i = 0; i < N; ++i)\n    y[i] += x[i]* f;\n}\n\ngcc/ChangeLog:\n\n\t* internal-fn.def (COMPLEX_FMA, COMPLEX_FMA_CONJ): New.\n\t* optabs.def (cmla_optab, cmla_conj_optab): New.\n\t* doc/md.texi: Document them.\n\t* tree-vect-slp-patterns.c (vect_match_call_p,\n\tclass complex_fma_pattern, vect_slp_reset_pattern,\n\tcomplex_fma_pattern::matches, complex_fma_pattern::recognize,\n\tcomplex_fma_pattern::build): New.", "tree": {"sha": "d98e36d4c883b57648f26c48e77234096a8624aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d98e36d4c883b57648f26c48e77234096a8624aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31fac31800b5671d17c46108013d6fc709370ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fac31800b5671d17c46108013d6fc709370ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31fac31800b5671d17c46108013d6fc709370ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fac31800b5671d17c46108013d6fc709370ef3/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e09173d84dabd186ad2463f47350c1bcabfeab8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09173d84dabd186ad2463f47350c1bcabfeab8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09173d84dabd186ad2463f47350c1bcabfeab8f"}], "stats": {"total": 229, "additions": 229, "deletions": 0}, "files": [{"sha": "49a1ce045b19a2a1d49a1fedbacd81876e317c04", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=31fac31800b5671d17c46108013d6fc709370ef3", "patch": "@@ -6202,6 +6202,51 @@ The operation is only supported for vector modes @var{m}.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{cmla@var{m}4} instruction pattern\n+@item @samp{cmla@var{m}4}\n+Perform a vector multiply and accumulate that is semantically the same as\n+a multiply and accumulate of complex numbers.\n+\n+@smallexample\n+  complex TYPE c[N];\n+  complex TYPE a[N];\n+  complex TYPE b[N];\n+  for (int i = 0; i < N; i += 1)\n+    @{\n+      c[i] += a[i] * b[i];\n+    @}\n+@end smallexample\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{cmla_conj@var{m}4} instruction pattern\n+@item @samp{cmla_conj@var{m}4}\n+Perform a vector multiply by conjugate and accumulate that is semantically\n+the same as a multiply and accumulate of complex numbers where the second\n+multiply arguments is conjugated.\n+\n+@smallexample\n+  complex TYPE c[N];\n+  complex TYPE a[N];\n+  complex TYPE b[N];\n+  for (int i = 0; i < N; i += 1)\n+    @{\n+      c[i] += a[i] * conj (b[i]);\n+    @}\n+@end smallexample\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{cmul@var{m}4} instruction pattern\n @item @samp{cmul@var{m}4}\n Perform a vector multiply that is semantically the same as multiply of"}, {"sha": "020b586bc656b2691c6151d727f58601d4eec80f", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=31fac31800b5671d17c46108013d6fc709370ef3", "patch": "@@ -288,6 +288,8 @@ DEF_INTERNAL_FLT_FN (LDEXP, ECF_CONST, ldexp, binary)\n \n /* Ternary math functions.  */\n DEF_INTERNAL_FLT_FLOATN_FN (FMA, ECF_CONST, fma, ternary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_FMA, ECF_CONST, cmla, ternary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_FMA_CONJ, ECF_CONST, cmla_conj, ternary)\n \n /* Unary integer ops.  */\n DEF_INTERNAL_INT_FN (CLRSB, ECF_CONST | ECF_NOTHROW, clrsb, unary)"}, {"sha": "cecd1b61a1f1f7ae58e182eb789e1a3551a429ba", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=31fac31800b5671d17c46108013d6fc709370ef3", "patch": "@@ -294,6 +294,8 @@ OPTAB_D (cadd90_optab, \"cadd90$a3\")\n OPTAB_D (cadd270_optab, \"cadd270$a3\")\n OPTAB_D (cmul_optab, \"cmul$a3\")\n OPTAB_D (cmul_conj_optab, \"cmul_conj$a3\")\n+OPTAB_D (cmla_optab, \"cmla$a4\")\n+OPTAB_D (cmla_conj_optab, \"cmla_conj$a4\")\n OPTAB_D (cos_optab, \"cos$a2\")\n OPTAB_D (cosh_optab, \"cosh$a2\")\n OPTAB_D (exp10_optab, \"exp10$a2\")"}, {"sha": "bd632e01fb851761ad9e43ffaa1aeaf152176c47", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31fac31800b5671d17c46108013d6fc709370ef3/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=31fac31800b5671d17c46108013d6fc709370ef3", "patch": "@@ -325,6 +325,24 @@ vect_match_expression_p (slp_tree node, tree_code code)\n   return true;\n }\n \n+/* Checks to see if the expression represented by NODE is a call to the internal\n+   function FN.  */\n+\n+static inline bool\n+vect_match_call_p (slp_tree node, internal_fn fn)\n+{\n+  if (!node\n+      || !SLP_TREE_REPRESENTATIVE (node))\n+    return false;\n+\n+  gimple* expr = STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (node));\n+  if (!expr\n+      || !gimple_call_internal_p (expr, fn))\n+    return false;\n+\n+   return true;\n+}\n+\n /* Check if the given lane permute in PERMUTES matches an alternating sequence\n    of {even odd even odd ...}.  This to account for unrolled loops.  Further\n    mode there resulting permute must be linear.   */\n@@ -1085,6 +1103,168 @@ complex_mul_pattern::build (vec_info *vinfo)\n   complex_pattern::build (vinfo);\n }\n \n+/*******************************************************************************\n+ * complex_fma_pattern class\n+ ******************************************************************************/\n+\n+class complex_fma_pattern : public complex_pattern\n+{\n+  protected:\n+    complex_fma_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+      : complex_pattern (node, m_ops, ifn)\n+    {\n+      this->m_num_args = 3;\n+    }\n+\n+  public:\n+    void build (vec_info *);\n+    static internal_fn\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n+\t     vec<slp_tree> *);\n+\n+    static vect_pattern*\n+    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+\n+    static vect_pattern*\n+    mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+    {\n+      return new complex_fma_pattern (node, m_ops, ifn);\n+    }\n+};\n+\n+/* Helper function to \"reset\" a previously matched node and undo the changes\n+   made enough so that the node is treated as an irrelevant node.  */\n+\n+static inline void\n+vect_slp_reset_pattern (slp_tree node)\n+{\n+  stmt_vec_info stmt_info = vect_orig_stmt (SLP_TREE_REPRESENTATIVE (node));\n+  STMT_VINFO_IN_PATTERN_P (stmt_info) = false;\n+  STMT_SLP_TYPE (stmt_info) = pure_slp;\n+  SLP_TREE_REPRESENTATIVE (node) = stmt_info;\n+}\n+\n+/* Pattern matcher for trying to match complex multiply and accumulate\n+   and multiply and subtract patterns in SLP tree.\n+   If the operation matches then IFN is set to the operation it matched and\n+   the arguments to the two replacement statements are put in m_ops.\n+\n+   If no match is found then IFN is set to IFN_LAST and m_ops is unchanged.\n+\n+   This function matches the patterns shaped as:\n+\n+   double ax = (b[i+1] * a[i]) + (b[i] * a[i]);\n+   double bx = (a[i+1] * b[i]) - (a[i+1] * b[i+1]);\n+\n+   c[i] = c[i] - ax;\n+   c[i+1] = c[i+1] + bx;\n+\n+   If a match occurred then TRUE is returned, else FALSE.  The match is\n+   performed after COMPLEX_MUL which would have done the majority of the work.\n+   This function merely matches an ADD with a COMPLEX_MUL IFN.  The initial\n+   match is expected to be in OP1 and the initial match operands in args0.  */\n+\n+internal_fn\n+complex_fma_pattern::matches (complex_operation_t op,\n+\t\t\t      slp_tree_to_load_perm_map_t * /* perm_cache */,\n+\t\t\t      slp_tree *ref_node, vec<slp_tree> *ops)\n+{\n+  internal_fn ifn = IFN_LAST;\n+\n+  /* Find the two components.  We match Complex MUL first which reduces the\n+     amount of work this pattern has to do.  After that we just match the\n+     head node and we're done.:\n+\n+     * FMA: + +.\n+\n+     We need to ignore the two_operands nodes that may also match.\n+     For that we can check if they have any scalar statements and also\n+     check that it's not a permute node as we're looking for a normal\n+     PLUS_EXPR operation.  */\n+  if (op != CMPLX_NONE)\n+    return IFN_LAST;\n+\n+  /* Find the two components.  We match Complex MUL first which reduces the\n+     amount of work this pattern has to do.  After that we just match the\n+     head node and we're done.:\n+\n+   * FMA: + + on a non-two_operands node.  */\n+  slp_tree vnode = *ref_node;\n+  if (SLP_TREE_LANE_PERMUTATION (vnode).exists ()\n+      || !SLP_TREE_CHILDREN (vnode).exists ()\n+      || !vect_match_expression_p (vnode, PLUS_EXPR))\n+    return IFN_LAST;\n+\n+  slp_tree node = SLP_TREE_CHILDREN (vnode)[1];\n+\n+  if (vect_match_call_p (node, IFN_COMPLEX_MUL))\n+    ifn = IFN_COMPLEX_FMA;\n+  else if (vect_match_call_p (node, IFN_COMPLEX_MUL_CONJ))\n+    ifn = IFN_COMPLEX_FMA_CONJ;\n+  else\n+    return IFN_LAST;\n+\n+  if (!vect_pattern_validate_optab (ifn, vnode))\n+    return IFN_LAST;\n+\n+  /* FMA matched ADD + CMUL.  During the matching of CMUL the\n+     stmt that starts the pattern is marked as being in a pattern,\n+     namely the CMUL.  When replacing this with a CFMA we have to\n+     unmark this statement as being in a pattern.  This is because\n+     vect_mark_pattern_stmts will only mark the current stmt as being\n+     in a pattern.  Later on when the scalar stmts are examined the\n+     old statement which is supposed to be irrelevant will point to\n+     CMUL unless we undo the pattern relationship here.  */\n+  vect_slp_reset_pattern (node);\n+  ops->truncate (0);\n+  ops->create (3);\n+\n+  if (ifn == IFN_COMPLEX_FMA)\n+    {\n+      ops->quick_push (SLP_TREE_CHILDREN (vnode)[0]);\n+      ops->quick_push (SLP_TREE_CHILDREN (node)[1]);\n+      ops->quick_push (SLP_TREE_CHILDREN (node)[0]);\n+    }\n+  else\n+    {\n+      ops->quick_push (SLP_TREE_CHILDREN (vnode)[0]);\n+      ops->quick_push (SLP_TREE_CHILDREN (node)[0]);\n+      ops->quick_push (SLP_TREE_CHILDREN (node)[1]);\n+    }\n+\n+  return ifn;\n+}\n+\n+/* Attempt to recognize a complex mul pattern.  */\n+\n+vect_pattern*\n+complex_fma_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_tree *node)\n+{\n+  auto_vec<slp_tree> ops;\n+  complex_operation_t op\n+    = vect_detect_pair_op (*node, true, &ops);\n+  internal_fn ifn\n+    = complex_fma_pattern::matches (op, perm_cache, node, &ops);\n+  if (ifn == IFN_LAST)\n+    return NULL;\n+\n+  return new complex_fma_pattern (node, &ops, ifn);\n+}\n+\n+/* Perform a replacement of the detected complex mul pattern with the new\n+   instruction sequences.  */\n+\n+void\n+complex_fma_pattern::build (vec_info *vinfo)\n+{\n+  SLP_TREE_CHILDREN (*this->m_node).release ();\n+  SLP_TREE_CHILDREN (*this->m_node).create (3);\n+  SLP_TREE_CHILDREN (*this->m_node).safe_splice (this->m_ops);\n+\n+  complex_pattern::build (vinfo);\n+}\n+\n /*******************************************************************************\n  * Pattern matching definitions\n  ******************************************************************************/"}]}