{"sha": "ecc4ddde87a9d5ddbd115e118db5101bd0249437", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNjNGRkZGU4N2E5ZDVkZGJkMTE1ZTExOGRiNTEwMWJkMDI0OTQzNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T12:53:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T12:53:51Z"}, "message": "[multiple changes]\n\n2009-04-08  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.ads: Update comment on switches file\n\n\t* prj-nmsc.adb: Code clean up. Use renaming clauses.\n\n2009-04-08  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Further fixes to bounds handling\n\n2009-04-08  Thomas Quinot  <quinot@adacore.com>\n\n\t* ali-util.adb: Minor comment fix\n\n2009-04-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Use_Type): Improve error message when clause\n\tappears in a context clause, and the enclosing package is mentioned in\n\ta limited_with_clause.\n\t(Use_One_Type): Reject clause if type is still incomplete.\n\nFrom-SVN: r145722", "tree": {"sha": "8230647596da5feaad11e1549aa143b759ab6e08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8230647596da5feaad11e1549aa143b759ab6e08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecc4ddde87a9d5ddbd115e118db5101bd0249437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc4ddde87a9d5ddbd115e118db5101bd0249437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecc4ddde87a9d5ddbd115e118db5101bd0249437", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecc4ddde87a9d5ddbd115e118db5101bd0249437/comments", "author": null, "committer": null, "parents": [{"sha": "a29262fd4476d0d0e5144b794d966cc676e9cef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29262fd4476d0d0e5144b794d966cc676e9cef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29262fd4476d0d0e5144b794d966cc676e9cef3"}], "stats": {"total": 512, "additions": 317, "deletions": 195}, "files": [{"sha": "a18c7d2de853f17122e6320b76e99d34961073d5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ecc4ddde87a9d5ddbd115e118db5101bd0249437", "patch": "@@ -1,3 +1,24 @@\n+2009-04-08  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.ads: Update comment on switches file\n+\n+\t* prj-nmsc.adb: Code clean up. Use renaming clauses.\n+\n+2009-04-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Further fixes to bounds handling\n+\n+2009-04-08  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* ali-util.adb: Minor comment fix\n+\n+2009-04-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Use_Type): Improve error message when clause\n+\tappears in a context clause, and the enclosing package is mentioned in\n+\ta limited_with_clause.\n+\t(Use_One_Type): Reject clause if type is still incomplete.\n+\n 2009-04-08  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-nmsc.adb (Check_File, Process_Sources_In_Multi_Language_Mode):"}, {"sha": "25a0d7a7d51d10d38468b6ec13ceaa62006d23e5", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=ecc4ddde87a9d5ddbd115e118db5101bd0249437", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -490,7 +490,7 @@ package body ALI.Util is\n             if not Source.Table (Src).Source_Found\n               or else Sdep.Table (D).Stamp /= Source.Table (Src).Stamp\n             then\n-               --  If -t debug flag set, output time stamp found/expected\n+               --  If -dt debug flag set, output time stamp found/expected\n \n                if Source.Table (Src).Source_Found and Debug_Flag_T then\n                   Write_Str (\"Source: \"\"\");"}, {"sha": "b01203d13664e123954cd258fb9b752a9d483818", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ecc4ddde87a9d5ddbd115e118db5101bd0249437", "patch": "@@ -2146,8 +2146,13 @@ package body Exp_Ch4 is\n       --  Component type. Elements of this component type can appear as one\n       --  of the operands of concatenation as well as arrays.\n \n-      Ityp : constant Entity_Id := Etype (First_Index (Atyp));\n-      --  Index type\n+      Istyp : constant Entity_Id := Etype (First_Index (Atyp));\n+      --  Index subtype\n+\n+      Ityp : constant Entity_Id := Base_Type (Istyp);\n+      --  Index type. This is the base type of the index subtype, and is used\n+      --  for all computed bounds (which may be out of range of Istyp in the\n+      --  case of null ranges).\n \n       Intyp : Entity_Id;\n       --  This is the type we use to do arithmetic to compute the bounds and\n@@ -2239,7 +2244,7 @@ package body Exp_Ch4 is\n \n       function To_Intyp (X : Node_Id) return Node_Id is\n       begin\n-         if Base_Type (Ityp) = Base_Type (Intyp) then\n+         if Ityp = Base_Type (Intyp) then\n             return X;\n \n          elsif Is_Enumeration_Type (Ityp) then\n@@ -2271,7 +2276,7 @@ package body Exp_Ch4 is\n \n          else\n             --  If the value is known at compile time, and known to be out of\n-            --  range of the index type or the base type, we can signal that\n+            --  range of the index subtype or its base type, we can signal that\n             --  we are sure to have a constraint error at run time.\n \n             --  There are two reasons for doing this. First of all, it is of\n@@ -2285,11 +2290,11 @@ package body Exp_Ch4 is\n             Analyze_And_Resolve (X);\n \n             if Compile_Time_Compare\n-                 (X, Type_High_Bound (Ityp),\n+                 (X, Type_High_Bound (Istyp),\n                   Assume_Valid => False) = GT\n               or else\n                Compile_Time_Compare\n-                 (X, Type_High_Bound (Base_Type (Ityp)),\n+                 (X, Type_High_Bound (Ityp),\n                   Assume_Valid => False) = GT\n             then\n                Apply_Compile_Time_Constraint_Error\n@@ -2299,7 +2304,7 @@ package body Exp_Ch4 is\n                raise Concatenation_Error;\n \n             else\n-               if Base_Type (Ityp) = Base_Type (Intyp) then\n+               if Ityp = Base_Type (Intyp) then\n                   return X;\n                else\n                   return Convert_To (Ityp, X);\n@@ -2345,21 +2350,21 @@ package body Exp_Ch4 is\n       --  identity type, and for larger unsigned types we use 64-bits.\n \n       elsif Is_Modular_Integer_Type (Ityp) then\n-         if RM_Size (Base_Type (Ityp)) < RM_Size (Standard_Unsigned) then\n+         if RM_Size (Ityp) < RM_Size (Standard_Unsigned) then\n             Intyp := Standard_Unsigned;\n-         elsif RM_Size (Base_Type (Ityp)) = RM_Size (Standard_Unsigned) then\n-            Intyp := Base_Type (Ityp);\n+         elsif RM_Size (Ityp) = RM_Size (Standard_Unsigned) then\n+            Intyp := Ityp;\n          else\n             Intyp := RTE (RE_Long_Long_Unsigned);\n          end if;\n \n       --  Similar treatment for signed types\n \n       else\n-         if RM_Size (Base_Type (Ityp)) < RM_Size (Standard_Integer) then\n+         if RM_Size (Ityp) < RM_Size (Standard_Integer) then\n             Intyp := Standard_Integer;\n-         elsif RM_Size (Base_Type (Ityp)) = RM_Size (Standard_Integer) then\n-            Intyp := Base_Type (Ityp);\n+         elsif RM_Size (Ityp) = RM_Size (Standard_Integer) then\n+            Intyp := Ityp;\n          else\n             Intyp := Standard_Long_Long_Integer;\n          end if;\n@@ -2395,7 +2400,7 @@ package body Exp_Ch4 is\n \n             Opnd_Low_Bound (NN) :=\n               Make_Attribute_Reference (Loc,\n-                Prefix         => New_Reference_To (Ityp, Loc),\n+                Prefix         => New_Reference_To (Istyp, Loc),\n                 Attribute_Name => Name_First);\n \n             Set := True;"}, {"sha": "c00a69ae7c9cd142185e41c2c1acdb602b35fd92", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 222, "deletions": 176, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=ecc4ddde87a9d5ddbd115e118db5101bd0249437", "patch": "@@ -50,8 +50,6 @@ with Ada.Strings.Maps.Constants; use Ada.Strings.Maps.Constants;\n \n package body Prj.Nmsc is\n \n-   type Source_Data_Access is access Source_Data;\n-\n    No_Continuation_String : aliased String := \"\";\n    Continuation_String    : aliased String := \"\\\";\n    --  Used in Check_Library for continuation error messages at the same\n@@ -798,7 +796,6 @@ package body Prj.Nmsc is\n             declare\n                Language      : Language_Index;\n                Source        : Source_Id;\n-               Src_Data      : Source_Data_Access;\n                Alt_Lang      : Alternate_Language_Id;\n                Alt_Lang_Data : Alternate_Language_Data;\n                Continuation  : Boolean := False;\n@@ -808,23 +805,25 @@ package body Prj.Nmsc is\n                while Language /= No_Language_Index loop\n                   Source := Data.First_Source;\n                   Source_Loop : while Source /= No_Source loop\n-                     Src_Data :=\n-                       In_Tree.Sources.Table (Source)'Unrestricted_Access;\n-\n-                     exit Source_Loop when Src_Data.Language = Language;\n+                     declare\n+                        Src_Data      : Source_Data renames\n+                          In_Tree.Sources.Table (Source);\n+                     begin\n+                        exit Source_Loop when Src_Data.Language = Language;\n \n-                     Alt_Lang := Src_Data.Alternate_Languages;\n+                        Alt_Lang := Src_Data.Alternate_Languages;\n \n-                     Alternate_Loop :\n-                     while Alt_Lang /= No_Alternate_Language loop\n-                        Alt_Lang_Data :=\n-                          In_Tree.Alt_Langs.Table (Alt_Lang);\n-                        exit Source_Loop\n-                               when Alt_Lang_Data.Language = Language;\n-                        Alt_Lang := Alt_Lang_Data.Next;\n-                     end loop Alternate_Loop;\n+                        Alternate_Loop :\n+                        while Alt_Lang /= No_Alternate_Language loop\n+                           Alt_Lang_Data :=\n+                             In_Tree.Alt_Langs.Table (Alt_Lang);\n+                           exit Source_Loop\n+                           when Alt_Lang_Data.Language = Language;\n+                           Alt_Lang := Alt_Lang_Data.Next;\n+                        end loop Alternate_Loop;\n \n-                     Source := Src_Data.Next_In_Project;\n+                        Source := Src_Data.Next_In_Project;\n+                     end;\n                   end loop Source_Loop;\n \n                   if Source = No_Source then\n@@ -2497,7 +2496,6 @@ package body Prj.Nmsc is\n       Name    : File_Name_Type;\n \n       Source   : Source_Id;\n-      Src_Data : Source_Data_Access;\n \n       Project_2 : Project_Id;\n       Data_2     : Project_Data;\n@@ -2513,9 +2511,13 @@ package body Prj.Nmsc is\n          loop\n             Source := Data_2.First_Source;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n-               Src_Data.In_Interfaces := False;\n-               Source := Src_Data.Next_In_Project;\n+               declare\n+                  Src_Data : Source_Data renames\n+                    In_Tree.Sources.Table (Source);\n+               begin\n+                  Src_Data.In_Interfaces := False;\n+                  Source := Src_Data.Next_In_Project;\n+               end;\n             end loop;\n \n             Project_2 := Data_2.Extends;\n@@ -2538,31 +2540,35 @@ package body Prj.Nmsc is\n             loop\n                Source := Data_2.First_Source;\n                while Source /= No_Source loop\n-                  Src_Data :=\n-                    In_Tree.Sources.Table (Source)'Unrestricted_Access;\n-                  if Src_Data.File = Name then\n-                     if not Src_Data.Locally_Removed then\n-                        Src_Data.In_Interfaces := True;\n-                        Src_Data.Declared_In_Interfaces := True;\n-\n-                        if Src_Data.Other_Part /= No_Source then\n-                           In_Tree.Sources.Table\n-                             (Src_Data.Other_Part).In_Interfaces := True;\n-                           In_Tree.Sources.Table\n-                             (Src_Data.Other_Part).Declared_In_Interfaces :=\n-                             True;\n-                        end if;\n+                  declare\n+                     Src_Data : Source_Data renames\n+                       In_Tree.Sources.Table (Source);\n+                  begin\n+                     if Src_Data.File = Name then\n+                        if not Src_Data.Locally_Removed then\n+                           Src_Data.In_Interfaces := True;\n+                           Src_Data.Declared_In_Interfaces := True;\n \n-                        if Current_Verbosity = High then\n-                           Write_Str (\"   interface: \");\n-                           Write_Line (Get_Name_String (Src_Data.Path.Name));\n+                           if Src_Data.Other_Part /= No_Source then\n+                              In_Tree.Sources.Table\n+                                (Src_Data.Other_Part).In_Interfaces := True;\n+                              In_Tree.Sources.Table\n+                                (Src_Data.Other_Part).Declared_In_Interfaces :=\n+                                True;\n+                           end if;\n+\n+                           if Current_Verbosity = High then\n+                              Write_Str (\"   interface: \");\n+                              Write_Line\n+                                (Get_Name_String (Src_Data.Path.Name));\n+                           end if;\n                         end if;\n-                     end if;\n \n-                     exit Big_Loop;\n-                  end if;\n+                        exit Big_Loop;\n+                     end if;\n \n-                  Source := Src_Data.Next_In_Project;\n+                     Source := Src_Data.Next_In_Project;\n+                  end;\n                end loop;\n \n                Project_2 := Data_2.Extends;\n@@ -2596,13 +2602,16 @@ package body Prj.Nmsc is\n          if Data.Interfaces_Defined then\n             Source := Data.First_Source;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n-\n-               if not Src_Data.Declared_In_Interfaces then\n-                  Src_Data.In_Interfaces := False;\n-               end if;\n+               declare\n+                  Src_Data : Source_Data renames\n+                    In_Tree.Sources.Table (Source);\n+               begin\n+                  if not Src_Data.Declared_In_Interfaces then\n+                     Src_Data.In_Interfaces := False;\n+                  end if;\n \n-               Source := Src_Data.Next_In_Project;\n+                  Source := Src_Data.Next_In_Project;\n+               end;\n             end loop;\n          end if;\n       end if;\n@@ -3530,7 +3539,6 @@ package body Prj.Nmsc is\n       procedure Check_Library (Proj : Project_Id; Extends : Boolean) is\n          Proj_Data : Project_Data;\n          Src_Id    : Source_Id;\n-         Src       : Source_Data_Access;\n \n       begin\n          if Proj /= No_Project then\n@@ -3544,12 +3552,15 @@ package body Prj.Nmsc is\n \n                Src_Id := Proj_Data.First_Source;\n                while Src_Id /= No_Source loop\n-                  Src := In_Tree.Sources.Table (Src_Id)'Unrestricted_Access;\n-\n-                  exit when Src.Lang_Kind /= File_Based\n-                    or else Src.Kind /= Spec;\n+                  declare\n+                     Src       : Source_Data renames\n+                       In_Tree.Sources.Table (Src_Id);\n+                  begin\n+                     exit when Src.Lang_Kind /= File_Based\n+                       or else Src.Kind /= Spec;\n \n-                  Src_Id := Src.Next_In_Project;\n+                     Src_Id := Src.Next_In_Project;\n+                  end;\n                end loop;\n \n                if Src_Id /= No_Source then\n@@ -6413,6 +6424,8 @@ package body Prj.Nmsc is\n    is\n       Mains : constant Variable_Value :=\n                 Prj.Util.Value_Of (Name_Main, Data.Decl.Attributes, In_Tree);\n+      List  : String_List_Id;\n+      Elem  : String_Element;\n \n    begin\n       Data.Mains := Mains.Values;\n@@ -6433,6 +6446,22 @@ package body Prj.Nmsc is\n            (Project, In_Tree,\n             \"a library project file cannot have Main specified\",\n             Mains.Location);\n+\n+      else\n+         List := Mains.Values;\n+         while List /= Nil_String loop\n+            Elem := In_Tree.String_Elements.Table (List);\n+\n+            if Length_Of_Name (Elem.Value) = 0 then\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"?a main cannot have an empty name\",\n+                  Elem.Location);\n+               exit;\n+            end if;\n+\n+            List := Elem.Next;\n+         end loop;\n       end if;\n    end Get_Mains;\n \n@@ -7366,29 +7395,32 @@ package body Prj.Nmsc is\n \n          declare\n             Source   : Source_Id;\n-            Src_Data : Source_Data_Access;\n \n          begin\n             Source := Data.First_Source;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n+               declare\n+                  Src_Data : Source_Data renames\n+                    In_Tree.Sources.Table (Source);\n+               begin\n \n-               if Src_Data.Naming_Exception\n-                 and then Src_Data.Path = No_Path_Information\n-               then\n-                  if Src_Data.Unit /= No_Name then\n-                     Error_Msg_Name_1 := Name_Id (Src_Data.Display_File);\n-                     Error_Msg_Name_2 := Name_Id (Src_Data.Unit);\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"source file %% for unit %% not found\",\n-                        No_Location);\n-                  end if;\n+                  if Src_Data.Naming_Exception\n+                    and then Src_Data.Path = No_Path_Information\n+                  then\n+                     if Src_Data.Unit /= No_Name then\n+                        Error_Msg_Name_1 := Name_Id (Src_Data.Display_File);\n+                        Error_Msg_Name_2 := Name_Id (Src_Data.Unit);\n+                        Error_Msg\n+                          (Project, In_Tree,\n+                           \"source file %% for unit %% not found\",\n+                           No_Location);\n+                     end if;\n \n-                  Remove_Source (Source, No_Source, Project, Data, In_Tree);\n-               end if;\n+                     Remove_Source (Source, No_Source, Project, Data, In_Tree);\n+                  end if;\n \n-               Source := Src_Data.Next_In_Project;\n+                  Source := Src_Data.Next_In_Project;\n+               end;\n             end loop;\n          end;\n \n@@ -8112,10 +8144,10 @@ package body Prj.Nmsc is\n             Add_Src := True;\n             while Source /= No_Source loop\n                declare\n-                  Src_Data : constant Source_Data_Access :=\n-                    In_Tree.Sources.Table (Source)'Unrestricted_Access;\n-               begin\n+                  Src_Data : Source_Data renames\n+                    In_Tree.Sources.Table (Source);\n \n+               begin\n                   if Unit /= No_Name\n                     and then Src_Data.Unit = Unit\n                     and then\n@@ -8129,10 +8161,10 @@ package body Prj.Nmsc is\n                          and then Src_Data.Unit = Unit\n                          and then\n                            (Src_Data.Kind = Kind\n-                            or else\n-                              (Src_Data.Kind = Sep and then Kind = Impl)\n-                            or else\n-                              (Src_Data.Kind = Impl and then Kind = Sep)))\n+                             or else\n+                               (Src_Data.Kind = Sep  and then Kind = Impl)\n+                             or else\n+                               (Src_Data.Kind = Impl and then Kind = Sep)))\n                     or else\n                       (Unit = No_Name and then Src_Data.File = File_Name)\n                   then\n@@ -8437,7 +8469,6 @@ package body Prj.Nmsc is\n \n       procedure Process_Sources_In_Multi_Language_Mode is\n          Source   : Source_Id;\n-         Src_Data : Source_Data_Access;\n          Name_Loc : Name_Location;\n          OK       : Boolean;\n          FF       : File_Found;\n@@ -8449,57 +8480,63 @@ package body Prj.Nmsc is\n \n          Source := Data.First_Source;\n          while Source /= No_Source loop\n-            Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n+            declare\n+               Src_Data : Source_Data renames\n+                 In_Tree.Sources.Table (Source);\n \n-            --  A file that is excluded cannot also be an exception file name\n+            begin\n+               --  A file that is excluded cannot also be an exception file\n+               --  name\n \n-            if Excluded_Sources_Htable.Get (Src_Data.File) /=\n-              No_File_Found\n-            then\n-               Error_Msg_File_1 := Src_Data.File;\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ cannot be both excluded and an exception file name\",\n-                  No_Location);\n-            end if;\n+               if Excluded_Sources_Htable.Get (Src_Data.File) /=\n+                 No_File_Found\n+               then\n+                  Error_Msg_File_1 := Src_Data.File;\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"{ cannot be both excluded and an exception file name\",\n+                     No_Location);\n+               end if;\n \n-            Name_Loc := (Name     => Src_Data.File,\n-                         Location => No_Location,\n-                         Source   => Source,\n-                         Except   => Src_Data.Unit /= No_Name,\n-                         Found    => False);\n+               Name_Loc := (Name     => Src_Data.File,\n+                            Location => No_Location,\n+                            Source   => Source,\n+                            Except   => Src_Data.Unit /= No_Name,\n+                            Found    => False);\n \n-            if Current_Verbosity = High then\n-               Write_Str (\"Putting source #\");\n-               Write_Str (Source'Img);\n-               Write_Str (\", file \");\n-               Write_Str (Get_Name_String (Src_Data.File));\n-               Write_Line (\" in Source_Names\");\n-            end if;\n+               if Current_Verbosity = High then\n+                  Write_Str (\"Putting source #\");\n+                  Write_Str (Source'Img);\n+                  Write_Str (\", file \");\n+                  Write_Str (Get_Name_String (Src_Data.File));\n+                  Write_Line (\" in Source_Names\");\n+               end if;\n \n-            Source_Names.Set (K => Src_Data.File, E => Name_Loc);\n+               Source_Names.Set (K => Src_Data.File, E => Name_Loc);\n \n-            --  If this is an Ada exception, record it in table Unit_Exceptions\n+               --  If this is an Ada exception, record it in table\n+               --  Unit_Exceptions\n \n-            if Src_Data.Unit /= No_Name then\n-               declare\n-                  Unit_Except : Unit_Exception :=\n-                                  Unit_Exceptions.Get (Src_Data.Unit);\n+               if Src_Data.Unit /= No_Name then\n+                  declare\n+                     Unit_Except : Unit_Exception :=\n+                       Unit_Exceptions.Get (Src_Data.Unit);\n \n-               begin\n-                  Unit_Except.Name := Src_Data.Unit;\n+                  begin\n+                     Unit_Except.Name := Src_Data.Unit;\n \n-                  if Src_Data.Kind = Spec then\n-                     Unit_Except.Spec := Src_Data.File;\n-                  else\n-                     Unit_Except.Impl := Src_Data.File;\n-                  end if;\n+                     if Src_Data.Kind = Spec then\n+                        Unit_Except.Spec := Src_Data.File;\n+                     else\n+                        Unit_Except.Impl := Src_Data.File;\n+                     end if;\n \n-                  Unit_Exceptions.Set (Src_Data.Unit, Unit_Except);\n-               end;\n-            end if;\n+                     Unit_Exceptions.Set (Src_Data.Unit, Unit_Except);\n+                  end;\n+               end if;\n \n-            Source := Src_Data.Next_In_Project;\n+               Source := Src_Data.Next_In_Project;\n+            end;\n          end loop;\n \n          Find_Explicit_Sources\n@@ -8513,25 +8550,29 @@ package body Prj.Nmsc is\n             Source := In_Tree.First_Source;\n \n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n+               declare\n+                  Src_Data : Source_Data renames\n+                    In_Tree.Sources.Table (Source);\n \n-               if Src_Data.File = FF.File then\n+               begin\n+                  if Src_Data.File = FF.File then\n \n-                  --  Check that this is from this project or a project that\n-                  --  the current project extends.\n+                     --  Check that this is from this project or a project that\n+                     --  the current project extends.\n \n-                  if Src_Data.Project = Project or else\n-                    Is_Extending (Project, Src_Data.Project, In_Tree)\n-                  then\n-                     Src_Data.Locally_Removed := True;\n-                     Src_Data.In_Interfaces := False;\n-                     Add_Forbidden_File_Name (FF.File);\n-                     OK := True;\n-                     exit;\n+                     if Src_Data.Project = Project or else\n+                       Is_Extending (Project, Src_Data.Project, In_Tree)\n+                     then\n+                        Src_Data.Locally_Removed := True;\n+                        Src_Data.In_Interfaces := False;\n+                        Add_Forbidden_File_Name (FF.File);\n+                        OK := True;\n+                        exit;\n+                     end if;\n                   end if;\n-               end if;\n \n-               Source := Src_Data.Next_In_Sources;\n+                  Source := Src_Data.Next_In_Sources;\n+               end;\n             end loop;\n \n             if not FF.Found and not OK then\n@@ -8547,10 +8588,9 @@ package body Prj.Nmsc is\n \n          Check_Object_File_Names : declare\n             Src_Id      : Source_Id;\n-            Src_Data    : Source_Data_Access;\n             Source_Name : File_Name_Type;\n \n-            procedure Check_Object;\n+            procedure Check_Object (Src_Data : Source_Data);\n             --  Check if object file name of the current source is already in\n             --  hash table Object_File_Names. If it is, report an error. If it\n             --  is not, put it there with the file name of the current source.\n@@ -8559,7 +8599,7 @@ package body Prj.Nmsc is\n             -- Check_Object --\n             ------------------\n \n-            procedure Check_Object is\n+            procedure Check_Object (Src_Data : Source_Data) is\n             begin\n                Source_Name := Object_File_Names.Get (Src_Data.Object);\n \n@@ -8583,54 +8623,60 @@ package body Prj.Nmsc is\n             Object_File_Names.Reset;\n             Src_Id := In_Tree.First_Source;\n             while Src_Id /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Src_Id)'Unrestricted_Access;\n+               declare\n+                  Src_Data : Source_Data renames\n+                    In_Tree.Sources.Table (Src_Id);\n \n-               if Src_Data.Compiled and then Src_Data.Object_Exists\n-                 and then Project_Extends (Project, Src_Data.Project, In_Tree)\n-               then\n-                  if Src_Data.Unit = No_Name then\n-                     if Src_Data.Kind = Impl then\n-                        Check_Object;\n-                     end if;\n+               begin\n+                  if Src_Data.Compiled and then Src_Data.Object_Exists\n+                    and then Project_Extends\n+                      (Project, Src_Data.Project, In_Tree)\n+                  then\n+                     if Src_Data.Unit = No_Name then\n+                        if Src_Data.Kind = Impl then\n+                           Check_Object (Src_Data);\n+                        end if;\n \n-                  else\n-                     case Src_Data.Kind is\n-                        when Spec =>\n-                           if Src_Data.Other_Part = No_Source then\n-                              Check_Object;\n-                           end if;\n+                     else\n+                        case Src_Data.Kind is\n+                           when Spec =>\n+                              if Src_Data.Other_Part = No_Source then\n+                                 Check_Object (Src_Data);\n+                              end if;\n \n-                        when Sep =>\n-                           null;\n+                           when Sep =>\n+                              null;\n \n-                        when Impl =>\n-                           if Src_Data.Other_Part /= No_Source then\n-                              Check_Object;\n+                           when Impl =>\n+                              if Src_Data.Other_Part /= No_Source then\n+                                 Check_Object (Src_Data);\n \n-                           else\n-                              --  Check if it is a subunit\n-\n-                              declare\n-                                 Src_Ind : constant Source_File_Index :=\n-                                             Sinput.P.Load_Project_File\n-                                               (Get_Name_String\n-                                                  (Src_Data.Path.Name));\n-\n-                              begin\n-                                 if Sinput.P.Source_File_Is_Subunit\n-                                     (Src_Ind)\n-                                 then\n-                                    In_Tree.Sources.Table (Src_Id).Kind := Sep;\n-                                 else\n-                                    Check_Object;\n-                                 end if;\n-                              end;\n-                           end if;\n-                     end case;\n+                              else\n+                                 --  Check if it is a subunit\n+\n+                                 declare\n+                                    Src_Ind : constant Source_File_Index :=\n+                                      Sinput.P.Load_Project_File\n+                                        (Get_Name_String\n+                                             (Src_Data.Path.Name));\n+\n+                                 begin\n+                                    if Sinput.P.Source_File_Is_Subunit\n+                                      (Src_Ind)\n+                                    then\n+                                       In_Tree.Sources.Table (Src_Id).Kind :=\n+                                         Sep;\n+                                    else\n+                                       Check_Object (Src_Data);\n+                                    end if;\n+                                 end;\n+                              end if;\n+                        end case;\n+                     end if;\n                   end if;\n-               end if;\n \n-               Src_Id := Src_Data.Next_In_Sources;\n+                  Src_Id := Src_Data.Next_In_Sources;\n+               end;\n             end loop;\n          end Check_Object_File_Names;\n       end Process_Sources_In_Multi_Language_Mode;"}, {"sha": "18bbd197aa0364cfdf3b89e587e0734dd4683657", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=ecc4ddde87a9d5ddbd115e118db5101bd0249437", "patch": "@@ -725,7 +725,8 @@ package Prj is\n       --  Dependency file time stamp\n \n       Switches            : File_Name_Type        := No_File;\n-      --  File name of the switches file\n+      --  File name of the switches file. For all languages, this is a file\n+      --  that ends with the .cswi extension.\n \n       Switches_Path       : Path_Name_Type        := No_Path;\n       --  Path name of the switches file"}, {"sha": "4fb37aef2e9ee465c77dea6003950d183fc30c91", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecc4ddde87a9d5ddbd115e118db5101bd0249437/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=ecc4ddde87a9d5ddbd115e118db5101bd0249437", "patch": "@@ -2515,7 +2515,7 @@ package body Sem_Ch8 is\n \n    procedure Analyze_Use_Type (N : Node_Id) is\n       E  : Entity_Id;\n-      Id : Entity_Id;\n+      Id : Node_Id;\n \n    begin\n       Set_Hidden_By_Use_Clause (N, No_Elist);\n@@ -2544,6 +2544,52 @@ package body Sem_Ch8 is\n                   Check_In_Previous_With_Clause (N, Prefix (Id));\n                end if;\n             end if;\n+\n+         else\n+            --  If the use_type_clause appears in a compilation context,\n+            --  check whether it comes from a unit that may appear in a\n+            --  limited with_clause, for a better error message.\n+\n+            if Nkind (Parent (N)) = N_Compilation_Unit\n+              and then Nkind (Id) /= N_Identifier\n+            then\n+               declare\n+                  Item : Node_Id;\n+                  Pref : Node_Id;\n+\n+                  function Mentioned (Nam : Node_Id) return Boolean;\n+                  --  check whether the prefix of expanded name for the\n+                  --  type appears in the prefix of some limited_with_clause.\n+\n+                  function Mentioned (Nam : Node_Id) return Boolean is\n+                  begin\n+                     if Nkind (Name (Item)) = N_Selected_Component\n+                       and then Chars (Prefix (Name (Item))) = Chars (Nam)\n+                     then\n+                        return True;\n+                     else\n+                        return False;\n+                     end if;\n+                  end Mentioned;\n+\n+               begin\n+                  Pref := Prefix (Id);\n+                  Item := First (Context_Items (Parent (N)));\n+                  while Present (Item)\n+                    and then Item /= N\n+                  loop\n+                     if Nkind (Item) = N_With_Clause\n+                       and then Limited_Present (Item)\n+                       and then Mentioned (Pref)\n+                     then\n+                        Change_Error_Text (Get_Msg_Id,\n+                           \"premature usage of incomplete type\");\n+                     end if;\n+\n+                     Next (Item);\n+                  end loop;\n+               end;\n+            end if;\n          end if;\n \n          Next (Id);\n@@ -7064,7 +7110,10 @@ package body Sem_Ch8 is\n       Set_Redundant_Use (Id,\n         Is_Known_Used or else Is_Potentially_Use_Visible (T));\n \n-      if In_Open_Scopes (Scope (T)) then\n+      if Ekind (T) = E_Incomplete_Type then\n+         Error_Msg_N (\"premature usage of incomplete type\", Id);\n+\n+      elsif In_Open_Scopes (Scope (T)) then\n          null;\n \n       --  A limited view cannot appear in a use_type clause. However, an"}]}