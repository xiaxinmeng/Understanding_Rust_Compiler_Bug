{"sha": "e27a1019c5cac8377587a3528d0b724b680ea646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI3YTEwMTljNWNhYzgzNzc1ODdhMzUyOGQwYjcyNGI2ODBlYTY0Ng==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-07-13T05:49:33Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-07-13T05:49:33Z"}, "message": "sh.c (mark_use): Remove.\n\n\t* config/sh/sh.c (mark_use): Remove.\n\nFrom-SVN: r126611", "tree": {"sha": "92be685e48b8e53dd8574463ad33a08234ddba3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92be685e48b8e53dd8574463ad33a08234ddba3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e27a1019c5cac8377587a3528d0b724b680ea646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27a1019c5cac8377587a3528d0b724b680ea646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e27a1019c5cac8377587a3528d0b724b680ea646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27a1019c5cac8377587a3528d0b724b680ea646/comments", "author": null, "committer": null, "parents": [{"sha": "cd7b7317eb677c69e9eaa4223f7ca7bd45b238a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7b7317eb677c69e9eaa4223f7ca7bd45b238a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd7b7317eb677c69e9eaa4223f7ca7bd45b238a9"}], "stats": {"total": 85, "additions": 4, "deletions": 81}, "files": [{"sha": "380c480a32fe3c897bf674ef4b4db9ce1b9006f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27a1019c5cac8377587a3528d0b724b680ea646/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27a1019c5cac8377587a3528d0b724b680ea646/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e27a1019c5cac8377587a3528d0b724b680ea646", "patch": "@@ -1,3 +1,7 @@\n+2007-07-13  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (mark_use): Remove.\n+\n 2007-07-12  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (thumb1_compute_save_reg_mask): Make sure scratch"}, {"sha": "ae1f916dc95a55cc1453684aaf584f1375b693a8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27a1019c5cac8377587a3528d0b724b680ea646/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27a1019c5cac8377587a3528d0b724b680ea646/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e27a1019c5cac8377587a3528d0b724b680ea646", "patch": "@@ -182,7 +182,6 @@ static rtx push (int);\n static void pop (int);\n static void push_regs (HARD_REG_SET *, int);\n static int calc_live_regs (HARD_REG_SET *);\n-static void mark_use (rtx, rtx *);\n static HOST_WIDE_INT rounded_frame_size (int);\n static rtx mark_constant_pool_use (rtx);\n const struct attribute_spec sh_attribute_table[];\n@@ -8378,86 +8377,6 @@ expand_df_binop (rtx (*fun) (rtx, rtx, rtx, rtx), rtx *operands)\n \t\t\tget_fpscr_rtx ()));\n }\n \f\n-/* ??? gcc does flow analysis strictly after common subexpression\n-   elimination.  As a result, common subexpression elimination fails\n-   when there are some intervening statements setting the same register.\n-   If we did nothing about this, this would hurt the precision switching\n-   for SH4 badly.  There is some cse after reload, but it is unable to\n-   undo the extra register pressure from the unused instructions, and\n-   it cannot remove auto-increment loads.\n-\n-   A C code example that shows this flow/cse weakness for (at least) SH\n-   and sparc (as of gcc ss-970706) is this:\n-\n-double\n-f(double a)\n-{\n-  double d;\n-  d = 0.1;\n-  a += d;\n-  d = 1.1;\n-  d = 0.1;\n-  a *= d;\n-  return a;\n-}\n-\n-   So we add another pass before common subexpression elimination, to\n-   remove assignments that are dead due to a following assignment in the\n-   same basic block.  */\n-\n-static void\n-mark_use (rtx x, rtx *reg_set_block)\n-{\n-  enum rtx_code code;\n-\n-  if (! x)\n-    return;\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case REG:\n-      {\n-\tint regno = REGNO (x);\n-\tint nregs = (regno < FIRST_PSEUDO_REGISTER\n-\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x))\n-\t\t     : 1);\n-\tdo\n-\t  {\n-\t    reg_set_block[regno + nregs - 1] = 0;\n-\t  }\n-\twhile (--nregs);\n-\tbreak;\n-      }\n-    case SET:\n-      {\n-\trtx dest = SET_DEST (x);\n-\n-\tif (GET_CODE (dest) == SUBREG)\n-\t  dest = SUBREG_REG (dest);\n-\tif (GET_CODE (dest) != REG)\n-\t  mark_use (dest, reg_set_block);\n-\tmark_use (SET_SRC (x), reg_set_block);\n-\tbreak;\n-      }\n-    case CLOBBER:\n-      break;\n-    default:\n-      {\n-\tconst char *fmt = GET_RTX_FORMAT (code);\n-\tint i, j;\n-\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t  {\n-\t    if (fmt[i] == 'e')\n-\t      mark_use (XEXP (x, i), reg_set_block);\n-\t    else if (fmt[i] == 'E')\n-\t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t\tmark_use (XVECEXP (x, i, j), reg_set_block);\n-\t  }\n-\tbreak;\n-      }\n-    }\n-}\n-\f\n static rtx get_free_reg (HARD_REG_SET);\n \n /* This function returns a register to use to load the address to load"}]}