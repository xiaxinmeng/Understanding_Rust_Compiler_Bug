{"sha": "14be52a22cda9918524fa0e4b6bb14ac1c466fdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiZTUyYTIyY2RhOTkxODUyNGZhMGU0YjZiYjE0YWMxYzQ2NmZkZA==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-02-15T20:52:13Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-02-15T20:52:13Z"}, "message": "re PR pch/14940 (PCH largefile test fails on various platforms)\n\n2005-02-15  James A. Morrison  <phython@gcc.gnu.org>\n\n       PR pch/14940\n       PR target/19300\n       * config/host-linux.c (linux_gt_pch_use_address): Copy from\n       config/pa/pa-host.c:pa_gt_pch_use_address.\n\nFrom-SVN: r95073", "tree": {"sha": "af007bbc8798751e7bf2b9c728971dfb3058f047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af007bbc8798751e7bf2b9c728971dfb3058f047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14be52a22cda9918524fa0e4b6bb14ac1c466fdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14be52a22cda9918524fa0e4b6bb14ac1c466fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14be52a22cda9918524fa0e4b6bb14ac1c466fdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14be52a22cda9918524fa0e4b6bb14ac1c466fdd/comments", "author": null, "committer": null, "parents": [{"sha": "eace8c18aa504923067581a1037a37b1cce97f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eace8c18aa504923067581a1037a37b1cce97f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eace8c18aa504923067581a1037a37b1cce97f9e"}], "stats": {"total": 73, "additions": 73, "deletions": 0}, "files": [{"sha": "42e602b36873a0655e23f41ae7a265a8417a958e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14be52a22cda9918524fa0e4b6bb14ac1c466fdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14be52a22cda9918524fa0e4b6bb14ac1c466fdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14be52a22cda9918524fa0e4b6bb14ac1c466fdd", "patch": "@@ -1,3 +1,10 @@\n+2005-02-15  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\tPR pch/14940\n+\tPR target/19300\n+\t* config/host-linux.c (linux_gt_pch_use_address): Copy from\n+\tconfig/pa/pa-host.c:pa_gt_pch_use_address.\n+\n 2005-02-15  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-vn.c (get_value_handle): Make sure that given an"}, {"sha": "7683c720c05265d13022e240b3d143762529550c", "filename": "gcc/config/host-linux.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14be52a22cda9918524fa0e4b6bb14ac1c466fdd/gcc%2Fconfig%2Fhost-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14be52a22cda9918524fa0e4b6bb14ac1c466fdd/gcc%2Fconfig%2Fhost-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-linux.c?ref=14be52a22cda9918524fa0e4b6bb14ac1c466fdd", "patch": "@@ -61,6 +61,9 @@\n #undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n #define HOST_HOOKS_GT_PCH_GET_ADDRESS linux_gt_pch_get_address\n \n+#undef HOST_HOOKS_GT_PCH_USE_ADDRESS\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS linux_gt_pch_use_address\n+\n /* For various ports, try to guess a fixed spot in the vm space\n    that's probably free.  */\n #if defined(__alpha)\n@@ -143,5 +146,68 @@ linux_gt_pch_get_address (size_t size, int fd)\n   return addr;\n }\n \n+/* Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at\n+   mapping the data at BASE, -1 if we couldn't.\n+\n+   It's not possibly to reliably mmap a file using MAP_PRIVATE to\n+   a specific START address on either hpux or linux.  First we see\n+   if mmap with MAP_PRIVATE works.  If it does, we are off to the\n+   races.  If it doesn't, we try an anonymous private mmap since the\n+   kernel is more likely to honor the BASE address in anonymous maps.\n+   We then copy the data to the anonymous private map.  This assumes\n+   of course that we don't need to change the data in the PCH file\n+   after it is created.\n+\n+   This approach obviously causes a performance penalty but there is\n+   little else we can do given the current PCH implementation.  */\n+\n+static int\n+linux_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+{\n+  void *addr;\n+\n+  /* We're called with size == 0 if we're not planning to load a PCH\n+     file at all.  This allows the hook to free any static space that\n+     we might have allocated at link time.  */\n+  if (size == 0)\n+    return -1;\n+\n+  /* Try to map the file with MAP_PRIVATE.  */\n+  addr = mmap (base, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, offset);\n+\n+  if (addr == base)\n+    return 1;\n+\n+  if (addr != (void *) MAP_FAILED)\n+    munmap (addr, size);\n+\n+  /* Try to make an anonymous private mmap at the desired location.  */\n+  addr = mmap (base, size, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+\n+  if (addr != base)\n+    {\n+      if (addr != (void *) MAP_FAILED)\n+        munmap (addr, size);\n+      return -1;\n+    }\n+\n+  if (lseek (fd, offset, SEEK_SET) == (off_t)-1)\n+    return -1;\n+\n+  while (size)\n+    {\n+      ssize_t nbytes;\n+\n+      nbytes = read (fd, base, MIN (size, SSIZE_MAX));\n+      if (nbytes <= 0)\n+        return -1;\n+      base = (char *) base + nbytes;\n+      size -= nbytes;\n+    }\n+\n+  return 1;\n+}\n+\n \f\n const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;"}]}