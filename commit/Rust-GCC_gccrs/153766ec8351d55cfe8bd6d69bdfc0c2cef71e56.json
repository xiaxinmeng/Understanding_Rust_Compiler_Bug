{"sha": "153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUzNzY2ZWM4MzUxZDU1Y2ZlOGJkNmQ2OWJkZmMwYzJjZWY3MWU1Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-31T08:28:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-01T10:54:14Z"}, "message": "tree-optimization/102139 - fix SLP DR base alignment\n\nWhen doing whole-function SLP we have to make sure the recorded\nbase alignments we compute as the maximum alignment seen for a\nbase anywhere in the function is actually valid at the point\nwe want to make use of it.\n\nTo make this work we now record the stmt the alignment was derived\nfrom in addition to the DRs innermost behavior and we use a\ndominance check to verify the recorded info is valid when doing\nBB vectorization.  For this to work for groups inside a BB that are\nseparate by a call that might not return we now store the DR\nanalysis group-id permanently and use that for an additional check\nwhen the DRs are in the same BB.\n\n2021-08-31  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102139\n\t* tree-vectorizer.h (vec_base_alignments): Adjust hash-map\n\ttype to record a std::pair of the stmt-info and the innermost\n\tloop behavior.\n\t(dr_vec_info::group): New member.\n\t* tree-vect-data-refs.c (vect_record_base_alignment): Adjust.\n\t(vect_compute_data_ref_alignment): Verify the recorded\n\tbase alignment can be used.\n\t(data_ref_pair): Remove.\n\t(dr_group_sort_cmp): Adjust.\n\t(vect_analyze_data_ref_accesses): Store the group-ID in the\n\tdr_vec_info and operate on a vector of dr_vec_infos.\n\n\t* gcc.dg/torture/pr102139.c: New testcase.", "tree": {"sha": "ebb2c8b87ddc274e6732f491c48f03658a4c3780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebb2c8b87ddc274e6732f491c48f03658a4c3780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea1a16420cd2cd23917a1fd8be08ea929e55a55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1a16420cd2cd23917a1fd8be08ea929e55a55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea1a16420cd2cd23917a1fd8be08ea929e55a55b"}], "stats": {"total": 119, "additions": 85, "deletions": 34}, "files": [{"sha": "06c1357438aad1c8785eb1340374ebda9e748839", "filename": "gcc/testsuite/gcc.dg/torture/pr102139.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr102139.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr102139.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr102139.c?ref=153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-ftree-slp-vectorize\" } */\n+\n+typedef double aligned_double __attribute__((aligned(2*sizeof(double))));\n+\n+void __attribute__((noipa))\n+bar (int aligned, double *p)\n+{\n+  if (aligned)\n+    {\n+      *(aligned_double *)p = 3.;\n+      p[1] = 4.;\n+    }\n+  else\n+    {\n+      p[2] = 0.;\n+      p[3] = 1.;\n+    }\n+}\n+\n+void __attribute__((noipa))\n+foo (int i)\n+{\n+  if (i)\n+    __builtin_exit (0);\n+}\n+void __attribute__((noipa))\n+baz (double *p)\n+{\n+  p[0] = 0.;\n+  p[1] = 1.;\n+  foo (1);\n+  *(aligned_double *)p = 3.;\n+  p[1] = 4.;\n+}\n+\n+double x[8] __attribute__((aligned(2*sizeof (double))));\n+int main()\n+{\n+  bar (0, &x[1]);\n+  baz (&x[1]);\n+  return 0;\n+}"}, {"sha": "f43d0f4785e90942e93f9b00c8800367af50b574", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "patch": "@@ -895,11 +895,11 @@ vect_record_base_alignment (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t\t    innermost_loop_behavior *drb)\n {\n   bool existed;\n-  innermost_loop_behavior *&entry\n+  std::pair<stmt_vec_info, innermost_loop_behavior *> &entry\n     = vinfo->base_alignments.get_or_insert (drb->base_address, &existed);\n-  if (!existed || entry->base_alignment < drb->base_alignment)\n+  if (!existed || entry.second->base_alignment < drb->base_alignment)\n     {\n-      entry = drb;\n+      entry = std::make_pair (stmt_info, drb);\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"recording new base alignment for %T\\n\"\n@@ -1060,11 +1060,18 @@ vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n \n   /* Calculate the maximum of the pooled base address alignment and the\n      alignment that we can compute for DR itself.  */\n-  innermost_loop_behavior **entry = base_alignments->get (drb->base_address);\n-  if (entry && base_alignment < (*entry)->base_alignment)\n+  std::pair<stmt_vec_info, innermost_loop_behavior *> *entry\n+    = base_alignments->get (drb->base_address);\n+  if (entry\n+      && base_alignment < (*entry).second->base_alignment\n+      && (loop_vinfo\n+\t  || (dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt_info->stmt),\n+\t\t\t      gimple_bb (entry->first->stmt))\n+\t      && (gimple_bb (stmt_info->stmt) != gimple_bb (entry->first->stmt)\n+\t\t  || (entry->first->dr_aux.group <= dr_info->group)))))\n     {\n-      base_alignment = (*entry)->base_alignment;\n-      base_misalignment = (*entry)->base_misalignment;\n+      base_alignment = entry->second->base_alignment;\n+      base_misalignment = entry->second->base_misalignment;\n     }\n \n   if (drb->offset_alignment < vect_align_c\n@@ -2813,27 +2820,25 @@ vect_analyze_data_ref_access (vec_info *vinfo, dr_vec_info *dr_info)\n   return vect_analyze_group_access (vinfo, dr_info);\n }\n \n-typedef std::pair<data_reference_p, int> data_ref_pair;\n-\n /* Compare two data-references DRA and DRB to group them into chunks\n    suitable for grouping.  */\n \n static int\n dr_group_sort_cmp (const void *dra_, const void *drb_)\n {\n-  data_ref_pair dra_pair = *(data_ref_pair *)const_cast<void *>(dra_);\n-  data_ref_pair drb_pair = *(data_ref_pair *)const_cast<void *>(drb_);\n-  data_reference_p dra = dra_pair.first;\n-  data_reference_p drb = drb_pair.first;\n+  dr_vec_info *dra_info = *(dr_vec_info **)const_cast<void *>(dra_);\n+  dr_vec_info *drb_info = *(dr_vec_info **)const_cast<void *>(drb_);\n+  data_reference_p dra = dra_info->dr;\n+  data_reference_p drb = drb_info->dr;\n   int cmp;\n \n   /* Stabilize sort.  */\n   if (dra == drb)\n     return 0;\n \n   /* Different group IDs lead never belong to the same group.  */\n-  if (dra_pair.second != drb_pair.second)\n-    return dra_pair.second < drb_pair.second ? -1 : 1;\n+  if (dra_info->group != drb_info->group)\n+    return dra_info->group < drb_info->group ? -1 : 1;\n \n   /* Ordering of DRs according to base.  */\n   cmp = data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n@@ -2953,28 +2958,28 @@ vect_analyze_data_ref_accesses (vec_info *vinfo,\n   /* Sort the array of datarefs to make building the interleaving chains\n      linear.  Don't modify the original vector's order, it is needed for\n      determining what dependencies are reversed.  */\n-  vec<data_ref_pair> datarefs_copy;\n+  vec<dr_vec_info *> datarefs_copy;\n   datarefs_copy.create (datarefs.length ());\n   for (unsigned i = 0; i < datarefs.length (); i++)\n     {\n-      int group_id;\n+      dr_vec_info *dr_info = vinfo->lookup_dr (datarefs[i]);\n       /* If the caller computed DR grouping use that, otherwise group by\n \t basic blocks.  */\n       if (dataref_groups)\n-\tgroup_id = (*dataref_groups)[i];\n+\tdr_info->group = (*dataref_groups)[i];\n       else\n-\tgroup_id = gimple_bb (DR_STMT (datarefs[i]))->index;\n-      datarefs_copy.quick_push (data_ref_pair (datarefs[i], group_id));\n+\tdr_info->group = gimple_bb (DR_STMT (datarefs[i]))->index;\n+      datarefs_copy.quick_push (dr_info);\n     }\n   datarefs_copy.qsort (dr_group_sort_cmp);\n   hash_set<stmt_vec_info> to_fixup;\n \n   /* Build the interleaving chains.  */\n   for (i = 0; i < datarefs_copy.length () - 1;)\n     {\n-      data_reference_p dra = datarefs_copy[i].first;\n-      int dra_group_id = datarefs_copy[i].second;\n-      dr_vec_info *dr_info_a = vinfo->lookup_dr (dra);\n+      dr_vec_info *dr_info_a = datarefs_copy[i];\n+      data_reference_p dra = dr_info_a->dr;\n+      int dra_group_id = dr_info_a->group;\n       stmt_vec_info stmtinfo_a = dr_info_a->stmt;\n       stmt_vec_info lastinfo = NULL;\n       if (!STMT_VINFO_VECTORIZABLE (stmtinfo_a)\n@@ -2985,9 +2990,9 @@ vect_analyze_data_ref_accesses (vec_info *vinfo,\n \t}\n       for (i = i + 1; i < datarefs_copy.length (); ++i)\n \t{\n-\t  data_reference_p drb = datarefs_copy[i].first;\n-\t  int drb_group_id = datarefs_copy[i].second;\n-\t  dr_vec_info *dr_info_b = vinfo->lookup_dr (drb);\n+\t  dr_vec_info *dr_info_b = datarefs_copy[i];\n+\t  data_reference_p drb = dr_info_b->dr;\n+\t  int drb_group_id = dr_info_b->group;\n \t  stmt_vec_info stmtinfo_b = dr_info_b->stmt;\n \t  if (!STMT_VINFO_VECTORIZABLE (stmtinfo_b)\n \t      || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n@@ -3048,15 +3053,15 @@ vect_analyze_data_ref_accesses (vec_info *vinfo,\n \t  HOST_WIDE_INT init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n \t  HOST_WIDE_INT init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n \t  HOST_WIDE_INT init_prev\n-\t    = TREE_INT_CST_LOW (DR_INIT (datarefs_copy[i-1].first));\n+\t    = TREE_INT_CST_LOW (DR_INIT (datarefs_copy[i-1]->dr));\n \t  gcc_assert (init_a <= init_b\n \t\t      && init_a <= init_prev\n \t\t      && init_prev <= init_b);\n \n \t  /* Do not place the same access in the interleaving chain twice.  */\n \t  if (init_b == init_prev)\n \t    {\n-\t      gcc_assert (gimple_uid (DR_STMT (datarefs_copy[i-1].first))\n+\t      gcc_assert (gimple_uid (DR_STMT (datarefs_copy[i-1]->dr))\n \t\t\t  < gimple_uid (DR_STMT (drb)));\n \t      /* Simply link in duplicates and fix up the chain below.  */\n \t    }\n@@ -3169,10 +3174,9 @@ vect_analyze_data_ref_accesses (vec_info *vinfo,\n       to_fixup.add (newgroup);\n     }\n \n-  data_ref_pair *dr_pair;\n-  FOR_EACH_VEC_ELT (datarefs_copy, i, dr_pair)\n+  dr_vec_info *dr_info;\n+  FOR_EACH_VEC_ELT (datarefs_copy, i, dr_info)\n     {\n-      dr_vec_info *dr_info = vinfo->lookup_dr (dr_pair->first);\n       if (STMT_VINFO_VECTORIZABLE (dr_info->stmt)\n \t  && !vect_analyze_data_ref_access (vinfo, dr_info))\n \t{"}, {"sha": "7453d2a91312ca6133c3b009bb02af0c38c63719", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/153766ec8351d55cfe8bd6d69bdfc0c2cef71e56/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=153766ec8351d55cfe8bd6d69bdfc0c2cef71e56", "patch": "@@ -106,10 +106,11 @@ struct stmt_info_for_cost {\n \n typedef vec<stmt_info_for_cost> stmt_vector_for_cost;\n \n-/* Maps base addresses to an innermost_loop_behavior that gives the maximum\n-   known alignment for that base.  */\n+/* Maps base addresses to an innermost_loop_behavior and the stmt it was\n+   derived from that gives the maximum known alignment for that base.  */\n typedef hash_map<tree_operand_hash,\n-\t\t innermost_loop_behavior *> vec_base_alignments;\n+\t\t std::pair<stmt_vec_info, innermost_loop_behavior *> >\n+\t  vec_base_alignments;\n \n /************************************************************************\n   SLP\n@@ -1059,6 +1060,9 @@ class dr_vec_info {\n   data_reference *dr;\n   /* The statement that contains the data reference.  */\n   stmt_vec_info stmt;\n+  /* The analysis group this DR belongs to when doing BB vectorization.\n+     DRs of the same group belong to the same conditional execution context.  */\n+  unsigned group;\n   /* The misalignment in bytes of the reference, or -1 if not known.  */\n   int misalignment;\n   /* The byte alignment that we'd ideally like the reference to have,"}]}