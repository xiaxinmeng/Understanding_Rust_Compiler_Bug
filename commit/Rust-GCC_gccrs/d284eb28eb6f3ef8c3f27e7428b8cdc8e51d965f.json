{"sha": "d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4NGViMjhlYjZmM2VmOGMzZjI3ZTc0MjhiOGNkYzhlNTFkOTY1Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-01-21T17:54:26Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-01-21T17:54:26Z"}, "message": "re PR rtl-optimization/576 (gcc performs invalid optimization with float operations when different rounding mode.)\n\n\n\tPR rtl-optimization/576\n\t* real.c (real_arithmetic): Change return type from void to bool\n\tto return an indication that the result may be inexact.\n\t* real.h (real_arithmeric): Update prototype.\n\t* fold-const.c (const_binop):  Don't constant fold floating\n\tpoint expressions when the user specifies -frounding-math and\n\tthe result may depend upon the run-time rounding mode.\n\t(fold_convert_const_real_from_real): Clean-up.\n\t(fold_initializer): Ignore flag_rounding_math for initializers.\n\t* simplify-rtx.c (simplify_binary_operation): Likewise, don't\n\tconstant fold FP operations with flag_rounding_math if the\n\tresult may depend upon the run-time rounding mode.\n\nFrom-SVN: r94020", "tree": {"sha": "87965b49d99f08cdf39d5e6360e95fccbda397a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87965b49d99f08cdf39d5e6360e95fccbda397a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/comments", "author": null, "committer": null, "parents": [{"sha": "a101957b98129887878b4e98830147e49fa4f655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a101957b98129887878b4e98830147e49fa4f655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a101957b98129887878b4e98830147e49fa4f655"}], "stats": {"total": 89, "additions": 58, "deletions": 31}, "files": [{"sha": "7c07cc430f8becbe0bd7f2be6bfe9558d1d935e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "patch": "@@ -1,3 +1,18 @@\n+2005-01-21  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/576\n+\t* real.c (real_arithmetic): Change return type from void to bool\n+\tto return an indication that the result may be inexact.\n+\t* real.h (real_arithmeric): Update prototype.\n+\t* fold-const.c (const_binop):  Don't constant fold floating\n+\tpoint expressions when the user specifies -frounding-math and\n+\tthe result may depend upon the run-time rounding mode.\n+\t(fold_convert_const_real_from_real): Clean-up.\n+\t(fold_initializer): Ignore flag_rounding_math for initializers.\n+\t* simplify-rtx.c (simplify_binary_operation): Likewise, don't\n+\tconstant fold FP operations with flag_rounding_math if the\n+\tresult may depend upon the run-time rounding mode.\n+\n 2005-01-21  Tom Tromey  <tromey@redhat.com>\n \n \t* c-cppbuiltin.c (define__GNUC__): Correct assertion."}, {"sha": "cb822ed2ec536bf9ec9b65a2952d55de28c41164", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "patch": "@@ -1482,6 +1482,8 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       REAL_VALUE_TYPE d1;\n       REAL_VALUE_TYPE d2;\n       REAL_VALUE_TYPE value;\n+      REAL_VALUE_TYPE result;\n+      bool inexact;\n       tree t, type;\n \n       d1 = TREE_REAL_CST (arg1);\n@@ -1510,9 +1512,18 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       else if (REAL_VALUE_ISNAN (d2))\n \treturn arg2;\n \n-      REAL_ARITHMETIC (value, code, d1, d2);\n+      inexact = real_arithmetic (&value, code, &d1, &d2);\n+      real_convert (&result, mode, &value);\n \n-      t = build_real (type, real_value_truncate (mode, value));\n+      /* Don't constant fold this floating point operation if the\n+\t result may dependent upon the run-time rounding mode and\n+\t flag_rounding_math is set.  */\n+      \n+      if (flag_rounding_math\n+\t  && (inexact || !real_identical (&result, &value)))\n+\treturn NULL_TREE;\n+\n+      t = build_real (type, result);\n \n       TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2);\n       TREE_CONSTANT_OVERFLOW (t)\n@@ -1808,20 +1819,11 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, tree arg1)\n static tree\n fold_convert_const_real_from_real (tree type, tree arg1)\n {\n+  REAL_VALUE_TYPE value;\n   tree t;\n \n-  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n-    {\n-      /* We make a copy of ARG1 so that we don't modify an\n-\t existing constant tree.  */\n-      t = copy_node (arg1);\n-      TREE_TYPE (t) = type;\n-      return t;\n-    }\n-\n-  t = build_real (type,\n-\t\t  real_value_truncate (TYPE_MODE (type),\n-\t\t\t\t       TREE_REAL_CST (arg1)));\n+  real_convert (&value, TYPE_MODE (type), &TREE_REAL_CST (arg1));\n+  t = build_real (type, value);\n \n   TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);\n   TREE_CONSTANT_OVERFLOW (t)\n@@ -9506,17 +9508,20 @@ fold_initializer (tree expr)\n {\n   int saved_signaling_nans = flag_signaling_nans;\n   int saved_trapping_math = flag_trapping_math;\n+  int saved_rounding_math = flag_rounding_math;\n   int saved_trapv = flag_trapv;\n   tree result;\n \n   flag_signaling_nans = 0;\n   flag_trapping_math = 0;\n+  flag_rounding_math = 0;\n   flag_trapv = 0;\n \n   result = fold (expr);\n \n   flag_signaling_nans = saved_signaling_nans;\n   flag_trapping_math = saved_trapping_math;\n+  flag_rounding_math = saved_rounding_math;\n   flag_trapv = saved_trapv;\n \n   return result;"}, {"sha": "a748b87b33a82fa2317aacaeb6587c2fd74f0ba9", "filename": "gcc/real.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "patch": "@@ -972,9 +972,10 @@ do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n }\n \n /* Perform the binary or unary operation described by CODE.\n-   For a unary operation, leave OP1 NULL.  */\n+   For a unary operation, leave OP1 NULL.  This function returns\n+   true if the result may be inexact due to loss of precision.  */\n \n-void\n+bool\n real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n \t\t const REAL_VALUE_TYPE *op1)\n {\n@@ -983,20 +984,16 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n   switch (code)\n     {\n     case PLUS_EXPR:\n-      do_add (r, op0, op1, 0);\n-      break;\n+      return do_add (r, op0, op1, 0);\n \n     case MINUS_EXPR:\n-      do_add (r, op0, op1, 1);\n-      break;\n+      return do_add (r, op0, op1, 1);\n \n     case MULT_EXPR:\n-      do_multiply (r, op0, op1);\n-      break;\n+      return do_multiply (r, op0, op1);\n \n     case RDIV_EXPR:\n-      do_divide (r, op0, op1);\n-      break;\n+      return do_divide (r, op0, op1);\n \n     case MIN_EXPR:\n       if (op1->cl == rvc_nan)\n@@ -1033,6 +1030,7 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n     default:\n       gcc_unreachable ();\n     }\n+  return false;\n }\n \n /* Legacy.  Similar, but return the result directly.  */"}, {"sha": "b7cf3bb2f04205f70c39c0eb3958b5577da6fa20", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "patch": "@@ -160,7 +160,7 @@ extern const struct real_format *\n /* Declare functions in real.c.  */\n \n /* Binary or unary arithmetic on tree_code.  */\n-extern void real_arithmetic (REAL_VALUE_TYPE *, int, const REAL_VALUE_TYPE *,\n+extern bool real_arithmetic (REAL_VALUE_TYPE *, int, const REAL_VALUE_TYPE *,\n \t\t\t     const REAL_VALUE_TYPE *);\n \n /* Compare reals by tree_code.  */"}, {"sha": "92567fe3c41b79d4bda8df41990916b5d746dc52", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=d284eb28eb6f3ef8c3f27e7428b8cdc8e51d965f", "patch": "@@ -1288,12 +1288,13 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t}\n       else\n \t{\n-\t  REAL_VALUE_TYPE f0, f1, value;\n+\t  REAL_VALUE_TYPE f0, f1, value, result;\n+\t  bool inexact;\n \n \t  REAL_VALUE_FROM_CONST_DOUBLE (f0, trueop0);\n \t  REAL_VALUE_FROM_CONST_DOUBLE (f1, trueop1);\n-\t  f0 = real_value_truncate (mode, f0);\n-\t  f1 = real_value_truncate (mode, f1);\n+\t  real_convert (&f0, mode, &f0);\n+\t  real_convert (&f1, mode, &f1);\n \n \t  if (HONOR_SNANS (mode)\n \t      && (REAL_VALUE_ISNAN (f0) || REAL_VALUE_ISNAN (f1)))\n@@ -1339,10 +1340,18 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t    /* Inf * 0 = NaN plus exception.  */\n \t    return 0;\n \n-\t  REAL_ARITHMETIC (value, rtx_to_tree_code (code), f0, f1);\n+\t  inexact = real_arithmetic (&value, rtx_to_tree_code (code),\n+\t\t\t\t     &f0, &f1);\n+\t  real_convert (&result, mode, &value);\n \n-\t  value = real_value_truncate (mode, value);\n-\t  return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n+\t  /* Don't constant fold this floating point operation if the\n+\t     result may dependent upon the run-time rounding mode and\n+\t     flag_rounding_math is set.  */\n+\t  if (flag_rounding_math\n+\t      && (inexact || !real_identical (&result, &value)))\n+\t    return NULL_RTX;\n+\n+\t  return CONST_DOUBLE_FROM_REAL_VALUE (result, mode);\n \t}\n     }\n "}]}