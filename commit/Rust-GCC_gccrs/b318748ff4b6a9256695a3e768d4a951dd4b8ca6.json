{"sha": "b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMxODc0OGZmNGI2YTkyNTY2OTVhM2U3NjhkNGE5NTFkZDRiOGNhNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2001-12-04T09:33:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2001-12-04T09:33:17Z"}, "message": "flow.c (ior_reg_cond): Return NULL if ! add and rtx wasn't optimized.\n\n\t* flow.c (ior_reg_cond): Return NULL if ! add and rtx wasn't optimized.\n\tReturn correct value if one of the subexpressions was optimized to\n\t0 resp. 1.  Optimize (x | A) | x and (x & A) | x.\n\t(and_reg_cond): Similarly.\n\n\t* gcc.c-torture/compile/20011130-2.c: New test.\n\nFrom-SVN: r47602", "tree": {"sha": "f4cbf2a19a8962de46bab2e668b5770fcd6f9668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4cbf2a19a8962de46bab2e668b5770fcd6f9668"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "108b7d3d316599861369de7c7f9bfaef915c7bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108b7d3d316599861369de7c7f9bfaef915c7bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108b7d3d316599861369de7c7f9bfaef915c7bd3"}], "stats": {"total": 176, "additions": 126, "deletions": 50}, "files": [{"sha": "fff9d986497039a2fae28a7989c33b2c1656174c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "patch": "@@ -1,3 +1,10 @@\n+2001-12-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* flow.c (ior_reg_cond): Return NULL if ! add and rtx wasn't optimized.\n+\tReturn correct value if one of the subexpressions was optimized to\n+\t0 resp. 1.  Optimize (x | A) | x and (x & A) | x.\n+\t(and_reg_cond): Similarly.\n+\n 2001-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* function.c (assign_parms): Set last_named only for last named"}, {"sha": "fdf4df29b1be13b183dc92f05b340868f703adfa", "filename": "gcc/flow.c", "status": "modified", "additions": 63, "deletions": 50, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "patch": "@@ -2796,7 +2796,7 @@ flush_reg_cond_reg (pbi, regno)\n    For ior/and, the ADD flag determines whether we want to add the new\n    condition X to the old one unconditionally.  If it is zero, we will\n    only return a new expression if X allows us to simplify part of\n-   OLD, otherwise we return OLD unchanged to the caller.\n+   OLD, otherwise we return NULL to the caller.\n    If ADD is nonzero, we will return a new condition in all cases.  The\n    toplevel caller of one of these functions should always pass 1 for\n    ADD.  */\n@@ -2818,7 +2818,7 @@ ior_reg_cond (old, x, add)\n \t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n \treturn old;\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_IOR (0, old, x);\n     }\n \n@@ -2827,51 +2827,63 @@ ior_reg_cond (old, x, add)\n     case IOR:\n       op0 = ior_reg_cond (XEXP (old, 0), x, 0);\n       op1 = ior_reg_cond (XEXP (old, 1), x, 0);\n-      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n+      if (op0 != NULL || op1 != NULL)\n \t{\n \t  if (op0 == const0_rtx)\n-\t    return op1;\n+\t    return op1 ? op1 : gen_rtx_IOR (0, XEXP (old, 1), x);\n \t  if (op1 == const0_rtx)\n-\t    return op0;\n+\t    return op0 ? op0 : gen_rtx_IOR (0, XEXP (old, 0), x);\n \t  if (op0 == const1_rtx || op1 == const1_rtx)\n \t    return const1_rtx;\n-\t  if (op0 == XEXP (old, 0))\n-\t    op0 = gen_rtx_IOR (0, op0, x);\n-\t  else\n-\t    op1 = gen_rtx_IOR (0, op1, x);\n+\t  if (op0 == NULL)\n+\t    op0 = gen_rtx_IOR (0, XEXP (old, 0), x);\n+\t  else if (rtx_equal_p (x, op0))\n+\t    /* (x | A) | x ~ (x | A).  */\n+\t    return old;\n+\t  if (op1 == NULL)\n+\t    op1 = gen_rtx_IOR (0, XEXP (old, 1), x);\n+\t  else if (rtx_equal_p (x, op1))\n+\t    /* (A | x) | x ~ (A | x).  */\n+\t    return old;\n \t  return gen_rtx_IOR (0, op0, op1);\n \t}\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_IOR (0, old, x);\n \n     case AND:\n       op0 = ior_reg_cond (XEXP (old, 0), x, 0);\n       op1 = ior_reg_cond (XEXP (old, 1), x, 0);\n-      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n+      if (op0 != NULL || op1 != NULL)\n \t{\n \t  if (op0 == const1_rtx)\n-\t    return op1;\n+\t    return op1 ? op1 : gen_rtx_IOR (0, XEXP (old, 1), x);\n \t  if (op1 == const1_rtx)\n-\t    return op0;\n+\t    return op0 ? op0 : gen_rtx_IOR (0, XEXP (old, 0), x);\n \t  if (op0 == const0_rtx || op1 == const0_rtx)\n \t    return const0_rtx;\n-\t  if (op0 == XEXP (old, 0))\n-\t    op0 = gen_rtx_IOR (0, op0, x);\n-\t  else\n-\t    op1 = gen_rtx_IOR (0, op1, x);\n+\t  if (op0 == NULL)\n+\t    op0 = gen_rtx_IOR (0, XEXP (old, 0), x);\n+\t  else if (rtx_equal_p (x, op0))\n+\t    /* (x & A) | x ~ x.  */\n+\t    return op0;\n+\t  if (op1 == NULL)\n+\t    op1 = gen_rtx_IOR (0, XEXP (old, 1), x);\n+\t  else if (rtx_equal_p (x, op1))\n+\t    /* (A & x) | x ~ x.  */\n+\t    return op1;\n \t  return gen_rtx_AND (0, op0, op1);\n \t}\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_IOR (0, old, x);\n \n     case NOT:\n       op0 = and_reg_cond (XEXP (old, 0), not_reg_cond (x), 0);\n-      if (op0 != XEXP (old, 0))\n+      if (op0 != NULL)\n \treturn not_reg_cond (op0);\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_IOR (0, old, x);\n \n     default:\n@@ -2921,7 +2933,7 @@ and_reg_cond (old, x, add)\n \t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n \treturn old;\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_AND (0, old, x);\n     }\n \n@@ -2930,62 +2942,63 @@ and_reg_cond (old, x, add)\n     case IOR:\n       op0 = and_reg_cond (XEXP (old, 0), x, 0);\n       op1 = and_reg_cond (XEXP (old, 1), x, 0);\n-      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n+      if (op0 != NULL || op1 != NULL)\n \t{\n \t  if (op0 == const0_rtx)\n-\t    return op1;\n+\t    return op1 ? op1 : gen_rtx_AND (0, XEXP (old, 1), x);\n \t  if (op1 == const0_rtx)\n-\t    return op0;\n+\t    return op0 ? op0 : gen_rtx_AND (0, XEXP (old, 0), x);\n \t  if (op0 == const1_rtx || op1 == const1_rtx)\n \t    return const1_rtx;\n-\t  if (op0 == XEXP (old, 0))\n-\t    op0 = gen_rtx_AND (0, op0, x);\n-\t  else\n-\t    op1 = gen_rtx_AND (0, op1, x);\n+\t  if (op0 == NULL)\n+\t    op0 = gen_rtx_AND (0, XEXP (old, 0), x);\n+\t  else if (rtx_equal_p (x, op0))\n+\t    /* (x | A) & x ~ x.  */\n+\t    return op0;\n+\t  if (op1 == NULL)\n+\t    op1 = gen_rtx_AND (0, XEXP (old, 1), x);\n+\t  else if (rtx_equal_p (x, op1))\n+\t    /* (A | x) & x ~ x.  */\n+\t    return op1;\n \t  return gen_rtx_IOR (0, op0, op1);\n \t}\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_AND (0, old, x);\n \n     case AND:\n       op0 = and_reg_cond (XEXP (old, 0), x, 0);\n       op1 = and_reg_cond (XEXP (old, 1), x, 0);\n-      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n+      if (op0 != NULL || op1 != NULL)\n \t{\n \t  if (op0 == const1_rtx)\n-\t    return op1;\n+\t    return op1 ? op1 : gen_rtx_AND (0, XEXP (old, 1), x);\n \t  if (op1 == const1_rtx)\n-\t    return op0;\n+\t    return op0 ? op0 : gen_rtx_AND (0, XEXP (old, 0), x);\n \t  if (op0 == const0_rtx || op1 == const0_rtx)\n \t    return const0_rtx;\n-\t  if (op0 == XEXP (old, 0))\n-\t    op0 = gen_rtx_AND (0, op0, x);\n-\t  else\n-\t    op1 = gen_rtx_AND (0, op1, x);\n+\t  if (op0 == NULL)\n+\t    op0 = gen_rtx_AND (0, XEXP (old, 0), x);\n+\t  else if (rtx_equal_p (x, op0))\n+\t    /* (x & A) & x ~ (x & A).  */\n+\t    return old;\n+\t  if (op1 == NULL)\n+\t    op1 = gen_rtx_AND (0, XEXP (old, 1), x);\n+\t  else if (rtx_equal_p (x, op1))\n+\t    /* (A & x) & x ~ (A & x).  */\n+\t    return old;\n \t  return gen_rtx_AND (0, op0, op1);\n \t}\n       if (! add)\n-\treturn old;\n-\n-      /* If X is identical to one of the existing terms of the AND,\n-\t then just return what we already have.  */\n-      /* ??? There really should be some sort of recursive check here in\n-\t case there are nested ANDs.  */\n-      if ((GET_CODE (XEXP (old, 0)) == GET_CODE (x)\n-\t   && REGNO (XEXP (XEXP (old, 0), 0)) == REGNO (XEXP (x, 0)))\n-\t  || (GET_CODE (XEXP (old, 1)) == GET_CODE (x)\n-\t      && REGNO (XEXP (XEXP (old, 1), 0)) == REGNO (XEXP (x, 0))))\n-\treturn old;\n-\n+\treturn NULL;\n       return gen_rtx_AND (0, old, x);\n \n     case NOT:\n       op0 = ior_reg_cond (XEXP (old, 0), not_reg_cond (x), 0);\n-      if (op0 != XEXP (old, 0))\n+      if (op0 != NULL)\n \treturn not_reg_cond (op0);\n       if (! add)\n-\treturn old;\n+\treturn NULL;\n       return gen_rtx_AND (0, old, x);\n \n     default:"}, {"sha": "76f673f6d0ce71c5303abf944496352bbd5e2758", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "patch": "@@ -2,6 +2,8 @@\n \n \t* g++.dg/other/stdarg1.C: New test.\n \n+\t* gcc.c-torture/compile/20011130-2.c: New test.\n+\n 2001-12-03  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.c-torture/execute/builtin-prefetch-1.c: New test."}, {"sha": "6439527e89c06177095a291b51482cc6a1d6217f", "filename": "gcc/testsuite/gcc.c-torture/compile/20011130-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011130-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b318748ff4b6a9256695a3e768d4a951dd4b8ca6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011130-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011130-2.c?ref=b318748ff4b6a9256695a3e768d4a951dd4b8ca6", "patch": "@@ -0,0 +1,54 @@\n+/* This testcase caused infinite loop in life info computation\n+   after if conversion on IA-64.  Conditional register dead for\n+   pseudo holding sign-extended k was improperly computed,\n+   resulting in this pseudo beeing live at start of bb if it was\n+   dead at the end and vice versa; as it was a bb which had edge\n+   to itself, this resulted in alternative propagating this basic\n+   block forever.  */\n+\n+typedef struct {\n+  unsigned char a;\n+  unsigned char b;\n+} S0;\n+\n+typedef struct {\n+  S0 *c;\n+  int d;\n+  unsigned int e;\n+  unsigned char *f[3];\n+  void *g;\n+} S1;\n+\n+int bar (int, void *);\n+\n+int foo (S1 *x, float y)\n+{\n+  S0 *h;\n+  int i, j, k, l, m;\n+  float n, o, p;\n+  unsigned char *q, *r[3];\n+\n+  h = x->c;\n+  m = h->a;\n+  l = h->b;\n+  n = y;\n+  o = 0.0;\n+  if (x->d == 8)\n+    for (j = 0; j < x->e; j++)\n+      for (k = 0; k < 3; k++)\n+\t{\n+\t  n = y;\n+\t  o = 0.0;\n+\t  if (m)\n+\t    q = x->f[k] + x->e - 1 - j;\n+\t  else\n+\t    q = x->f[k] + j;\n+\t  p = (*q - o) * y / (n - o);\n+\t  p = 0.0 > p ? 0.0 : p;\n+\t  p = y < p ? y : p;\n+\t  if (l)\n+\t    p = r[k][(int) p];\n+\t  bar (p, x->g);\n+\t}\n+  return 1;\n+}"}]}