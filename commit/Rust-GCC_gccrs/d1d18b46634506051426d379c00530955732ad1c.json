{"sha": "d1d18b46634506051426d379c00530955732ad1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFkMThiNDY2MzQ1MDYwNTE0MjZkMzc5YzAwNTMwOTU1NzMyYWQxYw==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2001-10-07T15:05:20Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-10-07T15:05:20Z"}, "message": "Fix reload conflict testing to take correct order of output reloads into account.\n\nFrom-SVN: r46061", "tree": {"sha": "8601fa96dc728f34ca6ef4f8ed3b85e25924579b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8601fa96dc728f34ca6ef4f8ed3b85e25924579b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1d18b46634506051426d379c00530955732ad1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d18b46634506051426d379c00530955732ad1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d18b46634506051426d379c00530955732ad1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d18b46634506051426d379c00530955732ad1c/comments", "author": null, "committer": null, "parents": [{"sha": "0be6abca220b75aa5a3394fc1f89705aa37c0ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be6abca220b75aa5a3394fc1f89705aa37c0ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be6abca220b75aa5a3394fc1f89705aa37c0ebf"}], "stats": {"total": 40, "additions": 28, "deletions": 12}, "files": [{"sha": "8ad7b71eb57b844c01ed610a02613f20c2e8ab9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d18b46634506051426d379c00530955732ad1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d18b46634506051426d379c00530955732ad1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1d18b46634506051426d379c00530955732ad1c", "patch": "@@ -1,3 +1,11 @@\n+2001-10-07  Dale Johannesen  <dalej@apple.com>\n+\n+\t* reload1.c (reload_reg_free_p): Teach register interference\n+\tchecking that multiple output reloads are emitted in\n+\treverse order.\n+\treload1.c (reload_reg_reaches_end_p):  Ditto.\n+\treload1.c (reloads_conflict):  Ditto.\n+\n 2001-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* doc/c-tree.texi, doc/tm.texi: Consistently put NULL and"}, {"sha": "de868e6bfb9098cf4d21bf8f0bd04d50e8b00838", "filename": "gcc/reload1.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d18b46634506051426d379c00530955732ad1c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d18b46634506051426d379c00530955732ad1c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d1d18b46634506051426d379c00530955732ad1c", "patch": "@@ -4417,11 +4417,13 @@ reload_reg_free_p (regno, opnum, type)\n \n     case RELOAD_FOR_OUTPUT_ADDRESS:\n       /* Can't use a register if it is used for an output address for this\n-\t operand or used as an output in this or a later operand.  */\n+\t operand or used as an output in this or a later operand.  Note\n+\t that multiple output operands are emitted in reverse order, so\n+\t the conflicting ones are those with lower indices.  */\n       if (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], regno))\n \treturn 0;\n \n-      for (i = opnum; i < reload_n_operands; i++)\n+      for (i = 0; i <= opnum; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n@@ -4430,11 +4432,13 @@ reload_reg_free_p (regno, opnum, type)\n     case RELOAD_FOR_OUTADDR_ADDRESS:\n       /* Can't use a register if it is used for an output address\n \t for this operand or used as an output in this or a\n-\t later operand.  */\n+\t later operand.  Note that multiple output operands are\n+\t emitted in reverse order, so the conflicting ones are\n+\t those with lower indices.  */\n       if (TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], regno))\n \treturn 0;\n \n-      for (i = opnum; i < reload_n_operands; i++)\n+      for (i = 0; i <= opnum; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n@@ -4457,15 +4461,17 @@ reload_reg_free_p (regno, opnum, type)\n \n     case RELOAD_FOR_OUTPUT:\n       /* This cannot share a register with RELOAD_FOR_INSN reloads, other\n-\t outputs, or an operand address for this or an earlier output.  */\n+\t outputs, or an operand address for this or an earlier output.\n+\t Note that multiple output operands are emitted in reverse order,\n+\t so the conflicting ones are those with higher indices.  */\n       if (TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno))\n \treturn 0;\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n-      for (i = 0; i <= opnum; i++)\n+      for (i = opnum; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno))\n \t  return 0;\n@@ -4601,16 +4607,18 @@ reload_reg_reaches_end_p (regno, opnum, type)\n       /* These conflict with other outputs with RELOAD_OTHER.  So\n \t we need only check for output addresses.  */\n \n-      opnum = -1;\n+      opnum = reload_n_operands;\n \n       /* ... fall through ...  */\n \n     case RELOAD_FOR_OUTPUT:\n     case RELOAD_FOR_OUTPUT_ADDRESS:\n     case RELOAD_FOR_OUTADDR_ADDRESS:\n       /* We already know these can't conflict with a later output.  So the\n-\t only thing to check are later output addresses.  */\n-      for (i = opnum + 1; i < reload_n_operands; i++)\n+\t only thing to check are later output addresses.\n+\t Note that multiple output operands are emitted in reverse order,\n+\t so the conflicting ones are those with lower indices.  */\n+      for (i = 0; i < opnum; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno))\n \t  return 0;\n@@ -4662,11 +4670,11 @@ reloads_conflict (r1, r2)\n \n     case RELOAD_FOR_OUTPUT_ADDRESS:\n       return ((r2_type == RELOAD_FOR_OUTPUT_ADDRESS && r2_opnum == r1_opnum)\n-\t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum >= r1_opnum));\n+\t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum <= r1_opnum));\n \n     case RELOAD_FOR_OUTADDR_ADDRESS:\n       return ((r2_type == RELOAD_FOR_OUTADDR_ADDRESS && r2_opnum == r1_opnum)\n-\t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum >= r1_opnum));\n+\t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum <= r1_opnum));\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n@@ -4680,7 +4688,7 @@ reloads_conflict (r1, r2)\n       return (r2_type == RELOAD_FOR_INSN || r2_type == RELOAD_FOR_OUTPUT\n \t      || ((r2_type == RELOAD_FOR_OUTPUT_ADDRESS\n \t\t   || r2_type == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t\t  && r2_opnum <= r1_opnum));\n+\t\t  && r2_opnum >= r1_opnum));\n \n     case RELOAD_FOR_INSN:\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_OUTPUT"}]}