{"sha": "ebb1abc3e45a4b8d83779a134d341c871d960332", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiMWFiYzNlNDVhNGI4ZDgzNzc5YTEzNGQzNDFjODcxZDk2MDMzMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-12-22T23:31:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-12-22T23:31:55Z"}, "message": "* typeck.c (build_binary_op): Fix pmf comparison logic.\n\nFrom-SVN: r38471", "tree": {"sha": "5dd6a7c52f5b1d37ad2e46570ccb0b8e9b84a338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dd6a7c52f5b1d37ad2e46570ccb0b8e9b84a338"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb1abc3e45a4b8d83779a134d341c871d960332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb1abc3e45a4b8d83779a134d341c871d960332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb1abc3e45a4b8d83779a134d341c871d960332", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb1abc3e45a4b8d83779a134d341c871d960332/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0692b39c5be6724c3a929607683bc6f76bbe6e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0692b39c5be6724c3a929607683bc6f76bbe6e25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0692b39c5be6724c3a929607683bc6f76bbe6e25"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "6054868d0d8bf34ba5252fe80a160ad9cae3cb32", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1abc3e45a4b8d83779a134d341c871d960332/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1abc3e45a4b8d83779a134d341c871d960332/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ebb1abc3e45a4b8d83779a134d341c871d960332", "patch": "@@ -1,10 +1,10 @@\n 2000-12-22  Jason Merrill  <jason@redhat.com>\n \n+\t* typeck.c (build_binary_op): Fix pmf comparison logic.\n+\n \t* call.c (joust): Use DECL_NONSTATIC_MEMBER_FUNCTION_P, not\n \tDECL_STATIC_FUNCTION_P.\n \n-\t* typeck.c (build_binary_op): Fix pmf comparison logic.\n-\n \t* semantics.c (genrtl_finish_function): Don't try to jump to\n \treturn_label unless it exists.\n "}, {"sha": "23efc90a9efa1eb79e2a61809e1745653f34ab6b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1abc3e45a4b8d83779a134d341c871d960332/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1abc3e45a4b8d83779a134d341c871d960332/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ebb1abc3e45a4b8d83779a134d341c871d960332", "patch": "@@ -3648,6 +3648,11 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  tree e1;\n \t  tree e2;\n \n+\t  if (TREE_SIDE_EFFECTS (op0))\n+\t    op0 = save_expr (op0);\n+\t  if (TREE_SIDE_EFFECTS (op1))\n+\t    op1 = save_expr (op1);\n+\n \t  if (flag_new_abi)\n \t    {\n \t      /* We generate:\n@@ -3670,7 +3675,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      delta1 = build_component_ref (op1, delta_identifier,\n \t\t\t\t\t    NULL_TREE, 0);\n \t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n-\t      e2 = cp_build_binary_op (NE_EXPR, \n+\t      e2 = cp_build_binary_op (EQ_EXPR, \n \t\t\t\t       pfn0,\n \t\t\t\t       cp_convert (TREE_TYPE (pfn0),\n \t\t\t\t\t\t   integer_zero_node));\n@@ -3683,13 +3688,19 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      /* The code we generate for the test is:\n \n \t\t (op0.index == op1.index\n-\t\t  && ((op1.index != -1 && op0.delta2 == op1.delta2)\n-\t\t      || op0.pfn == op1.pfn)) */\n+\t\t  && op0.delta == op1.delta\n+\t\t  && (op1.index == -1 ? op0.pfn == op1.pfn\n+\t\t      : op0.delta2 == op1.delta2)) */\n \n \t      tree index0 = build_component_ref (op0, index_identifier,\n \t\t\t\t\t\t NULL_TREE, 0);\n-\t      tree index1 = save_expr (build_component_ref (op1, index_identifier,\n-\t\t\t\t\t\t\t    NULL_TREE, 0));\n+\t      tree index1\n+\t\t= save_expr (build_component_ref (op1, index_identifier,\n+\t\t\t\t\t\t  NULL_TREE, 0));\n+\t      tree delta0 = build_component_ref (op0, delta_identifier,\n+\t\t\t\t\t\t NULL_TREE, 0);\n+\t      tree delta1 = build_component_ref (op1, delta_identifier,\n+\t\t\t\t\t\t NULL_TREE, 0);\n \t      tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n \t      tree pfn1 = PFN_FROM_PTRMEMFUNC (op1);\n \t      tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n@@ -3698,17 +3709,17 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      tree integer_neg_one_node\n \t\t= cp_build_binary_op (MINUS_EXPR, integer_zero_node,\n \t\t\t\t      integer_one_node);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, index0, index1);\n-\t      e2 = cp_build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n-\t      e2 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2,\n-\t\t\t\t       cp_build_binary_op (EQ_EXPR, \n-\t\t\t\t\t\t\t   delta20, delta21));\n+\t      e1 = cp_build_binary_op (EQ_EXPR, index1, integer_neg_one_node);\n \t      /* We can't use build_binary_op for this cmp because it\n \t\t would get confused by the ptr to method types and\n \t\t think we want pmfs.  */\n-\t      e3 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t      e2 = cp_build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n-\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n+\t      e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n+\t      e3 = cp_build_binary_op (EQ_EXPR, delta20, delta21);\n+\t      e = build_conditional_expr (e1, e2, e3);\n+\t      e1 = cp_build_binary_op (EQ_EXPR, index0, index1);\n+\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e);\n+\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n+\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e);\n \t    }\n \t  if (code == EQ_EXPR)\n \t    return e;"}]}