{"sha": "78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiYmQ3NjU1ZWI1M2NmMmQwZmNkZjQ1ZjI1MGEzYjQwZTUxZjM1YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-09-17T11:05:31Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-09-17T11:05:31Z"}, "message": "tree-inline.h (struct copy_body_data): Add transform_parameter.\n\n\t* tree-inline.h (struct copy_body_data): Add transform_parameter.\n\t* tree-inline.c (is_parameter_of): New predicate.\n\t(remap_gimple_op_r): Do not propagate TREE_THIS_NOTRAP on MEM_REF if\n\ta parameter has been remapped.\n\t(copy_tree_body_r): Likewise on INDIRECT_REF and MEM_REF.\n\t(optimize_inline_calls): Initialize transform_parameter.\n\t(copy_gimple_seq_and_replace_locals): Likewise.\n\t(tree_function_versioning): Likewise.\n\t(maybe_inline_call_in_expr): Likewise.\n\nFrom-SVN: r202647", "tree": {"sha": "219c5c5f83f0c8d87a806be3e5dd0643b4ad1ba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/219c5c5f83f0c8d87a806be3e5dd0643b4ad1ba8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/comments", "author": null, "committer": null, "parents": [{"sha": "00c90ae1796a2cc6d9006d246e829793bc3cba0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c90ae1796a2cc6d9006d246e829793bc3cba0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c90ae1796a2cc6d9006d246e829793bc3cba0d"}], "stats": {"total": 204, "additions": 172, "deletions": 32}, "files": [{"sha": "44c7d66134a5275b8e59c4193d48744389393276", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -1,3 +1,15 @@\n+2013-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-inline.h (struct copy_body_data): Add transform_parameter.\n+\t* tree-inline.c (is_parameter_of): New predicate.\n+\t(remap_gimple_op_r): Do not propagate TREE_THIS_NOTRAP on MEM_REF if\n+\ta parameter has been remapped.\n+\t(copy_tree_body_r): Likewise on INDIRECT_REF and MEM_REF.\n+\t(optimize_inline_calls): Initialize transform_parameter.\n+\t(copy_gimple_seq_and_replace_locals): Likewise.\n+\t(tree_function_versioning): Likewise.\n+\t(maybe_inline_call_in_expr): Likewise.\n+\n 2013-09-17  Nick Clifton  <nickc@redhat.com>\n \n \t* config/msp430/msp430-protos.h: Add prototypes for new functions."}, {"sha": "7ae7ea1eddb430ae6b3f7ab21ab223deb1d701e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -1,3 +1,8 @@\n+2013-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt27.adb: New test.\n+\t* gnat.dg/opt27_pkg.ad[sb]: New helper.\n+\n 2013-09-17  Andreas Schwab  <schwab@suse.de>\n \n \t* gcc.dg/tree-ssa/ldist-22.c (main): Return zero."}, {"sha": "be1980076a4fb78c1bb63c8875fc9f165f90ed30", "filename": "gcc/testsuite/gnat.dg/opt27.adb", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27.adb?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -0,0 +1,29 @@\n+-- { dg-do run }\r\n+-- { dg-options \"-O\" }\r\n+\r\n+with Opt27_Pkg;\r\n+\r\n+procedure Opt27 is\r\n+\r\n+    type Rec_T is record\r\n+        A, B, C, D, E : Integer;\r\n+    end record;\r\n+\r\n+    package List is new Opt27_Pkg (Rec_T);\r\n+\r\n+    My_List : List.List_T;\r\n+\r\n+    function Is_Match (Element : Rec_T; Template : Integer) return Boolean is\r\n+    begin\r\n+        return (Element.C = Template);\r\n+    end;\r\n+\r\n+    function Find_Int is new List.Find_Elem (Integer, Is_Match);\r\n+\r\n+    Node : List.Node_T := Find_Int (10, My_List);\r\n+\r\n+begin\r\n+    if not List.Is_Null (Node) then\r\n+        raise Program_Error;\r\n+    end if;\r\n+end;\r"}, {"sha": "17ffb731db25c9235bda97bcdcb3570b6fcb0797", "filename": "gcc/testsuite/gnat.dg/opt27_pkg.adb", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27_pkg.adb?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -0,0 +1,32 @@\n+package body Opt27_Pkg is\n+\n+    type Node_Rec_T is record\n+         Element : Element_T;\n+         Left : Node_T;\n+         Right : Node_T;\n+    end record;\n+\n+    function Is_Null (Node : in Node_T) return Boolean is\n+    begin\n+        return (Node = null);\n+    end Is_Null;\n+\n+    function Find_Elem (Template : Template_T; List : List_T) return Node_T is\n+        Element_Found : Boolean := False;\n+        Node_Walker : Node_T := null;\n+    begin\n+        Node_Walker := List.First_Node;\n+\n+        while not Element_Found and (Node_Walker /= null) loop\n+\n+            if Is_Match (Node_Walker.Element, Template) then\n+                Element_Found := True;\n+            else\n+                Node_Walker := Node_Walker.Right;\n+            end if;\n+        end loop;\n+\n+        return Node_Walker;\n+    end;\n+\n+end Opt27_Pkg;"}, {"sha": "01b3a909c6d09fad07249c42ec2fd692e204b760", "filename": "gcc/testsuite/gnat.dg/opt27_pkg.ads", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt27_pkg.ads?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -0,0 +1,33 @@\n+generic\n+\n+    type Element_T is private;\n+\n+package Opt27_Pkg is\n+\n+    type Node_T is private;\n+\n+    type List_T is private;\n+\n+    function Is_Null (Node : in Node_T) return Boolean;\n+\n+    generic\n+\n+        type Template_T is private;\n+\n+        with function Is_Match\n+                         (Element : in Element_T;\n+                          Template : in Template_T) return Boolean is <>;\n+\n+    function Find_Elem (Template : Template_T; List : List_T) return Node_T;\n+\n+private\n+\n+    type Node_Rec_T;\n+    type Node_T is access Node_Rec_T;\n+\n+    type List_T is record\n+        First_Node : Node_T := null;\n+        Last_Node : Node_T := null;\n+    end record;\n+\n+end Opt27_Pkg;"}, {"sha": "ebb4b9188133c73a46ceb5bd8eb33f24da50eb98", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -751,6 +751,20 @@ copy_gimple_bind (gimple stmt, copy_body_data *id)\n   return new_bind;\n }\n \n+/* Return true if DECL is a parameter or a SSA_NAME for a parameter.  */\n+\n+static bool\n+is_parm (tree decl)\n+{\n+  if (TREE_CODE (decl) == SSA_NAME)\n+    {\n+      decl = SSA_NAME_VAR (decl);\n+      if (!decl)\n+\treturn false;\n+    }\n+\n+  return (TREE_CODE (decl) == PARM_DECL);\n+}\n \n /* Remap the GIMPLE operand pointed to by *TP.  DATA is really a\n    'struct walk_stmt_info *'.  DATA->INFO is a 'copy_body_data *'.\n@@ -840,20 +854,24 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \n       if (TREE_CODE (*tp) == MEM_REF)\n \t{\n-\t  tree ptr = TREE_OPERAND (*tp, 0);\n-\t  tree type = remap_type (TREE_TYPE (*tp), id);\n-\t  tree old = *tp;\n-\n \t  /* We need to re-canonicalize MEM_REFs from inline substitutions\n \t     that can happen when a pointer argument is an ADDR_EXPR.\n \t     Recurse here manually to allow that.  */\n+\t  tree ptr = TREE_OPERAND (*tp, 0);\n+\t  tree type = remap_type (TREE_TYPE (*tp), id);\n+\t  tree old = *tp;\n \t  walk_tree (&ptr, remap_gimple_op_r, data, NULL);\n-\t  *tp = fold_build2 (MEM_REF, type,\n-\t\t\t     ptr, TREE_OPERAND (*tp, 1));\n-\t  TREE_THIS_NOTRAP (*tp) = TREE_THIS_NOTRAP (old);\n+\t  *tp = fold_build2 (MEM_REF, type, ptr, TREE_OPERAND (*tp, 1));\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n \t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t  /* We cannot propagate the TREE_THIS_NOTRAP flag if we have\n+\t     remapped a parameter as the property might be valid only\n+\t     for the parameter itself.  */\n+\t  if (TREE_THIS_NOTRAP (old)\n+\t      && (!is_parm (TREE_OPERAND (old, 0))\n+\t\t  || (!id->transform_parameter && is_parm (ptr))))\n+\t    TREE_THIS_NOTRAP (*tp) = 1;\n \t  *walk_subtrees = 0;\n \t  return NULL;\n \t}\n@@ -1043,45 +1061,44 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  /* Get rid of *& from inline substitutions that can happen when a\n \t     pointer argument is an ADDR_EXPR.  */\n \t  tree decl = TREE_OPERAND (*tp, 0);\n-\t  tree *n;\n-\n-\t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n+\t  tree *n = (tree *) pointer_map_contains (id->decl_map, decl);\n \t  if (n)\n \t    {\n-\t      tree new_tree;\n-\t      tree old;\n \t      /* If we happen to get an ADDR_EXPR in n->value, strip\n \t         it manually here as we'll eventually get ADDR_EXPRs\n \t\t which lie about their types pointed to.  In this case\n \t\t build_fold_indirect_ref wouldn't strip the INDIRECT_REF,\n \t\t but we absolutely rely on that.  As fold_indirect_ref\n \t         does other useful transformations, try that first, though.  */\n-\t      tree type = TREE_TYPE (TREE_TYPE (*n));\n-\t      if (id->do_not_unshare)\n-\t\tnew_tree = *n;\n-\t      else\n-\t\tnew_tree = unshare_expr (*n);\n-\t      old = *tp;\n-\t      *tp = gimple_fold_indirect_ref (new_tree);\n+\t      tree type = TREE_TYPE (*tp);\n+\t      tree ptr = id->do_not_unshare ? *n : unshare_expr (*n);\n+\t      tree old = *tp;\n+\t      *tp = gimple_fold_indirect_ref (ptr);\n \t      if (! *tp)\n \t        {\n-\t\t  if (TREE_CODE (new_tree) == ADDR_EXPR)\n+\t\t  if (TREE_CODE (ptr) == ADDR_EXPR)\n \t\t    {\n-\t\t      *tp = fold_indirect_ref_1 (EXPR_LOCATION (new_tree),\n-\t\t\t\t\t\t type, new_tree);\n+\t\t      *tp\n+\t\t        = fold_indirect_ref_1 (EXPR_LOCATION (ptr), type, ptr);\n \t\t      /* ???  We should either assert here or build\n \t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n \t\t\t incompatible types to our IL.  */\n \t\t      if (! *tp)\n-\t\t\t*tp = TREE_OPERAND (new_tree, 0);\n+\t\t\t*tp = TREE_OPERAND (ptr, 0);\n \t\t    }\n \t          else\n \t\t    {\n-\t              *tp = build1 (INDIRECT_REF, type, new_tree);\n+\t              *tp = build1 (INDIRECT_REF, type, ptr);\n \t\t      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t\t      TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n \t\t      TREE_READONLY (*tp) = TREE_READONLY (old);\n-\t\t      TREE_THIS_NOTRAP (*tp) = TREE_THIS_NOTRAP (old);\n+\t\t      /* We cannot propagate the TREE_THIS_NOTRAP flag if we\n+\t\t\t have remapped a parameter as the property might be\n+\t\t\t valid only for the parameter itself.  */\n+\t\t      if (TREE_THIS_NOTRAP (old)\n+\t\t\t  && (!is_parm (TREE_OPERAND (old, 0))\n+\t\t\t      || (!id->transform_parameter && is_parm (ptr))))\n+\t\t        TREE_THIS_NOTRAP (*tp) = 1;\n \t\t    }\n \t\t}\n \t      *walk_subtrees = 0;\n@@ -1090,20 +1107,24 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t}\n       else if (TREE_CODE (*tp) == MEM_REF)\n \t{\n-\t  tree ptr = TREE_OPERAND (*tp, 0);\n-\t  tree type = remap_type (TREE_TYPE (*tp), id);\n-\t  tree old = *tp;\n-\n \t  /* We need to re-canonicalize MEM_REFs from inline substitutions\n \t     that can happen when a pointer argument is an ADDR_EXPR.\n \t     Recurse here manually to allow that.  */\n+\t  tree ptr = TREE_OPERAND (*tp, 0);\n+\t  tree type = remap_type (TREE_TYPE (*tp), id);\n+\t  tree old = *tp;\n \t  walk_tree (&ptr, copy_tree_body_r, data, NULL);\n-\t  *tp = fold_build2 (MEM_REF, type,\n-\t\t\t     ptr, TREE_OPERAND (*tp, 1));\n-\t  TREE_THIS_NOTRAP (*tp) = TREE_THIS_NOTRAP (old);\n+\t  *tp = fold_build2 (MEM_REF, type, ptr, TREE_OPERAND (*tp, 1));\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n \t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t  /* We cannot propagate the TREE_THIS_NOTRAP flag if we have\n+\t     remapped a parameter as the property might be valid only\n+\t     for the parameter itself.  */\n+\t  if (TREE_THIS_NOTRAP (old)\n+\t      && (!is_parm (TREE_OPERAND (old, 0))\n+\t\t  || (!id->transform_parameter && is_parm (ptr))))\n+\t    TREE_THIS_NOTRAP (*tp) = 1;\n \t  *walk_subtrees = 0;\n \t  return NULL;\n \t}\n@@ -4452,6 +4473,7 @@ optimize_inline_calls (tree fn)\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n   id.transform_new_cfg = false;\n   id.transform_return_to_modify = true;\n+  id.transform_parameter = true;\n   id.transform_lang_insert_block = NULL;\n   id.statements_to_fold = pointer_set_create ();\n \n@@ -4757,6 +4779,7 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n   id.transform_new_cfg = false;\n   id.transform_return_to_modify = false;\n+  id.transform_parameter = false;\n   id.transform_lang_insert_block = NULL;\n \n   /* Walk the tree once to find local labels.  */\n@@ -5216,6 +5239,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n     = update_clones ? CB_CGE_MOVE_CLONES : CB_CGE_MOVE;\n   id.transform_new_cfg = true;\n   id.transform_return_to_modify = false;\n+  id.transform_parameter = false;\n   id.transform_lang_insert_block = NULL;\n \n   old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n@@ -5440,6 +5464,7 @@ maybe_inline_call_in_expr (tree exp)\n       id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n       id.transform_new_cfg = false;\n       id.transform_return_to_modify = true;\n+      id.transform_parameter = true;\n       id.transform_lang_insert_block = NULL;\n \n       /* Make sure not to unshare trees behind the front-end's back"}, {"sha": "a78e4b69f0efdf4d1f50838f42162fd3e7630a32", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=78bbd7655eb53cf2d0fcdf45f250a3b40e51f35a", "patch": "@@ -97,6 +97,10 @@ typedef struct copy_body_data\n      by manipulating the CFG rather than a statement.  */\n   bool transform_return_to_modify;\n \n+  /* True if the parameters of the source function are transformed.\n+     Only true for inlining.  */\n+  bool transform_parameter;\n+\n   /* True if this statement will need to be regimplified.  */\n   bool regimplify;\n "}]}