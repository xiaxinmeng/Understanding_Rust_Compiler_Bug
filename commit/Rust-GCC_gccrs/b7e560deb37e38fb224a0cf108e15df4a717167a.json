{"sha": "b7e560deb37e38fb224a0cf108e15df4a717167a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdlNTYwZGViMzdlMzhmYjIyNGEwY2YxMDhlMTVkZjRhNzE3MTY3YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "richard.henderson@linaro.org", "date": "2019-09-19T14:36:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2019-09-19T14:36:33Z"}, "message": "aarch64: Tidy aarch64_split_compare_and_swap\n\nWith aarch64_track_speculation, we had extra code to do exactly what the\n!strong_zero_p path already did.  The rest is reducing code duplication.\n\n\t* config/aarch64/aarch64 (aarch64_split_compare_and_swap): Disable\n\tstrong_zero_p for aarch64_track_speculation; unify some code paths;\n\tuse aarch64_gen_compare_reg instead of open-coding.\n\nFrom-SVN: r275966", "tree": {"sha": "7f44a7e5a50a5b2a1d2d39a01338dd1aa2ba645f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f44a7e5a50a5b2a1d2d39a01338dd1aa2ba645f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7e560deb37e38fb224a0cf108e15df4a717167a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e560deb37e38fb224a0cf108e15df4a717167a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e560deb37e38fb224a0cf108e15df4a717167a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e560deb37e38fb224a0cf108e15df4a717167a/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a2095ebace8534038ce2adf4ae94bfc854066c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2095ebace8534038ce2adf4ae94bfc854066c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2095ebace8534038ce2adf4ae94bfc854066c4"}], "stats": {"total": 54, "additions": 18, "deletions": 36}, "files": [{"sha": "cef3a6e2b6de7a33e882a1a035f6fe61629dda35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e560deb37e38fb224a0cf108e15df4a717167a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e560deb37e38fb224a0cf108e15df4a717167a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7e560deb37e38fb224a0cf108e15df4a717167a", "patch": "@@ -16,6 +16,10 @@\n \t(aarch64_store_exclusive_pair): New.\n \t* config/aarch64/iterators.md (JUST_TI): New.\n \n+\t* config/aarch64/aarch64 (aarch64_split_compare_and_swap): Disable\n+\tstrong_zero_p for aarch64_track_speculation; unify some code paths;\n+\tuse aarch64_gen_compare_reg instead of open-coding.\n+\n 2019-09-19  Feng Xue  <fxue@os.amperecomputing.com>\n \n \t* ipa-fnsummary.c (set_cond_stmt_execution_predicate): Do not compute"}, {"sha": "b937514e6f84f5a8af52bf277c9ce4f961d830de", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e560deb37e38fb224a0cf108e15df4a717167a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e560deb37e38fb224a0cf108e15df4a717167a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b7e560deb37e38fb224a0cf108e15df4a717167a", "patch": "@@ -16955,13 +16955,11 @@ aarch64_emit_post_barrier (enum memmodel model)\n void\n aarch64_split_compare_and_swap (rtx operands[])\n {\n-  rtx rval, mem, oldval, newval, scratch;\n+  rtx rval, mem, oldval, newval, scratch, x, model_rtx;\n   machine_mode mode;\n   bool is_weak;\n   rtx_code_label *label1, *label2;\n-  rtx x, cond;\n   enum memmodel model;\n-  rtx model_rtx;\n \n   rval = operands[0];\n   mem = operands[1];\n@@ -16982,7 +16980,8 @@ aarch64_split_compare_and_swap (rtx operands[])\n \tCBNZ\tscratch, .label1\n     .label2:\n \tCMP\trval, 0.  */\n-  bool strong_zero_p = !is_weak && oldval == const0_rtx && mode != TImode;\n+  bool strong_zero_p = (!is_weak && !aarch64_track_speculation &&\n+\t\t\toldval == const0_rtx && mode != TImode);\n \n   label1 = NULL;\n   if (!is_weak)\n@@ -16995,35 +16994,20 @@ aarch64_split_compare_and_swap (rtx operands[])\n   /* The initial load can be relaxed for a __sync operation since a final\n      barrier will be emitted to stop code hoisting.  */\n   if (is_mm_sync (model))\n-    aarch64_emit_load_exclusive (mode, rval, mem,\n-\t\t\t\t GEN_INT (MEMMODEL_RELAXED));\n+    aarch64_emit_load_exclusive (mode, rval, mem, GEN_INT (MEMMODEL_RELAXED));\n   else\n     aarch64_emit_load_exclusive (mode, rval, mem, model_rtx);\n \n   if (strong_zero_p)\n-    {\n-      if (aarch64_track_speculation)\n-\t{\n-\t  /* Emit an explicit compare instruction, so that we can correctly\n-\t     track the condition codes.  */\n-\t  rtx cc_reg = aarch64_gen_compare_reg (NE, rval, const0_rtx);\n-\t  x = gen_rtx_NE (GET_MODE (cc_reg), cc_reg, const0_rtx);\n-\t}\n-      else\n-\tx = gen_rtx_NE (VOIDmode, rval, const0_rtx);\n-\n-      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n-\t\t\t\tgen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n-      aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n-    }\n+    x = gen_rtx_NE (VOIDmode, rval, const0_rtx);\n   else\n     {\n-      cond = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);\n-      x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n-      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n-\t\t\t\tgen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n-      aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n+      rtx cc_reg = aarch64_gen_compare_reg_maybe_ze (NE, rval, oldval, mode);\n+      x = gen_rtx_NE (VOIDmode, cc_reg, const0_rtx);\n     }\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n+\t\t\t    gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n+  aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n \n   aarch64_emit_store_exclusive (mode, scratch, mem, newval, model_rtx);\n \n@@ -17044,22 +17028,16 @@ aarch64_split_compare_and_swap (rtx operands[])\n       aarch64_emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n     }\n   else\n-    {\n-      cond = gen_rtx_REG (CCmode, CC_REGNUM);\n-      x = gen_rtx_COMPARE (CCmode, scratch, const0_rtx);\n-      emit_insn (gen_rtx_SET (cond, x));\n-    }\n+    aarch64_gen_compare_reg (NE, scratch, const0_rtx);\n \n   emit_label (label2);\n+\n   /* If we used a CBNZ in the exchange loop emit an explicit compare with RVAL\n      to set the condition flags.  If this is not used it will be removed by\n      later passes.  */\n   if (strong_zero_p)\n-    {\n-      cond = gen_rtx_REG (CCmode, CC_REGNUM);\n-      x = gen_rtx_COMPARE (CCmode, rval, const0_rtx);\n-      emit_insn (gen_rtx_SET (cond, x));\n-    }\n+    aarch64_gen_compare_reg (NE, rval, const0_rtx);\n+\n   /* Emit any final barrier needed for a __sync operation.  */\n   if (is_mm_sync (model))\n     aarch64_emit_post_barrier (model);"}]}