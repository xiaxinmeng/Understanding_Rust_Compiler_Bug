{"sha": "16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhYWUzZDIwOWI2ZDI0OGYxMmM1ZDA2NDI3M2MzM2JjYjVlMGNlMg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-10-02T09:37:04Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-02T09:37:04Z"}, "message": "2003-10-02  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/table/AbstractTableModel.java\n\t(findColumnName): Prevent from NullPointerException if argument\n\tcolumnName is null.\n\n2003-10-02  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/table/AbstractTableModel.java:\n\tThis patch is based on a patch done by Arnaud Vandyck\n\t<arnaud.vandyck@ulg.ac.be>.\n\t(getColumnName): Fixed method documentation.\n\t(findColumn): Likewise.\n\t(getColumnClass): Likewise.\n\t(isCellEditable): Likewise.\n\t(setValueAt): Likewise.\n\t(addTableModelListener): Likewise.\n\t(removeTableModelListener): Likewise.\n\t(getTableModelListeners): New method.\n\n2003-10-02  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/table/AbstractTableModel.java:\n\tReformated.\n\nFrom-SVN: r72019", "tree": {"sha": "77abb0188bdebb69ad0146d5d868b322f03ad581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77abb0188bdebb69ad0146d5d868b322f03ad581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16aae3d209b6d248f12c5d064273c33bcb5e0ce2/comments", "author": null, "committer": null, "parents": [{"sha": "ffb344c1a191bc7a00dc3754d953bebb51543089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb344c1a191bc7a00dc3754d953bebb51543089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb344c1a191bc7a00dc3754d953bebb51543089"}], "stats": {"total": 563, "additions": 303, "deletions": 260}, "files": [{"sha": "c11753b9a33583dc2170bdcf566928f6dfacfe48", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16aae3d209b6d248f12c5d064273c33bcb5e0ce2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16aae3d209b6d248f12c5d064273c33bcb5e0ce2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "patch": "@@ -1,3 +1,28 @@\n+2003-10-02  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/table/AbstractTableModel.java\n+\t(findColumnName): Prevent from NullPointerException if argument\n+\tcolumnName is null.\n+\n+2003-10-02  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/table/AbstractTableModel.java:\n+\tThis patch is based on a patch done by Arnaud Vandyck\n+\t<arnaud.vandyck@ulg.ac.be>.\n+\t(getColumnName): Fixed method documentation.\n+\t(findColumn): Likewise.\n+\t(getColumnClass): Likewise.\n+\t(isCellEditable): Likewise.\n+\t(setValueAt): Likewise.\n+\t(addTableModelListener): Likewise.\n+\t(removeTableModelListener): Likewise.\n+\t(getTableModelListeners): New method.\n+\n+2003-10-02  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/table/AbstractTableModel.java:\n+\tReformated.\n+\n 2003-10-01  Bryce McKinlay  <bryce@mckinlay.net.nz>\n \n \tFix PR libgcj/12475"}, {"sha": "64e4d12cff4474b7f96a2a14c358d8af67dc0572", "filename": "libjava/javax/swing/table/AbstractTableModel.java", "status": "modified", "additions": 278, "deletions": 260, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16aae3d209b6d248f12c5d064273c33bcb5e0ce2/libjava%2Fjavax%2Fswing%2Ftable%2FAbstractTableModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16aae3d209b6d248f12c5d064273c33bcb5e0ce2/libjava%2Fjavax%2Fswing%2Ftable%2FAbstractTableModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftable%2FAbstractTableModel.java?ref=16aae3d209b6d248f12c5d064273c33bcb5e0ce2", "patch": "@@ -46,273 +46,291 @@\n \n /**\n  * AbstractTableModel\n+ * \n  * @author Andrew Selkirk\n  */\n public abstract class AbstractTableModel implements TableModel, Serializable\n {\n   static final long serialVersionUID = -5798593159423650347L;\n \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * listenerList\n-\t */\n-\tprotected EventListenerList listenerList = new EventListenerList();\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor AbstractTableModel\n-\t */\n-\tpublic AbstractTableModel() {\n-\t\t// TODO\n-\t} // AbstractTableModel()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * getColumnName\n-\t * @param value0 TODO\n-\t * @returns String\n-\t */\n-\tpublic String getColumnName(int columnIndex) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\t\tint\t\tleft;\n-\t\tint\t\tbase;\n-\t\tint\t\tmultiplier;\n-\t\tStringBuffer\tbuffer;\n-\t\tboolean\t\tfoundFirst;\n-\n-\t\t// Ok, this is not the best solution in the world\n-\t\t// and it does produce wrong answers starting 1378\n-\t\t// but it's a start.  I sure hope there is a more\n-\t\t// simple algorithm.  I started with a base 10 to\n-\t\t// base 26 converter and later found that there\n-\t\t// were so many are exceptions that it has morphed\n-\t\t// into a pile of goop.\n+  /**\n+   * listenerList\n+   */\n+  protected EventListenerList listenerList = new EventListenerList();\n+\n+  /**\n+   * Constructor AbstractTableModel\n+   */\n+  public AbstractTableModel()\n+  {\n+    // TODO\n+  }\n+\n+  /**\n+   * Get the name of the column for this index. If you do not override\n+   * this methode, you'll get something like: 0, A; 1, B; ...; AA; AB;\n+   * ...\n+   *\n+   * @param columnIndex The index of the column.\n+   *\n+   * @return The name of the column.\n+   */\n+  public String getColumnName (int columnIndex)\n+  {\n+    // Ok, this is not the best solution in the world\n+    // and it does produce wrong answers starting 1378\n+    // but it's a start.  I sure hope there is a more\n+    // simple algorithm.  I started with a base 10 to\n+    // base 26 converter and later found that there\n+    // were so many are exceptions that it has morphed\n+    // into a pile of goop.\n \t\t\n-\t\t// NOTE2: I have a working algorithm which is much\n-\t\t// much simplier and works for all values...I'll\n-\t\t// be adding it soon...\n-\n-\t\t// Process Exponent levels\n-\t\tbuffer = new StringBuffer();\n-\t\tleft = columnIndex;\n-\t\tfoundFirst = false;\n-\t\tfor (index = 6; index >= 0; index--) {\n-\t\t\tbase = (int) (Math.pow(26, index));\n-\t\t\tif (index > 1) {\n-\t\t\t\tbase = base + (int) (Math.pow(26, index - 1));\n-\t\t\t}\n-\t\t\tif (base <= left) {\n-\t\t\t\tmultiplier = left / base;\n-\t\t\t\tif (foundFirst == false && index > 0) {\n-\t\t\t\t\tbuffer.append((char) (multiplier + 64)); \n-\t\t\t\t} else {\n-\t\t\t\t\tbuffer.append((char) (multiplier + 65));\n-\t\t\t\t}\n-\t\t\t\tleft = left - (base * multiplier);\n-\t\t\t\tfoundFirst = true;\n-\t\t\t} else if (foundFirst == true || index == 0) {\n-\t\t\t\tbuffer.append('A');\n-\t\t\t}\n-\t\t} // for\n-\n-\t\t// Return Column Name\n-\t\treturn buffer.toString();\n-\n-\t} // getColumnName()\n-\n-\t/**\n-\t * findColumn\n-\t * @param value0 TODO\n-\t * @returns int\n-\t */\n-\tpublic int findColumn(String columnName) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\t\tString\t\tname;\n-\t\tint\t\tcount;\n-\n-\t\t// Process Columns\n-\t\tcount = getColumnCount();\n-\t\tfor (index = 0; index < count; index++) {\n-\t\t\tname = getColumnName(index);\n-\t\t\tif (columnName.equals(name) == true) {\n-\t\t\t\treturn index;\n-\t\t\t} // if\n-\t\t} // for\n-\n-\t\t// Unable to Locate\n-\t\treturn -1;\n-\n-\t} // findColumn()\n-\n-\t/**\n-\t * getColumnClass\n-\t * @param value0 TODO\n-\t * @returns Class\n-\t */\n-\tpublic Class getColumnClass(int columnIndex) {\n-\t\treturn Object.class;\n-\t} // getColumnClass()\n-\n-\t/**\n-\t * isCellEditable\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isCellEditable(int rowIndex, int columnIndex) {\n-\t\treturn false;\n-\t} // isCellEditable()\n-\n-\t/**\n-\t * setValueAt\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t * @param value2 TODO\n-\t */\n-\tpublic void setValueAt(Object value, int rowIndex, int columnIndex) {\n-\t\t// Do nothing...\n-\t} // setValueAt()\n-\n-\t/**\n-\t * addTableModelListener\n-\t * @param value0 TODO\n-\t */\n-\tpublic void addTableModelListener(TableModelListener listener) {\n-\t\tlistenerList.add(TableModelListener.class, listener);\n-\t} // addTableModelListener()\n-\n-\t/**\n-\t * removeTableModelListener\n-\t * @param value0 TODO\n-\t */\n-\tpublic void removeTableModelListener(TableModelListener listener) {\n-\t\tlistenerList.remove(TableModelListener.class, listener);\n-\t} // removeTableModelListener()\n-\n-\t/**\n-\t * fireTableDataChanged\n-\t */\n-\tpublic void fireTableDataChanged() {\n-\t\tfireTableChanged(new TableModelEvent(this));\n-\t} // fireTableDataChanged()\n-\n-\t/**\n-\t * fireTableStructureChanged\n-\t */\n-\tpublic void fireTableStructureChanged() {\n-\t\tfireTableChanged(new TableModelEvent(this,\n-\t\t\tTableModelEvent.HEADER_ROW));\n-\t} // fireTableStructureChanged()\n-\n-\t/**\n-\t * fireTableRowsInserted\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t */\n-\tpublic void fireTableRowsInserted(int firstRow, int lastRow) {\n-\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\n-\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));\n-\t} // fireTableRowsInserted()\n-\n-\t/**\n-\t * fireTableRowsUpdated\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t */\n-\tpublic void fireTableRowsUpdated(int firstRow, int lastRow) {\n-\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\n-\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE));\n-\t} // fireTableRowsUpdated()\n-\n-\t/**\n-\t * fireTableRowsDeleted\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t */\n-\tpublic void fireTableRowsDeleted(int firstRow, int lastRow) {\n-\t\tfireTableChanged(new TableModelEvent(this, firstRow, lastRow,\n-\t\t\tTableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE));\n-\t} // fireTableRowsDeleted()\n-\n-\t/**\n-\t * fireTableCellUpdated\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t */\n-\tpublic void fireTableCellUpdated(int row, int column) {\n-\t\tfireTableChanged(new TableModelEvent(this, row, row, column));\n-\t} // fireTableCellUpdated()\n-\n-\t/**\n-\t * fireTableChanged\n-\t * @param value0 TODO\n-\t */\n-\tpublic void fireTableChanged(TableModelEvent event) {\n-\n-\t\t// Variables\n-\t\tObject[]\t\tlist;\n-\t\tint\t\t\tindex;\n-\t\tTableModelListener\tlistener;\n+    // NOTE2: I have a working algorithm which is much\n+    // much simplier and works for all values...I'll\n+    // be adding it soon...\n+\n+    StringBuffer buffer = new StringBuffer();\n+    int left = columnIndex;\n+    boolean foundFirst = false;\n+    \n+    // Process Exponent levels.\n+    for (int index = 6; index >= 0; index--)\n+      {\n+        int base = (int) (Math.pow (26, index));\n+        \n+        if (index > 1)\n+          {\n+            base = base + (int) (Math.pow (26, index - 1));\n+          }\n+        \n+        if (base <= left)\n+          {\n+            int multiplier = left / base;\n+            \n+            if (foundFirst == false\n+                && index > 0)\n+              {\n+                buffer.append ((char) (multiplier + 64));\n+              }\n+            else\n+              {\n+                buffer.append ((char) (multiplier + 65));\n+              }\n+            \n+            left = left - (base * multiplier);\n+            foundFirst = true;\n+          }\n+        else if (foundFirst == true\n+                 || index == 0)\n+          {\n+            buffer.append('A');\n+          }\n+    }\n+\n+    // Return column name.\n+    return buffer.toString();\n+  }\n+\n+  /**\n+   * Return the index of the given name.\n+   *\n+   * @param columnName The name of the column.\n+   *\n+   * @return The index of the column, -1 if not found.\n+   */\n+  public int findColumn (String columnName)\n+  {\n+    int count = getColumnCount();\n+    \n+    for (int index = 0; index < count; index++)\n+      {\n+        String name = getColumnName (index);\n+        \n+        if (name.equals (columnName))\n+          return index;\n+    }\n+\n+    // Unable to locate.\n+    return -1;\n+  }\n+\n+  /**\n+   * Returns the class of a comlumn.\n+   *\n+   * @param columnIndex The index of the column.\n+   *\n+   * @return The class type of the column.\n+   */\n+  public Class getColumnClass (int columnIndex)\n+  {\n+    return Object.class;\n+  }\n+\n+  /**\n+   * Tells whether a cell is editable.\n+   *\n+   * @param rowIndex The row of the cell.\n+   * @param columnIndex The index of the cell.\n+   *\n+   * @return True if cell is editable.\n+   */\n+  public boolean isCellEditable (int rowIndex, int columnIndex)\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Sets a cell to a value.\n+   *\n+   * @param value New value of cell.\n+   * @param rowIndex The row of the cell.\n+   * @param columnIndex The column of the cell.\n+   */\n+  public void setValueAt (Object value, int rowIndex, int columnIndex)\n+  {\n+    // Do nothing...\n+  }\n+\n+  /**\n+   * Add a TableModelListener.\n+   *\n+   * @param listener The listener to add.\n+   */\n+  public void addTableModelListener (TableModelListener listener)\n+  {\n+    listenerList.add (TableModelListener.class, listener);\n+  }\n+\n+  /**\n+   * Removes a TableModelListener.\n+   *\n+   * @param listener The listener to remove.\n+   */\n+  public void removeTableModelListener (TableModelListener listener)\n+  {\n+    listenerList.remove (TableModelListener.class, listener);\n+  }\n+\n+  /**\n+   * Return all registered TableModelListener objects.\n+   *\n+   * @return Array of TableModelListener objects.\n+   *\n+   * @since 1.4\n+   */\n+  public TableModelListener[] getTableModelListeners()\n+  {\n+    return (TableModelListener[])\n+      listenerList.getListeners (TableModelListener.class);\n+  }\n+\n+  /**\n+   * fireTableDataChanged\n+   */\n+  public void fireTableDataChanged()\n+  {\n+    fireTableChanged (new TableModelEvent (this));\n+  }\n+\n+  /**\n+   * fireTableStructureChanged\n+   */\n+  public void fireTableStructureChanged()\n+  {\n+    fireTableChanged (new TableModelEvent (this, TableModelEvent.HEADER_ROW));\n+  }\n+\n+  /**\n+   * fireTableRowsInserted\n+   * @param value0 TODO\n+   * @param value1 TODO\n+   */\n+  public void fireTableRowsInserted (int firstRow, int lastRow)\n+  {\n+    fireTableChanged (new TableModelEvent (this, firstRow, lastRow,\n+                                           TableModelEvent.ALL_COLUMNS,\n+                                           TableModelEvent.INSERT));\n+  }\n+\n+  /**\n+   * fireTableRowsUpdated\n+   * @param value0 TODO\n+   * @param value1 TODO\n+   */\n+  public void fireTableRowsUpdated (int firstRow, int lastRow)\n+  {\n+    fireTableChanged (new TableModelEvent (this, firstRow, lastRow,\n+                                           TableModelEvent.ALL_COLUMNS,\n+                                           TableModelEvent.UPDATE));\n+  }\n+\n+  /**\n+   * fireTableRowsDeleted\n+   * @param value0 TODO\n+   * @param value1 TODO\n+   */\n+  public void fireTableRowsDeleted(int firstRow, int lastRow)\n+  {\n+    fireTableChanged (new TableModelEvent (this, firstRow, lastRow,\n+                                           TableModelEvent.ALL_COLUMNS,\n+                                           TableModelEvent.DELETE));\n+  }\n+\n+  /**\n+   * fireTableCellUpdated\n+   * @param value0 TODO\n+   * @param value1 TODO\n+   */\n+  public void fireTableCellUpdated (int row, int column)\n+  {\n+    fireTableChanged (new TableModelEvent (this, row, row, column));\n+  }\n+\n+  /**\n+   * fireTableChanged\n+   * @param value0 TODO\n+   */\n+  public void fireTableChanged (TableModelEvent event)\n+  {\n+    int\tindex;\n+    TableModelListener listener;\n+    Object[] list = listenerList.getListenerList();\n  \n-\t\t// Get Listener List\n-\t\tlist = listenerList.getListenerList();\n- \n-\t\tfor (index = 0; index < list.length; index += 2) {\n- \n-\t\t\t// Get Listener\n-\t\t\tlistener = (TableModelListener) list[index + 1];\n- \n-\t\t\t// Notify Listener\n-\t\t\tlistener.tableChanged(event);\n- \n-\t\t} // for: index                                                 \n-\n-\t} // fireTableChanged()\n-\n-\t/**\n-\t * getListeners\n-\t * @param value0 TODO\n-\t * @returns EventListener[]\n-\t */\n-\tpublic EventListener[] getListeners(Class listenerType) {\n-\t\treturn listenerList.getListeners(listenerType);\n-\t} // getListeners()\n-\n-\t/**\n-\t * getValueAt\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t * @returns Object\n-\t */\n-\tpublic abstract Object getValueAt(int row, int column);\n-\n-\t/**\n-\t * getColumnCount\n-\t * @returns int\n-\t */\n-\tpublic abstract int getColumnCount();\n-\n-\t/**\n-\t * getRowCount\n-\t * @returns int\n-\t */\n-\tpublic abstract int getRowCount();\n-\n+    for (index = 0; index < list.length; index += 2)\n+      {\n+        listener = (TableModelListener) list [index + 1];\n+        listener.tableChanged (event);\n+      }\n+  }\n+\n+  /**\n+   * getListeners\n+   * @param value0 TODO\n+   * @return EventListener[]\n+   */\n+  public EventListener[] getListeners (Class listenerType)\n+  {\n+    return listenerList.getListeners (listenerType);\n+  }\n+\n+  /**\n+   * getValueAt\n+   * @param value0 TODO\n+   * @param value1 TODO\n+   * @return Object\n+   */\n+  public abstract Object getValueAt (int row, int column);\n+\n+  /**\n+   * getColumnCount\n+   * @return int\n+   */\n+  public abstract int getColumnCount();\n+\n+  /**\n+   * getRowCount\n+   * @return int\n+   */\n+  public abstract int getRowCount();\n \n } // AbstractTableModel\n-"}]}