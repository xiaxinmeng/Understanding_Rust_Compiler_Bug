{"sha": "33b647956caa977d1ae489f9baed9cef70b4f382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNiNjQ3OTU2Y2FhOTc3ZDFhZTQ4OWY5YmFlZDljZWY3MGI0ZjM4Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-07T10:11:51Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-07T10:11:51Z"}, "message": "OpenMP: Fix SIMT for complex/float reduction with && and ||\n\n2021-05-07  Tobias Burnus  <tobias@codesourcery.com>\n\t    Tom de Vries  <tdevries@suse.de>\n\ngcc/ChangeLog:\n\n\t* omp-low.c (lower_rec_simd_input_clauses): Set max_vf = 1 if\n\ta truth_value_p reduction variable is nonintegral.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.c-c++-common/reduction-5.c: New test, testing\n\tcomplex/floating-point || + && reduction with 'omp target'.\n\t* testsuite/libgomp.c-c++-common/reduction-6.c: Likewise.", "tree": {"sha": "465ce5bcdc9f33dff40257c7cad8db3dc0b62bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/465ce5bcdc9f33dff40257c7cad8db3dc0b62bc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33b647956caa977d1ae489f9baed9cef70b4f382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b647956caa977d1ae489f9baed9cef70b4f382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33b647956caa977d1ae489f9baed9cef70b4f382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b647956caa977d1ae489f9baed9cef70b4f382/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4613d9ada54c334650d93edbb4c08069550099e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4613d9ada54c334650d93edbb4c08069550099e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4613d9ada54c334650d93edbb4c08069550099e"}], "stats": {"total": 417, "additions": 410, "deletions": 7}, "files": [{"sha": "2325cfcfc34a4a8bcc182fed09a56216af2ea522", "filename": "gcc/omp-low.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b647956caa977d1ae489f9baed9cef70b4f382/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b647956caa977d1ae489f9baed9cef70b4f382/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=33b647956caa977d1ae489f9baed9cef70b4f382", "patch": "@@ -4389,14 +4389,28 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t{\n \t  for (tree c = gimple_omp_for_clauses (ctx->stmt); c;\n \t       c = OMP_CLAUSE_CHAIN (c))\n-\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n-\t\t&& OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n-\t      {\n-\t\t/* UDR reductions are not supported yet for SIMT, disable\n-\t\t   SIMT.  */\n-\t\tsctx->max_vf = 1;\n-\t\tbreak;\n+\t    {\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\t\tcontinue;\n+\n+\t      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t\t{\n+\t\t  /* UDR reductions are not supported yet for SIMT, disable\n+\t\t     SIMT.  */\n+\t\t  sctx->max_vf = 1;\n+\t\t  break;\n+\t\t}\n+\n+\t      if (truth_value_p (OMP_CLAUSE_REDUCTION_CODE (c))\n+\t\t  && !INTEGRAL_TYPE_P (TREE_TYPE (new_var)))\n+\t\t{\n+\t\t  /* Doing boolean operations on non-integral types is\n+\t\t     for conformance only, it's not worth supporting this\n+\t\t     for SIMT.  */\n+\t\t  sctx->max_vf = 1;\n+\t\t  break;\n \t      }\n+\t    }\n \t}\n       if (maybe_gt (sctx->max_vf, 1U))\n \t{"}, {"sha": "21540512e23e8350be8bcba97c9833ac750e9a33", "filename": "libgomp/testsuite/libgomp.c-c++-common/reduction-5.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b647956caa977d1ae489f9baed9cef70b4f382/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b647956caa977d1ae489f9baed9cef70b4f382/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-5.c?ref=33b647956caa977d1ae489f9baed9cef70b4f382", "patch": "@@ -0,0 +1,193 @@\n+/* { dg-additional-options \"-foffload=-latomic\" { target { offload_target_nvptx } } } */\n+/* C / C++'s logical AND and OR operators take any scalar argument\n+   which compares (un)equal to 0 - the result 1 or 0 and of type int.\n+\n+   In this testcase, the int result is again converted to a floating-poing\n+   or complex type.\n+\n+   While having a floating-point/complex array element with || and && can make\n+   sense, having a non-integer/non-bool reduction variable is odd but valid.\n+\n+   Test: FP reduction variable + FP array - as reduction-1.c but with target  */\n+\n+#define N 1024\n+_Complex float rcf[N];\n+_Complex double rcd[N];\n+float rf[N];\n+double rd[N];\n+\n+int\n+reduction_or ()\n+{\n+  float orf = 0;\n+  double ord = 0;\n+  _Complex float orfc = 0;\n+  _Complex double ordc = 0;\n+\n+  #pragma omp target parallel reduction(||: orf) map(orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp target parallel for reduction(||: ord) map(ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp target parallel for simd reduction(||: orfc) map(orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp target parallel loop reduction(||: ordc) map(ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_or_teams ()\n+{\n+  float orf = 0;\n+  double ord = 0;\n+  _Complex float orfc = 0;\n+  _Complex double ordc = 0;\n+\n+  #pragma omp target teams distribute parallel for reduction(||: orf) map(orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(||: ord) map(ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp target teams distribute parallel for reduction(||: orfc) map(orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(||: ordc) map(ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_and ()\n+{\n+  float andf = 1;\n+  double andd = 1;\n+  _Complex float andfc = 1;\n+  _Complex double anddc = 1;\n+\n+  #pragma omp target parallel reduction(&&: andf) map(andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp target parallel for reduction(&&: andd) map(andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp target parallel for simd reduction(&&: andfc) map(andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp target parallel loop reduction(&&: anddc) map(anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+reduction_and_teams ()\n+{\n+  float andf = 1;\n+  double andd = 1;\n+  _Complex float andfc = 1;\n+  _Complex double anddc = 1;\n+\n+  #pragma omp target teams distribute parallel for reduction(&&: andf) map(andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(&&: andd) map(andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp target teams distribute parallel for reduction(&&: andfc) map(andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(&&: anddc) map(anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 0;\n+      rd[i] = 0;\n+      rcf[i] = 0;\n+      rcd[i] = 0;\n+    }\n+\n+  if (reduction_or () != 0)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 0)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  rf[10] = 1.0;\n+  rd[15] = 1.0;\n+  rcf[10] = 1.0;\n+  rcd[15] = 1.0i;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 1;\n+      rd[i] = 1;\n+      rcf[i] = 1;\n+      rcd[i] = 1;\n+    }\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 4)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 4)\n+    __builtin_abort ();\n+\n+  rf[10] = 0.0;\n+  rd[15] = 0.0;\n+  rcf[10] = 0.0;\n+  rcd[15] = 0.0;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "27d9ef6b635a6db877bf0249042cd823bc191fb5", "filename": "libgomp/testsuite/libgomp.c-c++-common/reduction-6.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b647956caa977d1ae489f9baed9cef70b4f382/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b647956caa977d1ae489f9baed9cef70b4f382/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-6.c?ref=33b647956caa977d1ae489f9baed9cef70b4f382", "patch": "@@ -0,0 +1,196 @@\n+/* { dg-additional-options \"-foffload=-latomic\" { target { offload_target_nvptx } } } */\n+/* C / C++'s logical AND and OR operators take any scalar argument\n+   which compares (un)equal to 0 - the result 1 or 0 and of type int.\n+\n+   In this testcase, the int result is again converted to an integer complex\n+   type.\n+\n+   While having a floating-point/complex array element with || and && can make\n+   sense, having a complex reduction variable is odd but valid.\n+\n+   Test: int complex reduction variable + int complex array.\n+         as reduction-4.c but with target.  */\n+\n+#define N 1024\n+_Complex char rcc[N];\n+_Complex short rcs[N];\n+_Complex int rci[N];\n+_Complex long long rcl[N];\n+\n+int\n+reduction_or ()\n+{\n+  _Complex char orc = 0;\n+  _Complex short ors = 0;\n+  _Complex int ori = 0;\n+  _Complex long orl = 0;\n+\n+  #pragma omp target parallel reduction(||: orc) map(orc)\n+  for (int i=0; i < N; ++i)\n+    orc = orc || rcl[i];\n+\n+  #pragma omp target parallel for reduction(||: ors) map(ors)\n+  for (int i=0; i < N; ++i)\n+    ors = ors || rci[i];\n+\n+  #pragma omp target parallel for simd reduction(||: ori) map(ori)\n+  for (int i=0; i < N; ++i)\n+    ori = ori || rcs[i];\n+\n+  #pragma omp target parallel loop reduction(||: orl) map(orl)\n+  for (int i=0; i < N; ++i)\n+    orl = orl || rcc[i];\n+\n+  return __real__ (orc + ors + ori + orl) + __imag__ (orc + ors + ori + orl);\n+}\n+\n+int\n+reduction_or_teams ()\n+{\n+  _Complex char orc = 0;\n+  _Complex short ors = 0;\n+  _Complex int ori = 0;\n+  _Complex long orl = 0;\n+\n+  #pragma omp target teams distribute parallel for reduction(||: orc) map(orc)\n+  for (int i=0; i < N; ++i)\n+    orc = orc || rcc[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(||: ors) map(ors)\n+  for (int i=0; i < N; ++i)\n+    ors = ors || rcs[i];\n+\n+  #pragma omp target teams distribute parallel for reduction(||: ori) map(ori)\n+  for (int i=0; i < N; ++i)\n+    ori = ori || rci[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(||: orl) map(orl)\n+  for (int i=0; i < N; ++i)\n+    orl = orl || rcl[i];\n+\n+  return __real__ (orc + ors + ori + orl) + __imag__ (orc + ors + ori + orl);\n+}\n+\n+int\n+reduction_and ()\n+{\n+  _Complex char andc = 1;\n+  _Complex short ands = 1;\n+  _Complex int andi = 1;\n+  _Complex long andl = 1;\n+\n+  #pragma omp target parallel reduction(&&: andc) map(andc)\n+  for (int i=0; i < N; ++i)\n+    andc = andc && rcc[i];\n+\n+  #pragma omp target parallel for reduction(&&: ands) map(ands)\n+  for (int i=0; i < N; ++i)\n+    ands = ands && rcs[i];\n+\n+  #pragma omp target parallel for simd reduction(&&: andi) map(andi)\n+  for (int i=0; i < N; ++i)\n+    andi = andi && rci[i];\n+\n+  #pragma omp target parallel loop reduction(&&: andl) map(andl)\n+  for (int i=0; i < N; ++i)\n+    andl = andl && rcl[i];\n+\n+  return __real__ (andc + ands + andi + andl)\n+\t + __imag__ (andc + ands + andi + andl);\n+}\n+\n+int\n+reduction_and_teams ()\n+{\n+  _Complex char andc = 1;\n+  _Complex short ands = 1;\n+  _Complex int andi = 1;\n+  _Complex long andl = 1;\n+\n+  #pragma omp target teams distribute parallel for reduction(&&: andc) map(andc)\n+  for (int i=0; i < N; ++i)\n+    andc = andc && rcl[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(&&: ands) map(ands)\n+  for (int i=0; i < N; ++i)\n+    ands = ands && rci[i];\n+\n+  #pragma omp target teams distribute parallel for reduction(&&: andi) map(andi)\n+  for (int i=0; i < N; ++i)\n+    andi = andi && rcs[i];\n+\n+  #pragma omp target teams distribute parallel for simd reduction(&&: andl) map(andl)\n+  for (int i=0; i < N; ++i)\n+    andl = andl && rcc[i];\n+\n+  return __real__ (andc + ands + andi + andl)\n+\t + __imag__ (andc + ands + andi + andl);\n+}\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rcc[i] = 0;\n+      rcs[i] = 0;\n+      rci[i] = 0;\n+      rcl[i] = 0;\n+    }\n+\n+  if (reduction_or () != 0)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 0)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  rcc[10] = 1.0;\n+  rcs[15] = 1.0i;\n+  rci[10] = 1.0;\n+  rcl[15] = 1.0i;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rcc[i] = 1;\n+      rcs[i] = 1i;\n+      rci[i] = 1;\n+      rcl[i] = 1 + 1i;\n+    }\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 4)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 4)\n+    __builtin_abort ();\n+\n+  rcc[10] = 0.0;\n+  rcs[15] = 0.0;\n+  rci[10] = 0.0;\n+  rcl[15] = 0.0;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}