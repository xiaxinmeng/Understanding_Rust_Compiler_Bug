{"sha": "4d39941ea9e6fe059084be9f5dea7e29e055db91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzOTk0MWVhOWU2ZmUwNTkwODRiZTlmNWRlYTdlMjllMDU1ZGI5MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-12-14T11:47:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-12-14T11:47:24Z"}, "message": "gigi.h (pad_type_has_rm_size): Declare.\n\n\t* gcc-interface/gigi.h (pad_type_has_rm_size): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Do not build\n\ta padding type for the alignment before validating the size.\n\tFlip conditional construct and add a comment.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Size>: Make sure to\n\tapply the exception for padded objects to the type of the object.\n\t* gcc-interface/utils.c (hash_pad_type): New static function.\n\t(lookup_and_insert_pad_type): Rename into...\n\t(canonicalize_pad_type): ...this.  Call hash_pad_type, do only one\n\tlookup with insertion and always return the canonical type.\n\t(maybe_pad_type): Adjust to above changes.  Set debug type later.\n\t(pad_type_has_rm_size): New predicate.\n\t(set_reverse_storage_order_on_pad_type): Adjust to above changes.\n\nFrom-SVN: r255631", "tree": {"sha": "cb51425855d3854723367fc3c5edb23fca63211e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb51425855d3854723367fc3c5edb23fca63211e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d39941ea9e6fe059084be9f5dea7e29e055db91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d39941ea9e6fe059084be9f5dea7e29e055db91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d39941ea9e6fe059084be9f5dea7e29e055db91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d39941ea9e6fe059084be9f5dea7e29e055db91/comments", "author": null, "committer": null, "parents": [{"sha": "02aee327674dae6359d7b1e1a7434f039ba0c3d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02aee327674dae6359d7b1e1a7434f039ba0c3d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02aee327674dae6359d7b1e1a7434f039ba0c3d3"}], "stats": {"total": 207, "additions": 133, "deletions": 74}, "files": [{"sha": "3ac3bfba6e5371e1d8634c8484e5d6aec37df6ee", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -1,3 +1,19 @@\n+2017-12-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (pad_type_has_rm_size): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Do not build\n+\ta padding type for the alignment before validating the size.\n+\tFlip conditional construct and add a comment.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Size>: Make sure to\n+\tapply the exception for padded objects to the type of the object.\n+\t* gcc-interface/utils.c (hash_pad_type): New static function.\n+\t(lookup_and_insert_pad_type): Rename into...\n+\t(canonicalize_pad_type): ...this.  Call hash_pad_type, do only one\n+\tlookup with insertion and always return the canonical type.\n+\t(maybe_pad_type): Adjust to above changes.  Set debug type later.\n+\t(pad_type_has_rm_size): New predicate.\n+\t(set_reverse_storage_order_on_pad_type): Adjust to above changes.\n+\n 2017-12-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Initialize locus."}, {"sha": "f2da070ab0fba652411a3edeaad60fb84718a0ce", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 18, "deletions": 46, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -713,48 +713,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  }\n \n \t/* If an alignment is specified, use it if valid.  Note that exceptions\n-\t   are objects but don't have an alignment.  We must do this before we\n-\t   validate the size, since the alignment can affect the size.  */\n-\tif (kind != E_Exception && Known_Alignment (gnat_entity))\n-\t  {\n-\t    gcc_assert (Present (Alignment (gnat_entity)));\n-\n-\t    align = validate_alignment (Alignment (gnat_entity), gnat_entity,\n-\t\t\t\t\tTYPE_ALIGN (gnu_type));\n-\n-\t    /* No point in changing the type if there is an address clause\n-\t       as the final type of the object will be a reference type.  */\n-\t    if (Present (Address_Clause (gnat_entity)))\n-\t      align = 0;\n-\t    else\n-\t      {\n-\t\ttree orig_type = gnu_type;\n-\n-\t\tgnu_type\n-\t\t  = maybe_pad_type (gnu_type, NULL_TREE, align, gnat_entity,\n-\t\t\t\t    false, false, definition, true);\n-\n-\t\t/* If a padding record was made, declare it now since it will\n-\t\t   never be declared otherwise.  This is necessary to ensure\n-\t\t   that its subtrees are properly marked.  */\n-\t\tif (gnu_type != orig_type && !DECL_P (TYPE_NAME (gnu_type)))\n-\t\t  create_type_decl (TYPE_NAME (gnu_type), gnu_type, true,\n-\t\t\t\t    debug_info_p, gnat_entity);\n-\t      }\n-\t  }\n-\n-\t/* If we are defining the object, see if it has a Size and validate it\n-\t   if so.  If we are not defining the object and a Size clause applies,\n-\t   simply retrieve the value.  We don't want to ignore the clause and\n-\t   it is expected to have been validated already.  Then get the new\n-\t   type, if any.  */\n-\tif (definition)\n-\t  gnu_size = validate_size (Esize (gnat_entity), gnu_type,\n-\t\t\t\t    gnat_entity, VAR_DECL, false,\n-\t\t\t\t    Has_Size_Clause (gnat_entity));\n-\telse if (Has_Size_Clause (gnat_entity))\n-\t  gnu_size = UI_To_gnu (Esize (gnat_entity), bitsizetype);\n+\t   are objects but don't have an alignment and there is also no point in\n+\t   setting it for an address clause, since the final type of the object\n+\t   will be a reference type.  */\n+\tif (Known_Alignment (gnat_entity)\n+\t    && kind != E_Exception\n+\t    && No (Address_Clause (gnat_entity)))\n+\t  align = validate_alignment (Alignment (gnat_entity), gnat_entity,\n+\t\t\t\t      TYPE_ALIGN (gnu_type));\n \n+\t/* Likewise, if a size is specified, use it if valid.  */\n+\tif (Known_Esize (gnat_entity) && No (Address_Clause (gnat_entity)))\n+\t  gnu_size\n+\t    = validate_size (Esize (gnat_entity), gnu_type, gnat_entity,\n+\t\t\t     VAR_DECL, false, Has_Size_Clause (gnat_entity));\n \tif (gnu_size)\n \t  {\n \t    gnu_type\n@@ -4580,15 +4552,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  gnu_type = change_qualified_type (gnu_type, quals);\n \t}\n \n-      if (!gnu_decl)\n-\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n-\t\t\t\t     artificial_p, debug_info_p,\n-\t\t\t\t     gnat_entity);\n-      else\n+      /* If we already made a decl, just set the type, otherwise create it.  */\n+      if (gnu_decl)\n \t{\n \t  TREE_TYPE (gnu_decl) = gnu_type;\n \t  TYPE_STUB_DECL (gnu_type) = gnu_decl;\n \t}\n+      else\n+\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type, artificial_p,\n+\t\t\t\t     debug_info_p, gnat_entity);\n     }\n \n   /* If we got a type that is not dummy, back-annotate the alignment of the"}, {"sha": "f700374a3968a13fd468c1952e52462faef114c5", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -151,6 +151,9 @@ extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t    bool is_user_type, bool definition,\n \t\t\t    bool set_rm_size);\n \n+/* Return true if padded TYPE was built with an RM size.  */\n+extern bool pad_type_has_rm_size (tree type);\n+\n /* Return a copy of the padded TYPE but with reverse storage order.  */\n extern tree set_reverse_storage_order_on_pad_type (tree type);\n "}, {"sha": "cae156fa8c6e398f1761fa3f81762d92abbafcce", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -1850,7 +1850,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t This is in keeping with the object case of gnat_to_gnu_entity.  */\n       else if ((TREE_CODE (gnu_prefix) != TYPE_DECL\n \t\t&& !(TYPE_IS_PADDING_P (gnu_type)\n-\t\t     && TREE_CODE (gnu_expr) == COMPONENT_REF))\n+\t\t     && TREE_CODE (gnu_expr) == COMPONENT_REF\n+\t\t     && pad_type_has_rm_size (gnu_type)))\n \t       || attribute == Attr_Object_Size\n \t       || attribute == Attr_Max_Size_In_Storage_Elements)\n \t{"}, {"sha": "eae23d281b09e6c6732e6327cbe17d0b5dc896d7", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -1224,32 +1224,44 @@ pad_type_hasher::equal (pad_type_hash *t1, pad_type_hash *t2)\n     && TYPE_REVERSE_STORAGE_ORDER (type1) == TYPE_REVERSE_STORAGE_ORDER (type2);\n }\n \n-/* Look up the padded TYPE in the hash table and return its canonical version\n-   if it exists; otherwise, insert it into the hash table.  */\n+/* Compute the hash value for the padded TYPE.  */\n \n-static tree\n-lookup_and_insert_pad_type (tree type)\n+static hashval_t\n+hash_pad_type (tree type)\n {\n   hashval_t hashcode;\n-  struct pad_type_hash in, *h;\n \n   hashcode\n     = iterative_hash_object (TYPE_HASH (TREE_TYPE (TYPE_FIELDS (type))), 0);\n   hashcode = iterative_hash_expr (TYPE_SIZE (type), hashcode);\n   hashcode = iterative_hash_hashval_t (TYPE_ALIGN (type), hashcode);\n   hashcode = iterative_hash_expr (TYPE_ADA_SIZE (type), hashcode);\n \n+  return hashcode;\n+}\n+\n+/* Look up the padded TYPE in the hash table and return its canonical version\n+   if it exists; otherwise, insert it into the hash table.  */\n+\n+static tree\n+canonicalize_pad_type (tree type)\n+{\n+  const hashval_t hashcode = hash_pad_type (type);\n+  struct pad_type_hash in, *h, **slot;\n+\n   in.hash = hashcode;\n   in.type = type;\n-  h = pad_type_hash_table->find_with_hash (&in, hashcode);\n-  if (h)\n-    return h->type;\n+  slot = pad_type_hash_table->find_slot_with_hash (&in, hashcode, INSERT);\n+  h = *slot;\n+  if (!h)\n+    {\n+      h = ggc_alloc<pad_type_hash> ();\n+      h->hash = hashcode;\n+      h->type = type;\n+      *slot = h;\n+    }\n \n-  h = ggc_alloc<pad_type_hash> ();\n-  h->hash = hashcode;\n-  h->type = type;\n-  *pad_type_hash_table->find_slot_with_hash (h, hashcode, INSERT) = h;\n-  return NULL_TREE;\n+  return h->type;\n }\n \n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n@@ -1380,28 +1392,29 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* We will output additional debug info manually below.  */\n   finish_record_type (record, field, 1, false);\n \n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-    SET_TYPE_DEBUG_TYPE (record, type);\n-\n   /* Set the RM size if requested.  */\n   if (set_rm_size)\n     {\n-      tree canonical_pad_type;\n-\n       SET_TYPE_ADA_SIZE (record, size ? size : orig_size);\n \n       /* If the padded type is complete and has constant size, we canonicalize\n \t it by means of the hash table.  This is consistent with the language\n \t semantics and ensures that gigi and the middle-end have a common view\n \t of these padded types.  */\n-      if (TREE_CONSTANT (TYPE_SIZE (record))\n-\t  && (canonical_pad_type = lookup_and_insert_pad_type (record)))\n+      if (TREE_CONSTANT (TYPE_SIZE (record)))\n \t{\n-\t  record = canonical_pad_type;\n-\t  goto built;\n+\t  tree canonical = canonicalize_pad_type (record);\n+\t  if (canonical != record)\n+\t    {\n+\t      record = canonical;\n+\t      goto built;\n+\t    }\n \t}\n     }\n \n+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+    SET_TYPE_DEBUG_TYPE (record, type);\n+\n   /* Unless debugging information isn't being written for the input type,\n      write a record that shows what we are a subtype of and also make a\n      variable that indicates our size, if still variable.  */\n@@ -1520,13 +1533,31 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   return record;\n }\n \n+/* Return true if padded TYPE was built with an RM size.  */\n+\n+bool\n+pad_type_has_rm_size (tree type)\n+{\n+  /* This is required for the lookup.  */\n+  if (!TREE_CONSTANT (TYPE_SIZE (type)))\n+    return false;\n+\n+  const hashval_t hashcode = hash_pad_type (type);\n+  struct pad_type_hash in, *h;\n+\n+  in.hash = hashcode;\n+  in.type = type;\n+  h = pad_type_hash_table->find_with_hash (&in, hashcode);\n+\n+  /* The types built with an RM size are the canonicalized ones.  */\n+  return h && h->type == type;\n+}\n+\n /* Return a copy of the padded TYPE but with reverse storage order.  */\n \n tree\n set_reverse_storage_order_on_pad_type (tree type)\n {\n-  tree field, canonical_pad_type;\n-\n   if (flag_checking)\n     {\n       /* If the inner type is not scalar then the function does nothing.  */\n@@ -1538,13 +1569,12 @@ set_reverse_storage_order_on_pad_type (tree type)\n   /* This is required for the canonicalization.  */\n   gcc_assert (TREE_CONSTANT (TYPE_SIZE (type)));\n \n-  field = copy_node (TYPE_FIELDS (type));\n+  tree field = copy_node (TYPE_FIELDS (type));\n   type = copy_type (type);\n   DECL_CONTEXT (field) = type;\n   TYPE_FIELDS (type) = field;\n   TYPE_REVERSE_STORAGE_ORDER (type) = 1;\n-  canonical_pad_type = lookup_and_insert_pad_type (type);\n-  return canonical_pad_type ? canonical_pad_type : type;\n+  return canonicalize_pad_type (type);\n }\n \f\n /* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP."}, {"sha": "a7686ceb604c30ecfb5e4717be4483079a955402", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -1,3 +1,8 @@\n+2017-12-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/alignment11.adb: New test.\n+\t* gnat.dg/alignment12.adb: Likewise.\n+\n 2017-12-14  Richard Biener  <rguenther@suse.de>\n \n \tPR c/83415"}, {"sha": "e55d8783180fd3bdbb9193e4cb66212b774a875a", "filename": "gcc/testsuite/gnat.dg/alignment11.adb", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Ftestsuite%2Fgnat.dg%2Falignment11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Ftestsuite%2Fgnat.dg%2Falignment11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment11.adb?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -0,0 +1,15 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+procedure Alignment11 is\n+\n+  type Arr is array (1 .. 3) of Character;\n+  for Arr'Alignment use 4;\n+\n+  A : Arr;\n+\n+begin\n+  if A'Size /= 32 then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "0992913250ec95f414a8a792e0cc886ddae05c88", "filename": "gcc/testsuite/gnat.dg/alignment12.adb", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Ftestsuite%2Fgnat.dg%2Falignment12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d39941ea9e6fe059084be9f5dea7e29e055db91/gcc%2Ftestsuite%2Fgnat.dg%2Falignment12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment12.adb?ref=4d39941ea9e6fe059084be9f5dea7e29e055db91", "patch": "@@ -0,0 +1,17 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+\n+procedure Alignment12 is\n+\n+  type Rec is record\n+    I : Integer;\n+  end record;\n+\n+  R : Rec;\n+  for R'Alignment use 8;\n+\n+begin\n+  if R'Size /= 32 then\n+    raise Program_Error;\n+  end if;\n+end;"}]}