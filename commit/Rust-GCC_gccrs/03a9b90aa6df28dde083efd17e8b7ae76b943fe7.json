{"sha": "03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNhOWI5MGFhNmRmMjhkZGUwODNlZmQxN2U4YjdhZTc2Yjk0M2ZlNw==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2019-10-02T14:23:51Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2019-10-02T14:23:51Z"}, "message": "builtins.c (expand_builtin_memory_copy_args): Add might_overlap parm.\n\n2019-10-02  Aaron Sawdey <acsawdey@linux.ibm.com>\n\n\t* builtins.c (expand_builtin_memory_copy_args): Add might_overlap parm.\n\t(expand_builtin_memcpy): Use might_overlap parm.\n\t(expand_builtin_mempcpy_args): Use might_overlap parm.\n\t(expand_builtin_memmove): Call expand_builtin_memory_copy_args.\n\t(expand_builtin_memory_copy_args): Add might_overlap parm.\n\t* expr.c (emit_block_move_via_cpymem): Rename to\n\temit_block_move_via_pattern, add might_overlap parm, use cpymem\n\tor movmem optab as appropriate.\n\t(emit_block_move_hints): Add might_overlap parm, do the right\n\tthing for might_overlap==true.\n\t* expr.h (emit_block_move_hints): Update prototype.\n\nFrom-SVN: r276461", "tree": {"sha": "cf2c7debb8c890c231f2b9b46d142d78e10e2f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf2c7debb8c890c231f2b9b46d142d78e10e2f4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "629387a6586a753166f5cf53d587026a34362523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629387a6586a753166f5cf53d587026a34362523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/629387a6586a753166f5cf53d587026a34362523"}], "stats": {"total": 117, "additions": 87, "deletions": 30}, "files": [{"sha": "fe1457769db452d7c35d01fc2f60d48b1e76a9a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "patch": "@@ -1,3 +1,17 @@\n+2019-10-02  Aaron Sawdey <acsawdey@linux.ibm.com>\n+\n+\t* builtins.c (expand_builtin_memory_copy_args): Add might_overlap parm.\n+\t(expand_builtin_memcpy): Use might_overlap parm.\n+\t(expand_builtin_mempcpy_args): Use might_overlap parm.\n+\t(expand_builtin_memmove): Call expand_builtin_memory_copy_args.\n+\t(expand_builtin_memory_copy_args): Add might_overlap parm.\n+\t* expr.c (emit_block_move_via_cpymem): Rename to\n+\temit_block_move_via_pattern, add might_overlap parm, use cpymem\n+\tor movmem optab as appropriate.\n+\t(emit_block_move_hints): Add might_overlap parm, do the right\n+\tthing for might_overlap==true.\n+\t* expr.h (emit_block_move_hints): Update prototype.\n+\n 2019-10-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-eh.h (unsplit_eh_edges): Declare."}, {"sha": "fa17afd2e8a974338adbbeb583e42124dd973f3a", "filename": "gcc/builtins.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "patch": "@@ -127,7 +127,8 @@ static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n \t\t\t\t\t    rtx target, tree exp,\n-\t\t\t\t\t    memop_ret retmode);\n+\t\t\t\t\t    memop_ret retmode,\n+\t\t\t\t\t    bool might_overlap);\n static rtx expand_builtin_memmove (tree, rtx);\n static rtx expand_builtin_mempcpy (tree, rtx);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, memop_ret);\n@@ -3790,14 +3791,14 @@ expand_builtin_memcpy (tree exp, rtx target)\n   check_memop_access (exp, dest, src, len);\n \n   return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n-\t\t\t\t\t  /*retmode=*/ RETURN_BEGIN);\n+\t\t\t\t\t  /*retmode=*/ RETURN_BEGIN, false);\n }\n \n /* Check a call EXP to the memmove built-in for validity.\n    Return NULL_RTX on both success and failure.  */\n \n static rtx\n-expand_builtin_memmove (tree exp, rtx)\n+expand_builtin_memmove (tree exp, rtx target)\n {\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -3809,7 +3810,8 @@ expand_builtin_memmove (tree exp, rtx)\n \n   check_memop_access (exp, dest, src, len);\n \n-  return NULL_RTX;\n+  return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n+\t\t\t\t\t  /*retmode=*/ RETURN_BEGIN, true);\n }\n \n /* Expand a call EXP to the mempcpy builtin.\n@@ -3858,7 +3860,8 @@ expand_builtin_mempcpy (tree exp, rtx target)\n \n static rtx\n expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n-\t\t\t\t rtx target, tree exp, memop_ret retmode)\n+\t\t\t\t rtx target, tree exp, memop_ret retmode,\n+\t\t\t\t bool might_overlap)\n {\n   const char *src_str;\n   unsigned int src_align = get_pointer_alignment (src);\n@@ -3894,9 +3897,12 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n \t\t\t&probable_max_size);\n   src_str = c_getstr (src);\n \n-  /* If SRC is a string constant and block move would be done\n-     by pieces, we can avoid loading the string from memory\n-     and only stored the computed constants.  */\n+  /* If SRC is a string constant and block move would be done by\n+     pieces, we can avoid loading the string from memory and only\n+     stored the computed constants.  This works in the overlap\n+     (memmove) case as well because store_by_pieces just generates a\n+     series of stores of constants from the string constant returned\n+     by c_getstr().  */\n   if (src_str\n       && CONST_INT_P (len_rtx)\n       && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n@@ -3923,13 +3929,14 @@ expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n     method = BLOCK_OP_TAILCALL;\n   bool use_mempcpy_call = (targetm.libc_has_fast_function (BUILT_IN_MEMPCPY)\n \t\t\t   && retmode == RETURN_END\n+\t\t\t   && !might_overlap\n \t\t\t   && target != const0_rtx);\n   if (use_mempcpy_call)\n     method = BLOCK_OP_NO_LIBCALL_RET;\n   dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx, method,\n \t\t\t\t     expected_align, expected_size,\n \t\t\t\t     min_size, max_size, probable_max_size,\n-\t\t\t\t     use_mempcpy_call, &is_move_done);\n+\t\t\t\t     use_mempcpy_call, &is_move_done, might_overlap);\n \n   /* Bail out when a mempcpy call would be expanded as libcall and when\n      we have a target that provides a fast implementation\n@@ -3962,7 +3969,7 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n \t\t\t     rtx target, tree orig_exp, memop_ret retmode)\n {\n   return expand_builtin_memory_copy_args (dest, src, len, target, orig_exp,\n-\t\t\t\t\t  retmode);\n+\t\t\t\t\t  retmode, false);\n }\n \n /* Expand into a movstr instruction, if one is available.  Return NULL_RTX if"}, {"sha": "bd6a71a4e2fde97c511a6827d39c6229bfb1cb60", "filename": "gcc/expr.c", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "patch": "@@ -73,9 +73,10 @@ along with GCC; see the file COPYING3.  If not see\n int cse_not_expected;\n \n static bool block_move_libcall_safe_for_call_parm (void);\n-static bool emit_block_move_via_cpymem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT,\n-\t\t\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\t\t\tunsigned HOST_WIDE_INT);\n+static bool emit_block_move_via_pattern (rtx, rtx, rtx, unsigned, unsigned, \n+\t\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT, bool);\n static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n static void clear_by_pieces (rtx, unsigned HOST_WIDE_INT, unsigned int);\n static rtx_insn *compress_float_constant (rtx, rtx);\n@@ -1562,7 +1563,8 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n \t\t       unsigned HOST_WIDE_INT min_size,\n \t\t       unsigned HOST_WIDE_INT max_size,\n \t\t       unsigned HOST_WIDE_INT probable_max_size,\n-\t\t       bool bail_out_libcall, bool *is_move_done)\n+\t\t       bool bail_out_libcall, bool *is_move_done,\n+\t\t       bool might_overlap)\n {\n   int may_use_call;\n   rtx retval = 0;\n@@ -1622,13 +1624,30 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n       set_mem_size (y, const_size);\n     }\n \n-  if (CONST_INT_P (size) && can_move_by_pieces (INTVAL (size), align))\n-    move_by_pieces (x, y, INTVAL (size), align, RETURN_BEGIN);\n-  else if (emit_block_move_via_cpymem (x, y, size, align,\n-\t\t\t\t       expected_align, expected_size,\n-\t\t\t\t       min_size, max_size, probable_max_size))\n+  bool pieces_ok = can_move_by_pieces (INTVAL (size), align);\n+  bool pattern_ok = false;\n+\n+  if (!CONST_INT_P (size) || !pieces_ok || might_overlap)\n+    {\n+      pattern_ok = \n+\temit_block_move_via_pattern (x, y, size, align,\n+\t\t\t\t     expected_align, expected_size,\n+\t\t\t\t     min_size, max_size, probable_max_size,\n+\t\t\t\t     might_overlap);\n+      if (!pattern_ok && might_overlap)\n+\t{\n+\t  /* Do not try any of the other methods below as they are not safe\n+\t     for overlapping moves.  */\n+\t  *is_move_done = false;\n+\t  return retval;\n+\t}\n+    }\n+\n+  if (pattern_ok)\n     ;\n-  else if (may_use_call\n+  else if (CONST_INT_P (size) && pieces_ok)\n+    move_by_pieces (x, y, INTVAL (size), align, RETURN_BEGIN);\n+  else if (may_use_call && !might_overlap\n \t   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))\n \t   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (y)))\n     {\n@@ -1645,7 +1664,8 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n       retval = emit_block_copy_via_libcall (x, y, size,\n \t\t\t\t\t    method == BLOCK_OP_TAILCALL);\n     }\n-\n+  else if (might_overlap)\n+    *is_move_done = false;\n   else\n     emit_block_move_via_loop (x, y, size, align);\n \n@@ -1721,15 +1741,26 @@ block_move_libcall_safe_for_call_parm (void)\n   return true;\n }\n \n-/* A subroutine of emit_block_move.  Expand a cpymem pattern;\n-   return true if successful.  */\n+/* A subroutine of emit_block_move.  Expand a cpymem or movmem pattern;\n+   return true if successful.\n+  \n+   X is the destination of the copy or move.\n+   Y is the source of the copy or move.\n+   SIZE is the size of the block to be moved.\n+\n+   MIGHT_OVERLAP indicates this originated with expansion of a\n+   builtin_memmove() and the source and destination blocks may\n+   overlap.\n+  */\n \n static bool\n-emit_block_move_via_cpymem (rtx x, rtx y, rtx size, unsigned int align,\n-\t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size,\n-\t\t\t    unsigned HOST_WIDE_INT min_size,\n-\t\t\t    unsigned HOST_WIDE_INT max_size,\n-\t\t\t    unsigned HOST_WIDE_INT probable_max_size)\n+emit_block_move_via_pattern (rtx x, rtx y, rtx size, unsigned int align,\n+\t\t\t     unsigned int expected_align,\n+\t\t\t     HOST_WIDE_INT expected_size,\n+\t\t\t     unsigned HOST_WIDE_INT min_size,\n+\t\t\t     unsigned HOST_WIDE_INT max_size,\n+\t\t\t     unsigned HOST_WIDE_INT probable_max_size,\n+\t\t\t     bool might_overlap)\n {\n   if (expected_align < align)\n     expected_align = align;\n@@ -1752,7 +1783,11 @@ emit_block_move_via_cpymem (rtx x, rtx y, rtx size, unsigned int align,\n   FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n     {\n       scalar_int_mode mode = mode_iter.require ();\n-      enum insn_code code = direct_optab_handler (cpymem_optab, mode);\n+      enum insn_code code;\n+      if (might_overlap)\n+\tcode = direct_optab_handler (movmem_optab, mode);\n+      else\n+\tcode = direct_optab_handler (cpymem_optab, mode);\n \n       if (code != CODE_FOR_nothing\n \t  /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT"}, {"sha": "17c9163c351113e9e4badc3be08507b0d738b321", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9b90aa6df28dde083efd17e8b7ae76b943fe7/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=03a9b90aa6df28dde083efd17e8b7ae76b943fe7", "patch": "@@ -116,7 +116,8 @@ extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,\n \t\t\t\t  unsigned HOST_WIDE_INT,\n \t\t\t\t  unsigned HOST_WIDE_INT,\n \t\t\t\t  bool bail_out_libcall = false,\n-\t\t\t\t  bool *is_move_done = NULL);\n+\t\t\t\t  bool *is_move_done = NULL,\n+\t\t\t\t  bool might_overlap = false);\n extern rtx emit_block_cmp_hints (rtx, rtx, rtx, tree, rtx, bool,\n \t\t\t\t by_pieces_constfn, void *);\n extern bool emit_storent_insn (rtx to, rtx from);"}]}