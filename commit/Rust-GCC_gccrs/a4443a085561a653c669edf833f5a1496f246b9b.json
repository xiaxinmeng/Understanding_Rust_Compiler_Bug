{"sha": "a4443a085561a653c669edf833f5a1496f246b9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ0NDNhMDg1NTYxYTY1M2M2NjllZGY4MzNmNWExNDk2ZjI0NmI5Yg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-13T02:46:07Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-13T02:46:07Z"}, "message": "37th Cygnus<->FSF merge\n\nFrom-SVN: r7290", "tree": {"sha": "f5b93db711e076badbbc538e10d3f61b684d5908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5b93db711e076badbbc538e10d3f61b684d5908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4443a085561a653c669edf833f5a1496f246b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4443a085561a653c669edf833f5a1496f246b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4443a085561a653c669edf833f5a1496f246b9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4443a085561a653c669edf833f5a1496f246b9b/comments", "author": null, "committer": null, "parents": [{"sha": "5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0"}], "stats": {"total": 1055, "additions": 670, "deletions": 385}, "files": [{"sha": "bd2be26f9cab41fb3f3acd2d8769152b21838fc1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -2,6 +2,186 @@ Thu May 12 19:13:54 1994  Richard Earnshaw  (rwe11@cl.cam.ac.uk)\n \n \t* g++.c: Use #ifdef for __MSDOS__, not #if.\n \n+Thu May 12 18:05:18 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* decl2.c (lang_f_options): Handle -fshort-temps.  -fshort-temps\n+\tgives old behavior , and destroys temporaries earlier.  Default\n+\tbehavior now conforms to the ANSI working paper.\n+\n+Thu May 12 14:45:35 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_modify_expr): Understand MODIFY_EXPR as an lvalue.\n+\tUse convert_force to convert the result of a recursive call when we\n+\tare dealing with a NOP_EXPR.  Don't automatically wrap MODIFY_EXPRs\n+\tin COMPOUND_EXPRs any more.\n+\t(various): Lose pedantic_lvalue_warning.\n+\t(unary_complex_lvalue): Understand MODIFY_EXPR.\n+\n+\t* cvt.c (convert_to_reference): Allow DECL to be error_mark_node if\n+\twe don't know what we're initializing.\n+\n+Wed May 11 01:59:36 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (convert_to_reference): Modify to use convtype parameter.\n+\tOnly create temporaries when initializing a reference, not when\n+\tcasting.\n+\t(cp_convert): New main function.\n+\t(convert): Call cp_convert.\n+\t* cvt.c, decl.c, typeck.c: Fix calls to convert_to_reference.\n+\t* cp-tree.h (CONV_*): New constants used by conversion code for\n+\tselecting conversions to perform.\n+\n+\t* tree.c (lvalue_p): MODIFY_EXPRs are no longer lvalues.\n+\n+\t* typeck.c (build_{static,reinterpret,const_cast): Stubs that just\n+\tcall build_c_cast.\n+\t* parse.y: Add {static,reinterpret,const}_cast.\n+\t* gxx.gperf: Ditto.\n+\n+\t* typeck.c (common_type): Allow methods with basetypes of different\n+\tUPTs.\n+\t(comptypes): Deal with UPTs.\n+\t(build_modify_expr): Wrap all MODIFY_EXPRs in a COMPOUND_EXPR.\n+\n+\t* pt.c (end_template_decl): Check for multiple definitions of member\n+\ttemplates.\n+\n+\t* call.c (build_method_call): Complain about calling an abstract\n+\tvirtual from a constructor.\n+\n+\t* typeck.c (pointer_int_sum): Check for the integer operand being 0\n+\tafter checking the validity of the pointer operand.\n+\n+\t* typeck2.c (digest_init): Pedwarn about string initializer being\n+\ttoo long.\n+\n+Tue May 10 12:10:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (push_overloaded_decl): Only throw away a builtin if the\n+\tdecl in question is the artificial one.\n+\n+\t* parse.y (simple_stmt, switch): Use implicitly_scoped_stmt because\n+\texpand_{start,end}_case cannot happen in the middle of a block.\n+\n+\t* cvt.c (build_type_conversion_1): Use convert again.\n+\n+Tue May 10 11:52:04 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* typeck2.c (digest_init): Make sure we check for signed and\n+\tunsigned chars as well when warning about string initializers.\n+\n+\t* init.c (emit_base_init): Check if there's a DECL_NAME on the\n+\tmember before trying to do an initialization for it.\n+\n+Tue May 10 11:34:37 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* except.c: Don't do anything useful when cross compiling.\n+\n+Tue May 10 03:04:13 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (duplicate_decls): Fix up handling of builtins yet again.\n+\t(push_overloaded_decl): Ditto.\n+\n+\t* cvt.c (convert): Don't look for void type conversion.\n+\n+Mon May  9 18:05:41 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (do_friend): Only do a pushdecl for friends, not\n+\tpushdecl_top_level.\n+\n+Mon May  9 13:36:34 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)\n+\n+\t* decl.c (lookup_name_current_level): Put empty statement after\n+\tthe label OUT to make the code valid C.\n+\n+Mon May  9 12:20:57 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_binary_op_nodefault): Only complain about\n+\tcomparing void * and a function pointer if void * is smaller.\n+\n+Sun May  8 01:29:13 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (lookup_name_current_level): Move through temporary binding\n+\tlevels.\n+\n+\t* parse.y (already_scoped_stmt): Revive.\n+\t(simple_stmt): Use it again.\n+\n+\t* decl.c (poplevel): Always call poplevel recursively if we're\n+\tdealing with a temporary binding level.\n+\n+Sat May  7 10:52:28 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* decl.c (finish_decl): Make sure we run cleanups for initial values\n+\tof decls.  Cures memory leak.\n+\t* decl.c (expand_static_init): Ditto for static variables.\n+\t* decl2.c (finish_file): Ditto for globals.\n+\n+Sat May  7 03:57:44 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (commonparms): Don't complain about redefining default\n+\targs.\n+\n+\t* decl.c (duplicate_decls): Don't complain twice about conflicting\n+\tfunction decls.\n+\t(decls_match): Don't look at default args.\n+\t(redeclaration_error_message): Complain about redefining default\n+\targs.\n+\n+\t* call.c (build_overload_call_real): Also deal with guiding\n+\tdeclarations coming BEFORE the template decl.\n+\n+\t* pt.c (unify): Allow different parms to have different\n+\tcv-qualifiers.\n+\t(unify): Allow trivial conversions on non-template parms.\n+\n+Fri May  6 03:53:23 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (tsubst): Support OFFSET_TYPEs.\n+\t(unify): Ditto.\n+\n+\t* decl2.c (finish_decl_parsing): Call push_nested_class with a type.\n+\n+\t* init.c (build_offset_ref): Fix error message.\n+\t* search.c (lookup_field): Ditto.\n+\n+\t* call.c (build_scoped_method_call): Pass binfo to\n+\tbuild_method_call.\n+\t* typeck.c (build_object_ref): Ditto.\n+\n+\t* typeck2.c (binfo_or_else): Don't return a _TYPE.\n+\n+\t* class.c (finish_struct): Don't complain about re-use of inherited\n+\tnames or shadowing of type decls.\n+\t* decl.c (pushdecl_class_level): Ditto.\n+\n+\t* decl.c (finish_enum): Set the type of all the enums.\n+\n+\t* class.c (finish_struct): Don't get confused by access decls.\n+\n+\t* cp-tree.h (TYPE_MAIN_DECL): New macro to get the _DECL for a\n+\t_TYPE.  You can stop using TYPE_NAME for that now.\n+\n+\t* parse.y: Lose doing_explicit (check $0 instead).\n+\t* gxx.gperf: 'template' now has a RID.\n+\t* lex.h (rid): Ditto.\n+\t* lex.c (init_lex): Set up the RID for 'template'.\n+\n+\t* parse.y (type_specifier_seq): typed_typespecs or\n+\tnonempty_type_quals.  Use it.\n+\t(handler_args): Fix bogus syntax.\n+\t(raise_identifier{,s}, optional_identifier): Lose.\n+\t* except.c (expand_start_catch_block): Use grokdeclarator to parse\n+\tthe catch variable.\n+\t(init_exception_processing): The second argument to\n+\t__throw_type_match is ptr_type_node.\n+\n+\tFri May  6 07:18:54 1994  Chip Salzenberg  (chip@fin)\n+\n+\t[ change propagated from c-decl.c of snapshot 940429 ]\n+\t* cp/decl.c (finish_decl): Setting asmspec_tree should not\n+\tzero out the old RTL.\n+\n Fri May  6 01:25:38 1994  Mike Stump  (mrs@cygnus.com)\n \n \tAdd alpha exception handling support to the compiler."}, {"sha": "6700f87e87e2a90f48b282cd0e7045dc58c27b19", "filename": "gcc/cp/call.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -2672,7 +2672,7 @@ build_scoped_method_call (exp, scopes, name, parms)\n \t}\n \n       /* Call to a method.  */\n-      return build_method_call (decl, name, parms, NULL_TREE,\n+      return build_method_call (decl, name, parms, binfo,\n \t\t\t\tLOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n     }\n   return error_mark_node;\n@@ -3597,6 +3597,13 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   /* From here on down, BASETYPE is the type that INSTANCE_PTR's\n      type (if it exists) is a pointer to.  */\n \n+  if (DECL_ABSTRACT_VIRTUAL_P (function)\n+      && instance == C_C_D\n+      && DECL_CONSTRUCTOR_P (current_function_decl)\n+      && ! (flags & LOOKUP_NONVIRTUAL)\n+      && value_member (function, get_abstract_virtuals (basetype)))\n+    cp_error (\"abstract virtual `%#D' called from constructor\", function);\n+\n   if (IS_SIGNATURE (basetype) && static_call_context)\n     {\n       cp_error (\"cannot call signature member function `%T::%D' without signature pointer/reference\",\n@@ -4046,22 +4053,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (function)),\n \t\t\t\tparms, &template_cost, 0);\n \t  if (i == 0)\n-\t    {\n-\t      struct candidate *cp2;\n-\n-\t      function = instantiate_template (function, targs);\n-\t      /* Now check that the template instantiated for this is not\n-\t\t the same as a function that's in the list due to some\n-\t\t previous instantiation.  */\n-\t      cp2 = candidates;\n-\t      while (cp2 != cp)\n-\t\tif (cp2->function == function)\n-\t\t  break;\n-\t\telse\n-\t\t  cp2 += 1;\n-\t      if (cp2->function == function)\n-\t\tcontinue;\n-\t    }\n+\t    function = instantiate_template (function, targs);\n \t}\n \n       if (TREE_CODE (function) == TEMPLATE_DECL)\n@@ -4076,6 +4068,19 @@ build_overload_call_real (fnname, parms, flags, final_cp, buildxxx)\n \t}\n       else\n \t{\n+\t  struct candidate *cp2;\n+\n+\t  /* Check that this decl is not the same as a function that's in\n+\t     the list due to some template instantiation.  */\n+\t  cp2 = candidates;\n+\t  while (cp2 != cp)\n+\t    if (cp2->function == function)\n+\t      break;\n+\t    else\n+\t      cp2 += 1;\n+\t  if (cp2->function == function)\n+\t    continue;\n+\n \t  function = DECL_MAIN_VARIANT (function);\n \n \t  /* Can't use alloca here, since result might be"}, {"sha": "27e9a4b0d8ce11e023432144ab214a6128c7042b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -2734,10 +2734,22 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  if (TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n \t    {\n \t      tree name = DECL_NAME (x);\n-\t      tree icv = name ? IDENTIFIER_CLASS_VALUE (name) : NULL_TREE;\n+\t      tree icv;\n \n-\t      /* Don't complain about constructors.  */\n-\t      if (icv && name != constructor_name (current_class_type))\n+\t      /* Don't get confused by access decls.  */\n+\t      if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t\ticv = IDENTIFIER_CLASS_VALUE (name);\n+\t      else\n+\t\ticv = NULL_TREE;\n+\n+\t      if (icv\n+\t\t  /* Don't complain about constructors.  */\n+\t\t  && name != constructor_name (current_class_type)\n+\t\t  /* Or inherited names.  */\n+\t\t  && id_in_current_class (name)\n+\t\t  /* Or shadowed tags.  */\n+\t\t  && !(TREE_CODE (icv) == TYPE_DECL\n+\t\t       && DECL_CONTEXT (icv) == t))\n \t\t{\n \t\t  cp_error_at (\"declaration of identifier `%D' as `%+#D'\",\n \t\t\t       name, x);"}, {"sha": "5d7cfa763d799a519da7394debbd8f0975758d7a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -321,6 +321,9 @@ enum languages { lang_c, lang_cplusplus };\n #define TYPE_ASSEMBLER_NAME_STRING(NODE) (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME  (NODE))))\n #define TYPE_ASSEMBLER_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n \n+/* The _DECL for this _TYPE.  */\n+#define TYPE_MAIN_DECL(NODE) (TYPE_NAME (NODE))\n+\n #define IS_AGGR_TYPE(t)\t\t(TYPE_LANG_FLAG_5 (t))\n #define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE || t == UNINSTANTIATED_P_TYPE)\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n@@ -1723,6 +1726,24 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define LOOKUP_NO_CONVERSION (512)\n #define LOOKUP_DESTRUCTOR (512)\n \n+/* These flags are used by the conversion code.\n+   CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n+   CONV_STATIC     :  Perform the explicit conversions for static_cast.\n+   CONV_CONST      :  Perform the explicit conversions for const_cast.\n+   CONV_REINTERPRET:  Perform the explicit conversions for reinterpret_cast.\n+   CONV_PRIVATE    :  Perform upcasts to private bases.  */\n+\n+#define CONV_IMPLICIT    1\n+#define CONV_STATIC      2\n+#define CONV_CONST       4\n+#define CONV_REINTERPRET 8\n+#define CONV_PRIVATE\t 16\n+#define CONV_STATIC_CAST (CONV_IMPLICIT | CONV_STATIC)\n+#define CONV_OLD_CONVERT (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n+\t\t\t  | CONV_REINTERPRET)\n+#define CONV_C_CAST      (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n+\t\t\t  | CONV_REINTERPRET | CONV_PRIVATE)\n+\n /* Anatomy of a DECL_FRIENDLIST (which is a TREE_LIST):\n    purpose = friend name (IDENTIFIER_NODE);\n    value = TREE_LIST of FUNCTION_DECLS;\n@@ -1790,7 +1811,7 @@ extern void print_class_statistics\t\tPROTO((void));\n extern void maybe_push_cache_obstack\t\tPROTO((void));\n \n /* in cvt.c */\n-extern tree convert_to_reference\t\tPROTO((tree, tree, tree, tree, int, char *, int, int));\n+extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n extern tree convert_from_reference\t\tPROTO((tree));\n extern tree convert_to_aggr\t\t\tPROTO((tree, tree, char **, int));\n extern tree convert_pointer_to\t\t\tPROTO((tree, tree));"}, {"sha": "d614c70dbb8f2f2828a107e5a7c04a420e274afe", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 71, "deletions": 102, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -594,40 +594,29 @@ build_up_reference (type, arg, flags, checkconst)\n /* For C++: Only need to do one-level references, but cannot\n    get tripped up on signed/unsigned differences.\n \n-   If DECL is NULL_TREE it means convert as though casting (by force).\n-   If it is ERROR_MARK_NODE, it means the conversion is implicit,\n-   and that temporaries may be created.\n-   Make sure the use of user-defined conversion operators is un-ambiguous.\n-   Otherwise, DECL is a _DECL node which can be used in error reporting.\n+   DECL is either NULL_TREE or the _DECL node for a reference that is being\n+   initialized.  It can be error_mark_node if we don't know the _DECL but\n+   we know it's an initialization.  */\n \n-   FNDECL, PARMNUM, and ERRTYPE are only used when checking for use of\n-   volatile or const references where they aren't desired.  */\n+tree cp_convert PROTO((tree, tree, int, int));\n \n tree\n-convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n-\t\t      errtype, strict, flags)\n-     tree decl;\n+convert_to_reference (reftype, expr, convtype, flags, decl)\n      tree reftype, expr;\n-     tree fndecl;\n-     int parmnum;\n-     char *errtype;\n-     int strict, flags;\n+     int convtype, flags;\n+     tree decl;\n {\n   register tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n   register tree intype = TREE_TYPE (expr);\n   register enum tree_code form = TREE_CODE (intype);\n   tree rval = NULL_TREE;\n \n-#if 0\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    type = build_pointer_type (TREE_TYPE (type));\n-#endif\n-  \n   if (form == REFERENCE_TYPE)\n     intype = TREE_TYPE (intype);\n   intype = TYPE_MAIN_VARIANT (intype);\n \n   if (IS_AGGR_TYPE (intype)\n+      && ! (flags & LOOKUP_NO_CONVERSION)\n       && (rval = build_type_conversion (CONVERT_EXPR, reftype, expr, 1)))\n     {\n       if (rval == error_mark_node)\n@@ -636,16 +625,11 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n       return rval;\n     }\n \n-  if (comptypes (type, intype, strict))\n+  if (((convtype & CONV_STATIC) && comptypes (type, intype, -1))\n+      || ((convtype & CONV_IMPLICIT) && comptypes (type, intype, 0)))\n     {\n-      /* Section 13.  */\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n-\t  /* Since convert_for_initialization didn't call\n-\t     convert_for_assignment, we have to do this checking here.\n-\t     FIXME: We should have a common routine between here and\n-\t     convert_for_assignment.  */\n-\n \t  tree ttl = TREE_TYPE (reftype);\n \t  tree ttr;\n \t  \n@@ -654,37 +638,25 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t  else\n \t    ttr = TREE_TYPE (expr);\n \n-\t  if (! TYPE_READONLY (ttl))\n+\t  if (! lvalue_p (expr) &&\n+\t      (decl == NULL_TREE || ! TYPE_READONLY (ttl)))\n \t    {\n-\t      if (TYPE_READONLY (ttr) && decl != NULL_TREE)\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n-\t\t\t\tTREE_TYPE (expr), parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n-\t\t\t\terrtype, reftype, TREE_TYPE (expr));\n-\t\t}\n-\t      else if (! lvalue_p (expr))\n-\t\t{\n-\t\t  /* Ensure semantics of 8.4.3 */\n-\t\t  if (fndecl)\n-\t\t    cp_pedwarn (\"ANSI C++ forbids passing non-lvalue `%T' as argument %P of `%D' into non-const &\",\n-\t\t\t\tTREE_TYPE (expr), parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_pedwarn (\"ANSI C++ forbids %s to `%T' from non-lvalue `%T'\",\n-\t\t\t\terrtype, reftype, TREE_TYPE (expr));\n-\t\t}\n+\t      if (decl)\n+\t\t/* Ensure semantics of [dcl.init.ref] */\n+\t\tcp_pedwarn (\"initialization of non-const `%T' from rvalue `%T'\",\n+\t\t\t    reftype, intype);\n+\t      else\n+\t\tcp_pedwarn (\"conversion to `%T' from rvalue `%T'\",\n+\t\t\t    reftype, intype);\n \t    }\n-\t  else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr)\n-\t\t   && decl != NULL_TREE)\n+\t  else if (! (convtype & CONV_CONST))\n \t    {\n-\t      if (fndecl)\n-\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n-\t\t\t    TREE_TYPE (expr), parmnum, fndecl);\n-\t      else\n-\t\tcp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n-\t\t\t    errtype, reftype, TREE_TYPE (expr));\n+\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t\tcp_pedwarn (\"conversion from `%T' to `%T' discards const\",\n+\t\t\t    TREE_TYPE (expr), reftype);\n+\t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t\tcp_pedwarn (\"conversion from `%T' to `%T' discards volatile\",\n+\t\t\t    TREE_TYPE (expr), reftype);\n \t    }\n \t}\n       \n@@ -718,15 +690,17 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t  rval = build1 (NOP_EXPR,\n \t\t\t build_pointer_type (TREE_TYPE (TREE_TYPE (expr))),\n \t\t\t expr);\n-\t  rval = convert (build_pointer_type (TREE_TYPE (reftype)), rval);\n+\t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), rval,\n+\t\t\t     convtype, flags);\n \t  rval = build1 (NOP_EXPR, reftype, rval);\n \t  return rval;\n \t}\n \n-      return build_up_reference (reftype, expr, flags, decl!=NULL_TREE);\n+      return build_up_reference (reftype, expr, flags,\n+\t\t\t\t ! (convtype & CONV_CONST));\n     }\n \n-  if (decl == NULL_TREE && lvalue_p (expr))\n+  if ((convtype & CONV_REINTERPRET) && lvalue_p (expr))\n     {\n       /* When casting an lvalue to a reference type, just convert into\n \t a pointer to the new type and deference it.  This is allowed\n@@ -736,7 +710,7 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n       /* B* bp; A& ar = (A&)bp; is legal, but it's probably not what they\n          meant.  */\n       if (form == POINTER_TYPE\n-\t  && (comptypes (TREE_TYPE (intype), type, strict)))\n+\t  && (comptypes (TREE_TYPE (intype), type, -1)))\n \tcp_warning (\"casting `%T' to `%T' does not dereference pointer\",\n \t\t    intype, reftype);\n \t  \n@@ -746,7 +720,7 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n       if (rval != error_mark_node)\n \trval = build1 (NOP_EXPR, reftype, rval);\n     }\n-  else if (decl == error_mark_node || decl == NULL_TREE)\n+  else if (decl)\n     {\n       tree rval_as_conversion = NULL_TREE;\n       tree rval_as_ctor = NULL_TREE;\n@@ -773,23 +747,25 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t  if (global_bindings_p ())\n \t    {\n \t      extern tree static_aggregates;\n-\t      decl = get_temp_name (type, global_bindings_p ());\n-\t      init = build_method_call (decl, constructor_name_full (type),\n+\t      tree t = get_temp_name (type, global_bindings_p ());\n+\t      init = build_method_call (t, constructor_name_full (type),\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n-\t\t\t\t\tTYPE_BINFO (type), LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\t\t\t\t\tTYPE_BINFO (type),\n+\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n \n \t      if (init == error_mark_node)\n \t\treturn error_mark_node;\n \n-\t      make_decl_rtl (decl, NULL_PTR, 1);\n-\t      static_aggregates = perm_tree_cons (expr, decl, static_aggregates);\n-\t      rval = build_unary_op (ADDR_EXPR, decl, 0);\n+\t      make_decl_rtl (t, NULL_PTR, 1);\n+\t      static_aggregates = perm_tree_cons (expr, t, static_aggregates);\n+\t      rval = build_unary_op (ADDR_EXPR, t, 0);\n \t    }\n \t  else\n \t    {\n \t      init = build_method_call (NULL_TREE, constructor_name_full (type),\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n-\t\t\t\t\tTYPE_BINFO (type), LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\t\t\t\t\tTYPE_BINFO (type),\n+\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n \n \t      if (init == error_mark_node)\n \t\treturn error_mark_node;\n@@ -820,8 +796,8 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n \t}\n \n       if (rval && ! TYPE_READONLY (TREE_TYPE (reftype)))\n-\tcp_pedwarn (\"converting `%T' to non-const `%T' will use a temporary\",\n-\t\t    intype, reftype);\n+\tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n+\t\t    reftype, intype);\n     }\n \n   if (rval)\n@@ -1219,41 +1195,27 @@ convert_pointer_to_vbase (binfo, expr)\n   return NULL_TREE;\n }\n \f\n-/* Create an expression whose value is that of EXPR,\n-   converted to type TYPE.  The TREE_TYPE of the value\n-   is always TYPE.  This function implements all reasonable\n-   conversions; callers should filter out those that are\n-   not permitted by the language being compiled.  */\n-\n tree\n-convert (type, expr)\n+cp_convert (type, expr, convtype, flags)\n      tree type, expr;\n+     int convtype, flags;\n {\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n \n   if (type == TREE_TYPE (expr)\n       || TREE_CODE (expr) == ERROR_MARK)\n     return expr;\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold (build1 (NOP_EXPR, type, expr));\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return error_mark_node;\n-  if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n-    {\n-      error (\"void value not ignored as it ought to be\");\n-      return error_mark_node;\n-    }\n-  if (code == VOID_TYPE)\n-    {\n-      /* We're converting to a void type; see if they have an\n-\t `operator void'.  */\n-      tree rval = build_type_conversion (NOP_EXPR, type, e, 0);\n-      /* If we can convert to void type via a type conversion, do so.  */\n-      if (rval)\n-\treturn rval;\n-      return build1 (CONVERT_EXPR, type, e);\n-    }\n+\n+  /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n+    return fold (build1 (NOP_EXPR, type, expr));\n+  \n+  if (code == VOID_TYPE && (convtype & CONV_STATIC))\n+    return build1 (CONVERT_EXPR, type, e);\n+\n #if 0\n   /* This is incorrect.  A truncation can't be stripped this way.\n      Extensions will be stripped by the use of get_unwidened.  */\n@@ -1268,10 +1230,8 @@ convert (type, expr)\n       code = TREE_CODE (type);\n     }\n \n-  /* C++ */\n   if (code == REFERENCE_TYPE)\n-    return fold (convert_to_reference (error_mark_node, type, e, NULL_TREE,\n-\t\t\t\t       -1, \"conversion\", -1, LOOKUP_NORMAL));\n+    return fold (convert_to_reference (type, e, convtype, flags, NULL_TREE));\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n@@ -1455,6 +1415,19 @@ convert (type, expr)\n   return error_mark_node;\n }\n \n+/* Create an expression whose value is that of EXPR,\n+   converted to type TYPE.  The TREE_TYPE of the value\n+   is always TYPE.  This function implements all reasonable\n+   conversions; callers should filter out those that are\n+   not permitted by the language being compiled.  */\n+\n+tree\n+convert (type, expr)\n+     tree type, expr;\n+{\n+  return cp_convert (type, expr, CONV_OLD_CONVERT, 0);\n+}\n+\n /* Like convert, except permit conversions to take place which\n    are not normally allowed due to access restrictions\n    (such as conversion from sub-type to private super-type).  */\n@@ -1467,8 +1440,8 @@ convert_force (type, expr)\n   register enum tree_code code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n-    return fold (convert_to_reference (0, type, e, NULL_TREE, -1,\n-\t\t\t\t       \"casting\", -1, LOOKUP_COMPLAIN));\n+    return fold (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,\n+\t\t\t\t       NULL_TREE));\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n@@ -1539,11 +1512,7 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n       && (TREE_READONLY (TREE_TYPE (TREE_TYPE (rval)))\n \t  > TREE_READONLY (TREE_TYPE (xtype))))\n     warning (\"user-defined conversion casting away `const'\");\n-  rval = convert_for_initialization (NULL_TREE, xtype, rval, flags,\n-\t\t\t\t     \"conversion\", NULL_TREE, 0);\n-  if (rval == error_mark_node)\n-    return NULL_TREE;\n-  return rval;\n+  return convert (xtype, rval);\n }\n \n /* Convert an aggregate EXPR to type XTYPE.  If a conversion"}, {"sha": "1c9905f7b3638c62ed6df0bd088dee16c6dda484", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -47,6 +47,8 @@ extern struct obstack permanent_obstack;\n \n extern int current_class_depth;\n \n+extern tree cleanups_this_call;\n+\n /* Stack of places to restore the search obstack back to.  */\n    \n /* Obstack used for remembering local class declarations (like\n@@ -1077,7 +1079,7 @@ poplevel (keep, reverse, functionbody)\n     }\n \n   /* Take care of compiler's internal binding structures.  */\n-  if (tmp == 2 && class_binding_level)\n+  if (tmp == 2)\n     {\n #if 0\n       /* We did not call push_momentary for this\n@@ -1976,7 +1978,7 @@ decls_match (newdecl, olddecl)\n \t      TREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n \t    }\n \t  else\n-\t    types_match = compparms (p1, p2, 1);\n+\t    types_match = compparms (p1, p2, 3);\n \t}\n       else\n \ttypes_match = 0;\n@@ -2114,31 +2116,44 @@ duplicate_decls (newdecl, olddecl)\n        after implicit decl.  */\n     ;\n   else if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t   && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl))\n-\t   && DECL_ASSEMBLER_NAME (newdecl) == DECL_ASSEMBLER_NAME (olddecl))\n-    /* Redeclaring a builtin as another function is handled in\n-       push_overloaded_decl.  */\n+\t   && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl)))\n     {\n       /* If you declare a built-in or predefined function name as static,\n-\t the old definition is overridden,\n-\t but optionally warn this was a bad choice of name.  */\n-      if (! TREE_PUBLIC (newdecl))\n-\tif (warn_shadow)\n-\t  cp_warning (\"shadowing %s function `%#D'\",\n-\t\t      DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n-\t\t      newdecl);\n-      /* Likewise, if the built-in is not ansi, then programs can override\n-         it even globally without an error.  */\n-      else if (! DECL_BUILT_IN (olddecl))\n-\tcp_warning (\"library function `%#D' redeclared as non-function `%#D'\",\n-\t\t    olddecl, newdecl);\n-      else\n+\t the old definition is overridden, but optionally warn this was a\n+\t bad choice of name.  Ditto for overloads.  */\n+      if (! TREE_PUBLIC (newdecl)\n+\t  || (TREE_CODE (newdecl) == FUNCTION_DECL\n+\t      && DECL_LANGUAGE (newdecl) != DECL_LANGUAGE (olddecl)))\n+\t{\n+\t  if (warn_shadow)\n+\t    cp_warning (\"shadowing %s function `%#D'\",\n+\t\t\tDECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n+\t\t\tolddecl);\n+\t  /* Discard the old built-in function.  */\n+\t  return 0;\n+\t}\n+      else if (! types_match)\n \t{\n+\t  if (TREE_CODE (newdecl) != FUNCTION_DECL)\n+\t    {\n+\t      /* If the built-in is not ansi, then programs can override\n+\t\t it even globally without an error.  */\n+\t      if (! DECL_BUILT_IN (olddecl))\n+\t\tcp_warning (\"library function `%#D' redeclared as non-function `%#D'\",\n+\t\t\t    olddecl, newdecl);\n+\t      else\n+\t\t{\n+\t\t  cp_error (\"declaration of `%#D'\", newdecl);\n+\t\t  cp_error (\"conflicts with built-in declaration `%#D'\",\n+\t\t\t    olddecl);\n+\t\t}\n+\t      return 0;\n+\t    }\n+\n \t  cp_warning (\"declaration of `%#D'\", newdecl);\n \t  cp_warning (\"conflicts with built-in declaration `%#D'\",\n \t\t      olddecl);\n \t}\n-      return 0;\n     }\n   else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n     {\n@@ -2185,7 +2200,7 @@ duplicate_decls (newdecl, olddecl)\n \t}\n \n       /* Already complained about this, so don't do so again.  */\n-      if (current_class_type == NULL_TREE\n+      else if (current_class_type == NULL_TREE\n \t  || IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (newdecl)) != current_class_type)\n \t{\n \t  /* Since we're doing this before finish_struct can set the\n@@ -3082,7 +3097,12 @@ pushdecl_class_level (x)\n \t     members are checked in finish_struct.  */\n \t  tree icv = IDENTIFIER_CLASS_VALUE (name);\n \n-\t  if (icv)\n+\t  if (icv\n+\t      /* Don't complain about inherited names.  */\n+\t      && id_in_current_class (name)\n+\t      /* Or shadowed tags.  */\n+\t      && !(TREE_CODE (icv) == TYPE_DECL\n+\t\t   && DECL_CONTEXT (icv) == current_class_type))\n \t    {\n \t      cp_error (\"declaration of identifier `%D' as `%#D'\", name, x);\n \t      cp_error_at (\"conflicts with previous use in class as `%#D'\",\n@@ -3186,23 +3206,18 @@ push_overloaded_decl (decl, forgettable)\n     {\n       old = IDENTIFIER_GLOBAL_VALUE (orig_name);\n       if (old && TREE_CODE (old) == FUNCTION_DECL\n+\t  && DECL_ARTIFICIAL (old)\n \t  && (DECL_BUILT_IN (old) || DECL_BUILT_IN_NONANSI (old)))\n \t{\n-\t  if (! decls_match (decl, old)\n-\t      && (DECL_LANGUAGE (decl) == lang_c\n-\t\t  || compparms (TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (old)), 2)))\n-\t    {\n-\t      cp_warning (\"declaration of `%#D'\", decl);\n-\t      cp_warning (\"conflicts with built-in declaration `%#D'\", old);\n-\t    }\n+\t  if (duplicate_decls (decl, old))\n+\t    return old;\n \t  old = NULL_TREE;\n \t}\n     }\n   else\n     {\n       old = IDENTIFIER_LOCAL_VALUE (orig_name);\n-      \n+\n       if (! purpose_member (orig_name, current_binding_level->shadowed))\n \t{\n \t  current_binding_level->shadowed\n@@ -3355,6 +3370,18 @@ redeclaration_error_message (newdecl, olddecl)\n \t  else\n \t    return \"redefinition of `%#D'\";\n \t}\n+\n+      {\n+\ttree t1 = TYPE_ARG_TYPES (TREE_TYPE (olddecl));\n+\ttree t2 = TYPE_ARG_TYPES (TREE_TYPE (newdecl));\n+\n+\tif (TREE_CODE (TREE_TYPE (newdecl)) == METHOD_TYPE)\n+\t  t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2);\n+\t\n+\tfor (; t1; t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n+\t  if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n+\t    return \"duplicate default arguments given for `%#D'\";\n+      }\n       return 0;\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n@@ -3990,9 +4017,19 @@ lookup_name_current_level (name)\n     }\n   else if (IDENTIFIER_LOCAL_VALUE (name) != NULL_TREE)\n     {\n-      for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n-\tif (DECL_NAME (t) == name)\n-\t  break;\n+      struct binding_level *b = current_binding_level;\n+      while (1)\n+\t{\n+\t  for (t = b->names; t; t = TREE_CHAIN (t))\n+\t    if (DECL_NAME (t) == name)\n+\t      goto out;\n+\t  if (b->keep == 2)\n+\t    b = b->level_chain;\n+\t  else\n+\t    break;\n+\t}\n+    out:\n+      ;\n     }\n \n   return t;\n@@ -5559,25 +5596,14 @@ grok_reference_init (decl, type, init, cleanupp)\n     }\n   /* OK, can we generate a reference then?  */\n   else if ((actual_init = convert_to_reference\n-\t    (decl, type, init, 0, 0, \"initialization\", 0,\n-\t     LOOKUP_SPECULATIVELY|LOOKUP_NORMAL)))\n+\t    (type, init, CONV_IMPLICIT,\n+\t     LOOKUP_SPECULATIVELY|LOOKUP_NORMAL, decl)))\n     {\n       if (actual_init == error_mark_node)\n \tgoto fail;\n \n       init = actual_init;\n       is_reference = 1;\n-    }\n-  /* OK, try going through a temporary.  */\n-  else if ((actual_init = convert_to_reference\n-\t    (error_mark_node, type, init, 0, 0, \"initialization\",\n-\t     0, LOOKUP_NORMAL)))\n-    {\n-      if (actual_init == error_mark_node)\n-\tgoto fail;\n-      \n-      init = actual_init;\n-      is_reference = 1;\n \n       if (TREE_CODE (init) == WITH_CLEANUP_EXPR)\n \t{\n@@ -5705,12 +5731,9 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n       return;\n     }\n \n+  /* If a name was specified, get the string.  */\n   if (asmspec_tree)\n-    {\n       asmspec = TREE_STRING_POINTER (asmspec_tree);\n-      /* Zero out old RTL, since we will rewrite it.  */\n-      DECL_RTL (decl) = NULL_RTX;\n-    }\n \n   /* If the type of the thing we are declaring either has\n      a constructor, or has a virtual function table pointer,\n@@ -6276,6 +6299,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t}\n       else if (! toplev)\n \t{\n+\t  tree old_cleanups = cleanups_this_call;\n \t  /* This is a declared decl which must live until the\n \t     end of the binding contour.  It may need a cleanup.  */\n \n@@ -6335,6 +6359,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\t\t      decl);\n \t\t}\n \t    }\n+\t  /* Cleanup any temporaries needed for the initial value.  */\n+\t  expand_cleanups_to (old_cleanups);\n \t}\n     finish_end0:\n \n@@ -6404,6 +6430,8 @@ expand_static_init (decl, init)\n      tree init;\n {\n   tree oldstatic = value_member (decl, static_aggregates);\n+  tree old_cleanups;\n+\n   if (oldstatic)\n     {\n       if (TREE_PURPOSE (oldstatic) && init != NULL_TREE)\n@@ -6422,6 +6450,7 @@ expand_static_init (decl, init)\n       rest_of_decl_compilation (temp, NULL_PTR, 0, 0);\n       expand_start_cond (build_binary_op (EQ_EXPR, temp,\n \t\t\t\t\t  integer_zero_node, 1), 0);\n+      old_cleanups = cleanups_this_call;\n       expand_assignment (temp, integer_one_node, 0, 0);\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n \t{\n@@ -6430,6 +6459,8 @@ expand_static_init (decl, init)\n \t}\n       else\n \texpand_assignment (decl, init, 0, 0);\n+      /* Cleanup any temporaries needed for the initial value.  */\n+      expand_cleanups_to (old_cleanups);\n       expand_end_cond ();\n       if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n \t{\n@@ -10235,6 +10266,7 @@ finish_enum (enumtype, values)\n \t  else if (value < minvalue)\n \t    minvalue = value;\n \t  TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n+\t  TREE_TYPE (DECL_INITIAL (TREE_VALUE (pair))) = enumtype;\n \t}\n     }\n \n@@ -11968,3 +12000,10 @@ revert_static_member_fn (decl, fn, argtypes)\n   if (argtypes)\n     *argtypes = args;\n }\n+\n+int\n+id_in_current_class (id)\n+     tree id;\n+{\n+  return !!purpose_member (id, class_binding_level->class_shadowed);\n+}"}, {"sha": "c5ab8dbd7fc95d3fb199a32c7f18ff2791741a27", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -37,6 +37,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n extern tree grokdeclarator ();\n extern tree get_file_function_name ();\n+extern tree cleanups_this_call;\n static void grok_function_init ();\n \n /* A list of virtual function tables we must make sure to write out.  */\n@@ -362,6 +363,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n+  {\"short-temps\", &flag_short_temps, 1},\n };\n \n /* Decode the string P as a language-specific option.\n@@ -2595,6 +2597,7 @@ finish_file ()\n \t{\n \t  tree decl = TREE_VALUE (vars);\n \t  tree init = TREE_PURPOSE (vars);\n+\t  tree old_cleanups = cleanups_this_call;\n \n \t  /* If this was a static attribute within some function's scope,\n \t     then don't initialize it here.  Also, don't bother\n@@ -2684,6 +2687,8 @@ finish_file ()\n \t    ;\n \t  else my_friendly_abort (22);\n \t  vars = TREE_CHAIN (vars);\n+\t  /* Cleanup any temporaries needed for the initial value.  */\n+\t  expand_cleanups_to (old_cleanups);\n \t}\n \n       expand_end_bindings (getdecls(), 1, 0);\n@@ -2936,7 +2941,7 @@ finish_decl_parsing (decl)\n       TREE_OPERAND (decl, 0) = finish_decl_parsing (TREE_OPERAND (decl, 0));\n       return decl;\n     case SCOPE_REF:\n-      push_nested_class (TREE_OPERAND (decl, 0), 3);\n+      push_nested_class (TREE_TYPE (TREE_OPERAND (decl, 0)), 3);\n       TREE_COMPLEXITY (decl) = current_class_depth;\n       return decl;\n     case ARRAY_REF:"}, {"sha": "160a10b19b344d2d0637828d8c1273c8d84747d9", "filename": "gcc/cp/except.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -35,11 +35,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n tree builtin_return_address_fndecl;\n \n /* Define at your own risk!  */\n+#ifndef CROSS_COMPILE\n #ifdef sun\n #ifdef sparc\n #define TRY_NEW_EH\n #endif\n #endif\n+#endif\n \n #ifndef TRY_NEW_EH\n \n@@ -97,8 +99,8 @@ expand_end_all_catch ()\n }\n \n void\n-expand_start_catch_block (typename, identifier)\n-     tree typename, identifier;\n+expand_start_catch_block (declspecs, declarator)\n+     tree declspecs, declarator;\n {\n }\n \n@@ -409,7 +411,6 @@ exception_section ()\n \n extern rtx emit_insn\t\tPROTO((rtx));\n extern rtx gen_nop\t\tPROTO(());\n-extern void do_unwind\t\tPROTO((rtx));\n \n /* local globals for function calls\n    ====================================================================== */\n@@ -808,7 +809,7 @@ init_exception_processing ()\n   catch_match_fndecl =\n     define_function (\"__throw_type_match\",\n \t\t     build_function_type (integer_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, string_type_node, tree_cons (NULL_TREE, string_type_node, void_list_node))),\n+\t\t\t\t\t  tree_cons (NULL_TREE, string_type_node, tree_cons (NULL_TREE, ptr_type_node, void_list_node))),\n \t\t     NOT_BUILT_IN,\n \t\t     pushdecl,\n \t\t     0);\n@@ -1088,24 +1089,27 @@ expand_leftover_cleanups ()\n     }\n }\n \n-\n /* call this to start a catch block. Typename is the typename, and identifier\n    is the variable to place the object in or NULL if the variable doesn't\n    matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n    everything.  In that case we don't need to do any type checking.\n    (ie: it ends up as the \"else\" clause rather than an \"else if\" clause) */\n void\n-expand_start_catch_block (typename, identifier)\n-     tree typename, identifier;\n+expand_start_catch_block (declspecs, declarator)\n+     tree declspecs, declarator;\n {\n   rtx false_label_rtx;\n   tree type;\n+  tree decl;\n \n   if (! doing_eh (1))\n     return;\n \n-  if (typename)\n-    type = groktypename (typename);\n+  if (declspecs)\n+    {\n+      decl = grokdeclarator (declarator, declspecs, PARM, 0, NULL_TREE);\n+      type = TREE_TYPE (decl);\n+    }\n   else\n     type = NULL_TREE;\n "}, {"sha": "a35853416148f59d1cf93119412dad0ba3d8e929", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -35,6 +35,7 @@ char, TYPESPEC, RID_CHAR,\n class, AGGR, RID_CLASS,\n classof, CLASSOF, NORID,\n const, TYPE_QUAL, RID_CONST,\n+const_cast, CONST_CAST, NORID,\n continue, CONTINUE, NORID,\n default, DEFAULT, NORID,\n delete, DELETE, NORID,\n@@ -61,18 +62,20 @@ private, VISSPEC, RID_PRIVATE,\n protected, VISSPEC, RID_PROTECTED,\n public, VISSPEC, RID_PUBLIC,\n register, SCSPEC, RID_REGISTER,\n+reinterpret_cast, REINTERPRET_CAST, NORID,\n return, RETURN, NORID,\n short, TYPESPEC, RID_SHORT,\n signature, AGGR, RID_SIGNATURE\t/* Extension */,\n signed, TYPESPEC, RID_SIGNED,\n sigof, SIGOF, NORID\t\t/* Extension */,\n sizeof, SIZEOF, NORID,\n static, SCSPEC, RID_STATIC,\n+static_cast, STATIC_CAST, NORID,\n struct, AGGR, RID_RECORD,\n switch, SWITCH, NORID,\n this, THIS, NORID,\n throw, THROW, NORID,\n-template, TEMPLATE, NORID,\n+template, TEMPLATE, RID_TEMPLATE,\n try, TRY, NORID,\n typedef, SCSPEC, RID_TYPEDEF,\n typeof, TYPEOF, NORID,"}, {"sha": "0780d025d326142869d8f716ae1a98f2c06119a6", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 92, "deletions": 78, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -1,14 +1,14 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../devo/gcc/cp/gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ /deneb/blob/jason/g++/small/devo/gcc/cp/gxx.gperf  */\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 80\n+#define TOTAL_KEYWORDS 83\n #define MIN_WORD_LENGTH 2\n-#define MAX_WORD_LENGTH 13\n+#define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 166\n-/* maximum key range = 163, duplicates = 0 */\n+#define MAX_HASH_VALUE 170\n+/* maximum key range = 167, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -20,19 +20,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n-     167, 167, 167, 167, 167,   0, 167,  36,   6,  60,\n-      17,   0,  16,   5,  41,  38, 167,  11,  22,   7,\n-      26,   0,   4, 167,  22,   0,   4,  44,  19,   8,\n-       5,  18, 167, 167, 167, 167, 167, 167,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+     171, 171, 171, 171, 171,   0, 171,  62,   5,  65,\n+      27,   0,  18,   7,  10,  48, 171,   1,  30,   7,\n+      79,   0,  33, 171,  18,   0,   4,  26,  13,   0,\n+       1,  24, 171, 171, 171, 171, 171, 171,\n     };\n   register int hval = len;\n \n@@ -68,103 +68,117 @@ is_reserved_word (str, len)\n       {\"\",}, {\"\",}, \n       {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n       {\"this\",  THIS, NORID,},\n-      {\"goto\",  GOTO, NORID,},\n+      {\"throw\",  THROW, NORID,},\n       {\"__headof__\",  HEADOF, NORID},\n-      {\"\",}, \n+      {\"goto\",  GOTO, NORID,},\n       {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n       {\"__const__\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n       {\"__const\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"throw\",  THROW, NORID,},\n+      {\"\",}, \n       {\"enum\",  ENUM, NORID,},\n-      {\"do\",  DO, NORID,},\n-      {\"template\",  TEMPLATE, NORID,},\n+      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"\",}, {\"\",}, \n       {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n       {\"sizeof\",  SIZEOF, NORID,},\n-      {\"delete\",  DELETE, NORID,},\n+      {\"\",}, \n       {\"__headof\",  HEADOF, NORID},\n-      {\"try\",  TRY, NORID,},\n+      {\"short\",  TYPESPEC, RID_SHORT,},\n       {\"typeof\",  TYPEOF, NORID,},\n-      {\"typeid\",  TYPEID, NORID,},\n+      {\"do\",  DO, NORID,},\n+      {\"\",}, \n+      {\"try\",  TRY, NORID,},\n+      {\"\",}, \n+      {\"delete\",  DELETE, NORID,},\n       {\"__typeof__\",  TYPEOF, NORID},\n+      {\"while\",  WHILE, NORID,},\n+      {\"struct\",  AGGR, RID_RECORD,},\n+      {\"typeid\",  TYPEID, NORID,},\n       {\"double\",  TYPESPEC, RID_DOUBLE,},\n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n-      {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"extern\",  SCSPEC, RID_EXTERN,},\n-      {\"__classof__\",  CLASSOF, NORID},\n+      {\"for\",  FOR, NORID,},\n       {\"\",}, \n-      {\"while\",  WHILE, NORID,},\n+      {\"__classof__\",  CLASSOF, NORID},\n+      {\"\",}, {\"\",}, \n+      {\"operator\",  OPERATOR, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n       {\"long\",  TYPESPEC, RID_LONG,},\n-      {\"new\",  NEW, NORID,},\n-      {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n-      {\"auto\",  SCSPEC, RID_AUTO,},\n-      {\"for\",  FOR, NORID,},\n+      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n       {\"__typeof\",  TYPEOF, NORID},\n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n-      {\"__extension__\",  EXTENSION, NORID},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"\",}, \n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"\",}, \n       {\"int\",  TYPESPEC, RID_INT,},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"\",}, \n       {\"__classof\",  CLASSOF, NORID},\n       {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n-      {\"switch\",  SWITCH, NORID,},\n-      {\"operator\",  OPERATOR, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"headof\",  HEADOF, NORID,},\n+      {\"\",}, \n       {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"struct\",  AGGR, RID_RECORD,},\n+      {\"\",}, \n       {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"\",}, \n       {\"if\",  IF, NORID,},\n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"break\",  BREAK, NORID,},\n-      {\"__alignof__\",  ALIGNOF, NORID},\n-      {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"float\",  TYPESPEC, RID_FLOAT,},\n-      {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n       {\"case\",  CASE, NORID,},\n       {\"class\",  AGGR, RID_CLASS,},\n-      {\"\",}, \n-      {\"__label__\",  LABEL, NORID},\n-      {\"default\",  DEFAULT, NORID,},\n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"break\",  BREAK, NORID,},\n       {\"const\",  TYPE_QUAL, RID_CONST,},\n       {\"static\",  SCSPEC, RID_STATIC,},\n-      {\"\",}, {\"\",}, \n-      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"new\",  NEW, NORID,},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n       {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n-      {\"union\",  AGGR, RID_UNION,},\n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"headof\",  HEADOF, NORID,},\n-      {\"\",}, \n-      {\"inline\",  SCSPEC, RID_INLINE,},\n-      {\"overload\",  OVERLOAD, NORID,},\n-      {\"\",}, \n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"\",}, {\"\",}, \n       {\"register\",  SCSPEC, RID_REGISTER,},\n-      {\"\",}, \n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"__extension__\",  EXTENSION, NORID},\n       {\"\",}, {\"\",}, \n       {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__label__\",  LABEL, NORID},\n+      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"continue\",  CONTINUE, NORID,},\n+      {\"default\",  DEFAULT, NORID,},\n+      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"\",}, {\"\",}, \n-      {\"return\",  RETURN, NORID,},\n       {\"classof\",  CLASSOF, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n-      {\"char\",  TYPESPEC, RID_CHAR,},\n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"\",}, \n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"overload\",  OVERLOAD, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"return\",  RETURN, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n+      {\"__alignof\",  ALIGNOF, NORID},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"const_cast\",  CONST_CAST, NORID,},\n+      {\"catch\",  CATCH, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      \n-      {\"catch\",  CATCH, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"__inline\",  SCSPEC, RID_INLINE},\n+      {\"\",}, \n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"\",}, \n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "6ce92a3d0d4cd02970d74a11c42495d6b1fc805d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -643,7 +643,7 @@ emit_base_init (t, immediately)\n \t  /* member could be, for example, a CONST_DECL for an enumerated\n \t     tag; we don't want to try to initialize that, since it already\n \t     has a value.  */\n-\t  if (TREE_CODE (member) != FIELD_DECL)\n+\t  if (TREE_CODE (member) != FIELD_DECL || !DECL_NAME (member))\n \t    continue;\n \n \t  name = DECL_NAME (member);\n@@ -2087,8 +2087,7 @@ build_offset_ref (cname, name)\n \n   if (t == NULL_TREE)\n     {\n-      cp_error (\"`%D' is not a member of type `%T'\", name,\n-\t\tIDENTIFIER_TYPE_VALUE (cname));\n+      cp_error (\"`%D' is not a member of type `%T'\", name, type);\n       return error_mark_node;\n     }\n \n@@ -2748,7 +2747,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n \n       /* We can call pushdecl here, because the TREE_CHAIN of this\n \t FUNCTION_DECL is not needed for other purposes.  */\n-      decl = pushdecl_top_level (decl);\n+      decl = pushdecl (decl);\n \n       make_decl_rtl (decl, NULL_PTR, 1);\n       add_friend (current_class_type, decl);"}, {"sha": "22cf0a51cd8b2026f269f9d7a247f7638801a2cf", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -662,6 +662,9 @@ init_lex ()\n   ridpointers[(int) RID_PROTECTED] = get_identifier (\"protected\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_PROTECTED],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_PROTECTED]));\n+  ridpointers[(int) RID_TEMPLATE] = get_identifier (\"template\");\n+  SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_TEMPLATE],\n+\t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_TEMPLATE]));\n   /* This is for ANSI C++. */\n   ridpointers[(int) RID_MUTABLE] = get_identifier (\"mutable\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_MUTABLE],"}, {"sha": "f9bf3f1aea3d216458492f5f21fd1cf1e467fc0b", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -65,6 +65,7 @@ enum rid\n   RID_RAISES,\n   RID_AUTO,\n   RID_MUTABLE,\n+  RID_TEMPLATE,\n   RID_SIGNATURE,\n   /* Before adding enough to get up to 64, the RIDBIT_* macros\n      will have to be changed a little. */"}, {"sha": "dd8a96ab5c6fbdc272d7c538be96d54366b6508b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 53, "deletions": 62, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -80,8 +80,6 @@ void yyerror ();\n    error message if the user supplies an empty conditional expression.  */\n static char *cond_stmt_keyword;\n \n-static int doing_explicit;\n-\n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n int used_extern_spec;\n@@ -153,7 +151,7 @@ empty_parms ()\n %token <itype> VISSPEC\n %token DELETE NEW OVERLOAD THIS OPERATOR\n %token LEFT_RIGHT TEMPLATE\n-%token TYPEID DYNAMIC_CAST\n+%token TYPEID DYNAMIC_CAST STATIC_CAST REINTERPRET_CAST CONST_CAST\n %token <itype> SCOPE\n \n /* Define the operator tokens and their precedences.\n@@ -197,7 +195,7 @@ empty_parms ()\n %type <code> unop\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n-%type <ttype> optional_identifier paren_expr_or_null nontrivial_exprlist\n+%type <ttype> paren_expr_or_null nontrivial_exprlist\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n %type <ttype> typed_declspecs reserved_declspecs\n %type <ttype> typed_typespecs reserved_typespecquals\n@@ -242,7 +240,7 @@ empty_parms ()\n %type <ttype> class_head base_class_list\n %type <itype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n-%type <ttype> maybe_raises raise_identifier raise_identifiers ansi_raise_identifier ansi_raise_identifiers\n+%type <ttype> maybe_raises ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> component_declarator0\n %type <ttype> forhead.1 operator_name\n %type <ttype> object aggr\n@@ -261,7 +259,7 @@ empty_parms ()\n %type <ttype> qualified_type_name complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n-%type <ttype> new_initializer new_placement specialization\n+%type <ttype> new_initializer new_placement specialization type_specifier_seq\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n@@ -538,7 +536,6 @@ datadef:\n         | declmods ';'\n \t  { pedwarn (\"empty declaration\"); }\n \t| explicit_instantiation ';'\n-\t\t{ doing_explicit = 0; }\n \t| typed_declspecs ';'\n \t  {\n \t    tree t = $<ttype>$;\n@@ -775,16 +772,11 @@ identifier_defn:\n \t| PTYPENAME_DEFN\n \t;\n \n-do_explicit: TEMPLATE %prec EMPTY\n-\t{ doing_explicit = 1; }\n-\t;\n-\n explicit_instantiation:\n-\t  do_explicit specialization template_instantiation\n+\t  TEMPLATE specialization template_instantiation\n \t\t{ do_type_instantiation ($3 ? $3 : $2); }\n-\t| do_explicit typed_declspecs declarator\n+\t| TEMPLATE typed_declspecs declarator\n \t\t{ do_function_instantiation ($2, $3); }\n-\t| do_explicit error\n \t;\n \n template_type:\n@@ -925,7 +917,7 @@ xcond:\n \t;\n \n condition:\n-\ttyped_typespecs declarator maybe_raises maybeasm maybe_attribute '='\n+\ttype_specifier_seq declarator maybe_raises maybeasm maybe_attribute '='\n \t\t{ {\n \t\t  tree d;\n \t\t  for (d = getdecls (); d; d = TREE_CHAIN (d))\n@@ -953,6 +945,17 @@ condition:\n \t| expr\n \t;\n \n+already_scoped_stmt:\n+\t  '{' '}'\n+\t\t{ finish_stmt (); }\n+\t| '{' maybe_label_decls stmts '}'\n+\t\t{ finish_stmt (); }\n+\t| '{' maybe_label_decls error '}'\n+\t\t{ finish_stmt (); }\n+\t| simple_stmt\n+\t;\n+\n+\n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n \t\t{ $$ = tree_cons (NULL_TREE, $$, \n@@ -1414,10 +1417,18 @@ primary:\n \t\t    }\n \t\t}\n \t| functional_cast\n-\t/* Stroustrup RTTI */\n \t| DYNAMIC_CAST '<' type_id '>' '(' expr ')'\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = build_dynamic_cast (type, $6); }\n+\t| STATIC_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3);\n+\t\t  $$ = build_static_cast (type, $6); }\n+\t| REINTERPRET_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3);\n+\t\t  $$ = build_reinterpret_cast (type, $6); }\n+\t| CONST_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3);\n+\t\t  $$ = build_const_cast (type, $6); }\n \t| TYPEID '(' expr ')'\n \t\t{ $$ = build_typeid ($3); }\n \t| TYPEID '(' type_id ')'\n@@ -2168,8 +2179,8 @@ specialization:\n \t  aggr template_type_name ';'\n \t\t{ \n \t\t  yyungetc (';', 1); current_aggr = $$; $$ = $2; \n-\t\t  if (doing_explicit)\n-\t\t    instantiate_class_template ($$, 1);\n+\t\t  if ($<ttype>0 == ridpointers[(int) RID_TEMPLATE])\n+\t\t    instantiate_class_template ($$, 2);\n \t\t}\n \t;\n \n@@ -2644,13 +2655,9 @@ enumerator:\n \n /* ANSI new-type-id (5.3.4) */\n new_type_id:\n-\t  typed_typespecs new_declarator\n-\t\t{ $$ = build_decl_list ($$, $2); }\n-\t| nonempty_type_quals new_declarator\n+\t  type_specifier_seq new_declarator\n \t\t{ $$ = build_decl_list ($$, $2); }\n-\t| typed_typespecs %prec EMPTY\n-\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n-\t| nonempty_type_quals %prec EMPTY\n+\t| type_specifier_seq %prec EMPTY\n \t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n \t/* GNU extension to allow arrays of arbitrary types with\n \t   non-constant dimension.  */\n@@ -3100,7 +3107,7 @@ simple_stmt:\n \t\t  cond_stmt_keyword = \"while\"; }\n \t  .pushlevel paren_cond_or_null\n \t\t{ expand_exit_loop_if_false (0, truthvalue_conversion ($4)); }\n-\t  implicitly_scoped_stmt\n+\t  already_scoped_stmt\n \t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n@@ -3131,14 +3138,14 @@ simple_stmt:\n \t\t/* Don't let the tree nodes for $7 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n \t\t{ push_momentary (); }\n-\t  implicitly_scoped_stmt\n+\t  already_scoped_stmt\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($7) cplus_expand_expr_stmt ($7);\n-\t\t  pop_momentary ();\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n+\t\t  expand_loop_continue_here ();\n+\t\t  if ($7) cplus_expand_expr_stmt ($7);\n+\t\t  pop_momentary ();\n \t\t  expand_end_loop ();\n \t\t  finish_stmt (); }\n \t| forhead.2\n@@ -3153,14 +3160,14 @@ simple_stmt:\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n \t\t{ push_momentary ();\n \t\t  $<itype>8 = lineno; }\n-\t  implicitly_scoped_stmt\n+\t  already_scoped_stmt\n \t\t{ emit_line_note (input_filename, (int) $<itype>8);\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($7) cplus_expand_expr_stmt ($7);\n-\t\t  pop_momentary ();\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n+\t\t  expand_loop_continue_here ();\n+\t\t  if ($7) cplus_expand_expr_stmt ($7);\n+\t\t  pop_momentary ();\n \t\t  expand_end_loop ();\n \t\t  finish_stmt ();\n \t\t}\n@@ -3422,11 +3429,6 @@ ansi_try_stmts:\n \t\t}\n \t;\n \n-optional_identifier:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| identifier ;\n-\n handler_seq:\n \t  /* empty */\n \t| handler_seq CATCH\n@@ -3435,10 +3437,21 @@ handler_seq:\n \t\t{ expand_end_catch_block (); }\n \t;\n \n+type_specifier_seq:\n+\t  typed_typespecs %prec EMPTY\n+\t| nonempty_type_quals %prec EMPTY\n+\t;\n+\n handler_args:\n \t  '(' ELLIPSIS ')'\n \t\t{ expand_start_catch_block (NULL_TREE, NULL_TREE); }\n-\t| '(' type_id optional_identifier ')'\n+\t| '(' type_specifier_seq absdcl ')'\n+\t\t{ expand_start_catch_block ($2, $3); }\n+\t| '(' type_specifier_seq ')'\n+\t\t{ expand_start_catch_block ($2, NULL_TREE); }\n+\t| '(' type_specifier_seq notype_declarator ')'\n+\t\t{ expand_start_catch_block ($2, $3); }\n+\t| '(' typed_typespecs after_type_declarator ')'\n \t\t{ expand_start_catch_block ($2, $3); }\n \t;\n \n@@ -3704,33 +3717,11 @@ maybe_raises:\n \t\t{ $$ = $3; }\n \t;\n \n-raise_identifier:\n-/*\t  ALL\n-\t\t{ $$ = void_list_node; } */\n-\t  IDENTIFIER\n-\t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n-\t| TYPENAME\n-\t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n-\t| global_scope IDENTIFIER\n-\t\t{ $$ = build_decl_list (NULL_TREE, $2); }\n-\t| global_scope TYPENAME\n-\t\t{ $$ = build_decl_list (NULL_TREE, $2); }\n-\t;\n-\n ansi_raise_identifier:\n \t  type_id\n \t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n \t;\n \n-raise_identifiers:\n-\t  raise_identifier\n-\t| raise_identifiers ',' raise_identifier\n-\t\t{\n-\t\t  TREE_CHAIN ($3) = $$;\n-\t\t  $$ = $3;\n-\t\t}\n-\t;\n-\n ansi_raise_identifiers:\n \t  ansi_raise_identifier\n \t| ansi_raise_identifiers ',' ansi_raise_identifier\n@@ -3825,7 +3816,7 @@ operator_name:\n \t| operator DELETE '[' ']'\n \t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }\n \t/* Names here should be looked up in class scope ALSO.  */\n-\t| operator typed_typespecs conversion_declarator\n+\t| operator type_specifier_seq conversion_declarator\n \t\t{ $$ = grokoptypename ($2, $3); }\n \t| operator error\n \t\t{ $$ = ansi_opname[ERROR_MARK]; }"}, {"sha": "528bbdd34dc1bd0e6e5af48475a2ae4f28cf24e9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -265,12 +265,16 @@ end_template_decl (d1, d2, is_class, defn)\n       && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n     {\n       tree ctx = DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl));\n-      tree tmpl;\n+      tree tmpl, t;\n       my_friendly_assert (TREE_CODE (ctx) == UNINSTANTIATED_P_TYPE, 266);\n       tmpl = UPT_TEMPLATE (ctx);\n+      for (t = DECL_TEMPLATE_MEMBERS (tmpl); t; t = TREE_CHAIN (t))\n+\tif (TREE_PURPOSE (t) == DECL_NAME (decl)\n+\t    && duplicate_decls (decl, TREE_VALUE (t)))\n+\t  goto already_there;\n       DECL_TEMPLATE_MEMBERS (tmpl) =\n-\tperm_tree_cons (DECL_NAME (decl), decl,\n-\t\t\tDECL_TEMPLATE_MEMBERS (tmpl));\n+\tperm_tree_cons (DECL_NAME (decl), decl, DECL_TEMPLATE_MEMBERS (tmpl));\n+    already_there:\n       poplevel (0, 0, 0);\n       poplevel (0, 0, 0);\n     }\n@@ -1459,6 +1463,9 @@ tsubst (t, args, nargs, in_decl)\n \tlayout_type (r);\n \treturn r;\n       }\n+    case OFFSET_TYPE:\n+      return build_offset_type\n+\t(tsubst (TYPE_OFFSET_BASETYPE (t), args, nargs, in_decl), type);\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n@@ -2008,10 +2015,19 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n       if (targs[idx] == arg)\n \treturn 0;\n       else if (targs[idx])\n-\treturn 1;\n+\t{\n+\t  if (TYPE_MAIN_VARIANT (targs[idx]) == TYPE_MAIN_VARIANT (arg))\n+\t    /* allow different parms to have different cv-qualifiers */;\n+\t  else\n+\t    return 1;\n+\t}\n       /* Check for mixed types and values.  */\n       if (TREE_CODE (TREE_VEC_ELT (tparms, idx)) != IDENTIFIER_NODE)\n \treturn 1;\n+      /* Allow trivial conversions.  */\n+      if (TYPE_READONLY (parm) < TYPE_READONLY (arg)\n+\t  || TYPE_VOLATILE (parm) < TYPE_VOLATILE (arg))\n+\treturn 1;\n       targs[idx] = arg;\n       return 0;\n     case TEMPLATE_CONST_PARM:\n@@ -2136,8 +2152,12 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n \t\t      arg, nsubsts);\n \n-      /* Unification of something that is not a template fails. (mrs) */\n-      return 1;\n+      /* Allow trivial conversions.  */\n+      if (TYPE_MAIN_VARIANT (parm) != TYPE_MAIN_VARIANT (arg)\n+\t  || TYPE_READONLY (parm) < TYPE_READONLY (arg)\n+\t  || TYPE_VOLATILE (parm) < TYPE_VOLATILE (arg))\n+\treturn 1;\n+      return 0;\n \n     case METHOD_TYPE:\n       if (TREE_CODE (arg) != METHOD_TYPE)\n@@ -2150,7 +2170,16 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n      check_args:\n       return type_unification (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t       TYPE_ARG_TYPES (arg), nsubsts, 1);\n-\t\t    \n+\n+    case OFFSET_TYPE:\n+      if (TREE_CODE (arg) != OFFSET_TYPE)\n+\treturn 1;\n+      if (unify (tparms, targs, ntparms, TYPE_OFFSET_BASETYPE (parm),\n+\t\t TYPE_OFFSET_BASETYPE (arg), nsubsts))\n+\treturn 1;\n+      return unify (tparms, targs, ntparms, TREE_TYPE (parm),\n+\t\t    TREE_TYPE (arg), nsubsts);\n+\n     default:\n       sorry (\"use of `%s' in template type unification\",\n \t     tree_code_name [(int) TREE_CODE (parm)]);"}, {"sha": "c81f1e1488d01abc91d008f5e904b9629097d294", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -1134,7 +1134,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n       if (errstr && protect)\n \t{\n-\t  error (errstr, IDENTIFIER_POINTER (name), TYPE_NAME_STRING (type));\n+\t  cp_error (errstr, name, type);\n \t  return error_mark_node;\n \t}\n       return rval;"}, {"sha": "d8df8e48df83ed6f80edc6288e7d7b52ae23e02d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -94,9 +94,6 @@ lvalue_p (ref)\n \t  return (lvalue_p (TREE_OPERAND (ref, 1))\n \t\t  && lvalue_p (TREE_OPERAND (ref, 2)));\n \n-\tcase MODIFY_EXPR:\n-\t  return 1;\n-\n \tcase COMPOUND_EXPR:\n \t  return lvalue_p (TREE_OPERAND (ref, 1));\n \t}"}, {"sha": "490d9988f0746b3ec4b728fb73324e2c2cc6be4c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -47,7 +47,6 @@ static tree pointer_int_sum ();\n static tree pointer_diff ();\n static tree convert_sequence ();\n /* static */ tree unary_complex_lvalue ();\n-static void pedantic_lvalue_warning ();\n tree truthvalue_conversion ();\n \n extern rtx original_result_rtx;\n@@ -223,10 +222,7 @@ commonparms (p1, p2)\n \t  if (cmp < 0)\n \t    my_friendly_abort (111);\n \t  if (cmp == 0)\n-\t    {\n-\t      error (\"redeclaration of default argument %d\", i+1);\n-\t      any_change = 1;\n-\t    }\n+\t    any_change = 1;\n \t  TREE_PURPOSE (n) = TREE_PURPOSE (p2);\n \t}\n       if (TREE_VALUE (p1) != TREE_VALUE (p2))\n@@ -411,7 +407,7 @@ common_type (t1, t2)\n       return t1;\n \n     case METHOD_TYPE:\n-      if (TYPE_METHOD_BASETYPE (t1) == TYPE_METHOD_BASETYPE (t2)\n+      if (comptypes (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2), 1)\n \t  && TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n \t{\n \t  /* Get this value the long way, since TYPE_METHOD_BASETYPE\n@@ -642,6 +638,9 @@ comptypes (type1, type2, strict)\n \n     case TEMPLATE_TYPE_PARM:\n       return 1;\n+\n+    case UNINSTANTIATED_P_TYPE:\n+      return UPT_TEMPLATE (t1) == UPT_TEMPLATE (t2);\n     }\n   return 0;\n }\n@@ -1340,9 +1339,10 @@ build_object_ref (datum, basetype, field)\n   else if (is_aggr_typedef (basetype, 1))\n     {\n       tree real_basetype = IDENTIFIER_TYPE_VALUE (basetype);\n-      if (binfo_or_else (real_basetype, TREE_TYPE (datum)))\n+      tree binfo = binfo_or_else (real_basetype, TREE_TYPE (datum));\n+      if (binfo)\n \treturn build_component_ref (build_scoped_ref (datum, basetype),\n-\t\t\t\t    field, NULL_TREE, 1);\n+\t\t\t\t    field, binfo, 1);\n     }\n   return error_mark_node;\n }\n@@ -3006,12 +3006,14 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    ;\n \t  else if (tt0 == void_type_node)\n \t    {\n-\t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE)\n+\t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n+\t\t  && tree_int_cst_lt (TYPE_SIZE (type0), TYPE_SIZE (type1)))\n \t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else if (tt1 == void_type_node)\n \t    {\n-\t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE)\n+\t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE\n+\t\t  && tree_int_cst_lt (TYPE_SIZE (type1), TYPE_SIZE (type0)))\n \t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else if ((TYPE_SIZE (tt0) != 0) != (TYPE_SIZE (tt1) != 0))\n@@ -3457,13 +3459,6 @@ pointer_int_sum (resultcode, ptrop, intop)\n \n   register tree result_type = TREE_TYPE (ptrop);\n \n-  /* Needed to make OOPS V2R3 work.  */\n-  intop = folded;\n-  if (TREE_CODE (intop) == INTEGER_CST\n-      && TREE_INT_CST_LOW (intop) == 0\n-      && TREE_INT_CST_HIGH (intop) == 0)\n-    return ptrop;\n-\n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n@@ -3491,6 +3486,13 @@ pointer_int_sum (resultcode, ptrop, intop)\n   else\n     size_exp = size_in_bytes (TREE_TYPE (result_type));\n \n+  /* Needed to make OOPS V2R3 work.  */\n+  intop = folded;\n+  if (TREE_CODE (intop) == INTEGER_CST\n+      && TREE_INT_CST_LOW (intop) == 0\n+      && TREE_INT_CST_HIGH (intop) == 0)\n+    return ptrop;\n+\n   /* If what we are about to multiply by the size of the elements\n      contains a constant term, apply distributive law\n      and multiply that constant term separately.\n@@ -3882,7 +3884,6 @@ build_unary_op (code, xarg, noconvert)\n \t  case FIX_CEIL_EXPR:\n \t    {\n \t      tree incremented, modify, value;\n-\t      pedantic_lvalue_warning (CONVERT_EXPR);\n \t      arg = stabilize_reference (arg);\n \t      if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t\tvalue = arg;\n@@ -4158,17 +4159,18 @@ unary_complex_lvalue (code, arg)\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n     {\n       tree real_result = build_unary_op (code, TREE_OPERAND (arg, 1), 0);\n-      pedantic_lvalue_warning (COMPOUND_EXPR);\n       return build (COMPOUND_EXPR, TREE_TYPE (real_result),\n \t\t    TREE_OPERAND (arg, 0), real_result);\n     }\n \n   /* Handle (a ? b : c) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COND_EXPR)\n-    {\n-      pedantic_lvalue_warning (COND_EXPR);\n-      return rationalize_conditional_expr (code, arg);\n-    }\n+    return rationalize_conditional_expr (code, arg);\n+\n+  if (TREE_CODE (arg) == MODIFY_EXPR)\n+    return unary_complex_lvalue\n+      (code, build (COMPOUND_EXPR, TREE_TYPE (TREE_OPERAND (arg, 0)),\n+\t\t    arg, TREE_OPERAND (arg, 0)));\n \n   if (code != ADDR_EXPR)\n     return 0;\n@@ -4295,19 +4297,6 @@ unary_complex_lvalue (code, arg)\n   /* Don't let anything else be handled specially.  */\n   return 0;\n }\n-\n-/* If pedantic, warn about improper lvalue.   CODE is either COND_EXPR\n-   COMPOUND_EXPR, or CONVERT_EXPR (for casts).  */\n-\n-static void\n-pedantic_lvalue_warning (code)\n-     enum tree_code code;\n-{\n-  if (pedantic)\n-    pedwarn (\"ANSI C++ forbids use of %s expressions as lvalues\",\n-\t     code == COND_EXPR ? \"conditional\"\n-\t     : code == COMPOUND_EXPR ? \"compound\" : \"cast\");\n-}\n \f\n /* Mark EXP saying that we need to be able to take the\n    address of it; it should not be allocated in a register.\n@@ -4785,6 +4774,24 @@ build_compound_expr (list)\n \t\tbreak_out_cleanups (TREE_VALUE (list)), rest);\n }\n \n+tree build_static_cast (type, expr)\n+   tree type, expr;\n+{\n+  return build_c_cast (type, expr);\n+}\n+\n+tree build_reinterpret_cast (type, expr)\n+   tree type, expr;\n+{\n+  return build_c_cast (type, expr);\n+}\n+\n+tree build_const_cast (type, expr)\n+   tree type, expr;\n+{\n+  return build_c_cast (type, expr);\n+}\n+\n /* Build an expression representing a cast to type TYPE of expression EXPR.  */\n \n tree\n@@ -5294,17 +5301,21 @@ build_modify_expr (lhs, modifycode, rhs)\n \n       /* Handle (a, b) used as an \"lvalue\".  */\n     case COMPOUND_EXPR:\n-      pedantic_lvalue_warning (COMPOUND_EXPR);\n       newrhs = build_modify_expr (TREE_OPERAND (lhs, 1),\n \t\t\t\t  modifycode, rhs);\n       if (TREE_CODE (newrhs) == ERROR_MARK)\n \treturn error_mark_node;\n       return build (COMPOUND_EXPR, lhstype,\n \t\t    TREE_OPERAND (lhs, 0), newrhs);\n \n+    case MODIFY_EXPR:\n+      newrhs = build_modify_expr (TREE_OPERAND (lhs, 0), modifycode, rhs);\n+      if (TREE_CODE (newrhs) == ERROR_MARK)\n+\treturn error_mark_node;\n+      return build (COMPOUND_EXPR, lhstype, lhs, newrhs);\n+\n       /* Handle (a ? b : c) used as an \"lvalue\".  */\n     case COND_EXPR:\n-      pedantic_lvalue_warning (COND_EXPR);\n       rhs = save_expr (rhs);\n       {\n \t/* Produce (a ? (b = rhs) : (c = rhs))\n@@ -5450,7 +5461,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t     convert (lhstype, newrhs)));\n \tif (TREE_CODE (result) == ERROR_MARK)\n \t  return result;\n-\treturn convert (TREE_TYPE (lhs), result);\n+\treturn convert_force (TREE_TYPE (lhs), result);\n       }\n     }\n \n@@ -6559,9 +6570,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n      return here before checking if RHS is of complete type.  */\n      \n   if (codel == REFERENCE_TYPE)\n-    return convert_to_reference ((exp ? exp : error_mark_node),\n-\t\t \t\t type, rhs, fndecl, parmnum, errtype,\n-\t\t\t\t 0, flags);\n+    return convert_to_reference (type, rhs, CONV_IMPLICIT, flags,\n+\t\t\t\t exp ? exp : error_mark_node);\n \n   rhs = require_complete_type (rhs);\n   if (rhs == error_mark_node)"}, {"sha": "858896a4f11a536e56b177add0267fc8f5fe2eab", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4443a085561a653c669edf833f5a1496f246b9b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a4443a085561a653c669edf833f5a1496f246b9b", "patch": "@@ -59,7 +59,7 @@ binfo_or_else (parent_or_type, type)\n {\n   tree binfo;\n   if (TYPE_MAIN_VARIANT (parent_or_type) == TYPE_MAIN_VARIANT (type))\n-    return parent_or_type;\n+    return TYPE_BINFO (parent_or_type);\n   if ((binfo = get_binfo (parent_or_type, TYPE_MAIN_VARIANT (type), 0)))\n     {\n       if (binfo == error_mark_node)\n@@ -738,7 +738,10 @@ digest_init (type, init, tail)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (pedantic && typ1 != char_type_node)\n+\t  if (pedantic\n+\t      && typ1 != char_type_node\n+\t      && typ1 != signed_char_type_node\n+\t      && typ1 != unsigned_char_type_node)\n \t    pedwarn (\"ANSI C++ forbids string initializer except for `char' elements\");\n \t  TREE_TYPE (string) = type;\n \t  if (TYPE_DOMAIN (type) != 0\n@@ -752,7 +755,7 @@ digest_init (type, init, tail)\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n \t      if (size < TREE_STRING_LENGTH (string))\n-\t\twarning (\"initializer-string for array of chars is too long\");\n+\t\tpedwarn (\"initializer-string for array of chars is too long\");\n \t    }\n \t  return string;\n \t}"}]}