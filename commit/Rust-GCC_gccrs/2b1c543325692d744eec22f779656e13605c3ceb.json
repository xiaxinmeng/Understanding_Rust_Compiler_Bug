{"sha": "2b1c543325692d744eec22f779656e13605c3ceb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxYzU0MzMyNTY5MmQ3NDRlZWMyMmY3Nzk2NTZlMTM2MDVjM2NlYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-03-16T08:32:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-03-16T08:32:13Z"}, "message": "final.c (final_scan_insn): Handle NOTE_INSN_CALL_ARG_LOCATION.\n\n\t* final.c (final_scan_insn): Handle NOTE_INSN_CALL_ARG_LOCATION.\n\tCall var_location debug hook even on CALL_INSNs.\n\t(rest_of_clean_state): Don't print NOTE_INSN_CALL_ARG_LOCATION.\n\t* rtl.def (ENTRY_VALUE): New.\n\t* dwarf2out.c: Include cfglayout.h.\n\t(dwarf_stack_op_name, size_of_loc_descr, output_loc_operands,\n\toutput_loc_operands_raw): Handle DW_OP_GNU_entry_value.\n\t(struct call_arg_loc_node): New type.\n\t(call_arg_locations, call_arg_loc_last, block_map, call_site_count,\n\ttail_call_site_count): New variables.\n\t(dwarf_tag_name): Handle DW_TAG_GNU_call_site and\n\tDW_TAG_GNU_call_site_parameter.\n\t(dwarf_attr_name): Handle DW_AT_GNU_call_site_value,\n\tDW_AT_GNU_call_site_data_value, DW_AT_GNU_call_site_target,\n\tDW_AT_GNU_call_site_target_clobbered, DW_AT_GNU_tail_call,\n\tDW_AT_GNU_all_tail_call_sites, DW_AT_GNU_all_call_sites\n\tand DW_AT_GNU_all_source_call_sites.\n\t(mem_loc_descriptor): Handle ENTRY_VALUE.\n\t(add_src_coords_attributes): Don't add enything if\n\tDECL_SOURCE_LOCATION is UNKNOWN_LOCATION.\n\t(dwarf2out_abstract_function): Save and clear call_arg_location,\n\tcall_site_count and tail_call_site_count around dwarf2out_decl call.\n\t(gen_call_site_die): New function.\n\t(gen_subprogram_die): Emit DW_TAG_GNU_call_site DIEs for call sites.\n\t(gen_lexical_block_die, gen_inlined_subroutine_die): Update block_map.\n\t(dwarf2out_function_decl): Clear call_arg_locations,\n\tcall_arg_loc_last, set call_site_count and tail_call_site_count\n\tto -1 and free block_map.\n\t(dwarf2out_var_location): Handle NOTE_INSN_CALL_ARG_LOCATION and\n\tCALL_INSNs.  Add NOTE_DURING_CALL_P var location notes even when not\n\tfollowed by any real instructions.\n\t(dwarf2out_begin_function): Set call_site_count and\n\ttail_call_site_count to 0.\n\t(resolve_addr): If DW_AT_abstract_origin of DW_TAG_GNU_call_site\n\tis dw_val_class_addr, attempt to look it up again, for DECL_EXTERNAL\n\tattempt to force a DIE for it and worst case remove the attribute.\n\t(resolve_one_addr): For TREE_CONSTANT_POOL_ADDRESS_P SYMBOL_REFs\n\tcheck TREE_ASM_WRITTEN of DECL_INITIAL of the decl instead of\n\tthe decl itself.\n\t* var-tracking.c: Include tm_p.h.\n\t(vt_stack_adjustments): For calls call note_register_arguments.\n\t(argument_reg_set): New variable.\n\t(add_stores): For MO_VAL_SET of non-tracked regs from argument_reg_set\n\tensure the VALUE is resolved.\n\t(call_arguments): New variable.\n\t(prepare_call_arguments): New function.\n\t(add_with_sets): For MO_CALL set u.loc from call_arguments and clear it.\n\t(struct expand_loc_callback_data): Add ignore_cur_loc field.\n\t(vt_expand_loc_callback): If ignore_cur_loc, don't look at cur_loc and\n\talways use the best expression.\n\t(vt_expand_loc): Add ignore_cur_loc argument.\n\t(vt_expand_loc_dummy): Clear ignore_cur_loc field.\n\t(emit_note_insn_var_location): Adjust vt_expand_loc callers.\n\t(emit_notes_in_bb) <case MO_CALL>: Add NOTE_INSN_CALL_ARG_LOCATION\n\tnote for all calls.\n\t(vt_add_function_parameter): Use cselib_lookup_from_insn.\n\tIf dv is a VALUE, enter into hash table also ENTRY_VALUE for the\n\targument.  Don't call cselib_preserve_only_values and\n\tcselib_reset_table.\n\t(note_register_arguments): New function.\n\t(vt_initialize): Compute argument_reg_set.  Call\n\tvt_add_function_parameters before processing basic blocks instead of\n\tafterwards.  For calls call prepare_call_arguments before calling\n\tcselib_process_insn.\n\t* print-rtl.c (print_rtx): Handle NOTE_INSN_CALL_ARG_LOCATION.\n\t* Makefile.in (dwarf2out.o): Depend on $(CFGLAYOUT_H).\n\t(var-tracking.o): Depend on $(TM_P_H).\n\t* cfglayout.h (insn_scope): New prototype.\n\t* gengtype.c (adjust_field_rtx_def): Handle NOTE_INSN_CALL_ARG_LOCATION.\n\t* cfglayout.c (insn_scope): No longer static.\n\t* insn-notes.def (CALL_ARG_LOCATION): New.\n\t* calls.c (expand_call, emit_library_call_value_1): Put USEs for\n\tMEM arguments into CALL_INSN_FUNCTION_USAGE unconditionally.\n\t* integrate.c (set_block_origin_self, set_block_abstract_flags): Do\n\tnothing for DECL_EXTERNAL BLOCK_VARS.\ncp/\n\t* cp-objcp-common.c (cp_function_decl_explicit_p): Don't crash if\n\tDECL_LANG_SPECIFIC is NULL.\ninclude/\n\t* dwarf2.h (DW_TAG_GNU_call_site, DW_TAG_GNU_call_site_parameter,\n\tDW_AT_GNU_call_site_value, DW_AT_GNU_call_site_data_value,\n\tDW_AT_GNU_call_site_target, DW_AT_GNU_call_site_target_clobbered,\n\tDW_AT_GNU_tail_call, DW_AT_GNU_all_tail_call_sites,\n\tDW_AT_GNU_all_call_sites,, DW_AT_GNU_all_source_call_sites,\n\tDW_OP_GNU_entry_value): New.\n\nFrom-SVN: r171033", "tree": {"sha": "aeb4609b3e08ab1fc279aa49e68d456a808be9f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeb4609b3e08ab1fc279aa49e68d456a808be9f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b1c543325692d744eec22f779656e13605c3ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1c543325692d744eec22f779656e13605c3ceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1c543325692d744eec22f779656e13605c3ceb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1c543325692d744eec22f779656e13605c3ceb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ef13bd018fc5c6e2dc57aa36d378919c8aeded1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef13bd018fc5c6e2dc57aa36d378919c8aeded1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef13bd018fc5c6e2dc57aa36d378919c8aeded1"}], "stats": {"total": 946, "additions": 861, "deletions": 85}, "files": [{"sha": "d42943d8636279f17d9cdcdaf7dc2a587b7b693a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,3 +1,81 @@\n+2011-03-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* final.c (final_scan_insn): Handle NOTE_INSN_CALL_ARG_LOCATION.\n+\tCall var_location debug hook even on CALL_INSNs.\n+\t(rest_of_clean_state): Don't print NOTE_INSN_CALL_ARG_LOCATION.\n+\t* rtl.def (ENTRY_VALUE): New.\n+\t* dwarf2out.c: Include cfglayout.h.\n+\t(dwarf_stack_op_name, size_of_loc_descr, output_loc_operands,\n+\toutput_loc_operands_raw): Handle DW_OP_GNU_entry_value.\n+\t(struct call_arg_loc_node): New type.\n+\t(call_arg_locations, call_arg_loc_last, block_map, call_site_count,\n+\ttail_call_site_count): New variables.\n+\t(dwarf_tag_name): Handle DW_TAG_GNU_call_site and\n+\tDW_TAG_GNU_call_site_parameter.\n+\t(dwarf_attr_name): Handle DW_AT_GNU_call_site_value,\n+\tDW_AT_GNU_call_site_data_value, DW_AT_GNU_call_site_target,\n+\tDW_AT_GNU_call_site_target_clobbered, DW_AT_GNU_tail_call,\n+\tDW_AT_GNU_all_tail_call_sites, DW_AT_GNU_all_call_sites\n+\tand DW_AT_GNU_all_source_call_sites.\n+\t(mem_loc_descriptor): Handle ENTRY_VALUE.\n+\t(add_src_coords_attributes): Don't add enything if\n+\tDECL_SOURCE_LOCATION is UNKNOWN_LOCATION.\n+\t(dwarf2out_abstract_function): Save and clear call_arg_location,\n+\tcall_site_count and tail_call_site_count around dwarf2out_decl call.\n+\t(gen_call_site_die): New function.\n+\t(gen_subprogram_die): Emit DW_TAG_GNU_call_site DIEs for call sites.\n+\t(gen_lexical_block_die, gen_inlined_subroutine_die): Update block_map.\n+\t(dwarf2out_function_decl): Clear call_arg_locations,\n+\tcall_arg_loc_last, set call_site_count and tail_call_site_count\n+\tto -1 and free block_map.\n+\t(dwarf2out_var_location): Handle NOTE_INSN_CALL_ARG_LOCATION and\n+\tCALL_INSNs.  Add NOTE_DURING_CALL_P var location notes even when not\n+\tfollowed by any real instructions.\n+\t(dwarf2out_begin_function): Set call_site_count and\n+\ttail_call_site_count to 0.\n+\t(resolve_addr): If DW_AT_abstract_origin of DW_TAG_GNU_call_site\n+\tis dw_val_class_addr, attempt to look it up again, for DECL_EXTERNAL\n+\tattempt to force a DIE for it and worst case remove the attribute.\n+\t(resolve_one_addr): For TREE_CONSTANT_POOL_ADDRESS_P SYMBOL_REFs\n+\tcheck TREE_ASM_WRITTEN of DECL_INITIAL of the decl instead of\n+\tthe decl itself.\n+\t* var-tracking.c: Include tm_p.h.\n+\t(vt_stack_adjustments): For calls call note_register_arguments.\n+\t(argument_reg_set): New variable.\n+\t(add_stores): For MO_VAL_SET of non-tracked regs from argument_reg_set\n+\tensure the VALUE is resolved.\n+\t(call_arguments): New variable.\n+\t(prepare_call_arguments): New function.\n+\t(add_with_sets): For MO_CALL set u.loc from call_arguments and clear it.\n+\t(struct expand_loc_callback_data): Add ignore_cur_loc field.\n+\t(vt_expand_loc_callback): If ignore_cur_loc, don't look at cur_loc and\n+\talways use the best expression.\n+\t(vt_expand_loc): Add ignore_cur_loc argument.\n+\t(vt_expand_loc_dummy): Clear ignore_cur_loc field.\n+\t(emit_note_insn_var_location): Adjust vt_expand_loc callers.\n+\t(emit_notes_in_bb) <case MO_CALL>: Add NOTE_INSN_CALL_ARG_LOCATION\n+\tnote for all calls.\n+\t(vt_add_function_parameter): Use cselib_lookup_from_insn.\n+\tIf dv is a VALUE, enter into hash table also ENTRY_VALUE for the\n+\targument.  Don't call cselib_preserve_only_values and\n+\tcselib_reset_table.\n+\t(note_register_arguments): New function.\n+\t(vt_initialize): Compute argument_reg_set.  Call\n+\tvt_add_function_parameters before processing basic blocks instead of\n+\tafterwards.  For calls call prepare_call_arguments before calling\n+\tcselib_process_insn.\n+\t* print-rtl.c (print_rtx): Handle NOTE_INSN_CALL_ARG_LOCATION.\n+\t* Makefile.in (dwarf2out.o): Depend on $(CFGLAYOUT_H).\n+\t(var-tracking.o): Depend on $(TM_P_H).\n+\t* cfglayout.h (insn_scope): New prototype.\n+\t* gengtype.c (adjust_field_rtx_def): Handle NOTE_INSN_CALL_ARG_LOCATION.\n+\t* cfglayout.c (insn_scope): No longer static.\n+\t* insn-notes.def (CALL_ARG_LOCATION): New.\n+\t* calls.c (expand_call, emit_library_call_value_1): Put USEs for\n+\tMEM arguments into CALL_INSN_FUNCTION_USAGE unconditionally.\n+\t* integrate.c (set_block_origin_self, set_block_abstract_flags): Do\n+\tnothing for DECL_EXTERNAL BLOCK_VARS.\n+\n 2011-03-16  Alan Modra  <amodra@gmail.com>\n \n \tPR target/45844"}, {"sha": "b4de74b00bae875f57c7e83678acac2094bac914", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -3,7 +3,7 @@\n \n # Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996,\n # 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n-# 2008, 2009, 2010 Free Software Foundation, Inc.\n+# 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -2933,7 +2933,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(LIBFUNCS_H) toplev.h $(DIAGNOSTIC_CORE_H) dwarf2out.h reload.h \\\n    $(GGC_H) $(EXCEPT_H) dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) \\\n    gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) $(MD5_H) $(INPUT_H) $(FUNCTION_H) \\\n-   $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) tree-pretty-print.h\n+   $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) $(CFGLAYOUT_H) tree-pretty-print.h\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \\\n    gt-dwarf2asm.h $(DWARF2_H) $(SPLAY_TREE_H) $(TARGET_H)\n@@ -3162,7 +3162,7 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n    $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n    cselib.h $(TARGET_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) $(DIAGNOSTIC_H) pointer-set.h \\\n-   $(RECOG_H) tree-pretty-print.h\n+   $(RECOG_H) $(TM_P_H) tree-pretty-print.h\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_CORE_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "b15bfefa3c1d9a9e071aed3d202b5e2be39d18d7", "filename": "gcc/calls.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,7 +1,7 @@\n /* Convert function calls to rtl insns, for GNU C compiler.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2784,9 +2784,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\tsibcall_failure = 1;\n \t      }\n \n-\t  if (((flags & ECF_CONST)\n-\t       || ((flags & ECF_PURE) && ACCUMULATE_OUTGOING_ARGS))\n-\t      && args[i].stack)\n+\t  if (args[i].stack)\n \t    call_fusage = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t     gen_rtx_USE (VOIDmode,\n \t\t\t\t\t\t\t  args[i].stack),\n@@ -3682,6 +3680,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n       if (! (reg != 0 && partial == 0))\n \t{\n+\t  rtx use;\n+\n \t  if (ACCUMULATE_OUTGOING_ARGS)\n \t    {\n \t      /* If this is being stored into a pre-allocated, fixed-size,\n@@ -3752,28 +3752,22 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n \t  NO_DEFER_POP;\n \n-\t  if ((flags & ECF_CONST)\n-\t      || ((flags & ECF_PURE) && ACCUMULATE_OUTGOING_ARGS))\n-\t    {\n-\t      rtx use;\n-\n-\t      /* Indicate argument access so that alias.c knows that these\n-\t\t values are live.  */\n-\t      if (argblock)\n-\t\tuse = plus_constant (argblock,\n-\t\t\t\t     argvec[argnum].locate.offset.constant);\n-\t      else\n-\t\t/* When arguments are pushed, trying to tell alias.c where\n-\t\t   exactly this argument is won't work, because the\n-\t\t   auto-increment causes confusion.  So we merely indicate\n-\t\t   that we access something with a known mode somewhere on\n-\t\t   the stack.  */\n-\t\tuse = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n-\t\t\t\t    gen_rtx_SCRATCH (Pmode));\n-\t      use = gen_rtx_MEM (argvec[argnum].mode, use);\n-\t      use = gen_rtx_USE (VOIDmode, use);\n-\t      call_fusage = gen_rtx_EXPR_LIST (VOIDmode, use, call_fusage);\n-\t    }\n+\t  /* Indicate argument access so that alias.c knows that these\n+\t     values are live.  */\n+\t  if (argblock)\n+\t    use = plus_constant (argblock,\n+\t\t\t\t argvec[argnum].locate.offset.constant);\n+\t  else\n+\t    /* When arguments are pushed, trying to tell alias.c where\n+\t       exactly this argument is won't work, because the\n+\t       auto-increment causes confusion.  So we merely indicate\n+\t       that we access something with a known mode somewhere on\n+\t       the stack.  */\n+\t    use = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n+\t\t\t\tgen_rtx_SCRATCH (Pmode));\n+\t  use = gen_rtx_MEM (argvec[argnum].mode, use);\n+\t  use = gen_rtx_USE (VOIDmode, use);\n+\t  call_fusage = gen_rtx_EXPR_LIST (VOIDmode, use, call_fusage);\n \t}\n     }\n "}, {"sha": "76925a519f24432dbe83a2e60e8c0a1096da68e6", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,6 +1,6 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -54,7 +54,6 @@ static void change_scope (rtx, tree, tree);\n \n void verify_insn_chain (void);\n static void fixup_fallthru_exit_predecessor (void);\n-static tree insn_scope (const_rtx);\n \f\n rtx\n unlink_insn_chain (rtx first, rtx last)\n@@ -499,7 +498,7 @@ locator_scope (int loc)\n }\n \n /* Return lexical scope block insn belongs to.  */\n-static tree\n+tree\n insn_scope (const_rtx insn)\n {\n   return locator_scope (INSN_LOCATOR (insn));"}, {"sha": "deb985646a332f19ed2e2a5f046534e984a53492", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,5 +1,5 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2003, 2004, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003, 2004, 2007, 2011 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -27,6 +27,7 @@ extern GTY(()) rtx cfg_layout_function_header;\n \n extern void cfg_layout_initialize (unsigned int);\n extern void cfg_layout_finalize (void);\n+extern tree insn_scope (const_rtx);\n extern void reemit_insn_block_notes (void);\n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,"}, {"sha": "58ea1a544a2df89be4835c32743ff1c927ade2b0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,3 +1,8 @@\n+2011-03-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-objcp-common.c (cp_function_decl_explicit_p): Don't crash if\n+\tDECL_LANG_SPECIFIC is NULL.\n+\n 2011-03-15  Jason Merrill  <jason@redhat.com>\n \n \tCore 1074"}, {"sha": "6e042694a8760d0eb0069784f2e4d60bb8cfa952", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,5 +1,6 @@\n /* Some code common to C++ and ObjC++ front ends.\n-   Copyright (C) 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Ziemowit Laski  <zlaski@apple.com>\n \n This file is part of GCC.\n@@ -160,6 +161,7 @@ cp_function_decl_explicit_p (tree decl)\n {\n   return (decl\n \t  && FUNCTION_FIRST_USER_PARMTYPE (decl) != void_list_node\n+\t  && DECL_LANG_SPECIFIC (STRIP_TEMPLATE (decl))\n \t  && DECL_NONCONVERTING_P (decl));\n }\n "}, {"sha": "7e257c3a4c3f3d5f354d88d03b9ca1c95ca8539d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 360, "deletions": 14, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -92,6 +92,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n #include \"tree-flow.h\"\n+#include \"cfglayout.h\"\n \n static void dwarf2out_source_line (unsigned int, const char *, int, bool);\n static rtx last_var_location_insn;\n@@ -4794,6 +4795,8 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_GNU_encoded_addr\";\n     case DW_OP_GNU_implicit_pointer:\n       return \"DW_OP_GNU_implicit_pointer\";\n+    case DW_OP_GNU_entry_value:\n+      return \"DW_OP_GNU_entry_value\";\n \n     default:\n       return \"OP_<unknown>\";\n@@ -4900,6 +4903,8 @@ loc_list_plus_const (dw_loc_list_ref list_head, HOST_WIDE_INT offset)\n #define DWARF_REF_SIZE\t\\\n   (dwarf_version == 2 ? DWARF2_ADDR_SIZE : DWARF_OFFSET_SIZE)\n \n+static unsigned long size_of_locs (dw_loc_descr_ref);\n+\n /* Return the size of a location descriptor.  */\n \n static unsigned long\n@@ -5015,6 +5020,12 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n     case DW_OP_GNU_implicit_pointer:\n       size += DWARF_REF_SIZE + size_of_sleb128 (loc->dw_loc_oprnd2.v.val_int);\n       break;\n+    case DW_OP_GNU_entry_value:\n+      {\n+\tunsigned long op_size = size_of_locs (loc->dw_loc_oprnd1.v.val_loc);\n+\tsize += size_of_uleb128 (op_size) + op_size;\n+\tbreak;\n+      }\n     default:\n       break;\n     }\n@@ -5052,6 +5063,7 @@ size_of_locs (dw_loc_descr_ref loc)\n \n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n static void get_ref_die_offset_label (char *, dw_die_ref);\n+static void output_loc_sequence (dw_loc_descr_ref, int);\n \n /* Output location description stack opcode's operands (if any).\n    The for_eh_or_skip parameter controls whether register numbers are\n@@ -5301,6 +5313,11 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n       }\n       break;\n \n+    case DW_OP_GNU_entry_value:\n+      dw2_asm_output_data_uleb128 (size_of_locs (val1->v.val_loc), NULL);\n+      output_loc_sequence (val1->v.val_loc, for_eh_or_skip);\n+      break;\n+\n     default:\n       /* Other codes have no operands.  */\n       break;\n@@ -5477,6 +5494,7 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n       break;\n \n     case DW_OP_GNU_implicit_pointer:\n+    case DW_OP_GNU_entry_value:\n       gcc_unreachable ();\n       break;\n \n@@ -6115,10 +6133,33 @@ struct GTY (()) var_loc_list_def {\n };\n typedef struct var_loc_list_def var_loc_list;\n \n+/* Call argument location list.  */\n+struct GTY ((chain_next (\"%h.next\"))) call_arg_loc_node {\n+  rtx GTY (()) call_arg_loc_note;\n+  const char * GTY (()) label;\n+  tree GTY (()) block;\n+  bool tail_call_p;\n+  rtx GTY (()) symbol_ref;\n+  struct call_arg_loc_node * GTY (()) next;\n+};\n+\n \n /* Table of decl location linked lists.  */\n static GTY ((param_is (var_loc_list))) htab_t decl_loc_table;\n \n+/* Head and tail of call_arg_loc chain.  */\n+static GTY (()) struct call_arg_loc_node *call_arg_locations;\n+static struct call_arg_loc_node *call_arg_loc_last;\n+\n+/* Number of call sites in the current function.  */\n+static int call_site_count = -1;\n+/* Number of tail call sites in the current function.  */\n+static int tail_call_site_count = -1;\n+\n+/* Vector mapping block numbers to DW_TAG_{lexical_block,inlined_subroutine}\n+   DIEs.  */\n+static VEC (dw_die_ref, heap) *block_map;\n+\n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n    children DIE's, and list of attribute/value pairs.  */\n@@ -6907,6 +6948,10 @@ dwarf_tag_name (unsigned int tag)\n       return \"DW_TAG_GNU_EINCL\";\n     case DW_TAG_GNU_template_template_param:\n       return \"DW_TAG_GNU_template_template_param\";\n+    case DW_TAG_GNU_call_site:\n+      return \"DW_TAG_GNU_call_site\";\n+    case DW_TAG_GNU_call_site_parameter:\n+      return \"DW_TAG_GNU_call_site_parameter\";\n     default:\n       return \"DW_TAG_<unknown>\";\n     }\n@@ -7151,6 +7196,22 @@ dwarf_attr_name (unsigned int attr)\n       return \"DW_AT_GNU_odr_signature\";\n     case DW_AT_GNU_template_name:\n       return \"DW_AT_GNU_template_name\";\n+    case DW_AT_GNU_call_site_value:\n+      return \"DW_AT_GNU_call_site_value\";\n+    case DW_AT_GNU_call_site_data_value:\n+      return \"DW_AT_GNU_call_site_data_value\";\n+    case DW_AT_GNU_call_site_target:\n+      return \"DW_AT_GNU_call_site_target\";\n+    case DW_AT_GNU_call_site_target_clobbered:\n+      return \"DW_AT_GNU_call_site_target_clobbered\";\n+    case DW_AT_GNU_tail_call:\n+      return \"DW_AT_GNU_tail_call\";\n+    case DW_AT_GNU_all_tail_call_sites:\n+      return \"DW_AT_GNU_all_tail_call_sites\";\n+    case DW_AT_GNU_all_call_sites:\n+      return \"DW_AT_GNU_all_call_sites\";\n+    case DW_AT_GNU_all_source_call_sites:\n+      return \"DW_AT_GNU_all_source_call_sites\";\n \n     case DW_AT_VMS_rtnbeg_pd_address:\n       return \"DW_AT_VMS_rtnbeg_pd_address\";\n@@ -13964,6 +14025,26 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\"CONCAT/CONCATN/VAR_LOCATION is handled only by loc_descriptor\");\n       return 0;\n \n+    case ENTRY_VALUE:\n+      mem_loc_result = new_loc_descr (DW_OP_GNU_entry_value, 0, 0);\n+      mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+      if (REG_P (XEXP (rtl, 0)))\n+\tmem_loc_result->dw_loc_oprnd1.v.val_loc\n+\t  = one_reg_loc_descriptor (dbx_reg_number (XEXP (rtl, 0)),\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+      else if (MEM_P (XEXP (rtl, 0)) && REG_P (XEXP (XEXP (rtl, 0), 0)))\n+\t{\n+\t  dw_loc_descr_ref ref\n+\t    = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\t  if (ref == NULL)\n+\t    return NULL;\n+\t  mem_loc_result->dw_loc_oprnd1.v.val_loc = ref;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      return mem_loc_result;\n+\n     case PRE_MODIFY:\n       /* Extract the PLUS expression nested inside and fall into\n \t PLUS code below.  */\n@@ -17842,8 +17923,11 @@ add_linkage_attr (dw_die_ref die, tree decl)\n static void\n add_src_coords_attributes (dw_die_ref die, tree decl)\n {\n-  expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));\n+  expanded_location s;\n \n+  if (DECL_SOURCE_LOCATION (decl) == UNKNOWN_LOCATION)\n+    return;\n+  s = expand_location (DECL_SOURCE_LOCATION (decl));\n   add_AT_file (die, DW_AT_decl_file, lookup_filename (s.file));\n   add_AT_unsigned (die, DW_AT_decl_line, s.line);\n }\n@@ -18872,6 +18956,8 @@ dwarf2out_abstract_function (tree decl)\n   tree context;\n   int was_abstract;\n   htab_t old_decl_loc_table;\n+  int old_call_site_count, old_tail_call_site_count;\n+  struct call_arg_loc_node *old_call_arg_locations;\n \n   /* Make sure we have the actual abstract inline, not a clone.  */\n   decl = DECL_ORIGIN (decl);\n@@ -18886,6 +18972,12 @@ dwarf2out_abstract_function (tree decl)\n      get locations in abstract instantces.  */\n   old_decl_loc_table = decl_loc_table;\n   decl_loc_table = NULL;\n+  old_call_arg_locations = call_arg_locations;\n+  call_arg_locations = NULL;\n+  old_call_site_count = call_site_count;\n+  call_site_count = -1;\n+  old_tail_call_site_count = tail_call_site_count;\n+  tail_call_site_count = -1;\n \n   /* Be sure we've emitted the in-class declaration DIE (if any) first, so\n      we don't get confused by DECL_ABSTRACT.  */\n@@ -18910,6 +19002,9 @@ dwarf2out_abstract_function (tree decl)\n \n   current_function_decl = save_fn;\n   decl_loc_table = old_decl_loc_table;\n+  call_arg_locations = old_call_arg_locations;\n+  call_site_count = old_call_site_count;\n+  tail_call_site_count = old_tail_call_site_count;\n   pop_cfun ();\n }\n \n@@ -18985,6 +19080,43 @@ premark_types_used_by_global_vars (void)\n \t\t   premark_types_used_by_global_vars_helper, NULL);\n }\n \n+/* Generate a DW_TAG_GNU_call_site DIE in function DECL under SUBR_DIE\n+   for CA_LOC call arg loc node.  */\n+\n+static dw_die_ref\n+gen_call_site_die (tree decl, dw_die_ref subr_die,\n+\t\t   struct call_arg_loc_node *ca_loc)\n+{\n+  dw_die_ref stmt_die = NULL, die;\n+  tree block = ca_loc->block;\n+\n+  while (block\n+\t && block != DECL_INITIAL (decl)\n+\t && TREE_CODE (block) == BLOCK)\n+    {\n+      if (VEC_length (dw_die_ref, block_map) > BLOCK_NUMBER (block))\n+\tstmt_die = VEC_index (dw_die_ref, block_map, BLOCK_NUMBER (block));\n+      if (stmt_die)\n+\tbreak;\n+      block = BLOCK_SUPERCONTEXT (block);\n+    }\n+  if (stmt_die == NULL)\n+    stmt_die = subr_die;\n+  die = new_die (DW_TAG_GNU_call_site, stmt_die, NULL_TREE);\n+  add_AT_lbl_id (die, DW_AT_low_pc, ca_loc->label);\n+  if (ca_loc->tail_call_p)\n+    add_AT_flag (die, DW_AT_GNU_tail_call, 1);\n+  if (ca_loc->symbol_ref)\n+    {\n+      dw_die_ref tdie = lookup_decl_die (SYMBOL_REF_DECL (ca_loc->symbol_ref));\n+      if (tdie)\n+\tadd_AT_die_ref (die, DW_AT_abstract_origin, tdie);\n+      else\n+\tadd_AT_addr (die, DW_AT_abstract_origin, ca_loc->symbol_ref);\n+    }\n+  return die;\n+}\n+\n /* Generate a DIE to represent a declared function (either file-scope or\n    block-local).  */\n \n@@ -19467,12 +19599,113 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n      constructor function.  */\n   if (! declaration && TREE_CODE (outer_scope) != ERROR_MARK)\n     {\n+      int call_site_note_count = 0;\n+      int tail_call_site_note_count = 0;\n+\n       /* Emit a DW_TAG_variable DIE for a named return value.  */\n       if (DECL_NAME (DECL_RESULT (decl)))\n \tgen_decl_die (DECL_RESULT (decl), NULL, subr_die);\n \n       current_function_has_inlines = 0;\n       decls_for_scope (outer_scope, subr_die, 0);\n+\n+      if (call_arg_locations)\n+\t{\n+\t  struct call_arg_loc_node *ca_loc;\n+\t  for (ca_loc = call_arg_locations; ca_loc; ca_loc = ca_loc->next)\n+\t    {\n+\t      dw_die_ref die = NULL;\n+\t      rtx tloc = NULL_RTX;\n+\t      rtx arg, next_arg;\n+\n+\t      for (arg = NOTE_VAR_LOCATION (ca_loc->call_arg_loc_note);\n+\t\t   arg; arg = next_arg)\n+\t\t{\n+\t\t  dw_loc_descr_ref reg, val;\n+\t\t  enum machine_mode mode = GET_MODE (XEXP (XEXP (arg, 0), 1));\n+\t\t  dw_die_ref cdie;\n+\n+\t\t  next_arg = XEXP (arg, 1);\n+\t\t  if (REG_P (XEXP (XEXP (arg, 0), 0))\n+\t\t      && next_arg\n+\t\t      && MEM_P (XEXP (XEXP (next_arg, 0), 0))\n+\t\t      && REG_P (XEXP (XEXP (XEXP (next_arg, 0), 0), 0))\n+\t\t      && REGNO (XEXP (XEXP (arg, 0), 0))\n+\t\t\t == REGNO (XEXP (XEXP (XEXP (next_arg, 0), 0), 0)))\n+\t\t    next_arg = XEXP (next_arg, 1);\n+\t\t  if (mode == VOIDmode)\n+\t\t    mode = GET_MODE (XEXP (XEXP (arg, 0), 0));\n+\t\t  if (GET_MODE_CLASS (mode) != MODE_INT\n+\t\t      || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+\t\t    continue;\n+\t\t  if (XEXP (XEXP (arg, 0), 0) == pc_rtx)\n+\t\t    {\n+\t\t      gcc_assert (ca_loc->symbol_ref == NULL_RTX);\n+\t\t      tloc = XEXP (XEXP (arg, 0), 1);\n+\t\t      continue;\n+\t\t    }\n+\t\t  if (REG_P (XEXP (XEXP (arg, 0), 0)))\n+\t\t    reg = reg_loc_descriptor (XEXP (XEXP (arg, 0), 0),\n+\t\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n+\t\t  else if (MEM_P (XEXP (XEXP (arg, 0), 0)))\n+\t\t    reg = mem_loc_descriptor (XEXP (XEXP (XEXP (arg, 0),\n+\t\t\t\t\t\t\t  0), 0), mode,\n+\t\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n+\t\t  else\n+\t\t    continue;\n+\t\t  if (reg == NULL)\n+\t\t    continue;\n+\t\t  val = mem_loc_descriptor (XEXP (XEXP (arg, 0), 1), VOIDmode,\n+\t\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t\t  if (val == NULL)\n+\t\t    continue;\n+\t\t  if (die == NULL)\n+\t\t    die = gen_call_site_die (decl, subr_die, ca_loc);\n+\t\t  cdie = new_die (DW_TAG_GNU_call_site_parameter, die,\n+\t\t\t\t  NULL_TREE);\t\t\n+\t\t  add_AT_loc (cdie, DW_AT_location, reg);\n+\t\t  add_AT_loc (cdie, DW_AT_GNU_call_site_value, val);\n+\t\t  if (next_arg != XEXP (arg, 1))\n+\t\t    {\n+\t\t      val = mem_loc_descriptor (XEXP (XEXP (XEXP (arg, 1),\n+\t\t\t\t\t\t\t    0), 1), VOIDmode,\n+\t\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\t\t      if (val != NULL)\n+\t\t\tadd_AT_loc (cdie, DW_AT_GNU_call_site_data_value, val);\n+\t\t    }\n+\t\t}\n+\t      if (die == NULL\n+\t\t  && (ca_loc->symbol_ref || tloc))\n+\t\tdie = gen_call_site_die (decl, subr_die, ca_loc);\n+\t      if (die != NULL && tloc != NULL_RTX)\n+\t\t{\n+\t\t  dw_loc_descr_ref tval\n+\t\t    = mem_loc_descriptor (tloc, VOIDmode,\n+\t\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\t\t  if (tval)\n+\t\t    add_AT_loc (die, DW_AT_GNU_call_site_target, tval);\n+\t\t}\n+\t      if (die != NULL)\n+\t\t{\n+\t\t  call_site_note_count++;\n+\t\t  if (ca_loc->tail_call_p)\n+\t\t    tail_call_site_note_count++;\n+\t\t}\n+\t    }\n+\t  call_arg_locations = NULL;\n+\t  call_arg_loc_last = NULL;\n+\t}\n+      if (tail_call_site_count >= 0\n+\t  && tail_call_site_count == tail_call_site_note_count)\n+\t{\n+\t  if (call_site_count >= 0\n+\t      && call_site_count == call_site_note_count)\n+\t    add_AT_flag (subr_die, DW_AT_GNU_all_call_sites, 1);\n+\t  else\n+\t    add_AT_flag (subr_die, DW_AT_GNU_all_tail_call_sites, 1);\n+\t}\n+      call_site_count = -1;\n+      tail_call_site_count = -1;\n     }\n   /* Add the calling convention attribute if requested.  */\n   add_calling_convention_attribute (subr_die, decl);\n@@ -19861,6 +20094,14 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die, int depth)\n {\n   dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);\n \n+  if (call_arg_locations)\n+    {\n+      if (VEC_length (dw_die_ref, block_map) <= BLOCK_NUMBER (stmt))\n+\tVEC_safe_grow_cleared (dw_die_ref, heap, block_map,\n+\t\t\t       BLOCK_NUMBER (stmt) + 1);\n+      VEC_replace (dw_die_ref, block_map, BLOCK_NUMBER (stmt), stmt_die);\n+    }\n+\n   if (! BLOCK_ABSTRACT (stmt) && TREE_ASM_WRITTEN (stmt))\n     add_high_low_attributes (stmt, stmt_die);\n \n@@ -19891,6 +20132,13 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n       dw_die_ref subr_die\n \t= new_die (DW_TAG_inlined_subroutine, context_die, stmt);\n \n+      if (call_arg_locations)\n+\t{\n+\t  if (VEC_length (dw_die_ref, block_map) <= BLOCK_NUMBER (stmt))\n+\t    VEC_safe_grow_cleared (dw_die_ref, heap, block_map,\n+\t\t\t\t   BLOCK_NUMBER (stmt) + 1);\n+\t  VEC_replace (dw_die_ref, block_map, BLOCK_NUMBER (stmt), subr_die);\n+\t}\n       add_abstract_origin_attribute (subr_die, decl);\n       if (TREE_ASM_WRITTEN (stmt))\n         add_high_low_attributes (stmt, subr_die);\n@@ -21502,7 +21750,11 @@ static void\n dwarf2out_function_decl (tree decl)\n {\n   dwarf2out_decl (decl);\n-\n+  call_arg_locations = NULL;\n+  call_arg_loc_last = NULL;\n+  call_site_count = -1;\n+  tail_call_site_count = -1;\n+  VEC_free (dw_die_ref, heap, block_map);\n   htab_empty (decl_loc_table);\n }\n \n@@ -21899,16 +22151,35 @@ dwarf2out_var_location (rtx loc_note)\n   static const char *last_postcall_label;\n   static bool last_in_cold_section_p;\n   tree decl;\n+  bool var_loc_p;\n+\n+  if (!NOTE_P (loc_note))\n+    {\n+      if (CALL_P (loc_note))\n+\t{\n+\t  call_site_count++;\n+\t  if (SIBLING_CALL_P (loc_note))\n+\t    tail_call_site_count++;\n+\t}\n+      return;\n+    }\n \n-  if (!DECL_P (NOTE_VAR_LOCATION_DECL (loc_note)))\n+  var_loc_p = NOTE_KIND (loc_note) == NOTE_INSN_VAR_LOCATION;\n+  if (var_loc_p && !DECL_P (NOTE_VAR_LOCATION_DECL (loc_note)))\n     return;\n \n   next_real = next_real_insn (loc_note);\n+\n   /* If there are no instructions which would be affected by this note,\n      don't do anything.  */\n-  if (next_real == NULL_RTX && !NOTE_DURING_CALL_P (loc_note))\n+  if (var_loc_p\n+      && next_real == NULL_RTX\n+      && !NOTE_DURING_CALL_P (loc_note))\n     return;\n \n+  if (next_real == NULL_RTX)\n+    next_real = get_last_insn ();\n+\n   /* If there were any real insns between note we processed last time\n      and this note (or if it is the first note), clear\n      last_{,postcall_}label so that they are not reused this time.  */\n@@ -21920,12 +22191,20 @@ dwarf2out_var_location (rtx loc_note)\n       last_postcall_label = NULL;\n     }\n \n-  decl = NOTE_VAR_LOCATION_DECL (loc_note);\n-  newloc = add_var_loc_to_decl (decl, loc_note,\n-\t\t\t\tNOTE_DURING_CALL_P (loc_note)\n-\t\t\t\t? last_postcall_label : last_label);\n-  if (newloc == NULL)\n-    return;\n+  if (var_loc_p)\n+    {\n+      decl = NOTE_VAR_LOCATION_DECL (loc_note);\n+      newloc = add_var_loc_to_decl (decl, loc_note,\n+\t\t\t\t    NOTE_DURING_CALL_P (loc_note)\n+\t\t\t\t    ? last_postcall_label : last_label);\n+      if (newloc == NULL)\n+\treturn;\n+    }\n+  else\n+    {\n+      decl = NULL_TREE;\n+      newloc = NULL;\n+    }\n \n   /* If there were no real insns between note we processed last time\n      and this note, use the label we emitted last time.  Otherwise\n@@ -21938,7 +22217,43 @@ dwarf2out_var_location (rtx loc_note)\n       last_label = ggc_strdup (loclabel);\n     }\n \n-  if (!NOTE_DURING_CALL_P (loc_note))\n+  if (!var_loc_p)\n+    {\n+      struct call_arg_loc_node *ca_loc\n+\t= ggc_alloc_cleared_call_arg_loc_node ();\n+      rtx prev = prev_real_insn (loc_note), x;\n+      ca_loc->call_arg_loc_note = loc_note;\n+      ca_loc->next = NULL;\n+      ca_loc->label = last_label;\n+      gcc_assert (prev\n+\t\t  && (CALL_P (prev)\n+\t\t      || (NONJUMP_INSN_P (prev)\n+\t\t\t  && GET_CODE (PATTERN (prev)) == SEQUENCE\n+\t\t\t  && CALL_P (XVECEXP (PATTERN (prev), 0, 0)))));\n+      if (!CALL_P (prev))\n+\tprev = XVECEXP (PATTERN (prev), 0, 0);\n+      ca_loc->tail_call_p = SIBLING_CALL_P (prev);\n+      x = PATTERN (prev);\n+      if (GET_CODE (x) == PARALLEL)\n+\tx = XVECEXP (x, 0, 0);\n+      if (GET_CODE (x) == SET)\n+\tx = SET_SRC (x);\n+      if (GET_CODE (x) == CALL && MEM_P (XEXP (x, 0)))\n+\t{\n+\t  x = XEXP (XEXP (x, 0), 0);\n+\t  if (GET_CODE (x) == SYMBOL_REF\n+\t      && SYMBOL_REF_DECL (x)\n+\t      && TREE_CODE (SYMBOL_REF_DECL (x)) == FUNCTION_DECL)\n+\t    ca_loc->symbol_ref = x;\n+\t}\n+      ca_loc->block = insn_scope (prev);\n+      if (call_arg_locations)\n+\tcall_arg_loc_last->next = ca_loc;\n+      else\n+\tcall_arg_locations = ca_loc;\n+      call_arg_loc_last = ca_loc;\n+    }\n+  else if (!NOTE_DURING_CALL_P (loc_note))\n     newloc->label = last_label;\n   else\n     {\n@@ -21974,6 +22289,8 @@ dwarf2out_begin_function (tree fun)\n     }\n \n   dwarf2out_note_section_used ();\n+  call_site_count = 0;\n+  tail_call_site_count = 0;\n }\n \n /* Output a label to mark the beginning of a source code line entry\n@@ -22804,9 +23121,16 @@ resolve_one_addr (rtx *addr, void *data ATTRIBUTE_UNUSED)\n     }\n \n   if (GET_CODE (rtl) == SYMBOL_REF\n-      && SYMBOL_REF_DECL (rtl)\n-      && !TREE_ASM_WRITTEN (SYMBOL_REF_DECL (rtl)))\n-    return 1;\n+      && SYMBOL_REF_DECL (rtl))\n+    {\n+      if (TREE_CONSTANT_POOL_ADDRESS_P (rtl))\n+\t{\n+\t  if (!TREE_ASM_WRITTEN (DECL_INITIAL (SYMBOL_REF_DECL (rtl))))\n+\t    return 1;\n+\t}\n+      else if (!TREE_ASM_WRITTEN (SYMBOL_REF_DECL (rtl)))\n+\treturn 1;\n+    }\n \n   if (GET_CODE (rtl) == CONST\n       && for_each_rtx (&XEXP (rtl, 0), resolve_one_addr, NULL))\n@@ -22898,6 +23222,28 @@ resolve_addr (dw_die_ref die)\n \t    remove_AT (die, a->dw_attr);\n \t    ix--;\n \t  }\n+\tif (die->die_tag == DW_TAG_GNU_call_site\n+\t    && a->dw_attr == DW_AT_abstract_origin)\n+\t  {\n+\t    tree tdecl = SYMBOL_REF_DECL (a->dw_attr_val.v.val_addr);\n+\t    dw_die_ref tdie = lookup_decl_die (tdecl);\n+\t    if (tdie == NULL && DECL_EXTERNAL (tdecl))\n+\t      {\n+\t\tforce_decl_die (tdecl);\n+\t\ttdie = lookup_decl_die (tdecl);\n+\t      }\n+\t    if (tdie)\n+\t      {\n+\t\ta->dw_attr_val.val_class = dw_val_class_die_ref;\n+\t\ta->dw_attr_val.v.val_die_ref.die = tdie;\n+\t\ta->dw_attr_val.v.val_die_ref.external = 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\tremove_AT (die, a->dw_attr);\n+\t\tix--;\n+\t      }\n+\t  }\n \tbreak;\n       default:\n \tbreak;"}, {"sha": "eb800c50e53b7a5074a13eb3a90123f3061fb549", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,6 +1,7 @@\n /* Convert RTL to assembler code and output it, for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2005,6 +2006,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_VAR_LOCATION:\n+\tcase NOTE_INSN_CALL_ARG_LOCATION:\n \t  if (!DECL_IGNORED_P (current_function_decl))\n \t    debug_hooks->var_location (insn);\n \t  break;\n@@ -2671,6 +2673,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\tif (t)\n \t\t  assemble_external (t);\n \t      }\n+\t    if (!DECL_IGNORED_P (current_function_decl))\n+\t      debug_hooks->var_location (insn);\n \t  }\n \n \t/* Output assembler code from the template.  */\n@@ -4423,6 +4427,7 @@ rest_of_clean_state (void)\n       if (final_output\n \t  && (!NOTE_P (insn) ||\n \t      (NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION\n+\t       && NOTE_KIND (insn) != NOTE_INSN_CALL_ARG_LOCATION\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_BEG\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END\n \t       && NOTE_KIND (insn) != NOTE_INSN_CFA_RESTORE_STATE)))"}, {"sha": "94cc449211742750d32ed4f9e8a8d510a4304380", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,5 +1,5 @@\n /* Process source files and output type information.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -1013,6 +1013,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t    break;\n \n \t  case NOTE_INSN_VAR_LOCATION:\n+\t  case NOTE_INSN_CALL_ARG_LOCATION:\n \t    note_flds = create_field (note_flds, rtx_tp, \"rt_rtx\");\n \t    break;\n "}, {"sha": "6cdbabde09d6e1a0d1dd20dfb89348e07ae4a0b8", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,5 +1,5 @@\n /* Insn note definitions.\n-   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -61,6 +61,9 @@ INSN_NOTE (EH_REGION_END)\n /* The location of a variable.  */\n INSN_NOTE (VAR_LOCATION)\n \n+/* The values passed to callee.  */\n+INSN_NOTE (CALL_ARG_LOCATION)\n+\n /* Record the struct for the following basic block.  Uses\n    NOTE_BASIC_BLOCK.  FIXME: Redundant with the basic block pointer\n    now included in every insn.  */"}, {"sha": "3211fed9c4730edc7c150691043c6d499bc754e5", "filename": "gcc/integrate.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,6 +1,6 @@\n /* Procedure integration for GCC.\n    Copyright (C) 1988, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -112,7 +112,8 @@ set_block_origin_self (tree stmt)\n \tfor (local_decl = BLOCK_VARS (stmt);\n \t     local_decl != NULL_TREE;\n \t     local_decl = DECL_CHAIN (local_decl))\n-\t  set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n+\t  if (! DECL_EXTERNAL (local_decl))\n+\t    set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n       }\n \n       {\n@@ -173,7 +174,8 @@ set_block_abstract_flags (tree stmt, int setting)\n   for (local_decl = BLOCK_VARS (stmt);\n        local_decl != NULL_TREE;\n        local_decl = DECL_CHAIN (local_decl))\n-    set_decl_abstract_flags (local_decl, setting);\n+    if (! DECL_EXTERNAL (local_decl))\n+      set_decl_abstract_flags (local_decl, setting);\n \n   for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n     {"}, {"sha": "7748585c2dcf3e0f20ff38090e82f8aefcfea6c2", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,6 +1,6 @@\n /* Print RTL for GCC.\n    Copyright (C) 1987, 1988, 1992, 1997, 1998, 1999, 2000, 2002, 2003,\n-   2004, 2005, 2007, 2008, 2009, 2010\n+   2004, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -302,6 +302,7 @@ print_rtx (const_rtx in_rtx)\n \t\t}\n \n \t      case NOTE_INSN_VAR_LOCATION:\n+\t      case NOTE_INSN_CALL_ARG_LOCATION:\n #ifndef GENERATOR_FILE\n \t\tfputc (' ', outfile);\n \t\tprint_rtx (NOTE_VAR_LOCATION (in_rtx));"}, {"sha": "885cbcf3ce8ce5d45ad221d0aa790b4de244ff93", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -2,7 +2,7 @@\n    Register Transfer Expressions (rtx's) that make up the\n    Register Transfer Language (rtl) used in the Back End of the GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2004,\n-   2005, 2006, 2007, 2008, 2009, 2010\n+   2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -718,6 +718,10 @@ DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"tei\", RTX_EXTRA)\n    addressable.  */\n DEF_RTL_EXPR(DEBUG_IMPLICIT_PTR, \"debug_implicit_ptr\", \"t\", RTX_OBJ)\n \n+/* Represents value that argument had on function entry.  Should\n+   be only used in VAR_LOCATION location expression.  */\n+DEF_RTL_EXPR(ENTRY_VALUE, \"entry_value\", \"e\", RTX_OBJ)\n+\n /* All expressions from this point forward appear only in machine\n    descriptions.  */\n #ifdef GENERATOR_FILE"}, {"sha": "7141ab5c7d4161bbb49778b4bd65719ca13c3c42", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 331, "deletions": 26, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -115,6 +115,7 @@\n #include \"tree-pretty-print.h\"\n #include \"pointer-set.h\"\n #include \"recog.h\"\n+#include \"tm_p.h\"\n \n /* var-tracking.c assumes that tree code with the same value as VALUE rtx code\n    has no chance to appear in REG_EXPR/MEM_EXPRs and isn't a decl.\n@@ -408,6 +409,7 @@ static void stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n static void insn_stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t       HOST_WIDE_INT *);\n static bool vt_stack_adjustments (void);\n+static void note_register_arguments (rtx);\n static hashval_t variable_htab_hash (const void *);\n static int variable_htab_eq (const void *, const void *);\n static void variable_htab_free (void *);\n@@ -659,11 +661,15 @@ vt_stack_adjustments (void)\n \t    for (insn = BB_HEAD (dest);\n \t\t insn != NEXT_INSN (BB_END (dest));\n \t\t insn = NEXT_INSN (insn))\n-\t      if (INSN_P (insn))\n-\t\t{\n-\t\t  insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n-\t\t  offset += pre + post;\n-\t\t}\n+\t      {\n+\t\tif (INSN_P (insn))\n+\t\t  {\n+\t\t    insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n+\t\t    offset += pre + post;\n+\t\t  }\n+\t\tif (CALL_P (insn))\n+\t\t  note_register_arguments (insn);\n+\t      }\n \n \t  VTI (dest)->out.stack_adjust = offset;\n \n@@ -4971,6 +4977,9 @@ log_op_type (rtx x, basic_block bb, rtx insn,\n /* All preserved VALUEs.  */\n static VEC (rtx, heap) *preserved_values;\n \n+/* Registers used in the current function for passing parameters.  */\n+static HARD_REG_SET argument_reg_set;\n+\n /* Ensure VAL is preserved and remember it in a vector for vt_emit_notes.  */\n \n static void\n@@ -5324,10 +5333,22 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t{\n \t  mo.type = MO_CLOBBER;\n \t  mo.u.loc = loc;\n+\t  if (GET_CODE (expr) == SET\n+\t      && SET_DEST (expr) == loc\n+\t      && REGNO (loc) < FIRST_PSEUDO_REGISTER\n+\t      && TEST_HARD_REG_BIT (argument_reg_set, REGNO (loc))\n+\t      && find_use_val (loc, mode, cui)\n+\t      && GET_CODE (SET_SRC (expr)) != ASM_OPERANDS)\n+\t    {\n+\t      gcc_checking_assert (type == MO_VAL_SET);\n+\t      mo.u.loc = gen_rtx_SET (VOIDmode, loc, SET_SRC (expr));\n+\t    }\n \t}\n       else\n \t{\n-\t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n+\t  if (GET_CODE (expr) == SET\n+\t      && SET_DEST (expr) == loc\n+\t      && GET_CODE (SET_SRC (expr)) != ASM_OPERANDS)\n \t    src = var_lowpart (mode2, SET_SRC (expr));\n \t  loc = var_lowpart (mode2, loc);\n \n@@ -5387,7 +5408,9 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t}\n       else\n \t{\n-\t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n+\t  if (GET_CODE (expr) == SET\n+\t      && SET_DEST (expr) == loc\n+\t      && GET_CODE (SET_SRC (expr)) != ASM_OPERANDS)\n \t    src = var_lowpart (mode2, SET_SRC (expr));\n \t  loc = var_lowpart (mode2, loc);\n \n@@ -5542,6 +5565,195 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n }\n \n+/* Arguments to the call.  */\n+static rtx call_arguments;\n+\n+/* Compute call_arguments.  */\n+\n+static void\n+prepare_call_arguments (basic_block bb, rtx insn)\n+{\n+  rtx link, x;\n+  rtx prev, cur, next;\n+  rtx call = PATTERN (insn);\n+  tree type = NULL_TREE, t;\n+  CUMULATIVE_ARGS args_so_far;\n+\n+  memset (&args_so_far, 0, sizeof (args_so_far));\n+  if (GET_CODE (call) == PARALLEL)\n+    call = XVECEXP (call, 0, 0);\n+  if (GET_CODE (call) == SET)\n+    call = SET_SRC (call);\n+  if (GET_CODE (call) == CALL\n+      && MEM_P (XEXP (call, 0))\n+      && GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)\n+    {\n+      rtx symbol = XEXP (XEXP (call, 0), 0);\n+      if (SYMBOL_REF_DECL (symbol)\n+\t  && TREE_CODE (SYMBOL_REF_DECL (symbol)) == FUNCTION_DECL\n+\t  && TYPE_ARG_TYPES (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n+\t{\n+\t  type = TREE_TYPE (SYMBOL_REF_DECL (symbol));\n+\t  for (t = TYPE_ARG_TYPES (type); t && t != void_list_node;\n+\t       t = TREE_CHAIN (t))\n+\t    if (TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n+\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (TREE_VALUE (t))))\n+\t      break;\n+\t  if (t == NULL || t == void_list_node)\n+\t    type = NULL;\n+\t  else\n+\t    INIT_CUMULATIVE_ARGS (args_so_far, type, NULL_RTX,\n+\t\t\t\t  SYMBOL_REF_DECL (symbol),\n+\t\t\t\t  list_length (TYPE_ARG_TYPES (type)));\n+\t}\n+    }\n+  t = type ? TYPE_ARG_TYPES (type) : NULL_TREE;\n+\n+  for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+    if (GET_CODE (XEXP (link, 0)) == USE)\n+      {\n+\trtx item = NULL_RTX;\n+\tx = XEXP (XEXP (link, 0), 0);\n+\tif (REG_P (x))\n+\t  {\n+\t    cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n+\t    if (val && cselib_preserved_value_p (val))\n+\t      item = gen_rtx_CONCAT (GET_MODE (x), x, val->val_rtx);\n+\t    else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+\t      {\n+\t\tenum machine_mode mode = GET_MODE (x);\n+\n+\t\twhile ((mode = GET_MODE_WIDER_MODE (mode)) != VOIDmode\n+\t\t       && GET_MODE_BITSIZE (mode) <= BITS_PER_WORD)\n+\t\t  {\n+\t\t    rtx reg = simplify_subreg (mode, x, GET_MODE (x), 0);\n+\n+\t\t    if (reg == NULL_RTX || !REG_P (reg))\n+\t\t      continue;\n+\t\t    val = cselib_lookup (reg, mode, 0, VOIDmode);\n+\t\t    if (val && cselib_preserved_value_p (val))\n+\t\t      {\n+\t\t\titem = gen_rtx_CONCAT (GET_MODE (x), x,\n+\t\t\t\t\t       lowpart_subreg (GET_MODE (x),\n+\t\t\t\t\t\t\t       val->val_rtx,\n+\t\t\t\t\t\t\t       mode));\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+\telse if (MEM_P (x))\n+\t  {\n+\t    rtx mem = x;\n+\t    cselib_val *val;\n+\n+\t    if (!frame_pointer_needed)\n+\t      {\n+\t\tstruct adjust_mem_data amd;\n+\t\tamd.mem_mode = VOIDmode;\n+\t\tamd.stack_adjust = -VTI (bb)->out.stack_adjust;\n+\t\tamd.side_effects = NULL_RTX;\n+\t\tamd.store = true;\n+\t\tmem = simplify_replace_fn_rtx (mem, NULL_RTX, adjust_mems,\n+\t\t\t\t\t       &amd);\n+\t\tgcc_assert (amd.side_effects == NULL_RTX);\n+\t      }\n+\t    val = cselib_lookup (mem, GET_MODE (mem), 0, VOIDmode);\n+\t    if (val && cselib_preserved_value_p (val))\n+\t      item = gen_rtx_CONCAT (GET_MODE (x), copy_rtx (x), val->val_rtx);\n+\t  }\n+\tif (item)\n+\t  call_arguments = gen_rtx_EXPR_LIST (VOIDmode, item, call_arguments);\n+\tif (t && t != void_list_node)\n+\t  {\n+\t    enum machine_mode mode = TYPE_MODE (TREE_VALUE (t));\n+\t    rtx reg = targetm.calls.function_arg (&args_so_far, mode,\n+\t\t\t\t\t\t  TREE_VALUE (t), true);\n+\t    if (TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n+\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (TREE_VALUE (t)))\n+\t\t&& reg\n+\t\t&& REG_P (reg)\n+\t\t&& GET_MODE (reg) == mode\n+\t\t&& GET_MODE_CLASS (mode) == MODE_INT\n+\t\t&& REG_P (x)\n+\t\t&& REGNO (x) == REGNO (reg)\n+\t\t&& GET_MODE (x) == mode\n+\t\t&& item)\n+\t      {\n+\t\tenum machine_mode indmode\n+\t\t  = TYPE_MODE (TREE_TYPE (TREE_VALUE (t)));\n+\t\trtx mem = gen_rtx_MEM (indmode, x);\n+\t\tcselib_val *val = cselib_lookup (mem, indmode, 0, VOIDmode);\n+\t\tif (val && cselib_preserved_value_p (val))\n+\t\t  {\n+\t\t    item = gen_rtx_CONCAT (indmode, mem, val->val_rtx);\n+\t\t    call_arguments = gen_rtx_EXPR_LIST (VOIDmode, item,\n+\t\t\t\t\t\t\tcall_arguments);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    struct elt_loc_list *l;\n+\t\t    tree initial;\n+\n+\t\t    /* Try harder, when passing address of a constant\n+\t\t       pool integer it can be easily read back.  */\n+\t\t    val = CSELIB_VAL_PTR (XEXP (item, 1));\n+\t\t    for (l = val->locs; l; l = l->next)\n+\t\t      if (GET_CODE (l->loc) == SYMBOL_REF\n+\t\t\t  && TREE_CONSTANT_POOL_ADDRESS_P (l->loc)\n+\t\t\t  && SYMBOL_REF_DECL (l->loc)\n+\t\t\t  && DECL_INITIAL (SYMBOL_REF_DECL (l->loc)))\n+\t\t\t{\n+\t\t\t  initial = DECL_INITIAL (SYMBOL_REF_DECL (l->loc));\n+\t\t\t  if (host_integerp (initial, 0))\n+\t\t\t    {\n+\t\t\t      item = GEN_INT (tree_low_cst (initial, 0));\n+\t\t\t      item = gen_rtx_CONCAT (indmode, mem, item);\n+\t\t\t      call_arguments\n+\t\t\t\t= gen_rtx_EXPR_LIST (VOIDmode, item,\n+\t\t\t\t\t\t     call_arguments);\n+\t\t\t    }\n+\t\t\t  break;\n+\t\t\t}\n+\t\t  }\n+\t      }\n+\t    targetm.calls.function_arg_advance (&args_so_far, mode,\n+\t\t\t\t\t\tTREE_VALUE (t), true);\n+\t    t = TREE_CHAIN (t);\n+\t  }\n+      }\n+\n+  /* Reverse call_arguments chain.  */\n+  prev = NULL_RTX;\n+  for (cur = call_arguments; cur; cur = next)\n+    {\n+      next = XEXP (cur, 1);\n+      XEXP (cur, 1) = prev;\n+      prev = cur;\n+    }\n+  call_arguments = prev;\n+\n+  x = PATTERN (insn);\n+  if (GET_CODE (x) == PARALLEL)\n+    x = XVECEXP (x, 0, 0);\n+  if (GET_CODE (x) == SET)\n+    x = SET_SRC (x);\n+  if (GET_CODE (x) == CALL && MEM_P (XEXP (x, 0)))\n+    {\n+      x = XEXP (XEXP (x, 0), 0);\n+      if (GET_CODE (x) != SYMBOL_REF)\n+\t{\n+\t  cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n+\t  if (val && cselib_preserved_value_p (val))\n+\t    {\n+\t      x = gen_rtx_CONCAT (GET_MODE (x), pc_rtx, val->val_rtx);\n+\t      call_arguments\n+\t\t= gen_rtx_EXPR_LIST (VOIDmode, x, call_arguments);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Callback for cselib_record_sets_hook, that records as micro\n    operations uses and stores in an insn after cselib_record_sets has\n    analyzed the sets in an insn, but before it modifies the stored\n@@ -5611,7 +5823,8 @@ add_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n \n       mo.type = MO_CALL;\n       mo.insn = insn;\n-      mo.u.loc = NULL_RTX;\n+      mo.u.loc = call_arguments;\n+      call_arguments = NULL_RTX;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tlog_op_type (PATTERN (insn), bb, insn, mo.type, dump_file);\n@@ -6927,6 +7140,10 @@ struct expand_loc_callback_data\n      whose cur_loc has been already recomputed during current\n      emit_notes_for_changes call.  */\n   bool cur_loc_changed;\n+\n+  /* True if cur_loc should be ignored and any possible location\n+     returned.  */\n+  bool ignore_cur_loc;\n };\n \n /* Callback for cselib_expand_value, that looks for expressions\n@@ -6940,6 +7157,7 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n     = (struct expand_loc_callback_data *) data;\n   bool dummy = elcd->dummy;\n   bool cur_loc_changed = elcd->cur_loc_changed;\n+  rtx cur_loc;\n   decl_or_value dv;\n   variable var;\n   location_chain loc;\n@@ -7014,7 +7232,7 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n   VALUE_RECURSED_INTO (x) = true;\n   result = NULL;\n \n-  if (var->var_part[0].cur_loc)\n+  if (var->var_part[0].cur_loc && !elcd->ignore_cur_loc)\n     {\n       if (dummy)\n \t{\n@@ -7029,12 +7247,16 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n \t\t\t\t\t     vt_expand_loc_callback, data);\n       if (result)\n \tset_dv_changed (dv, false);\n+      cur_loc = var->var_part[0].cur_loc;\n     }\n-  if (!result && dv_changed_p (dv))\n+  else\n+    cur_loc = NULL_RTX;\n+  if (!result && (dv_changed_p (dv) || elcd->ignore_cur_loc))\n     {\n-      set_dv_changed (dv, false);\n+      if (!elcd->ignore_cur_loc)\n+\tset_dv_changed (dv, false);\n       for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n-\tif (loc->loc == var->var_part[0].cur_loc)\n+\tif (loc->loc == cur_loc)\n \t  continue;\n \telse if (dummy)\n \t  {\n@@ -7056,7 +7278,8 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n \t  }\n       if (dummy && (result || var->var_part[0].cur_loc))\n \tvar->cur_loc_changed = true;\n-      var->var_part[0].cur_loc = loc ? loc->loc : NULL_RTX;\n+      if (!elcd->ignore_cur_loc)\n+\tvar->var_part[0].cur_loc = loc ? loc->loc : NULL_RTX;\n     }\n   if (dummy)\n     {\n@@ -7077,7 +7300,7 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n    tables.  */\n \n static rtx\n-vt_expand_loc (rtx loc, htab_t vars)\n+vt_expand_loc (rtx loc, htab_t vars, bool ignore_cur_loc)\n {\n   struct expand_loc_callback_data data;\n \n@@ -7087,6 +7310,7 @@ vt_expand_loc (rtx loc, htab_t vars)\n   data.vars = vars;\n   data.dummy = false;\n   data.cur_loc_changed = false;\n+  data.ignore_cur_loc = ignore_cur_loc;\n   loc = cselib_expand_value_rtx_cb (loc, scratch_regs, 8,\n \t\t\t\t    vt_expand_loc_callback, &data);\n \n@@ -7108,6 +7332,7 @@ vt_expand_loc_dummy (rtx loc, htab_t vars, bool *pcur_loc_changed)\n   data.vars = vars;\n   data.dummy = true;\n   data.cur_loc_changed = false;\n+  data.ignore_cur_loc = false;\n   ret = cselib_dummy_expand_value_rtx_cb (loc, scratch_regs, 8,\n \t\t\t\t\t  vt_expand_loc_callback, &data);\n   *pcur_loc_changed = data.cur_loc_changed;\n@@ -7178,7 +7403,7 @@ emit_note_insn_var_location (void **varp, void *data)\n \t  complete = false;\n \t  continue;\n \t}\n-      loc2 = vt_expand_loc (var->var_part[i].cur_loc, vars);\n+      loc2 = vt_expand_loc (var->var_part[i].cur_loc, vars, false);\n       if (!loc2)\n \t{\n \t  complete = false;\n@@ -7208,7 +7433,7 @@ emit_note_insn_var_location (void **varp, void *data)\n \t  && mode == GET_MODE (var->var_part[j].cur_loc)\n \t  && (REG_P (loc[n_var_parts]) || MEM_P (loc[n_var_parts]))\n \t  && last_limit == var->var_part[j].offset\n-\t  && (loc2 = vt_expand_loc (var->var_part[j].cur_loc, vars))\n+\t  && (loc2 = vt_expand_loc (var->var_part[j].cur_loc, vars, false))\n \t  && GET_CODE (loc[n_var_parts]) == GET_CODE (loc2))\n \t{\n \t  rtx new_loc = NULL;\n@@ -7662,6 +7887,34 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t  case MO_CALL:\n \t    dataflow_set_clear_at_call (set);\n \t    emit_notes_for_changes (insn, EMIT_NOTE_AFTER_CALL_INSN, set->vars);\n+\t    {\n+\t      rtx arguments = mo->u.loc, *p = &arguments, note;\n+\t      while (*p)\n+\t\t{\n+\t\t  XEXP (XEXP (*p, 0), 1)\n+\t\t    = vt_expand_loc (XEXP (XEXP (*p, 0), 1),\n+\t\t\t\t     shared_hash_htab (set->vars), true);\n+\t\t  /* If expansion is successful, keep it in the list.  */\n+\t\t  if (XEXP (XEXP (*p, 0), 1))\n+\t\t    p = &XEXP (*p, 1);\n+\t\t  /* Otherwise, if the following item is data_value for it,\n+\t\t     drop it too too.  */\n+\t\t  else if (XEXP (*p, 1)\n+\t\t\t   && REG_P (XEXP (XEXP (*p, 0), 0))\n+\t\t\t   && MEM_P (XEXP (XEXP (XEXP (*p, 1), 0), 0))\n+\t\t\t   && REG_P (XEXP (XEXP (XEXP (XEXP (*p, 1), 0), 0),\n+\t\t\t\t\t   0))\n+\t\t\t   && REGNO (XEXP (XEXP (*p, 0), 0))\n+\t\t\t      == REGNO (XEXP (XEXP (XEXP (XEXP (*p, 1), 0),\n+\t\t\t\t\t\t    0), 0)))\n+\t\t    *p = XEXP (XEXP (*p, 1), 1);\n+\t\t  /* Just drop this item.  */\n+\t\t  else\n+\t\t    *p = XEXP (*p, 1);\n+\t\t}\n+\t      note = emit_note_after (NOTE_INSN_CALL_ARG_LOCATION, insn);\n+\t      NOTE_VAR_LOCATION (note) = arguments;\n+\t    }\n \t    break;\n \n \t  case MO_USE:\n@@ -8095,8 +8348,8 @@ vt_add_function_parameter (tree parm)\n       if (offset)\n \treturn;\n \n-      val = cselib_lookup (var_lowpart (mode, incoming), mode, true,\n-\t\t\t   VOIDmode);\n+      val = cselib_lookup_from_insn (var_lowpart (mode, incoming), mode, true,\n+\t\t\t\t     VOIDmode, get_insns ());\n \n       /* ??? Float-typed values in memory are not handled by\n \t cselib.  */\n@@ -8117,6 +8370,36 @@ vt_add_function_parameter (tree parm)\n \t\t\t incoming);\n       set_variable_part (out, incoming, dv, offset,\n \t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n+      if (dv_is_value_p (dv))\n+\t{\n+\t  cselib_val *val = CSELIB_VAL_PTR (dv_as_value (dv));\n+\t  struct elt_loc_list *el;\n+\t  el = (struct elt_loc_list *)\n+\t    ggc_alloc_cleared_atomic (sizeof (*el));\n+\t  el->next = val->locs;\n+\t  el->loc = gen_rtx_ENTRY_VALUE (GET_MODE (incoming), incoming);\n+\t  el->setting_insn = get_insns ();\n+\t  val->locs = el;\n+\t  if (TREE_CODE (TREE_TYPE (parm)) == REFERENCE_TYPE\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (parm))))\n+\t    {\n+\t      enum machine_mode indmode\n+\t\t= TYPE_MODE (TREE_TYPE (TREE_TYPE (parm)));\n+\t      rtx mem = gen_rtx_MEM (indmode, incoming);\n+\t      val = cselib_lookup_from_insn (mem, indmode, true,\n+\t\t\t\t\t     VOIDmode, get_insns ());\n+\t      if (val)\n+\t\t{\n+\t\t  preserve_value (val);\n+\t\t  el = (struct elt_loc_list *)\n+\t\t    ggc_alloc_cleared_atomic (sizeof (*el));\n+\t\t  el->next = val->locs;\n+\t\t  el->loc = gen_rtx_ENTRY_VALUE (indmode, mem);\n+\t\t  el->setting_insn = get_insns ();\n+\t\t  val->locs = el;\n+\t\t}\n+\t    }\n+\t}\n     }\n   else if (MEM_P (incoming))\n     {\n@@ -8150,13 +8433,6 @@ vt_add_function_parameters (void)\n \t  && DECL_NAMELESS (vexpr))\n \tvt_add_function_parameter (vexpr);\n     }\n-\n-  if (MAY_HAVE_DEBUG_INSNS)\n-    {\n-      cselib_preserve_only_values ();\n-      cselib_reset_table (cselib_get_next_uid ());\n-    }\n-\n }\n \n /* Return true if INSN in the prologue initializes hard_frame_pointer_rtx.  */\n@@ -8184,6 +8460,23 @@ fp_setter (rtx insn)\n   return false;\n }\n \n+/* Gather all registers used for passing arguments to other functions\n+   called from the current routine.  */\n+\n+static void\n+note_register_arguments (rtx insn)\n+{\n+  rtx link, x;\n+\n+  for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+    if (GET_CODE (XEXP (link, 0)) == USE)\n+      {\n+\tx = XEXP (XEXP (link, 0), 0);\n+\tif (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t  SET_HARD_REG_BIT (argument_reg_set, REGNO (x));\n+      }\n+}\n+\n /* Initialize cfa_base_rtx, create a preserved VALUE for it and\n    ensure it isn't flushed during cselib_reset_table.\n    Can be called only if frame_pointer_rtx resp. arg_pointer_rtx\n@@ -8286,6 +8579,8 @@ vt_initialize (void)\n       valvar_pool = NULL;\n     }\n \n+  CLEAR_HARD_REG_SET (argument_reg_set);\n+\n   if (!frame_pointer_needed)\n     {\n       rtx reg, elim;\n@@ -8332,9 +8627,18 @@ vt_initialize (void)\n \t    prologue_bb = single_succ (ENTRY_BLOCK_PTR);\n \t}\n     }\n+  if (frame_pointer_needed)\n+    {\n+      rtx insn;\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (CALL_P (insn))\n+\t  note_register_arguments (insn);\n+    }\n \n   hard_frame_pointer_adjustment = -1;\n \n+  vt_add_function_parameters ();\n+\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n@@ -8395,6 +8699,8 @@ vt_initialize (void)\n \t\t  adjust_insn (bb, insn);\n \t\t  if (MAY_HAVE_DEBUG_INSNS)\n \t\t    {\n+\t\t      if (CALL_P (insn))\n+\t\t\tprepare_call_arguments (bb, insn);\n \t\t      cselib_process_insn (insn);\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t{\n@@ -8445,7 +8751,6 @@ vt_initialize (void)\n \n   hard_frame_pointer_adjustment = -1;\n   VTI (ENTRY_BLOCK_PTR)->flooded = true;\n-  vt_add_function_parameters ();\n   cfa_base_rtx = NULL_RTX;\n   return true;\n }"}, {"sha": "2b674d7c45a940645732c9ed26ea0bc6cf930a29", "filename": "include/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,3 +1,12 @@\n+2011-03-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2.h (DW_TAG_GNU_call_site, DW_TAG_GNU_call_site_parameter,\n+\tDW_AT_GNU_call_site_value, DW_AT_GNU_call_site_data_value,\n+\tDW_AT_GNU_call_site_target, DW_AT_GNU_call_site_target_clobbered,\n+\tDW_AT_GNU_tail_call, DW_AT_GNU_all_tail_call_sites,\n+\tDW_AT_GNU_all_call_sites,, DW_AT_GNU_all_source_call_sites,\n+\tDW_OP_GNU_entry_value): New.\n+\n 2011-02-28  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* filenames.h (filename_ncmp): New prototype."}, {"sha": "46f2291c6176e794637e22bb67815e495e55bd1d", "filename": "include/dwarf2.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1c543325692d744eec22f779656e13605c3ceb/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1c543325692d744eec22f779656e13605c3ceb/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=2b1c543325692d744eec22f779656e13605c3ceb", "patch": "@@ -1,7 +1,7 @@\n /* Declarations and definitions of codes relating to the DWARF2 and\n    DWARF3 symbolic debugging information formats.\n    Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n    Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n@@ -141,6 +141,12 @@ enum dwarf_tag\n        are properly part of DWARF 5.  */\n     DW_TAG_GNU_template_parameter_pack = 0x4107,\n     DW_TAG_GNU_formal_parameter_pack = 0x4108,\n+    /* The GNU call site extension, specified at\n+       http://www.dwarfstd.org/ShowIssue.php?issue=100909.2&type=open .\n+       The values of these two TAGS are in the DW_TAG_GNU_* space until the tags\n+       are properly part of DWARF 5.  */\n+    DW_TAG_GNU_call_site = 0x4109,\n+    DW_TAG_GNU_call_site_parameter = 0x410a,\n     /* Extensions for UPC.  See: http://upc.gwu.edu/~upc.  */\n     DW_TAG_upc_shared_type = 0x8765,\n     DW_TAG_upc_strict_type = 0x8766,\n@@ -351,6 +357,16 @@ enum dwarf_attribute\n     /* Template template argument name.\n        See http://gcc.gnu.org/wiki/TemplateParmsDwarf .  */\n     DW_AT_GNU_template_name = 0x2110,\n+    /* The GNU call site extension.\n+       See http://www.dwarfstd.org/ShowIssue.php?issue=100909.2&type=open .  */\n+    DW_AT_GNU_call_site_value = 0x2111,\n+    DW_AT_GNU_call_site_data_value = 0x2112,\n+    DW_AT_GNU_call_site_target = 0x2113,\n+    DW_AT_GNU_call_site_target_clobbered = 0x2114,\n+    DW_AT_GNU_tail_call = 0x2115,\n+    DW_AT_GNU_all_tail_call_sites = 0x2116,\n+    DW_AT_GNU_all_call_sites = 0x2117,\n+    DW_AT_GNU_all_source_call_sites = 0x2118,\n     /* VMS extensions.  */\n     DW_AT_VMS_rtnbeg_pd_address = 0x2201,\n     /* GNAT extensions.  */\n@@ -535,7 +551,12 @@ enum dwarf_location_atom\n     /* The following is for marking variables that are uninitialized.  */\n     DW_OP_GNU_uninit     = 0xf0,\n     DW_OP_GNU_encoded_addr = 0xf1,\n+    /* The GNU implicit pointer extension.\n+       See http://www.dwarfstd.org/ShowIssue.php?issue=100831.1&type=open .  */\n     DW_OP_GNU_implicit_pointer = 0xf2,\n+    /* The GNU entry value extension.\n+       See http://www.dwarfstd.org/ShowIssue.php?issue=100909.1&type=open .  */\n+    DW_OP_GNU_entry_value = 0xf3,\n     /* HP extensions.  */\n     DW_OP_HP_unknown     = 0xe0, /* Ouch, the same as GNU_push_tls_address.  */\n     DW_OP_HP_is_value    = 0xe1,"}]}