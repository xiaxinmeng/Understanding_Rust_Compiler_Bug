{"sha": "73c4b4df26d90486debc267cd61c55ab350de4e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjNGI0ZGYyNmQ5MDQ4NmRlYmMyNjdjZDYxYzU1YWIzNTBkZTRlMA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-20T12:02:19Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-20T12:02:19Z"}, "message": "re PR tree-optimization/81388 (Incorrect code generation with -O1)\n\n\n\tPR tree-optimization/81388\n\tRevert r238585:\n\t2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n\n\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne): Clean up\n\tby removing computation of may_be_zero.\n\n\tgcc/testsuite\n\tPR tree-optimization/81388\n\t* gcc.dg/tree-ssa/pr81388-1.c: New test.\n\t* gcc.dg/tree-ssa/pr81388-2.c: New test.\n\nFrom-SVN: r250384", "tree": {"sha": "4b66df896dfeeb4859f5e87593d22ec46e1c455f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b66df896dfeeb4859f5e87593d22ec46e1c455f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73c4b4df26d90486debc267cd61c55ab350de4e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c4b4df26d90486debc267cd61c55ab350de4e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c4b4df26d90486debc267cd61c55ab350de4e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c4b4df26d90486debc267cd61c55ab350de4e0/comments", "author": null, "committer": null, "parents": [{"sha": "77e5edafafd54b6a68f56e2fb8be67a4dd68ec0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e5edafafd54b6a68f56e2fb8be67a4dd68ec0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77e5edafafd54b6a68f56e2fb8be67a4dd68ec0c"}], "stats": {"total": 148, "additions": 120, "deletions": 28}, "files": [{"sha": "42ae134177ebf39ad083bcccf3b419f1a79532fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73c4b4df26d90486debc267cd61c55ab350de4e0", "patch": "@@ -1,3 +1,12 @@\n+2017-07-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/81388\n+\tRevert r238585:\n+\t2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne): Clean up\n+\tby removing computation of may_be_zero.\n+\n 2017-07-18  Jan Hubicka  <hubicka@ucw.cz>\n \t    Tom de Vries  <tom@codesourcery.com>\n "}, {"sha": "3fc1332e68627710ce44de32b292d3c51569883b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73c4b4df26d90486debc267cd61c55ab350de4e0", "patch": "@@ -1,3 +1,9 @@\n+2017-07-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/81388\n+\t* gcc.dg/tree-ssa/pr81388-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr81388-2.c: New test.\n+\n 2017-07-17  Tom de Vries  <tom@codesourcery.com>\n \n \tPR middle-end/81030"}, {"sha": "ecfe12929ccbcf8f5b56ef04dcb5533fd62f0070", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81388-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c?ref=73c4b4df26d90486debc267cd61c55ab350de4e0", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-strict-overflow -fdump-tree-ivcanon-details\" } */\n+\n+void bar();\n+void foo(char *dst)\n+{\n+  char *const end = dst;\n+  do {\n+    bar();\n+    dst += 2;\n+  } while (dst < end);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" zero if \" 1 \"ivcanon\" } } */"}, {"sha": "71fd2890f3d2d7f426134a2324a17877850d165b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81388-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-2.c?ref=73c4b4df26d90486debc267cd61c55ab350de4e0", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivcanon-details\" } */\n+\n+void bar();\n+void foo(unsigned dst)\n+{\n+  unsigned end = dst;\n+  do {\n+    bar();\n+    dst += 2;\n+  } while (dst < end);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" zero if \" 1 \"ivcanon\" } } */"}, {"sha": "e0107c28dfbf7c5e3e0a6c508fa97e2f61d0a78a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 77, "deletions": 28, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c4b4df26d90486debc267cd61c55ab350de4e0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=73c4b4df26d90486debc267cd61c55ab350de4e0", "patch": "@@ -1142,60 +1142,109 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree niter_type = TREE_TYPE (step);\n   tree mod = fold_build2 (FLOOR_MOD_EXPR, niter_type, *delta, step);\n   tree tmod;\n-  tree assumption = boolean_true_node, bound;\n-  tree type1 = (POINTER_TYPE_P (type)) ? sizetype : type;\n+  mpz_t mmod;\n+  tree assumption = boolean_true_node, bound, noloop;\n+  bool ret = false, fv_comp_no_overflow;\n+  tree type1 = type;\n+  if (POINTER_TYPE_P (type))\n+    type1 = sizetype;\n \n   if (TREE_CODE (mod) != INTEGER_CST)\n     return false;\n   if (integer_nonzerop (mod))\n     mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n   tmod = fold_convert (type1, mod);\n \n+  mpz_init (mmod);\n+  wi::to_mpz (mod, mmod, UNSIGNED);\n+  mpz_neg (mmod, mmod);\n+\n   /* If the induction variable does not overflow and the exit is taken,\n-     then the computation of the final value does not overflow.  There\n-     are three cases:\n-       1) The case if the new final value is equal to the current one.\n-       2) Induction varaible has pointer type, as the code cannot rely\n-\t  on the object to that the pointer points being placed at the\n-\t  end of the address space (and more pragmatically,\n-\t  TYPE_{MIN,MAX}_VALUE is not defined for pointers).\n-       3) EXIT_MUST_BE_TAKEN is true, note it implies that the induction\n-\t  variable does not overflow.  */\n-  if (!integer_zerop (mod) && !POINTER_TYPE_P (type) && !exit_must_be_taken)\n+     then the computation of the final value does not overflow.  This is\n+     also obviously the case if the new final value is equal to the\n+     current one.  Finally, we postulate this for pointer type variables,\n+     as the code cannot rely on the object to that the pointer points being\n+     placed at the end of the address space (and more pragmatically,\n+     TYPE_{MIN,MAX}_VALUE is not defined for pointers).  */\n+  if (integer_zerop (mod) || POINTER_TYPE_P (type))\n+    fv_comp_no_overflow = true;\n+  else if (!exit_must_be_taken)\n+    fv_comp_no_overflow = false;\n+  else\n+    fv_comp_no_overflow =\n+\t    (iv0->no_overflow && integer_nonzerop (iv0->step))\n+\t    || (iv1->no_overflow && integer_nonzerop (iv1->step));\n+\n+  if (integer_nonzerop (iv0->step))\n     {\n-      if (integer_nonzerop (iv0->step))\n+      /* The final value of the iv is iv1->base + MOD, assuming that this\n+\t computation does not overflow, and that\n+\t iv0->base <= iv1->base + MOD.  */\n+      if (!fv_comp_no_overflow)\n \t{\n-\t  /* The final value of the iv is iv1->base + MOD, assuming\n-\t     that this computation does not overflow, and that\n-\t     iv0->base <= iv1->base + MOD.  */\n \t  bound = fold_build2 (MINUS_EXPR, type1,\n \t\t\t       TYPE_MAX_VALUE (type1), tmod);\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n+\t  if (integer_zerop (assumption))\n+\t    goto end;\n \t}\n+      if (mpz_cmp (mmod, bnds->below) < 0)\n+\tnoloop = boolean_false_node;\n+      else if (POINTER_TYPE_P (type))\n+\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      iv0->base,\n+\t\t\t      fold_build_pointer_plus (iv1->base, tmod));\n       else\n+\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      iv0->base,\n+\t\t\t      fold_build2 (PLUS_EXPR, type1,\n+\t\t\t\t\t   iv1->base, tmod));\n+    }\n+  else\n+    {\n+      /* The final value of the iv is iv0->base - MOD, assuming that this\n+\t computation does not overflow, and that\n+\t iv0->base - MOD <= iv1->base. */\n+      if (!fv_comp_no_overflow)\n \t{\n-\t  /* The final value of the iv is iv0->base - MOD, assuming\n-\t     that this computation does not overflow, and that\n-\t     iv0->base - MOD <= iv1->base.  */\n \t  bound = fold_build2 (PLUS_EXPR, type1,\n \t\t\t       TYPE_MIN_VALUE (type1), tmod);\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n+\t  if (integer_zerop (assumption))\n+\t    goto end;\n \t}\n-      if (integer_zerop (assumption))\n-\treturn false;\n-      else if (!integer_nonzerop (assumption))\n-\tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\t  niter->assumptions, assumption);\n+      if (mpz_cmp (mmod, bnds->below) < 0)\n+\tnoloop = boolean_false_node;\n+      else if (POINTER_TYPE_P (type))\n+\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      fold_build_pointer_plus (iv0->base,\n+\t\t\t\t\t\t       fold_build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t\t\t    type1, tmod)),\n+\t\t\t      iv1->base);\n+      else\n+\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t      fold_build2 (MINUS_EXPR, type1,\n+\t\t\t\t\t   iv0->base, tmod),\n+\t\t\t      iv1->base);\n     }\n \n-  /* Since we are transforming LT to NE and DELTA is constant, there\n-     is no need to compute may_be_zero because this loop must roll.  */\n-\n+  if (!integer_nonzerop (assumption))\n+    niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      niter->assumptions,\n+\t\t\t\t      assumption);\n+  if (!integer_zerop (noloop))\n+    niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t      niter->may_be_zero,\n+\t\t\t\t      noloop);\n   bounds_add (bnds, wi::to_widest (mod), type);\n   *delta = fold_build2 (PLUS_EXPR, niter_type, *delta, mod);\n-  return true;\n+\n+  ret = true;\n+end:\n+  mpz_clear (mmod);\n+  return ret;\n }\n \n /* Add assertions to NITER that ensure that the control variable of the loop"}]}