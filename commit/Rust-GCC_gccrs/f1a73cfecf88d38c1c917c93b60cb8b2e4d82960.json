{"sha": "f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFhNzNjZmVjZjg4ZDM4YzFjOTE3YzkzYjYwY2I4YjJlNGQ4Mjk2MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@multimania.com", "date": "2002-07-17T18:00:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-07-17T18:00:35Z"}, "message": "re PR rtl-optimization/6713 (Regression wrt 3.0.4: g++ -O2 leads to seg fault at run time)\n\n PR optimization/6713\n * loop.c (loop_givs_rescan): Explicitly delete the insn that\n sets a non-replaceable giv after issuing the new one.\n\nCo-Authored-By: Glen Nakamura <glen@imodulo.com>\n\nFrom-SVN: r55539", "tree": {"sha": "350a578d0f7c7d1813548df578d08e605c0b1894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/350a578d0f7c7d1813548df578d08e605c0b1894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/comments", "author": null, "committer": null, "parents": [{"sha": "90888283784269660b9143890d880642fd5becbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90888283784269660b9143890d880642fd5becbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90888283784269660b9143890d880642fd5becbf"}], "stats": {"total": 137, "additions": 135, "deletions": 2}, "files": [{"sha": "da5ebc2ba2c110091e1e9fb7278323e45bb054bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "patch": "@@ -1,3 +1,10 @@\n+2002-06-17  Eric Botcazou <ebotcazou@multimania.com>\n+            Glen Nakamura <glen@imodulo.com>\n+\n+\tPR optimization/6713\n+\t* loop.c (loop_givs_rescan): Explicitly delete the insn that\n+\tsets a non-replaceable giv after issuing the new one.\n+\n 2002-07-17  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cppexp.c (cpp_interpret_integer, append_digit, parse_defined,"}, {"sha": "5966324dc34dde9bcf670481340d906a580032d4", "filename": "gcc/loop.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "patch": "@@ -4874,10 +4874,20 @@ loop_givs_rescan (loop, bl, reg_map)\n \t}\n       else\n \t{\n+\t  rtx original_insn = v->insn;\n+\n \t  /* Not replaceable; emit an insn to set the original giv reg from\n \t     the reduced giv, same as above.  */\n-\t  loop_insn_emit_after (loop, 0, v->insn,\n-\t\t\t\tgen_move_insn (v->dest_reg, v->new_reg));\n+\t  v->insn = loop_insn_emit_after (loop, 0, original_insn,\n+\t\t\t\t\t  gen_move_insn (v->dest_reg,\n+\t\t\t\t\t\t\t v->new_reg));\n+\n+\t  /* The original insn may have a REG_EQUAL note.  This note is\n+\t     now incorrect and may result in invalid substitutions later.\n+\t     We could just delete the note, but we know that the entire\n+\t     insn is dead, so we might as well save ourselves the bother\n+\t     and remove the whole thing.  */\n+\t  delete_insn (original_insn);\n \t}\n \n       /* When a loop is reversed, givs which depend on the reversed"}, {"sha": "c844ddb34d346e7d353ffc83f7873033a9a99282", "filename": "gcc/testsuite/g++.dg/opt/pr6713.C", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr6713.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a73cfecf88d38c1c917c93b60cb8b2e4d82960/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr6713.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr6713.C?ref=f1a73cfecf88d38c1c917c93b60cb8b2e4d82960", "patch": "@@ -0,0 +1,116 @@\n+// PR optimization/6713\n+// This testcase segfaulted on x86 because a dangling REG_EQUAL note\n+// resulted in incorrect substitutions later.\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+template<typename _CharT> class basic_iterator\n+{\n+  public:\n+    basic_iterator(_CharT* _p) : _M_current(_p) {}\n+    basic_iterator& operator++() { ++_M_current; return *this; }\n+    _CharT& operator*() const { return *_M_current; }\n+    bool operator!=(basic_iterator &_rhs) { return _M_current != _rhs._M_current; }\n+\n+  private:\n+    _CharT* _M_current;\n+};\n+\n+template<typename _CharT> class basic_string\n+{\n+  public:\n+    typedef unsigned int size_type;\n+    typedef basic_iterator<_CharT> iterator;\n+\n+  private:\n+    struct _Rep\n+    {\n+      size_type _M_length;\n+      size_type _M_capacity;\n+      int _M_references;\n+\n+      bool _M_is_leaked() const { return _M_references < 0; }\n+      bool _M_is_shared() const { return _M_references > 0; }\n+      void _M_set_leaked() { _M_references = -1; }\n+      void _M_set_sharable() { _M_references = 0; }\n+    };\n+\n+    struct _Rep _M_rep;\n+\n+    struct _Alloc_hider\n+    {\n+      _CharT _raw[16];\n+      _CharT* _M_p;\n+    };\n+\n+    mutable _Alloc_hider _M_dataplus;\n+\n+    _CharT* _M_data() const { return _M_dataplus._M_p; }\n+\n+    void _M_leak() { if (!_M_rep._M_is_leaked()) _M_leak_hard(); }\n+\n+    static int count;\n+\n+    static void _M_leak_hard();\n+\n+  public:\n+    explicit basic_string(const _CharT* __s);\n+\n+    iterator begin() { _M_leak(); return iterator(_M_data()); }\n+\n+    iterator end() { _M_leak(); return iterator(_M_data() + this->size()); }\n+\n+    size_type size() const { return _M_rep._M_length; }\n+};\n+\n+template<typename _CharT> basic_string<_CharT>::\n+basic_string(const _CharT* __s)\n+{\n+  int i;\n+\n+  for (i=0; i<15; i++) {\n+    if (!__s[i])\n+      break;\n+\n+    _M_dataplus._raw[i] = __s[i];\n+  }\n+\n+  _M_dataplus._raw[i] = 0;\n+  _M_dataplus._M_p = _M_dataplus._raw;\n+\n+  _M_rep._M_length = i;\n+  _M_rep._M_capacity = i;\n+  _M_rep._M_references = 1;\n+}     \n+\n+template<typename _CharT> int basic_string<_CharT>::count = 0;\n+\n+template<typename _CharT> void basic_string<_CharT>::\n+_M_leak_hard()\n+{\n+  count++;\n+}\n+\n+typedef basic_string<char> string;\n+\n+\n+int isspa(int ch)\n+{\n+  return 0;\n+}\n+\n+void foo(string& str)\n+{\n+  string::iterator it = str.begin();\n+  string::iterator stop = str.end();\n+\n+  for (; it != stop; ++it)\n+    if (isspa(*it))\n+      break;\n+}\n+\n+int main()\n+{\n+  string str(\"test\");\n+  foo(str);\n+}"}]}