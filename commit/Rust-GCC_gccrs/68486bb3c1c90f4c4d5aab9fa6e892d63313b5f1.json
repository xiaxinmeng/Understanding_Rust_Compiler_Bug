{"sha": "68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg0ODZiYjNjMWM5MGY0YzRkNWFhYjlmYTZlODkyZDYzMzEzYjVmMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-01-24T15:19:40Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2006-01-24T15:19:40Z"}, "message": "genautomata.c (process_state_for_insn_equiv_partition): Use xcalloc for insn_arcs_array.\n\n\t* genautomata.c (process_state_for_insn_equiv_partition):\n\tUse xcalloc for insn_arcs_array.\n\t* vec.h (DEF_VEC_ALLOC_FUNC_I): New set of templates.\n\t(DEF_VEC_ALLOC_I): Use it, not DEF_VEC_ALLOC_FUNC_P.\n\nFrom-SVN: r110172", "tree": {"sha": "310851c47ee12a55d837dbf6fd1ad78bfc539dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/310851c47ee12a55d837dbf6fd1ad78bfc539dcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11daaf60a6f71bd90f95883f41a222f8fe0588f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11daaf60a6f71bd90f95883f41a222f8fe0588f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11daaf60a6f71bd90f95883f41a222f8fe0588f8"}], "stats": {"total": 96, "additions": 94, "deletions": 2}, "files": [{"sha": "3eeb33f830707634fcf17487f38e618d36ed82c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "patch": "@@ -1,3 +1,10 @@\n+2006-01-24  Zack Weinberg  <zackw@panix.com>\n+\n+\t* genautomata.c (process_state_for_insn_equiv_partition):\n+\tUse xcalloc for insn_arcs_array.\n+\t* vec.h (DEF_VEC_ALLOC_FUNC_I): New set of templates.\n+\t(DEF_VEC_ALLOC_I): Use it, not DEF_VEC_ALLOC_FUNC_P.\n+\n 2006-01-24  Richard Henderson  <rth@redhat.com>\n \n \t* genextract.c (VEC_safe_set_locstr): Take VEC by reference;"}, {"sha": "e546f479ac0b48f6b6f3aa80e5a5d5683d1bf2cc", "filename": "gcc/genautomata.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "patch": "@@ -6162,7 +6162,7 @@ static void\n process_state_for_insn_equiv_partition (state_t state)\n {\n   arc_t arc;\n-  arc_t *insn_arcs_array = xmalloc (description->insns_num * sizeof(arc_t));\n+  arc_t *insn_arcs_array = xcalloc (description->insns_num, sizeof(arc_t));\n \n   /* Process insns of the arcs.  */\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))"}, {"sha": "09d0f0ac877ef9eb5785da162ef5e6f7a0a7721d", "filename": "gcc/vec.h", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=68486bb3c1c90f4c4d5aab9fa6e892d63313b5f1", "patch": "@@ -479,7 +479,7 @@ DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n #define DEF_VEC_ALLOC_I(T,A)\t\t\t\t\t\t  \\\n VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t\t  \\\n+DEF_VEC_ALLOC_FUNC_I(T,A)\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n #endif\n \n@@ -1032,4 +1032,89 @@ static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n   return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n \t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n }\n+\n+#define DEF_VEC_ALLOC_FUNC_I(T,A)\t\t\t\t\t  \\\n+static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n+     (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  /* We must request exact size allocation, hence the negation.  */\t  \\\n+  return (VEC(T,A) *) vec_##A##_o_reserve (NULL, -alloc_,\t\t  \\\n+                                           offsetof (VEC(T,A),base.vec),  \\\n+\t\t\t\t\t   sizeof (T)\t\t\t  \\\n+                                           PASS_MEM_STAT);\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n+  VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (len_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      /* We must request exact size allocation, hence the negation. */\t  \\\n+      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve\t\t\t  \\\n+\t\t\t       (NULL, -len_,\t\t\t\t  \\\n+\t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n+\t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      new_vec_->base.num = len_;\t\t\t\t\t  \\\n+      memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+  return new_vec_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n+     (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  if (*vec_)\t\t\t\t\t\t\t\t  \\\n+    vec_##A##_free (*vec_);\t\t\t\t\t\t  \\\n+  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (T,A,reserve)\t   \t    \t\t\t  \\\n+     (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  int extend = !VEC_OP (T,base,space) (VEC_BASE(*vec_),\t\t\t  \\\n+\t\t\t\t       alloc_ < 0 ? -alloc_ : alloc_\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (extend)\t\t\t\t\t\t\t\t  \\\n+    *vec_ = (VEC(T,A) *) vec_##A##_o_reserve (*vec_, alloc_,\t\t  \\\n+\t\t\t   \t\t      offsetof (VEC(T,A),base.vec),\\\n+ \t\t\t\t\t      sizeof (T)\t\t  \\\n+\t\t\t   \t\t      PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return extend;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (T,A,safe_grow)\t\t\t\t  \\\n+     (VEC(T,A) **vec_, int size_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (size_ >= 0\t\t\t\t\t\t  \\\n+\t      && VEC_OP(T,base,length) VEC_BASE(*vec_) <= (unsigned)size_, \\\n+\t\t\t\t\t\t \"grow\", T, A);\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, (int)(*vec_ ? VEC_BASE(*vec_)->num : 0) - size_ \\\n+\t\t\tVEC_CHECK_PASS PASS_MEM_STAT);\t\t\t  \\\n+  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+  VEC_BASE (*vec_)->num = size_;\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,A,safe_push)\t\t\t\t\t  \\\n+     (VEC(T,A) **vec_, const T obj_ VEC_CHECK_DECL MEM_STAT_DECL)\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (T,base,quick_push) (VEC_BASE(*vec_), obj_ VEC_CHECK_PASS);  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n+     (VEC(T,A) **vec_, unsigned ix_, const T obj_\t\t\t  \\\n+ \t\tVEC_CHECK_DECL MEM_STAT_DECL)\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_OP (T,A,reserve) (vec_, 1 VEC_CHECK_PASS PASS_MEM_STAT);\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  return VEC_OP (T,base,quick_insert) (VEC_BASE(*vec_), ix_, obj_\t  \\\n+\t\t\t\t       VEC_CHECK_PASS);\t\t\t  \\\n+}\n+\n #endif /* GCC_VEC_H */"}]}