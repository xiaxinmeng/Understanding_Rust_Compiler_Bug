{"sha": "56031823208468f061281130a7e67d6ccf1b5fd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYwMzE4MjMyMDg0NjhmMDYxMjgxMTMwYTdlNjdkNmNjZjFiNWZkMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-11-29T01:33:07Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-11-29T01:33:07Z"}, "message": "libgcc2.c (__register_exceptions): Find max ending of a segment for end, not min.\n\n        * libgcc2.c (__register_exceptions): Find max ending of a segment for\n        end, not min.\n        * libgcc2.c (__unwind_function): New function to support stack\n        unwinding on i[34]86 for g++ exception handling.\n\nFrom-SVN: r8571", "tree": {"sha": "73402b2bca23eb75b3ea14960fd1b2d5ee1479f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73402b2bca23eb75b3ea14960fd1b2d5ee1479f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56031823208468f061281130a7e67d6ccf1b5fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56031823208468f061281130a7e67d6ccf1b5fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56031823208468f061281130a7e67d6ccf1b5fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56031823208468f061281130a7e67d6ccf1b5fd2/comments", "author": null, "committer": null, "parents": [{"sha": "db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b"}], "stats": {"total": 28, "additions": 27, "deletions": 1}, "files": [{"sha": "5df5278c8bdae5d29eec27ca7bdd255ef9efc602", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56031823208468f061281130a7e67d6ccf1b5fd2/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56031823208468f061281130a7e67d6ccf1b5fd2/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=56031823208468f061281130a7e67d6ccf1b5fd2", "patch": "@@ -2254,13 +2254,39 @@ __register_exceptions (exception_table *table)\n     {\n       if (range->start < node->start)\n \tnode->start = range->start;\n-      if (range->end < node->end)\n+      if (range->end > node->end)\n \tnode->end = range->end;\n     }\n \n   node->next = exception_table_list;\n   exception_table_list = node;\n }\n+\n+#ifdef __i386\n+void\n+__unwind_function(void *ptr)\n+{\n+  asm(\"movl 8(%esp),%ecx\");\n+  /* Undo current frame */\n+  asm(\"movl %ebp,%esp\");\n+  asm(\"popl %ebp\");\n+  asm(\"# like ret, but stay here\");\n+  asm(\"addl $4,%esp\");\n+  \n+  /* Now, undo previous frame. */\n+  /* This is a test routine, as we have to dynamically probe to find out\n+     what to pop for certain, this is just a guess. */\n+  asm(\"leal -16(%ebp),%esp\");\n+  asm(\"pop %eax # really for popl %ebx\");\n+  asm(\"pop %eax # really for popl %esi\");\n+  asm(\"pop %eax # really for popl %edi\");\n+  asm(\"movl %ebp,%esp\");\n+  asm(\"popl %ebp\");\n+\n+  asm(\"movl %ecx,0(%esp)\");\n+  asm(\"ret\");\n+}\n+#endif\n #endif /* L_eh */\n \f\n #ifdef L_pure"}]}