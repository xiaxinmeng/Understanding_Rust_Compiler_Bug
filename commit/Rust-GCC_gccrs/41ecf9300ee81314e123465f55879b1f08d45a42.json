{"sha": "41ecf9300ee81314e123465f55879b1f08d45a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFlY2Y5MzAwZWU4MTMxNGUxMjM0NjVmNTU4NzliMWYwOGQ0NWE0Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-01-06T00:56:21Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-01-06T00:56:21Z"}, "message": "natClass.cc (getMethod): Compute offset relative to `klass's methods table, not `this's table.\n\n\t* java/lang/natClass.cc (getMethod): Compute offset relative to\n\t`klass's methods table, not `this's table.\n\n\t* java/lang/reflect/natMethod.cc (_Jv_CallNonvirtualMethodA):\n\tIn unwrapping/widening case, check whether `k' is null, not\n\twhether it is primitive.  Initialize `num' from `argelts', not\n\t`paramelts'.  Correct create and pass arguments to ffi_call.\n\tDon't let presence of `this' argument affect index used to look in\n\targument arrays.\n\t(COPY): Set appropriate element in `values' vector.\n\nFrom-SVN: r31253", "tree": {"sha": "1965e52244bebcbaf8849bb44cebccffca987422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1965e52244bebcbaf8849bb44cebccffca987422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41ecf9300ee81314e123465f55879b1f08d45a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ecf9300ee81314e123465f55879b1f08d45a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ecf9300ee81314e123465f55879b1f08d45a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ecf9300ee81314e123465f55879b1f08d45a42/comments", "author": null, "committer": null, "parents": [{"sha": "fe5a58103115ff22b1707fb1f561eabe8dcc3f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe5a58103115ff22b1707fb1f561eabe8dcc3f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe5a58103115ff22b1707fb1f561eabe8dcc3f39"}], "stats": {"total": 63, "additions": 38, "deletions": 25}, "files": [{"sha": "e0ffb0e9ed9dd2c73e21eeb11982779f02ae0d99", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ecf9300ee81314e123465f55879b1f08d45a42/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ecf9300ee81314e123465f55879b1f08d45a42/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=41ecf9300ee81314e123465f55879b1f08d45a42", "patch": "@@ -1,5 +1,16 @@\n 2000-01-05  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/lang/natClass.cc (getMethod): Compute offset relative to\n+\t`klass's methods table, not `this's table.\n+\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallNonvirtualMethodA):\n+\tIn unwrapping/widening case, check whether `k' is null, not\n+\twhether it is primitive.  Initialize `num' from `argelts', not\n+\t`paramelts'.  Correct create and pass arguments to ffi_call.\n+\tDon't let presence of `this' argument affect index used to look in\n+\targument arrays.\n+\t(COPY): Set appropriate element in `values' vector.\n+\n \t* java/lang/natClass.cc: Include <gcj/method.h>.\n \n \t* java/lang/Class.h (_getMethods): Correctly declare as private,"}, {"sha": "533f7abf102c51e079761666ccfc17f2fc4bc28a", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ecf9300ee81314e123465f55879b1f08d45a42/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ecf9300ee81314e123465f55879b1f08d45a42/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=41ecf9300ee81314e123465f55879b1f08d45a42", "patch": "@@ -477,7 +477,8 @@ java::lang::Class::getMethod (jstring name, JArray<jclass> *param_types)\n \t\tbreak;\n \n \t      Method *rmethod = new Method ();\n-\t      rmethod->offset = (char*) (&klass->methods[i]) - (char*) methods;\n+\t      rmethod->offset = ((char *) (&klass->methods[i])\n+\t\t\t\t - (char *) klass->methods);\n \t      rmethod->declaringClass = klass;\n \t      return rmethod;\n \t    }"}, {"sha": "14708d1346848fae591aa5d89f693e386c21e9cf", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ecf9300ee81314e123465f55879b1f08d45a42/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ecf9300ee81314e123465f55879b1f08d45a42/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=41ecf9300ee81314e123465f55879b1f08d45a42", "patch": "@@ -374,21 +374,21 @@ _Jv_CallNonvirtualMethodA (jobject obj,\n       size += sizeof (jobject);\n     }\n \n-  for (; i < param_count; ++i)\n+  for (int arg = 0; i < param_count; ++i, ++arg)\n     {\n-      jclass k = argelts[i] ? argelts[i]->getClass() : NULL;\n+      jclass k = argelts[arg] ? argelts[arg]->getClass() : NULL;\n       argtypes[i] = get_ffi_type (k);\n-      if (paramelts[i]->isPrimitive())\n+      if (paramelts[arg]->isPrimitive())\n \t{\n-\t  if (! argelts[i]\n-\t      || ! k->isPrimitive ()\n-\t      || ! can_widen (k, paramelts[i]))\n+\t  if (! argelts[arg]\n+\t      || ! k\n+\t      || ! can_widen (k, paramelts[arg]))\n \t    JvThrow (new java::lang::IllegalArgumentException);\n-\t  size += paramelts[i]->size();\n+\t  size += paramelts[arg]->size();\n \t}\n       else\n \t{\n-\t  if (argelts[i] && ! paramelts[i]->isAssignableFrom (k))\n+\t  if (argelts[arg] && ! paramelts[arg]->isAssignableFrom (k))\n \t    JvThrow (new java::lang::IllegalArgumentException);\n \t  size += sizeof (jobject);\n \t}\n@@ -401,13 +401,14 @@ _Jv_CallNonvirtualMethodA (jobject obj,\n       // FIXME: throw some kind of VirtualMachineError here.\n     }\n \n-  char *values = (char *) alloca (size);\n-  char *p = values;\n+  char *p = (char *) alloca (size);\n+  void **values = (void **) alloca (param_count * sizeof (void *));\n \n #define COPY(Where, What, Type) \\\n   do { \\\n     Type val = (What); \\\n     memcpy ((Where), &val, sizeof (Type)); \\\n+    values[i] = (Where); \\\n     Where += sizeof (Type); \\\n   } while (0)\n \n@@ -418,30 +419,30 @@ _Jv_CallNonvirtualMethodA (jobject obj,\n       ++i;\n     }\n \n-  for (; i < param_count; ++i)\n+  for (int arg = 0; i < param_count; ++i, ++arg)\n     {\n-      java::lang::Number *num = (java::lang::Number *) paramelts[i];\n-      if (paramelts[i] == JvPrimClass (byte))\n+      java::lang::Number *num = (java::lang::Number *) argelts[arg];\n+      if (paramelts[arg] == JvPrimClass (byte))\n \tCOPY (p, num->byteValue(), jbyte);\n-      else if (paramelts[i] == JvPrimClass (short))\n+      else if (paramelts[arg] == JvPrimClass (short))\n \tCOPY (p, num->shortValue(), jshort);\n-      else if (paramelts[i] == JvPrimClass (int))\n+      else if (paramelts[arg] == JvPrimClass (int))\n \tCOPY (p, num->intValue(), jint);\n-      else if (paramelts[i] == JvPrimClass (long))\n+      else if (paramelts[arg] == JvPrimClass (long))\n \tCOPY (p, num->longValue(), jlong);\n-      else if (paramelts[i] == JvPrimClass (float))\n+      else if (paramelts[arg] == JvPrimClass (float))\n \tCOPY (p, num->floatValue(), jfloat);\n-      else if (paramelts[i] == JvPrimClass (double))\n+      else if (paramelts[arg] == JvPrimClass (double))\n \tCOPY (p, num->doubleValue(), jdouble);\n-      else if (paramelts[i] == JvPrimClass (boolean))\n-\tCOPY (p, ((java::lang::Boolean *) argelts[i])->booleanValue(),\n+      else if (paramelts[arg] == JvPrimClass (boolean))\n+\tCOPY (p, ((java::lang::Boolean *) argelts[arg])->booleanValue(),\n \t      jboolean);\n-      else if (paramelts[i] == JvPrimClass (char))\n-\tCOPY (p, ((java::lang::Character *) argelts[i])->charValue(), jchar);\n+      else if (paramelts[arg] == JvPrimClass (char))\n+\tCOPY (p, ((java::lang::Character *) argelts[arg])->charValue(), jchar);\n       else\n \t{\n-\t  JvAssert (! paramelts[i]->isPrimitive());\n-\t  COPY (p, argelts[i], jobject);\n+\t  JvAssert (! paramelts[arg]->isPrimitive());\n+\t  COPY (p, argelts[arg], jobject);\n \t}\n     }\n "}]}