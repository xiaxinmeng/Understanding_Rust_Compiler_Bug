{"sha": "aca8570e11d28b8c33d26593df6d4725a6140aab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhODU3MGUxMWQyOGI4YzMzZDI2NTkzZGY2ZDQ3MjVhNjE0MGFhYg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-07-26T16:45:43Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-07-26T16:45:43Z"}, "message": "PR tree-optimization/86043 - strlen after memcpy partially overwriting a string not optimized\n\nPR tree-optimization/86043 - strlen after memcpy partially overwriting a string not optimized\nPR tree-optimization/86042 - missing strlen optimization after second strcpy\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/86043\n\tPR tree-optimization/86042\n\t* tree-ssa-strlen.c (handle_builtin_memcpy): Handle strict overlaps.\n\t(get_string_cst_length): Rename...\n\t(get_min_string_length): ...to this.  Add argument.\n\t(handle_char_store): Extend to handle multi-character stores by\n\tMEM_REF.\n\t* tree.c (initializer_zerop): Use new argument.  Handle MEM_REF.\n\t* tree.h (initializer_zerop): Add argument.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/86043\n\tPR tree-optimization/86042\n\t* gcc/testsuite/gcc.dg/attr-nonstring-2.c: Xfail test cases due to\n\tpr86688.\n\t* gcc.dg/strlenopt-44.c: New test.\n\nFrom-SVN: r263018", "tree": {"sha": "bea2270f62332f8d85e1bcd3adcb0c246cb32648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bea2270f62332f8d85e1bcd3adcb0c246cb32648"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aca8570e11d28b8c33d26593df6d4725a6140aab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca8570e11d28b8c33d26593df6d4725a6140aab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca8570e11d28b8c33d26593df6d4725a6140aab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca8570e11d28b8c33d26593df6d4725a6140aab/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b8b1f5997e7f16713be5c05e7fd40c122fa9381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b8b1f5997e7f16713be5c05e7fd40c122fa9381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b8b1f5997e7f16713be5c05e7fd40c122fa9381"}], "stats": {"total": 357, "additions": 306, "deletions": 51}, "files": [{"sha": "f5e8d62c7b9acce141f73ab896af611962644c0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -1,3 +1,15 @@\n+2018-07-26  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86043\n+\tPR tree-optimization/86042\n+\t* tree-ssa-strlen.c (handle_builtin_memcpy): Handle strict overlaps.\n+\t(get_string_cst_length): Rename...\n+\t(get_min_string_length): ...to this.  Add argument.\n+\t(handle_char_store): Extend to handle multi-character stores by\n+\tMEM_REF.\n+\t* tree.c (initializer_zerop): Use new argument.  Handle MEM_REF.\n+\t* tree.h (initializer_zerop): Add argument.\n+\n 2018-07-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/86660"}, {"sha": "30f528eea86cc9f617150159c82bc71ec861a7a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -1,3 +1,11 @@\n+2018-07-26  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86043\n+\tPR tree-optimization/86042\n+\t* gcc/testsuite/gcc.dg/attr-nonstring-2.c: Xfail test cases due to\n+\tpr86688.\n+\t* gcc.dg/strlenopt-44.c: New test.\n+\n 2018-07-26  Martin Liska  <mliska@suse.cz>\n \n         PR gcov-profile/86536"}, {"sha": "246a3729a2afefc1a771a555b13822006086d482", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -73,8 +73,8 @@ void test_strnlen_string_cst (void)\n   T (3, \"12\",  3, 1);\n   T (3, \"12\",  3, 9);\n   T (3, \"123\", 3, 1);\n-  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n-  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 9\" } */\n+  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" \"bug 86688\" { xfail *-*-* } } */\n+  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 9\" \"bug 86688\" { xfail *-*-* } } */\n \n   T (5, \"1\",   2, 1);\n   T (5, \"1\",   2, 2);\n@@ -110,6 +110,6 @@ void test_strnlen_string_range (void)\n {\n   T (3, \"1\",   2, UR (0, 1));\n   T (3, \"1\",   2, UR (3, 9));\n-  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[4, 5]\" } */\n-  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[5, 9]\" } */\n+  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[4, 5]\" \"bug 86688\" { xfail *-*-* } } */\n+  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[5, 9]\" \"bug 86688\" { xfail *-*-* } } */\n }"}, {"sha": "c38e7918f8bc2d71b1ad91a4adbd57245294e18e", "filename": "gcc/testsuite/gcc.dg/strlenopt-54.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-54.c?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -0,0 +1,109 @@\n+/* PR tree-optimization/86042 - missing strlen optimization after second strcpy\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to function named\n+   call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+void elim_after_duplicate_strcpy (void)\n+{\n+#define T(N, assign, off, str, r0, r1)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    char a[N];\t\t\t\t\t\\\n+    strcpy (a, assign);\t\t\t\t\\\n+    unsigned n0 = strlen (a);\t\t\t\\\n+    strcpy (a + off, str);\t\t\t\\\n+    unsigned n1 = strlen (a);\t\t\t\\\n+    ELIM (n0 == r0 && n1 == r1);\t\t\\\n+  } while (0)\n+\n+  T (2, \"\",   0, \"1\",   0, 1);\n+\n+  T (2, \"1\",  0, \"2\",   1, 1);\n+  T (2, \"1\",  1, \"\",    1, 1);\n+\n+  T (3, \"\\0\", 0, \"1\",   0, 1);\n+  T (3, \"1\",  1, \"2\",   1, 2);\n+\n+  T (3, \"12\", 0, \"23\",  2, 2);\n+  T (3, \"12\", 1, \"3\",   2, 2);\n+  T (3, \"12\", 2, \"\",    2, 2);\n+\n+  T (4, \"1\",   1, \"23\",  1, 3);\n+  T (4, \"12\",  1, \"23\",  2, 3);\n+\n+  T (4, \"123\", 0, \"234\", 3, 3);\n+  T (4, \"123\", 1, \"34\",  3, 3);\n+  T (4, \"123\", 2, \"4\",   3, 3);\n+  T (4, \"123\", 3, \"\",    3, 3);\n+\n+  T (5, \"1234\", 0, \"1\",    4, 1);\n+  T (5, \"1234\", 0, \"12\",   4, 2);\n+  T (5, \"1234\", 0, \"123\",  4, 3);\n+  T (5, \"1234\", 0, \"1234\", 4, 4);\n+\n+  T (5, \"123\",  1, \"234\", 3, 4);\n+  T (6, \"123\",  2, \"234\", 3, 5);\n+}\n+\n+void elim_after_init_memcpy (void)\n+{\n+#undef T\n+#define T(init, off, str, n, res)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    char a[] = init;\t\t\t\t\\\n+    memcpy (a + off, str, n);\t\t\t\\\n+    ELIM (strlen (a) == res);\t\t\t\\\n+  } while (0)\n+\n+  T (\"\\0\",   0, \"1\",    2, 1);\n+  T (\"\\0\\0\", 0, \"12\",   3, 2);\n+\n+#define INIT { '1', '2', '3', '4' }\n+  T (INIT,   0, \"\",     1, 0);\n+  T (INIT,   0, \"1\",    2, 1);\n+  T (INIT,   0, \"12\",   3, 2);\n+  T (INIT,   0, \"123\",  4, 3);\n+\n+  T (\"1234\", 0, \"2\",    1, 4);\n+  T (\"1234\", 0, \"23\",   2, 4);\n+  T (\"1234\", 0, \"234\",  3, 4);\n+  T (\"1234\", 0, \"2345\", 4, 4);\n+  T (\"1234\", 0, \"2345\", 5, 4);\n+\n+  T (\"1234\", 1, \"2\",    1, 4);\n+  T (\"1234\", 1, \"23\",   2, 4);\n+  T (\"1234\", 1, \"234\",  3, 4);\n+  T (\"1234\", 1, \"234\",  4, 4);\n+\n+  T (\"1234\", 2, \"3\",    1, 4);\n+  T (\"1234\", 2, \"3\",    2, 3);\n+  T (\"1234\", 2, \"34\",   2, 4);\n+  T (\"1234\", 2, \"34\",   3, 4);\n+\n+  T (\"12\\00034\", 0, \"1\", 1, 2);\n+  T (\"12\\00034\", 0, \"1\", 2, 1);\n+\n+  T (\"AB\\000CD\", 0, \"ab\", 2, 2);\n+  T (\"AB\\000CD\", 0, \"ab\", 3, 2);\n+  T (\"AB\\000CD\", 0, \"ab\\000c\", 4, 2);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"optimized\" } } */"}, {"sha": "eca88a56f72db73cc0e00f47fb83d585048d74f3", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 84, "deletions": 25, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -2326,6 +2326,18 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       full_string_p = clen > nonzero_chars;\n     }\n \n+  if (!full_string_p\n+      && olddsi\n+      && olddsi->nonzero_chars\n+      && TREE_CODE (olddsi->nonzero_chars) == INTEGER_CST\n+      && tree_int_cst_le (newlen, olddsi->nonzero_chars))\n+    {\n+      /* The SRC substring being written strictly overlaps\n+\t a subsequence of the existing string OLDDSI.  */\n+      newlen = olddsi->nonzero_chars;\n+      full_string_p = olddsi->full_string_p;\n+    }\n+\n   if (olddsi != NULL && TREE_CODE (len) == SSA_NAME)\n     adjust_last_stmt (olddsi, stmt, false);\n \n@@ -3131,11 +3143,25 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n }\n \n /* If RHS, either directly or indirectly, refers to a string of constant\n-   length, return it.  Otherwise return a negative value.  */\n+   length, return the length.  Otherwise, if it refers to a character\n+   constant, return 1 if the constant is non-zero and 0 if it is nul.\n+   Otherwise, return a negative value.  */\n \n static HOST_WIDE_INT\n-get_string_cst_length (tree rhs)\n+get_min_string_length (tree rhs, bool *full_string_p)\n {\n+  if (TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE)\n+    {\n+      if (tree_expr_nonzero_p (rhs))\n+\t{\n+\t  *full_string_p = false;\n+\t  return 1;\n+\t}\n+\n+      *full_string_p = true;\n+      return 0;\n+    }\n+\n   if (TREE_CODE (rhs) == MEM_REF\n       && integer_zerop (TREE_OPERAND (rhs, 1)))\n     {\n@@ -3152,9 +3178,11 @@ get_string_cst_length (tree rhs)\n \t\t{\n \t\t  strinfo *si = get_strinfo (idx);\n \t\t  if (si\n-\t\t      && si->full_string_p\n \t\t      && tree_fits_shwi_p (si->nonzero_chars))\n-\t\t    return tree_to_shwi (si->nonzero_chars);\n+\t\t    {\n+\t\t      *full_string_p = si->full_string_p;\n+\t\t      return tree_to_shwi (si->nonzero_chars);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -3165,12 +3193,17 @@ get_string_cst_length (tree rhs)\n     rhs = DECL_INITIAL (rhs);\n \n   if (rhs && TREE_CODE (rhs) == STRING_CST)\n-    return strlen (TREE_STRING_POINTER (rhs));\n+    {\n+      *full_string_p = true;\n+      return strlen (TREE_STRING_POINTER (rhs));\n+    }\n \n   return -1;\n }\n \n-/* Handle a single character store.  */\n+/* Handle a single or multiple character store either by single\n+   character assignment or by multi-character assignment from\n+   MEM_REF.  */\n \n static bool\n handle_char_store (gimple_stmt_iterator *gsi)\n@@ -3208,16 +3241,23 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \tsi = get_strinfo (idx);\n     }\n \n-  bool storing_zero_p = initializer_zerop (rhs);\n-  bool storing_nonzero_p = !storing_zero_p && tree_expr_nonzero_p (rhs);\n+  /* STORING_NONZERO_P is true iff not all stored characters are zero.\n+     STORING_ALL_ZEROS_P is true iff all stored characters are zero.\n+     Both are false when it's impossible to determine which is true.  */\n+  bool storing_nonzero_p;\n+  bool storing_all_zeros_p = initializer_zerop (rhs, &storing_nonzero_p);\n+  if (!storing_nonzero_p)\n+    storing_nonzero_p = tree_expr_nonzero_p (rhs);\n+  bool full_string_p = storing_all_zeros_p;\n+\n   /* Set to the length of the string being assigned if known.  */\n   HOST_WIDE_INT rhslen;\n \n   if (si != NULL)\n     {\n       int cmp = compare_nonzero_chars (si, offset);\n       gcc_assert (offset == 0 || cmp >= 0);\n-      if (storing_zero_p && cmp == 0 && si->full_string_p)\n+      if (storing_all_zeros_p && cmp == 0 && si->full_string_p)\n \t{\n \t  /* When overwriting a '\\0' with a '\\0', the store can be removed\n \t     if we know it has been stored in the current function.  */\n@@ -3260,17 +3300,25 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t  gsi_next (gsi);\n \t  return false;\n \t}\n-      else if (storing_zero_p || storing_nonzero_p || (offset != 0 && cmp > 0))\n+      else if (storing_all_zeros_p || storing_nonzero_p || (offset != 0 && cmp > 0))\n \t{\n-\t  /* When storing_nonzero_p, we know that the string now starts\n-\t     with OFFSET + 1 nonzero characters, but don't know whether\n-\t     there's a following nul terminator.\n+\t  /* When STORING_NONZERO_P, we know that the string will start\n+\t     with at least OFFSET + 1 nonzero characters.  If storing\n+\t     a single character, set si->NONZERO_CHARS to the result.\n+\t     If storing multiple characters, try to determine the number\n+\t     of leading non-zero characters and set si->NONZERO_CHARS to\n+\t     the result instead.\n \n-\t     When storing_zero_p, we know that the string is now OFFSET\n-\t     characters long.\n+\t     When STORING_ALL_ZEROS_P, we know that the string is now\n+\t     OFFSET characters long.\n \n \t     Otherwise, we're storing an unknown value at offset OFFSET,\n \t     so need to clip the nonzero_chars to OFFSET.  */\n+\t  bool full_string_p = storing_all_zeros_p;\n+\t  HOST_WIDE_INT len = (storing_nonzero_p\n+\t\t\t       ? get_min_string_length (rhs, &full_string_p)\n+\t\t\t       : 1);\n+\n \t  location_t loc = gimple_location (stmt);\n \t  tree oldlen = si->nonzero_chars;\n \t  if (cmp == 0 && si->full_string_p)\n@@ -3280,11 +3328,14 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t    adjust_last_stmt (si, stmt, false);\n \t  si = unshare_strinfo (si);\n \t  if (storing_nonzero_p)\n-\t    si->nonzero_chars = build_int_cst (size_type_node, offset + 1);\n+\t    {\n+\t      gcc_assert (len >= 0);\n+\t      si->nonzero_chars = build_int_cst (size_type_node, offset + len);\n+\t    }\n \t  else\n \t    si->nonzero_chars = build_int_cst (size_type_node, offset);\n-\t  si->full_string_p = storing_zero_p;\n-\t  if (storing_zero_p\n+\t  si->full_string_p = full_string_p;\n+\t  if (storing_all_zeros_p\n \t      && ssaname\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n \t    si->endptr = ssaname;\n@@ -3304,7 +3355,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t    si->prev = 0;\n \t}\n     }\n-  else if (idx == 0 && (storing_zero_p || storing_nonzero_p))\n+  else if (idx == 0 && (storing_all_zeros_p || storing_nonzero_p))\n     {\n       if (ssaname)\n \tidx = new_stridx (ssaname);\n@@ -3313,10 +3364,17 @@ handle_char_store (gimple_stmt_iterator *gsi)\n       if (idx != 0)\n \t{\n \t  tree ptr = (ssaname ? ssaname : build_fold_addr_expr (lhs));\n-\t  tree len = storing_nonzero_p ? size_one_node : size_zero_node;\n-\t  si = new_strinfo (ptr, idx, len, storing_zero_p);\n+\t  HOST_WIDE_INT slen = (storing_all_zeros_p\n+\t\t\t\t? 0\n+\t\t\t\t: (storing_nonzero_p\n+\t\t\t\t   ? get_min_string_length (rhs, &full_string_p)\n+\t\t\t\t   : -1));\n+\t  tree len = (slen <= 0\n+\t\t      ? size_zero_node\n+\t\t      : build_int_cst (size_type_node, slen));\n+\t  si = new_strinfo (ptr, idx, len, slen >= 0 && full_string_p);\n \t  set_strinfo (idx, si);\n-\t  if (storing_zero_p\n+\t  if (storing_all_zeros_p\n \t      && ssaname\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n \t    si->endptr = ssaname;\n@@ -3325,7 +3383,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t}\n     }\n   else if (idx == 0\n-\t   && (rhslen = get_string_cst_length (gimple_assign_rhs1 (stmt))) >= 0\n+\t   && (rhslen = get_min_string_length (rhs, &full_string_p)) >= 0\n \t   && ssaname == NULL_TREE\n \t   && TREE_CODE (TREE_TYPE (lhs)) == ARRAY_TYPE)\n     {\n@@ -3336,14 +3394,15 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t  if (idx != 0)\n \t    {\n \t      si = new_strinfo (build_fold_addr_expr (lhs), idx,\n-\t\t\t\tbuild_int_cst (size_type_node, rhslen), true);\n+\t\t\t\tbuild_int_cst (size_type_node, rhslen),\n+\t\t\t\tfull_string_p);\n \t      set_strinfo (idx, si);\n \t      si->dont_invalidate = true;\n \t    }\n \t}\n     }\n \n-  if (si != NULL && offset == 0 && storing_zero_p)\n+  if (si != NULL && offset == 0 && storing_all_zeros_p)\n     {\n       /* Allow adjust_last_stmt to remove it if the stored '\\0'\n \t is immediately overwritten.  */"}, {"sha": "28952e5b1cdec18c15806383d4df1c0bd7e74d2c", "filename": "gcc/tree.c", "status": "modified", "additions": 83, "deletions": 20, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -10643,61 +10643,124 @@ vector_cst_elt (const_tree t, unsigned int i)\n }\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some\n-   aggregate of zeros.  Otherwise return FALSE.  */\n+   aggregate of zeros.  Otherwise return FALSE.  If NONZERO is not\n+   null, set *NONZERO if and only if INIT is known not to be all\n+   zeros.  The combination of return value of false and *NONZERO\n+   false implies that INIT may but need not be all zeros.  Other\n+   combinations indicate definitive answers.  */\n+\n bool\n-initializer_zerop (const_tree init)\n+initializer_zerop (const_tree init, bool *nonzero /* = NULL */)\n {\n-  tree elt;\n+  bool dummy;\n+  if (!nonzero)\n+    nonzero = &dummy;\n+\n+  /* Conservatively clear NONZERO and set it only if INIT is definitely\n+     not all zero.  */\n+  *nonzero = false;\n \n   STRIP_NOPS (init);\n \n+  unsigned HOST_WIDE_INT off = 0;\n+\n   switch (TREE_CODE (init))\n     {\n     case INTEGER_CST:\n-      return integer_zerop (init);\n+      if (integer_zerop (init))\n+\treturn true;\n+\n+      *nonzero = true;\n+      return false;\n \n     case REAL_CST:\n       /* ??? Note that this is not correct for C4X float formats.  There,\n \t a bit pattern of all zeros is 1.0; 0.0 is encoded with the most\n \t negative exponent.  */\n-      return real_zerop (init)\n-\t&& ! REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (init));\n+      if (real_zerop (init)\n+\t  && !REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (init)))\n+\treturn true;\n+\n+      *nonzero = true;\n+      return false;\n \n     case FIXED_CST:\n-      return fixed_zerop (init);\n+      if (fixed_zerop (init))\n+\treturn true;\n+\n+      *nonzero = true;\n+      return false;\n \n     case COMPLEX_CST:\n-      return integer_zerop (init)\n-\t|| (real_zerop (init)\n-\t    && ! REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (TREE_REALPART (init)))\n-\t    && ! REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (TREE_IMAGPART (init))));\n+      if (integer_zerop (init)\n+\t  || (real_zerop (init)\n+\t      && !REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (TREE_REALPART (init)))\n+\t      && !REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (TREE_IMAGPART (init)))))\n+\treturn true;\n+\n+      *nonzero = true;\n+      return false;\n \n     case VECTOR_CST:\n-      return (VECTOR_CST_NPATTERNS (init) == 1\n-\t      && VECTOR_CST_DUPLICATE_P (init)\n-\t      && initializer_zerop (VECTOR_CST_ENCODED_ELT (init, 0)));\n+      if (VECTOR_CST_NPATTERNS (init) == 1\n+\t  && VECTOR_CST_DUPLICATE_P (init)\n+\t  && initializer_zerop (VECTOR_CST_ENCODED_ELT (init, 0)))\n+\treturn true;\n+\n+      *nonzero = true;\n+      return false;\n \n     case CONSTRUCTOR:\n       {\n-\tunsigned HOST_WIDE_INT idx;\n-\n \tif (TREE_CLOBBER_P (init))\n \t  return false;\n+\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree elt;\n+\n \tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), idx, elt)\n-\t  if (!initializer_zerop (elt))\n+\t  if (!initializer_zerop (elt, nonzero))\n \t    return false;\n+\n \treturn true;\n       }\n \n+    case MEM_REF:\n+      {\n+\ttree arg = TREE_OPERAND (init, 0);\n+\tif (TREE_CODE (arg) != ADDR_EXPR)\n+\t  return false;\n+\ttree offset = TREE_OPERAND (init, 1);\n+\tif (TREE_CODE (offset) != INTEGER_CST\n+\t    || !tree_fits_uhwi_p (offset))\n+\t  return false;\n+\toff = tree_to_uhwi (offset);\n+\tif (INT_MAX < off)\n+\t  return false;\n+\targ = TREE_OPERAND (arg, 0);\n+\tif (TREE_CODE (arg) != STRING_CST)\n+\t  return false;\n+\tinit = arg;\n+      }\n+      /* Fall through.  */\n+\n     case STRING_CST:\n       {\n-\tint i;\n+\tgcc_assert (off <= INT_MAX);\n+\n+\tint i = off;\n+\tint n = TREE_STRING_LENGTH (init);\n+\tif (n <= i)\n+\t  return false;\n \n \t/* We need to loop through all elements to handle cases like\n \t   \"\\0\" and \"\\0foobar\".  */\n-\tfor (i = 0; i < TREE_STRING_LENGTH (init); ++i)\n+\tfor (i = 0; i < n; ++i)\n \t  if (TREE_STRING_POINTER (init)[i] != '\\0')\n-\t    return false;\n+\t    {\n+\t      *nonzero = true;\n+\t      return false;\n+\t    }\n \n \treturn true;\n       }"}, {"sha": "7bed03553b28d78a743050ac1adeff3937758a44", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca8570e11d28b8c33d26593df6d4725a6140aab/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=aca8570e11d28b8c33d26593df6d4725a6140aab", "patch": "@@ -4429,9 +4429,13 @@ extern int list_length (const_tree);\n extern tree first_field (const_tree);\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some\n-   aggregate of zeros.  Otherwise return FALSE.  */\n+   aggregate of zeros.  Otherwise return FALSE.  If NONZERO is not\n+   null, set *NONZERO if and only if INIT is known not to be all\n+   zeros.  The combination of return value of false and *NONZERO\n+   false implies that INIT may but need not be all zeros.  Other\n+   combinations indicate definitive answers.  */\n \n-extern bool initializer_zerop (const_tree);\n+extern bool initializer_zerop (const_tree, bool * = NULL);\n \n extern wide_int vector_cst_int_elt (const_tree, unsigned int);\n extern tree vector_cst_elt (const_tree, unsigned int);"}]}