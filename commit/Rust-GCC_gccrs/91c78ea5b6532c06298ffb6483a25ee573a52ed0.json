{"sha": "91c78ea5b6532c06298ffb6483a25ee573a52ed0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFjNzhlYTViNjUzMmMwNjI5OGZmYjY0ODNhMjVlZTU3M2E1MmVkMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-01-20T11:50:58Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-01-20T11:50:58Z"}, "message": "Implement N3657: heterogeneous lookup in associative containers.\n\n\t* include/bits/stl_map.h (map::find<>, map::count<>,\n\tmap::lower_bound<>, map::upper_bound<>, map::equal_range<>): New\n\tmember function templates to perform heterogeneous lookup.\n\t* include/bits/stl_multimap.h (multimap::find<>, multimap::count<>,\n\tmultimap::lower_bound<>, multimap::upper_bound<>,\n\tmultimap::equal_range<>): Likewise.\n\t* include/bits/stl_multiset.h (multiset::find<>, multiset::count<>,\n\tmultiset::lower_bound<>, multiset::upper_bound<>,\n\tmultiset::equal_range<>): Likewise.\n\t* include/bits/stl_set.h (set::find<>, set::count<>,\n\tset::lower_bound<>, set::upper_bound<>, set::equal_range<>): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree::_S_lower_bound_tr,\n\t_Rb_tree::_S_upper_bound_tr, _Rb_tree::_M_find_tr,\n\t_Rb_tree::_M_count_tr, _Rb_tree::_M_lower_bound_tr,\n\t_Rb_tree::_M_upper_bound_tr, _Rb_tree::_M_equal_range_tr): Likewise.\n\t* testsuite/23_containers/map/operations/2.cc: New.\n\t* testsuite/23_containers/multimap/operations/2.cc: New.\n\t* testsuite/23_containers/multiset/operations/2.cc: New.\n\t* testsuite/23_containers/set/operations/2.cc: New.\n\nFrom-SVN: r219888", "tree": {"sha": "a4ea5df9a398d561ff18a5b12f7be17188e80153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4ea5df9a398d561ff18a5b12f7be17188e80153"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91c78ea5b6532c06298ffb6483a25ee573a52ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c78ea5b6532c06298ffb6483a25ee573a52ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c78ea5b6532c06298ffb6483a25ee573a52ed0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c78ea5b6532c06298ffb6483a25ee573a52ed0/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71a16cd8bcb8d112a2a1db544b7f3aa9cfea67f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a16cd8bcb8d112a2a1db544b7f3aa9cfea67f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a16cd8bcb8d112a2a1db544b7f3aa9cfea67f8"}], "stats": {"total": 1020, "additions": 1020, "deletions": 0}, "files": [{"sha": "3274825b5938d50b59a538d71bec13c9e62ee5b4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -1,3 +1,25 @@\n+2015-01-20  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/stl_map.h (map::find<>, map::count<>,\n+\tmap::lower_bound<>, map::upper_bound<>, map::equal_range<>): New\n+\tmember function templates to perform heterogeneous lookup.\n+\t* include/bits/stl_multimap.h (multimap::find<>, multimap::count<>,\n+\tmultimap::lower_bound<>, multimap::upper_bound<>,\n+\tmultimap::equal_range<>): Likewise.\n+\t* include/bits/stl_multiset.h (multiset::find<>, multiset::count<>,\n+\tmultiset::lower_bound<>, multiset::upper_bound<>,\n+\tmultiset::equal_range<>): Likewise.\n+\t* include/bits/stl_set.h (set::find<>, set::count<>,\n+\tset::lower_bound<>, set::upper_bound<>, set::equal_range<>): Likewise.\n+\t* include/bits/stl_tree.h (_Rb_tree::_S_lower_bound_tr,\n+\t_Rb_tree::_S_upper_bound_tr, _Rb_tree::_M_find_tr,\n+\t_Rb_tree::_M_count_tr, _Rb_tree::_M_lower_bound_tr,\n+\t_Rb_tree::_M_upper_bound_tr, _Rb_tree::_M_equal_range_tr): Likewise.\n+\t* testsuite/23_containers/map/operations/2.cc: New.\n+\t* testsuite/23_containers/multimap/operations/2.cc: New.\n+\t* testsuite/23_containers/multiset/operations/2.cc: New.\n+\t* testsuite/23_containers/set/operations/2.cc: New.\n+\n 2015-01-20  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* config/abi/pre/gnu.ver: Export new constructors."}, {"sha": "df18973931ec366c59b12734deb5f7fec2a793da", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -824,6 +824,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return value_compare(_M_t.key_comp()); }\n \n       // [23.3.1.3] map operations\n+\n+      //@{\n       /**\n        *  @brief Tries to locate an element in a %map.\n        *  @param  __x  Key of (key, value) %pair to be located.\n@@ -835,10 +837,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  pointing to the sought after %pair.  If unsuccessful it returns the\n        *  past-the-end ( @c end() ) iterator.\n        */\n+\n       iterator\n       find(const key_type& __x)\n       { return _M_t.find(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Tries to locate an element in a %map.\n        *  @param  __x  Key of (key, value) %pair to be located.\n@@ -850,10 +862,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  iterator pointing to the sought after %pair. If unsuccessful it\n        *  returns the past-the-end ( @c end() ) iterator.\n        */\n+\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief  Finds the number of elements with given key.\n        *  @param  __x  Key of (key, value) pairs to be located.\n@@ -866,6 +888,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       count(const key_type& __x) const\n       { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n+\t{ return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -881,6 +912,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -896,6 +937,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -906,6 +957,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       upper_bound(const key_type& __x)\n       { return _M_t.upper_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -916,6 +977,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pairs to be located.\n@@ -935,6 +1006,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pairs to be located.\n@@ -954,6 +1035,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+#endif\n+      //@}\n+\n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n         operator==(const map<_K1, _T1, _C1, _A1>&,"}, {"sha": "f3d21ab8bea156fa51fc90c64451ed15b3f850bc", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -734,6 +734,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return value_compare(_M_t.key_comp()); }\n \n       // multimap operations\n+\n+      //@{\n       /**\n        *  @brief Tries to locate an element in a %multimap.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -749,6 +751,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       find(const key_type& __x)\n       { return _M_t.find(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Tries to locate an element in a %multimap.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -764,6 +775,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the number of elements with given key.\n        *  @param  __x  Key of (key, value) pairs to be located.\n@@ -773,6 +793,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       count(const key_type& __x) const\n       { return _M_t.count(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n+\t{ return _M_t._M_count_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -788,6 +817,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -803,6 +842,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -813,6 +862,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       upper_bound(const key_type& __x)\n       { return _M_t.upper_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pair to be located.\n@@ -823,6 +882,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pairs to be located.\n@@ -840,6 +909,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+#endif\n+      //@}\n+\n+      //@{\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  __x  Key of (key, value) pairs to be located.\n@@ -857,6 +936,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+#endif\n+      //@}\n+\n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n         operator==(const multimap<_K1, _T1, _C1, _A1>&,"}, {"sha": "7e92836aaecf2e16b5545ff8d03ff2fb522cf9d8", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -636,6 +636,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // multiset operations:\n \n+      //@{\n       /**\n        *  @brief Finds the number of elements with given key.\n        *  @param  __x  Key of elements to be located.\n@@ -645,6 +646,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       count(const key_type& __x) const\n       { return _M_t.count(__x); }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n+\t{ return _M_t._M_count_tr(__x); }\n+#endif\n+      //@}\n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214.  set::find() missing const overload\n       //@{\n@@ -666,6 +675,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -687,6 +708,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_iterator\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -703,6 +738,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_iterator\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -728,6 +777,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+#endif\n       //@}\n \n       template<typename _K1, typename _C1, typename _A1>"}, {"sha": "518923435702e799ad0d23fc24e1edb470d8cdac", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -651,6 +651,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // set operations:\n \n+      //@{\n       /**\n        *  @brief  Finds the number of elements.\n        *  @param  __x  Element to located.\n@@ -663,6 +664,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       count(const key_type& __x) const\n       { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n \n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tcount(const _Kt& __x) const\n+\t-> decltype(_M_t._M_count_tr(__x))\n+\t{ return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }\n+#endif\n+      //@}\n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214.  set::find() missing const overload\n       //@{\n@@ -684,6 +694,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tfind(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))\n+\t{ return _M_t._M_find_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -705,6 +727,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_iterator\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tlower_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_lower_bound_tr(__x))\n+\t{ return _M_t._M_lower_bound_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -721,6 +757,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       const_iterator\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x)\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tupper_bound(const _Kt& __x) const\n+\t-> decltype(_M_t._M_upper_bound_tr(__x))\n+\t{ return _M_t._M_upper_bound_tr(__x); }\n+#endif\n       //@}\n \n       //@{\n@@ -746,6 +796,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n+\n+#if __cplusplus > 201103L\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x)\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+\n+      template<typename _Kt>\n+\tauto\n+\tequal_range(const _Kt& __x) const\n+\t-> decltype(_M_t._M_equal_range_tr(__x))\n+\t{ return _M_t._M_equal_range_tr(__x); }\n+#endif\n       //@}\n \n       template<typename _K1, typename _C1, typename _A1>"}, {"sha": "5ca8e28ef43af3b9309680af6670a7b01712f20f", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -1118,6 +1118,137 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       pair<const_iterator, const_iterator>\n       equal_range(const key_type& __k) const;\n \n+#if __cplusplus > 201103L\n+      template<typename _Cmp, typename _Kt, typename = __void_t<>>\n+\tstruct __is_transparent { };\n+\n+      template<typename _Cmp, typename _Kt>\n+\tstruct\n+\t__is_transparent<_Cmp, _Kt, __void_t<typename _Cmp::is_transparent>>\n+\t{ typedef void type; };\n+\n+      static auto _S_iter(_Link_type __x) { return iterator(__x); }\n+\n+      static auto _S_iter(_Const_Link_type __x) { return const_iterator(__x); }\n+\n+      template<typename _Cmp, typename _Link, typename _Kt>\n+\tstatic auto\n+\t_S_lower_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)\n+\t{\n+\t  while (__x != 0)\n+\t    if (!__cmp(_S_key(__x), __k))\n+\t      __y = __x, __x = _S_left(__x);\n+\t    else\n+\t      __x = _S_right(__x);\n+\t  return _S_iter(__y);\n+\t}\n+\n+      template<typename _Cmp, typename _Link, typename _Kt>\n+\tstatic auto\n+\t_S_upper_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)\n+\t{\n+\t  while (__x != 0)\n+\t    if (__cmp(__k, _S_key(__x)))\n+\t      __y = __x, __x = _S_left(__x);\n+\t    else\n+\t      __x = _S_right(__x);\n+\t  return _S_iter(__y);\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\titerator\n+\t_M_find_tr(const _Kt& __k)\n+\t{\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);\n+\t  return (__j == end() || __cmp(__k, _S_key(__j._M_node)))\n+\t    ? end() : __j;\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\tconst_iterator\n+\t_M_find_tr(const _Kt& __k) const\n+\t{\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);\n+\t  return (__j == end() || __cmp(__k, _S_key(__j._M_node)))\n+\t    ? end() : __j;\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\tsize_type\n+\t_M_count_tr(const _Kt& __k) const\n+\t{\n+\t  auto __p = _M_equal_range_tr(__k);\n+\t  return std::distance(__p.first, __p.second);\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\titerator\n+\t_M_lower_bound_tr(const _Kt& __k)\n+\t{\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\tconst_iterator\n+\t_M_lower_bound_tr(const _Kt& __k) const\n+\t{\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\titerator\n+\t_M_upper_bound_tr(const _Kt& __k)\n+\t{\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\tconst_iterator\n+\t_M_upper_bound_tr(const _Kt& __k) const\n+\t{\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\tpair<iterator, iterator>\n+\t_M_equal_range_tr(const _Kt& __k)\n+\t{\n+\t  auto __low = _M_lower_bound_tr(__k);\n+\t  auto __high = __low;\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))\n+\t    ++__high;\n+\t  return { __low, __high };\n+\t}\n+\n+      template<typename _Kt,\n+\t       typename _Req = typename __is_transparent<_Compare, _Kt>::type>\n+\tpair<const_iterator, const_iterator>\n+\t_M_equal_range_tr(const _Kt& __k) const\n+\t{\n+\t  auto __low = _M_lower_bound_tr(__k);\n+\t  auto __high = __low;\n+\t  auto& __cmp = _M_impl._M_key_compare;\n+\t  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))\n+\t    ++__high;\n+\t  return { __low, __high };\n+\t}\n+#endif\n+\n       // Debugging.\n       bool\n       __rb_verify() const;"}, {"sha": "6cc277aedceffa758891b2d8c794ede03eb920eb", "filename": "libstdc++-v3/testsuite/23_containers/map/operations/2.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperations%2F2.cc?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+struct Cmp\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i < l; }\n+  bool operator()(long l, int i) const { return l < i; }\n+  bool operator()(int i, int j) const { ++count; return i < j; }\n+\n+  static int count;\n+};\n+\n+int Cmp::count = 0;\n+\n+using test_type = std::map<int, char, Cmp>;\n+\n+test_type x{ { 1, '2' }, { 3, '4' } };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && it->second == '2' );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test02()\n+{\n+  Cmp::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 1 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test03()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.lower_bound(1L);\n+  VERIFY( it != x.end() && it->second == '2' );\n+  it = x.lower_bound(2L);\n+  VERIFY( it != x.end() && it->second == '4' );\n+\n+  auto cit = cx.lower_bound(1L);\n+  VERIFY( cit != cx.end() && cit->second == '2' );\n+  cit = cx.lower_bound(2L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test04()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.upper_bound(1L);\n+  VERIFY( it != x.end() && it->second == '4' );\n+  it = x.upper_bound(3L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.upper_bound(1L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+  cit = cx.upper_bound(3L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test05()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && it.first->second == '2' );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first != x.end() );\n+\n+  auto cit = cx.equal_range(1L);\n+  VERIFY( cit.first != cit.second && cit.first->second == '2' );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first != cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "67c3bfd60a38fea91f2cf90cb2bf63190ef63110", "filename": "libstdc++-v3/testsuite/23_containers/multimap/operations/2.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperations%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperations%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Foperations%2F2.cc?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -0,0 +1,141 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+struct Cmp\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i < l; }\n+  bool operator()(long l, int i) const { return l < i; }\n+  bool operator()(int i, int j) const { ++count; return i < j; }\n+\n+  static int count;\n+};\n+\n+int Cmp::count = 0;\n+\n+using test_type = std::multimap<int, char, Cmp>;\n+\n+test_type x{ { 1, '2' }, { 3, '4' }, { 3, '5' } };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && it->second == '2' );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test02()\n+{\n+  Cmp::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 2 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test03()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.lower_bound(1L);\n+  VERIFY( it != x.end() && it->second == '2' );\n+  it = x.lower_bound(2L);\n+  VERIFY( it != x.end() && it->second == '4' );\n+\n+  auto cit = cx.lower_bound(1L);\n+  VERIFY( cit != cx.end() && cit->second == '2' );\n+  cit = cx.lower_bound(2L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test04()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.upper_bound(1L);\n+  VERIFY( it != x.end() && it->second == '4' );\n+  it = x.upper_bound(3L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.upper_bound(1L);\n+  VERIFY( cit != cx.end() && cit->second == '4' );\n+  cit = cx.upper_bound(3L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test05()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && it.first->second == '2' );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first != x.end() );\n+\n+  auto cit = cx.equal_range(3L);\n+  VERIFY( cit.first != cit.second && cit.first->second == '4' );\n+  VERIFY( std::distance(cit.first, cit.second) == 2 );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first != cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "ff2748f713a0ba8bafcbb7a04e080e24be5969bb", "filename": "libstdc++-v3/testsuite/23_containers/multiset/operations/2.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperations%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperations%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Foperations%2F2.cc?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -0,0 +1,141 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+struct Cmp\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i < l; }\n+  bool operator()(long l, int i) const { return l < i; }\n+  bool operator()(int i, int j) const { ++count; return i < j; }\n+\n+  static int count;\n+};\n+\n+int Cmp::count = 0;\n+\n+using test_type = std::multiset<int, Cmp>;\n+\n+test_type x{ 1, 3, 3, 5 };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && *it == 1 );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test02()\n+{\n+  Cmp::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 2 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test03()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.lower_bound(1L);\n+  VERIFY( it != x.end() && *it == 1 );\n+  it = x.lower_bound(2L);\n+  VERIFY( it != x.end() && *it == 3 );\n+\n+  auto cit = cx.lower_bound(1L);\n+  VERIFY( cit != cx.end() && *cit == 1 );\n+  cit = cx.lower_bound(2L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test04()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.upper_bound(1L);\n+  VERIFY( it != x.end() && *it == 3 );\n+  it = x.upper_bound(5L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.upper_bound(1L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+  cit = cx.upper_bound(5L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test05()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && *it.first == 1 );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first != x.end() );\n+\n+  auto cit = cx.equal_range(3L);\n+  VERIFY( cit.first != cit.second && *cit.first == 3 );\n+  VERIFY( std::distance(cit.first, cit.second) == 2 );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first != cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "752bc7dd7a62d1967c2b60086d1cdaeaec7280f1", "filename": "libstdc++-v3/testsuite/23_containers/set/operations/2.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperations%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c78ea5b6532c06298ffb6483a25ee573a52ed0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperations%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperations%2F2.cc?ref=91c78ea5b6532c06298ffb6483a25ee573a52ed0", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+struct Cmp\n+{\n+  typedef void is_transparent;\n+\n+  bool operator()(int i, long l) const { return i < l; }\n+  bool operator()(long l, int i) const { return l < i; }\n+  bool operator()(int i, int j) const { ++count; return i < j; }\n+\n+  static int count;\n+};\n+\n+int Cmp::count = 0;\n+\n+using test_type = std::set<int, Cmp>;\n+\n+test_type x{ 1, 3, 5 };\n+const test_type& cx = x;\n+\n+void\n+test01()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.find(1L);\n+  VERIFY( it != x.end() && *it == 1 );\n+  it = x.find(2L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.find(3L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+  cit = cx.find(2L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test02()\n+{\n+  Cmp::count = 0;\n+\n+  auto n = x.count(1L);\n+  VERIFY( n == 1 );\n+  n = x.count(2L);\n+  VERIFY( n == 0 );\n+\n+  auto cn = cx.count(3L);\n+  VERIFY( cn == 1 );\n+  cn = cx.count(2L);\n+  VERIFY( cn == 0 );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test03()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.lower_bound(1L);\n+  VERIFY( it != x.end() && *it == 1 );\n+  it = x.lower_bound(2L);\n+  VERIFY( it != x.end() && *it == 3 );\n+\n+  auto cit = cx.lower_bound(1L);\n+  VERIFY( cit != cx.end() && *cit == 1 );\n+  cit = cx.lower_bound(2L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test04()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.upper_bound(1L);\n+  VERIFY( it != x.end() && *it == 3 );\n+  it = x.upper_bound(5L);\n+  VERIFY( it == x.end() );\n+\n+  auto cit = cx.upper_bound(1L);\n+  VERIFY( cit != cx.end() && *cit == 3 );\n+  cit = cx.upper_bound(5L);\n+  VERIFY( cit == cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+void\n+test05()\n+{\n+  Cmp::count = 0;\n+\n+  auto it = x.equal_range(1L);\n+  VERIFY( it.first != it.second && *it.first == 1 );\n+  it = x.equal_range(2L);\n+  VERIFY( it.first == it.second && it.first != x.end() );\n+\n+  auto cit = cx.equal_range(1L);\n+  VERIFY( cit.first != cit.second && *cit.first == 1 );\n+  cit = cx.equal_range(2L);\n+  VERIFY( cit.first == cit.second && cit.first != cx.end() );\n+\n+  VERIFY( Cmp::count == 0);\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}]}