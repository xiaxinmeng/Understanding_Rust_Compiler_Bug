{"sha": "d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDljNWE4Yjk4YTIxYWIwMDkxYmJlMGYzZGFiOTNkZDU5ZTZjNThmYg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-05-04T23:50:21Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-05-04T23:50:21Z"}, "message": "PR libstdc++/54924 - Warn for std::string constructor with wrong size\n\nPR libstdc++/54924 - Warn for std::string constructor with wrong size\nPR middle-end/79234 - warn on past the end reads by library functions\n\ngcc/ChangeLog:\n\n\tPR middle-end/79234\n\t* builtins.c (check_sizes): Adjust to handle reading past the end.\n\tAvoid printing excessive upper bound of ranges.  Use %E to print\n\ttree nodes instead of converting them to %wu.\n\t(expand_builtin_memchr): New function.\n\t(compute_dest_size): Rename...\n\t(compute_objsize): ...to this.\n\t(expand_builtin_memcpy): Adjust.\n\t(expand_builtin_mempcpy): Adjust.\n\t(expand_builtin_strcat): Adjust.\n\t(expand_builtin_strcpy): Adjust.\n\t(check_strncat_sizes): Adjust.\n\t(expand_builtin_strncat): Adjust.\n\t(expand_builtin_strncpy): Adjust and simplify.\n\t(expand_builtin_memset): Adjust.\n\t(expand_builtin_bzero): Adjust.\n\t(expand_builtin_memcmp): Adjust.\n\t(expand_builtin): Handle memcmp.\n\t(maybe_emit_chk_warning): Check strncat just once.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/79234\n\t* gcc.dg/builtin-stringop-chk-8.c: New test.\n\t* gcc.dg/builtin-stringop-chk-1.c: Adjust.\n\t* gcc.dg/builtin-stringop-chk-4.c: Same.\n\t* gcc.dg/builtin-strncat-chk-1.c: Same.\n\t* g++.dg/ext/strncpy-chk1.C: Same.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n\t* gcc.dg/out-of-bounds-1.c: Same.\n\t* gcc.dg/pr78138.c: Same.\n\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Same.\n\t* gfortran.dg/mvbits_7.f90: Same.\n\nFrom-SVN: r247622", "tree": {"sha": "84e9df2d0bf355d3dd1816f7a7833c5fc6204ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84e9df2d0bf355d3dd1816f7a7833c5fc6204ff1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f3587ec0e7af6140ceb75947144baf42676617b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3587ec0e7af6140ceb75947144baf42676617b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3587ec0e7af6140ceb75947144baf42676617b"}], "stats": {"total": 630, "additions": 449, "deletions": 181}, "files": [{"sha": "ae600c02c748c1a221a69b32805871481dfbdd87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -1,3 +1,25 @@\n+2017-05-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/79234\n+\t* builtins.c (check_sizes): Adjust to handle reading past the end.\n+\tAvoid printing excessive upper bound of ranges.  Use %E to print\n+\ttree nodes instead of converting them to %wu.\n+\t(expand_builtin_memchr): New function.\n+\t(compute_dest_size): Rename...\n+\t(compute_objsize): ...to this.\n+\t(expand_builtin_memcpy): Adjust.\n+\t(expand_builtin_mempcpy): Adjust.\n+\t(expand_builtin_strcat): Adjust.\n+\t(expand_builtin_strcpy): Adjust.\n+\t(check_strncat_sizes): Adjust.\n+\t(expand_builtin_strncat): Adjust.\n+\t(expand_builtin_strncpy): Adjust and simplify.\n+\t(expand_builtin_memset): Adjust.\n+\t(expand_builtin_bzero): Adjust.\n+\t(expand_builtin_memcmp): Adjust.\n+\t(expand_builtin): Handle memcmp.\n+\t(maybe_emit_chk_warning): Check strncat just once.\n+\n 2017-05-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR preprocessor/79214"}, {"sha": "c6ce7d68acdf30aa19c8c5293b33d50b42a2f541", "filename": "gcc/builtins.c", "status": "modified", "additions": 192, "deletions": 112, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -118,6 +118,7 @@ static rtx expand_builtin_va_copy (tree);\n static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n+static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memcpy_with_bounds (tree, rtx);\n static rtx expand_builtin_memcpy_args (tree, tree, tree, rtx, tree);\n@@ -3046,10 +3047,10 @@ expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n    MAXLEN is the user-supplied bound on the length of the source sequence\n    (such as in strncat(d, s, N).  It specifies the upper limit on the number\n    of bytes to write.\n-   STR is the source string (such as in strcpy(d, s)) when the epxression\n+   SRC is the source string (such as in strcpy(d, s)) when the epxression\n    EXP is a string function call (as opposed to a memory call like memcpy).\n-   As an exception, STR can also be an integer denoting the precomputed\n-   length of the source string.\n+   As an exception, SRC can also be an integer denoting the precomputed\n+   size of the source string or object (for functions like memcpy).\n    OBJSIZE is the size of the destination object specified by the last\n    argument to the _chk builtins, typically resulting from the expansion\n    of __builtin_object_size (such as in __builtin___strcpy_chk(d, s,\n@@ -3062,41 +3063,56 @@ expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n    the function returns true, otherwise false..  */\n \n static bool\n-check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n+check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n {\n   /* The size of the largest object is half the address space, or\n      SSIZE_MAX.  (This is way too permissive.)  */\n   tree maxobjsize = TYPE_MAX_VALUE (ssizetype);\n \n   tree slen = NULL_TREE;\n \n+  tree range[2] = { NULL_TREE, NULL_TREE };\n+\n   /* Set to true when the exact number of bytes written by a string\n      function like strcpy is not known and the only thing that is\n      known is that it must be at least one (for the terminating nul).  */\n   bool at_least_one = false;\n-  if (str)\n+  if (src)\n     {\n-      /* STR is normally a pointer to string but as a special case\n+      /* SRC is normally a pointer to string but as a special case\n \t it can be an integer denoting the length of a string.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (str)))\n+      if (POINTER_TYPE_P (TREE_TYPE (src)))\n \t{\n \t  /* Try to determine the range of lengths the source string\n-\t     refers to.  If it can be determined add one to it for\n+\t     refers to.  If it can be determined and is less than\n+\t     the upper bound given by MAXLEN add one to it for\n \t     the terminating nul.  Otherwise, set it to one for\n-\t     the same reason.  */\n-\t  tree lenrange[2];\n-\t  get_range_strlen (str, lenrange);\n-\t  if (lenrange[0])\n-\t    slen = fold_build2 (PLUS_EXPR, size_type_node, lenrange[0],\n-\t\t\t\tsize_one_node);\n+\t     the same reason, or to MAXLEN as appropriate.  */\n+\t  get_range_strlen (src, range);\n+\t  if (range[0] && (!maxlen || TREE_CODE (maxlen) == INTEGER_CST))\n+\t    {\n+\t      if (maxlen && tree_int_cst_le (maxlen, range[0]))\n+\t\trange[0] = range[1] = maxlen;\n+\t      else\n+\t\trange[0] = fold_build2 (PLUS_EXPR, size_type_node,\n+\t\t\t\t\trange[0], size_one_node);\n+\n+\t      if (maxlen && tree_int_cst_le (maxlen, range[1]))\n+\t\trange[1] = maxlen;\n+\t      else if (!integer_all_onesp (range[1]))\n+\t\trange[1] = fold_build2 (PLUS_EXPR, size_type_node,\n+\t\t\t\t\trange[1], size_one_node);\n+\n+\t      slen = range[0];\n+\t    }\n \t  else\n \t    {\n \t      at_least_one = true;\n \t      slen = size_one_node;\n \t    }\n \t}\n       else\n-\tslen = str;\n+\tslen = src;\n     }\n \n   if (!size && !maxlen)\n@@ -3108,7 +3124,8 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n \n       /* Otherwise, when the length of the source sequence is known\n \t (as with with strlen), set SIZE to it.  */\n-      size = slen;\n+      if (!range[0])\n+\tsize = slen;\n     }\n \n   if (!objsize)\n@@ -3118,7 +3135,6 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n      unsigned HOST_WIDE_INT.  */\n   bool exactsize = size && tree_fits_uhwi_p (size);\n \n-  tree range[2] = { NULL_TREE, NULL_TREE };\n   if (size)\n     get_size_range (size, range);\n \n@@ -3131,19 +3147,15 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n \n       if (range[0] == range[1])\n \twarning_at (loc, opt,\n-\t\t    \"%K%qD: specified size %wu \"\n-\t\t    \"exceeds maximum object size %wu\",\n-\t\t    exp, get_callee_fndecl (exp),\n-\t\t    tree_to_uhwi (range[0]),\n-\t\t    tree_to_uhwi (maxobjsize));\n+\t\t    \"%K%qD: specified size %E \"\n+\t\t    \"exceeds maximum object size %E\",\n+\t\t    exp, get_callee_fndecl (exp), range[0], maxobjsize);\n \t  else\n \t    warning_at (loc, opt,\n-\t\t\t\"%K%qD: specified size between %wu and %wu \"\n-\t\t\t\"exceeds maximum object size %wu\",\n+\t\t\t\"%K%qD: specified size between %E and %E \"\n+\t\t\t\"exceeds maximum object size %E\",\n \t\t\texp, get_callee_fndecl (exp),\n-\t\t\ttree_to_uhwi (range[0]),\n-\t\t\ttree_to_uhwi (range[1]),\n-\t\t\ttree_to_uhwi (maxobjsize));\n+\t\t\trange[0], range[1], maxobjsize);\n       return false;\n     }\n \n@@ -3157,33 +3169,41 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n \t      || (tree_fits_uhwi_p (size)\n \t\t  && tree_int_cst_lt (size, range[0]))))\n \t{\n-\t  unsigned HOST_WIDE_INT uwir0 = tree_to_uhwi (range[0]);\n-\n \t  location_t loc = tree_nonartificial_location (exp);\n \t  loc = expansion_point_location_if_in_system_header (loc);\n \n-\t  if (at_least_one)\n-\t    warning_at (loc, opt,\n-\t\t\t\"%K%qD writing at least %wu byte into a region \"\n-\t\t\t\"of size %wu overflows the destination\",\n-\t\t\texp, get_callee_fndecl (exp), uwir0,\n-\t\t\ttree_to_uhwi (objsize));\n-\t  else if (range[0] == range[1])\n+\t  if (size == slen && at_least_one)\n+\t    {\n+\t      /* This is a call to strcpy with a destination of 0 size\n+\t\t and a source of unknown length.  The call will write\n+\t\t at least one byte past the end of the destination.  */\n+\t      warning_at (loc, opt,\n+\t\t\t  \"%K%qD: writing %E or more bytes into a region \"\n+\t\t\t  \"of size %E overflows the destination\",\n+\t\t\t  exp, get_callee_fndecl (exp), range[0], objsize);\n+\t    }\n+\t  else if (tree_int_cst_equal (range[0], range[1]))\n \t    warning_at (loc, opt,\n-\t\t\t(uwir0 == 1\n-\t\t\t ? G_(\"%K%qD writing %wu byte into a region \"\n-\t\t\t      \"of size %wu overflows the destination\")\n-\t\t\t : G_(\"%K%qD writing %wu bytes into a region \"\n-\t\t\t      \"of size %wu overflows the destination\")),\n-\t\t\texp, get_callee_fndecl (exp), uwir0,\n-\t\t\ttree_to_uhwi (objsize));\n+\t\t\t(integer_onep (range[0])\n+\t\t\t ? G_(\"%K%qD: writing %E byte into a region \"\n+\t\t\t      \"of size %E overflows the destination\")\n+\t\t\t : G_(\"%K%qD writing %E bytes into a region \"\n+\t\t\t      \"of size %E overflows the destination\")),\n+\t\t\texp, get_callee_fndecl (exp), range[0], objsize);\n+\t  else if (tree_int_cst_sign_bit (range[1]))\n+\t    {\n+\t      /* Avoid printing the upper bound if it's invalid.  */\n+\t      warning_at (loc, opt,\n+\t\t\t  \"%K%qD: writing %E or more bytes into a region \"\n+\t\t\t  \"of size %E overflows the destination\",\n+\t\t\t  exp, get_callee_fndecl (exp), range[0], objsize);\n+\t    }\n \t  else\n \t    warning_at (loc, opt,\n-\t\t\t\"%K%qD writing between %wu and %wu bytes \"\n-\t\t\t\"into a region of size %wu overflows \"\n-\t\t\t\"the destination\",\n-\t\t\texp, get_callee_fndecl (exp), uwir0,\n-\t\t\ttree_to_uhwi (range[1]), tree_to_uhwi (objsize));\n+\t\t\t\"%K%qD: writing between %E and %E bytes into \"\n+\t\t\t\"a region of size %E overflows the destination\",\n+\t\t\texp, get_callee_fndecl (exp), range[0],\trange[1],\n+\t\t\tobjsize);\n \n \t  /* Return error when an overflow has been detected.  */\n \t  return false;\n@@ -3209,45 +3229,68 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n \t\t is greater than the object size if both are big.  */\n \t      if (range[0] == range[1])\n \t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD: specified bound %wu \"\n-\t\t\t    \"exceeds maximum object size %wu\",\n+\t\t\t    \"%K%qD: specified bound %E \"\n+\t\t\t    \"exceeds maximum object size %E\",\n \t\t\t    exp, get_callee_fndecl (exp),\n-\t\t\t    tree_to_uhwi (range[0]),\n-\t\t\t    tree_to_uhwi (maxobjsize));\n+\t\t\t    range[0], maxobjsize);\n \t      else\n \t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD: specified bound between %wu and %wu \"\n-\t\t\t    \" exceeds maximum object size %wu\",\n+\t\t\t    \"%K%qD: specified bound between %E and %E \"\n+\t\t\t    \"exceeds maximum object size %E\",\n \t\t\t    exp, get_callee_fndecl (exp),\n-\t\t\t    tree_to_uhwi (range[0]),\n-\t\t\t    tree_to_uhwi (range[1]),\n-\t\t\t    tree_to_uhwi (maxobjsize));\n+\t\t\t    range[0], range[1], maxobjsize);\n \n \t      return false;\n \t    }\n \n \t  if (objsize != maxobjsize && tree_int_cst_lt (objsize, range[0]))\n \t    {\n-\t      if (range[0] == range[1])\n+\t      if (tree_int_cst_equal (range[0], range[1]))\n \t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD: specified bound %wu \"\n-\t\t\t    \"exceeds the size %wu of the destination\",\n+\t\t\t    \"%K%qD: specified bound %E \"\n+\t\t\t    \"exceeds destination size %E\",\n \t\t\t    exp, get_callee_fndecl (exp),\n-\t\t\t    tree_to_uhwi (range[0]),\n-\t\t\t    tree_to_uhwi (objsize));\n+\t\t\t    range[0], objsize);\n \t      else\n \t\twarning_at (loc, opt,\n-\t\t\t    \"%K%qD: specified bound between %wu and %wu \"\n-\t\t\t    \" exceeds the size %wu of the destination\",\n+\t\t\t    \"%K%qD: specified bound between %E and %E \"\n+\t\t\t    \"exceeds destination size %E\",\n \t\t\t    exp, get_callee_fndecl (exp),\n-\t\t\t    tree_to_uhwi (range[0]),\n-\t\t\t    tree_to_uhwi (range[1]),\n-\t\t\t    tree_to_uhwi (objsize));\n+\t\t\t    range[0], range[1], objsize);\n \t      return false;\n \t    }\n \t}\n     }\n \n+  if (slen\n+      && slen == src\n+      && size && range[0]\n+      && tree_int_cst_lt (slen, range[0]))\n+    {\n+      location_t loc = tree_nonartificial_location (exp);\n+\n+      if (tree_int_cst_equal (range[0], range[1]))\n+\twarning_at (loc, opt,\n+\t\t    (tree_int_cst_equal (range[0], integer_one_node)\n+\t\t     ? G_(\"%K%qD: reading %E byte from a region of size %E\")\n+\t\t     : G_(\"%K%qD reading %E bytes from a region of size %E\")),\n+\t\t    exp, get_callee_fndecl (exp), range[0], slen);\n+      else if (tree_int_cst_sign_bit (range[1]))\n+\t{\n+\t  /* Avoid printing the upper bound if it's invalid.  */\n+\t  warning_at (loc, opt,\n+\t\t      \"%K%qD: reading %E or more bytes from a region \"\n+\t\t      \"of size %E\",\n+\t\t      exp, get_callee_fndecl (exp), range[0], slen);\n+\t}\n+      else\n+\twarning_at (loc, opt,\n+\t\t    \"%K%qD: reading between %E and %E bytes from a region \"\n+\t\t    \"of size %E\",\n+\t\t    exp, get_callee_fndecl (exp), range[0], range[1], slen);\n+      return false;\n+    }\n+\n   return true;\n }\n \n@@ -3258,7 +3301,7 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree str, tree objsize)\n    be determined.  */\n \n static inline tree\n-compute_dest_size (tree dest, int ostype)\n+compute_objsize (tree dest, int ostype)\n {\n   unsigned HOST_WIDE_INT size;\n   if (compute_builtin_object_size (dest, ostype & 3, &size))\n@@ -3268,24 +3311,53 @@ compute_dest_size (tree dest, int ostype)\n }\n \n /* Helper to determine and check the sizes of the source and the destination\n-   of calls to __builtin_{bzero,memcpy,memset} calls.  Use Object Size type-0\n-   regardless of the OPT_Wstringop_overflow_ setting.  Returns true on success\n+   of calls to __builtin_{bzero,memcpy,mempcpy,memset} calls.  EXP is the\n+   call expression, DEST is the destination argument, SRC is the source\n+   argument or null, and LEN is the number of bytes.  Use Object Size type-0\n+   regardless of the OPT_Wstringop_overflow_ setting.  Return true on success\n    (no overflow or invalid sizes), false otherwise.  */\n \n static bool\n-check_memop_sizes (tree exp, tree dest, tree size)\n+check_memop_sizes (tree exp, tree dest, tree src, tree size)\n {\n   if (!warn_stringop_overflow)\n     return true;\n \n   /* For functions like memset and memcpy that operate on raw memory\n-     try to determine the size of the largest destination object using\n-     type-0 Object Size regardless of the object size type specified\n-     by the option.  */\n-  tree objsize = compute_dest_size (dest, 0);\n+     try to determine the size of the largest source and destination\n+     object using type-0 Object Size regardless of the object size\n+     type specified by the option.  */\n+  tree srcsize = src ? compute_objsize (src, 0) : NULL_TREE;\n+  tree dstsize = compute_objsize (dest, 0);\n \n   return check_sizes (OPT_Wstringop_overflow_, exp,\n-\t\t      size, /*maxlen=*/NULL_TREE, /*str=*/NULL_TREE, objsize);\n+\t\t      size, /*maxlen=*/NULL_TREE, srcsize, dstsize);\n+}\n+\n+/* Validate memchr arguments without performing any expansion.\n+   Return NULL_RTX.  */\n+\n+static rtx\n+expand_builtin_memchr (tree exp, rtx)\n+{\n+  if (!validate_arglist (exp,\n+ \t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tree arg1 = CALL_EXPR_ARG (exp, 0);\n+  tree len = CALL_EXPR_ARG (exp, 2);\n+\n+  /* Diagnose calls where the specified length exceeds the size\n+     of the object.  */\n+  if (warn_stringop_overflow)\n+    {\n+      tree size = compute_objsize (arg1, 0);\n+      check_sizes (OPT_Wstringop_overflow_,\n+\t\t   exp, len, /*maxlen=*/NULL_TREE,\n+\t\t   size, /*objsize=*/NULL_TREE);\n+    }\n+\n+  return NULL_RTX;\n }\n \n /* Expand a call EXP to the memcpy builtin.\n@@ -3304,7 +3376,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_sizes (exp, dest, len);\n+  check_memop_sizes (exp, dest, src, len);\n \n   return expand_builtin_memcpy_args (dest, src, len, target, exp);\n }\n@@ -3320,9 +3392,10 @@ expand_builtin_memmove (tree exp, rtx)\n     return NULL_RTX;\n \n   tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_sizes (exp, dest, len);\n+  check_memop_sizes (exp, dest, src, len);\n \n   return NULL_RTX;\n }\n@@ -3380,7 +3453,7 @@ expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n   /* Avoid expanding mempcpy into memcpy when the call is determined\n      to overflow the buffer.  This also prevents the same overflow\n      from being diagnosed again when expanding memcpy.  */\n-  if (!check_memop_sizes (exp, dest, len))\n+  if (!check_memop_sizes (exp, dest, src, len))\n     return NULL_RTX;\n \n   return expand_builtin_mempcpy_args (dest, src, len,\n@@ -3576,7 +3649,7 @@ expand_builtin_strcat (tree exp, rtx)\n      just diagnose cases when the souce string is longer than\n      the destination object.  */\n \n-  tree destsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n \n   check_sizes (OPT_Wstringop_overflow_,\n \t       exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n@@ -3600,7 +3673,7 @@ expand_builtin_strcpy (tree exp, rtx target)\n \n   if (warn_stringop_overflow)\n     {\n-      tree destsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+      tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n       check_sizes (OPT_Wstringop_overflow_,\n \t\t   exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n     }\n@@ -3639,7 +3712,7 @@ expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n \n   if (warn_stringop_overflow)\n     {\n-      tree destsize = compute_dest_size (dst, warn_stringop_overflow - 1);\n+      tree destsize = compute_objsize (dst, warn_stringop_overflow - 1);\n       check_sizes (OPT_Wstringop_overflow_,\n \t\t   exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n     }\n@@ -3734,8 +3807,7 @@ expand_builtin_stpncpy (tree exp, rtx)\n       slen = lenrange[0];\n     }\n \n-  tree destsize = compute_dest_size (dest,\n-\t\t\t\t     warn_stringop_overflow - 1);\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n \n   /* The number of bytes to write is LEN but check_sizes will also\n      check SLEN if LEN's value isn't known.  */\n@@ -3785,7 +3857,7 @@ check_strncat_sizes (tree exp, tree objsize)\n       /* If it hasn't been provided by __strncat_chk, try to determine\n \t the size of the destination object into which the source is\n \t being copied.  */\n-      objsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+      objsize = compute_objsize (dest, warn_stringop_overflow - 1);\n     }\n \n   /* Add one for the terminating nul.  */\n@@ -3804,10 +3876,8 @@ check_strncat_sizes (tree exp, tree objsize)\n       loc = expansion_point_location_if_in_system_header (loc);\n \n       warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t  \"%K%qD: specified bound %wu \"\n-\t\t  \"equals the size of the destination\",\n-\t\t  exp, get_callee_fndecl (exp),\n-\t\t  tree_to_uhwi (maxlen));\n+\t\t  \"%K%qD: specified bound %E equals destination size\",\n+\t\t  exp, get_callee_fndecl (exp), maxlen);\n \n       return false;\n     }\n@@ -3854,7 +3924,7 @@ expand_builtin_strncat (tree exp, rtx)\n   /* Try to verify that the destination is big enough for the shortest\n      string.  First try to determine the size of the destination object\n      into which the source is being copied.  */\n-  tree destsize = compute_dest_size (dest, warn_stringop_overflow - 1);\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n \n   /* Add one for the terminating nul.  */\n   tree srclen = (lenrange[0]\n@@ -3872,10 +3942,8 @@ expand_builtin_strncat (tree exp, rtx)\n       loc = expansion_point_location_if_in_system_header (loc);\n \n       warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t  \"%K%qD: specified bound %wu \"\n-\t\t  \"equals the size of the destination\",\n-\t\t  exp, get_callee_fndecl (exp),\n-\t\t  tree_to_uhwi (maxlen));\n+\t\t  \"%K%qD: specified bound %E equals destination size\",\n+\t\t  exp, get_callee_fndecl (exp), maxlen);\n \n       return NULL_RTX;\n     }\n@@ -3914,24 +3982,13 @@ expand_builtin_strncpy (tree exp, rtx target)\n \n       if (warn_stringop_overflow)\n \t{\n-\t  /* Try to determine the range of lengths that the source expression\n-\t     refers to.  */\n-\t  tree lenrange[2];\n-\t  if (slen)\n-\t    lenrange[0] = lenrange[1] = slen;\n-\t  else\n-\t    {\n-\t      get_range_strlen (src, lenrange);\n-\t      slen = lenrange[0];\n-\t    }\n-\n-\t  tree destsize = compute_dest_size (dest,\n-\t\t\t\t\t     warn_stringop_overflow - 1);\n+\t  tree destsize = compute_objsize (dest,\n+\t\t\t\t\t   warn_stringop_overflow - 1);\n \n \t  /* The number of bytes to write is LEN but check_sizes will also\n \t     check SLEN if LEN's value isn't known.  */\n \t  check_sizes (OPT_Wstringop_overflow_,\n-\t\t       exp, len, /*maxlen=*/NULL_TREE, slen, destsize);\n+\t\t       exp, len, /*maxlen=*/NULL_TREE, src, destsize);\n \t}\n \n       /* We must be passed a constant len and src parameter.  */\n@@ -4026,7 +4083,7 @@ expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n   tree val = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_sizes (exp, dest, len);\n+  check_memop_sizes (exp, dest, NULL_TREE, len);\n \n   return expand_builtin_memset_args (dest, val, len, target, mode, exp);\n }\n@@ -4215,7 +4272,7 @@ expand_builtin_bzero (tree exp)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree size = CALL_EXPR_ARG (exp, 1);\n \n-  check_memop_sizes (exp, dest, size);\n+  check_memop_sizes (exp, dest, NULL_TREE, size);\n \n   /* New argument list transforming bzero(ptr x, int y) to\n      memset(ptr x, int 0, size_t y).   This is done this way\n@@ -4268,6 +4325,23 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n+\n+  /* Diagnose calls where the specified length exceeds the size of either\n+     object.  */\n+  if (warn_stringop_overflow)\n+    {\n+      tree size = compute_objsize (arg1, 0);\n+      if (check_sizes (OPT_Wstringop_overflow_,\n+\t\t       exp, len, /*maxlen=*/NULL_TREE,\n+\t\t       size, /*objsize=*/NULL_TREE))\n+\t{\n+\t  size = compute_objsize (arg2, 0);\n+\t  check_sizes (OPT_Wstringop_overflow_,\n+\t\t       exp, len, /*maxlen=*/NULL_TREE,\n+\t\t       size, /*objsize=*/NULL_TREE);\n+\t}\n+    }\n+\n   machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   location_t loc = EXPR_LOCATION (exp);\n \n@@ -6797,6 +6871,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_MEMCHR:\n+      target = expand_builtin_memchr (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_MEMCPY:\n       target = expand_builtin_memcpy (exp, target);\n       if (target)\n@@ -9789,8 +9869,8 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n       /* Check __strncat_chk.  There is no way to determine the length\n \t of the string to which the source string is being appended so\n \t just warn when the length of the source string is not known.  */\n-      if (!check_strncat_sizes (exp, objsize))\n-\treturn;\n+      check_strncat_sizes (exp, objsize);\n+      return;\n     }\n \n   check_sizes (OPT_Wstringop_overflow_, exp,"}, {"sha": "0d54e4ceaecbaad04f7ae538a44d623f7dea7ea7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -1,3 +1,17 @@\n+2017-05-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/79234\n+\t* gcc.dg/builtin-stringop-chk-8.c: New test.\n+\t* gcc.dg/builtin-stringop-chk-1.c: Adjust.\n+\t* gcc.dg/builtin-stringop-chk-4.c: Same.\n+\t* gcc.dg/builtin-strncat-chk-1.c: Same.\n+\t* g++.dg/ext/strncpy-chk1.C: Same.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n+\t* gcc.dg/out-of-bounds-1.c: Same.\n+\t* gcc.dg/pr78138.c: Same.\n+\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Same.\n+\t* gfortran.dg/mvbits_7.f90: Same.\n+\n 2017-05-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR preprocessor/79214"}, {"sha": "ff591a01f994083f76a0289aaee25ab39ce69d32", "filename": "gcc/testsuite/g++.dg/ext/strncpy-chk1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstrncpy-chk1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstrncpy-chk1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstrncpy-chk1.C?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -9,7 +9,7 @@ struct B { char z[50]; };\n inline void\n foo (char *dest, const char *__restrict src, __SIZE_TYPE__ n)\n {\n-  __builtin___strncpy_chk (dest, src, n, __builtin_object_size (dest, 0));\t// { dg-warning \"specified bound 36 exceeds the size 35 of the destination\" }\n+  __builtin___strncpy_chk (dest, src, n, __builtin_object_size (dest, 0));\t// { dg-warning \"specified bound 36 exceeds destination size 35\" }\n }\n \n void bar (const char *, int);"}, {"sha": "c72532be4f4057dee3f12e2f3789aa25b7659ee9", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-sizeof-array-argument\" }\n+// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }"}, {"sha": "ebf6e85f0ce44ea2fd21aea6c3476fa1b0a8add2", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -37,9 +37,9 @@ test (int arg, ...)\n   vx = stpcpy (&buf2[18], \"a\");\n   vx = stpcpy (&buf2[18], \"ab\"); /* { dg-warning \"writing 3\" \"stpcpy\" } */\n   strncpy (&buf2[18], \"a\", 2);\n-  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"strncpy\" } */\n+  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"specified bound 3 exceeds destination size 2\" \"strncpy\" } */\n   strncpy (&buf2[18], \"abc\", 2);\n-  strncpy (&buf2[18], \"abc\", 3); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"strncpy\" } */\n+  strncpy (&buf2[18], \"abc\", 3); /* { dg-warning \"writing 3 \" \"strncpy\" } */\n   memset (buf2, '\\0', sizeof (buf2));\n   strcat (&buf2[18], \"a\");\n   memset (buf2, '\\0', sizeof (buf2));\n@@ -54,7 +54,7 @@ test (int arg, ...)\n      Although this particular call wouldn't overflow buf2,\n      incorrect buffer size was passed to it and therefore\n      we want a warning and runtime failure.  */\n-  snprintf (&buf2[18], 3, \"%d\", x); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"snprintf\" } */\n+  snprintf (&buf2[18], 3, \"%d\", x); /* { dg-warning \"specified bound 3 exceeds destination size 2\" \"snprintf\" } */\n   va_start (ap, arg);\n   vsprintf (&buf2[18], \"a\", ap);\n   va_end (ap);\n@@ -67,7 +67,7 @@ test (int arg, ...)\n   va_end (ap);\n   va_start (ap, arg);\n   /* See snprintf above.  */\n-  vsnprintf (&buf2[18], 3, \"%s\", ap); /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" \"vsnprintf\" } */\n+  vsnprintf (&buf2[18], 3, \"%s\", ap); /* { dg-warning \"specified bound 3 exceeds destination size 2\" \"vsnprintf\" } */\n   va_end (ap);\n \n   p = p + 10;\n@@ -94,7 +94,7 @@ void\n test2 (const H h)\n {\n   char c;\n-  strncpy (&c, str, 3); /* { dg-warning \"specified bound 3 exceeds the size 1 of the destination\" \"strncpy\" } */\n+  strncpy (&c, str, 3); /* { dg-warning \"specified bound 3 exceeds destination size 1\" \"strncpy\" } */\n \n   struct { char b[4]; } x;\n   sprintf (x.b, \"%s\", \"ABCD\"); /* { dg-warning \"writing 5\" \"sprintf\" } */"}, {"sha": "c0110f2eb62aaba5dcb19478582d404cfdcec970", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-4.c", "status": "modified", "additions": 32, "deletions": 53, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -77,32 +77,11 @@ signed_range (ptrdiff_t min, ptrdiff_t max)\n #define UR(min, max)   unsigned_range (min, max)\n #define SR(min, max)   signed_range (min, max)\n \n-/* UReturn a pointer to constant string whose length is at least MINLEN\n+/* Return a pointer to constant string whose length is at least MINLEN\n    and at most 10.  */\n-static inline const char*\n-string_range (size_t minlen)\n-{\n-  static const char str[] = \"0123456789\";\n-\n-  const size_t len = unsigned_range (minlen, sizeof str - 1);\n-\n-  switch (len)\n-    {\n-    case 10: return \"0123456789\";\n-    case  9: return \"012345678\";\n-    case  8: return \"01234567\";\n-    case  7: return \"0123456\";\n-    case  6: return \"012345\";\n-    case  5: return \"01234\";\n-    case  4: return \"0123\";\n-    case  3: return \"012\";\n-    case  2: return \"01\";\n-    case  1: return \"0\";\n-    case  0: return \"\";\n-    }\n-}\n-\n-#define S(minlen)   string_range (minlen)\n+#define S(minlen)\t\t\t\t\\\n+  (minlen == random_unsigned_value ()\t\t\\\n+   ? \"0123456789\" + 10 - minlen : \"0123456789\")\n \n /* Test memcpy with a number of bytes bounded by a known range.  */\n \n@@ -122,7 +101,7 @@ void test_memcpy_range (void *d, const void *s)\n \n   memcpy (buf + size_max, s, UR (1, 2));  /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 overflows the destination\" \"excessive pointer offset\" { xfail *-*-* } } */\n \n-  memcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  memcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing \\[0-9\\]+ or more bytes into a region of size 5 overflows the destination\" } */\n   memcpy (buf, s, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n   memcpy (buf, s, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n \n@@ -207,7 +186,7 @@ void test_mempcpy_range (void *d, const void *s)\n \n   mempcpy (buf, s, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n \n-  mempcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  mempcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing \\[0-9\\]+ or more bytes into a region of size 5 overflows the destination\" } */\n   mempcpy (buf, s, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n   mempcpy (buf, s, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n \n@@ -233,7 +212,7 @@ void test_memset_range (void *d)\n \n   memset (buf, 0, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n \n-  memset (buf, 0, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  memset (buf, 0, UR (ssize_max, size_max));   /* { dg-warning \"writing \\[0-9\\]+ or more bytes into a region of size 5 overflows the destination\" } */\n   memset (buf, 0, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n   memset (buf, 0, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n \n@@ -259,7 +238,7 @@ void test_bzero_range (void *d)\n \n   bzero (buf, UR (6, 7));  /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 overflows the destination\" } */\n \n-  bzero (buf, UR (ssize_max, size_max));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 overflows the destination\" } */\n+  bzero (buf, UR (ssize_max, size_max));   /* { dg-warning \"writing \\[0-9\\]+ or more bytes into a region of size 5 overflows the destination\" } */\n   bzero (buf, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n   bzero (buf, UR (size_max - 1, size_max));  /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n \n@@ -281,7 +260,7 @@ void test_strcat_range (void)\n   strcat (buf, S (2));\n   strcat (buf, S (3));\n   strcat (buf, S (4));\n-  strcat (buf, S (5));   /* { dg-warning \"writing 6 bytes into a region of size 5 \" } */\n+  strcat (buf, S (5));   /* { dg-warning \"writing between 6 and 11 bytes into a region of size 5 \" } */\n \n   {\n     /* The implementation of the warning isn't smart enough to determine\n@@ -320,10 +299,10 @@ void test_strcpy (const char *src)\n   strcpy (a.a + 2, src);    /* { dg-warning \"writing at least 1 byte into a region of size 0 \" \"strcpy into empty substring\" { xfail *-*-* } } */\n \n   /* This does work.  */\n-  strcpy (a.a + 5, src);    /* { dg-warning \"writing at least 1 byte into a region of size 0 \" } */\n+  strcpy (a.a + 5, src);    /* { dg-warning \"writing 1 or more bytes into a region of size 0 \" } */\n \n   /* As does this.  */\n-  strcpy (a.a + 17, src);    /* { dg-warning \"writing at least 1 byte into a region of size 0 \" } */\n+  strcpy (a.a + 17, src);    /* { dg-warning \"writing 1 or more bytes into a region of size 0 \" } */\n }\n \n /* Test strcpy with a non-constant source string of length in a known\n@@ -337,16 +316,16 @@ void test_strcpy_range (void)\n   strcpy (buf, S (1));\n   strcpy (buf, S (2));\n   strcpy (buf, S (4));\n-  strcpy (buf, S (5));   /* { dg-warning \"writing 6 bytes into a region of size 5 \" } */\n-  strcpy (buf, S (6));   /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n-  strcpy (buf, S (7));   /* { dg-warning \"writing 8 bytes into a region of size 5 \" } */\n-  strcpy (buf, S (8));   /* { dg-warning \"writing 9 bytes into a region of size 5 \" } */\n-  strcpy (buf, S (9));   /* { dg-warning \"writing 10 bytes into a region of size 5 \" } */\n-  strcpy (buf, S (10));   /* { dg-warning \"writing 11 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (5));   /* { dg-warning \"writing between 6 and 11 bytes into a region of size 5 \" } */\n+  strcpy (buf, S (6));   /* { dg-warning \"writing between 7 and 11 bytes\" } */\n+  strcpy (buf, S (7));   /* { dg-warning \"writing between 8 and 11 bytes\" } */\n+  strcpy (buf, S (8));   /* { dg-warning \"writing between 9 and 11 bytes\" } */\n+  strcpy (buf, S (9));   /* { dg-warning \"writing between 10 and 11 bytes\" } */\n+  strcpy (buf, S (10));   /* { dg-warning \"writing 11 bytes\" } */\n \n-  strcpy (buf + 5, S (0));   /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n+  strcpy (buf + 5, S (0));   /* { dg-warning \"writing between 1 and 11 bytes\" } */\n \n-  strcpy (buf + 17, S (0));   /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n+  strcpy (buf + 17, S (0));   /* { dg-warning \"writing between 1 and 11 bytes \" } */\n }\n \n /* Test strncat with an argument referencing a non-constant string of\n@@ -364,31 +343,31 @@ void test_strncat_range (void)\n \n   strncat (buf + 5, S (0), 0);\n \n-  strncat (buf + 5, S (0), 1);   /* { dg-warning \"specified bound 1 exceeds the size 0 of the destination \" } */\n-  strncat (buf + 5, S (1), 1);   /* { dg-warning \"specified bound 1 exceeds the size 0 of the destination \" } */\n+  strncat (buf + 5, S (0), 1);   /* { dg-warning \"specified bound 1 exceeds destination size 0\" } */\n+  strncat (buf + 5, S (1), 1);   /* { dg-warning \"specified bound 1 exceeds destination size 0\" } */\n \n   /* Strncat always appends a terminating null after copying the N\n      characters so the following triggers a warning pointing out\n      that specifying sizeof(buf) as the upper bound may cause\n      the nul to overflow the destination.  */\n-  strncat (buf, S (0), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination\" } */\n-  strncat (buf, S (0), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+  strncat (buf, S (0), 5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n+  strncat (buf, S (0), 6);   /* { dg-warning \"specified bound 6 exceeds destination size 5\" } */\n \n   strncat (buf, S (1), 0);\n   strncat (buf, S (1), 1);\n   strncat (buf, S (1), 2);\n   strncat (buf, S (1), 3);\n   strncat (buf, S (1), 4);\n-  strncat (buf, S (1), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination\" } */\n-  strncat (buf, S (1), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n-  strncat (buf, S (2), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+  strncat (buf, S (1), 5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n+  strncat (buf, S (1), 6);   /* { dg-warning \"specified bound 6 exceeds destination size 5\" } */\n+  strncat (buf, S (2), 6);   /* { dg-warning \"specified bound 6 exceeds destination size 5\" } */\n \n   /* The following could just as well say \"writing 6 bytes into a region\n      of size 5.  Either would be correct and probably equally as clear\n      in this case.  But when the length of the source string is not known\n      at all then the bound warning seems clearer.  */\n-  strncat (buf, S (5), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination \" } */\n-  strncat (buf, S (7), 6);   /* { dg-warning \"specified bound 6 exceeds the size 5 of the destination\" } */\n+  strncat (buf, S (5), 6);   /* { dg-warning \"specified bound 6 exceeds destination size 5\" } */\n+  strncat (buf, S (7), 6);   /* { dg-warning \"specified bound 6 exceeds destination size 5\" } */\n \n   {\n     /* The implementation of the warning isn't smart enough to determine\n@@ -413,15 +392,15 @@ void test_strncat_chk_range (char *d)\n   strncat_chk (buf, S (0), 2);\n   strncat_chk (buf, S (0), 3);\n   strncat_chk (buf, S (0), 4);\n-  strncat_chk (buf, S (0), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination \" } */\n+  strncat_chk (buf, S (0), 5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n \n   strncat_chk (buf, S (5), 1);\n   strncat_chk (buf, S (5), 2);\n   strncat_chk (buf, S (5), 3);\n   strncat_chk (buf, S (5), 4);\n-  strncat_chk (buf, S (5), 5);   /* { dg-warning \"specified bound 5 equals the size of the destination \" } */\n+  strncat_chk (buf, S (5), 5);   /* { dg-warning \"specified bound 5 equals destination size\" } */\n \n-  strncat_chk (buf, S (5), 10);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds the size 5 of the destination \" } */\n+  strncat_chk (buf, S (5), 10);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds destination size 5\" } */\n \n   strncat_chk (d, S (5), size_max);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \" } */\n }\n@@ -491,7 +470,7 @@ void test_strncpy_string_count_range (char *dst, const char *src)\n \n   strncpy (buf, S (0), UR (6, 7));   /* { dg-warning \"writing between 6 and 7 bytes into a region of size 5 \" } */\n   strncpy (buf, S (1), UR (7, 8));   /* { dg-warning \"writing between 7 and 8 bytes into a region of size 5 \" } */\n-  strncpy (buf, S (2), UR (ssize_max, ssize_max + 1));   /* { dg-warning \"writing between \\[0-9\\]+ and \\[0-9\\]+ bytes into a region of size 5 \" } */\n+  strncpy (buf, S (2), UR (ssize_max, ssize_max + 1));   /* { dg-warning \"writing \\[0-9\\]+ or more bytes into a region of size 5 \" } */\n \n   strncpy (buf, S (2), UR (ssize_max + 1, ssize_max + 2));   /* { dg-warning \"specified size between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */\n "}, {"sha": "f4056f3632b771ecf9103012179572f510678e91", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-8.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -0,0 +1,173 @@\n+/* Test exercising -Wstringop-overflow warnings for reading past the end.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstringop-overflow=1 -ftrack-macro-expansion=0\" } */\n+\n+#define PTRDIFF_MAX   __PTRDIFF_MAX__\n+#define SIZE_MAX      __SIZE_MAX__\n+\n+#define offsetof(type, mem)   __builtin_offsetof (type, mem)\n+\n+/* Return the number of bytes from member MEM of TYPE to the end\n+   of object OBJ.  */\n+#define offsetfrom(type, obj, mem) (sizeof (obj) - offsetof (type, mem))\n+\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void* memchr (const void*, int, size_t);\n+extern int memcmp (const void*, const void*, size_t);\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memmove (void*, const void*, size_t);\n+extern void* mempcpy (void*, const void*, size_t);\n+\n+#define memchr(d, s, n) sink (memchr (d, s, n))\n+#define memcmp(d, s, n) sink (d, memcmp (d, s, n))\n+#define memcpy(d, s, n) sink (memcpy (d, s, n))\n+#define memmove(d, s, n) sink (memmove (d, s, n))\n+#define mempcpy(d, s, n) sink (mempcpy (d, s, n))\n+\n+struct A { char a, b; };\n+struct B { struct A a; char c, d; };\n+\n+/* Function to call to \"escape\" pointers from tests below to prevent\n+   GCC from assuming the values of the objects they point to stay\n+   the unchanged.  */\n+void sink (void*, ...);\n+\n+/* Function to \"generate\" a random number each time it's called.  Declared\n+   (but not defined) and used to prevent GCC from making assumptions about\n+   their values based on the variables uses in the tested expressions.  */\n+size_t random_unsigned_value (void);\n+\n+/* Return a random unsigned value between MIN and MAX.  */\n+\n+static inline size_t\n+range (size_t min, size_t max)\n+{\n+  const size_t val = random_unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+#define R(min, max)   range (min, max)\n+\n+/* Verify that reading beyond the end of a local array is diagnosed.  */\n+\n+void test_memop_warn_local (void *p, const void *q)\n+{\n+  memcpy (p, \"1234\", R (6, 7));   /* { dg-warning \"reading between 6 and 7 bytes from a region of size 5\" } */\n+\n+  struct A a[2];\n+\n+  memcpy (p, a, R (7, 8));   /* { dg-warning \"reading between 7 and 8 bytes from a region of size 4\" } */\n+\n+  /* At -Wstringop-overflow=1 the destination is considered to be\n+     the whole array and its size is therefore sizeof a.  */\n+  memcpy (p, &a[0], R (8, 9));   /* { dg-warning \"reading between 8 and 9 bytes from a region of size 4\" } */\n+\n+  /* Verify the same as above but by reading from the first mmeber\n+     of the first element of the array.  */\n+  memcpy (p, &a[0].a, R (8, 9));   /* { dg-warning \"reading between 8 and 9 bytes from a region of size 4\" } */\n+\n+  struct B b[2];\n+\n+  memcpy (p, &b[0], R (12, 32));   /* { dg-warning \"reading between 12 and 32 bytes from a region of size 8\" } */\n+\n+  /* Verify memchr/memcmp.  */\n+  int i = R (0, 255);\n+  memchr (\"\", i, 2);   /* { dg-warning \"reading 2 bytes from a region of size 1\" } */\n+  memchr (\"\", i, 2);   /* { dg-warning \"reading 2 bytes from a region of size 1\" } */\n+  memchr (\"123\", i, 5);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n+  memchr (a, i, sizeof a + 1);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n+\n+  memcmp (p, \"\", 2);   /* { dg-warning \"reading 2 bytes from a region of size 1\" } */\n+  memcmp (p, \"123\", 5);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n+  memcmp (p, a, sizeof a + 1);   /* { dg-warning \"reading 5 bytes from a region of size 4\" } */\n+\n+  size_t n = PTRDIFF_MAX + (size_t)1;\n+  memchr (p, 1, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+  memcmp (p, q, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+\n+  n = SIZE_MAX;\n+  memchr (p, 1, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+  memcmp (p, q, n);   /* { dg-warning \"exceeds maximum object size\" } */\n+}\n+\n+/* Verify that reading beyond the end of a dynamically allocated array\n+   of known size is diagnosed.  */\n+\n+void test_memop_warn_alloc (void *p)\n+{\n+  size_t n;\n+\n+  n = range (8, 32);\n+\n+  struct A *a = __builtin_malloc (sizeof *a * 2);\n+\n+  memcpy (p, a, n);   /* { dg-warning \"reading between 8 and 32 bytes from region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n+\n+  memcpy (p, &a[0], n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n+\n+  memcpy (p, &a[0].a, n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n+\n+  n = range (12, 32);\n+\n+  struct B *b = __builtin_malloc (sizeof *b * 2);\n+\n+  memcpy (p, &b[0], n);   /* { dg-warning \"reading between 12 and 32 bytes from a region of size 8\" \"memcpy from allocated\" { xfail *-*-*} } */\n+\n+  /* Verify memchr/memcmp.  */\n+  n = sizeof *b * 2 + 1;\n+\n+  memchr (b, 1, n);   /* { dg-warning \"reading 5 bytes from a region of size 4\" \"memcmp from allocated\" { xfail *-*-* } } */\n+  memcmp (p, b, n);   /* { dg-warning \"reading 5 bytes from a region of size 4\" \"memcmp from allocated\" { xfail *-*-* } } */\n+}\n+\n+\n+void test_memop_nowarn (void *p)\n+{\n+  struct B b[2];\n+\n+  size_t n = range (sizeof b, 32);\n+\n+  /* Verify that copying the whole array is not diagnosed regardless\n+     of whether the expression pointing to its beginning is obtained\n+     from the array itself or its first member(s).  */\n+  memcpy (p, b, n);\n+\n+  memcpy (p, &b[0], n);\n+\n+  memcpy (p, &b[0].a, n);\n+\n+  memcpy (p, &b[0].a.a, n);\n+\n+  /* Verify that memchr/memcmp doesn't cause a warning.  */\n+  memchr (p, 1, n);\n+  memchr (b, 2, n);\n+  memchr (&b[0], 3, n);\n+  memchr (&b[0].a, 4, n);\n+  memchr (&b[0].a.a, 5, n);\n+  memchr (\"01234567\", R (0, 255), n);\n+\n+  memcmp (p, p, n);\n+  memcmp (p, b, n);\n+  memcmp (p, &b[0], n);\n+  memcmp (p, &b[0].a, n);\n+  memcmp (p, &b[0].a.a, n);\n+  memcmp (p, \"01234567\", n);\n+}\n+\n+\n+/* The following function could specify in its API that it takes\n+   an array of exactly two elements, as shown below (or simply be\n+   called with such an array).  Verify that reading from both\n+   elements is not diagnosed.  */\n+void test_memop_nowarn_arg (void*, const struct A[2]);\n+\n+void test_memop_nowarn_arg (void *p, const struct A *a)\n+{\n+  memcpy (p, a, 2 * sizeof *a);\n+\n+  memcpy (p, a, range (2 * sizeof *a, 123));\n+\n+  memchr (p, 1, 1234);\n+  memcmp (p, a, 1234);\n+}"}, {"sha": "851fb7418c1d8b39a52648d89a9a1a5ae0934c8d", "filename": "gcc/testsuite/gcc.dg/builtin-strncat-chk-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-strncat-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-strncat-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-strncat-chk-1.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -28,11 +28,11 @@ test (int arg, ...)\n   *p = 0;\n   strncat (p, \"abcdefgh\", 11);\n   *p = 0;\n-  strncat (p, \"abcdefghijkl\", 11); /* { dg-warning \"specified bound 11 exceeds the size 10 of the destination\" } */\n+  strncat (p, \"abcdefghijkl\", 11); /* { dg-warning \"specified bound 11 exceeds destination size 10\" } */\n   *p = 0;\n   strncat (p, q, 9);\n   *p = 0;\n-  strncat (p, q, 10); /* { dg-warning \"specified bound 10 equals the size of the destination\" } */\n+  strncat (p, q, 10); /* { dg-warning \"specified bound 10 equals destination size\" } */\n   *p = 0;\n-  strncat (p, q, 11); /* { dg-warning \"specified bound 11 exceeds the size 10 of the destination\" } */\n+  strncat (p, q, 11); /* { dg-warning \"specified bound 11 exceeds destination size 10\" } */\n }"}, {"sha": "1c76341af272ba6268dcf0937cd510457a7c3ce0", "filename": "gcc/testsuite/gcc.dg/out-of-bounds-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fout-of-bounds-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fout-of-bounds-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fout-of-bounds-1.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -9,5 +9,5 @@ void ProjectOverlay(const float localTextureAxis[2], char *lump)\n {\n    const void *d = &localTextureAxis;\n    int size = sizeof(float)*8 ;\n-   __builtin_memcpy( &lump[ 0 ], d, size );  \n+   __builtin_memcpy( &lump[ 0 ], d, size );  /* { dg-warning \"reading\" } */\n }"}, {"sha": "c0c861e12e88cfa5eee8aa10c0279f1f7f8aab58", "filename": "gcc/testsuite/gcc.dg/pr78138.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78138.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78138.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr78138.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -12,7 +12,7 @@ extern char* strcpy (char*, const char*);\n \n void f (int i, int j)\n {\n-  strcpy (d, j ? \"12345\" : \"123456\");   /* { dg-warning \".strcpy. writing 6 bytes into a region of size 5\" } */\n+  strcpy (d, j ? \"12345\" : \"123456\");   /* { dg-warning \".strcpy.: writing between 6 and 7 bytes into a region of size 5 \" } */\n }\n \n void g (void *p)"}, {"sha": "a73e45fb80971eee0dafbc910a864c6eedd1c1e3", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -1,6 +1,6 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-sizeof-array-argument\" } */\n+/* { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n /* Test just twice, once with -O0 non-fortified, once with -O2 fortified.  */\n /* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } } */\n /* { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } } */"}, {"sha": "c4dbf3e9305ffd8107828e9d0ddc8ea44b7d563f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -1576,7 +1576,7 @@ void test_snprintf_chk_c_const (void)\n   /* Verify that specifying a size of the destination buffer that's\n      bigger than its actual size (normally determined and passed to\n      the function by __builtin_object_size) is diagnosed.  */\n-  FUNC (__snprintf_chk)(buffer, 3, 0, 2, \" \");   /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" } */\n+  FUNC (__snprintf_chk)(buffer, 3, 0, 2, \" \");   /* { dg-warning \"specified bound 3 exceeds destination size 2\" } */\n \n   T (-1, \"%c\",    0);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n@@ -1717,7 +1717,7 @@ void test_vsnprintf_chk_s (va_list va)\n   /* Verify that specifying a size of the destination buffer that's\n      bigger than its actual size (normally determined and passed to\n      the function by __builtin_object_size) is diagnosed.  */\n-  FUNC (__vsnprintf_chk)(buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"specified bound 123 exceeds the size 122 of the destination\" } */\n+  FUNC (__vsnprintf_chk)(buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"specified bound 123 exceeds destination size 122\" } */\n \n   FUNC (__vsnprintf_chk)(buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n "}, {"sha": "104ec67e4ff5fcfe1a745e2cf8fbdf10130d1550", "filename": "gcc/testsuite/gfortran.dg/mvbits_7.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgfortran.dg%2Fmvbits_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb/gcc%2Ftestsuite%2Fgfortran.dg%2Fmvbits_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmvbits_7.f90?ref=d9c5a8b98a21ab0091bbe0f3dab93dd59e6c58fb", "patch": "@@ -25,6 +25,6 @@ SUBROUTINE foo (x)\n   SUBROUTINE bar (x, NF4, NF3, NF1, MF1, MF4, MF3)\n     TYPE(t) x(NF4, NF3)  ! Dependency through variable indices\n     CALL MVBITS (x(NF4:NF1:MF1, NF1:NF3)%i, 1, &\n-                 6, x(-MF4:-MF1:-NF1, -MF1:-MF3)%i, 9)\n+                 6, x(-MF4:-MF1:-NF1, -MF1:-MF3)%i, 9)   ! { dg-warning \"reading\" }\n   END SUBROUTINE\n end"}]}