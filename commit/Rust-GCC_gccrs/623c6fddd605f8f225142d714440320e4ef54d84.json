{"sha": "623c6fddd605f8f225142d714440320e4ef54d84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIzYzZmZGRkNjA1ZjhmMjI1MTQyZDcxNDQ0MDMyMGU0ZWY1NGQ4NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-01-15T00:28:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-01-15T00:28:43Z"}, "message": "tree-optimization: Fix tree dse of strncpy PR93249\n\nAs the testcase shows, tail trimming of strncpy in tree-ssa-dse.c is fine,\nwe just copy or clear fewer bytes in the destination, but unlike\nmemcpy/memset etc., head trimming is problematic in certain cases.\nIf we can prove that there are no zero bytes among initial head_trim bytes,\nit is ok to trim it, if we can prove there is at least one zero byte among\ninitial head_trim bytes, we could (not implemented in the patch) turn\nthe strncpy into memset 0, but otherwise we need to avoid the head trimming,\nbecause the presence or absence of NUL byte there changes the behavior for\nsubsequent bytes, whether further bytes from src are copied or if further\nbytes are cleared.\n\n2020-01-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/93249\n\t* tree-ssa-dse.c: Include builtins.h and gimple-fold.h.\n\t(maybe_trim_memstar_call): Move head_trim and tail_trim vars to\n\tfunction body scope, reindent.  For BUILTIN_IN_STRNCPY*, don't\n\tperform head trim unless we can prove there are no '\\0' chars\n\tfrom the source among the first head_trim chars.\n\n\t* gcc.c-torture/execute/pr93249.c: New test.", "tree": {"sha": "307ab325b0611135185827e918ffcff7bf0abfef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/307ab325b0611135185827e918ffcff7bf0abfef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/623c6fddd605f8f225142d714440320e4ef54d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623c6fddd605f8f225142d714440320e4ef54d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/623c6fddd605f8f225142d714440320e4ef54d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623c6fddd605f8f225142d714440320e4ef54d84/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8998708ca316249e475d139c89ae7d169e64d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8998708ca316249e475d139c89ae7d169e64d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8998708ca316249e475d139c89ae7d169e64d34"}], "stats": {"total": 163, "additions": 123, "deletions": 40}, "files": [{"sha": "8f4382030b94ca82d613eb1b2580f41b94374631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=623c6fddd605f8f225142d714440320e4ef54d84", "patch": "@@ -1,3 +1,12 @@\n+2020-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93249\n+\t* tree-ssa-dse.c: Include builtins.h and gimple-fold.h.\n+\t(maybe_trim_memstar_call): Move head_trim and tail_trim vars to\n+\tfunction body scope, reindent.  For BUILTIN_IN_STRNCPY*, don't\n+\tperform head trim unless we can prove there are no '\\0' chars\n+\tfrom the source among the first head_trim chars.\n+\n 2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (ANALYZER_OBJS): Add analyzer/function-set.o."}, {"sha": "77d573fed2873d23dbbc794e9cc346f72e8e8378", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=623c6fddd605f8f225142d714440320e4ef54d84", "patch": "@@ -1,3 +1,8 @@\n+2020-01-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93249\n+\t* gcc.c-torture/execute/pr93249.c: New test.\n+\n 2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/analyzer/signal-5.c: New test."}, {"sha": "2c9a6b4dee0f9f0b49770e5ccbc453bbcafa4ecd", "filename": "gcc/testsuite/gcc.c-torture/execute/pr93249.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr93249.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr93249.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr93249.c?ref=623c6fddd605f8f225142d714440320e4ef54d84", "patch": "@@ -0,0 +1,40 @@\n+/* PR tree-optimization/93249 */\n+\n+char a[2], b[4], c[6];\n+\n+void\n+foo (void)\n+{\n+  char d[2] = { 0x00, 0x11 };\n+  __builtin_strncpy (&b[2], d, 2);\n+  __builtin_strncpy (&b[1], a, 2);\n+  if (b[0] || b[1] || b[2] || b[3])\n+    __builtin_abort ();\n+}\n+\n+void\n+bar (void)\n+{\n+  __builtin_strncpy (&b[2], \"\\0\\x11\", 2);\n+  __builtin_strncpy (&b[1], a, 2);\n+  if (b[0] || b[1] || b[2] || b[3])\n+    __builtin_abort ();\n+}\n+\n+void\n+baz (void)\n+{\n+  __builtin_strncpy (&c[2], \"\\x11\\x11\\0\\x11\", 4);\n+  __builtin_strncpy (&c[1], a, 2);\n+  if (c[0] || c[1] || c[2] || c[3] != 0x11 || c[4] || c[5])\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  bar ();\n+  baz ();\n+  return 0;\n+}"}, {"sha": "cb64d6fe83a64efa5ac3d3d022a4b14d3b661501", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 69, "deletions": 40, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623c6fddd605f8f225142d714440320e4ef54d84/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=623c6fddd605f8f225142d714440320e4ef54d84", "patch": "@@ -36,6 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alias.h\"\n #include \"tree-ssa-loop.h\"\n #include \"tree-ssa-dse.h\"\n+#include \"builtins.h\"\n+#include \"gimple-fold.h\"\n \n /* This file implements dead store elimination.\n \n@@ -456,56 +458,83 @@ increment_start_addr (gimple *stmt, tree *where, int increment)\n static void\n maybe_trim_memstar_call (ao_ref *ref, sbitmap live, gimple *stmt)\n {\n+  int head_trim, tail_trim;\n   switch (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)))\n     {\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+      compute_trims (ref, live, &head_trim, &tail_trim, stmt);\n+      if (head_trim)\n+\t{\n+\t  /* Head trimming of strncpy is only possible if we can\n+\t     prove all bytes we would trim are non-zero (or we could\n+\t     turn the strncpy into memset if there must be zero\n+\t     among the head trimmed bytes).  If we don't know anything\n+\t     about those bytes, the presence or absence of '\\0' bytes\n+\t     in there will affect whether it acts for the non-trimmed\n+\t     bytes as memset or memcpy/strncpy.  */\n+\t  c_strlen_data lendata = { };\n+\t  int orig_head_trim = head_trim;\n+\t  tree srcstr = gimple_call_arg (stmt, 1);\n+\t  if (!get_range_strlen (srcstr, &lendata, /*eltsize=*/1)\n+\t      || !tree_fits_uhwi_p (lendata.minlen))\n+\t    head_trim = 0;\n+\t  else if (tree_to_uhwi (lendata.minlen) < (unsigned) head_trim)\n+\t    {\n+\t      head_trim = tree_to_uhwi (lendata.minlen);\n+\t      if ((orig_head_trim & (UNITS_PER_WORD - 1)) == 0)\n+\t\thead_trim &= ~(UNITS_PER_WORD - 1);\n+\t    }\n+\t  if (orig_head_trim != head_trim\n+\t      && dump_file\n+\t      && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Adjusting strncpy trimming to (head = %d,\"\n+\t\t     \" tail = %d)\\n\", head_trim, tail_trim);\n+\t}\n+      goto do_memcpy;\n+\n     case BUILT_IN_MEMCPY:\n     case BUILT_IN_MEMMOVE:\n-    case BUILT_IN_STRNCPY:\n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMMOVE_CHK:\n-    case BUILT_IN_STRNCPY_CHK:\n-      {\n-\tint head_trim, tail_trim;\n-\tcompute_trims (ref, live, &head_trim, &tail_trim, stmt);\n-\n-\t/* Tail trimming is easy, we can just reduce the count.  */\n-        if (tail_trim)\n-\t  decrement_count (stmt, tail_trim);\n-\n-\t/* Head trimming requires adjusting all the arguments.  */\n-        if (head_trim)\n-          {\n-\t    tree *dst = gimple_call_arg_ptr (stmt, 0);\n-\t    increment_start_addr (stmt, dst, head_trim);\n-\t    tree *src = gimple_call_arg_ptr (stmt, 1);\n-\t    increment_start_addr (stmt, src, head_trim);\n-\t    decrement_count (stmt, head_trim);\n-\t  }\n-        break;\n-      }\n+      compute_trims (ref, live, &head_trim, &tail_trim, stmt);\n+\n+    do_memcpy:\n+      /* Tail trimming is easy, we can just reduce the count.  */\n+      if (tail_trim)\n+\tdecrement_count (stmt, tail_trim);\n+\n+      /* Head trimming requires adjusting all the arguments.  */\n+      if (head_trim)\n+\t{\n+\t  tree *dst = gimple_call_arg_ptr (stmt, 0);\n+\t  increment_start_addr (stmt, dst, head_trim);\n+\t  tree *src = gimple_call_arg_ptr (stmt, 1);\n+\t  increment_start_addr (stmt, src, head_trim);\n+\t  decrement_count (stmt, head_trim);\n+\t}\n+      break;\n \n     case BUILT_IN_MEMSET:\n     case BUILT_IN_MEMSET_CHK:\n-      {\n-\tint head_trim, tail_trim;\n-\tcompute_trims (ref, live, &head_trim, &tail_trim, stmt);\n-\n-\t/* Tail trimming is easy, we can just reduce the count.  */\n-        if (tail_trim)\n-\t  decrement_count (stmt, tail_trim);\n-\n-\t/* Head trimming requires adjusting all the arguments.  */\n-        if (head_trim)\n-          {\n-\t    tree *dst = gimple_call_arg_ptr (stmt, 0);\n-\t    increment_start_addr (stmt, dst, head_trim);\n-\t    decrement_count (stmt, head_trim);\n-\t  }\n-\tbreak;\n-      }\n+      compute_trims (ref, live, &head_trim, &tail_trim, stmt);\n+\n+      /* Tail trimming is easy, we can just reduce the count.  */\n+      if (tail_trim)\n+\tdecrement_count (stmt, tail_trim);\n+\n+      /* Head trimming requires adjusting all the arguments.  */\n+      if (head_trim)\n+\t{\n+\t  tree *dst = gimple_call_arg_ptr (stmt, 0);\n+\t  increment_start_addr (stmt, dst, head_trim);\n+\t  decrement_count (stmt, head_trim);\n+\t}\n+      break;\n \n-      default:\n-\tbreak;\n+    default:\n+      break;\n     }\n }\n "}]}