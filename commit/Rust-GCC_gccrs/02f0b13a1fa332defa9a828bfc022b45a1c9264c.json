{"sha": "02f0b13a1fa332defa9a828bfc022b45a1c9264c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJmMGIxM2ExZmEzMzJkZWZhOWE4MjhiZmMwMjJiNDVhMWM5MjY0Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-12T14:05:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-12T14:05:28Z"}, "message": "loop-36.c: Reduce amount of iterations to 2 so unrolling still happens.\n\n\n\t* gcc.dg/tree-ssa/loop-36.c: Reduce amount of iterations to 2 so unrolling\n\tstill happens.\n\t* gcc.dg/ipa/ipacost-1.c: Prevent inlining\n\t* gcc.dg/ipa/ipacost-2.c: Likewise.\n\t* gcc.dg/vect/slp-3.c: Loop is no longer unrolled.\n\n\t* tree-inline.c (estimate_operator_cost): Add operands;\n\twhen division happens by constant, it is cheap.\n\t(estimate_num_insns): Loads and stores are not having cost of 0;\n\tEH magic stuff is cheap; when computing runtime cost of switch,\n\tuse log2 base of amount of its cases; builtin_expect has cost of 0;\n\tcompute cost for moving return value of call.\n\t(init_inline_once): Initialize time_based flags.\n\t* tree-inline.h (eni_weights_d): Add time_based flag.\n\nFrom-SVN: r147436", "tree": {"sha": "63fd58b98168fb3c755ec6145a978b20b41a8e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63fd58b98168fb3c755ec6145a978b20b41a8e2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02f0b13a1fa332defa9a828bfc022b45a1c9264c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f0b13a1fa332defa9a828bfc022b45a1c9264c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f0b13a1fa332defa9a828bfc022b45a1c9264c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f0b13a1fa332defa9a828bfc022b45a1c9264c/comments", "author": null, "committer": null, "parents": [{"sha": "ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f"}], "stats": {"total": 87, "additions": 72, "deletions": 15}, "files": [{"sha": "529e0ba05b280864eda6c1f79a579522c8b810fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -1,3 +1,14 @@\n+2009-05-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c (estimate_operator_cost): Add operands;\n+\twhen division happens by constant, it is cheap.\n+\t(estimate_num_insns): Loads and stores are not having cost of 0;\n+\tEH magic stuff is cheap; when computing runtime cost of switch,\n+\tuse log2 base of amount of its cases; builtin_expect has cost of 0;\n+\tcompute cost for moving return value of call.\n+\t(init_inline_once): Initialize time_based flags.\n+\t* tree-inline.h (eni_weights_d): Add time_based flag.\n+\n 2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* df-core.c: Update head documentation."}, {"sha": "9e1a4a9c67ba493f2debc31adcd66b346245c246", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -1,3 +1,11 @@\n+2009-05-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-36.c: Reduce amount of iterations to 2 so unrolling\n+\tstill happens.\n+\t* gcc.dg/ipa/ipacost-1.c: Prevent inlining\n+\t* gcc.dg/ipa/ipacost-2.c: Likewise.\n+\t* gcc.dg/vect/slp-3.c: Loop is no longer unrolled.\n+\n 2009-05-12  David Billinghurst <billingd@gcc.gnu.org>\n \n \t* gfortran.dg/default_format_1.f90: XFAIL on cygwin. "}, {"sha": "d91546899ea747fbec19f3af95a99d54634208b2", "filename": "gcc/testsuite/gcc.dg/ipa/ipacost-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-1.c?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -46,6 +46,8 @@ i_can_not_be_propagated_fully2 (int *a)\n main()\n {\n   i_can_be_propagated_fully2 (array);\n+  i_can_be_propagated_fully2 (array);\n+  i_can_not_be_propagated_fully2 (array);\n   i_can_not_be_propagated_fully2 (array);\n }\n "}, {"sha": "958059c73e6e5493eb35a2286ca25794dfa79089", "filename": "gcc/testsuite/gcc.dg/ipa/ipacost-2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipacost-2.c?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -47,14 +47,16 @@ i_can_not_be_propagated_fully2 (int *a)\n main()\n {\n   i_can_be_propagated_fully2 (array);\n+  i_can_be_propagated_fully2 (array);\n+  i_can_not_be_propagated_fully2 (array);\n   i_can_not_be_propagated_fully2 (array);\n }\n \n /* { dg-final { scan-ipa-dump-times \"versioned function i_can_be_propagated_fully2\" 1 \"cp\"  } } */\n /* { dg-final { scan-ipa-dump-times \"versioned function i_can_be_propagated_fully \" 1 \"cp\"  } } */\n /* { dg-final { scan-ipa-dump-times \"versioned function i_can_not_be_propagated_fully2\" 1 \"cp\"  } } */\n /* { dg-final { scan-ipa-dump-times \"versioned function i_can_not_be_propagated_fully \" 1 \"cp\"  } } */\n-/* { dg-final { scan-tree-dump-not \"i_can_be_propagated\" \"optimized\"  } } */\n-/* { dg-final { scan-tree-dump-not \"i_can_be_propagated\" \"optimized\"  } } */\n+/* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully \\\\(\" \"optimized\"  } } */\n+/* { dg-final { scan-tree-dump-not \"i_can_be_propagated_fully2 \\\\(\" \"optimized\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9e917376581599226baa3767910ce709b63a5822", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-36.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-36.c?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -1,17 +1,17 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-dce2\" } */\n \n-struct X { float array[4]; };\n+struct X { float array[2]; };\n \n struct X a,b;\n \n float foobar () {\n   float s = 0;\n   unsigned int d;\n   struct X c;\n-  for (d=0; d<4; ++d)\n+  for (d=0; d<2; ++d)\n     c.array[d] = a.array[d] * b.array[d];\n-  for (d=0; d<4; ++d)\n+  for (d=0; d<2; ++d)\n     s+=c.array[d];\n   return s;\n }"}, {"sha": "070715371bb74d01551e9aebc09eb87bab982ca0", "filename": "gcc/testsuite/gcc.dg/vect/slp-3.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -142,8 +142,7 @@ int main (void)\n   return 0;\n }\n \n-/* One of the loops gets complettely unrolled.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n   "}, {"sha": "78cb716d7ad91f4e55f16b16ee36286af79ecbcb", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -2783,7 +2783,8 @@ estimate_move_cost (tree type)\n /* Returns cost of operation CODE, according to WEIGHTS  */\n \n static int\n-estimate_operator_cost (enum tree_code code, eni_weights *weights)\n+estimate_operator_cost (enum tree_code code, eni_weights *weights,\n+\t\t\ttree op1 ATTRIBUTE_UNUSED, tree op2)\n {\n   switch (code)\n     {\n@@ -2893,7 +2894,9 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights)\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n     case RDIV_EXPR:\n-      return weights->div_mod_cost;\n+      if (TREE_CODE (op2) != INTEGER_CST)\n+        return weights->div_mod_cost;\n+      return 1;\n \n     default:\n       /* We expect a copy assignment with no operator.  */\n@@ -2930,6 +2933,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n   unsigned cost, i;\n   enum gimple_code code = gimple_code (stmt);\n   tree lhs;\n+  tree rhs;\n \n   switch (code)\n     {\n@@ -2953,16 +2957,35 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \t of moving something into \"a\", which we compute using the function\n \t estimate_move_cost.  */\n       lhs = gimple_assign_lhs (stmt);\n+      rhs = gimple_assign_rhs1 (stmt);\n+\n+      /* EH magic stuff is most probably going to be optimized out.\n+         We rarely really need to save EH info for unwinding\n+         nested exceptions.  */\n+      if (TREE_CODE (lhs) == FILTER_EXPR\n+\t  || TREE_CODE (lhs) == EXC_PTR_EXPR\n+          || TREE_CODE (rhs) == FILTER_EXPR\n+\t  || TREE_CODE (rhs) == EXC_PTR_EXPR)\n+\treturn 0;\n       if (is_gimple_reg (lhs))\n \tcost = 0;\n       else\n \tcost = estimate_move_cost (TREE_TYPE (lhs));\n \n-      cost += estimate_operator_cost (gimple_assign_rhs_code (stmt), weights);\n+      if (!is_gimple_reg (rhs) && !is_gimple_min_invariant (rhs))\n+\tcost += estimate_move_cost (TREE_TYPE (rhs));\n+\n+      cost += estimate_operator_cost (gimple_assign_rhs_code (stmt), weights,\n+      \t\t\t\t      gimple_assign_rhs1 (stmt),\n+\t\t\t\t      get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n+\t\t\t\t      == GIMPLE_BINARY_RHS\n+\t\t\t\t      ? gimple_assign_rhs2 (stmt) : NULL);\n       break;\n \n     case GIMPLE_COND:\n-      cost = 1 + estimate_operator_cost (gimple_cond_code (stmt), weights);\n+      cost = 1 + estimate_operator_cost (gimple_cond_code (stmt), weights,\n+      \t\t\t\t         gimple_op (stmt, 0),\n+\t\t\t\t         gimple_op (stmt, 1));\n       break;\n \n     case GIMPLE_SWITCH:\n@@ -2971,7 +2994,10 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \n \t TODO: once the switch expansion logic is sufficiently separated, we can\n \t do better job on estimating cost of the switch.  */\n-      cost = gimple_switch_num_labels (stmt) * 2;\n+      if (weights->time_based)\n+        cost = floor_log2 (gimple_switch_num_labels (stmt)) * 2;\n+      else\n+        cost = gimple_switch_num_labels (stmt) * 2;\n       break;\n \n     case GIMPLE_CALL:\n@@ -2994,8 +3020,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \t    case BUILT_IN_CONSTANT_P:\n \t      return 0;\n \t    case BUILT_IN_EXPECT:\n-\t      cost = 0;\n-\t      break;\n+\t      return 0;\n \n \t    /* Prefetch instruction is not expensive.  */\n \t    case BUILT_IN_PREFETCH:\n@@ -3009,6 +3034,8 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \tif (decl)\n \t  funtype = TREE_TYPE (decl);\n \n+\tif (!VOID_TYPE_P (TREE_TYPE (funtype)))\n+\t  cost += estimate_move_cost (TREE_TYPE (funtype));\n \t/* Our cost must be kept in sync with\n \t   cgraph_estimate_size_after_inlining that does use function\n \t   declaration to figure out the arguments.  */\n@@ -3133,11 +3160,13 @@ init_inline_once (void)\n   eni_inlining_weights.target_builtin_call_cost = 1;\n   eni_inlining_weights.div_mod_cost = 10;\n   eni_inlining_weights.omp_cost = 40;\n+  eni_inlining_weights.time_based = true;\n \n   eni_size_weights.call_cost = 1;\n   eni_size_weights.target_builtin_call_cost = 1;\n   eni_size_weights.div_mod_cost = 1;\n   eni_size_weights.omp_cost = 40;\n+  eni_size_weights.time_based = false;\n \n   /* Estimating time for call is difficult, since we have no idea what the\n      called function does.  In the current uses of eni_time_weights,\n@@ -3147,6 +3176,7 @@ init_inline_once (void)\n   eni_time_weights.target_builtin_call_cost = 10;\n   eni_time_weights.div_mod_cost = 10;\n   eni_time_weights.omp_cost = 40;\n+  eni_time_weights.time_based = true;\n }\n \n /* Estimate the number of instructions in a gimple_seq. */"}, {"sha": "37e60bfd3609d69cfd4ae9ed18da8ac95fe28aa5", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f0b13a1fa332defa9a828bfc022b45a1c9264c/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=02f0b13a1fa332defa9a828bfc022b45a1c9264c", "patch": "@@ -130,6 +130,11 @@ typedef struct eni_weights_d\n \n   /* Cost for omp construct.  */\n   unsigned omp_cost;\n+\n+  /* True when time of statemnt should be estimated.  Thus i.e\n+     cost of switch statement is logarithmic rather than linear in number\n+     of cases.  */\n+  bool time_based;\n } eni_weights;\n \n /* Weights that estimate_num_insns uses for heuristics in inlining.  */"}]}