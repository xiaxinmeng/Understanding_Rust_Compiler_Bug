{"sha": "67d743fe7745039f5933f9d90f80c088a7a77077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdkNzQzZmU3NzQ1MDM5ZjU5MzNmOWQ5MGY4MGMwODhhN2E3NzA3Nw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-24T18:30:21Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-24T18:30:21Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11877", "tree": {"sha": "62f12c1696671cc71e7e6c052e9a6b9f479d17b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62f12c1696671cc71e7e6c052e9a6b9f479d17b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67d743fe7745039f5933f9d90f80c088a7a77077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67d743fe7745039f5933f9d90f80c088a7a77077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67d743fe7745039f5933f9d90f80c088a7a77077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67d743fe7745039f5933f9d90f80c088a7a77077/comments", "author": null, "committer": null, "parents": [{"sha": "9a57586f836ae5f1c69e868d6406299ebe2b11a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a57586f836ae5f1c69e868d6406299ebe2b11a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a57586f836ae5f1c69e868d6406299ebe2b11a4"}], "stats": {"total": 384, "additions": 345, "deletions": 39}, "files": [{"sha": "b455ae8cc52f755588edf058faee2736b1732234", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -1,3 +1,47 @@\n+Wed Apr 24 00:36:21 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst_expr, DECL_STMT): If we don't have an initializer,\n+\tdon't pass LOOKUP_ONLYCONVERTING.\n+\n+Tue Apr 23 17:18:47 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (common_type): Fix the ARRAY_TYPE case so it\n+\tproperly keeps track of const and volatile type modifiers.\n+\n+Tue Apr 23 10:52:56 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (cp_tree_equal): C++ version of simple_cst_equal.\n+\t* pt.c (comp_template_args): Use it.\n+\n+\t* rtti.c (get_tinfo_fn, build_dynamic_cast, expand_*_desc): Call\n+\tassemble_external for artificial function decls.\n+\n+\t* decl.c (cp_finish_decl): Oops.\n+\n+Mon Apr 22 17:28:27 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (import_export_decl): Put static data member templates\n+ \tinto common storage, or make them weak, depending on whether they\n+ \tare dynamically or statically initialized.\n+\t(get_sentry): New function.\n+\t(finish_file): Do import_export_decl for static data members before\n+\tbuilding the init/fini functions.  Don't init/fini a variable that's\n+\tEXTERNAL.  Use a sentry for variables in common.  Fix mismatching\n+\tpush/pop_temp_slots.\n+\t* decl.c (cp_finish_decl): If DECL_NOT_REALLY_EXTERN, do the\n+ \texpand_static_init thang.\n+\t* method.c (get_id_2): New function.\n+\n+Mon Apr 22 15:32:45 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* parse.y (empty_parms): Make sure we use C++-style prototypes\n+ \twhen we're declaring member functions.\n+\n+Sun Apr 21 10:08:22 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* Makefile.in (CONFLICTS): 16 s/r conflicts.\n+\t* parse.y (self_template_type): New nonterminal.\n+\n Thu Apr 18 08:56:54 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (make_typename_type): Handle getting a TYPE_DECL for a"}, {"sha": "fe9ef8dde8cae58325ffee3484fbe5acd3d0264a", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -195,7 +195,7 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n-CONFLICTS = expect 12 shift/reduce conflicts and 39 reduce/reduce conflicts.\n+CONFLICTS = expect 16 shift/reduce conflicts and 39 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)"}, {"sha": "a4b8c801e996d0e4380bbae98e4eda257a03241d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -6567,7 +6567,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t;\n-      else if (DECL_EXTERNAL (decl))\n+      else if (DECL_EXTERNAL (decl)\n+\t       && ! (DECL_LANG_SPECIFIC (decl)\n+\t\t     && DECL_NOT_REALLY_EXTERN (decl)))\n \t{\n \t  if (init)\n \t    DECL_INITIAL (decl) = init;"}, {"sha": "5c9cf35d7a15e0fae87deba086383f4c288ffc44", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 79, "deletions": 27, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -2729,14 +2729,26 @@ import_export_decl (decl)\n       DECL_NOT_REALLY_EXTERN (decl) = 1;\n       if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n \t{\n-\t  /* For now, leave vars public so multiple defs will break.  */\n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n \t    {\n \t      if (flag_weak)\n \t\tDECL_WEAK (decl) = 1;\n \t      else\n \t\tTREE_PUBLIC (decl) = 0;\n \t    }\n+\t  /* Dynamically initialized vars go into common.  */\n+\t  else if (DECL_INITIAL (decl) == NULL_TREE\n+\t\t   || DECL_INITIAL (decl) == error_mark_node)\n+\t    DECL_COMMON (decl) = 1;\n+\t  else if (EMPTY_CONSTRUCTOR_P (DECL_INITIAL (decl)))\n+\t    {\n+\t      DECL_COMMON (decl) = 1;\n+\t      DECL_INITIAL (decl) = error_mark_node;\n+\t    }\n+\t  /* Statically initialized vars are weak or comdat, if supported.  */\n+\t  else if (flag_weak)\n+\t    DECL_WEAK (decl) = 1;\n+\t  /* else leave vars public so multiple defs will break.  */\n \t}\n       else\n \tDECL_NOT_REALLY_EXTERN (decl) = 0;\n@@ -2808,6 +2820,31 @@ extern tree pending_templates;\n #define TIMEVAR(VAR, BODY)    \\\n do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)\n \n+extern struct obstack permanent_obstack;\n+extern tree get_id_2 ();\n+\n+tree\n+get_sentry (base)\n+     tree base;\n+{\n+  tree sname = get_id_2 (\"__sn\", base);\n+  tree sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n+  if (! sentry)\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      sentry = build_decl (VAR_DECL, sname, integer_type_node);\n+      TREE_PUBLIC (sentry) = 1;\n+      DECL_ARTIFICIAL (sentry) = 1;\n+      TREE_STATIC (sentry) = 1;\n+      TREE_USED (sentry) = 1;\n+      DECL_COMMON (sentry) = 1;\n+      pushdecl_top_level (sentry);\n+      cp_finish_decl (sentry, NULL_TREE, NULL_TREE, 0, 0);\n+      pop_obstacks ();\n+    }\n+  return sentry;\n+}\n+\n /* This routine is called from the last rule in yyparse ().\n    Its job is to create all the code needed to initialize and\n    destroy the global aggregates.  We do the destruction\n@@ -2880,6 +2917,18 @@ finish_file ()\n      that we can pick up any other tdecls that those routines need. */\n   walk_vtables ((void (*)())0, finish_prevtable_vardecl);\n \n+  for (vars = pending_statics; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree decl = TREE_VALUE (vars);\n+\n+      if (DECL_TEMPLATE_INSTANTIATION (decl)\n+\t  && ! DECL_IN_AGGR_P (decl))\n+\t{\n+\t  import_export_decl (decl);\n+\t  DECL_EXTERNAL (decl) = ! DECL_NOT_REALLY_EXTERN (decl);\n+\t}\n+    }\n+\n   vars = static_aggregates;\n \n   if (static_ctors || vars || might_have_exceptions_p ())\n@@ -2925,10 +2974,23 @@ finish_file ()\n       tree type = TREE_TYPE (decl);\n       tree temp = TREE_PURPOSE (vars);\n \n-      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars))\n+      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars)\n+\t  && ! DECL_EXTERNAL (decl))\n \t{\n \t  temp = build_cleanup (decl);\n+\n+\t  if (DECL_COMMON (decl))\n+\t    {\n+\t      tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+\t      sentry = build_unary_op (PREDECREMENT_EXPR, sentry, 0);\n+\t      sentry = build_binary_op (EQ_EXPR, sentry, integer_zero_node, 1);\n+\t      expand_start_cond (sentry, 0);\n+\t    }\n+\n \t  expand_expr_stmt (temp);\n+\n+\t  if (DECL_COMMON (decl))\n+\t    expand_end_cond ();\n \t}\n     }\n \n@@ -2983,11 +3045,12 @@ finish_file ()\n \t     then don't initialize it here.  Also, don't bother\n \t     with initializers that contain errors.  */\n \t  if (TREE_STATIC (vars)\n+\t      || DECL_EXTERNAL (decl)\n \t      || (init && TREE_CODE (init) == TREE_LIST\n \t\t  && value_member (error_mark_node, init)))\n \t    {\n \t      vars = TREE_CHAIN (vars);\n-\t      continue;\n+\t      goto next_mess;\n \t    }\n \n \t  if (TREE_CODE (decl) == VAR_DECL)\n@@ -3003,6 +3066,15 @@ finish_file ()\n \t      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n \t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n \n+\t      if (DECL_COMMON (decl))\n+\t\t{\n+\t\t  tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+\t\t  sentry = build_unary_op (PREINCREMENT_EXPR, sentry, 0);\n+\t\t  sentry = build_binary_op\n+\t\t    (EQ_EXPR, sentry, integer_one_node, 1);\n+\t\t  expand_start_cond (sentry, 0);\n+\t\t}\n+\n \t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t\texpand_aggr_init (decl, init, 0, 0);\n@@ -3016,32 +3088,19 @@ finish_file ()\n \t      else\n \t\texpand_assignment (decl, init, 0, 0);\n \n+\t      if (DECL_COMMON (decl))\n+\t\texpand_end_cond ();\n+\n \t      DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n \t      DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n \t    }\n-\t  else if (TREE_CODE (decl) == SAVE_EXPR)\n-\t    {\n-\t      if (! PARM_DECL_EXPR (decl))\n-\t\t{\n-\t\t  /* a `new' expression at top level.  */\n-\t\t  expand_expr (decl, const0_rtx, VOIDmode, 0);\n-\t\t  if (TREE_CODE (init) == TREE_VEC)\n-\t\t    {\n-\t\t      expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n-\t\t\t\t\t\t    TREE_VEC_ELT (init, 1),\n-\t\t\t\t\t\t    TREE_VEC_ELT (init, 2), 0),\n-\t\t\t\t   const0_rtx, VOIDmode, 0);\n-\t\t    }\n-\t\t  else\n-\t\t    expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0, 0);\n-\t\t}\n-\t    }\n \t  else if (decl == error_mark_node)\n \t    ;\n \t  else my_friendly_abort (22);\n \n \t  /* Cleanup any temporaries needed for the initial value.  */\n \t  expand_cleanups_to (old_cleanups);\n+\tnext_mess:\n \t  pop_temp_slots ();\n \t  pop_temp_slots ();\n \t  target_temp_slot_level = old_temp_level;\n@@ -3074,13 +3133,6 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (pending_statics);\n \n-      if (DECL_TEMPLATE_INSTANTIATION (decl)\n-\t  && ! DECL_IN_AGGR_P (decl))\n-\t{\n-\t  import_export_decl (decl);\n-\t  DECL_EXTERNAL (decl) = ! DECL_NOT_REALLY_EXTERN (decl);\n-\t}\n-\n       if (TREE_USED (decl) == 1\n \t  || TREE_READONLY (decl) == 0\n \t  || DECL_INITIAL (decl) == 0)"}, {"sha": "8a0735a9089c7fcc37404e934f5235f2ccefad68", "filename": "gcc/cp/method.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -1085,6 +1085,18 @@ build_overload_with_type (name, type)\n   return get_identifier (obstack_base (&scratch_obstack));\n }\n \n+tree\n+get_id_2 (name, name2)\n+     char *name;\n+     tree name2;\n+{\n+  OB_INIT ();\n+  OB_PUTCP (name);\n+  OB_PUTID (name2);\n+  OB_FINISH ();\n+  return get_identifier (obstack_base (&scratch_obstack));\n+}\n+\n /* Top-level interface to explicit overload requests. Allow NAME\n    to be overloaded. Error if NAME is already declared for the current\n    scope. Warning if function is redundantly overloaded. */"}, {"sha": "7f8d2a03bb4c63e9ef370fdee1a3666449ad4af2", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -88,7 +88,8 @@ empty_parms ()\n {\n   tree parms;\n \n-  if (strict_prototype)\n+  if (strict_prototype\n+      || current_class_type != NULL)\n     parms = void_list_node;\n   else\n     parms = NULL_TREE;\n@@ -265,6 +266,8 @@ empty_parms ()\n %type <ttype> named_class_head_sans_basetype_defn\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n \n+%type <ttype> self_template_type\n+\n %token NSNAME\n %type <ttype> NSNAME\n \n@@ -595,6 +598,48 @@ constructor_declarator:\n \t\t    }\n \t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $5);\n \t\t}\n+\t| nested_name_specifier self_template_type '(' \n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n+\t\t  if ($1 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($1, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t}\n+\t  parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>4, $5, $7); }\n+\t| nested_name_specifier self_template_type LEFT_RIGHT type_quals\n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n+\t\t  if ($1 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($1, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $4);\n+\t\t}\n+\t| global_scope nested_name_specifier self_template_type '(' \n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n+\t\t  if ($2 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($2, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t}\n+\t parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>5, $6, $8); }\n+\t| global_scope nested_name_specifier self_template_type LEFT_RIGHT type_quals\n+\t\t{\n+\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n+\t\t  if ($2 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($2, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $5);\n+\t\t}\n \t;\n \n fn.def1:\n@@ -636,6 +681,10 @@ component_constructor_declarator:\n \t\t{ $$ = build_parse_node (CALL_EXPR, $1, $3, $5); }\n \t| SELFNAME LEFT_RIGHT type_quals\n \t\t{ $$ = build_parse_node (CALL_EXPR, $1, empty_parms (), $3); }\n+\t| self_template_type '(' parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $1, $3, $5); }\n+\t| self_template_type LEFT_RIGHT type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $1, empty_parms (), $3); }\n \t;\n \n /* more C++ complexity.  See component_decl for a comment on the\n@@ -826,7 +875,11 @@ template_type:\n \t\t  if ($$ != error_mark_node)\n \t\t    $$ = TYPE_STUB_DECL ($$);\n \t\t}\n-\t| SELFNAME  '<' template_arg_list template_close_bracket\n+\t| self_template_type\n+\t;\n+\n+self_template_type:\n+\t  SELFNAME  '<' template_arg_list template_close_bracket\n \t\t{\n \t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n \t\t  if ($$ != error_mark_node)"}, {"sha": "5d1dfcef9803aefcd7b6e2dd6965241143acff87", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -463,10 +463,12 @@ comp_template_args (oldargs, newargs)\n \tcontinue;\n       if (TREE_CODE (nt) != TREE_CODE (ot))\n \treturn 0;\n-      if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't' && comptypes (ot, nt, 1))\n-\tcontinue;\n-      if (TREE_CODE (ot) == TEMPLATE_CONST_PARM\n-\t  && TEMPLATE_CONST_IDX (nt) == TEMPLATE_CONST_IDX (ot))\n+      if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n+\t{\n+\t  if (comptypes (ot, nt, 1))\n+\t    continue;\n+\t}\n+      else if (cp_tree_equal (ot, nt) > 0)\n \tcontinue;\n       return 0;\n     }\n@@ -2080,7 +2082,7 @@ tsubst_expr (t, args, nargs, in_decl)\n     case DECL_STMT:\n       {\n \tint i = suspend_momentary ();\n-\ttree dcl;\n+\ttree dcl, init;\n \n \tlineno = TREE_COMPLEXITY (t);\n \temit_line_note (input_filename, lineno);\n@@ -2089,9 +2091,9 @@ tsubst_expr (t, args, nargs, in_decl)\n \t   tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl),\n \t   TREE_OPERAND (t, 3) != 0,\n \t   tsubst (TREE_OPERAND (t, 2), args, nargs, in_decl));\n+\tinit = tsubst_expr (TREE_OPERAND (t, 3), args, nargs, in_decl);\n \tcp_finish_decl\n-\t  (dcl, tsubst_expr (TREE_OPERAND (t, 3), args, nargs, in_decl),\n-\t   NULL_TREE, 1, LOOKUP_ONLYCONVERTING);\n+\t  (dcl, init, NULL_TREE, 1, init ? LOOKUP_ONLYCONVERTING : 0);\n \tresume_momentary (i);\n \treturn dcl;\n       }"}, {"sha": "37e6698b17dc1397f7be78627c257a4deed21334", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -248,6 +248,7 @@ get_tinfo_fn (type)\n   TREE_TYPE (name) = type;\n   pushdecl_top_level (d);\n   make_function_rtl (d);\n+  assemble_external (d);\n   mark_inline_for_output (d);\n   if (at_eof)\n     import_export_decl (d);\n@@ -312,6 +313,7 @@ throw_bad_cast ()\n   DECL_ARTIFICIAL (d) = 1;\n   pushdecl_top_level (d);\n   make_function_rtl (d);\n+  assemble_external (d);\n \n   pop_obstacks ();\n \n@@ -519,6 +521,7 @@ build_dynamic_cast (type, expr)\n \t      DECL_ARTIFICIAL (dcast_fn) = 1;\n \t      pushdecl_top_level (dcast_fn);\n \t      make_function_rtl (dcast_fn);\n+\t      assemble_external (dcast_fn);\n \t      pop_obstacks ();\n \t    }\n \t  \n@@ -603,6 +606,7 @@ expand_si_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n+      assemble_external (fn);\n       pop_obstacks ();\n     }\n \n@@ -782,6 +786,7 @@ expand_class_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n+      assemble_external (fn);\n       pop_obstacks ();\n     }\n \n@@ -829,6 +834,7 @@ expand_ptr_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n+      assemble_external (fn);\n       pop_obstacks ();\n     }\n \n@@ -879,6 +885,7 @@ expand_attr_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n+      assemble_external (fn);\n       pop_obstacks ();\n     }\n \n@@ -920,6 +927,7 @@ expand_generic_desc (tdecl, type, fnname)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n+      assemble_external (fn);\n       pop_obstacks ();\n     }\n "}, {"sha": "11cc90da6fc6b7f6f8b9db0688deff7e7a77fd38", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -2013,3 +2013,130 @@ hack_decl_function_context (decl)\n     return decl_function_context (TYPE_MAIN_DECL (DECL_CLASS_CONTEXT (decl)));\n   return decl_function_context (decl);\n }\n+\n+/* Return truthvalue of whether T1 is the same tree structure as T2.\n+   Return 1 if they are the same.\n+   Return 0 if they are understandably different.\n+   Return -1 if either contains tree structure not understood by\n+   this function.  */\n+\n+int\n+cp_tree_equal (t1, t2)\n+     tree t1, t2;\n+{\n+  register enum tree_code code1, code2;\n+  int cmp;\n+\n+  if (t1 == t2)\n+    return 1;\n+  if (t1 == 0 || t2 == 0)\n+    return 0;\n+\n+  code1 = TREE_CODE (t1);\n+  code2 = TREE_CODE (t2);\n+\n+  if (code1 == NOP_EXPR || code1 == CONVERT_EXPR || code1 == NON_LVALUE_EXPR)\n+    if (code2 == NOP_EXPR || code2 == CONVERT_EXPR || code2 == NON_LVALUE_EXPR)\n+      return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+    else\n+      return cp_tree_equal (TREE_OPERAND (t1, 0), t2);\n+  else if (code2 == NOP_EXPR || code2 == CONVERT_EXPR\n+\t   || code2 == NON_LVALUE_EXPR)\n+    return cp_tree_equal (t1, TREE_OPERAND (t2, 0));\n+\n+  if (code1 != code2)\n+    return 0;\n+\n+  switch (code1)\n+    {\n+    case INTEGER_CST:\n+      return TREE_INT_CST_LOW (t1) == TREE_INT_CST_LOW (t2)\n+\t&& TREE_INT_CST_HIGH (t1) == TREE_INT_CST_HIGH (t2);\n+\n+    case REAL_CST:\n+      return REAL_VALUES_EQUAL (TREE_REAL_CST (t1), TREE_REAL_CST (t2));\n+\n+    case STRING_CST:\n+      return TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n+\t&& !bcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t  TREE_STRING_LENGTH (t1));\n+\n+    case CONSTRUCTOR:\n+      abort ();\n+\n+    case SAVE_EXPR:\n+      return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+\n+    case CALL_EXPR:\n+      cmp = cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+      if (cmp <= 0)\n+\treturn cmp;\n+      return simple_cst_list_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+\n+    case TARGET_EXPR:\n+      /* Special case: if either target is an unallocated VAR_DECL,\n+\t it means that it's going to be unified with whatever the\n+\t TARGET_EXPR is really supposed to initialize, so treat it\n+\t as being equivalent to anything.  */\n+      if ((TREE_CODE (TREE_OPERAND (t1, 0)) == VAR_DECL\n+\t   && DECL_NAME (TREE_OPERAND (t1, 0)) == NULL_TREE\n+\t   && DECL_RTL (TREE_OPERAND (t1, 0)) == 0)\n+\t  || (TREE_CODE (TREE_OPERAND (t2, 0)) == VAR_DECL\n+\t      && DECL_NAME (TREE_OPERAND (t2, 0)) == NULL_TREE\n+\t      && DECL_RTL (TREE_OPERAND (t2, 0)) == 0))\n+\tcmp = 1;\n+      else\n+\tcmp = cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+      if (cmp <= 0)\n+\treturn cmp;\n+      return cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+\n+    case WITH_CLEANUP_EXPR:\n+      cmp = cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+      if (cmp <= 0)\n+\treturn cmp;\n+      return cp_tree_equal (TREE_OPERAND (t1, 2), TREE_OPERAND (t1, 2));\n+\n+    case COMPONENT_REF:\n+      if (TREE_OPERAND (t1, 1) == TREE_OPERAND (t2, 1))\n+\treturn cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+      return 0;\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case CONST_DECL:\n+    case FUNCTION_DECL:\n+      return 0;\n+\n+    case TEMPLATE_CONST_PARM:\n+      return TEMPLATE_CONST_IDX (t1) == TEMPLATE_CONST_IDX (t2);\n+\n+    case SIZEOF_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t1, 0)) != TREE_CODE (TREE_OPERAND (t2, 0)))\n+\treturn 0;\n+      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t1, 0))) == 't')\n+\treturn comptypes (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0), 1);\n+      break;\n+    }\n+\n+  switch (TREE_CODE_CLASS (code1))\n+    {\n+      int i;\n+    case '1':\n+    case '2':\n+    case '<':\n+    case 'e':\n+    case 'r':\n+    case 's':\n+      cmp = 1;\n+      for (i=0; i<tree_code_length[(int) code1]; ++i)\n+\t{\n+\t  cmp = cp_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i));\n+\t  if (cmp <= 0)\n+\t    return cmp;\n+\t}\n+      return cmp;\n+    }\n+\n+  return -1;\n+}"}, {"sha": "0b7554c549fee19a04914f26d0be0443d14c78e8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d743fe7745039f5933f9d90f80c088a7a77077/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=67d743fe7745039f5933f9d90f80c088a7a77077", "patch": "@@ -437,14 +437,20 @@ common_type (t1, t2)\n \n     case ARRAY_TYPE:\n       {\n+\tint constp \n+\t  = TYPE_READONLY (t1) || TYPE_READONLY (t2);\n+\tint volatilep\n+\t  = TYPE_VOLATILE (t1) || TYPE_VOLATILE (t2);\n \ttree elt = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t1, attributes);\n \tif (elt == TREE_TYPE (t2) && TYPE_DOMAIN (t2))\n \t  return build_type_attribute_variant (t2, attributes);\n \t/* Merge the element types, and have a size if either arg has one.  */\n-\tt1 = build_cplus_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\tt1 = build_cplus_array_type (TYPE_MAIN_VARIANT (elt), TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\tif (constp || volatilep)\n+\t  t1 = cp_build_type_variant (t1, constp, volatilep);\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n "}]}